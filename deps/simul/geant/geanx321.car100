+TITLE.
C GEANX.CAR 3.21/05 26/11/99 11.41.24 CVSTOCAR RESTAURATION 
+PATCH, EXAMPLES_GEXAM9.
+KEEP, URGEOM.
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant
* urgeom.inc
      COMMON/URGEOM/UTHICK,CSHIEL,ESHIEL,BTHICK,AIRGP1,CTHICK,AIRGP2,
     *              AIRGP3,EPCHAM,HMODL1,HSECT1,HMODL2,HSECT2,HMODL3,
     *              HSECT3,HLCALO,WGS1,WGS2
*
+KEEP, TSTCOM.
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant
* tstcom.inc
      COMMON / TSTCOM / HEAD1(4) , IRUN     , NEVT     ,
     +                  NSHOW(10), ESHOW(10),
     +                  ISHOW    , ITHETA   , IENERG   ,
     +                  PXYZ(3)  , XYZ(3)   , HEAD2(32),
     +                  ECHAM(60), KPART    , PPART    , SIGP     ,
     +                  SIGBX    , SIGBY    , SIGBZ     , EDEP   ,
     +                  NUMREJ   , BSPOT    , XY0(3)   , ANGL(2)
*
+KEEP, MAPHC.
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant
* maphc.inc
      PARAMETER (MAXENE=8,MAXEV=1000,MAXKP=MAXEV*MAXENE)
      COMMON/MAPHC/FMAP(58,30,10),ZMAP(45,30,10),RNON(10),NP1,NPZ,
     +         KP(MAXEV),KEVN,IBUF(20000)
      INTEGER*2 IBUF,KP
*
+KEEP, HSIZES.
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant
* hsizes.inc
      COMMON/HSIZES/X1CALO,X2CALO,YCALO,ZCALO,X1ECAL,X2ECAL,X1HCAL,
     +              X2HCAL,ZHCAL,X1HIRO,X2HIRO,ZHIRO,
     +              X1HURA,X2HURA,ZHURA,CHADEP
*
+KEEP, HBOOT.
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant
* hboot.inc
      COMMON / HBOOT / LHBOOT(2), NE(3), IBTYP(10),
     +          EHBOOT(10,3), EBTUP(3), PAMASS(3)
+DECK,  BTSTOR, T=FORT.
* Revision 1.2  1996/02/22 13:32:37  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant

      SUBROUTINE BTSTOR
************************************************************************
*
*   Collect the hits for
*     1) frozen file if ITHETA = 0
*     2) find the theta correlation of shower width and energy deposit
*
************************************************************************
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCBANK.
+CDE, GCLIST.
+CDE, GCSETS.
+CDE, GCNUM.
+CDE, TSTCOM.
+CDE, MAPHC.
      PARAMETER  (NDDIM=2, NHDIM=1, NHMAX=100, NVDIM=4)
      INTEGER*2  NTOT,KDIGI(NDDIM,NHMAX)
      INTEGER  LITRA(1), LLAYF(NHMAX), LLAYZ(NHMAX)
     +        ,LTOWF(NHMAX), LTOWZ(NHMAX), LTRAF(NHMAX), LTRAZ(NHMAX)
     +        ,NUMBF(NVDIM,NHMAX), NUMBZ(NVDIM,NHMAX), NUMVS(NVDIM)
     +        ,MINUST(0:1)
      REAL  HITF(NHDIM,NHMAX), HITZ(NHDIM,NHMAX)
      CHARACTER*4  HBF, HBZ
      DATA  FACT /1.0E+08/, ORIG /0./, NTOW /9/, NLAY /10/
      DATA L0/3/,MINUSL/5/,NTUBE0/5/,MINUST/5,7/
*
* *** CHECK THAT DETECTOR SET 'HTST' EXISTS
*
      NSET = IQ(JSET - 1)
      CALL GLOOK('HTST',IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0) RETURN
      JS   = LQ(JSET-ISET)
*
      CALL VZERO (NUMVS, NVDIM)
      HBF = 'HBFC'
      HBZ = 'HBZC'
*
* *** Extract hits for each of the 3 relevant rings in turn
*
      CALL GFHITS ('HTST', HBF, NVDIM,NHDIM,NHMAX, 0, NUMVS,
     +               LTRAF, NUMBF, HITF, NHITF)
      CALL GFHITS ('HTST', HBZ, NVDIM,NHDIM,NHMAX, 0, NUMVS,
     +               LTRAZ, NUMBZ, HITZ, NHITZ)
      NTOT=NHITF+NHITZ
*
      CALL HFILL(24,1.*NTOT,0.,1.)
      IF(NTOT.GT.0) CALL HFILL(50,XYZ(3),0.0,1.)
      IF (NHITF.GT.NHMAX.OR.NHITZ.GT.NHMAX) THEN
         NHITF = MIN0(NHITF,NHMAX)
         NHITZ = MIN0(NHITZ,NHMAX)
         WRITE (6, 10000)
      END IF
      DO 10 I=1,NHITF
         IL=(NUMBF(3,I)+1)/2
         IT=NUMBF(4,I)
         KDIGI(1,I)=IL*100+IT
         EHIT=AMIN1(0.0002,HITF(1,I))
         KDIGI(2,I)=EHIT*FACT
         FMAP(IT,IL,ITHETA+1)=FMAP(IT,IL,ITHETA+1)+EHIT
   10 CONTINUE
      DO 20 I=1,NHITZ
         IL=NUMBZ(3,I)/2
         IT=NUMBZ(4,I)
         KDIGI(1,I+NHITF)=10000+IL*100+IT
         EHIT=AMIN1(0.0002,HITZ(1,I))
         KDIGI(2,I+NHITF)=EHIT*FACT
         ZMAP(IT,IL,ITHETA+1)=ZMAP(IT,IL,ITHETA+1)+EHIT
   20 CONTINUE
*
      IF(NTOT.EQ.0) THEN
         RNON(ITHETA+1)=RNON(ITHETA+1)+1
      ELSEIF(ITHETA.EQ.0) THEN
         KEVN=KEVN+1
         KP(KEVN)=NP1+1
         DO 30  I=1,NTOT
            IF(KDIGI(2,I).EQ.0.) GOTO 30
            LZ=KDIGI(1,I)/10000
            KKDIGI=KDIGI(1,I)
            LAYER=MOD(KKDIGI,10000)/100-MINUSL
            IF(LAYER.LT.0) LAYER=0
            IF(LAYER.GT.9) LAYER=9
            NTUBE=MOD(KKDIGI,100)-MINUST(LZ)
            IF(NTUBE.LT.0) NTUBE=0
            IBUF(NP1+2*I-1)=LZ*1000+LAYER*100+NTUBE
   30    IBUF(NP1+2*I)=KDIGI(2,I)
         NPZ=NP1+NTOT*2
         NP1 = NPZ
      ENDIF
*
10000 FORMAT (/,' BTSTOR: Hit buffer overflow, truncated to NHMAX')
*                                                             END BTSTOR
      END
+DECK,  DATA9, T=DATA.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant
*
*
LIST
C  Example input data cards to make frozen file of electron
DEBU         1       10
SWIT         1       10
PAIR 1
COMP 1
PHOT 1
PFIS 1
DRAY 1
ANNI 1
BREM 1
MUNU 1
HADR 1
LOSS 2
MULS 2
RNDM    2345 12384
XYZ0 0.0 0.0 11.07
ESHO 0.010 0.020  0.040 0.080  0.160 0.320 0.640
NSHO   500   400    300    200   200   100   100
CUTS 0.0001 0.0001 0.0001 0.001 0.001
PRIN 'VERT' 'KINE'  'HITS'
END
+DECK,  FTUBES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant

      SUBROUTINE FTUBES(ITYP,UCELL,VCELL,IFLAG,NEWMED)
*******************************************************************
*
*    Search for the tube (NEWMED = 5) next to the vertex
*     INPUT:
*        ITYP=0 SEARCHING IN X, Y AND Z.
*        ITYP=1 SEARCHING IN X ONLY.
*        ITYP=2 SEARCHING IN Y ONLY.
*        UCELL = COORDINATES OF THE ORIGIN
*     OUTPUT:
*        VCELL = COORDINATES OF A POINT INSIDE THE TUBE NEXT.
*        IFLAG = 1 IF O.K., = 0 IF FAILED.
*
*     CALLED BY HBOOTG
*******************************************************************
+CDE, GCFLAG.
+CDE, GCTMED.
      DIMENSION VCELL(3),UCELL(3),SHIFT(3),NMEDA(100,100),BSHIFT(2)
      DATA SHIFT/0.1,0.1,0.74/,BSHIFT/0.21,-0.21/
*
      IFLAG=0
      NFAIL=0
      CALL UCOPY(UCELL,VCELL,3)
+SELF, IF=DEBUG.
      DO 10 I=1,100
         VCELL(3)=UCELL(3)+0.015*I
         DO 10 J=1,100
            VCELL(1)=UCELL(1)+0.01*J
            CALL GMEDIA(VCELL,NEWMED)
            IF(N0.NE.NEWMED) PRINT 10000, I,J,VCELL,NEWMED
10000         FORMAT(' I,J,VCELL,NEWMED',2I4,3F9.3,I3)
            NMEDA(J,I)=NEWMED
            N0=NEWMED
   10 CONTINUE
      PRINT 10100,UCELL,NMEDA
10100  FORMAT(' UCELL',3F9.5,'  NEWMED',100(/,100I1))
+SELF.
*
      IF(ITYP.EQ.0.AND.NUMED.EQ.6) GOTO 30
*
      IF(ITYP.EQ.0) THEN
         VCELL(3)=VCELL(3)+SHIFT(3)
      ELSE
         VCELL(ITYP)=VCELL(ITYP)+SHIFT(ITYP)
      ENDIF
   20 CALL GMEDIA(VCELL,NEWMED)
*
      IF(NEWMED.EQ.5) GOTO 50
      IF(NEWMED.EQ.0.OR.NEWMED.EQ.7) GOTO 60
      NFAIL=NFAIL+1
      IF(NFAIL.GT.3) GOTO 60
      IF(ITYP.EQ.0) THEN
         VCELL(1)=VCELL(1)+0.1
         VCELL(2)=VCELL(2)+0.1
         VCELL(3)=VCELL(3)+0.02
      ELSE
         VCELL(ITYP)=VCELL(ITYP)+SHIFT(ITYP)
      ENDIF
      GOTO 20
*
*     THE VERTEX IS IN THE BRASS
*          SEARCHING IN TWO DIRECTIONS: UP AND DOWN
   30 CONTINUE
      DO 40  J=1,2
         CALL UCOPY(UCELL,VCELL,3)
         VCELL(3)=UCELL(3)+BSHIFT(J)
         CALL GMEDIA(VCELL,NEWMED)
         IF(NEWMED.EQ.5) GOTO 50
         IF(NEWMED.EQ.0.OR.NEWMED.EQ.7) GOTO 60
         IF(NEWMED.EQ.3.OR.NEWMED.EQ.1) GOTO 40
         IF(NEWMED.EQ.6) THEN
            VCELL(1)=VCELL(1)+0.1
            VCELL(2)=VCELL(2)+0.1
            CALL GMEDIA(VCELL,NEWMED)
            IF(NEWMED.EQ.5) GOTO 50
            IF(NEWMED.EQ.0.OR.NEWMED.EQ.7) GOTO 60
*           IF(NEWMED.EQ.3.OR.NEWMED.EQ.1) GOTO 510
         ENDIF
   40 CONTINUE
      RETURN
*
   50 IFLAG=1
*
   60 CONTINUE
      END
+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/22 13:32:38  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant

      SUBROUTINE GUKINE
*
************************************************************************
*                                                                      *
*             GEANT3 user routine to generate Kinematics               *
*               for primary tracks                                     *
*                                                                      *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, URGEOM.
+CDE, TSTCOM.
+CDE, HBOOT.
*
      DIMENSION VERTEX(3), PLAB(3), BUF(10), MHE1(5)
      DATA NBUF /1/, BUF /10*0.0/
      DATA MHE1 /4HJHE1, 1, 1, 20, 3/, NZERO /0/
*
      IF (LHBOOT(1) .EQ. 1) THEN

*             Define "JHE1" bank to be saved
         JHE1 = LQ(JHEAD-1)
         IF (JHE1.NE.0) CALL MZDROP (IXSTOR, JHE1, '    ' )
         CALL MZLIFT (IXSTOR, JHE1, JHEAD, -1, MHE1, NZERO)
   10    CALL RANNOR(RANX, RANY)
         XYZ(1) = XY0(1) + RANX * SIGBX
         XYZ(2) = XY0(2) + RANY * SIGBY
         IF(ABS(XYZ(1)).GT.BSPOT.OR.ABS(XYZ(2)).GT.BSPOT) GO TO 10
         XYZ(3) = XY0(3)
         PXYZ(1) = PPART*SIN(ANGL(2))*COS(ANGL(1))
         PXYZ(2) = PPART*SIN(ANGL(2))*SIN(ANGL(1))
         PXYZ(3) = PPART*COS(ANGL(2))
*
      ELSE
*
         RANX=RNDM(DUMMY)
         RANY=RNDM(DUMMY)
         XYZ(1) = XY0(1) + RANX * SIGBX
         XYZ(2) = XY0(2) + RANY * SIGBY
*
   20    RANZ=RNDM(DUMMY)
         DZ = RANZ * SIGBZ
   30    XYZ(3) = XY0(3) + DZ
         CALL HFILL(25,DZ,0.,1.)
*
* *** Energy of the incident particle
*
         ISHOW = ISHOW+1
         IF(ISHOW.GT.NSHOW(IENERG)) THEN
            IF(ITHETA.EQ.9) THEN
               CALL SUMANG
               IENERG = IENERG+1
               ISHOW = 1
               ITHETA = 0
            ELSE
               ITHETA = ITHETA +1
               ISHOW = 1
            ENDIF
         ENDIF
*
         IF(ISHOW.EQ.1) THEN
            JPA = LQ(JPART-KPART)
            AMASS = Q(JPA+7)
            EKINE = ESHOW(IENERG)
            PPART=SQRT((EKINE+2.*AMASS)*EKINE)
            WRITE(6,10000) IENERG,ITHETA,EKINE,PPART,IEVENT
10000  FORMAT('   IENERG',I4,'   ITHETA',I4,'   EKINE,PPART',
     +        2F9.5,'   IEVENTS',I8)
         ENDIF
*
         THET = 3.1415926535/18.*ITHETA
         PXYZ(1) = PPART*SIN(THET)
         PXYZ(2) = 0.0
         PXYZ(3) = PPART*COS(THET)
*
         LHBEG=0
      END IF

      CALL GSVERT(XYZ,0,0,0,0,NVERT)
      CALL GSKINE(PXYZ,KPART,NVERT,BUF,NBUF,NT)
*
*              Kinematic debug (controled by ISWIT(1))
      IF(IDEBUG.EQ.1.AND.ISWIT(1).EQ.1) THEN
         CALL GPRINT('VERT',0)
         CALL GPRINT('KINE',0)
      ENDIF
*
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/22 13:32:38  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant

      SUBROUTINE GUOUT
************************************************************************
*                                                                      *
*             GEANT3 user routine called at the end of each event.     *
*                                                                      *
************************************************************************
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCBANK.
+CDE, GCLIST.
+CDE, GCSETS.
+CDE, GCNUM.
+CDE, HBOOT.
      CHARACTER*4 LISTC(3),LIST(10)
      DATA LISTC/'KINE','VERT','HITS'/
*
      PARAMETER  (NDDIM=2, NHDIM=1, NHMAX=100, NVDIM=4)
      INTEGER*2  NTOT,KDIGI(NDDIM,NHMAX)
      INTEGER  LITRA(1), LLAYF(NHMAX), LLAYZ(NHMAX)
     +        ,LTOWF(NHMAX), LTOWZ(NHMAX), LTRAF(NHMAX), LTRAZ(NHMAX)
     +        ,NUMBF(NVDIM,NHMAX), NUMBZ(NVDIM,NHMAX), NUMVS(NVDIM)
      REAL  HITF(NHDIM,NHMAX), HITZ(NHDIM,NHMAX)
      CHARACTER*4  HBF, HBZ
*
      IF(IDEBUG.NE.0) CALL GPHITS('*   ','*   ')

      IF(NSAVE.GT.0) THEN
         NLIST=3
         DO 10 I=1,NLIST
   10    LIST(I)=LISTC(I)
         CALL GFOUT(2,LIST,NLIST,IDEVT,' ',IER)
      ENDIF
*
      IF (LHBOOT(1) .EQ. 1) THEN
         NSET = IQ(JSET - 1)
         CALL GLOOK('HTST',IQ(JSET+1),NSET,ISET)
         IF(ISET.LE.0) RETURN
         JS = LQ(JSET-ISET)
*
         CALL VZERO (NUMVS, NVDIM)
         HBF = 'HBFC'
         HBZ = 'HBZC'
*
* *** Extract hits for each of the 3 relevant rings in turn
*
         CALL GFHITS ('HTST', HBF, NVDIM,NHDIM,NHMAX, 0, NUMVS, LTRAF,
     +   NUMBF, HITF, NHITF)
         CALL GFHITS ('HTST', HBZ, NVDIM,NHDIM,NHMAX, 0, NUMVS, LTRAZ,
     +   NUMBZ, HITZ, NHITZ)
         NTOT=NHITF+NHITZ
*
         ETOT = 0.0
         CALL HFILL(201,1.*NTOT,0.,1.)
         DO 20 I=1,NHITF
            IL=(NUMBF(3,I)+1)/2
            IT=NUMBF(4,I)
            CALL HFILL(202,HITF(1,I),0.,1.)
            RL = IL * 2. -1
            CALL HFILL(204,RL, 0., HITF(1,I))
            MML = MIN0(IL,26)
            RIT = IT-17-0.5*(MML-1)
            CALL HFILL(205,RIT, 0., HITF(1,I))
            ETOT = ETOT + HITF(1,I)
   20    CONTINUE
         DO 30 I=1,NHITZ
            IL=NUMBZ(3,I)/2
            IT=NUMBZ(4,I)
            CALL HFILL(202,HITZ(1,I),0.,1.)
            RL = IL * 2.
            CALL HFILL(204,RL, 0., HITZ(1,I))
            CALL HFILL(205,(IT-23)*1., 0., HITZ(1,I))
            ETOT = ETOT + HITZ(1,I)
   30    CONTINUE
*
         CALL HFILL(203,ETOT,0.0,1.)
*
      ELSE
*
         CALL BTSTOR
*
      END IF
*
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.2  1996/02/22 13:32:39  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant

      SUBROUTINE GUSTEP
*
************************************************************************
*                                                                      *
*        GEANT3 user routine called at the end of each tracking step   *
*                                                                      *
************************************************************************
*
+CDE, GCTMED.
+CDE, GCKING.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSETS.
+CDE, GCBANK.
+CDE, GCONST.
+CDE, GCMATE.
+CDE, GCUNIT.
+CDE, GCLIST.
+CDE, TSTCOM.
+CDE, HBOOT.
      INTEGER HNAME(4),ECAL,HCAL,ECRY,HSCI
      EQUIVALENCE (ECAL,HNAME(1)),(HCAL,HNAME(2))
      EQUIVALENCE (ECRY,HNAME(3)),(HSCI,HNAME(4))
      CHARACTER*4 MYNAME(4)
      DIMENSION KTRT(5),HITS(1)
      DATA KTRT/5*0/,IFIRST/0/
      DATA TOMAX/2.E-7/
      DATA MYNAME / 'ECAL','HCAL','ECRY','HSCI'/
*
      IF (IFIRST.EQ.0) THEN
         CALL UCTOH(MYNAME,HNAME,4,16)
         IFIRST=1
      END IF
*
*             Something generated ?
      IF(NGKINE.GT.0) THEN
         DO 10 I=1,NGKINE
            ITYPA = INT(GKIN(5,I))
*
*     BOOTSTRAP THE SECONDARY PARTICLES.
            IF(LHBOOT(1).EQ.1.AND.VECT(3).GT.-6.4) THEN
               IF(ITYPA.GE.2.AND.ITYPA.LE.3.AND. GKIN(4,I).LE.EBTUP(1))
     +         THEN
                  CALL HBOOTG(1,I,IBOOT)
                  IF(IBOOT.EQ.1) THEN
                     CALL HFILL(31,GKIN(4,I),0.,1.)
                     GOTO 10
                  ENDIF
               END IF
               IF(LHBOOT(2).EQ.1) THEN
                  IF(ITYPA.GE.8.AND.ITYPA.LE.9.AND. (GKIN(4,I))
     +            .LE.EBTUP(2)) THEN
                     CALL HBOOTG(2,I,IBOOT)
                     IF(IBOOT.EQ.1) THEN
                        CALL HFILL(41,GKIN(4,I),0.,1.)
                        GOTO 10
                     ENDIF
                  END IF
               ENDIF
            ENDIF
            IF(ITYPA.NE.4) CALL GSKING(I)
   10    CONTINUE
      END IF
*
*             Is it in the gas ?
      IF(NUMED.EQ.5)THEN
         IF(DESTEP.GT.0.) THEN
            HITS(1)=DESTEP
            CALL GSCHIT(ISET,IDET,ITRA,NUMBV,HITS,1,IHIT)
         ENDIF
      ENDIF
*
*             Debug/plot event
      IF(IDEBUG.NE.0) THEN
         IF (ISWIT(2).EQ.2) CALL GPCXYZ
      ENDIF
*
*    BOOTSTRAP THE TRACKING PARTICLE.
      IF(LHBOOT(1).EQ.1.AND.ISTOP.EQ.0.AND.VECT(3).GT.-6.4) THEN
         IF(NUMED.EQ.3.OR.NUMED.EQ.6) THEN
            IF(IPART.EQ.2.OR.IPART.EQ.3.AND. GETOT.LE.EBTUP(1)) THEN
               CALL HBOOTG(1,0,IBOOT)
               IF(IBOOT.EQ.1) THEN
                  CALL HFILL(31,GETOT,0.,1.)
                  ISTOP=2
               ENDIF
            END IF
            IF(LHBOOT(2).EQ.1) THEN
               IF(IPART.GE.8.AND.IPART.LE.9.AND. GETOT.LE.EBTUP(2))
     +         THEN
                  CALL HBOOTG(2,0,IBOOT)
                  IF(IBOOT.EQ.1) THEN
                     CALL HFILL(41,GETOT,0.,1.)
                     ISTOP=2
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF(IDEBUG.NE.0) THEN
         IF (ISWIT(2).EQ.2) CALL GPCXYZ
      ENDIF
*
      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant

      SUBROUTINE GUTREV
*
************************************************************************
*                                                                      *
*             GEANT3 user routine to control tracking of one event     *
*                                                                      *
*             Called by GRUN                                           *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
*
      CALL GTREVE
*
*             Debug and plot tracks.
      IF(IDEBUG.EQ.1) THEN
         IF(ISWIT(2).EQ.1) CALL GPRINT('JXYZ', 0)
      ENDIF
*
      END
+DECK,  HBOOTS, T=FORT.
* Revision 1.2  1996/02/22 13:32:40  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant

      SUBROUTINE HBOOTS
*
***********************************************************************
*   BOOTSTRAP ELECTRONS AND POSITIONS IN HACAL.
***********************************************************************
*
+CDE, HBOOT.
+CDE, GCBANK.
+CDE, GCSETS.
+CDE, GCKING.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCONST.
+CDE, GCTMED.
      PARAMETER (LEBTIN=81,LPBTIN=82)
      PARAMETER (MAXENE=10,MAXEV=300)
      PARAMETER (MMP=2,MAXDAT=50000,MAXKP=MAXEV*MAXENE*1.5)
      PARAMETER (MAXL=8,NLOWE=2)
      INTEGER*2 NDATA(MAXDAT),KP(MAXKP)
      DIMENSION NPOI(MAXENE,MMP),NDPOI(MAXENE,MMP),RNON(10,MAXENE,MMP),
     +    AGLENE(MAXL,0:9,0:1,MAXENE,MMP),
     +    AGLWID(MAXL,0:9,0:1,MAXENE,MMP),
     +    ESIG(NLOWE,2),ARNON(NLOWE,2),ETUBE(NLOWE,2),
     +    VCELL(3),VBOOT(6),UCELL(3),ZCELL(3),KEVN(MAXENE,MMP)
      DATA ARNON/0.990,0.985,0.97,0.95/,DIFMAX/0.333333334/,
     +     ETUBE/1.3E-6,1.5E-6,0.039E-3,0.034E-3/,ESIG/4*1.0/,
     +     THRES/0.5/,THICKL/1.34/,WIDTH/1.06/
      DATA L0/3/,NTUBE0/15/
*
*    INITIALIZATION OF BOOTSTRAP IN HACAL.
      PAMASS(1) = EMASS
      PAMASS(2) = 0.139567
*
*          READ THE PREGENERATED SHOWERS AND THEIR ANGULAR COORELATION
      OPEN(UNIT=LEBTIN,FORM='UNFORMATTED',STATUS='OLD',
+SELF, IF=VAX,UNIX,CRAY.
     +FILE='efr.dat')
+SELF, IF=IBM.
     +FILE='/EFR DAT *')
+SELF.
      READ(LEBTIN) NE(1),(EHBOOT(I,1),I=1,NE(1))
      WRITE(6,10000) NE(1),(EHBOOT(I,1),I=1,NE(1))
10000 FORMAT(//,' BOOTSTRAP ELECTRONS IN HACAL FOR',I2,
     +          ' KINETIC ENERGIES:',9F7.4)
      EBTUP(1)=1.3333334*EHBOOT(NE(1),1)+PAMASS(1)
      PRINT *,' UP LIMIT OF TOTAL ENERGY IS',EBTUP(1)
*
      JJ1=1
      LL1=1
      DO 10  N=1,NE(1)
         READ(LEBTIN) KEVN(N,1),(RNON(K,N,1),K=1,10),LENGTH,
     +        (((AGLENE(I1,I2,I3,N,1),I1=1,MAXL),I2=0,9),I3=0,1),
     +        (((AGLWID(I1,I2,I3,N,1),I1=1,MAXL),I2=0,9),I3=0,1)
         JJ2=JJ1+KEVN(N,1)-1
         NPOI(N,1)=JJ1
         NDPOI(N,1)=LL1
         READ(LEBTIN) (KP(I),I=JJ1,JJ2)
         LL2=LL1+LENGTH-1
         IF(LL2.GT.MAXDAT) THEN
            WRITE(6,10100)N,LL2,MAXDAT
10100       FORMAT(' Too much data during read ',3(1X,I10))
            NE(1)=N-1
            RETURN
         ENDIF
         READ(LEBTIN) (NDATA(I),I=LL1,LL2)
         WRITE(6,10200) EHBOOT(N,1),KEVN(N,1),LENGTH,JJ1,JJ2,LL1,LL2
         WRITE(6,10300) (RNON(K,N,1),K=1,10), (((AGLENE(I1,I2,I3,N,1),
     +   I1=1,MAXL),I2=0,9),I3=0,1), (((AGLWID(I1,I2,I3,N,1),I1=1,MAXL)
     +   ,I2=0,9),I3=0,1)
10200    FORMAT(/,' EBOOT =',F8.4,'   # of events',I5,5I8)
10300    FORMAT(/,' RNON',10F7.4,/,' AGLENE',8(/,20F6.2),
     +      /,' AGLWID',8(/,20F6.2))
         LL1=LL2+1
         JJ1=JJ2+1
   10 CONTINUE
*
      IF (LHBOOT(2) .EQ. 1) THEN
*
*   READ THE FROZEN FILE OF CHARGED PIONS
         OPEN(LPBTIN,FORM='UNFORMATTED',STATUS='OLD',
+SELF, IF=VAX,UNIX,CRAY.
     +   FILE='efrp.dat')
+SELF, IF=IBM.
     +   FILE='/EFRP DAT *')
+SELF.
         READ(LPBTIN) NE(2),(EHBOOT(I,2),I=1,NE(2))
         WRITE(6,10400) NE(2),(EHBOOT(I,2),I=1,NE(2))
10400 FORMAT(//,' BOOTSTRAP PION IN HACAL FOR',I2,' ENERGIES:',9F7.4)
         EBTUP(2)=1.3333334*EHBOOT(NE(2),2)+PAMASS(2)
         PRINT *,' UP LIMIT OF TOTAL ENERGY IS',EBTUP(2)
         DO 20  N=1,NE(2)
            READ(LPBTIN) KEVN(N,2),(RNON(K,N,2),K=1,10),LENGTH, (((AGLE
     +      NE(I1,I2,I3,N,2),I1=1,MAXL),I2=0,9),I3=0,1), (((AGLWID(I1,
     +      I2,I3,N,2),I1=1,MAXL),I2=0,9),I3=0,1)
            JJ2=JJ1+KEVN(N,2)-1
            NPOI(N,2)=JJ1
            NDPOI(N,2)=LL1
            READ(LPBTIN) (KP(I),I=JJ1,JJ2)
            LL2=LL1+LENGTH-1
            IF(LL2.GT.MAXDAT) THEN
               PRINT *,' TOO NUCH DATA DURING READ  .',N,LL2,MAXDAT
               NE(2)=N-1
               RETURN
            ENDIF
            READ(LPBTIN) (NDATA(I),I=LL1,LL2)
            WRITE(6,10200) EHBOOT(N,2),KEVN(N,2),LENGTH,JJ1,JJ2,LL1,LL2
            WRITE(6,10300) (RNON(K,N,2),K=1,10), (((AGLENE(I1,I2,I3,N,
     +      2) ,I1=1,MAXL),I2=0,9),I3=0,1), (((AGLWID(I1,I2,I3,N,2),I1=
     +      1, MAXL),I2=0,9),I3=0,1)
            LL1=LL2+1
            JJ1=JJ2+1
   20    CONTINUE
      END IF
*
      RETURN
*
      ENTRY HBOOTG(MP,IPA,IBOOT)
*
*   BOOTSTRAP ELECTRONS AND POSITRONS IN HACAL.
*     INPUT MP =1 FOR ELECTRON ; 2 FOR CHARGED PION.
*           IPA=0  IF PRELIMINARY PARTICLE.
*           IPA>0 IF SECONDARY PARTICLE. ( = THE ORDER IN /GCKING/ )
*     OUTPUT IBOOT=0 IF IT WAS NOT BOOTSTRAPED
*            IBOOT=1 IF IT WAS BOOTSTRAPED
*
      IBOOT=0
      IFAIL=0
      LPRINT=0
      IF(IDEBUG.NE.0.AND.ISWIT(3).EQ.1) LPRINT=1
      JK=LQ(JKINE-ITRA)
*
*  BOOTSTRAP ONLY WHEN THE ENERGY OF PARTICLE < THRES*ENERGY OF
*  THE PRELIMINARY PARTICLE
*
      ETHRES=THRES*(Q(JK+4)-PAMASS(mp))
      IF(IPA.EQ.0) THEN
         EBOOT = GETOT-PAMASS(mp)
         IF(EBOOT.GT.ETHRES) GOTO 120
         DO 30  JDO=1,6
            VBOOT(JDO)=VECT(JDO)
   30    CONTINUE
      ELSEIF(IPA.GT.0) THEN
         EBOOT = GKIN(4,IPA)-PAMASS(mp)
         IF(EBOOT.GT.ETHRES) GOTO 120
         PMOM2 =GKIN(1,IPA)**2+GKIN(2,IPA)**2+GKIN(3,IPA)**2
         PMOINV = 1. / SQRT(PMOM2)
         DO 40  JDO=1,3
            VBOOT(JDO) = VECT(JDO)
            VBOOT(JDO+3) = PMOINV * GKIN(JDO,IPA)
   40    CONTINUE
      ELSE
         RETURN
      END IF
      IF(LPRINT.EQ.1) PRINT 10500,IPA,EBOOT,VBOOT
10500 FORMAT(' IPA,EBOOT,VBOOT',I3,7F9.3)
*
*  LET'S GO BOOTSTRAP
      IF(EBOOT.LE.EHBOOT(1,MP)*(1.-DIFMAX)) THEN
*
*  Energy < min. energy stored, deposit a part of the energy in
*        one tube next to the vertex only.
         IF(EBOOT.LE.0.0007) THEN
            GOTO 100
         ELSEIF(EBOOT.LE.0.002) THEN
            IEP=1
         ELSE
            IEP=2
         ENDIF
*
         RNN=RNDM(DUMMY)
         IF(RNN.LE.ARNON(IEP,MP)) GOTO 100
         CALL RANNOR(RNOR1,RNOR2)
         DEPENE = ETUBE(IEP,MP)*(1.0+ESIG(IEP,MP)*RNOR1)
         IF(DEPENE.LT.0.0) DEPENE = - DEPENE
*
         CALL FTUBES(0,VBOOT,VCELL,IFLAG,NEWMED)
         IF(IFLAG.EQ.0) GOTO 120
         ISVOL = 1
         CALL UCOPY(VCELL,VECT,3)
         CALL GFINDS
         CALL GSCHIT( ISET, IDET, ITRA, NUMBV, DEPENE, 1, IHIT )
         IF(IHIT.EQ.0) PRINT *,' GSCHIT ERROR'
         IF(LPRINT.eq.1) WRITE(6,10900) IPA, (NUMBV(NM),NM=1,5),DEPENE,
     +   EBOOT
         GO TO 90
      ENDIF
*
*  Energy > min. energy stored, take a shower and deposit cells contents
   50 CONTINUE
      DO 60  I=1,NE(MP)
         IRANGE=I
         IF(ABS(EBOOT-EHBOOT(I,MP))/EHBOOT(I,MP).LT.DIFMAX) GO TO 70
   60 CONTINUE
*
*   * Out of stored energy ranges  ==>  return
      GO TO 120
*
   70 CONTINUE
      SCALEF=EBOOT/EHBOOT(IRANGE,MP)
*
*      Energy values stored in frozen file are in unit of 10 eV
      SCALEF=SCALEF * .00000001
*
      CALL FTUBES(0,VBOOT,VCELL,IFLAG,NEWMED)
      IF(LPRINT.EQ.1) WRITE(6,10600) (VBOOT(I),I=1,3),VCELL,NEWMED
10600 FORMAT(' VBOOT,VCELL,NEWMED',6F9.3,I5)
      IF(IFLAG.EQ.0) GOTO 120
      ISVOL = 1
      CALL UCOPY(VCELL,VECT,3)
      CALL GFINDS
      IPL=NUMBV(3)
      IF(IPL.EQ.1) GOTO 110
      LPHI=MOD(IPL,2)
      CALL UCOPY(VCELL,ZCELL,3)
*
*   ANGLE = THETA ANGLE W.R.T. BEAM AXIS.
      ANGLE=ACOS(VBOOT(6))
      IANG=(ANGLE*RADDEG+5.)/10.0
      DIREC=1.0
      IF(IANG.GT.9) THEN
         IANG=18-IANG
         DIREC=-1.0
      ENDIF
      IF(RNDM(DUMMY).LE.RNON(IANG,IRANGE,MP)) GOTO 100
      ANGPHI=ATAN2(VBOOT(5),VBOOT(4))
*
      KSH=RNDM(DUMMY)*KEVN(IRANGE,MP)
      KPP=NPOI(IRANGE,MP)+KSH
*
*  THE SELECTED SHOWER IS IN NDATA(KSH1) - NDATA(KSH2)
*
      KSH1=KP(KPP)+NDPOI(IRANGE,MP)-1
      KSH2=KP(KPP+1)+NDPOI(IRANGE,MP)-3
*
      DO 80  LK=KSH1,KSH2,2
         ID=NDATA(LK)
         IF(ID.EQ.0.OR.NDATA(LK+1).EQ.0) GOTO 80
         LZ=ID/1000
         IL=MOD(ID,1000)/100-L0
         IT=MOD(ID,100)
*         CALL UCOPY(ZCELL,UCELL,3)
         IF(LPHI.EQ.1.AND.LZ.EQ.0) THEN
            LSHIFT=IL*cos(ANGLE)
            LSHIFT=LSHIFT*2
            II=1
         ELSEIF(LPHI.EQ.1.AND.LZ.EQ.1) THEN
            LSHIFT=IL*cos(ANGLE)
            LSHIFT=LSHIFT*2+ 1
            II=2
         ELSEIF(LPHI.EQ.0.AND.LZ.EQ.1) THEN
            LSHIFT=IL*cos(ANGLE)
            LSHIFT=LSHIFT*2 + 1
            II=1
         ELSE
            LSHIFT=IL*cos(ANGLE)
            LSHIFT=LSHIFT*2
            II=2
         ENDIF
*
         ILL=MIN0(IL,6)
         IF(ILL.LT.-1) ILL=-1
         AGLW = AGLWID(ILL+2,IANG,LPHI,IRANGE,MP)
         AGLE = AGLENE(ILL+2,IANG,LPHI,IRANGE,MP)
         IF (AGLE.EQ.0.0) AGLE = 1.
         SHIFT0=THICKL*LSHIFT*SIN(ANGLE)
         RNTUBE=IT-NTUBE0
         IF(LZ.EQ.0) RNTUBE=RNTUBE-ILL*0.5
         SHIFT=SHIFT0+WIDTH*RNTUBE*AGLW
         UCELL(1)=ZCELL(1)+SHIFT*COS(ANGPHI)
         UCELL(2)=ZCELL(2)+SHIFT*SIN(ANGPHI)
         UCELL(3)=ZCELL(3)+THICKL*LSHIFT
         CALL FTUBES(II,UCELL,VCELL,IFLAG,NEWMED)
         IF(LPRINT.EQ.1) WRITE(6,10700) ID,IL,IT,UCELL,VCELL
10700    FORMAT(' ID,IL,IT,UCELL,VCELL',3I5,6F9.3)
         IF(IFLAG.EQ.0) THEN
            IFAIL=IFAIL+1
            IF(LPRINT.EQ.0.AND.IFAIL.LE.100) WRITE(6,10800) ID,
     +      NDATA(LK+1),NEWMED,ZCELL,UCELL,VCELL
10800    FORMAT(' FAIL: ID,NEWMED,Z-U-VCELL',I5,I9,I2,9F7.2)
            GOTO 80
         ENDIF
         DEPENE=SCALEF*NDATA(LK+1)*AGLE
         IF(DEPENE.LT.0.0) DEPENE = DEPENE
         CALL UCOPY(VCELL,VECT,3)
         CALL GFINDS
         IF(LPRINT.EQ.1)WRITE(6,10900)IPA,(NUMBV(M),M=1,5),DEPENE,EBOOT
10900    FORMAT(' BOOTSTRAP AT',6I4,2X,E11.5,F9.5)
         CALL GSCHIT( ISET, IDET, ITRA, NUMBV, DEPENE, 1, IHIT )
         IF(IHIT.EQ.0) PRINT *,' GSCHIT ERROR'
   80 CONTINUE
*
   90 ISVOL = 0
      CALL UCOPY(VBOOT,VECT,3)
      IF(LPRINT.EQ.1.AND.IFAIL.NE.0) PRINT *,' IFAIL',IFAIL
  100 IBOOT=1
      CALL HFILL(22+MP*10,VBOOT(6),0.,1.)
      RETURN
*
  110 ISVOL = 0
      CALL UCOPY(VBOOT,VECT,3)
      IF(LPRINT.EQ.1) PRINT *,' NO BOTTSTRAP IN THE FIRST PLANE'
  120 RETURN
      END
+DECK,  HCATST, T=FORT.
* Revision 1.2  1996/02/22 13:32:41  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:24  cernlib
* Geant

      SUBROUTINE HCATST
****************************************************************
*
*     Defines a module of L3 Hadron calorimeter
*
****************************************************************
+CDE, URGEOM.
      DIMENSION TWALL(7),PAR(4),NLFI(30)
      CHARACTER*4  NAMEH(1),NAMED(2)
      INTEGER  NBITH(1),NBITD(2)
      REAL  FACTH(1), ORIGH(1)
      DATA  NAMEH /'EDEP'/,NBITH /32/,FACTH /1.E+07/,ORIGH /0./
      DATA  NAMED /'IDNT','EDEP'/,NBITD /20,16/
*
****** THE RELEVANT PARAMETERS ARE :
*     FRONT RADIUS OF MODUL:
      DATA RIHB/88.6/
*     MODUL SIZE:
      DATA HMOD/86.9/
*     MODUL WIDTH:
      DATA WMOD/52.3/
*---- TWALL(1)-THICKNESS OF MODUL FRONT WALL
*          (2)-//---------- BACK WALL
*          (3)-//-----//- SIDE WALL IN F-PROJECTION (Phi)
*          (4)-//-----//-------//-  IN Z-PROJECTION (Zeta)
*          (5)-GAP BETWEEN SIDE WALL AND CHAMBER IN Z-PROJECTION
*          (6)-//-----//-----//-----//-----//----//-F-PROJECTION
*          (7)-//-----//-----//----- AND U-PLATE IN Z-PROJECTION
      DATA TWALL/3.9,1.5,0.4,1.5,0.8,0.5,0.4/
*---- AUXILIARY VOLUME SIZE(FIRST F/Z-CHAMBERS+STEEL PLATE):
      DATA TBPL/3.3/
*---- STEEL PLATE THICKNESS:
      DATA TFEA/1.5/
*---- ENDPIECE THICKNESS:
      DATA TENDP/0.7/
*---- CHAMBER PITCH:
      DATA PITCH/1.06/
*---- CHAMBER THICKNESS:
      DATA TCHAM/0.56/
*---- WIDTH/THICKNESS OF GAS CELL:
      DATA WCELL/1.0/,TCELL/0.5/
*---- URANIUM SHIELD THICKNESS(COPPER):
      DATA TSHL/0.07/
*---- ABSORBER THICKNESS(URANIUM):
      DATA TABS/0.5/
*---- SLOT THICKNESS FOR CHAMBERS(AIR):
      DATA TGAP/0.84/
*---- NUMBER OF TUBES IN ONE LAYER OF Z-PROJECTION:
      DATA NLZE/45/
*---- NUMBER OF TUBES IN EACH LAYER OF F-PROJECTION:
      DATA NLFI/33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
     +49,50,51,52,53,54,55,56,57,58,58,58,58,58/
*
      DATA ITAIR /0/, ITCU /0/, ITFE /0/, ITGAC /0/, ITU /0/
*
*---------------------------------------------------------------
      TPI16=TAN(3.141593/16.)
      TGCH=TABS+TGAP
*      HLCALO=0.5*HMOD
*------- DEFINE VOLUME 1 :HV1C(AIR) ---------
      DZUSE=0.5*WMOD-TWALL(4)
      RCM=RIHB+0.5*HMOD
      R1=RIHB+TWALL(1)
      R2=R1+TBPL+48*TGCH
      DX1=TPI16*R1-TWALL(3)
      DX2=TPI16*R2-TWALL(3)
      PAR(1)=DX1
      PAR(2)=DX2
      PAR(3)=DZUSE
      PAR(4)=0.5*(R2-R1)
      XC=0.
      YC=0.
      ZC=-(RCM-0.5*(R1+R2))
      CALL GSVOLU('HV1C','TRD1',1,PAR,4,IVOL)
      CALL GSPOS('HV1C',1,'HBMC',XC,YC,ZC,0,'ONLY')
*
*------- DEFINE VOLUME 2 :HV2C(AIR) ---------
      R3=RIHB+HMOD-TWALL(2)
      PAR(1)=DX2
      PAR(2)=DZUSE
      PAR(3)=(R3-R2)*0.5
      ZC=0.5*(R2+R3)-RCM
      CALL GSVOLU('HV2C','BOX ',1,PAR,3,IVOL)
      CALL GSPOS('HV2C',1,'HBMC',XC,YC,ZC,0,'ONLY')
*
******** DEFINE FI-CHAMB,ZETA-CHAMB,U-PLATE:HVFC,HVZC,HBUC *********
*
      PAR(1)=0.
      PAR(2)=0.
      PAR(3)=0.
      CALL GSVOLU('HVFC','BOX ',6,PAR,0,IVOL)
      CALL GSVOLU('HVZC','BOX ',6,PAR,0,IVOL)
      CALL GSVOLU('HBUC','BOX ',3,PAR,0,IVOL)
      TAIR=0.5*(TGAP-TCHAM-2.*TSHL)
*
*------- POSITION (2-25)F-CHAM,(2-25)T-CHAM AND U IN HV1C --------
      DO 10  K=1,24
*------------ F-CHAMBERS --------------
         PAR(1)=NLFI(K+1)*PITCH*0.5+0.000001
         PAR(2)=DZUSE-TWALL(5)-TENDP
         PAR(3)=0.5*(TCHAM+2.*TSHL)
         STEP=2.*(TABS+TGAP)
         XC=0.
         YC=0.
         RIF=R1+TBPL+TABS+0.5*TGAP+(K-1)*STEP
         ZCF=RIF-0.5*(R1+R2)+TAIR
         CALL GSPOSP('HVFC',2*K+1,'HV1C',XC,YC,ZCF,0,'ONLY',PAR,3)
*
*------------ T-CHAMBERS --------------
         RIT=R1+TBPL+2.*TGCH-0.5*TGAP+(K-1)*STEP
         PAR(1)=TPI16*RIT-TWALL(3)-TWALL(6)-TENDP
         PAR(2)=NLZE*PITCH*0.5+0.000001
         PAR(3)=0.5*(TCHAM+2.*TSHL)
         ZCT=RIT-0.5*(R1+R2)+TAIR
         CALL GSPOSP('HVZC',2*K+2,'HV1C',XC,YC,ZCT,0,'ONLY',PAR,3)
*
*---------------- U-PLATES ---------------
         RIU1=R1+TBPL+0.5*TABS+(K-1)*STEP
         RIU2=RIU1+TGAP+TABS
         PAR(1)=TPI16*RIU1-TWALL(3)-TWALL(6)
         PAR(2)=DZUSE-TWALL(7)
         PAR(3)=0.5*TABS
         XC=0.
         YC=0.
         ZC1=RIU1-0.5*(R1+R2)
         CALL GSPOSP('HBUC',2*K-1,'HV1C',XC,YC,ZC1,0,'ONLY',PAR,3)
         PAR(1)=TPI16*RIU2-TWALL(3)-TWALL(6)
         ZC2=RIU2-0.5*(R1+R2)
         CALL GSPOSP('HBUC',2*K,'HV1C',XC,YC,ZC2,0,'ONLY',PAR,3)
   10 CONTINUE
*
*------ POSITION (26-30)F-CHAM,(26-30)T-CHAM AND U IN HV2C -------
      DO 20  K=1,5
*------------- F-CHAMBERS -------------
         PAR(1)=NLFI(25+K)*PITCH*0.5+0.000001
         PAR(2)=DZUSE-TWALL(5)-TENDP
         PAR(3)=0.5*(TCHAM+2.*TSHL)
         XC=0.
         YC=0.
         ZCF=-0.5*(R3-R2)+TABS+0.5*TGAP+(K-1)*STEP+TAIR
         CALL GSPOSP('HVFC',2*K+49,'HV2C',XC,YC,ZCF,0,'ONLY',PAR,3)
*------------- T-CHAMBERS -------------
         PAR(1)=DX2-TWALL(6)-TENDP
         PAR(2)=NLZE*PITCH*0.5+0.000001
         PAR(3)=0.5*(TCHAM+2.*TSHL)
         ZCT=ZCF+TGAP+TABS
         CALL GSPOSP('HVZC',2*K+50,'HV2C',XC,YC,ZCT,0,'ONLY',PAR,3)
*------------- U-PLATES ---------------
         PAR(1)=DX2-TWALL(6)
         PAR(2)=DZUSE-TWALL(7)
         PAR(3)=0.5*TABS
         XC=0.
         YX=0.
         ZCU1=-0.5*(R3-R2)+0.5*TABS+(K-1)*STEP
         ZCU2=ZCU1+TGAP+TABS
         CALL GSPOSP('HBUC',2*K-1,'HV2C',XC,YC,ZCU1,0,'ONLY',PAR,3)
         CALL GSPOSP('HBUC',2*K,'HV2C',XC,YC,ZCU2,0,'ONLY',PAR,3)
   20 CONTINUE
*
*------ POSITION FIRST F/T-CHAMBERS IN HV1C ---------
*
      PAR(1)=NLFI(1)*PITCH*0.5+0.000001
      PAR(2)=DZUSE-TWALL(5)-TENDP
      PAR(3)=0.5*(TCHAM+2.*TSHL)
      XC=0.
      YC=0.
      RT1=R1+TBPL-0.5*TGAP
      ZCT=RT1-0.5*(R1+R2)
      ZCF=ZCT-TGAP-TFEA
      CALL GSPOSP('HVFC',1,'HV1C',XC,YC,ZCF,0,'ONLY',PAR,3)
      PAR(1)=TPI16*RT1-TWALL(3)-TWALL(6)-TENDP
      PAR(2)=NLZE*PITCH*0.5+0.000001
      CALL GSPOSP('HVZC',2,'HV1C',XC,YC,ZCT,0,'ONLY',PAR,3)
*
*------ POSITION FE-ABSORBER IN HV1C --------
*
      PAR(1)=TPI16*(R1+TBPL-TGAP-TFEA) -TWALL(3)
      PAR(2)=DZUSE-TWALL(5)
      PAR(3)=0.5*TFEA
      CALL GSVOLU('HBIC','BOX ',7,PAR,3,IVOL)
      XC=0.
      YC=0.
      ZC=ZCF+0.5*TGAP+0.5*TFEA
      CALL GSPOS('HBIC',1,'HV1C',XC,YC,ZC,0,'ONLY')
*
*------ DEFINE SUBDIVISION IN FI/ZETA DIRECTIONS:HWFC,HWZC -----
      CALL GSDVT('HWFC','HVFC',PITCH,1, 0, 58)
      CALL GSDVT('HWZC','HVZC',PITCH,2, 0, 45)
*------ DEFINE ELEM. GAS CELL:HBFC,HBZC ------------------------
      PAR(1)=0.5*WCELL
      PAR(2)=-1.
      PAR(3)=0.5*TCELL
      CALL GSVOLU('HBFC','BOX ',5,PAR,3,IVOL)
      PAR(1)=-1.
      PAR(2)=0.5*WCELL
      CALL GSVOLU('HBZC','BOX ',5,PAR,3,IVOL)
*------ POSITION IT IN ALL FI/ZETA CHAMBERS --------------------
      XC=0.
      YC=0.
      ZC=0.
      CALL GSPOS('HBFC',1,'HWFC',XC,YC,ZC,0,'ONLY')
      CALL GSPOS('HBZC',1,'HWZC',XC,YC,ZC,0,'ONLY')
+SELF, IF=VSOP.
*--------- FORCE THE ORDERING SEARCH IN HV1C,HV2C --------------
      CALL GSORD('HBM*',3)
      CALL GSORD('HV1C',3)
      CALL GSORD('HV2C',3)
+SELF.
      CALL GSDETV ('HTST', 'HBFC', 1, 500, 0, ISET, IDET)
      CALL GSDETV ('HTST', 'HBZC', 1, 500, 0, ISET, IDET)
      CALL GSDETH ('HTST', 'HBFC', 1, 'EDEP', 32, 0., 1.E+07)
      CALL GSDETH ('HTST', 'HBZC', 1, 'EDEP', 32, 0., 1.E+07)
*                                                             END HCATST
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant

+SELF, IF=-INTER.
      PROGRAM MAIN
*     program for fast simualtion by bootstrap lower energy
*       electrons/positrons and charged pions.
*
*                            Author: H. S. Chen
*
      COMMON/PAWC/H(90000)
      COMMON/GCBANK/Q(280000)
*
      CALL GZEBRA(280000)
*
      CALL HLIMIT(-90000)
*
*             Geant initialization
      CALL UGINIT
*
*             Test printings.
      CALL GPRINT('MATE',0)
      CALL GPRINT('TMED',0)
      CALL GPRINT('VOLU',0)
      CALL GPRINT('SETS',0)
*
*             Start events processing
      CALL GRUN
*
*             End of run
      CALL UGLAST
*
      END
+SELF.
+DECK,  SUMANG, T=FORT.
* Revision 1.2  1996/02/22 13:32:42  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:25  cernlib
* Geant

      SUBROUTINE SUMANG
*****************************************************************************
*
*    Summary the informations of energy deposits in  10 angle bins
*
*                             called by GUKINE
*****************************************************************************
+CDE, MAPHC.
+CDE, TSTCOM.
      PARAMETER (MAXL=8)
      DIMENSION COMPF(30,10),COMPZ(30,10),FF(58),FZ(45)
      DIMENSION RP(MAXL,10),RZ(MAXL,10),RBINF(MAXL,10),RBINZ(MAXL,10)
*
      CALL VZERO(COMPF,300)
      CALL VZERO(COMPZ,300)
*
      DO 10 N=1, 10
   10 RNON(N)=RNON(N)/FLOAT(NSHOW(IENERG))
      WRITE(6,10000) RNON
10000 format (' rnon',10f10.5)
*
      DO 100  IIII=1,10
*
*             total energy deposit per layer
         DO 40   JJ = 1 , 30
            DO 20   II = 1 , 58
               COMPF(JJ,IIII)=COMPF(JJ,IIII)+FMAP(II,JJ,IIII)
   20       CONTINUE
            DO 30   IJ = 1 , 45
               COMPZ(JJ,IIII)=COMPZ(JJ,IIII)+ZMAP(IJ,JJ,IIII)
   30       CONTINUE
   40    CONTINUE
*
*  calculate the average width for each layer: contain 95% of the energy in laye
*
         DO 90  L=7,6+MAXL
            MBIN=0
            IF(COMPF(L,IIII).LE.0.) GOTO 60
            CALL UCOPY(FMAP(1,L,IIII),FF(1),58)
            CALL FLPSOR(FF,58)
            CUT = COMPF(L,IIII)*0.95
            SUM = 0.0
            DO 50  KL=1,58
               MBIN=MBIN+1
               SUM=SUM+FF(59-KL)
               IF(SUM.GT.CUT) GOTO 60
   50       CONTINUE
   60       RBINF(L-6,IIII)=MBIN
*
            MBIN=0
            IF(COMPZ(L,IIII).LE.0) GOTO 80
            CALL UCOPY(ZMAP(1,L,IIII),FZ(1),45)
            CALL FLPSOR(FZ,45)
            CUT = COMPZ(L,IIII)*0.95
            SUM=0.0
            DO 70  KL=1,45
               MBIN=MBIN+1
               SUM=SUM+FZ(46-KL)
               IF(SUM.GT.CUT) GOTO 80
   70       CONTINUE
   80       RBINZ(L-6,IIII)=MBIN
   90    CONTINUE
*
  100 CONTINUE
*
      DO 110  L=1,MAXL
         RRP=AMAX1(COMPF(L+6,1),.00000001)/(1.-RNON(1))
         RRZ=AMAX1(COMPZ(L+6,1),.00000001)/(1.-RNON(1))
         RBF=AMAX1(1.0,RBINF(L,1))
         RBZ=AMAX1(1.0,RBINZ(L,1))
         DO 110  J= 1, 10
            RBINF(L,J)=RBINF(L,J)/RBF
            RBINZ(L,J)=RBINZ(L,J)/RBZ
            IF(RNON(J).LT.1.) THEN
               RP(L,J)=COMPF(L+6,J)/RRP/(1.-RNON(J))
               RZ(L,J)=COMPZ(L+6,J)/RRZ/(1.-RNON(J))
            ELSE
               RP(L,J)=1.
               RZ(L,J)=1.
            ENDIF
            IF(RP(L,J).GT.3.0) THEN
               RP(L,J)=3.0
            ENDIF
            IF(RZ(L,J).GT.3.0) THEN
               RZ(L,J)=3.0
            ENDIF
            IF(RBINF(L,J).LE.0.0) THEN
               RBINF(L,J)=1.0
            ELSEIF(RBINF(L,J).GT.3.0) THEN
               RBINF(L,J)=3.0
            ENDIF
            IF(RBINZ(L,J).LE.0.0) THEN
               RBINZ(L,J)=1.0
            ELSEIF(RBINZ(L,J).GT.3.0) THEN
               RBINZ(L,J)=3.0
            ENDIF
  110 CONTINUE
*
*    write the angle corelation and the zero degree file
*
      WRITE(21) KEVN,RNON,NPZ,RP,RZ,RBINF,RBINZ
      WRITE(21) (KP(I),I=1,KEVN)
      WRITE(21) (IBUF(I),I=1,NP1)
*
      PRINT *,'summary for one energy'
      WRITE(6,10100) ((COMPF(L+6,J),J=1,10),L=1,MAXL)
      WRITE(6,10100) ((COMPZ(L+6,J),J=1,10),L=1,MAXL)
10100 FORMAT('         SUM PER LAYER',10(/,10F10.7))
      WRITE(6,10200) ((RP(L,J),J=1,10),L=1,MAXL)
      WRITE(6,10200) ((RZ(L,J),J=1,10),L=1,MAXL)
      WRITE(6,10200) ((RBINF(L,J),J=1,10),L=1,MAXL)
      WRITE(6,10200) ((RBINZ(L,J),J=1,10),L=1,MAXL)
10200 FORMAT('         RATIO',10(/,10F10.7))
*
      CALL VZERO(FMAP,17400)
      CALL VZERO(ZMAP,13500)
      CALL VZERO(RNON,10)
      KEVN = 0
*                                  end of SUMANG
      END
+DECK,  UFILES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:25  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
*
*            To open FFREAD and HBOOK files
*
      CHARACTER*(*) FILNAM, FSTAT
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='gexam9.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GEXAM9 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='OLD')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.2  1996/02/22 13:32:43  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:25  cernlib
* Geant

      SUBROUTINE UGEOM
*
************************************************************************
*                                                                      *
*             Routine to define the geometry of the set-up.            *
*                                                                      *
************************************************************************
*
+CDE, URGEOM.
+CDE, HSIZES.
+CDE, TSTCOM.
*
      DIMENSION AF(3),ZF(3),WMATF(3)
      DIMENSION PAR(10),ABRASS(2),ZBRASS(2),WBRASS(2)
      DIMENSION AISOBU(3),ZISOBU(3),WGAS(3),ACO2(3),ZCO2(3)
*     FRONT RADIUS OF MODUL:
      DATA RIHB/88.6/,RIEC/25.0/
      DATA ECALGH/0./
*     MODUL SIZE:
      DATA WMOD/52.3/,HMOD/86.9/,EMOD/60./
*
*            Define parameters (= half sizes of detectors)
*            ( convention: X1... half x at Z min.
*                          X2... half x at Z max.)
*
      DATA DISTCA/20. /,TOLERA/ 5. /
      DATA MATE,TMED,VOLU/4HMATE,4HTMED,4HVOLU/
      DATA AISOBU/12.01,1.01,39.95/
      DATA ZISOBU/6.,1.,18./
      DATA ACO2/12.01,16.01,39.95/
      DATA ZCO2/6.,8.,18./
      DATA ABRASS/63.54,65.37/
      DATA ZBRASS/29.,30./
      DATA WBRASS/.7,.3/
*
*             Iron+Nickel+Crome  compound parameters
      DATA AF/55.847,58.71,51.998/
      DATA ZF/26.,28.,24./
      DATA WMATF/0.703964,0.099,0.197/
*
      X1CALO = 25.0
      X2CALO = 32.86
      YCALO  = 23.85
      X1HCAL = 16.68
      ZHCAL  = 41.85
      X2HIRO = 17.99
      ZHIRO  =  3.57
      CHADEP =  0.82
*
      X1ECAL = 10.5
      ZCALO  = ZHCAL + (DISTCA + ECALGH + TOLERA)*.5
      X2HCAL = X2CALO
      X1HIRO = X1HCAL
      X1HURA = X2HIRO
      X2HURA = X2CALO
      ZHURA  = ZHCAL - ZHIRO
*
*             Defines materials
      CALL GSMATE( 1,'AIR$     ',  15.0,7.0,0.0012,30050.0,67500.0,0,0)
      CALL GSMATE( 2,'COPPER$  ', 63.54,29.,8.960 ,   1.43,   14.8,0,0)
      CALL GSMATE( 3,'URANIUM$ ',238.03,92.,18.950,   0.32,   12.0,0,0)
      CALL GSMIXT( 6,'BRASS$    ',ABRASS,ZBRASS,8.560   , 2,WBRASS)
      CALL GSMIXT( 7,'IRON(COMPOUND)$',AF,ZF,7.8,3,WMATF)
*
*             Argon/CO2 mixture (90% Ar and 10% CO2)
*             First define CO2 compound and relative weights
*
      DENS2  =0.0019573
      DCO2   =0.001977
      WGAS(1)=1.
      WGAS(2)=2.
      CALL GSMIXT(15,'CO2$',ACO2,ZCO2,0.90*DCO2,-2,WGAS)
      WGAS(1)=0.10*WGAS(1)
      WGAS(2)=0.10*WGAS(2)
      WGAS(3)=0.90
      CALL GSMIXT( 5,'ARG/CO2$',ACO2,ZCO2,DENS2, 3,WGAS)
*
*             Defines tracking media parameters.
      DMAXMS =  0.50
      DEEMAX =  0.20
      EPSIL  =  0.01
      STMIN  =  0.10
*
      CALL GSTMED( 1, 'AIR$     ', 1, 0, 0, 0., 0., DMAXMS,
     +            DEEMAX, EPSIL, STMIN, 0, 0)
      CALL GSTMED( 2, 'COPPER$  ', 2, 0, 0, 0., 0., DMAXMS,
     +            DEEMAX, EPSIL, STMIN, 0, 0)
      CALL GSTMED( 3, 'URANIUM$ ', 3, 0, 0, 0., 0., DMAXMS,
     +            DEEMAX, EPSIL, STMIN, 0, 0)
      CALL GSTMED( 5,'GAS$      ', 5, 1, 0, 0., 0., DMAXMS,
     +            DEEMAX, 0.001, 0.1, 0, 0)
      CALL GSTMED( 6,'BRASS$    ', 6, 0, 0, 0., 0., DMAXMS,
     +            DEEMAX, EPSIL, STMIN, 0, 0)
      CALL GSTMED( 7,'IRON$     ', 7, 0, 0, 0., 0., DMAXMS,
     +            DEEMAX, EPSIL, STMIN, 0, 0)
      FIELDM = 5.
      IFIELD = 0
      TMAXFD = 0.01
      DMAXMS = 0.90
      DEEMAX = 0.10
      EPSIL = 0.001
      STMIN = 0.10
      EPSILM = 0.001
      STMINM = 0.01
*
*           TEST SET UP
      TPI16=TAN(3.141593/16.)
*-------- DEFINE A TUBS FOR BGO + HCAL TEST
      PAR(1)=TPI16*RIEC*1.5
      PAR(2)=TPI16*(RIHB+HMOD)*1.5
      PAR(3)=0.5*WMOD*1.5
      PAR(4)=0.5*(HMOD+EMOD)
      CALL GSVOLU('BHTS','TRD1',1,PAR,4,IVOL)
*
      PAR(1)=TPI16*RIHB
*-------- DEFINE A MODUL(STEEL):HBMC
      PAR(2)=TPI16*(RIHB+HMOD)
      PAR(3)=0.5*WMOD
      PAR(4)=0.5*HMOD
      CALL GSVOLU('HBMC','TRD1',7,PAR,4,IVOL)
      CALL GSROTM (100, 90., 0., 90., 90., 0., 0.)
*
      XC=0.0
      YC=0.0
      ZC=0.5*EMOD
      CALL GSPOS('HBMC',1,'BHTS',XC,YC,ZC,100,'ONLY')
*
      CALL HCATST
*
*             Close geometry banks. Mandatory system routine.
      CALL GGCLOS
*                                                   end of UGEOM
      END
+DECK,  UGINIT, T=FORT.
* Revision 1.2  1996/02/22 13:32:44  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:25  cernlib
* Geant

      SUBROUTINE UGINIT
*
************************************************************************
*                                                                      *
*          To initialise GEANT3 program and read data cards            *
*                                                                      *
************************************************************************
*
+CDE, GCLIST.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCONSP.
+CDE, URGEOM.
+CDE, TSTCOM.
+CDE, GCKINE.
+CDE, MAPHC.
+CDE, HBOOT.
*
*             Initialize global variables
      DIMENSION MRUN1(5)
      DATA MRUN1 /4HRUN1, 1, 1, 20, 3/, NZERO/0/
      DATA INIT/4HINIT/
*
      CALL UFILES
*
*             Initialize Geant.
      CALL GINIT
*
*             Use data cards definition
*     gexam9 cards *
      BSPOT  = 1.0
      XY0(1) = 0.0
      XY0(2) = 0.0
      XY0(3) = -66.85
      ANGL(1) = 0.0
      ANGL(2) = 0.0
*     gexam10 cards *
      PPART  = 2.0
      SIGBX  = 1.
      SIGBY  = 1.
      SIGBZ  = 0.841
      KPART  = 3
      XY0(1) = 0.0
      XY0(2) = 0.0
      XY0(3) = 11.07
      CALL VZERO(ESHOW,20)
      CALL VZERO(NSHOW,20)
*

      CALL FFKEY('MOME', PPART , 1, 'REAL')
      CALL FFKEY('PART', KPART , 1, 'INTE')
      CALL FFKEY('ANGL', ANGL  , 2, 'REAL')
      CALL FFKEY('XYZ0', XY0 , 3, 'REAL')
      CALL FFKEY('SIGB', SIGBX , 3, 'REAL')
      CALL FFKEY('HBOT',LHBOOT,2,'INTEGER')
      CALL FFKEY('ESHO',ESHOW(1),20,'REAL'   )
      CALL FFKEY('NSHO',NSHOW(1),20,'INTEGER')

      CALL GFFGO

      ANGL(1) = ANGL(1)*DEGRAD
      ANGL(2) = ANGL(2)*DEGRAD
*
      CALL GZINIT
*
*             Geometry and materials description.
      CALL UGEOM
*
*             Particle table definition and energy loss initialization.
      CALL GPART
      CALL GPHYSI
*
      IF(LHBOOT(1).EQ.1) THEN
*             Open I/O buffers
         IF(NGET .GT.0)CALL GOPEN(1,'I',0,IER)
         IF(NSAVE.GT.0)CALL GOPEN(2,'O',0,IER)
*
*             Prints version number
         WRITE(LOUT,10000)
         IGAST = 1
         IDSTW = 0
*
         CALL HBOOTS
*
      ELSE
*             Define "RUN1" bank to be saved
         JRUN1 = LQ(JRUNG-1)
         IF (JRUN1.NE.0) CALL MZDROP (IXSTOR, JRUN1, '    ')
         CALL MZLIFT (IXSTOR, JRUN1, JRUNG, -1, MRUN1, NZERO)
         CALL UCOPY (PPART, Q(JRUN1+1), 7)
         Q(JRUN1+8) = KPART
*
*             Open I/O buffers
         IF(NSAVE.GT.0)CALL GOPEN(2,'O',0,IER)
*
*             Prints version number
         WRITE(LOUT,10100)
*
         NENERG = 0
         NEVENT = 0
         NP1 = 0
         KEVN = 0
         DO 10 I=1,20
            IF(NSHOW(I).LE.0) GO TO 20
            NENERG = NENERG + 1
   10    NEVENT = NEVENT+NSHOW(I)*10
*
   20    IF(NENERG.LE.0) RETURN
         IENERG = 1
         ISHOW = 0
         ITHETA = 0
         IF (KPART.EQ.8 .OR. KPART.EQ.9) THEN
+SELF, IF=UNIX,VAX,CRAY.
            OPEN (UNIT=21, FILE='efrp.dat', STATUS='UNKNOWN', FORM=
+SELF, IF=IBM.
            OPEN (UNIT=21,FILE='/EFRP DAT *',STATUS='UNKNOWN',FORM=
+SELF.
     +      'UNFORMATTED')
         ELSE
+SELF, IF=UNIX,VAX,CRAY.
            OPEN (UNIT=21, FILE='efr.dat', STATUS='UNKNOWN', FORM=
+SELF, IF=IBM.
            OPEN (UNIT=21,FILE='/EFR DAT *',STATUS='UNKNOWN',FORM=
+SELF.
     +      'UNFORMATTED')
         END IF
*
         WRITE(21) NENERG,(ESHOW(I),I=1,NENERG)
*
         CALL VZERO(FMAP,17400)
         CALL VZERO(ZMAP,13500)
         CALL VZERO(RNON,10)
*
      END IF

      CALL UHINIT
*
10000 FORMAT(/,'**** GEXAMPLE 9: Bootstrap in L3 HCAL (one module)',
     +          '(June 1987)',/)
10100 FORMAT(/,'**** GEXAMPLE 10:  L3  HCAL (one module)
     +          makes frozen files for bootstrap ',/)
*
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.2  1996/02/22 13:32:45  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:25  cernlib
* Geant

      SUBROUTINE UGLAST
*
************************************************************************
*                                                                      *
*       Termination routine to print histograms and statistics         *
*                                                                      *
************************************************************************
*
+CDE, GCLIST.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, HBOOT.
*
      IF (LHBOOT(1) .NE. 1) THEN
         CALL SUMANG
         ENDFILE 21
      END IF
*
      CALL GLAST
*
*             Close I/O buffers
      IF((NGET+NSAVE).GT.0) THEN
         CALL GCLOSE(0,IER)
      ENDIF
*
      CALL HISTDO
*
      END
+DECK,  UHINIT, T=FORT.
* Revision 1.2  1996/02/22 13:32:46  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:25  cernlib
* Geant

      SUBROUTINE UHINIT
*
************************************************************************
*                                                                      *
*             To book the user's histograms                            *
*                                                                      *
************************************************************************
+CDE, HBOOT.
+CDE, TSTCOM.
*
      IF (IENERG .EQ. 0) THEN
         CALL HBOOK1(201,'# OF HITS PER EVENT$',100,0.0,100.,0.)
         CALL HBOOK1(202,'ENERGY PER HIT$',100,0.0,0.0002,0.)
         CALL HBOOK1(203,'TOTAL ENERGY DEPOSIT IN GAS$',100,0.0,0.002,
     +   0.)
         CALL HBOOK1(204,'LONG. ENERGY DISTR.$',60,0.,60.,0.)
         CALL HBOOK1(205,'TRANS. ENERGY DISTR.$',58,-29.,29.,0.)
      END IF
*
      IF (LHBOOT(1) .EQ. 1) THEN
         CALL HBOOK1(31,'ENERGY DISTR. OF BS E+E-$',100,0.0,1.,0.)
         CALL HBOOK1(32,'COS THETA DISTR. OF BS E+E-$',100,-1.,1.,0.)
         IF (LHBOOT(2) .EQ. 1) THEN
            CALL HBOOK1(41,'ENERGY DISTR. OF BS PION$',100,0.1,0.6,0.)
            CALL HBOOK1(42,'COS THETA DISTR. OF BS PION$',100,-1.,1.,
     +      0.)
         END IF

      ELSE

         CALL HBOOK1(24,'# OF HITS PER EVENT$',100,0.,100.,0.)
         CALL HBOOK1(25,'Z VERTEX DISTRIBUTION$',100,0.,1.,0.)
         CALL HBOOK1(50,'VERTEX DISTRI. OF EVENT WITH SIGNAL$',100,
     +   11.07, 12.07,0.)

      END IF
*
      END
+PATCH, EXAMPLES_GEXAM7.
+KEEP, PVOLUM.
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant
* pvolum.inc
      COMMON/PVOLUM/ IMAT,NLTOT,NRTOT,DLX0,DRX0,X0,Z1,R1
C
C  IMAT   = GEANT material number.                              (data card MATER
C  NLTOT  = total number of longitudinal bins.                  (data card BINS)
C  NRTOT  = total number of radial bins.                        (data card BINS)
C  DLX0   = longitudinal bin length , in radiation length unit. (data card BINS)
C  DRX0   = radial bin length       , in radiation length unit. (data card BINS)
C
+KEEP, BOOTDT.
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant
*   (BOOT DATA)
* bootdt.inc
      COMMON/BOOTDT/MEDIUM,ECUT,RANGE,LTYPE(2,10)
C----------------------------------------------------------------------
C     BOOTSTRAP COMMON : MEDIUM = VOLUME IN WHICH BOOTSTRAP IS DONE
C                        ECUT   = BELOW ECUT TIMES PRIMARY  ENERGY
C                                 BOOTSTRAP REPLACES TRACKING
C                        RANGE  = DEVIATION FROM GENERATED EN-
C                                 ERGY VALUES
C                        LTYPE1 = TYPE OF PARTICLE
C                        LTYPE2 = ASSOCIATED LUN CONTAINING PRESHOWERS
C----------------------------------------------------------------------
+KEEP, BOOTWK.
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant
*   (BOOT WORK)
* bootwk.inc
      COMMON/BOOTWK/JBOOT,EINCID
C----------------------------------------------------------------------
C     BOOTSTRAP COMMON : JBOOT  = BOOTSTRAP BANK ADRESS
C                        EINCID = TOTAL ENERGY OF PRIMARY  PARTICLE
C----------------------------------------------------------------------
+KEEP, CELOSS.
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant
* celoss.inc
      PARAMETER (NBIN= 50)
      COMMON/CELOSS/ ELEAK(3),
     +               SEL1(NBIN), SEL1C(NBIN), SER1(NBIN), SER1C(NBIN),
     +               SEL2(NBIN), SEL2C(NBIN), SER2(NBIN), SER2C(NBIN),
     +             SNPAT1(NBIN,4),SNPAT2(NBIN,4),
     +               DEDL(NBIN),DEDR(NBIN),FNPAT(NBIN,4)
+DECK,  DATA1, T=DATA.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant
*
*
LIST
BINS  20  IN Z   20  IN R   1.  DZ  0.25  DR
MATER   21
TRIG   100
KINE  1  1.
DEBUG     1   1   10
SWIT      1   0
PAIR  1
COMP  1
PHOT  1
PFIS  0
MULS  1
BREM  1
LOSS  1
DRAY  1
ANNI  1
MUNU  0
HADR  2
CUTS  0.0001    0.001    6=0.00010 (BCUTE)    8=0.00100 (DCUTE)
*BOOT 'RING' 0.5 0.33 1 50 2 51 3 51
PRINT   'MATE' 'VOLU'  'TMED'
TIME 2= 4.
END











+DECK,  FFUSER, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant

      SUBROUTINE FFUSER(IKEY)
C---------------------------------------------------------------------
C  CALLED WHEN A *NAME CARD IS READ
C---------------------------------------------------------------------
      CHARACTER*4 KEYW

      CALL UHTOC(IKEY,4,KEYW,4)
      IF (KEYW.EQ.'BOOT') CALL GBOOTI

      END
+DECK,  GBOOTI, T=FORT.
* Revision 1.2  1996/02/22 13:24:00  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant

      SUBROUTINE GBOOTI
C---------------------------------------------------------------------
C  CALLED WHEN *BOOT CARD IS READ
C    TO CREATE DIRECTORIES OF THE SHOWER FILES
C---------------------------------------------------------------------
+CDE, BOOTDT.
+CDE, BOOTWK.
+CDE, GCBANK.
      DIMENSION BUF(80),IBUF(80),LOPEN(10)
      EQUIVALENCE (BUF(1),IBUF(1))
CCCCC LOGICAL READY
*
      DATA IOBMED,IOBADM,IOBSHO / 0,0,0 /
      DATA NOPEN / 0 /
*
C---------------------------------------------------------------------
C  INITIALIZE ZEBRA STRUCTURE IF IT WAS NOT YET
C  CREATE BOOTSTRAP MOTHER BANK IF IT DOES NOT EXIST
C---------------------------------------------------------------------
      CALL GZINIT
      IF(JBOOT.EQ.0) THEN
         CALL MZLINK(IXSTOR,'/BOOTWK/',JBOOT,JBOOT,JBOOT)
         CALL MZBOOK(IXCONS,LBANK,JBOOT,1,'BOOT',10,10,1,2,0)
*
         CALL MZFORM('BMED','1H 2F -I', IOBMED)
         CALL MZFORM('BADM','6I 3F 1I 1F 1I 3F',IOBADM)
         CALL MZFORM('BSHO','1F -I', IOBSHO)
      ENDIF
C--------------------------------------------------------------
C     NEW VOLUME ASSIGNED TO BOOTSTRAP PROCEDURE
C--------------------------------------------------------------
      NMED=IQ(JBOOT+1)
      NMED=NMED+1
      IQ(JBOOT+1)=NMED
C--------------------------------------------------------------
C     CREATE BOOTSTRAP VOLUME BANK CONTAINING :
C       -  THE NAME OF THE VOLUME IN WHICH BOOTSTRAP IS USED
C       -  THE ENERGY CUT-OFF
C       -  THE MAXIMUM DEVIATION FROM STORED SHOWER ENERGY
C       -  THE PARTICLE TYPES TO BE REPLACED BY PREFABRICATED
C          SHOWERS
C       -  THE LOGICAL UNITS FOR READING THE CORRESPONDING
C          DIRECT ACCES FILES
C--------------------------------------------------------------
      CALL MZBOOK(IXCONS,JBMED,JBOOT,-NMED,'BMED',10,10,24,IOBMED,0)
      IQ(JBMED+1)=MEDIUM
      Q (JBMED+2)=ECUT
      Q (JBMED+3)=RANGE
      NTYPE=0
      DO 900 I=1,10
900   IF(LTYPE(1,I)*LTYPE(2,I).GT.0) NTYPE=NTYPE+1
      IQ(JBMED+4)=NTYPE
      DO 1000 ITYPE=1,NTYPE
      JBMED = LQ(JBOOT - NMED)
      IND1=JBMED+4+ITYPE
      IND2=JBMED+4+ITYPE+NTYPE
C--------------------------------
C     PARTICLE TYPE
C--------------------------------
      IQ(IND1)=LTYPE(1,ITYPE)
C--------------------------------
C     LOGICAL UNIT
C--------------------------------
      IQ(IND2)=LTYPE(2,ITYPE)
      LUNACT=LTYPE(2,ITYPE)
CCCCC INQUIRE (LUNACT,OPENED=READY)
      LUN = IUCOMP(LUNACT,LOPEN,NOPEN)
      IF(LUN.LE.0) THEN
         NOPEN = NOPEN + 1
         LOPEN(NOPEN) = LUNACT
      ENDIF
      READ(LUNACT,REC=1) IBUF
      LENDIR=IBUF(1)
      IQI   =IBUF(2)
      IRI   =IBUF(3)
      NXBIN =IBUF(4)
      NYBIN =IBUF(5)
      NZBIN =IBUF(6)
      XBIN  = BUF(7)
      YBIN  = BUF(8)
      ZBIN  = BUF(9)
      NENRG =IBUF(10)
      CUTCEL= BUF(11)
      IXY   = NXBIN*NYBIN
      I     = (IRI-2)/IXY+1
      J     = (IRI-2-IXY*(I-1))/NXBIN+1
      K     = (IRI-1-IXY*(I-1)-NXBIN*(J-1))
      XRI   = (K-0.5)*XBIN
      YRI   = (J-0.5)*YBIN
      ZRI   = (I-0.5)*ZBIN
C----------------------------------------------------------------
C     DIRECTORY BANK ( HIGHER LEVEL )
C        LENDIR     = NUMBER OF DIRECTORY RECORDS
C        IQI        = CHARGE
C        IRI        = INCIDENT REGION NUMBER IN EGS
C        NXBIN      = NUMBER OF X BINS IN EGS RECTANGULAR SYSTEM
C        XBIN       = X BINSIZE
C        NENRG      = NUMBER OF DIFFERENT ENERGY GENERATED
C        CUTCEL     = THE MINIMUM ENERGY OF A CELL THAT WAS STORED
C        XRI        = X COORDINATE OF THE SHOWER ORIGIN
C----------------------------------------------------------------
      JBMED  = LQ(JBOOT - NMED)
      CALL MZBOOK (IXCONS,JBADM,JBMED,-ITYPE,'BADM',20,20,15,IOBADM,0)
      IQ(JBADM+1) = LENDIR
      IQ(JBADM+2) = IQI
      IQ(JBADM+3) = IRI
      IQ(JBADM+4) = NXBIN
      IQ(JBADM+5) = NYBIN
      IQ(JBADM+6) = NZBIN
       Q(JBADM+7) = XBIN
       Q(JBADM+8) = YBIN
       Q(JBADM+9) = ZBIN
      IQ(JBADM+10)= NENRG
       Q(JBADM+11)= CUTCEL
      IQ(JBADM+12)= IXY
       Q(JBADM+13)= XRI
       Q(JBADM+14)= YRI
       Q(JBADM+15)= ZRI
      DO 100 IENRG=1,NENRG
C---------------------------------------------------------------
C     CREATES SHOWER BANKS ( LOWER LEVEL OF DIRECTORY STRUCTURE )
C        ENERGY   = ENERGY OF THE PREFABRICATED SHOWERS
C        NSHWER   = NUMBER OF THE GENERATED SHOWERS ( MAX. 78 )
C     STORES THE RECORD NUMBERS AT WHICH SHOWERS BEGIN AND
C     ALSO THE RECORD NUMBER FOLLOWING THE LAST SHOWER
C---------------------------------------------------------------
      JBMED  = LQ(JBOOT - NMED)
      JBADM  = LQ(JBMED - ITYPE)
      CALL MZBOOK(IXCONS,JBSHO,JBADM,-IENRG,'BSHO',0,0,80,IOBSHO,0)
      READ(LUNACT,REC=IENRG+1) IBUF
      ENERGY =  BUF(1)
      NSHWER= IBUF(2)
       Q(JBSHO+1) =ENERGY
      IQ(JBSHO+2) =NSHWER
      DO 10 ISHWER=1,NSHWER+1
10    IQ(JBSHO+ISHWER+2)=IBUF(ISHWER+2)
100   CONTINUE
1000  CONTINUE

      CALL VZERO(MEDIUM,23)

      END
+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/22 13:24:01  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:21  cernlib
* Geant

      SUBROUTINE GUKINE
C.    *
C.    *       Generates Kinematics for primary track
C.    *
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, PVOLUM.
+CDE, BOOTWK.
+CDE, CELOSS.
C
      DIMENSION VERTEX(3),PLAB(3)
      SAVE VERTEX,PLAB
      DATA VERTEX/3*0./
      DATA PLAB  /3*0./
C.
      CALL VZERO(DEDL,6*NBIN)
      CALL VZERO(ELEAK,3)
      VERTEX(3) = - Z1     + 0.01
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
C
      JPA = LQ(JPART-IKINE)
      XMASS = Q(JPA+7)
      PKINE(3) = XMASS + PKINE(1)
      EINCID = PKINE(3)
      PLAB(3) = SQRT(PKINE(1)*(PKINE(3)+XMASS))
C
      CALL GSKINE(PLAB,IKINE,NVERT,0,0,NT)
C
C ***          Kinematics debug (controlled by ISWIT(1) )
C
      IF(IDEBUG*ISWIT(1).EQ.1) THEN
          CALL GPRINT('VERT',0)
          CALL GPRINT('KINE',0)
      ENDIF
C
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/22 13:24:02  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

      SUBROUTINE GUOUT
C.    *
C.    *       User routine called at the end of each event
C.    *
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, PVOLUM.
+CDE, CELOSS.
      DIMENSION IDLK(3),NIDLK(3)
      SAVE IDLK,NID1,NID3,NIDLK
      DATA      IDLK / 6,7,8 /
      DATA NID1/0/, NID3/0/ , NIDLK/3*0/

      DLC = 0.
      DRC = 0.

      DO 2 I = 1,NLTOT
         SEL1 (I) = SEL1 (I) + DEDL(I)
         SEL2 (I) = SEL2 (I) + DEDL(I)**2
         DLC      = DLC      + DEDL(I)
         SEL1C(I) = SEL1C(I) + DLC
         SEL2C(I) = SEL2C(I) + DLC**2
   2  CONTINUE

      DO 3 I = 1,NRTOT
         SER1 (I) = SER1 (I) + DEDR(I)
         SER2 (I) = SER2 (I) + DEDR(I)**2
         DRC      = DRC      + DEDR(I)
         SER1C(I) = SER1C(I) + DRC
         SER2C(I) = SER2C(I) + DRC**2
   3  CONTINUE

      DO 14 IPAT = 1,4
      DO 14 NPL  = 1,NLTOT
         SNPAT1(NPL,IPAT) = SNPAT1(NPL,IPAT) + FNPAT(NPL,IPAT)
         SNPAT2(NPL,IPAT) = SNPAT2(NPL,IPAT) + FNPAT(NPL,IPAT)**2
   14 CONTINUE

      ESEEN = 100.*DLC/PKINE(3)
      CALL HFF1( 1,NID1, ESEEN,1.)

      ETOT = ESEEN
      DO 16 LK=1,3
         ELEAK(LK) = 100.*ELEAK(LK)/PKINE(3)
         CALL HFF1(IDLK(LK),NIDLK(LK),ELEAK(LK),1.)
         ETOT = ETOT + ELEAK(LK)
   16 CONTINUE
      CALL HFF1( 9,NID3, ETOT,1.)

      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.2  1996/02/22 13:24:03  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:21  cernlib
* Geant

      SUBROUTINE GUSTEP
C.    *
C.    *       User routine called at the end of each tracking step
C.    *       INWVOL is different from 0 when the track has reached
C.    *              a volume boundary
C.    *       ISTOP is different from 0 if the track has stopped
C.    *
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, CELOSS.
+CDE, PVOLUM.
+CDE, BOOTWK.
      DIMENSION NID(100)
      DATA NID/100*0/
C
C ***         Debug event
C
      IF(IDEBUG*ISWIT(2).EQ.2) CALL GPCXYZ
C
C ***          Something generated ?
C
      IF(NGKINE.GT.0) CALL GSKING(0)
C
C ***          Energy deposited
C
       IF(DESTEP.NE.0.)THEN
          NL  = NUMBER(NLEVEL)
          NR  = NUMBER(NLEVEL-1)
          DEDL(NL) = DEDL(NL) + DESTEP
          DEDR(NR) = DEDR(NR) + DESTEP
       ENDIF
C
C ***     Leakage
C
      IF(INWVOL.EQ.3) THEN
         ZL = Z1 - EPSIL
         IF(VECT(3).LE.-ZL) THEN
            ELEAK(1) = ELEAK(1) + GETOT
         ELSEIF(VECT(3).GE.ZL) THEN
            ELEAK(2) = ELEAK(2) + GETOT
         ELSE
            ELEAK(3) = ELEAK(3) + GETOT
         ENDIF
      ENDIF
C
C ***          Particle's flux
C
       NL  = NUMBER(NLEVEL)
       IF(SLENG.LE.0.) NLOLD = NL
       IF(NL.NE.NLOLD) THEN
         NPL = (NL + NLOLD)/2 + 1
         IPA = MIN(IPART,4)
         FNPAT(NPL,IPA) = FNPAT(NPL,IPA) + 1.
         NLOLD = NL
       ENDIF
*
* *** Bootstrap for this particle ?
*
      IF(JBOOT.NE.0) CALL UGBOOT
C
+SELF, IF=CHECK.
C
C ***          Process calls frequency
C
       IF(NMEC.LE.0) GO TO 56
       DO 55 IM = 1,NMEC
       IF(LMEC(IM).GT.12) GO TO 55
       IDM = 30 + LMEC(IM)
       CALL HFF1(IDM,NID(IDM),GEKIN,1.)
   55  CONTINUE
   56  CONTINUE
C
C ***         Plot total track length
C
      IF(ISTOP.NE.0) THEN
          SLENRL = SLENG/X0
          ID3=20+MIN(IPART,4)
          CALL HFF1(ID3,NID(ID3),SLENRL,1.)
      ENDIF
C
C *** Energy of generated secondaries
C
      IF(NGKINE.GT.0) THEN
        DO 30 I=1,NGKINE
        ITYPA  = MIN(GKIN(5,I),4)
        EKING = GKIN(4,I)
        IF(EKING.LE.0.010) ID1=50+ITYPA
        IF(EKING.GT.0.010) ID1=60+ITYPA
        CALL HFF1(ID1,NID(ID1),GKIN(4,I),1.)
   30   CONTINUE
      ENDIF

+SELF.

      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:21  cernlib
* Geant

      SUBROUTINE GUTREV
C.    *
C.    *       User routine to control tracking of one event
C.    *       Called by GRUN
C.    *
C
      CALL GTREVE
C
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant

C.    *
C.    *       TEST PROGRAM FOR GEANT/SHOWER STUDIES
C.    *
C.    *       Authors    R.Brun, M.Maire, P.Ribaric  *********
C.
      COMMON/PAWC/H(10000)
      COMMON/GCBANK/Q(50000)
C.
C.
      CALL GZEBRA(50000)
      CALL HLIMIT(-10000)
C
C ***          GEANT initialisation
C
      CALL UGINIT
C
C ***          Start events processing
C
      CALL GRUN
C
C ***          End of RUN
C
      CALL UGLAST
C.
      STOP
      END
+DECK,  UFILES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
+SELF, IF=CRAY.
      OPEN(50,FILE='bootgen1.dat',ACCESS='DIRECT',RECL=640,
     +        FORM='UNFORMATTED',STATUS='OLD')
      OPEN(51,FILE='bootgen2.dat',ACCESS='DIRECT',RECL=640,
     +        FORM='UNFORMATTED',STATUS='OLD')
      OPEN(UNIT=4,FILE='gexam7.dat',STATUS='OLD')
      OPEN(UNIT=34,FILE='gexam7.hist',ACCESS='DIRECT',
     +     RECL=8192,STATUS='NEW',FORM='UNFORMATTED')
+SELF, IF=APOLLO.
      OPEN(50,FILE='bootgen1.dat',ACCESS='DIRECT',RECL=320,
     +        FORM='UNFORMATTED',STATUS='UNKNOWN')
      OPEN(51,FILE='bootgen2.dat',ACCESS='DIRECT',RECL=320,
     +        FORM='UNFORMATTED',STATUS='UNKNOWN')
      OPEN(UNIT=4,FILE='gexam7.dat',STATUS='UNKNOWN')
      OPEN(UNIT=34,FILE='gexam7.hist',ACCESS='DIRECT',
     +     RECL=4096,STATUS='UNKNOWN')
+SELF, IF=VAX.
      OPEN(50,FILE='BOOTGEN1.DAT',ACCESS='DIRECT',RECL=80,
     +        FORM='UNFORMATTED',STATUS='UNKNOWN')
      OPEN(51,FILE='BOOTGEN2.DAT',ACCESS='DIRECT',RECL=80,
     +        FORM='UNFORMATTED',STATUS='UNKNOWN')
      OPEN(UNIT=4,FILE='GEXAM7.DAT',STATUS='UNKNOWN')
      OPEN(UNIT=34,FILE='GEXAM7.HIST',ACCESS='DIRECT',
     +     FORM='UNFORMATTED',RECL=1024,STATUS='UNKNOWN')
+SELF, IF=IBM.
      OPEN (50,RECL=320,ACCESS='DIRECT')
      OPEN (51,RECL=320,ACCESS='DIRECT')
      CALL VMCMS('FILEDEF  4 DISK GEXAM7 DAT',IRET)
      CALL VMCMS('FILEDEF 34 DISK GEXAM7 HIST A6',IRET)
      OPEN(UNIT=4,STATUS='UNKNOWN')
      OPEN(UNIT=34,ACCESS='DIRECT',
     +     FORM='UNFORMATTED',RECL=4096,STATUS='UNKNOWN')
+SELF.
      END
+DECK,  UGBOOT, T=FORT.
* Revision 1.2  1996/02/22 13:24:04  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:21  cernlib
* Geant

      SUBROUTINE UGBOOT

C------------------------------------------------------------------
C       CKECK THAT THE CURRENT PARTICLE SHOULD BE REPLACED
C       BY PRESHOWER OR NOT.
C
C       IF YES DO IT. THE USER SHOULD TAKE CARE OF THE DEPOSITED ENERGY
C       IN EACH CELL.
C
C       CALLED BY GUSTEP
C------------------------------------------------------------------
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, CELOSS.
+CDE, BOOTWK.

      DIMENSION BUF(2,40),IBUF(2,40),XREGIO(3)
      EQUIVALENCE (BUF,IBUF)
      DIMENSION RNDM(2)

      IF (ISTOP.NE.0) RETURN
C------------------------------------------------------------------
C     IS THIS MEDIUM MARKED FOR BOOTSTRAP ?
C------------------------------------------------------------------
      NMED =IQ(JBOOT+1)
      IF (NMED .EQ.0) RETURN
      DO 100 IMED=1,NMED
         JBMED=LQ(JBOOT-IMED)
         NAME =IQ(JBMED+1)
         IF (NAME.EQ.NAMES(NLEVEL)) GOTO 200
100   CONTINUE
      RETURN
C------------------------------------------------------------------
C     PARTICLE ENERGY BELOW ECUT ?
C------------------------------------------------------------------
200   ECUT = Q(JBMED+2)*EINCID
      IF (GETOT.LT.ECUT) GOTO 300
      RETURN
C------------------------------------------------------------------
C     PARTICLE MARKED FOR BOOTSTRAP IN THIS MEDIUM ?
C------------------------------------------------------------------
300   NTYPE=IQ(JBMED+4)
      DO 400 ITYPE=1,NTYPE
         IF (IQ(JBMED+ITYPE+4).EQ.IPART) GOTO 500
400   CONTINUE
      RETURN
C------------------------------------------------------------------
C     IS THERE SHOWERS THERE ?
C------------------------------------------------------------------
500   JBADM=LQ(JBMED-ITYPE)
      NENRG=IQ(JBADM+10)
      DO 600 IENRG=1,NENRG
         JBSHO=LQ(JBADM-IENRG)
         ENSHO= Q(JBSHO+1)/1000.0
         DEVIA=ABS(ENSHO-GETOT)/ENSHO
         IF (DEVIA.LT.Q(JBMED+3)) GOTO 700
600   CONTINUE
      RETURN
C------------------------------------------------------------------
C     LET'S GO BOOTSTRAP
C------------------------------------------------------------------
700   NBSHO=IQ(JBSHO+2)
      CALL HFILL(1000,FLOAT(IENRG),0.,1.)
      LUNIT=IQ(JBMED+ITYPE+NTYPE+4)
      NXBIN=IQ(JBADM+4)
      NYBIN=IQ(JBADM+5)
      NZBIN=IQ(JBADM+6)
      XBIN = Q(JBADM+7)
      YBIN = Q(JBADM+8)
      ZBIN = Q(JBADM+9)
      IXY  =IQ(JBADM+12)
      XRI  = Q(JBADM+13)
      YRI  = Q(JBADM+14)
      ZRI  = Q(JBADM+15)
C------------------------------------------------------------------
C     DIRECTION COSINES AND PARTICLE COORDINATES
C------------------------------------------------------------------
      XP=VECT(1)
      YP=VECT(2)
      ZP=VECT(3)
      UP=VECT(4)
      VP=VECT(5)
      WP=VECT(6)
C------------------------------------------------------------------
C     ROTATION MATRIX ELEMENTS
C------------------------------------------------------------------
      P=UP*UP
      T=UP*VP
      R=VP*VP
      S= 1.0/(1.0+WP)
      T11=1.0-P*S
      T12=-T*S
      T13=UP
      T21=T12
      T22=1.0-R*S
      T23=VP
      T31=-T13
      T32=-T23
      T33=WP
C------------------------------------------------------------------
C     RANDOM ROTATION MATRIX ELEMENTS
C------------------------------------------------------------------
      CALL GRNDM(RNDM,2)
      PHIROT=6.28*RNDM(1)
      COSROT=COS(PHIROT)
      SINROT=SIN(PHIROT)
C------------------------------------------------------------------
C     NORMALIZE FOR THE DEVIATION FROM STORED SHOWER ENERGY
C------------------------------------------------------------------
      ENORM=GETOT/ENSHO
C------------------------------------------------------------------
C     RANDOMLY PICKS UP A SHOWER FROM THE FILE
C------------------------------------------------------------------
      INSHO=RNDM(2)*NBSHO+1
      IREC1=IQ(JBSHO+INSHO+2)
      IREC2=IQ(JBSHO+INSHO+3)
      NREC=IREC2-IREC1
      DO 900 IREC=IREC1,IREC2-1
      READ(LUNIT,REC=IREC) IBUF
      DO 800 IND=1,40
C------------------------------------------------------------------
C     THE CONTENT OF A CELL , NUMBER 'IREGIO' , IS 'EREGIO'
C------------------------------------------------------------------
      IREGIO=IBUF(2,IND)
C------------------------------------------------------------------
      EREGIO= BUF(1,IND)/1000.0*ENORM
      IF ((IREGIO.GT.0).AND.(EREGIO.GT.0.)) THEN
             I=(IREGIO-2)/IXY+1
             J=(IREGIO-2-IXY*(I-1))/NXBIN+1
             K=IREGIO-1-IXY*(I-1)-NXBIN*(J-1)
             AR=(K-0.5)*XBIN-XRI
             BR=(J-0.5)*YBIN-YRI
             XR= COSROT*AR + SINROT*BR
             YR=-SINROT*AR + COSROT*BR
             ZR=(I-0.5)*ZBIN-ZRI
             XREGIO(1)=T11*XR+T12*YR+T13*ZR+XP
             XREGIO(2)=T21*XR+T22*YR+T23*ZR+YP
             XREGIO(3)=T31*XR+T32*YR+T33*ZR+ZP
C---------------------------------------------------------
C            HERE ATTACH BINS TO 'PHYSICAL' CRYSTALS
C            ( BEFORE THAT UPDATES THE VOLUME COMMON )
C            YOU CAN INSERT HERE YOUR OWN ROUTIN FOR COUNTING
C            DEPOSITED ENERGY
C---------------------------------------------------------
             CALL GMEDIA(XREGIO,NUMED)

C ***          Energy deposited
              IF(NUMED.EQ.1) THEN
                 NL  = NUMBER(NLEVEL)
                 NR  = NUMBER(NLEVEL-1)
                 DEDL(NL) = DEDL(NL) + EREGIO
                 DEDR(NR) = DEDR(NR) + EREGIO
              ENDIF
C---------------------------------------------------------
C      SOME DEBUG MAY BE HERE
C---------------------------------------------------------
       ENDIF
800    CONTINUE
900    CONTINUE
C------------------------------------------------------------------
C      PARTICLE DISCARDED ( ITS ENERGY BECOMES ZERO )
C------------------------------------------------------------------
       GEKIN=0.0
       ISTOP=2
       IF(IDEBUG*ISWIT(2).EQ.2) PRINT 1239,GETOT
1239   FORMAT(' BOOTSTRAP FOR ',F12.3,' GEV SHOWER USED')

      END
+DECK,  UGEOM, T=FORT.
* Revision 1.2  1996/02/22 13:24:04  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:21  cernlib
* Geant

      SUBROUTINE UGEOM
C
C ***          Define user geometry set up
C
+CDE, GCBANK.
+CDE, PVOLUM.
C
      DIMENSION PAR( 3)
      DIMENSION ZLG(6),ALG(6),WLG(6)
      DIMENSION ABGO(3),ZBGO(3),WBGO(3)
      DIMENSION AF(3),ZF(3),WMATF(3)
C
C             Lead glass mixture parameters
C
      DATA ZLG/  82.00,  19.00,  14.00,  11.00,  8.00,  33.00/
      DATA ALG/ 207.19,  39.102,  28.088,  22.99, 15.999,  74.922/
      DATA WLG/ .65994, .00799, .126676, .0040073,.199281, .00200485 /
C
C             BGO compound parameters
C
      DATA ABGO/208.98,72.59,15.999/
      DATA ZBGO/83.,32.,8./
      DATA WBGO/4.,3.,12./
C
C             Iron+Nickel+Crome  compound parameters
C
      DATA AF/55.847,58.71,51.998/
      DATA ZF/26.,28.,24./
      DATA WMATF/0.703964,0.099,0.197/
C
C ***          Defines USER particular materials
C
      CALL GSMATE( 1,'AIR$    ', 14.61,7.3,0.001205,30423.,6750.,0,0)
      CALL GSMATE( 2,'CARBON$   ', 12.01, 6.,2.265 ,18.8,49.9,0,0)
      CALL GSMATE( 3,'ALUMINIUM$', 26.98,13.,2.7   , 8.9,37.2,0,0)
      CALL GSMATE( 4,'COPPER$   ', 63.54,29.,8.96  ,1.43,14.8,0,0)
      CALL GSMATE( 5,'LEAD$     ',207.19,82.,11.35 ,0.56,18.5,0,0)
      CALL GSMATE( 6,'URANIUM$  ',238.03,92.,18.95 ,0.32,12. ,0,0)
      CALL GSMIXT(10,'IRON(COMPOUND)$',AF,ZF,7.8,3,WMATF)
      CALL GSMIXT(21,'BGO(COMPOUND)$',ABGO,ZBGO,7.1,-3,WBGO)
      CALL GSMIXT(22,'LEAD GLASS$',ALG,ZLG,5.2,6,WLG)
C
C ***          Defines USER tracking media parameters
C
      FIELDM =  0.
      IFIELD =  0
      TMAXFD = 10.0
      DMAXMS =  0.50
      DEEMAX =  0.20
      EPSIL  =  0.01
      STMIN  =  0.80
C
      CALL GSTMED( 1,'ABSORBER$'              ,IMAT, 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
C
C ***          Defines USER'S VOLUMES
C
      JMA = LQ(JMATE-IMAT)
      X0 = Q(JMA + 9)
      R1     =  NRTOT*DRX0*X0
      Z1     =  NLTOT*DLX0*X0*0.5
C
      PAR(1) = 0.
      PAR(2) = R1
      PAR(3) = Z1
      CALL GSVOLU( 'ECAL' , 'TUBE' ,    1, PAR , 3 , IVOL )
C
      CALL GSDVN( 'RTUB' , 'ECAL' ,   NRTOT , 1)
      CALL GSDVN( 'RING' , 'RTUB' ,   NLTOT , 3)
C
C ***          Close geometry banks. (obligatory system routine)
C
      CALL GGCLOS
C
      END
+DECK,  UGINIT, T=FORT.
* Revision 1.3  1996/03/05 15:08:53  ravndal
* Cleanup of CARTOCVS conversion
* Revision 1.2  1996/02/22 13:24:05  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant

      SUBROUTINE UGINIT
C.    *
C.    *        To initialise GEANT/USER  program and read data cards
C.    *
+CDE, PVOLUM.
+CDE, GCUNIT.
+CDE, GCLIST.
+CDE, GCKINE.
+CDE, GCMULO.
+CDE, CELOSS.
+CDE, BOOTDT.
+CDE, BOOTWK.
*
*             Open user files
*
      CALL UFILES
C.
C             Initialise GEANT
C
      CALL GINIT
C *** volumes and bins definition
      NLTOT=20
      DLX0 = 1.
      NRTOT=20
      DRX0 = 0.25
      CALL FFKEY('BINS',NLTOT,4,'MIXED')
C *** material definition
      IMAT=21
      CALL FFKEY('MATE',IMAT,1,'INTEGER')
C *** define kinematic
      IKINE = 1
      PKINE(1)=10.
C *** bootstrap option
      JBOOT=0
      CALL FFKEY('BOOT',MEDIUM,23,'MIXED')
C *** read data cards
      CALL GFFGO
C *** achieve initialization
      NLTOT = MIN(NLTOT,NBIN)
      NRTOT = MIN(NRTOT,NBIN)
      CALL VZERO(SEL1,22*NBIN)
C
C
      CALL GZINIT
      CALL GPART
C
C             Prints version number
C
      WRITE(LOUT,1000)
C
C              Geometry and materials description
      CALL UGEOM
C
      CALL GLOOK('MATE',LPRIN,NPRIN,IM)
      CALL GLOOK('TMED',LPRIN,NPRIN,IT)
      CALL GLOOK('VOLU',LPRIN,NPRIN,IV)
      IF(IM.NE.0)CALL GPRINT('MATE',0)
      IF(IT.NE.0)CALL GPRINT('TMED',0)
      IF(IV.NE.0)CALL GPRINT('VOLU',0)
C
C              Energy loss and cross-sections initialisations
C
      CALL GPHYSI
C
+SELF, IF=CHECK.
      IF(IKINE.LE.3) THEN
         CALL GPLMAT(IMAT,1,'ALL',90,ELOW,0)
         CALL GPLMAT(IMAT,3,'ALL',90,ELOW,0)
       ELSE
         CALL GPLMAT(IMAT,IKINE,'ALL',90,ELOW,0)
      ENDIF
+SELF.
C
C             Define user histograms
C
      CALL UHINIT
C
 1000 FORMAT(/,'  GEXAM1 VERSION 2.05 ',/)
C
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.2  1996/02/22 13:24:06  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

      SUBROUTINE UGLAST
C.    *
C.    *      Termination routine to print histograms and statistics
C.    *
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, PVOLUM.
+CDE, CELOSS.
+CDE, BOOTWK.
C
      DIMENSION     XSEL1(NBIN),XSEL1C(NBIN),XSER1(NBIN),XSER1C(NBIN),
     +              XSEL2(NBIN),XSEL2C(NBIN),XSER2(NBIN),XSER2C(NBIN),
     +               PAT1(NBIN), PAT2(NBIN)

      IF(ISWIT(10).EQ.0)CALL GLAST

C ***          Normalize and print energy distribution

      XEVENT=IEVENT
      CNORM  = 100./(XEVENT*PKINE(3))
C
      DO 2 I = 1,NLTOT
         XSEL1 (I) = CNORM * SEL1 (I)
         XSEL2 (I) = CNORM*SQRT(ABS(XEVENT*SEL2 (I) - SEL1 (I)**2))
         XSEL1C(I) = CNORM * SEL1C(I)
         XSEL2C(I) = CNORM*SQRT(ABS(XEVENT*SEL2C(I) - SEL1C(I)**2))
    2 CONTINUE

      CALL HPAK (2,XSEL1 )
      CALL HPAKE(2,XSEL2 )

      CALL HPAK (4,XSEL1C)
      CALL HPAKE(4,XSEL2C)

      DO 3 I = 1,NRTOT
         XSER1 (I) = CNORM * SER1 (I)
         XSER2 (I) = CNORM*SQRT(ABS(XEVENT*SER2 (I) - SER1 (I)**2))
         XSER1C(I) = CNORM * SER1C(I)
         XSER2C(I) = CNORM*SQRT(ABS(XEVENT*SER2C(I) - SER1C(I)**2))
    3 CONTINUE

      CALL HPAK (3,XSER1 )
      CALL HPAKE(3,XSER2 )

      CALL HPAK (5,XSER1C)
      CALL HPAKE(5,XSER2C)

      IPMX=3
      IF(IKINE.GT.3) IPMX=4
      DO 14 IP = 1,IPMX
      DO 13 I  = 1,NLTOT
         PAT1(I) = SNPAT1(I,IP) / XEVENT
         PAT2(I) = SQRT(SNPAT2(I,IP)/XEVENT - PAT1(I)**2)
   13 CONTINUE
      CALL HPAK (10+IP,PAT1)
      CALL HPAKE(10+IP,PAT2)
   14 CONTINUE
*
* *** NORMALISE HISTO
*
      IF(JBOOT.NE.0) CALL HNORMA(1000, HSUM(1000)/XEVENT)

      PRINT 751
      PRINT 754 ,( XSEL2 (I),I=1,NLTOT)
      PRINT 755 ,( XSEL2C(I),I=1,NLTOT)
      PRINT 752
      PRINT 754 ,( XSER2 (I),I=1,NRTOT)
      PRINT 755 ,( XSER2C(I),I=1,NRTOT)
  751 FORMAT(///,40X,'LONGITUDINAL PROFIL',/)
  752 FORMAT(///,40X,'   RADIAL PROFIL   ',/)
  754 FORMAT(//,30X,'ERROR ON PROFIL     VALUES',/
     *         ,(10X,10F10.4))
  755 FORMAT(//,30X,'ERROR ON CUMULATIVE VALUES',/
     *         ,(10X,10F10.4))
C
C             Save histograms
C
      CALL HROUT(0,ICYCLE,' ')
      CALL HREND('HBOOK')
C
      IF(ISWIT(10).EQ.0)THEN
         CALL HIDOPT(0,'BLAC')
         CALL HISTDO
      ENDIF
      END
+DECK,  UHINIT, T=FORT.
* Revision 1.2  1996/02/22 13:24:07  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:20  cernlib
* Geant

      SUBROUTINE UHINIT
C
C     *       To book the user's histograms
C     *
+CDE, GCKINE.
+CDE, PVOLUM.
+CDE, BOOTWK.
C
C ***            Histograms for shower development
C
*             Open a HBOOK direct access file
*
      CALL HRFILE(34,'HBOOK','N')
*
      NBINZ=NLTOT+1
      NBINR=NRTOT+1
      ZMAX=NBINZ+1
      RMAX=NBINR+1
C
      IF(IKINE.LE.3) THEN
         EDMIN=81.
         EDMAX=101.
         ETMAX=101.
       ELSE
         EDMIN=0.
         EDMAX=110.
         ETMAX=100. + 100./PKINE(1)
      ENDIF
      CALL HBOOK1(1,'TOTAL ENERGY DEPOSITION(IN PERCENT OF E INC)$'
     *,100,EDMIN,EDMAX,0.0)
      CALL HBOOK1(6,'BACKWARD LEAKAGE(IN PERCENT OF E INC)$'
     *,100,  0., EDMAX,0.0)
      CALL HBOOK1(7,' FORWARD LEAKAGE(IN PERCENT OF E INC)$'
     *,100,  0.,EDMAX,0.0)
      CALL HBOOK1(8,' LATERAL LEAKAGE(IN PERCENT OF E INC)$'
     *,100,  0., EDMAX,0.0)
      CALL HBOOK1(9,'TOTAL ENERGY CONSERVATION(IN PERCENT OF E INC)$'
     *,100, EDMIN,ETMAX,0.0)
      CALL HBOOK1(2,'LONGIT ENERGY DEPOSITION (IN PERCENT OF E INC)$'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(4,'CUMUL LONGIT ENERGY DEP. (IN PERCENT OF E INC)$'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(3,'RADIAL ENERGY DEPOSITION (IN PERCENT OF E INC)$'
     *, NBINR, 1.,RMAX,  0.0)
      CALL HBOOK1(5,'CUMUL RADIAL ENERGY DEP. (IN PERCENT OF E INC)$'
     *, NBINR, 1.,RMAX,  0.0)
      CALL HBOOK1(11,'NB OF GAMMA PER PLANE$'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(12,'NB OF E +   PER PLANE$'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(13,'NB OF E -   PER PLANE$'
     *, NBINZ, 1.,ZMAX,  0.0)
      IF(IKINE.GT.3)
     * CALL HBOOK1(14,'NB OF OTHERS PARTICLES PER PLANE$'
     *, NBINZ, 1.,ZMAX,  0.0)
      IF(JBOOT.NE.0)
     * CALL HBOOK1(1000,'NB OF BOOT CALLS PER EVENT$',20,0.,20.,0.)
C
      CALL HBIGBI(0,4)
C
+SELF, IF=CHECK.
C
C ***          Histograms for detailed studies
C
      CALL HBOOK1(21,'TOTAL GAMMA LENGHT IN RL$'
     *,100, 0.,  10. , 0.)
      CALL HBOOK1(22,'TOTAL POSIT LENGHT IN RL$'
     *,100, 0., 5.   , 0.)
      CALL HBOOK1(23,'TOTAL ELECT LENGHT IN RL$'
     *,100, 0., 5.   , 0.)
      CALL HBOOK1(24,'TOTAL LENGHT IN RL FOR OTHER PARTICLES$'
     *,100, 0., 20.  , 0.)
C
      CALL HBOOK1(31,'NUMBER OF NEXT CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(32,'NUMBER OF MULS CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(33,'NUMBER OF LOSS CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(34,'NUMBER OF FIEL CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(35,'NUMBER OF DCAY CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(36,'NUMBER OF PAIR CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(37,'NUMBER OF COMP CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(38,'NUMBER OF PHOT CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(39,'NUMBER OF BREM CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(  40,'NUMBER OF DRAY CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(41,'NUMBER OF ANNI CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(42,'NUMBER OF HADR CALLS$'
     *,100, 0., 1.00, 0.)

      CALL HBOOK1(51,'ENERGY DISTR OF GAMMAS(0 - 10MEV)$'
     *,100,0.,0.01,0.)
      CALL HBOOK1(52,'ENERGY DISTR OF POSITRONS(0 - 10 MEV)$'
     *,100,0.,0.01,0.)
      CALL HBOOK1(53,'ENERGY DISTR OF ELECTRONS(0 - 10 MEV)$'
     *,100,0.,0.01,0.)
      CALL HBOOK1(54,'ENERGY DISTR OF OTHERS PA(0 - 10 MEV)$'
     *,100,0.,0.01,0.)
      CALL HBOOK1(61,'ENERGY DISTR OF GAMMAS(10 -100 MEV)$'
     *,100,0.,0.1,0.)
      CALL HBOOK1(62,'ENERGY DISTR OF POSITRONS(10-100 MEV)$'
     *,100,0.,0.1,0.)
      CALL HBOOK1(63,'ENERGY DISTR OF ELECTRONS(10 - 100 MEV)$'
     *,100,0.,0.1,0.)
      CALL HBOOK1(64,'ENERGY DISTR OF OTHERS PA(10 - 100 MEV)$'
     *,100,0.,0.1,0.)
C
+SELF.
C
      END
+PATCH, EXAMPLES_EREXAM1.
+KEEP, CUGEOM.
* Revision 1.1.1.1  1996/03/06 15:36:25  mclareni
* Add geane321 examples
* cugeom.inc
      COMMON/CUGEOM/ TFRAM,TBEAM,TCDET,TECAL,TSOLN,THCAL,TMUON
+DECK,  DATA1, T=DATA.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples
*
*
LIST
C    GET  'INIT'
TRIG  10
KINE  5 (type)  20. (momentum)   90. (teta)   0. (phi)
DEBUG 1  1
SWIT  0  1  3
CUTS  5*0.00010   5*10000.
LOSS  4
MULS  0
TIME  2=3.
END
+DECK,  ERTEST, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:25  mclareni
* Add geane321 examples
*      GEANE TRACKING

      SUBROUTINE ERTEST
*
*     Test ERTRAK by generating a particle
*
*     Card Kine : itype  momentum  teta  phi
*
+CDE, ERTRIO.
+CDE, GCONST.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCFLAG.
*
      PARAMETER (NPMX = 5)
      DIMENSION X1(3),P1(3),ER1(15)
      DIMENSION X2(3),P2(3)
      DIMENSION XL(NPMX),PPL(3,3,NPMX),PLI(3,2)
      DIMENSION NUMV(NPMX),IOVL(NPMX)
      CHARACTER * 4 CNAMV(NPMX)
*
*
* *** Data for option 'P' and 'L'
*
      DATA XL    / 25.   , 50.     , 120.     , 220.     , 300.     /
*
* *** Data for option 'V'
*
      DATA CNAMV / 'CDET', 'ECAL', 'ECAL', 'HCAL', 'HCAL'  /
      DATA  NUMV /   1   ,   1   ,   1   ,   1   ,   1     /
      DATA  IOVL /   1   ,   1   ,   2   ,   1   ,   2     /
*
      CALL VZERO(ER1,15)
      CALL VZERO(PLI,6)
      CALL VZERO(PPL,9*NPMX)
*
      PLI(2,1) = 1.
      PLI(3,2) = 1.
*
      NP = 5
      DO 1 IP=1,NP
         PPL(2,1,IP) = 1.
         PPL(3,2,IP) = 1.
         PPL(1,3,IP) = XL(IP)
    1 CONTINUE
*
* *** Forward Tracking
*
      X1(1) = 0.
      X1(2) = 0.
      X1(3) = 0.
*
      PMOM  = PKINE(1)
      TETA  = PKINE(2)*DEGRAD
      PHI   = PKINE(3)*DEGRAD
      P1(1) = PMOM * SIN(TETA) * COS(PHI)
      P1(2) = PMOM * SIN(TETA) * SIN(PHI)
      P1(3) = PMOM * COS(TETA)
*
* *** Prepare the common /EROPTS/
*
      CALL EUFILL (NP,ER1,XL)
      CALL EUFILP (NP,ER1,PLI,PPL)
      CALL EUFILV (NP,ER1,CNAMV,NUMV,IOVL)
*
      CALL ERTRAK (X1,P1,X2,P2,IKINE,'P')
      IF (IDEBUG.EQ.1) THEN
         WRITE (LOUT, 1001)
         WRITE (LOUT, 1002) (X2(IP),IP=1,3),(P2(IP),IP=1,3),
     +               ((ERXOUT(IP,IR),IP=1,3),IR=1,NP),
     +               ((ERPOUT(IP,IR),IP=1,3),IR=1,NP),
     +               ((ERROUT(IP,IR),IP=1,15),IR=1,NP),
     +               (((ERTRSP(IP,IQ,IR),IP=1,5),IQ=1,5),IR=1,NP)
      END IF
*
* *** Backward tracking
*
      IF (ISWIT(3).LT.2) RETURN
*
      DO 2 I=1,3
         X1(I) = VECT(I)
         P1(I) = VECT(I+3)*VECT(7)
    2 CONTINUE
      CALL VZERO(ER1,15)
      NP = 5
*
      CALL EUFILV(NP,ER1,CNAMV,NUMV,IOVL)
*
      CALL ERTRAK(X1,P1,X2,P2,IKINE,'VB')
      IF (IDEBUG.EQ.1) THEN
         WRITE (LOUT, 1001)
         WRITE (LOUT, 1003) (X2(IP),IP=1,3),(P2(IP),IP=1,3),
     +               ((ERXOUT(IP,IR),IP=1,3),IR=1,NP),
     +               ((ERPOUT(IP,IR),IP=1,3),IR=1,NP),
     +               ((ERROUT(IP,IR),IP=1,15),IR=1,NP),
     +               (((ERTRSP(IP,IQ,IR),IP=1,5),IQ=1,5),IR=1,NP)
      END IF
*
 1001 FORMAT (/'  Result of the tracking'/)
 1002 FORMAT (/'  Track stopped at :',3F12.3,
     +         '     with momentum :',3F12.3,
     +        /'  Stored coordinates :  ',/,5(2X,3F12.3,/),
     +        /'  Stored momenta in SD :',/,5(2X,3F12.3,/),
     +        /'  Stored error-matrices in SD :',
     +        /   5(2X,10E13.4,/,2X,5E13.4,//),
     +        /'  Stored transport matrices in SD :',
     +        /   5(5(2X,5E13.4/),/))
 1003 FORMAT (/'  Track stopped at :',3F12.3,
     +         '     with momentum :',3F12.3,
     +        /'  Stored coordinates :  ',/,4(2X,3F12.3,/),
     +        /'  Stored momenta in SC :',/,4(2X,3F12.3,/),
     +        /'  Stored error-matrices in SC :',
     +        /   4(2X,10E13.4,/,2X,5E13.4,//),
     +        /'  Stored transport matrices in SC :',
     +        /   4(5(2X,5E13.4/),/))
*
      END
+DECK,  GUKINE, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:25  mclareni
* Add geane321 examples
*      GEANT TRACKING

      SUBROUTINE GUKINE
*
*     Generates Kinematic for primary track
*
*     Card Kine : itype  momentum  teta  phi
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCONST.
*
      DIMENSION VERTEX(3)
*
      VERTEX(1) = 0.
      VERTEX(2) = 0.
      VERTEX(3) = 0.
      PMOM      = PKINE(1)
      TETA      = PKINE(2)*DEGRAD
      PHI       = PKINE(3)*DEGRAD
*
      PKINE( 8) = PMOM * SIN(TETA) * COS(PHI)
      PKINE( 9) = PMOM * SIN(TETA) * SIN(PHI)
      PKINE(10) = PMOM * COS(TETA)
*
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
*
      CALL GSKINE(PKINE(8),IKINE,NVERT,0,0,NT)
*
* *** Kinematics debug (controlled by ISWIT(1) )
      IF(IDEBUG*ISWIT(1).EQ.1) THEN
          CALL GPRINT('VERT',0)
          CALL GPRINT('KINE',0)
      ENDIF
*
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:25  mclareni
* Add geane321 examples

      SUBROUTINE GUSTEP
*
*     User routine called at the end of each tracking step
*
+CDE, GCFLAG.
*
* *** Debug event
      IF (IDEBUG*ISWIT(2).NE.0) CALL GPCXYZ
*
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:25  mclareni
* Add geane321 examples

+CDE, GCFLAG.
+CDE, GCLIST.
+CDE, GCTIME.
+CDE, GCUNIT.

      PARAMETER (IGSPAC=100000 ,IHSPAC=10000)
      COMMON/GCBANK/Q(IGSPAC)
      COMMON/PAWC  /H(IHSPAC)
*
      CHARACTER*4 CLGET(20)
      DATA INPUT  /1/
*
* *** Initializations
*
      CALL GZEBRA( IGSPAC)
      CALL HLIMIT(-IHSPAC)
      CALL GINIT
      CALL GFFGO
      CALL GZINIT
*
* *** Build or readin the following Geant banks : JVOLU  JMATE  JTMED  JPART
      IF (NGET.LE.0) THEN
         CALL UGEOM
         CALL GPART
      ELSE
         DO  5 JGET=1, NGET
            CALL UHTOC(LGET(JGET),4,CLGET(JGET),4)
   5     CONTINUE
         CALL GOPEN (INPUT, 'I' ,0,IER)
         CALL GFIN  (INPUT,CLGET,NGET,IDENT,'I',IER)
         IF (IER.LT.0) GO TO 90
      ENDIF
*
      CALL GPHYSI
*
* *** Print control
      CALL GPRINT('MATE',0)
      CALL GPRINT('TMED',0)
      CALL GPRINT('VOLU',0)

      CALL TIMEX(TIMINT)
*
* *** Process the events
*
  10  CALL GTRIGC
      CALL GTRIGI
*
*     geant tracking , if required
      IF (ISWIT(3).GE.3) CALL GTRIG
*     geane tracking
      IF (ISWIT(3).GE.1) CALL ERTEST
*
      IF(IEVENT.LT.NEVENT) THEN
         IEVENT = IEVENT + 1
         GO TO 10
      ENDIF
*
* *** End of run
*
      IEORUN = 1
      CALL TIMEX(TIMNOW)
      TMEAN = 1000.*(TIMNOW - TIMINT)/FLOAT(IEVENT)
      PRINT 4000,TMEAN
*
   90 CONTINUE
*
      STOP
*
 4000 FORMAT(10X,'Time per event =',F10.3,' mseconds')
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:25  mclareni
* Add geane321 examples

      SUBROUTINE UGEOM
*
* *** Define user geometry set up
*
+CDE, GCONST.
+CDE, GCLIST.
+CDE, CUGEOM.
*
      DIMENSION PAR( 5)
*
* *** Defines USER perticular materials
      CALL GSMATE( 1,'Vacuum  ',1.E-16,1.E-16,1.E-16,1.E+16,1.E+16,0,0)
      CALL GSMATE( 2,'Air     ', 14.61,7.3,0.001205,30423.,6750.,0,0)
      CALL GSMATE( 3,'Aluminium', 26.98,13.,2.7   ,8.90,37.2,0,0)
      CALL GSMATE( 4,'Iron     ', 55.85,26.,7.87  ,1.76,17.1,0,0)
      CALL GSMATE( 5,'Copper   ', 63.54,29.,8.96  ,1.43,14.8,0,0)
*
* *** Defines USER tracking media parameters
      FIELDM = 10.0
      TMAXFD = 10.0
      DMAXMS =  0.50
      DEEMAX =  0.05
      EPSIL  =  0.0100
      STMIN  =  0.0100
*
      IFIELD =  0
      CALL GSTMED( 1,'Fram'            , 2, 0 ,IFIELD, FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
      CALL GSTMED( 2,'Muon detection'  , 2, 0 ,IFIELD, FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
      CALL GSTMED( 3,'Solenoid'        , 3, 0 ,IFIELD, FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
      IFIELD =  3
      CALL GSTMED( 4,'Beam            ', 1, 0 ,IFIELD,-FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
      CALL GSTMED( 5,'Central Detector', 2, 0 ,IFIELD,-FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
      CALL GSTMED( 6,'Electr. calorim.', 5, 0 ,IFIELD,-FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
      CALL GSTMED( 7,'Hadronic calorim', 4, 0 ,IFIELD,+FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
*
* *** Defines the GEOMETRY : typical detectors for collider ...
*
* *** Basic parameters
      TBEAM  = 5.
      TCDET  = 95.
      TECAL  = 40.
      TSOLN  = 10.
      THCAL  = 100.
      TMUON  = 50.
      DECAL  = 10.
      DHCAL  = 10.
*
* *** Absolute reference frame (box )
      TFRAM  = TBEAM + TCDET + TECAL + TSOLN + THCAL + TMUON
      PAR(1) = TFRAM
      PAR(2) = 50.
      PAR(3) = 50.
      IMED   = 1
      CALL GSVOLU('FRAM','BOX ',IMED ,PAR, 3 ,IVOLU)
*
* *** Beam
      PAR(1) = TBEAM
      PAR(2) = 50.
      PAR(3) = 50.
      IMED   = 4
      CALL GSVOLU('BEAM','BOX ',IMED ,PAR, 3 ,IVOLU)
*
      OGX   = 0.
      OGY   = 0.
      OGZ   = 0.
      CALL GSPOS ('BEAM', 1,'FRAM',OGX,OGY,OGZ, 0,'ONLY')
*
* *** Central Detector
      PAR(1) = 0.5*TCDET
      PAR(2) = 50.
      PAR(3) = 50.
      IMED   = 5
      CALL GSVOLU('CDET','BOX ',IMED ,PAR, 3 ,IVOLU)
*
      OGX   = TBEAM + 0.5*TCDET
      OGY   = 0.
      OGZ   = 0.
      CALL GSPOS ('CDET', 1,'FRAM',OGX,OGY,OGZ, 0,'ONLY')
*
* *** Electromagnetic calorimeter
      PAR(1) = 0.5*TECAL
      PAR(2) = 50.
      PAR(3) = 50.
      IMED   = 6
      CALL GSVOLU('ECAL','BOX ',IMED ,PAR, 3 ,IVOLU)
*
      OGX   = TBEAM + TCDET + 0.5*TECAL
      OGY   = 0.
      OGZ   = 0.
      CALL GSPOS ('ECAL', 1,'FRAM',OGX,OGY,OGZ, 0,'ONLY')
*
      CALL GSDVT ('DVEC','ECAL',DECAL,1,IMED,0)
*
* *** Solenoid
      PAR(1) = 0.5*TSOLN
      PAR(2) = 50.
      PAR(3) = 50.
      IMED   = 3
      CALL GSVOLU('SOLN','BOX ',IMED ,PAR, 3 ,IVOLU)
*
      OGX   = TBEAM + TCDET + TECAL + 0.5*TSOLN
      OGY   = 0.
      OGZ   = 0.
      CALL GSPOS ('SOLN', 1,'FRAM',OGX,OGY,OGZ, 0,'ONLY')
*
* *** Hadron calorimeter
      PAR(1) = 0.5*THCAL
      PAR(2) = 50.
      PAR(3) = 50.
      IMED   = 7
      CALL GSVOLU('HCAL','BOX ',IMED ,PAR, 3 ,IVOLU)
*
      OGX   = TBEAM + TCDET + TECAL + TSOLN + 0.5*THCAL
      OGY   = 0.
      OGZ   = 0.
      CALL GSPOS ('HCAL', 1,'FRAM',OGX,OGY,OGZ, 0,'ONLY')
*
      CALL GSDVT ('DVEH','HCAL',DHCAL,1,IMED,0)
*
* *** Muon chambers
      PAR(1) = 0.5*TMUON
      PAR(2) = 50.
      PAR(3) = 50.
      IMED   = 2
      CALL GSVOLU('MUON','BOX ',IMED ,PAR, 3 ,IVOLU)
*
      OGX   = TBEAM + TCDET + TECAL + TSOLN + THCAL + 0.5*TMUON
      OGY   = 0.
      OGZ   = 0.
      CALL GSPOS ('MUON', 1,'FRAM',OGX,OGY,OGZ, 0,'ONLY')
*
*     Optimisation of the search
      CALL GSORD ('FRAM' , 1)
*
* *** Close geometry banks. (obligatory system routine)
      CALL GGCLOS
*
      END
+PATCH, EXAMPLES_GEXAM1.
+KEEP, PVOLUM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:07  cernlib
* Geant
* pvolum.inc
      COMMON/PVOLUM/ NL,NR,IMAT,X0
*
* pvolum.inc
*
+KEEP, PVOLUM, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:07  cernlib
* Geant
* pvolum.inc
*
* pvolum.inc
*
+CDE, INCBEG.
     +   pvolum
+CDE, INCEND.
+KEEP, CELOSS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:07  cernlib
* Geant
* celoss.inc
      COMMON/CELOSS/SEL1(40),SEL1C(40),SER1(40),SER1C(40),SNPAT1(40,4),
     *              SEL2(40),SEL2C(40),SER2(40),SER2C(40),SNPAT2(40,4),
     *              EINTOT,DEDL(40),DEDR(40),FNPAT(40,4)
*
* celoss.inc
*
+KEEP, CELOSS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:07  cernlib
* Geant
* celoss.inc
*
* celoss.inc
*
+CDE, INCBEG.
     +   celoss
+CDE, INCEND.
+DECK,  EXAM1, T=DATA.
LIST
TRIGGERS   10
DEBUG     1   1    1
CUTS  0.0001    0.001
KINE 101 10. 0. 0. -1.
MATER   21
BINS  20 IN Z  20 IN R
PRINT   'MATE' 'VOLU'  'TMED'
TIME 2=10.
END
+DECK,  G321X1_INP_D, T=DATA, IF=DOC.
READ 4
TRIGGER 300
TIME 2=60.
STOP
+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/01 14:37:23  ravndal
* Clean up of the repository
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE GUKINE
C.
C.    *
C.    *       Generates Kinematics for primary track
C.    *
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCONSP.
+CDE, GCSCAN.
+CDE, CELOSS.
+CDE, PVOLUM.

C

      DIMENSION VERTEX(3),PLAB(3),RNDM(2)
      SAVE VERTEX,PLAB
      DATA VERTEX/3*0./
      DATA PLAB  /3*0./
C.
C.
      IF(SCANFL) THEN
         CALL GSCANK
      ELSE
         CALL VZERO(DEDL,240)
         VERTEX(3) = - 10.*X0 + 0.01
         IF(IKINE.GT.100)THEN
            IK=IKINE-100
            THETA=PKINE(2)*DEGRAD
            PHI=PKINE(3)*DEGRAD
         ELSE
            IK=IKINE
            CALL GRNDM(RNDM,2)
            THETA=PI*RNDM(1)
            PHI=TWOPI*RNDM(2)
         ENDIF
C
         PLAB(1) = PKINE(1)*SIN(THETA)*COS(PHI)
         PLAB(2) = PKINE(1)*SIN(THETA)*SIN(PHI)
         PLAB(3) = PKINE(1)*COS(THETA)
C
         CALL GSVERT(VERTEX,0,0,0,0,NVERT)
         CALL GSKINE(PLAB,IK,NVERT,0,0,NT)

         JK = LQ(JKINE-NT)
         EINTOT = EINTOT + Q(JK+4)


C
C ***          Kinematics debug (controlled by ISWIT(1) )
C
         IF(IDEBUG.EQ.1) THEN
            IF(ISWIT(1).EQ.1) THEN
               CALL GPRINT('VERT',0)
               CALL GPRINT('KINE',0)
            ENDIF
         ENDIF
      ENDIF

C
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/01 14:37:26  ravndal
* Clean up of the repository
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE GUOUT
C.
C.    *
C.    *       User routine called at the end of each event
C.    *
C.
C

+CDE, GCFLAG.
+CDE, GCSCAN.
+CDE, PVOLUM.
+CDE, CELOSS.
      SAVE NID1
      DATA NID1/0/

      IF(ISWIT(9).NE.0) RETURN
      IF(SCANFL) THEN
         CALL GSCANO
      ELSE
         DLC = 0.
         DRC = 0.

         DO 10 I = 1,NL
            SEL1 (I) = SEL1 (I) + DEDL(I)
            SEL2 (I) = SEL2 (I) + DEDL(I)**2

            DLC = DLC + DEDL(I)
            SEL1C(I) = SEL1C(I) + DLC
            SEL2C(I) = SEL2C(I) + DLC**2
   10    CONTINUE

         DO 20 I = 1,NR
            SER1 (I) = SER1 (I) + DEDR(I)
            SER2 (I) = SER2 (I) + DEDR(I)**2

            DRC = DRC + DEDR(I)
            SER1C(I) = SER1C(I) + DRC
            SER2C(I) = SER2C(I) + DRC**2
   20    CONTINUE

         DO 30 IPAT = 1,3
            DO 30 NPL = 1,NL
               SNPAT1(NPL,IPAT) = SNPAT1(NPL,IPAT) + FNPAT(NPL,IPAT)
               SNPAT2(NPL,IPAT) = SNPAT2(NPL,IPAT) + FNPAT(NPL,IPAT)**
     +         2
   30    CONTINUE

         ETOT = 100.*IEVENT*DLC/EINTOT
         CALL HFF1( 1,NID1, ETOT,1.)

      END IF

      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.2  1996/02/01 14:37:27  ravndal
* Clean up of the repository
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE GUSTEP
C.
C.    *
C.    *       User routine called at the end of each tracking step
C.    *       INWVOL is different from 0 when the track has reached
C.    *              a volume boundary
C.    *       ISTOP is different from 0 if the track has stopped
C.    *
C.
+CDE, GCBANK.
+CDE, GCTMED.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCFLAG.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCCUTS.
+CDE, GCONSP.
+CDE, GCSCAN.
+CDE, CELOSS.
+CDE, PVOLUM.
      DIMENSION NID(100)
      SAVE NID
      DATA NID/100*0/
C
+SELF, IF=-NEWFLUX.
      DATA NROLD / 1 /
+SELF.

      IF(SCANFL) THEN
         CALL GSCANU
      ELSE
C
C.
C              Something generated ?

         IF(NGKINE.GT.0) THEN
            DO 10 I=1,NGKINE
               ITYPA = GKIN(5,I)
               CALL GSKING(I)
               IF(ISWIT(9).NE.0)GO TO 10
+SELF, IF=CHECK.
               ID1=50+ITYPA
               CALL HFF1(ID1,NID(ID1),GKIN(4,I),1.)
               ID2=60+ITYPA
               CALL HFF1(ID2,NID(ID2),GKIN(4,I),1.)
+SELF.
   10       CONTINUE
         ENDIF
         IF(ISWIT(9).NE.0)GO TO 50
         IF(NUMED.EQ.2) THEN
            NRIN = NUMBER(NLEVEL)

C ***          Energy deposited
C
            IF(DESTEP.NE.0.)THEN
               NTUB = NUMBER(NLEVEL-1)
               DEDL(NRIN) = DEDL(NRIN) + DESTEP
               DEDR(NTUB) = DEDR(NTUB) + DESTEP
            ENDIF
C ***          Particle's flux
+SELF, IF=-NEWFLUX.
            IF(SLENG.LE.0.) NROLD = NRIN
            IF(NRIN.NE.NROLD) THEN
               NPL = (NRIN + NROLD)/2 + 1
               FNPAT(NPL,IPART) = FNPAT(NPL,IPART) + 1.
               NROLD = NRIN
            ENDIF
+SELF, IF=NEWFLUX.
            IF(INWVOL.EQ.1.AND.SLENG.GT.EPSIL)THEN
               DZ=20.*X0/FLOAT(NL)
               ZABS=VECT(3)+10.*X0
               ZABSM=MOD(ZABS,DZ)
               DELTA=0.5*EPSIL
               IF(ZABSM.GT.DZ-DELTA)THEN
                  NPL = NRIN+1
                  FNPAT(NPL,IPART) = FNPAT(NPL,IPART) + 1.
               ENDIF
               IF(ZABSM.LT.DELTA)THEN
                  NPL = NRIN
                  IF(NPL.EQ.0)NPL=1
                  FNPAT(NPL,IPART) = FNPAT(NPL,IPART) + 1.
               ENDIF
            ENDIF
+SELF.

+SELF, IF=CHECK.

C ***          Process calls frequency
C
            IF(NMEC.LE.0) GO TO 30
            DO 20 IM = 1,NMEC
               IF(LMEC(IM).GT.12) GO TO 20
               IDM = 30 + LMEC(IM)
               CALL HFF1(IDM,NID(IDM),GEKIN,1.)
   20       CONTINUE
   30       CONTINUE

+SELF.
C
C            If track is a photon extrapolate the track
C            directly to the next photon interaction
C            but still computing flux correctly
C
         ENDIF

+SELF, IF=CHECK.

C             Plot total track length

         IF(ISTOP.NE.0) THEN
            SLENRL = SLENG/X0
            ID3=20+IPART
            CALL HFF1(ID3,NID(ID3),SLENRL,1.)
         ENDIF

+SELF.


C             Debug event

  50     CALL GDEBUG
      END IF

      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE GUTREV
C.
C.    *
C.    *       User routine to control tracking of one event
C.    *
C.    *       Called by GRUN
C.    *
C.
      CALL GTREVE
C
      END
+DECK,  INCDEK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

+SELF.
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

+SELF, IF=-INTER.
      PROGRAM GEXAM1
C.
C.
C.         TEST PROGRAM FOR GEANT/SHOWER STUDIES
C.
C.         This program has been used to make the GEANT/EGS
C.         comparison.
C.              (see CERN/DD/85/1)
C.
C.         Authors    R.Brun, M.Maire  *********
C.
      COMMON/PAWC/H(10000)
      COMMON/GCBANK/Q(50000)
*
      CALL TIMEST(1E5)
*
      CALL GZEBRA(50000)
      CALL HLIMIT(-10000)
*
* ***          GEANT initialisation
      CALL UGINIT

*
* ***          Start events processing
      CALL GRUN
*
* ***          End of RUN
      CALL UGLAST

      END
+SELF.
+DECK,  UFILES, T=FORT.
* Revision 1.4  1997/05/23 13:06:52  mclareni
* Simplify the OPEN statements
* Revision 1.3  1997/04/25 12:33:16  mclareni
* Typing error ifndef CERNLIB+QFMSOFT corrected
* Revision 1.2  1997/04/10 15:33:16  mclareni
* Mods for WINNT
* Revision 1.1.1.1.2.1  1997/01/21 11:23:45  mclareni
* All mods for Winnt 96a on winnt branch
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
      CHARACTER*(*) FILNAM, FSTAT
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='gexam1.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GEXAM1 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='OLD')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
+SELF, IF=QFMSOFT.
      OPEN(UNIT=4,FILE=FILNAM,STATUS='OLD',FORM='FORMATTED')
+SELF, IF=VAX.
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,READONLY,FORM='FORMATTED')
+SELF, IF=-QFMSOFT, IF=-VAX.
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
+SELF.
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.2  1996/02/01 14:37:28  ravndal
* Clean up of the repository
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE UGEOM
C
C ***          Define user geometry set up
C

+CDE, GCBANK.
+CDE, GCKINE.
+CDE, PVOLUM.

      DIMENSION PAR( 8)
      DIMENSION ZLG(6),ALG(6),WLG(6)
      DIMENSION A(3),Z(3),WMAT(3)
      DIMENSION AF(3),ZF(3),WMATF(3)
C
C             Lead glass mixture parameters
C
      DATA ZLG/  82.00,  19.00,  14.00,  11.00,  8.00,  33.00/
      DATA ALG/ 207.19,  39.102,  28.088,  22.99, 15.999,  74.922/
      DATA WLG/ .65994, .00799, .126676, .0040073,.199281, .00200485/
C
C             BGO compound parameters
C
      DATA A/208.98,72.59,15.999/
      DATA Z/83.,32.,8./
      DATA WMAT/4.,3.,12./
C
C             Iron+Nickel+Crome  compound parameters
C
      DATA AF/55.847,58.71,51.998/
      DATA ZF/26.,28.,24./
      DATA WMATF/0.703964,0.099,0.197/
C
C ***          Defines USER particular materials
C
      CALL GSMATE( 9,'ALUMINIUM$', 26.98,13.,2.7   , 8.9,37.2,0,0)
      CALL GSMATE(11,'COPPER$   ', 63.54,29.,8.96  ,1.43,14.8,0,0)
      CALL GSMATE(13,'LEAD$     ',207.19,82.,11.35 ,0.56,18.5,0,0)
      CALL GSMATE(14,'URANIUM$  ',238.03,92.,18.95 ,0.32,12. ,0,0)
      CALL GSMATE(15,'AIR$      ', 14.61,7.3,0.001205,30423.,6750.,0,0)
      CALL GSMATE(16,'VACUUM$ ',1.E-16,1.E-16,1.E-16,1.E+16,1.E+16,0,0)
      CALL GSMIXT(10,'IRON(COMPOUND)$',AF,ZF,7.8,3,WMATF)
      CALL GSMIXT(21,'BGO(COMPOUND)$',A,Z,7.1,-3,WMAT)
      CALL GSMIXT(22,'LEAD GLASS$',ALG,ZLG,5.2,6,WLG)
C
C ***          Defines USER tracking media parameters
C
C

      FIELDM =  0.
      IFIELD =  0
      TMAXFD =  10.
      DMAXMS =  1.
      DEEMAX =  0.05
      EPSIL  =  0.001
      STMIN  =  0.001

      CALL GSTMED( 1,'DEFAULT MEDIUM AIR$'    , 15 , 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )


      CALL GSTMED( 2,'ABSORBER$'              ,IMAT, 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )


C
C ***          Defines USER'S VOLUMES
C
      NMED1  = 1
      NMED2  = 2
      JMA = LQ(JMATE-IMAT)
      X0 = Q(JMA + 9)
      XR     =  X0/4.

      R1     =  20.   * XR
      R2     =  21.   * XR

      Z1     =  10.    * X0
      Z2     =  11.    * X0


      PAR(1) = 0.
      PAR(2) = R2
      PAR(3) = Z2
      CALL GSVOLU( 'ECAL' , 'TUBE' ,NMED1, PAR , 3 , IVOL )

      PAR(1) = 0.
      PAR(2) = R2
      PAR(3) = 0.5 * X0
      CALL GSVOLU( 'LEAK' , 'TUBE' ,NMED1, PAR , 3 , IVOL )

      PAR(1) = R1
      PAR(2) = R2
      PAR(3) = Z1
      CALL GSVOLU( 'LATR' , 'TUBE' ,NMED1, PAR , 3 , IVOL )

      PAR(1) = 0.
      PAR(2) = R1
      PAR(3) = Z1
      CALL GSVOLU( 'BLOC' , 'TUBE' ,NMED2, PAR , 3 , IVOL )

C
C ***          Position volumes within ECAL
C

      ZC = 0.5 * (Z1 + Z2)
      CALL GSPOS( 'LEAK' ,1, 'ECAL' , 0.   , 0.   , -ZC  , 0,'ONLY')
      CALL GSPOS( 'LEAK' ,2, 'ECAL' , 0.   , 0.   , +ZC  , 0,'ONLY')
      CALL GSPOS( 'LATR' ,1, 'ECAL' , 0.   , 0.   , 0.   , 0,'ONLY')
      CALL GSPOS( 'BLOC' ,1, 'ECAL' , 0.   , 0.   , 0.   , 0,'ONLY')

      CALL GSDVN( 'RTUB' , 'BLOC' ,   NR , 1)
      CALL GSDVN( 'RING' , 'RTUB' ,   NL , 3)


C ***          Close geometry banks. (obligatory system routine)

      CALL GGCLOS

      END
+DECK,  UGINIT, T=FORT.
* Revision 1.4  1996/03/15 17:36:06  japost
* Small Parallel code correction
* Revision 1.3  1996/03/15 17:23:01  japost
* Addition of parallel code
* Revision 1.2  1996/02/01 14:37:29  ravndal
* Clean up of the repository
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE UGINIT
C.
C.    *
C.    *
C.    *        To initialise GEANT/USER  program and read data cards
C.    *
C.
+CDE, GCUNIT.
+CDE, GCLIST.
+CDE, GCKINE.
+CDE, PVOLUM.
+CDE, CELOSS.

+SELF, IF=PARA.
#if defined(MEIKO)
c     On the Meiko CS-2 reading from stdin-5 from multiple nodes
c       fails to give the same input: instead node 1 gets line 1,
c       node 2 gets line 2, and so on
c
c     Reset the FFREAD Input unit to the one in ufiles ...
c
      call ffset('LINP', 4 )
c          -----------------
#endif
+SELF.
C.
*
*             Open user files
*
      CALL UFILES
C.
C             Initialise GEANT
C
      CALL GINIT
      IMAT=10
      PKINE(1)=10.
      PKINE(2)=1.
      EINTOT=0.
      CALL VZERO(SEL1,640)
      NL=20
      NR=20
      CALL FFKEY('BINS',NL,2,'INTEGER')
      CALL FFKEY('MATE',IMAT,1,'INTEGER')
      CALL GFFGO
      CALL GZINIT
      CALL GPART
C
C             Prints version number
C
      WRITE(LOUT,10000)
C

C              Geometry and materials description

      CALL UGEOM
C
      CALL GLOOK('MATE',LPRIN,NPRIN,IM)
      CALL GLOOK('TMED',LPRIN,NPRIN,IT)
      CALL GLOOK('VOLU',LPRIN,NPRIN,IV)
      IF(IM.NE.0)CALL GPRINT('MATE',0)
      IF(IT.NE.0)CALL GPRINT('TMED',0)
      IF(IV.NE.0)CALL GPRINT('VOLU',0)

C              Energy loss and cross-sections initialisations

      CALL GPHYSI

C             Define user histograms

      CALL UHINIT

10000 FORMAT(/,'  GEXAM1 VERSION 1.00 ',/)

      END
+DECK,  UGLAST, T=FORT.
* Revision 1.4  1996/09/30 14:24:47  ravndal
* Windows NT related modifications
* Revision 1.3  1996/03/15 17:23:03  japost
* Addition of parallel code
* Revision 1.2  1996/02/01 14:37:29  ravndal
* Clean up of the repository
* Revision 1.1.1.1  1995/10/24 10:22:09  cernlib
* Geant

      SUBROUTINE UGLAST
C
C Termination routine to print histograms and statistics
C
+CDE, GCFLAG.
+CDE, PVOLUM.
+CDE, CELOSS.
      COMMON/SCLAST/XSEL1(40),XSEL2(40),XSEL1C(40),XSEL2C(40)
     +             ,XSER1(40),XSER2(40),XSER1C(40),XSER2C(40)

      DIMENSION PAT1(50),PAT2(50)
      CHARACTER*(*) FILNAM, FSTAT
      INTEGER IDVEC(100),IDN
      INTEGER ENTR
      REAL MEAN,RMS
      REAL DEF(100,2)
C
C     Control values, which have been obtained
C     using:
C     HP 720 running HP-UX 9
C     GEANT 3.21/02, CERNLIB release 94A
C
      DATA ((DEF(I,J),J=1,2),I=1,8)
     +        /94.20  ,1.0208,
     +         10.1478,3.8322,
     +          4.1152,3.8059,
     +         14.6771,4.1214,
     +         11.8910,5.4774,
     +         11.4431,3.8798,
     +         10.0794,3.6276,
     +         10.3324,3.6949/
C
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='ginst1.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GINST1 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='UNKNOWN')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
C
      CALL GLAST
C
C Normalize and print energy distribution
C
      CALL VZERO(XSEL1,320)
      CALL VZERO(PAT1,50)
      CALL VZERO(PAT2,50)
C
      IF (EINTOT.NE.0.0) THEN
          CNORM  = 100./EINTOT
      ELSE
          CNORM = 0.0
      END IF
C
      XEVENT=IEVENT
C
      DO 10 I = 1,NL
      XSEL1 (I) = CNORM * SEL1 (I)
      XSEL2 (I) = CNORM*SQRT(ABS(XEVENT*SEL2 (I) - SEL1 (I)**2))

      XSEL1C(I) = CNORM * SEL1C(I)
      XSEL2C(I) = CNORM*SQRT(ABS(XEVENT*SEL2C(I) - SEL1C(I)**2))
   10 CONTINUE

      CALL HPAK (2,XSEL1 )
      CALL HPAKE(2,XSEL2 )

      CALL HPAK (4,XSEL1C)
      CALL HPAKE(4,XSEL2C)

      DO 20 I = 1,NR
      XSER1 (I) = CNORM * SER1 (I)
      XSER2 (I) = CNORM*SQRT(ABS(XEVENT*SER2 (I) - SER1 (I)**2))

      XSER1C(I) = CNORM * SER1C(I)
      XSER2C(I) = CNORM*SQRT(ABS(XEVENT*SER2C(I) - SER1C(I)**2))
   20 CONTINUE

      CALL HPAK (3,XSER1 )
      CALL HPAKE(3,XSER2 )

      CALL HPAK (5,XSER1C)
      CALL HPAKE(5,XSER2C)

      DO 40 IP = 1,3
      DO 30 I  = 1,NL
          IF (XEVENT .NE. 0.0) THEN
              PAT1(I) = SNPAT1(I,IP) / XEVENT
              PAT2(I) = SQRT(SNPAT2(I,IP)/XEVENT - PAT1(I)**2)
          ELSE
              PAT1(I) = 0.0
              PAT2(I) = 0.0
          END IF
   30 CONTINUE
      CALL HPAK (10+IP,PAT1)
      CALL HPAKE(10+IP,PAT2)
   40 CONTINUE
C
C     Create a output file on unit 99 for the default installation
C     test run
C     The test consists of 10 events of 10 GeV photons
C
      OPEN(UNIT=99,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
C
      WRITE(99,15000)
      WRITE(99,15001)
      WRITE(99,15002)
      WRITE(99,15003)
      WRITE(99,15004)
      WRITE(99,15005)
      WRITE(99,15006)
C
      CALL HID1(IDVEC,IDN)
      IF(IDN.GE.1.AND.IDN.LE.100) THEN
C
          CALL HNOENT(1,ENTR)
          WRITE(99,20000) ENTR
          DO I=1,IDN
              MEAN = HSTATI(IDVEC(I),1,' ',0)
              RMS  = HSTATI(IDVEC(I),2,' ',0)
              WRITE(99,20100) IDVEC(I)
              WRITE(99,20200) MEAN,RMS
              WRITE(99,20300) DEF(I,1),DEF(I,2)
          END DO
      END IF
C
      CLOSE(99)
C
      PRINT 10000
      PRINT 10200,( XSEL2 (I),I=1,NL)
      PRINT 10300,( XSEL2C(I),I=1,NL)
      PRINT 10100
      PRINT 10200,( XSER2 (I),I=1,NR)
      PRINT 10300,( XSER2C(I),I=1,NR)
10000 FORMAT(/,1x,'LONGITUDINAL PROFIL',/)
10100 FORMAT(/,1x,'   RADIAL PROFIL   ',/)
10200 FORMAT(/,1X,'ERROR ON PROFIL     VALUES',/
     +         ,(5X,10F10.4))
10300 FORMAT(//,1X,'ERROR ON CUMULATIVE VALUES',/
     +         ,(5X,10F10.4))
C
15000 FORMAT(/,'                   GEANT Installation control file')
15001 FORMAT('                   _______________________________')
15002 FORMAT('The default values were obtained using:')
15003 FORMAT(/,3X,'GEANT Version 3.21/02')
15004 FORMAT(3X,'CERNLIB release 94A')
15005 FORMAT(3X,'HP 720 running HP-UX 9')
15006 FORMAT(3X,'Date: 11 Oct 1994')
20000 FORMAT(/,1x,'Number of Entries ',I6,20X,'Mean',6X,'RMS')
20100 FORMAT(/,1x,'Histogram Id: ',I3)
20200 FORMAT(1X,'Mean Entry value/R.M.S           :'
     +         ,(5X,2F10.4))
20300 FORMAT(1X,'Default values of GEANT 3.21/02  :'
     +         ,(5X,2F10.4))

+SELF, IF=-PARA.
C
C Save histograms to file
C
      CALL HRPUT(0,'gexam1.hbook',' ')
C
      CALL HISTDO()
+SELF, IF=PARA.
C     Save histograms
C
c     Gpsumhr is a replacement for hrput that saves histograms into a file,
c      summing the contribution from each node in the subdirectory 'totals',
c      and also storing each node's contribution separately elsewhere.
c     It has the same arguments as hrput: (histogramid, filename, options).
c
      call gpsumhr(0,'gexam3.hist',' ')
      call gprocs( nsize, nrank, nleader )
      if ( nrank .eq. nsize-1 ) then
          CALL HISTDO
      endif

c     The call to gplast will TERMINATE parallel GEANT.
c     It cleans up the parallel environment.
c     The program will not return from this call.

      call gplast
+SELF.
C
      END
+DECK,  UHINIT, T=FORT.
* Revision 1.2  1996/02/01 14:37:30  ravndal
* Clean up of the repository
* Revision 1.1.1.1  1995/10/24 10:22:10  cernlib
* Geant

      SUBROUTINE UHINIT
C
C     *       To book the user's histograms
C     *

+CDE, PVOLUM.

C
C ***            Histograms for shower development
C
      NBINZ=NL+1
      NBINR=NR+1
      ZMAX=NBINZ+1
      RMAX=NBINR+1
C
      CALL HBOOK1(1,'TOTAL ENERGY DEPOSITION$'
     *,100, 81.,101., 0.0)
      CALL HBOOK1(2,'LONGIT ENERGY DEPOSITION $'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(4,'CUMUL LONGIT ENERGY DEP. $'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(3,'RADIAL ENERGY DEPOSITION $'
     *, NBINR, 1.,RMAX,  0.0)
      CALL HBOOK1(5,'CUMUL RADIAL ENERGY DEP. $'
     *, NBINR, 1.,RMAX,  0.0)
      CALL HBOOK1(11,'NB OF GAMMA PER PLANE$'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(12,'NB OF E +   PER PLANE$'
     *, NBINZ, 1.,ZMAX,  0.0)
      CALL HBOOK1(13,'NB OF E -   PER PLANE$'
     *, NBINZ, 1.,ZMAX,  0.0)

      CALL HBIGBI(0,4)


+SELF, IF=CHECK.
C
C ***          Histograms for detailed studies
C
      CALL HBOOK1(21,'TOTAL GAMMA LENGHT IN RL$'
     *,100, 0.,  10. , 0.)
      CALL HBOOK1(22,'TOTAL POSIT LENGHT IN RL$'
     *,100, 0., 5.   , 0.)
      CALL HBOOK1(23,'TOTAL ELECT LENGHT IN RL$'
     *,100, 0., 5.   , 0.)

      CALL HBOOK1(31,'NUMBER OF NEXT CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(32,'NUMBER OF MULS CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(33,'NUMBER OF LOSS CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(34,'NUMBER OF FIEL CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(35,'NUMBER OF DCAY CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(36,'NUMBER OF PAIR CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(37,'NUMBER OF COMP CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(38,'NUMBER OF PHOT CALLS$'
     *,100, 0., 0.01, 0.)
      CALL HBOOK1(39,'NUMBER OF BREM CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(40,'NUMBER OF DRAY CALLS$'
     *,100, 0., 0.1, 0.)
      CALL HBOOK1(41,'NUMBER OF ANNI CALLS$'
     *,100, 0., 0.01, 0.)

      CALL HBOOK1(51,'ENERGY DISTR OF GAMMAS$'
     *,100,0.,0.1,0.)
      CALL HBOOK1(52,'ENERGY DISTR OF POSITRONS$'
     *,100,0.,0.1,0.)
      CALL HBOOK1(53,'ENERGY DISTR OF ELECTRONS$'
     *,100,0.,0.1,0.)
      CALL HBOOK1(61,'ENERGY DISTR OF GAMMAS$'
     *,100,0.,0.01,0.)
      CALL HBOOK1(62,'ENERGY DISTR OF POSITRONS$'
     *,100,0.,0.01,0.)
      CALL HBOOK1(63,'ENERGY DISTR OF ELECTRONS$'
     *,100,0.,0.01,0.)

+SELF.


      END
+PATCH, EXAMPLES_GEXAM4.
+KEEP, URMIPS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant
* urmips.inc
      COMMON/URMIPS/XMIP,NTXMIP,TXMIP,TXMIP2,CALIB1,CALIB2,XKPL(60,8),
     *              XPHMIP(20,34),IDSTW
C
*
* urmips.inc
*
+KEEP, URMIPS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant
* urmips.inc
*
* urmips.inc
*
+CDE, INCBEG.
     +   urmips
+CDE, INCEND.
+KEEP, URGEOM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant
* urgeom.inc
      COMMON/URGEOM/UTHICK,CSHIEL,ESHIEL,BTHICK,AIRGP1,CTHICK,AIRGP2,
     *              AIRGP3,EPCHAM,HMODL1,HSECT1,HMODL2,HSECT2,HMODL3,
     *              HSECT3,HLCALO,WGS1,WGS2,IGAST
C
*
* urgeom.inc
*
+KEEP, URGEOM, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant
* urgeom.inc
*
* urgeom.inc
*
+CDE, INCBEG.
     +   urgeom
+CDE, INCEND.
+DECK,  EXAM4, T=DATA.
LIST
TRIGGER  10000
DEBUG 0 0 1
SWIT 6=1         (FREQUENCY TO CALL PXMIPS)
DRAY 1
LOSS 3
PFIS 1
CUTS 0.0001 0.0001 0.0001 0.0001 0.001  ( CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO)
GAST 1           (GAS TYPE)
KINE 109 10. 0. 0.      (PARTICLE TYPE, ENERGY,THETA,PHI)
TIME 2=10.       (TIME LEFT FOR UGLAST)
END
+DECK,  G321X4_INP_D, T=DATA, IF=DOC.
READ 4
TRIGGER 300
HADR 4
TIME 2=60.
C   CUTS 2*2e-5 3*5e-5
STOP
+DECK,  GPHXSD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:16  cernlib
* Geant

      SUBROUTINE GPHXSD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Debugs  PHXS bank containing x-section constants              *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCPMXZ.
+CDE, GCPHXS.
+CDE, GC10EV.
      CHARACTER*20 CHTMED, CHMATE
*
* Loop over material
      DO 10 ITM=1,IQ(JTMED-2)
         JTM=LQ(JTMED-ITM)
         IF(JTM.GT.0) THEN
            IMA=Q(JTM+6)
            JMA=LQ(JMATE-IMA)
            CALL UHTOC(IQ(JTM+1),4,CHTMED,20)
            CALL UHTOC(IQ(JMA+1),4,CHMATE,20)
            WRITE(6,10000) CHTMED(:LNBLNK(CHTMED)),
     +      CHMATE(:LNBLNK(CHMATE))
            JPHOT = LQ(JMA-6)
            JPHXS=LQ(JPHOT-1)
            NZ=Q(JPHXS+1)
            NIT=Q(JPHXS+3*NZ+2)
            WRITE(6,10100) NZ
            WRITE(6,10200) (Q(JPHXS+1+IZ),Q(JPHXS+1+2*NZ+IZ),IZ=1,NZ)
            WRITE(6,10300)(IT+1,(Q(JPHXS+3*NZ+2+5*IT+IP),IP=1,5),IT=0,
     +      NIT- 1)
         ENDIF
   10 CONTINUE
10000 FORMAT(' Tracking medium : ',A,' Material : ',A)
10100 FORMAT(1X,I3,' elements in this material with ',I3,
     +       ' energy intervals')
10200 FORMAT('    Z    = ',F5.2,'    Weight   = ',F5.2)
10300 FORMAT((' Int. N. ',I2,' E= ',E11.4,' K= ',4(E11.4,',')))
      END
+DECK,  GUHADR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE GUHADR
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to generate one hadronic interaction        *
C.    *                                                                *
C.    *    ==>Called by : GTHADR,GTNEUT                                *
C.    *                                                                *
C.    ******************************************************************
*======================================================================*
*                                                                      *
*   An interface with a part of the FLUKA shower code is available in  *
*   GEANT 3.21. The following conditions and warnings must be taken    *
*   into account when using the FLUKA routines.                        *
*                                                                      *
*======================================================================*
*======================================================================*
*                                                                      *
*                   FFFF   L      U  U  K  K   AA                      *
*                   F      L      U  U  K K   A  A                     *
*                   FFF    L      U  U  KK    AAAA                     *
*                   F      L      U  U  K K   A  A                     *
*                   F      LLLL    UU   K  K  A  A                     *
*                                                                      *
*                   (C) Copyright of the authors                       *
*                                                                      *
*             A. Fasso'*, A. Ferrari#, J. Ranft$, P.R. Sala#           *
*                                                                      *
*               *: CERN, #: INFN -Milan, $: CERN/Frascati              *
*                                                                      *
*                (e-mail: FERRARIA@CERNVM.CERN.CH)                     *
*                                                                      *
*======================================================================*
*                                                                      *
*   - All the rights concerning FLUKA or parts of it are only of the   *
*     authors and are independent from those of the GEANT code         *
*                                                                      *
*   - FLUKA [1-6] is a standalone code capable of simulating the inter-*
*     action and transport of all components of EM and hadronic cas-   *
*     cades up to several TeV. However, only cross sections and        *
*     models for hadronic elastic and inelastic interactions (end 1992 *
*     status) are included in this GEANT version.                      *
*                                                                      *
*   - The most recent FLUKA model [4,6] for nucleon and pion interac-  *
*     tions in the intermediate energy range is not fully implemented  *
*     in GEANT. Only a simplified version, limited to p and n below    *
*     250 MeV, is available in GEANT 3.21. A coarser model is used for *
*     other projectiles in this energy range. However the implemented  *
*     parts should be adequate for most detector simulations and sim-  *
*     ilar applications for which GEANT is generally used. Their accu- *
*     racy could be insufficient for some nuclear physics studies or   *
*     demanding simulations at low energies, where the more sophistic- *
*     ated models [4,6] could be required.                             *
*                                                                      *
*   - The performances of GEANT-FLUKA are therefore not representative *
*     of those of FLUKA standalone and should be referenced as such    *
*     rather than simply GEANT or FLUKA.                               *
*                                                                      *
*   - The authors reserve the right of publishing about the physical   *
*     models developed for FLUKA. Running the FLUKA routines in isol-  *
*     ation for benchmarks (or equivalent use) is not permitted,       *
*     except after consultations or in collaboration with the authors. *
*                                                                      *
*   - The FLUKA routines are supposed to be included and used in       *
*     GEANT only. Any other use must be authorized by the authors.     *
*                                                                      *
*   - References: at least reference [5] should be always quoted when  *
*                 reporting results obtained with GEANT-FLUKA          *
*                                                                      *
* [1] A. Fasso', A. Ferrari, J. Ranft, P. R. Sala, G. R. Stevenson and *
*     J. M. Zazula, "FLUKA92", presented at the workshop on "Simulat-  *
*     ing Accelerator Radiation Environment", SARE, Santa Fe, 11-15    *
*     january (1993), Proceedings in press.                            *
*                                                                      *
* [2] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, Proc. MC93 Int. Conf. *
*     on Monte-Carlo Simulation in High-Energy and Nuclear Physics,    *
*     Tallahassee, Florida, 22-26 february (1993), World Scientific,   *
*     p. 88 (1994).                                                    *
*                                                                      *
* [3] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, ibidem, p. 100 (1994) *
*                                                                      *
* [4] A. Ferrari and P.R. Sala, ibidem, p. 277 (1994).                 *
*                                                                      *
* [5] A. Fasso', A. Ferrari, J. Ranft and P.R. Sala, "FLUKA: present   *
*     status and future developments", presented at the IV Int. Conf.  *
*     on Calorimetry in High Energy Physics, La Biodola (Elba),        *
*     September 19-25 1993, Proceedings in press.                      *
*                                                                      *
* [6] A. Fasso', A. Ferrari, J. Ranft, and P.R. Sala, "FLUKA: Perf-    *
*     ormances and Applications in the Intermediate Energy Range",     *
*     presented at the "Specialists' Meeting on Shielding Aspects of   *
*     Accelerators, Targets & Irradiation Facilities", Arlington,      *
*     April 28-29 1994, Proceedings in press.                          *
*                                                                      *
*======================================================================*
C.
+CDE, GCPHYS.
C.
C.    ------------------------------------------------------------------
C.
C
C          GHEISHA only if IHADR<3 (default)
C
      IF (IHADR.NE.4) THEN
         CALL GHEISH
      ELSE
         CALL FLUFIN
      ENDIF
      END
+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/01 15:00:34  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE GUKINE
*
************************************************************************
*                                                                      *
*             GEANT3 user routine to generate Kinematics               *
*               for primary tracks                                     *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCONSP.
+CDE, URGEOM.
+CDE, URMIPS.
      DIMENSION VERTEX(6),PLAB(3),RNDM(2)
*
*     -----------------------------------------------------------------
*
      XMIP=0.
      CALL VZERO(VERTEX,6)
      VERTEX(1)=0.04
      VERTEX(2)=0.04
      VERTEX(3)=-HLCALO+.01
      IF(IKINE.GT.100)THEN
         IK=IKINE-100
         THETA=PKINE(2)*DEGRAD
         PHI=PKINE(3)*DEGRAD
      ELSE
         IK=IKINE
         CALL GRNDM(RNDM,2)
         THETA=PI*RNDM(1)
         PHI=TWOPI*RNDM(2)
      ENDIF
C
      PLAB(1) = PKINE(1)*SIN(THETA)*COS(PHI)
      PLAB(2) = PKINE(1)*SIN(THETA)*SIN(PHI)
      PLAB(3) = PKINE(1)*COS(THETA)
C
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
      CALL GSKINE(PLAB,IK,NVERT,0,0,NT)
*
*              Kinematic debug (controled by ISWIT(1))
*
      IF(IDEBUG.EQ.1.AND.ISWIT(1).EQ.1) THEN
        CALL GPRINT('VERT',0)
        CALL GPRINT('KINE',0)
      ENDIF
*
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/01 15:00:35  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE GUOUT
*
************************************************************************
*                                                                      *
*             GEANT3 user routine called at the end of each event.     *
*                                                                      *
************************************************************************
*
*
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, URMIPS.
      SAVE N10
      DATA N10/0/
*
*     ------------------------------------------------------------------
*
      NTXMIP=NTXMIP+1
      TXMIP=TXMIP+XMIP
      TXMIP2=TXMIP2+XMIP*XMIP
      CALL HFF1(10,N10,XMIP,1.)
*
      IF(ISWIT(6).NE.0)THEN
         IS6=ISWIT(6)
         IF(MOD(IEVENT,IS6).EQ.0)CALL PXMIPS
      ENDIF
*
      END
+DECK,  GUPHAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE GUPHAD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to compute Hadron. inter. probabilities     *
C.    *                                                                *
C.    *    ==>Called by : GTHADR,GTNEUT                                *
C.    *                                                                *
C.    ******************************************************************
*
*======================================================================*
*                                                                      *
*   An interface with a part of the FLUKA shower code is available in  *
*   GEANT 3.21. The following conditions and warnings must be taken    *
*   into account when using the FLUKA routines.                        *
*                                                                      *
*======================================================================*
*======================================================================*
*                                                                      *
*                   FFFF   L      U  U  K  K   AA                      *
*                   F      L      U  U  K K   A  A                     *
*                   FFF    L      U  U  KK    AAAA                     *
*                   F      L      U  U  K K   A  A                     *
*                   F      LLLL    UU   K  K  A  A                     *
*                                                                      *
*                   (C) Copyright of the authors                       *
*                                                                      *
*             A. Fasso'*, A. Ferrari#, J. Ranft$, P.R. Sala#           *
*                                                                      *
*               *: CERN, #: INFN -Milan, $: CERN/Frascati              *
*                                                                      *
*                (e-mail: FERRARIA@CERNVM.CERN.CH)                     *
*                                                                      *
*======================================================================*
*                                                                      *
*   - All the rights concerning FLUKA or parts of it are only of the   *
*     authors and are independent from those of the GEANT code         *
*                                                                      *
*   - FLUKA [1-6] is a standalone code capable of simulating the inter-*
*     action and transport of all components of EM and hadronic cas-   *
*     cades up to several TeV. However, only cross sections and        *
*     models for hadronic elastic and inelastic interactions (end 1992 *
*     status) are included in this GEANT version.                      *
*                                                                      *
*   - The most recent FLUKA model [4,6] for nucleon and pion interac-  *
*     tions in the intermediate energy range is not fully implemented  *
*     in GEANT. Only a simplified version, limited to p and n below    *
*     250 MeV, is available in GEANT 3.21. A coarser model is used for *
*     other projectiles in this energy range. However the implemented  *
*     parts should be adequate for most detector simulations and sim-  *
*     ilar applications for which GEANT is generally used. Their accu- *
*     racy could be insufficient for some nuclear physics studies or   *
*     demanding simulations at low energies, where the more sophistic- *
*     ated models [4,6] could be required.                             *
*                                                                      *
*   - The performances of GEANT-FLUKA are therefore not representative *
*     of those of FLUKA standalone and should be referenced as such    *
*     rather than simply GEANT or FLUKA.                               *
*                                                                      *
*   - The authors reserve the right of publishing about the physical   *
*     models developed for FLUKA. Running the FLUKA routines in isol-  *
*     ation for benchmarks (or equivalent use) is not permitted,       *
*     except after consultations or in collaboration with the authors. *
*                                                                      *
*   - The FLUKA routines are supposed to be included and used in       *
*     GEANT only. Any other use must be authorized by the authors.     *
*                                                                      *
*   - References: at least reference [5] should be always quoted when  *
*                 reporting results obtained with GEANT-FLUKA          *
*                                                                      *
* [1] A. Fasso', A. Ferrari, J. Ranft, P. R. Sala, G. R. Stevenson and *
*     J. M. Zazula, "FLUKA92", presented at the workshop on "Simulat-  *
*     ing Accelerator Radiation Environment", SARE, Santa Fe, 11-15    *
*     january (1993), Proceedings in press.                            *
*                                                                      *
* [2] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, Proc. MC93 Int. Conf. *
*     on Monte-Carlo Simulation in High-Energy and Nuclear Physics,    *
*     Tallahassee, Florida, 22-26 february (1993), World Scientific,   *
*     p. 88 (1994).                                                    *
*                                                                      *
* [3] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, ibidem, p. 100 (1994) *
*                                                                      *
* [4] A. Ferrari and P.R. Sala, ibidem, p. 277 (1994).                 *
*                                                                      *
* [5] A. Fasso', A. Ferrari, J. Ranft and P.R. Sala, "FLUKA: present   *
*     status and future developments", presented at the IV Int. Conf.  *
*     on Calorimetry in High Energy Physics, La Biodola (Elba),        *
*     September 19-25 1993, Proceedings in press.                      *
*                                                                      *
* [6] A. Fasso', A. Ferrari, J. Ranft, and P.R. Sala, "FLUKA: Perf-    *
*     ormances and Applications in the Intermediate Energy Range",     *
*     presented at the "Specialists' Meeting on Shielding Aspects of   *
*     Accelerators, Targets & Irradiation Facilities", Arlington,      *
*     April 28-29 1994, Proceedings in press.                          *
*                                                                      *
*======================================================================*
C.
C.
C.    ------------------------------------------------------------------
C.
+CDE, GCPHYS.
C
      IF (IHADR.NE.4) THEN
         CALL GPGHEI
      ELSE
         CALL FLDIST
      ENDIF
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.2  1996/02/01 15:00:36  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE GUSTEP
*
************************************************************************
*                                                                      *
*        GEANT3 user routine called at the end of each tracking step   *
*                                                                      *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCTMED.
+CDE, GCKING.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, URMIPS.
      DIMENSION X(13)
      SAVE KMOD2,KMOD3,N500,N5,N6,XMIPMA,TOMAX,IPLOLD,PLMIP,SSTEP,FIRST
      CHARACTER*4 CMOD2, CMOD3
      LOGICAL FIRST
      DATA FIRST /.TRUE./
      DATA CMOD2, CMOD3 / 'MOD2', 'MOD3' /
      DATA N500/0/
      DATA N5/0/
      DATA N6/0/
      DATA XMIPMA/70./
      DATA TOMAX/2.E-7/
*
*     -----------------------------------------------------------------
*
      IF(FIRST) THEN
         CALL UCTOH(CMOD2, KMOD2, 4, 4)
         CALL UCTOH(CMOD3, KMOD3, 4, 4)
         FIRST = .FALSE.
      ENDIF
      IF(SLENG.LE.0.)THEN
         IPLOLD=0
         PLMIP=0.
         SSTEP=0.
      ENDIF
*             Something generated ?
      IF(NGKINE.GT.0) THEN
        DO 5 I=1,NGKINE
          ITYPA  = GKIN(5,I)
          UPWGHT = ITYPA
          IF(ITYPA.NE.4)  CALL GSKING(I)
   5    CONTINUE
      ENDIF
*
*             Are we in the gas ?
*
      IF(NUMED.EQ.5)THEN
*
*             Evaluate average energy loss for muons
*
         IF(ITRTYP.EQ.5)THEN
            IF(DESTEP.GT.0..AND.GETOT.GT.0.3)THEN
               IF(STEP.GT.0.1)THEN
                  DEDX=DESTEP/STEP
                  CALL HFF1(500,N500,DEDX,1.)
               ENDIF
            ENDIF
         ENDIF
*
*             Compute number of MIPS
*
         IPL=NUMBER(3)
         IF(NAMES(3).EQ.KMOD2)IPL=IPL+64
         IF(NAMES(3).EQ.KMOD3)IPL=IPL+99
         IF(DESTEP.GT.0.)THEN
            IF(IPL.LE.64)THEN
               DXMIP=DESTEP/CALIB1
            ELSE
               DXMIP=DESTEP/CALIB2
            ENDIF
            IF(IPL.EQ.IPLOLD)THEN
               PLMIP=PLMIP+DXMIP
               SSTEP=SSTEP+STEP
            ELSE
               PLMIP=DXMIP
               SSTEP=STEP
               IPLOLD=IPL
            ENDIF
+SELF, IF=NTUPLE.
            X(1)=IEVENT
            X(2)=IPART
            X(3)=GEKIN
            X(4)=ISTOP
            X(5)=INWVOL
            X(6)=STEP
            X(7)=DESTEP
            X(8)=DXMIP
            X(9)=TOFG
            X(10)=IPL
            X(11)=PLMIP
            X(12)=SSTEP
            X(13)=0
            DO 10 JMEC=1,NMEC
               IF(LMEC(JMEC).EQ.109) X(13)=1
  10        CONTINUE
            CALL HFN(1,X)
+SELF.
            CALL HFF1(5,N5,DXMIP,1.)
            CALL HFF1(6,N6,DXMIP,1.)
            IF(PLMIP.LT.XMIPMA.AND.TOFG.LT.TOMAX)THEN
               XMIP=XMIP+DXMIP
            ENDIF
         ENDIF
*
*             Count number of particles crossing planes
*
         IF(INWVOL.EQ.1)THEN
            IF(MOD(IPL,2).EQ.0)THEN
               KPL=IPL/2
               XKPL(KPL,ITRTYP)=XKPL(KPL,ITRTYP)+1.
            ENDIF
         ENDIF
      ENDIF
*
*             Debug/plot event
*
      CALL GDEBUG
*     IF(ISTOP.NE.0) THEN
*        IF(IPART.EQ.13) THEN
*          CALL GDTRAK('R')
*        ELSE
*          CALL GDTRAK('DR')
*        ENDIF
*     ENDIF
*
      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE GUTREV
*
************************************************************************
*                                                                      *
*             GEANT3 user routine to control tracking of one event     *
*                                                                      *
*             Called by GRUN                                           *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
*
*     -----------------------------------------------------------------
*
      CALL GTREVE
*
*             Debug and plot tracks.
*
      IF(IDEBUG.EQ.1) THEN
        IF(ISWIT(2).EQ.1) CALL GPRINT('JXYZ', 0)
+SELF, IF=HIGZ.
        IF(ISWIT(3).EQ.1) THEN
          CALL GDSHOW(1)
          CALL GDXYZ (0)
          CALL ICLRWK(0,0)
        ENDIF
+SELF.
      ENDIF
*
      END
+DECK,  INCDEK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:15  cernlib
* Geant

+SELF.
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

+SELF, IF=-INTER.
      PROGRAM GEXAM4
*
************************************************************************
*                                                                      *
*             This program simulates the L3 test beam setup            *
*             as described in  PITHA 85/11                             *
*              Experimental results published in this report can be    *
*              reproduced by this program.                             *
*                                                                      *
*         ********    Authors    R.Brun, F.Carminati  *********        *
*                                                                      *
************************************************************************
*
+SELF, IF=-INTER, IF=NTUPLE.
      PARAMETER (NMEMOR=100000)
+SELF, IF=-INTER, IF=-NTUPLE.
      PARAMETER (NMEMOR=10000)
+SELF, IF=-INTER.
      COMMON/PAWC/H(NMEMOR)
      COMMON/GCBANK/Q(80000)
*
*     ------------------------------------------------------------------
*
      CALL TIMEST(1E5)
*
      CALL GZEBRA(80000)
      CALL HLIMIT(-NMEMOR)
*
*             Geant initialization
      CALL UGINIT
*
*             Test printings.
      CALL GPRINT('PART',0)
      CALL GPRINT('MATE',0)
      CALL GPRINT('TMED',0)
      CALL GPRINT('VOLU',0)
*
*             Start events processing
      CALL GRUN
*
*             End of run
      CALL UGLAST
*
      END
+SELF.
+DECK,  PXMIPS, T=FORT.
* Revision 1.2  1996/02/01 15:00:37  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:15  cernlib
* Geant

      SUBROUTINE PXMIPS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Print MIPS                                                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, URMIPS.
C
C              Compute average number of MIPS
C
      IF(NTXMIP.GT.0)THEN
         TXM=TXMIP/NTXMIP
         TXMRMS=SQRT(MAX(TXMIP2/NTXMIP - TXM*TXM,0.))
         PRINT 1000,IEVENT,XMIP,TXM,TXMRMS
 1000    FORMAT(' =====> IEVENT=',I5,' MIPS =',F7.1,
     +          '  TOTAL MIPS =',F7.1,' +-',F7.1)
      ENDIF
C
      END
+DECK,  UFILES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:15  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
      CHARACTER*(*) FILNAM, FSTAT
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='gexam4.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GEXAM4 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='OLD')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,
+SELF, IF=VAX.
     +     READONLY,
+SELF.
     +     FORM='FORMATTED')
*
*             Open a HBOOK direct access file
*
      CALL HROPEN(34,'HBOOK','gexam4.hist','N',1024,ISTAT)
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.2  1996/02/01 15:00:38  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:15  cernlib
* Geant

      SUBROUTINE UGEOM
*
************************************************************************
*                                                                      *
*             Routine to define the geometry of the set-up.            *
*                                                                      *
************************************************************************
*
+CDE, GCONSP.
+CDE, URGEOM.
*
      DIMENSION PAR(10),ABRASS(2),ZBRASS(2),WBRASS(2)
      DIMENSION AISOBU(3),ZISOBU(3),WGAS(3),ACO2(3),ZCO2(3)
      DIMENSION AURAN(2),ZURAN(2),WURAN(2)
      DATA AISOBU/12.01,1.01,39.95/
      DATA ZISOBU/6.,1.,18./
      DATA ACO2/12.01,16.01,39.95/
      DATA ZCO2/6.,8.,18./
      DATA ABRASS/63.54,65.37/
      DATA ZBRASS/29.,30./
      DATA WBRASS/.7,.3/
C
C             Uranium mixture
C
      DATA AURAN/235.,238./
      DATA ZURAN/92.,92./
      DATA WURAN/0.004,0.996/
*
*     -----------------------------------------------------------------
*
*
*             Defines materials
      CALL GSMATE( 1,'AIR$     ',  15.0,7.0,0.0012,30050.0,67500.0,0,0)
      CALL GSMATE( 2,'COPPER$  ', 63.54,29.,8.960 ,   1.43,   14.8,0,0)
      CALL GSMIXT( 3,'URANIUM$  ',AURAN,ZURAN,18.95 ,2,WURAN)
      CALL GSMATE( 4,'CARBON$  ', 12.01, 6., 2.265,  18.80,   49.9,0,0)
      CALL GSMIXT( 6,'BRASS$    ',ABRASS,ZBRASS,8.560   , 2,WBRASS)
*
      IF(IGAST.EQ.1)THEN
*
*             Argon/Isobuthane mixture (60% Ar and 40% Isobuthane)
*             First define Isobuthane compound and relative weights
*
         DISO   =0.00267
         DENS1  =0.002136
         WGAS(1)=4.
         WGAS(2)=10.
         CALL GSMIXT(15,'ISOBUTHAN$',AISOBU,ZISOBU,0.40*DISO,-2,WGAS)
         WGAS(1)=0.40*WGAS(1)
         WGAS(2)=0.40*WGAS(2)
         WGAS(3)=0.60
         CALL GSMIXT( 5,'ARG/ISOBU$',AISOBU,ZISOBU,DENS1, 3,WGAS)
      ELSE
*
*             Argon/CO2 mixture (10% Ar and 90% CO2)
*             First define CO2 compound and relative weights
*
         DENS2  =0.0019573
         DCO2   =0.001977
         WGAS(1)=1.
         WGAS(2)=2.
         CALL GSMIXT(15,'CO2$',ACO2,ZCO2,0.90*DCO2,-2,WGAS)
         WGAS(1)=0.90*WGAS(1)
         WGAS(2)=0.90*WGAS(2)
         WGAS(3)=0.10
         CALL GSMIXT( 5,'ARG/CO2$',ACO2,ZCO2,DENS2, 3,WGAS)
      ENDIF
*
*             Defines tracking media parameters.
      STEMAX =  BIG
      DEEMAX =  0.30
      EPSIL  =  0.005
      STMIN  =  0.1
*
      CALL GSTMED( 1, 'AIR$     ', 1, 0, 0, 0., 0., STEMAX,
     *            DEEMAX, EPSIL, STMIN, 0, 0)
*
      CALL GSTMED( 2, 'COPPER$  ', 2, 0, 0, 0., 0., STEMAX,
     *            DEEMAX, EPSIL, STMIN, 0, 0)
*
      CALL GSTMED( 3, 'URANIUM$ ', 3, 0, 0, 0., 0., STEMAX,
     *            DEEMAX, EPSIL, STMIN, 0, 0)
*
      CALL GSTMED( 4,'CARBON$   ', 4, 0, 0, 0., 0., STEMAX,
     *            DEEMAX, EPSIL, STMIN, 0, 0)
*
      CALL GSTMED( 5,'GAS$      ', 5, 0, 0, 0., 0., STEMAX,
     *            DEEMAX, EPSIL, STMIN, 0, 0)
*
      CALL GSTMED( 6,'BRASS$    ', 6, 0, 0, 0., 0., STEMAX,
     *            DEEMAX, EPSIL, STMIN, 0, 0)
*
      CALL GSTPAR(5,'STRA',1.)
      CALL GSTPAR(5,'DCUTE',5E-5)
*
*             Defines geometry of the set-up
*
*             Basic parameters
      UTHICK = 0.4
      CSHIEL = 0.1
      ESHIEL = 0.1
      WGS1   = 0.55
      WGS2   = 0.35
      BTHICK = 0.05
      AIRGP1 = 0.9
      CTHICK = 2.0
      AIRGP2 = 1.9
      EPCHAM = 1.6
      AIRGP3 = 1.7
      HMODL1 = (2.*CSHIEL+UTHICK+AIRGP1)*.5
      HSECT1 = HMODL1*64.
      HMODL2 = (2.*CSHIEL+UTHICK+AIRGP2)*.5
      HSECT2 = HMODL2*35.
      HMODL3 = (          CTHICK+AIRGP3)*.5
      HSECT3 = HMODL3*13.
      HLCALO = HSECT1+HSECT2+HSECT3+AIRGP1
*
*             Define the overall calorimeter
      PAR(1)=25.
      PAR(2)=25.
      PAR(3)=HLCALO
      CALL GSVOLU('CALO', 'BOX ', 1, PAR, 3, IVOLU)
*
*             Now define the three sections
      PAR(3)=HSECT1
      CALL GSVOLU('CAL1', 'BOX ', 1, PAR, 3, IVOLU)
      PAR(3)=HSECT2
      CALL GSVOLU('CAL2', 'BOX ', 1, PAR, 3, IVOLU)
      PAR(3)=HSECT3
      CALL GSVOLU('CAL3', 'BOX ', 1, PAR, 3, IVOLU)
*
*             and position them
      CALL GSPOS('CAL1',1,'CALO',0.0,0.0,
     * 0.5*AIRGP1-(HSECT2+HSECT3) ,0,'ONLY')
      CALL GSPOS('CAL2',1,'CALO',0.0,0.0,
     * 0.5*AIRGP1+HSECT1-HSECT3  ,0,'ONLY')
      CALL GSPOS('CAL3',1,'CALO',0.0,0.0,
     * 0.5*AIRGP1+HSECT1+HSECT2  ,0,'ONLY')
*
*             Now divide each section in modules
      CALL GSDVN('MOD1','CAL1',64,3)
      CALL GSDVN('MOD2','CAL2',35,3)
      CALL GSDVN('MOD3','CAL3',13,3)
*
*             Define copper shielding for type 1 and 2 modules
      PAR(3)=CSHIEL*.5
      CALL GSVOLU('SHIL', 'BOX ', 2, PAR, 3, IVOLU)
*
*             Define Uranium plate for type 1 and 2 modules
      PAR(3)=UTHICK*.5
      CALL GSVOLU('URPL', 'BOX ', 3, PAR, 3, IVOLU)
*
*             Define brass chamber for type 1 modules
      PAR(3)=(WGS1+BTHICK)*.5
      CALL GSVOLU('CHA1', 'BOX ', 6, PAR, 3, IVOLU)
      CALL GSDVN('TUB1','CHA1', 40, 2)
*
*             Define gas for chamber of type 1 modules
      PAR(1)=24.
      PAR(2)=1.2*.5
      PAR(3)=WGS1*.5
      CALL GSVOLU('GAS1', 'BOX ', 5, PAR, 3, IVOLU)
      CALL GSPOS('GAS1', 1, 'TUB1', 0.0, 0.0, 0.0, 0, 'ONLY')
*
*             Define epoxy wrapping for type 1 chambers
      PAR(1)=25.
      PAR(2)=25.
      PAR(3)=ESHIEL*.5
      CALL GSVOLU('EPO1', 'BOX ', 4, PAR, 3, IVOLU)
*
*             Define copper plate for type 3 modules
      PAR(3)=CTHICK*.5
      CALL GSVOLU('COPL', 'BOX ', 2, PAR, 3, IVOLU)
*
*             Define epoxy chamber for type 2 and 3 modules
      PAR(2)=47.*.5
      PAR(3)=EPCHAM*.5
      CALL GSVOLU('CHA2', 'BOX ', 4, PAR, 3, IVOLU)
      CALL GSDVN('TUB2', 'CHA2', 72, 2)
*
*             Define gas for chamber of type 2 and 3 modules
      PAR(1)=24.
      PAR(2)=(.65-.1)*.5
      PAR(3)=WGS2*.5
      CALL GSVOLU('GAS2', 'BOX ', 5, PAR, 3, IVOLU)
      CALL GSPOS('GAS2', 1, 'TUB2', 0.0, 0.0, 0.0, 0, 'ONLY')
*
*             Now position front chamber
      Z=-HLCALO+0.5*AIRGP1-(ESHIEL+WGS1+BTHICK)*0.5
      CALL GSPOS('EPO1',1,'CALO',0.0,0.0,Z,0,'ONLY')
      Z=-HLCALO+0.5*AIRGP1
      CALL GSPOS('CHA1',1,'CALO',0.0,0.0,Z,0,'ONLY')
      Z=-HLCALO+0.5*AIRGP1+(ESHIEL+WGS1+BTHICK)*0.5
      CALL GSPOS('EPO1',2,'CALO',0.0,0.0,Z,0,'ONLY')
*
*             Now assemble type 1 modules
      Z=CSHIEL*.5-HMODL1
      CALL GSPOS('SHIL',1,'MOD1',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL+UTHICK*.5-HMODL1
      CALL GSPOS('URPL',1,'MOD1',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL*1.5+UTHICK-HMODL1
      CALL GSPOS('SHIL',2,'MOD1',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL*2.+UTHICK+AIRGP1*.5-(WGS1+BTHICK+ESHIEL)*.5-HMODL1
      CALL GSPOS('EPO1',1,'MOD1',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL*2.+UTHICK+AIRGP1*.5-HMODL1
      CALL GSPOS('CHA1',1,'MOD1',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL*2.+UTHICK+AIRGP1*.5+(WGS1+BTHICK+ESHIEL)*.5-HMODL1
      CALL GSPOS('EPO1',2,'MOD1',0.0,0.0,Z,0,'ONLY')
*
*             Now assemble type 2 modules
      Z=CSHIEL*.5-HMODL2
      CALL GSPOS('SHIL',1,'MOD2',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL+UTHICK*.5-HMODL2
      CALL GSPOS('URPL',1,'MOD2',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL*1.5+UTHICK-HMODL2
      CALL GSPOS('SHIL',2,'MOD2',0.0,0.0,Z,0,'ONLY')
      Z=CSHIEL*2.+UTHICK+AIRGP2*.5-HMODL2
      CALL GSPOS('CHA2',1,'MOD2',0.0,0.0,Z,0,'ONLY')
*
*             Now assemble type 3 modules
      Z=CTHICK*.5-HMODL3
      CALL GSPOS('COPL',1,'MOD3',0.0,0.0,Z,0,'ONLY')
      Z=CTHICK+AIRGP3*.5-HMODL3
      CALL GSPOS('CHA2',1,'MOD3',0.0,0.0,Z,0,'ONLY')
*
*             Define geometry optimization
      CALL GSORD('CALO',3)
      CALL GSORD('MOD1',3)
      CALL GSORD('MOD2',3)
      CALL GSORD('MOD3',3)
*
*             Close geometry banks. Mandatory system routine.
*
      CALL GGCLOS
*
      END
+DECK,  UGINIT, T=FORT.
* Revision 1.2  1996/02/01 15:00:39  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:15  cernlib
* Geant

      SUBROUTINE UGINIT
*
************************************************************************
*                                                                      *
*          To initialise GEANT3 program and read data cards            *
*                                                                      *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, URGEOM.
+CDE, URMIPS.
*
*     -----------------------------------------------------------------
*
*             Open user files
*
      CALL UFILES
*
*             Initialize GEXAM4 global variables
*
      IGAST = 1
      IDSTW = 0
      NTXMIP= 0
      TXMIP = 0.
      TXMIP2= 0.
      CALL VZERO(XKPL,300)
*
*             Initialize GEANT
      CALL GINIT
*
*             Prints version number
      WRITE(LOUT,1000)
*
*             Define a data card 'GAST' to change gas type
*
      CALL FFKEY('GAST',IGAST,1,'INTEGER')
*
*             Define a data card to fill and write the PH matrix
*
      CALL FFKEY('DSTW',IDSTW,1,'INTEGER')
*
*             Read data cards with FFREAD
*
      CALL GFFGO
*
*             Initialize GEANT/ZBOOK data structures
      CALL GZINIT
*
+SELF, IF=HIGZ.
*
*             Initialize drawing package
      IF(ISWIT(7).EQ.0)THEN
         CALL GDINIT
      ENDIF
+SELF.
*
*             Geometry and materials description.
      CALL UGEOM
*
*             Particle table definition and energy loss initialization.
      CALL GPART
      CALL GPHYSI
*
*             Compute calibration factors for the 2 types of chambers.
*             Calibration is obtained with minimum ionizing muons
*             of 500 MeV in material 5 (Argon/Isobuthane or Argon/CO2)
*
      JMA    = LQ(JMATE-5)
      JMULOS = LQ(JMA-2)
      DEDX   = Q(JMULOS+45)
      CALIB1 = DEDX*WGS1
      CALIB2 = DEDX*WGS2
*
+SELF, IF=HIGZ.
*
*             Create a view bank
      IF(ISWIT(7).EQ.0)CALL VIEWYZ(1)
+SELF.
      CALL UHINIT
*
 1000 FORMAT(/,' **** GEXAM4 VERSION 1.17.00 ( 10 May 1988 ) ',/)
*
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.2  1996/02/01 15:00:40  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:15  cernlib
* Geant

      SUBROUTINE UGLAST
*
************************************************************************
*                                                                      *
*       Termination routine to print histograms and statistics         *
*                                                                      *
************************************************************************
*
+CDE, URMIPS.
      CHARACTER*(*) FILNAM, FSTAT
      INTEGER IDVEC(100),IDN
      INTEGER ENTR
      REAL MEAN,RMS
      REAL DEF(100,2)
C
C
C     Control values, which have been obtained
C     using:
C     HP 720 running HP-UX 9
C     GEANT 3.21/02, CERNLIB release 94A
C
      DATA ((DEF(I,J),J=1,2),I=1,8)
     +        /   1.6442, 4.6370,
     +             .7328,  .4808,
     +          434.9000,97.2505,
     +           14.8803,10.3263,
     +           14.1464,10.3052,
     +           16.4515,10.7111,
     +           25.5833,13.5577,
     +             .0000,  .0000/
C
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='g_install4.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/G_INSTALL4 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='UNKNOWN')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
*     -----------------------------------------------------------------
*
      CALL GLAST
*
      CALL PXMIPS
*
      CALL HNOENT(10,NOENT)
C
      DO 20 I=1,5
         IF(NOENT.GT.0)THEN
            DO 10 J=1,60
              XKPL(J,I)=XKPL(J,I)/FLOAT(NOENT)
  10        CONTINUE
         ENDIF
         CALL HPAK(100+I,XKPL(1,I))
  20  CONTINUE
C
C
C     Create a output file on unit 99 for the default installation
C     test run
C     The test consists of 10 events of 10 GeV photons
C
      OPEN(UNIT=99,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
C
      WRITE(99,15000)
      WRITE(99,15001)
      WRITE(99,15002)
      WRITE(99,15003)
      WRITE(99,15004)
      WRITE(99,15005)
      WRITE(99,15006)
C
      CALL HID1(IDVEC,IDN)
      IF(IDN.GE.1.AND.IDN.LE.100) THEN
C
          CALL HNOENT(1,ENTR)
          WRITE(99,20000) ENTR
          DO I=1,IDN
              MEAN = HSTATI(IDVEC(I),1,' ',0)
              RMS  = HSTATI(IDVEC(I),2,' ',0)
              WRITE(99,20100) IDVEC(I)
              WRITE(99,20200) MEAN,RMS
              WRITE(99,20300) DEF(I,1),DEF(I,2)
          END DO
      END IF
C

      CLOSE(99)
C
C             Save histograms
C
      CALL HROUT(0,ICYCLE,' ')
      CALL HREND('HBOOK')
*
*             Print HBOOK histograms
      CALL HPRINT(0)
+SELF, IF=HIGZ.
*
*             Close GKS display file
      CALL IGEND
+SELF.
*
15000 FORMAT(/,'                   GEANT Installation control file')
15001 FORMAT('                   _______________________________')
15002 FORMAT(/,'The default values were obtained using:')
15003 FORMAT(/,3X,'GEANT Version 3.21/02')
15004 FORMAT(3X,'CERNLIB release 94A')
15005 FORMAT(3X,'HP 720 running HP-UX 9')
15006 FORMAT(3X,'Date: 11 Oct 1994')
20000 FORMAT(/,1x,'Number of Entries ',I6,20X,'Mean',6X,'RMS')
20100 FORMAT(/,1x,'Histogram Id: ',I3)
20200 FORMAT(1X,'Mean Entry value/R.M.S           :'
     +         ,(5X,2F10.4))
20300 FORMAT(1X,'Default values of GEANT 3.21/02  :'
     +         ,(5X,2F10.4))
      END
+DECK,  UHINIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:15  cernlib
* Geant

      SUBROUTINE UHINIT
*
************************************************************************
*                                                                      *
*             To book the user's histograms                            *
*                                                                      *
************************************************************************
*
+CDE, GCKINE.
+SELF, IF=NTUPLE.
      PARAMETER (NKEYS=13)
      CHARACTER*8 CHNAME(NKEYS)
      DATA CHNAME/'IEVENT  ','IPART   ','GEKIN   ','ISTOP   ','INWVOL  '
     +           ,'STEP    ','DESTEP  ','DXMIP   ','TOFG    ','IPL     '
     +           ,'PLMIP   ','SSTEP   ','THINLA  '/
+SELF.
*
*     ------------------------------------------------------------------
*
      XMIN=0.
      XMAX=100.*PKINE(1)
+SELF, IF=NTUPLE.
      CALL HBOOKN(1,'NTUPLE',NKEYS,'//HBOOK',9950,CHNAME)
+SELF.
      CALL HBOOK1(5,'PULSE HEIGHT DISTRIBUTION IN MIPS$',100,0.,100.,0.)
      CALL HBOOK1(6,'PULSE HEIGHT DISTRIBUTION IN MIPS$',100,0.,2.,0.)
      CALL HBOOK1(10,'NUMBER OF MIPS PER EVENT$',100,XMIN,XMAX,0.)
      CALL HBOOK1(101,'NUMBER OF PHOTONS PER PLANE$',60,1.,60.,0.)
      CALL HCOPY(101,102,'NUMBER OF ELECTRONS+POSITRONS PER PLANE$')
      CALL HCOPY(101,103,'NUMBER OF NEUTRAL PER PLANE$')
      CALL HCOPY(101,104,'NUMBER OF CHARGED HADRONS PER PLANE$')
      CALL HCOPY(101,105,'NUMBER OF MUONS PER PLANE$')
      CALL HBOOK1(500,'MUON AVERAGE ENERGY LOSS$',100,1.E-6,5.E-6,0.)
*
      END
+DECK,  VIEWYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:16  cernlib
* Geant

+SELF, IF=HIGZ.
      SUBROUTINE VIEWYZ (IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Draw full set up in 'view bank' mode.                      *
C.    *                                                                *
C.    ******************************************************************
C.
      CALL GSATT('*','SEEN', 1)
C
      CALL GSATT('MOD1','SEEN', -2)
      CALL GSATT('MOD2','SEEN', -2)
      CALL GSATT('MOD3','SEEN', -2)
C
C             Create bank for view YZ.
C
      CALL GDOPEN(IVIEW)
C
      CALL GDRAWC ('CALO', 1, 0., 10.,10.,0.08,0.2)
C
      CALL GDCLOS
C
      END
+SELF.
+PATCH, EXAMPLES_GEXAM6.
+KEEP, SHOBUF.
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant
* shobuf.inc
      PARAMETER (NCELL=40,NWORD=2*NCELL,NBYTE=4*NWORD)
C
      COMMON/SHOBUF/NXBIN,NYBIN,NZBIN,XBIN,YBIN,ZBIN,
     +              NENERG,ESHOW(20),NSHOW(20),NFIRE(20),NRCOR(20),
     +              XGENER,YGENER,ZGENER,CUTLOW,
     +              IENERG,ISHOW,IRECOR,
     +              IENBUF(NWORD),IBUF(NWORD)
C
      DIMENSION     ENBUF(NWORD),BUF(NWORD)
      EQUIVALENCE (ENBUF,IENBUF) , (BUF,IBUF)
C
C     NCELL = number of cells per logical record
C     NWORD = number of words per logical record
C     NBYTE = logical record length in bytes
C     IENBUF= directory record for a given energy
C     IBUF  = record of shower informations
C
C       One must store at least 2 informations per cell fired :
C          - the cell number
C          - the energy deposited in the cell
C
+DECK,  DATA0, T=DATA.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant
*
*
LIST
MATER   8
GRID    40  40  40  0.5  0.5  1.0
ESHO 0.002  0.004  0.008  0.016  0.032  0.064  0.128  0.256  0.512  1.024  2.048
NSHO 20     20     20     20     20     20     20     20     10     5      5
KINE    1
DEBUG   1   1
SWIT    1   0   0
PAIR  1
COMP  1
PHOT  1
PFIS  0
MULS  1
BREM  1
LOSS  1
DRAY  1
ANNI  1
MUNU  0
HADR  2
CUTS  0.0001    0.001    6=0.00010 (BCUTE)    8=0.00100 (DCUTE)
PRINT   'MATE' 'VOLU'  'TMED' 'SETS'
TIME 2= 4.
END





+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/22 13:16:26  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE GUKINE
C.    *
C.    *       Generates Kinematics for primary track
C.    *
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, SHOBUF.
C
      DIMENSION VERTEX(3),PLAB(3)
      SAVE VERTEX,PLAB
      DATA VERTEX/3*0./
      DATA PLAB  /3*0./
C
C *** Energy of the incident particle
C
      ISHOW = ISHOW+1
      IF(ISHOW.GT.NSHOW(IENERG)) THEN
         IENERG = IENERG+1
         ISHOW  = 1
      ENDIF
C
      IF(ISHOW.EQ.1) THEN
         CALL VZERO(IENBUF,NWORD)
         JPA = LQ(JPART-IKINE)
         AMASS = Q(JPA+7)
         ETOT  = ESHOW(IENERG)
         PLAB(3)=SQRT((ETOT+AMASS)*(ETOT-AMASS))
          ENBUF(1)=ETOT*1000.
         IENBUF(2)=NSHOW(IENERG)
      ENDIF
C
C *** Vertex creation
C
      VERTEX(1) = XGENER
      VERTEX(2) = YGENER
      VERTEX(3) = ZGENER
C
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
      CALL GSKINE(PLAB,IKINE,NVERT,0,0,NT)
C
C *** Kinematics debug (controlled by ISWIT(1) )
C
      IF(IDEBUG*ISWIT(1).EQ.1) THEN
         CALL GPRINT('VERT',0)
         CALL GPRINT('KINE',0)
      ENDIF
C
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/22 13:16:31  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE GUOUT
C.    *
C.    *       User routine called at the end of each event
C.    *
C
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, SHOBUF.
C
      PARAMETER (NV=3,NHMX=1000)
      DIMENSION  NVL(NV),ISLC(NV,NHMX),ECELL(NHMX),LTRA(NHMX)
C
      PARAMETER (IWS1=NV*NHMX+1,IWS2=IWS1+NHMX,IWS3=IWS2+NHMX)
      EQUIVALENCE  ( WS(   1), ISLC(1,1) )
     *            ,( WS(IWS1), ECELL(1)  )
     *            ,( WS(IWS2), LTRA (1)  )
C
      SAVE NVL
      DATA NVL / NV*0 /
C
C *** Fetch the cells fired
C
      IF(IDEBUG*ISWIT(3).EQ.1) CALL GPHITS('CELL','SLIZ')
      CALL MZWORK(IXSTOR,WS(1),WS(IWS3),0)
      CALL GFHITS('CELL','SLIZ',NV,1,NHMX,0,NVL,LTRA,ISLC,ECELL,NHITS)
      IF(NHITS.LE.0) RETURN
C
C *** Writout shower
C
      IENBUF(2+ISHOW)=IRECOR
      IWORD = 0
      ECHECK = 0.
      DO 10 IHIT =1,NHITS
      CALL HFILL( 1, ECELL(IHIT)*1000.,0.,1.)
      IF(ECELL(IHIT).LT.CUTLOW) GO TO 10
      ECHECK = ECHECK+ECELL(IHIT)
      NFIRE(IENERG) = NFIRE(IENERG) + 1
      IWORD=IWORD+2
      IX=ISLC(1,IHIT)
      IY=ISLC(2,IHIT)
      IZ=ISLC(3,IHIT)
      IRI=NXBIN*NYBIN*(IZ-1)+NXBIN*(IY-1)+IX+1
       BUF(IWORD-1)=ECELL(IHIT)*1000.
      IBUF(IWORD)  =IRI
C
      IF(IWORD.EQ.NWORD) THEN
CCCC     PRINT *,'IRECOR,IBUF  ',IRECOR,(BUF(J),IBUF(J+1),J=1,NWORD,2)
         WRITE(LUNITS(1),REC=IRECOR) IBUF
         CALL VZERO(IBUF,NWORD)
         IWORD=0
         INQUIRE(LUNITS(1),NEXTREC=IRECOR)
      ENDIF
   10 CONTINUE

      IF(IWORD.GT.0) THEN
CCCC     PRINT *,'IRECOR,IBUF  ',IRECOR,(BUF(J),IBUF(J+1),J=1,NWORD,2)
         WRITE(LUNITS(1),REC=IRECOR) IBUF
         CALL VZERO(IBUF,NWORD)
         IWORD=0
         INQUIRE(LUNITS(1),NEXTREC=IRECOR)
      ENDIF

      IENBUF(2+ISHOW+1)=IRECOR
C
      ECHECK = 100.*ECHECK/ESHOW(IENERG)
      ID = 1000*(ESHOW(IENERG)+0.0005)
      CALL HFILL( ID ,ECHECK,0.,1.)
C
C *** Write directory block if necessary
C
      IF(ISHOW.EQ.NSHOW(IENERG)) THEN
         NRCOR(IENERG)=IENBUF(3+ISHOW)-IENBUF(3)
CCCC     PRINT *,' DIR. BLOCK  ',ENBUF(1),(IENBUF(J),J=2,NWORD)
         WRITE(LUNITS(1),REC=IENERG+1) IENBUF
      ENDIF
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE GUSTEP
C.    *
C.    *       User routine called at the end of each tracking step
C.    *
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCSETS.
+CDE, GCTRAK.
C
C *** Debug event
C
      IF(IDEBUG*ISWIT(2).EQ.1) CALL GPCXYZ
C
C *** Something generated ?
C
      IF(NGKINE.GT.0) CALL GSKING(0)
C
C *** Energy deposited
C
      IF(DESTEP.NE.0.)CALL GSCHIT(ISET,IDET,ITRA,NUMBV,DESTEP,1,IHIT)
C
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

+SELF, IF=-INTER.
C.
C.    *
C.    *       PROGRAM FOR GEANT SHOWER LIBRARY GENERATION
C.    *
C     *      Authors : Pal Ribaric (Budapest), Michel Maire (Annecy)
C.
      PARAMETER (NZEBRA =50000, NHBOOK=10000)
      COMMON/GCBANK/Q(NZEBRA)
      COMMON/PAWC/H(NHBOOK)
C.
C.
      CALL GZEBRA(NZEBRA)
      CALL HLIMIT(-NHBOOK)
C
C *** GEANT initialisation
C
      CALL UGINIT
C
C *** Start events processing
C
      CALL GRUN
C
C *** End of RUN
C
      CALL UGLAST

      STOP
      END
+SELF.
+DECK,  UFILES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
+SELF, IF=CRAY.
      OPEN(UNIT=4,FILE='gexam6.dat',STATUS='OLD')
      OPEN(UNIT=34,FILE='gexam6.hist',ACCESS='DIRECT',
     +     RECL=8192,STATUS='NEW',FORM='UNFORMATTED')
+SELF, IF=APOLLO.
      OPEN(UNIT=4,FILE='gexam6.dat',STATUS='OLD')
      OPEN(UNIT=34,FILE='gexam6.hist',ACCESS='DIRECT',
     +     RECL=4096,STATUS='UNKNOWN')
+SELF, IF=VAX.
      OPEN(UNIT=4,FILE='GEXAM6.DAT',STATUS='UNKNOWN')
      OPEN(UNIT=34,FILE='GEXAM6.HIST',ACCESS='DIRECT',
     +     FORM='UNFORMATTED',RECL=1024,STATUS='UNKNOWN')
+SELF, IF=IBM.
      CALL VMCMS('FILEDEF  4 DISK GEXAM6 DAT',IRET)
      CALL VMCMS('FILEDEF 34 DISK GEXAM6 HIST A6',IRET)
      OPEN(UNIT=4,STATUS='UNKNOWN')
      OPEN(UNIT=34,ACCESS='DIRECT',
     +     FORM='UNFORMATTED',RECL=4096,STATUS='UNKNOWN')
+SELF.
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.2  1996/02/22 13:16:32  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE UGEOM
C
C ***          Define user geometry set up
C
+CDE, GCBANK.
+CDE, GCLIST.
+CDE, GCMATE.
+CDE, SHOBUF.
C
      DIMENSION PAR( 3)
      DIMENSION ZLG(6),ALG(6),WLG(6)
      DIMENSION ABGO(3),ZBGO(3),WBGO(3)
      DIMENSION AF(3),ZF(3),WMATF(3)
C
      PARAMETER   (NV=3)
      CHARACTER*4 NAMESV(NV)
      DIMENSION   NBITSV(NV)
C
      DATA NAMESV / 'SLIX','SLIY','SLIZ' /
      DATA NBITSV /    8  ,   8  ,   8   /
C
C *** Lead glass mixture parameters
C
      DATA ZLG/  82.00,  19.00,  14.00,  11.00,  8.00,  33.00/
      DATA ALG/ 207.19,  39.102,  28.088,  22.99, 15.999,  74.922/
      DATA WLG/ .65994, .00799, .126676, .0040073,.199281, .00200485/
C
C *** BGO compound parameters
C
      DATA ABGO/208.98,72.59,15.999/
      DATA ZBGO/83.,32.,8./
      DATA WBGO/4.,3.,12./
C
C *** Iron+Nickel+Crome  compound parameters
C
      DATA AF/55.847,58.71,51.998/
      DATA ZF/26.,28.,24./
      DATA WMATF/0.703964,0.099,0.197/
C
C *** Defines USER particular materials
C
      CALL GSMATE( 1,'AIR$    ', 14.61,7.3,0.001205,30423.,6750.,0,0)
      CALL GSMATE( 2,'CARBON$   ', 12.01, 6.,2.265 ,18.8,49.9,0,0)
      CALL GSMATE( 3,'ALUMINIUM$', 26.98,13.,2.7   , 8.9,37.2,0,0)
      CALL GSMATE( 4,'COPPER$   ', 63.54,29.,8.96  ,1.43,14.8,0,0)
      CALL GSMATE( 5,'LEAD$     ',207.19,82.,11.35 ,0.56,18.5,0,0)
      CALL GSMATE( 6,'URANIUM$  ',238.03,92.,18.95 ,0.32,12. ,0,0)
      CALL GSMIXT( 7,'IRON(COMPOUND)$',AF,ZF,7.8,3,WMATF)
      CALL GSMIXT( 8,'BGO(COMPOUND)$',ABGO,ZBGO,7.1,-3,WBGO)
      CALL GSMIXT( 9,'LEAD GLASS$',ALG,ZLG,5.2,6,WLG)
C
C *** Defines USER tracking media parameters
C
      FIELDM =  0.
      IFIELD =  0
      TMAXFD = +10.0
      DMAXMS = +0.50
      DEEMAX = +0.20
      EPSIL  =  0.01
      STMIN  =  0.8
C
      CALL GSTMED( 1,'ABSORBER$',NMAT, 1 , IFIELD,FIELDM,TMAXFD,
     *                DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
C
C *** Redefine cell's size in cm
C
      JMA    = LQ(JMATE-NMAT)
      RADL   =  Q(JMA + 9)
      XBIN   =  XBIN*RADL
      YBIN   =  YBIN*RADL
      ZBIN   =  ZBIN*RADL
C
C *** Defines USER'S VOLUMES
C
      PAR(1) = 0.5*NXBIN*XBIN
      PAR(2) = 0.5*NYBIN*YBIN
      PAR(3) = 0.5*NZBIN*ZBIN
      CALL GSVOLU( 'ECAL' , 'BOX ' ,  1  , PAR , 3 , IVOL )
C
      CALL GSDVN( 'SLIX' , 'ECAL' ,   NXBIN , 1)
      CALL GSDVN( 'SLIY' , 'SLIX' ,   NYBIN , 2)
      CALL GSDVN( 'SLIZ' , 'SLIY' ,   NZBIN , 3)
C
C *** Define 'SLIZ' as a detector
C
      NWHI = 2000
      NWDI = 0
C
      CALL GSDET ('CELL','SLIZ',NV,NAMESV,NBITSV,1,NWHI,NWDI,ISET,IDET)
      CALL GSDETH('CELL','SLIZ',1,'EDEP', 32, 0.0 , 1.E+06)
C
C *** Close geometry banks. (obligatory system routine)
C
      CALL GGCLOS
C
C *** Print geometry
C
      IF(IUCOMP(4HMATE,LPRIN,NPRIN).NE.0)CALL GPRINT('MATE',0)
      IF(IUCOMP(4HTMED,LPRIN,NPRIN).NE.0)CALL GPRINT('TMED',0)
      IF(IUCOMP(4HVOLU,LPRIN,NPRIN).NE.0)CALL GPRINT('VOLU',0)
      IF(IUCOMP(4HSETS,LPRIN,NPRIN).NE.0)CALL GPRINT('SETS',0)

      END
+DECK,  UGINIT, T=FORT.
* Revision 1.2  1996/02/22 13:16:33  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE UGINIT
C.    *
C.    *        To initialise GEANT/USER  program and read data cards
C.    *
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCMATE.
+CDE, GCUNIT.
+CDE, SHOBUF.
*
*             Open user files
*
      CALL UFILES
C
C *** Initialise GEANT
C
      CALL GINIT
C
C *** Prints version number
C
      WRITE(LOUT,1000)
C
C *** Material
C
      NMAT= 8
C
C *** Grid (sizes must be in unit of radiation length)
C          (they will be converted in cm by the routine UGEOM)
C
      NXBIN = 40
      NYBIN = 40
      NZBIN = 40
       XBIN = 0.5
       YBIN = 0.5
       ZBIN = 1.0
C
C *** Incident particle
C
      IKINE = 1
C
C *** Shower library
C
      CALL VZERO(ESHOW,20)
      CALL VZERO(NSHOW,20)
      CALL VZERO(NFIRE,20)
      CALL VZERO(NRCOR,20)
      CUTLOW = 0.0001
C
C *** Logical unit to write shower file
C
      LUNITS(1) = 50
C
C *** Overwrite some previous initializations from data cards
C
      CALL FFKEY('MATE',NMAT    , 1,'INTEGER')
      CALL FFKEY('GRID',NXBIN   , 6,'MIXED'  )
      CALL FFKEY('ESHO',ESHOW(1),20,'REAL'   )
      CALL FFKEY('NSHO',NSHOW(1),20,'INTEGER')
C
      CALL GFFGO
C
C *** Setup data structures and banks.
C
      CALL GZINIT
C
C *** Geometry and materials description
C
      CALL UGEOM
C
C *** Particles, energy loss and cross-sections initialisations
C
      CALL GPART
      CALL GPHYSI
C
C *** Total number of events
C
      NENERG = 0
      NEVENT = 0
      DO 4 I=1,20
      NSHOW(I) = MIN(NSHOW(I),NWORD-3)
      IF(NSHOW(I).LE.0) GO TO 5
      NENERG = NENERG + 1
    4 NEVENT = NEVENT+NSHOW(I)
C
   5  IF(NENERG.LE.0) RETURN
      IENERG = 1
      ISHOW  = 0
C
C *** Shower origin (bin number; coordinates)
C
      IX = NXBIN/2 + 1
      IY = NYBIN/2 + 1
      IZ = NZBIN/4 + 1
C
      IRI = NXBIN*NYBIN*(IZ-1)+NXBIN*(IY-1)+IX+1
C
      XRI = (IX-0.5)*XBIN
      YRI = (IY-0.5)*YBIN
      ZRI = (IZ-0.5)*ZBIN
C
      XGENER = XRI-0.5*NXBIN*XBIN
      YGENER = YRI-0.5*NYBIN*YBIN
      ZGENER = ZRI-0.5*NZBIN*ZBIN
C
C *** Write out header block
C
      CALL VZERO(IBUF,NWORD)
      IBUF(1)=NENERG+1
      JPA = LQ(JPART-IKINE)
      CHARGE = Q(JPA+8)
      IBUF(2)=INT(CHARGE)
      IBUF(3)=IRI
      IBUF(4)=NXBIN
      IBUF(5)=NYBIN
      IBUF(6)=NZBIN
       BUF(7)= XBIN
       BUF(8)= YBIN
       BUF(9)= ZBIN
      IBUF(10)= NENERG
       BUF(11)= CUTLOW*1000.
      IBUF(12)= NXBIN*NYBIN
       BUF(13)= XRI
       BUF(14)= YRI
       BUF(15)= ZRI
C
+SELF, IF=CRAY.
      OPEN(LUNITS(1),FILE='bootgen1.dat',ACCESS='DIRECT',
     +     FORM='UNFORMATTED',RECL=2*NBYTE,STATUS='NEW')
+SELF, IF=IBM.
      OPEN(LUNITS(1),ACCESS='DIRECT',RECL=NBYTE)
+SELF, IF=APOLLO.
      OPEN(LUNITS(1),FILE='bootgen1.dat',ACCESS='DIRECT',
     +     FORM='UNFORMATTED',RECL=NBYTE,STATUS='UNKNOWN')
+SELF, IF=VAX.
      OPEN(LUNITS(1),FILE='BOOTGEN1.DAT',ACCESS='DIRECT',
     +     FORM='UNFORMATTED',RECL=NWORD,STATUS='UNKNOWN')
+SELF.
      WRITE(LUNITS(1),REC=1) IBUF
      IRECOR=NENERG+2
C
CCCC  PRINT *,' FIRST  ',IBUF
C
      CALL VZERO(IBUF,NWORD)
C
C *** Define user histograms
C
      CALL UHINIT
C
 1000 FORMAT(/,'  SHOWER LIBRARY  GENERATION   VERSION  2.01 ',/)
C
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.2  1996/02/22 13:16:34  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE UGLAST
C.    *
C.    *
C.    *      Termination routine to print histograms and statistics
C.    *
C.    *
+CDE, GCBANK.
+CDE, GCMATE.
+CDE, GCUNIT.
+CDE, SHOBUF.
      DIMENSION TITLE(20)
C
      CALL GLAST
C
C *** Print geometry
C
      JMA = LQ(JMATE-NMAT)
      CALL UBLOW(IQ(JMA+1),TITLE,20)
      WRITE(LOUT,501) NMAT,TITLE ,RADL
      XSIZE = NXBIN * XBIN
      YSIZE = NYBIN * YBIN
      ZSIZE = NZBIN * ZBIN
      WRITE(LOUT,502) XSIZE,YSIZE,ZSIZE
      XRDL  = XBIN/RADL
      YRDL  = YBIN/RADL
      ZRDL  = ZBIN/RADL
      WRITE(LOUT,503) NXBIN,XRDL,XBIN,NYBIN,YRDL,YBIN,NZBIN,ZRDL,ZBIN
C
C *** Print statistic on records written
C
      WRITE(LOUT,1000)
      NTRCOR = NENERG+1
      DO 9 IE=1,NENERG
        NFIRE(IE)=NFIRE(IE)/NSHOW(IE)
        TKBYT    =NRCOR(IE)*NBYTE*1.E-03
        NTRCOR   =NTRCOR+NRCOR(IE)
        WRITE(LOUT,1001) IE,ESHOW(IE)*1000.,NSHOW(IE),NFIRE(IE),
     +                      NRCOR(IE),TKBYT
    9 CONTINUE
      TKBYT       =NTRCOR*NBYTE*1.E-03
      WRITE(LOUT,1002) NTRCOR,TKBYT
C
C
      CALL HIDOPT(0,'BLAC')
      CALL HISTDO
C
  501 FORMAT(1H1,/,21X,'ABSORBER :',I3,1X,20A1,'  RADL =',F8.2,' CM')
  502 FORMAT(25X,'SIZE :  LX=',F8.2,' CM  LY=',F8.2,' CM  LZ=',
     *                             F8.2,' CM')
  503 FORMAT(25X,'GRID :  X:',I3,' BINS OF',F6.2,' RADL =',F8.2,' CM',
     *       /,33X,      'Y:',I3,' BINS OF',F6.2,' RADL =',F8.2,' CM',
     *       /,33X,      'Z:',I3,' BINS OF',F6.2,' RADL =',F8.2,' CM')
C
 1000 FORMAT(/,15X,'  ENERGY (MEV) ',5X,'# SHOWERS ',5X,
     *             '# CELLS/SHOWER ',5X,'# RECORDS ',5X,
     *             ' # KBYTES ',/,15X,80('*'),/)
 1001 FORMAT(10X,I5,F11.0,' MEV',5X,I5,15X,I6,10X,I6,8X,F8.3)
 1002 FORMAT(70X,25('-'),/,45X,'TOTAL (WITH DIRECTORIES) :',I6,8X,F8.3)
      END
+DECK,  UHINIT, T=FORT.
* Revision 1.2  1996/02/22 13:16:35  ravndal
* Cleaning up CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:19  cernlib
* Geant

      SUBROUTINE UHINIT
C     *
C     *       To book the user's histograms
C     *
+CDE, SHOBUF.
*
*             Open a HBOOK direct access file
*
      CALL HRFILE(34,'HBOOK','N')
*
      VMX16 = 65535
      CALL HBOOK1( 1,'  ENERGY DEPOSITED PER CELL (IN MEV)$',
     *            100, 0. , 10. , VMX16)
C
      VMX8 = 255
      DO 1 I=1,NENERG
      ID=1000*(ESHOW(I)+0.0005)
      CALL HBOOK1(ID,' TOTAL ENERGY DEPOSITED (IN PERCENT)$',
     *            100, 91.0 , 101.0 , VMX8)
    1 CONTINUE
C
      END
+PATCH, EXAMPLES_GEXAM8.
+KEEP, PVOLUM.
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant
* pvolum.inc
      COMMON/PVOLUM/ IMAT1,IMAT2,X1,X2,DZ1,DZ2,NZ,ZECAL,
     +               ITR,ETOT(6),ESEEN(6)
+DECK,  DATA8, T=DATA.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant
*
*
LIST
TRIGGERS   10
DEBUG     1   10000    1
CUTS  5*2.E-5
KINE 109 10. 0. 0.
MATER   12 24
LAYE  1. 0.25 200
LOSS 3
DRAY 1
TIME 2=10.
END

+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/22 13:26:56  ravndal
* Cleaning up CARTOCVS interface
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

      SUBROUTINE GUKINE
C.
C.    *
C.    *       Generates Kinematics for primary track
C.    *
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, PVOLUM.
+CDE, GCONSP.
C

      DIMENSION VERTEX(3),PLAB(3),RNDM(2)
C.
C.
      DO 10 I=1,6
         ETOT(I)=0.
         ESEEN(I)=0.
  10  CONTINUE
      VERTEX(1) = 0.
      VERTEX(2) = 0.
      VERTEX(3) = - 0.9999*ZECAL
      IF(IKINE.GT.100)THEN
         IK=IKINE-100
         THETA=PKINE(2)*DEGRAD
         PHI=PKINE(3)*DEGRAD
      ELSE
         IK=IKINE
         CALL GRNDM(RNDM,2)
         THETA=PI*RNDM(1)
         PHI=TWOPI*RNDM(2)
      ENDIF
C
      PLAB(1) = PKINE(1)*SIN(THETA)*COS(PHI)
      PLAB(2) = PKINE(1)*SIN(THETA)*SIN(PHI)
      PLAB(3) = PKINE(1)*COS(THETA)
C
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
      CALL GSKINE(PLAB,IK,NVERT,0,0,NT)
      JPA=LQ(JPART-IK)
      ITR=Q(JPA+6)

C
C ***          Kinematics debug (controlled by ISWIT(1) )
C
      IF(IDEBUG.EQ.1) THEN
        IF(ISWIT(1).EQ.1) THEN
          CALL GPRINT('VERT',0)
          CALL GPRINT('KINE',0)
        ENDIF
      ENDIF

C
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/22 13:26:57  ravndal
* Cleaning up CARTOCVS interface
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant

      SUBROUTINE GUOUT
+CDE, PVOLUM.
      SETOT=ETOT(ITR)
      SESEEN=ESEEN(ITR)
      CALL HF1(10+ITR,SETOT,1.)
      CALL HF1(20+ITR,SESEEN,1.)
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.2  1996/02/22 13:26:58  ravndal
* Cleaning up CARTOCVS interface
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant

      SUBROUTINE GUSTEP
C.
C.    *
C.    *       User routine called at the end of each tracking step
C.    *       INWVOL is different from 0 when the track has reached
C.    *              a volume boundary
C.    *       ISTOP is different from 0 if the track has stopped
C.    *
C.
+CDE, GCFLAG.
+CDE, GCTMED.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCTRAK.
+CDE, GCNUM.
+CDE, PVOLUM.
      DIMENSION X(12)
      common/temp/dedx0,dedx1,dedx2,dedx3,ener
C              Something generated ?

      IF(NGKINE.GT.0) THEN
        DO 30 I=1,NGKINE
          ITYPA  = GKIN(5,I)
          IF(ITYPA.NE.4)  CALL GSKING(I)
   30   CONTINUE
      ENDIF
      IF(NUMED.EQ.2) THEN
       IF(DESTEP.NE.0.)THEN
          CALL GBIRK(EDEP)
          R=SQRT(VECT(1)**2+VECT(2)**2)
          Z=VECT(3)
          CALL HF1(30+ITR,Z,EDEP)
          CALL HF1(40+ITR,R,EDEP)
          IF(ITRTYP.EQ.5)CALL HF1(65,EDEP,1.)
          ESEEN(ITR)=ESEEN(ITR)+EDEP
       ENDIF
       IF(ISWIT(8).NE.0)THEN
          X(1)=IEVENT
          X(2)=IPART
          X(3)=GEKIN
          X(4)=ISTOP
          X(5)=INWVOL
          X(6)=STEP
          X(7)=DESTEP
          X(8)=DXMIP
          X(9)=TOFG
          X(10)=Z
*          CALL HFN(1,X)
          if(itrtyp.eq.2)then
          X(1)=IEVENT
          X(2)=IPART
          X(3)=GEKIN
          X(4)=ISTOP
          X(5)=INWVOL
          X(6)=STEP
          X(7)=DESTEP
          X(8)=ener
          X(9)=dedx0
          X(10)=dedx1
          X(11)=dedx2
          X(12)=dedx3
          CALL HFN(2,X)
          ENDIF
       ENDIF
      ENDIF
      ETOT(ITR)=ETOT(ITR)+DESTEP
*
*             Muon range
*
      IF(ITR.EQ.5)THEN
         IF(ISTOP.NE.0.AND.NTMULT.EQ.1)THEN
            CALL HF1(51,SLENG,1.)
         ENDIF
      ENDIF


C             Debug event

      CALL GDEBUG

      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant

      SUBROUTINE GUTREV
C.
C.    *
C.    *       User routine to control tracking of one event
C.    *
C.    *       Called by GRUN
C.    *
C.
      CALL GTREVE
C
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

+SELF, IF=-INTER.
C.
C.    *
C.    *       TEST PROGRAM FOR GEANT/SHOWER STUDIES
C.    *
C.    *       This program has been used to make the GEANT/EGS
C.    *       comparison.
C.    *            (see CERN/DD/85/1)
C.    *
C.    *       Authors    R.Brun, M.Maire  *********
C.
      COMMON/PAWC/H(10000)
      COMMON/GCBANK/Q(50000)
C.
C.
      CALL GZEBRA(50000)
      CALL HLIMIT(-10000)
C
C ***          GEANT initialisation
C
      CALL UGINIT

C
C ***          Start events processing
C
      CALL GRUN
C
C ***          End of RUN
C
      CALL UGLAST

      STOP
      END
+SELF.
+DECK,  UFILES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
      CHARACTER*(*) FILNAM, FSTAT
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='gexam8.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GEXAM8 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='OLD')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.2  1996/03/05 15:09:55  ravndal
* Cleanup CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

      SUBROUTINE UGEOM
C
C ***          Define user geometry set up
C

+CDE, GCBANK.
+CDE, PVOLUM.

      DIMENSION PAR( 8)
      DIMENSION ZLG(6),ALG(6),WLG(6)
      DIMENSION A(3),Z(3),WMAT(3)
      DIMENSION AF(3),ZF(3),WMATF(3)
      DIMENSION AURAN(2),ZURAN(2),WURAN(2)
      DIMENSION AWATER(2),ZWATER(2),WWATER(2)
      DIMENSION AISOBU(3),ZISOBU(3),WGAS(3)
      DIMENSION ASCI(2),ZSCI(2),WSCI(2)
C
C             Argon/Isobuthane compound
C
      DATA AISOBU/12.01,1.01,39.95/
      DATA ZISOBU/6.,1.,18./
C
C             Water compound parameters
C
      DATA AWATER/1.,16./
      DATA ZWATER/1.,8./
      DATA WWATER/2.,1./
C
C             Lead glass mixture parameters
C
      DATA ZLG/  82.00,  19.00,  14.00,  11.00,  8.00,  33.00/
      DATA ALG/ 207.19,  39.102,  28.088,  22.99, 15.999,  74.922/
      DATA WLG/ .65994, .00799, .126676, .0040073,.199281, .00200485/
C
C             BGO compound parameters
C
      DATA A/208.98,72.59,15.999/
      DATA Z/83.,32.,8./
      DATA WMAT/4.,3.,12./
C
C             Iron+Nickel+Crome  compound parameters
C
      DATA AF/55.847,58.71,51.998/
      DATA ZF/26.,28.,24./
      DATA WMATF/0.703964,0.099,0.197/
      DATA ALAR,ZLAR,WLAR,DLAR,NLAR/40.,18.,1.,1.40,-1/
C
C             Uranium mixture
C
      DATA AURAN/235.,238./
      DATA ZURAN/92.,92./
      DATA WURAN/0.004,0.996/
C
C             Scintillator
C
      DATA ASCI/12.,1./
      DATA ZSCI/6.,1./
      DATA WSCI/1.,1./
      DATA DSCI/1.032/
C
C ***          Defines USER particular materials
C
*
*             Argon/Isobuthane mixture (60% Ar and 40% Isobuthane)
*             First define Isobuthane compound and relative weights
*
      DISO   =0.00267
      DENS1  =0.002136
      WGAS(1)=4.
      WGAS(2)=10.
      CALL GSMIXT(4,'ISOBUTHAN$',AISOBU,ZISOBU,0.40*DISO,-2,WGAS)
      WGAS(1)=0.40*WGAS(1)
      WGAS(2)=0.40*WGAS(2)
      WGAS(3)=0.60
      CALL GSMIXT( 5,'ARG/ISOBU$',AISOBU,ZISOBU,DENS1, 3,WGAS)
      CALL GSMATE( 9,'ALUMINIUM$', 26.98,13.,2.7   , 8.9,37.2,0,0)
      CALL GSMATE(11,'COPPER$   ', 63.54,29.,8.96  ,1.43,14.8,0,0)
      CALL GSMATE(12,'LEAD$     ',207.19,82.,11.35 ,0.56,18.5,0,0)
      CALL GSMATE(13,'LEAD$     ',207.19,82.,11.35 ,0.56,18.5,0,0)
*      CALL GSMATE(14,'URANIUM$  ',238.03,92.,18.95 ,0.32,12. ,0,0)
      CALL GSMIXT(14,'URANIUM$  ',AURAN,ZURAN,18.95 ,2,WURAN)
      CALL GSMATE(15,'AIR$      ', 14.61,7.3,0.001205,30423.,6750.,0,0)
      CALL GSMATE(16,'VACUUM$ ',1.E-16,1.E-16,1.E-16,1.E+16,1.E+16,0,0)
      CALL GSMIXT(10,'IRON(COMPOUND)$',AF,ZF,7.8,3,WMATF)
      CALL GSMIXT(21,'BGO(COMPOUND)$',A,Z,7.1,-3,WMAT)
      CALL GSMIXT(22,'LEAD GLASS$',ALG,ZLG,5.2,6,WLG)
      CALL GSMATE(23,'PLAST SC$',  6.25,3.4,1.032 ,   43.0,   437.,0,0)
      CALL GSMIXT(24,'SCINTILLATOR$',ASCI,ZSCI,DSCI,-2,WSCI)
      CALL GSMIXT(25,'liq. Argon$',ALAR,ZLAR,DLAR,NLAR,WLAR)
      CALL GSMIXT(26,'Water$$',AWATER,ZWATER,1.,-2,WWATER)
      CALL GSMATE(32,'LEADLEGER$',207.19,82.,6. ,0.56,18.5,0,0)
      CALL GSMATE(33,'LEADLEGER$',207.19,82.,6. ,0.56,18.5,0,0)
C
C ***          Defines USER tracking media parameters
C
C

      FIELDM =  0.
      IFIELD =  0
      TMAXFD =  10.
      DMAXMS =  1.
      DEEMAX =  0.1
      EPSIL  =  0.001
      STMIN  = -0.01

      CALL GSTMED( 1,'ABSORBER$'              ,IMAT1, 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
      CALL GSTMED( 2,'ACTIVE MEDIUM$'         ,IMAT2, 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
      IF(IMAT2.EQ.24)THEN
         CALL GSTPAR(2,'BIRK1',1.)
         CALL GSTPAR(2,'BIRK2',0.013)
         CALL GSTPAR(2,'BIRK3',9.6E-6)
      ENDIF


C
C ***          Defines USER'S VOLUMES
C
      JMA    = LQ(JMATE-IMAT1)
      X1     = Q(JMA+9)
      ABS1   = Q(JMA+10)
      JMA    = LQ(JMATE-IMAT2)
      X2     = Q(JMA+9)
      NMED1  = 1
      NMED2  = 2
      DZ=DZ1+DZ2
      ZECAL=NZ*0.5*DZ
      RECAL=ZECAL

      PAR(1) = 0.
      PAR(2) = RECAL
      PAR(3) = ZECAL
      CALL GSVOLU( 'ECAL' , 'TUBE' ,1, PAR , 3 , IVOL )
      CALL GSDVN('BLOC','ECAL',NZ,3)
      PAR(1) = 0.
      PAR(2) = RECAL
      PAR(3) = 0.5*DZ2
      CALL GSVOLU( 'MEDI' , 'TUBE' ,2, PAR , 3 , IVOL )
      ZC=0.5*DZ-PAR(3)
      CALL GSPOS( 'MEDI' ,1, 'BLOC' , 0.   , 0.   , ZC  , 0,'ONLY')

C ***          Close geometry banks. (obligatory system routine)

      CALL GGCLOS

      END
+DECK,  UGINIT, T=FORT.
* Revision 1.2  1996/02/22 13:26:59  ravndal
* Cleaning up CARTOCVS interface
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

      SUBROUTINE UGINIT
C.
C.    *
C.    *
C.    *        To initialise GEANT/USER  program and read data cards
C.    *
C.
+CDE, PVOLUM.
+CDE, GCUNIT.
+CDE, GCLIST.
+CDE, GCKINE.

C.
*
*             Open user files
*
      CALL UFILES
C.
C             Initialise GEANT
C
      CALL GINIT
      IMAT1=14
      IMAT2=25
      DZ1=0.3
      DZ2=0.6
      NZ=200
      IKINE=109
      PKINE(1)=10.
      PKINE(2)=0.
      PKINE(3)=0.
      CALL FFKEY('MATE',IMAT1,2,'INTEGER')
      CALL FFKEY('LAYE',DZ1,3,'MIXED')
      CALL GFFGO
      CLOSE(4)
      CALL GZINIT
      CALL GDINIT
      CALL GPART
C
C             Prints version number
C
      WRITE(LOUT,1000)
C

C              Geometry and materials description

      CALL UGEOM
C
      CALL GLOOK('MATE',LPRIN,NPRIN,IM)
      CALL GLOOK('TMED',LPRIN,NPRIN,IT)
      CALL GLOOK('VOLU',LPRIN,NPRIN,IV)
      IF(IM.NE.0)CALL GPRINT('MATE',0)
      IF(IT.NE.0)CALL GPRINT('TMED',0)
      IF(IV.NE.0)CALL GPRINT('VOLU',0)

C              Energy loss and cross-sections initialisations

      CALL GPHYSI
C
*             Create a view bank
      CALL VIEWYZ(1)
*
C             Define user histograms

      CALL UHINIT

 1000 FORMAT(/,'  GEXAM8 VERSION 1.00 ',/)

      END
+DECK,  UGLAST, T=FORT.
* Revision 1.2  1996/02/22 13:26:59  ravndal
* Cleaning up CARTOCVS interface
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant

      SUBROUTINE UGLAST
C.    *
C.    *
C.    *      Termination routine to print histograms and statistics
C.    *
C.    *

+CDE, GCFLAG.
+CDE, PVOLUM.
C
      CALL GLAST

C ***          Normalize and print energy distribution

C             Save histograms
C
      CALL HROUT(0,ICYCLE,' ')
      CALL HREND('NTUPLE')
C
      END
+DECK,  UHINIT, T=FORT.
* Revision 1.2  1996/03/05 15:10:21  ravndal
* Cleanup CARTOCVS conversion
* Revision 1.1.1.1  1995/10/24 10:22:22  cernlib
* Geant

      SUBROUTINE UHINIT
C
C     *       To book the user's histograms
C     *

+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, PVOLUM.
      CHARACTER*8 CHNAME(10)
      CHARACTER*8 CHNAM2(12)
      DATA CHNAME/'IEVENT  ','IPART   ','GEKIN   ','ISTOP   ','INWVOL  '
     +           ,'STEP    ','DESTEP  ','DXMIP   ','TOFG    ','IPL     '
     +           /
      DATA CHNAM2/'IEVENT  ','IPART   ','GEKIN   ','ISTOP   ','INWVOL  '
     +           ,'STEP    ','DESTEP  ','ENER    ','DEDX0   ','DEDX1   '
     +           ,'DEDX2','DEDX3'/

C
C ***            Histograms for shower development
C
      JMA1=LQ(JMATE-IMAT1)
      JMA2=LQ(JMATE-IMAT2)
      DENS1=Q(JMA1+8)
      DENS2=Q(JMA2+8)
      ZMAX=ZECAL
      RMAX=25.
      EMAX=2.*PKINE(1)
      SMAX=1.5*EMAX*DZ2*DENS2/(DZ1*DENS1)
C
      CALL HBOOK1(11,'Total energy deposition by type 1'
     *,100, 0.,EMAX, 0.0)
      CALL HBOOK1(12,'Total energy deposition by type 2'
     *,100, 0.,EMAX, 0.0)
      CALL HBOOK1(13,'Total energy deposition by type 3'
     *,100, 0.,EMAX, 0.0)
      CALL HBOOK1(14,'Total energy deposition by type 4'
     *,100, 0.,EMAX, 0.0)
      CALL HBOOK1(15,'Total energy deposition by type 5'
     *,100, 0.,EMAX, 0.0)
*
      CALL HBOOK1(21,'Total energy seen in MEDI by type 1'
     *,100, 0.,SMAX, 0.0)
      CALL HBOOK1(22,'Total energy seen in MEDI by type 2'
     *,100, 0.,SMAX, 0.0)
      CALL HBOOK1(23,'Total energy seen in MEDI by type 3'
     *,100, 0.,SMAX, 0.0)
      CALL HBOOK1(24,'Total energy seen in MEDI by type 4'
     *,100, 0.,SMAX, 0.0)
      CALL HBOOK1(25,'Total energy seen in MEDI by type 5'
     *,100, 0.,SMAX, 0.0)
*
      CALL HBOOK1(31,'Longit energy deposition by type 1'
     *, 100,-ZMAX,ZMAX,0.)
      CALL HBOOK1(32,'Longit energy deposition by type 2'
     *, 100,-ZMAX,ZMAX,0.)
      CALL HBOOK1(33,'Longit energy deposition by type 3'
     *, 100,-ZMAX,ZMAX,0.)
      CALL HBOOK1(34,'Longit energy deposition by type 4'
     *, 100,-ZMAX,ZMAX,0.)
      CALL HBOOK1(35,'Longit energy deposition by type 5'
     *, 100,-ZMAX,ZMAX,0.)
*
      CALL HBOOK1(41,'Lateral energy deposition by type 1'
     *, 100,0.,RMAX,0.)
      CALL HBOOK1(42,'Lateral energy deposition by type 2'
     *, 100,0.,RMAX,0.)
      CALL HBOOK1(43,'Lateral energy deposition by type 3'
     *, 100,0.,RMAX,0.)
      CALL HBOOK1(44,'Lateral energy deposition by type 4'
     *, 100,0.,RMAX,0.)
      CALL HBOOK1(45,'Lateral energy deposition by type 5'
     *, 100,0.,RMAX,0.)
*
      CALL HBOOK1(51,'Muon range',100,ZECAL,2.*ZECAL,0.)
*
      CALL HBOOK1(65,'Muon DESTEP in MEDI',100,0.,0.,0.)
*
      CALL HROPEN(61,'NTUPLE','gexam8.hist','N',1024,ISTAT)
      IF(ISWIT(8).NE.0)THEN
         CALL HBOOKN(1,'NTUPLE',10,'//NTUPLE',1000,CHNAME)
         CALL HBOOKN(2,'NTUPLE',12,'//NTUPLE',1000,CHNAM2)
      ENDIF

      END
+DECK,  VIEWYZ, T=FORT.
* Revision 1.2  1996/02/22 13:27:00  ravndal
* Cleaning up CARTOCVS interface
* Revision 1.1.1.1  1995/10/24 10:22:23  cernlib
* Geant

      SUBROUTINE VIEWYZ (IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Draw full set up in 'view bank' mode.                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, PVOLUM.

      CALL GSATT('*','SEEN', 0)
      CALL GSATT('ECAL','SEEN', 1)
C
C             Create bank for view YZ.
C
      CALL GDOPEN(IVIEW)
C
      SX=0.9*10./ZECAL
      SY=SX
      CALL GDRAWC ('ECAL', 1, 0., 10.,10.,SX,SY)
C
      CALL GDCLOS
C
      END

+PATCH, EXAMPLES_GEXAM5.
+KEEP, NASCOM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:16  cernlib
* Geant
* nascom.inc
      COMMON/NASCOM/ED1,ED2,ETOT,NTWO
C
+DECK,  EXAM5, T=DATA.
LIST
TRIGGER  10000
DEBUG 0 0 1000
COMP 1
PAIR 1
BREM 1
ANNI 1
PHOT 1
CUTS 0.0005 0.0005 3*0.001    ( CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO)
KINE 1  0.00443  -74.29   (PARTICLE TYPE, ENERGY, VERTEX)
TIME 2=10.       (TIME LEFT FOR UGLAST)
END





+DECK,  G321X5_INP_D, T=DATA, IF=DOC.
READ 4
TIME 2=60.
STOP
+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/01 15:03:13  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE GUKINE
*
************************************************************************
*                                                                      *
*             Read or Generates Kinematics for primary tracks          *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, NASCOM.
*
      DIMENSION VERTEX(3),PLAB(3)
*
*     -----------------------------------------------------------------
*

      VERTEX(1) = 0.
      VERTEX(2) = 0.
      VERTEX(3) = PKINE(2)
C
      PLAB(1) = 0
      PLAB(2) = 0
      PLAB(3) = PKINE(1)
*
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
      CALL GSKINE(PLAB,IKINE,NVERT,0,0,NT)
*
*             Reset energy deposited
*
      ED1=0.
      ED2=0.
      ETOT=0.
*
*              Kinematic debug (controled by ISWIT(1))
*
      IF(IDEBUG.EQ.1.AND.ISWIT(1).EQ.1) THEN
        CALL GPRINT('VERT',0)
        CALL GPRINT('KINE',0)
      ENDIF
*
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/01 15:03:14  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE GUOUT
*
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each event.            *
C.    *                                                                *
C.    ******************************************************************
C.
C.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, NASCOM.
*
      SAVE ID101,ID102,ID103,ID104
      DATA ID101,ID102,ID103,ID104/4*0/
C.
C.    ------------------------------------------------------------------
C.
      ITWO=0
      IF((ED1.GT.1.E-10).AND.(ED2.GT.1.E-10))THEN
         NTWO=NTWO+1
         ITWO=1
         CALL HFF1(101,ID101,ED1,1.)
         CALL HFF1(102,ID102,ED2,1.)
         CALL HFF1(103,ID103,ETOT,1.)
         CALL HFF2(104,ID104,ED2,ED1,1.)
      ENDIF
C
      IF(IDEBUG.NE.0)THEN
         IF(ITWO.NE.0.OR.ISWIT(6).NE.0)THEN
            WRITE(LOUT,701)IEVENT,NTWO,ED1,ED2,ETOT
 701        FORMAT(' --------- SUMMARY OF EVENT NR ',I6,
     +      ' NTWO =',I5,' ----------',/
     +      ' ENERGY DEPOSIT IN D1 :',E11.3,' GEV',/
     +      ' ENERGY DEPOSIT IN D2 :',E11.3,' GEV',/
     +      ' SUM OF ENERGY DEPOSITS:',E11.3,' GEV')
*
         ENDIF
      ENDIF
  100 RETURN
*
      END
C
+DECK,  GUSTEP, T=FORT.
* Revision 1.2  1996/02/01 15:03:15  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE GUSTEP
*
************************************************************************
*                                                                      *
*             User routine called at the end of each tracking step     *
*             MEC   is the mechanism origin of the step                *
*             INWVOL is different from 0 when the track has reached    *
*                    a volume boundary                                 *
*             ISTOP is different from 0 if the track has stopped       *
*                                                                      *
************************************************************************
*
+CDE, GCTMED.
+CDE, GCKING.
+CDE, GCFLAG.
+CDE, GCTRAK.
+CDE, NASCOM.
*
*     -----------------------------------------------------------------
*
*             Accumulate energy deposited in silicon
*
      IF     (NUMED.EQ.2)THEN
         IF(DESTEP.GT.0.)THEN
            ED1=ED1+DESTEP
            ETOT=ETOT+DESTEP
         ENDIF
      ELSEIF (NUMED.EQ.3)THEN
         IF(DESTEP.GT.0.)THEN
            ED2=ED2+DESTEP
            ETOT=ETOT+DESTEP
         ENDIF
      ENDIF
*
*             Something generated ?
*
      IF(NGKINE.GT.0) THEN
          CALL GSKING(0)
      ENDIF
*
*             Debug/plot event
      IF(IDEBUG.EQ.1) THEN
        IF((ISWIT(2).EQ.1).OR.(ISWIT(3).EQ.1)) CALL GSXYZ
        IF (ISWIT(2).EQ.2) CALL GPCXYZ
        IF (ISWIT(2).EQ.3) CALL GDCXYZ
      ENDIF
      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE GUTREV
*
************************************************************************
*                                                                      *
*             User routine to control tracking of one event            *
*                                                                      *
*             Called by GRUN (in GEANT, controls a run of events)      *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
*
*     -----------------------------------------------------------------
*..geant..(TRAK 110)..
      CALL GTREVE
C..              in turn calls GUTRAK which, if not here,
C..              is in GEANT3. GUTRAK calls GTRACK (steering routine
C..              to track a ptcl).
*
*             Debug and plot tracks.
*
      IF(IDEBUG.EQ.1) THEN
        IF(ISWIT(2).EQ.1) CALL GPRINT('JXYZ', 0)
        IF(ISWIT(3).EQ.1) THEN
C..geant..draw a view..
          CALL GDSHOW(1)
C..geant..draw a track (0 means all tracks)..
          CALL GDXYZ (0)
          CALL ICLRWK(0,0)
        ENDIF
      ENDIF
*
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

+SELF, IF=-INTER.
      PROGRAM GEXAM5
*
************************************************************************
*                                                                      *
C....................................................
C....    Try at COMPTEL simulation                  .
C....                                               .
C....                                       Eamonn  .
C....                                      TMA/ESTEC.
C......................................................
C.                                                    .
*                                                                      *
************************************************************************
*
      COMMON/PAWC/H(10000)
      COMMON/GCBANK/Q(80000)
*
*     ------------------------------------------------------------------
*
      CALL TIMEST(1E5)
*
      CALL GZEBRA(80000)
      CALL HLIMIT(-10000)
*
*     Initialise graphics
      CALL HPLINT(0)
*
*             Geant initialization
      CALL UGINIT
*
*             Test printings.
      CALL GPRINT('PART',0)
      CALL GPRINT('MATE',0)
      CALL GPRINT('TMED',0)
      CALL GPRINT('VOLU',0)
*
*             Start events processing
      CALL GRUN
*
*             End of run
      CALL UGLAST
*
      END
+SELF.
+DECK,  UFILES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
      CHARACTER*(*) FILNAM, FSTAT
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='gexam5.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GEXAM5 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='OLD')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,
+SELF, IF=VAX.
     +     READONLY,
+SELF.
     +     FORM='FORMATTED')
*
*             Open a HBOOK direct access file
*
      CALL HROPEN(34,'HBOOK','gexam5.hist','N',1024,ISTAT)
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.2  1996/02/01 15:03:16  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE UGEOM
*
************************************************************************
*                                                                      *
*             Routine to define the geometry of the set-up.            *
*                                                                      *
************************************************************************
*
*
+CDE, NASCOM.
*
      DIMENSION PAR(10)
      DIMENSION ANE213(4),ZNE213(4),WNE213(4)
*
      DATA ANE213/1.01,12.01,20.18,16.01/
      DATA ZNE213/1.,6.,10.,8./
      DATA WNE213/0.5493,0.4505,0.0001,0.0001/
*
*     -----------------------------------------------------------------
*
*
*             Defines materials
      CALL GSMATE( 1,'VACUUM$  ',1.E-16,1.E-16,1.E-16,1.E16,1.E16, 0,0)
      CALL GSMATE( 5,'LIQ NE213$',  6.26,3.25,0.874 , 43.0,   437.,0,0)
      CALL GSMIXT( 2,'LIQ NE213$',ANE213,ZNE213,0.874,4,WNE213)
      CALL GSMATE( 3,'NAI(TL)$    ', 74.95,32.,3.67,   2.6,   41.3,0,0)
*
*             Defines tracking media parameters.
      FIELDM =  0.
      IFIELD =  0
      TMAXFD =  0.
      DMAXMS =  0.5
      DEEMAX =  0.2
      EPSIL  =  0.01
      STMIN  =  0.8
*
      CALL GSTMED( 1,'VACUUM            $'    ,  1 , 0 , IFIELD,
     *                FIELDM,TMAXFD,0.,0., EPSIL, STMIN, 0 , 0 )
      CALL GSTMED( 2,'LIQ NE213$'    ,  2 , 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
      CALL GSTMED( 3,'NAI(TL)  $'    ,  3 , 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
*             Change CUTS for Ne213
*
      CALL GSTPAR(2,'CUTGAM',0.00005)
      CALL GSTPAR(2,'CUTELE',0.00005)
*
*             Defines geometry of the set-up
*
        PAR(1)=0.
        PAR(2)=15.
        PAR(3)=80.
      CALL GSVOLU('SETU', 'TUBE', 1, PAR, 3, IVOLU)
        PAR(1)=0.
        PAR(2)=14.
        PAR(3)=4.25
      CALL GSVOLU('DET1', 'TUBE', 2, PAR, 3, IVOLU)
        PAR(1)=0.
        PAR(2)=14.25
        PAR(3)=3.75
      CALL GSVOLU('DET2', 'TUBE', 3, PAR, 3, IVOLU)
C
      CALL GSPOS('DET1', 1, 'SETU', 0, 0,   -75., 0, 'ONLY')
      CALL GSPOS('DET2', 1, 'SETU', 0, 0, 76.25 , 0, 'ONLY')
*
      CALL GSORD('SETU',3)
*
*             Close geometry banks. Mandatory system routine.
*
      CALL GGCLOS
*
      END
+DECK,  UGINIT, T=FORT.
* Revision 1.2  1996/02/01 15:03:17  ravndal
* Clean up repository
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE UGINIT
*
************************************************************************
*                                                                      *
*              To initialise GEANT3 program and read data cards        *
*                                                                      *
************************************************************************
*
+CDE, GCKINE.
+CDE, GCUNIT.
+CDE, NASCOM.
*
*     -----------------------------------------------------------------
*
*             Open user files
*
      CALL UFILES
*
*             Initialize GEANT
C..geant..
      CALL GINIT
*
*             Prints version number
*
      WRITE(LOUT,1000)
*
*             IKINE  = particle type (default=1=gamma)
*             PKINE(1)=particle energy
*             PKINE(2)=vertex position in Z
*             IKINE and PKINE can be changed with the data card KINE
*
      NTWO =0
      IKINE=1
      PKINE(1)=0.00443
      PKINE(2)=-79.24
*
*             Read data cards with FFREAD
*
C..geant..
      CALL GFFGO
*
*             Initialize GEANT/ZBOOK data structures
*
C..geant..
      CALL GZINIT
+SELF, IF=HIGZ.
*
*             Initialize graphics package
*
      CALL GDINIT
+SELF.
*
*             Geometry and materials description.
*
      CALL UGEOM
*
*             Particle table definition and energy loss initialization.
*
C..geant..
      CALL GPART
C..geant..
      CALL GPHYSI
+SELF, IF=HIGZ.
*
*             Initialize COMPTEL graphics
*
      CALL VIEWYZ(1)
+SELF.
C..book user histograms:
      CALL UHINIT
*
 1000 FORMAT(/,'  GEXAM5 VERSION 1.00 : ',/)
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE UGLAST
*
************************************************************************
*                                                                      *
*            Termination routine to print histograms and statistics    *
*                                                                      *
************************************************************************
      CHARACTER*(*) FILNAM, FSTAT
      INTEGER IDVEC(100),IDN
      INTEGER ENTR
      REAL MEAN,RMS
      REAL DEF(100,2)
C
C
C     Control values, which have been obtained
C     using:
C     HP 720 running HP-UX 9
C     GEANT 3.21/02, CERNLIB release 94A
C
      DATA ((DEF(I,J),J=1,2),I=1,3)
     +        /   0.0006, 0.0008,
     +            0.0030, 0.0013,
     +            0.0035, 0.0012/
C
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='g_install5.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/G_INSTALL5 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='UNKNOWN')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
*     -----------------------------------------------------------------
*
      CALL GLAST
C
C
C     Create a output file on unit 99 for the default installation
C     test run
C     The test consists of 10 events of 10 GeV photons
C
      OPEN(UNIT=99,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
C
      WRITE(99,15000)
      WRITE(99,15001)
      WRITE(99,15002)
      WRITE(99,15003)
      WRITE(99,15004)
      WRITE(99,15005)
      WRITE(99,15006)
C
      CALL HID1(IDVEC,IDN)
      IF(IDN.GE.1.AND.IDN.LE.100) THEN
C
          CALL HNOENT(1,ENTR)
          WRITE(99,20000) ENTR
          DO I=1,IDN
              MEAN = HSTATI(IDVEC(I),1,' ',0)
              RMS  = HSTATI(IDVEC(I),2,' ',0)
              WRITE(99,20100) IDVEC(I)
              WRITE(99,20200) MEAN,RMS
              WRITE(99,20300) DEF(I,1),DEF(I,2)
          END DO
      END IF
C

      CLOSE(99)
C
C
C             Save histograms
C
      CALL HROUT(0,ICYCLE,' ')
      CALL HREND('HBOOK')
*
*             Print HBOOK histograms
*
      CALL HPRINT(0)
+SELF, IF=HIGZ.
*
*             Close GKS display file
*
      CALL IGEND
+SELF.
*
15000 FORMAT(/,'                   GEANT Installation control file')
15001 FORMAT('                   _______________________________')
15002 FORMAT(/,'The default values were obtained using:')
15003 FORMAT(/,3X,'GEANT Version 3.21/02')
15004 FORMAT(3X,'CERNLIB release 94A')
15005 FORMAT(3X,'HP 720 running HP-UX 9')
15006 FORMAT(3X,'Date: 11 Oct 1994')
20000 FORMAT(/,1x,'Number of Entries ',I6,20X,'Mean',6X,'RMS')
20100 FORMAT(/,1x,'Histogram Id: ',I3)
20200 FORMAT(1X,'Mean Entry value/R.M.S           :'
     +         ,(5X,2F10.4))
20300 FORMAT(1X,'Default values of GEANT 3.21/02  :'
     +         ,(5X,2F10.4))
      END
+DECK,  UINIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE UHINIT
*
************************************************************************
*                                                                      *
*             To book the user's histograms                            *
*                                                                      *
************************************************************************
*
*
+CDE, GCKINE.
*
*     ------------------------------------------------------------------
*
      ELOW = 0.
      EHIG = 1.2*PKINE(1)
      CALL HBOOK1(101,'TOT ENERGY IN D1$', 100, ELOW, EHIG, 0.)
      CALL HBOOK1(102,'TOT ENERGY IN D2$', 100, ELOW, EHIG, 0.)
      CALL HBOOK1(103,'TOT ENERGY $', 100, ELOW, EHIG, 0.)
      CALL HBOOK2(104,'ENERGY IN D1 VS IN D2$',
     + 40,ELOW,EHIG,40,ELOW,EHIG,10000.)
*
      END
+DECK,  VIEWYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:17  cernlib
* Geant

      SUBROUTINE VIEWYZ (IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Draw full set up in 'view bank' mode.                      *
C.    *                                                                *
C.    ******************************************************************
C.
      CALL GSATT('*','SEEN', 1)
C
C             Create bank for view YZ.
C
      CALL GDOPEN(IVIEW)
C
      CALL GDHEAD(110110, 'VIEW YZ$' ,0.5)
C
      CALL GDRAWC ('SETU', 1,0., 10.,10.,0.05,0.1)
C
      CALL GDCLOS
C
      END
+PATCH, EXAMPLES_GEXAM2.
+KEEP, CDHSCOM, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant
* cdhscom.inc
      COMMON/CDHSC/SIGP,EMUON,SIGBX,SIGBY,
     +               ESINT(8,16),TRESHO,TRIGGE
*
* cdhscom.inc
*
+CDE, INCBEG.
     +   cdhscom
+CDE, INCEND.
+KEEP, CDHSCOM.
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant
* cdhscom.inc
      COMMON/CDHSC/SIGP,EMUON,SIGBX,SIGBY,
     +               ESINT(8,16),TRESHO,TRIGGE
*
* cdhscom.inc
*
+DECK,  EXAM2, T=DATA.
LIST
TRIGGER  10
DEBUG 1 1 1
HADR 1
COMP 1
PAIR 1
BREM 1
ANNI 1
DRAY 1
LOSS 1
PHOT 1
CUTS 0.001 0.001 3*0.005
KINE 9 138.8
SIGB  2.5 1.
SIGP  0.037
MUON 0.00652
TRHS  0.3  3.
END






+DECK,  G321X2_INP_D, T=DATA, IF=DOC.
READ 4
TIME 2=60.
STOP
+DECK,  GECDHS, T=FORT.
* Revision 1.2  1996/02/01 14:54:48  ravndal
* Clean up the repository
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE GECDHS
*
************************************************************************
*                                                                      *
*             Routine to define the geometry of the set-up.            *
*                                                                      *
************************************************************************
*
+CDE, CDHSCOM.
*
      DIMENSION PAR(10)
*
*     -----------------------------------------------------------------
*
*
*             Defines materials
      CALL GSMATE( 1,'AIR$     ',  15.0,7.0,0.0012,30050.0,67500.0,0,0)
      CALL GSMATE( 2,'PLAST SC$',  6.25,3.4,1.032 ,   43.0,   437.,0,0)
      CALL GSMATE( 3,'IRON$    ', 55.85,26.,7.8   ,   1.76,   17.1,0,0)
*
*             Defines tracking media parameters.
      FIELDM =  0.
      IFIELD =  0
      TMAXFD =  0.
      DMAXMS = +0.50
      DEEMAX = +0.20
      EPSIL  =  0.01
      STMIN  =  0.80
*
      CALL GSTMED( 1,'AIR               $'    ,  1 , 0 , IFIELD,
     *                FIELDM,TMAXFD,0.,0., EPSIL, STMIN, 0 , 0 )
      CALL GSTMED( 2,'PLASTIC SCINTILLAT$'    ,  2 , 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
      CALL GSTMED( 3,'IRON              $'    ,  3 , 0 , IFIELD,
     *                FIELDM,TMAXFD,DMAXMS,DEEMAX, EPSIL, STMIN, 0 , 0 )
*
*
*
*             Defines geometry of the set-up
*
*             Define the overall calorimeter
*
      PAR(1)=0.
      PAR(2)=187.5
      PAR(3)=166.0
      CALL GSVOLU('CDHS', 'TUBE', 1, PAR, 3, IVOLU)
*
*             Now define one module,
*
      PAR(1)=0.0
      PAR(3)=31.
      CALL GSVOLU('MODU', 'TUBE', 1, PAR, 3, IVOLU)
*
*             position it
*
      ZC = -225.
      DO 1 J=1,4
        ZC=ZC+90.
        CALL GSPOS('MODU', J, 'CDHS', 0.0, 0.0, ZC, 0, 'ONLY')
   1  CONTINUE
*
*             and divide it.
*
      CALL GSDVN('PLAN', 'MODU',20, 3)
*
*             Define the iron block
*
      PAR(3)=1.225
      CALL GSVOLU('SHEE', 'TUBE', 3, PAR, 3, IVOLU)
*
*             and position it.
*
      CALL GSPOS('SHEE', 1, 'PLAN', 0.0, 0.0, -0.325, 0, 'ONLY')
*
*             Define the scintillator thickness
*
      PAR(3)=0.23
      CALL GSVOLU('SINT', 'TUBE', 2, PAR, 3, IVOLU)
*
*             and position it.
*
      CALL GSPOS('SINT', 1, 'PLAN', 0.0, 0.0, 1.13, 0, 'ONLY')
*
*
*             Optimisation of geometry definition
*
      CALL GSORD('CDHS',3)
      CALL GSORD('PLAN',3)
*
*             Close geometry banks. Mandatory system routine.
*
      CALL GGCLOS
*
      END
+DECK,  GUKINE, T=FORT.
* Revision 1.2  1996/02/01 14:54:49  ravndal
* Clean up the repository
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE GUKINE
*
************************************************************************
*                                                                      *
*             Read or Generates Kinematics for primary tracks          *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, CDHSCOM.
      DIMENSION VERTEX(3),PLAB(3)
*
*     -----------------------------------------------------------------
*
      CALL GRANOR(RANX, RANY)
      VERTEX(1) = -60.0 + RANX * SIGBX
      VERTEX(2) = -80.0 + RANY * SIGBY
      VERTEX(3) = -165.999
      CALL GRANOR(RANP, DUMMY)
      PLAB(1) = 0.0
      PLAB(2) = 0.0
      PLAB(3) = PKINE(1) * (1. + SIGP * RANP)
*
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
      CALL GSKINE(PLAB,IKINE,NVERT,0,0,NT)
*
*             Reset energy deposited
*
      CALL VZERO(ESINT,128)
*
*              Kinematic debug (controled by ISWIT(1))
*
      IF(IDEBUG.EQ.1.AND.ISWIT(1).EQ.1) THEN
        CALL GPRINT('VERT',0)
        CALL GPRINT('KINE',0)
      ENDIF
*
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.2  1996/02/01 14:54:50  ravndal
* Clean up the repository
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE GUOUT
*
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each event.            *
C.    *                                                                *
C.    ******************************************************************
C.
C.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, CDHSCOM.
      SAVE ID101,ID102,ID103,ID104
      DATA ID101,ID102,ID103,ID104/4*0/
C.
C.    ------------------------------------------------------------------
C.
      ENEP = 0.0
      ENEP2 = 0.0
      NACT = 0
      DO 10 J=1,16
        ESTOT=VSUM(ESINT(1,J),8)
        CALL HFF1(104,ID104,ESTOT,1.0)
        ENEP=ENEP+ESTOT
        ENEP2=ENEP2+ESTOT**2
        IF(ESTOT.NE.0.0) NACT=NACT+1
  10  CONTINUE
      IF(NACT.GT.0) THEN
        EMEAN = ENEP / FLOAT(NACT)
        ERMS  = ENEP2 / FLOAT(NACT) - EMEAN**2
        ERMS  = SQRT(ERMS)
      ENDIF
*
      ETOT = 0.0
      DO 30 J=1,16
         ENEP=0.
         DO 20 K=1,8
            ENEPK=ESINT(K,J)/EMUON
            IF(ENEPK.GT.TRESHO)ENEP=ENEP+ENEPK
  20     CONTINUE
         IF(J.EQ.1)ENEP1=ENEP
         IF(ENEP.GT.TRESHO) THEN
            ETOT = ETOT+ENEP
            CALL HFF1(102, ID102,FLOAT(J), ENEP)
            IF(ENEP1.GT.TRIGGE) CALL HFF1(103, ID103,FLOAT(J), ENEP)
         ENDIF
  30  CONTINUE
      ETOT = ETOT * 2.5
      CALL HFF1(101, ID101,ETOT, 1.0)
*
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.2  1996/02/01 14:54:51  ravndal
* Clean up the repository
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE GUSTEP
*
************************************************************************
*                                                                      *
*             User routine called at the end of each tracking step     *
*             MEC   is the mechanism origin of the step                *
*             INWVOL is different from 0 when the track has reached    *
*                    a volume boundary                                 *
*             ISTOP is different from 0 if the track has stopped       *
*                                                                      *
************************************************************************
*
+CDE, GCTMED.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCFLAG.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, CDHSCOM.
*
*     -----------------------------------------------------------------
*
*             Accumulate energy deposited in cscintillator
*
      IF(NUMED.EQ.2)THEN
         IF(DESTEP.GT.0.)THEN
            INDEX  = (NUMBER(2) - 1)*4 + (NUMBER(3)-1)/5+1
            IPL=(VECT(2)+188.)/47. + 1
            ESINT(IPL,INDEX) = ESINT(IPL,INDEX) + DESTEP
         ENDIF
      ENDIF
*
*             Something generated ?
*
      IF(NGKINE.GT.0) THEN
        DO 5 I=1,NGKINE
          ITYPA  = GKIN(5,I)
          IF(ITYPA.NE.4) CALL GSKING(I)
   5    CONTINUE
      ENDIF
*
*             Debug/plot event
*
      IF(IDEBUG.NE.0) THEN
        IF((ISWIT(2).EQ.1).OR.(ISWIT(3).EQ.1)) CALL GSXYZ
        IF (ISWIT(2).EQ.2) CALL GPCXYZ
+SELF, IF=HIGZ.
        IF (ISWIT(2).GT.2)THEN
           IF(ISWIT(2).EQ.3) CALL GDCXYZ
           IF(ISWIT(2).EQ.4.AND.CHARGE.NE.0.) CALL GDCXYZ
           IF(ISWIT(2).EQ.5.AND.
     +        (IPART.EQ.2.OR.IPART.EQ.3)) CALL GDCXYZ
        ENDIF
+SELF.
      ENDIF
      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE GUTREV
*
************************************************************************
*                                                                      *
*             User routine to control tracking of one event            *
*                                                                      *
*             Called by GRUN                                           *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
*
*     -----------------------------------------------------------------
*
      CALL GTREVE
*
*             Debug and plot tracks.
*
      IF(IDEBUG.EQ.1) THEN
        IF(ISWIT(2).EQ.1) CALL GPRINT('JXYZ', 0)
+SELF, IF=HIGZ.
        IF(ISWIT(3).EQ.1) THEN
          CALL GDSHOW(1)
          CALL GDXYZ (0)
          CALL ICLRWK(0,0)
        ENDIF
+SELF.
      ENDIF
*
      END
+DECK,  INCDEK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

+SELF.
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

+SELF, IF=-INTER.
      PROGRAM GEXAM2
*
************************************************************************
*                                                                      *
*             Test program for the CDHS set-up                         *
*       Authors    R.Brun, F.Carminati  *********                      *
*                                                                      *
************************************************************************
*
      COMMON/PAWC/H(10000)
      COMMON/GCBANK/Q(80000)
*
*     ------------------------------------------------------------------
*
      CALL TIMEST(1E5)
*
      CALL GZEBRA(80000)
      CALL HLIMIT(-10000)
*
*             Geant initialization.
      CALL UGINIT
*
*             Start events processing.
      CALL GRUN
*
*             End of run.
      CALL UGLAST
      STOP
      END
+SELF.
+DECK,  UFILES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
      CHARACTER*(*) FILNAM, FSTAT
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='gexam2.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GEXAM2 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='OLD')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,
+SELF, IF=VAX.
     +     READONLY,
+SELF.
     +     FORM='FORMATTED')
*
*             Open a HBOOK direct access file
*
      CALL HROPEN(34,'HBOOK','gexam2.hist','N',1024,ISTAT)
      END
+DECK,  UGINIT, T=FORT.
* Revision 1.2  1996/02/01 14:54:52  ravndal
* Clean up the repository
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE UGINIT
*
************************************************************************
*                                                                      *
*              To initialise GEANT3 program and read data cards        *
*                                                                      *
************************************************************************
*
+CDE, GCUNIT.
+CDE, GCKINE.
+CDE, CDHSCOM.
*
*     -----------------------------------------------------------------
*
*             Open user files
*
      CALL UFILES
*
*             Initialize GEANT
*
      CALL GINIT
*
*             Prints version number
*
      WRITE(LOUT,1000)
*
*             Set default values in /CDHSCOM/
*             Define additional data cards to modigy them
*
      IKINE  = 9
      PKINE(1)  = 140.0
      SIGBX  = 2.50
      SIGBY  = 1.00
      SIGP   = 0.025
      EMUON   = 1.0
      TRESHO = 0.6
      TRIGGE = 3.0
      CALL FFKEY('SIGB', SIGBX, 2, 'REAL')
      CALL FFKEY('SIGP',  SIGP, 1, 'REAL')
      CALL FFKEY('MUON', EMUON, 1, 'REAL')
      CALL FFKEY('TRHS', TRESHO,2, 'REAL')
*
*             Read data cards with FFREAD
*
      CALL GFFGO
*
*             Initialize GEANT/ZEBRA data structures
*
      CALL GZINIT
*
+SELF, IF=HIGZ.
*
*             Initialize graphics package
*
      CALL GDINIT
+SELF.
*
*             Geometry and materials description.
*
      CALL GECDHS
*
*             Particle table definition and energy loss initialization.
*
      CALL GPART
      CALL GPHYSI
*
+SELF, IF=HIGZ.
*
*             Create a view bank
*
      CALL VIEWYZ(1)
+SELF.
      CALL UINIT
*
 1000 FORMAT(/,'  GEXAM2 VERSION 1.00 : ',/)
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.2  1996/02/01 14:54:52  ravndal
* Clean up the repository
* Revision 1.1.1.1  1995/10/24 10:22:11  cernlib
* Geant

      SUBROUTINE UGLAST
*
************************************************************************
*                                                                      *
*            Termination routine to print histograms and statistics    *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
+CDE, CDHSCOM.
      CHARACTER*(*) FILNAM, FSTAT
      INTEGER IDVEC(100),IDN
      INTEGER ENTR
      REAL MEAN,RMS
      REAL DEF(100,2)
C
C     Control values, which have been obtained
C     using:
C     HP 720 running HP-UX 9
C     GEANT 3.21/02, CERNLIB release 94A
C
      DATA ((DEF(I,J),J=1,2),I=1,4)
     +        /1242.4821,76.8034,
     +            5.4546, 2.2776,
     +            4.1940, 2.2776,
     +             .2116,  .3326/
C
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='g_install2.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/G_INSTALL2 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='UNKNOWN')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
*     -----------------------------------------------------------------
*
      CALL GLAST
*
*             Print HBOOK histograms
*
      XNORM=1./(FLOAT(IEVENT)+0.0000001)
      CALL HOPERA(102,'+   ',102,102,XNORM,0.)
      CALL HOPERA(103,'+   ',103,103,XNORM,0.)
C
C     Create a output file on unit 99 for the default installation
C     test run
C     The test consists of 10 events of 10 GeV photons
C
      OPEN(UNIT=99,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
C
      WRITE(99,15000)
      WRITE(99,15001)
      WRITE(99,15002)
      WRITE(99,15003)
      WRITE(99,15004)
      WRITE(99,15005)
      WRITE(99,15006)
C
      CALL HID1(IDVEC,IDN)
      IF(IDN.GE.1.AND.IDN.LE.100) THEN
C
          CALL HNOENT(1,ENTR)
          WRITE(99,20000) ENTR
          DO I=1,IDN
              MEAN = HSTATI(IDVEC(I),1,' ',0)
              RMS  = HSTATI(IDVEC(I),2,' ',0)
              WRITE(99,20100) IDVEC(I)
              WRITE(99,20200) MEAN,RMS
              WRITE(99,20300) DEF(I,1),DEF(I,2)
          END DO
      END IF
C
      CLOSE(99)
C
C             Save histograms
C
      CALL HROUT(0,ICYCLE,' ')
      CALL HREND('HBOOK')
      CALL HPRINT(0)
+SELF, IF=HIGZ.
*
*             Close GKS display file
*
      CALL IGEND
+SELF.
15000 FORMAT(/,'                   GEANT Installation control file')
15001 FORMAT('                   _______________________________')
15002 FORMAT(/,'The default values were obtained using:')
15003 FORMAT(/,3X,'GEANT Version 3.21/02')
15004 FORMAT(3X,'CERNLIB release 94A')
15005 FORMAT(3X,'HP 720 running HP-UX 9')
15006 FORMAT(3X,'Date: 11 Oct 1994')
20000 FORMAT(/,1x,'Number of Entries ',I6,20X,'Mean',6X,'RMS')
20100 FORMAT(/,1x,'Histogram Id: ',I3)
20200 FORMAT(1X,'Mean Entry value/R.M.S           :'
     +         ,(5X,2F10.4))
20300 FORMAT(1X,'Default values of GEANT 3.21/02  :'
     +         ,(5X,2F10.4))
*
      END
+DECK,  UINIT, T=FORT.
* Revision 1.2  1996/02/01 14:54:53  ravndal
* Clean up the repository
* Revision 1.1.1.1  1995/10/24 10:22:12  cernlib
* Geant

      SUBROUTINE UINIT
*
************************************************************************
*                                                                      *
*             To book the user's histograms                            *
*                                                                      *
************************************************************************
*
+CDE, GCKINE.
+CDE, CDHSCOM.
*
*     ------------------------------------------------------------------
*
      ELOW = PKINE(1) * .2
      EHIG = PKINE(1) * 20.
      CALL HBOOK1(101,'TOT ENERGY IN SINT$', 100, ELOW, EHIG, 0.)
      CALL HBOOK1(102,'NEPS PER PLANE$',96,0.5,16.5,0.)
      CALL HBOOK1(103,'NEPS FIRST PLANE EVENT$',96,0.5,16.5,0.)
      CALL HBOOK1(104,'PULSE HEIGTH PER PLANE$',100,0.,5.,0.)
*
      END
+DECK,  VIEWYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:12  cernlib
* Geant

+SELF, IF=HIGZ.
      SUBROUTINE VIEWYZ (IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Draw full set up in 'view bank' mode.                      *
C.    *                                                                *
C.    ******************************************************************
C.
      CALL GSATT('*','SEEN', 0)
C
      CALL GSATT('SINT','SEEN', 1)
C
C             Create bank for view YZ.
C
      CALL GDOPEN(IVIEW)
C
      CALL GDHEAD(110110, 'VIEW YZ$' ,0.5)
C
      CALL GDRAWC ('CDHS', 1, 0., 10.,10.,0.05,0.04)
C
      CALL GDCLOS
C
      END
+SELF.
+PATCH, EXAMPLES_GEXAM3.
+KEEP, MOMENTID, IF=PARA.
c     Arrays that hold the mommenta and particle-id of initial tracks
      integer     MAXNTR
      parameter  (MAXNTR=100)

      integer     ntr
      real        p1s(3,MAXNTR)
      Integer     itypes(MAXNTR)
      common   /momentid/ ntr, p1s, itypes
+DECK,  DLSOUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE DLSOUT
C
+CDE, GCFLAG.
C
      DIMENSION NUMVS(2),ITRA(50)
      DIMENSION NUMV1(2,50),NUMV2(2,50),NUMV3(2,50),NUMV4(2,50)
      DIMENSION HITS1(9,50),HITS2(9,50),HITS3(9,50),HITS4(9,50)
      DIMENSION VERT(3),PVERT(4)
      SAVE NUMVS
      DATA NUMVS/0,0/
C
      IF(ISWIT(10).LT.3)GO TO 99
      LUN=ISWIT(10)

      CALL GFHITS('DRFT','FSP ',2,9,50,0,NUMVS,ITRA,NUMV1,HITS1,NHITS1)
      CALL GFHITS('DRFT','RSP1',2,9,50,0,NUMVS,ITRA,NUMV2,HITS2,NHITS2)
      CALL GFHITS('DRFT','RSP2',2,9,50,0,NUMVS,ITRA,NUMV3,HITS3,NHITS3)
      CALL GFHITS('DRFT','RSP3',2,9,50,0,NUMVS,ITRA,NUMV4,HITS4,NHITS4)
C
      CALL GFKINE(1,VERT,PVERT,IP,NVERT,UBUF,NUBUF)
C
      WRITE(LUN)NHITS1,NHITS2,NHITS3,NHITS4,IP,VERT,PVERT
      IF(NHITS1.GT.0)THEN
        WRITE(LUN)(NUMV1(2,I),(HITS1(J,I),J=1,9),I=1,NHITS1)
      ENDIF
      IF(NHITS2.GT.0)THEN
        WRITE(LUN)(NUMV2(2,I),(HITS2(J,I),J=1,9),I=1,NHITS2)
      ENDIF
      IF(NHITS3.GT.0)THEN
        WRITE(LUN)(NUMV3(2,I),(HITS3(J,I),J=1,9),I=1,NHITS3)
      ENDIF
      IF(NHITS4.GT.0)THEN
        WRITE(LUN)(NUMV4(2,I),(HITS4(J,I),J=1,9),I=1,NHITS4)
      ENDIF
C
  99  RETURN
      END
+DECK,  EXAM3, T=DATA.
LIST
TRIGGER 10
DEBUG 1 1 1
SWIT 1 2
SETS 'DRFT'
END
   14
  0.4378 -0.0045  2.300613
 -0.5821  0.1841  0.868513
 -0.4349 -0.0148  0.738514
  0.4291  0.1618  0.346414
 -0.5418 -0.0193  2.720513
  0.3770 -0.0037  0.842314
  0.5825 -0.1207  0.132613
 -0.2316  0.0453  1.198014
  0.0430  0.0185  0.213614
 -0.7536  0.0243  0.140214
 -0.0772  0.0305  0.401714
 -0.5071 -0.0813  0.1786 8
  0.3444  0.0529  0.5787 8
 -0.1724  0.0060  0.1471 7
   19
 -0.7748 -0.2270  2.907613
 -0.1614 -0.0649  0.480313
  0.2609 -0.0425  0.107114
  0.5167 -0.0083  2.721613
 -0.3553  0.0345  0.084014
 -0.2974 -0.0639  0.916514
  0.4621 -0.2127  2.869514
  0.2454  0.0240  0.784813
 -0.4153 -0.0752  0.433713
  0.7705  0.2647  1.488613
  0.5251 -0.1539  0.292713
 -0.9955  0.3666  2.376313
 -0.1600  0.0145  0.2967 8
  0.1482 -0.0560  0.2513 8
  0.1924 -0.0444  0.5281 7
  0.1671  0.0665  0.2883 9
 -0.2636  0.0587  1.4432 7
  0.1229 -0.0118  0.1158 8
 -0.1066 -0.0275  0.2865 9
   17
 -0.3216  0.0526  1.619214
 -0.6685  0.1749  2.682814
  0.8363 -0.2724  1.934413
 -0.5160 -0.0709  2.734613
  0.1675  0.0599  0.194114
  0.4886 -0.1133  0.107314
 -0.7109  0.0716  0.173014
  0.4575 -0.0628  1.581114
  0.5394  0.0167  2.496613
 -0.6139 -0.2548  1.911013
  0.2867 -0.0963  0.691213
 -0.6873  0.2783  0.701914
  0.4502  0.1574  0.232313
  0.4223 -0.1165  0.3646 9
  0.2815  0.0183  1.5609 7
  0.1020 -0.0218  0.3980 8
 -0.1770  0.0587  0.7353 8
   11
 -0.3993  0.0134  0.357114
  0.1846 -0.0466  0.579214
 -0.7858 -0.2743  3.293213
  0.2280  0.0038  0.034513
 -0.2728  0.0743  0.136514
  0.1249  0.0066  0.2863 8
 -0.0962  0.0447  0.0458 7
  0.1398 -0.0117  0.4812 8
  0.3510  0.1501  1.1456 7
  0.3006 -0.0179  0.8242 8
 -0.1701 -0.0144  0.4544 8
   14
 -0.3490  0.0085  0.242013
 -0.4213 -0.1805  1.417514
  0.7884  0.0679  1.993913
 -0.4438  0.1291  0.498214
  0.6993  0.2907  2.961514
  0.4311  0.0732  1.445114
 -0.2556  0.0467  0.381813
 -0.1482  0.0284  0.225114
  0.2492  0.0183  0.518713
 -0.3086  0.0148  0.0424 9
 -0.6979 -0.2030  0.9139 7
 -0.1480 -0.0229  0.0187 9
 -0.1145 -0.0331  0.0582 8
 -0.1161  0.0434  0.2278 7
   16
 -0.5918  0.2329  0.731914
  0.3345 -0.0355  0.532414
 -0.4588  0.0480  1.887513
 -1.2547 -0.1789  1.974613
  0.6187  0.0742  1.174214
 -0.8991 -0.2385  2.061113
  0.1634  0.0235  0.123313
  0.5521  0.0649  1.865013
  0.3679  0.0495  1.376313
 -0.2499  0.0605  0.099514
  0.4982  0.1763  1.076413
 -0.6505  0.0696  0.908413
  0.1493  0.0214  0.0950 9
 -0.1819  0.0840  0.2913 9
 -0.2267  0.0371  0.4449 9
  0.0622 -0.0052  0.1712 7
   16
  0.3777  0.0969  0.704914
  0.3656  0.0113  0.159014
  0.5284  0.1682  2.050313
 -0.3962 -0.0840  1.673114
  0.8503 -0.3569  0.585614
 -0.7069  0.1247  0.933914
 -0.4048  0.0466  0.044114
  0.2360 -0.0488  0.192714
  0.4363  0.0255  0.923314
  0.2553  0.0150  0.0802 9
 -0.1125  0.0345  0.0595 9
  0.1065 -0.0448  0.2581 9
 -0.1698  0.0346  0.1060 7
  0.1590  0.0734  0.2309 9
 -0.0881  0.0035  0.2172 7
 -0.0571 -0.0247  0.1484 8
    6
  0.3768  0.1420  1.457413
  0.9315 -0.2675  0.738513
  0.1855 -0.0376  1.027914
 -0.8063 -0.2025  2.877813
 -0.3828  0.1546  0.811914
 -0.2602  0.0408  0.0242 7
   17
  0.5934 -0.0448  2.664613
 -0.6900 -0.3083  1.402714
 -0.4611 -0.1334  0.756214
  0.5026  0.2021  2.064713
  0.9111  0.1802  2.731814
 -0.2997 -0.0253  0.292514
 -0.5986 -0.1812  1.638213
 -0.7189  0.3082  0.399814
  0.3014  0.0762  0.525814
 -0.2550 -0.0207  0.497314
 -0.5391 -0.0339  1.532213
 -0.2994  0.0106  0.2318 9
  0.2646  0.0708  0.1947 8
 -0.5612  0.0663  0.5562 9
 -0.1399 -0.0442  0.0183 7
 -0.2895 -0.1184  0.6733 9
 -0.2086  0.0229  1.0552 7
   25
  0.5503 -0.0004  0.542114
 -0.4916  0.1763  1.011014
 -1.0104 -0.2070  4.939613
  0.2408  0.0003  0.431114
 -0.4059  0.0636  0.716514
 -0.2299 -0.0636  0.185314
  0.6302  0.1247  1.437814
  0.8283 -0.3119  1.029714
  0.3940 -0.1609  1.354414
 -0.3591 -0.0865  0.575614
  0.7350 -0.3405  0.560714
  0.2570  0.1128  0.873914
  0.1279 -0.0300  0.0839 7
 -0.1380  0.0096  0.2073 7
  0.0729  0.0045  0.2456 9
 -0.0914  0.0228  0.1171 8
  0.3576 -0.1597  0.4754 9
  0.0633  0.0174  0.0642 8
 -0.1155 -0.0399  0.0928 7
  0.0840  0.0207  0.0887 7
  0.0938 -0.0166  0.2079 9
  0.0834 -0.0281  0.3157 8
 -0.2268  0.0269  0.6298 9
 -0.1362  0.0041  0.6725 8
 -0.1076 -0.0055  0.5167 9
   12
  0.5165  0.1491  0.997214
 -0.6410 -0.1728  1.794613
 -0.5795  0.0324  3.019213
  0.5396 -0.2342  1.599714
 -0.3319 -0.0277  0.208314
 -0.5484  0.2240  2.048113
  0.1374  0.0451  0.150413
  0.4667  0.1664  0.348314
 -0.6940 -0.2128  0.544113
  0.5037  0.1125  1.562513
 -0.3764 -0.1471  1.042314
  0.1449 -0.0570  0.3702 7
   10
  0.4108 -0.1727  1.891313
 -0.8883 -0.2218  1.346013
  0.2819 -0.1042  0.291214
 -0.4141  0.1658  2.194614
  0.6120  0.1916  2.193814
  0.5931 -0.0388  0.746814
  0.2839 -0.0069  0.6193 7
 -0.1825 -0.0093  0.5125 9
  0.2242 -0.0420  0.0906 8
 -0.2360  0.0402  0.5901 8
    9
  0.3556 -0.0668  1.212814
  0.1765 -0.0462  0.661613
  0.8018  0.0372  1.782713
 -0.1128  0.0163  0.043813
 -0.5857  0.0358  1.126214
 -0.6624  0.0421  0.619713
  0.1793  0.0824  0.1925 7
  0.2034 -0.0151  0.7528 7
  0.2128  0.0279  0.7576 8
   19
  0.8022 -0.0277  1.777013
  0.7700 -0.1556  0.887113
  0.5238  0.0269  1.839614
 -0.9087 -0.3917  1.731013
  0.4109  0.1517  0.490313
  0.3503 -0.1505  0.628114
  0.7672 -0.2044  0.352513
  1.0976 -0.1986  2.303814
 -0.7941  0.2838  0.779514
  0.4374 -0.1277  1.206113
  0.5604  0.0978  1.487013
 -0.3729  0.0633  0.420414
 -0.2241 -0.0154  0.3035 9
 -0.3371  0.0845  0.3060 7
 -0.4892  0.1541  0.5352 7
  0.1253  0.0285  0.1121 7
  0.2625  0.0425  0.1799 7
 -0.0583  0.0250  0.0780 7
 -0.1180 -0.0064  0.5059 9
   11
  0.3166  0.0942  1.746313
  0.9170  0.0608  3.714014
  1.0541 -0.2027  2.527214
  0.2923  0.1001  0.015913
 -0.8156  0.0091  0.378414
 -0.5877 -0.1940  1.501813
  0.5745  0.2637  1.392914
 -0.4676  0.0773  0.3284 7
 -0.1115  0.0092  0.0998 9
  0.2748 -0.1047  0.7491 9
  0.1934 -0.0696  0.3423 7
   17
 -0.3918 -0.1145  1.688314
 -0.5542  0.0786  2.459613
  0.5061  0.0733  2.329313
  0.8748 -0.2398  0.447413
  0.2402  0.0360  0.696713
 -0.4699  0.0545  1.625213
 -0.5478  0.1371  0.318213
  0.3138  0.0988  0.052514
  0.1279  0.0110  0.361113
  0.9134 -0.3806  0.907713
 -0.9916  0.3867  1.027414
 -0.1846  0.0156  0.062314
  0.3967  0.0452  0.433613
 -0.1218  0.0133  0.3605 7
  0.1523 -0.0185  0.0221 7
  0.2026  0.0390  0.2231 7
 -0.1120 -0.0232  0.1583 9
   16
  0.2941  0.0064  0.654114
  0.6032  0.2140  2.186813
 -0.6164 -0.1572  2.432913
 -0.7066  0.3058  1.394113
  0.2141  0.0479  0.069214
 -0.8236  0.2025  3.439613
  0.1171 -0.0469  0.648214
  0.3185 -0.1284  1.322813
  0.9655 -0.4467  1.159813
  0.1769  0.0353  0.083113
 -0.6358  0.2496  0.314614
  0.5257  0.0372  0.489214
  0.6304  0.1520  0.358513
 -0.1993 -0.0332  0.0449 7
 -0.0693  0.0182  0.0280 7
  0.1665  0.0183  0.6006 9
   23
  0.3672 -0.0688  0.860513
  0.4509  0.1588  0.455114
  0.7987  0.0544  1.160913
 -0.4047 -0.0550  0.534513
  0.9616  0.3421  0.922413
 -0.2320  0.0746  1.353014
 -0.7945  0.1520  3.098113
  0.5059 -0.0804  1.754913
  1.0751  0.0076  4.322313
  0.4153 -0.1037  2.193413
  1.1353 -0.1135  2.515914
  0.3372  0.0318  0.219513
 -0.2370  0.0250  0.280313
  0.4354 -0.1907  0.781113
 -0.6327 -0.1398  0.810113
 -0.4159  0.1792  0.348513
  0.6608  0.2658  0.3181 7
 -0.3108 -0.1423  0.2002 8
  0.1438 -0.0294  0.0403 8
 -0.2712 -0.0847  0.2781 9
  0.3295  0.0940  0.4079 7
  0.2638 -0.0434  0.6674 9
 -0.1195 -0.0030  0.4456 7
   16
 -0.3589  0.0753  1.563913
 -1.2908 -0.0436  2.971814
 -0.3082 -0.0678  0.349114
 -0.3756  0.0188  0.377214
 -0.0885 -0.0182  0.223214
  1.0125 -0.2764  0.370614
  0.4445 -0.0352  0.259313
  0.6827  0.1809  0.363714
  0.5520  0.0923  0.868914
  0.9840 -0.0226  4.037713
  0.5494  0.0627  2.412513
 -0.0880 -0.0010  0.1114 7
 -0.5525  0.0156  0.6003 7
 -0.1364 -0.0566  0.0501 8
  0.3702 -0.0977  0.5389 8
  0.2821 -0.1303  0.9371 8
    9
  0.7944  0.2080  2.032014
  0.5336  0.1070  2.232714
  0.6262 -0.0727  1.285413
 -0.4359  0.0632  1.209513
  0.1303  0.0314  0.021414
 -0.3856  0.0208  0.491513
  0.1664  0.0712  0.1325 8
 -0.1418 -0.0152  0.5020 7
 -0.1702  0.0348  0.6018 7
   16
  0.2359 -0.0942  0.491013
 -0.4333 -0.0113  1.996113
 -1.0294 -0.0726  1.581313
 -0.5323 -0.1391  0.505913
 -0.3359  0.0196  0.514913
  0.5095  0.0577  1.541413
  0.4630 -0.0702  0.031314
  1.1062  0.1174  1.708914
 -0.2349  0.0126  0.443714
  0.7927 -0.0795  0.077914
  0.3066  0.0526  0.935713
 -0.4833  0.0990  0.687413
  0.4057  0.1685  0.8698 7
  0.3376 -0.1037  0.0149 8
  0.1365  0.0068  0.1471 8
  0.1090 -0.0153  0.0424 7
   18
  0.5641  0.0487  1.366013
  0.3636 -0.0773  1.188313
 -0.4057  0.1544  0.455013
 -0.2229  0.0629  0.333214
 -0.6420  0.2783  2.024014
  0.2545  0.0996  1.036113
 -0.2055  0.0329  0.247514
 -0.3809  0.1613  0.301314
  0.4529  0.1913  2.327213
 -0.3509 -0.0870  0.5041 9
  0.1250 -0.0247  0.2957 8
 -0.1841  0.0117  0.1140 8
 -0.0576 -0.0063  0.2164 8
 -0.2648 -0.0067  0.1469 8
 -0.2055  0.0248  0.2113 9
  0.1873 -0.0823  0.9246 8
  0.2652  0.0696  0.9961 8
 -0.1049  0.0116  0.3047 9
   0






+DECK,  G321X3_INP_D, T=DATA, IF=DOC.
READ 4
TIME 2=60.
STOP
+DECK,  GUDIGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:14  cernlib
* Geant

      SUBROUTINE GUDIGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       User routine to digitize one event                       *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCNUM.
C      DIMENSION NUMVS(1),NUMBV(1,30),HITS(7,30),ITRA(30)
C      DIMENSION XL(3),XR(3),PARL(3),PARR(3)
C      DIMENSION X(3),XNEW(3),XP(3),DX(3),XPNEW(3)
C      DIMENSION X1(6),X2(6),XINT(6),PZINT(4)
C      DIMENSION XSAV(2,6,30),YSAV(2,6,30)
C      DATA NUMVS/0/
C      DATA DX/0.,0.,0./
C      DATA NPL/6/
C      DATA S1,S2/0.,0./
C.
C.    ------------------------------------------------------------------
C.
C
C          READING OF TRANSFORMATION AND SHAPE PARAMETERS
C
C      IF(ISWIT(10).EQ.0)GO TO 99
C      CALL GLOOK('CAVE',IB(JVOLUM+1),NVOLUM,IVO)
C      JVO =IB(JVOLUM-IVO)
C      JINL=IB(JVO-6)
C      JINR=IB(JVO-7)
C      IROTL=B(JINL+4)
C      DO 3 I=1,3
C      XL(I)  =B(JINL+I+4)
C      PARL(I)=B(JINL+I+9)
C    3 CONTINUE
C      IROTR=B(JINR+4)
C      DO 4 I=1,3
C      XR(I)  =B(JINR+I+4)
C      PARR(I)=B(JINR+I+9)
C    4 CONTINUE
C      IF(IDEBUG.NE.0)THEN
C        IF(ISWIT(4).NE.0)THEN
C           WRITE(6,*)IROTL,XL(3),PARL(3)
C           WRITE(6,*)IROTR,XR(3),PARR(3)
C        ENDIF
C      ENDIF
C
C         TRANSFORMATION TO LOCAL REFERENCE FRAME
C
C      CALL GFHITS('DRFT','FDOU',1,7,30,0,NUMVS,ITRA,NUMBV,HITS,NHITS)
C
C      IF(NHITS.LE.0)GO TO 99
C      DO 10 IHIT=1,NHITS
C      DO 11 I=1,3
C      X(I) =HITS(I,IHIT)
C      XP(I)=HITS(I+3,IHIT)
C   11 CONTINUE
C      IF(NUMBV(1,IHIT).EQ.1)THEN
C            CALL GITRAN(X,XL,IROTL,XNEW)
C            CALL GITRAN(XP,XD,IROTL,XPNEW)
C            END IF
C      IF(NUMBV(1,IHIT).EQ.2)THEN
C            CALL GITRAN(X,XR,IROTR,XNEW)
C            CALL GITRAN(XP,XD,IROTR,XPNEW)
C            END IF
C      DO 12 I=1,3
C      HITS(I,IHIT)  =XNEW(I)
C      HITS(I+3,IHIT)=XPNEW(I)
C   12 CONTINUE
C   10 CONTINUE
C
C         INTERSECTION WITH SENSE PLANES
C
C      DZPL=2.*PARL(3)/FLOAT(NPL+1)
C      ZPLMIN=-PARL(3)+DZPL
C      DO 20 IHIT=1,NHITS
C      IF(ITRA(IHIT).NE.ITRA(IHIT+1))GO TO 20
C ********  BELOW CHANGE OF COORDINATES TO USE GIPLAN
C      DO 21 I=1,6,3
C      X1(I)  =-HITS(I,IHIT)
C      X1(I+1)= HITS(I+2,IHIT)
C      X1(I+2)= HITS(I+1,IHIT)
C      X2(I)  =-HITS(I,IHIT+1)
C      X2(I+1)= HITS(I+2,IHIT+1)
C      X2(I+2)= HITS(I+1,IHIT+1)
C   21 CONTINUE
C ********
C      ZPL=ZPLMIN
C      DO 22 IPL=1,NPL
C      ZMIN=AMIN1(X1(2),X2(2))
C      ZMAX=AMAX1(X1(2),X2(2))
C      IF((ZPL.LT.ZMIN).OR.(ZPL.GT.ZMAX))GO TO 22
C      CALL GIPLAN(ZPL,X1,X2,S1,S2,1,XINT,SINT,PZINT,IFLAG)
C ********  BACK TO LOCAL REFERENCE FRAME
C ********  AND SAVE INTERACTION COORDINATES
C      XSAV(NUMBV(1,IHIT),IPL,IHIT)=-XINT(1)
C      YSAV(NUMBV(1,IHIT),IPL,IHIT)= XINT(3)
C ********
C      ZPL=ZPL+DZPL
C   22 CONTINUE
C   20 CONTINUE
C
C           DIGITISATION
C
C
   99 RETURN
      END
+DECK,  GUFLD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:13  cernlib
* Geant

      SUBROUTINE GUFLD(X,F)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       User routine to compute the magnetic field F             *
C.    *       at space point X                                         *
C.    *       Called by GRkuta,GHELIX                                  *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      COMMON/DLSFLD/ISWFLD,FLDVAL
C
      DIMENSION X(3),F(3)
C.
C.    ------------------------------------------------------------------
C.
      F(1)=0.
      F(2)=FLDVAL
      F(3)=0.
C
      RETURN
      END
+DECK,  GUKINE, T=FORT.
* Revision 1.4  1996/03/22 15:27:18  japost
* Minor bug correction in a write statement.
* Revision 1.3  1996/03/15 15:50:05  japost
* Small corrections to Parallel code
* Revision 1.2  1996/03/13 17:30:13  ravndal
* Modifications for parallel version testing included
c Revision 1.1.1.1  95/10/24  10:22:13  cernlib
c Geant
c
*

*CMZ :  3.21/02 29/03/94  15.41.35  by  S.Giani
*-- Author :
      SUBROUTINE GUKINE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       Read or Generates Kinematics for primary tracks          *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCLIST.
+CDE, GCKINE.
+CDE, GCONSP.
      CHARACTER*4 CHGET(20)
      DIMENSION XVERT(3)
      DIMENSION P1(3)
      DIMENSION RNDM(3)
      SAVE XVERT
C
      DATA XVERT/0.,0.,-100./
+SELF, IF=PARA.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, MOMENTID.
      integer  nsize, nrank, nleader
*----   The types of local variables  ---  GKTYPES
      REAL      XVERT, P1, RNDM, pmom, th, ph
      INTEGER   i, ident, ier, ilook, nvtx, itr, nt1
      INTEGER   itype, imax, itry
+SELF.
C.
C.    ------------------------------------------------------------------
C.
      IF(NGET.LE.0)GO TO 10
      ITRY=0
  5   ITRY=ITRY+1
      IF(ITRY.GT.2)GO TO 10
      DO 6 I=1,NGET
         CALL UHTOC(LGET(I),4,CHGET(I),4)
   6  CONTINUE
      CALL GFIN(1,CHGET,NGET,IDENT,'K',IER)
      IF(IER.LT.0)GO TO 5
      CALL GLOOK('KINE',LGET,NGET,ILOOK)
      IF(ILOOK.NE.0)GO TO 99
C
 10   CALL GSVERT(XVERT,0,0,0,0,NVTX)
C
      IF(IKINE.EQ.0)THEN
+SELF, IF=-PARA.
           READ(4,100)NTR
  100      FORMAT(I5)
           DO 200 ITR=1,NTR
           READ(4,110)P1,ITYPE
  110      FORMAT(3F8.4,I2)
           CALL GSKINE(P1,ITYPE,NVTX,0,0,NT1)
+SELF, IF=PARA.
c
c          Muxread reads a different event for each node.
c          The routine returns number of primary particles in the
c          event "ntr", and for each of these particles sets the
c          particle type "itypes(1:ntr)" and momenta "p1s(1:3,1:ntr)"
c
           call muxread( 4 )      ! read from unit number 4
c
           DO  itr=1,ntr
               CALL GSKINE(p1s(1,itr),itypes(itr),NVTX,0,0,NT1)
           enddo
           if( ntr.eq.0) then
	       call gprocs( nsize, nrank, nleader )
               write(chmail,'(A,I4,A,A,A)') 'Node ', nrank, ' has ',
     &           'received an event with no primary particles (ntr=0)',
     &           '. This signals the end of the run for this node.'
               call gmail(1,1)
               ieorun = 1
           endif
+SELF.
  200      CONTINUE
      ENDIF
C
      IF(IKINE.EQ.1)THEN
           IF(PKINE(1).EQ.0.)PKINE(1)=25.
           IF(PKINE(2).EQ.0.)PKINE(2)=65.
           IF(PKINE(3).EQ.0.)PKINE(3)=-5.
           IF(PKINE(4).EQ.0.)PKINE(4)= 5.
           IF(PKINE(5).EQ.0.)PKINE(5)=  .2
           IF(PKINE(6).EQ.0.)PKINE(6)=  .8
           IF(PKINE(7).EQ.0.)PKINE(7)= 1.
           IMAX=INT(PKINE(7))
           IF(PKINE(8).EQ.0.)PKINE(8)=14.
           ITYPE=INT(PKINE(8))
           CALL GRNDM(RNDM,3)
           DO 300 I=1,IMAX
           TH=RNDM(1)*(PKINE(2)-PKINE(1))+PKINE(1)
           PH=RNDM(2)*(PKINE(4)-PKINE(3))+PKINE(3)
           PMOM=RNDM(3)*(PKINE(6)-PKINE(5))+PKINE(5)
           P1(1)=PMOM*SIN(TH*DEGRAD)*COS(PH*DEGRAD)
           P1(2)=PMOM*SIN(TH*DEGRAD)*SIN(PH*DEGRAD)
           P1(3)=PMOM*COS(TH*DEGRAD)
           CALL GSKINE(P1,ITYPE,NVTX,0,0,NT1)
  300      CONTINUE
      ENDIF
C
  99  RETURN
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:13  cernlib
* Geant

      SUBROUTINE GUOUT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       User routine called at the end of each event             *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCLIST.
+CDE, GCFLAG.
      DIMENSION NUMVS(2),NUMBV(2,50),HITS(9,50),ITRA(50)
      CHARACTER*4 CHSAVE(20)
      SAVE NUMVS
      DATA NUMVS/0,1/
C.
C.    ------------------------------------------------------------------
C.
      IF(IDEBUG.NE.0)THEN
        IF(ISWIT(1).EQ.1)THEN
           CALL GPVERT(0)
           CALL GPKINE(0)
        ENDIF
        IF(ISWIT(2).EQ.1)THEN
           CALL GPJXYZ(0)
        ENDIF
        IF(ISWIT(3).EQ.10)THEN
           CALL GPHITS('*','*')
        ENDIF
      ENDIF
C
      CALL GFHITS('DRFT','FSP ',2,9,50,0,NUMVS,ITRA,NUMBV,HITS,NHITS)
C
      IF(NHITS.LE.0)GO TO 20
      DO 10 IHIT=1,NHITS
      ID=0
      IF(NUMBV(1,IHIT).EQ.1)ID=100
      IF(NUMBV(1,IHIT).EQ.2)ID=110
      X=HITS(4,IHIT)
      Y=HITS(5,IHIT)
      Z=HITS(6,IHIT)
      IF(ID.EQ.0)GO TO 10
      CALL HFILL(ID  ,X,0.,1.)
      CALL HFILL(ID+1,Y,0.,1.)
      CALL HFILL(ID+2,Z,0.,1.)
   10 CONTINUE
C
C                    SAVE EVENT
C
  20  IF(NSAVE.LE.0)GO TO 30
      DO 25 I=1,NSAVE
         CALL UHTOC(LSAVE(I),4,CHSAVE(I),4)
  25  CONTINUE
      CALL GFOUT(2,CHSAVE,NSAVE,1,'T',IER)
C
  30  CALL DLSOUT
C
   99 RETURN
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:13  cernlib
* Geant

      SUBROUTINE GUSTEP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       User routine called at the end of each tracking step     *
C.    *       INWVOL is different from 0 when the track has reached    *
C.    *              a volume boundary                                 *
C.    *       ISTOP is different from 0 if the track has stopped       *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, GCTMED.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, GCSETS.
+CDE, GCKING.
      DIMENSION HITS(9)
C.
C.    ------------------------------------------------------------------
C.
      IF(IDET.EQ.0)GO TO 20
      IF(CHARGE.EQ.0.)GO TO 20
      IF(INWVOL.NE.1)GO TO 20
      DO 10 I=1,3
         HITS(I) =VECT(I)
   10 CONTINUE
      CALL GMTOD(VECT(1),HITS(4),1)
      CALL GMTOD(VECT(4),HITS(7),2)
      CALL GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
C
   20 IF(ISWIT(6).EQ.0)THEN
C
         IF(NGKINE.GT.0)THEN
            DO 30 I=1,NGKINE
               IFLGK(I)=1
   30       CONTINUE
            CALL GSKING(0)
         ENDIF
      ENDIF
C
      CALL GDEBUG
C
  999 END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:13  cernlib
* Geant

      SUBROUTINE GUTREV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       User routine to control tracking of one event            *
C.    *                                                                *
C.    *       Called by GRUN                                           *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
+CDE, GCBANK.
+CDE, GCLIST.
+CDE, GCFLAG.
C
      IF(NGET.EQ.0)GO TO 10
      CALL GLOOK('HITS',LGET,NGET,ILOOK)
      IF(ILOOK.NE.0)GO TO 99
C
C
  10  CALL GTREVE
C
  99  RETURN
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:12  cernlib
* Geant

+SELF, IF=-INTER.
      PROGRAM GEXAM3
C.
C.
C.           Simulation program for the DLS experiment at LBL
C.             Original code from G.Roche LBL
C.             modified  by R.Brun
C.
C.           Kinematics is read from UNIT=4 (OPEN or JCL required)
C.                              and can be found in DECK,DATA32
C.
C.        DATA CARD USER FLAGS:
C.             SWIT(1)=1     ==>  CALL GPVERT AND GPKINE
C.                     2     ==>  CALL GPJXYZ
C.                     3     ==>  CALL GPHITS
C.             SWIT(2)=2     ==>  CALL GPCXYZ
C.                     3     ==>  CALL GDCXYZ
C.             SWIT(6)=1     ==>  TURN OFF TRACKING OF SECONDARIES
C.
C.
      COMMON/PAWC/H(10000)
      COMMON /GCBANK/ Q(150000)
*
      CALL TIMEST(1E5)
*
      CALL GZEBRA(150000)
      CALL HLIMIT(-10000)
*
      CALL HPLINT(0)
*
      CALL UGINIT
      CALL GRUN
      CALL UGLAST
*
      END
+SELF.
+DECK,  MUXREAD, T=FORT.

c     subroutine MUXREAD( lunread )
c--------------------------------------------------------------------
c     This routine is used to read, on one node, the data for the
c     primary particles of events and distribute this data to
c     requesting nodes to work on.
c--------------------------------------------------------------------
+SELF, IF=PARA.
      subroutine MUXREAD( lunread )
      implicit none
      integer lunread
c     lunread = unit number of event input file (stream)
c--------------------------------------------------------------------
c     Reads in primary particle id and 3-momenta and distributes them.
c
c     Although current version uses one node only to read the data and
c     all the others to simulate them, future versions may use other
c     method.
c
c     Author:  J.Apostolakis CERN/CN
c     First version:  October 20, 1994
c     Last modified:  March 12, 1996
c
c     Called by:  gukine (if an event input file exists)
c--------------------------------------------------------------------
c
+CDE, MPIFINC.
+CDE, MULTIPROX.
+CDE, GCFLAG.

C
C   These variables that will hold the data to be input (program dependent)
C
+CDE, MOMENTID.
c    The arrays will hold the data read in (leader) or received (worker).

c   Constants: tags to distinguish different communications
      integer  tagnparts, tag3mom, tagidpart, tgrequest
      parameter  (tagnparts=2001, tag3mom=2002, tagidpart=2003)
      parameter  (tgrequest=2010)

C   The two following "includes" are for termination like in grun.f
+CDE, GCUNIT.
+CDE, GCTIME.
      REAL TIMNOW
C   End of declarations for termination

      INTEGER LUNERR
c
      integer  nodeto        !  current node to send to
c                               !  \/ MOVED to gprun.f \/
      integer  locleader        !  node that acts as 'host' here and
      data     locleader / 0 /  !   does all the file reading

      integer  itr, j, ndfrom, ndcount, i
      integer  ierr, npstat(10)

c     Used for call to gpkeepbg - see below.                   !  ONLYBG
      integer timesleep
      data  timesleep / 150 /

c     As stderr is not defined, use Geant's stdout
      lunerr= lout

      if ( (npleader .lt. 0) .or. (npleader .gt. npsize) ) then
          npleader= locleader
      endif

      IF(nprank.eq.npleader)THEN

c          This is the host node that read the data and distributes it!
c          ---------------------------------------------------------------
c             The host waits for a work request, reads input data and
c            replies to the node sending it an event to process.
c          ---------------------------------------------------------------

c          do{ ----------->  the host loops here over all the events
c
  50        CONTINUE
            IF(IEVENT.LE.NEVENT) THEN

c              Receive a request from a "worker" for an event to process
c              (with procid as data).
c
               call mpi_recv(nodeto, 1, MPI_INTEGER, MPI_ANY_SOURCE,
     &                          tgrequest, MPI_COMM_WORLD, npstat, ierr)
               if( ierr .ne. 0)
     &              call gpmsgerr( 'muxread - tag request host',
     &              'mpi_recv', ierr )

c              Check to ensure that message was sent by node "nodeto"
               if( nodeto .ne. npstat(MPI_SOURCE) ) then
                  write( LUNERR, *) ' WARNING: nodeto ', nodeto,
     $                 ' differs from ',' value indicated in status - '
     $                 ,npstat(MPI_SOURCE), '*After Receive tagreq #1 '
               endif

c 	       Read an event's data: This segment depends on the program/data!
c              ---------------------
c

               READ(lunread,100,END=499) NTR
  100          FORMAT(I5)
c     x        ( NOTE: that an "END=lineno" condition is recommended
c     x          here, so that if the end of the file is encountered it can be
c     x          dealt with for the parallel program. Otherwise the host
c     x          will fail and the nodes may wait forever - a badly
c     x          behaved parallelprogram .      )

c              start of if( ntr > 0 )  ========
c
               if( ntr .gt. 0 ) then

c                  This send can be asynchronous.
                   call MPI_send( ntr, 1, MPI_INTEGER, nodeto,
     &                            tagnparts, MPI_COMM_WORLD, ierr)
	           if(ierr .ne. 0) call gpmsgerr('mpi_send', ierr,
     &                              'muxread- sending ntr' )

                   DO ITR=1,NTR
                       READ(lunread,110) (p1s(i,itr),i=1,3),itypes(itr)
                   ENDDO
  110              FORMAT(3F8.4,I2)
c
c                  Send all the data, in two sends
c                  -----------------
c
                   call MPI_send( P1S, 3*ntr, MPI_REAL,     nodeto,
     &                        tag3mom, MPI_COMM_WORLD,   ierr)
	           if(ierr .ne. 0) call gpmsgerr('mpi_send', ierr,
     &                              'muxread- sending 3-momenta' )

                   call MPI_send( itypes, ntr, MPI_INTEGER, nodeto,
     &                        tagidpart, MPI_COMM_WORLD, ierr)
	           if(ierr .ne. 0) call gpmsgerr('mpi_send', ierr,
     &                              'muxread - sending particle id' )
c
c     x            NOTE: As a variable number of primary particles
c     x              constitute an event, and the data is of two
c     x              different datatypes (floating point and integer)
c     x              either several sends (as here) or derived datatypes
c     x              or packing of the data into another buffer is needed.
               else
		   IEORUN = 1
               endif
c              end   of if( NTR > 0 )  ========

c              Next lines have been copied from standard grun.f, to
c                ensure the correct termination of the program, due to
c                the end of elapsed time.
c
	       IF(IEORUN.EQ.0) THEN
c                 Incrementing ievent, as "host" does not exit this
c                 routine until all events are distributed.
 	          IEVENT=IEVENT+1
c
c	           Check time left
c
		  IF(ITIME.LE.0)GO TO 50
		  IF(MOD(IEVENT,ITIME).NE.0)GO TO 50
		  CALL TIMEL(TIMNOW)
		  IF(TIMNOW.GT.TIMEND)GO TO 50
		  WRITE(CHMAIL,10000)TIMEND
10000             FORMAT(5X,'***** THE JOB STOPS NOW BECAUSE THE TIME ',
     +                   'LEFT IS LESS THAN     ',F8.3,' SECONDS *****')
		  CALL GMAIL(0,2)
		  IEORUN = 1
	       ENDIF
c	       End  of  lines taken from standard grun.f ....
  	    ENDIF
c           end of  if( ievent > nevent )
c           while { }  ----------->  the host should loop "forever"...

  499       continue
c
c           The input file has been exhausted (used up).
c           Send a termination (ntr=0) message to all nodes.
c
            ntr=0
	    IEORUN = 1
c
c     x     Inform the workers that all events have been assigned.
c     x     ------------------
c
c           Sending the goodbyes in processor order.
	    nfirstworker=1
	    do ndcount= nfirstworker, npsize-1
               call    MPI_send( ntr,    1, MPI_INTEGER, ndcount,
     &                          tagnparts, MPI_COMM_WORLD,    ierr)
	       write (lunerr,*)  ' Node ', npleader, ' sent a ',
     &              ' goodbye (number of parts ntr=0) to node ',ndcount
	    enddo

c     x     Now receive all the outstanding requests, so that no
c     x       messages are left hanging (one node has been rcv above).
	    ndfrom= nodeto
	    nfirstworker=1
	    do ndcount= nfirstworker+1, npsize-1
               call MPI_recv(ndfrom, 1, MPI_INTEGER, MPI_ANY_SOURCE,
     &                       tgrequest, MPI_COMM_WORLD, npstat, ierr)

               if( ndfrom .ne. npstat(MPI_SOURCE) ) then
                     write( LUNERR, *)  ' WARNING: MPI or parallel ',
     &                 ' program error: ndfrom ', ndfrom, ' differs ',
     &                 ' from value indicated in status ',
     &                 npstat(MPI_SOURCE),
     &                 ' - Location: Receive tagreq #1 '
               endif
            enddo	
c
      ELSE
c
c     x    'Worker': ---------------------------------------------------
c     x    --------- Receive data and store it in arrays P1S and itypes
c

c     x    If you want this program to use only unused CPU cycles, you
c     x    can uncomment the line below. It makes certain that a node is
c     x    not loaded before asking for work.
c     x      The subroutine gpkeepbg only return when the load is low enough.
c
c          call gpkeepbg( timesleep )                           !  ONLYBG

c          Send a request for data to process,
c
	   call     MPI_send( nprank, 1, MPI_INTEGER, npleader,
     &                          tgrequest, MPI_COMM_WORLD,         ierr)
           if(ierr .ne. 0) call gpmsgerr('mpi_recv', ierr,
     &                          'muxread - requsting work' )

           call     MPI_recv( ntr,  1, MPI_INTEGER, npleader,
     &                          tagnparts, MPI_COMM_WORLD, npstat, ierr)
           if(ierr .ne. 0) call gpmsgerr('mpi_recv', ierr,
     &                          'muxread - receiving num-parts' )

c	   The case where NTR = 0 should be handled by the calling routine ??
c
           if( NTR .gt. 0 ) then
c              Receive input data arrays
               call MPI_recv( P1S,   3*ntr,   MPI_REAL,    npleader,
     &                        tag3mom,   MPI_COMM_WORLD, npstat, ierr  )
               if(ierr .ne. 0) call gpmsgerr('mpi_recv', ierr,
     &                          'muxread - receiving plund ' )

               call MPI_recv( itypes,   ntr,  MPI_INTEGER, npleader,
     &                        tagidpart, MPI_COMM_WORLD, npstat, ierr  )
               if(ierr .ne. 0) call gpmsgerr('mpi_recv', ierr,
     &                          'muxread - receiving klund ' )
           else
               write(LUNERR,*) ' Node ', nprank, ' got No-part ntr=0'
     $              ,' message and is finishing. '
	       IEORUN = 1
           endif
      ENDIF

      RETURN
      END
+SELF.
+DECK,  UDET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:13  cernlib
* Geant

      SUBROUTINE UDET
C
+CDE, GCLIST.
      CHARACTER*4 NAMESH(9),NAFD(2),NARD1(2),NARD2(2),NARD3(2)
      DIMENSION NBITSH(9),NBITSV(2),ORIG(9),FACT(9)
C
      DATA NAFD,NARD1,NARD2,NARD3/'ARM ','FSP ','ARM ','RSP1'
     + ,'ARM ','RSP2','ARM ','RSP3'/
      DATA NBITSV/2,6/
      DATA NAMESH/'X   ','Y   ','Z   ','U   ','V   ','W   '
     + ,'UP  ','VP  ','WP  '/
      DATA NBITSH/6*17,3*12/
      DATA ORIG/3*300,3*100.,3*1./
      DATA FACT/3*100.,3*500.,3*1000./
C
C
      CALL GLOOK('DRFT',LSETS,NSETS,ILOOK)
      IF(ILOOK.EQ.0)GO TO 99
      CALL GSDET('DRFT','FSP ',2,NAFD ,NBITSV,1,100,100,IDRFT,IFD )
      CALL GSDET('DRFT','RSP1',2,NARD1,NBITSV,1,100,100,IDRFT,IRD1)
      CALL GSDET('DRFT','RSP2',2,NARD2,NBITSV,1,100,100,IDRFT,IRD2)
      CALL GSDET('DRFT','RSP3',2,NARD3,NBITSV,1,100,100,IDRFT,IRD3)
C
C
      CALL GSDETH('DRFT','FSP ',9,NAMESH,NBITSH,ORIG,FACT)
      CALL GSDETH('DRFT','RSP1',9,NAMESH,NBITSH,ORIG,FACT)
      CALL GSDETH('DRFT','RSP2',9,NAMESH,NBITSH,ORIG,FACT)
      CALL GSDETH('DRFT','RSP3',9,NAMESH,NBITSH,ORIG,FACT)
C
C
C
C
      CALL GLOOK('SETS',LPRIN,NPRIN,ILOOK)
      IF(ILOOK.NE.0)CALL GPSETS('*','*')
C
  99  RETURN
      END
+DECK,  UFILES, T=FORT.
* Revision 1.2  1996/03/13 17:30:52  ravndal
* Modifications for parallel version testing included
c Revision 1.1.1.1  95/10/24  10:22:12  cernlib
c Geant
c
*

*CMZ :  3.21/02 29/03/94  15.41.35  by  S.Giani
*-- Author :
      SUBROUTINE UFILES
*
*            To open FFREAD and HBOOK files
*
      CHARACTER*(*) FILNAM, FSTAT
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='gexam3.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/GEXAM3 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='OLD')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF.
*
      OPEN(UNIT=4,FILE=FILNAM,STATUS=FSTAT,
+SELF, IF=VAX.
     +     READONLY,
+SELF.
     +     FORM='FORMATTED')

+SELF, IF=-PARA.
*
*             Open a HBOOK direct access file
*
      CALL HROPEN(34,'HBOOK','gexam3.hist','N',1024,ISTAT)
+SELF, IF=PARA.
*             Do not open a HBOOK file here. It will be done in uglast.
+SELF.
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:13  cernlib
* Geant

      SUBROUTINE UGEOM
C
C
+CDE, GCLIST.
+CDE, GCONSP.
C
      COMMON/DLSFLD/ISWFLD,FLDVAL
C
      DIMENSION   CAVPAR(3),TGTPAR(3),TBIPAR(4),TBOPAR(4),ARMPAR(4)
     + ,FMIPAR(3),FCIPAR(5),FCOPAR(5),FHOPAR(3),FDIPAR(3),FDOPAR(3)
     + ,FLDPAR(3),RD1IPA(3),RD1OPA(3),RD2IPA(3),RD2OPA(3),RD3IPA(3)
     + ,RD3OPA(3),RHOPAR(3)
C
C      VOLUME SIZE PARAMETERS
C
      DATA CAVPAR/450.,100.,360./
      DATA TGTPAR/.47625,1.27,.0232/
      DATA TBIPAR/60.91172,5.07172,10.14,27.92/
      DATA TBOPAR/60.96,5.08,10.16,27.94/
      DATA ARMPAR/18.,210.,50.,190./
      DATA FMIPAR/36.83,12.7,.06/
      DATA FCIPAR/13.29941,50.69885,7.565299,13.90419,34.23/
      DATA FCOPAR/13.335,50.80,7.62,13.97,34.29/
      DATA FHOPAR/40.005,13.49375,.15875/
      DATA FDIPAR/41.91,13.97,4.2/
      DATA FDOPAR/41.917,13.977,4.207/
      DATA FLDPAR/55.88,19.05,25.40/
      DATA RD1IPA/70.000,25.500,7.800/
      DATA RD1OPA/70.007,25.507,7.807/
      DATA RD2IPA/85.000,29.500,7.800/
      DATA RD2OPA/85.007,29.507,7.807/
      DATA RD3IPA/100.000,33.500,7.800/
      DATA RD3OPA/100.007,33.507,7.807/
      DATA RHOPAR/150.5,47.,.3175/
C
C      LOCATIONS:
C          TGT VERSUS CAVE CENTER
C          FIELD AND DETECTORS VERSUS ARM CENTER
C          ANGLE SETTINGS OF LEFT AND RIGHT ARMS (DEG., ANGR IS NEG.)
C          LEFT AND RIGHT ARM VERSUS CAVE CENTER
C
      DATA ZTG/-100./
      DATA DFCO,DFHO,DFDO,DFLD,DRD1,DRD2,DRD3,DRHO/-154.77,-120.1625
     + ,-115.4,-84.92,-27.77,3.98,35.73,142.41/
      DATA ANGL,ANGR/45.,-45./
      DATA DARM/217./
      CANGL=COS(ANGL*DEGRAD)
      SANGL=SIN(ANGL*DEGRAD)
      CANGR=COS(ANGR*DEGRAD)
      SANGR=SIN(ANGR*DEGRAD)
      XLARM=DARM*SANGL
      ZLARM=DARM*CANGL+ZTG
      XRARM=DARM*SANGR
      ZRARM=DARM*CANGR+ZTG
C
C      CAVE REFERENCE FRAME:
C          OZ ALONG BEAM, OX HORIZONTAL, OY VERTICAL
C
      CALL GSVOLU('CAVE','BOX ',1,CAVPAR,3,ICAVE)
C
C      TARGET BOX SHIFTED UPSTREAM 100CM IN CAVE.
C           REFERENCE FRAME:
C               OZ ALONG BEAM, OX HORIZONTAL, OY VERTICAL.
C           CA DENSITY = 1.55 G/CM**3.
C           5 SEGMENTS.
C
      CALL GSVOLU('TGT ','BOX ',2,TGTPAR,3,ITGT )
      CALL GSVOLU('TBIN','TRD1',3,TBIPAR,4,ITBIN)
      CALL GSVOLU('TBOU','TRD1',4,TBOPAR,4,ITBOU)
C
C      LEFT AND RIGHT ARM REFERENCE FRAMES:
C           OZ ALONG CENTRAL RAY, OX HORIZONTAL, OY VERTICAL.
C
      CALL GSVOLU('ARM ','TRD1',1,ARMPAR,4,IARM)
      CALL GSVOLU('FMIR','BOX ',5,FMIPAR,3,IFMIR)
      CALL GSVOLU('FCIN','TRD2',6,FCIPAR,5,IFCIN)
      CALL GSVOLU('FCOU','TRD2',7,FCOPAR,5,IFCOU)
      CALL GSVOLU('FHOD','BOX ',8,FHOPAR,3,IFHOD)
      CALL GSVOLU('FDIN','BOX ',9,FDIPAR,3,IFDIN)
      CALL GSVOLU('FDOU','BOX ',4,FDOPAR,3,IFDOU)
      CALL GSVOLU('FLD ','BOX ',10,FLDPAR,3,IFLD )
      CALL GSVOLU('RD1I','BOX ',11,RD1IPA,3,IRD1I)
      CALL GSVOLU('RD1O','BOX ', 4,RD1OPA,3,IRD1O)
      CALL GSVOLU('RD2I','BOX ',11,RD2IPA,3,IRD2I)
      CALL GSVOLU('RD2O','BOX ', 4,RD2OPA,3,IRD2O)
      CALL GSVOLU('RD3I','BOX ',11,RD3IPA,3,IRD3I)
      CALL GSVOLU('RD3O','BOX ', 4,RD3OPA,3,IRD3O)
      CALL GSVOLU('RHOD','BOX ', 8,RHOPAR,3,IRHOD)
C
C         DRIFT CHAMBER SENSE PLANES
C
      FDIPAR(3)=.0025
      CALL GSVOLU('FSP ','BOX ',13,FDIPAR,3,IFSP )
      RD1IPA(3)=.0025
      CALL GSVOLU('RSP1','BOX ',14,RD1IPA,3,IRSP1)
      RD2IPA(3)=.0025
      CALL GSVOLU('RSP2','BOX ',14,RD2IPA,3,IRSP2)
      RD3IPA(3)=.0025
      CALL GSVOLU('RSP3','BOX ',14,RD3IPA,3,IRSP3)
C
C
      THLX=90.+ANGL
      THRX=90.+ANGR
      PHX=0.
      THY=90.
      PHY=90.
      THLZ=ANGL
      THRZ=-ANGR
      PHLZ=0.
      PHRZ=180.
      CALL GSROTM(1,THLX,PHX,THY,PHY,THLZ,PHLZ)
      CALL GSROTM(2,THRX,PHX,THY,PHY,THRZ,PHRZ)
C
C
      CALL GSPOS('TGT ',1,'TBIN', 0., 0.,-5.08,0,'ONLY')
      CALL GSPOS('TGT ',2,'TBIN', 0., 0.,-2.54,0,'ONLY')
      CALL GSPOS('TGT ',3,'TBIN', 0., 0., 0.  ,0,'ONLY')
      CALL GSPOS('TGT ',4,'TBIN', 0., 0., 2.54,0,'ONLY')
      CALL GSPOS('TGT ',5,'TBIN', 0., 0., 5.08,0,'ONLY')
      CALL GSPOS('TBIN',1,'TBOU', 0., 0.,   0.,0,'ONLY')
      CALL GSPOS('TBOU',1,'CAVE', 0., 0.,  ZTG,0,'ONLY')
C
      CALL GSPOS('ARM ',1,'CAVE',XLARM,0.,ZLARM,1,'ONLY')
      CALL GSPOS('ARM ',2,'CAVE',XRARM,0.,ZRARM,2,'ONLY')
C
      CALL GSPOS('FMIR',1,'FCIN',0.,0.,26.0350,0,'ONLY')
      CALL GSPOS('FCIN',1,'FCOU',0.,0., 0.    ,0,'ONLY')
      CALL GSPOS('FCOU',1,'ARM ',0.,0., DFCO  ,0,'ONLY')
C
      CALL GSPOS('FHOD',1,'ARM ',0.,0., DFHO  ,0,'ONLY')
C
      CALL GSPOS('FDIN',1,'FDOU',0.,0., 0.    ,0,'ONLY')
      CALL GSPOS('FDOU',1,'ARM ',0.,0., DFDO  ,0,'ONLY')
C
      CALL GSPOS('FLD ',1,'ARM ',0.,0., DFLD  ,0,'ONLY')
C
      CALL GSPOS('RD1I',1,'RD1O',0.,0., 0.    ,0,'ONLY')
      CALL GSPOS('RD1O',1,'ARM ',0.,0., DRD1  ,0,'ONLY')
C
      CALL GSPOS('RD2I',1,'RD2O',0.,0., 0.    ,0,'ONLY')
      CALL GSPOS('RD2O',1,'ARM ',0.,0., DRD2  ,0,'ONLY')
C
      CALL GSPOS('RD3I',1,'RD3O',0.,0., 0.    ,0,'ONLY')
      CALL GSPOS('RD3O',1,'ARM ',0.,0., DRD3  ,0,'ONLY')
C
      CALL GSPOS('RHOD',1,'ARM ',0.,0., DRHO  ,0,'ONLY')
C
      CALL GSPOS('FSP ',1,'FDIN',0.,0.,-2.9975,0,'ONLY')
      CALL GSPOS('FSP ',2,'FDIN',0.,0.,-1.7975,0,'ONLY')
      CALL GSPOS('FSP ',3,'FDIN',0.,0., -.5975,0,'ONLY')
      CALL GSPOS('FSP ',4,'FDIN',0.,0.,  .6025,0,'ONLY')
      CALL GSPOS('FSP ',5,'FDIN',0.,0., 1.8025,0,'ONLY')
      CALL GSPOS('FSP ',6,'FDIN',0.,0., 3.0025,0,'ONLY')
C
      CALL GSPOS('RSP1',1,'RD1I',0.,0.,-5.9975,0,'ONLY')
      CALL GSPOS('RSP1',2,'RD1I',0.,0.,-3.5975,0,'ONLY')
      CALL GSPOS('RSP1',3,'RD1I',0.,0.,-1.1975,0,'ONLY')
      CALL GSPOS('RSP1',4,'RD1I',0.,0., 1.2025,0,'ONLY')
      CALL GSPOS('RSP1',5,'RD1I',0.,0., 3.6025,0,'ONLY')
      CALL GSPOS('RSP1',6,'RD1I',0.,0., 6.0025,0,'ONLY')
C
      CALL GSPOS('RSP2',1,'RD2I',0.,0.,-5.9975,0,'ONLY')
      CALL GSPOS('RSP2',2,'RD2I',0.,0.,-3.5975,0,'ONLY')
      CALL GSPOS('RSP2',3,'RD2I',0.,0.,-1.1975,0,'ONLY')
      CALL GSPOS('RSP2',4,'RD2I',0.,0., 1.2025,0,'ONLY')
      CALL GSPOS('RSP2',5,'RD2I',0.,0., 3.6025,0,'ONLY')
      CALL GSPOS('RSP2',6,'RD2I',0.,0., 6.0025,0,'ONLY')
C
      CALL GSPOS('RSP3',1,'RD3I',0.,0.,-5.9975,0,'ONLY')
      CALL GSPOS('RSP3',2,'RD3I',0.,0.,-3.5975,0,'ONLY')
      CALL GSPOS('RSP3',3,'RD3I',0.,0.,-1.1975,0,'ONLY')
      CALL GSPOS('RSP3',4,'RD3I',0.,0., 1.2025,0,'ONLY')
      CALL GSPOS('RSP3',5,'RD3I',0.,0., 3.6025,0,'ONLY')
      CALL GSPOS('RSP3',6,'RD3I',0.,0., 6.0025,0,'ONLY')
C
C      CALL GSORD('ARM ',3)
      CALL GSORD('FDIN',3)
      CALL GSORD('RD1I',3)
      CALL GSORD('RD2I',3)
      CALL GSORD('RD3I',3)
C
      CALL GSTMED( 1,'AIR       $',15,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED( 2,'TARGET    $',17,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED( 3,'VACUUM    $',16,0,0,0., 0.,.0,.0,.001,.5,0,0)
      CALL GSTMED( 4,'MYLAR     $',18,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED( 5,'PYREX     $',19,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED( 6,'FREON13   $',20,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED( 7,'POLYETHYL.$',22,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED( 8,'SCINTILL. $',23,0,0,0.,10.,.2,.1,.01,.5,0,0)
      CALL GSTMED( 9,'FRONTDRIFT$',24,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED(10,'AIR+FIELD $',15,0,ISWFLD,6.,10.,.2,.1,.01,.5,0,0)
      CALL GSTMED(11,'REAR DRIFT$',25,0,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED(12,'CO2       $',21,0,0,0.,10.,.2,.1,.01,.5,0,0)
      CALL GSTMED(13,'FR.DR.S.P.$',24,1,0,0.,10.,.2,.1,.001,.5,0,0)
      CALL GSTMED(14,'RE.DR.S.P.$',25,1,0,0.,10.,.2,.1,.001,.5,0,0)
C
C
      CALL GLOOK('VOLU',LPRIN,NPRIN,ILOOK)
      IF(ILOOK.NE.0) CALL GPVOLU(0)
      CALL GLOOK('ROTM',LPRIN,NPRIN,ILOOK)
      IF(ILOOK.NE.0) CALL GPROTM(0)
      CALL GLOOK('TMED',LPRIN,NPRIN,ILOOK)
      IF(ILOOK.NE.0) CALL GPTMED(0)
      CALL GLOOK('MATE',LPRIN,NPRIN,ILOOK)
      IF(ILOOK.NE.0) CALL GPMATE(0)
      CALL GLOOK('PART',LPRIN,NPRIN,ILOOK)
      IF(ILOOK.NE.0) CALL GPPART(0)
C
C
      CALL GGCLOS
C
      RETURN
      END
+DECK,  UGINIT, T=FORT.
* Revision 1.3  1997/04/10 15:33:35  mclareni
* Mods for WINNT
* Revision 1.2.2.1  1997/01/21 11:24:07  mclareni
* All mods for Winnt 96a on winnt branch
* Revision 1.2  1996/03/13 17:30:22  ravndal
* Modifications for parallel version testing included
c Revision 1.1.1.1  95/10/24  10:22:12  cernlib
c Geant
c
*

*CMZ :  3.21/02 29/03/94  15.41.35  by  S.Giani
*-- Author :
      SUBROUTINE UGINIT
C
+CDE, GCLIST.
+CDE, GCRZ.
C
      COMMON/DLSFLD/ISWFLD,FLDVAL
C
      DIMENSION AMYL(3),ZMYL(3),WMYL(3)
      DIMENSION APYR(4),ZPYR(4),WPYR(4)
      DIMENSION AFRE(3),ZFRE(3),WFRE(3)
      DIMENSION ACO2(2),ZCO2(2),WCO2(2)
      DIMENSION APOL(2),ZPOL(2),WPOL(2)
      DIMENSION ASCI(2),ZSCI(2),WSCI(2)
      DIMENSION AFDR(5),ZFDR(5),WFDR(5)
      DIMENSION ARDR(5),ZRDR(5),WRDR(5)
      CHARACTER*4 CHGET(20),CHSAVE(20)
C
      DATA AMYL,ZMYL,WMYL/12.01,1.01,16.00,6.,1.,8.,5.,4.,2./
      DATA APYR,ZPYR,WPYR/28.09,10.82,23.00,16.00,14.,5.,11.,8.,
     + .385,.039,.038,.538/
      DATA AFRE,ZFRE,WFRE/12.01,35.45,19.00,6.,17.,9.,1.,1.,3./
      DATA ACO2,ZCO2,WCO2/12.01,16.00,6.,8.,1.,2./
      DATA APOL,ZPOL,WPOL/12.01,1.01,6.,1.,1.,2./
      DATA ASCI,ZSCI,WSCI/12.01,1.01,6.,1.,1.,1./
      DATA AFDR,ZFDR,WFDR/63.54,183.85,39.95,12.01,1.01,
     + 29.,74.,18.,6.,1.,.457,.009,.313,.177,.045/
      DATA ARDR,ZRDR,WRDR/63.54,183.85,39.95,12.01,1.01,
     + 29.,74.,18.,6.,1.,.528,.002,.275,.156,.039/
*
      CALL GINIT

#if defined(MEIKO)
c     On the Meiko CS-2 reading from stdin-5 from multiple nodes
c       fails to give the same input: instead node 1 gets line 1,
c       node 2 gets line 2, and so on
c
c     Reset the FFREAD Input unit to the one in ufiles ...
c
      call ffset('LINP', 4 )
c          -----------------
#endif
*
*             Open user files
*
      CALL UFILES
C
C                 Define here user data cards
C
      ISWFLD=1
      FLDVAL=3.9
      CALL FFKEY('FIEL',ISWFLD,2,'MIXED')
C
      CALL GFFGO
C
      CALL GZINIT
C
      CALL GDINIT
C
      IF(NRGET.NE.0)THEN
         CALL GLOOK('INIT',LRGET,NRGET,ILOOK)
         IF(ILOOK.NE.0)THEN
            CALL GRFILE(3,'TEST',' ')
            CALL GRGET('INIT',0,1,0,0)
            GO TO 10
         ENDIF
      ENDIF
C
      IF(NGET .GT.0) CALL GOPEN(1,'I',0,IER)
      IF(NSAVE.GT.0) CALL GOPEN(2,'O',0,IER)
C
      DO 5 I=1,20
         CALL UHTOC(LGET(I),4,CHGET(I),4)
         CALL UHTOC(LSAVE(I),4,CHSAVE(I),4)
   5  CONTINUE
      CALL GFIN(1,CHGET,NGET,IDENT,'I',IER)
      IF(IER.GE.0) GO TO 10
C
      CALL GPART
C
      CALL GSMATE(15,'AIR$',14.61,7.3,0.001205,30423.24,6750.,0,0)
      CALL GSMATE(16,'VACUUM$',1.E-16,1.E-16,1.E-16,1.E+16,1.E+16,0,0)
      CALL GSMATE(17,'CALCIUM$',40.08,20.,1.55,10.4,23.2,0,0)
      CALL GSMIXT(18,'MYLAR$',AMYL,ZMYL,1.39,-3,WMYL)
      CALL GSMIXT(19,'PYREX$',APYR,ZPYR,2.23,4,WPYR)
      CALL GSMIXT(20,'FREON13$',AFRE,ZFRE,4.26E-03,-3,WFRE)
      CALL GSMIXT(21,'CO2$',ACO2,ZCO2,1.79E-03,-2,WCO2)
      CALL GSMIXT(22,'POLYETHYLENE$',APOL,ZPOL,.935,-2,WPOL)
      CALL GSMIXT(23,'SCINT$',ASCI,ZSCI,1.032,-2,WSCI)
      CALL GSMIXT(24,'FRONTDRIFT$',AFDR,ZFDR,2.85E-03,5,WFDR)
      CALL GSMIXT(25,'REARDRIFT$',ARDR,ZRDR,3.24E-03,5,WRDR)
C
      CALL UGEOM
C
      CALL UDET
C
  10  CALL GPHYSI
C
      IF(NHSTA.GT.0) CALL GBHSTA
      CALL USETPL
C
      CALL GFOUT(2,CHSAVE,NSAVE,0,'I',IER)
C
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.3  1996/03/15 15:50:07  japost
* Small corrections to Parallel code
* Revision 1.2  1996/03/13 17:30:33  ravndal
* Modifications for parallel version testing included
c Revision 1.1.1.1  95/10/24  10:22:12  cernlib
c Geant
c
*

*CMZ :  3.21/04 12/01/95  17.38.02  by  S.Ravndal
*-- Author :
      SUBROUTINE UGLAST
C
+CDE, GCLIST.
      CHARACTER*(*) FILNAM, FSTAT
      INTEGER IDVEC(100),IDN
      INTEGER ENTR
      REAL MEAN,RMS
      REAL DEF(100,2)
C
C
C     Control values, which have been obtained
C     using:
C     HP 720 running HP-UX 9
C     GEANT 3.21/02, CERNLIB release 94A
C
      DATA ((DEF(I,J),J=1,2),I=1,6)
     +        / -19.3125,22.4784,
     +            2.2500, 7.1458,
     +            -.5000, 0.0000,
     +           15.7857,14.0277,
     +            1.5000, 7.4066,
     +            -.5000,  .0000/
C
+SELF, IF=CRAY,UNIX,VAX.
      PARAMETER (FILNAM='g_install3.dat')
+SELF, IF=IBM.
      PARAMETER (FILNAM='/G_INSTALL3 DAT *')
+SELF.
*
+SELF, IF=CRAY,UNIX.
      PARAMETER (FSTAT='UNKNOWN')
+SELF, IF=VAX,IBM.
      PARAMETER (FSTAT='UNKNOWN')
+SELF, IF=PARA.
      integer  nsize, nrank, nleader
+SELF.
      CALL GLAST
C
      IF(NGET.NE.0.OR.NSAVE.NE.0) CALL GCLOSE(0,IER)
C
C
C     Create a output file on unit 99 for the default installation
C     test run
C     The test consists of 10 events of 10 GeV photons
C
      OPEN(UNIT=99,FILE=FILNAM,STATUS=FSTAT,FORM='FORMATTED')
C
      WRITE(99,15000)
      WRITE(99,15001)
      WRITE(99,15002)
      WRITE(99,15003)
      WRITE(99,15004)
      WRITE(99,15005)
      WRITE(99,15006)
C
      CALL HID1(IDVEC,IDN)
      IF(IDN.GE.1.AND.IDN.LE.100) THEN
C
          CALL HNOENT(1,ENTR)
          WRITE(99,20000) ENTR
          DO I=1,IDN
              MEAN = HSTATI(IDVEC(I),1,' ',0)
              RMS  = HSTATI(IDVEC(I),2,' ',0)
              WRITE(99,20100) IDVEC(I)
              WRITE(99,20200) MEAN,RMS
              WRITE(99,20300) DEF(I,1),DEF(I,2)
          END DO
      END IF
C

      CLOSE(99)
C
C
+SELF, IF=-PARA.
      CALL HISTDO
+SELF, IF=PARA.
C     Save histograms
C
c     Gpsumhr is a replacement for hrput that saves histograms into a file,
c      summing the contribution from each node in the subdirectory 'totals',
c      and also storing each node's contribution separately elsewhere.
c     It has the same arguments as hrput: (histogramid, filename, options).
c
      call gpsumhr(0,'gexam3.hist',' ')
      call gprocs( nsize, nrank, nleader )
      if ( nrank .eq. nsize-1 ) then
          CALL HISTDO
      endif

c     The call to gplast will TERMINATE parallel GEANT.
c     It cleans up the parallel environment.
c     The program will not return from this call.

      call gplast
+SELF.
C
      RETURN
15000 FORMAT(/,'                   GEANT Installation control file')
15001 FORMAT('                   _______________________________')
15002 FORMAT(/,'The default values were obtained using:')
15003 FORMAT(/,3X,'GEANT Version 3.21/02')
15004 FORMAT(3X,'CERNLIB release 94A')
15005 FORMAT(3X,'HP 720 running HP-UX 9')
15006 FORMAT(3X,'Date: 11 Oct 1994')
20000 FORMAT(/,1x,'Number of Entries ',I6,20X,'Mean',6X,'RMS')
20100 FORMAT(/,1x,'Histogram Id: ',I3)
20200 FORMAT(1X,'Mean Entry value/R.M.S           :'
     +         ,(5X,2F10.4))
20300 FORMAT(1X,'Default values of GEANT 3.21/02  :'
     +         ,(5X,2F10.4))
      END
+DECK,  USETPL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:13  cernlib
* Geant

      SUBROUTINE USETPL
C
+CDE, GCLIST.
C
      CALL HBOOK1(100,' XHITS IN LFDR$',100,-50.,50.,0.)
      CALL HBOOK1(101,' YHITS IN LFDR$', 40,-20.,20.,0.)
      CALL HBOOK1(102,' ZHITS IN LFDR$', 20,-10.,10.,0.)
      CALL HBOOK1(110,' XHITS IN RFDR$',100,-50.,50.,0.)
      CALL HBOOK1(111,' YHITS IN RFDR$', 40,-20.,20.,0.)
      CALL HBOOK1(112,' ZHITS IN RFDR$', 20,-10.,10.,0.)
C
      RETURN
      END
+PATCH, EXAMPLES_EREXAM2.
+DECK,  DATA2, T=DATA.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples
*
*
LIST
KINE  5 (itype)   10. (momentum)  (negative = random)
TRIGGER  10
DEBUG 1 1 0
C
C SWIT
C 3=1 Forward  geane tracking
C 3=2 Backward geane tracking
C 3=3 Forward-Backward geane tracking (geane self test)
C 3=4 Forward  geane tracking (test of the Transport Matrix)
C 3=5 Backward geane tracking (test of the Transport Matrix)
C 3=11 Forward geant tracking - Forward  geane tracking
C 3=12 Forward geant tracking - Backward geane tracking
C 3=15 Forward geant tracking - Forward  geane fit (matrix inv.)
C 3=16 Forward geant tracking - Backward geane fit (matrix inv.)
C 3=17 Forward geant tracking - Forward  geane fit (Kalman Filter)
C 3=18 Forward geant tracking - Backward geane fit (Kalman Filter)
C IN THE CASE 3=11 or 12  MULS/LOSS can be set to 0/4
C to check GEANE tracking or to 1/3 to check GEANE errors
SWIT 0  2  11
C
LOSS 4
MULS 0
PHOT 2
COMP 2
PAIR 2
BREM 2
ANNI 2
DRAY 2
HADR 0
C
CUTS  5*0.00010    5*10000.
C
END
+DECK,  DSBEQN, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

          SUBROUTINE          DSBEQN(N,M,A,IDIM,IFAIL,K,B)
C
C     ******************************************************************
C
C     SOLVES A BANDED SYSTEM OF LINEAR EQUATIONS USING CHOLESKY
C     DECOMPOSITION
C
C     N       ORDER OF THE BAND MATRIX.
C
C     M       BAND PARAMETER. NON-ZERO COEFFICIENTS ARE CONFINED TO
C             IABS(I-J).LE.M.
C
C     A       (DOUBLE PRECISION) TWO-DIMENSIONAL ARRAY CONTAINING THE
C             SUCCESSIVE ROWS OF THE BAND MATRIX
C
C     IDIM    FIRST DIMENSION PARAMETER OF ARRAYS ABAND AND B.
C
C     IFAIL   OUTPUT PARAMETER.   IFAIL= 0 ... NORMAL EXIT.
C                                 IFAIL=-1 ... SINGULAR MATRIX.
C
C     K       NUMBER OF COLUMNS OF THE MATRIX IN ARRAY B.
C
C     B       (DOUBLE PRECISION) TWO-DIMENSIONAL ARRAY CONTAINING A
C             MATRIX OF RIGHT-HAND SIDES.
C
C     THIS SUBROUTINE REPLACES B BY THE SOLUTION MATRIX X OF A*X=B,
C     WHERE A IS THE BAND-MATRIX
C
C
C     Author. V.Innocente  -  November 1988
C
C     ORIGIN    KERNLIB F102
C
C     ref. J.H.Wilkinson & C.Reinsch
C          Linear Algebra - Springer-Verlag 1971
C          pag. 9 and 50
C
C
C     ******************************************************************
C
          DOUBLE PRECISION    A(IDIM,*), B(IDIM,*),  ONE,  X, Y
          REAL                PIVOTF
          DOUBLE PRECISION    S1, S21, S22,       DOTF
          CHARACTER*6         HNAME
          DATA      HNAME               /  'DSBEQN'  /
          PIVOTF(X)    =  SNGL(X)
          DOTF(X,Y,S1)  =  X * Y + S1
          DATA      ONE                 /  1.D0  /
          IF(IDIM .LT. N  .OR.  N .LE. 0  .OR.  K .LT. 0)  GOTO 900
          IFAIL  =  0
          DO 144    J  =  1, N
             IF(PIVOTF(A(J,J)) .LE. 0.)  GOTO 150
             A(J,J)  =  ONE / A(J,J)
             IF(J .EQ. N)  GOTO 199
 140         JP1  =  J+1
             JPM = MIN(J+M,N)
             JP1MM =MAX(1,JP1-M)
             DO 143   L  =  JP1, JPM
                A(J,L)  =  A(J,J)*A(L,J)
                S1      =  -A(L,JP1)
                IM = MAX(JP1MM,L-M)
                DO 141  I  =  IM, J
                   S1  =  DOTF(A(L,I),A(I,J+1),S1)
 141               CONTINUE
                A(L,JP1)  =  -S1
 143            CONTINUE
 144         CONTINUE
 150      IFAIL  =  -1
          RETURN
 199      CONTINUE
          IF(K .LE. 0)  GOTO 299
          DO 220    L  =  1, K
             B(1,L)  =  A(1,1)*B(1,L)
 220         CONTINUE
          IF(N .EQ. 1)  GOTO 299
          DO 243    L  =  1, K
             DO 232   I  =  2, N
                IM1  =  I-1
                IMM  =  MAX(1,I-M)
                S21  =  - B(I,L)
                DO 231   J  =  IMM, IM1
                   S21  =  DOTF(A(I,J),B(J,L),S21)
 231               CONTINUE
                B(I,L)  =  - A(I,I)*S21
 232            CONTINUE
             NM1  =  N-1
             DO 242   I  =  NM1,1,-1
                S22  =  - B(I,L)
                IP1 = I+1
                IPM = MIN(N,I+M)
                DO 241   J  =  IP1, IPM
                   S22    =  DOTF(A(I,J),B(J,L),S22)
 241               CONTINUE
                B(I,L)  =  - S22
 242            CONTINUE
 243         CONTINUE
 299      CONTINUE
          RETURN
 900      CALL TMPRNT(HNAME,N,IDIM,K)
          RETURN
          END
+DECK,  DSBFINV, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

          SUBROUTINE          DSBFINV(N,M,A,IDIM,LB,B,LST)
C
C     ******************************************************************
C
C     INVERT A BANDED MATRIX USING CHOLESKY DECOMPOSITION
C     ROUTINE DSBEQN OR SIMILAR SHOULD BE CALLED FIRST
C     THE ELEMENT OF THE INVERTED MATRIX TO BE COMPIUTED ARE LISTED
C     IN LST AND STORED IN B
C
C     N       ORDER OF THE BAND MATRIX.
C
C     M       BAND PARAMETER. NON-ZERO COEFFICIENTS ARE CONFINED TO
C             IABS(I-J).LE.M.
C
C     A       (DOUBLE PRECISION) TWO-DIMENSIONAL ARRAY CONTAINING THE
C             SUCCESSIVE ROWS OF THE CHOLESKY DECOMPOSED BAND MATRIX
C
C     IDIM    FIRST DIMENSION PARAMETER OF ARRAYS ABAND AND B.
C
C     LB       NUMBER OF ELEMENTS TO BE INVERTED
C
C     B       (DOUBLE PRECISION) ARRAY CONTAINING IN EXIT THE INVERTED
C             ELEMENTS
C
C     LST     TWO-DIMENTIONAL ARRAY CONTEINING THE INDECES OF THE
C             ELEMENT OF THE MATRIX TO BE INVERTED
C
C                                                            -1
C     THIS SUBROUTINE REPLACES B(J)  BY  A(LST(1,J),LST(2,J))
C     WHERE A IS THE BAND-MATRIX
C
C
C     Author. V.Innocente  -  November 1988
C
C     ORIGIN    KERNLIB F102
C
C     ref. J.H.Wilkinson & C.Reinsch
C          Linear Algebra - Springer-Verlag 1971
C          pag. 9 and 50
C
C
C     ******************************************************************
C
          DOUBLE PRECISION    A(IDIM,*),ZERO,     X, Y
          DOUBLE PRECISION    B(*)
          DOUBLE PRECISION    S31, S32, S33, DOTF
          INTEGER             LST(2,*)
          CHARACTER*7         HNAME
          DOTF(X,Y,S31)  =  X*Y + S31
          DATA      HNAME               /  'DSBFINV'  /
          DATA      ZERO      /  0.D0  /
          IF(IDIM .LT. N  .OR.  N .LE. 0)  GOTO 900
          IF(N .EQ. 1)  GOTO 399
          A(1,2)  =  -A(1,2)
          A(2,1)  =   A(1,2)*A(2,2)
          IF(N .EQ. 2)  GOTO 320
          DO 314    J  =  3, N
             JM2  =  J - 2
             JMM = MAX(1,J-1-M)
             DO 312 K  =  1, JM2
                S31  =  A(K,J)
                IM = MAX(K,JMM)
                DO 311  I  =  IM, JM2
                   S31  =  DOTF(A(K,I+1),A(I+1,J),S31)
 311               CONTINUE
                A(K,J)  =  -S31
                A(J,K)  =  -S31*A(J,J)
 312            CONTINUE
             A(J-1,J)  =  -A(J-1,J)
             A(J,J-1)  =   A(J-1,J)*A(J,J)
 314         CONTINUE
*
 320         CONTINUE
             IF ( LB.LE.0 ) GO TO 999
             DO 329 L=1,LB
               K  =  LST(1,L)
               J  =  LST(2,L)
               IF (J.EQ.K)  THEN
                 S33  =  A(J,J)
                 IF(J .EQ. N)  GOTO 325
                 JP1  =  J + 1
                 DO 324 I  =  JP1, N
                   S33  =  DOTF(A(J,I),A(I,J),S33)
 324            CONTINUE
 325            B(L)  =  S33
               ELSE
                 IF ( K.GT.J ) THEN
                  K  =  LST(2,L)
                  J  =  LST(1,L)
                 ENDIF
                 S32  =  ZERO
                 DO 327  I  =  J, N
                   S32  =  DOTF(A(K,I),A(I,J),S32)
 327             CONTINUE
                 B(L)  =  S32
               ENDIF
 329         CONTINUE
 399      CONTINUE
          RETURN
 900      CALL TMPRNT(HNAME,N,IDIM,0)
 999      CONTINUE
          RETURN
          END

+DECK,  ERTEST, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE ERTEST
*
*     Main routine for a call to geane tracking alone.
*
*     Card  'kine' :  itype    momentum
*
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCFLAG.
+CDE, ERTRIO.
*
      REAL XXI(3), PII(3), XXO(3), PO(3), XIO(3),PIO(3)
      REAL RC(15), PLANI(3,2), PLANO(3,3,8)
      REAL PLAB(3)
      REAL XX(3,8),PP(3,8),DX(3),DP(3)
      REAL XST(5),XAR(5),YST(5),YAR(5),DEL(5),DIF(5)
      DOUBLE PRECISION TT(5,5)
*
      character * 4 chopt, cnamv(10)
*
      integer numv(10), ivol(10)
*
      DATA XXI/-109.998,0.0,0.0/,PLAB/0.0,0.0,0.0/
*
*
      JPA = LQ(JPART-IKINE)
      XMASS   = Q(JPA+7)
      PLAB(1) = PKINE(1)
      PLAB(2) = .1*PLAB(1)
      PLAB(3) = .1*PLAB(1)
      EVERT   = sqrt(dble(plab(1))**2+dble(xmass)**2) - xmass
      print *, 'particle ',ikine,' of momentum ',plab(1)
      overp = 1/sqrt(plab(1)**2+plab(2)**2+plab(3)**2)
*
      CALL VZERO (RC,15)
*
      CALL UCOPY(PLAB,PII,3)
*
      IF (ISWIT(4).EQ.1) THEN
        CALL VZERO(PLANI,6)
        PLANI(2,1) =  1.
        PLANI(3,2) =  1.
        XP = -62.
        DO IP=1,8
          CALL UCOPY(PLANI,PLANO(1,1,IP),6)
          XP = XP + 20.
          PLANO(1,3,IP) = XP
          PLANO(2,3,IP) = 0.
          PLANO(3,3,IP) = 0.
        ENDDO
        CALL EUFILP(8,RC,PLANI,PLANO)
      ELSE
        cnamv(1) = 'WBOX'
        numv(1) = 0
        ivol(1) = 1
        do i=2,10
          cnamv(i) = '    '
          numv(i) = 0
          ivol(i) = 1
        enddo
        CALL EUFILV(10,RC,cnamv,numv,ivol)
      ENDIF
*
      IF (ISWIT(3).EQ.2.OR.ISWIT(3).EQ.5) XXI(1) = - XXI(1)
*
      print *,'starting point ',xxi,pii
      IF (ISWIT(4).EQ.1) THEN
        chopt = 'EP  '
        IF (ISWIT(3).EQ.2.OR.ISWIT(3).EQ.5) chopt = 'EPB '
      ELSE
        chopt = 'EV  '
        IF (ISWIT(3).EQ.2.OR.ISWIT(3).EQ.5) chopt = 'EVB '
      ENDIF
      CALL ERTRAK(XXI,PII,XXO,PO,IKINE,CHOPT)
      print *,'arrival point ',xxo,po
*
      IF (ISWIT(3).GT.3) THEN
        xst(1) = erpin(1)
        xst(2) = erpin(2)
        xst(3) = erpin(3)
        xst(4) = xxi(2)
        xst(5) = xxi(3)
        xar(1) = erpout(1,ilpred)
        xar(2) = erpout(2,ilpred)
        xar(3) = erpout(3,ilpred)
        xar(4) = xxo(2)
        xar(5) = xxo(3)
        call ucopy(erdtrp(1,1,ilpred),tt,50)
      ENDIF
*
      print *, 'number of preditions ',ilpred
      do ip=1,ilpred
        print *, 'plane ',iepred(ip),' reached as ',ip
        print *,'position '
        print  '(3e15.5)',(erxout(i,ip),i=1,3)
        print *,'1/p, slopes '
        print  '(3e15.5)',(erpout(i,ip),i=1,3)
        print *,'arrival error '
        print  '(5e15.5)',(errout(i,ip),i=1,15)
        print *, 'transp matrix'
        print '(5e15.5)',((erdtrp(i,j,ip),i=1,5),j=1,5)
        if (iepred(ip).ne.0) then
          do i=1,3
            xx(i,iepred(ip)) = erxout(i,ip)
            pp(i,iepred(ip)) = erpout(i,ip)
          enddo
        endif
      enddo
*
      IF (ISWIT(3).EQ.3) THEN
        print *,'starting point ',xxo,po
        chopt = 'EPB '
        CALL ERTRAK(XXO,PO,XIO,PIO,IKINE,CHOPT)
        print *,'arrival point ',XIO,PIO
*
        print *, 'number of preditions ',ilpred
        do ip=1,ilpred
          print *, 'plane ',iepred(ip),' reached as ',ip
          print *,'position '
          print  '(3e15.5)',(erxout(i,ip),i=1,3)
          print *,'1/p, slopes '
          print  '(3e15.5)',(erpout(i,ip),i=1,3)
          print *,'arrival error '
          print  '(5e15.5)',(errout(i,ip),i=1,15)
          print *, 'transp matrix'
          print '(5e15.5)',((erdtrp(i,j,ip),i=1,5),j=1,5)
          if (iepred(ip).ne.0) then
            do i=1,3
              dx(i) = xx(i,iepred(ip)) - erxout(i,ip)
              dp(i) = pp(i,iepred(ip)) - erpout(i,ip)
            enddo
            print *,'dx',dx
            print *,'dp',dp
          endif
        enddo
      ENDIF
*
      IF(ISWIT(3).GT.3) THEN
*
        DEL(1) = 0.0
        DEL(2) = 0.0
        DEL(3) = 0.0
        DEL(1) = 0.3*overp
        DEL(2) = 0.1
        DEL(3) = 0.1
        DEL(4) = 1.
        DEL(5) = 1.
*
        pmax = 300.
*
        chopt = 'OP'
        IF (ISWIT(3).EQ.5) chopt = 'OPB '
*
        DO IE=1,NEVENT
          XXI(2) = DEL(4)*(2.*RNDM(XXI(2))-1.)
          XXI(3) = DEL(5)*(2.*RNDM(XXI(3))-1.)
10        p = 1/abs(overp + DEL(1)*(2.*RNDM(p)-1.))
          if (p.gt.pmax) go to 10
          PII(2) = p*(PLAB(2)*overp+DEL(2)*(2.*RNDM(PII(2))-1.))
          PII(3) = p*(PLAB(3)*overp+DEL(3)*(2.*RNDM(PII(3))-1.))
          p2 =  p**2-pii(2)**2-pii(3)**2
          if (p2.le.0) go to 10
          PII(1) = sqrt(p2)
          CALL ERTRAK(XXI,PII,XXO,PO,IKINE,CHOPT)
          Yst(1) = erpin(1)
          Yst(2) = erpin(2)
          Yst(3) = erpin(3)
          Yst(4) = xxi(2)
          Yst(5) = xxi(3)
          Yar(1) = erpout(1,ilpred)
          Yar(2) = erpout(2,ilpred)
          Yar(3) = erpout(3,ilpred)
          Yar(4) = xxo(2)
          Yar(5) = xxo(3)
          call vzero(dif,5)
          do i=1,5
            do j=1,5
              dif(i) = dif(i) + tt(i,j)*(yst(j)-xst(j))
            enddo
              dif(i) = Yar(i) - (xar(i)+dif(i))
              call hfill(i,dif(i),0.,1.)
              call hfill(10+i,dif(i)/(yar(i)-xar(i)),0.,1.)
              call hfill(100*i,(yst(i)-xst(i)),0.,1.)
          enddo
c          print *,' dsta ',(yst(j)-xst(j),j=1,5)
c          print *,' darr ',(yar(j)-xar(j),j=1,5)
c          print *,' diff ',dif

        ENDDO
      ENDIF
*
      END
+DECK,  GEAFIT, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE GEAFIT
*
*    stearing routine for trak fitting using GEANE
*
*
*
+CDE, GCFLAG.
*
*
      PARAMETER (NPLAN = 8, NSTOP = NPLAN-1, NSTOP5 = 5*NPLAN )
      COMMON /GCFIT/
     +          CSIX(6,0:NSTOP),CSIY(6,0:NSTOP),CSIZ(6,0:NSTOP)
     +         ,WW(5,5,0:NSTOP),DDT(5,5,0:NSTOP)
     +         ,VV(5,5,0:NSTOP),SS(5,5,0:NSTOP)
     +         ,CHI2,CHI2N,CHI2T,CHI2M
     +         ,PLANI(3,4,0:NSTOP)
      DOUBLE PRECISION
     +          CSIX           ,CSIY           ,CSIZ
     +         ,WW             ,DDT
     +         ,VV             ,SS
     +         ,CHI2,CHI2N,CHI2T,CHI2M
*
*     CSIZ            measured values
*     CSIY            predicted values
*     CSIX            fitted  values
*
*     VV              Weight on CSIZ
*     WW              tracking Weight
*     SS              fit covariance
*
*     DDT             trasport matrix (transpose)
*
*     CHI2            first chi2
*     CHI2N           estimated new chi2
*     CHI2T           estimated new chi2 due to tracking
*     CHI2M           estimated new chi2 due to measurements
*
      COMMON /COORD/CTRU(6,10),NMEA(10),charg
*
      REAL XMEA(3,10)
*
      double precision ssi(5,5),dd(5),chi2f,chi2ft
*
      Parameter (NDAT = 8*(6+5+5+1)+1)
      REAL  XNTP(NDAT)
*
      save ifail
      data ifail/0/
*
      data sigmay/0.02/
      data sigmaz/0.05/
cc      data sigmay/0.07/
cc      data sigmaz/0.10/
*
      DATA FIELDM/20.0/
*
*_____________________________________________________________________
*
*
      if (ifail.ne.0)  then
         print *,' previous fit failed '
         idebug=2
         CALL GPRINT('VERT',0)
         CALL GPRINT('KINE',0)
         CALL GPRINT('JXYZ',0)
      endif
*
*      start with simulating a position measurement in y and z
*      with resolution sigmay,sigmaz
*
      DO IPLAN = 1,NPLAN
        IF (NMEA(IPLAN).GT.0) THEN
          CTRU(1,IPLAN) = CTRU(1,IPLAN)/NMEA(IPLAN)
          CTRU(2,IPLAN) = CTRU(2,IPLAN)/NMEA(IPLAN)
          CTRU(3,IPLAN) = CTRU(3,IPLAN)/NMEA(IPLAN)
          CTRU(4,IPLAN) = CTRU(4,IPLAN)/NMEA(IPLAN)
          CTRU(5,IPLAN) = CTRU(5,IPLAN)/NMEA(IPLAN)
          CTRU(6,IPLAN) = CTRU(6,IPLAN)/NMEA(IPLAN)
          XMEA(1,IPLAN) = CTRU(1,IPLAN)
          call rannor(ry,rz)
          XMEA(2,IPLAN) = CTRU(2,IPLAN) + ry*sigmay
          XMEA(3,IPLAN) = CTRU(3,IPLAN) + rz*sigmaz
        ELSE
          PRINT *, 'no measurement at plane ',Iplan
          GO TO 999
        ENDIF
      ENDDO
      IF (IDEBUG.GE.1) THEN
        PRINT *,' GEAFIT,XMEA'
        WRITE(6,'(I4,3E15.5)') (I,(XMEA(J,I),J=1,3),I=1,8)
      ENDIF
*
**    tracking versus   0 = FORWARD 1 = BACKWARD
*
      IVER = MOD(ISWIT(3) - 15,2)
*
**     compute a starting point trajectory parameters
*
*             get helix crossing three points
*     circle is parameterized as:
*    C*[(X-Xp)**2+(Y-Yp)**2] - 2*alpha*(X-Xp) - 2*beta*(Y-Yp) = 0
*    Xp,Yp is a point on the track;
*    C = 1/r0 is the curvature  ( sign of C is charge of particle );
*   alpha & beta are the direction cosines of the radial vector at Xp,Yp
*    i.e.  alpha = C*(X0-Xp),
*          beta  = C*(Y0-Yp),
*    where center of circle is at X0,Y0.
*    Slope dy/dx of tangent at Xp,Yp is -alpha/beta.
*
      X1P = XMEA(1,1)-XMEA(1,4)
      Y1P = XMEA(2,1)-XMEA(2,4)
      D12 = X1P**2 + Y1P**2
      X3P = XMEA(1,8)-XMEA(1,4)
      Y3P = XMEA(2,8)-XMEA(2,4)
      D32 = X3P**2 + Y3P**2
      DET = D12*Y3P-D32*Y1P
      TOP = (X1P*Y3P-Y1P*X3P)         ! top also gives correct sign for CT
      CT  = TOP/DET
      SN  = SIGN(1.,TOP*CT)
      ST2 = (D12*X3P-D32*X1P)/DET
      SEQ = 1.+ST2**2
      AL2 = SN/SQRT(SEQ)
      BE2 = -ST2*AL2
      CT  = 2.*CT*AL2
      ST1 = -(BE2-CT*Y1P)/(AL2-CT*X1P)
      ST3 = -(BE2-CT*Y3P)/(AL2-CT*X3P)
*
      IF ( IVER.EQ.0) THEN
        dydx = 1./ST1
      ELSE
        dydx = 1./ST3
      ENDIF
      dzdx = (xmea(3,8)-xmea(3,1))/(xmea(1,8)-xmea(1,1))
      OVERP = CT/(0.29979251E-3*FIELDM*SQRT(1.+(dzdx*BE2)**2))
*
*
**    start to load parameters
*
      IF (IVER.EQ.0) THEN
        I1 = 1
        INC = 1
      ELSE
        I1 = NPLAN
        INC = -1
      ENDIF
      CALL VZERO(VV,50*NPLAN)
      CALL VZERO(CSIZ,12*NPLAN)
      CALL VZERO(PLANI,6)
      PLANI(2,1,0) =  1.
      PLANI(3,2,0) =  1.
      CALL CROSS(PLANI(1,1,0),PLANI(1,2,0),PLANI(1,4,0))
      IC = I1
      DO IP=0,NSTOP
        IF (IP.GT.0) CALL UCOPY(PLANI(1,1,0),PLANI(1,1,IP),12)
        PLANI(1,3,IP) = XMEA(1,IC)
        PLANI(2,3,IP) = XMEA(2,IC)
        PLANI(3,3,IP) = XMEA(3,IC)
        CSIZ(4,IP) = XMEA(2,IC)
        CSIZ(5,IP) = XMEA(3,IC)
        CSIZ(6,IP) = XMEA(1,IC)
        VV(4,4,IP) = 1.d0/sigmay**2
        VV(5,5,IP) = 1.d0/sigmaz**2
        IC = IC + INC
      ENDDO
*         initial parameters
      CSIX(1,0) = OVERP
      CSIX(2,0) = dydx
      CSIX(3,0) = dzdx
      CSIX(4,0) = XMEA(2,I1)
      CSIX(5,0) = XMEA(3,I1)
      CSIX(6,0) = XMEA(1,I1)
CC      CSIX(4,0) =
CC     +    PLANI(1,1)*XMEA(1,I1)+PLANI(2,1)*XMEA(2,I1)+PLANI(3,1)*XMEA(3,I1)
CC      CSIX(5,0) =
CC     +    PLANI(1,2)*XMEA(1,I1)+PLANI(2,2)*XMEA(2,I1)+PLANI(3,2)*XMEA(3,I1)
CC      CSIX(6,0) =
CC     +    PLANI(1,4)*XMEA(1,I1)+PLANI(2,4)*XMEA(2,I1)+PLANI(3,4)*XMEA(3,I1)
      CALL VZERO(DDT(1,1,0),50)
      CALL VZERO(WW(1,1,0),50)
      DO I=1,5
        DDT(I,I,0) = 1.D0
      ENDDO
      print *,'fitting starting point ',csix(6,0),csix(4,0),csix(5,0)
     +                                 ,csix(1,0),csix(2,0),csix(3,0)
      print *,'starting momentum ',1./csix(1,0)
*
**     call the chosen fitting algorithm
*
      if (ISWIT(3).LE.16) THEN
        CALL GFITMI(iver,ifail)
      elseif (ISWIT(3).LE.18) THEN
        CALL GFITKF(iver,ifail)
      endif
      print *,'fitpoint ',csix(6,0),csix(4,0),csix(5,0)
     +                                 ,csix(1,0),csix(2,0),csix(3,0)
      print *,'fit momentum ',1./csix(1,0)
      if (ifail.ne.0) then
        print *,' Fit failed ',ifail
        go to 999
      endif
*
**    fill histos
*
      p = charg/sqrt(ctru(4,1)**2+ctru(5,1)**2+ctru(6,1)**2)
      d = (csix(1,I1-1)-p)/p
      call hfill(1,d,0.,1.)
      p = ctru(5,1)/ctru(4,1)
      d = csix(2,I1-1)-p
      call hfill(2,d,0.,1.)
      p = ctru(6,1)/ctru(4,1)
      d = csix(3,I1-1)-p
      call hfill(3,d,0.,1.)
      d = csix(4,I1-1)-ctru(2,1)
      call hfill(4,d,0.,1.)
      d = csix(5,I1-1)-ctru(3,1)
      call hfill(5,d,0.,1.)
      IC = I1
      chi2ft = 0.d0
      intp = 0
      do ip=0,nstop
c         print *,' '
C        write(6,'(1X,6E15.5)') (ctru(i,IC),i=1,6)
C        write(6,'(1X,6E15.5)') (csix(i,ip),i=1,6)
C       write(6,'(1X,5E15.5)') (sqrt(ss(i,i,ip)),i=1,5)
        call ucopy(ctru(1,ic),xntp(intp+1),3)
        p = charg/sqrt(ctru(4,IC)**2+ctru(5,IC)**2+ctru(6,IC)**2)
        d = charg*(csix(1,ip)-p)/sqrt(ss(1,1,ip))
        dd(1) = csix(1,ip)-p
        call hfill(1+10*(IC),d,0.,1.)
        xntp(intp+4) = p
        xntp(intp+7) = csix(1,ip)
        xntp(intp+7+5) = sqrt(ss(1,1,ip))
        p = ctru(5,IC)/ctru(4,IC)
        d = (csix(2,ip)-p)/sqrt(ss(2,2,ip))
        dd(2) = csix(2,ip)-p
        xntp(intp+5) = p
        xntp(intp+8) = csix(2,ip)
        xntp(intp+8+5) = sqrt(ss(2,2,ip))
        call hfill(2+10*(IC),d,0.,1.)
        p = ctru(6,IC)/ctru(4,IC)
        d = (csix(3,ip)-p)/sqrt(ss(3,3,ip))
        dd(3) = csix(3,ip)-p
        call hfill(3+10*(IC),d,0.,1.)
        xntp(intp+6) = p
        xntp(intp+9) = csix(3,ip)
        xntp(intp+9+5) = sqrt(ss(3,3,ip))
        d = (csix(4,ip)-ctru(2,IC))/sqrt(ss(4,4,ip))
        dd(4) = csix(4,ip)-ctru(2,IC)
        call hfill(4+10*(IC),d,0.,1.)
        d = (csix(4,ip)-csiz(4,ip))/
     +     sqrt(max(sigmay**2-ss(4,4,ip),1.e-18))
        call hfill(6+10*(IC),d,0.,1.)
        xntp(intp+10) = csix(4,ip)
        xntp(intp+10+5) = sqrt(ss(4,4,ip))
        d = (csix(5,ip)-ctru(3,IC))/sqrt(ss(5,5,ip))
        dd(5) = csix(5,ip)-ctru(3,IC)
        call hfill(5+10*(IC),d,0.,1.)
        d = (csix(5,ip)-csiz(5,ip))/
     +     sqrt(max(sigmaz**2-ss(5,5,ip),1.e-18))
        call hfill(7+10*(IC),d,0.,1.)
        xntp(intp+11) = csix(5,ip)
        xntp(intp+11+5) = sqrt(ss(5,5,ip))
        do i=1,5
          call hfill(1010+i,float(ic)-.5,sngl(sqrt(ss(i,i,ip))),1.)
        enddo
        call ucopy(ss(1,1,ip),ssi,50)
        call dsinv(5,ssi,5,ierr)
        chi2f = 0.d0
        do i=1,5
        do j=1,5
          chi2f = chi2f + dd(i)*ssi(i,j)*dd(j)
        enddo
        enddo
        chi2ft = chi2ft + chi2f
        call hfill(10*ic,prob(sngl(chi2f),5),0.,1.)
        xntp(intp+17) = prob(sngl(chi2f),5)
        IC = IC + INC
        intp = intp + 17
       enddo
       call hfill(1000,prob(sngl(chi2ft),5*NPLAN),0.,1.)
        xntp(intp+1) = prob(sngl(chi2ft),5*NPLAN)
      call hfn(999,xntp)
*
999   CONTINUE
*
      CALL VZERO(CTRU,70)
*
      END
+DECK,  GFITKF, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:27  mclareni
* Add geane321 examples

      SUBROUTINE GFITKF(IVER,IFAFT)
*
*    trak fitting using GEANE and KALMAN FILTER
*
*    IVER = 0  forward  tracking
*           1  backward tracking
*
*    IFAFT = 0  Fit successful
*    IFAFT = 1  Error matrix singular
*    IFAFT = 9  Fit not successful
*
*    Ask V.Innocente for documentation
*
+CDE, GCFLAG.
+CDE, ERTRIO.
*
*
      PARAMETER (NPLAN = 8, NSTOP = NPLAN-1, NSTOP5 = 5*NPLAN )
      COMMON /GCFIT/
     +          CSIX(6,0:NSTOP),CSIY(6,0:NSTOP),CSIZ(6,0:NSTOP)
     +         ,WW(5,5,0:NSTOP),DDT(5,5,0:NSTOP)
     +         ,VV(5,5,0:NSTOP),SS(5,5,0:NSTOP)
     +         ,CHI2,CHI2N,CHI2T,CHI2M
     +         ,PLANI(3,4,0:NSTOP)
      DOUBLE PRECISION
     +          CSIX           ,CSIY           ,CSIZ
     +         ,WW             ,DDT
     +         ,VV             ,SS
     +         ,CHI2,CHI2N,CHI2T,CHI2M
*
*     CSIZ            measured values
*     CSIY            predicted values
*     CSIX            fitted  values
*
*     VV              Weight on CSIZ
*     WW              tracking Weight
*     SS              fit covariance
*
*     DDT             trasport matrix
*
*     CHI2            first chi2
*     CHI2N           estimated new chi2
*     CHI2T           estimated new chi2 due to tracking
*     CHI2M           estimated new chi2 due to measurements
*
*
      REAL PD(3),RD(15),PC(3),RC(15),H(3),XXI(3),XXO(3),PII(3),POO(3)
      REAL DIF(3)
*
      DOUBLE PRECISION VDUM(5),YDUM(5),AA(5,5),XDU55(5,5)
      DOUBLE PRECISION WI(5,5,0:NSTOP)
      DOUBLE PRECISION CC(5,5,0:NSTOP),DDUM(5)
      DOUBLE PRECISION DZERO, DSMALL, DBIG
*
      CHARACTER * 4 CHOPT
*
      PARAMETER (NITER = 2)
*
      DATA H/0.,0.,20./   ! magnetc field (not really needed)
*
      DATA E1S/1./    ! % error in 1/p
      DATA E2S/.3/    ! error in py/px
      DATA E3S/.3/    ! error in pz/px
*
      DATA DZERO,DSMALL,DBIG/0.D0,.1D-8,1.D8/
*_____________________________________________________________________
*
      IFAFT = 0
*
        IF (IDEBUG.GE.1) THEN
          PRINT *,' GFITKL, NPLAN, NITER ',NPLAN,NITER
        ENDIF
*
      CALL VZERO(RD,15)
*
      CHOPT = 'EP'
      IF (IVER.NE.0) CHOPT = 'BEP'
*
**     compute initial coovariance matrix (to be moved in GEAFIT?)
*
      CALL VZERO(CC,50)
      CALL VZERO(WI,50)
      CC(1,1,0) = (E1S*CSIX(1,0))**2
      CC(2,2,0) = E2S**2
      CC(3,3,0) = E3S**2
      CC(4,4,0) = 1.D0/VV(4,4,0)
      CC(5,5,0) = 1.D0/VV(5,5,0)
*
**     NITER  iterations
*
      DO 101 ITER=1,NITER
*
ccc        IF (ITER.NE.1) CALL UCOPY(SS(1,1,0),CC(1,1,0),50)
        CALL UCOPY(CSIX(1,0),CSIY(1,0),12)
*                    chi2
        DO J = 1,5
          DO K=1,5
            CHI2 =
     +       (CSIX(K,0)-CSIZ(K,0))*VV(K,J,0)*
     +       (CSIX(J,0)-CSIZ(J,0))
          ENDDO
        ENDDO
*            loop over inner planes
        DO JSTOP = 1,NSTOP
*            load starting point
           PD(1) = ABS(CSIX(1,JSTOP-1))
           PD(2) = CSIX(2,JSTOP-1)
           PD(3) = CSIX(3,JSTOP-1)
           XXI(1) = PLANI(1,1,JSTOP-1)*CSIX(4,JSTOP-1)
     +            + PLANI(1,2,JSTOP-1)*CSIX(5,JSTOP-1)
     +            + PLANI(1,4,JSTOP-1)*CSIX(6,JSTOP-1)
           XXI(2) = PLANI(2,1,JSTOP-1)*CSIX(4,JSTOP-1)
     +            + PLANI(2,2,JSTOP-1)*CSIX(5,JSTOP-1)
     +            + PLANI(2,4,JSTOP-1)*CSIX(6,JSTOP-1)
           XXI(3) = PLANI(3,1,JSTOP-1)*CSIX(4,JSTOP-1)
     +            + PLANI(3,2,JSTOP-1)*CSIX(5,JSTOP-1)
     +            + PLANI(3,4,JSTOP-1)*CSIX(6,JSTOP-1)
*
           CH = SIGN(1.D0,CSIX(1,JSTOP-1))
           ITYP = 5
           IF ( CH.LT.0)  ITYP = 6
           SPU = 1.
           CALL TRSDSC(PD,RD,PC,RC,H,CH,IERR,SPU,
     +                 PLANI(1,1,JSTOP-1),PLANI(1,2,JSTOP-1))
*
**         Load coov matrix at plane jstop-1
*
           k=0
           do i=1,5
           do j=i,5
             k = k+1
             FF = 1.D0
             IF (K.NE.1.AND.K.LE.5) FF = CH
             RC(K) = FF*CC(I,J,JSTOP-1)
           enddo
           enddo
*
           CALL DIRCOS(PC(2),DIF)
           P0 = 1.D0/PD(1)
           PII(1) = P0*DIF(1)
           PII(2) = P0*DIF(2)
           PII(3) = P0*DIF(3)
           CALL EUFILP(1,RC,PLANI(1,1,JSTOP-1),PLANI(1,1,JSTOP))
*                   track
           CALL ERTRAK(XXI,PII,XXO,POO,ITYP,CHOPT)
           IF (IEPRED(1).NE.1) THEN
             print *, 'plane ',JSTOP,' not reached '
             IFAFT = 9
             GO TO 999
           ENDIF
*
*
**            load arriving point
*
           CSIY(1,JSTOP) = CH*ERPOUT(1,1)
           CSIY(2,JSTOP) = ERPOUT(2,1)
           CSIY(3,JSTOP) = ERPOUT(3,1)
           CSIY(4,JSTOP) =
     +         PLANI(1,1,JSTOP)*XXO(1)+PLANI(2,1,JSTOP)*XXO(2)+
     +         PLANI(3,1,JSTOP)*XXO(3)
           CSIY(5,JSTOP) =
     +         PLANI(1,2,JSTOP)*XXO(1)+PLANI(2,2,JSTOP)*XXO(2)+
     +         PLANI(3,2,JSTOP)*XXO(3)
           CSIY(6,JSTOP) =
     +         PLANI(1,4,JSTOP)*XXO(1)+PLANI(2,4,JSTOP)*XXO(2)+
     +         PLANI(3,4,JSTOP)*XXO(3)
           K=0
           DO I=1,5
           DO J=I,5
             K=K+1
             FF = 1.D0
             IF (K.NE.1.AND.K.LE.5) FF = CH
             WW(I,J,JSTOP) = FF*ERROUT(K,1)
             WW(J,I,JSTOP) = WW(I,J,JSTOP)
           ENDDO
           ENDDO
C            DO I=1,5
C              IF( WW(I,I,JSTOP).LE.DZERO )  THEN
C                 WW(I,I,JSTOP) = DSMALL
C              ENDIF
C            ENDDO
            CALL UCOPY(WW(1,1,JSTOP),WI(1,1,JSTOP),50)
            CALL DSINV(5,WW(1,1,JSTOP),5,IFAIL)
            IF ( IFAIL.NE.0 )  THEN
              IF ( IDEBUG.GE.1 )
     1           PRINT *,'DSINV IFAIL',IFAIL,' AT PLANE ',JSTOP
                CALL VZERO(WW(1,1,JSTOP),50)
            ENDIF
*
           DO I=1,5
           DO J=1,5
             FF = 1.D0
             IF (I.EQ.1 .AND. J.NE.1 )  FF = CH
             IF (J.EQ.1 .AND. I.NE.1 )  FF = CH
             DDT(I,J,JSTOP) = FF*ERDTRP(J,I,1)
           ENDDO
           ENDDO
*
**        filter
*
          CALL DVADD(25,WW(1,1,JSTOP),WW(2,1,JSTOP),
     +                  VV(1,1,JSTOP),VV(2,1,JSTOP),
     +                  CC(1,1,JSTOP),CC(2,1,JSTOP))
          CALL DSINV(5,CC(1,1,JSTOP),5,IFAIL)
          IF ( IFAIL.NE.0 )  THEN
            IF ( IDEBUG.GE.1 )
     1         PRINT *,'DSINV IFAIL',IFAIL,' AT PLANE ',JSTOP
              CALL VZERO(CC(1,1,JSTOP),50)
          ENDIF
          CALL DMMPY(5,5,VV(1,1,JSTOP),VV(1,2,JSTOP),VV(2,1,JSTOP),
     +                   CSIZ(1,JSTOP),CSIZ(2,JSTOP),
     +                   YDUM(1),      YDUM(2))
          CALL DMMPA(5,5,WW(1,1,JSTOP),WW(1,2,JSTOP),WW(2,1,JSTOP),
     +                   CSIY(1,JSTOP),CSIY(2,JSTOP),
     +                   YDUM(1),      YDUM(2))
          CALL DMMPY(5,5,CC(1,1,JSTOP),CC(1,2,JSTOP),CC(2,1,JSTOP),
     +                   YDUM(1),      YDUM(2),
     +                   CSIX(1,JSTOP),CSIX(2,JSTOP))
          CSIX(6,JSTOP) = CSIY(6,JSTOP)
*                CHI2
          DO J = 1,5
            DO K=1,5
              CHI2 = CHI2 +
     +         (CSIX(K,JSTOP)-CSIZ(K,JSTOP))*VV(K,J,JSTOP)*
     +         (CSIX(J,JSTOP)-CSIZ(J,JSTOP))                 +
     +         (CSIX(K,JSTOP)-CSIY(K,JSTOP))*WW(K,J,JSTOP)*
     +         (CSIX(J,JSTOP)-CSIY(J,JSTOP))
            ENDDO
          ENDDO
*
        ENDDO               !  End plane loop
*
**               smoothing
*
        CALL UCOPY(CC(1,1,NSTOP),SS(1,1,NSTOP),50)
*                chi2
        DO J = 1,5
          DO K=1,5
            CHI2M =
     +         (CSIX(K,NSTOP)-CSIZ(K,NSTOP))*VV(K,J,NSTOP)*
     +         (CSIX(J,NSTOP)-CSIZ(J,NSTOP))
            CHI2T =
     +         (CSIX(K,NSTOP)-CSIY(K,NSTOP))*WW(K,J,NSTOP)*
     +         (CSIX(J,NSTOP)-CSIY(J,NSTOP))
          ENDDO
        ENDDO
*
        DO JS=NSTOP-1,0,-1
          CALL DMMLT(5,5,5,DDT(1,1,JS+1),DDT(1,2,JS+1),DDT(2,1,JS+1),
     1                     WW(1,1,JS+1),WW(1,2,JS+1),WW(2,1,JS+1),
     2                     XDU55(1,1),XDU55(1,2),XDU55(2,1), DDUM )
          CALL DMMLT(5,5,5,CC(1,1,JS),CC(1,2,JS),CC(2,1,JS),
     1                     XDU55(1,1),XDU55(1,2),XDU55(2,1),
     2                     AA(1,1),AA(1,2),AA(2,1), DDUM  )
          CALL DVSUB(25,SS(1,1,JS+1),SS(2,1,JS+1),
     1                  WI(1,1,JS+1),WI(2,1,JS+1),
     2                  XDU55(1,1),XDU55(2,1) )
          CALL DMMLT(5,5,5,XDU55(1,1),XDU55(1,2),XDU55(2,1),
     1                     AA(1,1),AA(2,1),AA(1,2),
     2                     XDU55(1,1),XDU55(1,2),XDU55(2,1), DDUM  )
          CALL UCOPY(CC(1,1,JS),SS(1,1,JS),50)
          CALL DMMLA(5,5,5, AA(1,1),AA(1,2),AA(2,1),
     1                     XDU55(1,1),XDU55(1,2),XDU55(2,1),
     2                     SS(1,1,JS),SS(1,2,JS),SS(2,1,JS) )
          CALL DVSUB(5,CSIX(1,JS+1),CSIX(2,JS+1),
     1                 CSIY(1,JS+1),CSIY(2,JS+1),
     2                 YDUM(1),YDUM(2))
          CALL DMMPA(5,5,AA(1,1),AA(1,2),AA(2,1),
     1                  YDUM(1),YDUM(2),
     2                  CSIX(1,JS),CSIX(2,JS) )
*
          DO I=1,5
            IF (SS(I,I,JS).LE.DZERO) THEN
              IFAFT = 1
              SS(I,I,JS) = DBIG
            ENDIF
          ENDDO
*                    chi2
          DO J = 1,5
            DO K=1,5
              CHI2M = CHI2M +
     +           (CSIX(K,JS)-CSIZ(K,JS))*VV(K,J,JS)*
     +           (CSIX(J,JS)-CSIZ(J,JS))
              CHI2T = CHI2T +
     +           (CSIX(K,JS)-CSIY(K,JS))*WW(K,J,JS)*
     +           (CSIX(J,JS)-CSIY(J,JS))
            ENDDO
          ENDDO
*
        ENDDO
        CHI2N = CHI2T + CHI2M
        print *,' chi2s ',iter,chi2,chi2n,chi2t,chi2m
        IF ( IDEBUG.GE.1 )  THEN
          WRITE(6,'(I6,''     CSIZ '',/(3X,6E15.5))')ITER,CSIZ
          WRITE(6,'(I6,''     CSIX '',/(3X,6E15.5))')ITER,CSIX
          WRITE(6,'(I6,''     CSIY '',/(3X,6E15.5))')ITER,CSIY
        ENDIF
*
          NDOF = 2*nplan-5
          call hfill(1000*iter+1,prob(sngl(chi2),ndof),0.,1.)
          call hfill(1000*iter+2,prob(sngl(chi2n),ndof),0.,1.)
          call hfill(1000*iter+3,prob(sngl(chi2t),ndof),0.,1.)
          call hfill(1000*iter+4,prob(sngl(chi2m),ndof),0.,1.)
        IF ( IDEBUG.GE.1 )  THEN
          PRINT *, ' SS '
          WRITE(6,'(5E15.5)') ((SS(i,i,ip),i=1,5),ip=0,nstop)
        ENDIF
*
*
101   CONTINUE
*
**      done
*
999   CONTINUE
*
      END
+DECK,  GFITMI, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE GFITMI(IVER,IFAFT)
*
*    trak fitting using GEANE and matrix inversion
*
*    IVER = 0  forward  tracking
*           1  backward tracking
*
*    IFAFT = 0  Fit successful
*    IFAFT = 1  Error matrix singular
*    IFAFT = 9  Fit not successful
*
*    Ask V.Innocente for documentation
*
+CDE, GCFLAG.
+CDE, ERTRIO.
*
*
      PARAMETER (NPLAN = 8, NSTOP = NPLAN-1, NSTOP5 = 5*NPLAN )
      COMMON /GCFIT/
     +          CSIX(6,0:NSTOP),CSIY(6,0:NSTOP),CSIZ(6,0:NSTOP)
     +         ,WW(5,5,0:NSTOP),DDT(5,5,0:NSTOP)
     +         ,VV(5,5,0:NSTOP),SS(5,5,0:NSTOP)
     +         ,CHI2,CHI2N,CHI2T,CHI2M
     +         ,PLANI(3,4,0:NSTOP)
      DOUBLE PRECISION
     +          CSIX           ,CSIY           ,CSIZ
     +         ,WW             ,DDT
     +         ,VV             ,SS
     +         ,CHI2,CHI2N,CHI2T,CHI2M
*
*     CSIZ            measured values
*     CSIY            predicted values
*     CSIX            fitted  values
*
*     VV              Weight on CSIZ
*     WW              tracking Weight
*     SS              fit covariance
*
*     DDT             trasport matrix
*
*     CHI2            first chi2
*     CHI2N           estimated new chi2
*     CHI2T           estimated new chi2 due to tracking
*     CHI2M           estimated new chi2 due to measurements
*
*
      REAL PD(3),RD(15),PC(3),RC(15),H(3),XXI(3),XXO(3),PII(3),POO(3)
      REAL DIF(3)
      INTEGER LSTER(2,150)
      DOUBLE PRECISION AMA(NSTOP5,NSTOP5),SOL(NSTOP5)
      DOUBLE PRECISION XDU55(5,5),DTR(5,5),WDT(5,5)
     +                ,VDUM(5),VDUM0(5),YDUM(5)
     +                ,ERRA(150),FF,DDUM(5)
      DOUBLE PRECISION DZERO, DSMALL, DBIG
*
      CHARACTER * 4 CHOPT
*
      PARAMETER (NITER = 2)
*
      DATA H/0.,0.,20./
*
      DATA DZERO,DSMALL,DBIG/0.D0,.1D-8,1.D8/
*_____________________________________________________________________
*
      IFAFT = 0
*
*         Define coordinate for which we want the errors
        K = 1
        DO 1 I=1,5
        DO 1 J=I,5
          LSTER(1,K) = I
          LSTER(2,K) = J
          K = K+1
1       CONTINUE
        DO 2 I=6,NPLAN*5
        DO 2 J=I,5*((I-1)/5)+5
          LSTER(1,K) = I
          LSTER(2,K) = J
          K = K+1
2       CONTINUE
        NERRA = K-1
*
        IF (IDEBUG.GE.1) THEN
          PRINT *,' GFITMI, NPLAN, NERRA, NITER ',NPLAN,NERRA,NITER
        ENDIF
*
      CALL VZERO(RD,15)
*
      CHOPT = 'EP'
      IF (IVER.NE.0) CHOPT = 'BEP'
*
**     NITER  iterations
*
      DO 101 ITER=1,NITER
*
        CALL UCOPY(CSIX(1,0),CSIY(1,0),12)
*            loop over inner planes
        DO JSTOP = 1,NSTOP
*            load starting point
           PD(1) = ABS(CSIX(1,JSTOP-1))
           PD(2) = CSIX(2,JSTOP-1)
           PD(3) = CSIX(3,JSTOP-1)
           XXI(1) = PLANI(1,1,JSTOP-1)*CSIX(4,JSTOP-1)
     +            + PLANI(1,2,JSTOP-1)*CSIX(5,JSTOP-1)
     +            + PLANI(1,4,JSTOP-1)*CSIX(6,JSTOP-1)
           XXI(2) = PLANI(2,1,JSTOP-1)*CSIX(4,JSTOP-1)
     +            + PLANI(2,2,JSTOP-1)*CSIX(5,JSTOP-1)
     +            + PLANI(2,4,JSTOP-1)*CSIX(6,JSTOP-1)
           XXI(3) = PLANI(3,1,JSTOP-1)*CSIX(4,JSTOP-1)
     +            + PLANI(3,2,JSTOP-1)*CSIX(5,JSTOP-1)
     +            + PLANI(3,4,JSTOP-1)*CSIX(6,JSTOP-1)
*
           CH = SIGN(1.D0,CSIX(1,JSTOP-1))
           ITYP = 5
           IF ( CH.LT.0)  ITYP = 6
           SPU = 1.
           CALL TRSDSC(PD,RD,PC,RC,H,CH,IERR,SPU,
     +                 PLANI(1,1,JSTOP-1),PLANI(1,2,JSTOP-1))
*
           CALL DIRCOS(PC(2),DIF)
           P0 = 1.D0/PD(1)
           PII(1) = P0*DIF(1)
           PII(2) = P0*DIF(2)
           PII(3) = P0*DIF(3)
           CALL EUFILP(1,RD,PLANI(1,1,JSTOP-1),PLANI(1,1,JSTOP))
*                   track
           CALL ERTRAK(XXI,PII,XXO,POO,ITYP,CHOPT)
           IF (IEPRED(1).NE.1) THEN
             print *, 'plane ',JSTOP,' not reached '
             IFAFT = 9
             GO TO 999
           ENDIF
*
*
**            load arriving point
*
           CSIY(1,JSTOP) = CH*ERPOUT(1,1)
           CSIY(2,JSTOP) = ERPOUT(2,1)
           CSIY(3,JSTOP) = ERPOUT(3,1)
           CSIY(4,JSTOP) =
     +         PLANI(1,1,JSTOP)*XXO(1)+PLANI(2,1,JSTOP)*XXO(2)+
     +         PLANI(3,1,JSTOP)*XXO(3)
           CSIY(5,JSTOP) =
     +         PLANI(1,2,JSTOP)*XXO(1)+PLANI(2,2,JSTOP)*XXO(2)+
     +         PLANI(3,2,JSTOP)*XXO(3)
           CSIY(6,JSTOP) =
     +         PLANI(1,4,JSTOP)*XXO(1)+PLANI(2,4,JSTOP)*XXO(2)+
     +         PLANI(3,4,JSTOP)*XXO(3)
           IF (ITER.EQ.1) CALL UCOPY(CSIY(1,JSTOP),CSIX(1,JSTOP),12)
           K=0
           DO I=1,5
           DO J=I,5
             K=K+1
             FF = 1.D0
             IF (K.NE.1.AND.K.LE.5) FF = CH
             WW(I,J,JSTOP) = FF*ERROUT(K,1)
             WW(J,I,JSTOP) = WW(I,J,JSTOP)
           ENDDO
           ENDDO
C            DO I=1,5
C              IF( WW(I,I,JSTOP).LE.DZERO )  THEN
C                 WW(I,I,JSTOP) = SMALL
C              ENDIF
C            ENDDO
            CALL DSINV(5,WW(1,1,JSTOP),5,IFAIL)
            IF ( IFAIL.NE.0 )  THEN
              IF ( IDEBUG.GE.1 )
     1           PRINT *,'DSINV IFAIL',IFAIL,' AT PLANE ',JSTOP
                CALL VZERO(WW(1,1,JSTOP),50)
            ENDIF
*
           DO I=1,5
           DO J=1,5
             FF = 1.D0
             IF (I.EQ.1 .AND. J.NE.1 )  FF = CH
             IF (J.EQ.1 .AND. I.NE.1 )  FF = CH
             DDT(I,J,JSTOP) = FF*ERDTRP(J,I,1)
           ENDDO
           ENDDO
        ENDDO               !  End plane loop
        IF ( IDEBUG.GE.1 )  THEN
          WRITE(6,'(I6,''     CSIZ '',/(3X,6E15.5))')ITER,CSIZ
          WRITE(6,'(I6,''     CSIX '',/(3X,6E15.5))')ITER,CSIX
          WRITE(6,'(I6,''     CSIY '',/(3X,6E15.5))')ITER,CSIY
        ENDIF
*
**     Solve now
*
        ISOL = 0
150     CONTINUE
        ISOL = ISOL + 1
*
        CALL VZERO(AMA,2*NSTOP5*NSTOP5)
        CALL VZERO(SOL,2*NSTOP5)
        CHI2 = 0.D0
        DO 151 J=1,5
151      VDUM(J) = CSIY(J,0) - CSIX(J,0)
        DO 120 I=0,NSTOP
          CALL UCOPY(VDUM,VDUM0,10)
          IF ( I.NE.NSTOP ) THEN
            CALL DMMLT(5,5,5,WW(1,1,I+1),WW(1,2,I+1),WW(2,1,I+1),
     1                   DDT(1,1,I+1),DDT(2,1,I+1),DDT(1,2,I+1),
     2                   WDT(1,1),WDT(1,2),WDT(2,1), DDUM )
            CALL DMMLT(5,5,5,DDT(1,1,I+1),DDT(1,2,I+1),DDT(2,1,I+1),
     1                   WDT(1,1),WDT(1,2),WDT(2,1),
     2                   XDU55(1,1),XDU55(1,2),XDU55(2,1), DDUM )
*
            DO 152 J=1,5
              VDUM(J) = CSIY(J,I+1) - CSIX(J,I+1)
152         CONTINUE
          ELSE
            CALL VZERO(XDU55,50)
            CALL VZERO(VDUM,10)
          ENDIF
          DO 153 J=1,5
            YDUM(J) = CSIZ(J,I) - CSIX(J,I)
153       CONTINUE
          II = 5*I
          DO 120 J=1,5
            IJ = II+J
            DO 121 K=1,5
              IK = II+K
              AMA(IJ,IK) = WW(K,J,I) + VV(K,J,I)  + XDU55(K,J)
              IF ( I.NE.NSTOP) THEN
                AMA(IJ,IK+5) = -WW(K,1,I+1)*DDT(J,1,I+1)
     2                         -WW(K,2,I+1)*DDT(J,2,I+1)
     3                         -WW(K,3,I+1)*DDT(J,3,I+1)
     4                         -WW(K,4,I+1)*DDT(J,4,I+1)
     5                         -WW(K,5,I+1)*DDT(J,5,I+1)
              ENDIF
              IF ( I.NE.0 ) THEN
                AMA(IJ,IK-5) = -WW(J,1,I)*DDT(K,1,I)
     2                         -WW(J,2,I)*DDT(K,2,I)
     3                         -WW(J,3,I)*DDT(K,3,I)
     4                         -WW(J,4,I)*DDT(K,4,I)
     5                         -WW(J,5,I)*DDT(K,5,I)
              ENDIF
              CHI2 = CHI2
     1         + VDUM0(J)*WW(J,K,I)*VDUM0(K)
     2         +  YDUM(J)*VV(J,K,I)*YDUM(K)
121         CONTINUE
*
            SOL(IJ)=
     1          VDUM0(1)*WW(1,J,I)+VDUM0(2)*WW(2,J,I)
     2         +VDUM0(3)*WW(3,J,I)+VDUM0(4)*WW(4,J,I)+VDUM0(5)*WW(5,J,I)
     3         +YDUM(1)*VV(1,J,I)+YDUM(2)*VV(2,J,I)
     4         +YDUM(3)*VV(3,J,I)+YDUM(4)*VV(4,J,I)+YDUM(5)*VV(5,J,I)
             IF (I.NE.NSTOP) SOL(IJ) = SOL(IJ)
     5         - VDUM(1)*WDT(1,J)-VDUM(2)*WDT(2,J)
     6         - VDUM(3)*WDT(3,J)-VDUM(4)*WDT(4,J)-VDUM(5)*WDT(5,J)
*
120     CONTINUE
*            "home made" band code
*           ( can be optimized )
        MBAN = 9
        CALL DSBEQN(NSTOP5,MBAN,AMA,NSTOP5,IFAIL,1,SOL)
        IF ( IFAIL.NE.0 ) THEN
*
**      inversion failed!!
*
          IF ( IDEBUG.GE.1 )
     1       PRINT *,' DSBEQN IFAIL ',IFAIL
CC          DO I=1,NSTOP5
CC            IF ( AMA(I,I).LE.DZERO ) THEN
CC              IF ( IDEBUG.GE.1 )   THEN
CC                PRINT *,' AMA matrix singular!!'
CC                PRINT *,' element ',I,' = ',AMA(I,I)
CC              ENDIF
CC            ENDIF
CC          ENDDO
          IFAFT = 9
          GO TO 999
        ENDIF
*
        CALL DSBFINV(NSTOP5,MBAN,AMA,NSTOP5,NERRA,ERRA,LSTER)
*
*      compute new fit values  and chi2s
        CHI2T = 0.D0
        CHI2M = 0.D0
        DO I = 0,NSTOP
          II = 5*I
          DO J=1,5
            IJ= II+J
            CSIX(J,I) = CSIX(J,I) + SOL(IJ)
          ENDDO
          IF (I.NE.0) THEN
             CALL UCOPY(CSIY(1,I),VDUM,10)
             DO J=1,5
               IJ= II+J -5
               DO K=1,5
                 VDUM(K) = VDUM(K) + DDT(J,K,I)*SOL(IJ)
               ENDDO
             ENDDO
          ENDIF
          DO J = 1,5
            DO K=1,5
              CHI2M = CHI2M +
     +         (CSIX(K,I)-CSIZ(K,I))*VV(K,J,I)*(CSIX(J,I)-CSIZ(J,I))
            ENDDO
            IF (I.NE.0) THEN
              DO K=1,5
                CHI2T = CHI2T +
     +           (CSIX(K,I)-VDUM(K))*WW(K,J,I)*(CSIX(J,I)-VDUM(J))
              ENDDO
            ENDIF
          ENDDO
        ENDDO
        CHI2N = CHI2T + CHI2M
          print *,' chi2s ',iter,chi2,chi2n,chi2t,chi2m
*
          NDOF = 2*nplan-5
          call hfill(1000*iter+1,prob(sngl(chi2),ndof),0.,1.)
          call hfill(1000*iter+2,prob(sngl(chi2n),ndof),0.,1.)
          call hfill(1000*iter+3,prob(sngl(chi2t),ndof),0.,1.)
          call hfill(1000*iter+4,prob(sngl(chi2m),ndof),0.,1.)
        IF ( IDEBUG.GE.1 )  THEN
          PRINT *, ' ERRA '
          WRITE(6,'(5E15.5)') (ERRA(IE),IE=1,NERRA)
        ENDIF
*
*
101   CONTINUE
*
**      done
*
*       load final coovariance
*
      call vzero(ss,50*nplan)
      do ie=1,nerra
       iplan = (lster(1,ie)-1)/5
       jplan = (lster(2,ie)-1)/5
       if (iplan.eq.jplan) then
         i = lster(1,ie) - 5*iplan
         j = lster(2,ie) - 5*jplan
         ss(i,j,iplan) = erra(ie)
         ss(j,i,iplan) = erra(ie)
         if (i.eq.j.and.erra(ie).le.DZERO) then
           ss(i,j,iplan) = DBIG
           ss(j,i,iplan) = DBIG
           IFAFT = 1
         endif
       endif
      enddo
*
999   CONTINUE
*
      END
+DECK,  GUKINE, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE GUKINE
*
*     Card  'kine' :  itype    momentum
*
+CDE, GCBANK.
+CDE, GCKINE.
*
      COMMON /COORD/CTRU(6,10),NMEA(10),charg
*
      DIMENSION VERTEX(3),PLAB(3)
      LOGICAL FIRST, LRANP, LRANC
      SAVE    FIRST,VERTEX,PLAB, LRANP, LRANC
      DATA FIRST /.TRUE./
      DATA VERTEX/-109.998,0.0,0.0/,PLAB/0.0,0.0,0.0/
*
**____________________________________________________________________
*
      IF (FIRST) THEN
         LRANP = .FALSE.
         IF (PKINE(1).LE.0) THEN
           LRANP = .TRUE.
           PKINE(1) = ABS(PKINE(1))
           print *,' Random momentum'
         ENDIF
         LRANC = .FALSE.
         IF (IKINE.LE.0) THEN
           LRANC = .TRUE.
           IKINE = ABS(IKINE)
           print *,' Random charge'
         ENDIF
         JPA = LQ(JPART-IKINE)
         XMASS   = Q(JPA+7)
         PLAB(1) = PKINE(1)
         PLAB(2) = .1*PLAB(1)
         PLAB(3) = .1*PLAB(1)
         EVERT   = sqrt(dble(plab(1))**2+dble(xmass)**2) - xmass
      ENDIF
*
      LKINE = IKINE
      IF (LRANC.AND. RNDM(IKINE).LE.0.5) LKINE = IKINE + 1
      JPA = LQ(JPART-LKINE)
      ITRTYP = Q(JPA+6)
      AMASS  = Q(JPA+7)
      CHARGE = Q(JPA+8)
      TLIFE  = Q(JPA+9)
      charg = charge
*
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
*
      IF (LRANP) THEN
        PP  = 10**(1.+RNDM(PP))
        PLAB(2) = .2*PP*(1.-2.*RNDM(PLAB(2)))
        PLAB(3) = .2*PP*(1.-2.*RNDM(PLAB(3)))
        PLAB(1) = SQRT(PP**2-PLAB(2)**2-PLAB(3)**2)
        EVERT   = sqrt(dble(PP)**2+dble(xmass)**2) - xmass
      ENDIF
*
      CALL GSKINE(PLAB,LKINE,NVERT,0,0,NT)
*
      IF (FIRST) THEN
         CALL GPRINT('VERT',0)
         CALL GPRINT('KINE',0)
         FIRST = .FALSE.
      ENDIF
*
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE GUOUT
*
*     Call for Geane tracking at the end of Geant tracking.
*          Then compare the two tracking.
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, ERTRIO.
*
      real gxi(3),gpi(4),gxo(3),gpo(4)
      real ubuf(10)
      real plani(3,2),plano(3,3,1),xxo(3),po(4),rc(15)
      real dx(3),dp(3),dd(5),err(5,5),ww(5,5)
*
      double precision p,gp,chi2
*
*     ------------------------------------------------------------------
*
      IF (ISWIT(3).GE.15) THEN
*            fit mode
        CALL GEAFIT
        RETURN
      ENDIF
      call vzero(rc,15)
      do i=1,3
        gxo(i) = vect(i)
        gpo(i) = vect(7)*vect(3+i)
      enddo
      gxo(1) = gxo(1) - 0.002
*
      call gfkine(1,gxi,gpi,ipart,nvert,ubuf,nwbuf)
*
      CALL VZERO(PLANI,6)
      PLANI(2,1) =  1.
      PLANI(3,2) =  1.
      CALL UCOPY(PLANI,PLANO(1,1,1),6)
      PLANO(2,3,1) = 0.
      PLANO(3,3,1) = 0.
      if (ISWIT(3).eq.11) then
        PLANO(1,3,1) = gxo(1)
        CALL EUFILP(1,RC,PLANI,PLANO)
        CALL ERTRAK(gxi,gpi,xxo,po,ipart,'EP')
        IF (IEPRED(1).NE.1) go to 999
        gp = 0.d0
        p  = 0.d0
        do i=1,3
          dx(i) = gxo(i)-xxo(i)
          gp = gp + gpo(i)**2
          p = p + po(i)**2
          dp(i) = gpo(i)/gpo(1)-po(i)/po(1)
        enddo
      elseif (ISWIT(3).eq.12) then
        PLANO(1,3,1) = gxi(1)
        CALL EUFILP(1,RC,PLANI,PLANO)
        CALL ERTRAK(gxo,gpo,xxo,po,ipart,'EPB')
        IF (IEPRED(1).NE.1) go to 999
        gp = 0.d0
        p  = 0.d0
        do i=1,3
          dx(i) = gxi(i)-xxo(i)
          gp = gp + gpi(i)**2
          p = p + po(i)**2
          dp(i) = gpi(i)/gpi(1)-po(i)/po(1)
        enddo
      endif
*
      do i=1,3
        call hfill(i,dx(i),0.,1.)
      enddo
      call hfill(4,dp(2),0.,1.)
      call hfill(5,dp(3),0.,1.)
      dpp =  1./sqrt(gp)-1./sqrt(p)
      dpop = sqrt(gp)*dpp
      call hfill(6,dpop,0.,1.)
      call hfill(16,dpp/sqrt(errout(1,1)),0.,1.)
      call hfill(12,dx(2)/sqrt(errout(13,1)),0.,1.)
      call hfill(13,dx(3)/sqrt(errout(15,1)),0.,1.)
      call hfill(14,dp(2)/sqrt(errout(6,1)),0.,1.)
      call hfill(15,dp(3)/sqrt(errout(10,1)),0.,1.)
      dd(1) = dpp
      dd(2) = dp(2)
      dd(3) = dp(3)
      dd(4) = dx(2)
      dd(5) = dx(3)
      k = 0
      do i=1,5
      do j=i,5
        k= k +1
        err(i,j) = errout(k,1)
        err(j,i) = err(i,j)
      enddo
      enddo
      call ucopy(err,ww,25)
      call rsinv(5,ww,5,ifail)
      k = 0
      do i=1,5
      do j=i,5
        k= k +1
cc        Exy = dd(j)**2*err(i,i) + dd(i)**2*err(j,j)
cc     +      + 2*dd(i)*dd(j)*err(i,j)
cc        if (Exy.gt.0) call hfill(100+k,dd(i)*dd(j)/sqrt(Exy),0.,1.)
        Exy = err(i,i) + err(j,j) + 2*err(i,j)
        if (Exy.gt.0) call hfill(100+k,(dd(i)+dd(j))/sqrt(Exy),0.,1.)
      enddo
      enddo
      chi2 = 0.d0
      do i=1,5
      do j=1,5
        chi2 = chi2 + dd(i)*ww(i,j)*dd(j)
      enddo
      enddo
      call hfill(100,prob(sngl(chi2),5),0.,1.)
*
999   continue
*
      END
+DECK,  GUSTEP, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE GUSTEP
*
+CDE, GCFLAG.
+CDE, GCTRAK.
+CDE, GCVOLU.
*
      COMMON /COORD/CTRU(6,10),NMEA(10),charg
*
      INTEGER IWBOX
      LOGICAL FIRST
*
      SAVE IWBOX,FIRST
*
      DATA FIRST/.TRUE./
*______________________________________________________
*
*
*   * Initialization
*
      IF (FIRST) THEN
        FIRST = .FALSE.
        CALL UCTOH ('WBOX', IWBOX, 4, 4)
      ENDIF
*
**     DEBUG
*
      IF (IDEBUG*ISWIT(2).NE.0) CALL GPCXYZ
*      IF (IDEBUG*ISWIT(2).NE.0) CALL GSXYZ
      CALL GSXYZ
*
**    store measured coordinate
*
      IF (NAMES(NLEVEL).EQ.IWBOX) THEN
        NMEA(NUMBER(3)) = NMEA(NUMBER(3)) + 1
        CTRU(1,NUMBER(3)) = CTRU(1,NUMBER(3)) + VECT(1)
        CTRU(2,NUMBER(3)) = CTRU(2,NUMBER(3)) + VECT(2)
        CTRU(3,NUMBER(3)) = CTRU(3,NUMBER(3)) + VECT(3)
        CTRU(4,NUMBER(3)) = CTRU(4,NUMBER(3)) + VECT(4)*VECT(7)
        CTRU(5,NUMBER(3)) = CTRU(5,NUMBER(3)) + VECT(5)*VECT(7)
        CTRU(6,NUMBER(3)) = CTRU(6,NUMBER(3)) + VECT(6)*VECT(7)
      ENDIF
*
      END
+DECK,  MAIN, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      PROGRAM EREXAM2
*
*      GEANE test program
*
*      It includes fitting examples by
*      V.Innocente, PPE Division, CERN
*
*
      PARAMETER (NG=100000,NH=100000)
      COMMON/PAWC  /H(NH)
      COMMON/GCBANK/Q(NG)
*
+CDE, GCFLAG.
*
      COMMON /COORD/CTRU(6,10),NMEA(10),charg
*
      PARAMETER (NDAT= 8*(6+5+5+1)+1)
      REAL X(NDAT)
      CHARACTER*8 TAGS(NDAT)
      DATA TAGS/
     +      'xt1','yt1','zt1','pt1','dyt1','dzt1','p1','dy1','dz1','y1',
     +      'z1','sp1','sdy1','sdz1','sy1','sz1','c1',
     +      'xt2','yt2','zt2','pt2','dyt2','dzt2','p2','dy2','dz2','y2',
     +      'z2','sp2','sdy2','sdz2','sy2','sz2','c2',
     +      'xt3','yt3','zt3','pt3','dyt3','dzt3','p3','dy3','dz3','y3',
     +      'z3','sp3','sdy3','sdz3','sy3','sz3','c3',
     +      'xt4','yt4','zt4','pt4','dyt4','dzt4','p4','dy4','dz4','y4',
     +      'z4','sp4','sdy4','sdz4','sy4','sz4','c4',
     +      'xt5','yt5','zt5','pt1','dyt5','dzt5','p5','dy5','dz5','y5',
     +      'z5','sp5','sdy5','sdz5','sy5','sz5','c5',
     +      'xt6','yt6','zt6','pt6','dyt6','dzt6','p6','dy6','dz6','y6',
     +      'z6','sp6','sdy6','sdz6','sy6','sz6','c6',
     +      'xt7','yt7','zt7','pt7','dyt7','dzt7','p7','dy7','dz7','y7',
     +      'z7','sp7','sdy7','sdz7','sy7','sz7','c7',
     +      'xt8','yt8','zt8','pt8','dyt8','dzt8','p8','dy8','dz8','y8',
     +      'z8','sp8','sdy8','sdz8','sy8','sz8','c8','chi2'/
*
*_____________________________________________________________________
*
*
c      call apollo_errrec
*
      CALL GZEBRA( NG)
      CALL HLIMIT(-NH)
*
      CALL UGINIT
*
      IF (ISWIT(3).GE.10) THEN
*         geant mode
*
        IF (ISWIT(3).LT.15) THEN
          call hbook1(1,'[D]x',100,-1.,1.,0.)
          call hbook1(2,'[D]y',100,-1.,1.,0.)
          call hbook1(3,'[D]z',100,-1.,1.,0.)
          call hbook1(4,'[D](p?y!/p?x!)',100,-.01,.01,0.)
          call hbook1(5,'[D](p?z!/p?x!)',100,-.01,.01,0.)
          call hbook1(6,'[D]p/p',100,-.1,.1,0.)
          call hbook1(11,'[D]x/[s]',100,-5.,5.,0.)
          call hbook1(12,'[D]y/[s]',100,-5.,5.,0.)
          call hbook1(13,'[D]z/[s]',100,-5.,5.,0.)
          call hbook1(14,'[D](p?y!/p?x!)/[s]',100,-5.,5.,0.)
          call hbook1(15,'[D](p?z!/p?x!)/[s]',100,-5.,5.,0.)
          call hbook1(16,'[D](1/p)/[s]',100,-5.,5.,0.)
          call hbook1(100,'P([v]^2!)',100,0.,1.,0.)
          do i=1,15
            call hbook1(100+i,'[D]x+y/[s]?x+y!',100,-5.,5.,0.)
          enddo
*
        ELSE
*            fit mode
          CALL VZERO(CTRU,70)
*
          call hbook1(1,'[D]p/p',100,-.5,.5,0.)
          call hbook1(2,'[D](p?y!/p?x!)',100,-.015,.015,0.)
          call hbook1(3,'[D](p?z!/p?x!)',100,-.015,.015,0.)
          call hbook1(4,'[D]y',100,-0.2,0.2,0.)
          call hbook1(5,'[D]z',100,-0.5,0.5,0.)
          do i=1,8
            call hbook1(10*i+1,'[D](1/p)/[s]',100,-5.,5.,0.)
            call hbook1(10*i+2,'[D](p?y!/p?x!)/[s]',100,-5.,5.,0.)
            call hbook1(10*i+3,'[D](p?z!/p?x!)/[s]',100,-5.,5.,0.)
            call hbook1(10*i+4,'[D]y/[s]',100,-5.,5.,0.)
            call hbook1(10*i+5,'[D]z/[s]',100,-5.,5.,0.)
             call hbook1(10*i+6,'[D]?m!y/[s]',100,-5.,5.,0.)
            call hbook1(10*i+7,'[D]]?m!z/[s]',100,-5.,5.,0.)
            call hbook1(10*i,'P([v]^2!)',100,0.,1.,0.)
*            call hbook1(10*i+8,'ysigma',100,0.,5.,0.)
*            call hbook1(10*i+9,'zsigma',100,0.,5.,0.)
          enddo
          call hbook1(1000,'P([v]^2!)',100,0.,1.,0.)
          do i=1,3
            call hbook1(1000*i+1,'P([v]^2!)',100,0.,1.,0.)
            call hbook1(1000*i+2,'P([v]^2!)',100,0.,1.,0.)
            call hbook1(1000*i+3,'P([v]^2!?t!)',100,0.,1.,0.)
            call hbook1(1000*i+4,'P([v]^2!?m!)',100,0.,1.,0.)
          enddo
          call hbprof(1011,'[s]?1/p!',8,0.,8.,0.,10.,' ')
          call hbprof(1012,'[s]?py/px!',8,0.,8.,0.,10.,' ')
          call hbprof(1013,'[s]?pz/px!',8,0.,8.,0.,10.,' ')
          call hbprof(1014,'[s]?y!',8,0.,8.,0.,10.,' ')
          call hbprof(1015,'[s]?z!',8,0.,8.,0.,10.,' ')
*
*  book a n-tuple
*
        CALL HROPEN(62,'EREX2','erexam2.ntp','N',1024,IHSTA)
        IF (IHSTA.NE.0) THEN
          PRINT *, 'PROBLEMS WITH HROPEN!!!!!'
        ENDIF
        CALL HBOOKN(999,'erexam2 NTUPLE',NDAT,'EREX2',1000,TAGS)


*
        ENDIF
*
        CALL GRUN
      ELSE
*       geane mode
*
        IF (ISWIT(3).GE.4) THEN
          call hbook1(100,'[d](1/p)',100,-.1,.1,0.)
          call hbook1(200,'[d](p?y!/p?x!)',100,-.2,.2,0.)
          call hbook1(300,'[d](p?z!/p?x!)',100,-.2,.2,0.)
          call hbook1(400,'[d]y',100,-1.0,1.0,0.)
          call hbook1(500,'[d]z',100,-1.0,1.0,0.)
          call hbook1(1,'[Dd](1/p)',100,-.01,.01,0.)
          call hbook1(2,'[Dd](p?y!/p?x!)',100,-.01,.01,0.)
          call hbook1(3,'[Dd](p?z!/p?x!)',100,-.01,.01,0.)
          call hbook1(4,'[Dd]y',100,-0.1,0.1,0.)
          call hbook1(5,'[Dd]z',100,-0.1,0.1,0.)
          call hbook1(11,'[Dd](1/p)/[d]',100,-.2,.2,0.)
          call hbook1(12,'[Dd](p?y!/p?x!)/[d]',100,-.2,.2,0.)
          call hbook1(13,'[Dd](p?z!/p?x!)/[d]',100,-.2,.2,0.)
          call hbook1(14,'[Dd]y/[d]',100,-0.2,0.2,0.)
          call hbook1(15,'[Dd]z/[d]',100,-0.2,0.2,0.)
        ENDIF
*
        CALL TIMEX(TIME)
        CALL ERTEST
        CALL TIMEX(TIM2)
        print *, 'elapsed time ',tim2-time
      ENDIF
*
      CALL GLAST
*
* dump last record of n-tuple and close file
      CALL HCDIR('//PAWC',' ')
      CALL HCDIR('//EREX2',' ')
      CALL HROUT(999,ICYCLE,' ')
      CALL HREND('EREX2')
      CALL HDELET(999)
*
      call HRPUT(0,'erexam2.hrz',' ')
C      CALL HISTDO
*
      STOP
      END
+DECK,  UGEOM, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE UGEOM
*
      DIMENSION PTBOX(3)
*
      DATA PTBOX/110.0,50.0,50.0/
*
      ISVOL=0
      IFIELD=3
      FIELDM=20.0
      TMAXFD=0.1
      DMAXMS=0.1
      DEEMAX=0.01
      EPSIL=0.01
      STMIN=0.01
      CALL GSTMED(1,'air$',15,
     +      ISVOL,IFIELD,FIELDM,TMAXFD,DMAXMS,DEEMAX,EPSIL,STMIN,UBUF,0)
      CALL GSTMED(2,'iron$',10,
     +      ISVOL,IFIELD,FIELDM,TMAXFD,DMAXMS,DEEMAX,EPSIL,STMIN,UBUF,0)
      CALL GSTMED(3,'alluminum$',9,
     +      ISVOL,IFIELD,FIELDM,TMAXFD,DMAXMS,DEEMAX,EPSIL,STMIN,UBUF,0)
*
*     a big volume of air
      CALL GSVOLU('ABOX','BOX ',1,PTBOX,3,IVOLU)
*
*     an iron box surrunding the outer detector
      PTBOX(1) = 80.
      CALL GSVOLU('IBOX','BOX ',2,PTBOX,3,IVOLU)
*
*     divided in 8 parts
      CALL GSDVN('IDIV','IBOX', 8,1)
      CALL GSPOS('IBOX',1,'ABOX',20.,0.,0.,0,'ONLY')
*
*     an air box containing the chamber
      PTBOX(1) = 2.
      CALL GSVOLU('GBOX','BOX ',1,PTBOX,3,IVOLU)
      CALL GSPOS('GBOX',1,'IDIV',8.,0.,0.,0,'ONLY')
*
*     an alluminum box for the chamber walls
      PTBOX(1) = 1.
      CALL GSVOLU('DBOX','BOX ',3,PTBOX,3,IVOLU)
      CALL GSPOS('DBOX',1,'GBOX',0.,0.,0.,0,'ONLY')
*
*     an finally a "gas" box for the sensitive part of the detector
      PTBOX(1) = PTBOX(1) - .2
      PTBOX(2) = PTBOX(2) - .2
      PTBOX(3) = PTBOX(3) - .2
      CALL GSVOLU('WBOX','BOX ',1,PTBOX,3,IVOLU)
      CALL GSPOS('WBOX',1,'DBOX',0.,0.,0.,0,'ONLY')
*
      CALL GGCLOS
*
      END
+DECK,  UGINIT, T=FORT.
* Revision 1.1.1.1  1996/03/06 15:36:26  mclareni
* Add geane321 examples

      SUBROUTINE UGINIT
*
*
      CALL GINIT
      CALL GFFGO
      CALL GZINIT
      CALL GPART
      CALL GMATE
      CALL UGEOM
      CALL GPHYSI
*
* *** Print control
      CALL GPRINT('TMED',0)
      CALL GPRINT('VOLU',0)
*
      END
+PATCH, GXUSER.
+DECK,  GUKINE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:52  cernlib
* Geant

      SUBROUTINE GUKINE
*
************************************************************************
*                                                                      *
*             Generates Kinematics for primary tracks                  *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCONSP.
+CDE, GCSCAN.
+CDE, GCOMIS.
*
      DIMENSION VERTEX(3),PLAB(3)
      DIMENSION RNDM(2)
*
*     -----------------------------------------------------------------
*
+SELF, IF=COMIS.
      IF(JUKINE.NE.0)THEN
         CALL CSJCAL(JUKINE,0,X,X,X,X,X,X,X,X,X,X)
         GO TO 99
      ENDIF
+SELF.

      VERTEX(1)=VSCAN(1)
      VERTEX(2)=VSCAN(2)
      VERTEX(3)=VSCAN(3)
      IF(IKINE.GT.100)THEN
         IK=IKINE-100
         THETA=PKINE(2)*DEGRAD
         PHI=PKINE(3)*DEGRAD
      ELSE
         IK=IKINE
         CALL GRNDM(RNDM,2)
         THETA=PI*RNDM(1)
         PHI=TWOPI*RNDM(2)
      ENDIF
C
      PLAB(1) = PKINE(1)*SIN(THETA)*COS(PHI)
      PLAB(2) = PKINE(1)*SIN(THETA)*SIN(PHI)
      PLAB(3) = PKINE(1)*COS(THETA)
C
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
      CALL GSKINE(PLAB,IK,NVERT,0,0,NT)
*
*              Kinematic debug (controled by ISWIT(1))
*
      IF(IDEBUG.EQ.1.AND.ISWIT(1).EQ.1) THEN
        CALL GPRINT('VERT',0)
        CALL GPRINT('KINE',0)
      ENDIF
*
  99  END
+DECK,  GUOUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:52  cernlib
* Geant

      SUBROUTINE GUOUT
*
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each event.            *
C.    *                                                                *
C.    ******************************************************************
C.
C.
+CDE, GCOMIS.
C.    ------------------------------------------------------------------
C.
+SELF, IF=COMIS.
      IF(JUOUT.NE.0)THEN
         CALL CSJCAL(JUOUT,0,X,X,X,X,X,X,X,X,X,X)
         GO TO 99
      ENDIF
+SELF.
*
  99  END
C
+DECK,  GUSTEP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:52  cernlib
* Geant

      SUBROUTINE GUSTEP
*
************************************************************************
*                                                                      *
*             User routine called at the end of each tracking step     *
*             MEC   is the mechanism origin of the step                *
*             INWVOL is different from 0 when the track has reached    *
*                    a volume boundary                                 *
*             ISTOP is different from 0 if the track has stopped       *
*                                                                      *
************************************************************************
*
+CDE, GCKING.
+CDE, GCOMIS.
*
*     -----------------------------------------------------------------
*
+SELF, IF=COMIS.
      IF(JUSTEP.NE.0)THEN
         CALL CSJCAL(JUSTEP,0,X,X,X,X,X,X,X,X,X,X)
         GO TO 99
      ENDIF
+SELF.
      IF(NGKINE.GT.0) THEN
        DO 5 I=1,NGKINE
          ITYPA  = GKIN(5,I)
          IF(ITYPA.NE.4)  CALL GSKING(I)
   5    CONTINUE
      ENDIF
      CALL GDEBUG
  99  END
+DECK,  UGINIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:52  cernlib
* Geant

      SUBROUTINE UGINIT
*
************************************************************************
*                                                                      *
*              To initialise GEANT3 program and read data cards        *
*                                                                      *
************************************************************************
*
+CDE, GCKINE.
+CDE, GCUNIT.
+CDE, GCPHYS.
*
*     -----------------------------------------------------------------
*
*             Initialize GEANT
C..geant..
      CALL GINIT
*
*             Prints version number
*
      WRITE(LOUT,1000)
*
*             IKINE  = particle type (default=1=gamma)
*             PKINE(1)=particle energy
*             IKINE and PKINE can be changed with the data card KINE
*
      PKINE(1)=10.
      PKINE(5)=4.
      IKINE=1
      ICOMP=1
      IPAIR=1
      IBREM=1
      IANNI=1
      IPHOT=1
      IHADR=1
*
*             Initialize GEANT/ZBOOK data structures
*
C..geant..
      CALL GZINIT
*
*             Initialize graphics package
*
      CALL GDINIT
*
 1000 FORMAT(/,'  MODE VERSION 1.00 : ',/)
      END
+DECK,  UGLAST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:52  cernlib
* Geant

      SUBROUTINE UGLAST
*
************************************************************************
*                                                                      *
*            Termination routine to print histograms and statistics    *
*                                                                      *
************************************************************************
+CDE, GCOMIS.
*
*     -----------------------------------------------------------------
*
+SELF, IF=COMIS.
      IF(JULAST.NE.0)THEN
         CALL CSJCAL(JULAST,0,X,X,X,X,X,X,X,X,X,X)
         GO TO 99
      ENDIF
+SELF.
      CALL GLAST
*
*             Close HIGZ
*
      CALL IGEND
*
  99  END

+PATCH, GXINT.
+DECK,  GDRMAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:47  cernlib
* Geant

      SUBROUTINE GDRMAT(IMATES,IPART,CHMECA,MMEC)
C.    ******************************************************************
C.    *                                                                *
C.    *       DRAW cross sections and energy loss tables               *
C.    *       material IMATE, particle IPART, mecanism name CHMECA,    *
C.    *                                                                *
C.    *      The CHMECAnism name can be :                              *
C.    *      'HADF'   'INEF'   'ELAF'   'FISF'   'CAPF'                *
C.    *      'HADG'   'INEG'   'ELAG'   'FISG'   'CAPG'                *
C.    *      'LOSS'   'PHOT'   'ANNI'   'COMP'   'BREM'                *
C.    *      'PAIR'   'DRAY'   'PFIS'   'RAYL'   'HADG'                *
C.    *      'MUNU'   'RANG'   'STEP'                                  *
C.    *                                                                *
C.    *       For Hadronic particles it also computes the              *
C.    *       hadronic cross section from FLUKA ( '***F' ) or          *
C.    *       GHEISHA ( '***G' ) programs:                             *
C.    *       HADF or HADG -- total                                    *
C.    *       INEF or INEG -- inelastic                                *
C.    *       ELAF or ELAG -- elastic                                  *
C.    *       FISF or FISG -- fission (0.0 for FLUKA)                  *
C.    *       CAPF or CAPG -- neutron capture (0.0 for FLUKA)          *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IMATE   Geant material number                                 *
C.    *  IPART   Geant particle number                                 *
C.    *  CHMECA   mechanism name of the bank to be fetched             *
C.    *                                                                *
C.    *    ==>Called by : <USER>  GXCONT                               *
C.    *       Authors    R.Brun, M.Maire    *********                  *
C.    *                                                                *
C.    ******************************************************************
+CDE, GCBANK.
+CDE, GCMULO.
+CDE, GCONSP.
*
      CHARACTER*4 CHMECA(MMEC)
      CHARACTER*20 MESSGE,NAMEM,NAMEP
      CHARACTER*64 TITLE
      LOGICAL HEXIST,LXBARN
+CDE, GCNMEC.
      DIMENSION CRY(201),IYES(NMECA+2),XC(2)
*
      IF(IMATES.LT.0) THEN
         LXBARN=.TRUE.
      ELSE
         LXBARN=.FALSE.
      ENDIF
      IMATE=ABS(IMATES)
      IDM=-1
      CALL IGSA(0)
      DO 10 JMEC=1,MMEC
         CALL GPLMAT(IMATES,IPART,CHMECA(JMEC),NEKBIN,ELOW,IDM)
   10 CONTINUE
      YMIN=BIG
      YMAX=-BIG
      IOK=0
      IBASE = 10000*IMATE+100*IPART
      DO 30 IDB=1,NMECA+2
         IYES(IDB)=0
         ID=IBASE+IDB
         IF(HEXIST(ID)) THEN
            CALL HNOENT(ID,NOENT)
            IF(NOENT.LE.0)THEN
               CALL HDELET(ID)
            ELSE
               IYES(IDB)=1
               IOK=1
               DO 20 I=1,NEKBIN
                  CRS=HI(ID,I)
                  IF(CRS.LE.0.)GO TO 20
                  IF(CRS.GT.1.E10)GO TO 20
                  IF(CRS.LT.YMIN)YMIN=CRS
                  IF(CRS.GT.YMAX)YMAX=CRS
   20          CONTINUE
            ENDIF
         ENDIF
   30 CONTINUE
      IF(IOK.EQ.0)GO TO 999
*
      CALL HPLOPT('LOGX',1)
      CALL HPLOPT('LOGY',1)
      CALL IGSET('MSCF',0.8)
      CALL IGSET('TXAL',10.)
      YLI=LOG10(YMIN)
      YLA=LOG10(YMAX)
      DELTA=0.05*(YLA-YLI)
      YMIN=10.**(YLI-DELTA)
      YMAX=10.**(YLA+DELTA)
      CALL HPLFRA(ELOW(1),ELOW(NEKBIN+1),YMIN,YMAX,' ')
      XC(1)=ELOW(8)
      XC(2)=ELOW(NEKBIN/2)
      JMA=LQ(JMATE-IMATE)
      CALL UHTOC(IQ(JMA+1),4,NAMEM,20)
      NCHM=LNBLNK(NAMEM)
      IF(NAMEM(NCHM:NCHM).EQ.'$')THEN
         NCHM=NCHM-1
      ENDIF
      JPA=LQ(JPART-IPART)
      CALL UHTOC(IQ(JPA+1),4,NAMEP,20)
      NCHP=LNBLNK(NAMEP)
      IF(NAMEP(NCHP:NCHP).EQ.'$')THEN
         NCHP=NCHP-1
      ENDIF
      TITLE='Tables for '//NAMEP(1:NCHP)//' in '//NAMEM(1:NCHM)
      XCT=XC(1)
      CALL HPLTOC(XCT,YMAX,XCTT,YCTT,NT)
      YCTT=YCTT+0.3
      CALL ISELNT(1)
      CALL IGSET('CHHE',0.28)
      CALL ITX(XCTT,YCTT,TITLE)
      CALL ISELNT(NT)
*
      CALL IGSA(0)
      NSHIF=0
      NPLOT=0
      HSYM = 20
      HCOL = 0
      DO 50 IDB=1,NMECA+2
         IF(IYES(IDB).NE.0)THEN
            IF(HSYM.EQ.31) HSYM = 20
            HSYM = HSYM+1
            IF(HCOL.EQ.7) HCOL = 0
            HCOL = HCOL+1
            ID=10000*IMATE+100*IPART+IDB
            CALL HUNPAK(ID,CRY,'HIST',1)
            CALL HDELET(ID)
            CALL IGSET('MTYP',HSYM)
            CALL IGSET('PMCI',HCOL)
            CALL IGSET('PLCI',HCOL)
            KMIN = 0
            KMAX = 0
            DO 40 IBIN=1,NEKBIN
               IF(CRY(IBIN).GT.0.) THEN
                  IF(KMIN.EQ.0) THEN
                     KMIN = IBIN
                  ENDIF
                  KMAX = IBIN
               ENDIF
   40       CONTINUE
            IF(KMIN.NE.0) THEN
               CALL IGRAPH(KMAX-KMIN+1,ELOW(KMIN),CRY(KMIN),'PLGXY')
            ENDIF
            NPLOT = NPLOT+1
            IND=2-MOD(NPLOT,2)
            IF(IND.EQ.1) THEN
               NSHIF = NSHIF+1
            ENDIF
            YC=10.**(YLA-(NSHIF-1)*0.8*DELTA)
            CALL HPLTOC(XC(IND),YC,XCM,YCM,NT)
            CALL ISELNT(1)
            CALL IPM(1,XCM,YCM)
            IF(IDB.LE.NMECA) THEN
               IF (CHNMEC(IDB).EQ.'LOSS') THEN
                  MESSGE=CHNMEC(IDB)//' (MeV/cm)'
               ELSEIF (CHNMEC(IDB).EQ.'RANG') THEN
                  MESSGE=CHNMEC(IDB)//' (cm)'
               ELSEIF (CHNMEC(IDB).EQ.'STEP') THEN
                  MESSGE=CHNMEC(IDB)//' (cm)'
               ELSE
                  MESSGE=CHNMEC(IDB)//' X-sec'
                  IF(LXBARN) THEN
                    MESSGE(LNBLNK(MESSGE)+1:) = ' (barn)'
                  ELSE
                    MESSGE(LNBLNK(MESSGE)+1:) = ' (1/cm)'
                  ENDIF
               ENDIF
            ELSEIF(IDB.EQ.NMECA+1) THEN
               MESSGE='Tot X-sec'
                  IF(LXBARN) THEN
                    MESSGE(LNBLNK(MESSGE)+1:) = ' (barn)'
                  ELSE
                    MESSGE(LNBLNK(MESSGE)+1:) = ' (1/cm)'
                  ENDIF
            ELSEIF(IDB.EQ.NMECA+2) THEN
               MESSGE='Mean free path (cm)'
            ENDIF
            CALL IGSET('CHHE',0.28)
            CALL ITX(XCM+0.5,YCM,MESSGE)
            CALL ISELNT(NT)
         ENDIF
   50 CONTINUE
      CALL HPLOPT('LINX',1)
      CALL HPLOPT('LINY',1)
      CALL IGSET('PMCI',1.)
      CALL IGSET('PLCI',1.)
  999 END
+DECK,  GIDROP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:48  cernlib
* Geant

      SUBROUTINE GIDROP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      DROP all ZEBRA structures created at initialisation time  *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
C.
C.    ------------------------------------------------------------------
C.
      IF(JMATE .NE.0)CALL MZDROP(IXCONS,JMATE,' ')
      IF(JTMED .NE.0)CALL MZDROP(IXCONS,JTMED,' ')
      IF(JVOLUM.NE.0)CALL MZDROP(IXCONS,JVOLUM,'L')
      IF(JPART .NE.0)CALL MZDROP(IXCONS,JPART,' ')
      IF(JROTM .NE.0)CALL MZDROP(IXCONS,JROTM,' ')
      IF(JSET  .NE.0)CALL MZDROP(IXCONS,JSET,' ')
      JVOLUM=0
      JMATE=0
      JTMED=0
      JPART=0
      JROTM=0
      JSET=0
*
      CALL VZERO (NLEVEL,306)
*
      END

+DECK,  GINTRI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:48  cernlib
* Geant

      SUBROUTINE GINTRI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Defines MENUs and COMMANDs                                *
C.    *       User MENUs initialisation by user routine GUINTI         *
C.    *                                                                *
C.    *    ==>Called by : GXINT                                        *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  S.Giani     **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=USRJMP.
      EXTERNAL GUINTI
+SELF.
C.
C.  ---------------------------------------------------------------------
C.
+SELF, IF=USRJMP.
*
      JUINTI = JUMPAD(GUINTI)
*
+SELF.
      CALL GKDRAW
      CALL GKGCON
      CALL GKGEOM
      CALL GKCONT
      CALL GKRZ
      CALL GKFZ
      CALL GKDZ
      CALL GKSCAN
      CALL GKPHYS
      CALL GKLIST
      CALL GKFORT
+SELF, IF=-USRJMP.
      CALL GUINTI
+SELF, IF=USRJMP.
      CALL JUMPT0(JUINTI)
+SELF.
*
      END



+DECK,  GOPTIM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:48  cernlib
* Geant

      SUBROUTINE GOPTIM(IOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Changes the geometry optimization level.                    *
C.    *    Reprocess the geometry initialization phase.                *
C.    *                                                                *
C.    *    Called by : <GXINT>                                         *
C.    *    Authors   : R.Brun  *********                               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCOPTI.
C.    ------------------------------------------------------------------
*
      IOPTIM=IOPT
      IF(JVOLUM.LE.0)GO TO 999
      JN=LQ(JVOLUM)
      IF(JN.GT.0)CALL MZDROP(IXCONS,JN,' ')
      DO 20 IVO = 1,NVOLUM
         JVO = LQ(JVOLUM-IVO)
         IQ(JVO) = IBCLR(IQ(JVO),0)
         NIN   = Q(JVO+3)
         IF(NIN.GT.0) THEN
            ISEARC = Q(JVO+1)
            IF(ISEARC.LT.0) THEN
               Q(JVO+1)=-Q(LQ(LQ(JVO-NIN-1))+1)
            ENDIF
            NINL = IQ(JVO-2)
            DO 10 I = NIN+1,NINL
               JN=LQ(JVO-I)
               IF(JN.GT.0)CALL MZDROP(IXCONS,JN,' ')
   10       CONTINUE
         ENDIF
   20 CONTINUE
*
      CALL GGCLOS
  999 END
+DECK,  GPAW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:48  cernlib
* Geant

      SUBROUTINE GPAW(NWGEAN,NWPAW)
*
      EXTERNAL      PAEXIT,UGLAST
      CHARACTER*80  BATCHF,PAWLOGF
+CDE, GCFLAG.
+CDE, GCTIME.
+CDE, GCOMIS.
+CDE, GCXLUN.
+CDE, GCUNIT.
*
      CALL TIMEST(1.E6)
*
      PRINT *,' *************************************************** '
      PRINT *,' *                                                 * '
      PRINT *,' *               G E A N T   3 . 2 1               * '
      PRINT *,' *                                                 * '
      PRINT *,' *                    C E R N                      * '
      PRINT *,' *                                                 * '
      PRINT *,' *               15/3/94  Geneva  CH               * '
      PRINT *,' *                                                 * '
      PRINT *,' *************************************************** '
*
      CALL PAWINT1('GEANT',BATCHF,PAWLOGF)
*
      CALL GZEBRA(NWGEAN)
*
      CALL PAWINT2(-NWPAW,' ',UGLAST,IWTYP)
*
+SELF, IF=-IBM.
      CALL ZBRDEF
+SELF.
      CALL GINTRI
*
      CALL PAWINT3
*
+SELF, IF=COMIS.
*
* *** Initialise COMIS
      DO 10 J=1,6
         JPCOMS(J)=0
   10 CONTINUE
      CALL GXCS
+SELF.
*
+SELF, IF=MONITOR.
      CALL GEAMON(0,' ')
+SELF.
      CALL UGINIT
      CALL GDINIT
      IEVENT=0
      CALL TIMEL(TIMINT)
      CALL KUEXEC('ROOT /GEANT')
*
      CALL KUEXEC('SET/PROMPT ''GEANT >''')
*
      CALL PAWINT4(PAWLOGF)
*
      CALL KUWHAG
*
      CALL PAEXIT
*
+SELF, IF=MONITOR.
      CALL GEAMON(2,'GXINT')
+SELF.
      WRITE(CHMAIL,'('' Exiting from GEANT.'')')
      CALL GMAIL(0,0)
*
      END


+DECK,  GPAWPP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:49  cernlib
* Geant

      SUBROUTINE GPAWPP(NWGEAN,NWPAW)
*
      EXTERNAL      PAEXIT,UGLAST
      CHARACTER*80  BATCHF,PAWLOGF
+CDE, GCFLAG.
+CDE, GCTIME.
+CDE, GCOMIS.
+CDE, GCXLUN.
+CDE, GCUNIT.
*
      CALL TIMEST(1.E6)
*
      PRINT *,' *************************************************** '
      PRINT *,' *                                                 * '
      PRINT *,' *               G E A N T   3 . 2 1               * '
      PRINT *,' *                                                 * '
      PRINT *,' *                    C E R N                      * '
      PRINT *,' *                                                 * '
      PRINT *,' *               15/3/94  Geneva  CH               * '
      PRINT *,' *                                                 * '
      PRINT *,' *************************************************** '
*
      CALL PAWINT1('GEANT',BATCHF,PAWLOGF)
*
      CALL GZEBRA(NWGEAN)
*
      CALL PAWINT2(-NWPAW,'+?',UGLAST,IWTYP)
*
      CALL GINTRI
*
      IF(IWTYP.EQ.999)THEN
         CALL PMINIT
         CALL GBROWS
         CALL KUINIM('Geant++')
      ENDIF
*
      CALL PAWINT3
*
      IF(IWTYP.EQ.999)THEN
         CALL KUEXEC('OPTION ZFL1')
+SELF, IF=IBMRT.
         CALL KUEXEC('HOST_EDITOR ''aixterm -e vi &''')
+SELF, IF=-IBMRT, IF=-VAX.
         CALL KUEXEC('HOST_EDITOR ''xterm -e vi &''')
+SELF.
      ENDIF
+SELF, IF=COMIS.
*
* *** Initialise COMIS
      DO 10 J=1,6
         JPCOMS(J)=0
   10 CONTINUE
      CALL GXCS
+SELF.
*
+SELF, IF=MONITOR.
      CALL GEAMON(0,' ')
+SELF.
      CALL UGINIT
      CALL GDINIT
      IEVENT=0
      CALL TIMEL(TIMINT)
      CALL KUEXEC('ROOT /GEANT')
*
      IF(IWTYP.EQ.999)THEN
         CALL KUEXEC('SET/PROMPT ''geant++ >''')
      ELSE
         CALL KUEXEC('SET/PROMPT ''GEANT >''')
      ENDIF
*
      CALL PAWINT4(PAWLOGF)
*
      IF(IWTYP.EQ.999)THEN
         CALL KUWHAM('Geant++')
      ELSE
         CALL KUWHAG
      ENDIF
*
      CALL PAEXIT
*
+SELF, IF=MONITOR.
      CALL GEAMON(2,'GXINT')
+SELF.
      WRITE(CHMAIL,'('' Exiting from GEANT.'')')
      CALL GMAIL(0,0)
*
      END


+DECK,  GXCLOS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:49  cernlib
* Geant

      SUBROUTINE GXCLOS(LUN)
*
*                To close unit LUN
*
+SELF, IF=IBM.
      CHARACTER*80 CHTEMP
      CHARACTER*3 CHLUN
+SELF.
*________________________________________________________
*
         CLOSE (LUN)
+SELF, IF=IBM.
         WRITE(CHLUN,'(I3)')LUN
         CHTEMP='FILEDEF '//CHLUN//'  CLEAR'
         CALL VMCMS(CHTEMP,ISTAT)
+SELF.
*
      END

+DECK,  GXCONT, T=FORT.
*CMZ :          05/02/96  17.20.51  by  S.Ravndal
*CMZ :  3.21/02 07/07/94  19.47.38  by  S.Giani
*-- Author :
      SUBROUTINE GXCONT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      General control commands                                  *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                  S.Giani     **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, PAWC.
+CDE, GCTMED.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCPHYS.
+CDE, GCMULO.
+CDE, GCLIST.
+CDE, GCSTAK.
+CDE, GCDRAW.
      CHARACTER*20 CHNAME
      CHARACTER*4  CHMECA,CHDEB,CHSET,CHDET,CHMECS(20)
      CHARACTER*32 CHPATL
      CHARACTER*32 CHPAR,NAMATE,NAPAR
      CHARACTER*32 UBUF,WMAT,AA,ZZ
      CHARACTER*32 BRATIO,MODE
C.
C.    ------------------------------------------------------------------
C.
      IWKSTY = IGIWTY(1)
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'KINE') THEN
         CALL KUGETI(IKINE)
         NPK=NPAR-1
         DO 10 I=1,NPK
            CALL KUGETR(PKINE(I))
   10    CONTINUE
*
      ELSEIF (CHPATL.EQ.'SORD') THEN
         CALL KUGETI(ISTORD)
*
*     ELSEIF (CHPATL.EQ.'PATR') THEN
*        CALL KUGETI(NJTMAX)
*        CALL KUGETI(NJTMIN)
*        WRITE(CHMAIL,'('' *** GXCONT: Parallel tracking disabled, '',
*    +                  ''see documentation'')')
*        CALL GMAIL(1,1)
*
      ELSEIF (CHPATL.EQ.'RUNG') THEN
         CALL KUGETI(IDRUN)
         CALL KUGETI(IDEVT)
*
      ELSEIF (CHPATL.EQ.'GTIME') THEN
         CALL KUGETR(TIMINT)
         CALL KUGETR(TIMEND)
         CALL KUGETI(ITIME)
*
      ELSEIF (CHPATL.EQ.'TRACK') THEN
         IF(JXYZ.NE.0)CALL MZDROP(IXDIV,JXYZ,' ')
         IF(JHITS.NE.0)CALL MZDROP(IXDIV,JHITS,' ')
         CALL MZGARB(IXDIV,0)
         CALL GTREVE
*
      ELSEIF (CHPATL.EQ.'TRIGGER') THEN
         CALL KUGETI(N)

         IF( NEVENT .EQ. 10000000 .OR. NEVENT .NE. IEVENT) THEN
            NEVENT = N
         ELSE
            NEVENT = NEVENT + N
         ENDIF

 20      CONTINUE

         IF( IEVENT .LT. NEVENT ) THEN

            CALL GTRIGC
            IEVENT=IEVENT+1
            CALL GTRIGI
            CALL GTRIG
            CALL GRNDMQ(IQ(JRUNG+19),IQ(JRUNG+20),0,'G')
            IQ(JRUNG+29)=IEVENT

            GOTO 20

         ENDIF

*         DO 20 I=1,N
*            CALL GTRIGC
*            IEVENT=IEVENT+1
*            CALL GTRIGI
*            CALL GTRIG
*            CALL GRNDMQ(IQ(JRUNG+19),IQ(JRUNG+20),0,'G')
*            IQ(JRUNG+29)=IEVENT
*   20    CONTINUE
*
      ELSEIF (CHPATL.EQ.'SWITCH') THEN
         CALL KUGETI(I)
         IF(I.GE.1.AND.I.LE.10) THEN
            IF(NPAR.LT.2)THEN
               WRITE(CHMAIL,'('' ISWIT('',I2,'')= '',I3)')I,ISWIT(I)
               CALL GMAIL(0,0)
            ENDIF
            CALL KUGETI(ISWIT(I))
         ENDIF
*
      ELSEIF (CHPATL.EQ.'PRINT') THEN
         CALL KUGETC(CHNAME,NCH)
         N=0
         CALL KUGETI(N)
         CALL GPRINT(CHNAME,N)
*
      ELSEIF (CHPATL.EQ.'DEBUG') THEN
         CALL KUGETC(CHDEB,NCH)
         IF(CHDEB.EQ.'ON')THEN
            IDEBUG=1
            IDEMIN=1
            IDEMAX=1000000
            ITIME=1
         ELSE
            IDEBUG=0
            IDEMIN=0
            IDEMAX=0
         ENDIF
*
      ELSEIF (CHPATL.EQ.'OUTPUT_LP') THEN
         CALL KUGETI(LOUT)
*
      ELSEIF (CHPATL.EQ.'PHITS') THEN
         CALL KUGETC(CHSET,NCH)
         CALL KUGETC(CHDET,NCH)
         CALL KUGETI(NUMHIT)
         IPKHIT=NUMHIT
         CALL GPHITS(CHSET,CHDET)
         IPKHIT=0
*
      ELSEIF (CHPATL.EQ.'PDIGI') THEN
         CALL KUGETC(CHSET,NCH)
         CALL KUGETC(CHDET,NCH)
         CALL GPDIGI(CHSET,CHDET)
*
      ELSEIF (CHPATL.EQ.'MZLOGL') THEN
         IXSTOR=0
         LEVEL=0
         CALL KUGETI(LEVEL)
         CALL MZLOGL(IXSTOR,LEVEL)
*
      ELSEIF (CHPATL.EQ.'PMATE') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPMATX(NUMB)
         ELSE
            CALL GPMATE(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'SMATE') THEN
         CALL KUGETI(IMAT)
         CALL KUGETC(NAMATE,NCH)
         CALL KUGETR(A)
         CALL KUGETR(Z)
         CALL KUGETR(DENS)
         CALL KUGETR(RADL)
         CALL KUGETR(ABSL)
         CALL KUGETV(UBUF,LLOW,LHIGH)
         CALL KUGETI(NWBUF)
         CALL GSMATE(IMAT,NAMATE,A,Z,DENS,RADL,ABSL,QQ(LLOW),NWBUF)
*
      ELSEIF (CHPATL.EQ.'SMIXT') THEN
         CALL KUGETI(IMAT)
         CALL KUGETC(NAMATE,NCH)
         CALL KUGETV(AA,LLOW,LHIGH)
         CALL KUGETV(ZZ,LLO1,LHIG1)
         CALL KUGETR(DENS)
         CALL KUGETI(NLMAT)
         CALL KUGETV(WMAT,LLO2,LHIG2)
         CALL GSMIXT(IMAT,NAMATE,QQ(LLOW),QQ(LLO1),DENS,NLMAT,QQ(LLO2))
*
      ELSEIF (CHPATL.EQ.'PRMAT') THEN
         CALL KUGETI(IMATE)
         CALL KUGETI(IPART)
         CALL KUGETC(CHMECA,NCH)
         CALL GPRMAT(IMATE,IPART,CHMECA,NEKBIN,ELOW)
*
      ELSEIF (CHPATL.EQ.'DRMAT') THEN
         CALL KUGETI(IMATE)
         CALL KUGETI(IPART)
         IF(NPAR.GT.2) THEN
            NMEC = NPAR-2
            DO 11 KMEC=1,NMEC
               CALL KUGETC(CHMECS(KMEC),NCH)
  11        CONTINUE
         ELSE
            NMEC = 1
            CHMECS(1)='ALL'
         ENDIF
         CALL GDRMAT(IMATE,IPART,CHMECS,NMEC)
*
      ELSEIF (CHPATL.EQ.'PLMAT') THEN
         CALL KUGETI(IMATE)
         CALL KUGETI(IPART)
         CALL KUGETC(CHMECA,NCH)
         IDM=0
         CALL KUGETI(IDM)
         CALL GPLMAT(IMATE,IPART,CHMECA,NEKBIN,ELOW,IDM)
*
      ELSEIF (CHPATL.EQ.'SPART') THEN
         CALL KUGETI(IPART)
         CALL KUGETC(NAPAR,NCH)
         CALL KUGETI(ITRTYP)
         CALL KUGETR(AMASS)
         CALL KUGETR(CHARGE)
         CALL KUGETR(TLIFE)
         CALL KUGETV(UBUF,LLOW,LHIGH)
         CALL KUGETI(NWBUF)
         CALL KUGETV(BRATIO,LLO1,LHI1)
         CALL KUGETV(MODE,LLO2,LHI2)
         CALL GSPART(IPART,NAPAR,ITRTYP,AMASS,CHARGE,TLIFE,
     +               QQ(LLOW),NWBUF)
         CALL GSDK(IPART,QQ(LLO1),IQQ(LLO2))
*
      ELSEIF (CHPATL.EQ.'PPART') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPPARX(NUMB)
         ELSE
            CALL GPPART(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'PRKINE') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPKINX(NUMB)
         ELSE
            CALL GPKINE(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'STPAR') THEN
         CALL KUGETI(ITMED)
         CALL KUGETC(CHPAR,NCH)
         CALL KUGETR(PARVAL)
         CALL GSTPAR(ITMED,CHPAR,PARVAL)
*
      ELSEIF (CHPATL.EQ.'RNDM') THEN
        IF (NPAR.EQ.0) THEN
          CALL GRNDMQ(IS1,IS2,0,'G')
          WRITE(6, 10000) IS1, IS2
        ELSEIF (NPAR.EQ.2) THEN
          CALL KUGETI(NRNDM(1))
          CALL KUGETI(NRNDM(2))
          IF ( NRNDM(2) .NE. 0 ) THEN
            CALL GRNDMQ(NRNDM(1),NRNDM(2),1,'S')
          ELSE
            ISEQ=NRNDM(1)
            CALL GRNDMQ(NRNDM(1),NRNDM(2),ISEQ,'Q')
            CALL GRNDMQ(NRNDM(1),NRNDM(2),ISEQ,'S')
          ENDIF
        ELSE
          WRITE(6, 10100)

10100 FORMAT(' Please give 2 seeds to initialize the random ',
     +       'number generator')

10000 FORMAT('  (E154) RANDOM NUMBER = ',2I12)
         ENDIF
      ENDIF
*
   30 END
+DECK,  GXCS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:49  cernlib
* Geant

+SELF, IF=COMIS.
      SUBROUTINE GXCS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        To initialize the COMIS package                         *
C.    *        To declare addresses of FORTRAN routines and COMMONs    *
C.    *        which may be invoked from COMIS routines                *
C.    *        (one can call CSOMAP instead)                           *
C.    *                                                                *
C.    ******************************************************************
+CDE, GCBANK.
+CDE, GCMATE.
+CDE, GCTMED.
+CDE, GCVOLU.
+CDE, GCFLAG.
+CDE, GCTRAK.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCCUTS.
+CDE, GCLIST.
+CDE, GCNUM.
+CDE, GCONST.
+CDE, GCPHYS.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCMULO.
+CDE, GCOMIS.
      DIMENSION P(1)
*
      EXTERNAL GINIT,GZINIT,GDINIT,GPRINT,GPSETS,GXCLOS
      EXTERNAL GSVERT,GSKINE,GSKING,GOPEN,GFIN,GCLOSE
      EXTERNAL GFOUT
      EXTERNAL GMATE,GSMATE,GSMIXT,GSTMED,GSTPAR,GPART,GPHYSI
      EXTERNAL GFMATE,GPIONS
      EXTERNAL GTRIG,GTRIGI,GTRIGC,GTREVE,GIDROP
      EXTERNAL GSVOLU,GSPOS,GSPOSP,GSDVN,GSDVS,GGCLOS,GOPTIM
      EXTERNAL GSROTM,GSORD,GSDET,GSDETH,GSDETV,GSATT
      EXTERNAL GPLMAT,GSAHIT,GSCHIT,GSDIGI,GSXYZ,GDEBUG
      EXTERNAL GPCXYZ,GDCXYZ,GDXYZ,GDAHIT,GDCHIT,GDHITS,GDHEAD
      EXTERNAL GDOPEN,GDCLOS,GDRAW,GDRAWC,GDSCAL,GDMAN,GDCOL
      EXTERNAL GDELET,GDAXIS,GDRAWT
      EXTERNAL GSCANK,GSCANU,GSCANO
      EXTERNAL UGLAST
*
C.
C.    ------------------------------------------------------------------
C.
      CALL PAWCS
*
      CALL CSCOM('GCLINK,GCBANK,GCCUTS,GCFLAG,GCKINE,GCLIST#'
     +,           JDIGI,NZEBRA,CUTGAM,IDEBUG,IKINE,NHSTA,P,P,P,P)
      CALL CSCOM('GCMATE,GCNUM,GCONST,GCPHYS,GCTMED,GCTRAK#'
     +,           NMAT,NMATE,PI,IPAIR,NUMED,VECT,P,P,P,P)
      CALL CSCOM('GCUNIT,GCVOLU,GCDRAW,GCKING,GCMULO#',LIN,NLEVEL,NUMNOD
     +,           KCASE,SINMUL,P,P,P,P,P)
*
      CALL CSEXT('GINIT,GZINIT,GDINIT,GPRINT,GPSETS,GXCLOS#'
     +,           GINIT,GZINIT,GDINIT,GPRINT,GPSETS,GXCLOS,P,P,P,P)
      CALL CSEXT(
     +'GSVERT,GSKINE,GSKING,GFIN,GOPEN,GCLOSE,GFOUT#',
     + GSVERT,GSKINE,GSKING,GFIN,GOPEN,GCLOSE,GFOUT,
     +            P,P,P)
      CALL CSEXT('GMATE,GSMATE,GFMATE,GSMIXT,GSTMED,GSTPAR,GPART,
     +            GPIONS,GPHYSI#'
     +,           GMATE,GSMATE,GFMATE,GSMIXT,GSTMED,GSTPAR,GPART,
     +            GPIONS,GPHYSI,P)
      CALL CSEXT('GTRIG,GTRIGI,GTRIGC,GTREVE,GIDROP#'
     +,           GTRIG,GTRIGI,GTRIGC,GTREVE,GIDROP,P,P,P,P,P)
      CALL CSEXT('GSVOLU,GSPOS,GSPOSP,GSDVN,GSDVS,GGCLOS,GOPTIM#'
     +,           GSVOLU,GSPOS,GSPOSP,GSDVN,GSDVS,GGCLOS,GOPTIM
     +,           P,P,P)
      CALL CSEXT('GSROTM,GSORD,GSDET,GSDETH,GSDETV,GSATT#'
     +,           GSROTM,GSORD,GSDET,GSDETH,GSDETV,GSATT,P,P,P,P)
      CALL CSEXT('GPLMAT,GSAHIT,GSCHIT,GSDIGI,GSXYZ,GDEBUG#'
     +,           GPLMAT,GSAHIT,GSCHIT,GSDIGI,GSXYZ,GDEBUG,P,P,P,P)
      CALL CSEXT('GPCXYZ,GDCXYZ,GDXYZ,GDAHIT,GDCHIT,GDHITS,GDHEAD#'
     +,           GPCXYZ,GDCXYZ,GDXYZ,GDAHIT,GDCHIT,GDHITS,GDHEAD
     +,           P,P,P)
      CALL CSEXT('GDOPEN,GDCLOS,GDELET,GDRAW,GDRAWC,GDAXIS,GDSCAL,GDMAN,
     +            GDCOL#'
     +,           GDOPEN,GDCLOS,GDELET,GDRAW,GDRAWC,GDAXIS,GDSCAL,GDMAN,
     +            GDCOL,P)
      CALL CSEXT('GDRAWT#',GDRAWT,P,P,P,P,P,P,P,P,P)
      CALL CSEXT('GSCANK,GSCANU,GSCANO,GBRSGE#',GSCANK,GSCANU,GSCANO,
     +            GBRSGE,P,P,P,P,P,P)
      CALL CSEXT('UGLAST#',UGLAST,P,P
     +,           P,P,P,P,P,P,P)
*
      CALL GUXCS
*
      END

+SELF.
+DECK,  GXDRAW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:49  cernlib
* Geant

      SUBROUTINE GXDRAW
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Drawing commands                                          *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                  S.Giani     **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, PAWC.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCGOBJ.
+CDE, GCMUTR.
+CDE, GCSPEE.
+CDE, GCCURS.
+CDE, GCHIL2.
+CDE, GCURSB.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
+CDE, GCVDMA.
+CDE, GCFDIM.
*
      COMMON/QUEST/IQUEST(100)
*
      DIMENSION NNAME(15),NNUMB(15),RVAL(2)
*SG
      DIMENSION VX(4),VXX(4),VVX(4),XV(4),BX(4)
      DIMENSION VY(4),VYY(4),VVY(4),YV(4),BY(4)
      CHARACTER*4 NAME,CHNUMB,IDS,IVS,ICS,NNVV,NVNV,MOTH
      CHARACTER*4 CHNRS,CHAX,YESNO,CENT
      CHARACTER*4 NOPT,SAMP,KSAM,KLSA
      CHARACTER*6 MODE

*SG
      CHARACTER*80 CHTEXT
      CHARACTER*32 CHPATL,VNAME
      CHARACTER*64 NAMNUM
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'BOX ') THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
10000      FORMAT(' *** GXDRAW ***:',
     +            ' No more space to store MCVOL information.')
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
10100      FORMAT(' *** GXDRAW ***: Please reset MCVOL')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(XMIN)
         CALL KUGETR(XMAX)
         CALL KUGETR(YMIN)
         CALL KUGETR(YMAX)
         CALL KUGETR(ZMIN)
         CALL KUGETR(ZMAX)
         IF(XMIN.GE.XMAX.OR.YMIN.GE.YMAX.OR.ZMIN.GE.ZMAX)THEN
            WRITE(CHMAIL,10200)
10200       FORMAT(' Wrong Box limits. Check values ')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='BOX'
         GXMIN(NCVOLS)=XMIN
         GXMAX(NCVOLS)=XMAX
         GYMIN(NCVOLS)=YMIN
         GYMAX(NCVOLS)=YMAX
         GZMIN(NCVOLS)=ZMIN
         GZMAX(NCVOLS)=ZMAX
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
* Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 10 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=-100000
               GXMAX(JJ)=-99999
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-99999
               GZMIN(JJ)=-100000
               GZMAX(JJ)=-99999
   10       CONTINUE
            NCVOLS=0
         ENDIF
      ELSEIF (CHPATL.EQ.'TUBE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX)
         CALL KUGETR(ZDEM)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='TUBE'
         GXMIN(NCVOLS)=RMAX
         GXMAX(NCVOLS)=ZDEM
         GYMIN(NCVOLS)=XMED
         GYMAX(NCVOLS)=YMED
         GZMIN(NCVOLS)=ZMED
         GZMAX(NCVOLS)=0.
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 20 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=0.1
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-100000
               GZMIN(JJ)=-100000
               GZMAX(JJ)=0.
   20       CONTINUE
            NCVOLS=0
         ENDIF

      ELSEIF (CHPATL.EQ.'CONE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX1)
         CALL KUGETR(RMAX2)
         CALL KUGETR(ZDEM)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='CONE'
         GXMIN(NCVOLS)=RMAX1
         GXMAX(NCVOLS)=RMAX2
         GYMIN(NCVOLS)=ZDEM
         GYMAX(NCVOLS)=XMED
         GZMIN(NCVOLS)=YMED
         GZMAX(NCVOLS)=ZMED
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 30 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=0.1
               GYMIN(JJ)=0.1
               GYMAX(JJ)=-100000
               GZMIN(JJ)=-100000
               GZMAX(JJ)=-100000
   30       CONTINUE
            NCVOLS=0
         ENDIF

      ELSEIF (CHPATL.EQ.'SPHE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='SPHE'
         GXMIN(NCVOLS)=RMAX
         GXMAX(NCVOLS)=XMED
         GYMIN(NCVOLS)=YMED
         GYMAX(NCVOLS)=ZMED
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 40 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=-100000
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-100000
   40       CONTINUE
            NCVOLS=0
         ENDIF
*
      ELSEIF (CHPATL.EQ.'VALCUT') THEN
         CALL KUGETR(XCUT)
         CALL KUGETR(YCUT)
         CALL KUGETR(ZCUT)
*
      ELSEIF (CHPATL.EQ.'SPOT') THEN
         CALL KUGETR(XLPOS)
         CALL KUGETR(YLPOS)
         CALL KUGETR(ZLPOS)
         CALL KUGETI(INTEN)
         CALL GLIGHT(XLPOS,YLPOS,ZLPOS,INTEN)
*
      ELSEIF (CHPATL.EQ.'VAR5D') THEN
         CALL KUGETR(TSEQTO)
         CALL KUGETI(NPROC)
         CALL KUGETI(NMPTOT)
         CALL KUGETR(TOTMBY)
         CALL KUGETR(TSEQ)
         CALL KUGETR(TLAT)
         CALL KUGETR(TNET)
*
      ELSEIF (CHPATL.EQ.'RANG5D') THEN
         CALL KUGETR(X1MIN)
         CALL KUGETR(X1MAX)
         CALL KUGETR(Y1MIN)
         CALL KUGETR(Y1MAX)
         CALL KUGETR(Z1MIN)
         CALL KUGETR(Z1MAX)
*
      ELSEIF (CHPATL.EQ.'DRAW') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         GTHETL=GTHETA
         GPHIL=GPHI
         GPSIL=GPSI
         GU0L=GU0
         GV0L=GV0
         GSCUL=GSCU
         GSCVL=GSCV
         IF(RAYTRA.EQ.1.)THEN
           CALL GDRAYT(NAME,GTHETL,GPHIL,GPSIL,GU0L,GV0L,GSCUL,GSCVL)
         ELSE
           CALL GDRAW(NAME,GTHETL,GPHIL,GPSIL,GU0L,GV0L,GSCUL,GSCVL)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'DVOLUME') THEN
         CALL KUGETI(N)
         IF (N.EQ.0) GO TO 60
         IF (N.LT.0.OR.N.GT.15) GO TO 999
*
         CALL KUGETC(CHTEXT,NCH)
         DO 50 I=1,N
            CALL KUGETL(NAMNUM,NCH)
            CALL UCTOH(NAMNUM,NNAME(I),4,4)
            CALL KUGETL(CHNUMB,NCH)
            CALL KICTON(CHNUMB,NNUMB(I),RVAL)
            IF (IQUEST(1).NE.0) GO TO 999
   50    CONTINUE
*
         CALL KUGETC(CHNRS,NCH)
         NRS=0
         IF (CHNRS.EQ.'DRS') NRS=1
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
   60    CALL GDRVOL(N,NNAME,NNUMB,NRS,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,
     +   GSCV)
*
      ELSEIF (CHPATL.EQ.'DCUT') THEN
         IHOLE=0
         CALL KUGETC(NAME,NCH)
         CALL KUGETC(CHAX,NCH)
         IF (CHAX.EQ.'X'.OR.CHAX.EQ.'1') THEN
            IAX=1
         ELSEIF (CHAX.EQ.'Y'.OR.CHAX.EQ.'2')THEN
            IAX=2
         ELSEIF (CHAX.EQ.'Z'.OR.CHAX.EQ.'3')THEN
            IAX=3
         ENDIF
         CALL KUGETR(CCUT)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL GDRAWC(NAME,IAX,CCUT,GU0,GV0,GSCU,GSCV)
*
      ELSEIF (CHPATL.EQ.'DXCUT') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(CUTTHE)
         CALL KUGETR(CUTPHI)
         CALL KUGETR(CCUT)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL GDRAWX(NAME,CUTTHE,CUTPHI,CCUT,GTHETA,GPHI,GU0,GV0,GSCU,
     +   GSCV)
*
***SG
*
*
*   It's now possible to shift each volume into a more visible place !
*
      ELSEIF(CHPATL.EQ.'SHIFT') THEN
         IF(NSHIFT.EQ.0)KSHIFT=1
         NSHIFT=NSHIFT+1
         IF(NSHIFT.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10300)
10300      FORMAT(' *** GXDRAW ***:',
     +            ' No more space to store SHIFT information.')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NVNV,NCH)
         CALL KUGETR(XXXX)
         CALL KUGETR(YYYY)
         CALL KUGETR(ZZZZ)
         GNVNV(NSHIFT)=NVNV
         GXXXX(NSHIFT)=XXXX
         GYYYY(NSHIFT)=YYYY
         GZZZZ(NSHIFT)=ZZZZ
*   Resetting Shift mode
         IF(GNVNV(NSHIFT).EQ.'.')THEN
            KSHIFT=0
            DO 70 KK=1,NSHIFT
               GNVNV(KK)=' '
               GXXXX(KK)=0
               GYYYY(KK)=0
               GZZZZ(KK)=0
   70       CONTINUE
            NSHIFT=0
         ENDIF
*
*  To make the detector 'explode'
*
      ELSEIF(CHPATL.EQ.'BOMB')THEN
         CALL KUGETR(BOOM)
         GBOOM=BOOM
*
***SG
*
      ELSEIF (CHPATL.EQ.'DTREE') THEN
*         JSIM=0
         KXXX=0
         NNPAR=NPAR
         CALL KUGETC(NAME,NCH)
         CALL UHTOC(IQ(JVOLUM+1),4,MOMO,4)
         CALL KUGETI(LEVMAX)
         IF(NNPAR.EQ.3)THEN
            CALL KUGETI(ISELT)
            IISELT=ISELT
         ELSE
            ISELT=111
         ENDIF
         IWTY=IGIWTY(1)
         JVSIM=2
         IF(IWTY.GT.10.OR.IWTY.LT.1)JVSIM=1
         IF (NAME.EQ.'    ')NAME=MOMO
         IF (NAME.NE.MOMO) THEN
            INTFLA=10
            CALL GDTREE(MOMO,0,110)
            DO 80 J=1,NUMND2
               IQ(JFINAM+J)=IQ(JNAM1+J)
               IQ(JFISCA+J)=IQ(JSCA1+J)
               IQ(JFIMOT+J)=IQ(JMOT1+J)
   80       CONTINUE
            KXXX=1
            IF(LEVMAX.LT.0)THEN
               LEVMAX=-LEVMAX
               DO 90  II=1,LEVMAX
                  CALL GDTR8(NAME,MOTH,IONL)
                  NAME=MOTH
   90          CONTINUE
               LEVMAX=3
            ENDIF
         ELSE
            INTFLA=10
            CALL GDTREE(NAME,0,110)
            DO 100 J=1,NUMND2
               IQ(JFINAM+J)=IQ(JNAM1+J)
               IQ(JFISCA+J)=IQ(JSCA1+J)
               IQ(JFIMOT+J)=IQ(JMOT1+J)
  100       CONTINUE
            INTFLA=-1
            CALL GDTREE(NAME,LEVMAX,ISELT)
         ENDIF
*
         CALL GDPLST(JVSIM,NAME,LEVMAX,KXXX)
*
      ELSEIF (CHPATL.EQ.'DSPEC') THEN
         CALL KUGETC(NAME,NCH)
         CALL GDSPEC(NAME)
*
      ELSEIF (CHPATL.EQ.'D3DSPEC') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(TETA3)
         CALL KUGETR(PHI3)
         CALL KUGETR(PSI3)
         CALL KUGETR(U03)
         CALL KUGETR(V03)
         CALL KUGETR(ZM3)
         CALL GSPE3D(NAME,TETA3,PHI3,PSI3,U03,V03,ZM3)
*
      ELSEIF (CHPATL.EQ.'DFSPC') THEN
         CALL KUGETC(NAME,NCH)
         ISORT=0
         CALL KUGETC(YESNO,NCH)
         IF (YESNO.EQ.'Y') ISORT=1
         INTER=1
         CALL KUGETC(MODE,NCH)
         IF (MODE.EQ.'B') INTER=0
         CALL GDFSPC(NAME,ISORT,INTER)
*
      ELSEIF (CHPATL.EQ.'DTEXT') THEN
         CALL KUGETR(X0)
         CALL KUGETR(Y0)
         CALL KUGETS(CHTEXT,NCH)
         CALL KUGETR(SIZE)
         CALL KUGETR(ANGLE)
         CALL KUGETI(LWID)
         CALL KUGETC(CENT,NCH)
         IF (CENT.EQ.'LEFT'.OR.CENT.EQ.'-1') THEN
            IOPT=-1
         ELSEIF (CENT.EQ.'RIGHT'.OR.CENT.EQ.'1') THEN
            IOPT=1
         ELSE
            IOPT=0
         ENDIF
         CALL IGSET('TXFP',-60.)
         IWTY=IGIWTY(1)
         IF(IWTY.GT.10.OR.IWTY.LT.1)CALL IGSET('TXFP',-61.)
         CALL GDRAWT(X0,Y0,CHTEXT,SIZE,ANGLE,LWID,IOPT)
         CALL IGSET('TXFP',2.)
*
      ELSEIF (CHPATL.EQ.'DVECTOR') THEN
         CALL KUGETV(VNAME,LPARX,LLL)
         CALL KUGETV(VNAME,LPARY,LLL)
         CALL KUGETI(NP)
         CALL GDRAWV(QQ(LPARX),QQ(LPARY),NP)
*
      ELSEIF (CHPATL.EQ.'DSCALE') THEN
         CALL KUGETR(X0)
         CALL KUGETR(Y0)
         CALL GDSCAL(X0,Y0)
*
      ELSEIF (CHPATL.EQ.'DAXIS') THEN
         CALL KUGETR(XX0)
         CALL KUGETR(YY0)
         CALL KUGETR(ZZ0)
         CALL KUGETR(DDX)
         CALL GDAXIS(XX0,YY0,ZZ0,DDX)
*
      ELSEIF (CHPATL.EQ.'DMAN') THEN
         CALL KUGETR(U0)
         CALL KUGETR(V0)
         CALL KUGETC(MODE,NCH)
         IF (MODE.EQ.'WM1') THEN
            CALL GDWMN1(U0,V0)
         ELSE IF (MODE.EQ.'WM3') THEN
            CALL GDWMN3(U0,V0)
         ELSE IF (MODE.EQ.'WM2') THEN
            CALL GDWMN2(U0,V0)
         ELSE IF (MODE.EQ.'MAN') THEN
            CALL GDMAN(U0,V0)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'DHEAD') THEN
         ISELH=111110
         CALL KUGETI(ISELH)
         CHRSIZ=0.6
         CALL KUGETS(CHTEXT,NCH)
         CALL KUGETR(CHRSIZ)
         CALL GDHEAD(ISELH,CHTEXT,CHRSIZ)
*
      ELSEIF (CHPATL.EQ.'MEASURE') THEN
         CALL IGLOC2(1,NT,U0,V0,U1,V1,ISTAT,'L')
         IF (ISTAT.EQ.0) GO TO 999
         UDIST=(U1-U0)/(GSCU*GZUA)
         VDIST=(V1-V0)/(GSCV*GZVA)
         DIST=SQRT(UDIST*UDIST+VDIST*VDIST)
         WRITE (CHMAIL,'('' MEASURE : '',F9.4,'' CM'')') DIST
         CALL GMAIL(0,0)
*
      ELSEIF (CHPATL.EQ.'MOVE')  THEN
         IWTY=IGIWTY(1)
         IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
            ISTAT=0
            LEP=-ABS(LEP)
            CALL KUGETC(NAME,NCH)
            CALL KUGETC(NOPT,NCH)
            VX(1)=0.
            VX(2)=4.
            VX(3)=4.
            VX(4)=0.
            VY(1)=0.
            VY(2)=0.
            VY(3)=1.
            VY(4)=1.
            VXX(1)=4.
            VXX(2)=8.
            VXX(3)=8.
            VXX(4)=4.
            VYY(1)=0.
            VYY(2)=0.
            VYY(3)=1.
            VYY(4)=1.
            VVX(1)=8.
            VVX(2)=12.
            VVX(3)=12.
            VVX(4)=8.
            VVY(1)=0.
            VVY(2)=0.
            VVY(3)=1.
            VVY(4)=1.
            XV(1)=12.
            XV(2)=16.
            XV(3)=16.
            XV(4)=12.
            YV(1)=0.
            YV(2)=0.
            YV(3)=1.
            YV(4)=1.
            BX(1)=16.
            BX(2)=20.
            BX(3)=20.
            BX(4)=16.
            BY(1)=0.
            BY(2)=0.
            BY(3)=1.
            BY(4)=1.
*****           CALL IGSET('DRMD',2.)
            CALL ISFAIS(1)
            CALL GDCOL1(2)
            CALL IFA(4,VX,VY)
            CALL GDCOL1(3)
            CALL IFA(4,VXX,VYY)
            CALL GDCOL1(4)
            CALL IFA(4,VVX,VVY)
            CALL GDCOL1(6)
            CALL IFA(4,XV,YV)
            CALL GDCOL1(7)
            CALL IFA(4,BX,BY)
            AITXCO=5.
            CALL IGSET('TXCI',AITXCO)
            CALL IGSET('TXFP',-60.)
            CALL GDRAWT(2.,.2,'THETA',.7,0.,4,0)
            CALL GDRAWT(6.,.2,'PHI',.7,0.,4,0)
            CALL GDRAWT(10.,.2,'TRASL',.7,0.,4,0)
            CALL GDRAWT(14.,.2,'ZOOM',.7,0.,4,0)
            CALL GDRAWT(18.,.2,'OFF',.7,0.,4,0)
            CALL IGSET('TXFP',2.)
            LLEP=ABS(LEP)
            IF(LLEP.GT.1)THEN
               LCLC=1
            ELSE
               LCLC=0
            ENDIF
            CALL ISFACI(LCLC)
            CALL IGBOX(0.,20.,20.,1.)
            CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
            IOPTS = INDEX(NOPT,'S')+INDEX(NOPT,'s')
            IOPTT = INDEX(NOPT,'T')+INDEX(NOPT,'t')
            IOPTH = INDEX(NOPT,'H')+INDEX(NOPT,'h')
            IF(IOPTT.NE.0) CALL GDXYZ(0)
            IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
            MO=2
*           OOY2=10.
*           OOX2=10.
            OGSCU=GSCU
            OGSCV=GSCV
*         ipx=1
            CALL IGQWK(1,'MXDS',RVAL)
            IXXX=RVAL(1)
            IYYY=RVAL(2)
            IYYY1=(IYYY*19.)/20.
            DO 110 J=1,1000000
               IF(ISTAT.EQ.2.AND.IOPTT.NE.0) CALL GKXYZ(-.25)
               IF(ISTAT.EQ.2.AND.IOPTH.NE.0) CALL GKHITS('*','*',-.1)
               CALL IRQLC(1,MO,ISTAT,NT,X2,Y2)
*           CALL ISFAIS(1)
*****           CALL IGSET('DRMD',2.)
               IF(MO.NE.-2)THEN
                  IF(X2.GT.0..AND.X2.LT.4..AND.Y2.LT.1.)NBAR=1
                  IF(X2.GT.4..AND.X2.LT.8..AND.Y2.LT.1.)NBAR=2
                  IF(X2.GT.8..AND.X2.LT.12..AND.Y2.LT.1.)NBAR=3
                  IF(X2.GT.12..AND.X2.LT.16..AND.Y2.LT.1.)NBAR=4
                  IF(X2.GT.16..AND.X2.LT.20..AND.Y2.LT.1.)THEN
                     CALL IGSET('DRMD',1.)
                     LEP=-LEP
                     GO TO 999
                  ENDIF
               ENDIF
*           YY22=ABS(Y2-OOY2)
               IF(NBAR.EQ.1) THEN
                  GTHETA=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ELSEIF(NBAR.EQ.2) THEN
*             GBOOM=Y2/10.
                  GPHI=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ELSEIF(NBAR.EQ.3) THEN
*             XX22=ABS(X2-OOY2)
                  GU0=X2
                  GV0=Y2
***             GTHETA=18.*Y2
***             GPHI=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2.AND.XX22.LT..2)GOTO 177
*             OOY2=Y2
*             OOX2=X2
               ELSEIF(NBAR.EQ.4) THEN
                  GSCU=OGSCU*Y2*.25
                  GSCV=OGSCV*Y2*.25
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ENDIF
*****           CALL IGSET('DRMD',1.)
               CALL IGPXMP(IPX,IXXX,IYYY1,'O')
               CALL ISFACI(LCLC)
               IF(LCLC.NE.0)CALL IGBOX(0.,20.,20.,1.)
               CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
               IF(IOPTT.NE.0) CALL GDXYZ(0)
               IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
               CALL IGPXMP(IPX,0,0,'CDR')
**       CALL GDRAW(NAME,SGT1,SGT2,SGT3,SGT4,SGT5,SGT6,SGT7)
*       CALL GDXYZ(0)
*       CALL GDHITS('*','*',0,-1,.4)
  110       CONTINUE
         ENDIF
*
      ELSEIF (CHPATL.EQ.'MOVE3D')  THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL KUGETR(GSCZ)
         CALL KUGETC(NOPT,NCH)
         GSCU=GSCU*GSCZ
         GSCV=GSCV*GSCZ
         CALL HPLI
         CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
         IOPTT = INDEX(NOPT,'T')+INDEX(NOPT,'t')
         IOPTH = INDEX(NOPT,'H')+INDEX(NOPT,'h')
         IF(IOPTT.NE.0) CALL GDXYZ(0)
         IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
*
      ELSEIF (CHPATL.EQ.'PERSP') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(DISTT)
         CALL KUGETC(SAMP,NCH)
         IF(DISTT.LT.100.)DISTT=100.
         DPERS=DISTT
         IF(SAMP(1:2).EQ.'ON')THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               LEP=-ABS(LEP)
               CALL IGQWK(1,'MXDS',RVAL)
               IXXX=RVAL(1)
               IYYY=RVAL(2)
               DO 120 II=1,1000000
                  CALL IRQLC(1,2,ISTAT,NT,X2,Y2)
                  IF(ISTAT.EQ.0)GOTO 130
                  DPERS=Y2*100.+100.
                  GTHETA=X2*4.5
                  GPHI=90.-GTHETA
                  CALL IGPXMP(IPX,IXXX,IYYY,'O')
                  CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
                  CALL IGPXMP(IPX,0,0,'CDR')
  120          CONTINUE
  130          CONTINUE
            ENDIF
         ENDIF

      ELSEIF (CHPATL.EQ.'LENS') THEN
         ZZFV=0.
         IWTY=IGIWTY(1)
         IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
            CALL KUGETI(KNUM)
            IF(KNUM.EQ.1000)KNUM=MYISEL
            CALL KUGETC(KSAM,NCH)
            KLLM=KNUM
            KLSA=KSAM
            CALL GDLENS(KLLM,KLSA)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'ZOOM') THEN
         CONTINUE
         ZZFV=0.
         ZFU=2.
         CALL KUGETR(ZFU)
         ZFV=ZFU
         CALL KUGETR(ZFV)
         ZZFU=ZFU
         ZZFV=ZFV
         IF(ZZFU.EQ.0.)ZZFV=0.
         IF(ZFU.EQ.0.OR.ZFV.EQ.0)GO TO 140
         IMODE=1
         CALL KUGETI(IMODE)
         UZ0=PLTRNX*.5
         CALL KUGETR(UZ0)
         VZ0=PLTRNY*.5
         CALL KUGETR(VZ0)
         U0 =UZ0
         CALL KUGETR(U0)
         V0 =U0
         CALL KUGETR(V0)
*
         IF(IMODE.GT.1000)THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               ISEL1=IMODE-1000
               CALL GDXZOO(ISEL1,ZFU,ZFV,UZ0,VZ0,U0,V0)
               RETURN
            ENDIF
         ELSEIF(IMODE.EQ.1000)THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               ISEL1=MYISEL
               CALL GDXZOO(ISEL1,ZFU,ZFV,UZ0,VZ0,U0,V0)
               RETURN
            ENDIF
         ENDIF
*
         IF(IMODE.EQ.0)THEN
*
            CALL GDCURS(UZ0,VZ0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
*
         ELSE IF(IMODE.EQ.1)THEN
*
            CALL IGLOC2(1,NT,UZ1,VZ1,UZ2,VZ2,ISTAT,'R')
            IF (ISTAT.EQ.0) GO TO 999
            IF (UZ2-UZ1.EQ.0.) UZ2=UZ1+PLTRNX/200.
            IF (VZ2-VZ1.EQ.0.) VZ2=VZ1+PLTRNY/200.
            ZFU=PLTRNX/ABS(UZ2-UZ1)
            ZFV=PLTRNY/ABS(VZ2-VZ1)
            UZ0=(UZ1+UZ2)/2.
            VZ0=(VZ1+VZ2)/2.
*
         ELSE IF(IMODE.EQ.2)THEN
*
            CALL GDCURS(UZ0,VZ0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
            CALL GDCURS(U0,V0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
*
         ENDIF
*
  140    CALL GDZOOM(ZFU,ZFV,UZ0,VZ0,U0,V0)
*
*
      ELSEIF (CHPATL.EQ.'DXYZ') THEN
         CALL KUGETI(IT)
         CALL GDXYZ(IT)
*
      ELSEIF (CHPATL.EQ.'KXYZ') THEN
         CALL KUGETR(EPSXYZ)
         CALL GKXYZ(EPSXYZ)
*
      ELSEIF (CHPATL.EQ.'DPART') THEN
         CALL KUGETI(IT)
         ISELP = 11
         CALL KUGETI(ISELP)
         CALL KUGETR(SIZE)
         CALL GDPART(IT,ISELP,SIZE)
*
      ELSEIF (CHPATL.EQ.'DHITS') THEN
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IUTR)
         ISYMB=0
         CALL KUGETI(ISYMB)
         CALL KUGETR(SSYMB)
         CALL GDHITS(IVS,ICS,IUTR,ISYMB,SSYMB)
*
      ELSEIF (CHPATL.EQ.'KHITS') THEN
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETR(EPSHIT)
         CALL GKHITS (IVS,ICS,EPSHIT)
*
      ELSEIF (CHPATL.EQ.'DCHIT') THEN
         IUTR =0
         ISYMB=0
         SIZMAX=1.
         KDHIT =4
         HITMIN=0.
         HITMAX=0.
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IUTR)
         CALL KUGETI(ISYMB)
         CALL KUGETR(SIZMAX)
         CALL KUGETI(KDHIT)
         CALL KUGETR(HITMIN)
         CALL KUGETR(HITMAX)
         CALL GDCHIT(IVS,ICS,IUTR,ISYMB,SIZMAX,KDHIT, HITMIN,HITMAX)
*
      ELSEIF (CHPATL.EQ.'DUVIEW') THEN
         CALL KUGETC(IDS,NCH)
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IVIEW)
+SELF, IF=-USRJMP.
         CALL GUVIEW(IDS,IVS,ICS,IVIEW)
+SELF, IF=USRJMP.
         CALL JUMPT4(JUVIEW,IDS,IVS,ICS,IVIEW)
+SELF.
      ENDIF
*
  999 END
+DECK,  GXDZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:49  cernlib
* Geant

      SUBROUTINE GXDZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      DZEBRA control commands                                   *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCXLUN.
      COMMON/GCLTMP/LTEMPA(3)
      COMMON/QUEST/IQUEST(100)
      CHARACTER*20 CHOPT
      CHARACTER*4 BNAME
      CHARACTER*32 CHPATL
      CHARACTER*255 DOCFIL
      CHARACTER*10  CHTOP
      CHARACTER*12  CHTDIR
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      IF(CHPATL.EQ.'SHOW')THEN
         CALL KUGETC(BNAME,NCH)
         CALL KUGETI(NUMBER)
         CALL KUGETC(CHOPT,NCH)
         LOC=LZLOC(IXSTOR,BNAME,NUMBER)
         IF(LOC.NE.0)THEN
            CALL DZSHOW('DZSHOW',IXSTOR,LOC,CHOPT,0,0,0,0)
         ENDIF
*
      ELSEIF(CHPATL.EQ.'SURV')THEN
         CALL KUGETC(BNAME,NCH)
         CALL KUGETI(NUMBER)
         LOC=LZLOC(IXSTOR,BNAME,NUMBER)
         IF(LOC.NE.0)THEN
            CALL DZSURV('DZSURV',IXSTOR,LOC)
         ENDIF
*
      ELSEIF(CHPATL.EQ.'SNAP')THEN
         CALL KUGETI(IDIV)
         CALL KUGETC(CHOPT,NCH)
         CALL DZSNAP('DZSNAP',IDIV,CHOPT)
*
      ELSEIF(CHPATL.EQ.'VERIFY')THEN
         CALL KUGETI(IDIV)
         CALL KUGETC(CHOPT,NCH)
         CALL DZVERI('DZVERI',IDIV,CHOPT)
*
      ELSEIF(CHPATL.EQ.'STORE')THEN
         CALL KUGETI(IXSTOR)
         CALL DZSTOR('DZSTOR',IXSTOR)
*
      ELSEIF (CHPATL.EQ.'DDIV') THEN
+SELF, IF=DZDOC.
         CALL KUGETI(IDIV)
         DOCFIL=' '
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC.
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC.
         CHOPT='IN'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         CHTOP =' '
         CHTDIR=' '
         IF(DOCFIL.NE.' ') THEN
            CALL GXLUNF(10, 3, IFREE)
            IF(IFREE.NE.0) THEN
               LRECL = 256
               CALL RZOPEN(IFREE,CHTOP,DOCFIL(1:NCH),'W',LRECL,ISTAT)
               IF(ISTAT.NE.0) GOTO 999
               CALL RZFILE(IFREE,CHTOP,' ')
               LUNIT(IFREE) = 3
               CHTDIR='//'//CHTOP
            ENDIF
         ENDIF
*
*        Workstation ID is 1 for GEANT
*
         IWTYPE=IGIWTY(1)
         CALL DZDDIV(IDIV,LMAIN,CHTDIR,CHOPT,IWDISP,
     +               IWMETA,ILOCNR,IWTYPE)
         IF(DOCFIL.NE.' ') THEN
            CALL RZEND(CHTOP)
            CLOSE(IFREE)
            LUNIT(IFREE)=0
         ENDIF
+SELF, IF=-DZDOC.
*
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
10000    FORMAT(' *** GXDZ *** : Sorry, command not available',
     +          ' in this implementation')
+SELF.
      ELSEIF (CHPATL.EQ.'DISP') THEN
+SELF, IF=DZDOC.
         CALL KUGETC(BNAME,NCH)
         DOCFIL=' '
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC.
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC.
         CALL KUGETI(NUMBER)
         CHOPT='N'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         CHTOP =' '
         CHTDIR=' '
         LOC=LZLOC(IXSTOR,BNAME,NUMBER)
         IF(LOC.NE.0)THEN
            IF(DOCFIL.NE.' ') THEN
               CALL GXLUNF(10, 3, IFREE)
               IF(IFREE.NE.0) THEN
                  LRECL = 256
                  CALL RZOPEN(IFREE,CHTOP,DOCFIL(1:NCH),
     +                        'W',LRECL,ISTAT)
                  IF(ISTAT.NE.0) GOTO 999
                  CALL RZFILE(IFREE,CHTOP,' ')
                  LUNIT(IFREE) = 3
                  CHTDIR='//'//CHTOP
               ENDIF
            ENDIF
*
*        Workstation ID is 1 for GEANT
*
            IWTYPE=IGIWTY(1)
            CALL DZDISP(IXSTOR,LOC,CHTDIR,CHOPT,IWDISP,
     +                  IWMETA,ILOCNR,IWTYPE)
            IF(DOCFIL.NE.' ') THEN
               CALL RZEND(CHTOP)
               CLOSE(IFREE)
               LUNIT(IFREE)=0
            ENDIF
         ENDIF
+SELF, IF=-DZDOC.
*
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
+SELF.
      ELSEIF (CHPATL.EQ.'DIRZ') THEN
+SELF, IF=DZDOC.
         DOCFIL=' '
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC.
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC.
         CHOPT='N'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         IDZSTR=0
         CALL MZLINT(IDZSTR,'/GCLTMP/',LTEMPA,LTEMPA(3),LTEMPA)
         CALL DZDIRZ(IDZSTR,LTEMPA(3),1,DOCFIL(1:NCH),CHOPT,
     +               IWDISP,IWMETA,ILOCNR)
         LTEMPA(1)=0
+SELF, IF=-DZDOC.
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
+SELF.
      ENDIF
*
  999 END
+DECK,  GXFCA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:49  cernlib
* Geant

      SUBROUTINE GXFCA(CHFUNC,NCH,JAD,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        To analize character string CHFUNC of length NCH        *
C.    *        CHFUNC may be the name of a COMIS function              *
C.    *        or a file name                                          *
C.    *                                                                *
C.    ******************************************************************
      COMMON/QUEST/IQUEST(100)
      CHARACTER*(*) CHFUNC
      CHARACTER*32 CHFILE
      INTEGER CSADDR
      CHARACTER*(*) BSLASH
+SELF, IF=BSLASH.
      PARAMETER (BSLASH='\\')
+SELF, IF=-BSLASH.
      PARAMETER (BSLASH='\')
+SELF.
C.
C.    ------------------------------------------------------------------
C.
      JADF=0
      IQUEST(1)=0
+SELF, IF=COMIS.
      IF(NCH.LE.1.AND.CHFUNC(1:1).EQ.'0')GO TO 50
      IF(NCH.LE.0)GO TO 99
      IFILE=0
      DO 10 I=1,NCH-1
         IF(CHFUNC(I:I).EQ.'.')THEN
+SELF, IF=COMIS, IF=IBM.
            CHFUNC(I:I)=' '
+SELF, IF=COMIS.
            IF(IFILE.EQ.0)IFILE=I-1
         ENDIF
  10  CONTINUE
  20  IF(IFILE.NE.0)THEN
         CHFILE='!FILE '//CHFUNC(1:NCH)
         CALL CSEXEC(CHFILE,IRET)
         DO 30 I=IFILE,1,-1
            IF(CHFUNC(I:I).EQ.'/'.OR.
     +         CHFUNC(I:I).EQ.BSLASH.OR.
     +         CHFUNC(I:I).EQ.']'.OR.
     +         CHFUNC(I:I).EQ.'~')THEN
                  I1=I+1
                  GO TO 40
            ENDIF
  30     CONTINUE
         I1=1
  40     CHFILE=CHFUNC(I1:IFILE)
         JADF=CSADDR(CHFILE)
         CHFUNC=CHFILE
         NCH=IFILE-I1+1
      ELSE
         JADF=CSADDR(CHFUNC)
      ENDIF
+SELF.
  50  JAD=JADF
*
  99  END

+DECK,  GXFORT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXFORT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      COMIS/FORTRAN control commands                            *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCOMIS.
+CDE, GCXLUN.
+CDE, GCUNIT.
*
      INTEGER CSADDR
      CHARACTER*80 CHFILE
      CHARACTER*32 CHPATL
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      IF(CHPATL.EQ.'FORTRAN')THEN
+SELF, IF=COMIS.
         CALL KUGETC(CHFILE,NCH)
         IF(NCH.EQ.1.AND.CHFILE(1:1).EQ.'-')THEN
            JUINIT=0
            JUGEOM=0
            JUKINE=0
            JUSTEP=0
            JUOUT =0
            JULAST=0
         ELSEIF(NCH.GT.0) THEN
            CALL CLTOU(CHFILE)
            CALL GXFCA(CHFILE,NCH,JAD,1)
            JUINIT=CSADDR('UGINIT')
            JUGEOM=CSADDR('UGEOM')
            JUKINE=CSADDR('GUKINE')
            JUSTEP=CSADDR('GUSTEP')
            JUOUT =CSADDR('GUOUT')
            JULAST=CSADDR('UGLAST')
         ENDIF
*
+SELF.
      ENDIF
*
      END
+DECK,  GXFZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXFZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      FZEBRA control commands                                   *
C.    *                                                                *
C.    *       Authors:   F.Carminati **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCXLUN.
+CDE, GCFLAG.
      COMMON/QUEST/IQUEST(100)
      CHARACTER*4  CHOPT
      CHARACTER*80 CHPATH
      CHARACTER*32 CHPATL
      CHARACTER*4  KEYSU
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'FZOPEN') THEN
         CALL KUGETI(LUN)
         CALL GXLUNF(LUN,1,IFREE)
         IF(IFREE.NE.0) GOTO 99
         CALL KUGETC(CHPATH,NCHPAT)
         CALL KUGETC(CHOPT,NCH)
         CALL KUGETI(LRECL)
         CALL CUTOL(CHPATH)
         IF(INDEX(CHOPT,'A').NE.0) THEN
            OPEN(UNIT=LUN,FILE=CHPATH(1:NCHPAT),FORM='FORMATTED',
     +      STATUS='UNKNOWN')
         ELSE
            OPEN(UNIT=LUN,FILE=CHPATH(1:NCHPAT),FORM='UNFORMATTED',
     +      STATUS='UNKNOWN')
         ENDIF
         CALL GOPEN(LUN, CHOPT, LRECL, IER)
         IF(INDEX(CHOPT,'I').NE.0) THEN
            LUNIT(LUN)=1
         ELSE
            LUNIT(LUN)=2
         ENDIF
         IF(NPAR.GT.4) THEN
            CALL KUGETC(CHOPT,NCH)
            IF(INDEX(CHOPT,'I').NE.0)THEN
               LUNIT(LUN)=0
               IDENT = 0
               CALL GFIN(LUN, 'INIT', 1, IDENT, ' ',IER)
               IF(IER.LT.0) THEN
                  WRITE(CHMAIL,12300) IER
12300 FORMAT(' *** GXFZ : Error in GFIN, IER = ',I4)
                  CALL GMAIL(0,0)
               ENDIF
               CALL GCLOSE(LUN,IER)
               LUNIT(LUN)=0
            ELSEIF(INDEX(CHOPT,'O').NE.0)THEN
               LUNIT(LUN)=0
               IDENT=1
               CALL GFOUT(LUN, 'INIT', 1, IDENT, ' ',IER)
               IF(IER.LT.0) THEN
                  WRITE(CHMAIL,12301) IER
12301 FORMAT(' *** GXFZ : Error in GFOUT, IER = ',I4)
                  CALL GMAIL(0,0)
               ENDIF
               CALL GCLOSE(LUN,IER)
               LUNIT(LUN)=0
            ENDIF
         ENDIF
*
      ELSEIF (CHPATL.EQ.'FZIN') THEN
         CALL KUGETI(LUN)
         CALL KUGETC(KEYSU,NCH)
         CALL KUGETI(IDENT)
         CALL GFIN(LUN, KEYSU, 1, IDENT, ' ',IER)
         IF(IER.LT.0) THEN
            WRITE(CHMAIL,12300) IER
            CALL GMAIL(0,0)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'FZOUT') THEN
         CALL KUGETI(LUN)
         CALL KUGETC(KEYSU,NCH)
         CALL KUGETI(IDENT)
         CALL GFOUT(LUN, KEYSU, 1, IDENT, ' ',IER)
         IF(IER.LT.0) THEN
            WRITE(CHMAIL,12301) IER
            CALL GMAIL(0,0)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'FZCLOSE') THEN
         CALL KUGETI(LUN)
         CALL GCLOSE(LUN, IER)
         LUNIT(LUN)=0
*
      ENDIF
*
   99 END
+DECK,  GXGCON, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXGCON
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Graphics control commands                                 *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCXLUN.
*KEEP,HIMETA
      COMMON /HIMETA/ IDMETA,XMFACT,YMFACT,TEKACT,METACT,FILOPN
      LOGICAL TEKACT,METACT,FILOPN
      COMMON /HIMETC/ CHMETA
      CHARACTER*24 CHMETA

      COMMON/CWK/IWK
      COMMON/DEFPAR/IATDEF,IVADEF
      CHARACTER*4 CHNAME,CHOPT,CHPAR,IATDEF
      CHARACTER*32 CHPATL
      LOGICAL IGM100
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
C             METAFILE
C
      IF(CHPATL.EQ.'METAFILE')THEN
         CALL KUGETI(I)
         LUN=IABS(I)
         CALL KUGETI(METAFL)
         CALL KUGETS(CHMETA,NCH)
         IF(IGM100(METAFL))THEN
            IF(LUN.LT.100)THEN
               IF(I.LT.0)THEN
                  I=I-100
               ELSEIF(I.GT.0)THEN
                  I=I+100
               ENDIF
            ELSEIF(LUN.GT.100)THEN
               LUN=LUN-100
            ENDIF
         ENDIF
         IF(LUN.NE.0)THEN
            CALL GXLUNF(LUN,2,IFREE)
            IF(IFREE.EQ.0)GO TO 99
         ENDIF
         LUNIT(LUN)=8
         IF(IWK.LE.0)THEN
            IF(I.GT.0)THEN
               IWK=-2
            ELSEIF(I.LT.0)THEN
               IWK=-1
            ELSE
               IWK=0
            ENDIF
         ENDIF
         CALL IGMETA(I,METAFL)
*
      ELSEIF (CHPATL.EQ.'DOPEN') THEN
         CALL KUGETI(IVIEW)
         CALL GDOPEN(IVIEW)
*
      ELSEIF (CHPATL.EQ.'DSHOW') THEN
         CALL KUGETI(IVIEW)
         IF(IVIEW.EQ.1000)THEN
           IVIEW=MYISEL
         ELSE
           MYISEL=IVIEW
         ENDIF
         CALL GDSHOW(IVIEW)
*
      ELSEIF (CHPATL.EQ.'DELETE') THEN
         CALL KUGETI(IVIEW)
         CALL GDELET(IVIEW)
*
      ELSEIF (CHPATL.EQ.'DCLOSE') THEN
         CALL GDCLOS
*
      ELSEIF (CHPATL.EQ.'CHANGEWK') THEN
         CALL GCHNWK
*
      ELSEIF (CHPATL.EQ.'RESETWK') THEN
         CALL GRESWK
*
      ELSEIF (CHPATL.EQ.'SSETAT') THEN
         CALL KUGETC(CHOPT,NCH)
         IATDEF=CHOPT
*
      ELSEIF (CHPATL.EQ.'SSETVA') THEN
         CALL KUGETR(RVAL)
         IVADEF=RVAL
*
      ELSEIF (CHPATL.EQ.'SATT') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETC(CHOPT,NCH)
         CALL KUGETI(IVAL)
         CALL GSATT(CHNAME,CHOPT,IVAL)
*
      ELSEIF (CHPATL.EQ.'SCALE') THEN
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
*
      ELSEIF (CHPATL.EQ.'COLOR') THEN
         CALL KUGETI(ICOL)
         ICOL=-IABS(ICOL)
         CALL GDCOL(ICOL)
*
      ELSEIF (CHPATL.EQ.'LWID') THEN
         CALL KUGETI(LW)
         LW=-IABS(LW)
         CALL GDLW(LW)
*
      ELSEIF (CHPATL.EQ.'NEXT') THEN
         CALL HPLI
         CALL ISELNT(1)
         CALL IGRNG(20.,20.)
*
      ELSEIF (CHPATL.EQ.'DOPT') THEN
         CALL KUGETC(CHOPT,NCH)
         CALL KUGETC(CHPAR,NCH)
         CALL GDOPT(CHOPT,CHPAR)
*
      ELSEIF (CHPATL.EQ.'SIZE') THEN
         CALL KUGETR(PLT1)
         PLT2=PLT1
         CALL KUGETR(PLT2)
         PLTRNX=PLT1
         PLTRNY=PLT2
         CALL IGRNG(PLT1,PLT2)
         CALL HPLSET('XSIZ',PLT1)
         CALL HPLSET('YSIZ',PLT2)
*
      ELSEIF (CHPATL.EQ.'SPERS') THEN
         CALL KUGETR(DPERS)
         DPERS=ABS(DPERS)
*
      ELSEIF (CHPATL.EQ.'MAP_COLOR') THEN
         IADD=0
         IF (NPAR.GT.0) THEN
   10       CALL KUGETI(IADD)
            IF (IADD.LT.0.OR.IADD.GT.16) GO TO 10
         ENDIF
         IF (NPAR.GT.1) THEN
   20       CALL KUGETI(IVAL)
            IF (IVAL.LT.1.OR.IVAL.GT.16) GO TO 20
         ENDIF
         IF (IADD.EQ.0) THEN
            IAD1=1
            IAD2=16
         ELSE
            IAD1=IADD
            IAD2=IADD
         ENDIF
         DO 30 I=IAD1,IAD2
            IF (NPAR.GT.1) LOOKTB(I)=IVAL
            WRITE (CHMAIL,'('' COLOR('',I2,'') = '',I2)') I,LOOKTB(I)
            CALL GMAIL(0,0)
   30    CONTINUE
      ENDIF
*
  99  END
+DECK,  GXGEOM, T=FORT.
* Revision 1.2  1996/04/30 11:25:57  ravndal
* Implicit Fortran data type convention overlooked
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXGEOM
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Geometry commands                                         *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                  N.Hoimyr 1992    **********                   *
C.    *                  S.Giani  1992    **********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, PAWC.
+CDE, GCUNIT.
+CDE, GCNUM.
+CDE, GCLIST.
+CDE, GCONSP.
      CHARACTER*4 CHNAME,CHISH,CHPAR,IONLY,CYESNO,CHAX
      CHARACTER*32 CHPATL,VNAME
      CHARACTER*24 FNAME
      CHARACTER*4 ANAME
      CHARACTER*24 INST,SITE,DEPT,RESP
      DIMENSION ARRAY(50),UBUF(1)
      DATA UBUF/1./
C.
C.    ------------------------------------------------------------------
C.
      IWKSTY = IGIWTY(1)
      CALL KUPATL(CHPATL,NPAR)
*
      IF(CHPATL.EQ.'OPTI') THEN
         CALL KUGETI(IOPT)
         CALL GOPTIM(IOPT)
      ELSEIF (CHPATL.EQ.'SVOLU') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETC(CHISH,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETI(NP)
         CALL KUGETV(VNAME,LPAR,LLL)
         CALL GSVOLU(CHNAME,CHISH,NUMED,QQ(LPAR),NP,IVOLU)
*
      ELSEIF (CHPATL.EQ.'SPOS') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(N)
         CALL KUGETC(CHPAR,NCH)
         CALL KUGETR(X0)
         CALL KUGETR(Y0)
         CALL KUGETR(Z0)
         CALL KUGETI(IROT)
         CALL KUGETC(IONLY,NCH)
         CALL GSPOS(CHNAME,N,CHPAR,X0,Y0,Z0,IROT,IONLY)
*
      ELSEIF (CHPATL.EQ.'SDVN') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETC(CHPAR,NCH)
         CALL KUGETI(NDIV)
         CALL KUGETC(CHAX,NCH)
         IF (CHAX.EQ.'X'.OR.CHAX.EQ.'1') THEN
            IAX=1
         ELSEIF (CHAX.EQ.'Y'.OR.CHAX.EQ.'2') THEN
            IAX=2
         ELSEIF (CHAX.EQ.'Z'.OR.CHAX.EQ.'3') THEN
            IAX=3
         ENDIF
         IF(IAX.LE.3.AND.IAX.GE.1) THEN
            CALL GSDVN(CHNAME,CHPAR,NDIV,IAX)
         ELSE
            WRITE(CHMAIL,10000)
10000       FORMAT(' *** GXGEOM *** Wrong value of IAX')
            CALL GMAIL(0,0)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'PVOLU') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPVOLX(NUMB)
         ELSE
            CALL GPVOLU(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'SROTM') THEN
         CALL KUGETI(N)
         CALL KUGETR(THETA1)
         CALL KUGETR(PHI1)
         CALL KUGETR(THETA2)
         CALL KUGETR(PHI2)
         CALL KUGETR(THETA3)
         CALL KUGETR(PHI3)
         CALL GSROTM(N,THETA1,PHI1,THETA2,PHI2,THETA3,PHI3)
*
      ELSEIF (CHPATL.EQ.'PROTM') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPROTX(NUMB)
         ELSE
            CALL GPROTM(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'STMED') THEN
         NMED=1
         NMAT=1
         IFIELD=0
         EPSIL=0.01
         ISVOL=0
         FIELDM=0.
         TMAXFD=0.01
         STEMAX=BIG
         DEEMAX=0.01
         STMIN=0.1
         CALL KUGETI(NMED)
         CALL KUGETC(VNAME,NCH)
         CALL KUGETI(NMAT)
         CALL KUGETI(ISVOL)
         CALL KUGETI(IFIELD)
         CALL KUGETR(FIELDM)
         CALL KUGETR(TMAXFD)
         CALL KUGETR(STEMAX)
         CALL KUGETR(DEEMAX)
         CALL KUGETR(EPSIL)
         CALL KUGETR(STMIN)
         CALL GSTMED(NMED,VNAME,NMAT,ISVOL,IFIELD,FIELDM,TMAXFD,
     +   STEMAX,DEEMAX,EPSIL,STMIN,UBUF,0)
*
      ELSEIF (CHPATL.EQ.'PTMED') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPTMEX(NUMB)
         ELSE
            CALL GPTMED(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'EDITV') THEN
         CALL KUGETI(NUM)
         IF(NUM.LE.0)THEN
            CALL GGCLOS
         ELSE
            CALL GEDITV(NUM)
         ENDIF
*
      ELSEIF(CHPATL.EQ.'SBOX') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(HALFX)
         CALL KUGETR(HALFY)
         CALL KUGETR(HALFZ)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=HALFX
         ARRAY(2)=HALFY
         ARRAY(3)=HALFZ
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=3
         ENDIF
         CALL GSVOLU(CHNAME,'BOX ',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'STRD1') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(HLFDWX)
         CALL KUGETR(HLFUPX)
         CALL KUGETR(HALFY)
         CALL KUGETR(HALFZ)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=HLFDWX
         ARRAY(2)=HLFUPX
         ARRAY(3)=HALFY
         ARRAY(4)=HALFZ
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=4
         ENDIF
         CALL GSVOLU(CHNAME,'TRD1',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'STRD2') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(HLFDWX)
         CALL KUGETR(HLFUPX)
         CALL KUGETR(HLFDWY)
         CALL KUGETR(HLFUPY)
         CALL KUGETR(HALFZ)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=HLFDWX
         ARRAY(2)=HLFUPX
         ARRAY(3)=HLFDWY
         ARRAY(4)=HLFUPY
         ARRAY(5)=HALFZ
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=5
         ENDIF
         CALL GSVOLU(CHNAME,'TRD2',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'STUBE') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(XINRAD)
         CALL KUGETR(OUTRAD)
         CALL KUGETR(HALFZ)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=XINRAD
         ARRAY(2)=OUTRAD
         ARRAY(3)=HALFZ
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=3
         ENDIF
         CALL GSVOLU(CHNAME,'TUBE',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'STUBS') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(XINRAD)
         CALL KUGETR(OUTRAD)
         CALL KUGETR(HALFZ)
         CALL KUGETR(SPHI)
         CALL KUGETR(EPHI)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=XINRAD
         ARRAY(2)=OUTRAD
         ARRAY(3)=HALFZ
         ARRAY(4)=SPHI
         ARRAY(5)=EPHI
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=5
         ENDIF
         CALL GSVOLU(CHNAME,'TUBS',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'SCONE') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(XINRDW)
         CALL KUGETR(OUTRDW)
         CALL KUGETR(XINRUP)
         CALL KUGETR(OUTRUP)
         CALL KUGETR(HALFZ)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=XINRDW
         ARRAY(2)=OUTRDW
         ARRAY(3)=XINRUP
         ARRAY(4)=OUTRUP
         ARRAY(5)=HALFZ
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=5
         ENDIF
         CALL GSVOLU(CHNAME,'CONE',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'SCONS') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(XINRDW)
         CALL KUGETR(OUTRDW)
         CALL KUGETR(XINRUP)
         CALL KUGETR(OUTRUP)
         CALL KUGETR(HALFZ)
         CALL KUGETR(SPHI)
         CALL KUGETR(EPHI)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=XINRDW
         ARRAY(2)=OUTRDW
         ARRAY(3)=XINRUP
         ARRAY(4)=OUTRUP
         ARRAY(5)=HALFZ
         ARRAY(6)=SPHI
         ARRAY(7)=EPHI
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=7
         ENDIF
         CALL GSVOLU(CHNAME,'CONS',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'SSPHE') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(XINRAD)
         CALL KUGETR(OUTRAD)
         CALL KUGETR(SPHI)
         CALL KUGETR(EPHI)
         CALL KUGETR(STHETA)
         CALL KUGETR(ETHETA)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=XINRAD
         ARRAY(2)=OUTRAD
         ARRAY(3)=SPHI
         ARRAY(4)=EPHI
         ARRAY(5)=STHETA
         ARRAY(6)=ETHETA
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=6
         ENDIF
         CALL GSVOLU(CHNAME,'SPHE',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF(CHPATL.EQ.'SPARA') THEN
         CALL KUGETC(CHNAME,NCH)
         CALL KUGETI(NUMED)
         CALL KUGETR(HALFX)
         CALL KUGETR(HALFY)
         CALL KUGETR(HALFZ)
         CALL KUGETR(AXIS)
         CALL KUGETR(PHI)
         CALL KUGETR(THETA)
         CALL KUGETC(CYESNO,NCHAR)
         ARRAY(1)=HALFX
         ARRAY(2)=HALFY
         ARRAY(3)=HALFZ
         ARRAY(4)=AXIS
         ARRAY(5)=PHI
         ARRAY(6)=THETA
         IF(CYESNO.EQ.'YES')THEN
            NUMP=0
         ELSE
            NUMP=6
         ENDIF
         CALL GSVOLU(CHNAME,'PARA',NUMED,ARRAY,NUMP,IVOLU)
*
      ELSEIF (CHPATL.EQ.'CADINT') THEN
         CALL KUGETS(FNAME,NCH)
         CALL KUGETC(ANAME,NCH)
         CALL KUGETI(NBINS)
         CALL KUGETI(LUNIT)
         CALL KUGETI(LUNIT2)
         CALL KUGETS(INST,NCH)
         CALL KUGETS(SITE,NCH)
         CALL KUGETS(DEPT,NCH)
         CALL KUGETS(RESP,NCH)
         CALL GTXSET(FNAME,ANAME,NBINS,LUNIT,LUNIT2,
     +INST,SITE,DEPT,RESP)
*
      ELSEIF (CHPATL.EQ.'WEUCLID') THEN
         CALL KUGETI(LUN)
         CALL KUGETS(FNAME,NCH)
         CALL KUGETC(CHNAME,NCH1)
         CALL KUGETI(NUMBER)
         CALL KUGETI(NLEVEL)
         CALL GWEUCL (LUN,FNAME(1:NCH),CHNAME,NUMBER,NLEVEL)
*
      ELSEIF (CHPATL.EQ.'REUCLID') THEN
         CALL KUGETI(LUN)
         CALL KUGETS(FNAME,NCH)
         CALL GREUCL (LUN,FNAME(1:NCH))
*
      ENDIF
*
      END
+DECK,  GXINT, T=FORT.
* Revision 1.2  1997/01/07 10:25:42  cernlib
* Remove #ifdef CERNLIB_MAIN; this shall be done via Imakefile.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      PROGRAM GXINT
*
*     GEANT main program. To link with the MOTIF user interface
*     the routine GPAWPP(NWGEAN,NWPAW) should be called, whereas
*     the routine GPAW(NWGEAN,NWPAW) gives access to the basic
*     graphics version.
*
+SELF, IF=-IBM.
      PARAMETER (NWGEAN=3000000,NWPAW=1000000)
+SELF, IF=IBM.
      PARAMETER (NWGEAN=1000000,NWPAW=500000)
+SELF.
      COMMON/GCBANK/GEANT(NWGEAN)
      COMMON/PAWC/PAW(NWPAW)
+SELF, IF=HPUX.
      ON REAL UNDERFLOW IGNORE
+SELF.
*
+SELF, IF=IBM.
      CALL INITC
      CALL ERRSET(151,999,-1)
+SELF, IF=MOTIF, IF=-IBM.
      CALL GPAWPP(NWGEAN,NWPAW)
+SELF, IF=-MOTIF,IBM.
      CALL GPAW(NWGEAN,NWPAW)
+SELF.
*
      END
      SUBROUTINE QNEXT
      END
+SELF, IF=-CZ.
      SUBROUTINE CZOPEN
      END
      SUBROUTINE CZTCP
      END
      SUBROUTINE CZCLOS
      END
      SUBROUTINE CZPUTA
      END
+SELF, IF=IBM.
      FUNCTION IOSCLR()
      IOSCLR=0
      END
+SELF.
+DECK,  GXLIST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXLIST
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Geometry commands                                         *
C.    *                                                                *
C.    *       Authors:   F.Carminati **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCLIST.
+CDE, GCRZ.
      PARAMETER (NUMLIS=11)
      DIMENSION LLIST1(20,9), NLIST1(9)
      DIMENSION LLIST2(20,2), NLIST2(2)
      EQUIVALENCE (NLIST1,NHSTA),(LLIST1,LHSTA)
      EQUIVALENCE (NLIST2,NRGET),(LLIST2,LRGET)
      CHARACTER*4  CHPAR, CHPATL, CHLNAM(NUMLIS)
      DATA CHLNAM / 'HSTA','GET ','SAVE','SETS','PRIN','GEOM',
     +              'VIEW','PLOT','STAT','RGET','RSAV'/
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      ILIST = 0
      DO 10 KLIST=1,NUMLIS
         IF(CHPATL.EQ.CHLNAM(KLIST)) THEN
            ILIST = KLIST
         ENDIF
   10 CONTINUE
      IF(ILIST.GT.9) THEN
         ILIST=ILIST-9
         IF(NPAR.GT.0) THEN
            CALL KUGETC(CHPAR,NCH)
            IF(CHPAR.EQ.'.') THEN
               CALL VBLANK(LLIST2(1,ILIST),20)
               NLIST2(ILIST) = 0
            ELSE
               NLIST2(ILIST) = NPAR
               CALL UCTOH(CHPAR,LLIST2(1,ILIST),4,4)
               DO 20 IPAR=2,NPAR
                  CALL KUGETC(CHPAR,NCH)
                  CALL UCTOH(CHPAR,LLIST2(IPAR,ILIST),4,4)
   20          CONTINUE
            ENDIF
         ELSE
            NDONE = MIN(NLIST2(ILIST),10)
            WRITE(CHMAIL,10000) CHPATL, NDONE, (LLIST2(IPAR,ILIST),
     +      IPAR= 1,NDONE)
            CALL GMAIL(1,0)
            IF(NLIST2(ILIST).GT.10) THEN
               WRITE(CHMAIL,10100) CHPATL, NLIST2(ILIST), (LLIST2(IPAR,
     +         ILIST), IPAR=11,NLIST2(ILIST))
               CALL GMAIL(0,0)
            ENDIF
         ENDIF
      ELSEIF(ILIST.GT.0) THEN
         IF(NPAR.GT.0) THEN
            CALL KUGETC(CHPAR,NCH)
            IF(CHPAR.EQ.'.') THEN
               CALL VBLANK(LLIST1(1,ILIST),20)
               NLIST1(ILIST) = 0
            ELSE
               NLIST1(ILIST) = NPAR
               CALL UCTOH(CHPAR,LLIST1(1,ILIST),4,4)
               DO 30 IPAR=2,NPAR
                  CALL KUGETC(CHPAR,NCH)
                  CALL UCTOH(CHPAR,LLIST1(IPAR,ILIST),4,4)
   30          CONTINUE
            ENDIF
         ELSE
            NDONE = MIN(NLIST1(ILIST),10)
            WRITE(CHMAIL,10000) CHPATL, NDONE, (LLIST1(IPAR,ILIST),
     +      IPAR= 1,NDONE)
            CALL GMAIL(1,0)
            IF(NLIST1(ILIST).GT.10) THEN
               WRITE(CHMAIL,10100) CHPATL, NLIST1(ILIST), (LLIST1(IPAR,
     +         ILIST), IPAR=11,NLIST1(ILIST))
               CALL GMAIL(0,0)
            ENDIF
         ENDIF
      ENDIF
*
10000 FORMAT(1X,A4,' list  1-',I2,10(2X,A4))
10100 FORMAT(1X,A4,' list 11-',I2,10(2X,A4))
      END
+DECK,  GXLUNF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXLUNF(LUN,ICASE,IFREE)
*
*             If ICASE=1 check if LUN is free
*             If ICASE=2 check if LUN is used
*             If ICASE=3 return first free unit starting at LUN
*
+CDE, GCXLUN.
+CDE, GCUNIT.
      CHARACTER*8 CHCASE(10)
      SAVE CHCASE
      DATA CHCASE/'FZ      ','FZOUT   ','HBOOK   ','HIGZ    '
     +           ,'RZ      ','KUIP    ','COMIS   ','GKS     '
     +           ,'FORTRAN ','USER    '/
*________________________________________________________
*
      IF(LUN.LE.0.OR.LUN.GT.128)THEN
         PRINT *,' Invalid Logical unit number'
         IFREE=6
         IF(ICASE.NE.1)IFREE=0
         GO TO 99
      ENDIF
      IFREE=IABS(LUNIT(LUN))
      IF(ICASE.EQ.1)THEN
         IF(IFREE.EQ.0)GO TO 99
         IFR=MIN(IFREE,10)
         WRITE(CHMAIL,1000) LUN,CHCASE(IFR)
         CALL GMAIL(0,0)
      ELSEIF(ICASE.EQ.2)THEN
         IF(IFREE.NE.0)GO TO 99
         WRITE(CHMAIL,2000) LUN
         CALL GMAIL(0,0)
      ELSE
         IFREE=0
         DO 10 I=LUN,99
            IF(LUNIT(I).EQ.0)THEN
               IFREE=I
               GO TO 99
            ENDIF
  10     CONTINUE
         WRITE(CHMAIL,3000) LUN
         CALL GMAIL(0,0)
      ENDIF
*
  99  RETURN
 1000 FORMAT(' Unit ',I3,' already used by ',A)
 2000 FORMAT(' Unit ',I3,' is not active')
 3000 FORMAT(' No more free logical units above ',I3)
      END
+DECK,  GXOBJ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXOBJ(BRCLAS,BRNAME,BRPATH,OBNAME,OBCLAS,STEXT,LTEXT)
*
***********************************************************************
*                                                                     *
*      This routine scans the Geant data structures to return each    *
*       time the next object found. It is used in the new user in-    *
*       terface based on KUIP-MOTIF.                                  *
*                                                                     *
*      Author :    S. Giani     ********************                  *
*                                                                     *
***********************************************************************
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
+CDE, GCFLAG.
+CDE, GCDRAW.
*
      CHARACTER*(*) BRCLAS,BRNAME,BRPATH,OBNAME,OBCLAS,STEXT,LTEXT
      CHARACTER*4 NAMV,NAMS,IUSET,IUDET
      CHARACTER*20 NATMED,NAPART,NAMM
      DIMENSION UBUF(1),VBUF(10),WBUF(10)
      SAVE IDPOIN,ISET
*
      IF(OBNAME.EQ.' ')IDPOIN=0
*
      IF(BRCLAS.EQ.'VOLU')THEN
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NVOLUM+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            CALL GFVOLU(IDPOIN,NAMV,NAMS)
            OBNAME=NAMV
            OBCLAS=NAMS
            WRITE(STEXT,'(I12)') IDPOIN
            LTEXT=OBCLAS
         ENDIF
      ELSEIF(BRCLAS.EQ.'MATE')THEN
   10    CONTINUE
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NMATE+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            CALL GFMATE(IDPOIN,NAMM,A,Z,DENS,RADL,ABSL,UBUF,NWBUF)
            JMA = LQ(JMATE-IDPOIN)
            IFF = Q(JMA+11)
            IF(A.GE.0.)THEN
               OBNAME=NAMM
               IF(IFF.LE.1)THEN
                  OBCLAS='Elem'
               ELSE
                  OBCLAS='Mixt'
               ENDIF
               WRITE(STEXT,'(I12)') IDPOIN
               LTEXT=OBCLAS
            ELSE
               GOTO 10
            ENDIF
         ENDIF
      ELSEIF(BRCLAS.EQ.'TMED')THEN
   20    CONTINUE
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NTMED+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            CALL GFTMED(IDPOIN,NATMED,NMAT,ISVOL,IFIELD,FIELDM, TMAXFD,
     +      STEMAX,DEEMAX,EPSIL,STMIN,UBUF,NWBUF)
            IF(NMAT.NE.0)THEN
               OBNAME=NATMED
               OBCLAS='Med'
               WRITE(STEXT,'(I12)') IDPOIN
               LTEXT=OBCLAS
            ELSE
               GOTO 20
            ENDIF
         ENDIF
      ELSEIF(BRCLAS.EQ.'PART')THEN
   30    CONTINUE
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NPART+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            CALL GFPART(IDPOIN,NAPART,ITRTYP,AMASS,CHARGE,TLIFE,
     +      VBUF,NWBUF)
            IF(ITRTYP.NE.0)THEN
               OBNAME=NAPART
               OBCLAS='Part'
               WRITE(STEXT,'(I12)') IDPOIN
               LTEXT=OBCLAS
            ELSE
               GOTO 30
            ENDIF
         ENDIF
      ELSEIF(BRCLAS.EQ.'KINE')THEN
   40    CONTINUE
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NTRACK+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            CALL GFKINE(IDPOIN,VERT,PVERT,IPART,NVERT,WBUF,NWBUF)
            IF(IPART.NE.0)THEN
               WRITE(OBNAME,'(I12)') IDPOIN
               OBCLAS='Kine'
               WRITE(STEXT,'(I12)') IDPOIN
               LTEXT=OBCLAS
            ELSE
               GOTO 40
            ENDIF
         ENDIF
      ELSEIF(BRCLAS.EQ.'HITS')THEN
        IF(BRPATH.EQ.' ')THEN
         IF(JSET.NE.0)THEN
           NSET=IQ(JSET-1)
         ELSE
           NSET=0
         ENDIF
   45    CONTINUE
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NSET+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            CALL UHTOC(IQ(JSET+IDPOIN),4,IUSET,4)
            CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
            IF(ISET.NE.0)THEN
               OBNAME=IUSET
               OBCLAS='Hitset'
               WRITE(STEXT,'(I12)') IDPOIN
               LTEXT=OBCLAS
            ELSE
               GOTO 45
            ENDIF
         ENDIF
        ELSE
         IF(JSET.NE.0)THEN
           NSET=IQ(JSET-1)
           IUSET=BRPATH(2:5)
           CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
           NDET=IQ(LQ(JSET-ISET)-1)
         ELSE
           NDET=0
         ENDIF
   46    CONTINUE
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NDET+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            CALL UHTOC(IQ(LQ(JSET-ISET)+IDPOIN),4,IUDET,4)
            CALL GLOOK(IUDET,IQ(LQ(JSET-ISET)+1),NDET,IDET)
            IF(IDET.NE.0)THEN
               OBNAME=IUDET
               OBCLAS='Hitdet'
               WRITE(STEXT,'(I12)') IDPOIN
               LTEXT=OBCLAS
            ELSE
               GOTO 46
            ENDIF
         ENDIF
        ENDIF
      ELSEIF(BRCLAS.EQ.'ROTM')THEN
   50    CONTINUE
         IDPOIN=IDPOIN+1
         IF((IDPOIN.EQ.(IQ(JROTM-2)+1)).OR.JROTM.LE.0)THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            JR=LQ(JROTM-IDPOIN)
            IF(JR.GT.0)THEN
               WRITE(OBNAME,'(I12)') IDPOIN
               OBCLAS='Rmatr'
               WRITE(STEXT,'(I12)') IDPOIN
               LTEXT=OBCLAS
            ELSE
               GOTO 50
            ENDIF
         ENDIF
      ELSEIF(BRCLAS.EQ.'VIEW')THEN
         IDPOIN=IDPOIN+1
         IF(IDPOIN.EQ.(NKVIEW+1))THEN
            IDPOIN=0
            OBNAME=' '
         ELSE
            WRITE(OBNAME,'(I12)') IDPOIN
            OBCLAS='VB'
            WRITE(STEXT,'(I12)') IDPOIN
            LTEXT=OBCLAS
         ENDIF
      ELSE
         PRINT*,'BRCLAS NOT VALID'
      ENDIF
*
      END
+DECK,  GXPHYS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXPHYS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Physics parameters control commands                       *
C.    *                                                                *
C.    *       Author:    R.Brun      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCCUTS.
+CDE, GCONSP.
+CDE, GCUNIT.
+CDE, GCTRAK.
+CDE, GCMULO.
      DIMENSION UCUTS(10),ULCUTS(10)
      EQUIVALENCE(UCUTS(1),CUTGAM)
      DIMENSION MECA(5,13)
      EQUIVALENCE (MECA(1,1),IPAIR)
      CHARACTER*6 CUTNAM(10)
      CHARACTER*4 CEN(10)
      CHARACTER*32 CHPATL
      CHARACTER*(*) CHNUMB
      PARAMETER (CHNUMB='1234567890')
      DATA CUTNAM/'CUTGAM','CUTELE','CUTNEU','CUTHAD','CUTMUO',
     +            'BCUTE' ,'BCUTM' ,'DCUTE' ,'DCUTM' ,'PPCUTM'/
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      IF(CHPATL.EQ.'ANNI')THEN
         CALL KUGETI(IANNI)
*
      ELSEIF(CHPATL.EQ.'AUTO')THEN
         CALL KUGETI(IGAUTO)
*
      ELSEIF(CHPATL.EQ.'BREM')THEN
         CALL KUGETI(IBREM)
*
      ELSEIF(CHPATL.EQ.'CKOV')THEN
         CALL KUGETI(ICKOV)
*
      ELSEIF(CHPATL.EQ.'COMP')THEN
         CALL KUGETI(ICOMP)
*
      ELSEIF(CHPATL.EQ.'DCAY')THEN
         CALL KUGETI(IDCAY)
*
      ELSEIF(CHPATL.EQ.'DRAY')THEN
         CALL KUGETI(IDRAY)
*
      ELSEIF(CHPATL.EQ.'ERAN')THEN
         CALL KUGETR(EKMIN)
         CALL KUGETR(EKMAX)
         CALL KUGETI(NEKBIN)
         NEKBIN=MIN(NEKBIN,199)
*
      ELSEIF(CHPATL.EQ.'HADR')THEN
         CALL KUGETI(IHADR)
*
      ELSEIF(CHPATL.EQ.'LABS')THEN
         CALL KUGETI(ILABS)
*
      ELSEIF(CHPATL.EQ.'LOSS')THEN
         CALL KUGETI(ILOSS)
         IF(ILOSS.EQ.2.OR.ILOSS.EQ.0)THEN
            IDRAY=0
         ELSE
            IDRAY=1
         ENDIF
*
      ELSEIF(CHPATL.EQ.'MULS')THEN
         CALL KUGETI(IMULS)
*
      ELSEIF(CHPATL.EQ.'MUNU')THEN
         CALL KUGETI(IMUNU)
*
      ELSEIF(CHPATL.EQ.'PAIR')THEN
         CALL KUGETI(IPAIR)
*
      ELSEIF(CHPATL.EQ.'PFIS')THEN
         CALL KUGETI(IPFIS)
*
      ELSEIF(CHPATL.EQ.'PHOT')THEN
         CALL KUGETI(IPHOT)
*
      ELSEIF(CHPATL.EQ.'RAYL')THEN
         CALL KUGETI(IRAYL)
*
      ELSEIF(CHPATL.EQ.'STRA')THEN
         CALL KUGETI(ISTRA)
*
      ELSEIF(CHPATL.EQ.'SYNC')THEN
         CALL KUGETI(ISYNC)
*
      ELSEIF(CHPATL.EQ.'CUTS')THEN
         IF(NPAR.LE.0)THEN
            WRITE(LOUT,10000)
10000       FORMAT(/,' Current PHYSICS parameters:',/)
            DO 10 I=1,10
               CALL GEVKEV(UCUTS(I),ULCUTS(I),CEN(I))
               WRITE(LOUT,10100)CUTNAM(I),ULCUTS(I),CEN(I)
10100          FORMAT(5X,A,' = ',F7.2,1X,A)
   10       CONTINUE
            GO TO 999
         ENDIF
         CALL KUGETR(CUTGAM)
         CALL KUGETR(CUTELE)
         CALL KUGETR(CUTHAD)
         CALL KUGETR(CUTNEU)
         CALL KUGETR(CUTMUO)
         CALL KUGETR(BCUTE)
         CALL KUGETR(BCUTM)
         CALL KUGETR(DCUTE)
         CALL KUGETR(DCUTM)
         CALL KUGETR(PPCUTM)
         CALL KUGETR(TOFMAX)
         CALL KUGETR(GCUTS(1))
         IF(BCUTE.LE.0.)BCUTE=CUTGAM
         IF(BCUTM.LE.0.)BCUTM=CUTGAM
         IF(DCUTE.LE.0.)DCUTE=CUTELE
         IF(DCUTM.LE.0.)DCUTM=CUTELE
         IF(PPCUTM.LT.4.*EMASS)PPCUTM=4.*EMASS
*
      ELSEIF(CHPATL.EQ.'DRPRT')THEN
         CALL KUGETI(IPART)
         CALL KUGETI(IMATE)
         CALL KUGETR(STEP)
         CALL KUGETI(NPOINT)
         CALL GDRPRT(IPART,IMATE,STEP,NPOINT)
*
      ELSEIF(CHPATL.EQ.'PHYSI')THEN
         IF(JTMED.GT.0)THEN
            DO 30 I=1,IQ(JTMED-2)
               JTM=LQ(JTMED-I)
               IF(JTM.LE.0)GO TO 30
               IF(IQ(JTM-2).EQ.0)THEN
                  CALL MZPUSH(IXCONS,JTM,10,0,'I')
                  GO TO 30
               ENDIF
               DO 20 J=1,10
                  JTMI=LQ(JTM-J)
                  IF(JTMI.GT.0)THEN
                     CALL MZDROP(IXCONS,JTMI,' ')
                  ENDIF
   20          CONTINUE
   30       CONTINUE
            CALL UCOPY(CUTGAM,Q(JTMED+1),10)
            DO 40 I=1,13
               Q(JTMED+10+I)=MECA(1,I)
   40       CONTINUE
         ENDIF
         IF(JMATE.LE.0)GO TO 999
         DO 60 I=1,IQ(JMATE-2)
            JMA=LQ(JMATE-I)
            IF(JMA.LE.0)GO TO 60
            DO 50 J=1,IQ(JMA-2)
               IF(J.EQ.4.OR.J.EQ.5)GO TO 60
               JM=LQ(JMA-J)
               IF(JM.LE.0)GO TO 50
               CALL MZDROP(IXCONS,JM,'L')
   50       CONTINUE
   60    CONTINUE
         CALL MZGARB (IXCONS, 0)
         CALL GPHYSI
      ENDIF
*
  999 END
+DECK,  GXPICK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:50  cernlib
* Geant

      SUBROUTINE GXPICK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Geometry commands                                         *
C.    *                                                                *
C.    * Point to volume just drawn to pick up medium name, volume name *
C.    * etc. The first point points to the volume, the second point    *
C.    * gives the position of the character string which contains this *
C.    * information.                                                   *
C.    *                                                                *
C.    *       Authors:   S.Egli      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCVOLU.
+CDE, GCDRAW.
+CDE, GCBANK.
+CDE, GCSETS.
+CDE, GCTMED.
+CDE, GCMATE.
+CDE, GCUNIT.
*
* this COMMON filled in routine GDRAW !
*
      COMMON/GCVHLP/NVLAST
*
      DIMENSION XC(3),XYZ(3),XINVMA(3,3),VL(3),VM(3),VN(3)
      DIMENSION XX(10),YY(10),RHELP(3)
*
      CHARACTER*4 NAMV,CHIDTY
      CHARACTER*20 NAMM
      LOGICAL BTEST
*
* determine inverse matrix xinvma for current view parameters
*
      PH = ABS(MOD(GPHI,360.))
      THET = ABS(MOD(GTHETA,360.))
      IF(THET.LE.180.)GO TO 10
      PH = PH + 180.
      THET = 360. - THET
*
   10 ST = SIN(THET * DEGRAD)
      CT = COS(THET * DEGRAD)
      SP = SIN(PH * DEGRAD)
      CP = COS(PH * DEGRAD)
*
*             VN is new nu axis
*
      VN(1) = ST * CP
      VN(2) = ST * SP
      VN(3) = CT
*
      IF(ABS(VN(2)).GT.0.99999) THEN
*
*             Special case when observer line of sight is along mu:
*             in this case one chooses arbitrarily the vertical axis of
*             plane of projection as the lambda axis and the horizontal
*             as the nu axis
*
         VL(1) = 0.
         VL(2) = 0.
         VL(3) = 1.
         VM(1) = 1.
         VM(2) = 0.
         VM(3) = 0.
      ELSE
*
         VM(1) = 0.
         VM(2) = 1.
         VM(3) = 0.
*
*             Define new lambda axis
*
         CALL CROSS(VM,VN,VL)
         CALL VUNIT(VL,VL,3)
*
*             Define new mu axis
*
         CALL CROSS(VN,VL,VM)
      ENDIF
*
*   now invert matrix defined by VL,VM,VN -> XINVMA
*
      DO 20 I=1,3
         XINVMA(1,I)=VL(I)
         XINVMA(2,I)=VM(I)
         XINVMA(3,I)=VN(I)
   20 CONTINUE
*
      CALL RINV(3,XINVMA,3,RHELP,IFAIL)
      IF(IFAIL.NE.0)THEN
         WRITE(CHMAIL,10100) IFAIL
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
*   perspective projection ?
*
      CALL UCTOH('PERS',IPERS,4,4)
      IF(IPRJ.EQ.IPERS)THEN
         WRITE(CHMAIL,10200)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
* pick up two points in user coordinates:
*
   30 CALL IRQLC(1,1,ISTAT,NT,U0,V0)
      IF(ISTAT.EQ.0)GOTO 999
      CALL IRQLC(1,1,ISTAT,NT,U1,V1)
      IF(ISTAT.EQ.0)GOTO 999
*
* transform (u0,v0) to coordinates in MARS system:
*  (inverse operation of what is done in routine GDFR3D)
*
*   take zoom parameters into account:
*
      U01=(U0-GZUB-GZUC)/GZUA
      V01=(V0-GZVB-GZVC)/GZVA
*
*   rotate and shift back
*
      UU=+COSPSI*(U01-GU0)+SINPSI*(V01-GV0)
      VV=-SINPSI*(U01-GU0)+COSPSI*(V01-GV0)
      XYZ(1)=UU/GSCU
      XYZ(2)=VV/GSCV
      XYZ(3)=DCUT
*
*   apply xinvma
*
      XC(1)=XINVMA(1,1)*XYZ(1)+XINVMA(1,2)*XYZ(2)+XINVMA(1,3)*XYZ(3)
      XC(2)=XINVMA(2,1)*XYZ(1)+XINVMA(2,2)*XYZ(2)+XINVMA(2,3)*XYZ(3)
      XC(3)=XINVMA(3,1)*XYZ(1)+XINVMA(3,2)*XYZ(2)+XINVMA(3,3)*XYZ(3)
*
*   build up GCVOLU structure with last drawn volume as
*   top of tree
*
      NLEV=1
      LNUM=0
      CALL GLVOLU(NLEV,NVLAST,LNUM,IER)
*
*  determine medium
*
      NUMED=0
      CALL GMEDIA(XC,NUMED)
*
      IF(NUMED.EQ.0)THEN
         WRITE(CHMAIL,10300)
         CALL GMAIL(0,0)
         GOTO 30
      ENDIF
      JTM = LQ(JTMED- NUMED)
      DO 40 I=1,5
   40 NATMED(I)=IQ(JTM+I)
      NMAT   = Q(JTM + 6)
      ISVOL  = Q(JTM + 7)
      IFIELD = Q(JTM + 8)
      FIELDM = Q(JTM + 9)
      TMAXFD = Q(JTM + 10)
      STEMAX = Q(JTM + 11)
      DEEMAX = Q(JTM + 12)
      EPSIL  = Q(JTM + 13)
      STMIN  = Q(JTM + 14)
      CALL UHTOC(NAMES(NLEVEL),4,NAMV,4)
      CALL UHTOC(NATMED,4,NAMM,20)
      DO 50 I=1,20
         IF(NAMM(I:I).EQ.'$')NAMM(I:I)=' '
   50 CONTINUE
      DO 60 I=20,1,-1
         IF(NAMM(I:I).NE.' ')GOTO 70
   60 CONTINUE
   70 NJLAST=I
*
*  determine detector idtype
*
      IF(JSET.GT.0)CALL GFINDS
*
* draw pointer and write volume name,medium
*
      XX(1)=U0
      YY(1)=V0
      XX(2)=U1
      YY(2)=V1
      CALL IPL(2,XX,YY)
*
*  determine text alignment
*
      PHI=ATAN2(V1-V0,U1-U0)*RADDEG
      IF(ABS(PHI).LT.90.)THEN
         IHOR=1
      ELSE
         IHOR=3
      ENDIF
      IF(PHI.GT.0.)THEN
         IVER=5
      ELSE
         IVER=1
      ENDIF
      CALL ISTXAL(IHOR,IVER)
*
      IF(.NOT.BTEST(IQ(LQ(JVOLUM-LVOLUM(1))),4))THEN
         CALL ITX(U1,V1,NAMV//'"j# '//NAMM(1:NJLAST))
      ELSE
         WRITE(CHIDTY,10000)IDTYPE
         CALL ITX(U1,V1,NAMV//'"j# '//NAMM(1:NJLAST)//','//CHIDTY)
      ENDIF
      GOTO 30
10000 FORMAT(I4)
10100 FORMAT(' GXPICK: Matrix inversion failed with ',I3,
     +       '; abandoning')
10200 FORMAT(' GXPICK: perspective projection can not be handled')
10300 FORMAT(' GXPICK: point is outside volume')
  999 END
+DECK,  GXRZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:51  cernlib
* Geant

      SUBROUTINE GXRZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      RZEBRA control commands                                   *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCXLUN.
+CDE, GCFLAG.
+CDE, GCRZ.
      COMMON/QUEST/IQUEST(100)
      CHARACTER*20 CHDIR,CHOPT
      CHARACTER*64 CHPATH
      CHARACTER*64 CHKEY
      CHARACTER*8 CHTAG(20)
      DIMENSION KEYRZ(4)
      CHARACTER*32 CHPATL
      CHARACTER*(*) BSLASH
+SELF, IF=BSLASH.
      PARAMETER (BSLASH='\\')
+SELF, IF=-BSLASH.
      PARAMETER (BSLASH='\')
+SELF.
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'PQUEST') THEN
         CALL KUGETI(IQ1)
         CALL KUGETI(IQ2)
         IF (NPAR.EQ.1) IQ2=IQ1
         DO 10 I=IQ1,IQ2
            WRITE(CHMAIL,10000)I,IQUEST(I),IQUEST(I)
            CALL GMAIL(0,0)
   10    CONTINUE
10000 FORMAT(' IQUEST(',I2,')=',I10,2X,Z8)
*
      ELSEIF (CHPATL.EQ.'FILE') THEN
         CALL KUGETI(LUN)
         CALL GXLUNF(LUN,1,IFREE)
         IF(IFREE.NE.0)GO TO 999
         CALL KUGETC(CHPATH,NCH)
         CALL KUGETC(CHOPT,NCH)
         CALL GRFILE(LUN,CHPATH,CHOPT)
         IF(INDEX(CHOPT,'I').NE.0.OR.INDEX(CHOPT,'O').NE.0)THEN
            LUNIT(LUN)=0
         ELSE
            LUNIT(LUN)=5
         ENDIF
*
      ELSEIF (CHPATL.EQ.'REND') THEN
         CALL KUGETI(IRLUN)
         CALL GREND(IRLUN)
*
      ELSEIF (CHPATL.EQ.'RZSAVE') THEN
         CALL RZSAVE
*
      ELSEIF (CHPATL.EQ.'MDIR') THEN
         CALL HCDIR(CHDIR,'R')
         IF(CHDIR(3:6).EQ.'PAWC')THEN
            IPAW=1
         ELSE
            IPAW=0
         ENDIF
         CALL KUGETC(CHDIR,NCH)
         DO 20 I=1,NCH
            IF(CHDIR(I:I).EQ.'/'.OR.CHDIR(I:I).EQ.BSLASH)THEN
               WRITE(CHMAIL,10100)
10100       FORMAT('Directory name cannot contain slash')
               CALL GMAIL(0,0)
               GOTO 999
            ENDIF
   20    CONTINUE
         IF(IPAW.NE.0)THEN
            CALL HMDIR(CHDIR,' ')
         ELSE
            CALL KUGETI(NWKEY)
            CALL KUGETC(CHOPT,NCH)
            DO 30 I=1,NWKEY
               CALL KUGETS(CHTAG(I),NCH)
   30       CONTINUE
            CALL RZMDIR(CHDIR,NWKEY,CHOPT,CHTAG)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'CDIR') THEN
         IF(NPAR.EQ.0)THEN
            CHOPT='P'
            CHPATH=' '
         ELSE
            CALL KUGETC(CHPATH,NCH)
            CHOPT=' '
            CALL KUGETC(CHOPT,NCH)
         ENDIF
         CALL HCDIR(CHPATH,CHOPT)
*
      ELSEIF (CHPATL.EQ.'IN') THEN
         CALL KUGETC(CHKEY,NCH)
         CALL KUGETI(IDVERS)
         CALL KUGETC(CHOPT,NCH)
         CALL GRIN(CHKEY,IDVERS,CHOPT)
*
      ELSEIF (CHPATL.EQ.'OUT') THEN
         CALL KUGETC(CHKEY,NCH)
         CALL KUGETI(IDVERS)
         CALL KUGETC(CHOPT,NCH)
         CALL GROUT(CHKEY,IDVERS,CHOPT)
*
      ELSEIF (CHPATL.EQ.'LDIR') THEN
         CALL KUGETC(CHPATH,NCH)
         CHOPT='R'
         CALL KUGETC(CHOPT,NCH)
         IF(NCH.GT.0)CHOPT=CHOPT(1:NCH)//'R'
         CALL HLDIR(CHPATH,CHOPT)
*
      ELSEIF (CHPATL.EQ.'PURGE') THEN
         CALL KUGETI(NKEEP)
         CALL RZPURG(NKEEP)
*
      ELSEIF (CHPATL.EQ.'SCR') THEN
         CALL KUGETC(CHKEY,NCH)
         CALL KUGETI(IDVERS)
         CALL UCTOH(CHKEY,KEYRZ(1),4,4)
         KEYRZ(2)=IDVERS
         ICYCLE=9999
         CHOPT=' '
         CALL RZDELK(KEYRZ,ICYCLE,CHOPT)
*
      ELSEIF (CHPATL.EQ.'LOCK') THEN
         CALL KUGETC(CHDIR,NCH)
         CALL RZLOCK(CHDIR)
*
      ELSEIF (CHPATL.EQ.'FREE') THEN
         CALL KUGETC(CHDIR,NCH)
         CALL RZFREE(CHDIR)
*
      ENDIF
  999 END
+DECK,  GXSCAH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:51  cernlib
* Geant

      SUBROUTINE GXSCAH(ID,NAME,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates and plot an histogram of physics quantities such as *
C.    *  the total number of radiation lengths or interaction lengths  *
C.    *  in function of the SCAN parameter TETA for a value of PHI.    *
C.    *    CHOPT='O' histogram is generated at Exit  of VOLUME.        *
C.    *    CHOPT='I' histogram is generated at Entry of VOLUME.        *
C.    *    CHOPT='X' radiation lengths                                 *
C.    *    CHOPT='L' Interaction lengths                               *
C.    *    CHOPT='P' Plot the histogram                                *
C.    *  If VOLUME='XXXX' Mother volume is used.                       *
C.    *  The histogram identifier IDPHI is used to also identify which *
C.    *  PHI division to plot. IPHI=MOD(IDPHI,1000).                   *
C.    *  If IPHI=0, then all PHI divisions are generated (not plotted) *
C.    *  with histogram identifiers IDPHI+PHI division number.         *
C.    *                                                                *
C.    *       Author:    R.Brun      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSCAN.
      CHARACTER*(*) NAME,CHOPT
C.
C.    ------------------------------------------------------------------
C.
  99  END

+DECK,  GXSCAL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:51  cernlib
* Geant

      SUBROUTINE GXSCAL(ID,NAME,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      To generate a LEGO plot of the scan geometry              *
C.    *  Generates and plot a table of physics quantities such as      *
C.    *  the total number of radiation lengths or interaction lengths  *
C.    *  in function of the SCAN parameters TETA,PHI.                  *
C.    *    CHOPT='O' table is generated at Exit  of volume NAME.       *
C.    *    CHOPT='I' table is generated at Entry of volume NAME        *
C.    *    CHOPT='X' radiation lengths                                 *
C.    *    CHOPT='L' Interaction lengths                               *
C.    *    CHOPT='P' Plot the table                                    *
C.    *  If VOLUME='XXXX' Mother volume is used.                       *
C.    *                                                                *
C.    *       Author:    R.Brun      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSCAN.
+CDE, GCONSP.
+CDE, GCSCAL.
      CHARACTER*(*) NAME,CHOPT
      CHARACTER*80 CHTITL
      CHARACTER*11 CHCASE(2)
      CHARACTER*6 CHLOC(2)
      DIMENSION IOPT(5)
      EQUIVALENCE (IOPTX,IOPT(1)),(IOPTL,IOPT(2))
      EQUIVALENCE (IOPTI,IOPT(3)),(IOPTO,IOPT(4))
      DATA CHCASE/'Radiation','Absorption'/
      DATA CHLOC/'before','after'/
C.
C.    ------------------------------------------------------------------
C.
      IF(LSCAN.LE.0)THEN
         ID=0
         GO TO 99
      ENDIF
      NTETA=Q(LSCAN+1)
      NPHI     = IQ(LSCAN+1)
      NTETA    = IQ(LSCAN+2)
      MODTET   = IQ(LSCAN+3)
      NSLIST   = IQ(LSCAN+4)
      NSLMAX   = IQ(LSCAN+5)
      PHIMIN   = Q (LSCAN+11)
      PHIMAX   = Q (LSCAN+12)
      TETMIN   = Q (LSCAN+13)
      TETMAX   = Q (LSCAN+14)
      VSCAN(1) = Q (LSCAN+15)
      VSCAN(2) = Q (LSCAN+16)
      VSCAN(3) = Q (LSCAN+17)
      FACTX0   = Q (LSCAN+18)
      FACTL    = Q (LSCAN+19)
      FACTR    = Q (LSCAN+20)
      DO 10 I=1,NSLIST
         ISLIST(I)=IQ(LSCAN+20+I)
  10  CONTINUE
*
      CHTITL=' '
      CALL UOPTC(CHOPT,'XLIO',IOPT)
      IF(IOPTL.EQ.0)IOPTX=1
      IF(IOPTI.EQ.0)IOPTO=1
      ICASE=1+IOPTL
      ILOC =1+IOPTO
      IF(NAME.EQ.'XXXX')THEN
         IHNAME=IQ(JVOLUM+1)
         WRITE(CHTITL,1000)CHCASE(ICASE),IHNAME
 1000    FORMAT('Number of ',A,' lengths in ',A4)
      ELSE
         CALL UCTOH(NAME,IHNAME,4,4)
         ISL=IUCOMP(ISLIST,NSLIST,IHNAME)
         IF(ISL.LE.0)THEN
            PRINT *,' Unknown SCAN name: ',NAME
            ID=0
            GO TO 99
         ENDIF
         WRITE(CHTITL,2000)CHCASE(ICASE),CHLOC(ILOC),IHNAME
 2000    FORMAT('Number of ',A,' lengths ',A,1X,A)
      ENDIF
      CALL HBOOK2(ID,CHTITL,NPHI,PHIMIN,PHIMAX,NTETA,TETMIN,TETMAX,0.)
*
      DPHI=(PHIMAX-PHIMIN)/NPHI
      DTETA=(TETMAX-TETMIN)/NTETA
      DO 50 IPHI=1,NPHI
         LPHI=LQ(LSCAN-IPHI)
         IF(LPHI.LE.0)GO TO 50
         PHI=PHIMIN+DPHI*(IPHI-0.5)
         DO 20 ITETA=1,NTETA
            TETA=TETMIN+DTETA*(ITETA-0.5)
            IDES=IQ(LPHI+ITETA)
            NW=IBITS(IDES,16,6)
            ISCUR=IBITS(IDES,0,16)
            IW1=IQ(LPHI+ISCUR+2*NW-2)
            IW2=IQ(LPHI+ISCUR+2*NW-1)
            SX0 =IBITS(IW2,17,15)/FACTX0
            SABS=IBITS(IW1,22,10)/FACTL
            IF(IOPTX.NE.0)THEN
               W=SX0
            ELSE
               W=SABS
            ENDIF
            CALL HFILL(ID,PHI,TETA,W)
  20     CONTINUE
  50  CONTINUE
*
  99  END

+DECK,  GXSCAN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:51  cernlib
* Geant

      SUBROUTINE GXSCAN
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Scan Geometry control commands                            *
C.    *                                                                *
C.    *       Author:    R.Brun      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSCAL.
+CDE, GCSCAN.
+CDE, GCUNIT.
+CDE, GCPARM.
      COMMON/QUEST/IQUEST(100)
      CHARACTER*20 CHOPT
      CHARACTER*32 CHPATL
      CHARACTER*4 NAME
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
*
      IF(CHPATL.EQ.'STURN')THEN
*
         IF(NPAR.LE.0) THEN
            IF(SCANFL) THEN
               CHOPT='ON'
            ELSE
               CHOPT='OFF'
            END IF
            WRITE(CHMAIL,10000) CHOPT
10000       FORMAT(' SCAN Parameters: SCAN mode is: ',A3)
            CALL GMAIL(0,0)
         ELSE
            CALL KUGETC(CHOPT,NCH)
            IF(CHOPT.EQ.'ON') THEN
               SCANFL=.TRUE.
            ELSE IF (CHOPT.EQ.'OFF') THEN
               SCANFL=.FALSE.
            ELSE IF (CHOPT.EQ.'INIT') THEN
               SCANFL=.TRUE.
               CALL GSCANI
            END IF
         END IF
      ELSEIF(CHPATL.EQ.'TETA')THEN
*
         IF(NPAR.LE.0) THEN
            WRITE(CHMAIL, 10100) NTETA, TETMIN, TETMAX, MODTET
10100       FORMAT(' SCAN Parameters: NTETA = ',I5,' MIN = ',G10.3,
     +             ' MAX = ',G10.3, ' MODE = ',I2)
            CALL GMAIL(0,0)
         ELSE
            CALL KUGETI(NTETA)
            CALL KUGETR(TETMIN)
            CALL KUGETR(TETMAX)
            IF(NSLMAX.EQ.0)NSLMAX=5
            CALL KUGETI(MODTET)
         END IF
      ELSEIF(CHPATL.EQ.'PHI')THEN
*
         IF(NPAR.LE.0) THEN
            WRITE(CHMAIL, 10200) NPHI, PHIMIN, PHIMAX
10200       FORMAT(' SCAN Parameters: NPHI  = ',I5,' MIN = ',G10.3,
     +             ' MAX = ',G10.3)
            CALL GMAIL(0,0)
         ELSE
            CALL KUGETI(NPHI)
            CALL KUGETR(PHIMIN)
            CALL KUGETR(PHIMAX)
            IPHI1=1
            IPHIL=NPHI
            IF(NSLMAX.EQ.0)NSLMAX=5
         END IF
      ELSEIF(CHPATL.EQ.'SLIST')THEN
*
         IF(NPAR.LE.0) THEN
            NPADON=MIN(NSLIST,8)
            NPAWRI=NPADON
            WRITE(CHMAIL,10300) NSLIST, (ISLIST(J), J=1, NPAWRI)
10300       FORMAT(' SCAN Parameters: ',I3,' Scan volumes :',8(1X,A4))
            CALL GMAIL(0,0)
   10       IF(NSLIST.GT.NPADON) THEN
               NPAWRI=MIN(NSLIST-NPADON,15)
               WRITE(CHMAIL,10400)(ISLIST(J),J=NPADON+1,NPADON+NPAWRI)
10400          FORMAT((1X,15(1X,A4)))
               CALL GMAIL(0,0)
               NPADON=NPADON+NPAWRI
               GO TO 10
            ENDIF
         ELSE
            CALL VBLANK(ISLIST, MSLIST)
            IF(NPAR.GT.MSLIST) THEN
               WRITE(CHMAIL,10500) MSLIST
10500          FORMAT(' Warning! Only first ',I3,' scan volumes ',
     +                'accepted')
               CALL GMAIL(0,0)
            ENDIF
            NSLIST=0
            NVOL=IQ(JVOLUM-1)
            DO 20 I=1,MIN(NPAR,MSLIST)
               CALL KUGETC(CHOPT,NCH)
               IF(I.EQ.1) THEN
                  IF(NPAR.EQ.1.AND.CHOPT.EQ.'.') THEN
                     CALL MZDROP(IXCONS,LSCAN,' ')
                     GO TO 999
                  END IF
               END IF
               NCH=MIN(4,NCH)
               NSLIST=NSLIST+1
               CALL UCTOH(CHOPT,ISLIST(NSLIST),4,NCH)
               JVOL=IUCOMP(ISLIST(NSLIST),IQ(JVOLUM+1),NVOL)
               IF(JVOL.LE.0) THEN
                  WRITE(CHMAIL,10600) ISLIST(NSLIST)
10600             FORMAT(' Warning: volume ',A4,' does not exist;',
     +                   ' skipped')
                  CALL GMAIL(0,0)
                  NSLIST=NSLIST-1
               END IF
   20       CONTINUE
            IF(NSLIST.LE.0) THEN
               WRITE(CHMAIL,10700)
10700          FORMAT(' Warning! No valid volume defined')
               CALL GMAIL(0,0)
            ENDIF
         ENDIF
      ELSEIF(CHPATL.EQ.'VERTEX')THEN
*
         IF(NSLMAX.EQ.0)NSLMAX=5
         CALL KUGETR(VSCAN(1))
         CALL KUGETR(VSCAN(2))
         CALL KUGETR(VSCAN(3))
      ELSEIF(CHPATL.EQ.'PCUTS')THEN
*
         IF(NPAR.LE.0) THEN
            WRITE(CHMAIL,10800) IPARAM
10800       FORMAT(' Parametrization flag = ',I2,
     +             ' Parametrization cuts:')
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10900)
10900       FORMAT('         Gamma     Electrons   Ch. Hadrons',
     +             '  Neu. Hadrons         Muons')
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11000) PACUTS
11000       FORMAT(5(1X,G13.4))
            CALL GMAIL(0,0)
         ELSE
            CALL KUGETI(IPARAM)
            DO 30 JPACUT=1, 5
               CALL KUGETR(PACUTS(JPACUT))
   30       CONTINUE
         ENDIF
      ELSEIF(CHPATL.EQ.'SFACTORS')THEN
*
         CALL KUGETR(FACTX0)
         CALL KUGETR(FACTL)
         CALL KUGETR(FACTR)
      ELSEIF(CHPATL.EQ.'LSCAN')THEN
*
         CALL KUGETI(IDPHI)
         CALL KUGETC(NAME,NCH)
         CALL KUGETC(CHOPT,NCH)
         CALL GXSCAL(IDPHI,NAME,CHOPT)
         IF(INDEX(CHOPT,'P').NE.0)THEN
            IF(IDPHI.NE.0)CALL HPLEGO(IDPHI,30.,30.)
         ENDIF
      ELSEIF(CHPATL.EQ.'HSCAN')THEN
*
         CALL KUGETI(IDPHI)
         CALL KUGETC(NAME,NCH)
         CALL KUGETC(CHOPT,NCH)
         CALL GXSCAH(IDPHI,NAME,CHOPT)
         IF(INDEX(CHOPT,'P').NE.0)THEN
            IF(IDPHI.NE.0)CALL HPLOT(IDPHI,' ',' ',0)
         ENDIF
      ENDIF
*
  999 END
+PATCH, EXAMPLES.
+PATCH, CDF.
+DECK,  G321M, T=CC.
/*
 * $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
 *
 * $Log: geanx321.car100,v $
 * Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
 * Imported sources
 *
 * Revision 1.1.1.1  1995/10/24 10:19:36  cernlib
 * Geant
 *
 */
/*CMZ :          27/09/95  15.13.13  by  Unknown*/
+SELF, IF=-KUIP95A.

/*-- Author :*/
/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 950303      Generation date: Thu Aug 24 15:19:04 1995
 *
 * Input file: geant321m.doc
 */

#if !defined(F77_LCASE) && !defined(F77_UCASE) && !defined(F77_USCORE)
#  if defined(__EXTENDED__) && !defined(IBM370) && !defined(_IBMR2)
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */

typedef struct _BrAction {      /*                                         */
  struct _BrAction *next;       /* link to next action binding             */
  BrActFlag   flags;            /*                                         */
  char       *text;             /* text line in menu                       */
  char       *user_text;        /* user text overriding CDF text (malloced)*/
  char       *accel;            /* accelerator                             */
  char       *exec;             /* action commands                         */
  SUBROUTINE *call_F;           /* action routine                          */
  IntFunc    *call_C;           /* action function                         */
  BrActTag    tag;              /* for which window the action is defined  */
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */

typedef struct _KmIcon {        /*                                         */
  struct _KmIcon *next;         /* link to next icon                       */
  char       *name;             /* unique identifier name                  */
  int         width;            /* width of the pixmap                     */
  int         height;           /* height of the pixmap                    */
  char       *bitmap;           /* bitmap data                             */
  KmPixmap    pix;              /* filled in Motif part                    */
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */

typedef enum {                  /*                                         */
  KmButtSensitive       = 0x00, /* sensitive button                        */
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */

extern struct {                        /*
    */   /* indirect calls to avoid linking HIGZ
    */   IntFunc    *graf_info_C;      /* pass display, open and close
 (ixmotif)  */   SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)
            */   SUBROUTINE *graf_pick_F;      /* identifying graphics objects
 (IGOBJ)    */   SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)
            */   SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)
            */   /* optional routines for Motif customization
            */   pCharFunc  *user_FallBk_C;    /* get application fallbacks
            */   IntFunc    *user_TopWid_C;    /* pass toplevel widget
 identifiers        */ } klnkaddr;                     /*
                    */

typedef enum {                  /*                                         */
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */

typedef struct {                /* file name                               */
  char         *filter_default; /* filter wildcard                         */
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */

typedef KmParInt KmParReal;     /* real and int have the same fields       */
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */

typedef struct _KmCommand {     /*                                         */
  struct _KmCommand *next;      /* link to next command                    */
  char         *path;           /* command path                            */
  char         *name;           /* command name                            */
  int           hidden;         /* flag if command is invisible            */
  int           level;          /* depth of submenus                       */
  int           total;          /* total number of parameters              */
  int           mandatory;      /* number of mandatory parameters          */
  KmParameter **par;            /* list of total parameter descriptions    */
  int           list_par;       /* index+1 of parameter taking a list      */
  int           xcount;         /* count number of action calls            */
  SUBROUTINE   *action_F;       /* action routine                          */
  IntFunc      *action_C;       /* action routine                          */
  SUBROUTINE   *user_help_F;    /* user help routine                       */
  pCharFunc    *user_help_C;    /* user help routine                       */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
  int           argc;           /* number of arguments entered             */
  char        **argv;           /* argc argument values                    */
  char         *argline;        /* argument line as entered                */
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */

typedef struct _KmMenu {        /*                                         */
  struct _KmMenu *next;         /* link to next menu                       */
  struct _KmMenu *down;         /* link to submenu                         */
  char         *path;           /* path of parent menu                     */
  char         *name;           /* menu name                               */
  int           level;          /* depth of submenus                       */
  KmCommand    *cmds;           /* link to first command                   */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */

#ifdef F77_LCASE
#  define gbrows_ gbrows
#  define gxobj_ gxobj
#  define igrsiz_ igrsiz
#  define igobj_ igobj
#  define igset_ igset
#  define iclwk_ iclwk
#endif

#ifdef F77_UCASE
#  define gbrows_ GBROWS
#  define gxobj_ GXOBJ
#  define igrsiz_ IGRSIZ
#  define igobj_ IGOBJ
#  define igset_ IGSET
#  define iclwk_ ICLWK
#endif

#ifdef IBM370
#  pragma linkage(GBROWS,FORTRAN)
#  pragma linkage(GXOBJ,FORTRAN)
#  pragma linkage(IGRSIZ,FORTRAN)
#  pragma linkage(IGOBJ,FORTRAN)
#  pragma linkage(IGSET,FORTRAN)
#  pragma linkage(ICLWK,FORTRAN)
#endif

extern void gbrows_();
extern void gxobj_();
extern void igrsiz_();
extern void igobj_();
extern void igset_();
extern void iclwk_();

extern int ixmotif();

void gbrows_()
{

static BrAction brclass_8_root_4 = { (BrAction*)0, (BrActFlag)17, "Delete",
 (char*)0, (char*)0, "-G/del", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_8_root_3 = { &brclass_8_root_4, (BrActFlag)16,
 "Close", (char*)0, (char*)0, "+Dclose", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_8_root_2 = { &brclass_8_root_3, (BrActFlag)16, "Open",
 (char*)0, (char*)0, "-Dopen", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_8_root_1 = { &brclass_8_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_8 = { (BrClass*)0, "VIEW", "View banks in memory",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_8_root_1,
 (BrAction*)0 };

static BrAction brclass_7_root_2 = { (BrAction*)0, (BrActFlag)16, "Create",
 (char*)0, (char*)0, "-Srotm", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_7_root_1 = { &brclass_7_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_7 = { &brclass_8, "ROTM", "Rotation matrix", gxobj_,
 (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_7_root_1, (BrAction*)0
 };

static BrAction brclass_6_root_1 = { (BrAction*)0, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_6 = { &brclass_7, "HITS", "Hits data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_6_root_1,
 (BrAction*)0 };

static BrAction brclass_5_root_1 = { (BrAction*)0, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_5 = { &brclass_6, "KINE", "Kinematics data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_5_root_1,
 (BrAction*)0 };

static BrAction brclass_4_root_2 = { (BrAction*)0, (BrActFlag)16, "Define",
 (char*)0, (char*)0, "-Spart", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_4_root_1 = { &brclass_4_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_4 = { &brclass_5, "PART", "Particles data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_4_root_1,
 (BrAction*)0 };

static BrAction brclass_3_root_2 = { (BrAction*)0, (BrActFlag)16, "Define",
 (char*)0, (char*)0, "-Stmed", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_3_root_1 = { &brclass_3_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_3 = { &brclass_4, "TMED", "Tracking medium parameters",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_3_root_1,
 (BrAction*)0 };

static BrAction brclass_2_root_3 = { (BrAction*)0, (BrActFlag)16, "Def_mix",
 (char*)0, (char*)0, "-Smixt", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_2_root_2 = { &brclass_2_root_3, (BrActFlag)16,
 "Def_mat", (char*)0, (char*)0, "-Smate", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_2_root_1 = { &brclass_2_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_2 = { &brclass_3, "MATE", "Materials data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_2_root_1,
 (BrAction*)0 };

static BrAction brclass_1_root_4 = { (BrAction*)0, (BrActFlag)16, "Divide",
 (char*)0, (char*)0, "-Sdvn; +Editv", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_1_root_3 = { &brclass_1_root_4, (BrActFlag)16,
 "Position", (char*)0, (char*)0, "-Spos; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_1_root_2 = { &brclass_1_root_3, (BrActFlag)16,
 "Create", (char*)0, (char*)0, "-Svol; -Spos; +Editv", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_1_root_1 = { &brclass_1_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrAction brclass_1_open_2 = { (BrAction*)0, (BrActFlag)16,
 "Read data structures from RZ file", (char*)0, (char*)0, "-rz/fil",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_OPEN, (BrClass*)0 };
static BrAction brclass_1_open_1 = { &brclass_1_open_2, (BrActFlag)16,
 "Save data structures in RZ file", (char*)0, (char*)0, "-rz/fil",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_OPEN, (BrClass*)0 };
static BrClass brclass_1 = { &brclass_2, "VOLU", "Volumes data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_1_root_1,
 &brclass_1_open_1 };

static BrAction kmclass_30_cont_3 = { (BrAction*)0, (BrActFlag)16, "Lens",
 (char*)0, (char*)0, "-Lens", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_30_cont_2 = { &kmclass_30_cont_3, (BrActFlag)16,
 "Zoom", (char*)0, (char*)0, "-Zoom", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_30_cont_1 = { &kmclass_30_cont_2, (BrActFlag)16,
 "Show", (char*)0, (char*)0, "Dshow [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_30_graf_3 = { (BrAction*)0, (BrActFlag)16, "Lens",
 (char*)0, (char*)0, "-Lens", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_30_graf_2 = { &kmclass_30_graf_3, (BrActFlag)16,
 "Show", (char*)0, (char*)0, "+Dshow [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_30_graf_1 = { &kmclass_30_graf_2, (BrActFlag)16,
 "Zoom", (char*)0, (char*)0, "-Zoom", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_30 = { (KmClass*)0, 0, "VB", "View banks id", "big_VB",
 (KmIcon*)0, "sm_VB", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_30_cont_1, &kmclass_30_graf_1, 0 };

static BrAction kmclass_29_cont_2 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Protm [that]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_29_cont_1 = { &kmclass_29_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Srotm [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_29 = { &kmclass_30, 0, "Rmatr", "Rotation matrix",
 "big_Rmatr", (KmIcon*)0, "sm_Rmatr", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_29_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_28_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this2] [this1] [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_28 = { &kmclass_29, 0, "Hitnum", "Numhit", "big_Num",
 (KmIcon*)0, "sm_Num", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0, (BrAction*)0,
 &kmclass_28_graf_1, 0 };

static BrAction kmclass_27_cont_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits * [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_27_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this1] [this] 0", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_27 = { &kmclass_28, 0, "Hitdet", "Dethit", "big_Det",
 (KmIcon*)0, "sm_Det", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_27_cont_1, &kmclass_27_graf_1, 0 };

static BrAction kmclass_26_cont_2 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_26_cont_1 = { &kmclass_26_cont_2, (BrActFlag)16,
 "List", (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_26_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_26 = { &kmclass_27, 1, "Hitset", "Sethit", "big_Set",
 (KmIcon*)0, "sm_Set", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_26_cont_1, &kmclass_26_graf_1, 0 };

static BrAction kmclass_25_cont_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Prkine [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_25_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Prkine [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_25 = { &kmclass_26, 0, "Kine", "Tracks", "big_Track",
 (KmIcon*)0, "sm_Track", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_25_cont_1, &kmclass_25_graf_1, 0 };

static BrAction kmclass_24_cont_2 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Ppart [that]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_24_cont_1 = { &kmclass_24_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Spart [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_24 = { &kmclass_25, 0, "Part", "Particles", "big_Part",
 (KmIcon*)0, "sm_Part", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_24_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_23_cont_3 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Ptmed [that]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_23_cont_2 = { &kmclass_23_cont_3, (BrActFlag)16,
 "Ed_cut_mec", (char*)0, (char*)0, "-Stpar [that]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_23_cont_1 = { &kmclass_23_cont_2, (BrActFlag)16,
 "Edit_med", (char*)0, (char*)0, "-Stmed [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_23 = { &kmclass_24, 0, "Med", "Tracking media",
 "big_Med", (KmIcon*)0, "sm_Med", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_23_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_22_cont_3 = { (BrAction*)0, (BrActFlag)16,
 "Plot_x-sec", (char*)0, (char*)0, "-Drmat [that]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_22_cont_2 = { &kmclass_22_cont_3, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pmate [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_22_cont_1 = { &kmclass_22_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Smixt [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_22 = { &kmclass_23, 0, "Mixt",
 "Mixtures and compounds", "big_Mixt", (KmIcon*)0, "sm_Mixt", (KmIcon*)0,
 (SUBROUTINE*)0, (IntFunc*)0, &kmclass_22_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_21_cont_3 = { (BrAction*)0, (BrActFlag)16,
 "Plot_x-sec", (char*)0, (char*)0, "-Drmat [that]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_21_cont_2 = { &kmclass_21_cont_3, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pmate [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_21_cont_1 = { &kmclass_21_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Smate [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_21 = { &kmclass_22, 0, "Elem", "Basic materials",
 "big_Elem", (KmIcon*)0, "sm_Elem", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_21_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_20_graf_3 = { (BrAction*)0, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this1]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_20_graf_2 = { &kmclass_20_graf_3, (BrActFlag)16,
 "Spec", (char*)0, (char*)0,
 "Changewk; option nzfl; next; +Dspec [this1]; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_20_graf_1 = { &kmclass_20_graf_2, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Next; Dtree [this1] [this] 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_20 = { &kmclass_21, 0, "Arrow", "Levels", "big_Arrow",
 (KmIcon*)0, "sm_Arrow", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 (BrAction*)0, &kmclass_20_graf_1, 0 };

static BrAction kmclass_19_graf_6 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_5 = { &kmclass_19_graf_6, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_4 = { &kmclass_19_graf_5, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_3 = { &kmclass_19_graf_4, (BrActFlag)16,
 "Spec3d", (char*)0, (char*)0,
 "box [this] 0 1000 0 1000 -1000 1000; +D3dspec [this]; -D3dspec [this]",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_2 = { &kmclass_19_graf_3, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_1 = { &kmclass_19_graf_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0,
 "Changewk; option nzfl; next; +Dspec [this]; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_19 = { &kmclass_20, 0, "Tree", "Dtree", "big_Tree",
 (KmIcon*)0, "sm_Tree", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0, (BrAction*)0,
 &kmclass_19_graf_1, 0 };

static BrAction kmclass_18_graf_13 = { (BrAction*)0, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_12 = { &kmclass_18_graf_13, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_18_graf_11 = { &kmclass_18_graf_12, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_10 = { &kmclass_18_graf_11, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_9 = { &kmclass_18_graf_10, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_8 = { &kmclass_18_graf_9, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_7 = { &kmclass_18_graf_8, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_6 = { &kmclass_18_graf_7, (BrActFlag)16,
 "Move3d", (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_5 = { &kmclass_18_graf_6, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_4 = { &kmclass_18_graf_5, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_3 = { &kmclass_18_graf_4, (BrActFlag)16,
 "Tree", (char*)0, (char*)0,
 "Changewk;option nzfl; next; Dtree [this] 3 111; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_2 = { &kmclass_18_graf_3, (BrActFlag)16,
 "Spec", (char*)0, (char*)0,
 "Changewk;option nzfl; next; +Dspec [this]; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_1 = { &kmclass_18_graf_2, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [this1]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_18 = { &kmclass_19, 0, "Pick", "Pick_volum",
 "big_Pick", (KmIcon*)0, "sm_Pick", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 (BrAction*)0, &kmclass_18_graf_1, 0 };

static BrAction kmclass_17_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_6 = { &kmclass_17_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_5 = { &kmclass_17_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_4 = { &kmclass_17_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_3 = { &kmclass_17_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_2 = { &kmclass_17_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_1 = { &kmclass_17_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_8 = { &kmclass_17_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_17_graf_7 = { &kmclass_17_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_17_graf_6 = { &kmclass_17_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_5 = { &kmclass_17_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_4 = { &kmclass_17_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_3 = { &kmclass_17_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_2 = { &kmclass_17_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_1 = { &kmclass_17_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_17 = { &kmclass_18, 0, "New", "New_shape", "big_New",
 (KmIcon*)0, "sm_New", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_17_cont_1, &kmclass_17_graf_1, 0 };

static BrAction kmclass_16_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_6 = { &kmclass_16_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_5 = { &kmclass_16_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_4 = { &kmclass_16_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_3 = { &kmclass_16_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_2 = { &kmclass_16_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_1 = { &kmclass_16_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_8 = { &kmclass_16_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_16_graf_7 = { &kmclass_16_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_16_graf_6 = { &kmclass_16_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_5 = { &kmclass_16_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_4 = { &kmclass_16_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_3 = { &kmclass_16_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_2 = { &kmclass_16_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_1 = { &kmclass_16_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_16 = { &kmclass_17, 0, "Ctub", "Shape ctub volumes",
 "big_Ctub", (KmIcon*)0, "sm_Ctub", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_16_cont_1, &kmclass_16_graf_1, 0 };

static BrAction kmclass_15_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_6 = { &kmclass_15_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_5 = { &kmclass_15_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_4 = { &kmclass_15_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_3 = { &kmclass_15_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_2 = { &kmclass_15_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_1 = { &kmclass_15_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_8 = { &kmclass_15_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_15_graf_7 = { &kmclass_15_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_15_graf_6 = { &kmclass_15_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_5 = { &kmclass_15_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_4 = { &kmclass_15_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_3 = { &kmclass_15_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_2 = { &kmclass_15_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_1 = { &kmclass_15_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_15 = { &kmclass_16, 0, "Gtra", "Shape gtra volumes",
 "big_Gtra", (KmIcon*)0, "sm_Gtra", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_15_cont_1, &kmclass_15_graf_1, 0 };

static BrAction kmclass_14_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_6 = { &kmclass_14_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_5 = { &kmclass_14_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_4 = { &kmclass_14_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_3 = { &kmclass_14_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_2 = { &kmclass_14_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_1 = { &kmclass_14_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_8 = { &kmclass_14_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_14_graf_7 = { &kmclass_14_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_14_graf_6 = { &kmclass_14_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_5 = { &kmclass_14_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_4 = { &kmclass_14_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_3 = { &kmclass_14_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_2 = { &kmclass_14_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_1 = { &kmclass_14_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_14 = { &kmclass_15, 0, "Hype", "Shape hype volumes",
 "big_Hype", (KmIcon*)0, "sm_Hype", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_14_cont_1, &kmclass_14_graf_1, 0 };

static BrAction kmclass_13_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_6 = { &kmclass_13_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_5 = { &kmclass_13_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_4 = { &kmclass_13_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_3 = { &kmclass_13_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_2 = { &kmclass_13_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_1 = { &kmclass_13_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_8 = { &kmclass_13_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_13_graf_7 = { &kmclass_13_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_13_graf_6 = { &kmclass_13_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_5 = { &kmclass_13_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_4 = { &kmclass_13_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_3 = { &kmclass_13_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_2 = { &kmclass_13_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_1 = { &kmclass_13_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_13 = { &kmclass_14, 0, "Eltu", "Shape eltu volumes",
 "big_Eltu", (KmIcon*)0, "sm_Eltu", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_13_cont_1, &kmclass_13_graf_1, 0 };

static BrAction kmclass_12_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_6 = { &kmclass_12_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_5 = { &kmclass_12_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_4 = { &kmclass_12_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_3 = { &kmclass_12_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_2 = { &kmclass_12_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_1 = { &kmclass_12_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_8 = { &kmclass_12_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_12_graf_7 = { &kmclass_12_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_12_graf_6 = { &kmclass_12_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_5 = { &kmclass_12_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_4 = { &kmclass_12_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_3 = { &kmclass_12_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_2 = { &kmclass_12_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_1 = { &kmclass_12_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_12 = { &kmclass_13, 0, "Pcon", "Shape pcon volumes",
 "big_Pcon", (KmIcon*)0, "sm_Pcon", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_12_cont_1, &kmclass_12_graf_1, 0 };

static BrAction kmclass_11_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_6 = { &kmclass_11_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_5 = { &kmclass_11_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_4 = { &kmclass_11_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_3 = { &kmclass_11_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_2 = { &kmclass_11_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_1 = { &kmclass_11_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_8 = { &kmclass_11_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_11_graf_7 = { &kmclass_11_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_11_graf_6 = { &kmclass_11_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_5 = { &kmclass_11_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_4 = { &kmclass_11_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_3 = { &kmclass_11_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_2 = { &kmclass_11_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_1 = { &kmclass_11_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_11 = { &kmclass_12, 0, "Pgon", "Shape pgon volumes",
 "big_Pgon", (KmIcon*)0, "sm_Pgon", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_11_cont_1, &kmclass_11_graf_1, 0 };

static BrAction kmclass_10_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_6 = { &kmclass_10_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_5 = { &kmclass_10_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_4 = { &kmclass_10_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_3 = { &kmclass_10_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_2 = { &kmclass_10_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_1 = { &kmclass_10_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_8 = { &kmclass_10_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_10_graf_7 = { &kmclass_10_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_10_graf_6 = { &kmclass_10_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_5 = { &kmclass_10_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_4 = { &kmclass_10_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_3 = { &kmclass_10_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_2 = { &kmclass_10_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_1 = { &kmclass_10_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_10 = { &kmclass_11, 0, "Para", "Shape para volumes",
 "big_Para", (KmIcon*)0, "sm_Para", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_10_cont_1, &kmclass_10_graf_1, 0 };

static BrAction kmclass_9_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_6 = { &kmclass_9_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_9_cont_5 = { &kmclass_9_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_4 = { &kmclass_9_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_3 = { &kmclass_9_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_9_cont_2 = { &kmclass_9_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_1 = { &kmclass_9_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_9_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_8 = { &kmclass_9_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_7 = { &kmclass_9_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_6 = { &kmclass_9_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_5 = { &kmclass_9_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_4 = { &kmclass_9_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_3 = { &kmclass_9_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_2 = { &kmclass_9_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_1 = { &kmclass_9_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_9 = { &kmclass_10, 0, "Sphe", "Shape sphe volumes",
 "big_Sphe", (KmIcon*)0, "sm_Sphe", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_9_cont_1, &kmclass_9_graf_1, 0 };

static BrAction kmclass_8_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_6 = { &kmclass_8_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_8_cont_5 = { &kmclass_8_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_4 = { &kmclass_8_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_3 = { &kmclass_8_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_8_cont_2 = { &kmclass_8_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_1 = { &kmclass_8_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_8_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_8 = { &kmclass_8_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_7 = { &kmclass_8_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_6 = { &kmclass_8_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_5 = { &kmclass_8_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_4 = { &kmclass_8_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_3 = { &kmclass_8_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_2 = { &kmclass_8_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_1 = { &kmclass_8_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_8 = { &kmclass_9, 0, "Cons", "Shape cons volumes",
 "big_Cons", (KmIcon*)0, "sm_Cons", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_8_cont_1, &kmclass_8_graf_1, 0 };

static BrAction kmclass_7_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_6 = { &kmclass_7_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_7_cont_5 = { &kmclass_7_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_4 = { &kmclass_7_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_3 = { &kmclass_7_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_7_cont_2 = { &kmclass_7_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_1 = { &kmclass_7_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_7_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_8 = { &kmclass_7_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_7 = { &kmclass_7_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_6 = { &kmclass_7_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_5 = { &kmclass_7_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_4 = { &kmclass_7_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_3 = { &kmclass_7_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_2 = { &kmclass_7_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_1 = { &kmclass_7_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_7 = { &kmclass_8, 0, "Cone", "Shape cone volumes",
 "big_Cone", (KmIcon*)0, "sm_Cone", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_7_cont_1, &kmclass_7_graf_1, 0 };

static BrAction kmclass_6_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_6 = { &kmclass_6_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_6_cont_5 = { &kmclass_6_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_4 = { &kmclass_6_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_3 = { &kmclass_6_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_6_cont_2 = { &kmclass_6_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_1 = { &kmclass_6_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_6_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_8 = { &kmclass_6_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_7 = { &kmclass_6_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_6 = { &kmclass_6_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_5 = { &kmclass_6_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_4 = { &kmclass_6_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_3 = { &kmclass_6_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_2 = { &kmclass_6_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_1 = { &kmclass_6_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_6 = { &kmclass_7, 0, "Tubs", "Shape tubs volumes",
 "big_Tubs", (KmIcon*)0, "sm_Tubs", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_6_cont_1, &kmclass_6_graf_1, 0 };

static BrAction kmclass_5_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_6 = { &kmclass_5_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_5_cont_5 = { &kmclass_5_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_4 = { &kmclass_5_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_3 = { &kmclass_5_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_5_cont_2 = { &kmclass_5_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_1 = { &kmclass_5_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_5_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_8 = { &kmclass_5_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_7 = { &kmclass_5_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_6 = { &kmclass_5_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_5 = { &kmclass_5_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_4 = { &kmclass_5_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_3 = { &kmclass_5_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_2 = { &kmclass_5_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_1 = { &kmclass_5_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_5 = { &kmclass_6, 0, "Tube", "Shape tube volumes",
 "big_Tube", (KmIcon*)0, "sm_Tube", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_5_cont_1, &kmclass_5_graf_1, 0 };

static BrAction kmclass_4_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_6 = { &kmclass_4_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_4_cont_5 = { &kmclass_4_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_4 = { &kmclass_4_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_3 = { &kmclass_4_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_4_cont_2 = { &kmclass_4_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_1 = { &kmclass_4_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_4_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_8 = { &kmclass_4_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_7 = { &kmclass_4_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_6 = { &kmclass_4_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_5 = { &kmclass_4_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_4 = { &kmclass_4_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_3 = { &kmclass_4_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_2 = { &kmclass_4_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_1 = { &kmclass_4_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_4 = { &kmclass_5, 0, "Trap", "Shape trap volumes",
 "big_Trap", (KmIcon*)0, "sm_Trap", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_4_cont_1, &kmclass_4_graf_1, 0 };

static BrAction kmclass_3_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_6 = { &kmclass_3_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_3_cont_5 = { &kmclass_3_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_4 = { &kmclass_3_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_3 = { &kmclass_3_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_3_cont_2 = { &kmclass_3_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_1 = { &kmclass_3_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_3_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_8 = { &kmclass_3_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_7 = { &kmclass_3_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_6 = { &kmclass_3_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_5 = { &kmclass_3_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_4 = { &kmclass_3_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_3 = { &kmclass_3_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_2 = { &kmclass_3_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_1 = { &kmclass_3_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_3 = { &kmclass_4, 0, "Trd2", "Shape trd2 volumes",
 "big_Trd2", (KmIcon*)0, "sm_Trd2", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_3_cont_1, &kmclass_3_graf_1, 0 };

static BrAction kmclass_2_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_6 = { &kmclass_2_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_2_cont_5 = { &kmclass_2_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_4 = { &kmclass_2_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_3 = { &kmclass_2_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_2_cont_2 = { &kmclass_2_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_1 = { &kmclass_2_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_2_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_8 = { &kmclass_2_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_7 = { &kmclass_2_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_6 = { &kmclass_2_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_5 = { &kmclass_2_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_4 = { &kmclass_2_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_3 = { &kmclass_2_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_2 = { &kmclass_2_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_1 = { &kmclass_2_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_2 = { &kmclass_3, 0, "Trd1", "Shape trd1 volumes",
 "big_Trd1", (KmIcon*)0, "sm_Trd1", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_2_cont_1, &kmclass_2_graf_1, 0 };

static BrAction kmclass_1_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_6 = { &kmclass_1_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_1_cont_5 = { &kmclass_1_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_4 = { &kmclass_1_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_3 = { &kmclass_1_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_1_cont_2 = { &kmclass_1_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_1 = { &kmclass_1_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_1_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_8 = { &kmclass_1_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_7 = { &kmclass_1_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_6 = { &kmclass_1_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_5 = { &kmclass_1_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_4 = { &kmclass_1_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_3 = { &kmclass_1_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_2 = { &kmclass_1_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_1 = { &kmclass_1_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_1 = { &kmclass_2, 0, "Box", "Shape box volumes",
 "big_Box", (KmIcon*)0, "sm_Box", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_1_cont_1, &kmclass_1_graf_1, 0 };

  klnkbrcl( &brclass_1, 950303 );
  klnkkmcl( &kmclass_1, 950303 );
  klnkaddr.graf_info_C = ixmotif;
  klnkaddr.graf_size_F = igrsiz_;
  klnkaddr.graf_pick_F = igobj_;
  klnkaddr.graf_attr_F = igset_;
  klnkaddr.graf_close_F = iclwk_;
}

+SELF, IF=KUIP95A.

/*CMZ :          21/03/95  18.51.58  by  S.Giani*/
/*-- Author :*/
/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 921023      Generation date: Tue Mar 21 18:51:55 1995
 *
 * Input file: g321m.doc
 */

#if !defined(F77_LCASE) && !defined(F77_UCASE) && !defined(F77_USCORE)
#  if defined(__EXTENDED__) && !defined(IBM370) && !defined(_IBMR2)
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */

typedef struct _BrAction {      /*                                         */
  struct _BrAction *next;       /* link to next action binding             */
  BrActFlag   flags;            /*                                         */
  char       *text;             /* text line in menu                       */
  char       *user_text;        /* user text overriding CDF text (malloced)*/
  char       *accel;            /* accelerator                             */
  char       *exec;             /* action commands                         */
  SUBROUTINE *call_F;           /* action routine                          */
  IntFunc    *call_C;           /* action function                         */
  BrActTag    tag;              /* for which window the action is defined  */
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */

typedef struct _KmIcon {        /*                                         */
  struct _KmIcon *next;         /* link to next icon                       */
  char       *name;             /* unique identifier name                  */
  int         width;            /* width of the pixmap                     */
  int         height;           /* height of the pixmap                    */
  char       *bitmap;           /* bitmap data                             */
  KmPixmap    pix;              /* filled in Motif part                    */
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */

typedef enum {                  /*                                         */
  KmButtSensitive       = 0x00, /* sensitive button                        */
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */

extern struct {                        /*
    */   /* indirect calls to avoid linking HIGZ
    */   IntFunc    *graf_info_C;      /* pass display, open and close
 (ixmotif)  */   SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)
            */   SUBROUTINE *graf_pick_F;      /* identifying graphics objects
 (IGOBJ)    */   SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)
            */   SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)
            */   /* optional routines for Motif customization
            */   pCharFunc  *user_FallBk_C;    /* get application fallbacks
            */   IntFunc    *user_TopWid_C;    /* pass toplevel widget
 identifiers        */ } klnkaddr;                     /*
                    */

typedef enum {                  /*                                         */
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */

typedef struct {                /* file name                               */
  char         *filter_default; /* filter wildcard                         */
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */

typedef KmParInt KmParReal;     /* real and int have the same fields       */
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */

typedef struct _KmCommand {     /*                                         */
  struct _KmCommand *next;      /* link to next command                    */
  char         *path;           /* command path                            */
  char         *name;           /* command name                            */
  int           hidden;         /* flag if command is invisible            */
  int           level;          /* depth of submenus                       */
  int           total;          /* total number of parameters              */
  int           mandatory;      /* number of mandatory parameters          */
  KmParameter **par;            /* list of total parameter descriptions    */
  int           list_par;       /* index+1 of parameter taking a list      */
  int           xcount;         /* count number of action calls            */
  SUBROUTINE   *action_F;       /* action routine                          */
  IntFunc      *action_C;       /* action routine                          */
  SUBROUTINE   *user_help_F;    /* user help routine                       */
  pCharFunc    *user_help_C;    /* user help routine                       */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int           argc;           /* number of arguments entered             */
  char        **argv;           /* argc argument values                    */
  char         *argline;        /* argument line as entered                */
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */

typedef struct _KmMenu {        /*                                         */
  struct _KmMenu *next;         /* link to next menu                       */
  struct _KmMenu *down;         /* link to submenu                         */
  char         *path;           /* path of parent menu                     */
  char         *name;           /* menu name                               */
  int           level;          /* depth of submenus                       */
  KmCommand    *cmds;           /* link to first command                   */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */

#ifdef F77_LCASE
#  define gbrows_ gbrows
#  define gxobj_ gxobj
#  define igrsiz_ igrsiz
#  define igobj_ igobj
#  define igset_ igset
#  define iclwk_ iclwk
#endif

#ifdef F77_UCASE
#  define gbrows_ GBROWS
#  define gxobj_ GXOBJ
#  define igrsiz_ IGRSIZ
#  define igobj_ IGOBJ
#  define igset_ IGSET
#  define iclwk_ ICLWK
#endif

#ifdef IBM370
#  pragma linkage(GBROWS,FORTRAN)
#  pragma linkage(GXOBJ,FORTRAN)
#  pragma linkage(IGRSIZ,FORTRAN)
#  pragma linkage(IGOBJ,FORTRAN)
#  pragma linkage(IGSET,FORTRAN)
#  pragma linkage(ICLWK,FORTRAN)
#endif

extern void gbrows_();
extern void gxobj_();
extern void igrsiz_();
extern void igobj_();
extern void igset_();
extern void iclwk_();

extern int ixmotif();

void gbrows_()
{

static BrAction brclass_8_root_4 = { (BrAction*)0, (BrActFlag)17, "Delete",
 (char*)0, (char*)0, "-G/del", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_8_root_3 = { &brclass_8_root_4, (BrActFlag)16,
 "Close", (char*)0, (char*)0, "+Dclose", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_8_root_2 = { &brclass_8_root_3, (BrActFlag)16, "Open",
 (char*)0, (char*)0, "-Dopen", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_8_root_1 = { &brclass_8_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_8 = { (BrClass*)0, "VIEW", "View banks in memory",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_8_root_1,
 (BrAction*)0 };

static BrAction brclass_7_root_2 = { (BrAction*)0, (BrActFlag)16, "Create",
 (char*)0, (char*)0, "-Srotm", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_7_root_1 = { &brclass_7_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_7 = { &brclass_8, "ROTM", "Rotation matrix", gxobj_,
 (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_7_root_1, (BrAction*)0
 };

static BrAction brclass_6_root_1 = { (BrAction*)0, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_6 = { &brclass_7, "HITS", "Hits data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_6_root_1,
 (BrAction*)0 };

static BrAction brclass_5_root_1 = { (BrAction*)0, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_5 = { &brclass_6, "KINE", "Kinematics data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_5_root_1,
 (BrAction*)0 };

static BrAction brclass_4_root_2 = { (BrAction*)0, (BrActFlag)16, "Define",
 (char*)0, (char*)0, "-Spart", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_4_root_1 = { &brclass_4_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_4 = { &brclass_5, "PART", "Particles data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_4_root_1,
 (BrAction*)0 };

static BrAction brclass_3_root_2 = { (BrAction*)0, (BrActFlag)16, "Define",
 (char*)0, (char*)0, "-Stmed", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_3_root_1 = { &brclass_3_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_3 = { &brclass_4, "TMED", "Tracking medium parameters",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_3_root_1,
 (BrAction*)0 };

static BrAction brclass_2_root_3 = { (BrAction*)0, (BrActFlag)16, "Def_mix",
 (char*)0, (char*)0, "-Smixt", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_2_root_2 = { &brclass_2_root_3, (BrActFlag)16,
 "Def_mat", (char*)0, (char*)0, "-Smate", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_2_root_1 = { &brclass_2_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrClass brclass_2 = { &brclass_3, "MATE", "Materials data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_2_root_1,
 (BrAction*)0 };

static BrAction brclass_1_root_4 = { (BrAction*)0, (BrActFlag)16, "Divide",
 (char*)0, (char*)0, "-Sdvn; +Editv", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT,
 (BrClass*)0 };
static BrAction brclass_1_root_3 = { &brclass_1_root_4, (BrActFlag)16,
 "Position", (char*)0, (char*)0, "-Spos; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_1_root_2 = { &brclass_1_root_3, (BrActFlag)16,
 "Create", (char*)0, (char*)0, "-Svol; -Spos; +Editv", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_ROOT, (BrClass*)0 };
static BrAction brclass_1_root_1 = { &brclass_1_root_2, (BrActFlag)16, "List",
 (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_ROOT, (BrClass*)0
 };
static BrAction brclass_1_open_2 = { (BrAction*)0, (BrActFlag)16,
 "Read data structures from RZ file", (char*)0, (char*)0, "-rz/fil",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_OPEN, (BrClass*)0 };
static BrAction brclass_1_open_1 = { &brclass_1_open_2, (BrActFlag)16,
 "Save data structures in RZ file", (char*)0, (char*)0, "-rz/fil",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_OPEN, (BrClass*)0 };
static BrClass brclass_1 = { &brclass_2, "VOLU", "Volumes data structure",
 gxobj_, (pCharFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, &brclass_1_root_1,
 &brclass_1_open_1 };

static BrAction kmclass_30_cont_3 = { (BrAction*)0, (BrActFlag)16, "Lens",
 (char*)0, (char*)0, "-Lens", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_30_cont_2 = { &kmclass_30_cont_3, (BrActFlag)16,
 "Zoom", (char*)0, (char*)0, "-Zoom", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_30_cont_1 = { &kmclass_30_cont_2, (BrActFlag)16,
 "Show", (char*)0, (char*)0, "Dshow [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_30_graf_3 = { (BrAction*)0, (BrActFlag)16, "Lens",
 (char*)0, (char*)0, "-Lens", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_30_graf_2 = { &kmclass_30_graf_3, (BrActFlag)16,
 "Show", (char*)0, (char*)0, "+Dshow [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_30_graf_1 = { &kmclass_30_graf_2, (BrActFlag)16,
 "Zoom", (char*)0, (char*)0, "-Zoom", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_30 = { (KmClass*)0, 0, "VB", "View banks id", "big_VB",
 (KmIcon*)0, "sm_VB", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_30_cont_1, &kmclass_30_graf_1, 0 };

static BrAction kmclass_29_cont_2 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Protm [that]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_29_cont_1 = { &kmclass_29_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Srotm [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_29 = { &kmclass_30, 0, "Rmatr", "Rotation matrix",
 "big_Rmatr", (KmIcon*)0, "sm_Rmatr", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_29_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_28_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this2] [this1] [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_28 = { &kmclass_29, 0, "Hitnum", "Numhit", "big_Num",
 (KmIcon*)0, "sm_Num", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0, (BrAction*)0,
 &kmclass_28_graf_1, 0 };

static BrAction kmclass_27_cont_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits * [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_27_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this1] [this] 0", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_27 = { &kmclass_28, 0, "Hitdet", "Dethit", "big_Det",
 (KmIcon*)0, "sm_Det", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_27_cont_1, &kmclass_27_graf_1, 0 };

static BrAction kmclass_26_cont_2 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_26_cont_1 = { &kmclass_26_cont_2, (BrActFlag)16,
 "List", (char*)0, (char*)0, " ", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_26_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Phits [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_26 = { &kmclass_27, 1, "Hitset", "Sethit", "big_Set",
 (KmIcon*)0, "sm_Set", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_26_cont_1, &kmclass_26_graf_1, 0 };

static BrAction kmclass_25_cont_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Prkine [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_25_graf_1 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Prkine [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_25 = { &kmclass_26, 0, "Kine", "Tracks", "big_Track",
 (KmIcon*)0, "sm_Track", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_25_cont_1, &kmclass_25_graf_1, 0 };

static BrAction kmclass_24_cont_2 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Ppart [that]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_24_cont_1 = { &kmclass_24_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Spart [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_24 = { &kmclass_25, 0, "Part", "Particles", "big_Part",
 (KmIcon*)0, "sm_Part", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_24_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_23_cont_3 = { (BrAction*)0, (BrActFlag)16, "Print",
 (char*)0, (char*)0, "+Ptmed [that]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_23_cont_2 = { &kmclass_23_cont_3, (BrActFlag)16,
 "Ed_cut_mec", (char*)0, (char*)0, "-Stpar [that]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_23_cont_1 = { &kmclass_23_cont_2, (BrActFlag)16,
 "Edit_med", (char*)0, (char*)0, "-Stmed [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_23 = { &kmclass_24, 0, "Med", "Tracking media",
 "big_Med", (KmIcon*)0, "sm_Med", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_23_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_22_cont_3 = { (BrAction*)0, (BrActFlag)16,
 "Plot_x-sec", (char*)0, (char*)0, "-Drmat [that]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_22_cont_2 = { &kmclass_22_cont_3, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pmate [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_22_cont_1 = { &kmclass_22_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Smixt [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_22 = { &kmclass_23, 0, "Mixt",
 "Mixtures and compounds", "big_Mixt", (KmIcon*)0, "sm_Mixt", (KmIcon*)0,
 (SUBROUTINE*)0, (IntFunc*)0, &kmclass_22_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_21_cont_3 = { (BrAction*)0, (BrActFlag)16,
 "Plot_x-sec", (char*)0, (char*)0, "-Drmat [that]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_21_cont_2 = { &kmclass_21_cont_3, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pmate [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_21_cont_1 = { &kmclass_21_cont_2, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Smate [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static KmClass kmclass_21 = { &kmclass_22, 0, "Elem", "Basic materials",
 "big_Elem", (KmIcon*)0, "sm_Elem", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_21_cont_1, (BrAction*)0, 0 };

static BrAction kmclass_20_graf_3 = { (BrAction*)0, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this1]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_20_graf_2 = { &kmclass_20_graf_3, (BrActFlag)16,
 "Spec", (char*)0, (char*)0,
 "Changewk; option nzfl; next; +Dspec [this1]; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_20_graf_1 = { &kmclass_20_graf_2, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Next; Dtree [this1] [this] 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_20 = { &kmclass_21, 0, "Arrow", "Levels", "big_Arrow",
 (KmIcon*)0, "sm_Arrow", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 (BrAction*)0, &kmclass_20_graf_1, 0 };

static BrAction kmclass_19_graf_6 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_5 = { &kmclass_19_graf_6, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_4 = { &kmclass_19_graf_5, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_3 = { &kmclass_19_graf_4, (BrActFlag)16,
 "Spec3d", (char*)0, (char*)0,
 "box [this] 0 1000 0 1000 -1000 1000; +D3dspec [this]; -D3dspec [this]",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_2 = { &kmclass_19_graf_3, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_19_graf_1 = { &kmclass_19_graf_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0,
 "Changewk; option nzfl; next; +Dspec [this]; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_19 = { &kmclass_20, 0, "Tree", "Dtree", "big_Tree",
 (KmIcon*)0, "sm_Tree", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0, (BrAction*)0,
 &kmclass_19_graf_1, 0 };

static BrAction kmclass_18_graf_13 = { (BrAction*)0, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_12 = { &kmclass_18_graf_13, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_18_graf_11 = { &kmclass_18_graf_12, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_10 = { &kmclass_18_graf_11, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_9 = { &kmclass_18_graf_10, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_8 = { &kmclass_18_graf_9, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_7 = { &kmclass_18_graf_8, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_6 = { &kmclass_18_graf_7, (BrActFlag)16,
 "Move3d", (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_5 = { &kmclass_18_graf_6, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_4 = { &kmclass_18_graf_5, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_3 = { &kmclass_18_graf_4, (BrActFlag)16,
 "Tree", (char*)0, (char*)0,
 "Changewk;option nzfl; next; Dtree [this] 3 111; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_2 = { &kmclass_18_graf_3, (BrActFlag)16,
 "Spec", (char*)0, (char*)0,
 "Changewk;option nzfl; next; +Dspec [this]; Resetwk; option zfl1",
 (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_18_graf_1 = { &kmclass_18_graf_2, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [this1]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_18 = { &kmclass_19, 0, "Pick", "Pick_volum",
 "big_Pick", (KmIcon*)0, "sm_Pick", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 (BrAction*)0, &kmclass_18_graf_1, 0 };

static BrAction kmclass_17_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_6 = { &kmclass_17_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_5 = { &kmclass_17_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_4 = { &kmclass_17_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_3 = { &kmclass_17_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_2 = { &kmclass_17_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_cont_1 = { &kmclass_17_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_17_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_8 = { &kmclass_17_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_17_graf_7 = { &kmclass_17_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_17_graf_6 = { &kmclass_17_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_5 = { &kmclass_17_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_4 = { &kmclass_17_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_3 = { &kmclass_17_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_2 = { &kmclass_17_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_17_graf_1 = { &kmclass_17_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_17 = { &kmclass_18, 0, "New", "New_shape", "big_New",
 (KmIcon*)0, "sm_New", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_17_cont_1, &kmclass_17_graf_1, 0 };

static BrAction kmclass_16_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_6 = { &kmclass_16_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_5 = { &kmclass_16_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_4 = { &kmclass_16_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_3 = { &kmclass_16_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_2 = { &kmclass_16_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_cont_1 = { &kmclass_16_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_16_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_8 = { &kmclass_16_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_16_graf_7 = { &kmclass_16_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_16_graf_6 = { &kmclass_16_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_5 = { &kmclass_16_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_4 = { &kmclass_16_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_3 = { &kmclass_16_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_2 = { &kmclass_16_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_16_graf_1 = { &kmclass_16_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_16 = { &kmclass_17, 0, "Ctub", "Shape ctub volumes",
 "big_Ctub", (KmIcon*)0, "sm_Ctub", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_16_cont_1, &kmclass_16_graf_1, 0 };

static BrAction kmclass_15_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_6 = { &kmclass_15_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_5 = { &kmclass_15_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_4 = { &kmclass_15_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_3 = { &kmclass_15_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_2 = { &kmclass_15_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_cont_1 = { &kmclass_15_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_15_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_8 = { &kmclass_15_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_15_graf_7 = { &kmclass_15_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_15_graf_6 = { &kmclass_15_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_5 = { &kmclass_15_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_4 = { &kmclass_15_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_3 = { &kmclass_15_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_2 = { &kmclass_15_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_15_graf_1 = { &kmclass_15_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_15 = { &kmclass_16, 0, "Gtra", "Shape gtra volumes",
 "big_Gtra", (KmIcon*)0, "sm_Gtra", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_15_cont_1, &kmclass_15_graf_1, 0 };

static BrAction kmclass_14_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_6 = { &kmclass_14_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_5 = { &kmclass_14_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_4 = { &kmclass_14_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_3 = { &kmclass_14_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_2 = { &kmclass_14_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_cont_1 = { &kmclass_14_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_14_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_8 = { &kmclass_14_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_14_graf_7 = { &kmclass_14_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_14_graf_6 = { &kmclass_14_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_5 = { &kmclass_14_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_4 = { &kmclass_14_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_3 = { &kmclass_14_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_2 = { &kmclass_14_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_14_graf_1 = { &kmclass_14_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_14 = { &kmclass_15, 0, "Hype", "Shape hype volumes",
 "big_Hype", (KmIcon*)0, "sm_Hype", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_14_cont_1, &kmclass_14_graf_1, 0 };

static BrAction kmclass_13_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_6 = { &kmclass_13_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_5 = { &kmclass_13_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_4 = { &kmclass_13_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_3 = { &kmclass_13_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_2 = { &kmclass_13_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_cont_1 = { &kmclass_13_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_13_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_8 = { &kmclass_13_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_13_graf_7 = { &kmclass_13_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_13_graf_6 = { &kmclass_13_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_5 = { &kmclass_13_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_4 = { &kmclass_13_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_3 = { &kmclass_13_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_2 = { &kmclass_13_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_13_graf_1 = { &kmclass_13_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_13 = { &kmclass_14, 0, "Eltu", "Shape eltu volumes",
 "big_Eltu", (KmIcon*)0, "sm_Eltu", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_13_cont_1, &kmclass_13_graf_1, 0 };

static BrAction kmclass_12_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_6 = { &kmclass_12_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_5 = { &kmclass_12_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_4 = { &kmclass_12_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_3 = { &kmclass_12_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_2 = { &kmclass_12_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_cont_1 = { &kmclass_12_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_12_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_8 = { &kmclass_12_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_12_graf_7 = { &kmclass_12_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_12_graf_6 = { &kmclass_12_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_5 = { &kmclass_12_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_4 = { &kmclass_12_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_3 = { &kmclass_12_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_2 = { &kmclass_12_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_12_graf_1 = { &kmclass_12_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_12 = { &kmclass_13, 0, "Pcon", "Shape pcon volumes",
 "big_Pcon", (KmIcon*)0, "sm_Pcon", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_12_cont_1, &kmclass_12_graf_1, 0 };

static BrAction kmclass_11_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_6 = { &kmclass_11_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_5 = { &kmclass_11_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_4 = { &kmclass_11_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_3 = { &kmclass_11_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_2 = { &kmclass_11_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_cont_1 = { &kmclass_11_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_11_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_8 = { &kmclass_11_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_11_graf_7 = { &kmclass_11_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_11_graf_6 = { &kmclass_11_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_5 = { &kmclass_11_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_4 = { &kmclass_11_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_3 = { &kmclass_11_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_2 = { &kmclass_11_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_11_graf_1 = { &kmclass_11_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_11 = { &kmclass_12, 0, "Pgon", "Shape pgon volumes",
 "big_Pgon", (KmIcon*)0, "sm_Pgon", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_11_cont_1, &kmclass_11_graf_1, 0 };

static BrAction kmclass_10_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_6 = { &kmclass_10_cont_7, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_5 = { &kmclass_10_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_4 = { &kmclass_10_cont_5, (BrActFlag)16,
 "Edit", (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_3 = { &kmclass_10_cont_4, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_2 = { &kmclass_10_cont_3, (BrActFlag)16,
 "Tree", (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_cont_1 = { &kmclass_10_cont_2, (BrActFlag)16,
 "Spec", (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_10_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_8 = { &kmclass_10_graf_9, (BrActFlag)16,
 "Satt", (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_10_graf_7 = { &kmclass_10_graf_8, (BrActFlag)16,
 "Shif", (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static BrAction kmclass_10_graf_6 = { &kmclass_10_graf_7, (BrActFlag)16,
 "Bomb", (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_5 = { &kmclass_10_graf_6, (BrActFlag)16,
 "Csph", (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_4 = { &kmclass_10_graf_5, (BrActFlag)16,
 "Ccon", (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_3 = { &kmclass_10_graf_4, (BrActFlag)16,
 "Ctub", (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_2 = { &kmclass_10_graf_3, (BrActFlag)16,
 "Cbox", (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_10_graf_1 = { &kmclass_10_graf_2, (BrActFlag)16,
 "Draw", (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_GRAF, (BrClass*)0 };
static KmClass kmclass_10 = { &kmclass_11, 0, "Para", "Shape para volumes",
 "big_Para", (KmIcon*)0, "sm_Para", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_10_cont_1, &kmclass_10_graf_1, 0 };

static BrAction kmclass_9_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_6 = { &kmclass_9_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_9_cont_5 = { &kmclass_9_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_4 = { &kmclass_9_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_3 = { &kmclass_9_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_9_cont_2 = { &kmclass_9_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_9_cont_1 = { &kmclass_9_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_9_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_8 = { &kmclass_9_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_7 = { &kmclass_9_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_6 = { &kmclass_9_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_5 = { &kmclass_9_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_4 = { &kmclass_9_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_3 = { &kmclass_9_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_2 = { &kmclass_9_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_9_graf_1 = { &kmclass_9_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_9 = { &kmclass_10, 0, "Sphe", "Shape sphe volumes",
 "big_Sphe", (KmIcon*)0, "sm_Sphe", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_9_cont_1, &kmclass_9_graf_1, 0 };

static BrAction kmclass_8_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_6 = { &kmclass_8_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_8_cont_5 = { &kmclass_8_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_4 = { &kmclass_8_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_3 = { &kmclass_8_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_8_cont_2 = { &kmclass_8_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_8_cont_1 = { &kmclass_8_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_8_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_8 = { &kmclass_8_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_7 = { &kmclass_8_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_6 = { &kmclass_8_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_5 = { &kmclass_8_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_4 = { &kmclass_8_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_3 = { &kmclass_8_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_2 = { &kmclass_8_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_8_graf_1 = { &kmclass_8_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_8 = { &kmclass_9, 0, "Cons", "Shape cons volumes",
 "big_Cons", (KmIcon*)0, "sm_Cons", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_8_cont_1, &kmclass_8_graf_1, 0 };

static BrAction kmclass_7_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_6 = { &kmclass_7_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_7_cont_5 = { &kmclass_7_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_4 = { &kmclass_7_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_3 = { &kmclass_7_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_7_cont_2 = { &kmclass_7_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_7_cont_1 = { &kmclass_7_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_7_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_8 = { &kmclass_7_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_7 = { &kmclass_7_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_6 = { &kmclass_7_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_5 = { &kmclass_7_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_4 = { &kmclass_7_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_3 = { &kmclass_7_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_2 = { &kmclass_7_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_7_graf_1 = { &kmclass_7_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_7 = { &kmclass_8, 0, "Cone", "Shape cone volumes",
 "big_Cone", (KmIcon*)0, "sm_Cone", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_7_cont_1, &kmclass_7_graf_1, 0 };

static BrAction kmclass_6_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_6 = { &kmclass_6_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_6_cont_5 = { &kmclass_6_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_4 = { &kmclass_6_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_3 = { &kmclass_6_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_6_cont_2 = { &kmclass_6_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_6_cont_1 = { &kmclass_6_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_6_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_8 = { &kmclass_6_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_7 = { &kmclass_6_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_6 = { &kmclass_6_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_5 = { &kmclass_6_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_4 = { &kmclass_6_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_3 = { &kmclass_6_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_2 = { &kmclass_6_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_6_graf_1 = { &kmclass_6_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_6 = { &kmclass_7, 0, "Tubs", "Shape tubs volumes",
 "big_Tubs", (KmIcon*)0, "sm_Tubs", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_6_cont_1, &kmclass_6_graf_1, 0 };

static BrAction kmclass_5_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_6 = { &kmclass_5_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_5_cont_5 = { &kmclass_5_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_4 = { &kmclass_5_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_3 = { &kmclass_5_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_5_cont_2 = { &kmclass_5_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_5_cont_1 = { &kmclass_5_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_5_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_8 = { &kmclass_5_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_7 = { &kmclass_5_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_6 = { &kmclass_5_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_5 = { &kmclass_5_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_4 = { &kmclass_5_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_3 = { &kmclass_5_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_2 = { &kmclass_5_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_5_graf_1 = { &kmclass_5_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_5 = { &kmclass_6, 0, "Tube", "Shape tube volumes",
 "big_Tube", (KmIcon*)0, "sm_Tube", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_5_cont_1, &kmclass_5_graf_1, 0 };

static BrAction kmclass_4_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_6 = { &kmclass_4_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_4_cont_5 = { &kmclass_4_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_4 = { &kmclass_4_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_3 = { &kmclass_4_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_4_cont_2 = { &kmclass_4_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_4_cont_1 = { &kmclass_4_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_4_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_8 = { &kmclass_4_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_7 = { &kmclass_4_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_6 = { &kmclass_4_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_5 = { &kmclass_4_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_4 = { &kmclass_4_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_3 = { &kmclass_4_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_2 = { &kmclass_4_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_4_graf_1 = { &kmclass_4_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_4 = { &kmclass_5, 0, "Trap", "Shape trap volumes",
 "big_Trap", (KmIcon*)0, "sm_Trap", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_4_cont_1, &kmclass_4_graf_1, 0 };

static BrAction kmclass_3_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_6 = { &kmclass_3_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_3_cont_5 = { &kmclass_3_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_4 = { &kmclass_3_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_3 = { &kmclass_3_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_3_cont_2 = { &kmclass_3_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_3_cont_1 = { &kmclass_3_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_3_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_8 = { &kmclass_3_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_7 = { &kmclass_3_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_6 = { &kmclass_3_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_5 = { &kmclass_3_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_4 = { &kmclass_3_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_3 = { &kmclass_3_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_2 = { &kmclass_3_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_3_graf_1 = { &kmclass_3_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_3 = { &kmclass_4, 0, "Trd2", "Shape trd2 volumes",
 "big_Trd2", (KmIcon*)0, "sm_Trd2", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_3_cont_1, &kmclass_3_graf_1, 0 };

static BrAction kmclass_2_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_6 = { &kmclass_2_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_2_cont_5 = { &kmclass_2_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_4 = { &kmclass_2_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_3 = { &kmclass_2_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_2_cont_2 = { &kmclass_2_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_2_cont_1 = { &kmclass_2_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_2_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_8 = { &kmclass_2_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_7 = { &kmclass_2_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_6 = { &kmclass_2_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_5 = { &kmclass_2_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_4 = { &kmclass_2_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_3 = { &kmclass_2_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_2 = { &kmclass_2_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_2_graf_1 = { &kmclass_2_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_2 = { &kmclass_3, 0, "Trd1", "Shape trd1 volumes",
 "big_Trd1", (KmIcon*)0, "sm_Trd1", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_2_cont_1, &kmclass_2_graf_1, 0 };

static BrAction kmclass_1_cont_7 = { (BrAction*)0, (BrActFlag)16, "Move3d",
 (char*)0, (char*)0, "next; +move3d [this]; -move3d [this]", (SUBROUTINE*)0,
 (IntFunc*)0, BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_6 = { &kmclass_1_cont_7, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_1_cont_5 = { &kmclass_1_cont_6, (BrActFlag)16,
 "Print", (char*)0, (char*)0, "+Pvolu [that]", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_4 = { &kmclass_1_cont_5, (BrActFlag)16, "Edit",
 (char*)0, (char*)0, "-Editv; +Editv", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_3 = { &kmclass_1_cont_4, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "-Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_1_cont_2 = { &kmclass_1_cont_3, (BrActFlag)16, "Tree",
 (char*)0, (char*)0, "Dtree [this] 3 111", (SUBROUTINE*)0, (IntFunc*)0,
 BRACT_CONT, (BrClass*)0 };
static BrAction kmclass_1_cont_1 = { &kmclass_1_cont_2, (BrActFlag)16, "Spec",
 (char*)0, (char*)0, "+Dspec [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_CONT,
 (BrClass*)0 };
static BrAction kmclass_1_graf_9 = { (BrAction*)0, (BrActFlag)16, "Move",
 (char*)0, (char*)0, "-Move", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_8 = { &kmclass_1_graf_9, (BrActFlag)16, "Satt",
 (char*)0, (char*)0, "Satt [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_7 = { &kmclass_1_graf_8, (BrActFlag)16, "Shif",
 (char*)0, (char*)0, "-Draw/Shift", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_6 = { &kmclass_1_graf_7, (BrActFlag)16, "Bomb",
 (char*)0, (char*)0, "-Bomb", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_5 = { &kmclass_1_graf_6, (BrActFlag)16, "Csph",
 (char*)0, (char*)0, "-Sphe", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_4 = { &kmclass_1_graf_5, (BrActFlag)16, "Ccon",
 (char*)0, (char*)0, "-Cone", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_3 = { &kmclass_1_graf_4, (BrActFlag)16, "Ctub",
 (char*)0, (char*)0, "-Tube", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_2 = { &kmclass_1_graf_3, (BrActFlag)16, "Cbox",
 (char*)0, (char*)0, "-Box", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static BrAction kmclass_1_graf_1 = { &kmclass_1_graf_2, (BrActFlag)16, "Draw",
 (char*)0, (char*)0, "Draw [this]", (SUBROUTINE*)0, (IntFunc*)0, BRACT_GRAF,
 (BrClass*)0 };
static KmClass kmclass_1 = { &kmclass_2, 0, "Box", "Shape box volumes",
 "big_Box", (KmIcon*)0, "sm_Box", (KmIcon*)0, (SUBROUTINE*)0, (IntFunc*)0,
 &kmclass_1_cont_1, &kmclass_1_graf_1, 0 };

  klnkbrcl( &brclass_1, 921023 );
  klnkkmcl( &kmclass_1, 921023 );
  klnkaddr.graf_info_C = ixmotif;
  klnkaddr.graf_size_F = igrsiz_;
  klnkaddr.graf_pick_F = igobj_;
  klnkaddr.graf_attr_F = igset_;
  klnkaddr.graf_close_F = iclwk_;
}

+SELF.
+DECK,  G321M_CDF_D, T=DATA, IF=DOC.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:36  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.35  by  S.Giani
*-- Author :
>Name GBROWS

>Graphics

>Browse VOLU 'Volumes data structure' GXOBJ
 List       .  ' '
 Create     .  '-Svol; -Spos; +Editv'
 Position   .  '-Spos; +Editv'
 Divide     .  '-Sdvn; +Editv'
+
 'Save data structures in RZ file'  .  '-rz/fil'
 'Read data structures from RZ file'  .  '-rz/fil'

>Class Box 'Shape box volumes' big_Box sm_Box
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Trd1 'Shape trd1 volumes' big_Trd1 sm_Trd1
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Trd2 'Shape trd2 volumes' big_Trd2 sm_Trd2
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Trap 'Shape trap volumes' big_Trap sm_Trap
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Tube 'Shape tube volumes' big_Tube sm_Tube
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Tubs 'Shape tubs volumes' big_Tubs sm_Tubs
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Cone 'Shape cone volumes' big_Cone sm_Cone
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Cons 'Shape cons volumes' big_Cons sm_Cons
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Sphe 'Shape sphe volumes' big_Sphe sm_Sphe
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Para 'Shape para volumes' big_Para sm_Para
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Pgon 'Shape pgon volumes' big_Pgon sm_Pgon
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Pcon 'Shape pcon volumes' big_Pcon sm_Pcon
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Eltu 'Shape eltu volumes' big_Eltu sm_Eltu
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Hype 'Shape hype volumes' big_Hype sm_Hype
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Gtra 'Shape gtra volumes' big_Gtra sm_Gtra
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Ctub 'Shape ctub volumes' big_Ctub sm_Ctub
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class New 'New_shape' big_New sm_New
 Spec       .  '+Dspec [this]'
 Tree       .  'Dtree [this] 3 111'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Print      .  '+Pvolu [that]'
 Satt       .  'Satt [this]'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
+
 Draw       .  'Draw [this]'
 Cbox       .  '-Box'
 Ctub       .  '-Tube'
 Ccon       .  '-Cone'
 Csph       .  '-Sphe'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift'
 Satt       .  'Satt [this]'
 Move       .  '-Move'

>Class Pick 'Pick_volum' big_Pick sm_Pick
+
 Print   .  '+Pvolu [this1]'
 Spec    .  'Changewk;option nzfl; next; +Dspec [this]; Resetwk; option zfl1'
 Tree    .  'Changewk;option nzfl; next; Dtree [this] 3 111; Resetwk; option zfl1'
 Satt       .  'Satt [this]'
 Edit       .  '-Editv; +Editv'
 Move3d     .  'next; +move3d [this]; -move3d [this]'
 Draw       .  '-Draw [this]'
 Cbox       .  '-Box [this]'
 Ctub       .  '-Tube [this]'
 Ccon       .  '-Cone [this]'
 Csph       .  '-Sphe [this]'
 Bomb       .  '-Bomb'
 Shif       .  '-Draw/Shift [this]'

>Class Tree 'Dtree' big_Tree sm_Tree
+
 Spec       .  'Changewk; option nzfl; next; +Dspec [this]; Resetwk; option zfl1'
 Satt       .  'Satt [this]'
 Spec3d     .  'box [this] 0 1000 0 1000 -1000 1000; +D3dspec [this]; _
-D3dspec [this]'
 Draw       .  '-Draw [this]'
 Edit       .  '-Editv; +Editv'
 Move3d     .  'next; +move3d [this]; -move3d [this]'

>Class Arrow 'Levels' big_Arrow sm_Arrow
+
 Tree       .  'Next; Dtree [this1] [this] 111'
 Spec       .  'Changewk; option nzfl; next; +Dspec [this1]; Resetwk; option zfl1'
 Satt       .  'Satt [this1]'

>Browse MATE 'Materials data structure' GXOBJ
 List       .  ' '
 Def_mat    .  '-Smate'
 Def_mix    .  '-Smixt'

>Class Elem 'Basic materials' big_Elem sm_Elem
 Edit       .  '-Smate [that]'
 Print      .  '+Pmate [that]'
 Plot_x-sec .  '-Drmat [that]'

>Class Mixt 'Mixtures and compounds' big_Mixt sm_Mixt
 Edit       .  '-Smixt [that]'
 Print      .  '+Pmate [that]'
 Plot_x-sec .  '-Drmat [that]'

>Browse TMED 'Tracking medium parameters' GXOBJ
 List       .  ' '
 Define     .  '-Stmed'

>Class Med 'Tracking media' big_Med sm_Med
 Edit_med   .  '-Stmed [that]'
 Ed_cut_mec .  '-Stpar [that]'
 Print      .  '+Ptmed [that]'

>Browse PART 'Particles data structure' GXOBJ
 List       .  ' '
 Define     .  '-Spart'

>Class Part 'Particles' big_Part sm_Part
 Edit       .  '-Spart [that]'
 Print      .  '+Ppart [that]'

>Browse KINE 'Kinematics data structure' GXOBJ
 List       .  ' '

>Class Kine 'Tracks' big_Track sm_Track
 Print      .  '+Prkine [that]'
+
 Print      .  '+Prkine [this]'

>Browse HITS 'Hits data structure' GXOBJ
 List       .  ' '

>Class /Hitset 'Sethit' big_Set sm_Set
 List       .  ' '
 Print      .  '+Phits [this]'
+
 Print      .  '+Phits [this]'

>Class Hitdet 'Dethit' big_Det sm_Det
 Print      .  '+Phits * [this]'
+
 Print      .  '+Phits [this1] [this] 0'

>Class Hitnum 'Numhit' big_Num sm_Num
+
 Print      .  '+Phits [this2] [this1] [this]'

>Browse ROTM 'Rotation matrix' GXOBJ
 List       .  ' '
 Create     .  '-Srotm'

>Class Rmatr 'Rotation matrix' big_Rmatr sm_Rmatr
 Edit       .  '-Srotm [that]'
 Print      .  '+Protm [that]'

>Browse VIEW 'View banks in memory' GXOBJ
 List       .  ' '
 Open       .  '-Dopen'
 Close      .  '+Dclose'
!Delete     .  '-G/del'

>Class VB 'View banks id' big_VB sm_VB
 Show       .  'Dshow [that]'
 Zoom       .  '-Zoom'
 Lens       .  '-Lens'
+
 Zoom       .  '-Zoom'
 Show       .  '+Dshow [that]'
 Lens       .  '-Lens'

>Icon_bitmaps

+DECK,  G321X, T=CC.
/*
 * $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
 *
 * $Log: geanx321.car100,v $
 * Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
 * Imported sources
 *
 * Revision 1.1.1.1  1995/10/24 10:19:37  cernlib
 * Geant
 *
 */
/*CMZ :          24/08/95  15.30.04  by  S.Ravndal*/
+SELF, IF=-KUIP95A.

/*-- Author :*/
/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 950303      Generation date: Thu Aug 24 15:18:48 1995
 *
 * Input file: geant321x.doc
 */

#if !defined(F77_LCASE) && !defined(F77_UCASE) && !defined(F77_USCORE)
#  if defined(__EXTENDED__) && !defined(IBM370) && !defined(_IBMR2)
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */

typedef struct _BrAction {      /*                                         */
  struct _BrAction *next;       /* link to next action binding             */
  BrActFlag   flags;            /*                                         */
  char       *text;             /* text line in menu                       */
  char       *user_text;        /* user text overriding CDF text (malloced)*/
  char       *accel;            /* accelerator                             */
  char       *exec;             /* action commands                         */
  SUBROUTINE *call_F;           /* action routine                          */
  IntFunc    *call_C;           /* action function                         */
  BrActTag    tag;              /* for which window the action is defined  */
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */

typedef struct _KmIcon {        /*                                         */
  struct _KmIcon *next;         /* link to next icon                       */
  char       *name;             /* unique identifier name                  */
  int         width;            /* width of the pixmap                     */
  int         height;           /* height of the pixmap                    */
  char       *bitmap;           /* bitmap data                             */
  KmPixmap    pix;              /* filled in Motif part                    */
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */

typedef enum {                  /*                                         */
  KmButtSensitive       = 0x00, /* sensitive button                        */
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */

extern struct {                        /*
    */   /* indirect calls to avoid linking HIGZ
    */   IntFunc    *graf_info_C;      /* pass display, open and close
 (ixmotif)  */   SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)
            */   SUBROUTINE *graf_pick_F;      /* identifying graphics objects
 (IGOBJ)    */   SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)
            */   SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)
            */   /* optional routines for Motif customization
            */   pCharFunc  *user_FallBk_C;    /* get application fallbacks
            */   IntFunc    *user_TopWid_C;    /* pass toplevel widget
 identifiers        */ } klnkaddr;                     /*
                    */

typedef enum {                  /*                                         */
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */

typedef struct {                /* file name                               */
  char         *filter_default; /* filter wildcard                         */
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */

typedef KmParInt KmParReal;     /* real and int have the same fields       */
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */

typedef struct _KmCommand {     /*                                         */
  struct _KmCommand *next;      /* link to next command                    */
  char         *path;           /* command path                            */
  char         *name;           /* command name                            */
  int           hidden;         /* flag if command is invisible            */
  int           level;          /* depth of submenus                       */
  int           total;          /* total number of parameters              */
  int           mandatory;      /* number of mandatory parameters          */
  KmParameter **par;            /* list of total parameter descriptions    */
  int           list_par;       /* index+1 of parameter taking a list      */
  int           xcount;         /* count number of action calls            */
  SUBROUTINE   *action_F;       /* action routine                          */
  IntFunc      *action_C;       /* action routine                          */
  SUBROUTINE   *user_help_F;    /* user help routine                       */
  pCharFunc    *user_help_C;    /* user help routine                       */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
  int           argc;           /* number of arguments entered             */
  char        **argv;           /* argc argument values                    */
  char         *argline;        /* argument line as entered                */
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */

typedef struct _KmMenu {        /*                                         */
  struct _KmMenu *next;         /* link to next menu                       */
  struct _KmMenu *down;         /* link to submenu                         */
  char         *path;           /* path of parent menu                     */
  char         *name;           /* menu name                               */
  int           level;          /* depth of submenus                       */
  KmCommand    *cmds;           /* link to first command                   */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */

#ifdef F77_LCASE
#  define gkdraw_ gkdraw
#  define gxdraw_ gxdraw
#  define gxpick_ gxpick
#endif

#ifdef F77_UCASE
#  define gkdraw_ GKDRAW
#  define gxdraw_ GXDRAW
#  define gxpick_ GXPICK
#endif

#ifdef IBM370
#  pragma linkage(GKDRAW,FORTRAN)
#  pragma linkage(GXDRAW,FORTRAN)
#  pragma linkage(GXPICK,FORTRAN)
#endif

extern void gkdraw_();
extern void gxdraw_();
extern void gxpick_();

void gkdraw_()
{

static KmParReal   _GEANT_CVOL_VALCUT_XCUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_VALCUT_XCUT = { "XCUT", 4,
 "x coordinate of cutted value", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_VALCUT_XCUT_type };
static KmParReal   _GEANT_CVOL_VALCUT_YCUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_VALCUT_YCUT = { "YCUT", 4,
 "y coordinate of cutted value", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_VALCUT_YCUT_type };
static KmParReal   _GEANT_CVOL_VALCUT_ZCUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_VALCUT_ZCUT = { "ZCUT", 4,
 "z coordinate of cutted value", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_VALCUT_ZCUT_type };
static KmParameter *_GEANT_CVOL_VALCUT_parameters[] = {
 &_GEANT_CVOL_VALCUT_XCUT, &_GEANT_CVOL_VALCUT_YCUT, &_GEANT_CVOL_VALCUT_ZCUT
 };
static char *_GEANT_CVOL_VALCUT_guidance[] = {
 "It allows the cutting in the ray-tracing. All the volumes are cutted",
 "from XCUT to +BIG along the x axis, from YCUT to +BIG along the y axis",
 "and from ZCUT to +BIG along the z axis." };
static KmCommand _GEANT_CVOL_VALCUT = {  (KmCommand*)0, "/GEANT/CVOL/VALCUT",
 "VALCUT", 0, 2, 3, 3, _GEANT_CVOL_VALCUT_parameters, 0, 0, gxdraw_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_CVOL_VALCUT_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_SPHE_CNVV = { "CNVV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_SPHE_RMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_RMAX = { "RMAX", 4,
 " External radius of sphere             ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_SPHE_RMAX_type };
static KmParReal   _GEANT_CVOL_SPHE_XMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_XMED = { "XMED", 4,
 " Center X coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_SPHE_XMED_type };
static KmParReal   _GEANT_CVOL_SPHE_YMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_YMED = { "YMED", 4,
 " Center Y coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_SPHE_YMED_type };
static KmParReal   _GEANT_CVOL_SPHE_ZMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_ZMED = { "ZMED", 4,
 " Center Z coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_SPHE_ZMED_type };
static KmParameter *_GEANT_CVOL_SPHE_parameters[] = { &_GEANT_CVOL_SPHE_CNVV,
 &_GEANT_CVOL_SPHE_RMAX, &_GEANT_CVOL_SPHE_XMED, &_GEANT_CVOL_SPHE_YMED,
 &_GEANT_CVOL_SPHE_ZMED };
static char *_GEANT_CVOL_SPHE_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a sphere; the sphere has the given parameters and is placed in",
 "the MARS according to the given coordinates of its center.",
 "See also CVOL. The following commands clip by a sphere,",
 "positioned according to the given parameters, the volume specified",
 "by NAME (a valid string for the NAME of the volume",
 "can be found using the DTREE command).", "EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " sphe * 500 0 0 500", " draw NAME 40 40 0 10 10 .01 .01", " box ." };
static KmCommand _GEANT_CVOL_SPHE = { &_GEANT_CVOL_VALCUT, "/GEANT/CVOL/SPHE",
 "SPHE", 0, 2, 5, 1, _GEANT_CVOL_SPHE_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _GEANT_CVOL_SPHE_guidance, 0, (char**)0,
 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_CONE_CNVV = { "CNVV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_CONE_RMAX1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_RMAX1 = { "RMAX1", 5,
 " Min external radius                   ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_CONE_RMAX1_type };
static KmParReal   _GEANT_CVOL_CONE_RMAX2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_RMAX2 = { "RMAX2", 5,
 " Max external radius                   ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_CONE_RMAX2_type };
static KmParReal   _GEANT_CVOL_CONE_ZDEM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_ZDEM = { "ZDEM", 4,
 " Half length of cone axis              ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_CONE_ZDEM_type };
static KmParReal   _GEANT_CVOL_CONE_XMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_XMED = { "XMED", 4,
 " Center X coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_CONE_XMED_type };
static KmParReal   _GEANT_CVOL_CONE_YMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_YMED = { "YMED", 4,
 " Center Y coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_CONE_YMED_type };
static KmParReal   _GEANT_CVOL_CONE_ZMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_ZMED = { "ZMED", 4,
 " Center Z coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_CONE_ZMED_type };
static KmParameter *_GEANT_CVOL_CONE_parameters[] = { &_GEANT_CVOL_CONE_CNVV,
 &_GEANT_CVOL_CONE_RMAX1, &_GEANT_CVOL_CONE_RMAX2, &_GEANT_CVOL_CONE_ZDEM,
 &_GEANT_CVOL_CONE_XMED, &_GEANT_CVOL_CONE_YMED, &_GEANT_CVOL_CONE_ZMED };
static char *_GEANT_CVOL_CONE_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a cone; the cone has the given parameters and is placed in",
 "the MARS according to the given coordinates of its center.",
 "See also CVOL.", "The following commands will clip by a cone,",
 "positioned according the given parameters, the volume specified",
 "by NAME (a valid string for the NAME of the volume",
 "can be found using the DTREE command).", " EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " cone * 1 750 1000 0 0 1000", " draw NAME 40 40 0 10 10 .01 .01", " box ." };
static KmCommand _GEANT_CVOL_CONE = { &_GEANT_CVOL_SPHE, "/GEANT/CVOL/CONE",
 "CONE", 0, 2, 7, 1, _GEANT_CVOL_CONE_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 16, _GEANT_CVOL_CONE_guidance, 0, (char**)0,
 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_TUBE_CNVV = { "CNVV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_TUBE_RMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_RMAX = { "RMAX", 4,
 " External radius of tube               ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_TUBE_RMAX_type };
static KmParReal   _GEANT_CVOL_TUBE_ZDEM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_ZDEM = { "ZDEM", 4,
 " Half length of tube axis              ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_TUBE_ZDEM_type };
static KmParReal   _GEANT_CVOL_TUBE_XMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_XMED = { "XMED", 4,
 " Center X coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_TUBE_XMED_type };
static KmParReal   _GEANT_CVOL_TUBE_YMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_YMED = { "YMED", 4,
 " Center Y coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_TUBE_YMED_type };
static KmParReal   _GEANT_CVOL_TUBE_ZMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_ZMED = { "ZMED", 4,
 " Center Z coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_TUBE_ZMED_type };
static KmParameter *_GEANT_CVOL_TUBE_parameters[] = { &_GEANT_CVOL_TUBE_CNVV,
 &_GEANT_CVOL_TUBE_RMAX, &_GEANT_CVOL_TUBE_ZDEM, &_GEANT_CVOL_TUBE_XMED,
 &_GEANT_CVOL_TUBE_YMED, &_GEANT_CVOL_TUBE_ZMED };
static char *_GEANT_CVOL_TUBE_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a tube; the tube has the given parameters and is placed in",
 "the MARS according the given coordinates of its center.", "See also CVOL.",
 "The following commands will clip, by a tube,",
 "positioned according to the given parameters, the volume specified",
 "by NAME (a valid string for the NAME of the volume",
 "can be found using the DTREE command).", " EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " tube * 500 1000 500 0 0", " draw NAME 40 40 0 10 10 .01 .01", " box ." };
static KmCommand _GEANT_CVOL_TUBE = { &_GEANT_CVOL_CONE, "/GEANT/CVOL/TUBE",
 "TUBE", 0, 2, 6, 1, _GEANT_CVOL_TUBE_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 16, _GEANT_CVOL_TUBE_guidance, 0, (char**)0,
 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_BOX_CNNV = { "CNNV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_BOX_XMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_XMIN = { "XMIN", 4,
 " Lower limit of the Shape X coordinate ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_XMIN_type };
static KmParReal   _GEANT_CVOL_BOX_XMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_XMAX = { "XMAX", 4,
 " Upper limit of the Shape X coordinate ", "-9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_XMAX_type };
static KmParReal   _GEANT_CVOL_BOX_YMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_YMIN = { "YMIN", 4,
 " Lower limit of the Shape Y coordinate ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_YMIN_type };
static KmParReal   _GEANT_CVOL_BOX_YMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_YMAX = { "YMAX", 4,
 " Upper limit of the Shape Y coordinate ", "-9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_YMAX_type };
static KmParReal   _GEANT_CVOL_BOX_ZMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_ZMIN = { "ZMIN", 4,
 " Lower limit of the Shape Z coordinate ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_ZMIN_type };
static KmParReal   _GEANT_CVOL_BOX_ZMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_ZMAX = { "ZMAX", 4,
 " Upper limit of the Shape Z coordinate ", "-9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_ZMAX_type };
static KmParameter *_GEANT_CVOL_BOX_parameters[] = { &_GEANT_CVOL_BOX_CNNV,
 &_GEANT_CVOL_BOX_XMIN, &_GEANT_CVOL_BOX_XMAX, &_GEANT_CVOL_BOX_YMIN,
 &_GEANT_CVOL_BOX_YMAX, &_GEANT_CVOL_BOX_ZMIN, &_GEANT_CVOL_BOX_ZMAX };
static char *_GEANT_CVOL_BOX_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a box placed in the MARS according the values of the given",
 "coordinates. See also CVOL.", "The following commands will clip by a box,",
 "with a vertex at the origin, the volume specified by NAME (a valid",
 "string for the NAME of the volume can be found using the DTREE command).",
 " EXAMPLE -", " dopt hide on", " satt * seen -2",
 " draw NAME 40 40 0 10 10 .01 .01", " next",
 " box NAME 0 1000 0 1000 0 1000", " draw NAME 40 40 0 10 10 .01 .01",
 " box ." };
static KmCommand _GEANT_CVOL_BOX = { &_GEANT_CVOL_TUBE, "/GEANT/CVOL/BOX",
 "BOX", 0, 2, 7, 1, _GEANT_CVOL_BOX_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GEANT_CVOL_BOX_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DUVIEW_NAME = { "NAME", 4, "Detector name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DUVIEW_TYPE = { "TYPE", 4, "View name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DUVIEW_CPXTYP = { "CPXTYP", 6,
 "Complexity name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DUVIEW_IVIEW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DUVIEW_IVIEW = { "IVIEW", 5,
 "View number where picture is stored", "0", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DUVIEW_IVIEW_type };
static KmParameter *_GEANT_DRAWING_DUVIEW_parameters[] = {
 &_GEANT_DRAWING_DUVIEW_NAME, &_GEANT_DRAWING_DUVIEW_TYPE,
 &_GEANT_DRAWING_DUVIEW_CPXTYP, &_GEANT_DRAWING_DUVIEW_IVIEW };
static char *_GEANT_DRAWING_DUVIEW_guidance[] = {
 " CALL GUVIEW(name,type,cpxtyp,iview)" };
static KmCommand _GEANT_DRAWING_DUVIEW = {  (KmCommand*)0,
 "/GEANT/DRAWING/DUVIEW", "DUVIEW", 0, 2, 4, 3,
 _GEANT_DRAWING_DUVIEW_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_DRAWING_DUVIEW_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DCHIT_CHUSET = { "CHUSET", 6,
 "User set identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DCHIT_CHUDET = { "CHUDET", 6,
 "User detector identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DCHIT_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_ITRA = { "ITRA", 4,
 "Number of the selected track", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DCHIT_ITRA_type };
static KmParInt    _GEANT_DRAWING_DCHIT_ISYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_ISYMB = { "ISYMB", 5,
 "Character selection number", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DCHIT_ISYMB_type };
static KmParReal   _GEANT_DRAWING_DCHIT_SIZMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_SIZMAX = { "SIZMAX", 6,
 "Maximum character size (cm)", "1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCHIT_SIZMAX_type };
static KmParInt    _GEANT_DRAWING_DCHIT_IHIT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_IHIT = { "IHIT", 4,
 "Index of array HITS", "4", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DCHIT_IHIT_type };
static KmParReal   _GEANT_DRAWING_DCHIT_HITMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_HITMIN = { "HITMIN", 6,
 "Lower boundary of HITS(IHIT)", "0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCHIT_HITMIN_type };
static KmParReal   _GEANT_DRAWING_DCHIT_HITMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_HITMAX = { "HITMAX", 6,
 "Upper boundary of HITS(IHIT)", "0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCHIT_HITMAX_type };
static KmParameter *_GEANT_DRAWING_DCHIT_parameters[] = {
 &_GEANT_DRAWING_DCHIT_CHUSET, &_GEANT_DRAWING_DCHIT_CHUDET,
 &_GEANT_DRAWING_DCHIT_ITRA, &_GEANT_DRAWING_DCHIT_ISYMB,
 &_GEANT_DRAWING_DCHIT_SIZMAX, &_GEANT_DRAWING_DCHIT_IHIT,
 &_GEANT_DRAWING_DCHIT_HITMIN, &_GEANT_DRAWING_DCHIT_HITMAX };
static char *_GEANT_DRAWING_DCHIT_guidance[] = {
 " CALL GDCHIT(chuset,chudet,itra,isymb,sizmax,ihit,hitmin,hitmax)",
 "The character plotted at each hit point may be chosen via",
 "CSYMB; isymb is composed as:",
 "      -1   (small) hardware points             (fast)",
 "       0   software crosses                    (default)",
 " 840,850   empty/full circles                  (slow)",
 " 841,851   empty/full squares                  (slow)",
 " 842,852   empty/full triangles (up)           (slow)",
 " 843,853   empty diamond/full triangle (down)  (slow)",
 " 844,854   empty/full stars                    (slow)",
 "Except for isymb=-1 the SIZE of the character on the screen",
 "is a function of HITS(IHIT), the array containing the calorimeter",
 "quantity, with HITMIN and HITMAX defining its range.",
 "The maximum character size (used in overflow) is SIZMAX.",
 " SIZE = SIZMAX * ( HITS(IHIT) - HITMIN ) / HITMAX" };
static KmCommand _GEANT_DRAWING_DCHIT = { &_GEANT_DRAWING_DUVIEW,
 "/GEANT/DRAWING/DCHIT", "DCHIT", 0, 2, 8, 0, _GEANT_DRAWING_DCHIT_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 15,
 _GEANT_DRAWING_DCHIT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_KHITS_CHUSET = { "CHUSET", 6,
 "User set identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_KHITS_CHUDET = { "CHUDET", 6,
 "User detector identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_KHITS_EPSILO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_KHITS_EPSILO = { "EPSILO", 6,
 "Pick aperture", "0.1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_KHITS_EPSILO_type };
static KmParameter *_GEANT_DRAWING_KHITS_parameters[] = {
 &_GEANT_DRAWING_KHITS_CHUSET, &_GEANT_DRAWING_KHITS_CHUDET,
 &_GEANT_DRAWING_KHITS_EPSILO };
static char *_GEANT_DRAWING_KHITS_guidance[] = {
 " CALL GKHITS(chuset,chudet,epsilo)",
 "The picking of hit points requires the appropriate JSET data structure",
 "have been filled",
 "and is  repeated until the character typed is 'Q' or 'q' (GKS) or the",
 "right button of the mouse is clicked (X11).",
 "If the character typed to pick is 'K' or 'k' then the",
 "kinematics of the corresponding track is also printed.",
 "The search is made of all the hits of all tracks in",
 "detector CHUDET of set CHUSET.",
 "EPSILO is the pick aperture; if EPSILO<0 its absolute value is taken",
 "and in addition the pick aperture is drawn; if EPSILO=0",
 "there is an infinite pick aperture and",
 "over all the hits the one nearest to the pick point is taken." };
static KmCommand _GEANT_DRAWING_KHITS = { &_GEANT_DRAWING_DCHIT,
 "/GEANT/DRAWING/KHITS", "KHITS", 0, 2, 3, 0, _GEANT_DRAWING_KHITS_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _GEANT_DRAWING_KHITS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DHITS_CHUSET = { "CHUSET", 6,
 "User set identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DHITS_CHUDET = { "CHUDET", 6,
 "User detector identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DHITS_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHITS_ITRA = { "ITRA", 4,
 "Number of the selected track", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DHITS_ITRA_type };
static KmParInt    _GEANT_DRAWING_DHITS_ISYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHITS_ISYMB = { "ISYMB", 5,
 "Character selection number", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DHITS_ISYMB_type };
static KmParReal   _GEANT_DRAWING_DHITS_SSYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHITS_SSYMB = { "SSYMB", 5,
 "Size of characters (cm)", "0.1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DHITS_SSYMB_type };
static KmParameter *_GEANT_DRAWING_DHITS_parameters[] = {
 &_GEANT_DRAWING_DHITS_CHUSET, &_GEANT_DRAWING_DHITS_CHUDET,
 &_GEANT_DRAWING_DHITS_ITRA, &_GEANT_DRAWING_DHITS_ISYMB,
 &_GEANT_DRAWING_DHITS_SSYMB };
static char *_GEANT_DRAWING_DHITS_guidance[] = {
 "CALL GDHITS(chuset,chudet,itra,isymb,ssymb).",
 "The character plotted at each hit point may be chosen by isymb :",
 "      -1   (small) hardware points             (fast)",
 "       0   software crosses                    (default)",
 "   840,850   empty/full circles                  (slow)",
 "   841,851   empty/full squares                  (slow)",
 "   842,852   empty/full triangles (up)           (slow)",
 "   843,853   empty diamond/full triangle (down)  (slow)",
 "   844,854   empty/full stars                    (slow)",
 "Except for isymb=-1, the size of the character on the screen can be",
 "chosen by SSYMB cm. The hit colour will follow the value of TXCI (text",
 "colour) for isymb>0, the value of PMCI (polymarkers colour) for isymb<0,",
 "the value of PLCI (polyline colour) for isymb=0." };
static KmCommand _GEANT_DRAWING_DHITS = { &_GEANT_DRAWING_KHITS,
 "/GEANT/DRAWING/DHITS", "DHITS", 0, 2, 5, 0, _GEANT_DRAWING_DHITS_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _GEANT_DRAWING_DHITS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DPART_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DPART_ITRA = { "ITRA", 4, "Track number",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DPART_ITRA_type };
static KmParInt    _GEANT_DRAWING_DPART_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DPART_ISEL = { "ISEL", 4, "Option flag",
 "11", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DPART_ISEL_type };
static KmParReal   _GEANT_DRAWING_DPART_SIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DPART_SIZE = { "SIZE", 4,
 "Character size (cm) for particle names", "0.25", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DPART_SIZE_type };
static KmParameter *_GEANT_DRAWING_DPART_parameters[] = {
 &_GEANT_DRAWING_DPART_ITRA, &_GEANT_DRAWING_DPART_ISEL,
 &_GEANT_DRAWING_DPART_SIZE };
static char *_GEANT_DRAWING_DPART_guidance[] = {
 " CALL GDPART(itra,isel,size)", " isel=x1 to draw the track number",
 " isel=1x to draw the particle name" };
static KmCommand _GEANT_DRAWING_DPART = { &_GEANT_DRAWING_DHITS,
 "/GEANT/DRAWING/DPART", "DPART", 0, 2, 3, 0, _GEANT_DRAWING_DPART_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_DRAWING_DPART_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_KXYZ_EPSILO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_KXYZ_EPSILO = { "EPSILO", 6, "Delta angle",
 "0.25", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_KXYZ_EPSILO_type };
static KmParameter *_GEANT_DRAWING_KXYZ_parameters[] = {
 &_GEANT_DRAWING_KXYZ_EPSILO };
static char *_GEANT_DRAWING_KXYZ_guidance[] = { " CALL GKXYZ(epsilo)",
 "The picking of track points requires the JXYZ data structure",
 "and is  repeated until the character typed is 'Q' or 'q' (GKS)",
 "or the right button of the mouse is clicked (X11).",
 "EPSILO is the delta angle used for picking; if EPSILO=0",
 "there is no optimization performed and",
 "over all the track points the one nearest to the pick", "point is taken." };
static KmCommand _GEANT_DRAWING_KXYZ = { &_GEANT_DRAWING_DPART,
 "/GEANT/DRAWING/KXYZ", "KXYZ", 0, 2, 1, 0, _GEANT_DRAWING_KXYZ_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_DRAWING_KXYZ_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DXYZ_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXYZ_ITRA = { "ITRA", 4, "Track number",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DXYZ_ITRA_type };
static KmParameter *_GEANT_DRAWING_DXYZ_parameters[] = {
 &_GEANT_DRAWING_DXYZ_ITRA };
static char *_GEANT_DRAWING_DXYZ_guidance[] = { " CALL GDXYZ(itra)",
 "Draw tracks previously stored via GSXYZ." };
static KmCommand _GEANT_DRAWING_DXYZ = { &_GEANT_DRAWING_KXYZ,
 "/GEANT/DRAWING/DXYZ", "DXYZ", 0, 2, 1, 0, _GEANT_DRAWING_DXYZ_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_DRAWING_DXYZ_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_ZOOM_ZFU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_ZOOM_ZFU = { "ZFU", 3,
 "Zoom factor for U-coord. (horizontal)", "2.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_ZOOM_ZFU_type };
static KmParReal   _GEANT_DRAWING_ZOOM_ZFV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_ZOOM_ZFV = { "ZFV", 3,
 "Zoom factor for V-coord. (vertical)", "2.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_ZOOM_ZFV_type };
static KmParInt    _GEANT_DRAWING_ZOOM_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_ZOOM_ISEL = { "ISEL", 4, "Options", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_ZOOM_ISEL_type };
static KmParReal   _GEANT_DRAWING_ZOOM_UZ0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_ZOOM_UZ0 = { "UZ0", 3,
 "U-coord. of the centre of zoom rectangle", "10.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_UZ0_type };
static KmParReal   _GEANT_DRAWING_ZOOM_VZ0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_ZOOM_VZ0 = { "VZ0", 3,
 "V-coord. of the centre of zoom rectangle", "10.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_VZ0_type };
static KmParReal   _GEANT_DRAWING_ZOOM_U0_type = { "0.", "20.", "0.", "20.", 0
 };
static KmParameter _GEANT_DRAWING_ZOOM_U0 = { "U0", 2,
 "U-coord. of the centre of resulting zoomed rectangle", "10.", (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_U0_type };
static KmParReal   _GEANT_DRAWING_ZOOM_V0_type = { "0.", "20.", "0.", "20.", 0
 };
static KmParameter _GEANT_DRAWING_ZOOM_V0 = { "V0", 2,
 "V-coord. of the centre of resulting zoomed rectangle", "10.", (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_V0_type };
static KmParameter *_GEANT_DRAWING_ZOOM_parameters[] = {
 &_GEANT_DRAWING_ZOOM_ZFU, &_GEANT_DRAWING_ZOOM_ZFV,
 &_GEANT_DRAWING_ZOOM_ISEL, &_GEANT_DRAWING_ZOOM_UZ0,
 &_GEANT_DRAWING_ZOOM_VZ0, &_GEANT_DRAWING_ZOOM_U0, &_GEANT_DRAWING_ZOOM_V0 };
static char *_GEANT_DRAWING_ZOOM_guidance[] = {
 " CALL GDZOOM(zfu,zfv,uz0,vz0,u0,v0)",
 "This command sets the zoom parameters that will be used by",
 "subsequent calls to the drawing routines. Each zoom operation is always",
 "relative to the status of the current zoom parameters.",
 "The scale factors in u,v are respectively  zfu,zfv.",
 "zfu=0 (or zfv=0) will act as a reset (i.e. unzoomed viewing).",
 "The zoom is computed around uz0,vz0 (user coordinates),",
 "and the resulting picture will be centered at u0,v0.",
 "The use of the space bar is replaced by the left button of the mouse",
 "running with X11:", "If isel=0 :", " 1. position the cursor at (uz0,vz0)",
 " 2. type the space bar (GKS)", "(u0,v0 are chosen at centre of screen)",
 "If isel=1 :", " 1. position the cursor at first corner of zoom rectangle",
 " 2. type the space bar (GKS)",
 " 3. position the cursor at second corner of zoom rectangle",
 " 4. type the space bar (GKS)",
 "(zfu,zfv are chosen according to the zoom rectangle;",
 "uz0,vz0 are chosen at the centre of the zoom rectangle;",
 "u0,v0 are chosen at centre of screen)", "If isel=2 :",
 " 1. position the cursor at (uz0,vz0)", " 2. type the space bar (GKS)",
 " 3. position the cursor at (u0,v0)", " 4. type the space bar (GKS)",
 "If isel=1000+n and running with X-windows:",
 " 1. n must be the identifier of an active view bank",
 " 2. clicking on the left button of the mouse will display",
 "    a zoomed view (computed around the cursor position) of",
 "    the previous drawing in a new window",
 " 3. it is now possible to iterate the zooming from the new window",
 " 4. clicking on the right button will return the control to the",
 "    main window",
 " 5. clicking on the left button it is possible to open new windows",
 "    zooming in other points of the detector",
 " 6. clicking on the right button when the main window is active",
 "    will return the control to the 'command mode'." };
static KmCommand _GEANT_DRAWING_ZOOM = { &_GEANT_DRAWING_DXYZ,
 "/GEANT/DRAWING/ZOOM", "ZOOM", 0, 2, 7, 0, _GEANT_DRAWING_ZOOM_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 39,
 _GEANT_DRAWING_ZOOM_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_LENS_KNUM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_LENS_KNUM = { "KNUM", 4,
 "View bank identifier", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_LENS_KNUM_type };
static KmParameter _GEANT_DRAWING_LENS_KSAM = { "KSAM", 4,
 "Sample mode         ", "OFF ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_LENS_parameters[] = {
 &_GEANT_DRAWING_LENS_KNUM, &_GEANT_DRAWING_LENS_KSAM };
static char *_GEANT_DRAWING_LENS_guidance[] = {
 "Interactive zooming for detectors and events when running",
 "with X-windows. Using this command, when showing the contents of a",
 "view bank, it is possible to click (left button) in two points of the",
 "drawing (which will represent the left upper corner and the right",
 "bottom corner of the part to be zoomed). After the second click",
 "a new 'window' will appear to fit the frame defined",
 "by the two clicks and it will show a zoomed view as seen from a",
 "lens with those dimensions. Clicking now the central button will",
 "translate the lens over the drawing, while clicking the right button",
 "will stop it. Moreover, clicking the left button of the",
 "mouse, the lens will increase (or decrease) its magnification",
 "power according to the backward-to-forward movement of the mouse.",
 "A click on the right button will stop this action and it is possible",
 "to restart the translation of the lens or, clicking",
 "on the right button again, to make the lens disappear. It is then possible",
 "to open another 'window-lens' with different dimensions. Thus,",
 "this command can be useful to scan detailed parts of a detector or",
 "to scan hits and showers for events. Clicking the right",
 "button when no lens is displayed will return the control to the",
 "'command mode'. The LENS is also available in sample mode when KSAM is",
 "'ON'.", "The following commands will fill a view bank and will",
 "allow to scan the detector and an event previously stored",
 "via the use of LENS (when running", "with X-windows):", " EXAMPLE -",
 " satt * seen 1", " dopen 1", " draw NAME 40 40 0 10 10 .01 .01", " dxyz 0",
 " dhits * * 0 0 .2", " dclose", " dsh 1", " lens 1 on" };
static KmCommand _GEANT_DRAWING_LENS = { &_GEANT_DRAWING_ZOOM,
 "/GEANT/DRAWING/LENS", "LENS", 0, 2, 2, 1, _GEANT_DRAWING_LENS_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 34,
 _GEANT_DRAWING_LENS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_PERSP_NAME = { "NAME", 4, "Volume name",
 "    ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GEANT_DRAWING_PERSP_DISTT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_PERSP_DISTT = { "DISTT", 5,
 "Volume distance from observer", "1000.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_PERSP_DISTT_type };
static KmParameter _GEANT_DRAWING_PERSP_SAMP = { "SAMP", 4,
 "Control to the mouse", "OFF ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_PERSP_parameters[] = {
 &_GEANT_DRAWING_PERSP_NAME, &_GEANT_DRAWING_PERSP_DISTT,
 &_GEANT_DRAWING_PERSP_SAMP };
static char *_GEANT_DRAWING_PERSP_guidance[] = {
 "To control the perspective according to the variation of the distance",
 "between the observer and the object (if PROJ has the value PERS).",
 "If SAMP is ON the control of the distance is given via the mouse." };
static KmCommand _GEANT_DRAWING_PERSP = { &_GEANT_DRAWING_LENS,
 "/GEANT/DRAWING/PERSP", "PERSP", 0, 2, 3, 2, _GEANT_DRAWING_PERSP_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_DRAWING_PERSP_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_MOVE3D_NAME = { "NAME", 4, "Volume name",
 "    ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GEANT_DRAWING_MOVE3D_THETA_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", "40.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_THETA_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", "40.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_PHI_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_PSI_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_PSI = { "PSI", 3,
 "Viewing angle psi (for 2D rotation)", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_PSI_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_U0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", "10.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_U0_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_V0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_V0_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_SU = { "SU", 2,
 "Scale factor for U-coord.", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_SU_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_SV = { "SV", 2,
 "Scale factor for V-coord.", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_SV_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_SZ_type = { "0.1", "10.", "0.1",
 "10.", 1 };
static KmParameter _GEANT_DRAWING_MOVE3D_SZ = { "SZ", 2, "Scale zoom factor",
 "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_MOVE3D_SZ_type };
static char *_GEANT_DRAWING_MOVE3D_NOPT_range[] = { "T", "H" };
static char *_GEANT_DRAWING_MOVE3D_NOPT_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_MOVE3D_NOPT_type = {
 _GEANT_DRAWING_MOVE3D_NOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_MOVE3D_NOPT = { "NOPT", 4,
 "T=tracks,H=hits", "    ", (char*)0, 8, 2, _GEANT_DRAWING_MOVE3D_NOPT_range,
 2, _GEANT_DRAWING_MOVE3D_NOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_MOVE3D_NOPT_type };
static KmParameter *_GEANT_DRAWING_MOVE3D_parameters[] = {
 &_GEANT_DRAWING_MOVE3D_NAME, &_GEANT_DRAWING_MOVE3D_THETA,
 &_GEANT_DRAWING_MOVE3D_PHI, &_GEANT_DRAWING_MOVE3D_PSI,
 &_GEANT_DRAWING_MOVE3D_U0, &_GEANT_DRAWING_MOVE3D_V0,
 &_GEANT_DRAWING_MOVE3D_SU, &_GEANT_DRAWING_MOVE3D_SV,
 &_GEANT_DRAWING_MOVE3D_SZ, &_GEANT_DRAWING_MOVE3D_NOPT };
static char *_GEANT_DRAWING_MOVE3D_guidance[] = {
 "Same functionality of the command MOVE interfaced with MOTIF." };
static KmCommand _GEANT_DRAWING_MOVE3D = { &_GEANT_DRAWING_PERSP,
 "/GEANT/DRAWING/MOVE3D", "MOVE3D", 0, 2, 10, 1,
 _GEANT_DRAWING_MOVE3D_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_DRAWING_MOVE3D_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_MOVE_NAME = { "NAME", 4, "Volume name",
 "    ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GEANT_DRAWING_MOVE_NOPT = { "NOPT", 4,
 "S=sample mode,T=tracks,H=hits", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_MOVE_parameters[] = {
 &_GEANT_DRAWING_MOVE_NAME, &_GEANT_DRAWING_MOVE_NOPT };
static char *_GEANT_DRAWING_MOVE_guidance[] = {
 "Positioning some daughter volumes inside a 'mother', it can be",
 "important to check if overlaps between such volumes have occurred.",
 "Instead of putting the drawing in a view bank, zooming, and iterating",
 "the process for different viewing angles of the same detector, the",
 "MOVE facility has been developed (for machines running with X11):",
 "it is sufficient to draw a view of the volumes to be analysed (after",
 "setting the proper SEEN, COLO, etc. attributes) and then to enter",
 "'MOVE' followed by the same 'NAME' used for the last command DRAW.",
 "The detector will appear in a panel with five buttons at the",
 "bottom: THETA, PHI, TRASL, ZOOM, OFF. Clicking on the left button",
 "of the mouse, when the cursor is inside the THETA area, will rotate the",
 "detector along the polar angle theta according to the",
 "backward-to-forward movement of the mouse",
 "(clicking up and down the left button if",
 "not in sample mode); clicking on the right button of",
 "the mouse will stop the rotation; clicking now on the",
 "left button of the mouse when inside the PHI area will activate a",
 "rotation along the polar angle phi. In the same way, activating the",
 "TRASL button, the detector can be translated in the u,v plane",
 "of the screen according to the 2D-movement of the mouse. Finally,",
 "activating the ZOOM button, the detector will be zoomed (or unzoomed)",
 "according to the backward-to-forward movement of the mouse. Clicking on\
 the", "OFF button will return the control to the 'command mode'. The MOVE",
 "command will work also with hidden line removal and shading options",
 "(when SHAD is on the background will be black);",
 "moreover, if the volumes are clipped, exploded, shifted, etc., they",
 "will be 'MOVED' with these features as well.",
 "Tracks and hits of a previously stored physical event can be moved",
 "together with the detector, allowing a dynamical 3-D analysis of the",
 "simulated events. Clicking the central button of the mouse when a good",
 "view of the event is found, will stop any movement and the mouse will",
 "allow the normal picking capabilities first for the tracks and then for",
 "the hits. After clicking of the right button, the normal",
 "movement will restart to find another interesting view of the event",
 "and to iterate the process.", "The MOVE is also available in sample mode.",
 "The following commands will produce a drawing of a volume",
 "and then will give the control to the MOVE panel; try the following",
 "possibilities:", " EXAMPLE 1 -", " dopt hide off", " satt * seen -2",
 " draw NAME 40 40 0 10 10 .01 .01", " move NAME", " EXAMPLE 2 -",
 " dopt hide on", " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01",
 " move NAME", " EXAMPLE 3 -", " dopt shad on", " satt * colo 3",
 " satt * fill 2", " dopt edge off", " draw NAME 40 40 0 10 10 .01 .01",
 " move NAME" };
static KmCommand _GEANT_DRAWING_MOVE = { &_GEANT_DRAWING_MOVE3D,
 "/GEANT/DRAWING/MOVE", "MOVE", 0, 2, 2, 1, _GEANT_DRAWING_MOVE_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 56,
 _GEANT_DRAWING_MOVE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_DRAWING_PICK_guidance[] = {
 "Activates graphic input to identify detector elements",
 "in a cut view. Clicking on the left button of the mouse when",
 "the cursor is in a given point of the drawing and clicking again",
 "(outside the detector) will produce the following effect:",
 "a line joininig the two points will be drawn together with",
 "the name and the medium number of the volume picked",
 "with the first clicking close to the second point." };
static KmCommand _GEANT_DRAWING_PICK = { &_GEANT_DRAWING_MOVE,
 "/GEANT/DRAWING/PICK", "PICK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxpick_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7, _GEANT_DRAWING_PICK_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_DRAWING_MEASURE_guidance[] = {
 "Position the cursor on the first point (u1,v1) and hit the space bar(GKS).",
 "Position the cursor on the second point (u2,v2) and hit the space\
 bar(GKS).",
 "Clicking the left button of the mouse (X11) will have the same effect as",
 "hiting the space bar (GKS).",
 "The command will compute and print the distance in space separating",
 "the two points on the projection view. It can be useful to measure",
 "distances either between volumes or between tracks or hits." };
static KmCommand _GEANT_DRAWING_MEASURE = { &_GEANT_DRAWING_PICK,
 "/GEANT/DRAWING/MEASURE", "MEASURE", 0, 2, 0, 0, (KmParameter**)0, 0, 0,
 gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7,
 _GEANT_DRAWING_MEASURE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DHEAD_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHEAD_ISEL = { "ISEL", 4, "Option flag",
 "111110", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DHEAD_ISEL_type };
static KmParameter _GEANT_DRAWING_DHEAD_NAME = { "NAME", 4, "Title", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GEANT_DRAWING_DHEAD_CHRSIZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHEAD_CHRSIZ = { "CHRSIZ", 6,
 "Character size (cm) of title NAME", "0.6", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DHEAD_CHRSIZ_type };
static KmParameter *_GEANT_DRAWING_DHEAD_parameters[] = {
 &_GEANT_DRAWING_DHEAD_ISEL, &_GEANT_DRAWING_DHEAD_NAME,
 &_GEANT_DRAWING_DHEAD_CHRSIZ };
static char *_GEANT_DRAWING_DHEAD_guidance[] = {
 " CALL GDHEAD(isel,name,chrsiz)", "ISEL =",
 " 0      to have only the header lines",
 " xxxxx1 to add the text name centered on top of header",
 " xxxx1x to add global detector name (first volume) on left",
 " xxx1xx to add date on right",
 " xx1xxx to select thick characters for text on top of header",
 " x1xxxx to add the text 'EVENT NR x' on top of header",
 " 1xxxxx to add the text 'RUN NR x' on top of header",
 "NOTE that ISEL=x1xxx1 or ISEL=1xxxx1 are illegal choices,",
 "i.e. they generate overwritten text.", "NAME is the title",
 "and CHRSIZ the character size in cm of text name." };
static KmCommand _GEANT_DRAWING_DHEAD = { &_GEANT_DRAWING_MEASURE,
 "/GEANT/DRAWING/DHEAD", "DHEAD", 0, 2, 3, 0, _GEANT_DRAWING_DHEAD_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _GEANT_DRAWING_DHEAD_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DMAN_U_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DMAN_U = { "U", 1,
 "U-coord. (horizontal) of the centre of man", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DMAN_U_type };
static KmParReal   _GEANT_DRAWING_DMAN_V_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DMAN_V = { "V", 1,
 "V-coord. (vertical) of the centre of man", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DMAN_V_type };
static char *_GEANT_DRAWING_DMAN_TYPE_range[] = { "MAN", "WM1", "WM2", "WM3" };
static char *_GEANT_DRAWING_DMAN_TYPE_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _GEANT_DRAWING_DMAN_TYPE_type = {
 _GEANT_DRAWING_DMAN_TYPE_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DMAN_TYPE = { "TYPE", 4,
 "Man, Wm1, Wm2, Wm3", "MAN", (char*)0, 8, 4, _GEANT_DRAWING_DMAN_TYPE_range,
 4, _GEANT_DRAWING_DMAN_TYPE_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_DMAN_TYPE_type };
static KmParameter *_GEANT_DRAWING_DMAN_parameters[] = {
 &_GEANT_DRAWING_DMAN_U, &_GEANT_DRAWING_DMAN_V, &_GEANT_DRAWING_DMAN_TYPE };
static char *_GEANT_DRAWING_DMAN_guidance[] = {
 " CALL GDMAN(u,v),CALL GDWMN1(u,v),CALL GDWMN2(u,v),CALL GDWMN2(u,v)",
 "It superimposes the picure of a man or of a woman, chosen among",
 "three different ones, with the same scale factors as the detector",
 "in the current drawing." };
static KmCommand _GEANT_DRAWING_DMAN = { &_GEANT_DRAWING_DHEAD,
 "/GEANT/DRAWING/DMAN", "DMAN", 0, 2, 3, 3, _GEANT_DRAWING_DMAN_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_DRAWING_DMAN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DAXIS_X0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_X0 = { "X0", 2,
 "X-coord. of axis origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DAXIS_X0_type };
static KmParReal   _GEANT_DRAWING_DAXIS_Y0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_Y0 = { "Y0", 2,
 "Y-coord. of axis origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DAXIS_Y0_type };
static KmParReal   _GEANT_DRAWING_DAXIS_Z0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_Z0 = { "Z0", 2,
 "Z-coord. of axis origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DAXIS_Z0_type };
static KmParReal   _GEANT_DRAWING_DAXIS_DX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_DX = { "DX", 2, "Axis size", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DAXIS_DX_type };
static KmParameter *_GEANT_DRAWING_DAXIS_parameters[] = {
 &_GEANT_DRAWING_DAXIS_X0, &_GEANT_DRAWING_DAXIS_Y0, &_GEANT_DRAWING_DAXIS_Z0,
 &_GEANT_DRAWING_DAXIS_DX };
static char *_GEANT_DRAWING_DAXIS_guidance[] = { " CALL GDAXIS(x0,y0,z0,dx)",
 "This commmand superimposes the axis of the MARS on the",
 "current picture. It is useful for finding immediately the",
 "orientation of the current drawing of the detector in the space." };
static KmCommand _GEANT_DRAWING_DAXIS = { &_GEANT_DRAWING_DMAN,
 "/GEANT/DRAWING/DAXIS", "DAXIS", 0, 2, 4, 4, _GEANT_DRAWING_DAXIS_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_DRAWING_DAXIS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DSCALE_U_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DSCALE_U = { "U", 1,
 "U-coord. (horizontal) of the centre of scale", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DSCALE_U_type };
static KmParReal   _GEANT_DRAWING_DSCALE_V_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DSCALE_V = { "V", 1,
 "V-coord. (vertical) of the centre of scale", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DSCALE_V_type };
static KmParameter *_GEANT_DRAWING_DSCALE_parameters[] = {
 &_GEANT_DRAWING_DSCALE_U, &_GEANT_DRAWING_DSCALE_V };
static char *_GEANT_DRAWING_DSCALE_guidance[] = { " CALL GDSCAL(u,v)",
 "It draws a scale centered in U,V." };
static KmCommand _GEANT_DRAWING_DSCALE = { &_GEANT_DRAWING_DAXIS,
 "/GEANT/DRAWING/DSCALE", "DSCALE", 0, 2, 2, 2,
 _GEANT_DRAWING_DSCALE_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_DRAWING_DSCALE_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DVECTOR_XVECT = { "XVECT", 5,
 "Vector containing X-coord. (horizontal)", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DVECTOR_YVECT = { "YVECT", 5,
 "Vector containing Y-coord. (vertical)", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DVECTOR_NPOINT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVECTOR_NPOINT = { "NPOINT", 6,
 "Number of coord.", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DVECTOR_NPOINT_type };
static KmParameter *_GEANT_DRAWING_DVECTOR_parameters[] = {
 &_GEANT_DRAWING_DVECTOR_XVECT, &_GEANT_DRAWING_DVECTOR_YVECT,
 &_GEANT_DRAWING_DVECTOR_NPOINT };
static char *_GEANT_DRAWING_DVECTOR_guidance[] = {
 "Draw a polyline of 'npoint' point via",
 "a call to GDRAWV(xvect,yvect,npoint)",
 "where xvect and yvect are two KUIP vectors" };
static KmCommand _GEANT_DRAWING_DVECTOR = { &_GEANT_DRAWING_DSCALE,
 "/GEANT/DRAWING/DVECTOR", "DVECTOR", 0, 2, 3, 3,
 _GEANT_DRAWING_DVECTOR_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_DRAWING_DVECTOR_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DTEXT_X0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_DTEXT_X0 = { "X0", 2,
 "X-coord. (horizontal) of text string", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_X0_type };
static KmParReal   _GEANT_DRAWING_DTEXT_Y0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_DTEXT_Y0 = { "Y0", 2,
 "Y-coord. (vertical) of text string", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_Y0_type };
static KmParameter _GEANT_DRAWING_DTEXT_TEXT = { "TEXT", 4, "Text string",
 "GEANT", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
  (void*)0 };
static KmParReal   _GEANT_DRAWING_DTEXT_SIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DTEXT_SIZE = { "SIZE", 4,
 "Character size (cm)", ".5", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_SIZE_type };
static KmParReal   _GEANT_DRAWING_DTEXT_ANGLE_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DTEXT_ANGLE = { "ANGLE", 5,
 "Rotation angle (deg)", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_ANGLE_type };
static KmParInt    _GEANT_DRAWING_DTEXT_LWID_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DTEXT_LWID = { "LWID", 4, "Line width", "4",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DTEXT_LWID_type };
static char *_GEANT_DRAWING_DTEXT_CENT_range[] = { "CENT", "LEFT", "RIGH" };
static char *_GEANT_DRAWING_DTEXT_CENT_text[] = { (char*)0, (char*)0, (char*)0
 };
static KmParOption _GEANT_DRAWING_DTEXT_CENT_type = {
 _GEANT_DRAWING_DTEXT_CENT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DTEXT_CENT = { "CENT", 4,
 "Centering option", "CENT", (char*)0, 8, 3, _GEANT_DRAWING_DTEXT_CENT_range,
 3, _GEANT_DRAWING_DTEXT_CENT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_DTEXT_CENT_type };
static KmParameter *_GEANT_DRAWING_DTEXT_parameters[] = {
 &_GEANT_DRAWING_DTEXT_X0, &_GEANT_DRAWING_DTEXT_Y0,
 &_GEANT_DRAWING_DTEXT_TEXT, &_GEANT_DRAWING_DTEXT_SIZE,
 &_GEANT_DRAWING_DTEXT_ANGLE, &_GEANT_DRAWING_DTEXT_LWID,
 &_GEANT_DRAWING_DTEXT_CENT };
static char *_GEANT_DRAWING_DTEXT_guidance[] = {
 " CALL GDRAWT(x0,y0,text,size,angle,lwid,opt)",
 "It allows one to draw some text in the current picture.",
 "Now more than 160 colours are available. The text colour",
 "must be set via the command IGSET. The size of the",
 "text will follow the zooming factors in the view banks." };
static KmCommand _GEANT_DRAWING_DTEXT = { &_GEANT_DRAWING_DVECTOR,
 "/GEANT/DRAWING/DTEXT", "DTEXT", 0, 2, 7, 7, _GEANT_DRAWING_DTEXT_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5,
 _GEANT_DRAWING_DTEXT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DFSPC_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_GEANT_DRAWING_DFSPC_CSORT_range[] = { "Y", "N", "0", "1" };
static char *_GEANT_DRAWING_DFSPC_CSORT_text[] = { (char*)0, (char*)0,
 (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_DFSPC_CSORT_type = {
 _GEANT_DRAWING_DFSPC_CSORT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DFSPC_CSORT = { "CSORT", 5,
 "Alphabetic sorting flag", "N", (char*)0, 8, 4,
 _GEANT_DRAWING_DFSPC_CSORT_range, 4, _GEANT_DRAWING_DFSPC_CSORT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_DRAWING_DFSPC_CSORT_type };
static char *_GEANT_DRAWING_DFSPC_CINTER_range[] = { "I", "B", "0", "1" };
static char *_GEANT_DRAWING_DFSPC_CINTER_text[] = { (char*)0, (char*)0,
 (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_DFSPC_CINTER_type = {
 _GEANT_DRAWING_DFSPC_CINTER_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DFSPC_CINTER = { "CINTER", 6,
 "Interactive/Batch version", "I", (char*)0, 8, 4,
 _GEANT_DRAWING_DFSPC_CINTER_range, 4, _GEANT_DRAWING_DFSPC_CINTER_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_DRAWING_DFSPC_CINTER_type };
static KmParameter *_GEANT_DRAWING_DFSPC_parameters[] = {
 &_GEANT_DRAWING_DFSPC_NAME, &_GEANT_DRAWING_DFSPC_CSORT,
 &_GEANT_DRAWING_DFSPC_CINTER };
static char *_GEANT_DRAWING_DFSPC_guidance[] = {
 " CALL GDFSPC(name,isort,inter)",
 "Same as DSPEC, but it will draw the specifications for all the volumes.",
 "If the alphabetic sorting flag is YES, all pictures will be drawn in\
 ascending", "alphabetic order; isort is set to 1.",
 "If INTERACTIVE, (inter=1), the routine will prompt the user at each plot",
 "before doing a clear screen, otherwise it will clear automatically",
 "the screen before starting a new frame." };
static KmCommand _GEANT_DRAWING_DFSPC = { &_GEANT_DRAWING_DTEXT,
 "/GEANT/DRAWING/DFSPC", "DFSPC", 0, 2, 3, 1, _GEANT_DRAWING_DFSPC_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7,
 _GEANT_DRAWING_DFSPC_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_D3DSPEC_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_D3DSPEC_TETA3_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_TETA3 = { "TETA3", 5, "Theta angle",
 "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_D3DSPEC_TETA3_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_PHI3_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_PHI3 = { "PHI3", 4, "Phi angle",
 "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_D3DSPEC_PHI3_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_PSI3_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_PSI3 = { "PSI3", 4, "Psi angle",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_D3DSPEC_PSI3_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_U03_type = { "-40.", "40.", "-40.",
 "40.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_U03 = { "U03", 3,
 "U-coord. (horizontal) of volume origin", "10.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_D3DSPEC_U03_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_V03_type = { "-40.", "40.", "-40.",
 "40.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_V03 = { "V03", 3,
 "V-coord. (vertical) of volume origin", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_D3DSPEC_V03_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_ZM3_type = { "0.00001", "10.",
 "0.00001", "10.", 5 };
static KmParameter _GEANT_DRAWING_D3DSPEC_ZM3 = { "ZM3", 3,
 "Zoom factor for current size factors", "1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_D3DSPEC_ZM3_type };
static KmParameter *_GEANT_DRAWING_D3DSPEC_parameters[] = {
 &_GEANT_DRAWING_D3DSPEC_NAME, &_GEANT_DRAWING_D3DSPEC_TETA3,
 &_GEANT_DRAWING_D3DSPEC_PHI3, &_GEANT_DRAWING_D3DSPEC_PSI3,
 &_GEANT_DRAWING_D3DSPEC_U03, &_GEANT_DRAWING_D3DSPEC_V03,
 &_GEANT_DRAWING_D3DSPEC_ZM3 };
static char *_GEANT_DRAWING_D3DSPEC_guidance[] = {
 "Trough a call to GSPE3D, this command allows one to show",
 "the volume (3D views in real time), together with",
 "its geometrical specifications (if using MOTIF). The 3D drawing will",
 "be performed according the current values of the options HIDE and",
 "SHAD and according the current CVOL clipping parameters for that", "volume."
 };
static KmCommand _GEANT_DRAWING_D3DSPEC = { &_GEANT_DRAWING_DFSPC,
 "/GEANT/DRAWING/D3DSPEC", "D3DSPEC", 0, 2, 7, 1,
 _GEANT_DRAWING_D3DSPEC_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _GEANT_DRAWING_D3DSPEC_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DSPEC_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_DSPEC_parameters[] = {
 &_GEANT_DRAWING_DSPEC_NAME };
static char *_GEANT_DRAWING_DSPEC_guidance[] = {
 "Trough a call to GDSPEC(name), this command allows one to show three",
 "views of the volume (two cut-views and a 3D view), together with",
 "its geometrical specifications. The 3D drawing will",
 "be performed according the current values of the options HIDE and",
 "SHAD and according the current CVOL clipping parameters for that", "volume."
 };
static KmCommand _GEANT_DRAWING_DSPEC = { &_GEANT_DRAWING_D3DSPEC,
 "/GEANT/DRAWING/DSPEC", "DSPEC", 0, 2, 1, 1, _GEANT_DRAWING_DSPEC_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_DRAWING_DSPEC_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DTREE_NAME = { "NAME", 4, "Volume name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DRAWING_DTREE_LEVMAX_type = { "-15", "15", "-15",
 "15", 0 };
static KmParameter _GEANT_DRAWING_DTREE_LEVMAX = { "LEVMAX", 6, "Depth level",
 "3", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DTREE_LEVMAX_type };
static KmParInt    _GEANT_DRAWING_DTREE_ISELT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DTREE_ISELT = { "ISELT", 5, "Options    ",
 "111", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DTREE_ISELT_type };
static KmParameter *_GEANT_DRAWING_DTREE_parameters[] = {
 &_GEANT_DRAWING_DTREE_NAME, &_GEANT_DRAWING_DTREE_LEVMAX,
 &_GEANT_DRAWING_DTREE_ISELT };
static char *_GEANT_DRAWING_DTREE_guidance[] = {
 "This command allows the drawing of the logical tree,",
 "displaying the name, the multiplicity and other information about the\
 volumes,", "via a call to GDTREE(name,levmax,isel):",
 "if the third parameter is not given (default), the command will",
 "produce the drawing of the tree displaying, for each volume, the",
 "number of the following levels (red arrows) and of the preceeding",
 "levels (green arrows); then the control is automatically given to the",
 "mouse: clicking on the left button when the cursor is inside a volume's",
 "pave will perform a DSPEC for that volume; doing the same when the cursor",
 "is on a red arrow, will perform a DTREE for the relative volume (the",
 "number of levels displayed depending on the clicked arrow); doing the",
 "same for the 'i-th' green arrow of a given volume, will perform a DTREE",
 "for its mother-volume staying 'i' levels before.",
 "If running with X-windows, the drawing of the specification (DSPEC)",
 "is performed",
 "in a different window to speed up the scanning of the tree.",
 "Iterating this procedure it is possible to analyse very easily and quickly",
 "any kind of tree. Clicking the right button of the mouse will return",
 "the control to the command mode.", "If the ISELT parameter is given,",
 "then the TREE will work as in the",
 "previous version, with ISELT up to 10001.",
 "The following command will perform a drawing of the tree and give the",
 "control to the user via the mouse:", " EXAMPLE -", " dtree NAME 3" };
static KmCommand _GEANT_DRAWING_DTREE = { &_GEANT_DRAWING_DSPEC,
 "/GEANT/DRAWING/DTREE", "DTREE", 0, 2, 3, 0, _GEANT_DRAWING_DTREE_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 26,
 _GEANT_DRAWING_DTREE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_BOMB_BOOM_type = { "-10.", "10.", "-10.",
 "10.", 0 };
static KmParameter _GEANT_DRAWING_BOMB_BOOM = { "BOOM", 4,
 " Exploding factor for volumes position ", "0.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_BOMB_BOOM_type };
static KmParameter *_GEANT_DRAWING_BOMB_parameters[] = {
 &_GEANT_DRAWING_BOMB_BOOM };
static char *_GEANT_DRAWING_BOMB_guidance[] = {
 "To 'explode' the detector. If BOOM is positive (values smaller",
 "than 1. are suggested, but any value is possible)",
 "all the volumes are shifted by a distance",
 "proportional to BOOM along the direction between their centre",
 "and the origin of the MARS; the volumes which are symmetric",
 "with respect to this origin are simply not shown.",
 "BOOM equal to 0 resets the normal mode.",
 "A negative (greater than -1.) value of",
 "BOOM will cause an 'implosion'; for even lower values of BOOM",
 "the volumes' positions will be reflected respect to the origin.",
 "This command can be useful to improve the 3D effect for very",
 "complex detectors. The following commands will make explode the",
 "detector:", " EXAMPLE -", " dopt hide on", " satt * seen 1",
 " draw NAME 40 40 0 10 10 .01 .01", " bomb 1", " next",
 " draw NAME 40 40 0 10 10 .01 .01" };
static KmCommand _GEANT_DRAWING_BOMB = { &_GEANT_DRAWING_DTREE,
 "/GEANT/DRAWING/BOMB", "BOMB", 0, 2, 1, 1, _GEANT_DRAWING_BOMB_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 20,
 _GEANT_DRAWING_BOMB_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_SHIFT_CNVN = { "CNVN", 4,
 " Name of volume to be shifted        ", "*", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_SHIFT_XXXX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SHIFT_XXXX = { "XXXX", 4,
 " Shift along X axis                  ", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SHIFT_XXXX_type };
static KmParReal   _GEANT_DRAWING_SHIFT_YYYY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SHIFT_YYYY = { "YYYY", 4,
 " Shift along Y axis                  ", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SHIFT_YYYY_type };
static KmParReal   _GEANT_DRAWING_SHIFT_ZZZZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SHIFT_ZZZZ = { "ZZZZ", 4,
 " Shift along Z axis                  ", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SHIFT_ZZZZ_type };
static KmParameter *_GEANT_DRAWING_SHIFT_parameters[] = {
 &_GEANT_DRAWING_SHIFT_CNVN, &_GEANT_DRAWING_SHIFT_XXXX,
 &_GEANT_DRAWING_SHIFT_YYYY, &_GEANT_DRAWING_SHIFT_ZZZZ };
static char *_GEANT_DRAWING_SHIFT_guidance[] = {
 "To draw a volume shifted from its initial position when hidden",
 "line removal is ON. It can be useful if you want to extract a",
 "volume or some volumes from the detector to show them more clearly.",
 "The last requested SHIFT for each volume",
 "NAME is performed. Moreover, the SHIFT of",
 "each volume will be performed starting from where its mother has",
 "been shifted, so that it's easier to SHIFT nicely sets",
 "of volumes using the mother-daughter relationships.",
 "If '.' is given as the name of the volume",
 "to be shifted, the shifts for all volumes will be reset.",
 "The following commands will produce the translation along",
 "the Z-axis of the previously drawn volume:", " EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " shift NAME 0 0 10" };
static KmCommand _GEANT_DRAWING_SHIFT = { &_GEANT_DRAWING_BOMB,
 "/GEANT/DRAWING/SHIFT", "SHIFT", 0, 2, 4, 4, _GEANT_DRAWING_SHIFT_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 17,
 _GEANT_DRAWING_SHIFT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DXCUT_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_DXCUT_CUTTHE_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_CUTTHE = { "CUTTHE", 6,
 "Theta angle of the line normal to cut plane", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_CUTTHE_type };
static KmParReal   _GEANT_DRAWING_DXCUT_CUTPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_CUTPHI = { "CUTPHI", 6,
 "Phi angle of the line normal to cut plane", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_CUTPHI_type };
static KmParReal   _GEANT_DRAWING_DXCUT_CUTVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_CUTVAL = { "CUTVAL", 6,
 "Cut plane distance from the origin along the axis", (char*)0, (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_CUTVAL_type };
static KmParReal   _GEANT_DRAWING_DXCUT_THETA_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_THETA_type };
static KmParReal   _GEANT_DRAWING_DXCUT_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_PHI_type };
static KmParReal   _GEANT_DRAWING_DXCUT_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_U0_type };
static KmParReal   _GEANT_DRAWING_DXCUT_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DXCUT_V0_type };
static KmParReal   _GEANT_DRAWING_DXCUT_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DXCUT_SU_type };
static KmParReal   _GEANT_DRAWING_DXCUT_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DXCUT_SV_type };
static KmParameter *_GEANT_DRAWING_DXCUT_parameters[] = {
 &_GEANT_DRAWING_DXCUT_NAME, &_GEANT_DRAWING_DXCUT_CUTTHE,
 &_GEANT_DRAWING_DXCUT_CUTPHI, &_GEANT_DRAWING_DXCUT_CUTVAL,
 &_GEANT_DRAWING_DXCUT_THETA, &_GEANT_DRAWING_DXCUT_PHI,
 &_GEANT_DRAWING_DXCUT_U0, &_GEANT_DRAWING_DXCUT_V0, &_GEANT_DRAWING_DXCUT_SU,
 &_GEANT_DRAWING_DXCUT_SV };
static char *_GEANT_DRAWING_DXCUT_guidance[] = {
 " CALL GDRAWX(name,cutthe,cutphi,cutval,theta,phi,u0,v0,su,sv)",
 "The cut plane is normal to the line given by the cut angles",
 "cutthe and cutphi and placed at the distance cutval from the origin.",
 "The resulting picture is seen from the viewing angles theta,phi.",
 "If optional parameters are missing, the current values in /GCDRAW/",
 "are taken." };
static KmCommand _GEANT_DRAWING_DXCUT = { &_GEANT_DRAWING_SHIFT,
 "/GEANT/DRAWING/DXCUT", "DXCUT", 0, 2, 10, 4,
 _GEANT_DRAWING_DXCUT_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 6, _GEANT_DRAWING_DXCUT_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DCUT_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_GEANT_DRAWING_DCUT_CAXIS_range[] = { "X", "Y", "Z" };
static char *_GEANT_DRAWING_DCUT_CAXIS_text[] = { (char*)0, (char*)0, (char*)0
 };
static KmParOption _GEANT_DRAWING_DCUT_CAXIS_type = {
 _GEANT_DRAWING_DCUT_CAXIS_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DCUT_CAXIS = { "CAXIS", 5, "Axis value",
 (char*)0, (char*)0, 8, 3, _GEANT_DRAWING_DCUT_CAXIS_range, 3,
 _GEANT_DRAWING_DCUT_CAXIS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_DCUT_CAXIS_type };
static KmParReal   _GEANT_DRAWING_DCUT_CUTVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_CUTVAL = { "CUTVAL", 6,
 "Cut plane distance from the origin along the axis", (char*)0, (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DCUT_CUTVAL_type };
static KmParReal   _GEANT_DRAWING_DCUT_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DCUT_U0_type };
static KmParReal   _GEANT_DRAWING_DCUT_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCUT_V0_type };
static KmParReal   _GEANT_DRAWING_DCUT_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCUT_SU_type };
static KmParReal   _GEANT_DRAWING_DCUT_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCUT_SV_type };
static KmParameter *_GEANT_DRAWING_DCUT_parameters[] = {
 &_GEANT_DRAWING_DCUT_NAME, &_GEANT_DRAWING_DCUT_CAXIS,
 &_GEANT_DRAWING_DCUT_CUTVAL, &_GEANT_DRAWING_DCUT_U0,
 &_GEANT_DRAWING_DCUT_V0, &_GEANT_DRAWING_DCUT_SU, &_GEANT_DRAWING_DCUT_SV };
static char *_GEANT_DRAWING_DCUT_guidance[] = {
 " CALL GDRAWC(name,iaxis,cutval,u0,v0,su,sv)",
 "The cut plane is normal to caxis (X,Y,Z), corresponding to iaxis (1,2,3),",
 "and placed at the distance cutval from the origin.",
 "The resulting picture is seen from the the same axis.",
 "If optional parameters are missing, the current values in /GCDRAW/",
 "are taken.",
 "When HIDE Mode is ON, it is possible to get the same effect with",
 "the CVOL/BOX command." };
static KmCommand _GEANT_DRAWING_DCUT = { &_GEANT_DRAWING_DXCUT,
 "/GEANT/DRAWING/DCUT", "DCUT", 0, 2, 7, 3, _GEANT_DRAWING_DCUT_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_DRAWING_DCUT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DVOLUME_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_N = { "N", 1,
 "Number of elements in arrays LNAMES and LNUMBS", "1", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DVOLUME_N_type };
static KmParameter _GEANT_DRAWING_DVOLUME_NAMNUM = { "NAMNUM", 6,
 "Volume names and numbers (ex. \"NAME1,NR1,NAME2,NR2\")", (char*)0, (char*)0,
 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_GEANT_DRAWING_DVOLUME_CHNRS_range[] = { "MARS", "DRS" };
static char *_GEANT_DRAWING_DVOLUME_CHNRS_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_DVOLUME_CHNRS_type = {
 _GEANT_DRAWING_DVOLUME_CHNRS_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DVOLUME_CHNRS = { "CHNRS", 5,
 "Reference system used", "MARS", (char*)0, 8, 2,
 _GEANT_DRAWING_DVOLUME_CHNRS_range, 2, _GEANT_DRAWING_DVOLUME_CHNRS_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_DRAWING_DVOLUME_CHNRS_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_THETA_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DVOLUME_THETA_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DVOLUME_PHI_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_PSI_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_PSI = { "PSI", 3,
 "Viewing angle psi (for 2D rotation)", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_PSI_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DVOLUME_U0_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_V0_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_SU_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_SV_type };
static KmParameter *_GEANT_DRAWING_DVOLUME_parameters[] = {
 &_GEANT_DRAWING_DVOLUME_N, &_GEANT_DRAWING_DVOLUME_NAMNUM,
 &_GEANT_DRAWING_DVOLUME_CHNRS, &_GEANT_DRAWING_DVOLUME_THETA,
 &_GEANT_DRAWING_DVOLUME_PHI, &_GEANT_DRAWING_DVOLUME_PSI,
 &_GEANT_DRAWING_DVOLUME_U0, &_GEANT_DRAWING_DVOLUME_V0,
 &_GEANT_DRAWING_DVOLUME_SU, &_GEANT_DRAWING_DVOLUME_SV };
static char *_GEANT_DRAWING_DVOLUME_guidance[] = {
 " CALL GDRVOL(n,lnames,lnumbs,nrs,theta,phi,psi,u0,v0,su,sv)",
 "N is the number of levels from the top of the geometry structure",
 "to the volume lnames(n),lnumbs(n) to be drawn.",
 "NAMNUM contain the arrays lnames and lnumbs,",
 "identifying the path, in pairs and separated by commas; for",
 "example (with n=2) :", "'lname(1),lnumbs(1),lname(2),lnumbs(2) '",
 "CHNRS is the name of the reference system used: MARS for MAster Reference",
 "System or DRS for Daughter Reference System.",
 "NRS=0 for MARS or NRS<>0 for DRS",
 "If optional parameters are missing, the current values in /GCDRAW/",
 "are taken." };
static KmCommand _GEANT_DRAWING_DVOLUME = { &_GEANT_DRAWING_DCUT,
 "/GEANT/DRAWING/DVOLUME", "DVOLUME", 0, 2, 10, 3,
 _GEANT_DRAWING_DVOLUME_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 12, _GEANT_DRAWING_DVOLUME_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_RANG5D_X1MIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_X1MIN = { "X1MIN", 5,
 "x coordinate min", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_X1MIN_type };
static KmParReal   _GEANT_DRAWING_RANG5D_X1MAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_X1MAX = { "X1MAX", 5,
 "x coordinate max", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_X1MAX_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Y1MIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Y1MIN = { "Y1MIN", 5,
 "y coordinate min", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Y1MIN_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Y1MAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Y1MAX = { "Y1MAX", 5,
 "y coordinate max", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Y1MAX_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Z1MIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Z1MIN = { "Z1MIN", 5,
 "z coordinate min", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Z1MIN_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Z1MAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Z1MAX = { "Z1MAX", 5,
 "z coordinate max", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Z1MAX_type };
static KmParameter *_GEANT_DRAWING_RANG5D_parameters[] = {
 &_GEANT_DRAWING_RANG5D_X1MIN, &_GEANT_DRAWING_RANG5D_X1MAX,
 &_GEANT_DRAWING_RANG5D_Y1MIN, &_GEANT_DRAWING_RANG5D_Y1MAX,
 &_GEANT_DRAWING_RANG5D_Z1MIN, &_GEANT_DRAWING_RANG5D_Z1MAX };
static char *_GEANT_DRAWING_RANG5D_guidance[] = {
 "It sets the range for the x,y,z variables." };
static KmCommand _GEANT_DRAWING_RANG5D = { &_GEANT_DRAWING_DVOLUME,
 "/GEANT/DRAWING/RANG5D", "RANG5D", 0, 2, 6, 6,
 _GEANT_DRAWING_RANG5D_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_DRAWING_RANG5D_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_VAR5D_TSEQTO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TSEQTO = { "TSEQTO", 6,
 "total sequential time", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TSEQTO_type };
static KmParInt    _GEANT_DRAWING_VAR5D_NPROC_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_NPROC = { "NPROC", 5,
 "number of processors", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_VAR5D_NPROC_type };
static KmParInt    _GEANT_DRAWING_VAR5D_NMPTOT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_NMPTOT = { "NMPTOT", 6,
 "number of message passing", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_VAR5D_NMPTOT_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TOTMBY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TOTMBY = { "TOTMBY", 6,
 "total megabytes transfert", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TOTMBY_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TSEQ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TSEQ = { "TSEQ", 4,
 "not parallelized code", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TSEQ_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TLAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TLAT = { "TLAT", 4, "latency time",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TLAT_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TNET_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TNET = { "TNET", 4,
 "network speed in Mbytes/sec", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TNET_type };
static KmParameter *_GEANT_DRAWING_VAR5D_parameters[] = {
 &_GEANT_DRAWING_VAR5D_TSEQTO, &_GEANT_DRAWING_VAR5D_NPROC,
 &_GEANT_DRAWING_VAR5D_NMPTOT, &_GEANT_DRAWING_VAR5D_TOTMBY,
 &_GEANT_DRAWING_VAR5D_TSEQ, &_GEANT_DRAWING_VAR5D_TLAT,
 &_GEANT_DRAWING_VAR5D_TNET };
static char *_GEANT_DRAWING_VAR5D_guidance[] = {
 "It sets the values of the parameters expressed in the formula and",
 "specify which variables must be assumed as x,y,z (setting their value",
 "to 1001,1002,1003, respectively)." };
static KmCommand _GEANT_DRAWING_VAR5D = { &_GEANT_DRAWING_RANG5D,
 "/GEANT/DRAWING/VAR5D", "VAR5D", 0, 2, 7, 7, _GEANT_DRAWING_VAR5D_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_DRAWING_VAR5D_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_SPOT_XLPOS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_XLPOS = { "XLPOS", 5,
 "x coordinate of light source", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SPOT_XLPOS_type };
static KmParReal   _GEANT_DRAWING_SPOT_YLPOS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_YLPOS = { "YLPOS", 5,
 "y coordinate of light source", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SPOT_YLPOS_type };
static KmParReal   _GEANT_DRAWING_SPOT_ZLPOS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_ZLPOS = { "ZLPOS", 5,
 "z coordinate of light source", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SPOT_ZLPOS_type };
static KmParInt    _GEANT_DRAWING_SPOT_INTEN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_INTEN = { "INTEN", 5,
 "intensity of light source", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_SPOT_INTEN_type };
static KmParameter *_GEANT_DRAWING_SPOT_parameters[] = {
 &_GEANT_DRAWING_SPOT_XLPOS, &_GEANT_DRAWING_SPOT_YLPOS,
 &_GEANT_DRAWING_SPOT_ZLPOS, &_GEANT_DRAWING_SPOT_INTEN };
static char *_GEANT_DRAWING_SPOT_guidance[] = {
 "This point-like light source can be moved in the space and its intensity",
 "can be changed (INTEN going from 0 to 10) relatively to the ambience light."
 };
static KmCommand _GEANT_DRAWING_SPOT = { &_GEANT_DRAWING_VAR5D,
 "/GEANT/DRAWING/SPOT", "SPOT", 0, 2, 4, 4, _GEANT_DRAWING_SPOT_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_DRAWING_SPOT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DRAW_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_DRAW_THETA_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_DRAW_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DRAW_THETA_type };
static KmParReal   _GEANT_DRAWING_DRAW_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DRAW_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DRAW_PHI_type };
static KmParReal   _GEANT_DRAWING_DRAW_PSI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DRAW_PSI = { "PSI", 3,
 "Viewing angle psi (for 2D rotation)", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_PSI_type };
static KmParReal   _GEANT_DRAWING_DRAW_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DRAW_U0_type };
static KmParReal   _GEANT_DRAWING_DRAW_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_V0_type };
static KmParReal   _GEANT_DRAWING_DRAW_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_SU_type };
static KmParReal   _GEANT_DRAWING_DRAW_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_SV_type };
static KmParameter *_GEANT_DRAWING_DRAW_parameters[] = {
 &_GEANT_DRAWING_DRAW_NAME, &_GEANT_DRAWING_DRAW_THETA,
 &_GEANT_DRAWING_DRAW_PHI, &_GEANT_DRAWING_DRAW_PSI, &_GEANT_DRAWING_DRAW_U0,
 &_GEANT_DRAWING_DRAW_V0, &_GEANT_DRAWING_DRAW_SU, &_GEANT_DRAWING_DRAW_SV };
static char *_GEANT_DRAWING_DRAW_guidance[] = {
 " CALL GDRAW(name,theta,phi,psi,u0,v0,su,sv)",
 "If optional parameters are missing, the corresponding values are",
 "taken from the common /GCDRAW/. This command will draw the volumes,",
 "selected with their graphical attributes, set by the SATT",
 "facility. The drawing may be performed with hidden line removal",
 "and with shading effects according to the value of the options HIDE",
 "and SHAD; if the option SHAD is ON, the contour's edges can be",
 "drawn or not. If the option HIDE is ON, the detector can be",
 "exploded (BOMB), clipped with different shapes (CVOL), and some",
 "of its parts can be shifted from their original",
 "position (SHIFT). When HIDE is ON, if",
 "the drawing requires more than the available memory, the program",
 "will evaluate and display the number of missing words",
 "(so that the user can increase the",
 "size of its ZEBRA store). Finally, at the end of each drawing (with HIDE\
 on),", "the program will print messages about the memory used and",
 "statistics on the volumes' visibility.",
 "The following commands will produce the drawing of a green",
 "volume, specified by NAME, without using the hidden line removal",
 "technique, using the hidden line removal technique,",
 "with different linewidth and colour (red), with",
 "solid colour, with shading of surfaces, and without edges.",
 "Finally, some examples are given for the ray-tracing. (A possible",
 "string for the NAME of the volume can be found using the command DTREE).",
 " EXAMPLE -", " satt * seen -2", " satt NAME colo 3",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " dopt hide on",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " satt NAME colo 2",
 " satt NAME lwid 4", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " dopt shad on", " satt * lwid 1", " satt NAME fill 1",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " satt NAME fill 3",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " dopt edge off",
 " draw NAME 40 40 0 10 10 .01 .01", " dopt rayt on", " satt * fill 20",
 " dopt mapp 1", " draw NAME 40 40 0 10 10 .01 .01", " dopt proj pers",
 " persp NAME 500", " draw NAME 40 40 0 10 10 1 1", " valcut 100 100 100",
 " dopt mapp 0", " dopt user on", " satt NAM1 seen 0", " satt NAM2 colo 2",
 " draw NAME 40 40 0 10 10 5 5" };
static KmCommand _GEANT_DRAWING_DRAW = { &_GEANT_DRAWING_SPOT,
 "/GEANT/DRAWING/DRAW", "DRAW", 0, 2, 8, 1, _GEANT_DRAWING_DRAW_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 59,
 _GEANT_DRAWING_DRAW_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_DRAWING_guidance[] = {
 "Drawing commands. These commands allow the visualization in several ways",
 "of the volumes defined in the geometrical data structure. It is possible",
 "to draw the logical tree of volumes belonging to the detector (DTREE),",
 "to show their geometrical specification (DSPEC,DFSPC), to draw them",
 "and their cut views (DRAW, DCUT). Moreover, it is possible to execute",
 "these commands when the hidden line removal option is activated; in",
 "this case, the volumes can be also either translated in the space",
 "(SHIFT), or clipped by boolean operation (CVOL). In addition, it is",
 "possible to fill the surfaces of the volumes",
 "with solid colours when the shading option (SHAD) is activated.",
 "Several tools (ZOOM, LENS) have been developed to zoom detailed parts",
 "of the detectors or to scan physical events as well.",
 "Finally, the command MOVE will allow the rotation, translation and zooming",
 "on real time parts of the detectors or tracks and hits of a simulated\
 event.",
 "Ray-tracing commands. In case the command (DOPT RAYT ON) is executed,",
 "the drawing is performed by the Geant ray-tracing;",
 "automatically, the color is assigned according to the tracking medium of\
 each",
 "volume and the volumes with a density lower/equal than the air are\
 considered",
 "transparent; if the option (USER) is set (ON) (again via the command\
 (DOPT)),",
 "the user can set color and visibility for the desired volumes via the\
 command",
 "(SATT), as usual, relatively to the attributes (COLO) and (SEEN).",
 "The resolution can be set via the command (SATT * FILL VALUE), where\
 (VALUE)",
 "is the ratio between the number of pixels drawn and 20 (user coordinates).",
 "Parallel view and perspective view are possible (DOPT PROJ PARA/PERS); in\
 the",
 "first case, we assume that the first mother volume of the tree is a box\
 with",
 "dimensions 10000 X 10000 X 10000 cm and the view point (infinetely far) is",
 "5000 cm far from the origin along the Z axis of the user coordinates; in\
 the",
 "second case, the distance between the observer and the origin of the world",
 "reference system is set in cm by the command (PERSP NAME VALUE);\
 grand-angle",
 "or telescopic effects can be achieved changing the scale factors in the\
 command", "(DRAW). When the final picture does not occupy the full window,",
 "mapping the space before tracing can speed up the drawing, but can also",
 "produce less precise results; values from 1 to 4 are allowed in the\
 command",
 "(DOPT MAPP VALUE), the mapping being more precise for increasing (VALUE);\
 for",
 "(VALUE = 0) no mapping is performed (therefore max precision and lowest\
 speed).",
 "The command (VALCUT) allows the cutting of the detector by three planes",
 "ortogonal to the x,y,z axis. The attribute (LSTY) can be set by the\
 command",
 "SATT for any desired volume and can assume values from 0 to 7; it\
 determines",
 "the different light processing to be performed for different materials:",
 "0 = dark-matt, 1 = bright-matt, 2 = plastic, 3 = ceramic, 4 =\
 rough-metals,",
 "5 = shiny-metals, 6 = glass, 7 = mirror. The detector is assumed to be in\
 the",
 "dark, the ambient light luminosity is 0.2 for each basic hue (the\
 saturation",
 "is 0.9) and the observer is assumed to have a light source (therefore he\
 will",
 "produce parallel light in the case of parallel view and point-like-source",
 "light in the case of perspective view)." };
static KmMenu _GEANT_DRAWING = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/DRAWING",
 "DRAWING", 2, &_GEANT_DRAWING_DRAW, 45, _GEANT_DRAWING_guidance, 0,
 (char**)0, 0, (char**)0 };

static char *_GEANT_CVOL_guidance[] = { "Clipping commands.",
 "The hidden line removal technique is necessary to visualize properly",
 "very complex detectors. At the same time, it can be useful to visualize",
 "the inner elements of a detector in detail. For this purpose, the",
 "commands menu CVOL has been developed: these commands allow",
 "subtractions (via boolean operation) of given shapes from any part of",
 "the detector, therefore showing its inner contents. It is possible",
 "to clip each different volume by means of a different shape (BOX ,",
 "TUBE, CONE, SPHE are available). If '*' is given as the name of the",
 "volume to be clipped, all volumes are clipped by the given shape.",
 "A volume can be clipped at most twice (even by",
 "different shapes); if a volume is explicitely clipped",
 "twice, the '*' will not act on it anymore. Giving '.' as the name",
 "of the volume to be clipped will reset the clipping." };
static KmMenu _GEANT_CVOL = { &_GEANT_DRAWING,  (KmMenu*)0, "/GEANT/CVOL",
 "CVOL", 2, &_GEANT_CVOL_BOX, 14, _GEANT_CVOL_guidance, 0, (char**)0, 0,
 (char**)0 };

static char *_GEANT_guidance[] = { "GEANT specific commands." };
static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_CVOL, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 1, _GEANT_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkgcon_ gkgcon
#  define gxgcon_ gxgcon
#endif

#ifdef F77_UCASE
#  define gkgcon_ GKGCON
#  define gxgcon_ GXGCON
#endif

#ifdef IBM370
#  pragma linkage(GKGCON,FORTRAN)
#  pragma linkage(GXGCON,FORTRAN)
#endif

extern void gkgcon_();
extern void gxgcon_();

void gkgcon_()
{

static KmParInt    _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD = { "ICADD", 5,
 "Colour table index", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD_type };
static KmParInt    _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL = { "ICVAL", 5,
 "Colour table value", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_MAP_COLOR_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD,
 &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL };
static char *_GEANT_GRAPHICS_CONTROL_MAP_COLOR_guidance[] = {
 "Sets the color table LOOKTB(ICADD)=ICVAL.",
 "If ICADD=0 then LOOKTB(1:16) is taken.",
 "If ICVAL is omitted the current value of LOOKTB(ICADD) is shown." };
static KmCommand _GEANT_GRAPHICS_CONTROL_MAP_COLOR = {  (KmCommand*)0,
 "/GEANT/GRAPHICS_CONTROL/MAP_COLOR", "MAP_COLOR", 0, 2, 2, 0,
 _GEANT_GRAPHICS_CONTROL_MAP_COLOR_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_MAP_COLOR_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SPERS_DPERS_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SPERS_DPERS = { "DPERS", 5,
 "Distance from the origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GRAPHICS_CONTROL_SPERS_DPERS_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SPERS_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SPERS_DPERS };
static char *_GEANT_GRAPHICS_CONTROL_SPERS_guidance[] = {
 "Set the variable dpers in /GCDRAW/, representing",
 "the distance from the origin when using option PERSpective." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SPERS = {
 &_GEANT_GRAPHICS_CONTROL_MAP_COLOR, "/GEANT/GRAPHICS_CONTROL/SPERS", "SPERS",
 0, 2, 1, 1, _GEANT_GRAPHICS_CONTROL_SPERS_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_GRAPHICS_CONTROL_SPERS_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SIZE_XSIZE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SIZE_XSIZE = { "XSIZE", 5,
 "Size along X", "20.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GRAPHICS_CONTROL_SIZE_XSIZE_type };
static KmParReal   _GEANT_GRAPHICS_CONTROL_SIZE_YSIZE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SIZE_YSIZE = { "YSIZE", 5,
 "Size along Y", "20.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GRAPHICS_CONTROL_SIZE_YSIZE_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SIZE_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SIZE_XSIZE, &_GEANT_GRAPHICS_CONTROL_SIZE_YSIZE };
static char *_GEANT_GRAPHICS_CONTROL_SIZE_guidance[] = {
 "Set the size of the picture.",
 "On the terminal, the pictures will have the ratio YSIZE/XSIZE, and,",
 "if a metafile is produced, pictures will be YSIZE by XSIZE cm.",
 "This command sets the parameters for the normalisation transformation",
 "number 1 to [0-XSIZE], [0-YSIZE]." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SIZE = {
 &_GEANT_GRAPHICS_CONTROL_SPERS, "/GEANT/GRAPHICS_CONTROL/SIZE", "SIZE", 0, 2,
 2, 0, _GEANT_GRAPHICS_CONTROL_SIZE_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _GEANT_GRAPHICS_CONTROL_SIZE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GRAPHICS_CONTROL_DOPT_IOPT = { "IOPT", 4,
 "Option name", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DOPT_IVAL = { "IVAL", 4,
 "Option value", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DOPT_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DOPT_IOPT, &_GEANT_GRAPHICS_CONTROL_DOPT_IVAL };
static char *_GEANT_GRAPHICS_CONTROL_DOPT_guidance[] = {
 " CALL GDOPT(iopt,ival)", "To set/modify the drawing options.",
 "   IOPT   IVAL      Action", "   THRZ    ON       Draw tracks in R vs Z",
 "           OFF (D)  Draw tracks in X,Y,Z", "           180",
 "           360", "   PROJ    PARA (D) Parallel projection",
 "           PERS     Perspective",
 "   TRAK    LINE (D) Trajectory drawn with lines",
 "           POIN       \" \" with markers",
 "   HIDE    ON       Hidden line removal using the CG package",
 "           OFF (D)  No hidden line removal",
 "   SHAD    ON       Fill area and shading of surfaces.",
 "           OFF (D)  Normal hidden line removal.",
 "   RAYT    ON       Ray-tracing on.",
 "           OFF (D)  Ray-tracing off.",
 "   EDGE    OFF      Does not draw contours when shad is on.",
 "           ON  (D)  Normal shading.",
 "   MAPP    1,2,3,4  Mapping before ray-tracing.",
 "           0   (D)  No mapping.",
 "   USER    ON       User graphics options in the raytracing.",
 "           OFF (D)  Automatic graphics options." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DOPT = {
 &_GEANT_GRAPHICS_CONTROL_SIZE, "/GEANT/GRAPHICS_CONTROL/DOPT", "DOPT", 0, 2,
 2, 0, _GEANT_GRAPHICS_CONTROL_DOPT_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 23, _GEANT_GRAPHICS_CONTROL_DOPT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_NEXT_guidance[] = {
 "Clear screen (start a new picture on graphics file, if opened)." };
static KmCommand _GEANT_GRAPHICS_CONTROL_NEXT = {
 &_GEANT_GRAPHICS_CONTROL_DOPT, "/GEANT/GRAPHICS_CONTROL/NEXT", "NEXT", 0, 2,
 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_GRAPHICS_CONTROL_NEXT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_LWID_LWIDTH_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_LWID_LWIDTH = { "LWIDTH", 6,
 "Line width code", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_LWID_LWIDTH_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_LWID_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_LWID_LWIDTH };
static char *_GEANT_GRAPHICS_CONTROL_LWID_guidance[] = {
 " CALL GDLW(-abs(lwidth))" };
static KmCommand _GEANT_GRAPHICS_CONTROL_LWID = {
 &_GEANT_GRAPHICS_CONTROL_NEXT, "/GEANT/GRAPHICS_CONTROL/LWID", "LWID", 0, 2,
 1, 1, _GEANT_GRAPHICS_CONTROL_LWID_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_GRAPHICS_CONTROL_LWID_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_COLOR_ICOL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_COLOR_ICOL = { "ICOL", 4,
 "Colour code", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_COLOR_ICOL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_COLOR_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_COLOR_ICOL };
static char *_GEANT_GRAPHICS_CONTROL_COLOR_guidance[] = {
 " CALL GDCOL(-abs(icol))" };
static KmCommand _GEANT_GRAPHICS_CONTROL_COLOR = {
 &_GEANT_GRAPHICS_CONTROL_LWID, "/GEANT/GRAPHICS_CONTROL/COLOR", "COLOR", 0,
 2, 1, 1, _GEANT_GRAPHICS_CONTROL_COLOR_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_COLOR_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SCALE_GSCU_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SCALE_GSCU = { "GSCU", 4,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GRAPHICS_CONTROL_SCALE_GSCU_type };
static KmParReal   _GEANT_GRAPHICS_CONTROL_SCALE_GSCV_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SCALE_GSCV = { "GSCV", 4,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GRAPHICS_CONTROL_SCALE_GSCV_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SCALE_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SCALE_GSCU, &_GEANT_GRAPHICS_CONTROL_SCALE_GSCV };
static char *_GEANT_GRAPHICS_CONTROL_SCALE_guidance[] = {
 "Change the scale factors GSCU and GSCV in /GCDRAW/." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SCALE = {
 &_GEANT_GRAPHICS_CONTROL_COLOR, "/GEANT/GRAPHICS_CONTROL/SCALE", "SCALE", 0,
 2, 2, 2, _GEANT_GRAPHICS_CONTROL_SCALE_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_SCALE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GRAPHICS_CONTROL_SATT_NAME = { "NAME", 4,
 "Volume name", "*   ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SATT_IOPT = { "IOPT", 4,
 "Name of the attribute to be set", "DEFA", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GRAPHICS_CONTROL_SATT_IVAL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SATT_IVAL = { "IVAL", 4,
 "Value to which the attribute is to be set", "10000", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GRAPHICS_CONTROL_SATT_IVAL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SATT_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SATT_NAME, &_GEANT_GRAPHICS_CONTROL_SATT_IOPT,
 &_GEANT_GRAPHICS_CONTROL_SATT_IVAL };
static char *_GEANT_GRAPHICS_CONTROL_SATT_guidance[] = {
 " CALL GSATT(name,iopt,ival)", "name='*' stands for all the volumes.",
 "iopt can be chosen among the following :",
 " 'WORK'   0=volume name is inactive for the tracking",
 "          1=volume name is active for the tracking (default)",
 " 'SEEN'   0=volume name is invisible",
 "          1=volume name is visible (default)",
 "         -1=volume invisible with all its descendants in the tree",
 "         -2=volume visible but not its descendants in the tree",
 " 'LSTY'   line style 1,2,3,... (default=1)",
 "          LSTY=7 will produce a very precise approximation for",
 "          revolution bodies.",
 " 'LWID'   line width -7,...,1,2,3,..7 (default=1)",
 "          LWID<0 will act as abs(LWID) was set for the volume",
 "          and for all the levels below it. When SHAD is 'ON', LWID",
 "          represent the linewidth of the scan lines filling the surfaces",
 "          (whereas the FILL value represent their number). Therefore",
 "          tuning this parameter will help to obtain the desired",
 "          quality/performance ratio.",
 " 'COLO'   colour code -166,...,1,2,..166 (default=1)",
 "          n=1=black",
 "          n=2=red;    n=17+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=3=green;  n=67+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=4=blue;   n=117+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=5=yellow; n=42+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=6=violet; n=142+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=7=lightblue; n=92+m, m=0,25, increasing luminosity according to\
 'm';", "          colour=n*10+m, m=1,2,...9, will produce the same colour",
 "          as 'n', but with increasing luminosity according to 'm';",
 "          COLO<0 will act as if abs(COLO) was set for the volume",
 "          and for all the levels below it.",
 "          When for a volume the attribute FILL is > 1 (and the",
 "          option SHAD is on), the ABS of its colour code must be < 8",
 "          because an automatic shading of its faces will be",
 "          performed.",
 " 'FILL'   (1992) fill area  -7,...,0,1,...7 (default=0)",
 "          when option SHAD is 'on' the FILL attribute of any",
 "          volume can be set different from 0 (normal drawing);",
 "          if it is set to 1, the faces of such volume will be filled",
 "          with solid colours; if ABS(FILL) is > 1, then a light",
 "          source is placed along the observer line, and the faces of",
 "          such volumes will be painted by colours whose luminosity",
 "          will depend on the amount of light reflected;",
 "          if ABS(FILL) = 1, then it is possible to use all the 166",
 "          colours of the colour table, becouse the automatic shading",
 "          is not performed;",
 "          for increasing values of FILL the drawing will be performed",
 "          with higher and higher resolution improving the quality (the",
 "          number of scan lines used to fill the faces increases with\
 FILL);", "          it is possible to set different values of FILL",
 "          for different volumes, in order to optimize at the same time",
 "          the performance and the quality of the picture;",
 "          FILL<0 will act as if abs(FILL) was set for the volume",
 "          and for all the levels below it.",
 "          This kind of drawing can be saved in 'picture files'",
 "          or in view banks.", "          0=drawing without fill area",
 "          1=faces filled with solid colours and resolution = 6",
 "          2=lowest resolution (very fast)",
 "          3=default resolution", "          4=.................",
 "          5=.................", "          6=.................",
 "          7=max resolution",
 "          Finally, if a coloured background is desired, the FILL",
 "          attribute for the first volume of the tree must be set",
 "          equal to -abs(colo), colo being >0 and <166.",
 " 'SET '   set number associated to volume name",
 " 'DET '   detector number associated to volume name",
 " 'DTYP'   detector type (1,2)" };
static KmCommand _GEANT_GRAPHICS_CONTROL_SATT = {
 &_GEANT_GRAPHICS_CONTROL_SCALE, "/GEANT/GRAPHICS_CONTROL/SATT", "SATT", 0, 2,
 3, 0, _GEANT_GRAPHICS_CONTROL_SATT_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 70, _GEANT_GRAPHICS_CONTROL_SATT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SSETVA_RVAL_type = { "-10.", "10.",
 "-10.", "10.", 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SSETVA_RVAL = { "RVAL", 4,
 "Attribute value", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GRAPHICS_CONTROL_SSETVA_RVAL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SSETVA_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SSETVA_RVAL };
static char *_GEANT_GRAPHICS_CONTROL_SSETVA_guidance[] = {
 "Set current attribute value." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SSETVA = {
 &_GEANT_GRAPHICS_CONTROL_SATT, "/GEANT/GRAPHICS_CONTROL/SSETVA", "SSETVA", 0,
 2, 1, 0, _GEANT_GRAPHICS_CONTROL_SSETVA_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_SSETVA_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GRAPHICS_CONTROL_SSETAT_IOPT = { "IOPT", 4,
 "Attribute name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SSETAT_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SSETAT_IOPT };
static char *_GEANT_GRAPHICS_CONTROL_SSETAT_guidance[] = {
 "Set current attribute." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SSETAT = {
 &_GEANT_GRAPHICS_CONTROL_SSETVA, "/GEANT/GRAPHICS_CONTROL/SSETAT", "SSETAT",
 0, 2, 1, 1, _GEANT_GRAPHICS_CONTROL_SSETAT_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_SSETAT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_RESETWK_guidance[] = { "CALL GRESWK",
 "It deactivate the previosly activated workstation and reactivate the",
 "default one." };
static KmCommand _GEANT_GRAPHICS_CONTROL_RESETWK = {
 &_GEANT_GRAPHICS_CONTROL_SSETAT, "/GEANT/GRAPHICS_CONTROL/RESETWK",
 "RESETWK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_RESETWK_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_CHANGEWK_guidance[] = { "CALL GCHNWK",
 "It open a new workstation (if not already opened) and activate it",
 "(deactivating the default one)." };
static KmCommand _GEANT_GRAPHICS_CONTROL_CHANGEWK = {
 &_GEANT_GRAPHICS_CONTROL_RESETWK, "/GEANT/GRAPHICS_CONTROL/CHANGEWK",
 "CHANGEWK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_CHANGEWK_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_DCLOSE_guidance[] = { " CALL GDCLOS",
 "It closes the currently open view bank; it must be called after the",
 "end of the drawing to be stored." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DCLOSE = {
 &_GEANT_GRAPHICS_CONTROL_CHANGEWK, "/GEANT/GRAPHICS_CONTROL/DCLOSE",
 "DCLOSE", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_DCLOSE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_DELETE_IVIEW_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DELETE_IVIEW = { "IVIEW", 5,
 "View number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_DELETE_IVIEW_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DELETE_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DELETE_IVIEW };
static char *_GEANT_GRAPHICS_CONTROL_DELETE_guidance[] = {
 " CALL GDELET(iview)", "It deletes a view bank from memory." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DELETE = {
 &_GEANT_GRAPHICS_CONTROL_DCLOSE, "/GEANT/GRAPHICS_CONTROL/DELETE", "DELETE",
 0, 2, 1, 1, _GEANT_GRAPHICS_CONTROL_DELETE_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_GRAPHICS_CONTROL_DELETE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW = { "IVIEW", 5,
 "View number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DSHOW_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW };
static char *_GEANT_GRAPHICS_CONTROL_DSHOW_guidance[] = {
 " CALL GDSHOW(iview)",
 "It shows on the screen the contents of a view bank. It",
 "can be called after a view bank has been closed." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DSHOW = {
 &_GEANT_GRAPHICS_CONTROL_DELETE, "/GEANT/GRAPHICS_CONTROL/DSHOW", "DSHOW", 0,
 2, 1, 0, _GEANT_GRAPHICS_CONTROL_DSHOW_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_GRAPHICS_CONTROL_DSHOW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW = { "IVIEW", 5,
 "View number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DOPEN_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW };
static char *_GEANT_GRAPHICS_CONTROL_DOPEN_guidance[] = {
 " CALL GDOPEN(iview)",
 "When a drawing is very complex and requires a long time to be",
 "executed, it can be useful to store it in a view bank: after a",
 "call to DOPEN and the execution of the drawing (nothing will",
 "appear on the screen), and after a necessary call to DCLOSE,",
 "the contents of the bank can be displayed in a very fast way",
 "through a call to DSHOW; therefore, the detector can be easily",
 "zoomed many times in different ways. Please note that the pictures",
 "with solid colours can now be stored in a view bank or in 'PICTURE FILES'."
 };
static KmCommand _GEANT_GRAPHICS_CONTROL_DOPEN = {
 &_GEANT_GRAPHICS_CONTROL_DSHOW, "/GEANT/GRAPHICS_CONTROL/DOPEN", "DOPEN", 0,
 2, 1, 1, _GEANT_GRAPHICS_CONTROL_DOPEN_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _GEANT_GRAPHICS_CONTROL_DOPEN_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_guidance[] = {
 "Graphics control commands." };
static KmMenu _GEANT_GRAPHICS_CONTROL = {  (KmMenu*)0,  (KmMenu*)0,
 "/GEANT/GRAPHICS_CONTROL", "GRAPHICS_CONTROL", 2,
 &_GEANT_GRAPHICS_CONTROL_DOPEN, 1, _GEANT_GRAPHICS_CONTROL_guidance, 0,
 (char**)0, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_GRAPHICS_CONTROL, "/GEANT",
 "GEANT", 1,  (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gklist_ gklist
#  define gxlist_ gxlist
#endif

#ifdef F77_UCASE
#  define gklist_ GKLIST
#  define gxlist_ GXLIST
#endif

#ifdef IBM370
#  pragma linkage(GKLIST,FORTRAN)
#  pragma linkage(GXLIST,FORTRAN)
#endif

extern void gklist_();
extern void gxlist_();

void gklist_()
{

static KmParameter _GEANT_LISTS_RSAV_LRSAVE_1 = { "LRSAVE_1", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_2 = { "LRSAVE_2", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_3 = { "LRSAVE_3", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_4 = { "LRSAVE_4", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_5 = { "LRSAVE_5", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_6 = { "LRSAVE_6", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_7 = { "LRSAVE_7", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_8 = { "LRSAVE_8", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_9 = { "LRSAVE_9", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_10 = { "LRSAVE_10", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_11 = { "LRSAVE_11", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_12 = { "LRSAVE_12", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_13 = { "LRSAVE_13", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_14 = { "LRSAVE_14", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_15 = { "LRSAVE_15", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_16 = { "LRSAVE_16", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_17 = { "LRSAVE_17", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_18 = { "LRSAVE_18", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_19 = { "LRSAVE_19", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_20 = { "LRSAVE_20", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_RSAV_parameters[] = {
 &_GEANT_LISTS_RSAV_LRSAVE_1, &_GEANT_LISTS_RSAV_LRSAVE_2,
 &_GEANT_LISTS_RSAV_LRSAVE_3, &_GEANT_LISTS_RSAV_LRSAVE_4,
 &_GEANT_LISTS_RSAV_LRSAVE_5, &_GEANT_LISTS_RSAV_LRSAVE_6,
 &_GEANT_LISTS_RSAV_LRSAVE_7, &_GEANT_LISTS_RSAV_LRSAVE_8,
 &_GEANT_LISTS_RSAV_LRSAVE_9, &_GEANT_LISTS_RSAV_LRSAVE_10,
 &_GEANT_LISTS_RSAV_LRSAVE_11, &_GEANT_LISTS_RSAV_LRSAVE_12,
 &_GEANT_LISTS_RSAV_LRSAVE_13, &_GEANT_LISTS_RSAV_LRSAVE_14,
 &_GEANT_LISTS_RSAV_LRSAVE_15, &_GEANT_LISTS_RSAV_LRSAVE_16,
 &_GEANT_LISTS_RSAV_LRSAVE_17, &_GEANT_LISTS_RSAV_LRSAVE_18,
 &_GEANT_LISTS_RSAV_LRSAVE_19, &_GEANT_LISTS_RSAV_LRSAVE_20 };
static char *_GEANT_LISTS_RSAV_guidance[] = {
 "The command RSAV is similar to the RSAV data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_RSAV = {  (KmCommand*)0, "/GEANT/LISTS/RSAV",
 "RSAV", 0, 2, 20, 0, _GEANT_LISTS_RSAV_parameters, 0, 0, gxlist_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_LISTS_RSAV_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_RGET_LRGET_1 = { "LRGET_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_2 = { "LRGET_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_3 = { "LRGET_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_4 = { "LRGET_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_5 = { "LRGET_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_6 = { "LRGET_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_7 = { "LRGET_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_8 = { "LRGET_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_9 = { "LRGET_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_10 = { "LRGET_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_11 = { "LRGET_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_12 = { "LRGET_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_13 = { "LRGET_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_14 = { "LRGET_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_15 = { "LRGET_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_16 = { "LRGET_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_17 = { "LRGET_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_18 = { "LRGET_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_19 = { "LRGET_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_20 = { "LRGET_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_RGET_parameters[] = {
 &_GEANT_LISTS_RGET_LRGET_1, &_GEANT_LISTS_RGET_LRGET_2,
 &_GEANT_LISTS_RGET_LRGET_3, &_GEANT_LISTS_RGET_LRGET_4,
 &_GEANT_LISTS_RGET_LRGET_5, &_GEANT_LISTS_RGET_LRGET_6,
 &_GEANT_LISTS_RGET_LRGET_7, &_GEANT_LISTS_RGET_LRGET_8,
 &_GEANT_LISTS_RGET_LRGET_9, &_GEANT_LISTS_RGET_LRGET_10,
 &_GEANT_LISTS_RGET_LRGET_11, &_GEANT_LISTS_RGET_LRGET_12,
 &_GEANT_LISTS_RGET_LRGET_13, &_GEANT_LISTS_RGET_LRGET_14,
 &_GEANT_LISTS_RGET_LRGET_15, &_GEANT_LISTS_RGET_LRGET_16,
 &_GEANT_LISTS_RGET_LRGET_17, &_GEANT_LISTS_RGET_LRGET_18,
 &_GEANT_LISTS_RGET_LRGET_19, &_GEANT_LISTS_RGET_LRGET_20 };
static char *_GEANT_LISTS_RGET_guidance[] = {
 "The command RGET is similar to the RGET data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_RGET = { &_GEANT_LISTS_RSAV,
 "/GEANT/LISTS/RGET", "RGET", 0, 2, 20, 0, _GEANT_LISTS_RGET_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_RGET_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_STAT_LSTAT_1 = { "LSTAT_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_2 = { "LSTAT_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_3 = { "LSTAT_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_4 = { "LSTAT_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_5 = { "LSTAT_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_6 = { "LSTAT_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_7 = { "LSTAT_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_8 = { "LSTAT_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_9 = { "LSTAT_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_10 = { "LSTAT_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_11 = { "LSTAT_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_12 = { "LSTAT_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_13 = { "LSTAT_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_14 = { "LSTAT_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_15 = { "LSTAT_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_16 = { "LSTAT_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_17 = { "LSTAT_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_18 = { "LSTAT_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_19 = { "LSTAT_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_20 = { "LSTAT_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_STAT_parameters[] = {
 &_GEANT_LISTS_STAT_LSTAT_1, &_GEANT_LISTS_STAT_LSTAT_2,
 &_GEANT_LISTS_STAT_LSTAT_3, &_GEANT_LISTS_STAT_LSTAT_4,
 &_GEANT_LISTS_STAT_LSTAT_5, &_GEANT_LISTS_STAT_LSTAT_6,
 &_GEANT_LISTS_STAT_LSTAT_7, &_GEANT_LISTS_STAT_LSTAT_8,
 &_GEANT_LISTS_STAT_LSTAT_9, &_GEANT_LISTS_STAT_LSTAT_10,
 &_GEANT_LISTS_STAT_LSTAT_11, &_GEANT_LISTS_STAT_LSTAT_12,
 &_GEANT_LISTS_STAT_LSTAT_13, &_GEANT_LISTS_STAT_LSTAT_14,
 &_GEANT_LISTS_STAT_LSTAT_15, &_GEANT_LISTS_STAT_LSTAT_16,
 &_GEANT_LISTS_STAT_LSTAT_17, &_GEANT_LISTS_STAT_LSTAT_18,
 &_GEANT_LISTS_STAT_LSTAT_19, &_GEANT_LISTS_STAT_LSTAT_20 };
static char *_GEANT_LISTS_STAT_guidance[] = {
 "The command STAT is similar to the STAT data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_STAT = { &_GEANT_LISTS_RGET,
 "/GEANT/LISTS/STAT", "STAT", 0, 2, 20, 0, _GEANT_LISTS_STAT_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_STAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_PLOT_LPLOT_1 = { "LPLOT_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_2 = { "LPLOT_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_3 = { "LPLOT_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_4 = { "LPLOT_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_5 = { "LPLOT_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_6 = { "LPLOT_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_7 = { "LPLOT_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_8 = { "LPLOT_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_9 = { "LPLOT_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_10 = { "LPLOT_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_11 = { "LPLOT_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_12 = { "LPLOT_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_13 = { "LPLOT_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_14 = { "LPLOT_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_15 = { "LPLOT_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_16 = { "LPLOT_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_17 = { "LPLOT_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_18 = { "LPLOT_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_19 = { "LPLOT_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_20 = { "LPLOT_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_PLOT_parameters[] = {
 &_GEANT_LISTS_PLOT_LPLOT_1, &_GEANT_LISTS_PLOT_LPLOT_2,
 &_GEANT_LISTS_PLOT_LPLOT_3, &_GEANT_LISTS_PLOT_LPLOT_4,
 &_GEANT_LISTS_PLOT_LPLOT_5, &_GEANT_LISTS_PLOT_LPLOT_6,
 &_GEANT_LISTS_PLOT_LPLOT_7, &_GEANT_LISTS_PLOT_LPLOT_8,
 &_GEANT_LISTS_PLOT_LPLOT_9, &_GEANT_LISTS_PLOT_LPLOT_10,
 &_GEANT_LISTS_PLOT_LPLOT_11, &_GEANT_LISTS_PLOT_LPLOT_12,
 &_GEANT_LISTS_PLOT_LPLOT_13, &_GEANT_LISTS_PLOT_LPLOT_14,
 &_GEANT_LISTS_PLOT_LPLOT_15, &_GEANT_LISTS_PLOT_LPLOT_16,
 &_GEANT_LISTS_PLOT_LPLOT_17, &_GEANT_LISTS_PLOT_LPLOT_18,
 &_GEANT_LISTS_PLOT_LPLOT_19, &_GEANT_LISTS_PLOT_LPLOT_20 };
static char *_GEANT_LISTS_PLOT_guidance[] = {
 "The command PLOT is similar to the PLOT data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_PLOT = { &_GEANT_LISTS_STAT,
 "/GEANT/LISTS/PLOT", "PLOT", 0, 2, 20, 0, _GEANT_LISTS_PLOT_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_PLOT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_VIEW_LVIEW_1 = { "LVIEW_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_2 = { "LVIEW_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_3 = { "LVIEW_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_4 = { "LVIEW_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_5 = { "LVIEW_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_6 = { "LVIEW_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_7 = { "LVIEW_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_8 = { "LVIEW_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_9 = { "LVIEW_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_10 = { "LVIEW_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_11 = { "LVIEW_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_12 = { "LVIEW_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_13 = { "LVIEW_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_14 = { "LVIEW_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_15 = { "LVIEW_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_16 = { "LVIEW_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_17 = { "LVIEW_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_18 = { "LVIEW_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_19 = { "LVIEW_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_20 = { "LVIEW_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_VIEW_parameters[] = {
 &_GEANT_LISTS_VIEW_LVIEW_1, &_GEANT_LISTS_VIEW_LVIEW_2,
 &_GEANT_LISTS_VIEW_LVIEW_3, &_GEANT_LISTS_VIEW_LVIEW_4,
 &_GEANT_LISTS_VIEW_LVIEW_5, &_GEANT_LISTS_VIEW_LVIEW_6,
 &_GEANT_LISTS_VIEW_LVIEW_7, &_GEANT_LISTS_VIEW_LVIEW_8,
 &_GEANT_LISTS_VIEW_LVIEW_9, &_GEANT_LISTS_VIEW_LVIEW_10,
 &_GEANT_LISTS_VIEW_LVIEW_11, &_GEANT_LISTS_VIEW_LVIEW_12,
 &_GEANT_LISTS_VIEW_LVIEW_13, &_GEANT_LISTS_VIEW_LVIEW_14,
 &_GEANT_LISTS_VIEW_LVIEW_15, &_GEANT_LISTS_VIEW_LVIEW_16,
 &_GEANT_LISTS_VIEW_LVIEW_17, &_GEANT_LISTS_VIEW_LVIEW_18,
 &_GEANT_LISTS_VIEW_LVIEW_19, &_GEANT_LISTS_VIEW_LVIEW_20 };
static char *_GEANT_LISTS_VIEW_guidance[] = {
 "The command VIEW is similar to the VIEW data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_VIEW = { &_GEANT_LISTS_PLOT,
 "/GEANT/LISTS/VIEW", "VIEW", 0, 2, 20, 0, _GEANT_LISTS_VIEW_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_VIEW_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_GEOM_LGEOM_1 = { "LGEOM_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_2 = { "LGEOM_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_3 = { "LGEOM_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_4 = { "LGEOM_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_5 = { "LGEOM_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_6 = { "LGEOM_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_7 = { "LGEOM_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_8 = { "LGEOM_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_9 = { "LGEOM_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_10 = { "LGEOM_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_11 = { "LGEOM_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_12 = { "LGEOM_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_13 = { "LGEOM_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_14 = { "LGEOM_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_15 = { "LGEOM_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_16 = { "LGEOM_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_17 = { "LGEOM_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_18 = { "LGEOM_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_19 = { "LGEOM_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_20 = { "LGEOM_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_GEOM_parameters[] = {
 &_GEANT_LISTS_GEOM_LGEOM_1, &_GEANT_LISTS_GEOM_LGEOM_2,
 &_GEANT_LISTS_GEOM_LGEOM_3, &_GEANT_LISTS_GEOM_LGEOM_4,
 &_GEANT_LISTS_GEOM_LGEOM_5, &_GEANT_LISTS_GEOM_LGEOM_6,
 &_GEANT_LISTS_GEOM_LGEOM_7, &_GEANT_LISTS_GEOM_LGEOM_8,
 &_GEANT_LISTS_GEOM_LGEOM_9, &_GEANT_LISTS_GEOM_LGEOM_10,
 &_GEANT_LISTS_GEOM_LGEOM_11, &_GEANT_LISTS_GEOM_LGEOM_12,
 &_GEANT_LISTS_GEOM_LGEOM_13, &_GEANT_LISTS_GEOM_LGEOM_14,
 &_GEANT_LISTS_GEOM_LGEOM_15, &_GEANT_LISTS_GEOM_LGEOM_16,
 &_GEANT_LISTS_GEOM_LGEOM_17, &_GEANT_LISTS_GEOM_LGEOM_18,
 &_GEANT_LISTS_GEOM_LGEOM_19, &_GEANT_LISTS_GEOM_LGEOM_20 };
static char *_GEANT_LISTS_GEOM_guidance[] = {
 "The command GEOM is similar to the GEOM data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_GEOM = { &_GEANT_LISTS_VIEW,
 "/GEANT/LISTS/GEOM", "GEOM", 0, 2, 20, 0, _GEANT_LISTS_GEOM_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_GEOM_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_LPRIN_LPRIN_1 = { "LPRIN_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_2 = { "LPRIN_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_3 = { "LPRIN_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_4 = { "LPRIN_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_5 = { "LPRIN_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_6 = { "LPRIN_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_7 = { "LPRIN_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_8 = { "LPRIN_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_9 = { "LPRIN_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_10 = { "LPRIN_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_11 = { "LPRIN_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_12 = { "LPRIN_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_13 = { "LPRIN_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_14 = { "LPRIN_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_15 = { "LPRIN_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_16 = { "LPRIN_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_17 = { "LPRIN_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_18 = { "LPRIN_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_19 = { "LPRIN_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_20 = { "LPRIN_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_LPRIN_parameters[] = {
 &_GEANT_LISTS_LPRIN_LPRIN_1, &_GEANT_LISTS_LPRIN_LPRIN_2,
 &_GEANT_LISTS_LPRIN_LPRIN_3, &_GEANT_LISTS_LPRIN_LPRIN_4,
 &_GEANT_LISTS_LPRIN_LPRIN_5, &_GEANT_LISTS_LPRIN_LPRIN_6,
 &_GEANT_LISTS_LPRIN_LPRIN_7, &_GEANT_LISTS_LPRIN_LPRIN_8,
 &_GEANT_LISTS_LPRIN_LPRIN_9, &_GEANT_LISTS_LPRIN_LPRIN_10,
 &_GEANT_LISTS_LPRIN_LPRIN_11, &_GEANT_LISTS_LPRIN_LPRIN_12,
 &_GEANT_LISTS_LPRIN_LPRIN_13, &_GEANT_LISTS_LPRIN_LPRIN_14,
 &_GEANT_LISTS_LPRIN_LPRIN_15, &_GEANT_LISTS_LPRIN_LPRIN_16,
 &_GEANT_LISTS_LPRIN_LPRIN_17, &_GEANT_LISTS_LPRIN_LPRIN_18,
 &_GEANT_LISTS_LPRIN_LPRIN_19, &_GEANT_LISTS_LPRIN_LPRIN_20 };
static char *_GEANT_LISTS_LPRIN_guidance[] = {
 "The command PRIN is similar to the PRIN data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_LPRIN = { &_GEANT_LISTS_GEOM,
 "/GEANT/LISTS/LPRIN", "LPRIN", 0, 2, 20, 0, _GEANT_LISTS_LPRIN_parameters, 0,
 0, gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_LPRIN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_SETS_LSETS_1 = { "LSETS_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_2 = { "LSETS_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_3 = { "LSETS_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_4 = { "LSETS_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_5 = { "LSETS_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_6 = { "LSETS_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_7 = { "LSETS_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_8 = { "LSETS_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_9 = { "LSETS_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_10 = { "LSETS_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_11 = { "LSETS_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_12 = { "LSETS_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_13 = { "LSETS_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_14 = { "LSETS_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_15 = { "LSETS_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_16 = { "LSETS_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_17 = { "LSETS_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_18 = { "LSETS_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_19 = { "LSETS_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_20 = { "LSETS_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_SETS_parameters[] = {
 &_GEANT_LISTS_SETS_LSETS_1, &_GEANT_LISTS_SETS_LSETS_2,
 &_GEANT_LISTS_SETS_LSETS_3, &_GEANT_LISTS_SETS_LSETS_4,
 &_GEANT_LISTS_SETS_LSETS_5, &_GEANT_LISTS_SETS_LSETS_6,
 &_GEANT_LISTS_SETS_LSETS_7, &_GEANT_LISTS_SETS_LSETS_8,
 &_GEANT_LISTS_SETS_LSETS_9, &_GEANT_LISTS_SETS_LSETS_10,
 &_GEANT_LISTS_SETS_LSETS_11, &_GEANT_LISTS_SETS_LSETS_12,
 &_GEANT_LISTS_SETS_LSETS_13, &_GEANT_LISTS_SETS_LSETS_14,
 &_GEANT_LISTS_SETS_LSETS_15, &_GEANT_LISTS_SETS_LSETS_16,
 &_GEANT_LISTS_SETS_LSETS_17, &_GEANT_LISTS_SETS_LSETS_18,
 &_GEANT_LISTS_SETS_LSETS_19, &_GEANT_LISTS_SETS_LSETS_20 };
static char *_GEANT_LISTS_SETS_guidance[] = {
 "The command SETS is similar to the SETS data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_SETS = { &_GEANT_LISTS_LPRIN,
 "/GEANT/LISTS/SETS", "SETS", 0, 2, 20, 0, _GEANT_LISTS_SETS_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_SETS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_SAVE_LSAVE_1 = { "LSAVE_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_2 = { "LSAVE_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_3 = { "LSAVE_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_4 = { "LSAVE_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_5 = { "LSAVE_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_6 = { "LSAVE_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_7 = { "LSAVE_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_8 = { "LSAVE_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_9 = { "LSAVE_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_10 = { "LSAVE_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_11 = { "LSAVE_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_12 = { "LSAVE_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_13 = { "LSAVE_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_14 = { "LSAVE_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_15 = { "LSAVE_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_16 = { "LSAVE_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_17 = { "LSAVE_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_18 = { "LSAVE_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_19 = { "LSAVE_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_20 = { "LSAVE_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_SAVE_parameters[] = {
 &_GEANT_LISTS_SAVE_LSAVE_1, &_GEANT_LISTS_SAVE_LSAVE_2,
 &_GEANT_LISTS_SAVE_LSAVE_3, &_GEANT_LISTS_SAVE_LSAVE_4,
 &_GEANT_LISTS_SAVE_LSAVE_5, &_GEANT_LISTS_SAVE_LSAVE_6,
 &_GEANT_LISTS_SAVE_LSAVE_7, &_GEANT_LISTS_SAVE_LSAVE_8,
 &_GEANT_LISTS_SAVE_LSAVE_9, &_GEANT_LISTS_SAVE_LSAVE_10,
 &_GEANT_LISTS_SAVE_LSAVE_11, &_GEANT_LISTS_SAVE_LSAVE_12,
 &_GEANT_LISTS_SAVE_LSAVE_13, &_GEANT_LISTS_SAVE_LSAVE_14,
 &_GEANT_LISTS_SAVE_LSAVE_15, &_GEANT_LISTS_SAVE_LSAVE_16,
 &_GEANT_LISTS_SAVE_LSAVE_17, &_GEANT_LISTS_SAVE_LSAVE_18,
 &_GEANT_LISTS_SAVE_LSAVE_19, &_GEANT_LISTS_SAVE_LSAVE_20 };
static char *_GEANT_LISTS_SAVE_guidance[] = {
 "The command SAVE is similar to the SAVE data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_SAVE = { &_GEANT_LISTS_SETS,
 "/GEANT/LISTS/SAVE", "SAVE", 0, 2, 20, 0, _GEANT_LISTS_SAVE_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_SAVE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_GET_LGET_1 = { "LGET_1", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_2 = { "LGET_2", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_3 = { "LGET_3", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_4 = { "LGET_4", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_5 = { "LGET_5", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_6 = { "LGET_6", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_7 = { "LGET_7", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_8 = { "LGET_8", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_9 = { "LGET_9", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_10 = { "LGET_10", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_11 = { "LGET_11", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_12 = { "LGET_12", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_13 = { "LGET_13", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_14 = { "LGET_14", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_15 = { "LGET_15", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_16 = { "LGET_16", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_17 = { "LGET_17", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_18 = { "LGET_18", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_19 = { "LGET_19", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_20 = { "LGET_20", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_GET_parameters[] = {
 &_GEANT_LISTS_GET_LGET_1, &_GEANT_LISTS_GET_LGET_2, &_GEANT_LISTS_GET_LGET_3,
 &_GEANT_LISTS_GET_LGET_4, &_GEANT_LISTS_GET_LGET_5, &_GEANT_LISTS_GET_LGET_6,
 &_GEANT_LISTS_GET_LGET_7, &_GEANT_LISTS_GET_LGET_8, &_GEANT_LISTS_GET_LGET_9,
 &_GEANT_LISTS_GET_LGET_10, &_GEANT_LISTS_GET_LGET_11,
 &_GEANT_LISTS_GET_LGET_12, &_GEANT_LISTS_GET_LGET_13,
 &_GEANT_LISTS_GET_LGET_14, &_GEANT_LISTS_GET_LGET_15,
 &_GEANT_LISTS_GET_LGET_16, &_GEANT_LISTS_GET_LGET_17,
 &_GEANT_LISTS_GET_LGET_18, &_GEANT_LISTS_GET_LGET_19,
 &_GEANT_LISTS_GET_LGET_20 };
static char *_GEANT_LISTS_GET_guidance[] = {
 "The command GET is similar to the GET data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_GET = { &_GEANT_LISTS_SAVE, "/GEANT/LISTS/GET",
 "GET", 0, 2, 20, 0, _GEANT_LISTS_GET_parameters, 0, 0, gxlist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_LISTS_GET_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_HSTA_LHSTA_1 = { "LHSTA_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_2 = { "LHSTA_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_3 = { "LHSTA_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_4 = { "LHSTA_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_5 = { "LHSTA_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_6 = { "LHSTA_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_7 = { "LHSTA_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_8 = { "LHSTA_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_9 = { "LHSTA_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_10 = { "LHSTA_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_11 = { "LHSTA_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_12 = { "LHSTA_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_13 = { "LHSTA_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_14 = { "LHSTA_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_15 = { "LHSTA_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_16 = { "LHSTA_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_17 = { "LHSTA_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_18 = { "LHSTA_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_19 = { "LHSTA_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_20 = { "LHSTA_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_HSTA_parameters[] = {
 &_GEANT_LISTS_HSTA_LHSTA_1, &_GEANT_LISTS_HSTA_LHSTA_2,
 &_GEANT_LISTS_HSTA_LHSTA_3, &_GEANT_LISTS_HSTA_LHSTA_4,
 &_GEANT_LISTS_HSTA_LHSTA_5, &_GEANT_LISTS_HSTA_LHSTA_6,
 &_GEANT_LISTS_HSTA_LHSTA_7, &_GEANT_LISTS_HSTA_LHSTA_8,
 &_GEANT_LISTS_HSTA_LHSTA_9, &_GEANT_LISTS_HSTA_LHSTA_10,
 &_GEANT_LISTS_HSTA_LHSTA_11, &_GEANT_LISTS_HSTA_LHSTA_12,
 &_GEANT_LISTS_HSTA_LHSTA_13, &_GEANT_LISTS_HSTA_LHSTA_14,
 &_GEANT_LISTS_HSTA_LHSTA_15, &_GEANT_LISTS_HSTA_LHSTA_16,
 &_GEANT_LISTS_HSTA_LHSTA_17, &_GEANT_LISTS_HSTA_LHSTA_18,
 &_GEANT_LISTS_HSTA_LHSTA_19, &_GEANT_LISTS_HSTA_LHSTA_20 };
static char *_GEANT_LISTS_HSTA_guidance[] = {
 "The command HSTA is similar to the HSTA data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_HSTA = { &_GEANT_LISTS_GET, "/GEANT/LISTS/HSTA",
 "HSTA", 0, 2, 20, 0, _GEANT_LISTS_HSTA_parameters, 0, 0, gxlist_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_LISTS_HSTA_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmMenu _GEANT_LISTS = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/LISTS",
 "LISTS", 2, &_GEANT_LISTS_HSTA, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_LISTS, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkgeom_ gkgeom
#  define gxgeom_ gxgeom
#endif

#ifdef F77_UCASE
#  define gkgeom_ GKGEOM
#  define gxgeom_ GXGEOM
#endif

#ifdef IBM370
#  pragma linkage(GKGEOM,FORTRAN)
#  pragma linkage(GXGEOM,FORTRAN)
#endif

extern void gkgeom_();
extern void gxgeom_();

void gkgeom_()
{

static KmParInt    _GEANT_GEOMETRY_WEUCLID_LUN_type = { "1", "100", "1",
 "100", 0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_LUN = { "LUN", 3,
 "Logical unit of the file to be written", (char*)0, (char*)0, 4, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_WEUCLID_LUN_type };
static KmParameter _GEANT_GEOMETRY_WEUCLID_FNAME = { "FNAME", 5,
 "Name of the EUCLID file to be written", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_TOPVOL = { "TOPVOL", 6,
 "Volume name of the starting node", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_WEUCLID_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_NUMBER = { "NUMBER", 6,
 "Copy number of TOPVOL (relevant for GSPOSP)", "1", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_WEUCLID_NUMBER_type };
static KmParInt    _GEANT_GEOMETRY_WEUCLID_NLEVEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_NLEVEL = { "NLEVEL", 6,
 "Number of levels in the tree structure", "15", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_WEUCLID_NLEVEL_type };
static KmParameter *_GEANT_GEOMETRY_WEUCLID_parameters[] = {
 &_GEANT_GEOMETRY_WEUCLID_LUN, &_GEANT_GEOMETRY_WEUCLID_FNAME,
 &_GEANT_GEOMETRY_WEUCLID_TOPVOL, &_GEANT_GEOMETRY_WEUCLID_NUMBER,
 &_GEANT_GEOMETRY_WEUCLID_NLEVEL };
static char *_GEANT_GEOMETRY_WEUCLID_guidance[] = {
 "          CALL GWEUCL(LUN,FNAME)",
 "Calls the routine to write the current GEANT geometry into an ASCII file",
 "in EUCLID compatible format." };
static KmCommand _GEANT_GEOMETRY_WEUCLID = {  (KmCommand*)0,
 "/GEANT/GEOMETRY/WEUCLID", "WEUCLID", 0, 2, 5, 3,
 _GEANT_GEOMETRY_WEUCLID_parameters, 0, 0, gxgeom_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GEOMETRY_WEUCLID_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_REUCLID_LUN_type = { "1", "100", "1",
 "100", 0 };
static KmParameter _GEANT_GEOMETRY_REUCLID_LUN = { "LUN", 3,
 "Logical unit of the file to be read", (char*)0, (char*)0, 4, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_REUCLID_LUN_type };
static KmParameter _GEANT_GEOMETRY_REUCLID_FNAME = { "FNAME", 5,
 "Name of the EUCLID file to be read", (char*)0, (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_REUCLID_parameters[] = {
 &_GEANT_GEOMETRY_REUCLID_LUN, &_GEANT_GEOMETRY_REUCLID_FNAME };
static char *_GEANT_GEOMETRY_REUCLID_guidance[] = {
 "          CALL GREUCL(LUN,FNAME)",
 "Calls the routine to read into GEANT a geometry from an ASCII file",
 "written by the EUCLID-GEANT interface." };
static KmCommand _GEANT_GEOMETRY_REUCLID = { &_GEANT_GEOMETRY_WEUCLID,
 "/GEANT/GEOMETRY/REUCLID", "REUCLID", 0, 2, 2, 2,
 _GEANT_GEOMETRY_REUCLID_parameters, 0, 0, gxgeom_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GEOMETRY_REUCLID_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GEOMETRY_CADINT_FNAME = { "FNAME", 5,
 "Name of the SET file", "example.set", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_ANAME = { "ANAME", 5,
 "Name of the volume", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_CADINT_NBINS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_CADINT_NBINS = { "NBINS", 5,
 "Number of the instances", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_CADINT_NBINS_type };
static KmParInt    _GEANT_GEOMETRY_CADINT_LUNIT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_CADINT_LUNIT = { "LUNIT", 5,
 "Logical unit number for SET file", "66", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_CADINT_LUNIT_type };
static KmParInt    _GEANT_GEOMETRY_CADINT_LUNIT2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_CADINT_LUNIT2 = { "LUNIT2", 6,
 "Logical unit number for material file", "67", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_CADINT_LUNIT2_type };
static KmParameter _GEANT_GEOMETRY_CADINT_INST = { "INST", 4,
 "Name of your institute", "CERN", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_SITE = { "SITE", 4, "Name of site",
 "MEYRIN", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_DEPT = { "DEPT", 4,
 "Name of departement", "CN", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_RESP = { "RESP", 4,
 "Name of sender", "god_knows_who", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_CADINT_parameters[] = {
 &_GEANT_GEOMETRY_CADINT_FNAME, &_GEANT_GEOMETRY_CADINT_ANAME,
 &_GEANT_GEOMETRY_CADINT_NBINS, &_GEANT_GEOMETRY_CADINT_LUNIT,
 &_GEANT_GEOMETRY_CADINT_LUNIT2, &_GEANT_GEOMETRY_CADINT_INST,
 &_GEANT_GEOMETRY_CADINT_SITE, &_GEANT_GEOMETRY_CADINT_DEPT,
 &_GEANT_GEOMETRY_CADINT_RESP };
static char *_GEANT_GEOMETRY_CADINT_guidance[] = {
 " CALL GTXSET(fname,aname,nbins,lunit,lunit2,inst,site,dept,resp)",
 "This command produces a SET file describing the given volume with",
 "the contents currently set visible. (Use the visibility attribute,",
 "see SATT SEEN.) The description is given as a flat assembly",
 "related to the global coordinate system.",
 "The ouput can be read into CAD systems (EUCLID-IS) trough a SET interface.",
 "A list of materials of the volumes in the SET file and the GEANT tree",
 "is written into a file with the same filename as the SET file,",
 "but with extension .mat." };
static KmCommand _GEANT_GEOMETRY_CADINT = { &_GEANT_GEOMETRY_REUCLID,
 "/GEANT/GEOMETRY/CADINT", "CADINT", 0, 2, 9, 9,
 _GEANT_GEOMETRY_CADINT_parameters, 0, 0, gxgeom_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 9, _GEANT_GEOMETRY_CADINT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_EDITV_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_EDITV_ISEL = { "ISEL", 4, "Options", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_EDITV_ISEL_type };
static KmParameter _GEANT_GEOMETRY_EDITV_NAME = { "NAME", 4, "Volume name",
 "   ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_GEANT_GEOMETRY_EDITV_parameters[] = {
 &_GEANT_GEOMETRY_EDITV_ISEL, &_GEANT_GEOMETRY_EDITV_NAME };
static char *_GEANT_GEOMETRY_EDITV_guidance[] = { " CALL GEDITV(isel,name)",
 "When the routine prompts for input parameters that do not need",
 "to be changed, type return.",
 "ISEL is used to select the editing operation to be performed:",
 " ISEL=0, CALL GGCLOS",
 " ISEL=1, to modify shape parameters PAR given by GSVOLU",
 " ISEL=2, to modify NAME given by GSVOLU",
 " ISEL=3, to delete NAME given by GSVOLU",
 " ISEL=4, to unlink NAME,NR given by GSPOS/GSDVN/GSDV..",
 " ISEL=5, to modify X0,Y0,Z0 of NAME,NR given by GSPOS",
 " ISEL=6, to modify IROT of NAME,NR given by GSPOS",
 " ISEL=7, to modify NDIV given by GSDVN",
 " ISEL=8, to modify IAXIS given by GSDVN" };
static KmCommand _GEANT_GEOMETRY_EDITV = { &_GEANT_GEOMETRY_CADINT,
 "/GEANT/GEOMETRY/EDITV", "EDITV", 0, 2, 2, 0,
 _GEANT_GEOMETRY_EDITV_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 13, _GEANT_GEOMETRY_EDITV_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_PTMED_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_PTMED_NUMB = { "NUMB", 4, "Medium ID",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_PTMED_NUMB_type };
static KmParameter *_GEANT_GEOMETRY_PTMED_parameters[] = {
 &_GEANT_GEOMETRY_PTMED_NUMB };
static char *_GEANT_GEOMETRY_PTMED_guidance[] = { " CALL GPTMED(numb)",
 "Print tracking media's specifications." };
static KmCommand _GEANT_GEOMETRY_PTMED = { &_GEANT_GEOMETRY_EDITV,
 "/GEANT/GEOMETRY/PTMED", "PTMED", 0, 2, 1, 1,
 _GEANT_GEOMETRY_PTMED_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_PTMED_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_STMED_NTMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_NTMED = { "NTMED", 5,
 "Tracking medium number", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_STMED_NTMED_type };
static KmParameter _GEANT_GEOMETRY_STMED_NAME = { "NAME", 4,
 "Tracking medium name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_STMED_NMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_NMAT = { "NMAT", 4,
 "Material number", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_STMED_NMAT_type };
static KmParInt    _GEANT_GEOMETRY_STMED_ISVOL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_ISVOL = { "ISVOL", 5,
 "Sensitive volume flag", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_STMED_ISVOL_type };
static KmParInt    _GEANT_GEOMETRY_STMED_IFIELD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_IFIELD = { "IFIELD", 6,
 "Magnetic field", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GEANT_GEOMETRY_STMED_IFIELD_type };
static KmParReal   _GEANT_GEOMETRY_STMED_FIELDM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_FIELDM = { "FIELDM", 6,
 "Max. field value (Kilogauss)", "0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_FIELDM_type };
static KmParReal   _GEANT_GEOMETRY_STMED_TMAXFD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_TMAXFD = { "TMAXFD", 6,
 "Max. angle due to field (deg/step)", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_TMAXFD_type };
static KmParReal   _GEANT_GEOMETRY_STMED_STEMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_STEMAX = { "STEMAX", 6,
 "Max. step allowed", "1.E+10", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_STEMAX_type };
static KmParReal   _GEANT_GEOMETRY_STMED_DEEMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_DEEMAX = { "DEEMAX", 6,
 "Max. fraction of energy lost in a step", "0.01", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_DEEMAX_type };
static KmParReal   _GEANT_GEOMETRY_STMED_EPSIL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_EPSIL = { "EPSIL", 5,
 "Tracking precision (cm)", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_EPSIL_type };
static KmParReal   _GEANT_GEOMETRY_STMED_STMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_STMIN = { "STMIN", 5,
 "Min. step due to continuos processes (cm)", "0.1", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_STMED_STMIN_type };
static KmParameter *_GEANT_GEOMETRY_STMED_parameters[] = {
 &_GEANT_GEOMETRY_STMED_NTMED, &_GEANT_GEOMETRY_STMED_NAME,
 &_GEANT_GEOMETRY_STMED_NMAT, &_GEANT_GEOMETRY_STMED_ISVOL,
 &_GEANT_GEOMETRY_STMED_IFIELD, &_GEANT_GEOMETRY_STMED_FIELDM,
 &_GEANT_GEOMETRY_STMED_TMAXFD, &_GEANT_GEOMETRY_STMED_STEMAX,
 &_GEANT_GEOMETRY_STMED_DEEMAX, &_GEANT_GEOMETRY_STMED_EPSIL,
 &_GEANT_GEOMETRY_STMED_STMIN };
static char *_GEANT_GEOMETRY_STMED_guidance[] = {
 "      CALL GSTMED(ntmed,name,nmat,isvol,ifield,fieldm,tmaxfd,",
 "     +            stemax,deemax,epsil,stmin,0,0)",
 "IFIELD = 0 if no magnetic field; IFIELD = -1 if user decision in GUSWIM;",
 "IFIELD = 1 if tracking performed with GRKUTA; IFIELD = 2 if tracking",
 "performed with GHELIX; IFIELD = 3 if tracking performed with GHELX3." };
static KmCommand _GEANT_GEOMETRY_STMED = { &_GEANT_GEOMETRY_PTMED,
 "/GEANT/GEOMETRY/STMED", "STMED", 0, 2, 11, 11,
 _GEANT_GEOMETRY_STMED_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 5, _GEANT_GEOMETRY_STMED_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_PROTM_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_PROTM_NUMB = { "NUMB", 4, "Matrix ID",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_PROTM_NUMB_type };
static KmParameter *_GEANT_GEOMETRY_PROTM_parameters[] = {
 &_GEANT_GEOMETRY_PROTM_NUMB };
static char *_GEANT_GEOMETRY_PROTM_guidance[] = { " CALL GPROTM(numb)",
 "Print matrixes' specifications." };
static KmCommand _GEANT_GEOMETRY_PROTM = { &_GEANT_GEOMETRY_STMED,
 "/GEANT/GEOMETRY/PROTM", "PROTM", 0, 2, 1, 1,
 _GEANT_GEOMETRY_PROTM_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_PROTM_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_SROTM_IROT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_IROT = { "IROT", 4,
 "Rotation matrix number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SROTM_IROT_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_THETA1_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_THETA1 = { "THETA1", 6,
 "Polar angle for axis I", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_THETA1_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_PHI1_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_PHI1 = { "PHI1", 4,
 "Azimuthal angle for axis I", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_PHI1_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_THETA2_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_THETA2 = { "THETA2", 6,
 "Polar angle for axis II", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_THETA2_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_PHI2_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_PHI2 = { "PHI2", 4,
 "Azimuthal angle for axis II", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_PHI2_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_THETA3_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_THETA3 = { "THETA3", 6,
 "Polar angle for axis III", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_THETA3_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_PHI3_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_PHI3 = { "PHI3", 4,
 "Azimuthal angle for axis III", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_PHI3_type };
static KmParameter *_GEANT_GEOMETRY_SROTM_parameters[] = {
 &_GEANT_GEOMETRY_SROTM_IROT, &_GEANT_GEOMETRY_SROTM_THETA1,
 &_GEANT_GEOMETRY_SROTM_PHI1, &_GEANT_GEOMETRY_SROTM_THETA2,
 &_GEANT_GEOMETRY_SROTM_PHI2, &_GEANT_GEOMETRY_SROTM_THETA3,
 &_GEANT_GEOMETRY_SROTM_PHI3 };
static char *_GEANT_GEOMETRY_SROTM_guidance[] = {
 " CALL GSROTM(irot,theta1,phi1,theta2,phi2,theta3,phi3)",
 "It defines the rotation matrix number IROT." };
static KmCommand _GEANT_GEOMETRY_SROTM = { &_GEANT_GEOMETRY_PROTM,
 "/GEANT/GEOMETRY/SROTM", "SROTM", 0, 2, 7, 7,
 _GEANT_GEOMETRY_SROTM_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_SROTM_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_PVOLU_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_PVOLU_NUMB = { "NUMB", 4, "Volume ID",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_PVOLU_NUMB_type };
static KmParameter *_GEANT_GEOMETRY_PVOLU_parameters[] = {
 &_GEANT_GEOMETRY_PVOLU_NUMB };
static char *_GEANT_GEOMETRY_PVOLU_guidance[] = { " CALL GPVOLU(numb)",
 "Prints volumes' specifications." };
static KmCommand _GEANT_GEOMETRY_PVOLU = { &_GEANT_GEOMETRY_SROTM,
 "/GEANT/GEOMETRY/PVOLU", "PVOLU", 0, 2, 1, 1,
 _GEANT_GEOMETRY_PVOLU_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_PVOLU_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GEOMETRY_SDVN_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_SDVN_MOTHER = { "MOTHER", 6,
 "Mother volume name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_SDVN_NDIV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SDVN_NDIV = { "NDIV", 4,
 "Number of divisions", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SDVN_NDIV_type };
static char *_GEANT_GEOMETRY_SDVN_CAXIS_range[] = { "X", "Y", "Z", "1", "2",
 "3" };
static char *_GEANT_GEOMETRY_SDVN_CAXIS_text[] = { (char*)0, (char*)0,
 (char*)0, (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_GEOMETRY_SDVN_CAXIS_type = {
 _GEANT_GEOMETRY_SDVN_CAXIS_text, (int*)0, (int*)0 };
static KmParameter _GEANT_GEOMETRY_SDVN_CAXIS = { "CAXIS", 5, "Axis value",
 (char*)0, (char*)0, 8, 6, _GEANT_GEOMETRY_SDVN_CAXIS_range, 6,
 _GEANT_GEOMETRY_SDVN_CAXIS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_GEOMETRY_SDVN_CAXIS_type };
static KmParameter *_GEANT_GEOMETRY_SDVN_parameters[] = {
 &_GEANT_GEOMETRY_SDVN_NAME, &_GEANT_GEOMETRY_SDVN_MOTHER,
 &_GEANT_GEOMETRY_SDVN_NDIV, &_GEANT_GEOMETRY_SDVN_CAXIS };
static char *_GEANT_GEOMETRY_SDVN_guidance[] = {
 " CALL GSDVN(name,mother,ndiv,iaxis)",
 "X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.",
 "It divides a previously defined volume." };
static KmCommand _GEANT_GEOMETRY_SDVN = { &_GEANT_GEOMETRY_PVOLU,
 "/GEANT/GEOMETRY/SDVN", "SDVN", 0, 2, 4, 4, _GEANT_GEOMETRY_SDVN_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_GEOMETRY_SDVN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_GEOMETRY_SPOS_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_SPOS_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_NUMBER = { "NUMBER", 6,
 "Copy number of the volume", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SPOS_NUMBER_type };
static KmParameter _GEANT_GEOMETRY_SPOS_MOTHER = { "MOTHER", 6,
 "Mother volume name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_GEOMETRY_SPOS_X0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_X0 = { "X0", 2,
 "X coord. of the volume in mother ref. sys.", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_SPOS_X0_type };
static KmParReal   _GEANT_GEOMETRY_SPOS_Y0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_Y0 = { "Y0", 2,
 "Y coord. of the volume in mother ref. sys.", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_SPOS_Y0_type };
static KmParReal   _GEANT_GEOMETRY_SPOS_Z0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_Z0 = { "Z0", 2,
 "Z coord. of the volume in mother ref. sys.", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_SPOS_Z0_type };
static KmParInt    _GEANT_GEOMETRY_SPOS_IROT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_IROT = { "IROT", 4,
 "Rotation matrix number w.r.t. mother ref. sys.", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_SPOS_IROT_type };
static KmParameter _GEANT_GEOMETRY_SPOS_ONLY = { "ONLY", 4, "ONLY/MANY flag",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_SPOS_parameters[] = {
 &_GEANT_GEOMETRY_SPOS_NAME, &_GEANT_GEOMETRY_SPOS_NUMBER,
 &_GEANT_GEOMETRY_SPOS_MOTHER, &_GEANT_GEOMETRY_SPOS_X0,
 &_GEANT_GEOMETRY_SPOS_Y0, &_GEANT_GEOMETRY_SPOS_Z0,
 &_GEANT_GEOMETRY_SPOS_IROT, &_GEANT_GEOMETRY_SPOS_ONLY };
static char *_GEANT_GEOMETRY_SPOS_guidance[] = {
 " CALL GSPOS(name,number,mother,x0,y0,z0,irot,only)",
 "It positions a previously defined volume in the mother." };
static KmCommand _GEANT_GEOMETRY_SPOS = { &_GEANT_GEOMETRY_SDVN,
 "/GEANT/GEOMETRY/SPOS", "SPOS", 0, 2, 8, 8, _GEANT_GEOMETRY_SPOS_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_GEOMETRY_SPOS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_GEOMETRY_SVOLU_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_SVOLU_SHAPE = { "SHAPE", 5, "Volume type",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_SVOLU_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SVOLU_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SVOLU_NUMED_type };
static KmParInt    _GEANT_GEOMETRY_SVOLU_NPAR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SVOLU_NPAR = { "NPAR", 4,
 "Number of shape parameters", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SVOLU_NPAR_type };
static KmParameter _GEANT_GEOMETRY_SVOLU_PAR = { "PAR", 3,
 "Vector containing shape parameters", (char*)0, (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_SVOLU_parameters[] = {
 &_GEANT_GEOMETRY_SVOLU_NAME, &_GEANT_GEOMETRY_SVOLU_SHAPE,
 &_GEANT_GEOMETRY_SVOLU_NUMED, &_GEANT_GEOMETRY_SVOLU_NPAR,
 &_GEANT_GEOMETRY_SVOLU_PAR };
static char *_GEANT_GEOMETRY_SVOLU_guidance[] = {
 " CALL GSVOLU(name,shape,numed,par,npar,ivolu)",
 "where par is a KUIP vector.",
 "It creates a new volume in the JVOLUM data structure." };
static KmCommand _GEANT_GEOMETRY_SVOLU = { &_GEANT_GEOMETRY_SPOS,
 "/GEANT/GEOMETRY/SVOLU", "SVOLU", 0, 2, 5, 5,
 _GEANT_GEOMETRY_SVOLU_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _GEANT_GEOMETRY_SVOLU_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GEOMETRY_OPTI_IOPTI_range[] = { "-1", "2" };
static KmParInt    _GEANT_GEOMETRY_OPTI_IOPTI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_OPTI_IOPTI = { "IOPTI", 5,
 "GSORD optimisation level", "0", (char*)0, 8, 2,
 _GEANT_GEOMETRY_OPTI_IOPTI_range, 2, _GEANT_GEOMETRY_OPTI_IOPTI_range,
 (KmParFlag)2, KmTYPE_INT, &_GEANT_GEOMETRY_OPTI_IOPTI_type };
static KmParameter *_GEANT_GEOMETRY_OPTI_parameters[] = {
 &_GEANT_GEOMETRY_OPTI_IOPTI };
static char *_GEANT_GEOMETRY_OPTI_guidance[] = {
 "This flag controls the tracking optimisation performed via the",
 "GSORD routine:", "    1 no optimisation at all; GSORD calls disabled;",
 "    0 no optimisation; only user calls to GSORD kept;",
 "    1 all non-GSORDered volumes are ordered along the best axis;",
 "    2 all volumes are ordered along the best axis." };
static KmCommand _GEANT_GEOMETRY_OPTI = { &_GEANT_GEOMETRY_SVOLU,
 "/GEANT/GEOMETRY/OPTI", "OPTI", 0, 2, 1, 1, _GEANT_GEOMETRY_OPTI_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_GEOMETRY_OPTI_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SPARA_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SPARA_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SPARA_NUMED_type };
static KmParReal   _GEANT_CREATE_SPARA_HALFX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_HALFX = { "HALFX", 5, "Half X length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SPARA_HALFX_type };
static KmParReal   _GEANT_CREATE_SPARA_HALFY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_HALFY = { "HALFY", 5, "Half Y length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SPARA_HALFY_type };
static KmParReal   _GEANT_CREATE_SPARA_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SPARA_HALFZ_type };
static KmParReal   _GEANT_CREATE_SPARA_AXIS_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SPARA_AXIS = { "AXIS", 4,
 "Angle of Y mid-faces segment to Y axis", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CREATE_SPARA_AXIS_type };
static KmParReal   _GEANT_CREATE_SPARA_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SPARA_PHI = { "PHI", 3,
 "PHI angle of Low Z mid-face to High Z mid-face segment", (char*)0, (char*)0,
 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CREATE_SPARA_PHI_type };
static KmParReal   _GEANT_CREATE_SPARA_THETA_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SPARA_THETA = { "THETA", 5,
 "THETA angle of mid-low-Z-face to mid-high-Z-face segment", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CREATE_SPARA_THETA_type };
static char *_GEANT_CREATE_SPARA_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SPARA_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SPARA_YESNO_type = {
 _GEANT_CREATE_SPARA_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SPARA_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SPARA_YESNO_range, 2,
 _GEANT_CREATE_SPARA_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SPARA_YESNO_type };
static KmParameter *_GEANT_CREATE_SPARA_parameters[] = {
 &_GEANT_CREATE_SPARA_NAME, &_GEANT_CREATE_SPARA_NUMED,
 &_GEANT_CREATE_SPARA_HALFX, &_GEANT_CREATE_SPARA_HALFY,
 &_GEANT_CREATE_SPARA_HALFZ, &_GEANT_CREATE_SPARA_AXIS,
 &_GEANT_CREATE_SPARA_PHI, &_GEANT_CREATE_SPARA_THETA,
 &_GEANT_CREATE_SPARA_YESNO };
static KmCommand _GEANT_CREATE_SPARA = {  (KmCommand*)0,
 "/GEANT/CREATE/SPARA", "SPARA", 0, 2, 9, 8, _GEANT_CREATE_SPARA_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SSPHE_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SSPHE_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SSPHE_NUMED_type };
static KmParReal   _GEANT_CREATE_SSPHE_INRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_INRAD = { "INRAD", 5, "Inside Radius",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SSPHE_INRAD_type };
static KmParReal   _GEANT_CREATE_SSPHE_OUTRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_OUTRAD = { "OUTRAD", 6,
 "Outside Radius", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_OUTRAD_type };
static KmParReal   _GEANT_CREATE_SSPHE_SPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SSPHE_SPHI = { "SPHI", 4,
 "Start of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_SPHI_type };
static KmParReal   _GEANT_CREATE_SSPHE_EPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SSPHE_EPHI = { "EPHI", 4,
 "End of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_EPHI_type };
static KmParReal   _GEANT_CREATE_SSPHE_STHETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_STHETA = { "STHETA", 6,
 "Start of section THETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_STHETA_type };
static KmParReal   _GEANT_CREATE_SSPHE_ETHETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_ETHETA = { "ETHETA", 6,
 "End of section THETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_ETHETA_type };
static char *_GEANT_CREATE_SSPHE_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SSPHE_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SSPHE_YESNO_type = {
 _GEANT_CREATE_SSPHE_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SSPHE_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SSPHE_YESNO_range, 2,
 _GEANT_CREATE_SSPHE_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SSPHE_YESNO_type };
static KmParameter *_GEANT_CREATE_SSPHE_parameters[] = {
 &_GEANT_CREATE_SSPHE_NAME, &_GEANT_CREATE_SSPHE_NUMED,
 &_GEANT_CREATE_SSPHE_INRAD, &_GEANT_CREATE_SSPHE_OUTRAD,
 &_GEANT_CREATE_SSPHE_SPHI, &_GEANT_CREATE_SSPHE_EPHI,
 &_GEANT_CREATE_SSPHE_STHETA, &_GEANT_CREATE_SSPHE_ETHETA,
 &_GEANT_CREATE_SSPHE_YESNO };
static KmCommand _GEANT_CREATE_SSPHE = { &_GEANT_CREATE_SPARA,
 "/GEANT/CREATE/SSPHE", "SSPHE", 0, 2, 9, 8, _GEANT_CREATE_SSPHE_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SCONS_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SCONS_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SCONS_NUMED_type };
static KmParReal   _GEANT_CREATE_SCONS_INRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_INRDW = { "INRDW", 5,
 "Inside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_INRDW_type };
static KmParReal   _GEANT_CREATE_SCONS_OUTRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_OUTRDW = { "OUTRDW", 6,
 "Outside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_OUTRDW_type };
static KmParReal   _GEANT_CREATE_SCONS_INRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_INRUP = { "INRUP", 5,
 "Inside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_INRUP_type };
static KmParReal   _GEANT_CREATE_SCONS_OUTRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_OUTRUP = { "OUTRUP", 6,
 "Outside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_OUTRUP_type };
static KmParReal   _GEANT_CREATE_SCONS_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SCONS_HALFZ_type };
static KmParReal   _GEANT_CREATE_SCONS_SPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SCONS_SPHI = { "SPHI", 4,
 "Start of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_SPHI_type };
static KmParReal   _GEANT_CREATE_SCONS_EPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SCONS_EPHI = { "EPHI", 4,
 "End of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_EPHI_type };
static char *_GEANT_CREATE_SCONS_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SCONS_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SCONS_YESNO_type = {
 _GEANT_CREATE_SCONS_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SCONS_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SCONS_YESNO_range, 2,
 _GEANT_CREATE_SCONS_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SCONS_YESNO_type };
static KmParameter *_GEANT_CREATE_SCONS_parameters[] = {
 &_GEANT_CREATE_SCONS_NAME, &_GEANT_CREATE_SCONS_NUMED,
 &_GEANT_CREATE_SCONS_INRDW, &_GEANT_CREATE_SCONS_OUTRDW,
 &_GEANT_CREATE_SCONS_INRUP, &_GEANT_CREATE_SCONS_OUTRUP,
 &_GEANT_CREATE_SCONS_HALFZ, &_GEANT_CREATE_SCONS_SPHI,
 &_GEANT_CREATE_SCONS_EPHI, &_GEANT_CREATE_SCONS_YESNO };
static KmCommand _GEANT_CREATE_SCONS = { &_GEANT_CREATE_SSPHE,
 "/GEANT/CREATE/SCONS", "SCONS", 0, 2, 10, 9, _GEANT_CREATE_SCONS_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SCONE_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SCONE_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SCONE_NUMED_type };
static KmParReal   _GEANT_CREATE_SCONE_INRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_INRDW = { "INRDW", 5,
 "Inside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_INRDW_type };
static KmParReal   _GEANT_CREATE_SCONE_OUTRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_OUTRDW = { "OUTRDW", 6,
 "Outside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_OUTRDW_type };
static KmParReal   _GEANT_CREATE_SCONE_INRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_INRUP = { "INRUP", 5,
 "Inside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_INRUP_type };
static KmParReal   _GEANT_CREATE_SCONE_OUTRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_OUTRUP = { "OUTRUP", 6,
 "Outside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_OUTRUP_type };
static KmParReal   _GEANT_CREATE_SCONE_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SCONE_HALFZ_type };
static char *_GEANT_CREATE_SCONE_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SCONE_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SCONE_YESNO_type = {
 _GEANT_CREATE_SCONE_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SCONE_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SCONE_YESNO_range, 2,
 _GEANT_CREATE_SCONE_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SCONE_YESNO_type };
static KmParameter *_GEANT_CREATE_SCONE_parameters[] = {
 &_GEANT_CREATE_SCONE_NAME, &_GEANT_CREATE_SCONE_NUMED,
 &_GEANT_CREATE_SCONE_INRDW, &_GEANT_CREATE_SCONE_OUTRDW,
 &_GEANT_CREATE_SCONE_INRUP, &_GEANT_CREATE_SCONE_OUTRUP,
 &_GEANT_CREATE_SCONE_HALFZ, &_GEANT_CREATE_SCONE_YESNO };
static KmCommand _GEANT_CREATE_SCONE = { &_GEANT_CREATE_SCONS,
 "/GEANT/CREATE/SCONE", "SCONE", 0, 2, 8, 7, _GEANT_CREATE_SCONE_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STUBS_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STUBS_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STUBS_NUMED_type };
static KmParReal   _GEANT_CREATE_STUBS_INRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_INRAD = { "INRAD", 5, "Inside Radius",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBS_INRAD_type };
static KmParReal   _GEANT_CREATE_STUBS_OUTRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_OUTRAD = { "OUTRAD", 6,
 "Outside Radius", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBS_OUTRAD_type };
static KmParReal   _GEANT_CREATE_STUBS_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBS_HALFZ_type };
static KmParReal   _GEANT_CREATE_STUBS_SPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_STUBS_SPHI = { "SPHI", 4,
 "Start of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBS_SPHI_type };
static KmParReal   _GEANT_CREATE_STUBS_EPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_STUBS_EPHI = { "EPHI", 4,
 "End of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBS_EPHI_type };
static char *_GEANT_CREATE_STUBS_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STUBS_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STUBS_YESNO_type = {
 _GEANT_CREATE_STUBS_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STUBS_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STUBS_YESNO_range, 2,
 _GEANT_CREATE_STUBS_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STUBS_YESNO_type };
static KmParameter *_GEANT_CREATE_STUBS_parameters[] = {
 &_GEANT_CREATE_STUBS_NAME, &_GEANT_CREATE_STUBS_NUMED,
 &_GEANT_CREATE_STUBS_INRAD, &_GEANT_CREATE_STUBS_OUTRAD,
 &_GEANT_CREATE_STUBS_HALFZ, &_GEANT_CREATE_STUBS_SPHI,
 &_GEANT_CREATE_STUBS_EPHI, &_GEANT_CREATE_STUBS_YESNO };
static KmCommand _GEANT_CREATE_STUBS = { &_GEANT_CREATE_SCONE,
 "/GEANT/CREATE/STUBS", "STUBS", 0, 2, 8, 7, _GEANT_CREATE_STUBS_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STUBE_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STUBE_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STUBE_NUMED_type };
static KmParReal   _GEANT_CREATE_STUBE_INRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_INRAD = { "INRAD", 5, "Inside Radius",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBE_INRAD_type };
static KmParReal   _GEANT_CREATE_STUBE_OUTRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_OUTRAD = { "OUTRAD", 6,
 "Outside Radius", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBE_OUTRAD_type };
static KmParReal   _GEANT_CREATE_STUBE_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBE_HALFZ_type };
static char *_GEANT_CREATE_STUBE_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STUBE_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STUBE_YESNO_type = {
 _GEANT_CREATE_STUBE_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STUBE_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STUBE_YESNO_range, 2,
 _GEANT_CREATE_STUBE_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STUBE_YESNO_type };
static KmParameter *_GEANT_CREATE_STUBE_parameters[] = {
 &_GEANT_CREATE_STUBE_NAME, &_GEANT_CREATE_STUBE_NUMED,
 &_GEANT_CREATE_STUBE_INRAD, &_GEANT_CREATE_STUBE_OUTRAD,
 &_GEANT_CREATE_STUBE_HALFZ, &_GEANT_CREATE_STUBE_YESNO };
static KmCommand _GEANT_CREATE_STUBE = { &_GEANT_CREATE_STUBS,
 "/GEANT/CREATE/STUBE", "STUBE", 0, 2, 6, 5, _GEANT_CREATE_STUBE_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STRD2_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STRD2_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STRD2_NUMED_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFDWX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFDWX = { "HLFDWX", 6,
 "Half X length in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFDWX_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFUPX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFUPX = { "HLFUPX", 6,
 "Half X length in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFUPX_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFDWY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFDWY = { "HLFDWY", 6,
 "Half Y length in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFDWY_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFUPY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFUPY = { "HLFUPY", 6,
 "Half Y length in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFUPY_type };
static KmParReal   _GEANT_CREATE_STRD2_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STRD2_HALFZ_type };
static char *_GEANT_CREATE_STRD2_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STRD2_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STRD2_YESNO_type = {
 _GEANT_CREATE_STRD2_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STRD2_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STRD2_YESNO_range, 2,
 _GEANT_CREATE_STRD2_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STRD2_YESNO_type };
static KmParameter *_GEANT_CREATE_STRD2_parameters[] = {
 &_GEANT_CREATE_STRD2_NAME, &_GEANT_CREATE_STRD2_NUMED,
 &_GEANT_CREATE_STRD2_HLFDWX, &_GEANT_CREATE_STRD2_HLFUPX,
 &_GEANT_CREATE_STRD2_HLFDWY, &_GEANT_CREATE_STRD2_HLFUPY,
 &_GEANT_CREATE_STRD2_HALFZ, &_GEANT_CREATE_STRD2_YESNO };
static KmCommand _GEANT_CREATE_STRD2 = { &_GEANT_CREATE_STUBE,
 "/GEANT/CREATE/STRD2", "STRD2", 0, 2, 8, 7, _GEANT_CREATE_STRD2_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STRD1_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STRD1_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STRD1_NUMED_type };
static KmParReal   _GEANT_CREATE_STRD1_HLFDWX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HLFDWX = { "HLFDWX", 6,
 "Half X length in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD1_HLFDWX_type };
static KmParReal   _GEANT_CREATE_STRD1_HLFUPX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HLFUPX = { "HLFUPX", 6,
 "Half X length in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD1_HLFUPX_type };
static KmParReal   _GEANT_CREATE_STRD1_HALFY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HALFY = { "HALFY", 5, "Half Y length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STRD1_HALFY_type };
static KmParReal   _GEANT_CREATE_STRD1_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STRD1_HALFZ_type };
static char *_GEANT_CREATE_STRD1_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STRD1_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STRD1_YESNO_type = {
 _GEANT_CREATE_STRD1_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STRD1_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STRD1_YESNO_range, 2,
 _GEANT_CREATE_STRD1_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STRD1_YESNO_type };
static KmParameter *_GEANT_CREATE_STRD1_parameters[] = {
 &_GEANT_CREATE_STRD1_NAME, &_GEANT_CREATE_STRD1_NUMED,
 &_GEANT_CREATE_STRD1_HLFDWX, &_GEANT_CREATE_STRD1_HLFUPX,
 &_GEANT_CREATE_STRD1_HALFY, &_GEANT_CREATE_STRD1_HALFZ,
 &_GEANT_CREATE_STRD1_YESNO };
static KmCommand _GEANT_CREATE_STRD1 = { &_GEANT_CREATE_STRD2,
 "/GEANT/CREATE/STRD1", "STRD1", 0, 2, 7, 6, _GEANT_CREATE_STRD1_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SBOX_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SBOX_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SBOX_NUMED_type };
static KmParReal   _GEANT_CREATE_SBOX_HALFX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_HALFX = { "HALFX", 5, "Half X length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SBOX_HALFX_type };
static KmParReal   _GEANT_CREATE_SBOX_HALFY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_HALFY = { "HALFY", 5, "Half Y length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SBOX_HALFY_type };
static KmParReal   _GEANT_CREATE_SBOX_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SBOX_HALFZ_type };
static char *_GEANT_CREATE_SBOX_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SBOX_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SBOX_YESNO_type = {
 _GEANT_CREATE_SBOX_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SBOX_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SBOX_YESNO_range, 2,
 _GEANT_CREATE_SBOX_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SBOX_YESNO_type };
static KmParameter *_GEANT_CREATE_SBOX_parameters[] = {
 &_GEANT_CREATE_SBOX_NAME, &_GEANT_CREATE_SBOX_NUMED,
 &_GEANT_CREATE_SBOX_HALFX, &_GEANT_CREATE_SBOX_HALFY,
 &_GEANT_CREATE_SBOX_HALFZ, &_GEANT_CREATE_SBOX_YESNO };
static KmCommand _GEANT_CREATE_SBOX = { &_GEANT_CREATE_STRD1,
 "/GEANT/CREATE/SBOX", "SBOX", 0, 2, 6, 5, _GEANT_CREATE_SBOX_parameters, 0,
 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_CREATE_guidance[] = {
 "It creates volumes of the given shape interactively.",
 "CALL GSVOLU(name,shape,numed,par,npar,ivolu)", "where par is a KUIP vector"
 };
static KmMenu _GEANT_CREATE = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/CREATE",
 "CREATE", 2, &_GEANT_CREATE_SBOX, 3, _GEANT_CREATE_guidance, 0, (char**)0, 0,
 (char**)0 };

static char *_GEANT_GEOMETRY_guidance[] = { "Geometry commands." };
static KmMenu _GEANT_GEOMETRY = { &_GEANT_CREATE,  (KmMenu*)0,
 "/GEANT/GEOMETRY", "GEOMETRY", 2, &_GEANT_GEOMETRY_OPTI, 1,
 _GEANT_GEOMETRY_guidance, 0, (char**)0, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_GEOMETRY, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkcont_ gkcont
#  define gxcont_ gxcont
#endif

#ifdef F77_UCASE
#  define gkcont_ GKCONT
#  define gxcont_ GXCONT
#endif

#ifdef IBM370
#  pragma linkage(GKCONT,FORTRAN)
#  pragma linkage(GXCONT,FORTRAN)
#endif

extern void gkcont_();
extern void gxcont_();

void gkcont_()
{

static char *_GEANT_CONTROL_DEBUG_IDEB_range[] = { "ON", "OFF" };
static char *_GEANT_CONTROL_DEBUG_IDEB_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CONTROL_DEBUG_IDEB_type = {
 _GEANT_CONTROL_DEBUG_IDEB_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CONTROL_DEBUG_IDEB = { "IDEB", 4, "Debug option",
 "ON", (char*)0, 8, 2, _GEANT_CONTROL_DEBUG_IDEB_range, 2,
 _GEANT_CONTROL_DEBUG_IDEB_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CONTROL_DEBUG_IDEB_type };
static KmParameter *_GEANT_CONTROL_DEBUG_parameters[] = {
 &_GEANT_CONTROL_DEBUG_IDEB };
static char *_GEANT_CONTROL_DEBUG_guidance[] = { "If ideb='ON  ' then :",
 " idebug=1, idemin=1, idemax=1000000, itime=1", "else :",
 " idebug=0, idemin=0, idemax=0" };
static KmCommand _GEANT_CONTROL_DEBUG = {  (KmCommand*)0,
 "/GEANT/CONTROL/DEBUG", "DEBUG", 0, 2, 1, 0, _GEANT_CONTROL_DEBUG_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_CONTROL_DEBUG_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PRKINE_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRKINE_NUMB = { "NUMB", 4, "Track number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PRKINE_NUMB_type };
static KmParameter *_GEANT_CONTROL_PRKINE_parameters[] = {
 &_GEANT_CONTROL_PRKINE_NUMB };
static char *_GEANT_CONTROL_PRKINE_guidance[] = { "CALL GPKINE(numb)" };
static KmCommand _GEANT_CONTROL_PRKINE = { &_GEANT_CONTROL_DEBUG,
 "/GEANT/CONTROL/PRKINE", "PRKINE", 0, 2, 1, 1,
 _GEANT_CONTROL_PRKINE_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_CONTROL_PRKINE_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PPART_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PPART_NUMB = { "NUMB", 4, "Particle number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PPART_NUMB_type };
static KmParameter *_GEANT_CONTROL_PPART_parameters[] = {
 &_GEANT_CONTROL_PPART_NUMB };
static char *_GEANT_CONTROL_PPART_guidance[] = { "CALL GPPART(numb)" };
static KmCommand _GEANT_CONTROL_PPART = { &_GEANT_CONTROL_PRKINE,
 "/GEANT/CONTROL/PPART", "PPART", 0, 2, 1, 1, _GEANT_CONTROL_PPART_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PPART_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_SPART_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_SPART_IPART_type };
static KmParameter _GEANT_CONTROL_SPART_NAPART = { "NAPART", 6,
 "Particle name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CONTROL_SPART_ITRTYP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_ITRTYP = { "ITRTYP", 6, " ", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SPART_ITRTYP_type };
static KmParReal   _GEANT_CONTROL_SPART_AMASS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_AMASS = { "AMASS", 5, "Mass",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SPART_AMASS_type };
static KmParReal   _GEANT_CONTROL_SPART_CHARGE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_CHARGE = { "CHARGE", 6, "Charge",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SPART_CHARGE_type };
static KmParReal   _GEANT_CONTROL_SPART_TLIFE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_TLIFE = { "TLIFE", 5, "Lifetime",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SPART_TLIFE_type };
static KmParReal   _GEANT_CONTROL_SPART_UBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_UBUF = { "UBUF", 4, " ", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_SPART_UBUF_type };
static KmParInt    _GEANT_CONTROL_SPART_NWBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_NWBUF = { "NWBUF", 5, " ", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SPART_NWBUF_type };
static KmParReal   _GEANT_CONTROL_SPART_BRATIO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_BRATIO = { "BRATIO", 6,
 "Branching ratios", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_SPART_BRATIO_type };
static KmParInt    _GEANT_CONTROL_SPART_MODE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_MODE = { "MODE", 4, "Decay mode",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SPART_MODE_type };
static KmParameter *_GEANT_CONTROL_SPART_parameters[] = {
 &_GEANT_CONTROL_SPART_IPART, &_GEANT_CONTROL_SPART_NAPART,
 &_GEANT_CONTROL_SPART_ITRTYP, &_GEANT_CONTROL_SPART_AMASS,
 &_GEANT_CONTROL_SPART_CHARGE, &_GEANT_CONTROL_SPART_TLIFE,
 &_GEANT_CONTROL_SPART_UBUF, &_GEANT_CONTROL_SPART_NWBUF,
 &_GEANT_CONTROL_SPART_BRATIO, &_GEANT_CONTROL_SPART_MODE };
static char *_GEANT_CONTROL_SPART_guidance[] = {
 "CALL GSPART(ipart,napart,itrtyp,amass,charge,tlife,ubuf,nwbuf);",
 "CALL GSDK(ipart,bratio,mode)" };
static KmCommand _GEANT_CONTROL_SPART = { &_GEANT_CONTROL_PPART,
 "/GEANT/CONTROL/SPART", "SPART", 0, 2, 10, 10,
 _GEANT_CONTROL_SPART_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_CONTROL_SPART_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_STPAR_ITMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_STPAR_ITMED = { "ITMED", 5, "Medium number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_STPAR_ITMED_type };
static KmParameter _GEANT_CONTROL_STPAR_CHPAR = { "CHPAR", 5,
 "Cut or mechanism", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CONTROL_STPAR_PARVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_STPAR_PARVAL = { "PARVAL", 6, "Value",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_STPAR_PARVAL_type };
static KmParameter *_GEANT_CONTROL_STPAR_parameters[] = {
 &_GEANT_CONTROL_STPAR_ITMED, &_GEANT_CONTROL_STPAR_CHPAR,
 &_GEANT_CONTROL_STPAR_PARVAL };
static char *_GEANT_CONTROL_STPAR_guidance[] = {
 "CALL GSTPAR(itmed,chpar,parval)" };
static KmCommand _GEANT_CONTROL_STPAR = { &_GEANT_CONTROL_SPART,
 "/GEANT/CONTROL/STPAR", "STPAR", 0, 2, 3, 3, _GEANT_CONTROL_STPAR_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_STPAR_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_DRMAT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_DRMAT_IMATE = { "IMATE", 5,
 "Material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_DRMAT_IMATE_type };
static KmParInt    _GEANT_CONTROL_DRMAT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_DRMAT_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_DRMAT_IPART_type };
static KmParameter _GEANT_CONTROL_DRMAT_MECAN = { "MECAN", 5,
 "List of mechanism", "ALL", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_CONTROL_DRMAT_parameters[] = {
 &_GEANT_CONTROL_DRMAT_IMATE, &_GEANT_CONTROL_DRMAT_IPART,
 &_GEANT_CONTROL_DRMAT_MECAN };
static char *_GEANT_CONTROL_DRMAT_guidance[] = {
 "CALL GDRMAT(imate,ipart,mecan,nmec)",
 "If MECAN = 'ALL' all the mechanisms are plotted. If the material number",
 "is negative, the cross sections relative to material ABS(IMATE) will",
 "be plotted in barns rather than in 1/cm.",
 "Note that it is not possible to plot anything if GSTMED has not been\
 called", "for the material number IMATE." };
static KmCommand _GEANT_CONTROL_DRMAT = { &_GEANT_CONTROL_STPAR,
 "/GEANT/CONTROL/DRMAT", "DRMAT", 0, 2, 3, 2, _GEANT_CONTROL_DRMAT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_CONTROL_DRMAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PLMAT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PLMAT_IMATE = { "IMATE", 5,
 "Material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PLMAT_IMATE_type };
static KmParInt    _GEANT_CONTROL_PLMAT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PLMAT_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PLMAT_IPART_type };
static KmParameter _GEANT_CONTROL_PLMAT_MECAN = { "MECAN", 5, "Mechanism",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CONTROL_PLMAT_IDM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PLMAT_IDM = { "IDM", 3, "ID mode option",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PLMAT_IDM_type };
static KmParameter *_GEANT_CONTROL_PLMAT_parameters[] = {
 &_GEANT_CONTROL_PLMAT_IMATE, &_GEANT_CONTROL_PLMAT_IPART,
 &_GEANT_CONTROL_PLMAT_MECAN, &_GEANT_CONTROL_PLMAT_IDM };
static char *_GEANT_CONTROL_PLMAT_guidance[] = {
 "CALL GPLMAT(imate,ipart,mecan,nekbin,elow,idm)",
 " IDM convention for histogramming mode :",
 " IDM.gt.0  fill, print,   keep   histogram(s)",
 " IDM.eq.0  fill, print,   delete histogram(s)",
 " IDM.lt.0  fill, noprint, keep   histogram(s)",
 "If MECAN = 'ALL' all the mechanisms are histogrammed. If the material\
 number",
 "is negative, the cross sections relative to material ABS(IMATE) will",
 "be histogrammed in barns rather than in 1/cm." };
static KmCommand _GEANT_CONTROL_PLMAT = { &_GEANT_CONTROL_DRMAT,
 "/GEANT/CONTROL/PLMAT", "PLMAT", 0, 2, 4, 3, _GEANT_CONTROL_PLMAT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_CONTROL_PLMAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PRMAT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRMAT_IMATE = { "IMATE", 5,
 "Material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PRMAT_IMATE_type };
static KmParInt    _GEANT_CONTROL_PRMAT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRMAT_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PRMAT_IPART_type };
static KmParameter _GEANT_CONTROL_PRMAT_MECAN = { "MECAN", 5, "Mechanism",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_CONTROL_PRMAT_parameters[] = {
 &_GEANT_CONTROL_PRMAT_IMATE, &_GEANT_CONTROL_PRMAT_IPART,
 &_GEANT_CONTROL_PRMAT_MECAN };
static char *_GEANT_CONTROL_PRMAT_guidance[] = {
 " CALL GPRMAT(imate,ipart,mecan,nekbin,elow)" };
static KmCommand _GEANT_CONTROL_PRMAT = { &_GEANT_CONTROL_PLMAT,
 "/GEANT/CONTROL/PRMAT", "PRMAT", 0, 2, 3, 3, _GEANT_CONTROL_PRMAT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PRMAT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PMATE_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PMATE_NUMB = { "NUMB", 4, "Material number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PMATE_NUMB_type };
static KmParameter *_GEANT_CONTROL_PMATE_parameters[] = {
 &_GEANT_CONTROL_PMATE_NUMB };
static char *_GEANT_CONTROL_PMATE_guidance[] = { " CALL GPMATE(numb)" };
static KmCommand _GEANT_CONTROL_PMATE = { &_GEANT_CONTROL_PRMAT,
 "/GEANT/CONTROL/PMATE", "PMATE", 0, 2, 1, 1, _GEANT_CONTROL_PMATE_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PMATE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_SMIXT_IMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_IMAT = { "IMAT", 4, "Material number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMIXT_IMAT_type };
static KmParameter _GEANT_CONTROL_SMIXT_NAMATE = { "NAMATE", 6,
 "Material name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CONTROL_SMIXT_A_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_A = { "A", 1, "Atomic weight",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMIXT_A_type };
static KmParReal   _GEANT_CONTROL_SMIXT_Z_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_Z = { "Z", 1, "Atomic number",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMIXT_Z_type };
static KmParReal   _GEANT_CONTROL_SMIXT_DENS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_DENS = { "DENS", 4, "Density",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMIXT_DENS_type };
static KmParInt    _GEANT_CONTROL_SMIXT_NLMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_NLMAT = { "NLMAT", 5, "Flag for WMAT",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMIXT_NLMAT_type };
static KmParReal   _GEANT_CONTROL_SMIXT_WMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_WMAT = { "WMAT", 4,
 "Relative weights or n. of atoms in molecule", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_SMIXT_WMAT_type };
static KmParameter *_GEANT_CONTROL_SMIXT_parameters[] = {
 &_GEANT_CONTROL_SMIXT_IMAT, &_GEANT_CONTROL_SMIXT_NAMATE,
 &_GEANT_CONTROL_SMIXT_A, &_GEANT_CONTROL_SMIXT_Z, &_GEANT_CONTROL_SMIXT_DENS,
 &_GEANT_CONTROL_SMIXT_NLMAT, &_GEANT_CONTROL_SMIXT_WMAT };
static char *_GEANT_CONTROL_SMIXT_guidance[] = {
 " CALL GSMIXT(imat,namate,a,z,dens,nlmat,wmat)" };
static KmCommand _GEANT_CONTROL_SMIXT = { &_GEANT_CONTROL_PMATE,
 "/GEANT/CONTROL/SMIXT", "SMIXT", 0, 2, 7, 7, _GEANT_CONTROL_SMIXT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_SMIXT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_SMATE_IMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_IMAT = { "IMAT", 4, "Material number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMATE_IMAT_type };
static KmParameter _GEANT_CONTROL_SMATE_NAMATE = { "NAMATE", 6,
 "Material name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CONTROL_SMATE_A_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_A = { "A", 1, "Atomic weight",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMATE_A_type };
static KmParReal   _GEANT_CONTROL_SMATE_Z_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_Z = { "Z", 1, "Atomic number",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMATE_Z_type };
static KmParReal   _GEANT_CONTROL_SMATE_DENS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_DENS = { "DENS", 4, "Density",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMATE_DENS_type };
static KmParReal   _GEANT_CONTROL_SMATE_RADL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_RADL = { "RADL", 4,
 "Radiation lenght", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_SMATE_RADL_type };
static KmParReal   _GEANT_CONTROL_SMATE_ABSL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_ABSL = { "ABSL", 4,
 "Absorption lenght", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_SMATE_ABSL_type };
static KmParReal   _GEANT_CONTROL_SMATE_UBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_UBUF = { "UBUF", 4, " ", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_SMATE_UBUF_type };
static KmParInt    _GEANT_CONTROL_SMATE_NWBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_NWBUF = { "NWBUF", 5, " ", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMATE_NWBUF_type };
static KmParameter *_GEANT_CONTROL_SMATE_parameters[] = {
 &_GEANT_CONTROL_SMATE_IMAT, &_GEANT_CONTROL_SMATE_NAMATE,
 &_GEANT_CONTROL_SMATE_A, &_GEANT_CONTROL_SMATE_Z, &_GEANT_CONTROL_SMATE_DENS,
 &_GEANT_CONTROL_SMATE_RADL, &_GEANT_CONTROL_SMATE_ABSL,
 &_GEANT_CONTROL_SMATE_UBUF, &_GEANT_CONTROL_SMATE_NWBUF };
static char *_GEANT_CONTROL_SMATE_guidance[] = {
 " CALL GSMATE(imat,namate,a,z,dens,radl,absl,ubuf,nwbuf)" };
static KmCommand _GEANT_CONTROL_SMATE = { &_GEANT_CONTROL_SMIXT,
 "/GEANT/CONTROL/SMATE", "SMATE", 0, 2, 9, 9, _GEANT_CONTROL_SMATE_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_SMATE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_CONTROL_PDIGI_CHUSET = { "CHUSET", 6, "User set",
 "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GEANT_CONTROL_PDIGI_CHUDET = { "CHUDET", 6,
 "User detector", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_CONTROL_PDIGI_parameters[] = {
 &_GEANT_CONTROL_PDIGI_CHUSET, &_GEANT_CONTROL_PDIGI_CHUDET };
static char *_GEANT_CONTROL_PDIGI_guidance[] = { " CALL GPDIGI(chuset,chudet)"
 };
static KmCommand _GEANT_CONTROL_PDIGI = { &_GEANT_CONTROL_SMATE,
 "/GEANT/CONTROL/PDIGI", "PDIGI", 0, 2, 2, 0, _GEANT_CONTROL_PDIGI_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PDIGI_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_CONTROL_PHITS_CHUSET = { "CHUSET", 6, "User set",
 "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GEANT_CONTROL_PHITS_CHUDET = { "CHUDET", 6,
 "User detector", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CONTROL_PHITS_NUMHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PHITS_NUMHI = { "NUMHI", 5, "Hit number",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PHITS_NUMHI_type };
static KmParameter *_GEANT_CONTROL_PHITS_parameters[] = {
 &_GEANT_CONTROL_PHITS_CHUSET, &_GEANT_CONTROL_PHITS_CHUDET,
 &_GEANT_CONTROL_PHITS_NUMHI };
static char *_GEANT_CONTROL_PHITS_guidance[] = { " CALL GPHITS(chuset,chudet)"
 };
static KmCommand _GEANT_CONTROL_PHITS = { &_GEANT_CONTROL_PDIGI,
 "/GEANT/CONTROL/PHITS", "PHITS", 0, 2, 3, 0, _GEANT_CONTROL_PHITS_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PHITS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_OUTPUT_LP_LOUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_OUTPUT_LP_LOUT = { "LOUT", 4,
 "New output unit", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_OUTPUT_LP_LOUT_type };
static KmParameter *_GEANT_CONTROL_OUTPUT_LP_parameters[] = {
 &_GEANT_CONTROL_OUTPUT_LP_LOUT };
static char *_GEANT_CONTROL_OUTPUT_LP_guidance[] = {
 "To change lout in /GCUNIT/",
 "Note: unit numbers 5,11,12,13,14,15 are reserved and cannot be used." };
static KmCommand _GEANT_CONTROL_OUTPUT_LP = { &_GEANT_CONTROL_PHITS,
 "/GEANT/CONTROL/OUTPUT_LP", "OUTPUT_LP", 0, 2, 1, 1,
 _GEANT_CONTROL_OUTPUT_LP_parameters, 0, 0, gxcont_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_CONTROL_OUTPUT_LP_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CONTROL_PRINT_NAME = { "NAME", 4, "Name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_CONTROL_PRINT_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRINT_NUMBER = { "NUMBER", 6, "Number", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PRINT_NUMBER_type };
static KmParameter *_GEANT_CONTROL_PRINT_parameters[] = {
 &_GEANT_CONTROL_PRINT_NAME, &_GEANT_CONTROL_PRINT_NUMBER };
static char *_GEANT_CONTROL_PRINT_guidance[] = { " CALL GPRINT(name,number)" };
static KmCommand _GEANT_CONTROL_PRINT = { &_GEANT_CONTROL_OUTPUT_LP,
 "/GEANT/CONTROL/PRINT", "PRINT", 0, 2, 2, 2, _GEANT_CONTROL_PRINT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PRINT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_MZLOGL_LEVEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_MZLOGL_LEVEL = { "LEVEL", 5, "MZ log level",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_MZLOGL_LEVEL_type };
static KmParameter *_GEANT_CONTROL_MZLOGL_parameters[] = {
 &_GEANT_CONTROL_MZLOGL_LEVEL };
static char *_GEANT_CONTROL_MZLOGL_guidance[] = {
 "Set the log level for the MZ package of ZEBRA: CALL MZLOGL(0,level)",
 " LEVEL = -3   no messages at all", "         -2   error messages only",
 "         -1   terse logging", "          0   normal",
 "         +1   log rare events", "         +2   log calls to MZ routines" };
static KmCommand _GEANT_CONTROL_MZLOGL = { &_GEANT_CONTROL_PRINT,
 "/GEANT/CONTROL/MZLOGL", "MZLOGL", 0, 2, 1, 1,
 _GEANT_CONTROL_MZLOGL_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 7, _GEANT_CONTROL_MZLOGL_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_SWITCH_ISWI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SWITCH_ISWI = { "ISWI", 4, "Switch number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SWITCH_ISWI_type };
static KmParInt    _GEANT_CONTROL_SWITCH_IVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SWITCH_IVAL = { "IVAL", 4,
 "New switch value", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_SWITCH_IVAL_type };
static KmParameter *_GEANT_CONTROL_SWITCH_parameters[] = {
 &_GEANT_CONTROL_SWITCH_ISWI, &_GEANT_CONTROL_SWITCH_IVAL };
static char *_GEANT_CONTROL_SWITCH_guidance[] = {
 "Change one element of array ISWIT(10) in /GCFLAG/" };
static KmCommand _GEANT_CONTROL_SWITCH = { &_GEANT_CONTROL_MZLOGL,
 "/GEANT/CONTROL/SWITCH", "SWITCH", 0, 2, 2, 2,
 _GEANT_CONTROL_SWITCH_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_CONTROL_SWITCH_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_RNDM_ISEED1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RNDM_ISEED1 = { "ISEED1", 6,
 "First seed for the random number generator", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_RNDM_ISEED1_type };
static KmParInt    _GEANT_CONTROL_RNDM_ISEED2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RNDM_ISEED2 = { "ISEED2", 6,
 "Second seed for the random number generator", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_RNDM_ISEED2_type };
static KmParameter *_GEANT_CONTROL_RNDM_parameters[] = {
 &_GEANT_CONTROL_RNDM_ISEED1, &_GEANT_CONTROL_RNDM_ISEED2 };
static char *_GEANT_CONTROL_RNDM_guidance[] = {
 "Set the seeds for the random number generator. If no numbers are",
 "given, the currents seeds are printed." };
static KmCommand _GEANT_CONTROL_RNDM = { &_GEANT_CONTROL_SWITCH,
 "/GEANT/CONTROL/RNDM", "RNDM", 0, 2, 2, 0, _GEANT_CONTROL_RNDM_parameters, 0,
 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_CONTROL_RNDM_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_TRIGGER_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_TRIGGER_N = { "N", 1, "Number of events",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_TRIGGER_N_type };
static KmParameter *_GEANT_CONTROL_TRIGGER_parameters[] = {
 &_GEANT_CONTROL_TRIGGER_N };
static char *_GEANT_CONTROL_TRIGGER_guidance[] = {
 "Start one or more new events." };
static KmCommand _GEANT_CONTROL_TRIGGER = { &_GEANT_CONTROL_RNDM,
 "/GEANT/CONTROL/TRIGGER", "TRIGGER", 0, 2, 1, 0,
 _GEANT_CONTROL_TRIGGER_parameters, 0, 0, gxcont_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_CONTROL_TRIGGER_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_CONTROL_TRACK_guidance[] = {
 "Restart tracking, clearing the track and hit",
 "banks, but keeping the kinematics." };
static KmCommand _GEANT_CONTROL_TRACK = { &_GEANT_CONTROL_TRIGGER,
 "/GEANT/CONTROL/TRACK", "TRACK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxcont_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_CONTROL_TRACK_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_CONTROL_GTIME_TIMINT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_GTIME_TIMINT = { "TIMINT", 6,
 "Total time after initialisation", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_GTIME_TIMINT_type };
static KmParReal   _GEANT_CONTROL_GTIME_TIMEND_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_GTIME_TIMEND = { "TIMEND", 6,
 "Time reserved for the termination phase", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_GTIME_TIMEND_type };
static KmParInt    _GEANT_CONTROL_GTIME_ITIME_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_GTIME_ITIME = { "ITIME", 5,
 "Frequency of control printing", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_GTIME_ITIME_type };
static KmParameter *_GEANT_CONTROL_GTIME_parameters[] = {
 &_GEANT_CONTROL_GTIME_TIMINT, &_GEANT_CONTROL_GTIME_TIMEND,
 &_GEANT_CONTROL_GTIME_ITIME };
static char *_GEANT_CONTROL_GTIME_guidance[] = {
 "These commands have limited use in the interactive version. In",
 "particular the value of TIMINT is disregarded by GEANT." };
static KmCommand _GEANT_CONTROL_GTIME = { &_GEANT_CONTROL_TRACK,
 "/GEANT/CONTROL/GTIME", "GTIME", 0, 2, 3, 3, _GEANT_CONTROL_GTIME_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_CONTROL_GTIME_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_CONTROL_SORD_ISTORD_range[] = { "1", "0" };
static KmParInt    _GEANT_CONTROL_SORD_ISTORD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SORD_ISTORD = { "ISTORD", 6,
 "Flag to control user ordering of the stack", "1", (char*)0, 8, 2,
 _GEANT_CONTROL_SORD_ISTORD_range, 2, _GEANT_CONTROL_SORD_ISTORD_range,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_SORD_ISTORD_type };
static KmParameter *_GEANT_CONTROL_SORD_parameters[] = {
 &_GEANT_CONTROL_SORD_ISTORD };
static char *_GEANT_CONTROL_SORD_guidance[] = {
 "If ISTORD is set to 1, the particle with the highest value of the",
 "user weight UPWGHT will be selected to be tracked next." };
static KmCommand _GEANT_CONTROL_SORD = { &_GEANT_CONTROL_GTIME,
 "/GEANT/CONTROL/SORD", "SORD", 0, 2, 1, 1, _GEANT_CONTROL_SORD_parameters, 0,
 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_CONTROL_SORD_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_RUNG_IDRUN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RUNG_IDRUN = { "IDRUN", 5,
 "User run number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_RUNG_IDRUN_type };
static KmParInt    _GEANT_CONTROL_RUNG_IDEVT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RUNG_IDEVT = { "IDEVT", 5,
 "User starting event number", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_RUNG_IDEVT_type };
static KmParameter *_GEANT_CONTROL_RUNG_parameters[] = {
 &_GEANT_CONTROL_RUNG_IDRUN, &_GEANT_CONTROL_RUNG_IDEVT };
static char *_GEANT_CONTROL_RUNG_guidance[] = {
 "Set the run number and the starting value for the user event number." };
static KmCommand _GEANT_CONTROL_RUNG = { &_GEANT_CONTROL_SORD,
 "/GEANT/CONTROL/RUNG", "RUNG", 0, 2, 2, 2, _GEANT_CONTROL_RUNG_parameters, 0,
 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_RUNG_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_KINE_IKINE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_IKINE = { "IKINE", 5, "IKINE", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_KINE_IKINE_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE1 = { "PKINE1", 6, "PKINE(1)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE1_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE2 = { "PKINE2", 6, "PKINE(2)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE2_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE3_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE3 = { "PKINE3", 6, "PKINE(3)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE3_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE4_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE4 = { "PKINE4", 6, "PKINE(4)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE4_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE5_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE5 = { "PKINE5", 6, "PKINE(5)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE5_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE6_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE6 = { "PKINE6", 6, "PKINE(6)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE6_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE7_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE7 = { "PKINE7", 6, "PKINE(7)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE7_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE8_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE8 = { "PKINE8", 6, "PKINE(8)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE8_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE9_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE9 = { "PKINE9", 6, "PKINE(9)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE9_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE10_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE10 = { "PKINE10", 7, "PKINE(10)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE10_type };
static KmParameter *_GEANT_CONTROL_KINE_parameters[] = {
 &_GEANT_CONTROL_KINE_IKINE, &_GEANT_CONTROL_KINE_PKINE1,
 &_GEANT_CONTROL_KINE_PKINE2, &_GEANT_CONTROL_KINE_PKINE3,
 &_GEANT_CONTROL_KINE_PKINE4, &_GEANT_CONTROL_KINE_PKINE5,
 &_GEANT_CONTROL_KINE_PKINE6, &_GEANT_CONTROL_KINE_PKINE7,
 &_GEANT_CONTROL_KINE_PKINE8, &_GEANT_CONTROL_KINE_PKINE9,
 &_GEANT_CONTROL_KINE_PKINE10 };
static char *_GEANT_CONTROL_KINE_guidance[] = {
 "Set the variables in /GCFLAG/ IKINE, PKINE(10)" };
static KmCommand _GEANT_CONTROL_KINE = { &_GEANT_CONTROL_RUNG,
 "/GEANT/CONTROL/KINE", "KINE", 0, 2, 11, 1, _GEANT_CONTROL_KINE_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_KINE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_CONTROL_guidance[] = { "Control commands." };
static KmMenu _GEANT_CONTROL = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/CONTROL",
 "CONTROL", 2, &_GEANT_CONTROL_KINE, 1, _GEANT_CONTROL_guidance, 0, (char**)0,
 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_CONTROL, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkdz_ gkdz
#  define gxdz_ gxdz
#endif

#ifdef F77_UCASE
#  define gkdz_ GKDZ
#  define gxdz_ GXDZ
#endif

#ifdef IBM370
#  pragma linkage(GKDZ,FORTRAN)
#  pragma linkage(GXDZ,FORTRAN)
#endif

extern void gkdz_();
extern void gxdz_();

void gkdz_()
{

static KmParameter _GEANT_DZ_DIRZ_PATH = { "PATH", 4,
 "Name of the RZ directory to analyse", (char*)0, (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DZ_DIRZ_parameters[] = { &_GEANT_DZ_DIRZ_PATH };
static char *_GEANT_DZ_DIRZ_guidance[] = {
 "Facility to display RZ directory trees.",
 " CALL DZDIRZ(0,LDUMMY,0,path,'N',1,0,1)" };
static KmCommand _GEANT_DZ_DIRZ = {  (KmCommand*)0, "/GEANT/DZ/DIRZ", "DIRZ",
 0, 2, 1, 0, _GEANT_DZ_DIRZ_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_DZ_DIRZ_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DZ_DISP_BANK = { "BANK", 4, "Name of the bank",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DZ_DISP_PATH = { "PATH", 4, "Name of the doc file",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DZ_DISP_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DZ_DISP_NUMBER = { "NUMBER", 6,
 "Number of the bank", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DZ_DISP_NUMBER_type };
static KmParameter *_GEANT_DZ_DISP_parameters[] = { &_GEANT_DZ_DISP_BANK,
 &_GEANT_DZ_DISP_PATH, &_GEANT_DZ_DISP_NUMBER };
static char *_GEANT_DZ_DISP_guidance[] = { "Interactive bank display tool.",
 " CALL DZDISP(IXSTOR,LBANK,path,'N',1,0,1,IWTYPE)" };
static KmCommand _GEANT_DZ_DISP = { &_GEANT_DZ_DIRZ, "/GEANT/DZ/DISP", "DISP",
 0, 2, 3, 1, _GEANT_DZ_DISP_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_DZ_DISP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_DDIV_IDIV_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_DZ_DDIV_IDIV = { "IDIV", 4, "Division number", "2",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_DDIV_IDIV_type };
static KmParameter _GEANT_DZ_DDIV_PATH = { "PATH", 4, "Name of the doc file",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_GEANT_DZ_DDIV_parameters[] = { &_GEANT_DZ_DDIV_IDIV,
 &_GEANT_DZ_DDIV_PATH };
static char *_GEANT_DZ_DDIV_guidance[] = {
 "Facility to display the layout of stores and divisions.",
 " CALL DZDDIV(idiv,LDUMMY,path,'IN',1,0,1,IWTYPE)" };
static KmCommand _GEANT_DZ_DDIV = { &_GEANT_DZ_DISP, "/GEANT/DZ/DDIV", "DDIV",
 0, 2, 2, 0, _GEANT_DZ_DDIV_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_DZ_DDIV_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_STORE_IXSTOR_type = { "0", "24", "0", "24", 0 };
static KmParameter _GEANT_DZ_STORE_IXSTOR = { "IXSTOR", 6, "Store number",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_STORE_IXSTOR_type };
static KmParameter *_GEANT_DZ_STORE_parameters[] = { &_GEANT_DZ_STORE_IXSTOR };
static char *_GEANT_DZ_STORE_guidance[] = {
 "Display the structure of the ZEBRA store IXSTOR.",
 "Output the parameters characterizing the store, followed by a",
 "list of all divisions and all link areas associated with the store in",
 "question." };
static KmCommand _GEANT_DZ_STORE = { &_GEANT_DZ_DDIV, "/GEANT/DZ/STORE",
 "STORE", 0, 2, 1, 0, _GEANT_DZ_STORE_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _GEANT_DZ_STORE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_VERIFY_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _GEANT_DZ_VERIFY_IDIV = { "IDIV", 4, "Division number ",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_VERIFY_IDIV_type };
static KmParOption _GEANT_DZ_VERIFY_CHOPT_type = { (char**)0, (int*)0, (int*)0
 };
static KmParameter _GEANT_DZ_VERIFY_CHOPT = { "CHOPT", 5, "Options", "CLSU",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DZ_VERIFY_CHOPT_type };
static KmParameter *_GEANT_DZ_VERIFY_parameters[] = { &_GEANT_DZ_VERIFY_IDIV,
 &_GEANT_DZ_VERIFY_CHOPT };
static char *_GEANT_DZ_VERIFY_guidance[] = {
 "Check the structure of one or more ZEBRA divisions.",
 "The verification detail depends on the settings in CHOPT.",
 " CHOPT='C' Check chaining of banks only",
 " CHOPT='L' Check validity of the structural links (implies 'C')",
 " CHOPT='S' Check the store parameters",
 " CHOPT='U' Check the validity of the up and origin (implies 'C')",
 " CHOPT='F' Errors are considered fatal and generate a call to ZFATAL" };
static KmCommand _GEANT_DZ_VERIFY = { &_GEANT_DZ_STORE, "/GEANT/DZ/VERIFY",
 "VERIFY", 0, 2, 2, 0, _GEANT_DZ_VERIFY_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _GEANT_DZ_VERIFY_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_SNAP_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _GEANT_DZ_SNAP_IDIV = { "IDIV", 4, "Division number ", "2",
 (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_SNAP_IDIV_type };
static KmParOption _GEANT_DZ_SNAP_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_DZ_SNAP_CHOPT = { "CHOPT", 5, "Options", "M",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DZ_SNAP_CHOPT_type };
static KmParameter *_GEANT_DZ_SNAP_parameters[] = { &_GEANT_DZ_SNAP_IDIV,
 &_GEANT_DZ_SNAP_CHOPT };
static char *_GEANT_DZ_SNAP_guidance[] = { "Snap of one or more divisions.",
 "Provides a snapshot of one or more divisions in a ZEBRA store.",
 "The kind of information provided is controlled by CHOPT.",
 " CHOPT='M' Print Map entry for each bank",
 " CHOPT='E' Extend map entry to dump all links of each bank",
 "           (otherwise only as many links as will fit on a line)",
 " CHOPT='F' Full. Dump all active banks, links and data",
 " CHOPT='K' Kill. Dropped banks to be treated as active",
 "           (dropped banks are not normally dumped under D or F option)",
 " CHOPT='L' Dump all Link areas associated with the store",
 " CHOPT='W' Dump the Working space, links and data",
 " CHOPT='Z' Dump the information in hexadecimal." };
static KmCommand _GEANT_DZ_SNAP = { &_GEANT_DZ_VERIFY, "/GEANT/DZ/SNAP",
 "SNAP", 0, 2, 2, 0, _GEANT_DZ_SNAP_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 12, _GEANT_DZ_SNAP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DZ_SHOW_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DZ_SHOW_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DZ_SHOW_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_SHOW_NUMBER_type };
static KmParOption _GEANT_DZ_SHOW_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_DZ_SHOW_CHOPT = { "CHOPT", 5, "Options", "BSV",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DZ_SHOW_CHOPT_type };
static KmParameter *_GEANT_DZ_SHOW_parameters[] = { &_GEANT_DZ_SHOW_NAME,
 &_GEANT_DZ_SHOW_NUMBER, &_GEANT_DZ_SHOW_CHOPT };
static char *_GEANT_DZ_SHOW_guidance[] = {
 "Display the contents of a bank or a data structure",
 "identified by its NAME and NUMBER.",
 "The output format of the data part is controlled by the internal",
 "or external I/O characteristic.", " CHOPT='B' Print the bank.",
 " CHOPT='S' Print the bank contents from left to right Sideways",
 "           with up to ten elements per line.",
 " CHOPT='V' Print the vertical (down) structure.",
 " CHOPT='D' Print the bank contents from top to bottom Downwards",
 "           with five elements per line.",
 " CHOPT='L' Print the linear structure.",
 " CHOPT='Z' Print the data part of each bank in hexadecimal format" };
static KmCommand _GEANT_DZ_SHOW = { &_GEANT_DZ_SNAP, "/GEANT/DZ/SHOW", "SHOW",
 0, 2, 3, 1, _GEANT_DZ_SHOW_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 12, _GEANT_DZ_SHOW_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DZ_SURV_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DZ_SURV_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DZ_SURV_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_SURV_NUMBER_type };
static KmParameter *_GEANT_DZ_SURV_parameters[] = { &_GEANT_DZ_SURV_NAME,
 &_GEANT_DZ_SURV_NUMBER };
static char *_GEANT_DZ_SURV_guidance[] = {
 "Print a survey of the structure identified by NAME, NUMBER." };
static KmCommand _GEANT_DZ_SURV = { &_GEANT_DZ_SHOW, "/GEANT/DZ/SURV", "SURV",
 0, 2, 2, 1, _GEANT_DZ_SURV_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_DZ_SURV_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmMenu _GEANT_DZ = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/DZ", "DZ", 2,
 &_GEANT_DZ_SURV, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_DZ, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkfz_ gkfz
#  define gxfz_ gxfz
#endif

#ifdef F77_UCASE
#  define gkfz_ GKFZ
#  define gxfz_ GXFZ
#endif

#ifdef IBM370
#  pragma linkage(GKFZ,FORTRAN)
#  pragma linkage(GXFZ,FORTRAN)
#endif

extern void gkfz_();
extern void gxfz_();

void gkfz_()
{

static KmParInt    _GEANT_FZ_FZCLOSE_LUN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_FZ_FZCLOSE_LUN = { "LUN", 3,
 "Fortran unit of the FZ to close", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZCLOSE_LUN_type };
static KmParameter *_GEANT_FZ_FZCLOSE_parameters[] = { &_GEANT_FZ_FZCLOSE_LUN
 };
static char *_GEANT_FZ_FZCLOSE_guidance[] = { "Equivalent to a call to:",
 "       CALL GCLOSE(LUN,IER)" };
static KmCommand _GEANT_FZ_FZCLOSE = {  (KmCommand*)0, "/GEANT/FZ/FZCLOSE",
 "FZCLOSE", 0, 2, 1, 1, _GEANT_FZ_FZCLOSE_parameters, 0, 0, gxfz_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_FZ_FZCLOSE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_FZ_FZOUT_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOUT_LUN = { "LUN", 3,
 "Fortran unit of the FZ file", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOUT_LUN_type };
static KmParameter _GEANT_FZ_FZOUT_KEYSU = { "KEYSU", 5,
 "Name of the data structure to be saved", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_FZ_FZOUT_IDENT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOUT_IDENT = { "IDENT", 5,
 "Version of the data structure to be saved", "1", (char*)0, 8, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOUT_IDENT_type };
static KmParameter *_GEANT_FZ_FZOUT_parameters[] = { &_GEANT_FZ_FZOUT_LUN,
 &_GEANT_FZ_FZOUT_KEYSU, &_GEANT_FZ_FZOUT_IDENT };
static char *_GEANT_FZ_FZOUT_guidance[] = { "Equivalent to a call to:",
 "       CALL GFOUT(LUN,KEYSU,1,IDENT,' ',IER)" };
static KmCommand _GEANT_FZ_FZOUT = { &_GEANT_FZ_FZCLOSE, "/GEANT/FZ/FZOUT",
 "FZOUT", 0, 2, 3, 2, _GEANT_FZ_FZOUT_parameters, 0, 0, gxfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_FZ_FZOUT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_FZ_FZOPEN_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOPEN_LUN = { "LUN", 3,
 "Fortran unit with which to open the file", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOPEN_LUN_type
 };
static KmParameter _GEANT_FZ_FZOPEN_FILE = { "FILE", 4,
 "Name of the file to be opened", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_FZ_FZOPEN_LUNTYP = { "LUNTYP", 6,
 "Type of FZ file to be opened by GOPEN", "XI", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_FZ_FZOPEN_LEN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOPEN_LEN = { "LEN", 3,
 "Recordlenght of the file", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOPEN_LEN_type };
static KmParOption _GEANT_FZ_FZOPEN_CHOPT_type = { (char**)0, (int*)0, (int*)0
 };
static KmParameter _GEANT_FZ_FZOPEN_CHOPT = { "CHOPT", 5,
 "Optional parameter to specify the action", " ", (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION, &_GEANT_FZ_FZOPEN_CHOPT_type };
static KmParameter *_GEANT_FZ_FZOPEN_parameters[] = { &_GEANT_FZ_FZOPEN_LUN,
 &_GEANT_FZ_FZOPEN_FILE, &_GEANT_FZ_FZOPEN_LUNTYP, &_GEANT_FZ_FZOPEN_LEN,
 &_GEANT_FZ_FZOPEN_CHOPT };
static char *_GEANT_FZ_FZOPEN_guidance[] = { "Equivalent to a call to:",
 "       CALL GOPEN(LUN,FILE,LUNTYP,LEN,IER)",
 "If CHOPT = I then a call to GFIN or GFOUT will be performed in addition",
 "according to the value of LUNTYP, with the key INIT to save or retrieve",
 "the whole initialization data structure." };
static KmCommand _GEANT_FZ_FZOPEN = { &_GEANT_FZ_FZOUT, "/GEANT/FZ/FZOPEN",
 "FZOPEN", 0, 2, 5, 4, _GEANT_FZ_FZOPEN_parameters, 0, 0, gxfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _GEANT_FZ_FZOPEN_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_FZ_FZIN_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZIN_LUN = { "LUN", 3,
 "Fortran unit of the FZ file", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZIN_LUN_type };
static KmParameter _GEANT_FZ_FZIN_KEYSU = { "KEYSU", 5,
 "Name of the data structure to be retrieved", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_FZ_FZIN_IDENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZIN_IDENT = { "IDENT", 5,
 "Version of the data structure to be retrieved", "0", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZIN_IDENT_type
 };
static KmParameter *_GEANT_FZ_FZIN_parameters[] = { &_GEANT_FZ_FZIN_LUN,
 &_GEANT_FZ_FZIN_KEYSU, &_GEANT_FZ_FZIN_IDENT };
static char *_GEANT_FZ_FZIN_guidance[] = { "Equivalent to a call to:",
 "       CALL GFIN(LUN,KEYSU,1,IDENT,' ',IER)" };
static KmCommand _GEANT_FZ_FZIN = { &_GEANT_FZ_FZOPEN, "/GEANT/FZ/FZIN",
 "FZIN", 0, 2, 3, 2, _GEANT_FZ_FZIN_parameters, 0, 0, gxfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_FZ_FZIN_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_FZ_guidance[] = { "ZEBRA/FZ commands" };
static KmMenu _GEANT_FZ = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/FZ", "FZ", 2,
 &_GEANT_FZ_FZIN, 1, _GEANT_FZ_guidance, 0, (char**)0, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_FZ, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkrz_ gkrz
#  define gxrz_ gxrz
#endif

#ifdef F77_UCASE
#  define gkrz_ GKRZ
#  define gxrz_ GXRZ
#endif

#ifdef IBM370
#  pragma linkage(GKRZ,FORTRAN)
#  pragma linkage(GXRZ,FORTRAN)
#endif

extern void gkrz_();
extern void gxrz_();

void gkrz_()
{

static KmParameter _GEANT_RZ_FREE_CHDIR = { "CHDIR", 5, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_RZ_FREE_parameters[] = { &_GEANT_RZ_FREE_CHDIR };
static char *_GEANT_RZ_FREE_guidance[] = { "Free an RZ directory." };
static KmCommand _GEANT_RZ_FREE = {  (KmCommand*)0, "/GEANT/RZ/FREE", "FREE",
 0, 2, 1, 1, _GEANT_RZ_FREE_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_FREE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_LOCK_CHDIR = { "CHDIR", 5, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_RZ_LOCK_parameters[] = { &_GEANT_RZ_LOCK_CHDIR };
static char *_GEANT_RZ_LOCK_guidance[] = { "Lock an RZ directory." };
static KmCommand _GEANT_RZ_LOCK = { &_GEANT_RZ_FREE, "/GEANT/RZ/LOCK", "LOCK",
 0, 2, 1, 1, _GEANT_RZ_LOCK_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_LOCK_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_SCR_OBJECT = { "OBJECT", 6, "Structure name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_RZ_SCR_IDVERS_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_SCR_IDVERS = { "IDVERS", 6, "Version number",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_SCR_IDVERS_type };
static KmParameter *_GEANT_RZ_SCR_parameters[] = { &_GEANT_RZ_SCR_OBJECT,
 &_GEANT_RZ_SCR_IDVERS };
static char *_GEANT_RZ_SCR_guidance[] = {
 "Delete entry identified by OBJECT,IDVERS on RZ file.",
 "OBJECT may be : MATE,TMED,VOLU,ROTM,SETS,PART,SCAN, *",
 "If OBJECT= *    delete all entries with IDVERS." };
static KmCommand _GEANT_RZ_SCR = { &_GEANT_RZ_LOCK, "/GEANT/RZ/SCR", "SCR", 0,
 2, 2, 1, _GEANT_RZ_SCR_parameters, 0, 0, gxrz_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _GEANT_RZ_SCR_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_PURGE_NKEEP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_RZ_PURGE_NKEEP = { "NKEEP", 5,
 "Number of cycles to keep", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_RZ_PURGE_NKEEP_type };
static KmParameter *_GEANT_RZ_PURGE_parameters[] = { &_GEANT_RZ_PURGE_NKEEP };
static char *_GEANT_RZ_PURGE_guidance[] = { "Purge an RZ directory." };
static KmCommand _GEANT_RZ_PURGE = { &_GEANT_RZ_SCR, "/GEANT/RZ/PURGE",
 "PURGE", 0, 2, 1, 0, _GEANT_RZ_PURGE_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_PURGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_LDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParOption _GEANT_RZ_LDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_LDIR_CHOPT = { "CHOPT", 5, "CHOPT", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_LDIR_CHOPT_type };
static KmParameter *_GEANT_RZ_LDIR_parameters[] = { &_GEANT_RZ_LDIR_CHPATH,
 &_GEANT_RZ_LDIR_CHOPT };
static char *_GEANT_RZ_LDIR_guidance[] = {
 "List the contents of a directory (memory or disk).",
 "To list all RZ files currently open, type 'LD //'." };
static KmCommand _GEANT_RZ_LDIR = { &_GEANT_RZ_PURGE, "/GEANT/RZ/LDIR",
 "LDIR", 0, 2, 2, 0, _GEANT_RZ_LDIR_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_RZ_LDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_OUT_OBJECT = { "OBJECT", 6, "Structure name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_RZ_OUT_IDVERS_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_OUT_IDVERS = { "IDVERS", 6, "Version number",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_OUT_IDVERS_type };
static KmParOption _GEANT_RZ_OUT_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_OUT_CHOPT = { "CHOPT", 5, "Option", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_OUT_CHOPT_type };
static KmParameter *_GEANT_RZ_OUT_parameters[] = { &_GEANT_RZ_OUT_OBJECT,
 &_GEANT_RZ_OUT_IDVERS, &_GEANT_RZ_OUT_CHOPT };
static char *_GEANT_RZ_OUT_guidance[] = {
 "Write data structure identified by OBJECT,IDVERS to RZ file.",
 "  MATE write JMATE structure", "  TMED write JTMED structure",
 "  VOLU write JVOLUM structure", "  ROTM write JROTM structure",
 "  SETS write JSET  structure", "  PART write JPART structure",
 "  SCAN write LSCAN structure", "  INIT write all above data structures" };
static KmCommand _GEANT_RZ_OUT = { &_GEANT_RZ_LDIR, "/GEANT/RZ/OUT", "OUT", 0,
 2, 3, 1, _GEANT_RZ_OUT_parameters, 0, 0, gxrz_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 9, _GEANT_RZ_OUT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_IN_OBJECT = { "OBJECT", 6, "Structure name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_RZ_IN_IDVERS_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_IN_IDVERS = { "IDVERS", 6, "Version number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_IN_IDVERS_type };
static KmParOption _GEANT_RZ_IN_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_IN_CHOPT = { "CHOPT", 5, "Option", " ", (char*)0,
 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_IN_CHOPT_type };
static KmParameter *_GEANT_RZ_IN_parameters[] = { &_GEANT_RZ_IN_OBJECT,
 &_GEANT_RZ_IN_IDVERS, &_GEANT_RZ_IN_CHOPT };
static char *_GEANT_RZ_IN_guidance[] = {
 "Read data structure identified by OBJECT,IDVERS into memory.",
 "  MATE read JMATE structure", "  TMED read JTMED structure",
 "  VOLU read JVOLUM structure", "  ROTM read JROTM structure",
 "  SETS read JSET  structure", "  PART read JPART structure",
 "  SCAN read LSCAN structure", "  INIT read all above data structures" };
static KmCommand _GEANT_RZ_IN = { &_GEANT_RZ_OUT, "/GEANT/RZ/IN", "IN", 0, 2,
 3, 1, _GEANT_RZ_IN_parameters, 0, 0, gxrz_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 9, _GEANT_RZ_IN_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_CDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParOption _GEANT_RZ_CDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_CDIR_CHOPT = { "CHOPT", 5, "CHOPT", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_CDIR_CHOPT_type };
static KmParameter *_GEANT_RZ_CDIR_parameters[] = { &_GEANT_RZ_CDIR_CHPATH,
 &_GEANT_RZ_CDIR_CHOPT };
static char *_GEANT_RZ_CDIR_guidance[] = {
 "Change or print the current directory.",
 " Ex.  CD dir1         ; make DIR1 the new CWD",
 "      CD //file1/dir2 ; make //FILE1/DIR2 the new CWD",
 "      CD              ; print the name of the CWD" };
static KmCommand _GEANT_RZ_CDIR = { &_GEANT_RZ_IN, "/GEANT/RZ/CDIR", "CDIR",
 0, 2, 2, 0, _GEANT_RZ_CDIR_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _GEANT_RZ_CDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_MDIR_CHDIR = { "CHDIR", 5, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParOption _GEANT_RZ_MDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_MDIR_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_MDIR_CHOPT_type };
static KmParameter *_GEANT_RZ_MDIR_parameters[] = { &_GEANT_RZ_MDIR_CHDIR,
 &_GEANT_RZ_MDIR_CHOPT };
static char *_GEANT_RZ_MDIR_guidance[] = {
 "To create a new RZ directory below the current directory.", "with",
 " RZTAGS(1)='Object'", " RZTAGS(2)='Idvers-NR '" };
static KmCommand _GEANT_RZ_MDIR = { &_GEANT_RZ_CDIR, "/GEANT/RZ/MDIR", "MDIR",
 0, 2, 2, 1, _GEANT_RZ_MDIR_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _GEANT_RZ_MDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_REND_LUNRZ_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_REND_LUNRZ = { "LUNRZ", 5, "Logical unit number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_REND_LUNRZ_type };
static KmParameter *_GEANT_RZ_REND_parameters[] = { &_GEANT_RZ_REND_LUNRZ };
static char *_GEANT_RZ_REND_guidance[] = {
 "Close an RZ file opened by GRFILE on logical unit LUNRZ.",
 " CALL GREND(LUNRZ)" };
static KmCommand _GEANT_RZ_REND = { &_GEANT_RZ_MDIR, "/GEANT/RZ/REND", "REND",
 0, 2, 1, 1, _GEANT_RZ_REND_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_RZ_REND_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_FILE_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_FILE_LUN_type };
static KmParameter _GEANT_RZ_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_GEANT_RZ_FILE_CHOPT_range[] = { " ", "A", "N", "U" };
static char *_GEANT_RZ_FILE_CHOPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _GEANT_RZ_FILE_CHOPT_type = { _GEANT_RZ_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_FILE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _GEANT_RZ_FILE_CHOPT_range, 4, _GEANT_RZ_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_RZ_FILE_CHOPT_type };
static KmParameter *_GEANT_RZ_FILE_parameters[] = { &_GEANT_RZ_FILE_LUN,
 &_GEANT_RZ_FILE_FNAME, &_GEANT_RZ_FILE_CHOPT };
static char *_GEANT_RZ_FILE_guidance[] = { "Open a GRZ file.",
 " CHOPT=' ' readonly mode", " CHOPT='U' update mode",
 " CHOPT='N' create new file",
 " CHOPT='I' Read all structures from existing file",
 " CHOPT='O' Write all structures on file" };
static KmCommand _GEANT_RZ_FILE = { &_GEANT_RZ_REND, "/GEANT/RZ/FILE", "FILE",
 0, 2, 3, 2, _GEANT_RZ_FILE_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _GEANT_RZ_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_PQUEST_IQ1_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_PQUEST_IQ1 = { "IQ1", 3,
 "Lower limit for IQ index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_RZ_PQUEST_IQ1_type };
static KmParInt    _GEANT_RZ_PQUEST_IQ2_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_PQUEST_IQ2 = { "IQ2", 3,
 "Upper limit for IQ index", "20", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_RZ_PQUEST_IQ2_type };
static KmParameter *_GEANT_RZ_PQUEST_parameters[] = { &_GEANT_RZ_PQUEST_IQ1,
 &_GEANT_RZ_PQUEST_IQ2 };
static char *_GEANT_RZ_PQUEST_guidance[] = {
 "Print the array IQUEST in /QUEST/." };
static KmCommand _GEANT_RZ_PQUEST = { &_GEANT_RZ_FILE, "/GEANT/RZ/PQUEST",
 "PQUEST", 0, 2, 2, 0, _GEANT_RZ_PQUEST_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_PQUEST_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_RZ_guidance[] = { "ZEBRA/RZ commands." };
static KmMenu _GEANT_RZ = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/RZ", "RZ", 2,
 &_GEANT_RZ_PQUEST, 1, _GEANT_RZ_guidance, 0, (char**)0, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_RZ, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkscan_ gkscan
#  define gxscan_ gxscan
#endif

#ifdef F77_UCASE
#  define gkscan_ GKSCAN
#  define gxscan_ GXSCAN
#endif

#ifdef IBM370
#  pragma linkage(GKSCAN,FORTRAN)
#  pragma linkage(GXSCAN,FORTRAN)
#endif

extern void gkscan_();
extern void gxscan_();

void gkscan_()
{

static KmParInt    _GEANT_SCAN_HSCAN_IDPHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_HSCAN_IDPHI = { "IDPHI", 5,
 "Histogram/phi identifier", "1000", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_HSCAN_IDPHI_type };
static KmParameter _GEANT_SCAN_HSCAN_VOLUME = { "VOLUME", 6, "Volume name",
 "XXXX", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_GEANT_SCAN_HSCAN_CHOPT_range[] = { " ", "O", "P", "I", "X", "L"
 };
static char *_GEANT_SCAN_HSCAN_CHOPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_SCAN_HSCAN_CHOPT_type = {
 _GEANT_SCAN_HSCAN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_SCAN_HSCAN_CHOPT = { "CHOPT", 5, "List of options",
 "OPX", (char*)0, 8, 6, _GEANT_SCAN_HSCAN_CHOPT_range, 6,
 _GEANT_SCAN_HSCAN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_SCAN_HSCAN_CHOPT_type };
static KmParameter *_GEANT_SCAN_HSCAN_parameters[] = {
 &_GEANT_SCAN_HSCAN_IDPHI, &_GEANT_SCAN_HSCAN_VOLUME, &_GEANT_SCAN_HSCAN_CHOPT
 };
static char *_GEANT_SCAN_HSCAN_guidance[] = {
 "Generates and plots an histogram of physics quantities such as",
 "the total number of radiation lengths or interaction lengths",
 "as a function of the SCAN parameter TETA for a given value of PHI.",
 "  CHOPT='O' histogram is generated at Exit  of VOLUME.",
 "  CHOPT='I' histogram is generated at Entry of VOLUME.",
 "  CHOPT='X' radiation lengths", "  CHOPT='L' Interaction lengths",
 "  CHOPT='P' Plot the histogram", "If VOLUME='XXXX' Mother volume is used.",
 "The histogram identifier IDPHI is used to also identify which",
 "PHI division to plot: IPHI=MOD(IDPHI,1000).",
 "If IPHI=0, then all PHI divisions are generated (not plotted)",
 "with histogram identifiers IDPHI+PHI division number." };
static KmCommand _GEANT_SCAN_HSCAN = {  (KmCommand*)0, "/GEANT/SCAN/HSCAN",
 "HSCAN", 0, 2, 3, 1, _GEANT_SCAN_HSCAN_parameters, 0, 0, gxscan_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13, _GEANT_SCAN_HSCAN_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_LSCAN_ID_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_SCAN_LSCAN_ID = { "ID", 2, "Lego plot identifier",
 "2000", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_SCAN_LSCAN_ID_type };
static KmParameter _GEANT_SCAN_LSCAN_VOLUME = { "VOLUME", 6, "Volume name",
 "XXXX", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_GEANT_SCAN_LSCAN_CHOPT_range[] = { " ", "O", "P", "I", "X", "L"
 };
static char *_GEANT_SCAN_LSCAN_CHOPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_SCAN_LSCAN_CHOPT_type = {
 _GEANT_SCAN_LSCAN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_SCAN_LSCAN_CHOPT = { "CHOPT", 5, "List of options",
 "OPX", (char*)0, 8, 6, _GEANT_SCAN_LSCAN_CHOPT_range, 6,
 _GEANT_SCAN_LSCAN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_SCAN_LSCAN_CHOPT_type };
static KmParameter *_GEANT_SCAN_LSCAN_parameters[] = { &_GEANT_SCAN_LSCAN_ID,
 &_GEANT_SCAN_LSCAN_VOLUME, &_GEANT_SCAN_LSCAN_CHOPT };
static char *_GEANT_SCAN_LSCAN_guidance[] = {
 "Generates and plot a table of physics quantities such as",
 "the total number of radiation lengths or interaction lengths",
 "in function of the SCAN parameters TETA,PHI.",
 "  CHOPT='O' table is generated at Exit  of VOLUME.",
 "  CHOPT='I' table is generated at Entry of VOLUME.",
 "  CHOPT='X' radiation lengths", "  CHOPT='L' Interaction lengths",
 "  CHOPT='P' Plot the table", "If VOLUME='XXXX' Mother volume is used." };
static KmCommand _GEANT_SCAN_LSCAN = { &_GEANT_SCAN_HSCAN,
 "/GEANT/SCAN/LSCAN", "LSCAN", 0, 2, 3, 1, _GEANT_SCAN_LSCAN_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _GEANT_SCAN_LSCAN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_PCUTS_IPARAM_type = { "0", "1", "0", "1", 0 };
static KmParameter _GEANT_SCAN_PCUTS_IPARAM = { "IPARAM", 6,
 "Parametrization Flag", (char*)0, (char*)0, 2, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_PCUTS_IPARAM_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTGA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTGA = { "PCUTGA", 6,
 "Parametrization Cut for gammas", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PCUTS_PCUTGA_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTEL = { "PCUTEL", 6,
 "Parametrization Cut for electrons", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PCUTS_PCUTEL_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTHA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTHA = { "PCUTHA", 6,
 "Parametrization Cut for charged hadrons", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_PCUTS_PCUTHA_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTNE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTNE = { "PCUTNE", 6,
 "Parametrization Cut for neutral hadrons", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_PCUTS_PCUTNE_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTMU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTMU = { "PCUTMU", 6,
 "Parametrization Cut for muons", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PCUTS_PCUTMU_type };
static KmParameter *_GEANT_SCAN_PCUTS_parameters[] = {
 &_GEANT_SCAN_PCUTS_IPARAM, &_GEANT_SCAN_PCUTS_PCUTGA,
 &_GEANT_SCAN_PCUTS_PCUTEL, &_GEANT_SCAN_PCUTS_PCUTHA,
 &_GEANT_SCAN_PCUTS_PCUTNE, &_GEANT_SCAN_PCUTS_PCUTMU };
static char *_GEANT_SCAN_PCUTS_guidance[] = {
 "Control parametrization at tracking time.",
 "     IPARAM=0       No parametrization is performed",
 "     IPARAM=1       Parametrization is performed",
 "If parametrization is active and a particle falls below its",
 "parametrization cut, then the particle will be replaced by",
 "a parametrized shower which will be tracked in the SCAN", "geometry." };
static KmCommand _GEANT_SCAN_PCUTS = { &_GEANT_SCAN_LSCAN,
 "/GEANT/SCAN/PCUTS", "PCUTS", 0, 2, 6, 0, _GEANT_SCAN_PCUTS_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7,
 _GEANT_SCAN_PCUTS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_SCAN_STURN_CHOPT_range[] = { "ON", "OFF", "INIT" };
static char *_GEANT_SCAN_STURN_CHOPT_text[] = { (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_SCAN_STURN_CHOPT_type = {
 _GEANT_SCAN_STURN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_SCAN_STURN_CHOPT = { "CHOPT", 5,
 "SCAN mode setting", (char*)0, (char*)0, 8, 3, _GEANT_SCAN_STURN_CHOPT_range,
 3, _GEANT_SCAN_STURN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_SCAN_STURN_CHOPT_type };
static KmParameter *_GEANT_SCAN_STURN_parameters[] = {
 &_GEANT_SCAN_STURN_CHOPT };
static char *_GEANT_SCAN_STURN_guidance[] = {
 "Switch on/off SCAN mode. If SCAN mode is on, SCAN geantinos",
 "are generated and tracked to fill (or complete) the current",
 "scan data structure. If SCAN mode is off, normal kinematics",
 "generation and tracking will take place. If INIT is given,",
 "the current SCAN data structure (if any) will be dropped",
 "and SCAN mode will be turned on." };
static KmCommand _GEANT_SCAN_STURN = { &_GEANT_SCAN_PCUTS,
 "/GEANT/SCAN/STURN", "STURN", 0, 2, 1, 1, _GEANT_SCAN_STURN_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_SCAN_STURN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_SCAN_SFACTORS_FACTX0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_SFACTORS_FACTX0 = { "FACTX0", 6,
 "Scale factor for SX0", "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_SFACTORS_FACTX0_type };
static KmParReal   _GEANT_SCAN_SFACTORS_FACTL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_SFACTORS_FACTL = { "FACTL", 5,
 "Scale factor for SL", "1000.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_SFACTORS_FACTL_type };
static KmParReal   _GEANT_SCAN_SFACTORS_FACTR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_SFACTORS_FACTR = { "FACTR", 5,
 "Scale factor for R", "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_SFACTORS_FACTR_type };
static KmParameter *_GEANT_SCAN_SFACTORS_parameters[] = {
 &_GEANT_SCAN_SFACTORS_FACTX0, &_GEANT_SCAN_SFACTORS_FACTL,
 &_GEANT_SCAN_SFACTORS_FACTR };
static char *_GEANT_SCAN_SFACTORS_guidance[] = {
 "Set scale factors for SX0,SL and R. The given scale factors must be",
 "such that:", "  SX0*FACTX0 < 2**15-1 (32767)",
 "  SL*FACTL   < 2**10-1 (1023)", "  SR*FACTR   < 2**17-1 (131071)" };
static KmCommand _GEANT_SCAN_SFACTORS = { &_GEANT_SCAN_STURN,
 "/GEANT/SCAN/SFACTORS", "SFACTORS", 0, 2, 3, 3,
 _GEANT_SCAN_SFACTORS_parameters, 0, 0, gxscan_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 5, _GEANT_SCAN_SFACTORS_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_SCAN_VERTEX_VX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_VERTEX_VX = { "VX", 2, "Scan X-origin", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_VERTEX_VX_type };
static KmParReal   _GEANT_SCAN_VERTEX_VY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_VERTEX_VY = { "VY", 2, "Scan Y-origin", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_VERTEX_VY_type };
static KmParReal   _GEANT_SCAN_VERTEX_VZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_VERTEX_VZ = { "VZ", 2, "Scan Z-origin", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_VERTEX_VZ_type };
static KmParameter *_GEANT_SCAN_VERTEX_parameters[] = {
 &_GEANT_SCAN_VERTEX_VX, &_GEANT_SCAN_VERTEX_VY, &_GEANT_SCAN_VERTEX_VZ };
static char *_GEANT_SCAN_VERTEX_guidance[] = {
 "All Geantinos tracked will start from position VX,VY,VZ." };
static KmCommand _GEANT_SCAN_VERTEX = { &_GEANT_SCAN_SFACTORS,
 "/GEANT/SCAN/VERTEX", "VERTEX", 0, 2, 3, 3, _GEANT_SCAN_VERTEX_parameters, 0,
 0, gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_SCAN_VERTEX_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_SCAN_SLIST_LIST = { "LIST", 4,
 "List of master volumes", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_SCAN_SLIST_parameters[] = { &_GEANT_SCAN_SLIST_LIST
 };
static char *_GEANT_SCAN_SLIST_guidance[] = {
 "Only boundary crossings of volumes given in LIST will be seen",
 "in the SCAN geometry. If no parameters are given, the current",
 "SCAN volumes will be listed. If a full stop (.) is given, the list",
 "of scan volumes will be erased." };
static KmCommand _GEANT_SCAN_SLIST = { &_GEANT_SCAN_VERTEX,
 "/GEANT/SCAN/SLIST", "SLIST", 0, 2, 1, 1, _GEANT_SCAN_SLIST_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_SCAN_SLIST_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_TETA_NTETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_TETA_NTETA = { "NTETA", 5,
 "Number of TETA divisions", "90", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_TETA_NTETA_type };
static KmParReal   _GEANT_SCAN_TETA_TETMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_TETA_TETMIN = { "TETMIN", 6,
 "Minimum value of TETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_TETA_TETMIN_type };
static KmParReal   _GEANT_SCAN_TETA_TETMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_TETA_TETMAX = { "TETMAX", 6,
 "Maximum value of TETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_TETA_TETMAX_type };
static KmParInt    _GEANT_SCAN_TETA_DIVTYP_type = { "1", "3", "1", "3", 0 };
static KmParameter _GEANT_SCAN_TETA_DIVTYP = { "DIVTYP", 6,
 "Type of TETA division", (char*)0, (char*)0, 2, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_TETA_DIVTYP_type };
static KmParameter *_GEANT_SCAN_TETA_parameters[] = { &_GEANT_SCAN_TETA_NTETA,
 &_GEANT_SCAN_TETA_TETMIN, &_GEANT_SCAN_TETA_TETMAX, &_GEANT_SCAN_TETA_DIVTYP
 };
static char *_GEANT_SCAN_TETA_guidance[] = {
 "To specify number of divisions along TETA.",
 "If DIVTYP=1 divisions in pseudo-rapidity ETA.",
 "If DIVTYP=2 divisions in degrees following the THETA angle.",
 "If DIVTYP=3 divisions in cos(TETA).",
 "If no parameter is given, the current values of the parameters",
 "are displayed." };
static KmCommand _GEANT_SCAN_TETA = { &_GEANT_SCAN_SLIST, "/GEANT/SCAN/TETA",
 "TETA", 0, 2, 4, 1, _GEANT_SCAN_TETA_parameters, 0, 0, gxscan_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _GEANT_SCAN_TETA_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_PHI_NPHI_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_SCAN_PHI_NPHI = { "NPHI", 4,
 "Number of PHI divisions", "90", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_PHI_NPHI_type };
static KmParReal   _GEANT_SCAN_PHI_PHIMIN_type = { "0.", "360.", "0.", "360.",
 0 };
static KmParameter _GEANT_SCAN_PHI_PHIMIN = { "PHIMIN", 6,
 "Minimum PHI in degrees", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PHI_PHIMIN_type };
static KmParReal   _GEANT_SCAN_PHI_PHIMAX_type = { "0.", "360.", "0.", "360.",
 0 };
static KmParameter _GEANT_SCAN_PHI_PHIMAX = { "PHIMAX", 6,
 "Maximum PHI in degrees", "360.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PHI_PHIMAX_type };
static KmParameter *_GEANT_SCAN_PHI_parameters[] = { &_GEANT_SCAN_PHI_NPHI,
 &_GEANT_SCAN_PHI_PHIMIN, &_GEANT_SCAN_PHI_PHIMAX };
static char *_GEANT_SCAN_PHI_guidance[] = {
 "To specify number of divisions along PHI. If no parameter is",
 "given, the current values of the parameters are displayed." };
static KmCommand _GEANT_SCAN_PHI = { &_GEANT_SCAN_TETA, "/GEANT/SCAN/PHI",
 "PHI", 0, 2, 3, 1, _GEANT_SCAN_PHI_parameters, 0, 0, gxscan_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_SCAN_PHI_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_SCAN_guidance[] = {
 "To define parameters for the SCAN geometry. If the routine GUSTEP",
 "and GUKINE are properly instrumented (see examples in GEANX),",
 "when the TRI command is entered NTETA Geantinos will be",
 "tracked through the real detector starting at the vertex position",
 "defined by the command vertex. A simplified version of the geometry",
 "is automatically generated in (ETA,PHI) or (THETA,PHI) following",
 "the option given in the command TETA. The data structure LSCAN",
 "generated may be saved on an RZ file for subsequent processing.",
 "This data structure may be used for fast parametrization techniques." };
static KmMenu _GEANT_SCAN = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/SCAN", "SCAN",
 2, &_GEANT_SCAN_PHI, 9, _GEANT_SCAN_guidance, 0, (char**)0, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_SCAN, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkphys_ gkphys
#  define gxphys_ gxphys
#endif

#ifdef F77_UCASE
#  define gkphys_ GKPHYS
#  define gxphys_ GXPHYS
#endif

#ifdef IBM370
#  pragma linkage(GKPHYS,FORTRAN)
#  pragma linkage(GXPHYS,FORTRAN)
#endif

extern void gkphys_();
extern void gxphys_();

void gkphys_()
{

static char *_GEANT_PHYSICS_PHYSI_guidance[] = {
 "Call the GEANT initialisation routine GPHYSI to recompute",
 "the tables of cross-sections and energy loss. This command",
 "must be invoked after CUTS, LOSS or ERAN commands." };
static KmCommand _GEANT_PHYSICS_PHYSI = {  (KmCommand*)0,
 "/GEANT/PHYSICS/PHYSI", "PHYSI", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxphys_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_PHYSICS_PHYSI_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_PHYSICS_DRPRT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_IPART = { "IPART", 5,
 "GEANT particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_PHYSICS_DRPRT_IPART_type };
static KmParInt    _GEANT_PHYSICS_DRPRT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_IMATE = { "IMATE", 5,
 "GEANT material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_PHYSICS_DRPRT_IMATE_type };
static KmParReal   _GEANT_PHYSICS_DRPRT_STEP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_STEP = { "STEP", 4,
 "step length in centimeters", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_DRPRT_STEP_type };
static KmParInt    _GEANT_PHYSICS_DRPRT_NPOINT_type = { "2", "100", "2",
 "100", 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_NPOINT = { "NPOINT", 6,
 "number of logarithmically spaced energy points", "10", (char*)0, 4, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_DRPRT_NPOINT_type };
static KmParameter *_GEANT_PHYSICS_DRPRT_parameters[] = {
 &_GEANT_PHYSICS_DRPRT_IPART, &_GEANT_PHYSICS_DRPRT_IMATE,
 &_GEANT_PHYSICS_DRPRT_STEP, &_GEANT_PHYSICS_DRPRT_NPOINT };
static char *_GEANT_PHYSICS_DRPRT_guidance[] = {
 "This routine prints the relevant parameters linked with the energy loss",
 "fluctuation." };
static KmCommand _GEANT_PHYSICS_DRPRT = { &_GEANT_PHYSICS_PHYSI,
 "/GEANT/PHYSICS/DRPRT", "DRPRT", 0, 2, 4, 3, _GEANT_PHYSICS_DRPRT_parameters,
 0, 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_PHYSICS_DRPRT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_PHYSICS_CUTS_CUTGAM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTGAM = { "CUTGAM", 6,
 "Cut for gammas", "0.001", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTGAM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTELE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTELE = { "CUTELE", 6,
 "Cut for electrons", "0.001", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTELE_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTHAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTHAD = { "CUTHAD", 6,
 "Cut for charged hadrons", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTHAD_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTNEU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTNEU = { "CUTNEU", 6,
 "Cut for neutral hadrons", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTNEU_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTMUO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTMUO = { "CUTMUO", 6,
 "Cut for muons", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTMUO_type };
static KmParReal   _GEANT_PHYSICS_CUTS_BCUTE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_BCUTE = { "BCUTE", 5,
 "Cut for electron brems.", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_BCUTE_type };
static KmParReal   _GEANT_PHYSICS_CUTS_BCUTM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_BCUTM = { "BCUTM", 5,
 "Cut for muon brems.", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_BCUTM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_DCUTE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_DCUTE = { "DCUTE", 5,
 "Cut for electron delta-rays", "-1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_DCUTE_type };
static KmParReal   _GEANT_PHYSICS_CUTS_DCUTM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_DCUTM = { "DCUTM", 5,
 "Cut for muon delta-rays", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_DCUTM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_PPCUTM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_PPCUTM = { "PPCUTM", 6,
 "Cut for e+e- pairs by muons", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_PPCUTM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_TOFMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_TOFMAX = { "TOFMAX", 6,
 "Time of flight cut", "1.E+10", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_TOFMAX_type };
static KmParReal   _GEANT_PHYSICS_CUTS_GCUTS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_GCUTS = { "GCUTS", 5, "5 user words",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_PHYSICS_CUTS_GCUTS_type };
static KmParameter *_GEANT_PHYSICS_CUTS_parameters[] = {
 &_GEANT_PHYSICS_CUTS_CUTGAM, &_GEANT_PHYSICS_CUTS_CUTELE,
 &_GEANT_PHYSICS_CUTS_CUTHAD, &_GEANT_PHYSICS_CUTS_CUTNEU,
 &_GEANT_PHYSICS_CUTS_CUTMUO, &_GEANT_PHYSICS_CUTS_BCUTE,
 &_GEANT_PHYSICS_CUTS_BCUTM, &_GEANT_PHYSICS_CUTS_DCUTE,
 &_GEANT_PHYSICS_CUTS_DCUTM, &_GEANT_PHYSICS_CUTS_PPCUTM,
 &_GEANT_PHYSICS_CUTS_TOFMAX, &_GEANT_PHYSICS_CUTS_GCUTS };
static char *_GEANT_PHYSICS_CUTS_guidance[] = {
 "To change physics cuts. If no parameter is given, the list",
 "of the current cuts is printed.",
 " If the default values (-1.) for       BCUTE ,BCUTM ,DCUTE ,DCUTM",
 " are not modified, they will be set to CUTGAM,CUTGAM,CUTELE,CUTELE",
 " respectively.", "If one of the parameters from CUTGAM to PPCUTM included",
 "is modified, cross-sections and energy loss tables must be",
 "recomputed via the command 'PHYSI'." };
static KmCommand _GEANT_PHYSICS_CUTS = { &_GEANT_PHYSICS_DRPRT,
 "/GEANT/PHYSICS/CUTS", "CUTS", 0, 2, 12, 0, _GEANT_PHYSICS_CUTS_parameters,
 0, 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_PHYSICS_CUTS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_SYNC_ISYNC_range[] = { "0", "1" };
static KmParInt    _GEANT_PHYSICS_SYNC_ISYNC_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_SYNC_ISYNC = { "ISYNC", 5, "Flag ISYNC",
 "1", (char*)0, 8, 2, _GEANT_PHYSICS_SYNC_ISYNC_range, 2,
 _GEANT_PHYSICS_SYNC_ISYNC_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_SYNC_ISYNC_type };
static KmParameter *_GEANT_PHYSICS_SYNC_parameters[] = {
 &_GEANT_PHYSICS_SYNC_ISYNC };
static char *_GEANT_PHYSICS_SYNC_guidance[] = {
 "To control synchrotron radiation:", " ISYNC=0 no synchrotron radiation;",
 "      =1 synchrotron radiation." };
static KmCommand _GEANT_PHYSICS_SYNC = { &_GEANT_PHYSICS_CUTS,
 "/GEANT/PHYSICS/SYNC", "SYNC", 0, 2, 1, 0, _GEANT_PHYSICS_SYNC_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_SYNC_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_STRA_ISTRA_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_STRA_ISTRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_STRA_ISTRA = { "ISTRA", 5, "Flag ISTRA",
 "0", (char*)0, 8, 3, _GEANT_PHYSICS_STRA_ISTRA_range, 3,
 _GEANT_PHYSICS_STRA_ISTRA_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_STRA_ISTRA_type };
static KmParameter *_GEANT_PHYSICS_STRA_parameters[] = {
 &_GEANT_PHYSICS_STRA_ISTRA };
static char *_GEANT_PHYSICS_STRA_guidance[] = {
 "To control energy loss fluctuation model:", " ISTRA=0 Urban model;",
 "      =1 PAI model;", "      =2 PAI+ASHO model (not active at the moment)."
 };
static KmCommand _GEANT_PHYSICS_STRA = { &_GEANT_PHYSICS_SYNC,
 "/GEANT/PHYSICS/STRA", "STRA", 0, 2, 1, 0, _GEANT_PHYSICS_STRA_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_STRA_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_RAYL_IRAYL_range[] = { "0", "1" };
static KmParInt    _GEANT_PHYSICS_RAYL_IRAYL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_RAYL_IRAYL = { "IRAYL", 5, "Flag IRAYL",
 "1", (char*)0, 8, 2, _GEANT_PHYSICS_RAYL_IRAYL_range, 2,
 _GEANT_PHYSICS_RAYL_IRAYL_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_RAYL_IRAYL_type };
static KmParameter *_GEANT_PHYSICS_RAYL_parameters[] = {
 &_GEANT_PHYSICS_RAYL_IRAYL };
static char *_GEANT_PHYSICS_RAYL_guidance[] = {
 "To control Rayleigh scattering.", " IRAYL=0 no Rayleigh scattering.",
 "      =1 Rayleigh." };
static KmCommand _GEANT_PHYSICS_RAYL = { &_GEANT_PHYSICS_STRA,
 "/GEANT/PHYSICS/RAYL", "RAYL", 0, 2, 1, 0, _GEANT_PHYSICS_RAYL_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_RAYL_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_PHOT_IPHOT_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_PHOT_IPHOT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_PHOT_IPHOT = { "IPHOT", 5, "Flag IPHOT",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_PHOT_IPHOT_range, 3,
 _GEANT_PHYSICS_PHOT_IPHOT_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_PHOT_IPHOT_type };
static KmParameter *_GEANT_PHYSICS_PHOT_parameters[] = {
 &_GEANT_PHYSICS_PHOT_IPHOT };
static char *_GEANT_PHYSICS_PHOT_guidance[] = { "To control Photo effect.",
 " IPHOT=0 no photo electric effect.",
 "      =1 Photo effect. Electron processed.",
 "      =2 Photo effect. No electron stored." };
static KmCommand _GEANT_PHYSICS_PHOT = { &_GEANT_PHYSICS_RAYL,
 "/GEANT/PHYSICS/PHOT", "PHOT", 0, 2, 1, 0, _GEANT_PHYSICS_PHOT_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_PHOT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_PFIS_IPFIS_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_PFIS_IPFIS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_PFIS_IPFIS = { "IPFIS", 5, "Flag IPFIS",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_PFIS_IPFIS_range, 3,
 _GEANT_PHYSICS_PFIS_IPFIS_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_PFIS_IPFIS_type };
static KmParameter *_GEANT_PHYSICS_PFIS_parameters[] = {
 &_GEANT_PHYSICS_PFIS_IPFIS };
static char *_GEANT_PHYSICS_PFIS_guidance[] = {
 "To control photo fission mechanism.", " IPFIS=0 no photo fission.",
 "      =1 Photo fission. secondaries processed.",
 "      =2 Photo fission. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_PFIS = { &_GEANT_PHYSICS_PHOT,
 "/GEANT/PHYSICS/PFIS", "PFIS", 0, 2, 1, 0, _GEANT_PHYSICS_PFIS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_PFIS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_PAIR_IPAIR_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_PAIR_IPAIR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_PAIR_IPAIR = { "IPAIR", 5, "Flag IPAIR",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_PAIR_IPAIR_range, 3,
 _GEANT_PHYSICS_PAIR_IPAIR_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_PAIR_IPAIR_type };
static KmParameter *_GEANT_PHYSICS_PAIR_parameters[] = {
 &_GEANT_PHYSICS_PAIR_IPAIR };
static char *_GEANT_PHYSICS_PAIR_guidance[] = {
 "To control pair production mechanism.", " IPAIR=0 no pair production.",
 "      =1 Pair production. secondaries processed.",
 "      =2 Pair production. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_PAIR = { &_GEANT_PHYSICS_PFIS,
 "/GEANT/PHYSICS/PAIR", "PAIR", 0, 2, 1, 0, _GEANT_PHYSICS_PAIR_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_PAIR_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_MUNU_IMUNU_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_MUNU_IMUNU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_MUNU_IMUNU = { "IMUNU", 5, "Flag IMUNU",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_MUNU_IMUNU_range, 3,
 _GEANT_PHYSICS_MUNU_IMUNU_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_MUNU_IMUNU_type };
static KmParameter *_GEANT_PHYSICS_MUNU_parameters[] = {
 &_GEANT_PHYSICS_MUNU_IMUNU };
static char *_GEANT_PHYSICS_MUNU_guidance[] = {
 "To control muon nuclear interactions.",
 " IMUNU=0 no muon-nuclear interactions.",
 "      =1 Nuclear interactions. Secondaries processed.",
 "      =2 Nuclear interactions. Secondaries not processed." };
static KmCommand _GEANT_PHYSICS_MUNU = { &_GEANT_PHYSICS_PAIR,
 "/GEANT/PHYSICS/MUNU", "MUNU", 0, 2, 1, 0, _GEANT_PHYSICS_MUNU_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_MUNU_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_MULS_IMULS_range[] = { "0", "1", "2", "3" };
static KmParInt    _GEANT_PHYSICS_MULS_IMULS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_MULS_IMULS = { "IMULS", 5, "Flag IMULS",
 "1", (char*)0, 8, 4, _GEANT_PHYSICS_MULS_IMULS_range, 4,
 _GEANT_PHYSICS_MULS_IMULS_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_MULS_IMULS_type };
static KmParameter *_GEANT_PHYSICS_MULS_parameters[] = {
 &_GEANT_PHYSICS_MULS_IMULS };
static char *_GEANT_PHYSICS_MULS_guidance[] = {
 "To control multiple scattering.", " IMULS=0 no multiple scattering.",
 "      =1 Moliere or Coulomb scattering.",
 "      =2 Moliere or Coulomb scattering.", "      =3 Gaussian scattering." };
static KmCommand _GEANT_PHYSICS_MULS = { &_GEANT_PHYSICS_MUNU,
 "/GEANT/PHYSICS/MULS", "MULS", 0, 2, 1, 0, _GEANT_PHYSICS_MULS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5,
 _GEANT_PHYSICS_MULS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_LOSS_ILOSS_range[] = { "0", "1", "2", "3", "4" };
static KmParInt    _GEANT_PHYSICS_LOSS_ILOSS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_LOSS_ILOSS = { "ILOSS", 5, "Flag ILOSS",
 "2", (char*)0, 8, 5, _GEANT_PHYSICS_LOSS_ILOSS_range, 5,
 _GEANT_PHYSICS_LOSS_ILOSS_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_LOSS_ILOSS_type };
static KmParameter *_GEANT_PHYSICS_LOSS_parameters[] = {
 &_GEANT_PHYSICS_LOSS_ILOSS };
static char *_GEANT_PHYSICS_LOSS_guidance[] = { "To control energy loss.",
 " ILOSS=0 no energy loss;", "      =1 restricted energy loss fluctuations;",
 "      =2 complete energy loss fluctuations;", "      =3 same as 1;",
 "      =4 no energy loss fluctuations.",
 "If the value ILOSS is changed, then cross-sections and energy loss",
 "tables must be recomputed via the command 'PHYSI'." };
static KmCommand _GEANT_PHYSICS_LOSS = { &_GEANT_PHYSICS_MULS,
 "/GEANT/PHYSICS/LOSS", "LOSS", 0, 2, 1, 0, _GEANT_PHYSICS_LOSS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_PHYSICS_LOSS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_PHYSICS_LABS_LABS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_LABS_LABS = { "LABS", 4, "Flag LABS", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_LABS_LABS_type };
static KmParameter *_GEANT_PHYSICS_LABS_parameters[] = {
 &_GEANT_PHYSICS_LABS_LABS };
static char *_GEANT_PHYSICS_LABS_guidance[] = {
 "To control absorbtion of Cerenkov photons:",
 "    LABS=0 no absorbtion of photons;", "    LABS=1 absorbtion of photons;" };
static KmCommand _GEANT_PHYSICS_LABS = { &_GEANT_PHYSICS_LOSS,
 "/GEANT/PHYSICS/LABS", "LABS", 0, 2, 1, 0, _GEANT_PHYSICS_LABS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_LABS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_PHYSICS_HADR_IHADR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_HADR_IHADR = { "IHADR", 5, "Flag IHADR",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_HADR_IHADR_type };
static KmParameter *_GEANT_PHYSICS_HADR_parameters[] = {
 &_GEANT_PHYSICS_HADR_IHADR };
static char *_GEANT_PHYSICS_HADR_guidance[] = {
 "To control hadronic interactions.", " IHADR=0 no hadronic interactions.",
 "      =1 Hadronic interactions. secondaries processed.",
 "      =2 Hadronic interactions. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_HADR = { &_GEANT_PHYSICS_LABS,
 "/GEANT/PHYSICS/HADR", "HADR", 0, 2, 1, 0, _GEANT_PHYSICS_HADR_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_HADR_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GEANT_PHYSICS_ERAN_EKMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_ERAN_EKMIN = { "EKMIN", 5,
 "Minimum energy of the tables", "1E-5", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_ERAN_EKMIN_type };
static KmParReal   _GEANT_PHYSICS_ERAN_EKMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_ERAN_EKMAX = { "EKMAX", 5,
 "Maximum energy of the tables", "1E+4", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_ERAN_EKMAX_type };
static KmParInt    _GEANT_PHYSICS_ERAN_NEKBIN_type = { "1", "200", "1", "200",
 0 };
static KmParameter _GEANT_PHYSICS_ERAN_NEKBIN = { "NEKBIN", 6,
 "Number of bins in the tables", "90", (char*)0, 4, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_PHYSICS_ERAN_NEKBIN_type };
static KmParameter *_GEANT_PHYSICS_ERAN_parameters[] = {
 &_GEANT_PHYSICS_ERAN_EKMIN, &_GEANT_PHYSICS_ERAN_EKMAX,
 &_GEANT_PHYSICS_ERAN_NEKBIN };
static char *_GEANT_PHYSICS_ERAN_guidance[] = {
 "To define the range and binning of internal tables." };
static KmCommand _GEANT_PHYSICS_ERAN = { &_GEANT_PHYSICS_HADR,
 "/GEANT/PHYSICS/ERAN", "ERAN", 0, 2, 3, 0, _GEANT_PHYSICS_ERAN_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_PHYSICS_ERAN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_DRAY_IDRAY_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_DRAY_IDRAY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRAY_IDRAY = { "IDRAY", 5, "Flag IDRAY",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_DRAY_IDRAY_range, 3,
 _GEANT_PHYSICS_DRAY_IDRAY_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_DRAY_IDRAY_type };
static KmParameter *_GEANT_PHYSICS_DRAY_parameters[] = {
 &_GEANT_PHYSICS_DRAY_IDRAY };
static char *_GEANT_PHYSICS_DRAY_guidance[] = {
 "To control delta rays mechanism.", " IDRAY=0 no delta rays.",
 "      =1 Delta rays. secondaries processed.",
 "      =2 Delta rays. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_DRAY = { &_GEANT_PHYSICS_ERAN,
 "/GEANT/PHYSICS/DRAY", "DRAY", 0, 2, 1, 0, _GEANT_PHYSICS_DRAY_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_DRAY_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_DCAY_IDCAY_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_DCAY_IDCAY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DCAY_IDCAY = { "IDCAY", 5, "Flag IDCAY",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_DCAY_IDCAY_range, 3,
 _GEANT_PHYSICS_DCAY_IDCAY_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_DCAY_IDCAY_type };
static KmParameter *_GEANT_PHYSICS_DCAY_parameters[] = {
 &_GEANT_PHYSICS_DCAY_IDCAY };
static char *_GEANT_PHYSICS_DCAY_guidance[] = { "To control Decay mechanism.",
 " IDCAY=0 no decays.", "      =1 Decays. secondaries processed.",
 "      =2 Decays. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_DCAY = { &_GEANT_PHYSICS_DRAY,
 "/GEANT/PHYSICS/DCAY", "DCAY", 0, 2, 1, 0, _GEANT_PHYSICS_DCAY_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_DCAY_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_COMP_ICOMP_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_COMP_ICOMP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_COMP_ICOMP = { "ICOMP", 5, "Flag ICOMP",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_COMP_ICOMP_range, 3,
 _GEANT_PHYSICS_COMP_ICOMP_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_COMP_ICOMP_type };
static KmParameter *_GEANT_PHYSICS_COMP_parameters[] = {
 &_GEANT_PHYSICS_COMP_ICOMP };
static char *_GEANT_PHYSICS_COMP_guidance[] = {
 "To control Compton scattering", " ICOMP=0 no Compton",
 "      =1 Compton. Electron processed.",
 "      =2 Compton. No electron stored." };
static KmCommand _GEANT_PHYSICS_COMP = { &_GEANT_PHYSICS_DCAY,
 "/GEANT/PHYSICS/COMP", "COMP", 0, 2, 1, 0, _GEANT_PHYSICS_COMP_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_COMP_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_CKOV_ICKOV_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_CKOV_ICKOV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CKOV_ICKOV = { "ICKOV", 5, "Flag ICKOV",
 "0", (char*)0, 8, 3, _GEANT_PHYSICS_CKOV_ICKOV_range, 3,
 _GEANT_PHYSICS_CKOV_ICKOV_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_CKOV_ICKOV_type };
static KmParameter *_GEANT_PHYSICS_CKOV_parameters[] = {
 &_GEANT_PHYSICS_CKOV_ICKOV };
static char *_GEANT_PHYSICS_CKOV_guidance[] = {
 "To control Cerenkov production", " ICOMP=0 no Cerenkov;",
 "      =1 Cerenkov;", "      =2 Cerenkov with primary stopped at each step."
 };
static KmCommand _GEANT_PHYSICS_CKOV = { &_GEANT_PHYSICS_COMP,
 "/GEANT/PHYSICS/CKOV", "CKOV", 0, 2, 1, 0, _GEANT_PHYSICS_CKOV_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_CKOV_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_BREM_IBREM_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_BREM_IBREM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_BREM_IBREM = { "IBREM", 5, "Flag IBREM",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_BREM_IBREM_range, 3,
 _GEANT_PHYSICS_BREM_IBREM_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_BREM_IBREM_type };
static KmParameter *_GEANT_PHYSICS_BREM_parameters[] = {
 &_GEANT_PHYSICS_BREM_IBREM };
static char *_GEANT_PHYSICS_BREM_guidance[] = { "To control bremstrahlung.",
 " IBREM=0 no bremstrahlung", "      =1 bremstrahlung. Photon processed.",
 "      =2 bremstrahlung. No photon stored." };
static KmCommand _GEANT_PHYSICS_BREM = { &_GEANT_PHYSICS_CKOV,
 "/GEANT/PHYSICS/BREM", "BREM", 0, 2, 1, 0, _GEANT_PHYSICS_BREM_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_BREM_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_AUTO_IAUTO_range[] = { "0", "1" };
static KmParInt    _GEANT_PHYSICS_AUTO_IAUTO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_AUTO_IAUTO = { "IAUTO", 5, "Flag IAUTO",
 "1", (char*)0, 8, 2, _GEANT_PHYSICS_AUTO_IAUTO_range, 2,
 _GEANT_PHYSICS_AUTO_IAUTO_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_AUTO_IAUTO_type };
static KmParameter *_GEANT_PHYSICS_AUTO_parameters[] = {
 &_GEANT_PHYSICS_AUTO_IAUTO };
static char *_GEANT_PHYSICS_AUTO_guidance[] = {
 "To control automatic calculation of tracking medium parameters:",
 " IAUTO=0 no automatic calculation;", "      =1 automati calculation." };
static KmCommand _GEANT_PHYSICS_AUTO = { &_GEANT_PHYSICS_BREM,
 "/GEANT/PHYSICS/AUTO", "AUTO", 0, 2, 1, 0, _GEANT_PHYSICS_AUTO_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_AUTO_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_ANNI_IANNI_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_ANNI_IANNI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_ANNI_IANNI = { "IANNI", 5, "Flag IANNI",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_ANNI_IANNI_range, 3,
 _GEANT_PHYSICS_ANNI_IANNI_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_ANNI_IANNI_type };
static KmParameter *_GEANT_PHYSICS_ANNI_parameters[] = {
 &_GEANT_PHYSICS_ANNI_IANNI };
static char *_GEANT_PHYSICS_ANNI_guidance[] = {
 "To control positron annihilation.", " IANNI=0 no annihilation",
 "      =1 annihilation. Decays processed.",
 "      =2 annihilation. No decay products stored." };
static KmCommand _GEANT_PHYSICS_ANNI = { &_GEANT_PHYSICS_AUTO,
 "/GEANT/PHYSICS/ANNI", "ANNI", 0, 2, 1, 0, _GEANT_PHYSICS_ANNI_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_ANNI_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_guidance[] = {
 "Commands to set physics parameters." };
static KmMenu _GEANT_PHYSICS = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/PHYSICS",
 "PHYSICS", 2, &_GEANT_PHYSICS_ANNI, 1, _GEANT_PHYSICS_guidance, 0, (char**)0,
 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_PHYSICS, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 950303 );
}


#ifdef F77_LCASE
#  define gkfort_ gkfort
#  define gxfort_ gxfort
#endif

#ifdef F77_UCASE
#  define gkfort_ GKFORT
#  define gxfort_ GXFORT
#endif

#ifdef IBM370
#  pragma linkage(GKFORT,FORTRAN)
#  pragma linkage(GXFORT,FORTRAN)
#endif

extern void gkfort_();
extern void gxfort_();

void gkfort_()
{

static KmParameter _FORTRAN_FORTRAN_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_FORTRAN_FORTRAN_parameters[] = { &_FORTRAN_FORTRAN_FNAME
 };
static char *_FORTRAN_FORTRAN_guidance[] = {
 "The routines in the file FNAME will be compiled by COMIS.",
 "If routines with names: UGEOM,GUKINE,GUOUT,UGLAST are found,",
 "then they will be automatically called by GXINT instead of",
 "the routines with the same names compiled with the standard",
 "Fortran compiler and linked with the application.",
 "The user callable routines from the GEANT library as well as",
 "routines from PACKLIB (HBOOK,HPLOT,HIGZ,ZEBRA) may be called",
 "from these user routines. All GEANT common blocks may be", "referenced.",
 "In case where the routine UGEOM is called several times,",
 "it is important to DROP all the initialisation data structures",
 "JVOLUM,JMATE,JTMED,etc already in memory by using the routine GIDROP.",
 " Example of an interactive session where the routine UGEOM is modified:",
 "", "   GEANT > Edit ugeom.for", "   GEANT > Fortran ugeom.for",
 "   GEANT > Call GIDROP", "   GEANT > Call UGEOM", "   GEANT > Dtree",
 "   GEANT > Edit ugeom.for", "   GEANT > Fortran ugeom.for",
 "   GEANT > Call GIDROP", "   GEANT > Call UGEOM", "   GEANT > Dtree",
 "If FNAME='-', calls to user routines is reset and standard",
 "routines called instead." };
static KmCommand _FORTRAN_FORTRAN = {  (KmCommand*)0, "/FORTRAN/FORTRAN",
 "FORTRAN", 0, 1, 1, 1, _FORTRAN_FORTRAN_parameters, 0, 0, gxfort_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 26, _FORTRAN_FORTRAN_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmMenu _FORTRAN = {  (KmMenu*)0,  (KmMenu*)0, "/FORTRAN", "FORTRAN", 1,
 &_FORTRAN_FORTRAN, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_FORTRAN, 950303 );
}

+SELF, IF=KUIP95A.

/*CMZ :          21/03/95  18.51.56  by  S.Giani*/
/*-- Author :*/
/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 921023      Generation date: Tue Mar 21 18:51:54 1995
 *
 * Input file: g321x.doc
 */

#if !defined(F77_LCASE) && !defined(F77_UCASE) && !defined(F77_USCORE)
#  if defined(__EXTENDED__) && !defined(IBM370) && !defined(_IBMR2)
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */

typedef struct _BrAction {      /*                                         */
  struct _BrAction *next;       /* link to next action binding             */
  BrActFlag   flags;            /*                                         */
  char       *text;             /* text line in menu                       */
  char       *user_text;        /* user text overriding CDF text (malloced)*/
  char       *accel;            /* accelerator                             */
  char       *exec;             /* action commands                         */
  SUBROUTINE *call_F;           /* action routine                          */
  IntFunc    *call_C;           /* action function                         */
  BrActTag    tag;              /* for which window the action is defined  */
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */

typedef struct _KmIcon {        /*                                         */
  struct _KmIcon *next;         /* link to next icon                       */
  char       *name;             /* unique identifier name                  */
  int         width;            /* width of the pixmap                     */
  int         height;           /* height of the pixmap                    */
  char       *bitmap;           /* bitmap data                             */
  KmPixmap    pix;              /* filled in Motif part                    */
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */

typedef enum {                  /*                                         */
  KmButtSensitive       = 0x00, /* sensitive button                        */
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */

extern struct {                        /*
    */   /* indirect calls to avoid linking HIGZ
    */   IntFunc    *graf_info_C;      /* pass display, open and close
 (ixmotif)  */   SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)
            */   SUBROUTINE *graf_pick_F;      /* identifying graphics objects
 (IGOBJ)    */   SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)
            */   SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)
            */   /* optional routines for Motif customization
            */   pCharFunc  *user_FallBk_C;    /* get application fallbacks
            */   IntFunc    *user_TopWid_C;    /* pass toplevel widget
 identifiers        */ } klnkaddr;                     /*
                    */

typedef enum {                  /*                                         */
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */

typedef struct {                /* file name                               */
  char         *filter_default; /* filter wildcard                         */
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */

typedef KmParInt KmParReal;     /* real and int have the same fields       */
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */

typedef struct _KmCommand {     /*                                         */
  struct _KmCommand *next;      /* link to next command                    */
  char         *path;           /* command path                            */
  char         *name;           /* command name                            */
  int           hidden;         /* flag if command is invisible            */
  int           level;          /* depth of submenus                       */
  int           total;          /* total number of parameters              */
  int           mandatory;      /* number of mandatory parameters          */
  KmParameter **par;            /* list of total parameter descriptions    */
  int           list_par;       /* index+1 of parameter taking a list      */
  int           xcount;         /* count number of action calls            */
  SUBROUTINE   *action_F;       /* action routine                          */
  IntFunc      *action_C;       /* action routine                          */
  SUBROUTINE   *user_help_F;    /* user help routine                       */
  pCharFunc    *user_help_C;    /* user help routine                       */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int           argc;           /* number of arguments entered             */
  char        **argv;           /* argc argument values                    */
  char         *argline;        /* argument line as entered                */
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */

typedef struct _KmMenu {        /*                                         */
  struct _KmMenu *next;         /* link to next menu                       */
  struct _KmMenu *down;         /* link to submenu                         */
  char         *path;           /* path of parent menu                     */
  char         *name;           /* menu name                               */
  int           level;          /* depth of submenus                       */
  KmCommand    *cmds;           /* link to first command                   */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */

#ifdef F77_LCASE
#  define gkdraw_ gkdraw
#  define gxdraw_ gxdraw
#  define gxpick_ gxpick
#endif

#ifdef F77_UCASE
#  define gkdraw_ GKDRAW
#  define gxdraw_ GXDRAW
#  define gxpick_ GXPICK
#endif

#ifdef IBM370
#  pragma linkage(GKDRAW,FORTRAN)
#  pragma linkage(GXDRAW,FORTRAN)
#  pragma linkage(GXPICK,FORTRAN)
#endif

extern void gkdraw_();
extern void gxdraw_();
extern void gxpick_();

void gkdraw_()
{

static KmParReal   _GEANT_CVOL_VALCUT_XCUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_VALCUT_XCUT = { "XCUT", 4,
 "x coordinate of cutted value", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_VALCUT_XCUT_type };
static KmParReal   _GEANT_CVOL_VALCUT_YCUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_VALCUT_YCUT = { "YCUT", 4,
 "y coordinate of cutted value", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_VALCUT_YCUT_type };
static KmParReal   _GEANT_CVOL_VALCUT_ZCUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_VALCUT_ZCUT = { "ZCUT", 4,
 "z coordinate of cutted value", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_VALCUT_ZCUT_type };
static KmParameter *_GEANT_CVOL_VALCUT_parameters[] = {
 &_GEANT_CVOL_VALCUT_XCUT, &_GEANT_CVOL_VALCUT_YCUT, &_GEANT_CVOL_VALCUT_ZCUT
 };
static char *_GEANT_CVOL_VALCUT_guidance[] = {
 "It allows the cutting in the ray-tracing. All the volumes are cutted",
 "from XCUT to +BIG along the x axis, from YCUT to +BIG along the y axis",
 "and from ZCUT to +BIG along the z axis." };
static KmCommand _GEANT_CVOL_VALCUT = {  (KmCommand*)0, "/GEANT/CVOL/VALCUT",
 "VALCUT", 0, 2, 3, 3, _GEANT_CVOL_VALCUT_parameters, 0, 0, gxdraw_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_CVOL_VALCUT_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_SPHE_CNVV = { "CNVV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_SPHE_RMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_RMAX = { "RMAX", 4,
 " External radius of sphere             ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_SPHE_RMAX_type };
static KmParReal   _GEANT_CVOL_SPHE_XMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_XMED = { "XMED", 4,
 " Center X coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_SPHE_XMED_type };
static KmParReal   _GEANT_CVOL_SPHE_YMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_YMED = { "YMED", 4,
 " Center Y coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_SPHE_YMED_type };
static KmParReal   _GEANT_CVOL_SPHE_ZMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_SPHE_ZMED = { "ZMED", 4,
 " Center Z coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_SPHE_ZMED_type };
static KmParameter *_GEANT_CVOL_SPHE_parameters[] = { &_GEANT_CVOL_SPHE_CNVV,
 &_GEANT_CVOL_SPHE_RMAX, &_GEANT_CVOL_SPHE_XMED, &_GEANT_CVOL_SPHE_YMED,
 &_GEANT_CVOL_SPHE_ZMED };
static char *_GEANT_CVOL_SPHE_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a sphere; the sphere has the given parameters and is placed in",
 "the MARS according to the given coordinates of its center.",
 "See also CVOL. The following commands clip by a sphere,",
 "positioned according to the given parameters, the volume specified",
 "by NAME (a valid string for the NAME of the volume",
 "can be found using the DTREE command).", "EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " sphe * 500 0 0 500", " draw NAME 40 40 0 10 10 .01 .01", " box ." };
static KmCommand _GEANT_CVOL_SPHE = { &_GEANT_CVOL_VALCUT, "/GEANT/CVOL/SPHE",
 "SPHE", 0, 2, 5, 1, _GEANT_CVOL_SPHE_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _GEANT_CVOL_SPHE_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_CONE_CNVV = { "CNVV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_CONE_RMAX1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_RMAX1 = { "RMAX1", 5,
 " Min external radius                   ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_CONE_RMAX1_type };
static KmParReal   _GEANT_CVOL_CONE_RMAX2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_RMAX2 = { "RMAX2", 5,
 " Max external radius                   ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_CONE_RMAX2_type };
static KmParReal   _GEANT_CVOL_CONE_ZDEM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_ZDEM = { "ZDEM", 4,
 " Half length of cone axis              ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_CONE_ZDEM_type };
static KmParReal   _GEANT_CVOL_CONE_XMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_XMED = { "XMED", 4,
 " Center X coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_CONE_XMED_type };
static KmParReal   _GEANT_CVOL_CONE_YMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_YMED = { "YMED", 4,
 " Center Y coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_CONE_YMED_type };
static KmParReal   _GEANT_CVOL_CONE_ZMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_CONE_ZMED = { "ZMED", 4,
 " Center Z coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_CONE_ZMED_type };
static KmParameter *_GEANT_CVOL_CONE_parameters[] = { &_GEANT_CVOL_CONE_CNVV,
 &_GEANT_CVOL_CONE_RMAX1, &_GEANT_CVOL_CONE_RMAX2, &_GEANT_CVOL_CONE_ZDEM,
 &_GEANT_CVOL_CONE_XMED, &_GEANT_CVOL_CONE_YMED, &_GEANT_CVOL_CONE_ZMED };
static char *_GEANT_CVOL_CONE_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a cone; the cone has the given parameters and is placed in",
 "the MARS according to the given coordinates of its center.",
 "See also CVOL.", "The following commands will clip by a cone,",
 "positioned according the given parameters, the volume specified",
 "by NAME (a valid string for the NAME of the volume",
 "can be found using the DTREE command).", " EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " cone * 1 750 1000 0 0 1000", " draw NAME 40 40 0 10 10 .01 .01", " box ." };
static KmCommand _GEANT_CVOL_CONE = { &_GEANT_CVOL_SPHE, "/GEANT/CVOL/CONE",
 "CONE", 0, 2, 7, 1, _GEANT_CVOL_CONE_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 16, _GEANT_CVOL_CONE_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_TUBE_CNVV = { "CNVV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_TUBE_RMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_RMAX = { "RMAX", 4,
 " External radius of tube               ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_TUBE_RMAX_type };
static KmParReal   _GEANT_CVOL_TUBE_ZDEM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_ZDEM = { "ZDEM", 4,
 " Half length of tube axis              ", "0.1", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CVOL_TUBE_ZDEM_type };
static KmParReal   _GEANT_CVOL_TUBE_XMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_XMED = { "XMED", 4,
 " Center X coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_TUBE_XMED_type };
static KmParReal   _GEANT_CVOL_TUBE_YMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_YMED = { "YMED", 4,
 " Center Y coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_TUBE_YMED_type };
static KmParReal   _GEANT_CVOL_TUBE_ZMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CVOL_TUBE_ZMED = { "ZMED", 4,
 " Center Z coordinate                   ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_TUBE_ZMED_type };
static KmParameter *_GEANT_CVOL_TUBE_parameters[] = { &_GEANT_CVOL_TUBE_CNVV,
 &_GEANT_CVOL_TUBE_RMAX, &_GEANT_CVOL_TUBE_ZDEM, &_GEANT_CVOL_TUBE_XMED,
 &_GEANT_CVOL_TUBE_YMED, &_GEANT_CVOL_TUBE_ZMED };
static char *_GEANT_CVOL_TUBE_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a tube; the tube has the given parameters and is placed in",
 "the MARS according the given coordinates of its center.", "See also CVOL.",
 "The following commands will clip, by a tube,",
 "positioned according to the given parameters, the volume specified",
 "by NAME (a valid string for the NAME of the volume",
 "can be found using the DTREE command).", " EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " tube * 500 1000 500 0 0", " draw NAME 40 40 0 10 10 .01 .01", " box ." };
static KmCommand _GEANT_CVOL_TUBE = { &_GEANT_CVOL_CONE, "/GEANT/CVOL/TUBE",
 "TUBE", 0, 2, 6, 1, _GEANT_CVOL_TUBE_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 16, _GEANT_CVOL_TUBE_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_CVOL_BOX_CNNV = { "CNNV", 4,
 " Name of volume to be clipped          ", "*   ", (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CVOL_BOX_XMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_XMIN = { "XMIN", 4,
 " Lower limit of the Shape X coordinate ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_XMIN_type };
static KmParReal   _GEANT_CVOL_BOX_XMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_XMAX = { "XMAX", 4,
 " Upper limit of the Shape X coordinate ", "-9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_XMAX_type };
static KmParReal   _GEANT_CVOL_BOX_YMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_YMIN = { "YMIN", 4,
 " Lower limit of the Shape Y coordinate ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_YMIN_type };
static KmParReal   _GEANT_CVOL_BOX_YMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_YMAX = { "YMAX", 4,
 " Upper limit of the Shape Y coordinate ", "-9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_YMAX_type };
static KmParReal   _GEANT_CVOL_BOX_ZMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_ZMIN = { "ZMIN", 4,
 " Lower limit of the Shape Z coordinate ", "-10000.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_ZMIN_type };
static KmParReal   _GEANT_CVOL_BOX_ZMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_CVOL_BOX_ZMAX = { "ZMAX", 4,
 " Upper limit of the Shape Z coordinate ", "-9999.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CVOL_BOX_ZMAX_type };
static KmParameter *_GEANT_CVOL_BOX_parameters[] = { &_GEANT_CVOL_BOX_CNNV,
 &_GEANT_CVOL_BOX_XMIN, &_GEANT_CVOL_BOX_XMAX, &_GEANT_CVOL_BOX_YMIN,
 &_GEANT_CVOL_BOX_YMAX, &_GEANT_CVOL_BOX_ZMIN, &_GEANT_CVOL_BOX_ZMAX };
static char *_GEANT_CVOL_BOX_guidance[] = {
 "This command performs a boolean subtraction between the volume",
 "CNVV and a box placed in the MARS according the values of the given",
 "coordinates. See also CVOL.", "The following commands will clip by a box,",
 "with a vertex at the origin, the volume specified by NAME (a valid",
 "string for the NAME of the volume can be found using the DTREE command).",
 " EXAMPLE -", " dopt hide on", " satt * seen -2",
 " draw NAME 40 40 0 10 10 .01 .01", " next",
 " box NAME 0 1000 0 1000 0 1000", " draw NAME 40 40 0 10 10 .01 .01",
 " box ." };
static KmCommand _GEANT_CVOL_BOX = { &_GEANT_CVOL_TUBE, "/GEANT/CVOL/BOX",
 "BOX", 0, 2, 7, 1, _GEANT_CVOL_BOX_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GEANT_CVOL_BOX_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DUVIEW_NAME = { "NAME", 4, "Detector name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DUVIEW_TYPE = { "TYPE", 4, "View name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DUVIEW_CPXTYP = { "CPXTYP", 6,
 "Complexity name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DUVIEW_IVIEW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DUVIEW_IVIEW = { "IVIEW", 5,
 "View number where picture is stored", "0", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DUVIEW_IVIEW_type };
static KmParameter *_GEANT_DRAWING_DUVIEW_parameters[] = {
 &_GEANT_DRAWING_DUVIEW_NAME, &_GEANT_DRAWING_DUVIEW_TYPE,
 &_GEANT_DRAWING_DUVIEW_CPXTYP, &_GEANT_DRAWING_DUVIEW_IVIEW };
static char *_GEANT_DRAWING_DUVIEW_guidance[] = {
 " CALL GUVIEW(name,type,cpxtyp,iview)" };
static KmCommand _GEANT_DRAWING_DUVIEW = {  (KmCommand*)0,
 "/GEANT/DRAWING/DUVIEW", "DUVIEW", 0, 2, 4, 3,
 _GEANT_DRAWING_DUVIEW_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_DRAWING_DUVIEW_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _GEANT_DRAWING_DCHIT_CHUSET = { "CHUSET", 6,
 "User set identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DCHIT_CHUDET = { "CHUDET", 6,
 "User detector identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DCHIT_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_ITRA = { "ITRA", 4,
 "Number of the selected track", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DCHIT_ITRA_type };
static KmParInt    _GEANT_DRAWING_DCHIT_ISYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_ISYMB = { "ISYMB", 5,
 "Character selection number", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DCHIT_ISYMB_type };
static KmParReal   _GEANT_DRAWING_DCHIT_SIZMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_SIZMAX = { "SIZMAX", 6,
 "Maximum character size (cm)", "1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCHIT_SIZMAX_type };
static KmParInt    _GEANT_DRAWING_DCHIT_IHIT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_IHIT = { "IHIT", 4,
 "Index of array HITS", "4", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DCHIT_IHIT_type };
static KmParReal   _GEANT_DRAWING_DCHIT_HITMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_HITMIN = { "HITMIN", 6,
 "Lower boundary of HITS(IHIT)", "0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCHIT_HITMIN_type };
static KmParReal   _GEANT_DRAWING_DCHIT_HITMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCHIT_HITMAX = { "HITMAX", 6,
 "Upper boundary of HITS(IHIT)", "0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCHIT_HITMAX_type };
static KmParameter *_GEANT_DRAWING_DCHIT_parameters[] = {
 &_GEANT_DRAWING_DCHIT_CHUSET, &_GEANT_DRAWING_DCHIT_CHUDET,
 &_GEANT_DRAWING_DCHIT_ITRA, &_GEANT_DRAWING_DCHIT_ISYMB,
 &_GEANT_DRAWING_DCHIT_SIZMAX, &_GEANT_DRAWING_DCHIT_IHIT,
 &_GEANT_DRAWING_DCHIT_HITMIN, &_GEANT_DRAWING_DCHIT_HITMAX };
static char *_GEANT_DRAWING_DCHIT_guidance[] = {
 " CALL GDCHIT(chuset,chudet,itra,isymb,sizmax,ihit,hitmin,hitmax)",
 "The character plotted at each hit point may be chosen via",
 "CSYMB; isymb is composed as:",
 "      -1   (small) hardware points             (fast)",
 "       0   software crosses                    (default)",
 " 840,850   empty/full circles                  (slow)",
 " 841,851   empty/full squares                  (slow)",
 " 842,852   empty/full triangles (up)           (slow)",
 " 843,853   empty diamond/full triangle (down)  (slow)",
 " 844,854   empty/full stars                    (slow)",
 "Except for isymb=-1 the SIZE of the character on the screen",
 "is a function of HITS(IHIT), the array containing the calorimeter",
 "quantity, with HITMIN and HITMAX defining its range.",
 "The maximum character size (used in overflow) is SIZMAX.",
 " SIZE = SIZMAX * ( HITS(IHIT) - HITMIN ) / HITMAX" };
static KmCommand _GEANT_DRAWING_DCHIT = { &_GEANT_DRAWING_DUVIEW,
 "/GEANT/DRAWING/DCHIT", "DCHIT", 0, 2, 8, 0, _GEANT_DRAWING_DCHIT_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 15,
 _GEANT_DRAWING_DCHIT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_KHITS_CHUSET = { "CHUSET", 6,
 "User set identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_KHITS_CHUDET = { "CHUDET", 6,
 "User detector identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_KHITS_EPSILO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_KHITS_EPSILO = { "EPSILO", 6,
 "Pick aperture", "0.1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_KHITS_EPSILO_type };
static KmParameter *_GEANT_DRAWING_KHITS_parameters[] = {
 &_GEANT_DRAWING_KHITS_CHUSET, &_GEANT_DRAWING_KHITS_CHUDET,
 &_GEANT_DRAWING_KHITS_EPSILO };
static char *_GEANT_DRAWING_KHITS_guidance[] = {
 " CALL GKHITS(chuset,chudet,epsilo)",
 "The picking of hit points requires the appropriate JSET data structure",
 "have been filled",
 "and is  repeated until the character typed is 'Q' or 'q' (GKS) or the",
 "right button of the mouse is clicked (X11).",
 "If the character typed to pick is 'K' or 'k' then the",
 "kinematics of the corresponding track is also printed.",
 "The search is made of all the hits of all tracks in",
 "detector CHUDET of set CHUSET.",
 "EPSILO is the pick aperture; if EPSILO<0 its absolute value is taken",
 "and in addition the pick aperture is drawn; if EPSILO=0",
 "there is an infinite pick aperture and",
 "over all the hits the one nearest to the pick point is taken." };
static KmCommand _GEANT_DRAWING_KHITS = { &_GEANT_DRAWING_DCHIT,
 "/GEANT/DRAWING/KHITS", "KHITS", 0, 2, 3, 0, _GEANT_DRAWING_KHITS_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _GEANT_DRAWING_KHITS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DHITS_CHUSET = { "CHUSET", 6,
 "User set identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DHITS_CHUDET = { "CHUDET", 6,
 "User detector identifier", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DHITS_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHITS_ITRA = { "ITRA", 4,
 "Number of the selected track", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DHITS_ITRA_type };
static KmParInt    _GEANT_DRAWING_DHITS_ISYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHITS_ISYMB = { "ISYMB", 5,
 "Character selection number", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DHITS_ISYMB_type };
static KmParReal   _GEANT_DRAWING_DHITS_SSYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHITS_SSYMB = { "SSYMB", 5,
 "Size of characters (cm)", "0.1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DHITS_SSYMB_type };
static KmParameter *_GEANT_DRAWING_DHITS_parameters[] = {
 &_GEANT_DRAWING_DHITS_CHUSET, &_GEANT_DRAWING_DHITS_CHUDET,
 &_GEANT_DRAWING_DHITS_ITRA, &_GEANT_DRAWING_DHITS_ISYMB,
 &_GEANT_DRAWING_DHITS_SSYMB };
static char *_GEANT_DRAWING_DHITS_guidance[] = {
 "CALL GDHITS(chuset,chudet,itra,isymb,ssymb).",
 "The character plotted at each hit point may be chosen by isymb :",
 "      -1   (small) hardware points             (fast)",
 "       0   software crosses                    (default)",
 "   840,850   empty/full circles                  (slow)",
 "   841,851   empty/full squares                  (slow)",
 "   842,852   empty/full triangles (up)           (slow)",
 "   843,853   empty diamond/full triangle (down)  (slow)",
 "   844,854   empty/full stars                    (slow)",
 "Except for isymb=-1, the size of the character on the screen can be",
 "chosen by SSYMB cm. The hit colour will follow the value of TXCI (text",
 "colour) for isymb>0, the value of PMCI (polymarkers colour) for isymb<0,",
 "the value of PLCI (polyline colour) for isymb=0." };
static KmCommand _GEANT_DRAWING_DHITS = { &_GEANT_DRAWING_KHITS,
 "/GEANT/DRAWING/DHITS", "DHITS", 0, 2, 5, 0, _GEANT_DRAWING_DHITS_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _GEANT_DRAWING_DHITS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DPART_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DPART_ITRA = { "ITRA", 4, "Track number",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DPART_ITRA_type };
static KmParInt    _GEANT_DRAWING_DPART_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DPART_ISEL = { "ISEL", 4, "Option flag",
 "11", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DPART_ISEL_type };
static KmParReal   _GEANT_DRAWING_DPART_SIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DPART_SIZE = { "SIZE", 4,
 "Character size (cm) for particle names", "0.25", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DPART_SIZE_type };
static KmParameter *_GEANT_DRAWING_DPART_parameters[] = {
 &_GEANT_DRAWING_DPART_ITRA, &_GEANT_DRAWING_DPART_ISEL,
 &_GEANT_DRAWING_DPART_SIZE };
static char *_GEANT_DRAWING_DPART_guidance[] = {
 " CALL GDPART(itra,isel,size)", " isel=x1 to draw the track number",
 " isel=1x to draw the particle name" };
static KmCommand _GEANT_DRAWING_DPART = { &_GEANT_DRAWING_DHITS,
 "/GEANT/DRAWING/DPART", "DPART", 0, 2, 3, 0, _GEANT_DRAWING_DPART_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_DRAWING_DPART_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_KXYZ_EPSILO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_KXYZ_EPSILO = { "EPSILO", 6, "Delta angle",
 "0.25", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_KXYZ_EPSILO_type };
static KmParameter *_GEANT_DRAWING_KXYZ_parameters[] = {
 &_GEANT_DRAWING_KXYZ_EPSILO };
static char *_GEANT_DRAWING_KXYZ_guidance[] = { " CALL GKXYZ(epsilo)",
 "The picking of track points requires the JXYZ data structure",
 "and is  repeated until the character typed is 'Q' or 'q' (GKS)",
 "or the right button of the mouse is clicked (X11).",
 "EPSILO is the delta angle used for picking; if EPSILO=0",
 "there is no optimization performed and",
 "over all the track points the one nearest to the pick", "point is taken." };
static KmCommand _GEANT_DRAWING_KXYZ = { &_GEANT_DRAWING_DPART,
 "/GEANT/DRAWING/KXYZ", "KXYZ", 0, 2, 1, 0, _GEANT_DRAWING_KXYZ_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_DRAWING_KXYZ_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DXYZ_ITRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXYZ_ITRA = { "ITRA", 4, "Track number",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DXYZ_ITRA_type };
static KmParameter *_GEANT_DRAWING_DXYZ_parameters[] = {
 &_GEANT_DRAWING_DXYZ_ITRA };
static char *_GEANT_DRAWING_DXYZ_guidance[] = { " CALL GDXYZ(itra)",
 "Draw tracks previously stored via GSXYZ." };
static KmCommand _GEANT_DRAWING_DXYZ = { &_GEANT_DRAWING_KXYZ,
 "/GEANT/DRAWING/DXYZ", "DXYZ", 0, 2, 1, 0, _GEANT_DRAWING_DXYZ_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_DRAWING_DXYZ_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_ZOOM_ZFU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_ZOOM_ZFU = { "ZFU", 3,
 "Zoom factor for U-coord. (horizontal)", "2.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_ZOOM_ZFU_type };
static KmParReal   _GEANT_DRAWING_ZOOM_ZFV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_ZOOM_ZFV = { "ZFV", 3,
 "Zoom factor for V-coord. (vertical)", "2.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_ZOOM_ZFV_type };
static KmParInt    _GEANT_DRAWING_ZOOM_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_ZOOM_ISEL = { "ISEL", 4, "Options", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_ZOOM_ISEL_type };
static KmParReal   _GEANT_DRAWING_ZOOM_UZ0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_ZOOM_UZ0 = { "UZ0", 3,
 "U-coord. of the centre of zoom rectangle", "10.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_UZ0_type };
static KmParReal   _GEANT_DRAWING_ZOOM_VZ0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_ZOOM_VZ0 = { "VZ0", 3,
 "V-coord. of the centre of zoom rectangle", "10.", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_VZ0_type };
static KmParReal   _GEANT_DRAWING_ZOOM_U0_type = { "0.", "20.", "0.", "20.", 0
 };
static KmParameter _GEANT_DRAWING_ZOOM_U0 = { "U0", 2,
 "U-coord. of the centre of resulting zoomed rectangle", "10.", (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_U0_type };
static KmParReal   _GEANT_DRAWING_ZOOM_V0_type = { "0.", "20.", "0.", "20.", 0
 };
static KmParameter _GEANT_DRAWING_ZOOM_V0 = { "V0", 2,
 "V-coord. of the centre of resulting zoomed rectangle", "10.", (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_ZOOM_V0_type };
static KmParameter *_GEANT_DRAWING_ZOOM_parameters[] = {
 &_GEANT_DRAWING_ZOOM_ZFU, &_GEANT_DRAWING_ZOOM_ZFV,
 &_GEANT_DRAWING_ZOOM_ISEL, &_GEANT_DRAWING_ZOOM_UZ0,
 &_GEANT_DRAWING_ZOOM_VZ0, &_GEANT_DRAWING_ZOOM_U0, &_GEANT_DRAWING_ZOOM_V0 };
static char *_GEANT_DRAWING_ZOOM_guidance[] = {
 " CALL GDZOOM(zfu,zfv,uz0,vz0,u0,v0)",
 "This command sets the zoom parameters that will be used by",
 "subsequent calls to the drawing routines. Each zoom operation is always",
 "relative to the status of the current zoom parameters.",
 "The scale factors in u,v are respectively  zfu,zfv.",
 "zfu=0 (or zfv=0) will act as a reset (i.e. unzoomed viewing).",
 "The zoom is computed around uz0,vz0 (user coordinates),",
 "and the resulting picture will be centered at u0,v0.",
 "The use of the space bar is replaced by the left button of the mouse",
 "running with X11:", "If isel=0 :", " 1. position the cursor at (uz0,vz0)",
 " 2. type the space bar (GKS)", "(u0,v0 are chosen at centre of screen)",
 "If isel=1 :", " 1. position the cursor at first corner of zoom rectangle",
 " 2. type the space bar (GKS)",
 " 3. position the cursor at second corner of zoom rectangle",
 " 4. type the space bar (GKS)",
 "(zfu,zfv are chosen according to the zoom rectangle;",
 "uz0,vz0 are chosen at the centre of the zoom rectangle;",
 "u0,v0 are chosen at centre of screen)", "If isel=2 :",
 " 1. position the cursor at (uz0,vz0)", " 2. type the space bar (GKS)",
 " 3. position the cursor at (u0,v0)", " 4. type the space bar (GKS)",
 "If isel=1000+n and running with X-windows:",
 " 1. n must be the identifier of an active view bank",
 " 2. clicking on the left button of the mouse will display",
 "    a zoomed view (computed around the cursor position) of",
 "    the previous drawing in a new window",
 " 3. it is now possible to iterate the zooming from the new window",
 " 4. clicking on the right button will return the control to the",
 "    main window",
 " 5. clicking on the left button it is possible to open new windows",
 "    zooming in other points of the detector",
 " 6. clicking on the right button when the main window is active",
 "    will return the control to the 'command mode'." };
static KmCommand _GEANT_DRAWING_ZOOM = { &_GEANT_DRAWING_DXYZ,
 "/GEANT/DRAWING/ZOOM", "ZOOM", 0, 2, 7, 0, _GEANT_DRAWING_ZOOM_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 39,
 _GEANT_DRAWING_ZOOM_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_LENS_KNUM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_LENS_KNUM = { "KNUM", 4,
 "View bank identifier", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_LENS_KNUM_type };
static KmParameter _GEANT_DRAWING_LENS_KSAM = { "KSAM", 4,
 "Sample mode         ", "OFF ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_LENS_parameters[] = {
 &_GEANT_DRAWING_LENS_KNUM, &_GEANT_DRAWING_LENS_KSAM };
static char *_GEANT_DRAWING_LENS_guidance[] = {
 "Interactive zooming for detectors and events when running",
 "with X-windows. Using this command, when showing the contents of a",
 "view bank, it is possible to click (left button) in two points of the",
 "drawing (which will represent the left upper corner and the right",
 "bottom corner of the part to be zoomed). After the second click",
 "a new 'window' will appear to fit the frame defined",
 "by the two clicks and it will show a zoomed view as seen from a",
 "lens with those dimensions. Clicking now the central button will",
 "translate the lens over the drawing, while clicking the right button",
 "will stop it. Moreover, clicking the left button of the",
 "mouse, the lens will increase (or decrease) its magnification",
 "power according to the backward-to-forward movement of the mouse.",
 "A click on the right button will stop this action and it is possible",
 "to restart the translation of the lens or, clicking",
 "on the right button again, to make the lens disappear. It is then possible",
 "to open another 'window-lens' with different dimensions. Thus,",
 "this command can be useful to scan detailed parts of a detector or",
 "to scan hits and showers for events. Clicking the right",
 "button when no lens is displayed will return the control to the",
 "'command mode'. The LENS is also available in sample mode when KSAM is",
 "'ON'.", "The following commands will fill a view bank and will",
 "allow to scan the detector and an event previously stored",
 "via the use of LENS (when running", "with X-windows):", " EXAMPLE -",
 " satt * seen 1", " dopen 1", " draw NAME 40 40 0 10 10 .01 .01", " dxyz 0",
 " dhits * * 0 0 .2", " dclose", " dsh 1", " lens 1 on" };
static KmCommand _GEANT_DRAWING_LENS = { &_GEANT_DRAWING_ZOOM,
 "/GEANT/DRAWING/LENS", "LENS", 0, 2, 2, 1, _GEANT_DRAWING_LENS_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 34,
 _GEANT_DRAWING_LENS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_PERSP_NAME = { "NAME", 4, "Volume name",
 "    ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GEANT_DRAWING_PERSP_DISTT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_PERSP_DISTT = { "DISTT", 5,
 "Volume distance from observer", "1000.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_PERSP_DISTT_type };
static KmParameter _GEANT_DRAWING_PERSP_SAMP = { "SAMP", 4,
 "Control to the mouse", "OFF ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_PERSP_parameters[] = {
 &_GEANT_DRAWING_PERSP_NAME, &_GEANT_DRAWING_PERSP_DISTT,
 &_GEANT_DRAWING_PERSP_SAMP };
static char *_GEANT_DRAWING_PERSP_guidance[] = {
 "To control the perspective according to the variation of the distance",
 "between the observer and the object (if PROJ has the value PERS).",
 "If SAMP is ON the control of the distance is given via the mouse." };
static KmCommand _GEANT_DRAWING_PERSP = { &_GEANT_DRAWING_LENS,
 "/GEANT/DRAWING/PERSP", "PERSP", 0, 2, 3, 2, _GEANT_DRAWING_PERSP_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_DRAWING_PERSP_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_MOVE3D_NAME = { "NAME", 4, "Volume name",
 "    ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GEANT_DRAWING_MOVE3D_THETA_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", "40.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_THETA_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", "40.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_PHI_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_PSI_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_PSI = { "PSI", 3,
 "Viewing angle psi (for 2D rotation)", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_PSI_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_U0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", "10.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_U0_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_V0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_V0_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_SU = { "SU", 2,
 "Scale factor for U-coord.", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_SU_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_MOVE3D_SV = { "SV", 2,
 "Scale factor for V-coord.", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_MOVE3D_SV_type };
static KmParReal   _GEANT_DRAWING_MOVE3D_SZ_type = { "0.1", "10.", "0.1",
 "10.", 1 };
static KmParameter _GEANT_DRAWING_MOVE3D_SZ = { "SZ", 2, "Scale zoom factor",
 "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_MOVE3D_SZ_type };
static char *_GEANT_DRAWING_MOVE3D_NOPT_range[] = { "T", "H" };
static char *_GEANT_DRAWING_MOVE3D_NOPT_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_MOVE3D_NOPT_type = {
 _GEANT_DRAWING_MOVE3D_NOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_MOVE3D_NOPT = { "NOPT", 4,
 "T=tracks,H=hits", "    ", (char*)0, 8, 2, _GEANT_DRAWING_MOVE3D_NOPT_range,
 2, _GEANT_DRAWING_MOVE3D_NOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_MOVE3D_NOPT_type };
static KmParameter *_GEANT_DRAWING_MOVE3D_parameters[] = {
 &_GEANT_DRAWING_MOVE3D_NAME, &_GEANT_DRAWING_MOVE3D_THETA,
 &_GEANT_DRAWING_MOVE3D_PHI, &_GEANT_DRAWING_MOVE3D_PSI,
 &_GEANT_DRAWING_MOVE3D_U0, &_GEANT_DRAWING_MOVE3D_V0,
 &_GEANT_DRAWING_MOVE3D_SU, &_GEANT_DRAWING_MOVE3D_SV,
 &_GEANT_DRAWING_MOVE3D_SZ, &_GEANT_DRAWING_MOVE3D_NOPT };
static char *_GEANT_DRAWING_MOVE3D_guidance[] = {
 "Same functionality of the command MOVE interfaced with MOTIF." };
static KmCommand _GEANT_DRAWING_MOVE3D = { &_GEANT_DRAWING_PERSP,
 "/GEANT/DRAWING/MOVE3D", "MOVE3D", 0, 2, 10, 1,
 _GEANT_DRAWING_MOVE3D_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_DRAWING_MOVE3D_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _GEANT_DRAWING_MOVE_NAME = { "NAME", 4, "Volume name",
 "    ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GEANT_DRAWING_MOVE_NOPT = { "NOPT", 4,
 "S=sample mode,T=tracks,H=hits", "    ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_MOVE_parameters[] = {
 &_GEANT_DRAWING_MOVE_NAME, &_GEANT_DRAWING_MOVE_NOPT };
static char *_GEANT_DRAWING_MOVE_guidance[] = {
 "Positioning some daughter volumes inside a 'mother', it can be",
 "important to check if overlaps between such volumes have occurred.",
 "Instead of putting the drawing in a view bank, zooming, and iterating",
 "the process for different viewing angles of the same detector, the",
 "MOVE facility has been developed (for machines running with X11):",
 "it is sufficient to draw a view of the volumes to be analysed (after",
 "setting the proper SEEN, COLO, etc. attributes) and then to enter",
 "'MOVE' followed by the same 'NAME' used for the last command DRAW.",
 "The detector will appear in a panel with five buttons at the",
 "bottom: THETA, PHI, TRASL, ZOOM, OFF. Clicking on the left button",
 "of the mouse, when the cursor is inside the THETA area, will rotate the",
 "detector along the polar angle theta according to the",
 "backward-to-forward movement of the mouse",
 "(clicking up and down the left button if",
 "not in sample mode); clicking on the right button of",
 "the mouse will stop the rotation; clicking now on the",
 "left button of the mouse when inside the PHI area will activate a",
 "rotation along the polar angle phi. In the same way, activating the",
 "TRASL button, the detector can be translated in the u,v plane",
 "of the screen according to the 2D-movement of the mouse. Finally,",
 "activating the ZOOM button, the detector will be zoomed (or unzoomed)",
 "according to the backward-to-forward movement of the mouse. Clicking on\
 the", "OFF button will return the control to the 'command mode'. The MOVE",
 "command will work also with hidden line removal and shading options",
 "(when SHAD is on the background will be black);",
 "moreover, if the volumes are clipped, exploded, shifted, etc., they",
 "will be 'MOVED' with these features as well.",
 "Tracks and hits of a previously stored physical event can be moved",
 "together with the detector, allowing a dynamical 3-D analysis of the",
 "simulated events. Clicking the central button of the mouse when a good",
 "view of the event is found, will stop any movement and the mouse will",
 "allow the normal picking capabilities first for the tracks and then for",
 "the hits. After clicking of the right button, the normal",
 "movement will restart to find another interesting view of the event",
 "and to iterate the process.", "The MOVE is also available in sample mode.",
 "The following commands will produce a drawing of a volume",
 "and then will give the control to the MOVE panel; try the following",
 "possibilities:", " EXAMPLE 1 -", " dopt hide off", " satt * seen -2",
 " draw NAME 40 40 0 10 10 .01 .01", " move NAME", " EXAMPLE 2 -",
 " dopt hide on", " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01",
 " move NAME", " EXAMPLE 3 -", " dopt shad on", " satt * colo 3",
 " satt * fill 2", " dopt edge off", " draw NAME 40 40 0 10 10 .01 .01",
 " move NAME" };
static KmCommand _GEANT_DRAWING_MOVE = { &_GEANT_DRAWING_MOVE3D,
 "/GEANT/DRAWING/MOVE", "MOVE", 0, 2, 2, 1, _GEANT_DRAWING_MOVE_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 56,
 _GEANT_DRAWING_MOVE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_DRAWING_PICK_guidance[] = {
 "Activates graphic input to identify detector elements",
 "in a cut view. Clicking on the left button of the mouse when",
 "the cursor is in a given point of the drawing and clicking again",
 "(outside the detector) will produce the following effect:",
 "a line joininig the two points will be drawn together with",
 "the name and the medium number of the volume picked",
 "with the first clicking close to the second point." };
static KmCommand _GEANT_DRAWING_PICK = { &_GEANT_DRAWING_MOVE,
 "/GEANT/DRAWING/PICK", "PICK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxpick_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7, _GEANT_DRAWING_PICK_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_DRAWING_MEASURE_guidance[] = {
 "Position the cursor on the first point (u1,v1) and hit the space bar(GKS).",
 "Position the cursor on the second point (u2,v2) and hit the space\
 bar(GKS).",
 "Clicking the left button of the mouse (X11) will have the same effect as",
 "hiting the space bar (GKS).",
 "The command will compute and print the distance in space separating",
 "the two points on the projection view. It can be useful to measure",
 "distances either between volumes or between tracks or hits." };
static KmCommand _GEANT_DRAWING_MEASURE = { &_GEANT_DRAWING_PICK,
 "/GEANT/DRAWING/MEASURE", "MEASURE", 0, 2, 0, 0, (KmParameter**)0, 0, 0,
 gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7,
 _GEANT_DRAWING_MEASURE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DHEAD_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHEAD_ISEL = { "ISEL", 4, "Option flag",
 "111110", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DHEAD_ISEL_type };
static KmParameter _GEANT_DRAWING_DHEAD_NAME = { "NAME", 4, "Title", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GEANT_DRAWING_DHEAD_CHRSIZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DHEAD_CHRSIZ = { "CHRSIZ", 6,
 "Character size (cm) of title NAME", "0.6", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DHEAD_CHRSIZ_type };
static KmParameter *_GEANT_DRAWING_DHEAD_parameters[] = {
 &_GEANT_DRAWING_DHEAD_ISEL, &_GEANT_DRAWING_DHEAD_NAME,
 &_GEANT_DRAWING_DHEAD_CHRSIZ };
static char *_GEANT_DRAWING_DHEAD_guidance[] = {
 " CALL GDHEAD(isel,name,chrsiz)", "ISEL =",
 " 0      to have only the header lines",
 " xxxxx1 to add the text name centered on top of header",
 " xxxx1x to add global detector name (first volume) on left",
 " xxx1xx to add date on right",
 " xx1xxx to select thick characters for text on top of header",
 " x1xxxx to add the text 'EVENT NR x' on top of header",
 " 1xxxxx to add the text 'RUN NR x' on top of header",
 "NOTE that ISEL=x1xxx1 or ISEL=1xxxx1 are illegal choices,",
 "i.e. they generate overwritten text.", "NAME is the title",
 "and CHRSIZ the character size in cm of text name." };
static KmCommand _GEANT_DRAWING_DHEAD = { &_GEANT_DRAWING_MEASURE,
 "/GEANT/DRAWING/DHEAD", "DHEAD", 0, 2, 3, 0, _GEANT_DRAWING_DHEAD_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _GEANT_DRAWING_DHEAD_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DMAN_U_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DMAN_U = { "U", 1,
 "U-coord. (horizontal) of the centre of man", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DMAN_U_type };
static KmParReal   _GEANT_DRAWING_DMAN_V_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DMAN_V = { "V", 1,
 "V-coord. (vertical) of the centre of man", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DMAN_V_type };
static char *_GEANT_DRAWING_DMAN_TYPE_range[] = { "MAN", "WM1", "WM2", "WM3" };
static char *_GEANT_DRAWING_DMAN_TYPE_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _GEANT_DRAWING_DMAN_TYPE_type = {
 _GEANT_DRAWING_DMAN_TYPE_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DMAN_TYPE = { "TYPE", 4,
 "Man, Wm1, Wm2, Wm3", "MAN", (char*)0, 8, 4, _GEANT_DRAWING_DMAN_TYPE_range,
 4, _GEANT_DRAWING_DMAN_TYPE_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_DMAN_TYPE_type };
static KmParameter *_GEANT_DRAWING_DMAN_parameters[] = {
 &_GEANT_DRAWING_DMAN_U, &_GEANT_DRAWING_DMAN_V, &_GEANT_DRAWING_DMAN_TYPE };
static char *_GEANT_DRAWING_DMAN_guidance[] = {
 " CALL GDMAN(u,v),CALL GDWMN1(u,v),CALL GDWMN2(u,v),CALL GDWMN2(u,v)",
 "It superimposes the picure of a man or of a woman, chosen among",
 "three different ones, with the same scale factors as the detector",
 "in the current drawing." };
static KmCommand _GEANT_DRAWING_DMAN = { &_GEANT_DRAWING_DHEAD,
 "/GEANT/DRAWING/DMAN", "DMAN", 0, 2, 3, 3, _GEANT_DRAWING_DMAN_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_DRAWING_DMAN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DAXIS_X0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_X0 = { "X0", 2,
 "X-coord. of axis origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DAXIS_X0_type };
static KmParReal   _GEANT_DRAWING_DAXIS_Y0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_Y0 = { "Y0", 2,
 "Y-coord. of axis origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DAXIS_Y0_type };
static KmParReal   _GEANT_DRAWING_DAXIS_Z0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_Z0 = { "Z0", 2,
 "Z-coord. of axis origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DAXIS_Z0_type };
static KmParReal   _GEANT_DRAWING_DAXIS_DX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DAXIS_DX = { "DX", 2, "Axis size", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DAXIS_DX_type };
static KmParameter *_GEANT_DRAWING_DAXIS_parameters[] = {
 &_GEANT_DRAWING_DAXIS_X0, &_GEANT_DRAWING_DAXIS_Y0, &_GEANT_DRAWING_DAXIS_Z0,
 &_GEANT_DRAWING_DAXIS_DX };
static char *_GEANT_DRAWING_DAXIS_guidance[] = { " CALL GDAXIS(x0,y0,z0,dx)",
 "This commmand superimposes the axis of the MARS on the",
 "current picture. It is useful for finding immediately the",
 "orientation of the current drawing of the detector in the space." };
static KmCommand _GEANT_DRAWING_DAXIS = { &_GEANT_DRAWING_DMAN,
 "/GEANT/DRAWING/DAXIS", "DAXIS", 0, 2, 4, 4, _GEANT_DRAWING_DAXIS_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_DRAWING_DAXIS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DSCALE_U_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DSCALE_U = { "U", 1,
 "U-coord. (horizontal) of the centre of scale", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DSCALE_U_type };
static KmParReal   _GEANT_DRAWING_DSCALE_V_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DSCALE_V = { "V", 1,
 "V-coord. (vertical) of the centre of scale", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DSCALE_V_type };
static KmParameter *_GEANT_DRAWING_DSCALE_parameters[] = {
 &_GEANT_DRAWING_DSCALE_U, &_GEANT_DRAWING_DSCALE_V };
static char *_GEANT_DRAWING_DSCALE_guidance[] = { " CALL GDSCAL(u,v)",
 "It draws a scale centered in U,V." };
static KmCommand _GEANT_DRAWING_DSCALE = { &_GEANT_DRAWING_DAXIS,
 "/GEANT/DRAWING/DSCALE", "DSCALE", 0, 2, 2, 2,
 _GEANT_DRAWING_DSCALE_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_DRAWING_DSCALE_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _GEANT_DRAWING_DVECTOR_XVECT = { "XVECT", 5,
 "Vector containing X-coord. (horizontal)", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DRAWING_DVECTOR_YVECT = { "YVECT", 5,
 "Vector containing Y-coord. (vertical)", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_DRAWING_DVECTOR_NPOINT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVECTOR_NPOINT = { "NPOINT", 6,
 "Number of coord.", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_DVECTOR_NPOINT_type };
static KmParameter *_GEANT_DRAWING_DVECTOR_parameters[] = {
 &_GEANT_DRAWING_DVECTOR_XVECT, &_GEANT_DRAWING_DVECTOR_YVECT,
 &_GEANT_DRAWING_DVECTOR_NPOINT };
static char *_GEANT_DRAWING_DVECTOR_guidance[] = {
 "Draw a polyline of 'npoint' point via",
 "a call to GDRAWV(xvect,yvect,npoint)",
 "where xvect and yvect are two KUIP vectors" };
static KmCommand _GEANT_DRAWING_DVECTOR = { &_GEANT_DRAWING_DSCALE,
 "/GEANT/DRAWING/DVECTOR", "DVECTOR", 0, 2, 3, 3,
 _GEANT_DRAWING_DVECTOR_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_DRAWING_DVECTOR_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_DTEXT_X0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_DTEXT_X0 = { "X0", 2,
 "X-coord. (horizontal) of text string", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_X0_type };
static KmParReal   _GEANT_DRAWING_DTEXT_Y0_type = { "0.", "20.", "0.", "20.",
 0 };
static KmParameter _GEANT_DRAWING_DTEXT_Y0 = { "Y0", 2,
 "Y-coord. (vertical) of text string", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_Y0_type };
static KmParameter _GEANT_DRAWING_DTEXT_TEXT = { "TEXT", 4, "Text string",
 "GEANT", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
  (void*)0 };
static KmParReal   _GEANT_DRAWING_DTEXT_SIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DTEXT_SIZE = { "SIZE", 4,
 "Character size (cm)", ".5", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_SIZE_type };
static KmParReal   _GEANT_DRAWING_DTEXT_ANGLE_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DTEXT_ANGLE = { "ANGLE", 5,
 "Rotation angle (deg)", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DTEXT_ANGLE_type };
static KmParInt    _GEANT_DRAWING_DTEXT_LWID_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DTEXT_LWID = { "LWID", 4, "Line width", "4",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DTEXT_LWID_type };
static char *_GEANT_DRAWING_DTEXT_CENT_range[] = { "CENT", "LEFT", "RIGH" };
static char *_GEANT_DRAWING_DTEXT_CENT_text[] = { (char*)0, (char*)0, (char*)0
 };
static KmParOption _GEANT_DRAWING_DTEXT_CENT_type = {
 _GEANT_DRAWING_DTEXT_CENT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DTEXT_CENT = { "CENT", 4,
 "Centering option", "CENT", (char*)0, 8, 3, _GEANT_DRAWING_DTEXT_CENT_range,
 3, _GEANT_DRAWING_DTEXT_CENT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_DTEXT_CENT_type };
static KmParameter *_GEANT_DRAWING_DTEXT_parameters[] = {
 &_GEANT_DRAWING_DTEXT_X0, &_GEANT_DRAWING_DTEXT_Y0,
 &_GEANT_DRAWING_DTEXT_TEXT, &_GEANT_DRAWING_DTEXT_SIZE,
 &_GEANT_DRAWING_DTEXT_ANGLE, &_GEANT_DRAWING_DTEXT_LWID,
 &_GEANT_DRAWING_DTEXT_CENT };
static char *_GEANT_DRAWING_DTEXT_guidance[] = {
 " CALL GDRAWT(x0,y0,text,size,angle,lwid,opt)",
 "It allows one to draw some text in the current picture.",
 "Now more than 160 colours are available. The text colour",
 "must be set via the command IGSET. The size of the",
 "text will follow the zooming factors in the view banks." };
static KmCommand _GEANT_DRAWING_DTEXT = { &_GEANT_DRAWING_DVECTOR,
 "/GEANT/DRAWING/DTEXT", "DTEXT", 0, 2, 7, 7, _GEANT_DRAWING_DTEXT_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5,
 _GEANT_DRAWING_DTEXT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DFSPC_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_GEANT_DRAWING_DFSPC_CSORT_range[] = { "Y", "N", "0", "1" };
static char *_GEANT_DRAWING_DFSPC_CSORT_text[] = { (char*)0, (char*)0,
 (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_DFSPC_CSORT_type = {
 _GEANT_DRAWING_DFSPC_CSORT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DFSPC_CSORT = { "CSORT", 5,
 "Alphabetic sorting flag", "N", (char*)0, 8, 4,
 _GEANT_DRAWING_DFSPC_CSORT_range, 4, _GEANT_DRAWING_DFSPC_CSORT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_DRAWING_DFSPC_CSORT_type };
static char *_GEANT_DRAWING_DFSPC_CINTER_range[] = { "I", "B", "0", "1" };
static char *_GEANT_DRAWING_DFSPC_CINTER_text[] = { (char*)0, (char*)0,
 (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_DFSPC_CINTER_type = {
 _GEANT_DRAWING_DFSPC_CINTER_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DFSPC_CINTER = { "CINTER", 6,
 "Interactive/Batch version", "I", (char*)0, 8, 4,
 _GEANT_DRAWING_DFSPC_CINTER_range, 4, _GEANT_DRAWING_DFSPC_CINTER_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_DRAWING_DFSPC_CINTER_type };
static KmParameter *_GEANT_DRAWING_DFSPC_parameters[] = {
 &_GEANT_DRAWING_DFSPC_NAME, &_GEANT_DRAWING_DFSPC_CSORT,
 &_GEANT_DRAWING_DFSPC_CINTER };
static char *_GEANT_DRAWING_DFSPC_guidance[] = {
 " CALL GDFSPC(name,isort,inter)",
 "Same as DSPEC, but it will draw the specifications for all the volumes.",
 "If the alphabetic sorting flag is YES, all pictures will be drawn in\
 ascending", "alphabetic order; isort is set to 1.",
 "If INTERACTIVE, (inter=1), the routine will prompt the user at each plot",
 "before doing a clear screen, otherwise it will clear automatically",
 "the screen before starting a new frame." };
static KmCommand _GEANT_DRAWING_DFSPC = { &_GEANT_DRAWING_DTEXT,
 "/GEANT/DRAWING/DFSPC", "DFSPC", 0, 2, 3, 1, _GEANT_DRAWING_DFSPC_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7,
 _GEANT_DRAWING_DFSPC_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_D3DSPEC_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_D3DSPEC_TETA3_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_TETA3 = { "TETA3", 5, "Theta angle",
 "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_D3DSPEC_TETA3_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_PHI3_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_PHI3 = { "PHI3", 4, "Phi angle",
 "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_D3DSPEC_PHI3_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_PSI3_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_PSI3 = { "PSI3", 4, "Psi angle",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_D3DSPEC_PSI3_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_U03_type = { "-40.", "40.", "-40.",
 "40.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_U03 = { "U03", 3,
 "U-coord. (horizontal) of volume origin", "10.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_D3DSPEC_U03_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_V03_type = { "-40.", "40.", "-40.",
 "40.", 0 };
static KmParameter _GEANT_DRAWING_D3DSPEC_V03 = { "V03", 3,
 "V-coord. (vertical) of volume origin", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_D3DSPEC_V03_type };
static KmParReal   _GEANT_DRAWING_D3DSPEC_ZM3_type = { "0.00001", "10.",
 "0.00001", "10.", 5 };
static KmParameter _GEANT_DRAWING_D3DSPEC_ZM3 = { "ZM3", 3,
 "Zoom factor for current size factors", "1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_D3DSPEC_ZM3_type };
static KmParameter *_GEANT_DRAWING_D3DSPEC_parameters[] = {
 &_GEANT_DRAWING_D3DSPEC_NAME, &_GEANT_DRAWING_D3DSPEC_TETA3,
 &_GEANT_DRAWING_D3DSPEC_PHI3, &_GEANT_DRAWING_D3DSPEC_PSI3,
 &_GEANT_DRAWING_D3DSPEC_U03, &_GEANT_DRAWING_D3DSPEC_V03,
 &_GEANT_DRAWING_D3DSPEC_ZM3 };
static char *_GEANT_DRAWING_D3DSPEC_guidance[] = {
 "Trough a call to GSPE3D, this command allows one to show",
 "the volume (3D views in real time), together with",
 "its geometrical specifications (if using MOTIF). The 3D drawing will",
 "be performed according the current values of the options HIDE and",
 "SHAD and according the current CVOL clipping parameters for that", "volume."
 };
static KmCommand _GEANT_DRAWING_D3DSPEC = { &_GEANT_DRAWING_DFSPC,
 "/GEANT/DRAWING/D3DSPEC", "D3DSPEC", 0, 2, 7, 1,
 _GEANT_DRAWING_D3DSPEC_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _GEANT_DRAWING_D3DSPEC_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DSPEC_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DRAWING_DSPEC_parameters[] = {
 &_GEANT_DRAWING_DSPEC_NAME };
static char *_GEANT_DRAWING_DSPEC_guidance[] = {
 "Trough a call to GDSPEC(name), this command allows one to show three",
 "views of the volume (two cut-views and a 3D view), together with",
 "its geometrical specifications. The 3D drawing will",
 "be performed according the current values of the options HIDE and",
 "SHAD and according the current CVOL clipping parameters for that", "volume."
 };
static KmCommand _GEANT_DRAWING_DSPEC = { &_GEANT_DRAWING_D3DSPEC,
 "/GEANT/DRAWING/DSPEC", "DSPEC", 0, 2, 1, 1, _GEANT_DRAWING_DSPEC_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_DRAWING_DSPEC_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DTREE_NAME = { "NAME", 4, "Volume name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DRAWING_DTREE_LEVMAX_type = { "-15", "15", "-15",
 "15", 0 };
static KmParameter _GEANT_DRAWING_DTREE_LEVMAX = { "LEVMAX", 6, "Depth level",
 "3", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DTREE_LEVMAX_type };
static KmParInt    _GEANT_DRAWING_DTREE_ISELT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DTREE_ISELT = { "ISELT", 5, "Options    ",
 "111", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DTREE_ISELT_type };
static KmParameter *_GEANT_DRAWING_DTREE_parameters[] = {
 &_GEANT_DRAWING_DTREE_NAME, &_GEANT_DRAWING_DTREE_LEVMAX,
 &_GEANT_DRAWING_DTREE_ISELT };
static char *_GEANT_DRAWING_DTREE_guidance[] = {
 "This command allows the drawing of the logical tree,",
 "displaying the name, the multiplicity and other information about the\
 volumes,", "via a call to GDTREE(name,levmax,isel):",
 "if the third parameter is not given (default), the command will",
 "produce the drawing of the tree displaying, for each volume, the",
 "number of the following levels (red arrows) and of the preceeding",
 "levels (green arrows); then the control is automatically given to the",
 "mouse: clicking on the left button when the cursor is inside a volume's",
 "pave will perform a DSPEC for that volume; doing the same when the cursor",
 "is on a red arrow, will perform a DTREE for the relative volume (the",
 "number of levels displayed depending on the clicked arrow); doing the",
 "same for the 'i-th' green arrow of a given volume, will perform a DTREE",
 "for its mother-volume staying 'i' levels before.",
 "If running with X-windows, the drawing of the specification (DSPEC)",
 "is performed",
 "in a different window to speed up the scanning of the tree.",
 "Iterating this procedure it is possible to analyse very easily and quickly",
 "any kind of tree. Clicking the right button of the mouse will return",
 "the control to the command mode.", "If the ISELT parameter is given,",
 "then the TREE will work as in the",
 "previous version, with ISELT up to 10001.",
 "The following command will perform a drawing of the tree and give the",
 "control to the user via the mouse:", " EXAMPLE -", " dtree NAME 3" };
static KmCommand _GEANT_DRAWING_DTREE = { &_GEANT_DRAWING_DSPEC,
 "/GEANT/DRAWING/DTREE", "DTREE", 0, 2, 3, 0, _GEANT_DRAWING_DTREE_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 26,
 _GEANT_DRAWING_DTREE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_BOMB_BOOM_type = { "-10.", "10.", "-10.",
 "10.", 0 };
static KmParameter _GEANT_DRAWING_BOMB_BOOM = { "BOOM", 4,
 " Exploding factor for volumes position ", "0.", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_BOMB_BOOM_type };
static KmParameter *_GEANT_DRAWING_BOMB_parameters[] = {
 &_GEANT_DRAWING_BOMB_BOOM };
static char *_GEANT_DRAWING_BOMB_guidance[] = {
 "To 'explode' the detector. If BOOM is positive (values smaller",
 "than 1. are suggested, but any value is possible)",
 "all the volumes are shifted by a distance",
 "proportional to BOOM along the direction between their centre",
 "and the origin of the MARS; the volumes which are symmetric",
 "with respect to this origin are simply not shown.",
 "BOOM equal to 0 resets the normal mode.",
 "A negative (greater than -1.) value of",
 "BOOM will cause an 'implosion'; for even lower values of BOOM",
 "the volumes' positions will be reflected respect to the origin.",
 "This command can be useful to improve the 3D effect for very",
 "complex detectors. The following commands will make explode the",
 "detector:", " EXAMPLE -", " dopt hide on", " satt * seen 1",
 " draw NAME 40 40 0 10 10 .01 .01", " bomb 1", " next",
 " draw NAME 40 40 0 10 10 .01 .01" };
static KmCommand _GEANT_DRAWING_BOMB = { &_GEANT_DRAWING_DTREE,
 "/GEANT/DRAWING/BOMB", "BOMB", 0, 2, 1, 1, _GEANT_DRAWING_BOMB_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 20,
 _GEANT_DRAWING_BOMB_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_SHIFT_CNVN = { "CNVN", 4,
 " Name of volume to be shifted        ", "*", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_SHIFT_XXXX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SHIFT_XXXX = { "XXXX", 4,
 " Shift along X axis                  ", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SHIFT_XXXX_type };
static KmParReal   _GEANT_DRAWING_SHIFT_YYYY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SHIFT_YYYY = { "YYYY", 4,
 " Shift along Y axis                  ", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SHIFT_YYYY_type };
static KmParReal   _GEANT_DRAWING_SHIFT_ZZZZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SHIFT_ZZZZ = { "ZZZZ", 4,
 " Shift along Z axis                  ", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SHIFT_ZZZZ_type };
static KmParameter *_GEANT_DRAWING_SHIFT_parameters[] = {
 &_GEANT_DRAWING_SHIFT_CNVN, &_GEANT_DRAWING_SHIFT_XXXX,
 &_GEANT_DRAWING_SHIFT_YYYY, &_GEANT_DRAWING_SHIFT_ZZZZ };
static char *_GEANT_DRAWING_SHIFT_guidance[] = {
 "To draw a volume shifted from its initial position when hidden",
 "line removal is ON. It can be useful if you want to extract a",
 "volume or some volumes from the detector to show them more clearly.",
 "The last requested SHIFT for each volume",
 "NAME is performed. Moreover, the SHIFT of",
 "each volume will be performed starting from where its mother has",
 "been shifted, so that it's easier to SHIFT nicely sets",
 "of volumes using the mother-daughter relationships.",
 "If '.' is given as the name of the volume",
 "to be shifted, the shifts for all volumes will be reset.",
 "The following commands will produce the translation along",
 "the Z-axis of the previously drawn volume:", " EXAMPLE -", " dopt hide on",
 " satt * seen -2", " draw NAME 40 40 0 10 10 .01 .01", " shift NAME 0 0 10" };
static KmCommand _GEANT_DRAWING_SHIFT = { &_GEANT_DRAWING_BOMB,
 "/GEANT/DRAWING/SHIFT", "SHIFT", 0, 2, 4, 4, _GEANT_DRAWING_SHIFT_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 17,
 _GEANT_DRAWING_SHIFT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DXCUT_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_DXCUT_CUTTHE_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_CUTTHE = { "CUTTHE", 6,
 "Theta angle of the line normal to cut plane", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_CUTTHE_type };
static KmParReal   _GEANT_DRAWING_DXCUT_CUTPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_CUTPHI = { "CUTPHI", 6,
 "Phi angle of the line normal to cut plane", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_CUTPHI_type };
static KmParReal   _GEANT_DRAWING_DXCUT_CUTVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_CUTVAL = { "CUTVAL", 6,
 "Cut plane distance from the origin along the axis", (char*)0, (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_CUTVAL_type };
static KmParReal   _GEANT_DRAWING_DXCUT_THETA_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_THETA_type };
static KmParReal   _GEANT_DRAWING_DXCUT_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DXCUT_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_PHI_type };
static KmParReal   _GEANT_DRAWING_DXCUT_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DXCUT_U0_type };
static KmParReal   _GEANT_DRAWING_DXCUT_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DXCUT_V0_type };
static KmParReal   _GEANT_DRAWING_DXCUT_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DXCUT_SU_type };
static KmParReal   _GEANT_DRAWING_DXCUT_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DXCUT_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DXCUT_SV_type };
static KmParameter *_GEANT_DRAWING_DXCUT_parameters[] = {
 &_GEANT_DRAWING_DXCUT_NAME, &_GEANT_DRAWING_DXCUT_CUTTHE,
 &_GEANT_DRAWING_DXCUT_CUTPHI, &_GEANT_DRAWING_DXCUT_CUTVAL,
 &_GEANT_DRAWING_DXCUT_THETA, &_GEANT_DRAWING_DXCUT_PHI,
 &_GEANT_DRAWING_DXCUT_U0, &_GEANT_DRAWING_DXCUT_V0, &_GEANT_DRAWING_DXCUT_SU,
 &_GEANT_DRAWING_DXCUT_SV };
static char *_GEANT_DRAWING_DXCUT_guidance[] = {
 " CALL GDRAWX(name,cutthe,cutphi,cutval,theta,phi,u0,v0,su,sv)",
 "The cut plane is normal to the line given by the cut angles",
 "cutthe and cutphi and placed at the distance cutval from the origin.",
 "The resulting picture is seen from the viewing angles theta,phi.",
 "If optional parameters are missing, the current values in /GCDRAW/",
 "are taken." };
static KmCommand _GEANT_DRAWING_DXCUT = { &_GEANT_DRAWING_SHIFT,
 "/GEANT/DRAWING/DXCUT", "DXCUT", 0, 2, 10, 4,
 _GEANT_DRAWING_DXCUT_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 6, _GEANT_DRAWING_DXCUT_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _GEANT_DRAWING_DCUT_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_GEANT_DRAWING_DCUT_CAXIS_range[] = { "X", "Y", "Z" };
static char *_GEANT_DRAWING_DCUT_CAXIS_text[] = { (char*)0, (char*)0, (char*)0
 };
static KmParOption _GEANT_DRAWING_DCUT_CAXIS_type = {
 _GEANT_DRAWING_DCUT_CAXIS_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DCUT_CAXIS = { "CAXIS", 5, "Axis value",
 (char*)0, (char*)0, 8, 3, _GEANT_DRAWING_DCUT_CAXIS_range, 3,
 _GEANT_DRAWING_DCUT_CAXIS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DRAWING_DCUT_CAXIS_type };
static KmParReal   _GEANT_DRAWING_DCUT_CUTVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_CUTVAL = { "CUTVAL", 6,
 "Cut plane distance from the origin along the axis", (char*)0, (char*)0, 12,
 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DCUT_CUTVAL_type };
static KmParReal   _GEANT_DRAWING_DCUT_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DCUT_U0_type };
static KmParReal   _GEANT_DRAWING_DCUT_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCUT_V0_type };
static KmParReal   _GEANT_DRAWING_DCUT_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCUT_SU_type };
static KmParReal   _GEANT_DRAWING_DCUT_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DCUT_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DCUT_SV_type };
static KmParameter *_GEANT_DRAWING_DCUT_parameters[] = {
 &_GEANT_DRAWING_DCUT_NAME, &_GEANT_DRAWING_DCUT_CAXIS,
 &_GEANT_DRAWING_DCUT_CUTVAL, &_GEANT_DRAWING_DCUT_U0,
 &_GEANT_DRAWING_DCUT_V0, &_GEANT_DRAWING_DCUT_SU, &_GEANT_DRAWING_DCUT_SV };
static char *_GEANT_DRAWING_DCUT_guidance[] = {
 " CALL GDRAWC(name,iaxis,cutval,u0,v0,su,sv)",
 "The cut plane is normal to caxis (X,Y,Z), corresponding to iaxis (1,2,3),",
 "and placed at the distance cutval from the origin.",
 "The resulting picture is seen from the the same axis.",
 "If optional parameters are missing, the current values in /GCDRAW/",
 "are taken.",
 "When HIDE Mode is ON, it is possible to get the same effect with",
 "the CVOL/BOX command." };
static KmCommand _GEANT_DRAWING_DCUT = { &_GEANT_DRAWING_DXCUT,
 "/GEANT/DRAWING/DCUT", "DCUT", 0, 2, 7, 3, _GEANT_DRAWING_DCUT_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_DRAWING_DCUT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_DRAWING_DVOLUME_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_N = { "N", 1,
 "Number of elements in arrays LNAMES and LNUMBS", "1", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DRAWING_DVOLUME_N_type };
static KmParameter _GEANT_DRAWING_DVOLUME_NAMNUM = { "NAMNUM", 6,
 "Volume names and numbers (ex. \"NAME1,NR1,NAME2,NR2\")", (char*)0, (char*)0,
 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_GEANT_DRAWING_DVOLUME_CHNRS_range[] = { "MARS", "DRS" };
static char *_GEANT_DRAWING_DVOLUME_CHNRS_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_DRAWING_DVOLUME_CHNRS_type = {
 _GEANT_DRAWING_DVOLUME_CHNRS_text, (int*)0, (int*)0 };
static KmParameter _GEANT_DRAWING_DVOLUME_CHNRS = { "CHNRS", 5,
 "Reference system used", "MARS", (char*)0, 8, 2,
 _GEANT_DRAWING_DVOLUME_CHNRS_range, 2, _GEANT_DRAWING_DVOLUME_CHNRS_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_DRAWING_DVOLUME_CHNRS_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_THETA_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DVOLUME_THETA_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DVOLUME_PHI_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_PSI_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_PSI = { "PSI", 3,
 "Viewing angle psi (for 2D rotation)", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_PSI_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DVOLUME_U0_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_V0_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_SU_type };
static KmParReal   _GEANT_DRAWING_DVOLUME_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DVOLUME_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DVOLUME_SV_type };
static KmParameter *_GEANT_DRAWING_DVOLUME_parameters[] = {
 &_GEANT_DRAWING_DVOLUME_N, &_GEANT_DRAWING_DVOLUME_NAMNUM,
 &_GEANT_DRAWING_DVOLUME_CHNRS, &_GEANT_DRAWING_DVOLUME_THETA,
 &_GEANT_DRAWING_DVOLUME_PHI, &_GEANT_DRAWING_DVOLUME_PSI,
 &_GEANT_DRAWING_DVOLUME_U0, &_GEANT_DRAWING_DVOLUME_V0,
 &_GEANT_DRAWING_DVOLUME_SU, &_GEANT_DRAWING_DVOLUME_SV };
static char *_GEANT_DRAWING_DVOLUME_guidance[] = {
 " CALL GDRVOL(n,lnames,lnumbs,nrs,theta,phi,psi,u0,v0,su,sv)",
 "N is the number of levels from the top of the geometry structure",
 "to the volume lnames(n),lnumbs(n) to be drawn.",
 "NAMNUM contain the arrays lnames and lnumbs,",
 "identifying the path, in pairs and separated by commas; for",
 "example (with n=2) :", "'lname(1),lnumbs(1),lname(2),lnumbs(2) '",
 "CHNRS is the name of the reference system used: MARS for MAster Reference",
 "System or DRS for Daughter Reference System.",
 "NRS=0 for MARS or NRS<>0 for DRS",
 "If optional parameters are missing, the current values in /GCDRAW/",
 "are taken." };
static KmCommand _GEANT_DRAWING_DVOLUME = { &_GEANT_DRAWING_DCUT,
 "/GEANT/DRAWING/DVOLUME", "DVOLUME", 0, 2, 10, 3,
 _GEANT_DRAWING_DVOLUME_parameters, 0, 0, gxdraw_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 12, _GEANT_DRAWING_DVOLUME_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_RANG5D_X1MIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_X1MIN = { "X1MIN", 5,
 "x coordinate min", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_X1MIN_type };
static KmParReal   _GEANT_DRAWING_RANG5D_X1MAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_X1MAX = { "X1MAX", 5,
 "x coordinate max", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_X1MAX_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Y1MIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Y1MIN = { "Y1MIN", 5,
 "y coordinate min", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Y1MIN_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Y1MAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Y1MAX = { "Y1MAX", 5,
 "y coordinate max", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Y1MAX_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Z1MIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Z1MIN = { "Z1MIN", 5,
 "z coordinate min", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Z1MIN_type };
static KmParReal   _GEANT_DRAWING_RANG5D_Z1MAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_RANG5D_Z1MAX = { "Z1MAX", 5,
 "z coordinate max", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_RANG5D_Z1MAX_type };
static KmParameter *_GEANT_DRAWING_RANG5D_parameters[] = {
 &_GEANT_DRAWING_RANG5D_X1MIN, &_GEANT_DRAWING_RANG5D_X1MAX,
 &_GEANT_DRAWING_RANG5D_Y1MIN, &_GEANT_DRAWING_RANG5D_Y1MAX,
 &_GEANT_DRAWING_RANG5D_Z1MIN, &_GEANT_DRAWING_RANG5D_Z1MAX };
static char *_GEANT_DRAWING_RANG5D_guidance[] = {
 "It sets the range for the x,y,z variables." };
static KmCommand _GEANT_DRAWING_RANG5D = { &_GEANT_DRAWING_DVOLUME,
 "/GEANT/DRAWING/RANG5D", "RANG5D", 0, 2, 6, 6,
 _GEANT_DRAWING_RANG5D_parameters, 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_DRAWING_RANG5D_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParReal   _GEANT_DRAWING_VAR5D_TSEQTO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TSEQTO = { "TSEQTO", 6,
 "total sequential time", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TSEQTO_type };
static KmParInt    _GEANT_DRAWING_VAR5D_NPROC_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_NPROC = { "NPROC", 5,
 "number of processors", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_VAR5D_NPROC_type };
static KmParInt    _GEANT_DRAWING_VAR5D_NMPTOT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_NMPTOT = { "NMPTOT", 6,
 "number of message passing", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_VAR5D_NMPTOT_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TOTMBY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TOTMBY = { "TOTMBY", 6,
 "total megabytes transfert", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TOTMBY_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TSEQ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TSEQ = { "TSEQ", 4,
 "not parallelized code", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TSEQ_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TLAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TLAT = { "TLAT", 4, "latency time",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TLAT_type };
static KmParReal   _GEANT_DRAWING_VAR5D_TNET_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_VAR5D_TNET = { "TNET", 4,
 "network speed in Mbytes/sec", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_VAR5D_TNET_type };
static KmParameter *_GEANT_DRAWING_VAR5D_parameters[] = {
 &_GEANT_DRAWING_VAR5D_TSEQTO, &_GEANT_DRAWING_VAR5D_NPROC,
 &_GEANT_DRAWING_VAR5D_NMPTOT, &_GEANT_DRAWING_VAR5D_TOTMBY,
 &_GEANT_DRAWING_VAR5D_TSEQ, &_GEANT_DRAWING_VAR5D_TLAT,
 &_GEANT_DRAWING_VAR5D_TNET };
static char *_GEANT_DRAWING_VAR5D_guidance[] = {
 "It sets the values of the parameters expressed in the formula and",
 "specify which variables must be assumed as x,y,z (setting their value",
 "to 1001,1002,1003, respectively)." };
static KmCommand _GEANT_DRAWING_VAR5D = { &_GEANT_DRAWING_RANG5D,
 "/GEANT/DRAWING/VAR5D", "VAR5D", 0, 2, 7, 7, _GEANT_DRAWING_VAR5D_parameters,
 0, 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_DRAWING_VAR5D_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_DRAWING_SPOT_XLPOS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_XLPOS = { "XLPOS", 5,
 "x coordinate of light source", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SPOT_XLPOS_type };
static KmParReal   _GEANT_DRAWING_SPOT_YLPOS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_YLPOS = { "YLPOS", 5,
 "y coordinate of light source", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SPOT_YLPOS_type };
static KmParReal   _GEANT_DRAWING_SPOT_ZLPOS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_ZLPOS = { "ZLPOS", 5,
 "z coordinate of light source", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_SPOT_ZLPOS_type };
static KmParInt    _GEANT_DRAWING_SPOT_INTEN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_SPOT_INTEN = { "INTEN", 5,
 "intensity of light source", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_DRAWING_SPOT_INTEN_type };
static KmParameter *_GEANT_DRAWING_SPOT_parameters[] = {
 &_GEANT_DRAWING_SPOT_XLPOS, &_GEANT_DRAWING_SPOT_YLPOS,
 &_GEANT_DRAWING_SPOT_ZLPOS, &_GEANT_DRAWING_SPOT_INTEN };
static char *_GEANT_DRAWING_SPOT_guidance[] = {
 "This point-like light source can be moved in the space and its intensity",
 "can be changed (INTEN going from 0 to 10) relatively to the ambience light."
 };
static KmCommand _GEANT_DRAWING_SPOT = { &_GEANT_DRAWING_VAR5D,
 "/GEANT/DRAWING/SPOT", "SPOT", 0, 2, 4, 4, _GEANT_DRAWING_SPOT_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_DRAWING_SPOT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_DRAWING_DRAW_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_DRAWING_DRAW_THETA_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_DRAWING_DRAW_THETA = { "THETA", 5,
 "Viewing angle theta (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DRAW_THETA_type };
static KmParReal   _GEANT_DRAWING_DRAW_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DRAW_PHI = { "PHI", 3,
 "Viewing angle phi (for 3D projection)", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DRAW_PHI_type };
static KmParReal   _GEANT_DRAWING_DRAW_PSI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_DRAWING_DRAW_PSI = { "PSI", 3,
 "Viewing angle psi (for 2D rotation)", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_PSI_type };
static KmParReal   _GEANT_DRAWING_DRAW_U0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_U0 = { "U0", 2,
 "U-coord. (horizontal) of volume origin", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_DRAWING_DRAW_U0_type };
static KmParReal   _GEANT_DRAWING_DRAW_V0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_V0 = { "V0", 2,
 "V-coord. (vertical) of volume origin", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_V0_type };
static KmParReal   _GEANT_DRAWING_DRAW_SU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_SU = { "SU", 2,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_SU_type };
static KmParReal   _GEANT_DRAWING_DRAW_SV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DRAWING_DRAW_SV = { "SV", 2,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_DRAWING_DRAW_SV_type };
static KmParameter *_GEANT_DRAWING_DRAW_parameters[] = {
 &_GEANT_DRAWING_DRAW_NAME, &_GEANT_DRAWING_DRAW_THETA,
 &_GEANT_DRAWING_DRAW_PHI, &_GEANT_DRAWING_DRAW_PSI, &_GEANT_DRAWING_DRAW_U0,
 &_GEANT_DRAWING_DRAW_V0, &_GEANT_DRAWING_DRAW_SU, &_GEANT_DRAWING_DRAW_SV };
static char *_GEANT_DRAWING_DRAW_guidance[] = {
 " CALL GDRAW(name,theta,phi,psi,u0,v0,su,sv)",
 "If optional parameters are missing, the corresponding values are",
 "taken from the common /GCDRAW/. This command will draw the volumes,",
 "selected with their graphical attributes, set by the SATT",
 "facility. The drawing may be performed with hidden line removal",
 "and with shading effects according to the value of the options HIDE",
 "and SHAD; if the option SHAD is ON, the contour's edges can be",
 "drawn or not. If the option HIDE is ON, the detector can be",
 "exploded (BOMB), clipped with different shapes (CVOL), and some",
 "of its parts can be shifted from their original",
 "position (SHIFT). When HIDE is ON, if",
 "the drawing requires more than the available memory, the program",
 "will evaluate and display the number of missing words",
 "(so that the user can increase the",
 "size of its ZEBRA store). Finally, at the end of each drawing (with HIDE\
 on),", "the program will print messages about the memory used and",
 "statistics on the volumes' visibility.",
 "The following commands will produce the drawing of a green",
 "volume, specified by NAME, without using the hidden line removal",
 "technique, using the hidden line removal technique,",
 "with different linewidth and colour (red), with",
 "solid colour, with shading of surfaces, and without edges.",
 "Finally, some examples are given for the ray-tracing. (A possible",
 "string for the NAME of the volume can be found using the command DTREE).",
 " EXAMPLE -", " satt * seen -2", " satt NAME colo 3",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " dopt hide on",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " satt NAME colo 2",
 " satt NAME lwid 4", " draw NAME 40 40 0 10 10 .01 .01", " next",
 " dopt shad on", " satt * lwid 1", " satt NAME fill 1",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " satt NAME fill 3",
 " draw NAME 40 40 0 10 10 .01 .01", " next", " dopt edge off",
 " draw NAME 40 40 0 10 10 .01 .01", " dopt rayt on", " satt * fill 20",
 " dopt mapp 1", " draw NAME 40 40 0 10 10 .01 .01", " dopt proj pers",
 " persp NAME 500", " draw NAME 40 40 0 10 10 1 1", " valcut 100 100 100",
 " dopt mapp 0", " dopt user on", " satt NAM1 seen 0", " satt NAM2 colo 2",
 " draw NAME 40 40 0 10 10 5 5" };
static KmCommand _GEANT_DRAWING_DRAW = { &_GEANT_DRAWING_SPOT,
 "/GEANT/DRAWING/DRAW", "DRAW", 0, 2, 8, 1, _GEANT_DRAWING_DRAW_parameters, 0,
 0, gxdraw_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 59,
 _GEANT_DRAWING_DRAW_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_DRAWING_guidance[] = {
 "Drawing commands. These commands allow the visualization in several ways",
 "of the volumes defined in the geometrical data structure. It is possible",
 "to draw the logical tree of volumes belonging to the detector (DTREE),",
 "to show their geometrical specification (DSPEC,DFSPC), to draw them",
 "and their cut views (DRAW, DCUT). Moreover, it is possible to execute",
 "these commands when the hidden line removal option is activated; in",
 "this case, the volumes can be also either translated in the space",
 "(SHIFT), or clipped by boolean operation (CVOL). In addition, it is",
 "possible to fill the surfaces of the volumes",
 "with solid colours when the shading option (SHAD) is activated.",
 "Several tools (ZOOM, LENS) have been developed to zoom detailed parts",
 "of the detectors or to scan physical events as well.",
 "Finally, the command MOVE will allow the rotation, translation and zooming",
 "on real time parts of the detectors or tracks and hits of a simulated\
 event.",
 "Ray-tracing commands. In case the command (DOPT RAYT ON) is executed,",
 "the drawing is performed by the Geant ray-tracing;",
 "automatically, the color is assigned according to the tracking medium of\
 each",
 "volume and the volumes with a density lower/equal than the air are\
 considered",
 "transparent; if the option (USER) is set (ON) (again via the command\
 (DOPT)),",
 "the user can set color and visibility for the desired volumes via the\
 command",
 "(SATT), as usual, relatively to the attributes (COLO) and (SEEN).",
 "The resolution can be set via the command (SATT * FILL VALUE), where\
 (VALUE)",
 "is the ratio between the number of pixels drawn and 20 (user coordinates).",
 "Parallel view and perspective view are possible (DOPT PROJ PARA/PERS); in\
 the",
 "first case, we assume that the first mother volume of the tree is a box\
 with",
 "dimensions 10000 X 10000 X 10000 cm and the view point (infinetely far) is",
 "5000 cm far from the origin along the Z axis of the user coordinates; in\
 the",
 "second case, the distance between the observer and the origin of the world",
 "reference system is set in cm by the command (PERSP NAME VALUE);\
 grand-angle",
 "or telescopic effects can be achieved changing the scale factors in the\
 command", "(DRAW). When the final picture does not occupy the full window,",
 "mapping the space before tracing can speed up the drawing, but can also",
 "produce less precise results; values from 1 to 4 are allowed in the\
 command",
 "(DOPT MAPP VALUE), the mapping being more precise for increasing (VALUE);\
 for",
 "(VALUE = 0) no mapping is performed (therefore max precision and lowest\
 speed).",
 "The command (VALCUT) allows the cutting of the detector by three planes",
 "ortogonal to the x,y,z axis. The attribute (LSTY) can be set by the\
 command",
 "SATT for any desired volume and can assume values from 0 to 7; it\
 determines",
 "the different light processing to be performed for different materials:",
 "0 = dark-matt, 1 = bright-matt, 2 = plastic, 3 = ceramic, 4 =\
 rough-metals,",
 "5 = shiny-metals, 6 = glass, 7 = mirror. The detector is assumed to be in\
 the",
 "dark, the ambient light luminosity is 0.2 for each basic hue (the\
 saturation",
 "is 0.9) and the observer is assumed to have a light source (therefore he\
 will",
 "produce parallel light in the case of parallel view and point-like-source",
 "light in the case of perspective view)." };
static KmMenu _GEANT_DRAWING = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/DRAWING",
 "DRAWING", 2, &_GEANT_DRAWING_DRAW, 45, _GEANT_DRAWING_guidance };

static char *_GEANT_CVOL_guidance[] = { "Clipping commands.",
 "The hidden line removal technique is necessary to visualize properly",
 "very complex detectors. At the same time, it can be useful to visualize",
 "the inner elements of a detector in detail. For this purpose, the",
 "commands menu CVOL has been developed: these commands allow",
 "subtractions (via boolean operation) of given shapes from any part of",
 "the detector, therefore showing its inner contents. It is possible",
 "to clip each different volume by means of a different shape (BOX ,",
 "TUBE, CONE, SPHE are available). If '*' is given as the name of the",
 "volume to be clipped, all volumes are clipped by the given shape.",
 "A volume can be clipped at most twice (even by",
 "different shapes); if a volume is explicitely clipped",
 "twice, the '*' will not act on it anymore. Giving '.' as the name",
 "of the volume to be clipped will reset the clipping." };
static KmMenu _GEANT_CVOL = { &_GEANT_DRAWING,  (KmMenu*)0, "/GEANT/CVOL",
 "CVOL", 2, &_GEANT_CVOL_BOX, 14, _GEANT_CVOL_guidance };

static char *_GEANT_guidance[] = { "GEANT specific commands." };
static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_CVOL, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 1, _GEANT_guidance };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkgcon_ gkgcon
#  define gxgcon_ gxgcon
#endif

#ifdef F77_UCASE
#  define gkgcon_ GKGCON
#  define gxgcon_ GXGCON
#endif

#ifdef IBM370
#  pragma linkage(GKGCON,FORTRAN)
#  pragma linkage(GXGCON,FORTRAN)
#endif

extern void gkgcon_();
extern void gxgcon_();

void gkgcon_()
{

static KmParInt    _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD = { "ICADD", 5,
 "Colour table index", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD_type };
static KmParInt    _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL = { "ICVAL", 5,
 "Colour table value", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_MAP_COLOR_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICADD,
 &_GEANT_GRAPHICS_CONTROL_MAP_COLOR_ICVAL };
static char *_GEANT_GRAPHICS_CONTROL_MAP_COLOR_guidance[] = {
 "Sets the color table LOOKTB(ICADD)=ICVAL.",
 "If ICADD=0 then LOOKTB(1:16) is taken.",
 "If ICVAL is omitted the current value of LOOKTB(ICADD) is shown." };
static KmCommand _GEANT_GRAPHICS_CONTROL_MAP_COLOR = {  (KmCommand*)0,
 "/GEANT/GRAPHICS_CONTROL/MAP_COLOR", "MAP_COLOR", 0, 2, 2, 0,
 _GEANT_GRAPHICS_CONTROL_MAP_COLOR_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_MAP_COLOR_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SPERS_DPERS_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SPERS_DPERS = { "DPERS", 5,
 "Distance from the origin", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GRAPHICS_CONTROL_SPERS_DPERS_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SPERS_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SPERS_DPERS };
static char *_GEANT_GRAPHICS_CONTROL_SPERS_guidance[] = {
 "Set the variable dpers in /GCDRAW/, representing",
 "the distance from the origin when using option PERSpective." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SPERS = {
 &_GEANT_GRAPHICS_CONTROL_MAP_COLOR, "/GEANT/GRAPHICS_CONTROL/SPERS", "SPERS",
 0, 2, 1, 1, _GEANT_GRAPHICS_CONTROL_SPERS_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_GRAPHICS_CONTROL_SPERS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SIZE_XSIZE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SIZE_XSIZE = { "XSIZE", 5,
 "Size along X", "20.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GRAPHICS_CONTROL_SIZE_XSIZE_type };
static KmParReal   _GEANT_GRAPHICS_CONTROL_SIZE_YSIZE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SIZE_YSIZE = { "YSIZE", 5,
 "Size along Y", "20.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GRAPHICS_CONTROL_SIZE_YSIZE_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SIZE_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SIZE_XSIZE, &_GEANT_GRAPHICS_CONTROL_SIZE_YSIZE };
static char *_GEANT_GRAPHICS_CONTROL_SIZE_guidance[] = {
 "Set the size of the picture.",
 "On the terminal, the pictures will have the ratio YSIZE/XSIZE, and,",
 "if a metafile is produced, pictures will be YSIZE by XSIZE cm.",
 "This command sets the parameters for the normalisation transformation",
 "number 1 to [0-XSIZE], [0-YSIZE]." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SIZE = {
 &_GEANT_GRAPHICS_CONTROL_SPERS, "/GEANT/GRAPHICS_CONTROL/SIZE", "SIZE", 0, 2,
 2, 0, _GEANT_GRAPHICS_CONTROL_SIZE_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _GEANT_GRAPHICS_CONTROL_SIZE_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GRAPHICS_CONTROL_DOPT_IOPT = { "IOPT", 4,
 "Option name", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DOPT_IVAL = { "IVAL", 4,
 "Option value", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DOPT_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DOPT_IOPT, &_GEANT_GRAPHICS_CONTROL_DOPT_IVAL };
static char *_GEANT_GRAPHICS_CONTROL_DOPT_guidance[] = {
 " CALL GDOPT(iopt,ival)", "To set/modify the drawing options.",
 "   IOPT   IVAL      Action", "   THRZ    ON       Draw tracks in R vs Z",
 "           OFF (D)  Draw tracks in X,Y,Z", "           180",
 "           360", "   PROJ    PARA (D) Parallel projection",
 "           PERS     Perspective",
 "   TRAK    LINE (D) Trajectory drawn with lines",
 "           POIN       \" \" with markers",
 "   HIDE    ON       Hidden line removal using the CG package",
 "           OFF (D)  No hidden line removal",
 "   SHAD    ON       Fill area and shading of surfaces.",
 "           OFF (D)  Normal hidden line removal.",
 "   RAYT    ON       Ray-tracing on.",
 "           OFF (D)  Ray-tracing off.",
 "   EDGE    OFF      Does not draw contours when shad is on.",
 "           ON  (D)  Normal shading.",
 "   MAPP    1,2,3,4  Mapping before ray-tracing.",
 "           0   (D)  No mapping.",
 "   USER    ON       User graphics options in the raytracing.",
 "           OFF (D)  Automatic graphics options." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DOPT = {
 &_GEANT_GRAPHICS_CONTROL_SIZE, "/GEANT/GRAPHICS_CONTROL/DOPT", "DOPT", 0, 2,
 2, 0, _GEANT_GRAPHICS_CONTROL_DOPT_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 23, _GEANT_GRAPHICS_CONTROL_DOPT_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_NEXT_guidance[] = {
 "Clear screen (start a new picture on graphics file, if opened)." };
static KmCommand _GEANT_GRAPHICS_CONTROL_NEXT = {
 &_GEANT_GRAPHICS_CONTROL_DOPT, "/GEANT/GRAPHICS_CONTROL/NEXT", "NEXT", 0, 2,
 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_GRAPHICS_CONTROL_NEXT_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_LWID_LWIDTH_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_LWID_LWIDTH = { "LWIDTH", 6,
 "Line width code", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_LWID_LWIDTH_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_LWID_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_LWID_LWIDTH };
static char *_GEANT_GRAPHICS_CONTROL_LWID_guidance[] = {
 " CALL GDLW(-abs(lwidth))" };
static KmCommand _GEANT_GRAPHICS_CONTROL_LWID = {
 &_GEANT_GRAPHICS_CONTROL_NEXT, "/GEANT/GRAPHICS_CONTROL/LWID", "LWID", 0, 2,
 1, 1, _GEANT_GRAPHICS_CONTROL_LWID_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_GRAPHICS_CONTROL_LWID_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_COLOR_ICOL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_COLOR_ICOL = { "ICOL", 4,
 "Colour code", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_COLOR_ICOL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_COLOR_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_COLOR_ICOL };
static char *_GEANT_GRAPHICS_CONTROL_COLOR_guidance[] = {
 " CALL GDCOL(-abs(icol))" };
static KmCommand _GEANT_GRAPHICS_CONTROL_COLOR = {
 &_GEANT_GRAPHICS_CONTROL_LWID, "/GEANT/GRAPHICS_CONTROL/COLOR", "COLOR", 0,
 2, 1, 1, _GEANT_GRAPHICS_CONTROL_COLOR_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_COLOR_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SCALE_GSCU_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SCALE_GSCU = { "GSCU", 4,
 "Scale factor for U-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GRAPHICS_CONTROL_SCALE_GSCU_type };
static KmParReal   _GEANT_GRAPHICS_CONTROL_SCALE_GSCV_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SCALE_GSCV = { "GSCV", 4,
 "Scale factor for V-coord.", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GRAPHICS_CONTROL_SCALE_GSCV_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SCALE_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SCALE_GSCU, &_GEANT_GRAPHICS_CONTROL_SCALE_GSCV };
static char *_GEANT_GRAPHICS_CONTROL_SCALE_guidance[] = {
 "Change the scale factors GSCU and GSCV in /GCDRAW/." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SCALE = {
 &_GEANT_GRAPHICS_CONTROL_COLOR, "/GEANT/GRAPHICS_CONTROL/SCALE", "SCALE", 0,
 2, 2, 2, _GEANT_GRAPHICS_CONTROL_SCALE_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_SCALE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GRAPHICS_CONTROL_SATT_NAME = { "NAME", 4,
 "Volume name", "*   ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SATT_IOPT = { "IOPT", 4,
 "Name of the attribute to be set", "DEFA", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GRAPHICS_CONTROL_SATT_IVAL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SATT_IVAL = { "IVAL", 4,
 "Value to which the attribute is to be set", "10000", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GRAPHICS_CONTROL_SATT_IVAL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SATT_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SATT_NAME, &_GEANT_GRAPHICS_CONTROL_SATT_IOPT,
 &_GEANT_GRAPHICS_CONTROL_SATT_IVAL };
static char *_GEANT_GRAPHICS_CONTROL_SATT_guidance[] = {
 " CALL GSATT(name,iopt,ival)", "name='*' stands for all the volumes.",
 "iopt can be chosen among the following :",
 " 'WORK'   0=volume name is inactive for the tracking",
 "          1=volume name is active for the tracking (default)",
 " 'SEEN'   0=volume name is invisible",
 "          1=volume name is visible (default)",
 "         -1=volume invisible with all its descendants in the tree",
 "         -2=volume visible but not its descendants in the tree",
 " 'LSTY'   line style 1,2,3,... (default=1)",
 "          LSTY=7 will produce a very precise approximation for",
 "          revolution bodies.",
 " 'LWID'   line width -7,...,1,2,3,..7 (default=1)",
 "          LWID<0 will act as abs(LWID) was set for the volume",
 "          and for all the levels below it. When SHAD is 'ON', LWID",
 "          represent the linewidth of the scan lines filling the surfaces",
 "          (whereas the FILL value represent their number). Therefore",
 "          tuning this parameter will help to obtain the desired",
 "          quality/performance ratio.",
 " 'COLO'   colour code -166,...,1,2,..166 (default=1)",
 "          n=1=black",
 "          n=2=red;    n=17+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=3=green;  n=67+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=4=blue;   n=117+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=5=yellow; n=42+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=6=violet; n=142+m, m=0,25, increasing luminosity according to\
 'm';",
 "          n=7=lightblue; n=92+m, m=0,25, increasing luminosity according to\
 'm';", "          colour=n*10+m, m=1,2,...9, will produce the same colour",
 "          as 'n', but with increasing luminosity according to 'm';",
 "          COLO<0 will act as if abs(COLO) was set for the volume",
 "          and for all the levels below it.",
 "          When for a volume the attribute FILL is > 1 (and the",
 "          option SHAD is on), the ABS of its colour code must be < 8",
 "          because an automatic shading of its faces will be",
 "          performed.",
 " 'FILL'   (1992) fill area  -7,...,0,1,...7 (default=0)",
 "          when option SHAD is 'on' the FILL attribute of any",
 "          volume can be set different from 0 (normal drawing);",
 "          if it is set to 1, the faces of such volume will be filled",
 "          with solid colours; if ABS(FILL) is > 1, then a light",
 "          source is placed along the observer line, and the faces of",
 "          such volumes will be painted by colours whose luminosity",
 "          will depend on the amount of light reflected;",
 "          if ABS(FILL) = 1, then it is possible to use all the 166",
 "          colours of the colour table, becouse the automatic shading",
 "          is not performed;",
 "          for increasing values of FILL the drawing will be performed",
 "          with higher and higher resolution improving the quality (the",
 "          number of scan lines used to fill the faces increases with\
 FILL);", "          it is possible to set different values of FILL",
 "          for different volumes, in order to optimize at the same time",
 "          the performance and the quality of the picture;",
 "          FILL<0 will act as if abs(FILL) was set for the volume",
 "          and for all the levels below it.",
 "          This kind of drawing can be saved in 'picture files'",
 "          or in view banks.", "          0=drawing without fill area",
 "          1=faces filled with solid colours and resolution = 6",
 "          2=lowest resolution (very fast)",
 "          3=default resolution", "          4=.................",
 "          5=.................", "          6=.................",
 "          7=max resolution",
 "          Finally, if a coloured background is desired, the FILL",
 "          attribute for the first volume of the tree must be set",
 "          equal to -abs(colo), colo being >0 and <166.",
 " 'SET '   set number associated to volume name",
 " 'DET '   detector number associated to volume name",
 " 'DTYP'   detector type (1,2)" };
static KmCommand _GEANT_GRAPHICS_CONTROL_SATT = {
 &_GEANT_GRAPHICS_CONTROL_SCALE, "/GEANT/GRAPHICS_CONTROL/SATT", "SATT", 0, 2,
 3, 0, _GEANT_GRAPHICS_CONTROL_SATT_parameters, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 70, _GEANT_GRAPHICS_CONTROL_SATT_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_GRAPHICS_CONTROL_SSETVA_RVAL_type = { "-10.", "10.",
 "-10.", "10.", 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_SSETVA_RVAL = { "RVAL", 4,
 "Attribute value", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GRAPHICS_CONTROL_SSETVA_RVAL_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SSETVA_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SSETVA_RVAL };
static char *_GEANT_GRAPHICS_CONTROL_SSETVA_guidance[] = {
 "Set current attribute value." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SSETVA = {
 &_GEANT_GRAPHICS_CONTROL_SATT, "/GEANT/GRAPHICS_CONTROL/SSETVA", "SSETVA", 0,
 2, 1, 0, _GEANT_GRAPHICS_CONTROL_SSETVA_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_SSETVA_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GRAPHICS_CONTROL_SSETAT_IOPT = { "IOPT", 4,
 "Attribute name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GRAPHICS_CONTROL_SSETAT_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_SSETAT_IOPT };
static char *_GEANT_GRAPHICS_CONTROL_SSETAT_guidance[] = {
 "Set current attribute." };
static KmCommand _GEANT_GRAPHICS_CONTROL_SSETAT = {
 &_GEANT_GRAPHICS_CONTROL_SSETVA, "/GEANT/GRAPHICS_CONTROL/SSETAT", "SSETAT",
 0, 2, 1, 1, _GEANT_GRAPHICS_CONTROL_SSETAT_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_GRAPHICS_CONTROL_SSETAT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_RESETWK_guidance[] = { "CALL GRESWK",
 "It deactivate the previosly activated workstation and reactivate the",
 "default one." };
static KmCommand _GEANT_GRAPHICS_CONTROL_RESETWK = {
 &_GEANT_GRAPHICS_CONTROL_SSETAT, "/GEANT/GRAPHICS_CONTROL/RESETWK",
 "RESETWK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_RESETWK_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_CHANGEWK_guidance[] = { "CALL GCHNWK",
 "It open a new workstation (if not already opened) and activate it",
 "(deactivating the default one)." };
static KmCommand _GEANT_GRAPHICS_CONTROL_CHANGEWK = {
 &_GEANT_GRAPHICS_CONTROL_RESETWK, "/GEANT/GRAPHICS_CONTROL/CHANGEWK",
 "CHANGEWK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_CHANGEWK_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_DCLOSE_guidance[] = { " CALL GDCLOS",
 "It closes the currently open view bank; it must be called after the",
 "end of the drawing to be stored." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DCLOSE = {
 &_GEANT_GRAPHICS_CONTROL_CHANGEWK, "/GEANT/GRAPHICS_CONTROL/DCLOSE",
 "DCLOSE", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxgcon_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GRAPHICS_CONTROL_DCLOSE_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_DELETE_IVIEW_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DELETE_IVIEW = { "IVIEW", 5,
 "View number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_DELETE_IVIEW_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DELETE_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DELETE_IVIEW };
static char *_GEANT_GRAPHICS_CONTROL_DELETE_guidance[] = {
 " CALL GDELET(iview)", "It deletes a view bank from memory." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DELETE = {
 &_GEANT_GRAPHICS_CONTROL_DCLOSE, "/GEANT/GRAPHICS_CONTROL/DELETE", "DELETE",
 0, 2, 1, 1, _GEANT_GRAPHICS_CONTROL_DELETE_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_GRAPHICS_CONTROL_DELETE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW = { "IVIEW", 5,
 "View number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DSHOW_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DSHOW_IVIEW };
static char *_GEANT_GRAPHICS_CONTROL_DSHOW_guidance[] = {
 " CALL GDSHOW(iview)",
 "It shows on the screen the contents of a view bank. It",
 "can be called after a view bank has been closed." };
static KmCommand _GEANT_GRAPHICS_CONTROL_DSHOW = {
 &_GEANT_GRAPHICS_CONTROL_DELETE, "/GEANT/GRAPHICS_CONTROL/DSHOW", "DSHOW", 0,
 2, 1, 0, _GEANT_GRAPHICS_CONTROL_DSHOW_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_GRAPHICS_CONTROL_DSHOW_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW = { "IVIEW", 5,
 "View number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW_type };
static KmParameter *_GEANT_GRAPHICS_CONTROL_DOPEN_parameters[] = {
 &_GEANT_GRAPHICS_CONTROL_DOPEN_IVIEW };
static char *_GEANT_GRAPHICS_CONTROL_DOPEN_guidance[] = {
 " CALL GDOPEN(iview)",
 "When a drawing is very complex and requires a long time to be",
 "executed, it can be useful to store it in a view bank: after a",
 "call to DOPEN and the execution of the drawing (nothing will",
 "appear on the screen), and after a necessary call to DCLOSE,",
 "the contents of the bank can be displayed in a very fast way",
 "through a call to DSHOW; therefore, the detector can be easily",
 "zoomed many times in different ways. Please note that the pictures",
 "with solid colours can now be stored in a view bank or in 'PICTURE FILES'."
 };
static KmCommand _GEANT_GRAPHICS_CONTROL_DOPEN = {
 &_GEANT_GRAPHICS_CONTROL_DSHOW, "/GEANT/GRAPHICS_CONTROL/DOPEN", "DOPEN", 0,
 2, 1, 1, _GEANT_GRAPHICS_CONTROL_DOPEN_parameters, 0, 0, gxgcon_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _GEANT_GRAPHICS_CONTROL_DOPEN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_GRAPHICS_CONTROL_guidance[] = {
 "Graphics control commands." };
static KmMenu _GEANT_GRAPHICS_CONTROL = {  (KmMenu*)0,  (KmMenu*)0,
 "/GEANT/GRAPHICS_CONTROL", "GRAPHICS_CONTROL", 2,
 &_GEANT_GRAPHICS_CONTROL_DOPEN, 1, _GEANT_GRAPHICS_CONTROL_guidance };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_GRAPHICS_CONTROL, "/GEANT",
 "GEANT", 1,  (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gklist_ gklist
#  define gxlist_ gxlist
#endif

#ifdef F77_UCASE
#  define gklist_ GKLIST
#  define gxlist_ GXLIST
#endif

#ifdef IBM370
#  pragma linkage(GKLIST,FORTRAN)
#  pragma linkage(GXLIST,FORTRAN)
#endif

extern void gklist_();
extern void gxlist_();

void gklist_()
{

static KmParameter _GEANT_LISTS_RSAV_LRSAVE_1 = { "LRSAVE_1", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_2 = { "LRSAVE_2", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_3 = { "LRSAVE_3", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_4 = { "LRSAVE_4", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_5 = { "LRSAVE_5", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_6 = { "LRSAVE_6", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_7 = { "LRSAVE_7", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_8 = { "LRSAVE_8", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_9 = { "LRSAVE_9", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_10 = { "LRSAVE_10", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_11 = { "LRSAVE_11", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_12 = { "LRSAVE_12", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_13 = { "LRSAVE_13", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_14 = { "LRSAVE_14", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_15 = { "LRSAVE_15", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_16 = { "LRSAVE_16", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_17 = { "LRSAVE_17", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_18 = { "LRSAVE_18", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_19 = { "LRSAVE_19", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RSAV_LRSAVE_20 = { "LRSAVE_20", 9,
 "user word", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_RSAV_parameters[] = {
 &_GEANT_LISTS_RSAV_LRSAVE_1, &_GEANT_LISTS_RSAV_LRSAVE_2,
 &_GEANT_LISTS_RSAV_LRSAVE_3, &_GEANT_LISTS_RSAV_LRSAVE_4,
 &_GEANT_LISTS_RSAV_LRSAVE_5, &_GEANT_LISTS_RSAV_LRSAVE_6,
 &_GEANT_LISTS_RSAV_LRSAVE_7, &_GEANT_LISTS_RSAV_LRSAVE_8,
 &_GEANT_LISTS_RSAV_LRSAVE_9, &_GEANT_LISTS_RSAV_LRSAVE_10,
 &_GEANT_LISTS_RSAV_LRSAVE_11, &_GEANT_LISTS_RSAV_LRSAVE_12,
 &_GEANT_LISTS_RSAV_LRSAVE_13, &_GEANT_LISTS_RSAV_LRSAVE_14,
 &_GEANT_LISTS_RSAV_LRSAVE_15, &_GEANT_LISTS_RSAV_LRSAVE_16,
 &_GEANT_LISTS_RSAV_LRSAVE_17, &_GEANT_LISTS_RSAV_LRSAVE_18,
 &_GEANT_LISTS_RSAV_LRSAVE_19, &_GEANT_LISTS_RSAV_LRSAVE_20 };
static char *_GEANT_LISTS_RSAV_guidance[] = {
 "The command RSAV is similar to the RSAV data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_RSAV = {  (KmCommand*)0, "/GEANT/LISTS/RSAV",
 "RSAV", 0, 2, 20, 0, _GEANT_LISTS_RSAV_parameters, 0, 0, gxlist_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_LISTS_RSAV_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_RGET_LRGET_1 = { "LRGET_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_2 = { "LRGET_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_3 = { "LRGET_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_4 = { "LRGET_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_5 = { "LRGET_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_6 = { "LRGET_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_7 = { "LRGET_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_8 = { "LRGET_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_9 = { "LRGET_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_10 = { "LRGET_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_11 = { "LRGET_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_12 = { "LRGET_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_13 = { "LRGET_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_14 = { "LRGET_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_15 = { "LRGET_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_16 = { "LRGET_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_17 = { "LRGET_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_18 = { "LRGET_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_19 = { "LRGET_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_RGET_LRGET_20 = { "LRGET_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_RGET_parameters[] = {
 &_GEANT_LISTS_RGET_LRGET_1, &_GEANT_LISTS_RGET_LRGET_2,
 &_GEANT_LISTS_RGET_LRGET_3, &_GEANT_LISTS_RGET_LRGET_4,
 &_GEANT_LISTS_RGET_LRGET_5, &_GEANT_LISTS_RGET_LRGET_6,
 &_GEANT_LISTS_RGET_LRGET_7, &_GEANT_LISTS_RGET_LRGET_8,
 &_GEANT_LISTS_RGET_LRGET_9, &_GEANT_LISTS_RGET_LRGET_10,
 &_GEANT_LISTS_RGET_LRGET_11, &_GEANT_LISTS_RGET_LRGET_12,
 &_GEANT_LISTS_RGET_LRGET_13, &_GEANT_LISTS_RGET_LRGET_14,
 &_GEANT_LISTS_RGET_LRGET_15, &_GEANT_LISTS_RGET_LRGET_16,
 &_GEANT_LISTS_RGET_LRGET_17, &_GEANT_LISTS_RGET_LRGET_18,
 &_GEANT_LISTS_RGET_LRGET_19, &_GEANT_LISTS_RGET_LRGET_20 };
static char *_GEANT_LISTS_RGET_guidance[] = {
 "The command RGET is similar to the RGET data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_RGET = { &_GEANT_LISTS_RSAV,
 "/GEANT/LISTS/RGET", "RGET", 0, 2, 20, 0, _GEANT_LISTS_RGET_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_RGET_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_STAT_LSTAT_1 = { "LSTAT_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_2 = { "LSTAT_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_3 = { "LSTAT_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_4 = { "LSTAT_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_5 = { "LSTAT_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_6 = { "LSTAT_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_7 = { "LSTAT_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_8 = { "LSTAT_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_9 = { "LSTAT_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_10 = { "LSTAT_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_11 = { "LSTAT_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_12 = { "LSTAT_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_13 = { "LSTAT_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_14 = { "LSTAT_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_15 = { "LSTAT_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_16 = { "LSTAT_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_17 = { "LSTAT_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_18 = { "LSTAT_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_19 = { "LSTAT_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_STAT_LSTAT_20 = { "LSTAT_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_STAT_parameters[] = {
 &_GEANT_LISTS_STAT_LSTAT_1, &_GEANT_LISTS_STAT_LSTAT_2,
 &_GEANT_LISTS_STAT_LSTAT_3, &_GEANT_LISTS_STAT_LSTAT_4,
 &_GEANT_LISTS_STAT_LSTAT_5, &_GEANT_LISTS_STAT_LSTAT_6,
 &_GEANT_LISTS_STAT_LSTAT_7, &_GEANT_LISTS_STAT_LSTAT_8,
 &_GEANT_LISTS_STAT_LSTAT_9, &_GEANT_LISTS_STAT_LSTAT_10,
 &_GEANT_LISTS_STAT_LSTAT_11, &_GEANT_LISTS_STAT_LSTAT_12,
 &_GEANT_LISTS_STAT_LSTAT_13, &_GEANT_LISTS_STAT_LSTAT_14,
 &_GEANT_LISTS_STAT_LSTAT_15, &_GEANT_LISTS_STAT_LSTAT_16,
 &_GEANT_LISTS_STAT_LSTAT_17, &_GEANT_LISTS_STAT_LSTAT_18,
 &_GEANT_LISTS_STAT_LSTAT_19, &_GEANT_LISTS_STAT_LSTAT_20 };
static char *_GEANT_LISTS_STAT_guidance[] = {
 "The command STAT is similar to the STAT data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_STAT = { &_GEANT_LISTS_RGET,
 "/GEANT/LISTS/STAT", "STAT", 0, 2, 20, 0, _GEANT_LISTS_STAT_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_STAT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_PLOT_LPLOT_1 = { "LPLOT_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_2 = { "LPLOT_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_3 = { "LPLOT_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_4 = { "LPLOT_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_5 = { "LPLOT_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_6 = { "LPLOT_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_7 = { "LPLOT_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_8 = { "LPLOT_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_9 = { "LPLOT_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_10 = { "LPLOT_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_11 = { "LPLOT_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_12 = { "LPLOT_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_13 = { "LPLOT_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_14 = { "LPLOT_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_15 = { "LPLOT_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_16 = { "LPLOT_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_17 = { "LPLOT_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_18 = { "LPLOT_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_19 = { "LPLOT_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_PLOT_LPLOT_20 = { "LPLOT_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_PLOT_parameters[] = {
 &_GEANT_LISTS_PLOT_LPLOT_1, &_GEANT_LISTS_PLOT_LPLOT_2,
 &_GEANT_LISTS_PLOT_LPLOT_3, &_GEANT_LISTS_PLOT_LPLOT_4,
 &_GEANT_LISTS_PLOT_LPLOT_5, &_GEANT_LISTS_PLOT_LPLOT_6,
 &_GEANT_LISTS_PLOT_LPLOT_7, &_GEANT_LISTS_PLOT_LPLOT_8,
 &_GEANT_LISTS_PLOT_LPLOT_9, &_GEANT_LISTS_PLOT_LPLOT_10,
 &_GEANT_LISTS_PLOT_LPLOT_11, &_GEANT_LISTS_PLOT_LPLOT_12,
 &_GEANT_LISTS_PLOT_LPLOT_13, &_GEANT_LISTS_PLOT_LPLOT_14,
 &_GEANT_LISTS_PLOT_LPLOT_15, &_GEANT_LISTS_PLOT_LPLOT_16,
 &_GEANT_LISTS_PLOT_LPLOT_17, &_GEANT_LISTS_PLOT_LPLOT_18,
 &_GEANT_LISTS_PLOT_LPLOT_19, &_GEANT_LISTS_PLOT_LPLOT_20 };
static char *_GEANT_LISTS_PLOT_guidance[] = {
 "The command PLOT is similar to the PLOT data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_PLOT = { &_GEANT_LISTS_STAT,
 "/GEANT/LISTS/PLOT", "PLOT", 0, 2, 20, 0, _GEANT_LISTS_PLOT_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_PLOT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_VIEW_LVIEW_1 = { "LVIEW_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_2 = { "LVIEW_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_3 = { "LVIEW_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_4 = { "LVIEW_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_5 = { "LVIEW_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_6 = { "LVIEW_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_7 = { "LVIEW_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_8 = { "LVIEW_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_9 = { "LVIEW_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_10 = { "LVIEW_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_11 = { "LVIEW_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_12 = { "LVIEW_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_13 = { "LVIEW_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_14 = { "LVIEW_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_15 = { "LVIEW_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_16 = { "LVIEW_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_17 = { "LVIEW_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_18 = { "LVIEW_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_19 = { "LVIEW_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_VIEW_LVIEW_20 = { "LVIEW_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_VIEW_parameters[] = {
 &_GEANT_LISTS_VIEW_LVIEW_1, &_GEANT_LISTS_VIEW_LVIEW_2,
 &_GEANT_LISTS_VIEW_LVIEW_3, &_GEANT_LISTS_VIEW_LVIEW_4,
 &_GEANT_LISTS_VIEW_LVIEW_5, &_GEANT_LISTS_VIEW_LVIEW_6,
 &_GEANT_LISTS_VIEW_LVIEW_7, &_GEANT_LISTS_VIEW_LVIEW_8,
 &_GEANT_LISTS_VIEW_LVIEW_9, &_GEANT_LISTS_VIEW_LVIEW_10,
 &_GEANT_LISTS_VIEW_LVIEW_11, &_GEANT_LISTS_VIEW_LVIEW_12,
 &_GEANT_LISTS_VIEW_LVIEW_13, &_GEANT_LISTS_VIEW_LVIEW_14,
 &_GEANT_LISTS_VIEW_LVIEW_15, &_GEANT_LISTS_VIEW_LVIEW_16,
 &_GEANT_LISTS_VIEW_LVIEW_17, &_GEANT_LISTS_VIEW_LVIEW_18,
 &_GEANT_LISTS_VIEW_LVIEW_19, &_GEANT_LISTS_VIEW_LVIEW_20 };
static char *_GEANT_LISTS_VIEW_guidance[] = {
 "The command VIEW is similar to the VIEW data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_VIEW = { &_GEANT_LISTS_PLOT,
 "/GEANT/LISTS/VIEW", "VIEW", 0, 2, 20, 0, _GEANT_LISTS_VIEW_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_VIEW_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_GEOM_LGEOM_1 = { "LGEOM_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_2 = { "LGEOM_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_3 = { "LGEOM_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_4 = { "LGEOM_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_5 = { "LGEOM_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_6 = { "LGEOM_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_7 = { "LGEOM_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_8 = { "LGEOM_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_9 = { "LGEOM_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_10 = { "LGEOM_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_11 = { "LGEOM_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_12 = { "LGEOM_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_13 = { "LGEOM_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_14 = { "LGEOM_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_15 = { "LGEOM_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_16 = { "LGEOM_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_17 = { "LGEOM_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_18 = { "LGEOM_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_19 = { "LGEOM_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GEOM_LGEOM_20 = { "LGEOM_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_GEOM_parameters[] = {
 &_GEANT_LISTS_GEOM_LGEOM_1, &_GEANT_LISTS_GEOM_LGEOM_2,
 &_GEANT_LISTS_GEOM_LGEOM_3, &_GEANT_LISTS_GEOM_LGEOM_4,
 &_GEANT_LISTS_GEOM_LGEOM_5, &_GEANT_LISTS_GEOM_LGEOM_6,
 &_GEANT_LISTS_GEOM_LGEOM_7, &_GEANT_LISTS_GEOM_LGEOM_8,
 &_GEANT_LISTS_GEOM_LGEOM_9, &_GEANT_LISTS_GEOM_LGEOM_10,
 &_GEANT_LISTS_GEOM_LGEOM_11, &_GEANT_LISTS_GEOM_LGEOM_12,
 &_GEANT_LISTS_GEOM_LGEOM_13, &_GEANT_LISTS_GEOM_LGEOM_14,
 &_GEANT_LISTS_GEOM_LGEOM_15, &_GEANT_LISTS_GEOM_LGEOM_16,
 &_GEANT_LISTS_GEOM_LGEOM_17, &_GEANT_LISTS_GEOM_LGEOM_18,
 &_GEANT_LISTS_GEOM_LGEOM_19, &_GEANT_LISTS_GEOM_LGEOM_20 };
static char *_GEANT_LISTS_GEOM_guidance[] = {
 "The command GEOM is similar to the GEOM data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_GEOM = { &_GEANT_LISTS_VIEW,
 "/GEANT/LISTS/GEOM", "GEOM", 0, 2, 20, 0, _GEANT_LISTS_GEOM_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_GEOM_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_LPRIN_LPRIN_1 = { "LPRIN_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_2 = { "LPRIN_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_3 = { "LPRIN_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_4 = { "LPRIN_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_5 = { "LPRIN_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_6 = { "LPRIN_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_7 = { "LPRIN_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_8 = { "LPRIN_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_9 = { "LPRIN_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_10 = { "LPRIN_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_11 = { "LPRIN_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_12 = { "LPRIN_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_13 = { "LPRIN_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_14 = { "LPRIN_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_15 = { "LPRIN_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_16 = { "LPRIN_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_17 = { "LPRIN_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_18 = { "LPRIN_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_19 = { "LPRIN_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_LPRIN_LPRIN_20 = { "LPRIN_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_LPRIN_parameters[] = {
 &_GEANT_LISTS_LPRIN_LPRIN_1, &_GEANT_LISTS_LPRIN_LPRIN_2,
 &_GEANT_LISTS_LPRIN_LPRIN_3, &_GEANT_LISTS_LPRIN_LPRIN_4,
 &_GEANT_LISTS_LPRIN_LPRIN_5, &_GEANT_LISTS_LPRIN_LPRIN_6,
 &_GEANT_LISTS_LPRIN_LPRIN_7, &_GEANT_LISTS_LPRIN_LPRIN_8,
 &_GEANT_LISTS_LPRIN_LPRIN_9, &_GEANT_LISTS_LPRIN_LPRIN_10,
 &_GEANT_LISTS_LPRIN_LPRIN_11, &_GEANT_LISTS_LPRIN_LPRIN_12,
 &_GEANT_LISTS_LPRIN_LPRIN_13, &_GEANT_LISTS_LPRIN_LPRIN_14,
 &_GEANT_LISTS_LPRIN_LPRIN_15, &_GEANT_LISTS_LPRIN_LPRIN_16,
 &_GEANT_LISTS_LPRIN_LPRIN_17, &_GEANT_LISTS_LPRIN_LPRIN_18,
 &_GEANT_LISTS_LPRIN_LPRIN_19, &_GEANT_LISTS_LPRIN_LPRIN_20 };
static char *_GEANT_LISTS_LPRIN_guidance[] = {
 "The command PRIN is similar to the PRIN data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_LPRIN = { &_GEANT_LISTS_GEOM,
 "/GEANT/LISTS/LPRIN", "LPRIN", 0, 2, 20, 0, _GEANT_LISTS_LPRIN_parameters, 0,
 0, gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_LPRIN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_SETS_LSETS_1 = { "LSETS_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_2 = { "LSETS_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_3 = { "LSETS_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_4 = { "LSETS_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_5 = { "LSETS_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_6 = { "LSETS_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_7 = { "LSETS_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_8 = { "LSETS_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_9 = { "LSETS_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_10 = { "LSETS_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_11 = { "LSETS_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_12 = { "LSETS_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_13 = { "LSETS_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_14 = { "LSETS_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_15 = { "LSETS_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_16 = { "LSETS_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_17 = { "LSETS_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_18 = { "LSETS_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_19 = { "LSETS_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SETS_LSETS_20 = { "LSETS_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_SETS_parameters[] = {
 &_GEANT_LISTS_SETS_LSETS_1, &_GEANT_LISTS_SETS_LSETS_2,
 &_GEANT_LISTS_SETS_LSETS_3, &_GEANT_LISTS_SETS_LSETS_4,
 &_GEANT_LISTS_SETS_LSETS_5, &_GEANT_LISTS_SETS_LSETS_6,
 &_GEANT_LISTS_SETS_LSETS_7, &_GEANT_LISTS_SETS_LSETS_8,
 &_GEANT_LISTS_SETS_LSETS_9, &_GEANT_LISTS_SETS_LSETS_10,
 &_GEANT_LISTS_SETS_LSETS_11, &_GEANT_LISTS_SETS_LSETS_12,
 &_GEANT_LISTS_SETS_LSETS_13, &_GEANT_LISTS_SETS_LSETS_14,
 &_GEANT_LISTS_SETS_LSETS_15, &_GEANT_LISTS_SETS_LSETS_16,
 &_GEANT_LISTS_SETS_LSETS_17, &_GEANT_LISTS_SETS_LSETS_18,
 &_GEANT_LISTS_SETS_LSETS_19, &_GEANT_LISTS_SETS_LSETS_20 };
static char *_GEANT_LISTS_SETS_guidance[] = {
 "The command SETS is similar to the SETS data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_SETS = { &_GEANT_LISTS_LPRIN,
 "/GEANT/LISTS/SETS", "SETS", 0, 2, 20, 0, _GEANT_LISTS_SETS_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_SETS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_SAVE_LSAVE_1 = { "LSAVE_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_2 = { "LSAVE_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_3 = { "LSAVE_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_4 = { "LSAVE_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_5 = { "LSAVE_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_6 = { "LSAVE_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_7 = { "LSAVE_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_8 = { "LSAVE_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_9 = { "LSAVE_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_10 = { "LSAVE_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_11 = { "LSAVE_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_12 = { "LSAVE_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_13 = { "LSAVE_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_14 = { "LSAVE_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_15 = { "LSAVE_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_16 = { "LSAVE_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_17 = { "LSAVE_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_18 = { "LSAVE_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_19 = { "LSAVE_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_SAVE_LSAVE_20 = { "LSAVE_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_SAVE_parameters[] = {
 &_GEANT_LISTS_SAVE_LSAVE_1, &_GEANT_LISTS_SAVE_LSAVE_2,
 &_GEANT_LISTS_SAVE_LSAVE_3, &_GEANT_LISTS_SAVE_LSAVE_4,
 &_GEANT_LISTS_SAVE_LSAVE_5, &_GEANT_LISTS_SAVE_LSAVE_6,
 &_GEANT_LISTS_SAVE_LSAVE_7, &_GEANT_LISTS_SAVE_LSAVE_8,
 &_GEANT_LISTS_SAVE_LSAVE_9, &_GEANT_LISTS_SAVE_LSAVE_10,
 &_GEANT_LISTS_SAVE_LSAVE_11, &_GEANT_LISTS_SAVE_LSAVE_12,
 &_GEANT_LISTS_SAVE_LSAVE_13, &_GEANT_LISTS_SAVE_LSAVE_14,
 &_GEANT_LISTS_SAVE_LSAVE_15, &_GEANT_LISTS_SAVE_LSAVE_16,
 &_GEANT_LISTS_SAVE_LSAVE_17, &_GEANT_LISTS_SAVE_LSAVE_18,
 &_GEANT_LISTS_SAVE_LSAVE_19, &_GEANT_LISTS_SAVE_LSAVE_20 };
static char *_GEANT_LISTS_SAVE_guidance[] = {
 "The command SAVE is similar to the SAVE data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_SAVE = { &_GEANT_LISTS_SETS,
 "/GEANT/LISTS/SAVE", "SAVE", 0, 2, 20, 0, _GEANT_LISTS_SAVE_parameters, 0, 0,
 gxlist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_LISTS_SAVE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_GET_LGET_1 = { "LGET_1", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_2 = { "LGET_2", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_3 = { "LGET_3", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_4 = { "LGET_4", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_5 = { "LGET_5", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_6 = { "LGET_6", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_7 = { "LGET_7", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_8 = { "LGET_8", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_9 = { "LGET_9", 6, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_10 = { "LGET_10", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_11 = { "LGET_11", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_12 = { "LGET_12", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_13 = { "LGET_13", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_14 = { "LGET_14", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_15 = { "LGET_15", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_16 = { "LGET_16", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_17 = { "LGET_17", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_18 = { "LGET_18", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_19 = { "LGET_19", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_GET_LGET_20 = { "LGET_20", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_GET_parameters[] = {
 &_GEANT_LISTS_GET_LGET_1, &_GEANT_LISTS_GET_LGET_2, &_GEANT_LISTS_GET_LGET_3,
 &_GEANT_LISTS_GET_LGET_4, &_GEANT_LISTS_GET_LGET_5, &_GEANT_LISTS_GET_LGET_6,
 &_GEANT_LISTS_GET_LGET_7, &_GEANT_LISTS_GET_LGET_8, &_GEANT_LISTS_GET_LGET_9,
 &_GEANT_LISTS_GET_LGET_10, &_GEANT_LISTS_GET_LGET_11,
 &_GEANT_LISTS_GET_LGET_12, &_GEANT_LISTS_GET_LGET_13,
 &_GEANT_LISTS_GET_LGET_14, &_GEANT_LISTS_GET_LGET_15,
 &_GEANT_LISTS_GET_LGET_16, &_GEANT_LISTS_GET_LGET_17,
 &_GEANT_LISTS_GET_LGET_18, &_GEANT_LISTS_GET_LGET_19,
 &_GEANT_LISTS_GET_LGET_20 };
static char *_GEANT_LISTS_GET_guidance[] = {
 "The command GET is similar to the GET data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_GET = { &_GEANT_LISTS_SAVE, "/GEANT/LISTS/GET",
 "GET", 0, 2, 20, 0, _GEANT_LISTS_GET_parameters, 0, 0, gxlist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_LISTS_GET_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_LISTS_HSTA_LHSTA_1 = { "LHSTA_1", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_2 = { "LHSTA_2", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_3 = { "LHSTA_3", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_4 = { "LHSTA_4", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_5 = { "LHSTA_5", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_6 = { "LHSTA_6", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_7 = { "LHSTA_7", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_8 = { "LHSTA_8", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_9 = { "LHSTA_9", 7, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_10 = { "LHSTA_10", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_11 = { "LHSTA_11", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_12 = { "LHSTA_12", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_13 = { "LHSTA_13", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_14 = { "LHSTA_14", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_15 = { "LHSTA_15", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_16 = { "LHSTA_16", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_17 = { "LHSTA_17", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_18 = { "LHSTA_18", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_19 = { "LHSTA_19", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_LISTS_HSTA_LHSTA_20 = { "LHSTA_20", 8, "user word",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_LISTS_HSTA_parameters[] = {
 &_GEANT_LISTS_HSTA_LHSTA_1, &_GEANT_LISTS_HSTA_LHSTA_2,
 &_GEANT_LISTS_HSTA_LHSTA_3, &_GEANT_LISTS_HSTA_LHSTA_4,
 &_GEANT_LISTS_HSTA_LHSTA_5, &_GEANT_LISTS_HSTA_LHSTA_6,
 &_GEANT_LISTS_HSTA_LHSTA_7, &_GEANT_LISTS_HSTA_LHSTA_8,
 &_GEANT_LISTS_HSTA_LHSTA_9, &_GEANT_LISTS_HSTA_LHSTA_10,
 &_GEANT_LISTS_HSTA_LHSTA_11, &_GEANT_LISTS_HSTA_LHSTA_12,
 &_GEANT_LISTS_HSTA_LHSTA_13, &_GEANT_LISTS_HSTA_LHSTA_14,
 &_GEANT_LISTS_HSTA_LHSTA_15, &_GEANT_LISTS_HSTA_LHSTA_16,
 &_GEANT_LISTS_HSTA_LHSTA_17, &_GEANT_LISTS_HSTA_LHSTA_18,
 &_GEANT_LISTS_HSTA_LHSTA_19, &_GEANT_LISTS_HSTA_LHSTA_20 };
static char *_GEANT_LISTS_HSTA_guidance[] = {
 "The command HSTA is similar to the HSTA data records. It can accept",
 "up to 20 4-character words. If the first argument is '.', the number",
 "of words is reset to 0 and all the words to four blanks." };
static KmCommand _GEANT_LISTS_HSTA = { &_GEANT_LISTS_GET, "/GEANT/LISTS/HSTA",
 "HSTA", 0, 2, 20, 0, _GEANT_LISTS_HSTA_parameters, 0, 0, gxlist_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_LISTS_HSTA_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmMenu _GEANT_LISTS = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/LISTS",
 "LISTS", 2, &_GEANT_LISTS_HSTA, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_LISTS, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkgeom_ gkgeom
#  define gxgeom_ gxgeom
#endif

#ifdef F77_UCASE
#  define gkgeom_ GKGEOM
#  define gxgeom_ GXGEOM
#endif

#ifdef IBM370
#  pragma linkage(GKGEOM,FORTRAN)
#  pragma linkage(GXGEOM,FORTRAN)
#endif

extern void gkgeom_();
extern void gxgeom_();

void gkgeom_()
{

static KmParInt    _GEANT_GEOMETRY_WEUCLID_LUN_type = { "1", "100", "1",
 "100", 0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_LUN = { "LUN", 3,
 "Logical unit of the file to be written", (char*)0, (char*)0, 4, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_WEUCLID_LUN_type };
static KmParameter _GEANT_GEOMETRY_WEUCLID_FNAME = { "FNAME", 5,
 "Name of the EUCLID file to be written", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_TOPVOL = { "TOPVOL", 6,
 "Volume name of the starting node", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_WEUCLID_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_NUMBER = { "NUMBER", 6,
 "Copy number of TOPVOL (relevant for GSPOSP)", "1", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_WEUCLID_NUMBER_type };
static KmParInt    _GEANT_GEOMETRY_WEUCLID_NLEVEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_WEUCLID_NLEVEL = { "NLEVEL", 6,
 "Number of levels in the tree structure", "15", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_WEUCLID_NLEVEL_type };
static KmParameter *_GEANT_GEOMETRY_WEUCLID_parameters[] = {
 &_GEANT_GEOMETRY_WEUCLID_LUN, &_GEANT_GEOMETRY_WEUCLID_FNAME,
 &_GEANT_GEOMETRY_WEUCLID_TOPVOL, &_GEANT_GEOMETRY_WEUCLID_NUMBER,
 &_GEANT_GEOMETRY_WEUCLID_NLEVEL };
static char *_GEANT_GEOMETRY_WEUCLID_guidance[] = {
 "          CALL GWEUCL(LUN,FNAME)",
 "Calls the routine to write the current GEANT geometry into an ASCII file",
 "in EUCLID compatible format." };
static KmCommand _GEANT_GEOMETRY_WEUCLID = {  (KmCommand*)0,
 "/GEANT/GEOMETRY/WEUCLID", "WEUCLID", 0, 2, 5, 3,
 _GEANT_GEOMETRY_WEUCLID_parameters, 0, 0, gxgeom_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GEOMETRY_WEUCLID_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_REUCLID_LUN_type = { "1", "100", "1",
 "100", 0 };
static KmParameter _GEANT_GEOMETRY_REUCLID_LUN = { "LUN", 3,
 "Logical unit of the file to be read", (char*)0, (char*)0, 4, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_REUCLID_LUN_type };
static KmParameter _GEANT_GEOMETRY_REUCLID_FNAME = { "FNAME", 5,
 "Name of the EUCLID file to be read", (char*)0, (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_REUCLID_parameters[] = {
 &_GEANT_GEOMETRY_REUCLID_LUN, &_GEANT_GEOMETRY_REUCLID_FNAME };
static char *_GEANT_GEOMETRY_REUCLID_guidance[] = {
 "          CALL GREUCL(LUN,FNAME)",
 "Calls the routine to read into GEANT a geometry from an ASCII file",
 "written by the EUCLID-GEANT interface." };
static KmCommand _GEANT_GEOMETRY_REUCLID = { &_GEANT_GEOMETRY_WEUCLID,
 "/GEANT/GEOMETRY/REUCLID", "REUCLID", 0, 2, 2, 2,
 _GEANT_GEOMETRY_REUCLID_parameters, 0, 0, gxgeom_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_GEOMETRY_REUCLID_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GEOMETRY_CADINT_FNAME = { "FNAME", 5,
 "Name of the SET file", "example.set", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_ANAME = { "ANAME", 5,
 "Name of the volume", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_CADINT_NBINS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_CADINT_NBINS = { "NBINS", 5,
 "Number of the instances", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_CADINT_NBINS_type };
static KmParInt    _GEANT_GEOMETRY_CADINT_LUNIT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_CADINT_LUNIT = { "LUNIT", 5,
 "Logical unit number for SET file", "66", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_CADINT_LUNIT_type };
static KmParInt    _GEANT_GEOMETRY_CADINT_LUNIT2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_CADINT_LUNIT2 = { "LUNIT2", 6,
 "Logical unit number for material file", "67", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_CADINT_LUNIT2_type };
static KmParameter _GEANT_GEOMETRY_CADINT_INST = { "INST", 4,
 "Name of your institute", "CERN", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_SITE = { "SITE", 4, "Name of site",
 "MEYRIN", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_DEPT = { "DEPT", 4,
 "Name of departement", "CN", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_CADINT_RESP = { "RESP", 4,
 "Name of sender", "god_knows_who", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_CADINT_parameters[] = {
 &_GEANT_GEOMETRY_CADINT_FNAME, &_GEANT_GEOMETRY_CADINT_ANAME,
 &_GEANT_GEOMETRY_CADINT_NBINS, &_GEANT_GEOMETRY_CADINT_LUNIT,
 &_GEANT_GEOMETRY_CADINT_LUNIT2, &_GEANT_GEOMETRY_CADINT_INST,
 &_GEANT_GEOMETRY_CADINT_SITE, &_GEANT_GEOMETRY_CADINT_DEPT,
 &_GEANT_GEOMETRY_CADINT_RESP };
static char *_GEANT_GEOMETRY_CADINT_guidance[] = {
 " CALL GTXSET(fname,aname,nbins,lunit,lunit2,inst,site,dept,resp)",
 "This command produces a SET file describing the given volume with",
 "the contents currently set visible. (Use the visibility attribute,",
 "see SATT SEEN.) The description is given as a flat assembly",
 "related to the global coordinate system.",
 "The ouput can be read into CAD systems (EUCLID-IS) trough a SET interface.",
 "A list of materials of the volumes in the SET file and the GEANT tree",
 "is written into a file with the same filename as the SET file,",
 "but with extension .mat." };
static KmCommand _GEANT_GEOMETRY_CADINT = { &_GEANT_GEOMETRY_REUCLID,
 "/GEANT/GEOMETRY/CADINT", "CADINT", 0, 2, 9, 9,
 _GEANT_GEOMETRY_CADINT_parameters, 0, 0, gxgeom_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 9, _GEANT_GEOMETRY_CADINT_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_GEOMETRY_EDITV_ISEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_EDITV_ISEL = { "ISEL", 4, "Options", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_EDITV_ISEL_type };
static KmParameter _GEANT_GEOMETRY_EDITV_NAME = { "NAME", 4, "Volume name",
 "   ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_GEANT_GEOMETRY_EDITV_parameters[] = {
 &_GEANT_GEOMETRY_EDITV_ISEL, &_GEANT_GEOMETRY_EDITV_NAME };
static char *_GEANT_GEOMETRY_EDITV_guidance[] = { " CALL GEDITV(isel,name)",
 "When the routine prompts for input parameters that do not need",
 "to be changed, type return.",
 "ISEL is used to select the editing operation to be performed:",
 " ISEL=0, CALL GGCLOS",
 " ISEL=1, to modify shape parameters PAR given by GSVOLU",
 " ISEL=2, to modify NAME given by GSVOLU",
 " ISEL=3, to delete NAME given by GSVOLU",
 " ISEL=4, to unlink NAME,NR given by GSPOS/GSDVN/GSDV..",
 " ISEL=5, to modify X0,Y0,Z0 of NAME,NR given by GSPOS",
 " ISEL=6, to modify IROT of NAME,NR given by GSPOS",
 " ISEL=7, to modify NDIV given by GSDVN",
 " ISEL=8, to modify IAXIS given by GSDVN" };
static KmCommand _GEANT_GEOMETRY_EDITV = { &_GEANT_GEOMETRY_CADINT,
 "/GEANT/GEOMETRY/EDITV", "EDITV", 0, 2, 2, 0,
 _GEANT_GEOMETRY_EDITV_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 13, _GEANT_GEOMETRY_EDITV_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_GEOMETRY_PTMED_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_PTMED_NUMB = { "NUMB", 4, "Medium ID",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_PTMED_NUMB_type };
static KmParameter *_GEANT_GEOMETRY_PTMED_parameters[] = {
 &_GEANT_GEOMETRY_PTMED_NUMB };
static char *_GEANT_GEOMETRY_PTMED_guidance[] = { " CALL GPTMED(numb)",
 "Print tracking media's specifications." };
static KmCommand _GEANT_GEOMETRY_PTMED = { &_GEANT_GEOMETRY_EDITV,
 "/GEANT/GEOMETRY/PTMED", "PTMED", 0, 2, 1, 1,
 _GEANT_GEOMETRY_PTMED_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_PTMED_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_GEOMETRY_STMED_NTMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_NTMED = { "NTMED", 5,
 "Tracking medium number", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_STMED_NTMED_type };
static KmParameter _GEANT_GEOMETRY_STMED_NAME = { "NAME", 4,
 "Tracking medium name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_STMED_NMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_NMAT = { "NMAT", 4,
 "Material number", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_STMED_NMAT_type };
static KmParInt    _GEANT_GEOMETRY_STMED_ISVOL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_ISVOL = { "ISVOL", 5,
 "Sensitive volume flag", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_STMED_ISVOL_type };
static KmParInt    _GEANT_GEOMETRY_STMED_IFIELD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_IFIELD = { "IFIELD", 6,
 "Magnetic field", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GEANT_GEOMETRY_STMED_IFIELD_type };
static KmParReal   _GEANT_GEOMETRY_STMED_FIELDM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_FIELDM = { "FIELDM", 6,
 "Max. field value (Kilogauss)", "0", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_FIELDM_type };
static KmParReal   _GEANT_GEOMETRY_STMED_TMAXFD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_TMAXFD = { "TMAXFD", 6,
 "Max. angle due to field (deg/step)", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_TMAXFD_type };
static KmParReal   _GEANT_GEOMETRY_STMED_STEMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_STEMAX = { "STEMAX", 6,
 "Max. step allowed", "1.E+10", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_STEMAX_type };
static KmParReal   _GEANT_GEOMETRY_STMED_DEEMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_DEEMAX = { "DEEMAX", 6,
 "Max. fraction of energy lost in a step", "0.01", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_DEEMAX_type };
static KmParReal   _GEANT_GEOMETRY_STMED_EPSIL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_EPSIL = { "EPSIL", 5,
 "Tracking precision (cm)", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_STMED_EPSIL_type };
static KmParReal   _GEANT_GEOMETRY_STMED_STMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_STMED_STMIN = { "STMIN", 5,
 "Min. step due to continuos processes (cm)", "0.1", (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_STMED_STMIN_type };
static KmParameter *_GEANT_GEOMETRY_STMED_parameters[] = {
 &_GEANT_GEOMETRY_STMED_NTMED, &_GEANT_GEOMETRY_STMED_NAME,
 &_GEANT_GEOMETRY_STMED_NMAT, &_GEANT_GEOMETRY_STMED_ISVOL,
 &_GEANT_GEOMETRY_STMED_IFIELD, &_GEANT_GEOMETRY_STMED_FIELDM,
 &_GEANT_GEOMETRY_STMED_TMAXFD, &_GEANT_GEOMETRY_STMED_STEMAX,
 &_GEANT_GEOMETRY_STMED_DEEMAX, &_GEANT_GEOMETRY_STMED_EPSIL,
 &_GEANT_GEOMETRY_STMED_STMIN };
static char *_GEANT_GEOMETRY_STMED_guidance[] = {
 "      CALL GSTMED(ntmed,name,nmat,isvol,ifield,fieldm,tmaxfd,",
 "     +            stemax,deemax,epsil,stmin,0,0)",
 "IFIELD = 0 if no magnetic field; IFIELD = -1 if user decision in GUSWIM;",
 "IFIELD = 1 if tracking performed with GRKUTA; IFIELD = 2 if tracking",
 "performed with GHELIX; IFIELD = 3 if tracking performed with GHELX3." };
static KmCommand _GEANT_GEOMETRY_STMED = { &_GEANT_GEOMETRY_PTMED,
 "/GEANT/GEOMETRY/STMED", "STMED", 0, 2, 11, 11,
 _GEANT_GEOMETRY_STMED_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 5, _GEANT_GEOMETRY_STMED_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_GEOMETRY_PROTM_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_PROTM_NUMB = { "NUMB", 4, "Matrix ID",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_PROTM_NUMB_type };
static KmParameter *_GEANT_GEOMETRY_PROTM_parameters[] = {
 &_GEANT_GEOMETRY_PROTM_NUMB };
static char *_GEANT_GEOMETRY_PROTM_guidance[] = { " CALL GPROTM(numb)",
 "Print matrixes' specifications." };
static KmCommand _GEANT_GEOMETRY_PROTM = { &_GEANT_GEOMETRY_STMED,
 "/GEANT/GEOMETRY/PROTM", "PROTM", 0, 2, 1, 1,
 _GEANT_GEOMETRY_PROTM_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_PROTM_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_GEOMETRY_SROTM_IROT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_IROT = { "IROT", 4,
 "Rotation matrix number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SROTM_IROT_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_THETA1_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_THETA1 = { "THETA1", 6,
 "Polar angle for axis I", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_THETA1_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_PHI1_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_PHI1 = { "PHI1", 4,
 "Azimuthal angle for axis I", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_PHI1_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_THETA2_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_THETA2 = { "THETA2", 6,
 "Polar angle for axis II", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_THETA2_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_PHI2_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_PHI2 = { "PHI2", 4,
 "Azimuthal angle for axis II", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_PHI2_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_THETA3_type = { "0.", "180.", "0.",
 "180.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_THETA3 = { "THETA3", 6,
 "Polar angle for axis III", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_THETA3_type };
static KmParReal   _GEANT_GEOMETRY_SROTM_PHI3_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_GEOMETRY_SROTM_PHI3 = { "PHI3", 4,
 "Azimuthal angle for axis III", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_GEOMETRY_SROTM_PHI3_type };
static KmParameter *_GEANT_GEOMETRY_SROTM_parameters[] = {
 &_GEANT_GEOMETRY_SROTM_IROT, &_GEANT_GEOMETRY_SROTM_THETA1,
 &_GEANT_GEOMETRY_SROTM_PHI1, &_GEANT_GEOMETRY_SROTM_THETA2,
 &_GEANT_GEOMETRY_SROTM_PHI2, &_GEANT_GEOMETRY_SROTM_THETA3,
 &_GEANT_GEOMETRY_SROTM_PHI3 };
static char *_GEANT_GEOMETRY_SROTM_guidance[] = {
 " CALL GSROTM(irot,theta1,phi1,theta2,phi2,theta3,phi3)",
 "It defines the rotation matrix number IROT." };
static KmCommand _GEANT_GEOMETRY_SROTM = { &_GEANT_GEOMETRY_PROTM,
 "/GEANT/GEOMETRY/SROTM", "SROTM", 0, 2, 7, 7,
 _GEANT_GEOMETRY_SROTM_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_SROTM_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_GEOMETRY_PVOLU_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_PVOLU_NUMB = { "NUMB", 4, "Volume ID",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_PVOLU_NUMB_type };
static KmParameter *_GEANT_GEOMETRY_PVOLU_parameters[] = {
 &_GEANT_GEOMETRY_PVOLU_NUMB };
static char *_GEANT_GEOMETRY_PVOLU_guidance[] = { " CALL GPVOLU(numb)",
 "Prints volumes' specifications." };
static KmCommand _GEANT_GEOMETRY_PVOLU = { &_GEANT_GEOMETRY_SROTM,
 "/GEANT/GEOMETRY/PVOLU", "PVOLU", 0, 2, 1, 1,
 _GEANT_GEOMETRY_PVOLU_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_GEOMETRY_PVOLU_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _GEANT_GEOMETRY_SDVN_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_SDVN_MOTHER = { "MOTHER", 6,
 "Mother volume name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_SDVN_NDIV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SDVN_NDIV = { "NDIV", 4,
 "Number of divisions", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SDVN_NDIV_type };
static char *_GEANT_GEOMETRY_SDVN_CAXIS_range[] = { "X", "Y", "Z", "1", "2",
 "3" };
static char *_GEANT_GEOMETRY_SDVN_CAXIS_text[] = { (char*)0, (char*)0,
 (char*)0, (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_GEOMETRY_SDVN_CAXIS_type = {
 _GEANT_GEOMETRY_SDVN_CAXIS_text, (int*)0, (int*)0 };
static KmParameter _GEANT_GEOMETRY_SDVN_CAXIS = { "CAXIS", 5, "Axis value",
 (char*)0, (char*)0, 8, 6, _GEANT_GEOMETRY_SDVN_CAXIS_range, 6,
 _GEANT_GEOMETRY_SDVN_CAXIS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_GEOMETRY_SDVN_CAXIS_type };
static KmParameter *_GEANT_GEOMETRY_SDVN_parameters[] = {
 &_GEANT_GEOMETRY_SDVN_NAME, &_GEANT_GEOMETRY_SDVN_MOTHER,
 &_GEANT_GEOMETRY_SDVN_NDIV, &_GEANT_GEOMETRY_SDVN_CAXIS };
static char *_GEANT_GEOMETRY_SDVN_guidance[] = {
 " CALL GSDVN(name,mother,ndiv,iaxis)",
 "X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.",
 "It divides a previously defined volume." };
static KmCommand _GEANT_GEOMETRY_SDVN = { &_GEANT_GEOMETRY_PVOLU,
 "/GEANT/GEOMETRY/SDVN", "SDVN", 0, 2, 4, 4, _GEANT_GEOMETRY_SDVN_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_GEOMETRY_SDVN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GEOMETRY_SPOS_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_SPOS_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_NUMBER = { "NUMBER", 6,
 "Copy number of the volume", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SPOS_NUMBER_type };
static KmParameter _GEANT_GEOMETRY_SPOS_MOTHER = { "MOTHER", 6,
 "Mother volume name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_GEOMETRY_SPOS_X0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_X0 = { "X0", 2,
 "X coord. of the volume in mother ref. sys.", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_SPOS_X0_type };
static KmParReal   _GEANT_GEOMETRY_SPOS_Y0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_Y0 = { "Y0", 2,
 "Y coord. of the volume in mother ref. sys.", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_SPOS_Y0_type };
static KmParReal   _GEANT_GEOMETRY_SPOS_Z0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_Z0 = { "Z0", 2,
 "Z coord. of the volume in mother ref. sys.", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_GEOMETRY_SPOS_Z0_type };
static KmParInt    _GEANT_GEOMETRY_SPOS_IROT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SPOS_IROT = { "IROT", 4,
 "Rotation matrix number w.r.t. mother ref. sys.", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_GEOMETRY_SPOS_IROT_type };
static KmParameter _GEANT_GEOMETRY_SPOS_ONLY = { "ONLY", 4, "ONLY/MANY flag",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_SPOS_parameters[] = {
 &_GEANT_GEOMETRY_SPOS_NAME, &_GEANT_GEOMETRY_SPOS_NUMBER,
 &_GEANT_GEOMETRY_SPOS_MOTHER, &_GEANT_GEOMETRY_SPOS_X0,
 &_GEANT_GEOMETRY_SPOS_Y0, &_GEANT_GEOMETRY_SPOS_Z0,
 &_GEANT_GEOMETRY_SPOS_IROT, &_GEANT_GEOMETRY_SPOS_ONLY };
static char *_GEANT_GEOMETRY_SPOS_guidance[] = {
 " CALL GSPOS(name,number,mother,x0,y0,z0,irot,only)",
 "It positions a previously defined volume in the mother." };
static KmCommand _GEANT_GEOMETRY_SPOS = { &_GEANT_GEOMETRY_SDVN,
 "/GEANT/GEOMETRY/SPOS", "SPOS", 0, 2, 8, 8, _GEANT_GEOMETRY_SPOS_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_GEOMETRY_SPOS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_GEOMETRY_SVOLU_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_GEOMETRY_SVOLU_SHAPE = { "SHAPE", 5, "Volume type",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_GEOMETRY_SVOLU_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SVOLU_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SVOLU_NUMED_type };
static KmParInt    _GEANT_GEOMETRY_SVOLU_NPAR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_SVOLU_NPAR = { "NPAR", 4,
 "Number of shape parameters", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_GEOMETRY_SVOLU_NPAR_type };
static KmParameter _GEANT_GEOMETRY_SVOLU_PAR = { "PAR", 3,
 "Vector containing shape parameters", (char*)0, (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_GEOMETRY_SVOLU_parameters[] = {
 &_GEANT_GEOMETRY_SVOLU_NAME, &_GEANT_GEOMETRY_SVOLU_SHAPE,
 &_GEANT_GEOMETRY_SVOLU_NUMED, &_GEANT_GEOMETRY_SVOLU_NPAR,
 &_GEANT_GEOMETRY_SVOLU_PAR };
static char *_GEANT_GEOMETRY_SVOLU_guidance[] = {
 " CALL GSVOLU(name,shape,numed,par,npar,ivolu)",
 "where par is a KUIP vector.",
 "It creates a new volume in the JVOLUM data structure." };
static KmCommand _GEANT_GEOMETRY_SVOLU = { &_GEANT_GEOMETRY_SPOS,
 "/GEANT/GEOMETRY/SVOLU", "SVOLU", 0, 2, 5, 5,
 _GEANT_GEOMETRY_SVOLU_parameters, 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _GEANT_GEOMETRY_SVOLU_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_GEANT_GEOMETRY_OPTI_IOPTI_range[] = { "-1", "2" };
static KmParInt    _GEANT_GEOMETRY_OPTI_IOPTI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_GEOMETRY_OPTI_IOPTI = { "IOPTI", 5,
 "GSORD optimisation level", "0", (char*)0, 8, 2,
 _GEANT_GEOMETRY_OPTI_IOPTI_range, 2, _GEANT_GEOMETRY_OPTI_IOPTI_range,
 (KmParFlag)2, KmTYPE_INT, &_GEANT_GEOMETRY_OPTI_IOPTI_type };
static KmParameter *_GEANT_GEOMETRY_OPTI_parameters[] = {
 &_GEANT_GEOMETRY_OPTI_IOPTI };
static char *_GEANT_GEOMETRY_OPTI_guidance[] = {
 "This flag controls the tracking optimisation performed via the",
 "GSORD routine:", "    1 no optimisation at all; GSORD calls disabled;",
 "    0 no optimisation; only user calls to GSORD kept;",
 "    1 all non-GSORDered volumes are ordered along the best axis;",
 "    2 all volumes are ordered along the best axis." };
static KmCommand _GEANT_GEOMETRY_OPTI = { &_GEANT_GEOMETRY_SVOLU,
 "/GEANT/GEOMETRY/OPTI", "OPTI", 0, 2, 1, 1, _GEANT_GEOMETRY_OPTI_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_GEOMETRY_OPTI_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SPARA_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SPARA_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SPARA_NUMED_type };
static KmParReal   _GEANT_CREATE_SPARA_HALFX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_HALFX = { "HALFX", 5, "Half X length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SPARA_HALFX_type };
static KmParReal   _GEANT_CREATE_SPARA_HALFY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_HALFY = { "HALFY", 5, "Half Y length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SPARA_HALFY_type };
static KmParReal   _GEANT_CREATE_SPARA_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SPARA_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SPARA_HALFZ_type };
static KmParReal   _GEANT_CREATE_SPARA_AXIS_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SPARA_AXIS = { "AXIS", 4,
 "Angle of Y mid-faces segment to Y axis", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CREATE_SPARA_AXIS_type };
static KmParReal   _GEANT_CREATE_SPARA_PHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SPARA_PHI = { "PHI", 3,
 "PHI angle of Low Z mid-face to High Z mid-face segment", (char*)0, (char*)0,
 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CREATE_SPARA_PHI_type };
static KmParReal   _GEANT_CREATE_SPARA_THETA_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SPARA_THETA = { "THETA", 5,
 "THETA angle of mid-low-Z-face to mid-high-Z-face segment", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CREATE_SPARA_THETA_type };
static char *_GEANT_CREATE_SPARA_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SPARA_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SPARA_YESNO_type = {
 _GEANT_CREATE_SPARA_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SPARA_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SPARA_YESNO_range, 2,
 _GEANT_CREATE_SPARA_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SPARA_YESNO_type };
static KmParameter *_GEANT_CREATE_SPARA_parameters[] = {
 &_GEANT_CREATE_SPARA_NAME, &_GEANT_CREATE_SPARA_NUMED,
 &_GEANT_CREATE_SPARA_HALFX, &_GEANT_CREATE_SPARA_HALFY,
 &_GEANT_CREATE_SPARA_HALFZ, &_GEANT_CREATE_SPARA_AXIS,
 &_GEANT_CREATE_SPARA_PHI, &_GEANT_CREATE_SPARA_THETA,
 &_GEANT_CREATE_SPARA_YESNO };
static KmCommand _GEANT_CREATE_SPARA = {  (KmCommand*)0,
 "/GEANT/CREATE/SPARA", "SPARA", 0, 2, 9, 8, _GEANT_CREATE_SPARA_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SSPHE_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SSPHE_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SSPHE_NUMED_type };
static KmParReal   _GEANT_CREATE_SSPHE_INRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_INRAD = { "INRAD", 5, "Inside Radius",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SSPHE_INRAD_type };
static KmParReal   _GEANT_CREATE_SSPHE_OUTRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_OUTRAD = { "OUTRAD", 6,
 "Outside Radius", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_OUTRAD_type };
static KmParReal   _GEANT_CREATE_SSPHE_SPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SSPHE_SPHI = { "SPHI", 4,
 "Start of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_SPHI_type };
static KmParReal   _GEANT_CREATE_SSPHE_EPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SSPHE_EPHI = { "EPHI", 4,
 "End of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_EPHI_type };
static KmParReal   _GEANT_CREATE_SSPHE_STHETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_STHETA = { "STHETA", 6,
 "Start of section THETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_STHETA_type };
static KmParReal   _GEANT_CREATE_SSPHE_ETHETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SSPHE_ETHETA = { "ETHETA", 6,
 "End of section THETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SSPHE_ETHETA_type };
static char *_GEANT_CREATE_SSPHE_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SSPHE_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SSPHE_YESNO_type = {
 _GEANT_CREATE_SSPHE_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SSPHE_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SSPHE_YESNO_range, 2,
 _GEANT_CREATE_SSPHE_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SSPHE_YESNO_type };
static KmParameter *_GEANT_CREATE_SSPHE_parameters[] = {
 &_GEANT_CREATE_SSPHE_NAME, &_GEANT_CREATE_SSPHE_NUMED,
 &_GEANT_CREATE_SSPHE_INRAD, &_GEANT_CREATE_SSPHE_OUTRAD,
 &_GEANT_CREATE_SSPHE_SPHI, &_GEANT_CREATE_SSPHE_EPHI,
 &_GEANT_CREATE_SSPHE_STHETA, &_GEANT_CREATE_SSPHE_ETHETA,
 &_GEANT_CREATE_SSPHE_YESNO };
static KmCommand _GEANT_CREATE_SSPHE = { &_GEANT_CREATE_SPARA,
 "/GEANT/CREATE/SSPHE", "SSPHE", 0, 2, 9, 8, _GEANT_CREATE_SSPHE_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SCONS_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SCONS_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SCONS_NUMED_type };
static KmParReal   _GEANT_CREATE_SCONS_INRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_INRDW = { "INRDW", 5,
 "Inside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_INRDW_type };
static KmParReal   _GEANT_CREATE_SCONS_OUTRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_OUTRDW = { "OUTRDW", 6,
 "Outside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_OUTRDW_type };
static KmParReal   _GEANT_CREATE_SCONS_INRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_INRUP = { "INRUP", 5,
 "Inside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_INRUP_type };
static KmParReal   _GEANT_CREATE_SCONS_OUTRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_OUTRUP = { "OUTRUP", 6,
 "Outside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_OUTRUP_type };
static KmParReal   _GEANT_CREATE_SCONS_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONS_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SCONS_HALFZ_type };
static KmParReal   _GEANT_CREATE_SCONS_SPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SCONS_SPHI = { "SPHI", 4,
 "Start of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_SPHI_type };
static KmParReal   _GEANT_CREATE_SCONS_EPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_SCONS_EPHI = { "EPHI", 4,
 "End of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONS_EPHI_type };
static char *_GEANT_CREATE_SCONS_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SCONS_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SCONS_YESNO_type = {
 _GEANT_CREATE_SCONS_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SCONS_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SCONS_YESNO_range, 2,
 _GEANT_CREATE_SCONS_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SCONS_YESNO_type };
static KmParameter *_GEANT_CREATE_SCONS_parameters[] = {
 &_GEANT_CREATE_SCONS_NAME, &_GEANT_CREATE_SCONS_NUMED,
 &_GEANT_CREATE_SCONS_INRDW, &_GEANT_CREATE_SCONS_OUTRDW,
 &_GEANT_CREATE_SCONS_INRUP, &_GEANT_CREATE_SCONS_OUTRUP,
 &_GEANT_CREATE_SCONS_HALFZ, &_GEANT_CREATE_SCONS_SPHI,
 &_GEANT_CREATE_SCONS_EPHI, &_GEANT_CREATE_SCONS_YESNO };
static KmCommand _GEANT_CREATE_SCONS = { &_GEANT_CREATE_SSPHE,
 "/GEANT/CREATE/SCONS", "SCONS", 0, 2, 10, 9, _GEANT_CREATE_SCONS_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SCONE_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SCONE_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SCONE_NUMED_type };
static KmParReal   _GEANT_CREATE_SCONE_INRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_INRDW = { "INRDW", 5,
 "Inside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_INRDW_type };
static KmParReal   _GEANT_CREATE_SCONE_OUTRDW_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_OUTRDW = { "OUTRDW", 6,
 "Outside Radius in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_OUTRDW_type };
static KmParReal   _GEANT_CREATE_SCONE_INRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_INRUP = { "INRUP", 5,
 "Inside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_INRUP_type };
static KmParReal   _GEANT_CREATE_SCONE_OUTRUP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_OUTRUP = { "OUTRUP", 6,
 "Outside Radius in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_SCONE_OUTRUP_type };
static KmParReal   _GEANT_CREATE_SCONE_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SCONE_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SCONE_HALFZ_type };
static char *_GEANT_CREATE_SCONE_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SCONE_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SCONE_YESNO_type = {
 _GEANT_CREATE_SCONE_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SCONE_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SCONE_YESNO_range, 2,
 _GEANT_CREATE_SCONE_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SCONE_YESNO_type };
static KmParameter *_GEANT_CREATE_SCONE_parameters[] = {
 &_GEANT_CREATE_SCONE_NAME, &_GEANT_CREATE_SCONE_NUMED,
 &_GEANT_CREATE_SCONE_INRDW, &_GEANT_CREATE_SCONE_OUTRDW,
 &_GEANT_CREATE_SCONE_INRUP, &_GEANT_CREATE_SCONE_OUTRUP,
 &_GEANT_CREATE_SCONE_HALFZ, &_GEANT_CREATE_SCONE_YESNO };
static KmCommand _GEANT_CREATE_SCONE = { &_GEANT_CREATE_SCONS,
 "/GEANT/CREATE/SCONE", "SCONE", 0, 2, 8, 7, _GEANT_CREATE_SCONE_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STUBS_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STUBS_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STUBS_NUMED_type };
static KmParReal   _GEANT_CREATE_STUBS_INRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_INRAD = { "INRAD", 5, "Inside Radius",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBS_INRAD_type };
static KmParReal   _GEANT_CREATE_STUBS_OUTRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_OUTRAD = { "OUTRAD", 6,
 "Outside Radius", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBS_OUTRAD_type };
static KmParReal   _GEANT_CREATE_STUBS_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBS_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBS_HALFZ_type };
static KmParReal   _GEANT_CREATE_STUBS_SPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_STUBS_SPHI = { "SPHI", 4,
 "Start of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBS_SPHI_type };
static KmParReal   _GEANT_CREATE_STUBS_EPHI_type = { "0.", "360.", "0.",
 "360.", 0 };
static KmParameter _GEANT_CREATE_STUBS_EPHI = { "EPHI", 4,
 "End of section PHI", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBS_EPHI_type };
static char *_GEANT_CREATE_STUBS_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STUBS_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STUBS_YESNO_type = {
 _GEANT_CREATE_STUBS_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STUBS_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STUBS_YESNO_range, 2,
 _GEANT_CREATE_STUBS_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STUBS_YESNO_type };
static KmParameter *_GEANT_CREATE_STUBS_parameters[] = {
 &_GEANT_CREATE_STUBS_NAME, &_GEANT_CREATE_STUBS_NUMED,
 &_GEANT_CREATE_STUBS_INRAD, &_GEANT_CREATE_STUBS_OUTRAD,
 &_GEANT_CREATE_STUBS_HALFZ, &_GEANT_CREATE_STUBS_SPHI,
 &_GEANT_CREATE_STUBS_EPHI, &_GEANT_CREATE_STUBS_YESNO };
static KmCommand _GEANT_CREATE_STUBS = { &_GEANT_CREATE_SCONE,
 "/GEANT/CREATE/STUBS", "STUBS", 0, 2, 8, 7, _GEANT_CREATE_STUBS_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STUBE_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STUBE_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STUBE_NUMED_type };
static KmParReal   _GEANT_CREATE_STUBE_INRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_INRAD = { "INRAD", 5, "Inside Radius",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBE_INRAD_type };
static KmParReal   _GEANT_CREATE_STUBE_OUTRAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_OUTRAD = { "OUTRAD", 6,
 "Outside Radius", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STUBE_OUTRAD_type };
static KmParReal   _GEANT_CREATE_STUBE_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STUBE_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STUBE_HALFZ_type };
static char *_GEANT_CREATE_STUBE_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STUBE_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STUBE_YESNO_type = {
 _GEANT_CREATE_STUBE_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STUBE_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STUBE_YESNO_range, 2,
 _GEANT_CREATE_STUBE_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STUBE_YESNO_type };
static KmParameter *_GEANT_CREATE_STUBE_parameters[] = {
 &_GEANT_CREATE_STUBE_NAME, &_GEANT_CREATE_STUBE_NUMED,
 &_GEANT_CREATE_STUBE_INRAD, &_GEANT_CREATE_STUBE_OUTRAD,
 &_GEANT_CREATE_STUBE_HALFZ, &_GEANT_CREATE_STUBE_YESNO };
static KmCommand _GEANT_CREATE_STUBE = { &_GEANT_CREATE_STUBS,
 "/GEANT/CREATE/STUBE", "STUBE", 0, 2, 6, 5, _GEANT_CREATE_STUBE_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STRD2_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STRD2_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STRD2_NUMED_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFDWX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFDWX = { "HLFDWX", 6,
 "Half X length in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFDWX_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFUPX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFUPX = { "HLFUPX", 6,
 "Half X length in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFUPX_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFDWY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFDWY = { "HLFDWY", 6,
 "Half Y length in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFDWY_type };
static KmParReal   _GEANT_CREATE_STRD2_HLFUPY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HLFUPY = { "HLFUPY", 6,
 "Half Y length in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD2_HLFUPY_type };
static KmParReal   _GEANT_CREATE_STRD2_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD2_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STRD2_HALFZ_type };
static char *_GEANT_CREATE_STRD2_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STRD2_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STRD2_YESNO_type = {
 _GEANT_CREATE_STRD2_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STRD2_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STRD2_YESNO_range, 2,
 _GEANT_CREATE_STRD2_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STRD2_YESNO_type };
static KmParameter *_GEANT_CREATE_STRD2_parameters[] = {
 &_GEANT_CREATE_STRD2_NAME, &_GEANT_CREATE_STRD2_NUMED,
 &_GEANT_CREATE_STRD2_HLFDWX, &_GEANT_CREATE_STRD2_HLFUPX,
 &_GEANT_CREATE_STRD2_HLFDWY, &_GEANT_CREATE_STRD2_HLFUPY,
 &_GEANT_CREATE_STRD2_HALFZ, &_GEANT_CREATE_STRD2_YESNO };
static KmCommand _GEANT_CREATE_STRD2 = { &_GEANT_CREATE_STUBE,
 "/GEANT/CREATE/STRD2", "STRD2", 0, 2, 8, 7, _GEANT_CREATE_STRD2_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_STRD1_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_STRD1_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_STRD1_NUMED_type };
static KmParReal   _GEANT_CREATE_STRD1_HLFDWX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HLFDWX = { "HLFDWX", 6,
 "Half X length in Lower Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD1_HLFDWX_type };
static KmParReal   _GEANT_CREATE_STRD1_HLFUPX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HLFUPX = { "HLFUPX", 6,
 "Half X length in Upper Z Surface", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CREATE_STRD1_HLFUPX_type };
static KmParReal   _GEANT_CREATE_STRD1_HALFY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HALFY = { "HALFY", 5, "Half Y length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STRD1_HALFY_type };
static KmParReal   _GEANT_CREATE_STRD1_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_STRD1_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_STRD1_HALFZ_type };
static char *_GEANT_CREATE_STRD1_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_STRD1_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_STRD1_YESNO_type = {
 _GEANT_CREATE_STRD1_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_STRD1_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_STRD1_YESNO_range, 2,
 _GEANT_CREATE_STRD1_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_STRD1_YESNO_type };
static KmParameter *_GEANT_CREATE_STRD1_parameters[] = {
 &_GEANT_CREATE_STRD1_NAME, &_GEANT_CREATE_STRD1_NUMED,
 &_GEANT_CREATE_STRD1_HLFDWX, &_GEANT_CREATE_STRD1_HLFUPX,
 &_GEANT_CREATE_STRD1_HALFY, &_GEANT_CREATE_STRD1_HALFZ,
 &_GEANT_CREATE_STRD1_YESNO };
static KmCommand _GEANT_CREATE_STRD1 = { &_GEANT_CREATE_STRD2,
 "/GEANT/CREATE/STRD1", "STRD1", 0, 2, 7, 6, _GEANT_CREATE_STRD1_parameters,
 0, 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CREATE_SBOX_NAME = { "NAME", 4, "Volume name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CREATE_SBOX_NUMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_NUMED = { "NUMED", 5,
 "Tracking medium number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CREATE_SBOX_NUMED_type };
static KmParReal   _GEANT_CREATE_SBOX_HALFX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_HALFX = { "HALFX", 5, "Half X length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SBOX_HALFX_type };
static KmParReal   _GEANT_CREATE_SBOX_HALFY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_HALFY = { "HALFY", 5, "Half Y length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SBOX_HALFY_type };
static KmParReal   _GEANT_CREATE_SBOX_HALFZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CREATE_SBOX_HALFZ = { "HALFZ", 5, "Half Z length",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CREATE_SBOX_HALFZ_type };
static char *_GEANT_CREATE_SBOX_YESNO_range[] = { "YES", "NO" };
static char *_GEANT_CREATE_SBOX_YESNO_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CREATE_SBOX_YESNO_type = {
 _GEANT_CREATE_SBOX_YESNO_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CREATE_SBOX_YESNO = { "YESNO", 5, "GSPOSP option",
 "NO", (char*)0, 8, 2, _GEANT_CREATE_SBOX_YESNO_range, 2,
 _GEANT_CREATE_SBOX_YESNO_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CREATE_SBOX_YESNO_type };
static KmParameter *_GEANT_CREATE_SBOX_parameters[] = {
 &_GEANT_CREATE_SBOX_NAME, &_GEANT_CREATE_SBOX_NUMED,
 &_GEANT_CREATE_SBOX_HALFX, &_GEANT_CREATE_SBOX_HALFY,
 &_GEANT_CREATE_SBOX_HALFZ, &_GEANT_CREATE_SBOX_YESNO };
static KmCommand _GEANT_CREATE_SBOX = { &_GEANT_CREATE_STRD1,
 "/GEANT/CREATE/SBOX", "SBOX", 0, 2, 6, 5, _GEANT_CREATE_SBOX_parameters, 0,
 0, gxgeom_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_GEANT_CREATE_guidance[] = {
 "It creates volumes of the given shape interactively.",
 "CALL GSVOLU(name,shape,numed,par,npar,ivolu)", "where par is a KUIP vector"
 };
static KmMenu _GEANT_CREATE = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/CREATE",
 "CREATE", 2, &_GEANT_CREATE_SBOX, 3, _GEANT_CREATE_guidance };

static char *_GEANT_GEOMETRY_guidance[] = { "Geometry commands." };
static KmMenu _GEANT_GEOMETRY = { &_GEANT_CREATE,  (KmMenu*)0,
 "/GEANT/GEOMETRY", "GEOMETRY", 2, &_GEANT_GEOMETRY_OPTI, 1,
 _GEANT_GEOMETRY_guidance };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_GEOMETRY, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkcont_ gkcont
#  define gxcont_ gxcont
#endif

#ifdef F77_UCASE
#  define gkcont_ GKCONT
#  define gxcont_ GXCONT
#endif

#ifdef IBM370
#  pragma linkage(GKCONT,FORTRAN)
#  pragma linkage(GXCONT,FORTRAN)
#endif

extern void gkcont_();
extern void gxcont_();

void gkcont_()
{

static char *_GEANT_CONTROL_DEBUG_IDEB_range[] = { "ON", "OFF" };
static char *_GEANT_CONTROL_DEBUG_IDEB_text[] = { (char*)0, (char*)0 };
static KmParOption _GEANT_CONTROL_DEBUG_IDEB_type = {
 _GEANT_CONTROL_DEBUG_IDEB_text, (int*)0, (int*)0 };
static KmParameter _GEANT_CONTROL_DEBUG_IDEB = { "IDEB", 4, "Debug option",
 "ON", (char*)0, 8, 2, _GEANT_CONTROL_DEBUG_IDEB_range, 2,
 _GEANT_CONTROL_DEBUG_IDEB_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_CONTROL_DEBUG_IDEB_type };
static KmParameter *_GEANT_CONTROL_DEBUG_parameters[] = {
 &_GEANT_CONTROL_DEBUG_IDEB };
static char *_GEANT_CONTROL_DEBUG_guidance[] = { "If ideb='ON  ' then :",
 " idebug=1, idemin=1, idemax=1000000, itime=1", "else :",
 " idebug=0, idemin=0, idemax=0" };
static KmCommand _GEANT_CONTROL_DEBUG = {  (KmCommand*)0,
 "/GEANT/CONTROL/DEBUG", "DEBUG", 0, 2, 1, 0, _GEANT_CONTROL_DEBUG_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_CONTROL_DEBUG_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PRKINE_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRKINE_NUMB = { "NUMB", 4, "Track number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PRKINE_NUMB_type };
static KmParameter *_GEANT_CONTROL_PRKINE_parameters[] = {
 &_GEANT_CONTROL_PRKINE_NUMB };
static char *_GEANT_CONTROL_PRKINE_guidance[] = { "CALL GPKINE(numb)" };
static KmCommand _GEANT_CONTROL_PRKINE = { &_GEANT_CONTROL_DEBUG,
 "/GEANT/CONTROL/PRKINE", "PRKINE", 0, 2, 1, 1,
 _GEANT_CONTROL_PRKINE_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_CONTROL_PRKINE_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_CONTROL_PPART_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PPART_NUMB = { "NUMB", 4, "Particle number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PPART_NUMB_type };
static KmParameter *_GEANT_CONTROL_PPART_parameters[] = {
 &_GEANT_CONTROL_PPART_NUMB };
static char *_GEANT_CONTROL_PPART_guidance[] = { "CALL GPPART(numb)" };
static KmCommand _GEANT_CONTROL_PPART = { &_GEANT_CONTROL_PRKINE,
 "/GEANT/CONTROL/PPART", "PPART", 0, 2, 1, 1, _GEANT_CONTROL_PPART_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PPART_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_SPART_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_SPART_IPART_type };
static KmParameter _GEANT_CONTROL_SPART_NAPART = { "NAPART", 6,
 "Particle name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CONTROL_SPART_ITRTYP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_ITRTYP = { "ITRTYP", 6, " ", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SPART_ITRTYP_type };
static KmParReal   _GEANT_CONTROL_SPART_AMASS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_AMASS = { "AMASS", 5, "Mass",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SPART_AMASS_type };
static KmParReal   _GEANT_CONTROL_SPART_CHARGE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_CHARGE = { "CHARGE", 6, "Charge",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SPART_CHARGE_type };
static KmParReal   _GEANT_CONTROL_SPART_TLIFE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_TLIFE = { "TLIFE", 5, "Lifetime",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SPART_TLIFE_type };
static KmParReal   _GEANT_CONTROL_SPART_UBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_UBUF = { "UBUF", 4, " ", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_SPART_UBUF_type };
static KmParInt    _GEANT_CONTROL_SPART_NWBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_NWBUF = { "NWBUF", 5, " ", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SPART_NWBUF_type };
static KmParReal   _GEANT_CONTROL_SPART_BRATIO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_BRATIO = { "BRATIO", 6,
 "Branching ratios", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_SPART_BRATIO_type };
static KmParInt    _GEANT_CONTROL_SPART_MODE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SPART_MODE = { "MODE", 4, "Decay mode",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SPART_MODE_type };
static KmParameter *_GEANT_CONTROL_SPART_parameters[] = {
 &_GEANT_CONTROL_SPART_IPART, &_GEANT_CONTROL_SPART_NAPART,
 &_GEANT_CONTROL_SPART_ITRTYP, &_GEANT_CONTROL_SPART_AMASS,
 &_GEANT_CONTROL_SPART_CHARGE, &_GEANT_CONTROL_SPART_TLIFE,
 &_GEANT_CONTROL_SPART_UBUF, &_GEANT_CONTROL_SPART_NWBUF,
 &_GEANT_CONTROL_SPART_BRATIO, &_GEANT_CONTROL_SPART_MODE };
static char *_GEANT_CONTROL_SPART_guidance[] = {
 "CALL GSPART(ipart,napart,itrtyp,amass,charge,tlife,ubuf,nwbuf);",
 "CALL GSDK(ipart,bratio,mode)" };
static KmCommand _GEANT_CONTROL_SPART = { &_GEANT_CONTROL_PPART,
 "/GEANT/CONTROL/SPART", "SPART", 0, 2, 10, 10,
 _GEANT_CONTROL_SPART_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _GEANT_CONTROL_SPART_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_CONTROL_STPAR_ITMED_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_STPAR_ITMED = { "ITMED", 5, "Medium number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_STPAR_ITMED_type };
static KmParameter _GEANT_CONTROL_STPAR_CHPAR = { "CHPAR", 5,
 "Cut or mechanism", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CONTROL_STPAR_PARVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_STPAR_PARVAL = { "PARVAL", 6, "Value",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_STPAR_PARVAL_type };
static KmParameter *_GEANT_CONTROL_STPAR_parameters[] = {
 &_GEANT_CONTROL_STPAR_ITMED, &_GEANT_CONTROL_STPAR_CHPAR,
 &_GEANT_CONTROL_STPAR_PARVAL };
static char *_GEANT_CONTROL_STPAR_guidance[] = {
 "CALL GSTPAR(itmed,chpar,parval)" };
static KmCommand _GEANT_CONTROL_STPAR = { &_GEANT_CONTROL_SPART,
 "/GEANT/CONTROL/STPAR", "STPAR", 0, 2, 3, 3, _GEANT_CONTROL_STPAR_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_STPAR_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_DRMAT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_DRMAT_IMATE = { "IMATE", 5,
 "Material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_DRMAT_IMATE_type };
static KmParInt    _GEANT_CONTROL_DRMAT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_DRMAT_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_DRMAT_IPART_type };
static KmParameter _GEANT_CONTROL_DRMAT_MECAN = { "MECAN", 5,
 "List of mechanism", "ALL", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_CONTROL_DRMAT_parameters[] = {
 &_GEANT_CONTROL_DRMAT_IMATE, &_GEANT_CONTROL_DRMAT_IPART,
 &_GEANT_CONTROL_DRMAT_MECAN };
static char *_GEANT_CONTROL_DRMAT_guidance[] = {
 "CALL GDRMAT(imate,ipart,mecan,nmec)",
 "If MECAN = 'ALL' all the mechanisms are plotted. If the material number",
 "is negative, the cross sections relative to material ABS(IMATE) will",
 "be plotted in barns rather than in 1/cm.",
 "Note that it is not possible to plot anything if GSTMED has not been\
 called", "for the material number IMATE." };
static KmCommand _GEANT_CONTROL_DRMAT = { &_GEANT_CONTROL_STPAR,
 "/GEANT/CONTROL/DRMAT", "DRMAT", 0, 2, 3, 2, _GEANT_CONTROL_DRMAT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_CONTROL_DRMAT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PLMAT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PLMAT_IMATE = { "IMATE", 5,
 "Material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PLMAT_IMATE_type };
static KmParInt    _GEANT_CONTROL_PLMAT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PLMAT_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PLMAT_IPART_type };
static KmParameter _GEANT_CONTROL_PLMAT_MECAN = { "MECAN", 5, "Mechanism",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CONTROL_PLMAT_IDM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PLMAT_IDM = { "IDM", 3, "ID mode option",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PLMAT_IDM_type };
static KmParameter *_GEANT_CONTROL_PLMAT_parameters[] = {
 &_GEANT_CONTROL_PLMAT_IMATE, &_GEANT_CONTROL_PLMAT_IPART,
 &_GEANT_CONTROL_PLMAT_MECAN, &_GEANT_CONTROL_PLMAT_IDM };
static char *_GEANT_CONTROL_PLMAT_guidance[] = {
 "CALL GPLMAT(imate,ipart,mecan,nekbin,elow,idm)",
 " IDM convention for histogramming mode :",
 " IDM.gt.0  fill, print,   keep   histogram(s)",
 " IDM.eq.0  fill, print,   delete histogram(s)",
 " IDM.lt.0  fill, noprint, keep   histogram(s)",
 "If MECAN = 'ALL' all the mechanisms are histogrammed. If the material\
 number",
 "is negative, the cross sections relative to material ABS(IMATE) will",
 "be histogrammed in barns rather than in 1/cm." };
static KmCommand _GEANT_CONTROL_PLMAT = { &_GEANT_CONTROL_DRMAT,
 "/GEANT/CONTROL/PLMAT", "PLMAT", 0, 2, 4, 3, _GEANT_CONTROL_PLMAT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_CONTROL_PLMAT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PRMAT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRMAT_IMATE = { "IMATE", 5,
 "Material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PRMAT_IMATE_type };
static KmParInt    _GEANT_CONTROL_PRMAT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRMAT_IPART = { "IPART", 5,
 "Particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_PRMAT_IPART_type };
static KmParameter _GEANT_CONTROL_PRMAT_MECAN = { "MECAN", 5, "Mechanism",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_CONTROL_PRMAT_parameters[] = {
 &_GEANT_CONTROL_PRMAT_IMATE, &_GEANT_CONTROL_PRMAT_IPART,
 &_GEANT_CONTROL_PRMAT_MECAN };
static char *_GEANT_CONTROL_PRMAT_guidance[] = {
 " CALL GPRMAT(imate,ipart,mecan,nekbin,elow)" };
static KmCommand _GEANT_CONTROL_PRMAT = { &_GEANT_CONTROL_PLMAT,
 "/GEANT/CONTROL/PRMAT", "PRMAT", 0, 2, 3, 3, _GEANT_CONTROL_PRMAT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PRMAT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_PMATE_NUMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PMATE_NUMB = { "NUMB", 4, "Material number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PMATE_NUMB_type };
static KmParameter *_GEANT_CONTROL_PMATE_parameters[] = {
 &_GEANT_CONTROL_PMATE_NUMB };
static char *_GEANT_CONTROL_PMATE_guidance[] = { " CALL GPMATE(numb)" };
static KmCommand _GEANT_CONTROL_PMATE = { &_GEANT_CONTROL_PRMAT,
 "/GEANT/CONTROL/PMATE", "PMATE", 0, 2, 1, 1, _GEANT_CONTROL_PMATE_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PMATE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_SMIXT_IMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_IMAT = { "IMAT", 4, "Material number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMIXT_IMAT_type };
static KmParameter _GEANT_CONTROL_SMIXT_NAMATE = { "NAMATE", 6,
 "Material name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CONTROL_SMIXT_A_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_A = { "A", 1, "Atomic weight",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMIXT_A_type };
static KmParReal   _GEANT_CONTROL_SMIXT_Z_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_Z = { "Z", 1, "Atomic number",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMIXT_Z_type };
static KmParReal   _GEANT_CONTROL_SMIXT_DENS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_DENS = { "DENS", 4, "Density",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMIXT_DENS_type };
static KmParInt    _GEANT_CONTROL_SMIXT_NLMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_NLMAT = { "NLMAT", 5, "Flag for WMAT",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMIXT_NLMAT_type };
static KmParReal   _GEANT_CONTROL_SMIXT_WMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMIXT_WMAT = { "WMAT", 4,
 "Relative weights or n. of atoms in molecule", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_SMIXT_WMAT_type };
static KmParameter *_GEANT_CONTROL_SMIXT_parameters[] = {
 &_GEANT_CONTROL_SMIXT_IMAT, &_GEANT_CONTROL_SMIXT_NAMATE,
 &_GEANT_CONTROL_SMIXT_A, &_GEANT_CONTROL_SMIXT_Z, &_GEANT_CONTROL_SMIXT_DENS,
 &_GEANT_CONTROL_SMIXT_NLMAT, &_GEANT_CONTROL_SMIXT_WMAT };
static char *_GEANT_CONTROL_SMIXT_guidance[] = {
 " CALL GSMIXT(imat,namate,a,z,dens,nlmat,wmat)" };
static KmCommand _GEANT_CONTROL_SMIXT = { &_GEANT_CONTROL_PMATE,
 "/GEANT/CONTROL/SMIXT", "SMIXT", 0, 2, 7, 7, _GEANT_CONTROL_SMIXT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_SMIXT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_SMATE_IMAT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_IMAT = { "IMAT", 4, "Material number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMATE_IMAT_type };
static KmParameter _GEANT_CONTROL_SMATE_NAMATE = { "NAMATE", 6,
 "Material name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GEANT_CONTROL_SMATE_A_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_A = { "A", 1, "Atomic weight",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMATE_A_type };
static KmParReal   _GEANT_CONTROL_SMATE_Z_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_Z = { "Z", 1, "Atomic number",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMATE_Z_type };
static KmParReal   _GEANT_CONTROL_SMATE_DENS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_DENS = { "DENS", 4, "Density",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_SMATE_DENS_type };
static KmParReal   _GEANT_CONTROL_SMATE_RADL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_RADL = { "RADL", 4,
 "Radiation lenght", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_SMATE_RADL_type };
static KmParReal   _GEANT_CONTROL_SMATE_ABSL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_ABSL = { "ABSL", 4,
 "Absorption lenght", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_SMATE_ABSL_type };
static KmParReal   _GEANT_CONTROL_SMATE_UBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_UBUF = { "UBUF", 4, " ", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_SMATE_UBUF_type };
static KmParInt    _GEANT_CONTROL_SMATE_NWBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SMATE_NWBUF = { "NWBUF", 5, " ", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SMATE_NWBUF_type };
static KmParameter *_GEANT_CONTROL_SMATE_parameters[] = {
 &_GEANT_CONTROL_SMATE_IMAT, &_GEANT_CONTROL_SMATE_NAMATE,
 &_GEANT_CONTROL_SMATE_A, &_GEANT_CONTROL_SMATE_Z, &_GEANT_CONTROL_SMATE_DENS,
 &_GEANT_CONTROL_SMATE_RADL, &_GEANT_CONTROL_SMATE_ABSL,
 &_GEANT_CONTROL_SMATE_UBUF, &_GEANT_CONTROL_SMATE_NWBUF };
static char *_GEANT_CONTROL_SMATE_guidance[] = {
 " CALL GSMATE(imat,namate,a,z,dens,radl,absl,ubuf,nwbuf)" };
static KmCommand _GEANT_CONTROL_SMATE = { &_GEANT_CONTROL_SMIXT,
 "/GEANT/CONTROL/SMATE", "SMATE", 0, 2, 9, 9, _GEANT_CONTROL_SMATE_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_SMATE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CONTROL_PDIGI_CHUSET = { "CHUSET", 6, "User set",
 "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GEANT_CONTROL_PDIGI_CHUDET = { "CHUDET", 6,
 "User detector", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_CONTROL_PDIGI_parameters[] = {
 &_GEANT_CONTROL_PDIGI_CHUSET, &_GEANT_CONTROL_PDIGI_CHUDET };
static char *_GEANT_CONTROL_PDIGI_guidance[] = { " CALL GPDIGI(chuset,chudet)"
 };
static KmCommand _GEANT_CONTROL_PDIGI = { &_GEANT_CONTROL_SMATE,
 "/GEANT/CONTROL/PDIGI", "PDIGI", 0, 2, 2, 0, _GEANT_CONTROL_PDIGI_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PDIGI_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CONTROL_PHITS_CHUSET = { "CHUSET", 6, "User set",
 "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GEANT_CONTROL_PHITS_CHUDET = { "CHUDET", 6,
 "User detector", "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_CONTROL_PHITS_NUMHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PHITS_NUMHI = { "NUMHI", 5, "Hit number",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PHITS_NUMHI_type };
static KmParameter *_GEANT_CONTROL_PHITS_parameters[] = {
 &_GEANT_CONTROL_PHITS_CHUSET, &_GEANT_CONTROL_PHITS_CHUDET,
 &_GEANT_CONTROL_PHITS_NUMHI };
static char *_GEANT_CONTROL_PHITS_guidance[] = { " CALL GPHITS(chuset,chudet)"
 };
static KmCommand _GEANT_CONTROL_PHITS = { &_GEANT_CONTROL_PDIGI,
 "/GEANT/CONTROL/PHITS", "PHITS", 0, 2, 3, 0, _GEANT_CONTROL_PHITS_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PHITS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_OUTPUT_LP_LOUT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_OUTPUT_LP_LOUT = { "LOUT", 4,
 "New output unit", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_OUTPUT_LP_LOUT_type };
static KmParameter *_GEANT_CONTROL_OUTPUT_LP_parameters[] = {
 &_GEANT_CONTROL_OUTPUT_LP_LOUT };
static char *_GEANT_CONTROL_OUTPUT_LP_guidance[] = {
 "To change lout in /GCUNIT/",
 "Note: unit numbers 5,11,12,13,14,15 are reserved and cannot be used." };
static KmCommand _GEANT_CONTROL_OUTPUT_LP = { &_GEANT_CONTROL_PHITS,
 "/GEANT/CONTROL/OUTPUT_LP", "OUTPUT_LP", 0, 2, 1, 1,
 _GEANT_CONTROL_OUTPUT_LP_parameters, 0, 0, gxcont_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_CONTROL_OUTPUT_LP_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_CONTROL_PRINT_NAME = { "NAME", 4, "Name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_CONTROL_PRINT_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_PRINT_NUMBER = { "NUMBER", 6, "Number", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_PRINT_NUMBER_type };
static KmParameter *_GEANT_CONTROL_PRINT_parameters[] = {
 &_GEANT_CONTROL_PRINT_NAME, &_GEANT_CONTROL_PRINT_NUMBER };
static char *_GEANT_CONTROL_PRINT_guidance[] = { " CALL GPRINT(name,number)" };
static KmCommand _GEANT_CONTROL_PRINT = { &_GEANT_CONTROL_OUTPUT_LP,
 "/GEANT/CONTROL/PRINT", "PRINT", 0, 2, 2, 2, _GEANT_CONTROL_PRINT_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_PRINT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_MZLOGL_LEVEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_MZLOGL_LEVEL = { "LEVEL", 5, "MZ log level",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_MZLOGL_LEVEL_type };
static KmParameter *_GEANT_CONTROL_MZLOGL_parameters[] = {
 &_GEANT_CONTROL_MZLOGL_LEVEL };
static char *_GEANT_CONTROL_MZLOGL_guidance[] = {
 "Set the log level for the MZ package of ZEBRA: CALL MZLOGL(0,level)",
 " LEVEL = -3   no messages at all", "         -2   error messages only",
 "         -1   terse logging", "          0   normal",
 "         +1   log rare events", "         +2   log calls to MZ routines" };
static KmCommand _GEANT_CONTROL_MZLOGL = { &_GEANT_CONTROL_PRINT,
 "/GEANT/CONTROL/MZLOGL", "MZLOGL", 0, 2, 1, 1,
 _GEANT_CONTROL_MZLOGL_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 7, _GEANT_CONTROL_MZLOGL_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_CONTROL_SWITCH_ISWI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SWITCH_ISWI = { "ISWI", 4, "Switch number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_SWITCH_ISWI_type };
static KmParInt    _GEANT_CONTROL_SWITCH_IVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SWITCH_IVAL = { "IVAL", 4,
 "New switch value", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_SWITCH_IVAL_type };
static KmParameter *_GEANT_CONTROL_SWITCH_parameters[] = {
 &_GEANT_CONTROL_SWITCH_ISWI, &_GEANT_CONTROL_SWITCH_IVAL };
static char *_GEANT_CONTROL_SWITCH_guidance[] = {
 "Change one element of array ISWIT(10) in /GCFLAG/" };
static KmCommand _GEANT_CONTROL_SWITCH = { &_GEANT_CONTROL_MZLOGL,
 "/GEANT/CONTROL/SWITCH", "SWITCH", 0, 2, 2, 2,
 _GEANT_CONTROL_SWITCH_parameters, 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _GEANT_CONTROL_SWITCH_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _GEANT_CONTROL_RNDM_ISEED1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RNDM_ISEED1 = { "ISEED1", 6,
 "First seed for the random number generator", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_RNDM_ISEED1_type };
static KmParInt    _GEANT_CONTROL_RNDM_ISEED2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RNDM_ISEED2 = { "ISEED2", 6,
 "Second seed for the random number generator", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_RNDM_ISEED2_type };
static KmParameter *_GEANT_CONTROL_RNDM_parameters[] = {
 &_GEANT_CONTROL_RNDM_ISEED1, &_GEANT_CONTROL_RNDM_ISEED2 };
static char *_GEANT_CONTROL_RNDM_guidance[] = {
 "Set the seeds for the random number generator. If no numbers are",
 "given, the currents seeds are printed." };
static KmCommand _GEANT_CONTROL_RNDM = { &_GEANT_CONTROL_SWITCH,
 "/GEANT/CONTROL/RNDM", "RNDM", 0, 2, 2, 0, _GEANT_CONTROL_RNDM_parameters, 0,
 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_CONTROL_RNDM_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_TRIGGER_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_TRIGGER_N = { "N", 1, "Number of events",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_TRIGGER_N_type };
static KmParameter *_GEANT_CONTROL_TRIGGER_parameters[] = {
 &_GEANT_CONTROL_TRIGGER_N };
static char *_GEANT_CONTROL_TRIGGER_guidance[] = {
 "Start one or more new events." };
static KmCommand _GEANT_CONTROL_TRIGGER = { &_GEANT_CONTROL_RNDM,
 "/GEANT/CONTROL/TRIGGER", "TRIGGER", 0, 2, 1, 0,
 _GEANT_CONTROL_TRIGGER_parameters, 0, 0, gxcont_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_CONTROL_TRIGGER_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_GEANT_CONTROL_TRACK_guidance[] = {
 "Restart tracking, clearing the track and hit",
 "banks, but keeping the kinematics." };
static KmCommand _GEANT_CONTROL_TRACK = { &_GEANT_CONTROL_TRIGGER,
 "/GEANT/CONTROL/TRACK", "TRACK", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxcont_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_CONTROL_TRACK_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_CONTROL_GTIME_TIMINT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_GTIME_TIMINT = { "TIMINT", 6,
 "Total time after initialisation", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_CONTROL_GTIME_TIMINT_type };
static KmParReal   _GEANT_CONTROL_GTIME_TIMEND_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_GTIME_TIMEND = { "TIMEND", 6,
 "Time reserved for the termination phase", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_CONTROL_GTIME_TIMEND_type };
static KmParInt    _GEANT_CONTROL_GTIME_ITIME_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_GTIME_ITIME = { "ITIME", 5,
 "Frequency of control printing", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_GTIME_ITIME_type };
static KmParameter *_GEANT_CONTROL_GTIME_parameters[] = {
 &_GEANT_CONTROL_GTIME_TIMINT, &_GEANT_CONTROL_GTIME_TIMEND,
 &_GEANT_CONTROL_GTIME_ITIME };
static char *_GEANT_CONTROL_GTIME_guidance[] = {
 "These commands have limited use in the interactive version. In",
 "particular the value of TIMINT is disregarded by GEANT." };
static KmCommand _GEANT_CONTROL_GTIME = { &_GEANT_CONTROL_TRACK,
 "/GEANT/CONTROL/GTIME", "GTIME", 0, 2, 3, 3, _GEANT_CONTROL_GTIME_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_CONTROL_GTIME_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_CONTROL_SORD_ISTORD_range[] = { "1", "0" };
static KmParInt    _GEANT_CONTROL_SORD_ISTORD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_SORD_ISTORD = { "ISTORD", 6,
 "Flag to control user ordering of the stack", "1", (char*)0, 8, 2,
 _GEANT_CONTROL_SORD_ISTORD_range, 2, _GEANT_CONTROL_SORD_ISTORD_range,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_SORD_ISTORD_type };
static KmParameter *_GEANT_CONTROL_SORD_parameters[] = {
 &_GEANT_CONTROL_SORD_ISTORD };
static char *_GEANT_CONTROL_SORD_guidance[] = {
 "If ISTORD is set to 1, the particle with the highest value of the",
 "user weight UPWGHT will be selected to be tracked next." };
static KmCommand _GEANT_CONTROL_SORD = { &_GEANT_CONTROL_GTIME,
 "/GEANT/CONTROL/SORD", "SORD", 0, 2, 1, 1, _GEANT_CONTROL_SORD_parameters, 0,
 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_CONTROL_SORD_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_RUNG_IDRUN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RUNG_IDRUN = { "IDRUN", 5,
 "User run number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_RUNG_IDRUN_type };
static KmParInt    _GEANT_CONTROL_RUNG_IDEVT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_RUNG_IDEVT = { "IDEVT", 5,
 "User starting event number", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_CONTROL_RUNG_IDEVT_type };
static KmParameter *_GEANT_CONTROL_RUNG_parameters[] = {
 &_GEANT_CONTROL_RUNG_IDRUN, &_GEANT_CONTROL_RUNG_IDEVT };
static char *_GEANT_CONTROL_RUNG_guidance[] = {
 "Set the run number and the starting value for the user event number." };
static KmCommand _GEANT_CONTROL_RUNG = { &_GEANT_CONTROL_SORD,
 "/GEANT/CONTROL/RUNG", "RUNG", 0, 2, 2, 2, _GEANT_CONTROL_RUNG_parameters, 0,
 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_RUNG_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_CONTROL_KINE_IKINE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_IKINE = { "IKINE", 5, "IKINE", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_CONTROL_KINE_IKINE_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE1 = { "PKINE1", 6, "PKINE(1)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE1_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE2 = { "PKINE2", 6, "PKINE(2)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE2_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE3_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE3 = { "PKINE3", 6, "PKINE(3)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE3_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE4_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE4 = { "PKINE4", 6, "PKINE(4)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE4_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE5_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE5 = { "PKINE5", 6, "PKINE(5)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE5_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE6_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE6 = { "PKINE6", 6, "PKINE(6)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE6_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE7_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE7 = { "PKINE7", 6, "PKINE(7)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE7_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE8_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE8 = { "PKINE8", 6, "PKINE(8)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE8_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE9_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE9 = { "PKINE9", 6, "PKINE(9)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE9_type };
static KmParReal   _GEANT_CONTROL_KINE_PKINE10_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_CONTROL_KINE_PKINE10 = { "PKINE10", 7, "PKINE(10)",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GEANT_CONTROL_KINE_PKINE10_type };
static KmParameter *_GEANT_CONTROL_KINE_parameters[] = {
 &_GEANT_CONTROL_KINE_IKINE, &_GEANT_CONTROL_KINE_PKINE1,
 &_GEANT_CONTROL_KINE_PKINE2, &_GEANT_CONTROL_KINE_PKINE3,
 &_GEANT_CONTROL_KINE_PKINE4, &_GEANT_CONTROL_KINE_PKINE5,
 &_GEANT_CONTROL_KINE_PKINE6, &_GEANT_CONTROL_KINE_PKINE7,
 &_GEANT_CONTROL_KINE_PKINE8, &_GEANT_CONTROL_KINE_PKINE9,
 &_GEANT_CONTROL_KINE_PKINE10 };
static char *_GEANT_CONTROL_KINE_guidance[] = {
 "Set the variables in /GCFLAG/ IKINE, PKINE(10)" };
static KmCommand _GEANT_CONTROL_KINE = { &_GEANT_CONTROL_RUNG,
 "/GEANT/CONTROL/KINE", "KINE", 0, 2, 11, 1, _GEANT_CONTROL_KINE_parameters,
 0, 0, gxcont_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_CONTROL_KINE_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_CONTROL_guidance[] = { "Control commands." };
static KmMenu _GEANT_CONTROL = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/CONTROL",
 "CONTROL", 2, &_GEANT_CONTROL_KINE, 1, _GEANT_CONTROL_guidance };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_CONTROL, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkdz_ gkdz
#  define gxdz_ gxdz
#endif

#ifdef F77_UCASE
#  define gkdz_ GKDZ
#  define gxdz_ GXDZ
#endif

#ifdef IBM370
#  pragma linkage(GKDZ,FORTRAN)
#  pragma linkage(GXDZ,FORTRAN)
#endif

extern void gkdz_();
extern void gxdz_();

void gkdz_()
{

static KmParameter _GEANT_DZ_DIRZ_PATH = { "PATH", 4,
 "Name of the RZ directory to analyse", (char*)0, (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_DZ_DIRZ_parameters[] = { &_GEANT_DZ_DIRZ_PATH };
static char *_GEANT_DZ_DIRZ_guidance[] = {
 "Facility to display RZ directory trees.",
 " CALL DZDIRZ(0,LDUMMY,0,path,'N',1,0,1)" };
static KmCommand _GEANT_DZ_DIRZ = {  (KmCommand*)0, "/GEANT/DZ/DIRZ", "DIRZ",
 0, 2, 1, 0, _GEANT_DZ_DIRZ_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_DZ_DIRZ_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DZ_DISP_BANK = { "BANK", 4, "Name of the bank",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_DZ_DISP_PATH = { "PATH", 4, "Name of the doc file",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DZ_DISP_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DZ_DISP_NUMBER = { "NUMBER", 6,
 "Number of the bank", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_DZ_DISP_NUMBER_type };
static KmParameter *_GEANT_DZ_DISP_parameters[] = { &_GEANT_DZ_DISP_BANK,
 &_GEANT_DZ_DISP_PATH, &_GEANT_DZ_DISP_NUMBER };
static char *_GEANT_DZ_DISP_guidance[] = { "Interactive bank display tool.",
 " CALL DZDISP(IXSTOR,LBANK,path,'N',1,0,1,IWTYPE)" };
static KmCommand _GEANT_DZ_DISP = { &_GEANT_DZ_DIRZ, "/GEANT/DZ/DISP", "DISP",
 0, 2, 3, 1, _GEANT_DZ_DISP_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_DZ_DISP_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_DDIV_IDIV_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_DZ_DDIV_IDIV = { "IDIV", 4, "Division number", "2",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_DDIV_IDIV_type };
static KmParameter _GEANT_DZ_DDIV_PATH = { "PATH", 4, "Name of the doc file",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_GEANT_DZ_DDIV_parameters[] = { &_GEANT_DZ_DDIV_IDIV,
 &_GEANT_DZ_DDIV_PATH };
static char *_GEANT_DZ_DDIV_guidance[] = {
 "Facility to display the layout of stores and divisions.",
 " CALL DZDDIV(idiv,LDUMMY,path,'IN',1,0,1,IWTYPE)" };
static KmCommand _GEANT_DZ_DDIV = { &_GEANT_DZ_DISP, "/GEANT/DZ/DDIV", "DDIV",
 0, 2, 2, 0, _GEANT_DZ_DDIV_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_DZ_DDIV_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_STORE_IXSTOR_type = { "0", "24", "0", "24", 0 };
static KmParameter _GEANT_DZ_STORE_IXSTOR = { "IXSTOR", 6, "Store number",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_STORE_IXSTOR_type };
static KmParameter *_GEANT_DZ_STORE_parameters[] = { &_GEANT_DZ_STORE_IXSTOR };
static char *_GEANT_DZ_STORE_guidance[] = {
 "Display the structure of the ZEBRA store IXSTOR.",
 "Output the parameters characterizing the store, followed by a",
 "list of all divisions and all link areas associated with the store in",
 "question." };
static KmCommand _GEANT_DZ_STORE = { &_GEANT_DZ_DDIV, "/GEANT/DZ/STORE",
 "STORE", 0, 2, 1, 0, _GEANT_DZ_STORE_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _GEANT_DZ_STORE_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_VERIFY_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _GEANT_DZ_VERIFY_IDIV = { "IDIV", 4, "Division number ",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_VERIFY_IDIV_type };
static KmParOption _GEANT_DZ_VERIFY_CHOPT_type = { (char**)0, (int*)0, (int*)0
 };
static KmParameter _GEANT_DZ_VERIFY_CHOPT = { "CHOPT", 5, "Options", "CLSU",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DZ_VERIFY_CHOPT_type };
static KmParameter *_GEANT_DZ_VERIFY_parameters[] = { &_GEANT_DZ_VERIFY_IDIV,
 &_GEANT_DZ_VERIFY_CHOPT };
static char *_GEANT_DZ_VERIFY_guidance[] = {
 "Check the structure of one or more ZEBRA divisions.",
 "The verification detail depends on the settings in CHOPT.",
 " CHOPT='C' Check chaining of banks only",
 " CHOPT='L' Check validity of the structural links (implies 'C')",
 " CHOPT='S' Check the store parameters",
 " CHOPT='U' Check the validity of the up and origin (implies 'C')",
 " CHOPT='F' Errors are considered fatal and generate a call to ZFATAL" };
static KmCommand _GEANT_DZ_VERIFY = { &_GEANT_DZ_STORE, "/GEANT/DZ/VERIFY",
 "VERIFY", 0, 2, 2, 0, _GEANT_DZ_VERIFY_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _GEANT_DZ_VERIFY_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_DZ_SNAP_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _GEANT_DZ_SNAP_IDIV = { "IDIV", 4, "Division number ", "2",
 (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_SNAP_IDIV_type };
static KmParOption _GEANT_DZ_SNAP_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_DZ_SNAP_CHOPT = { "CHOPT", 5, "Options", "M",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DZ_SNAP_CHOPT_type };
static KmParameter *_GEANT_DZ_SNAP_parameters[] = { &_GEANT_DZ_SNAP_IDIV,
 &_GEANT_DZ_SNAP_CHOPT };
static char *_GEANT_DZ_SNAP_guidance[] = { "Snap of one or more divisions.",
 "Provides a snapshot of one or more divisions in a ZEBRA store.",
 "The kind of information provided is controlled by CHOPT.",
 " CHOPT='M' Print Map entry for each bank",
 " CHOPT='E' Extend map entry to dump all links of each bank",
 "           (otherwise only as many links as will fit on a line)",
 " CHOPT='F' Full. Dump all active banks, links and data",
 " CHOPT='K' Kill. Dropped banks to be treated as active",
 "           (dropped banks are not normally dumped under D or F option)",
 " CHOPT='L' Dump all Link areas associated with the store",
 " CHOPT='W' Dump the Working space, links and data",
 " CHOPT='Z' Dump the information in hexadecimal." };
static KmCommand _GEANT_DZ_SNAP = { &_GEANT_DZ_VERIFY, "/GEANT/DZ/SNAP",
 "SNAP", 0, 2, 2, 0, _GEANT_DZ_SNAP_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 12, _GEANT_DZ_SNAP_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DZ_SHOW_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DZ_SHOW_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DZ_SHOW_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_SHOW_NUMBER_type };
static KmParOption _GEANT_DZ_SHOW_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_DZ_SHOW_CHOPT = { "CHOPT", 5, "Options", "BSV",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_DZ_SHOW_CHOPT_type };
static KmParameter *_GEANT_DZ_SHOW_parameters[] = { &_GEANT_DZ_SHOW_NAME,
 &_GEANT_DZ_SHOW_NUMBER, &_GEANT_DZ_SHOW_CHOPT };
static char *_GEANT_DZ_SHOW_guidance[] = {
 "Display the contents of a bank or a data structure",
 "identified by its NAME and NUMBER.",
 "The output format of the data part is controlled by the internal",
 "or external I/O characteristic.", " CHOPT='B' Print the bank.",
 " CHOPT='S' Print the bank contents from left to right Sideways",
 "           with up to ten elements per line.",
 " CHOPT='V' Print the vertical (down) structure.",
 " CHOPT='D' Print the bank contents from top to bottom Downwards",
 "           with five elements per line.",
 " CHOPT='L' Print the linear structure.",
 " CHOPT='Z' Print the data part of each bank in hexadecimal format" };
static KmCommand _GEANT_DZ_SHOW = { &_GEANT_DZ_SNAP, "/GEANT/DZ/SHOW", "SHOW",
 0, 2, 3, 1, _GEANT_DZ_SHOW_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 12, _GEANT_DZ_SHOW_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_DZ_SURV_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GEANT_DZ_SURV_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_DZ_SURV_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_DZ_SURV_NUMBER_type };
static KmParameter *_GEANT_DZ_SURV_parameters[] = { &_GEANT_DZ_SURV_NAME,
 &_GEANT_DZ_SURV_NUMBER };
static char *_GEANT_DZ_SURV_guidance[] = {
 "Print a survey of the structure identified by NAME, NUMBER." };
static KmCommand _GEANT_DZ_SURV = { &_GEANT_DZ_SHOW, "/GEANT/DZ/SURV", "SURV",
 0, 2, 2, 1, _GEANT_DZ_SURV_parameters, 0, 0, gxdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_DZ_SURV_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmMenu _GEANT_DZ = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/DZ", "DZ", 2,
 &_GEANT_DZ_SURV, 0, (char**)0 };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_DZ, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkfz_ gkfz
#  define gxfz_ gxfz
#endif

#ifdef F77_UCASE
#  define gkfz_ GKFZ
#  define gxfz_ GXFZ
#endif

#ifdef IBM370
#  pragma linkage(GKFZ,FORTRAN)
#  pragma linkage(GXFZ,FORTRAN)
#endif

extern void gkfz_();
extern void gxfz_();

void gkfz_()
{

static KmParInt    _GEANT_FZ_FZCLOSE_LUN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_FZ_FZCLOSE_LUN = { "LUN", 3,
 "Fortran unit of the FZ to close", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZCLOSE_LUN_type };
static KmParameter *_GEANT_FZ_FZCLOSE_parameters[] = { &_GEANT_FZ_FZCLOSE_LUN
 };
static char *_GEANT_FZ_FZCLOSE_guidance[] = { "Equivalent to a call to:",
 "       CALL GCLOSE(LUN,IER)" };
static KmCommand _GEANT_FZ_FZCLOSE = {  (KmCommand*)0, "/GEANT/FZ/FZCLOSE",
 "FZCLOSE", 0, 2, 1, 1, _GEANT_FZ_FZCLOSE_parameters, 0, 0, gxfz_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_FZ_FZCLOSE_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_FZ_FZOUT_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOUT_LUN = { "LUN", 3,
 "Fortran unit of the FZ file", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOUT_LUN_type };
static KmParameter _GEANT_FZ_FZOUT_KEYSU = { "KEYSU", 5,
 "Name of the data structure to be saved", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_FZ_FZOUT_IDENT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOUT_IDENT = { "IDENT", 5,
 "Version of the data structure to be saved", "1", (char*)0, 8, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOUT_IDENT_type };
static KmParameter *_GEANT_FZ_FZOUT_parameters[] = { &_GEANT_FZ_FZOUT_LUN,
 &_GEANT_FZ_FZOUT_KEYSU, &_GEANT_FZ_FZOUT_IDENT };
static char *_GEANT_FZ_FZOUT_guidance[] = { "Equivalent to a call to:",
 "       CALL GFOUT(LUN,KEYSU,1,IDENT,' ',IER)" };
static KmCommand _GEANT_FZ_FZOUT = { &_GEANT_FZ_FZCLOSE, "/GEANT/FZ/FZOUT",
 "FZOUT", 0, 2, 3, 2, _GEANT_FZ_FZOUT_parameters, 0, 0, gxfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_FZ_FZOUT_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_FZ_FZOPEN_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOPEN_LUN = { "LUN", 3,
 "Fortran unit with which to open the file", (char*)0, (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOPEN_LUN_type
 };
static KmParameter _GEANT_FZ_FZOPEN_FILE = { "FILE", 4,
 "Name of the file to be opened", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GEANT_FZ_FZOPEN_LUNTYP = { "LUNTYP", 6,
 "Type of FZ file to be opened by GOPEN", "XI", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_FZ_FZOPEN_LEN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZOPEN_LEN = { "LEN", 3,
 "Recordlenght of the file", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZOPEN_LEN_type };
static KmParOption _GEANT_FZ_FZOPEN_CHOPT_type = { (char**)0, (int*)0, (int*)0
 };
static KmParameter _GEANT_FZ_FZOPEN_CHOPT = { "CHOPT", 5,
 "Optional parameter to specify the action", " ", (char*)0, 20, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION, &_GEANT_FZ_FZOPEN_CHOPT_type };
static KmParameter *_GEANT_FZ_FZOPEN_parameters[] = { &_GEANT_FZ_FZOPEN_LUN,
 &_GEANT_FZ_FZOPEN_FILE, &_GEANT_FZ_FZOPEN_LUNTYP, &_GEANT_FZ_FZOPEN_LEN,
 &_GEANT_FZ_FZOPEN_CHOPT };
static char *_GEANT_FZ_FZOPEN_guidance[] = { "Equivalent to a call to:",
 "       CALL GOPEN(LUN,FILE,LUNTYP,LEN,IER)",
 "If CHOPT = I then a call to GFIN or GFOUT will be performed in addition",
 "according to the value of LUNTYP, with the key INIT to save or retrieve",
 "the whole initialization data structure." };
static KmCommand _GEANT_FZ_FZOPEN = { &_GEANT_FZ_FZOUT, "/GEANT/FZ/FZOPEN",
 "FZOPEN", 0, 2, 5, 4, _GEANT_FZ_FZOPEN_parameters, 0, 0, gxfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _GEANT_FZ_FZOPEN_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_FZ_FZIN_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZIN_LUN = { "LUN", 3,
 "Fortran unit of the FZ file", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZIN_LUN_type };
static KmParameter _GEANT_FZ_FZIN_KEYSU = { "KEYSU", 5,
 "Name of the data structure to be retrieved", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_FZ_FZIN_IDENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_FZ_FZIN_IDENT = { "IDENT", 5,
 "Version of the data structure to be retrieved", "0", (char*)0, 8, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_FZ_FZIN_IDENT_type
 };
static KmParameter *_GEANT_FZ_FZIN_parameters[] = { &_GEANT_FZ_FZIN_LUN,
 &_GEANT_FZ_FZIN_KEYSU, &_GEANT_FZ_FZIN_IDENT };
static char *_GEANT_FZ_FZIN_guidance[] = { "Equivalent to a call to:",
 "       CALL GFIN(LUN,KEYSU,1,IDENT,' ',IER)" };
static KmCommand _GEANT_FZ_FZIN = { &_GEANT_FZ_FZOPEN, "/GEANT/FZ/FZIN",
 "FZIN", 0, 2, 3, 2, _GEANT_FZ_FZIN_parameters, 0, 0, gxfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_FZ_FZIN_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_FZ_guidance[] = { "ZEBRA/FZ commands" };
static KmMenu _GEANT_FZ = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/FZ", "FZ", 2,
 &_GEANT_FZ_FZIN, 1, _GEANT_FZ_guidance };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_FZ, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkrz_ gkrz
#  define gxrz_ gxrz
#endif

#ifdef F77_UCASE
#  define gkrz_ GKRZ
#  define gxrz_ GXRZ
#endif

#ifdef IBM370
#  pragma linkage(GKRZ,FORTRAN)
#  pragma linkage(GXRZ,FORTRAN)
#endif

extern void gkrz_();
extern void gxrz_();

void gkrz_()
{

static KmParameter _GEANT_RZ_FREE_CHDIR = { "CHDIR", 5, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_RZ_FREE_parameters[] = { &_GEANT_RZ_FREE_CHDIR };
static char *_GEANT_RZ_FREE_guidance[] = { "Free an RZ directory." };
static KmCommand _GEANT_RZ_FREE = {  (KmCommand*)0, "/GEANT/RZ/FREE", "FREE",
 0, 2, 1, 1, _GEANT_RZ_FREE_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_FREE_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_LOCK_CHDIR = { "CHDIR", 5, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_RZ_LOCK_parameters[] = { &_GEANT_RZ_LOCK_CHDIR };
static char *_GEANT_RZ_LOCK_guidance[] = { "Lock an RZ directory." };
static KmCommand _GEANT_RZ_LOCK = { &_GEANT_RZ_FREE, "/GEANT/RZ/LOCK", "LOCK",
 0, 2, 1, 1, _GEANT_RZ_LOCK_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_LOCK_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_SCR_OBJECT = { "OBJECT", 6, "Structure name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_RZ_SCR_IDVERS_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_SCR_IDVERS = { "IDVERS", 6, "Version number",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_SCR_IDVERS_type };
static KmParameter *_GEANT_RZ_SCR_parameters[] = { &_GEANT_RZ_SCR_OBJECT,
 &_GEANT_RZ_SCR_IDVERS };
static char *_GEANT_RZ_SCR_guidance[] = {
 "Delete entry identified by OBJECT,IDVERS on RZ file.",
 "OBJECT may be : MATE,TMED,VOLU,ROTM,SETS,PART,SCAN, *",
 "If OBJECT= *    delete all entries with IDVERS." };
static KmCommand _GEANT_RZ_SCR = { &_GEANT_RZ_LOCK, "/GEANT/RZ/SCR", "SCR", 0,
 2, 2, 1, _GEANT_RZ_SCR_parameters, 0, 0, gxrz_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _GEANT_RZ_SCR_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_PURGE_NKEEP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_RZ_PURGE_NKEEP = { "NKEEP", 5,
 "Number of cycles to keep", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_RZ_PURGE_NKEEP_type };
static KmParameter *_GEANT_RZ_PURGE_parameters[] = { &_GEANT_RZ_PURGE_NKEEP };
static char *_GEANT_RZ_PURGE_guidance[] = { "Purge an RZ directory." };
static KmCommand _GEANT_RZ_PURGE = { &_GEANT_RZ_SCR, "/GEANT/RZ/PURGE",
 "PURGE", 0, 2, 1, 0, _GEANT_RZ_PURGE_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_PURGE_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_LDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParOption _GEANT_RZ_LDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_LDIR_CHOPT = { "CHOPT", 5, "CHOPT", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_LDIR_CHOPT_type };
static KmParameter *_GEANT_RZ_LDIR_parameters[] = { &_GEANT_RZ_LDIR_CHPATH,
 &_GEANT_RZ_LDIR_CHOPT };
static char *_GEANT_RZ_LDIR_guidance[] = {
 "List the contents of a directory (memory or disk).",
 "To list all RZ files currently open, type 'LD //'." };
static KmCommand _GEANT_RZ_LDIR = { &_GEANT_RZ_PURGE, "/GEANT/RZ/LDIR",
 "LDIR", 0, 2, 2, 0, _GEANT_RZ_LDIR_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_RZ_LDIR_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_OUT_OBJECT = { "OBJECT", 6, "Structure name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_RZ_OUT_IDVERS_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_OUT_IDVERS = { "IDVERS", 6, "Version number",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_OUT_IDVERS_type };
static KmParOption _GEANT_RZ_OUT_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_OUT_CHOPT = { "CHOPT", 5, "Option", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_OUT_CHOPT_type };
static KmParameter *_GEANT_RZ_OUT_parameters[] = { &_GEANT_RZ_OUT_OBJECT,
 &_GEANT_RZ_OUT_IDVERS, &_GEANT_RZ_OUT_CHOPT };
static char *_GEANT_RZ_OUT_guidance[] = {
 "Write data structure identified by OBJECT,IDVERS to RZ file.",
 "  MATE write JMATE structure", "  TMED write JTMED structure",
 "  VOLU write JVOLUM structure", "  ROTM write JROTM structure",
 "  SETS write JSET  structure", "  PART write JPART structure",
 "  SCAN write LSCAN structure", "  INIT write all above data structures" };
static KmCommand _GEANT_RZ_OUT = { &_GEANT_RZ_LDIR, "/GEANT/RZ/OUT", "OUT", 0,
 2, 3, 1, _GEANT_RZ_OUT_parameters, 0, 0, gxrz_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 9, _GEANT_RZ_OUT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_IN_OBJECT = { "OBJECT", 6, "Structure name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GEANT_RZ_IN_IDVERS_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_IN_IDVERS = { "IDVERS", 6, "Version number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_IN_IDVERS_type };
static KmParOption _GEANT_RZ_IN_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_IN_CHOPT = { "CHOPT", 5, "Option", " ", (char*)0,
 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_IN_CHOPT_type };
static KmParameter *_GEANT_RZ_IN_parameters[] = { &_GEANT_RZ_IN_OBJECT,
 &_GEANT_RZ_IN_IDVERS, &_GEANT_RZ_IN_CHOPT };
static char *_GEANT_RZ_IN_guidance[] = {
 "Read data structure identified by OBJECT,IDVERS into memory.",
 "  MATE read JMATE structure", "  TMED read JTMED structure",
 "  VOLU read JVOLUM structure", "  ROTM read JROTM structure",
 "  SETS read JSET  structure", "  PART read JPART structure",
 "  SCAN read LSCAN structure", "  INIT read all above data structures" };
static KmCommand _GEANT_RZ_IN = { &_GEANT_RZ_OUT, "/GEANT/RZ/IN", "IN", 0, 2,
 3, 1, _GEANT_RZ_IN_parameters, 0, 0, gxrz_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 9, _GEANT_RZ_IN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_CDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParOption _GEANT_RZ_CDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_CDIR_CHOPT = { "CHOPT", 5, "CHOPT", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_CDIR_CHOPT_type };
static KmParameter *_GEANT_RZ_CDIR_parameters[] = { &_GEANT_RZ_CDIR_CHPATH,
 &_GEANT_RZ_CDIR_CHOPT };
static char *_GEANT_RZ_CDIR_guidance[] = {
 "Change or print the current directory.",
 " Ex.  CD dir1         ; make DIR1 the new CWD",
 "      CD //file1/dir2 ; make //FILE1/DIR2 the new CWD",
 "      CD              ; print the name of the CWD" };
static KmCommand _GEANT_RZ_CDIR = { &_GEANT_RZ_IN, "/GEANT/RZ/CDIR", "CDIR",
 0, 2, 2, 0, _GEANT_RZ_CDIR_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _GEANT_RZ_CDIR_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GEANT_RZ_MDIR_CHDIR = { "CHDIR", 5, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParOption _GEANT_RZ_MDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_MDIR_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_RZ_MDIR_CHOPT_type };
static KmParameter *_GEANT_RZ_MDIR_parameters[] = { &_GEANT_RZ_MDIR_CHDIR,
 &_GEANT_RZ_MDIR_CHOPT };
static char *_GEANT_RZ_MDIR_guidance[] = {
 "To create a new RZ directory below the current directory.", "with",
 " RZTAGS(1)='Object'", " RZTAGS(2)='Idvers-NR '" };
static KmCommand _GEANT_RZ_MDIR = { &_GEANT_RZ_CDIR, "/GEANT/RZ/MDIR", "MDIR",
 0, 2, 2, 1, _GEANT_RZ_MDIR_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _GEANT_RZ_MDIR_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_REND_LUNRZ_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_REND_LUNRZ = { "LUNRZ", 5, "Logical unit number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_REND_LUNRZ_type };
static KmParameter *_GEANT_RZ_REND_parameters[] = { &_GEANT_RZ_REND_LUNRZ };
static char *_GEANT_RZ_REND_guidance[] = {
 "Close an RZ file opened by GRFILE on logical unit LUNRZ.",
 " CALL GREND(LUNRZ)" };
static KmCommand _GEANT_RZ_REND = { &_GEANT_RZ_MDIR, "/GEANT/RZ/REND", "REND",
 0, 2, 1, 1, _GEANT_RZ_REND_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_RZ_REND_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_FILE_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_RZ_FILE_LUN_type };
static KmParameter _GEANT_RZ_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_GEANT_RZ_FILE_CHOPT_range[] = { " ", "A", "N", "U" };
static char *_GEANT_RZ_FILE_CHOPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _GEANT_RZ_FILE_CHOPT_type = { _GEANT_RZ_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _GEANT_RZ_FILE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _GEANT_RZ_FILE_CHOPT_range, 4, _GEANT_RZ_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_GEANT_RZ_FILE_CHOPT_type };
static KmParameter *_GEANT_RZ_FILE_parameters[] = { &_GEANT_RZ_FILE_LUN,
 &_GEANT_RZ_FILE_FNAME, &_GEANT_RZ_FILE_CHOPT };
static char *_GEANT_RZ_FILE_guidance[] = { "Open a GRZ file.",
 " CHOPT=' ' readonly mode", " CHOPT='U' update mode",
 " CHOPT='N' create new file",
 " CHOPT='I' Read all structures from existing file",
 " CHOPT='O' Write all structures on file" };
static KmCommand _GEANT_RZ_FILE = { &_GEANT_RZ_REND, "/GEANT/RZ/FILE", "FILE",
 0, 2, 3, 2, _GEANT_RZ_FILE_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _GEANT_RZ_FILE_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_RZ_PQUEST_IQ1_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_PQUEST_IQ1 = { "IQ1", 3,
 "Lower limit for IQ index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_RZ_PQUEST_IQ1_type };
static KmParInt    _GEANT_RZ_PQUEST_IQ2_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_RZ_PQUEST_IQ2 = { "IQ2", 3,
 "Upper limit for IQ index", "20", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_RZ_PQUEST_IQ2_type };
static KmParameter *_GEANT_RZ_PQUEST_parameters[] = { &_GEANT_RZ_PQUEST_IQ1,
 &_GEANT_RZ_PQUEST_IQ2 };
static char *_GEANT_RZ_PQUEST_guidance[] = {
 "Print the array IQUEST in /QUEST/." };
static KmCommand _GEANT_RZ_PQUEST = { &_GEANT_RZ_FILE, "/GEANT/RZ/PQUEST",
 "PQUEST", 0, 2, 2, 0, _GEANT_RZ_PQUEST_parameters, 0, 0, gxrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _GEANT_RZ_PQUEST_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_RZ_guidance[] = { "ZEBRA/RZ commands." };
static KmMenu _GEANT_RZ = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/RZ", "RZ", 2,
 &_GEANT_RZ_PQUEST, 1, _GEANT_RZ_guidance };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_RZ, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkscan_ gkscan
#  define gxscan_ gxscan
#endif

#ifdef F77_UCASE
#  define gkscan_ GKSCAN
#  define gxscan_ GXSCAN
#endif

#ifdef IBM370
#  pragma linkage(GKSCAN,FORTRAN)
#  pragma linkage(GXSCAN,FORTRAN)
#endif

extern void gkscan_();
extern void gxscan_();

void gkscan_()
{

static KmParInt    _GEANT_SCAN_HSCAN_IDPHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_HSCAN_IDPHI = { "IDPHI", 5,
 "Histogram/phi identifier", "1000", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_HSCAN_IDPHI_type };
static KmParameter _GEANT_SCAN_HSCAN_VOLUME = { "VOLUME", 6, "Volume name",
 "XXXX", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_GEANT_SCAN_HSCAN_CHOPT_range[] = { " ", "O", "P", "I", "X", "L"
 };
static char *_GEANT_SCAN_HSCAN_CHOPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_SCAN_HSCAN_CHOPT_type = {
 _GEANT_SCAN_HSCAN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_SCAN_HSCAN_CHOPT = { "CHOPT", 5, "List of options",
 "OPX", (char*)0, 8, 6, _GEANT_SCAN_HSCAN_CHOPT_range, 6,
 _GEANT_SCAN_HSCAN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_SCAN_HSCAN_CHOPT_type };
static KmParameter *_GEANT_SCAN_HSCAN_parameters[] = {
 &_GEANT_SCAN_HSCAN_IDPHI, &_GEANT_SCAN_HSCAN_VOLUME, &_GEANT_SCAN_HSCAN_CHOPT
 };
static char *_GEANT_SCAN_HSCAN_guidance[] = {
 "Generates and plots an histogram of physics quantities such as",
 "the total number of radiation lengths or interaction lengths",
 "as a function of the SCAN parameter TETA for a given value of PHI.",
 "  CHOPT='O' histogram is generated at Exit  of VOLUME.",
 "  CHOPT='I' histogram is generated at Entry of VOLUME.",
 "  CHOPT='X' radiation lengths", "  CHOPT='L' Interaction lengths",
 "  CHOPT='P' Plot the histogram", "If VOLUME='XXXX' Mother volume is used.",
 "The histogram identifier IDPHI is used to also identify which",
 "PHI division to plot: IPHI=MOD(IDPHI,1000).",
 "If IPHI=0, then all PHI divisions are generated (not plotted)",
 "with histogram identifiers IDPHI+PHI division number." };
static KmCommand _GEANT_SCAN_HSCAN = {  (KmCommand*)0, "/GEANT/SCAN/HSCAN",
 "HSCAN", 0, 2, 3, 1, _GEANT_SCAN_HSCAN_parameters, 0, 0, gxscan_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13, _GEANT_SCAN_HSCAN_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_LSCAN_ID_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_SCAN_LSCAN_ID = { "ID", 2, "Lego plot identifier",
 "2000", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_SCAN_LSCAN_ID_type };
static KmParameter _GEANT_SCAN_LSCAN_VOLUME = { "VOLUME", 6, "Volume name",
 "XXXX", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_GEANT_SCAN_LSCAN_CHOPT_range[] = { " ", "O", "P", "I", "X", "L"
 };
static char *_GEANT_SCAN_LSCAN_CHOPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_SCAN_LSCAN_CHOPT_type = {
 _GEANT_SCAN_LSCAN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_SCAN_LSCAN_CHOPT = { "CHOPT", 5, "List of options",
 "OPX", (char*)0, 8, 6, _GEANT_SCAN_LSCAN_CHOPT_range, 6,
 _GEANT_SCAN_LSCAN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_SCAN_LSCAN_CHOPT_type };
static KmParameter *_GEANT_SCAN_LSCAN_parameters[] = { &_GEANT_SCAN_LSCAN_ID,
 &_GEANT_SCAN_LSCAN_VOLUME, &_GEANT_SCAN_LSCAN_CHOPT };
static char *_GEANT_SCAN_LSCAN_guidance[] = {
 "Generates and plot a table of physics quantities such as",
 "the total number of radiation lengths or interaction lengths",
 "in function of the SCAN parameters TETA,PHI.",
 "  CHOPT='O' table is generated at Exit  of VOLUME.",
 "  CHOPT='I' table is generated at Entry of VOLUME.",
 "  CHOPT='X' radiation lengths", "  CHOPT='L' Interaction lengths",
 "  CHOPT='P' Plot the table", "If VOLUME='XXXX' Mother volume is used." };
static KmCommand _GEANT_SCAN_LSCAN = { &_GEANT_SCAN_HSCAN,
 "/GEANT/SCAN/LSCAN", "LSCAN", 0, 2, 3, 1, _GEANT_SCAN_LSCAN_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _GEANT_SCAN_LSCAN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_PCUTS_IPARAM_type = { "0", "1", "0", "1", 0 };
static KmParameter _GEANT_SCAN_PCUTS_IPARAM = { "IPARAM", 6,
 "Parametrization Flag", (char*)0, (char*)0, 2, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_PCUTS_IPARAM_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTGA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTGA = { "PCUTGA", 6,
 "Parametrization Cut for gammas", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PCUTS_PCUTGA_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTEL = { "PCUTEL", 6,
 "Parametrization Cut for electrons", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PCUTS_PCUTEL_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTHA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTHA = { "PCUTHA", 6,
 "Parametrization Cut for charged hadrons", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_PCUTS_PCUTHA_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTNE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTNE = { "PCUTNE", 6,
 "Parametrization Cut for neutral hadrons", (char*)0, (char*)0, 12, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_PCUTS_PCUTNE_type };
static KmParReal   _GEANT_SCAN_PCUTS_PCUTMU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_PCUTS_PCUTMU = { "PCUTMU", 6,
 "Parametrization Cut for muons", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PCUTS_PCUTMU_type };
static KmParameter *_GEANT_SCAN_PCUTS_parameters[] = {
 &_GEANT_SCAN_PCUTS_IPARAM, &_GEANT_SCAN_PCUTS_PCUTGA,
 &_GEANT_SCAN_PCUTS_PCUTEL, &_GEANT_SCAN_PCUTS_PCUTHA,
 &_GEANT_SCAN_PCUTS_PCUTNE, &_GEANT_SCAN_PCUTS_PCUTMU };
static char *_GEANT_SCAN_PCUTS_guidance[] = {
 "Control parametrization at tracking time.",
 "     IPARAM=0       No parametrization is performed",
 "     IPARAM=1       Parametrization is performed",
 "If parametrization is active and a particle falls below its",
 "parametrization cut, then the particle will be replaced by",
 "a parametrized shower which will be tracked in the SCAN", "geometry." };
static KmCommand _GEANT_SCAN_PCUTS = { &_GEANT_SCAN_LSCAN,
 "/GEANT/SCAN/PCUTS", "PCUTS", 0, 2, 6, 0, _GEANT_SCAN_PCUTS_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7,
 _GEANT_SCAN_PCUTS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_SCAN_STURN_CHOPT_range[] = { "ON", "OFF", "INIT" };
static char *_GEANT_SCAN_STURN_CHOPT_text[] = { (char*)0, (char*)0, (char*)0 };
static KmParOption _GEANT_SCAN_STURN_CHOPT_type = {
 _GEANT_SCAN_STURN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GEANT_SCAN_STURN_CHOPT = { "CHOPT", 5,
 "SCAN mode setting", (char*)0, (char*)0, 8, 3, _GEANT_SCAN_STURN_CHOPT_range,
 3, _GEANT_SCAN_STURN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GEANT_SCAN_STURN_CHOPT_type };
static KmParameter *_GEANT_SCAN_STURN_parameters[] = {
 &_GEANT_SCAN_STURN_CHOPT };
static char *_GEANT_SCAN_STURN_guidance[] = {
 "Switch on/off SCAN mode. If SCAN mode is on, SCAN geantinos",
 "are generated and tracked to fill (or complete) the current",
 "scan data structure. If SCAN mode is off, normal kinematics",
 "generation and tracking will take place. If INIT is given,",
 "the current SCAN data structure (if any) will be dropped",
 "and SCAN mode will be turned on." };
static KmCommand _GEANT_SCAN_STURN = { &_GEANT_SCAN_PCUTS,
 "/GEANT/SCAN/STURN", "STURN", 0, 2, 1, 1, _GEANT_SCAN_STURN_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _GEANT_SCAN_STURN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_SCAN_SFACTORS_FACTX0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_SFACTORS_FACTX0 = { "FACTX0", 6,
 "Scale factor for SX0", "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_SFACTORS_FACTX0_type };
static KmParReal   _GEANT_SCAN_SFACTORS_FACTL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_SFACTORS_FACTL = { "FACTL", 5,
 "Scale factor for SL", "1000.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_SFACTORS_FACTL_type };
static KmParReal   _GEANT_SCAN_SFACTORS_FACTR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_SFACTORS_FACTR = { "FACTR", 5,
 "Scale factor for R", "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_SFACTORS_FACTR_type };
static KmParameter *_GEANT_SCAN_SFACTORS_parameters[] = {
 &_GEANT_SCAN_SFACTORS_FACTX0, &_GEANT_SCAN_SFACTORS_FACTL,
 &_GEANT_SCAN_SFACTORS_FACTR };
static char *_GEANT_SCAN_SFACTORS_guidance[] = {
 "Set scale factors for SX0,SL and R. The given scale factors must be",
 "such that:", "  SX0*FACTX0 < 2**15-1 (32767)",
 "  SL*FACTL   < 2**10-1 (1023)", "  SR*FACTR   < 2**17-1 (131071)" };
static KmCommand _GEANT_SCAN_SFACTORS = { &_GEANT_SCAN_STURN,
 "/GEANT/SCAN/SFACTORS", "SFACTORS", 0, 2, 3, 3,
 _GEANT_SCAN_SFACTORS_parameters, 0, 0, gxscan_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 5, _GEANT_SCAN_SFACTORS_guidance, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParReal   _GEANT_SCAN_VERTEX_VX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_VERTEX_VX = { "VX", 2, "Scan X-origin", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_VERTEX_VX_type };
static KmParReal   _GEANT_SCAN_VERTEX_VY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_VERTEX_VY = { "VY", 2, "Scan Y-origin", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_VERTEX_VY_type };
static KmParReal   _GEANT_SCAN_VERTEX_VZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_VERTEX_VZ = { "VZ", 2, "Scan Z-origin", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_SCAN_VERTEX_VZ_type };
static KmParameter *_GEANT_SCAN_VERTEX_parameters[] = {
 &_GEANT_SCAN_VERTEX_VX, &_GEANT_SCAN_VERTEX_VY, &_GEANT_SCAN_VERTEX_VZ };
static char *_GEANT_SCAN_VERTEX_guidance[] = {
 "All Geantinos tracked will start from position VX,VY,VZ." };
static KmCommand _GEANT_SCAN_VERTEX = { &_GEANT_SCAN_SFACTORS,
 "/GEANT/SCAN/VERTEX", "VERTEX", 0, 2, 3, 3, _GEANT_SCAN_VERTEX_parameters, 0,
 0, gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_SCAN_VERTEX_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GEANT_SCAN_SLIST_LIST = { "LIST", 4,
 "List of master volumes", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GEANT_SCAN_SLIST_parameters[] = { &_GEANT_SCAN_SLIST_LIST
 };
static char *_GEANT_SCAN_SLIST_guidance[] = {
 "Only boundary crossings of volumes given in LIST will be seen",
 "in the SCAN geometry. If no parameters are given, the current",
 "SCAN volumes will be listed. If a full stop (.) is given, the list",
 "of scan volumes will be erased." };
static KmCommand _GEANT_SCAN_SLIST = { &_GEANT_SCAN_VERTEX,
 "/GEANT/SCAN/SLIST", "SLIST", 0, 2, 1, 1, _GEANT_SCAN_SLIST_parameters, 0, 0,
 gxscan_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_SCAN_SLIST_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_TETA_NTETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_TETA_NTETA = { "NTETA", 5,
 "Number of TETA divisions", "90", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_TETA_NTETA_type };
static KmParReal   _GEANT_SCAN_TETA_TETMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_TETA_TETMIN = { "TETMIN", 6,
 "Minimum value of TETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_TETA_TETMIN_type };
static KmParReal   _GEANT_SCAN_TETA_TETMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_SCAN_TETA_TETMAX = { "TETMAX", 6,
 "Maximum value of TETA", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_TETA_TETMAX_type };
static KmParInt    _GEANT_SCAN_TETA_DIVTYP_type = { "1", "3", "1", "3", 0 };
static KmParameter _GEANT_SCAN_TETA_DIVTYP = { "DIVTYP", 6,
 "Type of TETA division", (char*)0, (char*)0, 2, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_TETA_DIVTYP_type };
static KmParameter *_GEANT_SCAN_TETA_parameters[] = { &_GEANT_SCAN_TETA_NTETA,
 &_GEANT_SCAN_TETA_TETMIN, &_GEANT_SCAN_TETA_TETMAX, &_GEANT_SCAN_TETA_DIVTYP
 };
static char *_GEANT_SCAN_TETA_guidance[] = {
 "To specify number of divisions along TETA.",
 "If DIVTYP=1 divisions in pseudo-rapidity ETA.",
 "If DIVTYP=2 divisions in degrees following the THETA angle.",
 "If DIVTYP=3 divisions in cos(TETA).",
 "If no parameter is given, the current values of the parameters",
 "are displayed." };
static KmCommand _GEANT_SCAN_TETA = { &_GEANT_SCAN_SLIST, "/GEANT/SCAN/TETA",
 "TETA", 0, 2, 4, 1, _GEANT_SCAN_TETA_parameters, 0, 0, gxscan_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _GEANT_SCAN_TETA_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GEANT_SCAN_PHI_NPHI_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GEANT_SCAN_PHI_NPHI = { "NPHI", 4,
 "Number of PHI divisions", "90", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_SCAN_PHI_NPHI_type };
static KmParReal   _GEANT_SCAN_PHI_PHIMIN_type = { "0.", "360.", "0.", "360.",
 0 };
static KmParameter _GEANT_SCAN_PHI_PHIMIN = { "PHIMIN", 6,
 "Minimum PHI in degrees", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PHI_PHIMIN_type };
static KmParReal   _GEANT_SCAN_PHI_PHIMAX_type = { "0.", "360.", "0.", "360.",
 0 };
static KmParameter _GEANT_SCAN_PHI_PHIMAX = { "PHIMAX", 6,
 "Maximum PHI in degrees", "360.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_SCAN_PHI_PHIMAX_type };
static KmParameter *_GEANT_SCAN_PHI_parameters[] = { &_GEANT_SCAN_PHI_NPHI,
 &_GEANT_SCAN_PHI_PHIMIN, &_GEANT_SCAN_PHI_PHIMAX };
static char *_GEANT_SCAN_PHI_guidance[] = {
 "To specify number of divisions along PHI. If no parameter is",
 "given, the current values of the parameters are displayed." };
static KmCommand _GEANT_SCAN_PHI = { &_GEANT_SCAN_TETA, "/GEANT/SCAN/PHI",
 "PHI", 0, 2, 3, 1, _GEANT_SCAN_PHI_parameters, 0, 0, gxscan_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GEANT_SCAN_PHI_guidance, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GEANT_SCAN_guidance[] = {
 "To define parameters for the SCAN geometry. If the routine GUSTEP",
 "and GUKINE are properly instrumented (see examples in GEANX),",
 "when the TRI command is entered NTETA Geantinos will be",
 "tracked through the real detector starting at the vertex position",
 "defined by the command vertex. A simplified version of the geometry",
 "is automatically generated in (ETA,PHI) or (THETA,PHI) following",
 "the option given in the command TETA. The data structure LSCAN",
 "generated may be saved on an RZ file for subsequent processing.",
 "This data structure may be used for fast parametrization techniques." };
static KmMenu _GEANT_SCAN = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/SCAN", "SCAN",
 2, &_GEANT_SCAN_PHI, 9, _GEANT_SCAN_guidance };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_SCAN, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkphys_ gkphys
#  define gxphys_ gxphys
#endif

#ifdef F77_UCASE
#  define gkphys_ GKPHYS
#  define gxphys_ GXPHYS
#endif

#ifdef IBM370
#  pragma linkage(GKPHYS,FORTRAN)
#  pragma linkage(GXPHYS,FORTRAN)
#endif

extern void gkphys_();
extern void gxphys_();

void gkphys_()
{

static char *_GEANT_PHYSICS_PHYSI_guidance[] = {
 "Call the GEANT initialisation routine GPHYSI to recompute",
 "the tables of cross-sections and energy loss. This command",
 "must be invoked after CUTS, LOSS or ERAN commands." };
static KmCommand _GEANT_PHYSICS_PHYSI = {  (KmCommand*)0,
 "/GEANT/PHYSICS/PHYSI", "PHYSI", 0, 2, 0, 0, (KmParameter**)0, 0, 0, gxphys_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GEANT_PHYSICS_PHYSI_guidance,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_PHYSICS_DRPRT_IPART_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_IPART = { "IPART", 5,
 "GEANT particle number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_PHYSICS_DRPRT_IPART_type };
static KmParInt    _GEANT_PHYSICS_DRPRT_IMATE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_IMATE = { "IMATE", 5,
 "GEANT material number", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GEANT_PHYSICS_DRPRT_IMATE_type };
static KmParReal   _GEANT_PHYSICS_DRPRT_STEP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_STEP = { "STEP", 4,
 "step length in centimeters", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_DRPRT_STEP_type };
static KmParInt    _GEANT_PHYSICS_DRPRT_NPOINT_type = { "2", "100", "2",
 "100", 0 };
static KmParameter _GEANT_PHYSICS_DRPRT_NPOINT = { "NPOINT", 6,
 "number of logarithmically spaced energy points", "10", (char*)0, 4, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_DRPRT_NPOINT_type };
static KmParameter *_GEANT_PHYSICS_DRPRT_parameters[] = {
 &_GEANT_PHYSICS_DRPRT_IPART, &_GEANT_PHYSICS_DRPRT_IMATE,
 &_GEANT_PHYSICS_DRPRT_STEP, &_GEANT_PHYSICS_DRPRT_NPOINT };
static char *_GEANT_PHYSICS_DRPRT_guidance[] = {
 "This routine prints the relevant parameters linked with the energy loss",
 "fluctuation." };
static KmCommand _GEANT_PHYSICS_DRPRT = { &_GEANT_PHYSICS_PHYSI,
 "/GEANT/PHYSICS/DRPRT", "DRPRT", 0, 2, 4, 3, _GEANT_PHYSICS_DRPRT_parameters,
 0, 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _GEANT_PHYSICS_DRPRT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_PHYSICS_CUTS_CUTGAM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTGAM = { "CUTGAM", 6,
 "Cut for gammas", "0.001", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTGAM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTELE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTELE = { "CUTELE", 6,
 "Cut for electrons", "0.001", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTELE_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTHAD_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTHAD = { "CUTHAD", 6,
 "Cut for charged hadrons", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTHAD_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTNEU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTNEU = { "CUTNEU", 6,
 "Cut for neutral hadrons", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTNEU_type };
static KmParReal   _GEANT_PHYSICS_CUTS_CUTMUO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_CUTMUO = { "CUTMUO", 6,
 "Cut for muons", "0.01", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_CUTMUO_type };
static KmParReal   _GEANT_PHYSICS_CUTS_BCUTE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_BCUTE = { "BCUTE", 5,
 "Cut for electron brems.", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_BCUTE_type };
static KmParReal   _GEANT_PHYSICS_CUTS_BCUTM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_BCUTM = { "BCUTM", 5,
 "Cut for muon brems.", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_BCUTM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_DCUTE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_DCUTE = { "DCUTE", 5,
 "Cut for electron delta-rays", "-1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_DCUTE_type };
static KmParReal   _GEANT_PHYSICS_CUTS_DCUTM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_DCUTM = { "DCUTM", 5,
 "Cut for muon delta-rays", "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_DCUTM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_PPCUTM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_PPCUTM = { "PPCUTM", 6,
 "Cut for e+e- pairs by muons", "0.01", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_PPCUTM_type };
static KmParReal   _GEANT_PHYSICS_CUTS_TOFMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_TOFMAX = { "TOFMAX", 6,
 "Time of flight cut", "1.E+10", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_CUTS_TOFMAX_type };
static KmParReal   _GEANT_PHYSICS_CUTS_GCUTS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CUTS_GCUTS = { "GCUTS", 5, "5 user words",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GEANT_PHYSICS_CUTS_GCUTS_type };
static KmParameter *_GEANT_PHYSICS_CUTS_parameters[] = {
 &_GEANT_PHYSICS_CUTS_CUTGAM, &_GEANT_PHYSICS_CUTS_CUTELE,
 &_GEANT_PHYSICS_CUTS_CUTHAD, &_GEANT_PHYSICS_CUTS_CUTNEU,
 &_GEANT_PHYSICS_CUTS_CUTMUO, &_GEANT_PHYSICS_CUTS_BCUTE,
 &_GEANT_PHYSICS_CUTS_BCUTM, &_GEANT_PHYSICS_CUTS_DCUTE,
 &_GEANT_PHYSICS_CUTS_DCUTM, &_GEANT_PHYSICS_CUTS_PPCUTM,
 &_GEANT_PHYSICS_CUTS_TOFMAX, &_GEANT_PHYSICS_CUTS_GCUTS };
static char *_GEANT_PHYSICS_CUTS_guidance[] = {
 "To change physics cuts. If no parameter is given, the list",
 "of the current cuts is printed.",
 " If the default values (-1.) for       BCUTE ,BCUTM ,DCUTE ,DCUTM",
 " are not modified, they will be set to CUTGAM,CUTGAM,CUTELE,CUTELE",
 " respectively.", "If one of the parameters from CUTGAM to PPCUTM included",
 "is modified, cross-sections and energy loss tables must be",
 "recomputed via the command 'PHYSI'." };
static KmCommand _GEANT_PHYSICS_CUTS = { &_GEANT_PHYSICS_DRPRT,
 "/GEANT/PHYSICS/CUTS", "CUTS", 0, 2, 12, 0, _GEANT_PHYSICS_CUTS_parameters,
 0, 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_PHYSICS_CUTS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_SYNC_ISYNC_range[] = { "0", "1" };
static KmParInt    _GEANT_PHYSICS_SYNC_ISYNC_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_SYNC_ISYNC = { "ISYNC", 5, "Flag ISYNC",
 "1", (char*)0, 8, 2, _GEANT_PHYSICS_SYNC_ISYNC_range, 2,
 _GEANT_PHYSICS_SYNC_ISYNC_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_SYNC_ISYNC_type };
static KmParameter *_GEANT_PHYSICS_SYNC_parameters[] = {
 &_GEANT_PHYSICS_SYNC_ISYNC };
static char *_GEANT_PHYSICS_SYNC_guidance[] = {
 "To control synchrotron radiation:", " ISYNC=0 no synchrotron radiation;",
 "      =1 synchrotron radiation." };
static KmCommand _GEANT_PHYSICS_SYNC = { &_GEANT_PHYSICS_CUTS,
 "/GEANT/PHYSICS/SYNC", "SYNC", 0, 2, 1, 0, _GEANT_PHYSICS_SYNC_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_SYNC_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_STRA_ISTRA_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_STRA_ISTRA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_STRA_ISTRA = { "ISTRA", 5, "Flag ISTRA",
 "0", (char*)0, 8, 3, _GEANT_PHYSICS_STRA_ISTRA_range, 3,
 _GEANT_PHYSICS_STRA_ISTRA_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_STRA_ISTRA_type };
static KmParameter *_GEANT_PHYSICS_STRA_parameters[] = {
 &_GEANT_PHYSICS_STRA_ISTRA };
static char *_GEANT_PHYSICS_STRA_guidance[] = {
 "To control energy loss fluctuation model:", " ISTRA=0 Urban model;",
 "      =1 PAI model;", "      =2 PAI+ASHO model (not active at the moment)."
 };
static KmCommand _GEANT_PHYSICS_STRA = { &_GEANT_PHYSICS_SYNC,
 "/GEANT/PHYSICS/STRA", "STRA", 0, 2, 1, 0, _GEANT_PHYSICS_STRA_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_STRA_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_RAYL_IRAYL_range[] = { "0", "1" };
static KmParInt    _GEANT_PHYSICS_RAYL_IRAYL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_RAYL_IRAYL = { "IRAYL", 5, "Flag IRAYL",
 "1", (char*)0, 8, 2, _GEANT_PHYSICS_RAYL_IRAYL_range, 2,
 _GEANT_PHYSICS_RAYL_IRAYL_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_RAYL_IRAYL_type };
static KmParameter *_GEANT_PHYSICS_RAYL_parameters[] = {
 &_GEANT_PHYSICS_RAYL_IRAYL };
static char *_GEANT_PHYSICS_RAYL_guidance[] = {
 "To control Rayleigh scattering.", " IRAYL=0 no Rayleigh scattering.",
 "      =1 Rayleigh." };
static KmCommand _GEANT_PHYSICS_RAYL = { &_GEANT_PHYSICS_STRA,
 "/GEANT/PHYSICS/RAYL", "RAYL", 0, 2, 1, 0, _GEANT_PHYSICS_RAYL_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_RAYL_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_PHOT_IPHOT_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_PHOT_IPHOT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_PHOT_IPHOT = { "IPHOT", 5, "Flag IPHOT",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_PHOT_IPHOT_range, 3,
 _GEANT_PHYSICS_PHOT_IPHOT_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_PHOT_IPHOT_type };
static KmParameter *_GEANT_PHYSICS_PHOT_parameters[] = {
 &_GEANT_PHYSICS_PHOT_IPHOT };
static char *_GEANT_PHYSICS_PHOT_guidance[] = { "To control Photo effect.",
 " IPHOT=0 no photo electric effect.",
 "      =1 Photo effect. Electron processed.",
 "      =2 Photo effect. No electron stored." };
static KmCommand _GEANT_PHYSICS_PHOT = { &_GEANT_PHYSICS_RAYL,
 "/GEANT/PHYSICS/PHOT", "PHOT", 0, 2, 1, 0, _GEANT_PHYSICS_PHOT_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_PHOT_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_PFIS_IPFIS_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_PFIS_IPFIS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_PFIS_IPFIS = { "IPFIS", 5, "Flag IPFIS",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_PFIS_IPFIS_range, 3,
 _GEANT_PHYSICS_PFIS_IPFIS_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_PFIS_IPFIS_type };
static KmParameter *_GEANT_PHYSICS_PFIS_parameters[] = {
 &_GEANT_PHYSICS_PFIS_IPFIS };
static char *_GEANT_PHYSICS_PFIS_guidance[] = {
 "To control photo fission mechanism.", " IPFIS=0 no photo fission.",
 "      =1 Photo fission. secondaries processed.",
 "      =2 Photo fission. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_PFIS = { &_GEANT_PHYSICS_PHOT,
 "/GEANT/PHYSICS/PFIS", "PFIS", 0, 2, 1, 0, _GEANT_PHYSICS_PFIS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_PFIS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_PAIR_IPAIR_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_PAIR_IPAIR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_PAIR_IPAIR = { "IPAIR", 5, "Flag IPAIR",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_PAIR_IPAIR_range, 3,
 _GEANT_PHYSICS_PAIR_IPAIR_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_PAIR_IPAIR_type };
static KmParameter *_GEANT_PHYSICS_PAIR_parameters[] = {
 &_GEANT_PHYSICS_PAIR_IPAIR };
static char *_GEANT_PHYSICS_PAIR_guidance[] = {
 "To control pair production mechanism.", " IPAIR=0 no pair production.",
 "      =1 Pair production. secondaries processed.",
 "      =2 Pair production. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_PAIR = { &_GEANT_PHYSICS_PFIS,
 "/GEANT/PHYSICS/PAIR", "PAIR", 0, 2, 1, 0, _GEANT_PHYSICS_PAIR_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_PAIR_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_MUNU_IMUNU_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_MUNU_IMUNU_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_MUNU_IMUNU = { "IMUNU", 5, "Flag IMUNU",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_MUNU_IMUNU_range, 3,
 _GEANT_PHYSICS_MUNU_IMUNU_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_MUNU_IMUNU_type };
static KmParameter *_GEANT_PHYSICS_MUNU_parameters[] = {
 &_GEANT_PHYSICS_MUNU_IMUNU };
static char *_GEANT_PHYSICS_MUNU_guidance[] = {
 "To control muon nuclear interactions.",
 " IMUNU=0 no muon-nuclear interactions.",
 "      =1 Nuclear interactions. Secondaries processed.",
 "      =2 Nuclear interactions. Secondaries not processed." };
static KmCommand _GEANT_PHYSICS_MUNU = { &_GEANT_PHYSICS_PAIR,
 "/GEANT/PHYSICS/MUNU", "MUNU", 0, 2, 1, 0, _GEANT_PHYSICS_MUNU_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_MUNU_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_MULS_IMULS_range[] = { "0", "1", "2", "3" };
static KmParInt    _GEANT_PHYSICS_MULS_IMULS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_MULS_IMULS = { "IMULS", 5, "Flag IMULS",
 "1", (char*)0, 8, 4, _GEANT_PHYSICS_MULS_IMULS_range, 4,
 _GEANT_PHYSICS_MULS_IMULS_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_MULS_IMULS_type };
static KmParameter *_GEANT_PHYSICS_MULS_parameters[] = {
 &_GEANT_PHYSICS_MULS_IMULS };
static char *_GEANT_PHYSICS_MULS_guidance[] = {
 "To control multiple scattering.", " IMULS=0 no multiple scattering.",
 "      =1 Moliere or Coulomb scattering.",
 "      =2 Moliere or Coulomb scattering.", "      =3 Gaussian scattering." };
static KmCommand _GEANT_PHYSICS_MULS = { &_GEANT_PHYSICS_MUNU,
 "/GEANT/PHYSICS/MULS", "MULS", 0, 2, 1, 0, _GEANT_PHYSICS_MULS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5,
 _GEANT_PHYSICS_MULS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_LOSS_ILOSS_range[] = { "0", "1", "2", "3", "4" };
static KmParInt    _GEANT_PHYSICS_LOSS_ILOSS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_LOSS_ILOSS = { "ILOSS", 5, "Flag ILOSS",
 "2", (char*)0, 8, 5, _GEANT_PHYSICS_LOSS_ILOSS_range, 5,
 _GEANT_PHYSICS_LOSS_ILOSS_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_LOSS_ILOSS_type };
static KmParameter *_GEANT_PHYSICS_LOSS_parameters[] = {
 &_GEANT_PHYSICS_LOSS_ILOSS };
static char *_GEANT_PHYSICS_LOSS_guidance[] = { "To control energy loss.",
 " ILOSS=0 no energy loss;", "      =1 restricted energy loss fluctuations;",
 "      =2 complete energy loss fluctuations;", "      =3 same as 1;",
 "      =4 no energy loss fluctuations.",
 "If the value ILOSS is changed, then cross-sections and energy loss",
 "tables must be recomputed via the command 'PHYSI'." };
static KmCommand _GEANT_PHYSICS_LOSS = { &_GEANT_PHYSICS_MULS,
 "/GEANT/PHYSICS/LOSS", "LOSS", 0, 2, 1, 0, _GEANT_PHYSICS_LOSS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _GEANT_PHYSICS_LOSS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_PHYSICS_LABS_LABS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_LABS_LABS = { "LABS", 4, "Flag LABS", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_LABS_LABS_type };
static KmParameter *_GEANT_PHYSICS_LABS_parameters[] = {
 &_GEANT_PHYSICS_LABS_LABS };
static char *_GEANT_PHYSICS_LABS_guidance[] = {
 "To control absorbtion of Cerenkov photons:",
 "    LABS=0 no absorbtion of photons;", "    LABS=1 absorbtion of photons;" };
static KmCommand _GEANT_PHYSICS_LABS = { &_GEANT_PHYSICS_LOSS,
 "/GEANT/PHYSICS/LABS", "LABS", 0, 2, 1, 0, _GEANT_PHYSICS_LABS_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_LABS_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GEANT_PHYSICS_HADR_IHADR_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_HADR_IHADR = { "IHADR", 5, "Flag IHADR",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_HADR_IHADR_type };
static KmParameter *_GEANT_PHYSICS_HADR_parameters[] = {
 &_GEANT_PHYSICS_HADR_IHADR };
static char *_GEANT_PHYSICS_HADR_guidance[] = {
 "To control hadronic interactions.", " IHADR=0 no hadronic interactions.",
 "      =1 Hadronic interactions. secondaries processed.",
 "      =2 Hadronic interactions. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_HADR = { &_GEANT_PHYSICS_LABS,
 "/GEANT/PHYSICS/HADR", "HADR", 0, 2, 1, 0, _GEANT_PHYSICS_HADR_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_HADR_guidance, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GEANT_PHYSICS_ERAN_EKMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_ERAN_EKMIN = { "EKMIN", 5,
 "Minimum energy of the tables", "1E-5", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_ERAN_EKMIN_type };
static KmParReal   _GEANT_PHYSICS_ERAN_EKMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_ERAN_EKMAX = { "EKMAX", 5,
 "Maximum energy of the tables", "1E+4", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GEANT_PHYSICS_ERAN_EKMAX_type };
static KmParInt    _GEANT_PHYSICS_ERAN_NEKBIN_type = { "1", "200", "1", "200",
 0 };
static KmParameter _GEANT_PHYSICS_ERAN_NEKBIN = { "NEKBIN", 6,
 "Number of bins in the tables", "90", (char*)0, 4, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GEANT_PHYSICS_ERAN_NEKBIN_type };
static KmParameter *_GEANT_PHYSICS_ERAN_parameters[] = {
 &_GEANT_PHYSICS_ERAN_EKMIN, &_GEANT_PHYSICS_ERAN_EKMAX,
 &_GEANT_PHYSICS_ERAN_NEKBIN };
static char *_GEANT_PHYSICS_ERAN_guidance[] = {
 "To define the range and binning of internal tables." };
static KmCommand _GEANT_PHYSICS_ERAN = { &_GEANT_PHYSICS_HADR,
 "/GEANT/PHYSICS/ERAN", "ERAN", 0, 2, 3, 0, _GEANT_PHYSICS_ERAN_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GEANT_PHYSICS_ERAN_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_DRAY_IDRAY_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_DRAY_IDRAY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DRAY_IDRAY = { "IDRAY", 5, "Flag IDRAY",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_DRAY_IDRAY_range, 3,
 _GEANT_PHYSICS_DRAY_IDRAY_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_DRAY_IDRAY_type };
static KmParameter *_GEANT_PHYSICS_DRAY_parameters[] = {
 &_GEANT_PHYSICS_DRAY_IDRAY };
static char *_GEANT_PHYSICS_DRAY_guidance[] = {
 "To control delta rays mechanism.", " IDRAY=0 no delta rays.",
 "      =1 Delta rays. secondaries processed.",
 "      =2 Delta rays. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_DRAY = { &_GEANT_PHYSICS_ERAN,
 "/GEANT/PHYSICS/DRAY", "DRAY", 0, 2, 1, 0, _GEANT_PHYSICS_DRAY_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_DRAY_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_DCAY_IDCAY_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_DCAY_IDCAY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_DCAY_IDCAY = { "IDCAY", 5, "Flag IDCAY",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_DCAY_IDCAY_range, 3,
 _GEANT_PHYSICS_DCAY_IDCAY_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_DCAY_IDCAY_type };
static KmParameter *_GEANT_PHYSICS_DCAY_parameters[] = {
 &_GEANT_PHYSICS_DCAY_IDCAY };
static char *_GEANT_PHYSICS_DCAY_guidance[] = { "To control Decay mechanism.",
 " IDCAY=0 no decays.", "      =1 Decays. secondaries processed.",
 "      =2 Decays. No secondaries stored." };
static KmCommand _GEANT_PHYSICS_DCAY = { &_GEANT_PHYSICS_DRAY,
 "/GEANT/PHYSICS/DCAY", "DCAY", 0, 2, 1, 0, _GEANT_PHYSICS_DCAY_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_DCAY_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_COMP_ICOMP_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_COMP_ICOMP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_COMP_ICOMP = { "ICOMP", 5, "Flag ICOMP",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_COMP_ICOMP_range, 3,
 _GEANT_PHYSICS_COMP_ICOMP_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_COMP_ICOMP_type };
static KmParameter *_GEANT_PHYSICS_COMP_parameters[] = {
 &_GEANT_PHYSICS_COMP_ICOMP };
static char *_GEANT_PHYSICS_COMP_guidance[] = {
 "To control Compton scattering", " ICOMP=0 no Compton",
 "      =1 Compton. Electron processed.",
 "      =2 Compton. No electron stored." };
static KmCommand _GEANT_PHYSICS_COMP = { &_GEANT_PHYSICS_DCAY,
 "/GEANT/PHYSICS/COMP", "COMP", 0, 2, 1, 0, _GEANT_PHYSICS_COMP_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_COMP_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_CKOV_ICKOV_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_CKOV_ICKOV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_CKOV_ICKOV = { "ICKOV", 5, "Flag ICKOV",
 "0", (char*)0, 8, 3, _GEANT_PHYSICS_CKOV_ICKOV_range, 3,
 _GEANT_PHYSICS_CKOV_ICKOV_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_CKOV_ICKOV_type };
static KmParameter *_GEANT_PHYSICS_CKOV_parameters[] = {
 &_GEANT_PHYSICS_CKOV_ICKOV };
static char *_GEANT_PHYSICS_CKOV_guidance[] = {
 "To control Cerenkov production", " ICOMP=0 no Cerenkov;",
 "      =1 Cerenkov;", "      =2 Cerenkov with primary stopped at each step."
 };
static KmCommand _GEANT_PHYSICS_CKOV = { &_GEANT_PHYSICS_COMP,
 "/GEANT/PHYSICS/CKOV", "CKOV", 0, 2, 1, 0, _GEANT_PHYSICS_CKOV_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_CKOV_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_BREM_IBREM_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_BREM_IBREM_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_BREM_IBREM = { "IBREM", 5, "Flag IBREM",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_BREM_IBREM_range, 3,
 _GEANT_PHYSICS_BREM_IBREM_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_BREM_IBREM_type };
static KmParameter *_GEANT_PHYSICS_BREM_parameters[] = {
 &_GEANT_PHYSICS_BREM_IBREM };
static char *_GEANT_PHYSICS_BREM_guidance[] = { "To control bremstrahlung.",
 " IBREM=0 no bremstrahlung", "      =1 bremstrahlung. Photon processed.",
 "      =2 bremstrahlung. No photon stored." };
static KmCommand _GEANT_PHYSICS_BREM = { &_GEANT_PHYSICS_CKOV,
 "/GEANT/PHYSICS/BREM", "BREM", 0, 2, 1, 0, _GEANT_PHYSICS_BREM_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_BREM_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_AUTO_IAUTO_range[] = { "0", "1" };
static KmParInt    _GEANT_PHYSICS_AUTO_IAUTO_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_AUTO_IAUTO = { "IAUTO", 5, "Flag IAUTO",
 "1", (char*)0, 8, 2, _GEANT_PHYSICS_AUTO_IAUTO_range, 2,
 _GEANT_PHYSICS_AUTO_IAUTO_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_AUTO_IAUTO_type };
static KmParameter *_GEANT_PHYSICS_AUTO_parameters[] = {
 &_GEANT_PHYSICS_AUTO_IAUTO };
static char *_GEANT_PHYSICS_AUTO_guidance[] = {
 "To control automatic calculation of tracking medium parameters:",
 " IAUTO=0 no automatic calculation;", "      =1 automati calculation." };
static KmCommand _GEANT_PHYSICS_AUTO = { &_GEANT_PHYSICS_BREM,
 "/GEANT/PHYSICS/AUTO", "AUTO", 0, 2, 1, 0, _GEANT_PHYSICS_AUTO_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _GEANT_PHYSICS_AUTO_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_ANNI_IANNI_range[] = { "0", "1", "2" };
static KmParInt    _GEANT_PHYSICS_ANNI_IANNI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GEANT_PHYSICS_ANNI_IANNI = { "IANNI", 5, "Flag IANNI",
 "1", (char*)0, 8, 3, _GEANT_PHYSICS_ANNI_IANNI_range, 3,
 _GEANT_PHYSICS_ANNI_IANNI_range, (KmParFlag)0, KmTYPE_INT,
 &_GEANT_PHYSICS_ANNI_IANNI_type };
static KmParameter *_GEANT_PHYSICS_ANNI_parameters[] = {
 &_GEANT_PHYSICS_ANNI_IANNI };
static char *_GEANT_PHYSICS_ANNI_guidance[] = {
 "To control positron annihilation.", " IANNI=0 no annihilation",
 "      =1 annihilation. Decays processed.",
 "      =2 annihilation. No decay products stored." };
static KmCommand _GEANT_PHYSICS_ANNI = { &_GEANT_PHYSICS_AUTO,
 "/GEANT/PHYSICS/ANNI", "ANNI", 0, 2, 1, 0, _GEANT_PHYSICS_ANNI_parameters, 0,
 0, gxphys_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GEANT_PHYSICS_ANNI_guidance, 0, (char**)0, (char*)0, (int*)0 };

static char *_GEANT_PHYSICS_guidance[] = {
 "Commands to set physics parameters." };
static KmMenu _GEANT_PHYSICS = {  (KmMenu*)0,  (KmMenu*)0, "/GEANT/PHYSICS",
 "PHYSICS", 2, &_GEANT_PHYSICS_ANNI, 1, _GEANT_PHYSICS_guidance };

static KmMenu _GEANT = {  (KmMenu*)0, &_GEANT_PHYSICS, "/GEANT", "GEANT", 1,
 (KmCommand*)0, 0, (char**)0 };

  klnkmenu( &_GEANT, 921023 );
}


#ifdef F77_LCASE
#  define gkfort_ gkfort
#  define gxfort_ gxfort
#endif

#ifdef F77_UCASE
#  define gkfort_ GKFORT
#  define gxfort_ GXFORT
#endif

#ifdef IBM370
#  pragma linkage(GKFORT,FORTRAN)
#  pragma linkage(GXFORT,FORTRAN)
#endif

extern void gkfort_();
extern void gxfort_();

void gkfort_()
{

static KmParameter _FORTRAN_FORTRAN_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_FORTRAN_FORTRAN_parameters[] = { &_FORTRAN_FORTRAN_FNAME
 };
static char *_FORTRAN_FORTRAN_guidance[] = {
 "The routines in the file FNAME will be compiled by COMIS.",
 "If routines with names: UGEOM,GUKINE,GUOUT,UGLAST are found,",
 "then they will be automatically called by GXINT instead of",
 "the routines with the same names compiled with the standard",
 "Fortran compiler and linked with the application.",
 "The user callable routines from the GEANT library as well as",
 "routines from PACKLIB (HBOOK,HPLOT,HIGZ,ZEBRA) may be called",
 "from these user routines. All GEANT common blocks may be", "referenced.",
 "In case where the routine UGEOM is called several times,",
 "it is important to DROP all the initialisation data structures",
 "JVOLUM,JMATE,JTMED,etc already in memory by using the routine GIDROP.",
 " Example of an interactive session where the routine UGEOM is modified:",
 "", "   GEANT > Edit ugeom.for", "   GEANT > Fortran ugeom.for",
 "   GEANT > Call GIDROP", "   GEANT > Call UGEOM", "   GEANT > Dtree",
 "   GEANT > Edit ugeom.for", "   GEANT > Fortran ugeom.for",
 "   GEANT > Call GIDROP", "   GEANT > Call UGEOM", "   GEANT > Dtree",
 "If FNAME='-', calls to user routines is reset and standard",
 "routines called instead." };
static KmCommand _FORTRAN_FORTRAN = {  (KmCommand*)0, "/FORTRAN/FORTRAN",
 "FORTRAN", 0, 1, 1, 1, _FORTRAN_FORTRAN_parameters, 0, 0, gxfort_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 26, _FORTRAN_FORTRAN_guidance, 0,
 (char**)0, (char*)0, (int*)0 };

static KmMenu _FORTRAN = {  (KmMenu*)0,  (KmMenu*)0, "/FORTRAN", "FORTRAN", 1,
 &_FORTRAN_FORTRAN, 0, (char**)0 };

  klnkmenu( &_FORTRAN, 921023 );
}

+SELF.
+DECK,  G321X_CDF_D, T=DATA, IF=DOC.
*
* $Id: geanx321.car100,v 1.1.1.1 2003/04/24 14:25:08 tretiak Exp $
*
* $Log: geanx321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:08  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:40  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.35  by  S.Giani
*-- Author :
>Menu GEANT
>Guidance
GEANT specific commands.

>Name GKDRAW

>Menu /GEANT/CVOL
>Guidance
Clipping commands.
The hidden line removal technique is necessary to visualize properly
very complex detectors. At the same time, it can be useful to visualize
the inner elements of a detector in detail. For this purpose, the
commands menu CVOL has been developed: these commands allow
subtractions (via boolean operation) of given shapes from any part of
the detector, therefore showing its inner contents. It is possible
to clip each different volume by means of a different shape (BOX ,
TUBE, CONE, SPHE are available). If '*' is given as the name of the
volume to be clipped, all volumes are clipped by the given shape.
A volume can be clipped at most twice (even by
different shapes); if a volume is explicitely clipped
twice, the '*' will not act on it anymore. Giving '.' as the name
of the volume to be clipped will reset the clipping.

>Command BOX
>Parameters
CNNV  ' Name of volume to be clipped          ' C  D='*   '
+
XMIN  ' Lower limit of the Shape X coordinate ' R  D=-10000.
XMAX  ' Upper limit of the Shape X coordinate ' R  D=-9999.
YMIN  ' Lower limit of the Shape Y coordinate ' R  D=-10000.
YMAX  ' Upper limit of the Shape Y coordinate ' R  D=-9999.
ZMIN  ' Lower limit of the Shape Z coordinate ' R  D=-10000.
ZMAX  ' Upper limit of the Shape Z coordinate ' R  D=-9999.
>Guidance
This command performs a boolean subtraction between the volume
CNVV and a box placed in the MARS according the values of the given
coordinates. See also CVOL.
The following commands will clip by a box,
with a vertex at the origin, the volume specified by NAME (a valid
string for the NAME of the volume can be found using the DTREE command).
 EXAMPLE -
 dopt hide on
 satt * seen -2
 draw NAME 40 40 0 10 10 .01 .01
 next
 box NAME 0 1000 0 1000 0 1000
 draw NAME 40 40 0 10 10 .01 .01
 box .

>Action GXDRAW

>Command TUBE
>Parameters
CNVV  ' Name of volume to be clipped          ' C  D='*   '
+
RMAX  ' External radius of tube               ' R  D=0.1
ZDEM  ' Half length of tube axis              ' R  D=0.1
XMED  ' Center X coordinate                   ' R  D=-10000.
YMED  ' Center Y coordinate                   ' R  D=-10000.
ZMED  ' Center Z coordinate                   ' R  D=-10000.
>Guidance
This command performs a boolean subtraction between the volume
CNVV and a tube; the tube has the given parameters and is placed in
the MARS according the given coordinates of its center.
See also CVOL.
The following commands will clip, by a tube,
positioned according to the given parameters, the volume specified
by NAME (a valid string for the NAME of the volume
can be found using the DTREE command).
 EXAMPLE -
 dopt hide on
 satt * seen -2
 draw NAME 40 40 0 10 10 .01 .01
 next
 tube * 500 1000 500 0 0
 draw NAME 40 40 0 10 10 .01 .01
 box .

>Action GXDRAW

>Command CONE
>Parameters
CNVV  ' Name of volume to be clipped          ' C  D='*   '
+
RMAX1 ' Min external radius                   ' R  D=0.1
RMAX2 ' Max external radius                   ' R  D=0.1
ZDEM  ' Half length of cone axis              ' R  D=0.1
XMED  ' Center X coordinate                   ' R  D=-10000.
YMED  ' Center Y coordinate                   ' R  D=-10000.
ZMED  ' Center Z coordinate                   ' R  D=-10000.
>Guidance
This command performs a boolean subtraction between the volume
CNVV and a cone; the cone has the given parameters and is placed in
the MARS according to the given coordinates of its center.
See also CVOL.
The following commands will clip by a cone,
positioned according the given parameters, the volume specified
by NAME (a valid string for the NAME of the volume
can be found using the DTREE command).
 EXAMPLE -
 dopt hide on
 satt * seen -2
 draw NAME 40 40 0 10 10 .01 .01
 next
 cone * 1 750 1000 0 0 1000
 draw NAME 40 40 0 10 10 .01 .01
 box .

>Action GXDRAW

>Command SPHE
>Parameters
CNVV  ' Name of volume to be clipped          ' C  D='*   '
+
RMAX  ' External radius of sphere             ' R  D=0.1
XMED  ' Center X coordinate                   ' R  D=-10000.
YMED  ' Center Y coordinate                   ' R  D=-10000.
ZMED  ' Center Z coordinate                   ' R  D=-10000.
>Guidance
This command performs a boolean subtraction between the volume
CNVV and a sphere; the sphere has the given parameters and is placed in
the MARS according to the given coordinates of its center.
See also CVOL. The following commands clip by a sphere,
positioned according to the given parameters, the volume specified
by NAME (a valid string for the NAME of the volume
can be found using the DTREE command).
EXAMPLE -
 dopt hide on
 satt * seen -2
 draw NAME 40 40 0 10 10 .01 .01
 next
 sphe * 500 0 0 500
 draw NAME 40 40 0 10 10 .01 .01
 box .

>Action GXDRAW

>Command VALCUT
>Parameters
XCUT 'x coordinate of cutted value' R D=0.
YCUT 'y coordinate of cutted value' R D=0.
ZCUT 'z coordinate of cutted value' R D=0.
>Guidance
It allows the cutting in the ray-tracing. All the volumes are cutted
from XCUT to +BIG along the x axis, from YCUT to +BIG along the y axis
and from ZCUT to +BIG along the z axis.

>Action GXDRAW

>Menu /GEANT/DRAWING
>Guidance
Drawing commands. These commands allow the visualization in several ways
of the volumes defined in the geometrical data structure. It is possible
to draw the logical tree of volumes belonging to the detector (DTREE),
to show their geometrical specification (DSPEC,DFSPC), to draw them
and their cut views (DRAW, DCUT). Moreover, it is possible to execute
these commands when the hidden line removal option is activated; in
this case, the volumes can be also either translated in the space
(SHIFT), or clipped by boolean operation (CVOL). In addition, it is
possible to fill the surfaces of the volumes
with solid colours when the shading option (SHAD) is activated.
Several tools (ZOOM, LENS) have been developed to zoom detailed parts
of the detectors or to scan physical events as well.
Finally, the command MOVE will allow the rotation, translation and zooming
on real time parts of the detectors or tracks and hits of a simulated event.
Ray-tracing commands. In case the command (DOPT RAYT ON) is executed,
the drawing is performed by the Geant ray-tracing;
automatically, the color is assigned according to the tracking medium of each
volume and the volumes with a density lower/equal than the air are considered
transparent; if the option (USER) is set (ON) (again via the command (DOPT)),
the user can set color and visibility for the desired volumes via the command
(SATT), as usual, relatively to the attributes (COLO) and (SEEN).
The resolution can be set via the command (SATT * FILL VALUE), where (VALUE)
is the ratio between the number of pixels drawn and 20 (user coordinates).
Parallel view and perspective view are possible (DOPT PROJ PARA/PERS); in the
first case, we assume that the first mother volume of the tree is a box with
dimensions 10000 X 10000 X 10000 cm and the view point (infinetely far) is
5000 cm far from the origin along the Z axis of the user coordinates; in the
second case, the distance between the observer and the origin of the world
reference system is set in cm by the command (PERSP NAME VALUE); grand-angle
or telescopic effects can be achieved changing the scale factors in the command
(DRAW). When the final picture does not occupy the full window,
mapping the space before tracing can speed up the drawing, but can also
produce less precise results; values from 1 to 4 are allowed in the command
(DOPT MAPP VALUE), the mapping being more precise for increasing (VALUE); for
(VALUE = 0) no mapping is performed (therefore max precision and lowest speed).
The command (VALCUT) allows the cutting of the detector by three planes
ortogonal to the x,y,z axis. The attribute (LSTY) can be set by the command
SATT for any desired volume and can assume values from 0 to 7; it determines
the different light processing to be performed for different materials:
0 = dark-matt, 1 = bright-matt, 2 = plastic, 3 = ceramic, 4 = rough-metals,
5 = shiny-metals, 6 = glass, 7 = mirror. The detector is assumed to be in the
dark, the ambient light luminosity is 0.2 for each basic hue (the saturation
is 0.9) and the observer is assumed to have a light source (therefore he will
produce parallel light in the case of parallel view and point-like-source
light in the case of perspective view).

>Command DRAW
>Parameters
NAME   'Volume name' C
+
THETA  'Viewing angle theta (for 3D projection)' R R=0.:180.
PHI    'Viewing angle phi (for 3D projection)' R R=0.:360.
PSI    'Viewing angle psi (for 2D rotation)' R R=0.:360.
U0     'U-coord. (horizontal) of volume origin' R
V0     'V-coord. (vertical) of volume origin' R
SU     'Scale factor for U-coord.' R
SV     'Scale factor for V-coord.' R
>Guidance
 CALL GDRAW(name,theta,phi,psi,u0,v0,su,sv)
If optional parameters are missing, the corresponding values are
taken from the common /GCDRAW/. This command will draw the volumes,
selected with their graphical attributes, set by the SATT
facility. The drawing may be performed with hidden line removal
and with shading effects according to the value of the options HIDE
and SHAD; if the option SHAD is ON, the contour's edges can be
drawn or not. If the option HIDE is ON, the detector can be
exploded (BOMB), clipped with different shapes (CVOL), and some
of its parts can be shifted from their original
position (SHIFT). When HIDE is ON, if
the drawing requires more than the available memory, the program
will evaluate and display the number of missing words
(so that the user can increase the
size of its ZEBRA store). Finally, at the end of each drawing (with HIDE on),
the program will print messages about the memory used and
statistics on the volumes' visibility.
The following commands will produce the drawing of a green
volume, specified by NAME, without using the hidden line removal
technique, using the hidden line removal technique,
with different linewidth and colour (red), with
solid colour, with shading of surfaces, and without edges.
Finally, some examples are given for the ray-tracing. (A possible
string for the NAME of the volume can be found using the command DTREE).
 EXAMPLE -
 satt * seen -2
 satt NAME colo 3
 draw NAME 40 40 0 10 10 .01 .01
 next
 dopt hide on
 draw NAME 40 40 0 10 10 .01 .01
 next
 satt NAME colo 2
 satt NAME lwid 4
 draw NAME 40 40 0 10 10 .01 .01
 next
 dopt shad on
 satt * lwid 1
 satt NAME fill 1
 draw NAME 40 40 0 10 10 .01 .01
 next
 satt NAME fill 3
 draw NAME 40 40 0 10 10 .01 .01
 next
 dopt edge off
 draw NAME 40 40 0 10 10 .01 .01
 dopt rayt on
 satt * fill 20
 dopt mapp 1
 draw NAME 40 40 0 10 10 .01 .01
 dopt proj pers
 persp NAME 500
 draw NAME 40 40 0 10 10 1 1
 valcut 100 100 100
 dopt mapp 0
 dopt user on
 satt NAM1 seen 0
 satt NAM2 colo 2
 draw NAME 40 40 0 10 10 5 5

>Action GXDRAW

>Command SPOT
>Parameters
XLPOS 'x coordinate of light source' R
YLPOS 'y coordinate of light source' R
ZLPOS 'z coordinate of light source' R
INTEN 'intensity of light source' I
>Guidance
This point-like light source can be moved in the space and its intensity
can be changed (INTEN going from 0 to 10) relatively to the ambience light.
>Action GXDRAW

>Command VAR5D
>Parameters
TSEQTO 'total sequential time' R
NPROC  'number of processors' I
NMPTOT 'number of message passing' I
TOTMBY 'total megabytes transfert' R
TSEQ   'not parallelized code' R
TLAT   'latency time' R
TNET   'network speed in Mbytes/sec' R
>Guidance
It sets the values of the parameters expressed in the formula and
specify which variables must be assumed as x,y,z (setting their value
to 1001,1002,1003, respectively).
>Action GXDRAW

>Command RANG5D
>Parameters
X1MIN 'x coordinate min' R
X1MAX 'x coordinate max' R
Y1MIN 'y coordinate min' R
Y1MAX 'y coordinate max' R
Z1MIN 'z coordinate min' R
Z1MAX 'z coordinate max' R
>Guidance
It sets the range for the x,y,z variables.
>Action GXDRAW

>Command DVOLUME
>Parameters
N      'Number of elements in arrays LNAMES and LNUMBS' I D=1
NAMNUM 'Volume names and numbers (ex. "NAME1,NR1,NAME2,NR2")' C
CHNRS    'Reference system used' C D='MARS' R='MARS,DRS'
+
THETA  'Viewing angle theta (for 3D projection)' R R=0.:360.
PHI    'Viewing angle phi (for 3D projection)' R R=0.:360.
PSI    'Viewing angle psi (for 2D rotation)' R R=0.:180.
U0     'U-coord. (horizontal) of volume origin' R
V0     'V-coord. (vertical) of volume origin' R
SU     'Scale factor for U-coord.' R
SV     'Scale factor for V-coord.' R
>Guidance
 CALL GDRVOL(n,lnames,lnumbs,nrs,theta,phi,psi,u0,v0,su,sv)
N is the number of levels from the top of the geometry structure
to the volume lnames(n),lnumbs(n) to be drawn.
NAMNUM contain the arrays lnames and lnumbs,
identifying the path, in pairs and separated by commas; for
example (with n=2) :
'lname(1),lnumbs(1),lname(2),lnumbs(2) '
CHNRS is the name of the reference system used: MARS for MAster Reference
System or DRS for Daughter Reference System.
NRS=0 for MARS or NRS<>0 for DRS
If optional parameters are missing, the current values in /GCDRAW/
are taken.
>Action GXDRAW

>Command DCUT
>Parameters
NAME   'Volume name' C
CAXIS  'Axis value' C R='X,Y,Z'
CUTVAL 'Cut plane distance from the origin along the axis' R
+
U0     'U-coord. (horizontal) of volume origin' R
V0     'V-coord. (vertical) of volume origin' R
SU     'Scale factor for U-coord.' R
SV     'Scale factor for V-coord.' R
>Guidance
 CALL GDRAWC(name,iaxis,cutval,u0,v0,su,sv)
The cut plane is normal to caxis (X,Y,Z), corresponding to iaxis (1,2,3),
and placed at the distance cutval from the origin.
The resulting picture is seen from the the same axis.
If optional parameters are missing, the current values in /GCDRAW/
are taken.
When HIDE Mode is ON, it is possible to get the same effect with
the CVOL/BOX command.
>Action GXDRAW

>Command DXCUT
>Parameters
NAME   'Volume name' C
CUTTHE 'Theta angle of the line normal to cut plane' R R=0.:360.
CUTPHI 'Phi angle of the line normal to cut plane' R R=0.:360.
CUTVAL 'Cut plane distance from the origin along the axis' R
+
THETA  'Viewing angle theta (for 3D projection)' R R=0.:360.
PHI    'Viewing angle phi (for 3D projection)' R R=0.:360.
U0     'U-coord. (horizontal) of volume origin' R
V0     'V-coord. (vertical) of volume origin' R
SU     'Scale factor for U-coord.' R
SV     'Scale factor for V-coord.' R
>Guidance
 CALL GDRAWX(name,cutthe,cutphi,cutval,theta,phi,u0,v0,su,sv)
The cut plane is normal to the line given by the cut angles
cutthe and cutphi and placed at the distance cutval from the origin.
The resulting picture is seen from the viewing angles theta,phi.
If optional parameters are missing, the current values in /GCDRAW/
are taken.
>Action GXDRAW

>Command SHIFT
>Parameters
CNVN  ' Name of volume to be shifted        ' C  D='*'
XXXX  ' Shift along X axis                  ' R  D=0.
YYYY  ' Shift along Y axis                  ' R  D=0.
ZZZZ  ' Shift along Z axis                  ' R  D=0.
>Guidance
To draw a volume shifted from its initial position when hidden
line removal is ON. It can be useful if you want to extract a
volume or some volumes from the detector to show them more clearly.
The last requested SHIFT for each volume
NAME is performed. Moreover, the SHIFT of
each volume will be performed starting from where its mother has
been shifted, so that it's easier to SHIFT nicely sets
of volumes using the mother-daughter relationships.
If '.' is given as the name of the volume
to be shifted, the shifts for all volumes will be reset.
The following commands will produce the translation along
the Z-axis of the previously drawn volume:
 EXAMPLE -
 dopt hide on
 satt * seen -2
 draw NAME 40 40 0 10 10 .01 .01
 shift NAME 0 0 10

>Action GXDRAW

>Command BOMB
>Parameters
BOOM  ' Exploding factor for volumes position ' R  D=0. R=-10.:10.
>Guidance
To 'explode' the detector. If BOOM is positive (values smaller
than 1. are suggested, but any value is possible)
all the volumes are shifted by a distance
proportional to BOOM along the direction between their centre
and the origin of the MARS; the volumes which are symmetric
with respect to this origin are simply not shown.
BOOM equal to 0 resets the normal mode.
A negative (greater than -1.) value of
BOOM will cause an 'implosion'; for even lower values of BOOM
the volumes' positions will be reflected respect to the origin.
This command can be useful to improve the 3D effect for very
complex detectors. The following commands will make explode the
detector:
 EXAMPLE -
 dopt hide on
 satt * seen 1
 draw NAME 40 40 0 10 10 .01 .01
 bomb 1
 next
 draw NAME 40 40 0 10 10 .01 .01

>Action GXDRAW

>Command DTREE
>Parameters
+
NAME   'Volume name' C D=' '
LEVMAX 'Depth level' I D=3 R=-15:15
ISELT  'Options    ' I D=111
>Guidance
This command allows the drawing of the logical tree,
displaying the name, the multiplicity and other information about the volumes,
via a call to GDTREE(name,levmax,isel):
if the third parameter is not given (default), the command will
produce the drawing of the tree displaying, for each volume, the
number of the following levels (red arrows) and of the preceeding
levels (green arrows); then the control is automatically given to the
mouse: clicking on the left button when the cursor is inside a volume's
pave will perform a DSPEC for that volume; doing the same when the cursor
is on a red arrow, will perform a DTREE for the relative volume (the
number of levels displayed depending on the clicked arrow); doing the
same for the 'i-th' green arrow of a given volume, will perform a DTREE
for its mother-volume staying 'i' levels before.
If running with X-windows, the drawing of the specification (DSPEC)
is performed
in a different window to speed up the scanning of the tree.
Iterating this procedure it is possible to analyse very easily and quickly
any kind of tree. Clicking the right button of the mouse will return
the control to the command mode.
If the ISELT parameter is given,
then the TREE will work as in the
previous version, with ISELT up to 10001.
The following command will perform a drawing of the tree and give the
control to the user via the mouse:
 EXAMPLE -
 dtree NAME 3

>Action GXDRAW

>Command DSPEC
>Parameters
NAME   'Volume name' C
>Guidance
Trough a call to GDSPEC(name), this command allows one to show three
views of the volume (two cut-views and a 3D view), together with
its geometrical specifications. The 3D drawing will
be performed according the current values of the options HIDE and
SHAD and according the current CVOL clipping parameters for that
volume.
>Action GXDRAW

>Command D3DSPEC
>Parameters
NAME   'Volume name' C
+
TETA3  'Theta angle' R D=40. R=0.:180.
PHI3   'Phi angle'   R D=40. R=0.:360.
PSI3   'Psi angle'   R D=0.  R=0.:360.
U03    'U-coord. (horizontal) of volume origin' R D=10. R=-40.:40.
V03    'V-coord. (vertical) of volume origin' R D=10. R=-40.:40.
ZM3    'Zoom factor for current size factors' R D=1. R=0.00001:10.
>Guidance
Trough a call to GSPE3D, this command allows one to show
the volume (3D views in real time), together with
its geometrical specifications (if using MOTIF). The 3D drawing will
be performed according the current values of the options HIDE and
SHAD and according the current CVOL clipping parameters for that
volume.
>Action GXDRAW

>Command DFSPC
>Parameters
NAME   'Volume name' C
+
CSORT  'Alphabetic sorting flag' C D='N' R='Y,N,0,1'
CINTER 'Interactive/Batch version' C D='I' R='I,B,0,1'
>Guidance
 CALL GDFSPC(name,isort,inter)
Same as DSPEC, but it will draw the specifications for all the volumes.
If the alphabetic sorting flag is YES, all pictures will be drawn in ascending
alphabetic order; isort is set to 1.
If INTERACTIVE, (inter=1), the routine will prompt the user at each plot
before doing a clear screen, otherwise it will clear automatically
the screen before starting a new frame.
>Action GXDRAW

>Command DTEXT
>Parameters
X0     'X-coord. (horizontal) of text string' R D=10. R=0.:20.
Y0     'Y-coord. (vertical) of text string' R D=10. R=0.:20.
TEXT   'Text string' C D='GEANT'
SIZE   'Character size (cm)' R D=.5
ANGLE  'Rotation angle (deg)' R D=0. R=0.:360.
LWID   'Line width' I D=4
CENT   'Centering option' C D='CENT' R='CENT,LEFT,RIGH'
>Guidance
 CALL GDRAWT(x0,y0,text,size,angle,lwid,opt)
It allows one to draw some text in the current picture.
Now more than 160 colours are available. The text colour
must be set via the command IGSET. The size of the
text will follow the zooming factors in the view banks.
>Action GXDRAW

>Command DVECTOR
>Parameters
XVECT  'Vector containing X-coord. (horizontal)' C
YVECT  'Vector containing Y-coord. (vertical)' C
NPOINT 'Number of coord.' I
>Guidance
Draw a polyline of 'npoint' point via
a call to GDRAWV(xvect,yvect,npoint)
where xvect and yvect are two KUIP vectors
>Action GXDRAW

>Command DSCALE
>Parameters
U      'U-coord. (horizontal) of the centre of scale' R
V      'V-coord. (vertical) of the centre of scale' R
>Guidance
 CALL GDSCAL(u,v)
It draws a scale centered in U,V.
>Action GXDRAW

>Command DAXIS
>Parameters
X0     'X-coord. of axis origin' R
Y0     'Y-coord. of axis origin' R
Z0     'Z-coord. of axis origin' R
DX     'Axis size' R
>Guidance
 CALL GDAXIS(x0,y0,z0,dx)
This commmand superimposes the axis of the MARS on the
current picture. It is useful for finding immediately the
orientation of the current drawing of the detector in the space.
>Action GXDRAW

>Command DMAN
>Parameters
U      'U-coord. (horizontal) of the centre of man' R
V      'V-coord. (vertical) of the centre of man' R
TYPE   'Man, Wm1, Wm2, Wm3' C D='MAN' R='MAN,WM1,WM2,WM3'
>Guidance
 CALL GDMAN(u,v),CALL GDWMN1(u,v),CALL GDWMN2(u,v),CALL GDWMN2(u,v)
It superimposes the picure of a man or of a woman, chosen among
three different ones, with the same scale factors as the detector
in the current drawing.
>Action GXDRAW

>Command DHEAD
>Parameters
+
ISEL   'Option flag' I D=111110
NAME   'Title' C D=' '
CHRSIZ 'Character size (cm) of title NAME' R D=0.6
>Guidance
 CALL GDHEAD(isel,name,chrsiz)
ISEL =
 0      to have only the header lines
 xxxxx1 to add the text name centered on top of header
 xxxx1x to add global detector name (first volume) on left
 xxx1xx to add date on right
 xx1xxx to select thick characters for text on top of header
 x1xxxx to add the text 'EVENT NR x' on top of header
 1xxxxx to add the text 'RUN NR x' on top of header
NOTE that ISEL=x1xxx1 or ISEL=1xxxx1 are illegal choices,
i.e. they generate overwritten text.
NAME is the title
and CHRSIZ the character size in cm of text name.
>Action GXDRAW

>Command MEASURE
>Guidance
Position the cursor on the first point (u1,v1) and hit the space bar(GKS).
Position the cursor on the second point (u2,v2) and hit the space bar(GKS).
Clicking the left button of the mouse (X11) will have the same effect as
hiting the space bar (GKS).
The command will compute and print the distance in space separating
the two points on the projection view. It can be useful to measure
distances either between volumes or between tracks or hits.
>Action GXDRAW

>Command PICK
>Parameters
>Guidance
Activates graphic input to identify detector elements
in a cut view. Clicking on the left button of the mouse when
the cursor is in a given point of the drawing and clicking again
(outside the detector) will produce the following effect:
a line joininig the two points will be drawn together with
the name and the medium number of the volume picked
with the first clicking close to the second point.
>Action GXPICK

>Command MOVE
>Parameters
NAME   'Volume name' C D='    '
+
NOPT   'S=sample mode,T=tracks,H=hits' C D='    '
>Guidance
Positioning some daughter volumes inside a 'mother', it can be
important to check if overlaps between such volumes have occurred.
Instead of putting the drawing in a view bank, zooming, and iterating
the process for different viewing angles of the same detector, the
MOVE facility has been developed (for machines running with X11):
it is sufficient to draw a view of the volumes to be analysed (after
setting the proper SEEN, COLO, etc. attributes) and then to enter
'MOVE' followed by the same 'NAME' used for the last command DRAW.
The detector will appear in a panel with five buttons at the
bottom: THETA, PHI, TRASL, ZOOM, OFF. Clicking on the left button
of the mouse, when the cursor is inside the THETA area, will rotate the
detector along the polar angle theta according to the
backward-to-forward movement of the mouse
(clicking up and down the left button if
not in sample mode); clicking on the right button of
the mouse will stop the rotation; clicking now on the
left button of the mouse when inside the PHI area will activate a
rotation along the polar angle phi. In the same way, activating the
TRASL button, the detector can be translated in the u,v plane
of the screen according to the 2D-movement of the mouse. Finally,
activating the ZOOM button, the detector will be zoomed (or unzoomed)
according to the backward-to-forward movement of the mouse. Clicking on the
OFF button will return the control to the 'command mode'. The MOVE
command will work also with hidden line removal and shading options
(when SHAD is on the background will be black);
moreover, if the volumes are clipped, exploded, shifted, etc., they
will be 'MOVED' with these features as well.
Tracks and hits of a previously stored physical event can be moved
together with the detector, allowing a dynamical 3-D analysis of the
simulated events. Clicking the central button of the mouse when a good
view of the event is found, will stop any movement and the mouse will
allow the normal picking capabilities first for the tracks and then for
the hits. After clicking of the right button, the normal
movement will restart to find another interesting view of the event
and to iterate the process.
The MOVE is also available in sample mode.
The following commands will produce a drawing of a volume
and then will give the control to the MOVE panel; try the following
possibilities:
 EXAMPLE 1 -
 dopt hide off
 satt * seen -2
 draw NAME 40 40 0 10 10 .01 .01
 move NAME
 EXAMPLE 2 -
 dopt hide on
 satt * seen -2
 draw NAME 40 40 0 10 10 .01 .01
 move NAME
 EXAMPLE 3 -
 dopt shad on
 satt * colo 3
 satt * fill 2
 dopt edge off
 draw NAME 40 40 0 10 10 .01 .01
 move NAME

>Action GXDRAW

>Command MOVE3D
>Parameters
NAME   'Volume name' C D='    '
+
THETA  'Viewing angle theta (for 3D projection)' R D=40. R=0.:180.
PHI    'Viewing angle phi (for 3D projection)' R D=40. R=0.:360.
PSI    'Viewing angle psi (for 2D rotation)' R D=0. R=0.:180.
U0     'U-coord. (horizontal) of volume origin' R D=10. R=0.:20.
V0     'V-coord. (vertical) of volume origin' R D=10. R=0.:20.
SU     'Scale factor for U-coord.' R D=0.01
SV     'Scale factor for V-coord.' R D=0.01
SZ     'Scale zoom factor' R D=1. R=0.1:10.
NOPT   'T=tracks,H=hits' C D='    ' R='T,H'
>Guidance
Same functionality of the command MOVE interfaced with MOTIF.
>Action GXDRAW

>Command PERSP
>Parameters
NAME   'Volume name' C D='    '
DISTT  'Volume distance from observer' R D=1000.
+
SAMP   'Control to the mouse' C D='OFF '
>Guidance
To control the perspective according to the variation of the distance
between the observer and the object (if PROJ has the value PERS).
If SAMP is ON the control of the distance is given via the mouse.
>Action GXDRAW

>Command LENS
>Parameters
KNUM   'View bank identifier' I D=1
+
KSAM   'Sample mode         ' C D='OFF '
>Guidance
Interactive zooming for detectors and events when running
with X-windows. Using this command, when showing the contents of a
view bank, it is possible to click (left button) in two points of the
drawing (which will represent the left upper corner and the right
bottom corner of the part to be zoomed). After the second click
a new 'window' will appear to fit the frame defined
by the two clicks and it will show a zoomed view as seen from a
lens with those dimensions. Clicking now the central button will
translate the lens over the drawing, while clicking the right button
will stop it. Moreover, clicking the left button of the
mouse, the lens will increase (or decrease) its magnification
power according to the backward-to-forward movement of the mouse.
A click on the right button will stop this action and it is possible
to restart the translation of the lens or, clicking
on the right button again, to make the lens disappear. It is then possible
to open another 'window-lens' with different dimensions. Thus,
this command can be useful to scan detailed parts of a detector or
to scan hits and showers for events. Clicking the right
button when no lens is displayed will return the control to the
'command mode'. The LENS is also available in sample mode when KSAM is
'ON'.
The following commands will fill a view bank and will
allow to scan the detector and an event previously stored
via the use of LENS (when running
with X-windows):
 EXAMPLE -
 satt * seen 1
 dopen 1
 draw NAME 40 40 0 10 10 .01 .01
 dxyz 0
 dhits * * 0 0 .2
 dclose
 dsh 1
 lens 1 on

>Action GXDRAW

>Command ZOOM
>Parameters
+
ZFU    'Zoom factor for U-coord. (horizontal)' R D=2.
ZFV    'Zoom factor for V-coord. (vertical)' R D=2.
ISEL   'Options' I D=1
UZ0    'U-coord. of the centre of zoom rectangle' R R=0.:20. D=10.
VZ0    'V-coord. of the centre of zoom rectangle' R R=0.:20. D=10.
U0     'U-coord. of the centre of resulting zoomed rectangle' R R=0.:20. D=10.
V0     'V-coord. of the centre of resulting zoomed rectangle' R R=0.:20. D=10.
>Guidance
 CALL GDZOOM(zfu,zfv,uz0,vz0,u0,v0)
This command sets the zoom parameters that will be used by
subsequent calls to the drawing routines. Each zoom operation is always
relative to the status of the current zoom parameters.
The scale factors in u,v are respectively  zfu,zfv.
zfu=0 (or zfv=0) will act as a reset (i.e. unzoomed viewing).
The zoom is computed around uz0,vz0 (user coordinates),
and the resulting picture will be centered at u0,v0.
The use of the space bar is replaced by the left button of the mouse
running with X11:

If isel=0 :
 1. position the cursor at (uz0,vz0)
 2. type the space bar (GKS)
(u0,v0 are chosen at centre of screen)

If isel=1 :
 1. position the cursor at first corner of zoom rectangle
 2. type the space bar (GKS)
 3. position the cursor at second corner of zoom rectangle
 4. type the space bar (GKS)
(zfu,zfv are chosen according to the zoom rectangle;
uz0,vz0 are chosen at the centre of the zoom rectangle;
u0,v0 are chosen at centre of screen)

If isel=2 :
 1. position the cursor at (uz0,vz0)
 2. type the space bar (GKS)
 3. position the cursor at (u0,v0)
 4. type the space bar (GKS)

If isel=1000+n and running with X-windows:
 1. n must be the identifier of an active view bank
 2. clicking on the left button of the mouse will display
    a zoomed view (computed around the cursor position) of
    the previous drawing in a new window
 3. it is now possible to iterate the zooming from the new window
 4. clicking on the right button will return the control to the
    main window
 5. clicking on the left button it is possible to open new windows
    zooming in other points of the detector
 6. clicking on the right button when the main window is active
    will return the control to the 'command mode'.
>Action GXDRAW

>Command DXYZ
>Parameters
+
ITRA   'Track number' I D=0
>Guidance
 CALL GDXYZ(itra)
Draw tracks previously stored via GSXYZ.
>Action GXDRAW

>Command KXYZ
>Parameters
+
EPSILO 'Delta angle' R D=0.25
>Guidance
 CALL GKXYZ(epsilo)
The picking of track points requires the JXYZ data structure
and is  repeated until the character typed is 'Q' or 'q' (GKS)
or the right button of the mouse is clicked (X11).
EPSILO is the delta angle used for picking; if EPSILO=0
there is no optimization performed and
over all the track points the one nearest to the pick
point is taken.
>Action GXDRAW

>Command DPART
>Parameters
+
ITRA   'Track number' I D=0
ISEL   'Option flag' I D=11
SIZE   'Character size (cm) for particle names' R D=0.25
>Guidance
 CALL GDPART(itra,isel,size)
 isel=x1 to draw the track number
 isel=1x to draw the particle name
>Action GXDRAW

>Command DHITS
>Parameters
+
CHUSET  'User set identifier' C D='*'
CHUDET  'User detector identifier' C D='*'
ITRA   'Number of the selected track' I D=0
ISYMB  'Character selection number' I D=0
SSYMB  'Size of characters (cm)' R D=0.1
>Guidance
CALL GDHITS(chuset,chudet,itra,isymb,ssymb).
The character plotted at each hit point may be chosen by isymb :
      -1   (small) hardware points             (fast)
       0   software crosses                    (default)
   840,850   empty/full circles                  (slow)
   841,851   empty/full squares                  (slow)
   842,852   empty/full triangles (up)           (slow)
   843,853   empty diamond/full triangle (down)  (slow)
   844,854   empty/full stars                    (slow)
Except for isymb=-1, the size of the character on the screen can be
chosen by SSYMB cm. The hit colour will follow the value of TXCI (text
colour) for isymb>0, the value of PMCI (polymarkers colour) for isymb<0,
the value of PLCI (polyline colour) for isymb=0.
>Action GXDRAW

>Command KHITS
>Parameters
+
CHUSET  'User set identifier' C D='*'
CHUDET  'User detector identifier' C D='*'
EPSILO 'Pick aperture' R D=0.1
>Guidance
 CALL GKHITS(chuset,chudet,epsilo)
The picking of hit points requires the appropriate JSET data structure
have been filled
and is  repeated until the character typed is 'Q' or 'q' (GKS) or the
right button of the mouse is clicked (X11).
If the character typed to pick is 'K' or 'k' then the
kinematics of the corresponding track is also printed.
The search is made of all the hits of all tracks in
detector CHUDET of set CHUSET.
EPSILO is the pick aperture; if EPSILO<0 its absolute value is taken
and in addition the pick aperture is drawn; if EPSILO=0
there is an infinite pick aperture and
over all the hits the one nearest to the pick point is taken.
>Action GXDRAW

>Command DCHIT
>Parameters
+
CHUSET  'User set identifier' C D='*'
CHUDET  'User detector identifier' C D='*'
ITRA   'Number of the selected track' I D=0
ISYMB  'Character selection number' I D=0
SIZMAX 'Maximum character size (cm)' R D=1
IHIT   'Index of array HITS' I D=4
HITMIN 'Lower boundary of HITS(IHIT)' R D=0
HITMAX 'Upper boundary of HITS(IHIT)' R D=0
>Guidance
 CALL GDCHIT(chuset,chudet,itra,isymb,sizmax,ihit,hitmin,hitmax)
The character plotted at each hit point may be chosen via
CSYMB; isymb is composed as:
      -1   (small) hardware points             (fast)
       0   software crosses                    (default)
 840,850   empty/full circles                  (slow)
 841,851   empty/full squares                  (slow)
 842,852   empty/full triangles (up)           (slow)
 843,853   empty diamond/full triangle (down)  (slow)
 844,854   empty/full stars                    (slow)
Except for isymb=-1 the SIZE of the character on the screen
is a function of HITS(IHIT), the array containing the calorimeter
quantity, with HITMIN and HITMAX defining its range.
The maximum character size (used in overflow) is SIZMAX.
 SIZE = SIZMAX * ( HITS(IHIT) - HITMIN ) / HITMAX
>Action GXDRAW

>Command DUVIEW
>Parameters
NAME   'Detector name' C
TYPE   'View name' C
CPXTYP 'Complexity name' C
+
IVIEW  'View number where picture is stored' I D=0
>Guidance
 CALL GUVIEW(name,type,cpxtyp,iview)
>Action GXDRAW

>Name GKGCON

>Menu /GEANT/GRAPHICS_CONTROL
>Guidance
Graphics control commands.

>Command DOPEN
>Parameters
IVIEW  'View number' I
>Guidance
 CALL GDOPEN(iview)
When a drawing is very complex and requires a long time to be
executed, it can be useful to store it in a view bank: after a
call to DOPEN and the execution of the drawing (nothing will
appear on the screen), and after a necessary call to DCLOSE,
the contents of the bank can be displayed in a very fast way
through a call to DSHOW; therefore, the detector can be easily
zoomed many times in different ways. Please note that the pictures
with solid colours can now be stored in a view bank or in 'PICTURE FILES'.
>Action GXGCON

>Command DSHOW
>Parameters
+
IVIEW  'View number' I
>Guidance
 CALL GDSHOW(iview)
It shows on the screen the contents of a view bank. It
can be called after a view bank has been closed.
>Action GXGCON

>Command DELETE
>Parameters
IVIEW  'View number' I
>Guidance
 CALL GDELET(iview)
It deletes a view bank from memory.
>Action GXGCON

>Command DCLOSE
>Guidance
 CALL GDCLOS
It closes the currently open view bank; it must be called after the
end of the drawing to be stored.
>Action GXGCON

>Command CHANGEWK
>Guidance
CALL GCHNWK
It open a new workstation (if not already opened) and activate it
(deactivating the default one).
>Action GXGCON

>Command RESETWK
>Guidance
CALL GRESWK
It deactivate the previosly activated workstation and reactivate the
default one.
>Action GXGCON

>Command SSETAT
>Parameters
IOPT   'Attribute name' C
>Guidance
Set current attribute.
>Action GXGCON

>Command SSETVA
>Parameters
+
RVAL   'Attribute value' R D=1. R=-10.:10.
>Guidance
Set current attribute value.
>Action GXGCON

>Command SATT
>Parameters
+
NAME   'Volume name' C D='*   '
IOPT   'Name of the attribute to be set' C D='DEFA'
IVAL   'Value to which the attribute is to be set' I D=10000
>Guidance
 CALL GSATT(name,iopt,ival)
name='*' stands for all the volumes.
iopt can be chosen among the following :

 'WORK'   0=volume name is inactive for the tracking
          1=volume name is active for the tracking (default)

 'SEEN'   0=volume name is invisible
          1=volume name is visible (default)
         -1=volume invisible with all its descendants in the tree
         -2=volume visible but not its descendants in the tree

 'LSTY'   line style 1,2,3,... (default=1)
          LSTY=7 will produce a very precise approximation for
          revolution bodies.

 'LWID'   line width -7,...,1,2,3,..7 (default=1)
          LWID<0 will act as abs(LWID) was set for the volume
          and for all the levels below it. When SHAD is 'ON', LWID
          represent the linewidth of the scan lines filling the surfaces
          (whereas the FILL value represent their number). Therefore
          tuning this parameter will help to obtain the desired
          quality/performance ratio.

 'COLO'   colour code -166,...,1,2,..166 (default=1)
          n=1=black
          n=2=red;    n=17+m, m=0,25, increasing luminosity according to 'm';
          n=3=green;  n=67+m, m=0,25, increasing luminosity according to 'm';
          n=4=blue;   n=117+m, m=0,25, increasing luminosity according to 'm';
          n=5=yellow; n=42+m, m=0,25, increasing luminosity according to 'm';
          n=6=violet; n=142+m, m=0,25, increasing luminosity according to 'm';
          n=7=lightblue; n=92+m, m=0,25, increasing luminosity according to 'm';
          colour=n*10+m, m=1,2,...9, will produce the same colour
          as 'n', but with increasing luminosity according to 'm';
          COLO<0 will act as if abs(COLO) was set for the volume
          and for all the levels below it.
          When for a volume the attribute FILL is > 1 (and the
          option SHAD is on), the ABS of its colour code must be < 8
          because an automatic shading of its faces will be
          performed.

 'FILL'   (1992) fill area  -7,...,0,1,...7 (default=0)
          when option SHAD is 'on' the FILL attribute of any
          volume can be set different from 0 (normal drawing);
          if it is set to 1, the faces of such volume will be filled
          with solid colours; if ABS(FILL) is > 1, then a light
          source is placed along the observer line, and the faces of
          such volumes will be painted by colours whose luminosity
          will depend on the amount of light reflected;
          if ABS(FILL) = 1, then it is possible to use all the 166
          colours of the colour table, becouse the automatic shading
          is not performed;
          for increasing values of FILL the drawing will be performed
          with higher and higher resolution improving the quality (the
          number of scan lines used to fill the faces increases with FILL);
          it is possible to set different values of FILL
          for different volumes, in order to optimize at the same time
          the performance and the quality of the picture;
          FILL<0 will act as if abs(FILL) was set for the volume
          and for all the levels below it.
          This kind of drawing can be saved in 'picture files'
          or in view banks.
          0=drawing without fill area
          1=faces filled with solid colours and resolution = 6
          2=lowest resolution (very fast)
          3=default resolution
          4=.................
          5=.................
          6=.................
          7=max resolution
          Finally, if a coloured background is desired, the FILL
          attribute for the first volume of the tree must be set
          equal to -abs(colo), colo being >0 and <166.

 'SET '   set number associated to volume name
 'DET '   detector number associated to volume name
 'DTYP'   detector type (1,2)
>Action GXGCON

>Command SCALE
>Parameters
GSCU   'Scale factor for U-coord.' R
GSCV   'Scale factor for V-coord.' R
>Guidance
Change the scale factors GSCU and GSCV in /GCDRAW/.
>Action GXGCON

>Command COLOR
>Parameters
ICOL   'Colour code' I D=1
>Guidance
 CALL GDCOL(-abs(icol))
>Action GXGCON

>Command LWID
>Parameters
LWIDTH 'Line width code' I D=1
>Guidance
 CALL GDLW(-abs(lwidth))
>Action GXGCON

>Command NEXT
>Guidance
Clear screen (start a new picture on graphics file, if opened).
>Action GXGCON

>Command DOPT
>Parameters
+
IOPT   'Option name' C D='*'
IVAL   'Option value' C D='*'
>Guidance
 CALL GDOPT(iopt,ival)
To set/modify the drawing options.
   IOPT   IVAL      Action

   THRZ    ON       Draw tracks in R vs Z
           OFF (D)  Draw tracks in X,Y,Z
           180
           360
   PROJ    PARA (D) Parallel projection
           PERS     Perspective
   TRAK    LINE (D) Trajectory drawn with lines
           POIN       " " with markers
   HIDE    ON       Hidden line removal using the CG package
           OFF (D)  No hidden line removal
   SHAD    ON       Fill area and shading of surfaces.
           OFF (D)  Normal hidden line removal.
   RAYT    ON       Ray-tracing on.
           OFF (D)  Ray-tracing off.
   EDGE    OFF      Does not draw contours when shad is on.
           ON  (D)  Normal shading.
   MAPP    1,2,3,4  Mapping before ray-tracing.
           0   (D)  No mapping.
   USER    ON       User graphics options in the raytracing.
           OFF (D)  Automatic graphics options.
>Action GXGCON


>Command SIZE
>Parameters
+
XSIZE 'Size along X' R D=20.
YSIZE 'Size along Y' R D=20.
>Guidance
Set the size of the picture.
On the terminal, the pictures will have the ratio YSIZE/XSIZE, and,
if a metafile is produced, pictures will be YSIZE by XSIZE cm.
This command sets the parameters for the normalisation transformation
number 1 to [0-XSIZE], [0-YSIZE].
>Action GXGCON

>Command SPERS
>Parameters
DPERS  'Distance from the origin' R
>Guidance
Set the variable dpers in /GCDRAW/, representing
the distance from the origin when using option PERSpective.
>Action GXGCON

>Command MAP_COLOR
>Parameters
+
ICADD  'Colour table index' I D=0
ICVAL  'Colour table value' I D=0
>Guidance
Sets the color table LOOKTB(ICADD)=ICVAL.
If ICADD=0 then LOOKTB(1:16) is taken.
If ICVAL is omitted the current value of LOOKTB(ICADD) is shown.
>Action GXGCON

>Name GKLIST
>Menu /GEANT/LISTS
>Guidance


>Command HSTA
>Parameters
+
LHSTA_1  'user word' C
LHSTA_2  'user word' C
LHSTA_3  'user word' C
LHSTA_4  'user word' C
LHSTA_5  'user word' C
LHSTA_6  'user word' C
LHSTA_7  'user word' C
LHSTA_8  'user word' C
LHSTA_9  'user word' C
LHSTA_10  'user word' C
LHSTA_11  'user word' C
LHSTA_12  'user word' C
LHSTA_13  'user word' C
LHSTA_14  'user word' C
LHSTA_15  'user word' C
LHSTA_16  'user word' C
LHSTA_17  'user word' C
LHSTA_18  'user word' C
LHSTA_19  'user word' C
LHSTA_20  'user word' C
>Guidance
The command HSTA is similar to the HSTA data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command GET
>Parameters
+
LGET_1  'user word' C
LGET_2  'user word' C
LGET_3  'user word' C
LGET_4  'user word' C
LGET_5  'user word' C
LGET_6  'user word' C
LGET_7  'user word' C
LGET_8  'user word' C
LGET_9  'user word' C
LGET_10  'user word' C
LGET_11  'user word' C
LGET_12  'user word' C
LGET_13  'user word' C
LGET_14  'user word' C
LGET_15  'user word' C
LGET_16  'user word' C
LGET_17  'user word' C
LGET_18  'user word' C
LGET_19  'user word' C
LGET_20  'user word' C
>Guidance
The command GET is similar to the GET data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command SAVE
>Parameters
+
LSAVE_1  'user word' C
LSAVE_2  'user word' C
LSAVE_3  'user word' C
LSAVE_4  'user word' C
LSAVE_5  'user word' C
LSAVE_6  'user word' C
LSAVE_7  'user word' C
LSAVE_8  'user word' C
LSAVE_9  'user word' C
LSAVE_10  'user word' C
LSAVE_11  'user word' C
LSAVE_12  'user word' C
LSAVE_13  'user word' C
LSAVE_14  'user word' C
LSAVE_15  'user word' C
LSAVE_16  'user word' C
LSAVE_17  'user word' C
LSAVE_18  'user word' C
LSAVE_19  'user word' C
LSAVE_20  'user word' C
>Guidance
The command SAVE is similar to the SAVE data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command SETS
>Parameters
+
LSETS_1  'user word' C
LSETS_2  'user word' C
LSETS_3  'user word' C
LSETS_4  'user word' C
LSETS_5  'user word' C
LSETS_6  'user word' C
LSETS_7  'user word' C
LSETS_8  'user word' C
LSETS_9  'user word' C
LSETS_10  'user word' C
LSETS_11  'user word' C
LSETS_12  'user word' C
LSETS_13  'user word' C
LSETS_14  'user word' C
LSETS_15  'user word' C
LSETS_16  'user word' C
LSETS_17  'user word' C
LSETS_18  'user word' C
LSETS_19  'user word' C
LSETS_20  'user word' C
>Guidance
The command SETS is similar to the SETS data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command LPRIN
>Parameters
+
LPRIN_1  'user word' C
LPRIN_2  'user word' C
LPRIN_3  'user word' C
LPRIN_4  'user word' C
LPRIN_5  'user word' C
LPRIN_6  'user word' C
LPRIN_7  'user word' C
LPRIN_8  'user word' C
LPRIN_9  'user word' C
LPRIN_10  'user word' C
LPRIN_11  'user word' C
LPRIN_12  'user word' C
LPRIN_13  'user word' C
LPRIN_14  'user word' C
LPRIN_15  'user word' C
LPRIN_16  'user word' C
LPRIN_17  'user word' C
LPRIN_18  'user word' C
LPRIN_19  'user word' C
LPRIN_20  'user word' C
>Guidance
The command PRIN is similar to the PRIN data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command GEOM
>Parameters
+
LGEOM_1  'user word' C
LGEOM_2  'user word' C
LGEOM_3  'user word' C
LGEOM_4  'user word' C
LGEOM_5  'user word' C
LGEOM_6  'user word' C
LGEOM_7  'user word' C
LGEOM_8  'user word' C
LGEOM_9  'user word' C
LGEOM_10  'user word' C
LGEOM_11  'user word' C
LGEOM_12  'user word' C
LGEOM_13  'user word' C
LGEOM_14  'user word' C
LGEOM_15  'user word' C
LGEOM_16  'user word' C
LGEOM_17  'user word' C
LGEOM_18  'user word' C
LGEOM_19  'user word' C
LGEOM_20  'user word' C
>Guidance
The command GEOM is similar to the GEOM data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command VIEW
>Parameters
+
LVIEW_1  'user word' C
LVIEW_2  'user word' C
LVIEW_3  'user word' C
LVIEW_4  'user word' C
LVIEW_5  'user word' C
LVIEW_6  'user word' C
LVIEW_7  'user word' C
LVIEW_8  'user word' C
LVIEW_9  'user word' C
LVIEW_10  'user word' C
LVIEW_11  'user word' C
LVIEW_12  'user word' C
LVIEW_13  'user word' C
LVIEW_14  'user word' C
LVIEW_15  'user word' C
LVIEW_16  'user word' C
LVIEW_17  'user word' C
LVIEW_18  'user word' C
LVIEW_19  'user word' C
LVIEW_20  'user word' C
>Guidance
The command VIEW is similar to the VIEW data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command PLOT
>Parameters
+
LPLOT_1  'user word' C
LPLOT_2  'user word' C
LPLOT_3  'user word' C
LPLOT_4  'user word' C
LPLOT_5  'user word' C
LPLOT_6  'user word' C
LPLOT_7  'user word' C
LPLOT_8  'user word' C
LPLOT_9  'user word' C
LPLOT_10  'user word' C
LPLOT_11  'user word' C
LPLOT_12  'user word' C
LPLOT_13  'user word' C
LPLOT_14  'user word' C
LPLOT_15  'user word' C
LPLOT_16  'user word' C
LPLOT_17  'user word' C
LPLOT_18  'user word' C
LPLOT_19  'user word' C
LPLOT_20  'user word' C
>Guidance
The command PLOT is similar to the PLOT data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command STAT
>Parameters
+
LSTAT_1  'user word' C
LSTAT_2  'user word' C
LSTAT_3  'user word' C
LSTAT_4  'user word' C
LSTAT_5  'user word' C
LSTAT_6  'user word' C
LSTAT_7  'user word' C
LSTAT_8  'user word' C
LSTAT_9  'user word' C
LSTAT_10  'user word' C
LSTAT_11  'user word' C
LSTAT_12  'user word' C
LSTAT_13  'user word' C
LSTAT_14  'user word' C
LSTAT_15  'user word' C
LSTAT_16  'user word' C
LSTAT_17  'user word' C
LSTAT_18  'user word' C
LSTAT_19  'user word' C
LSTAT_20  'user word' C
>Guidance
The command STAT is similar to the STAT data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command RGET
>Parameters
+
LRGET_1  'user word' C
LRGET_2  'user word' C
LRGET_3  'user word' C
LRGET_4  'user word' C
LRGET_5  'user word' C
LRGET_6  'user word' C
LRGET_7  'user word' C
LRGET_8  'user word' C
LRGET_9  'user word' C
LRGET_10  'user word' C
LRGET_11  'user word' C
LRGET_12  'user word' C
LRGET_13  'user word' C
LRGET_14  'user word' C
LRGET_15  'user word' C
LRGET_16  'user word' C
LRGET_17  'user word' C
LRGET_18  'user word' C
LRGET_19  'user word' C
LRGET_20  'user word' C
>Guidance
The command RGET is similar to the RGET data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Command RSAV
>Parameters
+
LRSAVE_1  'user word' C
LRSAVE_2  'user word' C
LRSAVE_3  'user word' C
LRSAVE_4  'user word' C
LRSAVE_5  'user word' C
LRSAVE_6  'user word' C
LRSAVE_7  'user word' C
LRSAVE_8  'user word' C
LRSAVE_9  'user word' C
LRSAVE_10  'user word' C
LRSAVE_11  'user word' C
LRSAVE_12  'user word' C
LRSAVE_13  'user word' C
LRSAVE_14  'user word' C
LRSAVE_15  'user word' C
LRSAVE_16  'user word' C
LRSAVE_17  'user word' C
LRSAVE_18  'user word' C
LRSAVE_19  'user word' C
LRSAVE_20  'user word' C
>Guidance
The command RSAV is similar to the RSAV data records. It can accept
up to 20 4-character words. If the first argument is '.', the number
of words is reset to 0 and all the words to four blanks.
>Action GXLIST

>Name GKGEOM
>Menu /GEANT/GEOMETRY
>Guidance
Geometry commands.

>Command OPTI
>Parameters
IOPTI  'GSORD optimisation level' I D=0 R=-1,2
>Guidance
This flag controls the tracking optimisation performed via the
GSORD routine:
    1 no optimisation at all; GSORD calls disabled;
    0 no optimisation; only user calls to GSORD kept;
    1 all non-GSORDered volumes are ordered along the best axis;
    2 all volumes are ordered along the best axis.
>Action GXGEOM

>Command SVOLU
>Parameters
NAME   'Volume name' C
SHAPE  'Volume type' C
NUMED  'Tracking medium number' I
NPAR   'Number of shape parameters' I
PAR    'Vector containing shape parameters' C
>Guidance
 CALL GSVOLU(name,shape,numed,par,npar,ivolu)
where par is a KUIP vector.
It creates a new volume in the JVOLUM data structure.
>Action GXGEOM

>Command SPOS
>Parameters
NAME   'Volume name' C
NUMBER 'Copy number of the volume' I
MOTHER 'Mother volume name' C
X0     'X coord. of the volume in mother ref. sys.' R
Y0     'Y coord. of the volume in mother ref. sys.' R
Z0     'Z coord. of the volume in mother ref. sys.' R
IROT   'Rotation matrix number w.r.t. mother ref. sys.' I
ONLY   'ONLY/MANY flag' C
>Guidance
 CALL GSPOS(name,number,mother,x0,y0,z0,irot,only)
It positions a previously defined volume in the mother.
>Action GXGEOM

>Command SDVN
>Parameters
NAME   'Volume name' C
MOTHER 'Mother volume name' C
NDIV   'Number of divisions' I
CAXIS  'Axis value' C R='X,Y,Z,1,2,3'
>Guidance
 CALL GSDVN(name,mother,ndiv,iaxis)
X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.
It divides a previously defined volume.
>Action GXGEOM

>Command PVOLU
>Parameters
NUMB   'Volume ID' I
>Guidance
 CALL GPVOLU(numb)
Prints volumes' specifications.
>Action GXGEOM

>Command SROTM
>Parameters
IROT   'Rotation matrix number' I
THETA1 'Polar angle for axis I'        R D=0. R=0.:180.
PHI1   'Azimuthal angle for axis I'    R D=0. R=0.:360.
THETA2 'Polar angle for axis II'       R D=0. R=0.:180.
PHI2   'Azimuthal angle for axis II'   R D=0. R=0.:360.
THETA3 'Polar angle for axis III'      R D=0. R=0.:180.
PHI3   'Azimuthal angle for axis III'  R D=0. R=0.:360.
>Guidance
 CALL GSROTM(irot,theta1,phi1,theta2,phi2,theta3,phi3)
It defines the rotation matrix number IROT.
>Action GXGEOM

>Command PROTM
>Parameters
NUMB   'Matrix ID' I
>Guidance
 CALL GPROTM(numb)
Print matrixes' specifications.
>Action GXGEOM


>Command STMED
>Parameters
NTMED  'Tracking medium number' I D=1
NAME   'Tracking medium name' C
NMAT   'Material number' I D=1
ISVOL  'Sensitive volume flag' I D=0
IFIELD 'Magnetic field' I D=0
FIELDM 'Max. field value (Kilogauss)' R D=0
TMAXFD 'Max. angle due to field (deg/step)' R D=0.01
STEMAX 'Max. step allowed'  R D=1.E+10
DEEMAX 'Max. fraction of energy lost in a step' R D=0.01
EPSIL  'Tracking precision (cm)' R D=0.01
STMIN  'Min. step due to continuos processes (cm)' R D=0.1
>Guidance
      CALL GSTMED(ntmed,name,nmat,isvol,ifield,fieldm,tmaxfd,
     +            stemax,deemax,epsil,stmin,0,0)
IFIELD = 0 if no magnetic field; IFIELD = -1 if user decision in GUSWIM;
IFIELD = 1 if tracking performed with GRKUTA; IFIELD = 2 if tracking
performed with GHELIX; IFIELD = 3 if tracking performed with GHELX3.
>Action GXGEOM

>Command PTMED
>Parameters
NUMB   'Medium ID' I
>Guidance
 CALL GPTMED(numb)
Print tracking media's specifications.
>Action GXGEOM

>Command EDITV
>Parameters
+
ISEL   'Options' I D=0
NAME   'Volume name' C D='   '
>Guidance
 CALL GEDITV(isel,name)
When the routine prompts for input parameters that do not need
to be changed, type return.
ISEL is used to select the editing operation to be performed:
 ISEL=0, CALL GGCLOS
 ISEL=1, to modify shape parameters PAR given by GSVOLU
 ISEL=2, to modify NAME given by GSVOLU
 ISEL=3, to delete NAME given by GSVOLU
 ISEL=4, to unlink NAME,NR given by GSPOS/GSDVN/GSDV..
 ISEL=5, to modify X0,Y0,Z0 of NAME,NR given by GSPOS
 ISEL=6, to modify IROT of NAME,NR given by GSPOS
 ISEL=7, to modify NDIV given by GSDVN
 ISEL=8, to modify IAXIS given by GSDVN
>Action GXGEOM

>Command CADINT
>Parameters
FNAME   'Name of the SET file'                        C D='example.set'
ANAME   'Name of the volume'                          C
NBINS   'Number of the instances'                     I D=1
LUNIT   'Logical unit number for SET file'            I D=66
LUNIT2  'Logical unit number for material file'       I D=67
INST    'Name of your institute'                      C D='CERN'
SITE    'Name of site'                                C D='MEYRIN'
DEPT    'Name of departement'                         C D='CN'
RESP    'Name of sender'                              C D='god_knows_who'
>Guidance
 CALL GTXSET(fname,aname,nbins,lunit,lunit2,inst,site,dept,resp)
This command produces a SET file describing the given volume with
the contents currently set visible. (Use the visibility attribute,
see SATT SEEN.) The description is given as a flat assembly
related to the global coordinate system.
The ouput can be read into CAD systems (EUCLID-IS) trough a SET interface.
A list of materials of the volumes in the SET file and the GEANT tree
is written into a file with the same filename as the SET file,
but with extension .mat.
>Action GXGEOM

>Command REUCLID
>Parameters
LUN    'Logical unit of the file to be read'        I R=1:100
FNAME  'Name of the EUCLID file to be read'         C
>Guidance
          CALL GREUCL(LUN,FNAME)
Calls the routine to read into GEANT a geometry from an ASCII file
written by the EUCLID-GEANT interface.
>Action GXGEOM

>Command WEUCLID
>Parameters
LUN    'Logical unit of the file to be written'       I R=1:100
FNAME  'Name of the EUCLID file to be written'        C
TOPVOL 'Volume name of the starting node'             C
+
NUMBER 'Copy number of TOPVOL (relevant for GSPOSP)'  I D=1
NLEVEL 'Number of levels in the tree structure'       I D=15

>Guidance
          CALL GWEUCL(LUN,FNAME)
Calls the routine to write the current GEANT geometry into an ASCII file
in EUCLID compatible format.
>Action GXGEOM

>Menu /GEANT/CREATE
>Guidance
It creates volumes of the given shape interactively.
CALL GSVOLU(name,shape,numed,par,npar,ivolu)
where par is a KUIP vector

>Command SBOX
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
HALFX  'Half X length' R
HALFY  'Half Y length' R
HALFZ  'Half Z length' R
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM

>Command STRD1
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
HLFDWX 'Half X length in Lower Z Surface' R
HLFUPX 'Half X length in Upper Z Surface' R
HALFY  'Half Y length' R
HALFZ  'Half Z length' R
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Command STRD2
>Parameters
NAME    'Volume name' C
NUMED   'Tracking medium number' I
HLFDWX  'Half X length in Lower Z Surface' R
HLFUPX  'Half X length in Upper Z Surface' R
HLFDWY  'Half Y length in Lower Z Surface' R
HLFUPY  'Half Y length in Upper Z Surface' R
HALFZ   'Half Z length' R
+
YESNO   'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Command STUBE
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
INRAD  'Inside Radius' R
OUTRAD 'Outside Radius' R
HALFZ  'Half Z length' R
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Command STUBS
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
INRAD  'Inside Radius' R
OUTRAD 'Outside Radius' R
HALFZ  'Half Z length' R
SPHI   'Start of section PHI' R R=0.:360.
EPHI   'End of section PHI' R R=0.:360.
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Command SCONE
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
INRDW  'Inside Radius in Lower Z Surface' R
OUTRDW 'Outside Radius in Lower Z Surface' R
INRUP  'Inside Radius in Upper Z Surface' R
OUTRUP 'Outside Radius in Upper Z Surface' R
HALFZ  'Half Z length' R
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Command SCONS
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
INRDW  'Inside Radius in Lower Z Surface' R
OUTRDW 'Outside Radius in Lower Z Surface' R
INRUP  'Inside Radius in Upper Z Surface' R
OUTRUP 'Outside Radius in Upper Z Surface' R
HALFZ  'Half Z length' R
SPHI   'Start of section PHI' R R=0.:360.
EPHI   'End of section PHI' R R=0.:360.
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Command SSPHE
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
INRAD  'Inside Radius' R
OUTRAD 'Outside Radius' R
SPHI   'Start of section PHI' R R=0.:360.
EPHI   'End of section PHI' R R=0.:360.
STHETA 'Start of section THETA' R
ETHETA 'End of section THETA' R
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Command SPARA
>Parameters
NAME   'Volume name' C
NUMED  'Tracking medium number' I
HALFX  'Half X length' R
HALFY  'Half Y length' R
HALFZ  'Half Z length' R
AXIS   'Angle of Y mid-faces segment to Y axis' R R=0.:360.
PHI    'PHI angle of Low Z mid-face to High Z mid-face segment' R R=0.:360.
THETA  'THETA angle of mid-low-Z-face to mid-high-Z-face segment' R R=0.:360.
+
YESNO  'GSPOSP option' C D='NO' R='YES,NO'
>Guidance
>Action GXGEOM


>Name GKCONT

>Menu /GEANT/CONTROL
>Guidance
Control commands.

>Command KINE
>Parameters
IKINE     'IKINE'     I D=1
+
PKINE1  'PKINE(1)'  R
PKINE2  'PKINE(2)'  R
PKINE3  'PKINE(3)'  R
PKINE4  'PKINE(4)'  R
PKINE5  'PKINE(5)'  R
PKINE6  'PKINE(6)'  R
PKINE7  'PKINE(7)'  R
PKINE8  'PKINE(8)'  R
PKINE9  'PKINE(9)'  R
PKINE10 'PKINE(10)' R
>Guidance
Set the variables in /GCFLAG/ IKINE, PKINE(10)
>Action GXCONT

>Command RUNG
>Parameters
IDRUN  'User run number'             I
IDEVT  'User starting event number'  I
>Guidance
Set the run number and the starting value for the user event number.
>Action GXCONT

>Command SORD
>Parameters
ISTORD  'Flag to control user ordering of the stack' I D=1 R=1,0
>Guidance
If ISTORD is set to 1, the particle with the highest value of the
user weight UPWGHT will be selected to be tracked next.
>Action GXCONT

>Command GTIME
>Parameters
TIMINT  'Total time after initialisation'          R
TIMEND  'Time reserved for the termination phase'  R
ITIME   'Frequency of control printing'            I
>Guidance
These commands have limited use in the interactive version. In
particular the value of TIMINT is disregarded by GEANT.
>Action GXCONT

>Command TRACK
>Guidance
Restart tracking, clearing the track and hit
banks, but keeping the kinematics.
>Action GXCONT

>Command TRIGGER
>Parameters
+
N      'Number of events' I D=1
>Guidance
Start one or more new events.
>Action GXCONT

>Command RNDM
>Parameters
+
ISEED1  'First seed for the random number generator' I
ISEED2  'Second seed for the random number generator' I
>Guidance
Set the seeds for the random number generator. If no numbers are
given, the currents seeds are printed.
>Action GXCONT

>Command SWITCH
>Parameters
ISWI   'Switch number' I
IVAL   'New switch value' I
>Guidance
Change one element of array ISWIT(10) in /GCFLAG/
>Action GXCONT


>Command MZLOGL
>Parameters
LEVEL  'MZ log level' I D=0
>Guidance
Set the log level for the MZ package of ZEBRA: CALL MZLOGL(0,level)
 LEVEL = -3   no messages at all
         -2   error messages only
         -1   terse logging
          0   normal
         +1   log rare events
         +2   log calls to MZ routines
>Action GXCONT


>Command PRINT
>Parameters
NAME   'Name' C
NUMBER 'Number' I D=0
>Guidance
 CALL GPRINT(name,number)
>Action GXCONT

>Command OUTPUT_LP
>Parameters
LOUT   'New output unit' I
>Guidance
To change lout in /GCUNIT/
Note: unit numbers 5,11,12,13,14,15 are reserved and cannot be used.
>Action GXCONT

>Command PHITS
>Parameters
+
CHUSET  'User set' C D='*'
CHUDET  'User detector' C D='*'
NUMHI  'Hit number' I D=0
>Guidance
 CALL GPHITS(chuset,chudet)
>Action GXCONT

>Command PDIGI
>Parameters
+
CHUSET  'User set' C D='*'
CHUDET  'User detector' C D='*'
>Guidance
 CALL GPDIGI(chuset,chudet)
>Action GXCONT

>Command SMATE
>Parameters
IMAT   'Material number' I
NAMATE 'Material name' C
A      'Atomic weight' R
Z      'Atomic number' R
DENS   'Density' R
RADL   'Radiation lenght' R
ABSL   'Absorption lenght' R
UBUF   ' ' R
NWBUF  ' ' I
>Guidance
 CALL GSMATE(imat,namate,a,z,dens,radl,absl,ubuf,nwbuf)
>Action GXCONT

>Command SMIXT
>Parameters
IMAT   'Material number' I
NAMATE 'Material name' C
A      'Atomic weight' R
Z      'Atomic number' R
DENS   'Density' R
NLMAT  'Flag for WMAT' I
WMAT   'Relative weights or n. of atoms in molecule' R
>Guidance
 CALL GSMIXT(imat,namate,a,z,dens,nlmat,wmat)
>Action GXCONT

>Command PMATE
>Parameters
NUMB   'Material number' I
>Guidance
 CALL GPMATE(numb)
>Action GXCONT

>Command PRMAT
>Parameters
IMATE  'Material number' I
IPART  'Particle number' I
MECAN  'Mechanism' C
>Guidance
 CALL GPRMAT(imate,ipart,mecan,nekbin,elow)
>Action GXCONT

>Command PLMAT
>Parameters
IMATE  'Material number' I
IPART  'Particle number' I
MECAN  'Mechanism' C
+
IDM    'ID mode option' I D=0
>Guidance
CALL GPLMAT(imate,ipart,mecan,nekbin,elow,idm)
 IDM convention for histogramming mode :
 IDM.gt.0  fill, print,   keep   histogram(s)
 IDM.eq.0  fill, print,   delete histogram(s)
 IDM.lt.0  fill, noprint, keep   histogram(s)
If MECAN = 'ALL' all the mechanisms are histogrammed. If the material number
is negative, the cross sections relative to material ABS(IMATE) will
be histogrammed in barns rather than in 1/cm.
>Action GXCONT

>Command DRMAT
>Parameters
IMATE  'Material number' I
IPART  'Particle number' I
+
MECAN  'List of mechanism' C D='ALL'
>Guidance
CALL GDRMAT(imate,ipart,mecan,nmec)
If MECAN = 'ALL' all the mechanisms are plotted. If the material number
is negative, the cross sections relative to material ABS(IMATE) will
be plotted in barns rather than in 1/cm.
Note that it is not possible to plot anything if GSTMED has not been called
for the material number IMATE.
>Action GXCONT

>Command STPAR
>Parameters
ITMED  'Medium number' I
CHPAR  'Cut or mechanism' C
PARVAL 'Value' R
>Guidance
CALL GSTPAR(itmed,chpar,parval)
>Action GXCONT

>Command SPART
>Parameters
IPART  'Particle number' I
NAPART 'Particle name' C
ITRTYP ' ' I
AMASS  'Mass' R
CHARGE 'Charge' R
TLIFE  'Lifetime' R
UBUF   ' ' R
NWBUF  ' ' I
BRATIO 'Branching ratios' R
MODE   'Decay mode' I
>Guidance
CALL GSPART(ipart,napart,itrtyp,amass,charge,tlife,ubuf,nwbuf);
CALL GSDK(ipart,bratio,mode)
>Action GXCONT

>Command PPART
>Parameters
NUMB   'Particle number' I
>Guidance
CALL GPPART(numb)
>Action GXCONT

>Command PRKINE
>Parameters
NUMB   'Track number' I
>Guidance
CALL GPKINE(numb)
>Action GXCONT

>Command DEBUG
>Parameters
+
IDEB   'Debug option' C D='ON' R='ON,OFF'
>Guidance
If ideb='ON  ' then :
 idebug=1, idemin=1, idemax=1000000, itime=1
else :
 idebug=0, idemin=0, idemax=0
>Action GXCONT

>Name GKDZ

>Menu /GEANT/DZ
>Command SURV
>Parameters
NAME 'Bank name' C
+
NUMBER 'Bank number' I D=1
>Guidance
Print a survey of the structure identified by NAME, NUMBER.
>Action GXDZ

>Command SHOW
>Parameters
NAME 'Bank name' C
+
NUMBER 'Bank number' I D=1
CHOPT 'Options' C D='BSV'
>Guidance
Display the contents of a bank or a data structure
identified by its NAME and NUMBER.
The output format of the data part is controlled by the internal
or external I/O characteristic.
 CHOPT='B' Print the bank.
 CHOPT='S' Print the bank contents from left to right Sideways
           with up to ten elements per line.
 CHOPT='V' Print the vertical (down) structure.
 CHOPT='D' Print the bank contents from top to bottom Downwards
           with five elements per line.
 CHOPT='L' Print the linear structure.
 CHOPT='Z' Print the data part of each bank in hexadecimal format
>Action GXDZ

>Command SNAP
>Parameters
+
IDIV 'Division number ' I D=2 R=0:24
CHOPT 'Options' C D='M'
>Guidance
Snap of one or more divisions.
Provides a snapshot of one or more divisions in a ZEBRA store.
The kind of information provided is controlled by CHOPT.
 CHOPT='M' Print Map entry for each bank
 CHOPT='E' Extend map entry to dump all links of each bank
           (otherwise only as many links as will fit on a line)
 CHOPT='F' Full. Dump all active banks, links and data
 CHOPT='K' Kill. Dropped banks to be treated as active
           (dropped banks are not normally dumped under D or F option)
 CHOPT='L' Dump all Link areas associated with the store
 CHOPT='W' Dump the Working space, links and data
 CHOPT='Z' Dump the information in hexadecimal.
>Action GXDZ

>Command VERIFY
>Parameters
+
IDIV 'Division number ' I D=0 R=0:24
CHOPT 'Options' C D='CLSU'
>Guidance
Check the structure of one or more ZEBRA divisions.
The verification detail depends on the settings in CHOPT.
 CHOPT='C' Check chaining of banks only
 CHOPT='L' Check validity of the structural links (implies 'C')
 CHOPT='S' Check the store parameters
 CHOPT='U' Check the validity of the up and origin (implies 'C')
 CHOPT='F' Errors are considered fatal and generate a call to ZFATAL
>Action GXDZ

>Command STORE
>Parameters
+
IXSTOR 'Store number' I D=0  R=0:24
>Guidance
Display the structure of the ZEBRA store IXSTOR.
Output the parameters characterizing the store, followed by a
list of all divisions and all link areas associated with the store in
question.
>Action GXDZ

>Command DDIV
>Parameters
+
IDIV   'Division number'      I D=2
PATH   'Name of the doc file' C D=' '
>Guidance
Facility to display the layout of stores and divisions.

 CALL DZDDIV(idiv,LDUMMY,path,'IN',1,0,1,IWTYPE)

>Action GXDZ

>Command DISP
>Parameters
BANK   'Name of the bank' C
+
PATH   'Name of the doc file' C D=' '
NUMBER 'Number of the bank' I D=1
>Guidance
Interactive bank display tool.

 CALL DZDISP(IXSTOR,LBANK,path,'N',1,0,1,IWTYPE)

>Action GXDZ

>Command DIRZ
>Parameters
+
PATH   'Name of the RZ directory to analyse' C
>Guidance
Facility to display RZ directory trees.

 CALL DZDIRZ(0,LDUMMY,0,path,'N',1,0,1)

>Action GXDZ

>Name GKFZ
>Menu /GEANT/FZ
>Guidance
ZEBRA/FZ commands

>Command FZIN
>Parameters
LUN         'Fortran unit of the FZ file' I
KEYSU       'Name of the data structure to be retrieved' C
+
IDENT       'Version of the data structure to be retrieved' I D=0
>Guidance
Equivalent to a call to:

       CALL GFIN(LUN,KEYSU,1,IDENT,' ',IER)

>Action GXFZ

>Command FZOPEN
>Parameters
LUN         'Fortran unit with which to open the file' I
FILE        'Name of the file to be opened' C
LUNTYP      'Type of FZ file to be opened by GOPEN' C D='XI'
LEN         'Recordlenght of the file' I D=0
+
CHOPT       'Optional parameter to specify the action' C D=' '
>Guidance
Equivalent to a call to:

       CALL GOPEN(LUN,FILE,LUNTYP,LEN,IER)

If CHOPT = I then a call to GFIN or GFOUT will be performed in addition
according to the value of LUNTYP, with the key INIT to save or retrieve
the whole initialization data structure.
>Action GXFZ

>Command FZOUT
>Parameters
LUN         'Fortran unit of the FZ file' I
KEYSU       'Name of the data structure to be saved' C
+
IDENT       'Version of the data structure to be saved' I D=1
>Guidance
Equivalent to a call to:

       CALL GFOUT(LUN,KEYSU,1,IDENT,' ',IER)

>Action GXFZ

>Command FZCLOSE
>Parameters
LUN         'Fortran unit of the FZ to close' I
>Guidance
Equivalent to a call to:

       CALL GCLOSE(LUN,IER)

>Action GXFZ

>Name GKRZ
>Menu /GEANT/RZ
>Guidance
ZEBRA/RZ commands.

>Command PQUEST
>Parameters
+
IQ1    'Lower limit for IQ index' I D=1
IQ2    'Upper limit for IQ index' I D=20
>Guidance
Print the array IQUEST in /QUEST/.
>Action GXRZ

>Command FILE
>Parameters
LUN    'Logical unit number' I
FNAME 'File name' C
+
CHOPT 'Options' C D=' ' R=' ,A,N,U'
>Guidance
Open a GRZ file.
 CHOPT=' ' readonly mode
 CHOPT='U' update mode
 CHOPT='N' create new file
 CHOPT='I' Read all structures from existing file
 CHOPT='O' Write all structures on file
>Action GXRZ

>Command REND
>Parameters
LUNRZ  'Logical unit number' I
>Guidance
Close an RZ file opened by GRFILE on logical unit LUNRZ.
 CALL GREND(LUNRZ)
>Action GXRZ


>Command MDIR
>Parameters
CHDIR  'Directory name' C
+
CHOPT  'Options' C D=' '
>Guidance
To create a new RZ directory below the current directory.
with
 RZTAGS(1)='Object'
 RZTAGS(2)='Idvers-NR '
>Action GXRZ

>Command CDIR
>Parameters
+
CHPATH 'Path name' C D=' '
CHOPT  'CHOPT' C D=' '
>Guidance
Change or print the current directory.
 Ex.  CD dir1         ; make DIR1 the new CWD
      CD //file1/dir2 ; make //FILE1/DIR2 the new CWD
      CD              ; print the name of the CWD
>Action GXRZ

>Command IN
>Parameters
OBJECT 'Structure name' C
+
IDVERS 'Version number' I D=1
CHOPT  'Option'         C D=' '
>Guidance
Read data structure identified by OBJECT,IDVERS into memory.
  MATE read JMATE structure
  TMED read JTMED structure
  VOLU read JVOLUM structure
  ROTM read JROTM structure
  SETS read JSET  structure
  PART read JPART structure
  SCAN read LSCAN structure
  INIT read all above data structures
>Action GXRZ

>Command OUT
>Parameters
OBJECT 'Structure name' C
+
IDVERS 'Version number' I D=1
CHOPT  'Option'         C D=' '
>Guidance
Write data structure identified by OBJECT,IDVERS to RZ file.
  MATE write JMATE structure
  TMED write JTMED structure
  VOLU write JVOLUM structure
  ROTM write JROTM structure
  SETS write JSET  structure
  PART write JPART structure
  SCAN write LSCAN structure
  INIT write all above data structures
>Action GXRZ

>Command LDIR
>Parameters
+
CHPATH 'Path name' C D=' '
CHOPT  'CHOPT' C D=' '
>Guidance
List the contents of a directory (memory or disk).
To list all RZ files currently open, type 'LD //'.
>Action GXRZ

>Command PURGE
>Parameters
+
NKEEP  'Number of cycles to keep' I D=1
>Guidance
Purge an RZ directory.
>Action GXRZ

>Command SCR
>Parameters
OBJECT 'Structure name' C
+
IDVERS 'Version number' I D=1
>Guidance
Delete entry identified by OBJECT,IDVERS on RZ file.
OBJECT may be : MATE,TMED,VOLU,ROTM,SETS,PART,SCAN, *
If OBJECT= *    delete all entries with IDVERS.
>Action GXRZ

>Command LOCK
>Parameters
CHDIR  'Lock identifier' C D='RZFILE'
>Guidance
Lock an RZ directory.
>Action GXRZ

>Command FREE
>Parameters
CHDIR  'Lock identifier' C D='RZFILE'
>Guidance
Free an RZ directory.
>Action GXRZ

>Name GKSCAN
>Menu /GEANT/SCAN
>Guidance
To define parameters for the SCAN geometry. If the routine GUSTEP
and GUKINE are properly instrumented (see examples in GEANX),
when the TRI command is entered NTETA Geantinos will be
tracked through the real detector starting at the vertex position
defined by the command vertex. A simplified version of the geometry
is automatically generated in (ETA,PHI) or (THETA,PHI) following
the option given in the command TETA. The data structure LSCAN
generated may be saved on an RZ file for subsequent processing.
This data structure may be used for fast parametrization techniques.

>Command PHI
>Parameters
NPHI 'Number of PHI divisions' I D=90
+
PHIMIN 'Minimum PHI in degrees' R D=0. R=0.:360.
PHIMAX 'Maximum PHI in degrees' R D=360. R=0.:360.
>Guidance
To specify number of divisions along PHI. If no parameter is
given, the current values of the parameters are displayed.
>Action GXSCAN

>Command TETA
>Parameters
NTETA 'Number of TETA divisions' I D=90
+
TETMIN 'Minimum value of TETA' R
TETMAX 'Maximum value of TETA' R
DIVTYP 'Type of TETA division' I R=1:3
>Guidance
To specify number of divisions along TETA.
If DIVTYP=1 divisions in pseudo-rapidity ETA.
If DIVTYP=2 divisions in degrees following the THETA angle.
If DIVTYP=3 divisions in cos(TETA).
If no parameter is given, the current values of the parameters
are displayed.
>Action GXSCAN

>Command SLIST
>Parameters
LIST 'List of master volumes' C
>Guidance
Only boundary crossings of volumes given in LIST will be seen
in the SCAN geometry. If no parameters are given, the current
SCAN volumes will be listed. If a full stop (.) is given, the list
of scan volumes will be erased.
>Action GXSCAN

>Command VERTEX
>Parameters
VX 'Scan X-origin' R D=0.
VY 'Scan Y-origin' R D=0.
VZ 'Scan Z-origin' R D=0.
>Guidance
All Geantinos tracked will start from position VX,VY,VZ.
>Action GXSCAN

>Command SFACTORS
>Parameters
FACTX0 'Scale factor for SX0' R D=100.
FACTL  'Scale factor for SL' R D=1000.
FACTR  'Scale factor for R'  R D=100.
>Guidance
Set scale factors for SX0,SL and R. The given scale factors must be
such that:
  SX0*FACTX0 < 2**15-1 (32767)
  SL*FACTL   < 2**10-1 (1023)
  SR*FACTR   < 2**17-1 (131071)
>Action GXSCAN

>Command STURN
>Parameters
CHOPT 'SCAN mode setting' C R='ON,OFF,INIT'
>Guidance
Switch on/off SCAN mode. If SCAN mode is on, SCAN geantinos
are generated and tracked to fill (or complete) the current
scan data structure. If SCAN mode is off, normal kinematics
generation and tracking will take place. If INIT is given,
the current SCAN data structure (if any) will be dropped
and SCAN mode will be turned on.
>Action GXSCAN

>Command PCUTS
>Parameters
+
IPARAM   'Parametrization Flag'                        I R=0:1
PCUTGA   'Parametrization Cut for gammas'              R
PCUTEL   'Parametrization Cut for electrons'           R
PCUTHA   'Parametrization Cut for charged hadrons'     R
PCUTNE   'Parametrization Cut for neutral hadrons'     R
PCUTMU   'Parametrization Cut for muons'               R
>Guidance
Control parametrization at tracking time.

     IPARAM=0       No parametrization is performed
     IPARAM=1       Parametrization is performed

If parametrization is active and a particle falls below its
parametrization cut, then the particle will be replaced by
a parametrized shower which will be tracked in the SCAN
geometry.
>Action GXSCAN

>Command LSCAN
>Parameters
ID 'Lego plot identifier' I D=2000
+
VOLUME 'Volume name' C D='XXXX'
CHOPT 'List of options' C D='OPX' R=' ,O,P,I,X,L'
>Guidance
Generates and plot a table of physics quantities such as
the total number of radiation lengths or interaction lengths
in function of the SCAN parameters TETA,PHI.
  CHOPT='O' table is generated at Exit  of VOLUME.
  CHOPT='I' table is generated at Entry of VOLUME.
  CHOPT='X' radiation lengths
  CHOPT='L' Interaction lengths
  CHOPT='P' Plot the table
If VOLUME='XXXX' Mother volume is used.
>Action GXSCAN

>Command HSCAN
>Parameters
IDPHI 'Histogram/phi identifier' I D=1000
+
VOLUME 'Volume name' C D='XXXX'
CHOPT 'List of options' C D='OPX' R=' ,O,P,I,X,L'
>Guidance
Generates and plots an histogram of physics quantities such as
the total number of radiation lengths or interaction lengths
as a function of the SCAN parameter TETA for a given value of PHI.
  CHOPT='O' histogram is generated at Exit  of VOLUME.
  CHOPT='I' histogram is generated at Entry of VOLUME.
  CHOPT='X' radiation lengths
  CHOPT='L' Interaction lengths
  CHOPT='P' Plot the histogram
If VOLUME='XXXX' Mother volume is used.
The histogram identifier IDPHI is used to also identify which
PHI division to plot: IPHI=MOD(IDPHI,1000).
If IPHI=0, then all PHI divisions are generated (not plotted)
with histogram identifiers IDPHI+PHI division number.
>Action GXSCAN

>Name GKPHYS
>Menu /GEANT/PHYSICS
>Guidance
Commands to set physics parameters.

>Command ANNI
>Parameters
+
IANNI 'Flag IANNI' I D=1 R=0,1,2
>Guidance
To control positron annihilation.
 IANNI=0 no annihilation
      =1 annihilation. Decays processed.
      =2 annihilation. No decay products stored.
>Action GXPHYS

>Command AUTO
>Parameters
+
IAUTO 'Flag IAUTO' I D=1 R=0,1
>Guidance
To control automatic calculation of tracking medium parameters:
 IAUTO=0 no automatic calculation;
      =1 automati calculation.
>Action GXPHYS

>Command BREM
>Parameters
+
IBREM 'Flag IBREM' I D=1 R=0,1,2
>Guidance
To control bremstrahlung.
 IBREM=0 no bremstrahlung
      =1 bremstrahlung. Photon processed.
      =2 bremstrahlung. No photon stored.
>Action GXPHYS

>Command CKOV
>Parameters
+
ICKOV 'Flag ICKOV' I D=0 R=0,1,2
>Guidance
To control Cerenkov production
 ICOMP=0 no Cerenkov;
      =1 Cerenkov;
      =2 Cerenkov with primary stopped at each step.
>Action GXPHYS

>Command COMP
>Parameters
+
ICOMP 'Flag ICOMP' I D=1 R=0,1,2
>Guidance
To control Compton scattering
 ICOMP=0 no Compton
      =1 Compton. Electron processed.
      =2 Compton. No electron stored.
>Action GXPHYS

>Command DCAY
>Parameters
+
IDCAY 'Flag IDCAY' I D=1 R=0,1,2
>Guidance
To control Decay mechanism.
 IDCAY=0 no decays.
      =1 Decays. secondaries processed.
      =2 Decays. No secondaries stored.
>Action GXPHYS

>Command DRAY
>Parameters
+
IDRAY 'Flag IDRAY' I D=1 R=0,1,2
>Guidance
To control delta rays mechanism.
 IDRAY=0 no delta rays.
      =1 Delta rays. secondaries processed.
      =2 Delta rays. No secondaries stored.
>Action GXPHYS

>Command ERAN
>Parameters
+
EKMIN  'Minimum energy of the tables' R D=1E-5
EKMAX  'Maximum energy of the tables' R D=1E+4
NEKBIN 'Number of bins in the tables' I D=90 R=1:200
>Guidance
To define the range and binning of internal tables.
>Action GXPHYS

>Command HADR
>Parameters
+
IHADR 'Flag IHADR' I D=1
>Guidance
To control hadronic interactions.
 IHADR=0 no hadronic interactions.
      =1 Hadronic interactions. secondaries processed.
      =2 Hadronic interactions. No secondaries stored.
>Action GXPHYS

>Command LABS
>Parameters
+
LABS   'Flag LABS' I D=0
>Guidance
To control absorbtion of Cerenkov photons:
    LABS=0 no absorbtion of photons;
    LABS=1 absorbtion of photons;
>Action GXPHYS

>Command LOSS
>Parameters
+
ILOSS 'Flag ILOSS' I D=2 R=0,1,2,3,4
>Guidance
To control energy loss.
 ILOSS=0 no energy loss;
      =1 restricted energy loss fluctuations;
      =2 complete energy loss fluctuations;
      =3 same as 1;
      =4 no energy loss fluctuations.
If the value ILOSS is changed, then cross-sections and energy loss
tables must be recomputed via the command 'PHYSI'.
>Action GXPHYS

>Command MULS
>Parameters
+
IMULS 'Flag IMULS' I D=1 R=0,1,2,3
>Guidance
To control multiple scattering.
 IMULS=0 no multiple scattering.
      =1 Moliere or Coulomb scattering.
      =2 Moliere or Coulomb scattering.
      =3 Gaussian scattering.
>Action GXPHYS

>Command MUNU
>Parameters
+
IMUNU 'Flag IMUNU' I D=1 R=0,1,2
>Guidance
To control muon nuclear interactions.
 IMUNU=0 no muon-nuclear interactions.
      =1 Nuclear interactions. Secondaries processed.
      =2 Nuclear interactions. Secondaries not processed.
>Action GXPHYS

>Command PAIR
>Parameters
+
IPAIR 'Flag IPAIR' I D=1 R=0,1,2
>Guidance
To control pair production mechanism.
 IPAIR=0 no pair production.
      =1 Pair production. secondaries processed.
      =2 Pair production. No secondaries stored.
>Action GXPHYS

>Command PFIS
>Parameters
+
IPFIS 'Flag IPFIS' I D=1 R=0,1,2
>Guidance
To control photo fission mechanism.
 IPFIS=0 no photo fission.
      =1 Photo fission. secondaries processed.
      =2 Photo fission. No secondaries stored.
>Action GXPHYS

>Command PHOT
>Parameters
+
IPHOT 'Flag IPHOT' I D=1 R=0,1,2
>Guidance
To control Photo effect.
 IPHOT=0 no photo electric effect.
      =1 Photo effect. Electron processed.
      =2 Photo effect. No electron stored.
>Action GXPHYS

>Command RAYL
>Parameters
+
IRAYL 'Flag IRAYL' I D=1 R=0,1
>Guidance
To control Rayleigh scattering.
 IRAYL=0 no Rayleigh scattering.
      =1 Rayleigh.
>Action GXPHYS

>Command STRA
>Parameters
+
ISTRA 'Flag ISTRA' I D=0 R=0,1,2
>Guidance
To control energy loss fluctuation model:
 ISTRA=0 Urban model;
      =1 PAI model;
      =2 PAI+ASHO model (not active at the moment).
>Action GXPHYS

>Command SYNC
>Parameters
+
ISYNC 'Flag ISYNC' I D=1 R=0,1
>Guidance
To control synchrotron radiation:
 ISYNC=0 no synchrotron radiation;
      =1 synchrotron radiation.
>Action GXPHYS

>Command CUTS
>Parameters
+
CUTGAM   'Cut for gammas'              R D=0.001
CUTELE   'Cut for electrons'           R D=0.001
CUTHAD   'Cut for charged hadrons'     R D=0.01
CUTNEU   'Cut for neutral hadrons'     R D=0.01
CUTMUO   'Cut for muons'               R D=0.01
BCUTE    'Cut for electron brems.'     R D=-1.
BCUTM    'Cut for muon brems.'         R D=-1.
DCUTE    'Cut for electron delta-rays' R D=-1.
DCUTM    'Cut for muon delta-rays'     R D=-1.
PPCUTM   'Cut for e+e- pairs by muons' R D=0.01
TOFMAX   'Time of flight cut'          R D=1.E+10
GCUTS    '5 user words'                R D=0.
>Guidance
To change physics cuts. If no parameter is given, the list
of the current cuts is printed.
 If the default values (-1.) for       BCUTE ,BCUTM ,DCUTE ,DCUTM
 are not modified, they will be set to CUTGAM,CUTGAM,CUTELE,CUTELE
 respectively.
If one of the parameters from CUTGAM to PPCUTM included
is modified, cross-sections and energy loss tables must be
recomputed via the command 'PHYSI'.
>Action GXPHYS

>Command DRPRT
>Parameters
IPART    'GEANT particle number'         I
IMATE    'GEANT material number'         I
STEP     'step length in centimeters'    R
+
NPOINT 'number of logarithmically spaced energy points' I D=10 R=2:100
>Guidance
This routine prints the relevant parameters linked with the energy loss
fluctuation.
>Action GXPHYS

>Command PHYSI
>Guidance
Call the GEANT initialisation routine GPHYSI to recompute
the tables of cross-sections and energy loss. This command
must be invoked after CUTS, LOSS or ERAN commands.
>Action GXPHYS

>Name GKFORT
>Menu FORTRAN

>Command FORTRAN
>Parameters
FNAME 'File name' C
>Guidance
The routines in the file FNAME will be compiled by COMIS.
If routines with names: UGEOM,GUKINE,GUOUT,UGLAST are found,
then they will be automatically called by GXINT instead of
the routines with the same names compiled with the standard
Fortran compiler and linked with the application.
The user callable routines from the GEANT library as well as
routines from PACKLIB (HBOOK,HPLOT,HIGZ,ZEBRA) may be called
from these user routines. All GEANT common blocks may be
referenced.
In case where the routine UGEOM is called several times,
it is important to DROP all the initialisation data structures
JVOLUM,JMATE,JTMED,etc already in memory by using the routine GIDROP.
 Example of an interactive session where the routine UGEOM is modified:
.
   GEANT > Edit ugeom.for
   GEANT > Fortran ugeom.for
   GEANT > Call GIDROP
   GEANT > Call UGEOM
   GEANT > Dtree
   GEANT > Edit ugeom.for
   GEANT > Fortran ugeom.for
   GEANT > Call GIDROP
   GEANT > Call UGEOM
   GEANT > Dtree

If FNAME='-', calls to user routines is reset and standard
routines called instead.
>Action GXFORT


+PATCH, PAMEND.
*- THIS IS THE LAST LINE OF THE PAM FILE geant321
