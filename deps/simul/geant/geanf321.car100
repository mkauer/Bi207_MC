+TITLE.
C GEANF.CAR 3.21/05 26/11/99 11.41.02 CVSTOCAR RESTAURATION 
+PATCH, PEANUT.
+DECK,  BIMSEL, T=FORT.
* Revision 1.2  1997/10/17 10:00:03  mclareni
* Remove SAVE statement for NT
* Revision 1.1.1.1  1995/10/24 10:22:00  cernlib
* Geant

*$ CREATE BIMSEL.FOR
*COPY BIMSEL
*=== bimsel ===========================================================*
      SUBROUTINE BIMSEL ( JPROJ, TXX, TYY, TZZ, LBCHCK )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, EVA0.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PART.
+CDE, PAREVT.
+CDE, RESNUC.
*
      PARAMETER ( FEFFEC = 1.518066780142162 D+00 )
      PARAMETER ( BETMAX = 0.4 D+00 )
*
      REAL RNDM(2)
*
      LOGICAL LBCHCK, LFERMI, LLMDBR
*
      SAVE ABTAR , ZZTAR , SIGMP0, SIGMN0,
     &     AMNHLP, RHOBIM, RPRONU, RADPRP, RADPRN, DSKRED, RHRUSF,
     &     AUSFL , ZUSFL , BNDSAV, RADHLP, BFCHLP, BIMCLM, PRCOLP,
     &     PRCOLN, IBTOLD, ICTOLD, KPROJ , NTRIAL, ITFRMI
      SAVE SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1, SBHAL1
+SELF, IF=-WINNT.
      SAVE
+SELF.
      DATA IBTOLD, ICTOLD / 2*0 /
*
      KPROJ  = JPROJ
      AUSFL  = IBTAR
      ZUSFL  = ICHTAR
      RHRUSF = 1.D+00
      BEPROJ = PNUCCO / ( EKECON + AM (KPROJ) )
      CXIMPC = TXX
      CYIMPC = TYY
      CZIMPC = TZZ
      NTRIAL = 0
      RHOBIM = - AINFNT
      IF ( KPROJ .EQ. 1 .OR. KPROJ .EQ. 8 ) THEN
         IPWELL = 1 + KPROJ / 8
         WLLRED = 1.D+00
         BNDNUC = BNENRG (IPWELL)
      ELSE
         IPWELL = 0
         IF ( IBAR (KPROJ) .EQ. 0 ) THEN
            IF ( KPROJ .LE. 11 ) THEN
               WLLRED = 0.D+00
               BNDNUC = 0.D+00
            ELSE
               WLLRED = POTMES
               BNDNUC = BNENRG (3)
            END IF
         ELSE
            WLLRED = POTBAR
            BNDNUC = BNENRG (3)
         END IF
      END IF
      BNDSAV = BNDNUC
      IF ( IBAR (KPROJ) .NE. 0 ) THEN
         RPRONU = 1.D+00
      ELSE IF ( KPROJ .NE. 7 ) THEN
         RPRONU = 0.8164965809277260D+00
      ELSE
         RPRONU = 0.D+00
      END IF
      IF ( LBCHCK ) THEN
         LFERMI = .FALSE.
         EKESIG = EKECON
         PPRSIG = PNUCCO
         CALL SIGFER ( KPTOIP (KPROJ), EKESIG, PPRSIG, LFERMI )
         PRCOLP = ZUSFL / AUSFL * SIGMAP
         PRCOLN = ( AUSFL - ZUSFL ) / AUSFL * SIGMAN
         SIGMAA = PRCOLP + PRCOLN
         PRCOLP = PRCOLP / SIGMAA
         PRCOLN = 1.D+00 - PRCOLP
      END IF
      IF ( RPRONU .GT. ANGLGB ) THEN
         IF ( LPARWV ) THEN
            LLMDBR = .TRUE.
            TMP102 = 1.D-02
            PDEBRO = MAX ( PNUCCO, TMP102 )
            ALMBAR = PLABRC / PDEBRO
            DEBRLM = 0.5D+00 * ALMBAR
            RADCOR = SQRT ( (RPRONU * RMSPRO)**2 + ALMBAR**2 )
     &             / ( RMSPRO * RPRONU )
         ELSE
            PDEBRO = ( EKECON + BNDNUC ) * ( EKECON + BNDNUC + 2.D+00
     &             * AM (KPROJ) )
            LLMDBR = .FALSE.
            DEBRLM = 0.D+00
            ALMBAR = 0.D+00
            LLLMAX = -1
            RADCOR = SQRT ( (RPRONU * RMSPRO)**2 + PLABRC**2 / PDEBRO
     &             ) / ( RMSPRO * RPRONU )
         END IF
      ELSE
         RADCOR = 0.D+00
         LLMDBR = .FALSE.
         DEBRLM = 0.D+00
      END IF
      RADCO2 = RADCOR
      RADPRO = MIN ( TWOTWO * RMSPRO * RPRONU * RADCOR, SKGT16 )
      RADPRP = RADPRO
      RADPRN = RADPRO
      IF ( IBTAR .NE. IBTOLD .OR. ICHTAR .NE. ICTOLD ) THEN
         IBTOLD = IBTAR
         ICTOLD = ICHTAR
         ABTAR  = IBTAR
         ZZTAR  = ICHTAR
         AR1O3  = RMASS (IBTAR)
         AMNHLP = 0.5D+00 * ( AMNUCL (1) + AMNUCL (2) )
         HKAP   = ABTAR**2 / ( ZZTAR**2 + ( ABTAR - ZZTAR )**2 )
         HHLP (1) = ( HKAP * ZZTAR )**0.3333333333333333D+00 / AR1O3
         HHLP (2) = ( HKAP * ( ABTAR - ZZTAR ) )
     &            **0.3333333333333333D+00 / AR1O3
         RHOCEN = RHOTAB (IBTAR)
         ALPHAL = ALPTAB (IBTAR)
         RADIU0 = RADTAB (IBTAR)
         SKINDP = SKITAB (IBTAR)
         HALODP = HALTAB (IBTAR)
         RADIU1 = RADIU0 + SKINDP
         RADTOT = RADIU1 + HALODP
         RHOCOR = ONEMNS * RHOCEN
         RHOSKN = ALPHAL * RHOCEN
         PFRCEN (1) = HHLP (1) * PFRTAB (IBTAR)
         PFRCEN (2) = HHLP (2) * PFRTAB (IBTAR)
         RHOAVE = RHATAB (IBTAR)
         PFRAVE = PFATAB (IBTAR)
         EKFAVE = EKATAB (IBTAR)
         OMALHL = 1.D+00 - ALPHAL
         RAD1O2 = RADIU0 + 0.5D+00 * SKINDP / OMALHL
         SKNEFF = SKINDP / OMALHL
         RADSKN = RADIU0 + SKNEFF
         EKFCEN (1) = SQRT ( AMNUSQ (1) + PFRCEN (1)**2 ) - AMNUCL (1)
         EKFCEN (2) = SQRT ( AMNUSQ (2) + PFRCEN (2)**2 ) - AMNUCL (2)
         IF ( PFRCEN (1) .GT. PFRCEN (2) ) THEN
            ITNCMX = 1
         ELSE
            ITNCMX = 2
         END IF
         CALL NCLVST ( IBTAR, ICHTAR )
      END IF
      IF ( IPWELL .LE. 0 ) IPWELL = ITNCMX
      CALL NCLVIN
      IF ( EKECON .LT. 2.D+00 * GAMMIN ) THEN
         EKECON = 0.D+00
         PNUCCO = 0.D+00
         LABRST = .TRUE.
         RADPRO = 0.D+00
         RADSIG = ( RADTOT + DEBRLM ) * BFCLMB
         RADMAX = RADTOT
         LLLMAX = -1
         OPACTY = 2.D+00
         CALL RSTSEL (KPROJ)
         RETURN
      END IF
      RADMAX = RADTOT + RADPRO
      BIMCLM = RDCLMB * BFCLMB
      IF ( LLMDBR ) THEN
         RADHLP = RADMAX
         IF ( RADHLP .LE. RDCLMB ) THEN
            BFCMAX = BFCLMB
            BFCHLP = 0.5D+00 * CLMBBR * RDCLMB / EKECON
         ELSE
            BFCHLP = 0.5D+00 * CLMBBR * RDCLMB / EKECON
            BFCMAX = SQRT ( 1.D+00 - CLMBBR * RDCLMB / EKECON / RADHLP )
         END IF
         BIMMAX = RADHLP * BFCMAX
         LLLMAX = INT ( BIMMAX / ALMBAR )
         RADSIG = ALMBAR * ( LLLMAX + 1.D+00 )
         SIGGEO = PI * RADSIG * RADSIG
      ELSE
         RADHLP = RADTOT + RADPRO + DEBRLM
         IF ( RADHLP .LE. RDCLMB ) THEN
            BFCMAX = BFCLMB
         ELSE
            BFCHLP = 0.5D+00 * CLMBBR * RDCLMB / EKECON
            BFCMAX = SQRT ( 1.D+00 - CLMBBR * RDCLMB / EKECON / RADHLP )
         END IF
         RADSIG = RADHLP * BFCMAX
      END IF
      R0TRAJ = - RADTOT
      R1TRAJ = - R0TRAJ
 4200  CONTINUE
          CALL GRNDM(RNDM,2)
          RPHI1 = 2.D+00 * RNDM (1) - 1.D+00
          RPHI2 = 2.D+00 * RNDM (2) - 1.D+00
          RPHI12 = RPHI1 * RPHI1
          RPHI22 = RPHI2 * RPHI2
          RSQ = RPHI12 + RPHI22
       IF ( RSQ .GT. 1.D+00 ) GO TO 4200
      SINPHI = 2.D+00 * RPHI1 * RPHI2 / RSQ
      COSPHI = ( RPHI12 - RPHI22 ) / RSQ
      SINT02 = 1.D+00 - CZIMPC * CZIMPC
      IF ( SINT02 .LT. ANGLSQ ) THEN
         UBIMPC = COSPHI
         VBIMPC = SINPHI
         WBIMPC = 0.D+00
      ELSE
         SINTH0 = SQRT ( SINT02 )
         SINPH0 = CYIMPC / SINTH0
         COSPH0 = CXIMPC / SINTH0
         UBIMPC = COSPHI * COSPH0 * CZIMPC - SINPHI * SINPH0
         VBIMPC = COSPHI * SINPH0 * CZIMPC + SINPHI * COSPH0
         WBIMPC = - COSPHI * SINTH0
      END IF
      GO TO 4500
      ENTRY BIMNXT ( LBCHCK )
         IF ( EKECON .LT. 2.D+00 * GAMMIN ) THEN
            LABRST = .TRUE.
            CALL RSTNXT
            RETURN
         END IF
 4300 CONTINUE
         BNDNUC = BNDSAV
         SIGMAP = SIGMP0
         SIGMAN = SIGMN0
 4400    CONTINUE
         CALL GRNDM(RNDM,1)
         ANMFP = - LOG ( 1.D+00 - RNDM (1) ) / DSKRED
         IF ( SBRES * SIGMAA .GT. ANMFP ) THEN
            GO TO 6000
         END IF
 4500 CONTINUE
 5000 CONTINUE
         SBUSED = 0.D+00
         NTRIAL = NTRIAL + 1
         IF ( LLMDBR ) THEN
            ALLMAX = LLLMAX + 1.D+00
            CALL GRNDM(RNDM,2)
            RNDLLL = ALLMAX * MAX ( RNDM (1), RNDM (2) )
            LLLACT = INT (RNDLLL)
            BIMPTR = RNDLLL * ALMBAR
            BIMPTR = ABS (BIMPTR)
            IF ( BIMPTR .LE. BIMCLM ) THEN
               BFCEFF = BFCLMB
            ELSE
               HLPHLP = BFCHLP / BIMPTR
               BFCEFF = 1.D+00 / ( HLPHLP + SQRT ( HLPHLP * HLPHLP
     &                + 1.D+00 ) )
            END IF
            BIMPTR = BIMPTR / BFCEFF
            IF ( BIMPTR .GT. RADHLP ) GO TO 5000
         ELSE
            CALL GRNDM(RNDM,2)
            BIMPTR = RADSIG * MAX ( RNDM (1), RNDM (2) )
            IF ( BIMPTR .LE. BIMCLM ) THEN
               BFCEFF = BFCLMB
            ELSE
               HLPHLP = BFCHLP / BIMPTR
               BFCEFF = 1.D+00 / ( HLPHLP + SQRT ( HLPHLP * HLPHLP
     &                + 1.D+00 ) )
            END IF
            BIMPTR = BIMPTR / BFCEFF
         END IF
         BIMMEM = BIMPTR
         IF ( BIMPTR .GT. RADTOT - RADPRO ) THEN
            BIMPCT = 0.5D+00 * ( RADTOT + BIMPTR - RADPRO )
            IF ( BIMPTR .GE. RADTOT ) THEN
               X1 = BIMPTR - RADTOT
               ANGRED = ACOS ( 2.D+00 * X1 / ( RADPRO + X1 ) ) / PI
               X1 = X1 / ( R0PROT * RPRONU * RADCO2 )
               DSKRED = ( 0.5D+00 * X1 * X1 + X1 + 1.D+00 ) * EXP (-X1)
     &                * ANGRED
            ELSE
               X1 = RADPRO + BIMPTR - RADTOT
               ANGRED = ACOS ( 2.D+00 * X1 / ( RADPRO + X1 ) ) / PI
               X1 = X1 / ( R0PROT * RPRONU * RADCO2 )
               DSKRED = 1.D+00 - ( 0.5D+00 * X1 * X1 + X1 + 1.D+00 )
     &                * EXP (-X1) * ANGRED
            END IF
         ELSE
            DSKRED = 1.D+00
            BIMPCT = BIMPTR
         END IF
         IF ( .NOT. LBCHCK ) THEN
            RHOSAV = RHOBIM
            RHOBIM = FRHONC ( BIMPCT )
            IF ( RHOBIM .EQ. RHOSAV ) GO TO 5500
            PFRBIM = FPFRNC ( RHOBIM, ITNCMX )
            EKFBIM = FEKFNC ( PFRBIM, ITNCMX )
            RHOHLP = FRHONC ( BIMPTR )
            PFRHLP = FPFRNC ( RHOHLP, IPWELL )
            PFRHLP = 0.5D+00 * PFRHLP * PFRHLP / AMNUSQ (IPWELL)
            IF ( BIMPTR .GT. RADTOT ) BNDNUC = BNDNUC * ( 1.D+00
     &         - ( BIMPTR - RADTOT ) / ( RADHLP - RADTOT ) )
            VPRBIM = WLLRED * ( AMNUCL (IPWELL) * PFRHLP
     &             * ( 1.D+00 - 0.5D+00 * PFRHLP ) + BNDNUC )
            LFERMI = .TRUE.
            EKESIG = EKECON
            PPRSIG = PNUCCO
            CALL SIGFER ( KPTOIP (KPROJ), EKESIG, PPRSIG, LFERMI )
            PRCOLP = ZUSFL / AUSFL * SIGMAP
            PRCOLN = ( AUSFL - ZUSFL ) / AUSFL * SIGMAN
            SIGMAA = PRCOLP + PRCOLN
            PRCOLP = PRCOLP / SIGMAA
            PRCOLN = 1.D+00 - PRCOLP
 5500       CONTINUE
         ELSE
            RHOBIM = FRHONC ( BIMPCT )
         END IF
         XBIMPC = UBIMPC * BIMPCT
         YBIMPC = VBIMPC * BIMPCT
         ZBIMPC = WBIMPC * BIMPCT
         CALL GRNDM(RNDM,1)
         ANMFP  = - LOG ( 1.D+00 - RNDM (1) ) / DSKRED
         IF ( BIMPCT .GT. RAD1O2 ) THEN
            SBTTSQ = 4.D+00 * ( RADTOT**2 - BIMPCT**2 ) * RHOBIM**2
            IF ( SBTTSQ .LE. ( ANMFP / SIGMAA )**2 ) GO TO 5000
         END IF
         CALL SBCOMP ( SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1, SBHAL1 )
         SBTOT  = SBHAL0 + SBSKI0 + SBCEN0 + SBCEN1 + SBSKI1 + SBHAL1
         SBTOT  = RHRUSF * SBTOT
      IF ( SBTOT * SIGMAA .LE. ANMFP ) GO TO 5000
 6000 CONTINUE
      SBUSED = SBUSED * RHRUSF + ANMFP / SIGMAA
      SBRES  = SBTOT  - SBUSED
      SBUSED = SBUSED / RHRUSF
      LELSTC = .TRUE.
      NTARGT = 1
      CALL GRNDM(RNDM,1)
      IF ( RNDM (1) .LT. PRCOLP ) THEN
         KNUCIM = 1
         ITFRMI = 1
      ELSE
         KNUCIM = 8
         ITFRMI = 2
      END IF
      IPRTYP = KPROJ * 10 + KNUCIM
      CALL RSCOMP ( SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1, SBHAL1 )
      BNDNUC = BNDSAV
      RHOIMP = FRHONC ( ABS (RIMPCT) )
      PFRIMP = FPFRNC ( RHOIMP, ITFRMI )
      EKFIMP = FEKFNC ( PFRIMP, ITFRMI )
      RIMHLP = ABS (RIMPTR)
      RHOIMT = FRHONC ( RIMHLP )
      PFRPRO = FPFRNC ( RHOIMT, IPWELL )
      EKFPRO = FEKFNC ( PFRPRO, IPWELL )
      IF ( RIMHLP .GT. RADTOT ) BNDNUC = BNDNUC * ( 1.D+00 - ( RIMHLP
     &                                 - RADTOT ) / ( RADHLP - RADTOT ))
      VPRWLL = WLLRED * ( EKFPRO + BNDNUC )
      EKEWLL = EKECON + VPRWLL
      EPSWLL = EKEWLL + AM (KPROJ)
      IF ( .NOT. LBCHCK ) THEN
         PPRWLL = SQRT ( EKEWLL * ( EKEWLL + 2.D+00 * AM (KPROJ) ) )
         CALL PHDWLL ( UBIMPC, VBIMPC, WBIMPC )
         PNFRMI = PFNCLV ( ITFRMI, .TRUE. )
         IF ( PNFRMI .LT. -100.D+00 ) GO TO 4400
         CALL RACO ( PXFERM, PYFERM, PZFERM )
         PXFERM = PXFERM * PNFRMI
         PYFERM = PYFERM * PNFRMI
         PZFERM = PZFERM * PNFRMI
         ERES   = EKEWLL + AM (KPROJ) + AM (KNUCIM) + EKFERM
         PXRES  = PXPROJ + PXFERM
         PYRES  = PYPROJ + PYFERM
         PZRES  = PZPROJ + PZFERM
         PTRES2 = PXRES**2 + PYRES**2 + PZRES**2
         UMO2   = ERES**2 - PTRES2
         EKESIG = 0.5D+00 * ( UMO2 - AM (KPROJ)**2 - AM (KNUCIM)**2 )
     &          / AM (KNUCIM) - AM (KPROJ)
         EKFIMP = MAX ( EKFERM, EKFIMP )
      ELSE
         EKESIG = EPSWLL - AM (KPROJ)
      END IF
      PPRSIG = SQRT ( EKESIG * ( EKESIG + 2.D+00 * AM (KPROJ) ) )
      SIGMN0 = SIGMAN
      SIGMP0 = SIGMAP
      LFERMI = .FALSE.
      CALL SIGFER ( KPTOIP (KPROJ), EKESIG, PPRSIG, LFERMI )
      IF ( KNUCIM .EQ. 1 ) THEN
         SIGMAR = SIGMAP / SIGMP0
      ELSE
         SIGMAR = SIGMAN / SIGMN0
      END IF
      SIGMAR = MIN ( SIGMAR, ONEONE )
      CALL GRNDM(RNDM,1)
      RNDREJ = RNDM(1)
      IF ( RNDREJ .GE. SIGMAR ) GO TO 4300
      IF ( LBCHCK ) THEN
         ZITA   = 0.5D+00 * ( EKFIMP + EKFPRO ) / EKEWLL
         IF ( ZITA .LE. 0.5D+00 ) THEN
            PZITA = 1.D+00 - 1.4D+00 * ZITA
         ELSE
            PZITA = 1.D+00 - 1.4D+00 * ZITA + 0.4D+00 * ZITA
     &            * ( 2.D+00 - 1.D+00 / ZITA )**2.5D+00
         END IF
         RNDREJ = RNDREJ / SIGMAR
         IF ( RNDREJ .GE. PZITA ) GO TO 4300
      ELSE
         PZITA = 1.D+00
      END IF
      OPACTY = 1.D+00 / NTRIAL
      RETURN
*=== End of subroutine Bimsel =========================================*
      END
+DECK,  COSLEG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:00  cernlib
* Geant

*$ CREATE COSLEG.FOR
*COPY COSLEG
*=== cosleg ===========================================================*
      FUNCTION COSLEG ( ACOLEG )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
      DIMENSION ACOLEG (0:2)
      REAL RNDM(2)
*
      IF ( ACOLEG (0) .NE. 0.5D+00 ) THEN
         ANORM = 0.5D+00 / ACOLEG (0)
         DO 100 I = 0,2
            ACOLEG (I) = ACOLEG (I) * ANORM
  100    CONTINUE
      END IF
      ACOF = 1.5D+00 * ACOLEG (2)
      BCOF = ACOLEG (1)
      CCOF = ACOLEG (0) - 0.5D+00 * ACOLEG (2)
      FORWRA = 0.3333333333333333D+00 * ACOF
      FORWRB = 0.5D+00 * BCOF
      FORWRC = CCOF
      FORWRD = FORWRA + FORWRB + FORWRC
      BACKWR = 1.D+00 - FORWRD
      CALL GRNDM(RNDM,1)
      RNDCOS = RNDM (1)
      IF ( RNDCOS .LT. FORWRD ) THEN
         RNDCOS = RNDCOS
         IF ( RNDCOS .LT. FORWRA ) THEN
            COSLEG = ( RNDCOS / FORWRA )**0.3333333333333333D+00
         ELSE IF ( RNDCOS .LT. FORWRA + FORWRB ) THEN
            COSLEG = SQRT ( ( RNDCOS - FORWRA ) / FORWRB )
         ELSE
            COSLEG = ( RNDCOS - FORWRA - FORWRB ) / FORWRC
         END IF
      ELSE
         COSLEG = - ( RNDCOS - FORWRD ) / BACKWR
         IF ( ACOF .LT. - ANGLGB ) THEN
            COSMAX = - 0.5D+00 * BCOF / ACOF
            IF ( COSMAX .GT. 0.D+00 ) THEN
               PROMAX = CCOF
            ELSE IF ( COSMAX .LT. -1.D+00 ) THEN
               PROMAX = ACOF - BCOF + CCOF
            ELSE
               PROMAX = ACOF * COSMAX**2 + BCOF * COSMAX + CCOF
            END IF
         ELSE IF ( ACOF .GT. ANGLGB ) THEN
            IF ( ACOF .GT. BCOF ) THEN
               PROMAX = ACOF - BCOF + CCOF
            ELSE
               PROMAX = CCOF
            END IF
         ELSE
            PROMAX = CCOF
         END IF
  200    CONTINUE
            FREJE = ( ACOF * COSLEG**2 + BCOF * COSLEG + CCOF ) / PROMAX
            CALL GRNDM(RNDM,2)
            IF ( RNDM (1) .GE. FREJE ) THEN
               COSLEG = - RNDM (2)
               GO TO 200
            END IF
      END IF
*=== End of subroutine cosleg =========================================*
      RETURN
      END
+DECK,  FEKFNC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:00  cernlib
* Geant

*$ CREATE FEKFNC.FOR
*COPY FEKFNC
*=== fekfnc ===========================================================*
      FUNCTION FEKFNC (PF,I)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, NUCGEO.
+CDE, NUCDAT.
*
      IF ( PFRCEN (I) - PF .LE. ANGLGB ) THEN
         FEKFNC = EKFCEN (I)
      ELSE
         FEKFNC = SQRT ( AMNUSQ (I) + PF**2 ) - AMNUCL (I)
      END IF
      RETURN
      END
+DECK,  FPFRNC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE FPFRNC.FOR
*COPY FPFRNC
*=== fpfrnc ===========================================================*
      FUNCTION FPFRNC (RHO,I)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, NUCGEO.
*
+CDE, NUCSTF.
*
      IF ( RHO .GE. RHOCOR ) THEN
         FPFRNC = PFCORE (RHO,I)
      ELSE IF ( RHO .GE. RHOSKN ) THEN
         FPFRNC = PFSKIN (RHO,I)
      ELSE IF ( RHO .GT. 0.D+00 ) THEN
         FPFRNC = PFHALO (RHO,I)
      ELSE
         FPFRNC = 0.D+00
      END IF
      RETURN
      END
+DECK,  FRADNC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE FRADNC.FOR
*COPY FRADNC
*=== fradnc ===========================================================*
      FUNCTION FRADNC (RHO)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, NUCGEO.
*
+CDE, NUCSTF.
*
      IF ( RHO .GE. RHOCOR ) THEN
         FRADNC = RACORE (RHO)
      ELSE IF ( RHO .GE. RHOSKN ) THEN
         FRADNC = RASKIN (RHO)
      ELSE IF ( RHO .GT. 0.D+00 ) THEN
         FRADNC = RAHALO (RHO)
      ELSE
         FRADNC = RADTOT
      END IF
      RETURN
      END
+DECK,  FRHINC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE FRHINC.FOR
*COPY FRHINC
*=== frhinc ===========================================================*
      FUNCTION FRHINC (R)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, NUCGEO.
*
+CDE, NUCSTF.
*
      IF ( R .LE. RADIU0 ) THEN
         FRHINC = RICORE (R)
      ELSE IF ( R .LE. RADIU1 ) THEN
         FRHINC = RISKIN (R)
      ELSE IF ( R .LE. RADTOT ) THEN
         FRHINC = RIHALO (R)
      ELSE
         FRHINC = RIHALO (RADTOT)
      END IF
      RETURN
      END
+DECK,  FRHONC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE FRHONC.FOR
*COPY FRHONC
*=== frhonc ===========================================================*
      FUNCTION FRHONC (R)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, NUCGEO.
*
+CDE, NUCSTF.
*
      IF ( R .LE. RADIU0 ) THEN
         FRHONC = RHCORE (R)
      ELSE IF ( R .LE. RADIU1 ) THEN
         FRHONC = RHSKIN (R)
      ELSE IF ( R .LE. RADTOT ) THEN
         FRHONC = RHHALO (R)
      ELSE
         FRHONC = 0.D+00
      END IF
      RETURN
      END
+DECK,  NCLVIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE NCLVIN.FOR
*COPY NCLVIN
*=== nclvin ===========================================================*
      SUBROUTINE NCLVIN

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, NUCLEV.
+CDE, NUCGEO.
*
      INUCLV = INUCLV + 1
      IPRNUC (1) = 0
      IPRNUC (2) = 0
      JPRNUC (1) = 0
      JPRNUC (2) = 0
      NPRNUC = 0
      RUSPRO = RADTOT
      RUSNEU = RADTOT
      NUSPRO = 0
      NUSNEU = 0
      NMXPRO = NAVPRO
      NMXNEU = NAVNEU
      DO 2000 I = 1,2
         IF ( NLSNUC (I) .LE. 1 ) JUSNUC (NAVNUC(I),I) = -1
         JMXNUC (I) = NTANUC (I)
         DEFRMI (I) = 0.6666666666666666D+00 * EKFCEN (I) / NTANUC (I)
         DEFMAG (I) = 0.D+00
         DO 1000 K = 1, MAGNUC (I)
            NUNFLL = MAGNUM (K) - NTANUC (I)
            IF ( NUNFLL .GT. 0 ) THEN
               MGSNUC (K,I) = -2 + MOD ( NUNFLL, 1 )
            ELSE
               MGSNUC (K,I) = 0
               IF ( NUNFLL .EQ. 0 ) DEFMAG (I) = MAX ( ZERZER,
     &              SHENUC (MAGNUM(K)+1,I) - SHENUC (MAGNUM(K),I)
     &            + PAENUC (NTANUC(I),I) )
            END IF
 1000    CONTINUE
 2000 CONTINUE
      RETURN
*=== End of subroutine nclvin =========================================*
      END
+DECK,  NCLVST, T=FORT.
* Revision 1.4  1996/11/13 13:08:05  ravndal
* Paramter ZERO at least real
* Revision 1.3  1996/05/03 09:46:12  cernlib
* Replace 0.0 in MAX() by ZERO to get the proper type;
* add parameter statement for ZERO
* Revision 1.2  1996/04/26 12:20:30  ravndal
* neg. SQRT protection
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE NCLVST.FOR
*COPY NCLVST
*=== nclvst ===========================================================*
      SUBROUTINE NCLVST ( NA, NZ )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
       PARAMETER (ZERO=0.)
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, NUCLEV.
*
      NTAPRO = NZ
      NTANEU = NA - NZ
      NAVPRO = MOD (NTAPRO,2)
      NLSPRO = 2 - NAVPRO
      NAVPRO = NTAPRO / 2 + NAVPRO
      NAVNEU = MOD (NTANEU,2)
      NLSNEU = 2 - NAVNEU
      NAVNEU = NTANEU / 2 + NAVNEU
      PROFAC = 2.D+00
*
      CUMRAD (0,1) = 0.D+00
      CUMRAD (0,2) = 0.D+00
      DO 2000 INC = 1,2
         DDNAV = NAVNUC(INC)
         DO 1000 JNC = 1, NAVNUC (INC)
            DDJNC = JNC
            PCEJNC = PFRCEN (INC) * ( DDJNC / DDNAV
     &             )**0.3333333333333333D+00
            EKCJNC = SQRT ( PCEJNC**2 + AMNUSQ (INC) ) - AMNUCL (INC)
            EKFJNC = EKFCEN (INC) - EKCJNC
            PFRJNC = SQRT (
     &      MAX( EKFJNC * ( EKFJNC + 2.D+00 * AMNUCL (INC) ), ZERO) )
            RHOJNC = RHOCEN * ( PFRJNC / PFRCEN (INC) )**3
            RADJNC = FRADNC (RHOJNC)
            IF ( JNC .LT. NAVNUC (INC) ) THEN
               CUMRAD (JNC,INC) = CUMRAD (JNC-1,INC) + PROFAC
     &                          / RADJNC**3
            ELSE
               CUMRAD (JNC,INC) = CUMRAD (JNC-1,INC) + NLSNUC (INC)
     &                          / RADJNC**3
            END IF
            IF ( RADJNC .LE. RADIU0 ) THEN
               NCONUC (INC) = JNC
            ELSE IF ( RADJNC .LE. RADIU1 ) THEN
               NSKNUC (INC) = JNC
            ELSE
               NHANUC (INC) = JNC
            END IF
 1000    CONTINUE
         DO 1500 K = 1,8
            IF ( NTANUC (INC) .LE. MAGNUM (K) ) THEN
               MAGNUC (INC) = K
               GO TO 2000
            END IF
 1500    CONTINUE
 2000 CONTINUE
      RETURN
*=== End of subroutine nclvst =========================================*
      END
+DECK,  NUCNUC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE NUCNUC.FOR
*COPY NUCNUC
*=== nucnuc ===========================================================*
      SUBROUTINE NUCNUC ( IKPMX , KRFLIN, WEE   , ERECMN, LBIMPC,
     &                    LBCHCK, ICYCL , NHOLE , NPROT , NNEUT ,
     &                    LEXIT , LNWINT )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, FINUC.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAREVT.
+CDE, PARNUC.
+CDE, PART.
+CDE, RESNUC.
*
      REAL RNDM(2)
      LOGICAL LBCHCK, LBIMPC, LTROUB, LEXIT, LNWINT
*
      NPNCLD = NPNUC
 1000 CONTINUE
      IF ( LELSTC ) THEN
         LELSTC = .FALSE.
         LNWINT = .FALSE.
      ELSE
         LEXIT  = .FALSE.
         LNWINT = .TRUE.
         RETURN
      END IF
      NHOLE = NHOLE + 1
      ICYCL = ICYCL + 1
      IF ( NUSCIN .LE. 0 ) THEN
         PXHLP  = PXFERM + PXPROJ - CXIMPC * PPRWLL
         PYHLP  = PYFERM + PYPROJ - CYIMPC * PPRWLL
         PZHLP  = PZFERM + PZPROJ - CZIMPC * PPRWLL
         ERECMN = 0.5D+00 * ( PXHLP**2 + PYHLP**2 + PZHLP**2 ) / AMNTAR
         ERECMN = ERECMN * ( 1.D+00 - 0.25D+00 * ERECMN )
         ERECMN = MAX ( ERECMN, EKFERM * AM (KNUCIM) / AMNTAR )
      ELSE
         ERECMN = EKFERM * AM (KNUCIM) / AMNTAR
      END IF
      ERECMN = 0.D+00
      POTINC = EKEWLL - EKECON + EKFERM
      IF ( NUSCIN .EQ. 0 .AND. KPRIN .NE. KNUCIM ) THEN
         ZAFT   = ZNOW + ICH (KPRIN) - ICH (KNUCIM)
         AMMAFT = ANOW * AMUAMU + 0.001D+00 * FKENER ( ANOW, ZAFT )
         AMNAFT = AMMAFT - ZAFT * AMELEC + ELBNDE (NINT(ZAFT))
         IF ( KPRIN .EQ. 1 ) THEN
            DEFRPR = DEFPRO
         ELSE
            DEFRPR = DEFNEU
         END IF
         IF ( KNUCIM .EQ. 8 ) THEN
            DEFRNU = MAX ( DEFNEU, HLFHLF * EEXANY + ERECMN
     &             + EKFERM - EKFIMP )
         ELSE
            DEFRNU = MAX ( DEFPRO, HLFHLF * EEXANY + ERECMN
     &             + EKFERM - EKFIMP )
         END IF
      ELSE IF ( NUSCIN .EQ. 0 ) THEN
         IF ( KPRIN .EQ. 1 ) THEN
            DEFRPR = MAX ( DEFPRO, HLFHLF * EEXANY + ERECMN
     &             + EKFERM - EKFIMP )
            DEFRNU = DEFRPR
         ELSE
            DEFRPR = MAX ( DEFNEU, HLFHLF * EEXANY + ERECMN
     &             + EKFERM - EKFIMP )
            DEFRNU = DEFRPR
         END IF
      ELSE
         ADDPRO = 0.D+00
         ADDTAR = 0.D+00
         IF ( KPRIN .EQ. 8 ) THEN
            DEFRPR = DEFNEU + ADDPRO
         ELSE
            DEFRPR = DEFPRO + ADDPRO
         END IF
         IF ( KNUCIM .EQ. 8 ) THEN
            DEFRNU = DEFNEU + ADDTAR
         ELSE
            DEFRNU = DEFPRO + ADDTAR
         END IF
      END IF
      NPLSIN = 2
      UMO2   = ERES**2 - PTRES2
      UMO    = SQRT (UMO2)
      GAMCM = ERES  / UMO
      ETAX  = PXRES / UMO
      ETAY  = PYRES / UMO
      ETAZ  = PZRES / UMO
      ETAPCM = ETAX * PXPROJ + ETAY * PYPROJ + ETAZ * PZPROJ
      ECMSPR = GAMCM * ( EKEWLL + AM (KPRIN) ) - ETAPCM
      PHELP  = EKEWLL + AM (KPRIN) - ETAPCM / ( GAMCM + 1.D+00 )
      PCMSX  = PXPROJ - ETAX * PHELP
      PCMSY  = PYPROJ - ETAY * PHELP
      PCMSZ  = PZPROJ - ETAZ * PHELP
      ETAPCM = ETAX * PXFERM + ETAY * PYFERM + ETAZ * PZFERM
      ECMSNU = GAMCM * ( EKFERM + AM (KNUCIM) ) - ETAPCM
      PCMS2  = PCMSX**2 + PCMSY**2 + PCMSZ**2
      PCMS   = SQRT ( PCMS2 )
      IF ( KPRIN .EQ. KNUCIM ) THEN
         EKESAM = 0.5D+00 * ( UMO2 - AM (KPRIN)**2 - AM (KNUCIM)**2 )
     &          / AM (KNUCIM) - AM (KPRIN)
         CALL SAMCST ( 1, EKESAM, COSTHE )
      ELSE IF ( KPRIN .EQ. 8 ) THEN
         EKESAM = 0.5D+00 * ( UMO2 - AM (KPRIN)**2 - AM (KNUCIM)**2 )
     &          / AM (KNUCIM) - AM (KPRIN)
         CALL SAMCST ( 8, EKESAM, COSTHE )
      ELSE
         EKESAM = 0.5D+00 * ( UMO2 - AM (KNUCIM)**2 - AM (KPRIN)**2 )
     &          / AM (KPRIN) - AM (KNUCIM)
         CALL SAMCST ( 8, EKESAM, COSTHE )
         COSTHE = - COSTHE
      END IF
      SINTHE = SQRT ( ( 1.D+00 - COSTHE ) * ( 1.D+00 + COSTHE ) )
 2000 CONTINUE
         CALL GRNDM(RNDM,2)
         RPHI1 = 2.D+00 * RNDM (1) - 1.D+00
         RPHI2 = 2.D+00 * RNDM (2) - 1.D+00
         RPHI12 = RPHI1 * RPHI1
         RPHI22 = RPHI2 * RPHI2
         RSQ = RPHI12 + RPHI22
      IF ( RSQ .GT. 1.D+00 ) GO TO 2000
      SINPHI = 2.D+00 * RPHI1 * RPHI2 / RSQ
      COSPHI = ( RPHI12 - RPHI22 ) / RSQ
      CZAXCM = PCMSZ / PCMS
      SINT02 = ( 1.D+00 - CZAXCM ) * ( 1.D+00 + CZAXCM )
      IF ( SINT02 .LT. ANGLSQ ) THEN
         CXCMS = COSPHI * SINTHE
         CYCMS = SINPHI * SINTHE
         CZCMS = CZAXCM * COSTHE
      ELSE
         SINTH0 = SQRT ( SINT02 )
         UPRIME = SINTHE * COSPHI
         VPRIME = SINTHE * SINPHI
         CXAXCM = PCMSX / PCMS
         CYAXCM = PCMSY / PCMS
         COSPH0 = CXAXCM / SINTH0
         SINPH0 = CYAXCM / SINTH0
         CXCMS = UPRIME * COSPH0 * CZAXCM - VPRIME * SINPH0
     &         + COSTHE * CXAXCM
         CYCMS = UPRIME * SINPH0 * CZAXCM + VPRIME * COSPH0
     &         + COSTHE * CYAXCM
         CZCMS = - UPRIME * SINTH0 + COSTHE * CZAXCM
      END IF
      PCMSX  = PCMS * CXCMS
      PCMSY  = PCMS * CYCMS
      PCMSZ  = PCMS * CZCMS
      NPNUC = NPNUC + 1
      KPNUCL (NPNUC) = KPRIN
      KRFNUC (NPNUC) = KRFLIN + 1
      ETAPCM = ETAX * PCMSX + ETAY * PCMSY + ETAZ * PCMSZ
      PHELP  = ECMSPR + ETAPCM / ( GAMCM + 1.D+00 )
      ENNUC  (NPNUC) = GAMCM * ECMSPR + ETAPCM
      IF ( ENNUC (NPNUC) - AM (KPRIN) .LE. EKFPRO + DEFRPR ) THEN
         NPNUC  = NPNUC - 1
         LBCHCK = .FALSE.
         IF ( LBIMPC ) THEN
            CALL BIMNXT ( LBCHCK )
            RHOMEM = 0.5D+00 * ( RHOIMP + RHOIMT )
            EKFMEM = 0.5D+00 * ( EKFIMP + EKFPRO )
         ELSE
            CALL NWINXT ( LBCHCK )
            IF ( BIMPCT .GT. RADTOT ) THEN
               NHOLE = NHOLE - 1
               ICYCL = ICYCL - 1
               CALL PHDSET ( IKPMX )
               IBRES = IBRES - IBAR (KPRIN)
               ICRES = ICRES - ICH  (KPRIN)
               BBRES = IBRES
               ZZRES = ICRES
               AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER
     &                ( BBRES, ZZRES)
               AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
               LTROUB = .FALSE.
               CALL UMOFIN ( IKPMX, BBRES, ZZRES, LTROUB )
               IF ( LTROUB ) THEN
                  KPNUCL (IKPMX) = 0
                  UMO2  = ERES**2 - PTRES2
                  UMO = SQRT (UMO2)
                  WRITE ( LUNOUT,* )' 0_P:UMO,AMNRES',UMO,AMNRES
                  IF ( KPRIN .EQ. 1 ) THEN
                     NPROT = NPROT + 1
                  ELSE
                     NNEUT = NNEUT + 1
                  END IF
                  LEXIT = .TRUE.
                  RETURN
               END IF
               EKNNUC = ENNUC (IKPMX) - AM (KPRIN)
               NP = NP + 1
               TKI   (NP) = ENNUC  (IKPMX) - AM (KPRIN)
               KPART (NP) = KPRIN
               PLR   (NP) = PNUCL  (IKPMX)
               CXR   (NP) = PXNUCL (IKPMX) / PLR (NP)
               CYR   (NP) = PYNUCL (IKPMX) / PLR (NP)
               CZR   (NP) = PZNUCL (IKPMX) / PLR (NP)
               WEI   (NP) = WEE
               KPNUCL (IKPMX) = 0
               IGREYP = IGREYP + ICH (KPRIN)
               IGREYN = IGREYN + 1 - ICH (KPRIN)
               PXINTR = PXINTR + PXNUCL (IKPMX)
               PYINTR = PYINTR + PYNUCL (IKPMX)
               PZINTR = PZINTR + PZNUCL (IKPMX)
               EINTR  = EINTR  + ENNUC  (IKPMX)
               IBINTR = IBINTR + IBAR   (KPART(NP))
               ICINTR = ICINTR + ICH    (KPART(NP))
               LEXIT  = .TRUE.
               RETURN
            END IF
            XSTNUC (IKPMX) = XIMPTR
            YSTNUC (IKPMX) = YIMPTR
            ZSTNUC (IKPMX) = ZIMPTR
            RSTNUC (IKPMX) = ABS (RIMPTR)
         END IF
         NHOLE = NHOLE - 1
         ICYCL = ICYCL - 1
         GO TO 1000
      END IF
      EKFNUC (NPNUC) = EKFPRO
      PXNUCL (NPNUC) = PCMSX + ETAX * PHELP
      PYNUCL (NPNUC) = PCMSY + ETAY * PHELP
      PZNUCL (NPNUC) = PCMSZ + ETAZ * PHELP
      PNUCL  (NPNUC) = SQRT ( PXNUCL (NPNUC)**2 + PYNUCL (NPNUC)**2
     &                      + PZNUCL (NPNUC)**2 )
      XSTNUC (NPNUC) = XIMPTR
      YSTNUC (NPNUC) = YIMPTR
      ZSTNUC (NPNUC) = ZIMPTR
      RSTNUC (NPNUC) = ABS (RIMPTR)
      RHNUCL (NPNUC) = RHOIMT
      NPNUC = NPNUC + 1
      KPNUCL (NPNUC) = KNUCIM
      KRFNUC (NPNUC) = KRFLIN + 1
      ETAPCM = - ETAPCM
      PHELP  = ECMSNU + ETAPCM / ( GAMCM + 1.D+00 )
      ENNUC  (NPNUC) = GAMCM * ECMSNU + ETAPCM
      IF ( ENNUC (NPNUC) - AM (KNUCIM) .LE. EKFIMP + DEFRNU ) THEN
         NPNUC  = NPNUC - NPLSIN
         LBCHCK = .FALSE.
         IF ( LBIMPC ) THEN
            CALL BIMNXT ( LBCHCK )
            RHOMEM = 0.5D+00 * ( RHOIMP + RHOIMT )
            EKFMEM = 0.5D+00 * ( EKFIMP + EKFPRO )
         ELSE
            CALL NWINXT ( LBCHCK )
            IF ( BIMPCT .GT. RADTOT ) THEN
               NHOLE = NHOLE - 1
               ICYCL = ICYCL - 1
               CALL PHDSET ( IKPMX )
               IBRES = IBRES - IBAR (KPRIN)
               ICRES = ICRES - ICH  (KPRIN)
               BBRES = IBRES
               ZZRES = ICRES
               AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER
     &                ( BBRES, ZZRES)
               AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
               LTROUB = .FALSE.
               CALL UMOFIN ( IKPMX, BBRES, ZZRES, LTROUB )
               IF ( LTROUB ) THEN
                  KPNUCL (IKPMX) = 0
                  UMO2  = ERES**2 - PTRES2
                  UMO = SQRT (UMO2)
                  WRITE ( LUNOUT,* )' 0_T:UMO,AMNRES',UMO,AMNRES
                  IF ( KPRIN .EQ. 1 ) THEN
                     NPROT = NPROT + 1
                  ELSE
                     NNEUT = NNEUT + 1
                  END IF
                  LEXIT = .TRUE.
                  RETURN
               END IF
               EKNNUC = ENNUC (IKPMX) - AM (KPRIN)
               NP = NP + 1
               TKI   (NP) = ENNUC  (IKPMX) - AM (KPRIN)
               KPART (NP) = KPRIN
               PLR   (NP) = PNUCL  (IKPMX)
               CXR   (NP) = PXNUCL (IKPMX) / PLR (NP)
               CYR   (NP) = PYNUCL (IKPMX) / PLR (NP)
               CZR   (NP) = PZNUCL (IKPMX) / PLR (NP)
               WEI   (NP) = WEE
               KPNUCL (IKPMX) = 0
               IGREYP = IGREYP + ICH (KPRIN)
               IGREYN = IGREYN + 1 - ICH (KPRIN)
               PXINTR = PXINTR + PXNUCL (IKPMX)
               PYINTR = PYINTR + PYNUCL (IKPMX)
               PZINTR = PZINTR + PZNUCL (IKPMX)
               EINTR  = EINTR  + ENNUC  (IKPMX)
               IBINTR = IBINTR + IBAR   (KPART(NP))
               ICINTR = ICINTR + ICH    (KPART(NP))
               LEXIT = .TRUE.
               RETURN
            END IF
            XSTNUC (IKPMX) = XIMPTR
            YSTNUC (IKPMX) = YIMPTR
            ZSTNUC (IKPMX) = ZIMPTR
            RSTNUC (IKPMX) = ABS (RIMPTR)
         END IF
         NHOLE = NHOLE - 1
         ICYCL = ICYCL - 1
         GO TO 1000
      END IF
      EKFNUC (NPNUC) = EKFIMP
      PXNUCL (NPNUC) = -PCMSX + ETAX * PHELP
      PYNUCL (NPNUC) = -PCMSY + ETAY * PHELP
      PZNUCL (NPNUC) = -PCMSZ + ETAZ * PHELP
      PNUCL  (NPNUC) = SQRT ( PXNUCL (NPNUC)**2 + PYNUCL (NPNUC)**2
     &                      + PZNUCL (NPNUC)**2 )
      XSTNUC (NPNUC) = XIMPCT
      YSTNUC (NPNUC) = YIMPCT
      ZSTNUC (NPNUC) = ZIMPCT
      RSTNUC (NPNUC) = ABS (RIMPCT)
      RHNUCL (NPNUC) = RHOIMP
      POTOUT = ENNUC (NPNUC) - AM (KPRIN) + ENNUC (NPNUC-1) - AM(KNUCIM)
     &       - EKECON
      LBIMPC = .FALSE.
      LEXIT  = .FALSE.
      NUSCIN = NUSCIN + 1
      ISCTYP (NUSCIN) = KPRIN * 10 + KNUCIM
      NHLEXP = NHLEXP + 1
      HOLEXP (NHLEXP) = EKFIMP - EKFERM
      RHOEXP = RHOEXP + 0.5D+00 * ( RHOIMP + RHOIMT )
      EKFEXP = EKFEXP + 0.5D+00 * ( EKFIMP + EKFPRO )
      CALL NCLVFX
      DO 3000 KP = NPNCLD+1, NPNUC
         KPNUC = KPNUCL (KP)
         IF ( AM (KPNUC) .LE. 0.D+00 ) THEN
            TAUTAU = RZNUCL / PNUCL (KP)
         ELSE
            TAUEFF = 0.5D+00 * TAUFOR * AM (13) / AM (KPNUC)
            CALL GRNDM(RNDM,1)
            TAUTAU = - TAUEFF / AM (KPNUC) * LOG ( 1.D+00 - RNDM
     &             (1) )
            TAUTAU = MAX ( TAUTAU, RZNUCL / PNUCL (KP) )
         END IF
         XSTNUC (KP) = XSTNUC (KP) + PXNUCL (KP) * TAUTAU
         YSTNUC (KP) = YSTNUC (KP) + PYNUCL (KP) * TAUTAU
         ZSTNUC (KP) = ZSTNUC (KP) + PZNUCL (KP) * TAUTAU
         RSTNUC (KP) = SQRT ( XSTNUC (KP)**2 + YSTNUC (KP)**2
     &               + ZSTNUC (KP)**2 )
 3000 CONTINUE
      RETURN
*=== End of subroutine Nucnuc =========================================*
      END
+DECK,  NWISEL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:01  cernlib
* Geant

*$ CREATE NWISEL.FOR
*COPY NWISEL
*=== nwisel ===========================================================*
      SUBROUTINE NWISEL ( IKN, LBCHCK )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, EVA0.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAREVT.
+CDE, PARNUC.
+CDE, PART.
+CDE, RESNUC.
*
      PARAMETER ( FEFFEC = 1.518066780142162 D+00 )
      PARAMETER ( BETMAX = 0.4 D+00 )
*
      REAL RNDM(1), RNGAUS, DUMNOR
*
      LOGICAL LBCHCK, LFERMI, LFRMCK, LLMDBR
*
      SAVE XBIMTR, YBIMTR, ZBIMTR, COSTHE, SINTHE, SIGMP0, EKENWI,
     &     SIGMN0, RHOBIM, RPRONU, RADPRP, RADPRN, DSKRED, RHRUSF,
     &     AUSFL , ZUSFL , PRCOLP, PRCOLN, KPROJ , IKPMX , LFRMCK
      SAVE SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1, SBHAL1
*
      LFRMCK = IKN .LT. 0
      IKPMX  = ABS (IKN)
      KPROJ  = KPNUCL (IKPMX)
      EKENWI = EKECON
      AUSFL  = IBTAR
      ZUSFL  = ICHTAR
      RHRUSF = 1.D+00
      BEPROJ = PNUCCO / ( EKENWI + AM (KPROJ) )
      RHOBIM = - AINFNT
*
      IF ( KPROJ .EQ. 1 .OR. KPROJ .EQ. 8 ) THEN
         IPWELL = 1 + KPROJ / 8
         WLLRED = 1.D+00
      ELSE
         IPWELL = ITNCMX
         IF ( IBAR (KPROJ) .EQ. 0 ) THEN
            IF ( KPROJ .LE. 11 ) THEN
               WLLRED = 0.D+00
            ELSE
               WLLRED = POTMES
            END IF
         ELSE
            WLLRED = POTBAR
         END IF
      END IF
      IF ( IBAR (KPROJ) .NE. 0 ) THEN
         RPRONU = 1.D+00
      ELSE IF ( KPROJ .NE. 7 ) THEN
         RPRONU = 0.8164965809277260D+00
      ELSE
         RPRONU = 0.D+00
      END IF
      IF ( LBCHCK ) THEN
         LFERMI = .FALSE.
         EKESIG = EKENWI
         PPRSIG = PNUCCO
         CALL SIGFER ( KPTOIP (KPROJ), EKESIG, PPRSIG, LFERMI )
         PRCOLP = ZUSFL / AUSFL * SIGMAP
         PRCOLN = ( AUSFL - ZUSFL ) / AUSFL * SIGMAN
         SIGMAA = PRCOLP + PRCOLN
         PRCOLP = PRCOLP / SIGMAA
         PRCOLN = 1.D+00 - PRCOLP
      END IF
      IF ( RPRONU .GT. ANGLGB ) THEN
         IF ( LPARWV ) THEN
            LLMDBR = .TRUE.
            TMP102 = 1.D-02
            PDEBRO = MAX ( PNUCL (IKPMX), TMP102 )
            DEBRLM = 0.5D+00 * PLABRC / PDEBRO
            RADCOR = 1.D+00
         ELSE
            LLMDBR = .FALSE.
            DEBRLM = 0.D+00
            RADCOR = 1.D+00
         END IF
      ELSE
         RADCOR = 0.D+00
         LLMDBR = .FALSE.
         DEBRLM = 0.D+00
      END IF
      RADCO2 = RADCOR
      RADPRO = MIN ( TWOTWO * RMSPRO * RPRONU * RADCOR, SKGT16 )
      RADPRP = RADPRO
      RADPRN = RADPRO
      CXIMPC = PXNUCL (IKPMX) / PNUCL (IKPMX)
      CYIMPC = PYNUCL (IKPMX) / PNUCL (IKPMX)
      CZIMPC = PZNUCL (IKPMX) / PNUCL (IKPMX)
      COSTHE = ( CXIMPC * XSTNUC (IKPMX) + CYIMPC * YSTNUC (IKPMX)
     &         + CZIMPC * ZSTNUC (IKPMX) ) / RSTNUC (IKPMX)
      SINTHE = SQRT ( 1.D+00 - MIN ( COSTHE * COSTHE, ONEONE ) )
      BIMPTR = RSTNUC (IKPMX) * SINTHE
      IF ( LLMDBR ) THEN
         BIMOLD = BIMPTR
         CALL GRNDM(RNDM,1)
         BIMPTR = BIMPTR + ( 2.D+00 * RNDM (1) - 1.D+00 )
     &          * DEBRLM
         CALL GRANOR ( RNGAUS, DUMNOR)
         HEISEX = DEBRLM * RNGAUS
         DSTMIN = - RSTNUC (IKPMX) * COSTHE
         XBIMTR = XSTNUC (IKPMX) + DSTMIN * CXIMPC
         YBIMTR = YSTNUC (IKPMX) + DSTMIN * CYIMPC
         ZBIMTR = ZSTNUC (IKPMX) + DSTMIN * CZIMPC
         XPARAL = XSTNUC (IKPMX) - XBIMTR
         YPARAL = YSTNUC (IKPMX) - YBIMTR
         ZPARAL = ZSTNUC (IKPMX) - ZBIMTR
         IF ( BIMOLD .GT. ANGLGB ) THEN
            BIMOLD = BIMPTR / BIMOLD
            XBIMTR = XBIMTR * BIMOLD
            YBIMTR = YBIMTR * BIMOLD
            ZBIMTR = ZBIMTR * BIMOLD
         ELSE
            CALL RACO ( CXHLP, CYHLP, CZHLP )
            XBIMTR = BIMPTR * ( CYHLP * CZIMPC - CZHLP * CYIMPC )
            YBIMTR = BIMPTR * ( CZHLP * CXIMPC - CXHLP * CZIMPC )
            ZBIMTR = BIMPTR * ( CXHLP * CYIMPC - CYHLP * CXIMPC )
         END IF
         XSTNUC (IKPMX) = XPARAL + XBIMTR + HEISEX * CXIMPC
         YSTNUC (IKPMX) = YPARAL + YBIMTR + HEISEX * CYIMPC
         ZSTNUC (IKPMX) = ZPARAL + ZBIMTR + HEISEX * CZIMPC
         RSTNUC (IKPMX) = SQRT ( XSTNUC (IKPMX)**2 + YSTNUC (IKPMX)**2
     &                  + ZSTNUC (IKPMX)**2 )
         COSTHE = ( CXIMPC * XSTNUC (IKPMX) + CYIMPC * YSTNUC (IKPMX)
     &          + CZIMPC * ZSTNUC (IKPMX) ) / RSTNUC (IKPMX)
         BIMPTR = ABS (BIMPTR)
         SINTHE = BIMPTR / MAX ( RSTNUC (IKPMX), ANGLGB )
      ELSE
         DSTMIN = - RSTNUC (IKPMX) * COSTHE
         XBIMTR = XSTNUC (IKPMX) + DSTMIN * CXIMPC
         YBIMTR = YSTNUC (IKPMX) + DSTMIN * CYIMPC
         ZBIMTR = ZSTNUC (IKPMX) + DSTMIN * CZIMPC
      END IF
      IF ( COSTHE .GE. 0.D+00 .AND. RSTNUC (IKPMX) .GE. RADTOT
     &   + RADPRO ) GO TO 4500
*
      SBUSED = 0.D+00
      IF ( BIMPTR .GT. RADTOT - RADPRO ) THEN
         BIMPCT = 0.5D+00 * ( RADTOT + BIMPTR - RADPRO )
         TRUFAC = BIMPCT / BIMPTR
         IF ( BIMPTR .GE. RADTOT ) THEN
            X1 = BIMPTR - RADTOT
            IF ( X1 .LE. RADPRO ) THEN
               ANGRED = ACOS ( 2.D+00 * X1 / ( RADPRO + X1 ) ) / PI
               X1 = X1 / ( R0PROT * RPRONU * RADCO2 )
               DSKRED = ( 0.5D+00 * X1 * X1 + X1 + 1.D+00 )
     &                * EXP (-X1) * ANGRED
            END IF
         ELSE
            X1 = RADPRO + BIMPTR - RADTOT
            ANGRED = ACOS ( 2.D+00 * X1 / ( RADPRO + X1 ) ) / PI
            X1 = X1 / ( R0PROT * RPRONU * RADCO2 )
            DSKRED = 1.D+00 - ( 0.5D+00 * X1 * X1 + X1 + 1.D+00 )
     &             * EXP (-X1) * ANGRED
         END IF
      ELSE
         BIMPCT = BIMPTR
         TRUFAC = 1.D+00
         DSKRED = 1.D+00
      END IF
      IF ( BIMPCT .LT. RADTOT ) THEN
         IF ( .NOT. LBCHCK ) THEN
            RHOSAV = RHOBIM
            RHOBIM = FRHONC ( BIMPCT )
            IF ( RHOBIM .EQ. RHOSAV ) GO TO 5500
            PFRBIM = FPFRNC ( RHOBIM, ITNCMX )
            EKFBIM = FEKFNC ( PFRBIM, ITNCMX )
            RHOHLP = FRHONC ( BIMPTR )
            PFRHLP = FPFRNC ( RHOHLP, IPWELL )
            PFRHLP = 0.5D+00 * PFRHLP * PFRHLP / AMNUSQ (IPWELL)
            VPRBIM = WLLRED * ( AMNUCL (IPWELL) * PFRHLP
     &             * ( 1.D+00 - 0.5D+00 * PFRHLP ) + BNDNUC )
            LFERMI = .TRUE.
            EKESIG = EKENWI
            PPRSIG = PNUCCO
            CALL SIGFER ( KPTOIP (KPROJ), EKESIG, PPRSIG, LFERMI )
            PRCOLP = ZUSFL / AUSFL * SIGMAP
            PRCOLN = ( AUSFL - ZUSFL ) / AUSFL * SIGMAN
            SIGMAA = PRCOLP + PRCOLN
            IF ( SIGMAA .GT. 0.D+00 ) THEN
               PRCOLP = PRCOLP / SIGMAA
               PRCOLN = 1.D+00 - PRCOLP
            ELSE
               PRCOLP = 0.D+00
               PRCOLN = 0.D+00
               XBIMPC = XBIMTR * TRUFAC
               YBIMPC = YBIMTR * TRUFAC
               ZBIMPC = ZBIMTR * TRUFAC
               GO TO 4500
            END IF
 5500       CONTINUE
         END IF
         XBIMPC = XBIMTR * TRUFAC
         YBIMPC = YBIMTR * TRUFAC
         ZBIMPC = ZBIMTR * TRUFAC
         IF ( COSTHE .GE. 0.D+00 ) THEN
            R0TRAJ = RSTNUC (IKPMX) * TRUFAC
            R1TRAJ = RADTOT
            IF ( R0TRAJ .GT. RADTOT ) GO TO 4500
         ELSE
            R0TRAJ = - MIN ( RSTNUC (IKPMX) * TRUFAC, RADTOT )
            R1TRAJ = RADTOT
         END IF
         CALL GRNDM(RNDM,1)
         ANMFP  = - LOG ( 1.D+00 - RNDM (1) ) / DSKRED
         IF ( BIMPCT .GT. RAD1O2 ) THEN
            SBTTSQ = 4.D+00 * ( RADTOT**2 - BIMPCT**2 ) * RHOBIM**2
            IF ( SBTTSQ .LE. ( ANMFP / SIGMAA )**2 ) GO TO 4500
         END IF
         CALL SBCOMP ( SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1, SBHAL1 )
         SBTOT  = SBHAL0 + SBSKI0 + SBCEN0 + SBCEN1 + SBSKI1 + SBHAL1
         SBTOT  = RHRUSF * SBTOT
         IF ( SBTOT * SIGMAA .GT. ANMFP ) GO TO 5000
      END IF
 4500 CONTINUE
      BIMPCT = RADTOT + RADPRO + 0.0001D+00
      IF ( BIMPTR .LT. BIMPCT ) THEN
         DSTMIN = SQRT ( BIMPCT**2 - BIMPTR**2 )
         RIMPTR = BIMPCT
         XIMPTR = XBIMTR + CXIMPC * DSTMIN
         YIMPTR = YBIMTR + CYIMPC * DSTMIN
         ZIMPTR = ZBIMTR + CZIMPC * DSTMIN
      ELSE
         XIMPTR = XBIMTR
         YIMPTR = YBIMTR
         ZIMPTR = ZBIMTR
         RIMPTR = BIMPTR
      END IF
      CXIMPC = -XIMPTR / RIMPTR
      CYIMPC = -YIMPTR / RIMPTR
      CZIMPC = -ZIMPTR / RIMPTR
      RETURN
      ENTRY NWINXT ( LBCHCK )
 4800 CONTINUE
         SIGMAP = SIGMP0
         SIGMAN = SIGMN0
 4900    CONTINUE
           CALL GRNDM(RNDM,1)
           ANMFP = - LOG ( 1.D+00 - RNDM (1) ) / DSKRED
         IF ( SBRES * SIGMAA .LE. ANMFP ) GO TO 4500
 5000 CONTINUE
      SBUSED = SBUSED * RHRUSF + ANMFP / SIGMAA
      SBRES  = SBTOT  - SBUSED
      SBUSED = SBUSED / RHRUSF
      CALL GRNDM(RNDM,1)
      IF ( RNDM (1) .LT. PRCOLP ) THEN
         KNUCIM = 1
         ITFRMI = 1
      ELSE
         KNUCIM = 8
         ITFRMI = 2
      END IF
      CALL RSCOMP ( SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1, SBHAL1 )
      RHOIMP = FRHONC ( ABS (RIMPCT) )
      PFRIMP = FPFRNC ( RHOIMP, ITFRMI )
      EKFIMP = FEKFNC ( PFRIMP, ITFRMI )
      RHOIMT = FRHONC ( ABS (RIMPTR) )
      PFRPRO = FPFRNC ( RHOIMT, IPWELL )
      EKFPRO = FEKFNC ( PFRPRO, IPWELL )
      VPRWLL = WLLRED * ( EKFPRO + BNDNUC )
      LELSTC = .TRUE.
      NTARGT = 1
      EKEWLL = EKENWI + VPRWLL
      EPSWLL = EKEWLL + AM (KPROJ)
      IF ( .NOT. LBCHCK ) THEN
         PPRWLL = SQRT ( EKEWLL * ( EKEWLL + 2.D+00 * AM (KPROJ) ) )
         PXPROJ = PPRWLL * CXIMPC
         PYPROJ = PPRWLL * CYIMPC
         PZPROJ = PPRWLL * CZIMPC
         PNFRMI = PFNCLV ( ITFRMI, .TRUE. )
         IF ( PNFRMI .LT. - 100.D+00 ) GO TO 4900
         CALL RACO ( PXFERM, PYFERM, PZFERM )
         PXFERM = PXFERM * PNFRMI
         PYFERM = PYFERM * PNFRMI
         PZFERM = PZFERM * PNFRMI
         EKFERM = SQRT ( PNFRMI**2 + AM (KNUCIM)**2 ) - AM (KNUCIM)
         ERES   = EKEWLL + AM (KPROJ) + AM (KNUCIM) + EKFERM
         PXRES  = PXPROJ + PXFERM
         PYRES  = PYPROJ + PYFERM
         PZRES  = PZPROJ + PZFERM
         PTRES2 = PXRES**2 + PYRES**2 + PZRES**2
         UMO2   = ERES**2 - PTRES2
         EKESIG = 0.5D+00 * ( UMO2 - AM (KPROJ)**2 - AM (KNUCIM)**2 )
     &          / AM (KNUCIM) - AM (KPROJ)
         EKFIMP = MAX ( EKFERM, EKFIMP )
      ELSE
         EKESIG = EKEWLL
      END IF
      PPRSIG = SQRT ( EKESIG * ( EKESIG + 2.D+00 * AM (KPROJ) ) )
      SIGMN0 = SIGMAN
      SIGMP0 = SIGMAP
      LFERMI = .FALSE.
      CALL SIGFER ( KPTOIP (KPROJ), EKESIG, PPRSIG, LFERMI )
      IF ( KNUCIM .EQ. 1 ) THEN
         SIGMAR = SIGMAP / SIGMP0
      ELSE
         SIGMAR = SIGMAN / SIGMN0
      END IF
      SIGMAR = MIN ( SIGMAR, ONEONE )
      CALL GRNDM(RNDM,1)
      RNDREJ = RNDM (1)
      IF ( RNDREJ .GE. SIGMAR ) GO TO 4800
      IF ( LBCHCK ) THEN
         ZITA   = 0.5D+00 * ( EKFIMP + EKFPRO ) / EKEWLL
         IF ( ZITA .LE. 0.5D+00 ) THEN
            PZITA = 1.D+00 - 1.4D+00 * ZITA
         ELSE
            PZITA = 1.D+00 - 1.4D+00 * ZITA + 0.4D+00 * ZITA
     &            * ( 2.D+00 - 1.D+00 / ZITA )**2.5D+00
         END IF
         RNDREJ = RNDREJ / SIGMAR
         IF ( RNDREJ .GE. PZITA ) GO TO 4800
      ELSE IF ( LFRMCK ) THEN
         EKFPRJ = EKFPRO + DEFNUC (IPWELL)
         EKFTAR = EKFIMP + DEFNUC (ITFRMI)
         IF ( EKEWLL + EKFERM .LE. EKFTAR + EKFPRJ ) GO TO 4800
         PCMSSQ = ( PXPROJ - 0.5D+00 * PXRES )**2
     &          + ( PYPROJ - 0.5D+00 * PYRES )**2
     &          + ( PZPROJ - 0.5D+00 * PZRES )**2
         RNDREJ = RNDREJ / SIGMAR
         PPROSQ = EKFPRJ * ( EKFPRJ + 2.D+00 * AM (KPROJ) )
         PTARSQ = EKFTAR * ( EKFTAR + 2.D+00 * AMNUCL (ITFRMI) )
         HLPHLP = PCMSSQ + 0.25D+00 * PTRES2
         HLPHL2 = PCMSSQ * PTRES2
         IF ( RNDREJ .GE. 0.5D+00 ) THEN
            RNDREJ = 2.D+00 * ( RNDREJ - 0.5D+00 )
            IF ( HLPHLP .LT. PTARSQ ) THEN
               COSQMX = 0.D+00
            ELSE
               COSQMX = ( HLPHLP - PTARSQ )**2 / HLPHL2
            END IF
            IF ( HLPHLP .GT. PPROSQ ) THEN
               COSQMN = 0.D+00
            ELSE
               COSQMN = ( PPROSQ - HLPHLP )**2 / HLPHL2
            END IF
         ELSE
            RNDREJ = 2.D+00 * RNDREJ
            IF ( HLPHLP .LT. PPROSQ ) THEN
               COSQMX = 0.D+00
            ELSE
               COSQMX = ( HLPHLP - PPROSQ )**2 / HLPHL2
            END IF
            IF ( HLPHLP .GT. PTARSQ ) THEN
               COSQMN = 0.D+00
            ELSE
               COSQMN = ( PTARSQ - HLPHLP )**2 / HLPHL2
            END IF
            COSQMX = ( 0.25D+00 * PTRES2 + PCMSSQ - PPROSQ )**2
     &             / ( PTRES2 * PCMSSQ )
         END IF
         RNDREJ = RNDREJ**2
         IF ( RNDREJ .GE. COSQMX .OR. RNDREJ .LT. COSQMN ) GO TO 4800
      END IF
      RETURN
*=== End of subroutine Nwisel =========================================*
      END
+DECK,  PEANUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:02  cernlib
* Geant

*$ CREATE PEANUT.FOR
*COPY PEANUT
*=== peanut ===========================================================*
      SUBROUTINE PEANUT ( KPROJ, EKE, PPROJ, TXX, TYY, TZZ, WEE )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
*
+CDE, BALANC.
+CDE, EVA0.
+CDE, FHEAVY.
+CDE, FINUC.
+CDE, HIGFIS.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAREVT.
+CDE, PARNUC.
+CDE, PART.
+CDE, RESNUC.
*
*
      COMMON / FKCOSP / C1ST (3), C2ND (3), LEMISS
      LOGICAL LEMISS
      COMMON / FKCMCY / NPCYCL (20,2), IEVT, LOUT
*
      COMMON / FKPLOC / IABCOU
      LOGICAL LBCHCK, LBIMPC, LTRPPD, LASSOR, LEXIT, LPRCYC, LEXPLC,
     &        LNWINT
      DIMENSION IPTYPE (39)
      REAL RNDM(2)
      SAVE IPTYPE
      DATA IPTYPE /  1,  2,  0,  0,  0,  0,  0,  1,  2,  0,  0,  0,
     &               3,  3,  4,  4,  5,  5,  0,  5,  5,  5,  3,  4,
     &               4,  0,  0,  0,  0,  0,  6,  6,  6,  7,  8,  7,
     &               8,  9, 10 /
*
*
      IEVPRE = IEVPRE + 1
      NUSCIN = 0
      IABCOU = 0
      IF ( EKE .GT. 2.D+00 * GAMMIN ) THEN
         EOTEST = ETTOT
         PTORI  = PPROJ
         PXORI  = PTORI * TXX
         PYORI  = PTORI * TYY
         PZORI  = PTORI * TZZ
      ELSE
         EOTEST = ETTOT - EKE
         ETTOT  = EOTEST
         PTORI  = 0.D+00
         PXTTOT = 0.D+00
         PYTTOT = 0.D+00
         PZTTOT = 0.D+00
         PTTOT  = 0.D+00
         PXORI  = 0.D+00
         PYORI  = 0.D+00
         PZORI  = 0.D+00
      END IF
      ETEPS  = 1.D-10 * ETTOT
      ICHTOT = ICHTAR + ICH  (KPROJ)
      IBTOT  = IBTAR  + IBAR (KPROJ)
      IBNUCL = IBTAR
      IBORI  = IBAR   (KPROJ)
      IPTORI = IPTYPE (KPTOIP(KPROJ))
      KPORI  = KPROJ
      EKORI  = EKE
      ZZTAR  = ICHTAR
      BBTAR  = IBTAR
      IF ( ICH (KPROJ) .NE. 0 .AND. EKE .GT. 2.D+00 * GAMMIN ) THEN
         FLKCOU = DOST ( 1, ZZTAR )
         CCOUL  = DOST ( 3, ZZTAR )
         CLMBBR = ICH (KPROJ) * COULBH * ZZTAR / RMASS (IBTAR)
         IF ( CLMBBR .GT. 0.9D+00 * EKE ) THEN
            TMPEKE = 0.98D+00 * EKE
            CLMHLP = MIN ( CLMBBR * FLKCOU, TMPEKE )
            CLMBBR = MIN  ( CLMBBR, EKE )
            WEIGH1 = 10.0D+00 * ( CLMBBR / EKE - 0.9D+00 )
            CLMBBR = WEIGH1 * CLMHLP + ( 1.D+00 - WEIGH1 ) * CLMBBR
         END IF
         BFCLMB = SQRT ( 1.D+00 - CLMBBR / EKE )
         RDCLMB = ICH (KPROJ) * COULPR * ZZTAR / CLMBBR
      ELSE
         CLMBBR = 0.D+00
         BFCLMB = 1.D+00
         RDCLMB = AINFNT
      END IF
      IBRES = IBTOT
      ICRES = ICHTOT
      BBRES = IBRES
      ZZRES = ICRES
      AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER ( BBRES, ZZRES )
      AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
      NPROT = 0
      NNEUT = 0
      NHOLE = 0
      AVEBIN = ( ( BBTAR - ZZTAR ) * AMNUCL (2) + ZZTAR * AMNUCL (1)
     &       - AMNTAR ) / BBTAR
      AMMHLP = ( BBTAR - 1.D+00 ) * AMUAMU + 1.D-03
     &       * FKENER ( BBTAR - ONEONE, ZZTAR - ONEONE )
      AMNHLP = AMMHLP - ( ZZTAR - 1.D+00 ) * AMELEC + ELBNDE (ICHTAR-1)
      BNENRG (1) = AMNHLP + AMNUCL (1) - AMNTAR
      AMMHLP = ( BBTAR - 1.D+00 ) * AMUAMU + 1.D-03
     &       * FKENER ( BBTAR - ONEONE, ZZTAR )
      AMNHLP = AMMHLP - ZZTAR * AMELEC + ELBNDE (ICHTAR)
      BNENRG (2) = AMNHLP + AMNUCL (2) - AMNTAR

      BNENRG (3) = 0.5D+00 * ( BNENRG (1) + BNENRG (2) )
      RHORED = 1.D+00
      NPNUC  = 0
      NNUCTS = 0
      NHLEXP = 0
      JNUCTS = 0
      ACOLL  = ANOW
      ZCOLL  = ZNOW
      IF ( .NOT. LPREEX ) THEN
         IF ( KPROJ .EQ. 1 .OR. KPROJ .EQ. 8 ) THEN
            LEXPLC = EKE .GT. 0.250D+00
         ELSE IF ( KPROJ .EQ. 14 .AND. PTTOT .LE. 0.D+00 ) THEN
            LEXPLC = .TRUE.
         ELSE
            STOP 'LEXPLC'
         END IF
      ELSE
         LEXPLC = .TRUE.
      END IF
      IF ( LEXPLC .AND. EKE .GT. IBAR(KPROJ) * EKEEXP ) THEN
         ICYCL  = 0
         IREINT = 0
         LPRCYC = .TRUE.
         LBCHCK = .FALSE.
         LBIMPC = .TRUE.
         LELSTC = .FALSE.
         LABRST = .FALSE.
         LABSRP = .FALSE.
         LINELS = .FALSE.
         LCHEXC = .FALSE.
         RHOEXP = 0.D+00
         EKFEXP = 0.D+00
         EKFREI = 0.D+00
         RHOREI = 0.D+00
         KPRIN  = KPROJ
         KRFLIN = 0
         ERECLD = 0.D+00
         BNPREV = 0.D+00
         EKECON = EKE
         PNUCCO = PPROJ
         CALL BIMSEL ( KPROJ, TXX, TYY, TZZ, LBCHCK )
         WLLPRO = WLLRED
         BNPROJ = WLLRED * BNDNUC
         RHOMEM = 0.5D+00 * ( RHOIMP + RHOIMT )
         EKFMEM = 0.5D+00 * ( EKFIMP + EKFPRO )
         IAAFT  = IBRES - IBAR (KPROJ)
         IZAFT  = ICRES - ICH  (KPROJ)
         CALL EEXLVL ( IAAFT, IZAFT, EEXDEL, EEXMIN, EEXDUM )
         EEXANY = EEXDEL
         IF ( ALPHAL .LE. 0.D+00 ) THEN
            DEFPRO = 0.D+00
            DEFNEU = 0.D+00
         ELSE
            DEFPRO = 0.D+00
            DEFNEU = 0.D+00
         END IF
         DEFNUC (1) = DEFPRO
         DEFNUC (2) = DEFNEU
  100    CONTINUE
         IF ( LELSTC ) THEN
            CALL NUCNUC ( IKPMX , KRFLIN, WEE   , ERECMN, LBIMPC,
     &                    LBCHCK, ICYCL , NHOLE , NPROT , NNEUT ,
     &                    LEXIT , LNWINT )
         ELSE IF ( KPRIN .EQ. 14 ) THEN
            CALL PIOABS ( IKPMX , KRFLIN, WEE   , ERECMN, LBIMPC,
     &                    LBCHCK, ICYCL , NHOLE , NPROT , NNEUT ,
     &                    LEXIT , LNWINT )
         ELSE
            STOP 'Int_kind'
         END IF
         IF ( LNWINT ) GO TO 100
         BBRES = IBRES
         ZZRES = ICRES
         IF ( .NOT. LEXIT ) THEN
            LPRCYC = .FALSE.
         ELSE
            BNPREV = BNPREV + BNDUSE
         END IF
  200    CONTINUE
         LELSTC = .FALSE.
         LABRST = .FALSE.
         LABSRP = .FALSE.
         LINELS = .FALSE.
         LCHEXC = .FALSE.
         GAMMAX = 0.D+00
         IREFMN = 10000
         IKPMX  = 0
         IBCHCK = 0
         ICCHCK = 0
         IBNUCL = 0
         ICNUCL = 0
         ILIVE  = 0
         LTRPPD = .FALSE.
         DO 300 KP = 1, NPNUC
            IF ( KPNUCL (KP) .LE. 0 ) GO TO 300
            ILIVE = ILIVE + 1
            KPNUC = KPNUCL (KP)
            IPTNUC = IPTYPE (KPTOIP(KPNUC))
            IF ( IPTNUC .EQ. 1 ) THEN
               BNDNU0 = BNENRG (1+KPNUC/8)
               WLLRE0 = POTBAR
            ELSE
               IF ( IBAR (KPNUC) .NE. 0 ) THEN
                  WLLRE0 = POTBAR
                  BNDNU0 = BNENRG (3)
               ELSE IF ( KPNUC .LE. 11 ) THEN
                  WLLRE0 = 0.D+00
                  BNDNU0 = 0.D+00
               ELSE
                  WLLRE0 = POTMES
                  BNDNU0 = BNENRG (3)
               END IF
            END IF
            IF ( EKFNUC (KP) .GT. -100.D+00 ) THEN
               GAMMA = ( ENNUC (KP) - WLLRE0 * ( EKFNUC (KP) + BNDNU0 )
     &               ) / AM (KPNUC)
            ELSE
               IF ( AM (KPNUC) .LE. ANGLGB ) THEN
                  GAMMA = AINFNT
               ELSE
                  GAMMA = ENNUC (KP) / AM (KPNUC)
               END IF
            END IF
            IF ( IBAR (KPNUC) .GT. 0 ) THEN
               IBNUCL = IBNUCL + IBAR (KPNUC)
               ICNUCL = ICNUCL + ICH  (KPNUC)
            END IF
            IBCHCK = IBCHCK + IBAR (KPNUC)
            ICCHCK = ICCHCK + ICH  (KPNUC)
            IF ( KRFNUC (KP) .LT. IREFMN ) THEN
               IREFMN = KRFNUC (KP)
               GAMMAX = GAMMA
               IKPMX  = KP
               WLLRED = WLLRE0
               BNDNUC = BNDNU0
            ELSE IF ( KRFNUC (KP) .EQ. IREFMN ) THEN
               IF ( GAMMA .GT. GAMMAX ) THEN
                  GAMMAX = GAMMA
                  IKPMX  = KP
                  WLLRED = WLLRE0
                  BNDNUC = BNDNU0
               END IF
            END IF
  300    CONTINUE
         IBNUCL = IBRES - IBNUCL - NPROT - NNEUT
         ICNUCL = ICRES - ICNUCL - NPROT
         ACOLL  = IBNUCL
         ZCOLL  = ICNUCL
         RHORED = ACOLL / BBTAR
         IF ( IKPMX .LE. 0 ) THEN
            IBCKC = IBTOT  - IBINTR - IBNUCR
            ICCKC = ICHTOT - ICINTR - ICNUCR
            IF ( IBCKC .NE. IBRES .OR. ICCKC .NE. ICRES ) THEN
               ICRES = ICCKC
               IBRES = IBCKC
            END IF
            NEXPEM = NP-NP0
            DO 450 IJJ = 1,IGREYN
               NPCYCL (IJJ,1) = 0
  450       CONTINUE
            DO 460 IJJ = 1,IGREYP
               NPCYCL (IJJ,2) = 0
  460       CONTINUE
            BBRES = IBRES
            ZZRES = ICRES
            ANOW  = BBRES
            ZNOW  = ZZRES
            AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER ( BBRES, ZZRES)
            AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
            PXRES = PXTTOT - PXNUCR - PXINTR
            PYRES = PYTTOT - PYNUCR - PYINTR
            PZRES = PZTTOT - PZNUCR - PZINTR
            PTRES2= PXRES**2 + PYRES**2 + PZRES**2
            PTRES = SQRT ( PTRES2 )
            ERES  = ETTOT - EINTR - ENUCR
            UMO2  = ( ERES - PTRES ) * ( ERES + PTRES )
            IF ( UMO2 .LT. ONEMNS*AMNRES**2 ) THEN
               UMO = SQRT (UMO2)
               WRITE ( LUNOUT,* )' 2:UMO,AMNRES',UMO,AMNRES
               GO TO 530
            ELSE IF ( UMO2 - AMNRES*AMNRES .LT. AMNRES*TVEPSI ) THEN
               UMO = SQRT (UMO2)
               GO TO 530
            END IF
            IF ( ICYCL .NE. NHOLE - IABCOU ) THEN
               WRITE (LUNOUT,*)' *** KPORI, ICYCL, NHOLE, IABCOU',
     &                               KPORI, ICYCL, NHOLE, IABCOU
               ICYCL = NHOLE - IABCOU
            END IF
            NPTOT  = NPROT + NNEUT
            NHLEXP = NHOLE
            IF ( .NOT. LPRCYC .OR. NPTOT .LE. 0 .OR. NNUCTS .GT. 0 )
     &         THEN
               LEMISS = .FALSE.
               NHOLE  = NHOLE + 1
               IF ( EKFREI .GT. ANGLGB ) THEN
                  RHOIMP = ( RHOEXP + RHOREI ) / NHOLE
                  EKFIMP = ( EKFEXP + EKFREI ) / NHOLE
               ELSE
                  RHOIMP = ( RHOEXP + RHOAVE ) / NHOLE
                  EKFIMP = ( EKFEXP + EKFAVE ) / NHOLE
               END IF
               ANPROT = NPROT
               ANNEUT = NNEUT
               ACOLL  = ACOLL - 1.D+00
               IF ( NPTOT .GT. 0 ) THEN
                  PNPROT = ( ZNOW - ANPROT ) * ( 3.D+00 * ANNEUT
     &                   + ANPROT ) / ( ANPROT * ( ZNOW - ANPROT
     &                   + 3.D+00 * ( ANOW - ANNEUT - ZNOW ) ) + ANNEUT
     &                   * ( 3.D+00 * ( ZNOW
     &                   - ANPROT ) + ANOW - ANNEUT - ZNOW ) )
               ELSE
                  PNPROT = ZNOW / ANOW
               END IF
               CALL GRNDM(RNDM,1)
               IF ( RNDM (1) .LT. PNPROT ) THEN
                  NPROT = NPROT + 1
                  ZCOLL = ZCOLL - 1.D+00
               ELSE
                  NNEUT = NNEUT + 1
               END IF
            ELSE
               RHOIMP = RHOEXP / NHLEXP
               EKFIMP = EKFEXP / NHLEXP
               IF ( ICYCL .EQ. 1 ) THEN
                  IF ( NP .LE. NP0 ) THEN
                     LEMISS = .FALSE.
                     ICYCL  = ICYCL - 1
                  ELSE
                     LEMISS = .TRUE.
                  END IF
               ELSE
                  LEMISS = .FALSE.
                  ICYCL  = ICYCL - 1
               END IF
            END IF
            GO TO 500
         END IF
         KPNUC  = KPNUCL (IKPMX)
         IPTNUC = IPTYPE (KPTOIP(KPNUC))
         ERECMN = MAX ( ERECLD, ERECMN )
         ERECLD = ERECMN
         ERECMN = ERECMN / ( ICYCL + IGREYP + IGREYN )
         IAAFT  = IBRES - IBAR (KPNUC)
         IZAFT  = ICRES - ICH  (KPNUC)
         CALL EEXLVL ( IAAFT, IZAFT, EEXDEL, EEXMIN, EEXDUM )
         IF ( NP .EQ. NP0 .AND. KPNUC .EQ. KPROJ ) THEN
            EEXANY = EEXDEL
         ELSE
            EEXANY = 0.D+00
         END IF
         AAFT = BBRES - IBAR (KPNUC)
         ZAFT = ZZRES - ICH  (KPNUC)
         AMMAFT = AAFT * AMUAMU + 0.001D+00 * FKENER ( AAFT, ZAFT )
         AMNAFT = AMMAFT - ZAFT * AMELEC + ELBNDE ( NINT (ZAFT) )
         IF ( WLLRED .GT. ANGLGB ) THEN
            IF ( EKFNUC (IKPMX) .GT. -100.D+00 ) THEN
               BNDGEN = IBAR (KPNUC) * AM (KPNUC) + AMNAFT - AMNRES
               IF ( NP .EQ. NP0 .AND. IPTNUC .EQ. IPTORI ) THEN
                  BNDUSE = BNPROJ + AMNAFT - AMNTAR + AM (KPNUC)
     &                   - AM (KPROJ)
               ELSE IF ( NP .EQ. NP0 ) THEN
                  IF ( IPTNUC .EQ. 1 ) THEN
                     BNDUSE = AMNAFT - AMNTAR + AM (KPNUC)
                     BNDUSE = MAX ( BNDUSE, ZERZER )
                  ELSE
                     BNDUSE = WLLRED * BNDNUC
                  END IF
               ELSE IF ( NUSCIN .EQ. 1 ) THEN
                  AMEMIT = 0.D+00
                  DO 430 KP = NP0+1, NP
                     IPTPAR = IPTYPE (KPTOIP(KPART(KP)))
                     IF ( IPTPAR .EQ. 1 .OR. IPTPAR .EQ. IPTORI )
     &               AMEMIT = AMEMIT + AM (KPTOIP(KPART(KP)))
  430             CONTINUE
                  IF ( IPTNUC .EQ. IPTORI ) THEN
                     BNTRUE = AMNAFT + AMEMIT + AM (KPNUC) - AMNTAR
     &                      - AM (KPROJ)
                     BNDUSE = BNPROJ + BNTRUE - BNPREV
                     BNDUSE = MAX ( BNDUSE, ZERZER )
                  ELSE IF ( IPTNUC .EQ. 1 ) THEN
                     BNDUSE = AMNAFT + AMEMIT + AM (KPNUC) - AMNTAR
     &                      - BNPREV
                     BNDUSE = MAX ( BNDUSE, ZERZER )
                  ELSE
                     BNDUSE = WLLRED * BNDNUC
                  END IF
               ELSE
                  BNDUSE = WLLRED * MAX ( BNDGEN, ZERZER )
               END IF
               EKFPRE = EKFNUC (IKPMX)
               VWELL0 = WLLRED * EKFNUC (IKPMX) + BNDUSE + ERECMN
               ENNUC  (IKPMX) = ENNUC (IKPMX) - VWELL0
               EKFNUC (IKPMX) = WLLRED * BNDNUC - BNDUSE - ERECMN
            ELSE
               BNDGEN = IBAR (KPNUC) * AM (KPNUC) + AMNAFT - AMNRES
               IF ( NP .EQ. NP0 .AND. KPNUC .EQ. KPORI ) THEN
                  BNDUSE = BNPROJ
               ELSE
                  BNDUSE = WLLRED * MAX ( BNDGEN, ZERZER )
               END IF
               EKFPRE = EKFAVE
               RHNUCL (IKPMX) = RHOAVE
               VWELL0 = BNDUSE - WLLRED * BNDNUC + ERECMN
               ENNUC  (IKPMX) = ENNUC (IKPMX) - VWELL0
               EKFNUC (IKPMX) = - VWELL0
            END IF
         ELSE
            VWELL0 = 0.D+00
            EKFNUC (IKPMX) = 0.D+00
            EKFPRE = 0.D+00
            BNDUSE = 0.D+00
         END IF
         EKNNUC = ENNUC (IKPMX) - AM (KPNUC)
         EKECON = EKNNUC - EKFNUC (IKPMX)
         IF ( ICH (KPNUC) .GT. 0 ) THEN
            FLKCOU = DOST ( 1, ZAFT )
            ETHRES = FLKCOU * ICH (KPNUC) * COULBH * ZAFT
     &             / RMASS ( NINT (AAFT) )
            IF ( EKNNUC .GT. ETHRES ) THEN
               LASSOR = .FALSE.
               FREJE  = 1.D+00 - ( ETHRES / EKNNUC )**3
               CALL GRNDM(RNDM,1)
               IF ( RNDM (1) .GE. FREJE ) LTRPPD = .TRUE.
            ELSE
               LASSOR = .TRUE.
            END IF
         ELSE
            ETHRES = 0.D+00
            IF ( EKNNUC .GT. ETHRES ) THEN
               LASSOR = .FALSE.
            ELSE
               LASSOR = .TRUE.
            END IF
         END IF
         IF ( LASSOR .OR. LTRPPD ) THEN
            IF ( KPNUC .EQ. 1 .OR. KPNUC .EQ. 8 ) THEN
               KPNUCL (IKPMX) = - KPNUCL (IKPMX)
               ENNUC (IKPMX) = ENNUC (IKPMX) - EKFNUC (IKPMX)
               EKFNUC (IKPMX) = -AINFNT
               NPROT  = NPROT + ICH (KPNUC)
               NNEUT  = NNEUT + 1 - ICH (KPNUC)
               IREINT = IREINT + 1
               LPRCYC = .FALSE.
               GO TO 200
            ELSE
               LTRPPD = .TRUE.
               STOP 'KPNUCL_TRAPPED'
            END IF
         ELSE
            LTRPPD = .FALSE.
         END IF
         IKPNWI = IKPMX
         IF ( KPNUC .EQ. 1 .OR. KPNUC .EQ. 8 ) THEN
            ETHMNM = ETHRES + EKEMNM
            ETHREI = MAX ( EKREXP, ETHMNM )
            IF ( EKECON .LT. ETHMNM ) THEN
               NPROT = NPROT + ICH (KPNUC)
               NNEUT = NNEUT + 1 - ICH (KPNUC)
               ENNUC  (IKPMX) = EKECON + AM (KPNUC)
               KPNUCL (IKPMX) = - KPNUCL (IKPMX)
               NNUCTS = NNUCTS + 1
               INUCTS (NNUCTS) = IKPMX
               JNUCTS = NUSCIN
               EKFNUC (IKPMX) = EKFPRE
               ENNUC  (IKPMX) = ENNUC (IKPMX) - BNDUSE + BNDGEN
               RSTNUC (IKPMX) = BNDGEN
               LPRCYC = .TRUE.
               GO TO 200
            ELSE IF ( EKECON .LT. ETHREI ) THEN
               LBCHCK = .FALSE.
               IKPNWI = - IKPMX
            ELSE
               LBCHCK = .FALSE.
            END IF
         ELSE
            LBCHCK = .FALSE.
         END IF
         PNUCCO = SQRT ( EKECON * ( EKECON + 2.D+00 * AM (KPNUC) ) )
         CALL NWISEL ( IKPNWI, LBCHCK )
  350    CONTINUE
         IF ( BIMPCT .GT. RADTOT .AND. .NOT. LTRPPD ) THEN
            KPRIN = KPNUC
            IF ( EKNNUC .NE. EKECON ) PNUCCO = SQRT ( EKNNUC * ( EKNNUC
     &         + 2.D+00 * AM (KPNUC) ) )
            IF ( ABS ( PNUCL (IKPMX) - PNUCCO ) .GT. ANGLGB * PNUCCO )
     &           CALL PHDSET ( IKPMX )
            IBRES = IBRES - IBAR (KPNUC)
            ICRES = ICRES - ICH  (KPNUC)
            BBRES = IBRES
            ZZRES = ICRES
            AMMRES = AMMAFT
            AMNRES = AMNAFT
            CALL UMOFIN ( IKPMX, BBRES, ZZRES, LTRPPD )
            EKNNUC = ENNUC (IKPMX) - AM (KPNUC)
            IF ( LTRPPD ) GO TO 350
            NP = NP + 1
            TKI   (NP) = ENNUC  (IKPMX) - AM (KPNUC)
            KPART (NP) = KPNUC
            PLR   (NP) = PNUCL  (IKPMX)
            CXR   (NP) = PXNUCL (IKPMX) / PLR (NP)
            CYR   (NP) = PYNUCL (IKPMX) / PLR (NP)
            CZR   (NP) = PZNUCL (IKPMX) / PLR (NP)
            WEI   (NP) = WEE
            KPNUCL (IKPMX) = 0
            IF ( KPNUC .EQ. 1 .OR. KPNUC .EQ. 8 ) THEN
               IGREYP = IGREYP + ICH (KPNUC)
               IGREYN = IGREYN + 1 - ICH (KPNUC)
               PXINTR = PXINTR + PXNUCL (IKPMX)
               PYINTR = PYINTR + PYNUCL (IKPMX)
               PZINTR = PZINTR + PZNUCL (IKPMX)
               EINTR  = EINTR  + ENNUC  (IKPMX)
               IBINTR = IBINTR + IBAR   (KPNUC)
               ICINTR = ICINTR + ICH    (KPNUC)
            ELSE
               IOTHER = IOTHER + 1
               PXNUCR = PXNUCR + PXNUCL (IKPMX)
               PYNUCR = PYNUCR + PYNUCL (IKPMX)
               PZNUCR = PZNUCR + PZNUCL (IKPMX)
               ENUCR  = ENUCR  + ENNUC  (IKPMX)
               IBNUCR = IBNUCR + IBAR   (KPNUC)
               ICNUCR = ICNUCR + ICH    (KPNUC)
            END IF
            BNPREV = BNPREV + BNDUSE
            IF ( IREINT .LE. 0 ) THEN
               LPRCYC = .TRUE.
            ELSE
               LPRCYC = .FALSE.
            END IF
            GO TO 200
         ELSE IF ( BIMPCT .GT. RADTOT ) THEN
            KRFNUC (IKPMX) = KRFNUC (IKPMX) + 1
            CALL GRNDM(RNDM,1)
            SINTHE = RNDM ( 1 )
            COSTHE = SQRT ( 1.D+00 - SINTHE )
            SINTHE = SQRT ( SINTHE )
  400       CONTINUE
               CALL GRNDM(RNDM,2)
               RPHI1 = 2.D+00 * RNDM (1) - 1.D+00
               RPHI2 = 2.D+00 * RNDM (2) - 1.D+00
               RPHI12 = RPHI1 * RPHI1
               RPHI22 = RPHI2 * RPHI2
               RSQ = RPHI12 + RPHI22
            IF ( RSQ .GT. 1.D+00 ) GO TO 400
            SINPHI = 2.D+00 * RPHI1 * RPHI2 / RSQ
            COSPHI = ( RPHI12 - RPHI22 ) / RSQ
            SINT02 = CXIMPC**2 + CYIMPC**2
            IF ( SINT02 .LT. ANGLSQ ) THEN
               PXNUCL (IKPMX) = COSPHI * SINTHE * PNUCCO
               PYNUCL (IKPMX) = SINPHI * SINTHE * PNUCCO
               PZNUCL (IKPMX) = CZIMPC * COSTHE * PNUCCO
            ELSE
               SINTH0 = SQRT ( SINT02 )
               UPRIME = SINTHE * COSPHI
               VPRIME = SINTHE * SINPHI
               COSPH0 = CXIMPC / SINTH0
               SINPH0 = CYIMPC / SINTH0
               PXNUCL (IKPMX) = ( UPRIME * COSPH0 * CZIMPC - VPRIME
     &                        * SINPH0 + COSTHE * CXIMPC ) * PNUCCO
               PYNUCL (IKPMX) = ( UPRIME * SINPH0 * CZIMPC + VPRIME
     &                        * COSPH0 + COSTHE * CYIMPC ) * PNUCCO
               PZNUCL (IKPMX) = ( - UPRIME * SINTH0 + COSTHE * CZIMPC )
     &                        * PNUCCO
            END IF
            PNUCL  (IKPMX) = PNUCCO
            XSTNUC (IKPMX) = XIMPTR
            YSTNUC (IKPMX) = YIMPTR
            ZSTNUC (IKPMX) = ZIMPTR
            RSTNUC (IKPMX) = ABS (RIMPTR)
            ENNUC (IKPMX) = EKECON + AM (KPNUC)
            EKFNUC (IKPMX) = -AINFNT
            GO TO 200
         ELSE
            IF ( ( KPNUC .EQ. 1 .OR. KPNUC .EQ. 8 ) .AND. EKECON .LE.
     &           ETHREI ) THEN
               KPNUCL (IKPMX) = - KPNUCL (IKPMX)
               ENNUC (IKPMX) = EKECON + AM (KPNUC)
               NPROT = NPROT + ICH (KPNUC)
               NNEUT = NNEUT + 1 - ICH (KPNUC)
               IF ( .NOT. LBCHCK .AND. IKPNWI .GT. 0 ) THEN
                  LPRCYC = .TRUE.
                  NNUCTS = NNUCTS + 1
                  INUCTS (NNUCTS) = IKPMX
                  JNUCTS = NUSCIN
                  EKFNUC (IKPMX) = EKFPRE
                  ENNUC  (IKPMX) = ENNUC (IKPMX) - BNDUSE + BNDGEN
                  RSTNUC (IKPMX) = BNDGEN
                  LPRCYC = .TRUE.
               ELSE
                  EKFNUC (IKPMX) = -AINFNT
                  IREINT = IREINT + 1
                  IF ( EKFREI .LT. ANGLGB ) THEN
                     EKFREI = 0.5D+00 * ( EKFIMP + EKFPRO )
                     RHOREI = 0.5D+00 * ( RHOIMP + RHOIMT )
                  END IF
                  LPRCYC = .FALSE.
               END IF
               GO TO 200
            END IF
            LBIMPC = .FALSE.
            KPRIN  = KPNUC
            KPNUCL (IKPMX) = 0
            KRFLIN = KRFNUC (IKPMX)
            IF ( EKNNUC .NE. EKECON ) PNUCCO = SQRT ( EKNNUC * ( EKNNUC
     &         + 2.D+00 * AM (KPRIN) ) )
            CXIMPC = PXNUCL (IKPMX) / PNUCL (IKPMX)
            CYIMPC = PYNUCL (IKPMX) / PNUCL (IKPMX)
            CZIMPC = PZNUCL (IKPMX) / PNUCL (IKPMX)
            XSTNUC (IKPMX) = XIMPTR
            YSTNUC (IKPMX) = YIMPTR
            ZSTNUC (IKPMX) = ZIMPTR
            RSTNUC (IKPMX) = ABS (RIMPTR)
            GO TO 100
         END IF
      END IF
      NEXPEM = 0
      IF ( LGDHPR ) THEN
         LBCHCK = .TRUE.
         EKECON = EKE
         PNUCCO = PPROJ
         CALL BIMSEL ( KPROJ, TXX, TYY, TZZ, LBCHCK )
         LELSTC = .FALSE.
         RHOIMP = 0.5D+00 * ( RHOIMP + RHOIMT )
         EKFIMP = 0.5D+00 * ( EKFIMP + EKFPRO )
         RHOMEM = RHOIMP
         EKFMEM = EKFIMP
      END IF
*
      ANOW  = BBRES
      ZNOW  = ZZRES
      PXRES = PXORI
      PYRES = PYORI
      PZRES = PZORI
      PTRES = PTORI
      ERES  = EKE  + AM (KPROJ) + AMNTAR
      IF ( LGDHPR ) THEN
         IF ( KPROJ .EQ. 1 ) THEN
            NPROT = NPROT + 1
         ELSE IF ( KPROJ .EQ. 8 ) THEN
            NNEUT  = NNEUT + 1
         END IF
         ACOLL = BBTAR - 1.D+00
         IF ( KNUCIM .EQ. 1 ) THEN
            NPROT = NPROT + 1
            ZCOLL = ZZTAR - 1.D+00
         ELSE
            NNEUT = NNEUT + 1
            ZCOLL = ZZTAR
         END IF
         NHOLE = NHOLE + 1
      ELSE
         ACOLL = BBTAR - 1.D+00
         IF ( KPROJ .EQ. 1 ) THEN
            NPROT = NPROT + 1
            PRPONP = ZNOW / ( 3.D+00 * ANOW - 2.D+00 * ZNOW )
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. PRPONP ) THEN
               NPROT = NPROT + 1
               ZCOLL = ZZTAR - 1.D+00
               IPRTYP = KPROJ * 10 + 1
            ELSE
               NNEUT = NNEUT + 1
               ZCOLL = ZZTAR
               IPRTYP = KPROJ * 10 + 8
            END IF
            NHOLE = NHOLE + 1
         ELSE IF ( KPROJ .EQ. 8 ) THEN
            NNEUT  = NNEUT + 1
            PRNONP = 3.D+00 * ZNOW / ( 2.D+00 * ZNOW + ANOW )
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. PRNONP ) THEN
               NPROT = NPROT + 1
               ZCOLL = ZZTAR  - 1.D+00
               IPRTYP = KPROJ * 10 + 1
            ELSE
               NNEUT = NNEUT + 1
               ZCOLL = ZZTAR
               IPRTYP = KPROJ * 10 + 8
            END IF
            NHOLE = NHOLE + 1
         ELSE
            STOP 'KPROJ'
         END IF
      END IF
      ICYCL  = 0
      LEMISS = .FALSE.
  500 CONTINUE
      CALL PREPRE ( WEE, NNEUT, NPROT, NHOLE, ICYCL )
  530 CONTINUE
      IF ( IBRES .GT. 0 ) THEN
         EKR0   = ERES - AMNRES
         ATTNUM = ELBNDE (ICHTAR) - ELBNDE (ICRES) - EKR0 * ( AMMRES
     &          - AMNRES ) / AMMRES
         ERES   = ERES + AMMTAR - AMNTAR - ( ZZTAR - ZNOW ) * AMELEC
     &          + ATTNUM
         EKRES  = ERES - AMMRES
      ELSE
         AMMRES = 0.D+00
         AMNRES = 0.D+00
         ERES   = 0.D+00
         EKR0   = 0.D+00
         EKRES  = 0.D+00
         TVTENT = 0.D+00
         GO TO 600
      END IF
      IF ( EKRES .LE. 0.D+00 ) THEN
         WRITE ( LUNERR,* )' Peanut: negative kinetic energy for',
     &                     ' the residual nucleus!!',ICRES,IBRES,
     &                       REAL (EKRES)
         IF ( EKRES .LT. -3.D-3 ) THEN
            LRESMP = .TRUE.
            RETURN
         END IF
         EKRES  = 0.D+00
         TVRECL = 0.D+00
         AMSTAR = AMMRES
         TVCMS  = 0.D+00
         PTRES2 = 0.D+00
         PXRES  = 0.D+00
         PYRES  = 0.D+00
         PZRES  = 0.D+00
         PTRES  = 0.D+00
      ELSE
         PTRES2 = PTRES * PTRES
         AMSTAR = ( ERES - PTRES ) * ( ERES + PTRES )
         IF ( AMSTAR .GE. AMMRES**2 ) THEN
            AMSTAR = SQRT ( AMSTAR )
            TVCMS  = AMSTAR - AMMRES
         ELSE IF ( AMMRES**2 - AMSTAR .LT. 2.D+00 * AMSTAR * TVEPSI
     &             ) THEN
            AMSTAR = AMMRES
            ERES   = SQRT ( AMSTAR**2 + PTRES**2 )
            TVCMS  = 0.D+00
         ELSE IF ( AMSTAR .LE. 0.D+00 ) THEN
            WRITE ( LUNERR,* )' Peanut: immaginary mass for',
     &                        ' the residual nucleus!!',ICRES,IBRES,
     &                          REAL (AMSTAR)
            LRESMP = .TRUE.
            RETURN
         ELSE
            AMSTAR = SQRT ( AMSTAR )
            IF ( AMMRES - AMSTAR .LT. TVEPSI ) THEN
               AMSTAR = AMMRES
               TVCMS  = 0.D+00
               TVRECL = ERES - AMSTAR
               GO TO 550
            END IF
            WRITE ( LUNERR,* )' Peanut: negative excitation energy for',
     &                        ' the residual nucleus!!',ICRES,IBRES,
     &                          REAL ( AMSTAR - AMMRES )
            IF ( AMSTAR - AMMRES .LT. -3.D-3 ) THEN
               LRESMP = .TRUE.
               RETURN
            END IF
            AMSTAR = AMMRES
            TVCMS  = 0.D+00
            HELP   = SQRT ( ( ERES - AMMRES ) * ( ERES + AMMRES ) )
     &             / PTRES
            PXRES = PXRES * HELP
            PYRES = PYRES * HELP
            PZRES = PZRES * HELP
            PTRES = PTRES * HELP
         END IF
         TVRECL = ERES - AMSTAR
      END IF
  550 CONTINUE
      IF ( TVRECL .LT. 0.D+00 ) THEN
         TVRECL = 0.D+00
      END IF
      TV     = 0.D+00
      EKRES  = TVRECL
  600 CONTINUE
      EOTEST = EOTEST - EINTR - ENUCR - EKR0 - AMNRES
      IF ( ABS (EOTEST) .GT. ETEPS ) THEN
         WRITE (LUNERR,*)' Peanut: eotest failure',EOTEST
         LRESMP = .TRUE.
         RETURN
      END IF
      IF ( IBRES .EQ. 0 ) RETURN
      EOTEST = ETTOT + AMMTAR - AMNTAR + ATTNUM
      IF ( KPROJ .EQ. 1 ) THEN
         EOTEST = EOTEST + AMHEAV (2) - AM (1)
      ELSE IF ( KPROJ .EQ. 8 ) THEN
         EOTEST = EOTEST + AMHEAV (1) - AM (8)
      ELSE
         EOTEST = EOTEST + ICH(KPROJ) * AMELEC
      END IF
      IF ( LEVPRT ) THEN
         CALL EVEVAP ( WEE )
         IF ( LRESMP ) RETURN
      ELSE
         TVHEAV = 0.D+00
      END IF
      DO 1000 KP = NP0+1,NP
         IF ( KPART (KP) .EQ. 1 ) THEN
            EOTEST = EOTEST - TKI (KP) - AMHEAV (2)
            IBTOT  = IBTOT  - 1
            ICHTOT = ICHTOT - 1
         ELSE IF ( KPART (KP) .EQ. 8 ) THEN
            EOTEST = EOTEST - TKI (KP) - AMHEAV (1)
            IBTOT  = IBTOT  - 1
         ELSE
            EOTEST = EOTEST - TKI (KP) - AM (KPART(KP))
            IBTOT  = IBTOT  - IBAR (KPART(KP))
            ICHTOT = ICHTOT - ICH  (KPART(KP))
         END IF
 1000 CONTINUE
      EOTEST = EOTEST - TVHEAV - IEVDEU * AMHEAV (3)
     &       - IEVTRI * AMHEAV (4)
     &       - IEV3HE * AMHEAV (5)
     &       - IEV4HE * AMHEAV (6)
     &       - AMMRES - TVRECL
      IBTOT  = IBTOT  - IEVDEU * 2 - IEVTRI * 3 - IEV3HE * 3
     &       - IEV4HE * 4
      ICHTOT = ICHTOT - IEVDEU - IEVTRI - IEV3HE * 2
     &       - IEV4HE * 2
      IF ( LRNFSS ) THEN
         IF ( LHEAVY ) THEN
            DO 2000 JP = 1, NPHEAV
               IF ( KHEAVY (JP) .GT. 6 ) THEN
                  EOTEST = EOTEST - AMHEAV (JP)
                  IBTOT  = IBTOT  - IBHEAV (KHEAVY(JP))
                  ICHTOT = ICHTOT - ICHEAV (KHEAVY(JP))
               END IF
 2000       CONTINUE
         ELSE
            DO 2100 JFISS = 1, NFISS
               IBHLP = NINT (ATFIS(JFISS))
               IF ( IBHLP .GT. 0 ) THEN
                  ICHLP  = NINT (ZTFIS(JFISS))
                  EOTEST = EOTEST - 1.D-03 * AMTFIS (JFISS)
                  IBTOT  = IBTOT  - IBHLP
                  ICHTOT = ICHTOT - ICHLP
               END IF
 2100       CONTINUE
         END IF
      END IF
      IF ( ABS (EOTEST) .GT. 1.D+3 * ETEPS ) THEN
         WRITE (LUNERR,*)
     &   ' Peanut failure!!, Eotest,Ammres,Tvrecl,Ibres,Icres',
     &                       EOTEST,AMMRES,TVRECL,IBRES,ICRES
      END IF
      IF ( IBTOT .NE. IBRES .OR. ICHTOT .NE. ICRES ) THEN
         WRITE (LUNERR,*)
     &   ' Peanut failure!!, Ichtot, Icres, Ibtot, Ibres',
     &                       ICHTOT, ICRES, IBTOT, IBRES
      END IF
*=== End of subroutine peanut =========================================*
      RETURN
      END
+DECK,  PFNCLV, T=FORT.
* Revision 1.2  1996/09/30 14:25:47  ravndal
* Windows NT related modifications
* Revision 1.1.1.1  1995/10/24 10:22:02  cernlib
* Geant

*$ CREATE PFNCLV.FOR
*COPY PFNCLV
*=== pfnclv ===========================================================*
      FUNCTION PFNCLV ( INC, LINNEW )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, EVA0.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, NUCLEV.
*
      LOGICAL LINNEW, LOCSEL
      DIMENSION RADSCB (2), DEFPAI (2), DEFSHE (2), NMSHLL (2)
      REAL RNDM(1)
      SAVE RADSCB, DEFPAI, DEFSHE, NMSHLL, NLEVEL, LOCSEL
      DATA LOCSEL / .FALSE. /
*
*======================================================================*
*======================================================================*
*
      I = INC
      IF ( ABS (RIMPCT) .GT. RUSNUC (I) ) THEN
         PFNCLV = - AINFNT
         RETURN
      END IF
      IF ( LINNEW ) THEN
         EKFCHC = EKFIMP
      ELSE
         EKFCHC = EKFIM2
      END IF
      EKCENT = EKFCEN (I) - EKFCHC
      EKCENT = EKFCEN (I) - EKFCHC
      EKCENT = MAX ( EKCENT, ZERZER )
      JMIN = INT ( NAVNUC (I) * ( SQRT ( EKCENT * ( EKCENT + 2.D+00
     &     * AMNUCL (I) ) ) / PFRCEN (I) )**3 ) + 1
      JMAX = NAVNUC (I)
      PROBTT = JMAX - JMIN + 1
      CALL GRNDM(RNDM,1)
      RNDJTA = RNDM (1) * PROBTT
      JMAX   = MIN ( INT (RNDJTA) + JMIN, JMAX )
      CUMMAX = CUMRAD (JMAX,I)
      IF ( LINNEW ) THEN
         NPRNUC = 1
         IF ( JUSNUC (JMAX,I) .EQ. INUCLV ) THEN
            P_FNCLV = - AINFNT
            PFNCLV = P_FNCLV
            RETURN
         ELSE IF ( JUSNUC (JMAX,I) .EQ. -INUCLV ) THEN
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. 0.5D+00 ) THEN
               P_FNCLV = - AINFNT
               PFNCLV = P_FNCLV
               RETURN
            END IF
            DEFPAI (I) = 0.D+00
         ELSE
            IF ( JUSNUC (JMAX,I) .NE. -1 ) THEN
               DEFPAI (I) = PAENUC ( NTANUC (I), I )
            ELSE
               DEFPAI (I) = 0.D+00
            END IF
         END IF
         PFCHCK = PFRIMP
         PCJMAX = PFRCEN (I) * RMASS (JMAX) / RMASS (NAVNUC(I))
         EKCJMX = SQRT ( PCJMAX**2 + AMNUSQ (I) ) - AMNUCL (I)
         EKFERM = EKFCHC + EKCJMX - EKFCEN (I)
         P_FNCLV = SQRT ( EKFERM * ( EKFERM + 2.D+00 * AMNUCL (I) ) )
         IO = 2 - I/2
         DEFPAI (IO) = 0.D+00
         DEFSHE (IO) = DEFMAG (IO)
      ELSE
         NPRNUC = NPRNUC + 1
         IF ( JUSNUC (JMAX,I) .EQ. INUCLV ) THEN
            P_FNCLV = - AINFNT
            PFNCLV = P_FNCLV
            RETURN
         ELSE IF ( I .EQ. IPRNUC (1) .AND. JMAX .EQ. JPRNUC (1) ) THEN
            IF ( JUSNUC (JMAX,I) .EQ. -INUCLV .OR. JUSNUC (JMAX,I) .EQ.
     &         -1 ) THEN
               P_FNCLV = - AINFNT
               PFNCLV = P_FNCLV
               RETURN
            END IF
         ELSE IF ( JUSNUC (JMAX,I) .EQ. -INUCLV ) THEN
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. 0.5D+00 ) THEN
               P_FNCLV = - AINFNT
               PFNCLV = P_FNCLV
               RETURN
            END IF
         ELSE
            IF ( JUSNUC (JMAX,I) .NE. -1 ) DEFPAI (I) = DEFPAI (I)
     &                                     + PAENUC ( NTANUC (I), I )
         END IF
         PFCHCK = PFRIM2
         PCJMAX = PFRCEN (I) * RMASS (JMAX) / RMASS (NAVNUC(I))
         EKCJMX = SQRT ( PCJMAX**2 + AMNUSQ (I) ) - AMNUCL (I)
         EKFER2 = EKFCHC + EKCJMX - EKFCEN (I)
         P_FNCLV = SQRT ( EKFER2 * ( EKFER2 + 2.D+00 * AMNUCL (I) ) )
      END IF
      PFNCLV = MIN ( P_FNCLV, PFCHCK )
      IF ( JMAX .EQ. NAVNUC (I) ) THEN
         RADSCB (NPRNUC) = NLSNUC (I) / ( CUMMAX - CUMRAD (JMAX-1,I) )
         NLEVEL = NLSNUC (I)
         JNUCLN = 2 * ( JMAX - 1 ) + NLEVEL
      ELSE
         RADSCB (NPRNUC) = 2.D+00 / ( CUMMAX - CUMRAD (JMAX-1,I) )
         NLEVEL = 2
         JNUCLN = 2 * JMAX
      END IF
      IPRNUC (NPRNUC) = I
      JPRNUC (NPRNUC) = JMAX
      DO 3000 MG = MAGNUC (I), 2
         IF ( MAGNUM (MG-1) .LT. JNUCLN ) GO TO 4000
 3000 CONTINUE
      MG = 1
 4000 CONTINUE
      NMSHLL (NPRNUC) = MG
      IF ( MGSNUC (MG,I) .EQ. 0 .AND. NTANUC (I) .NE. MAGNUM (MG) ) THEN
         DEFSHE (I) = SHENUC ( MAGNUM (MG) + 1, I )
     &              - SHENUC ( MAGNUM (MG), I ) + PAENUC (MAGNUM(MG),I)
     &              + DEFMAG (I)
      ELSE
         DEFSHE (I) = DEFMAG (I)
      END IF
      IF ( NUSCIN .EQ. 0 ) THEN
         DEFNUC (1) = MAX ( DEFSHE (1), ZERZER )
         DEFNUC (2) = MAX ( DEFSHE (2), ZERZER )
      ELSE
         DEFNUC (1) = MAX ( DEFPAI (1) + DEFRMI (1), DEFSHE (1), ZERZER)
         DEFNUC (2) = MAX ( DEFPAI (2) + DEFRMI (2), DEFSHE (2), ZERZER)
      END IF
      RETURN
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
      ENTRY NCLVFX
      NCLVFX = PIPIPI
      DO 5000 N=1,NPRNUC
         I = IPRNUC (N)
         J = JPRNUC (N)
         IF ( MOD (MGSNUC(NMSHLL(N),I),2) .EQ. 0 )
     &      MGSNUC (NMSHLL(N),I) = MGSNUC (NMSHLL(N),I) + 1
         IF ( JUSNUC (J,I) .EQ. -INUCLV .OR. JUSNUC (J,I) .EQ. -1 ) THEN
            JUSNUC (J,I) = INUCLV
            IF ( J .GE. JMXNUC (I) ) THEN
               JMXNUC (I) = JMXNUC (I) - NLEVEL
               RUSNUC (I) = RADSCB (N)**0.3333333333333333D+00
            END IF
         ELSE
            JUSNUC (J,I) = -INUCLV
         END IF
         NUSNUC (I) = NUSNUC (I) + 1
 5000 CONTINUE
      RETURN
*=== End of function pfnclv ===========================================*
      END
+DECK,  PHDSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:02  cernlib
* Geant

*$ CREATE PHDSET.FOR
*COPY PHDSET
*=== phdset ===========================================================*
      SUBROUTINE PHDSET ( IKPMX )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, NUCGEO.
+CDE, PARNUC.
+CDE, PART.
*
 1000 CONTINUE
      PDIFF = PNUCL (IKPMX) - PNUCCO
      IF ( PDIFF .LT. - ANGLGB ) THEN
         PNUCL0 = PNUCL (IKPMX)
         PNUCL (IKPMX) = PNUCCO
         PDTCMP = - ( PXNUCL (IKPMX) * CXIMPC + PYNUCL (IKPMX)
     &          * CYIMPC + PZNUCL (IKPMX) * CZIMPC )
         DELTAE = PDTCMP**2 - PNUCL0**2 + PNUCL (IKPMX)**2
         DELTAP = - PDTCMP + SQRT ( DELTAE )
         PXNUCL (IKPMX) = PXNUCL (IKPMX) + DELTAP * CXIMPC
         PYNUCL (IKPMX) = PYNUCL (IKPMX) + DELTAP * CYIMPC
         PZNUCL (IKPMX) = PZNUCL (IKPMX) + DELTAP * CZIMPC
      ELSE IF ( PDIFF .GT. ANGLGB ) THEN
         PNUCL0 = PNUCL (IKPMX)
         PNUCL (IKPMX) = PNUCCO
         PDTCMP = PXNUCL (IKPMX) * CXIMPC + PYNUCL (IKPMX)
     &          * CYIMPC + PZNUCL (IKPMX) * CZIMPC
         IF ( PDTCMP .GE. 0.D+00 ) THEN
            PNUCL0 = PNUCL (IKPMX) / PNUCL0
            PXNUCL (IKPMX) = PXNUCL (IKPMX) * PNUCL0
            PYNUCL (IKPMX) = PYNUCL (IKPMX) * PNUCL0
            PZNUCL (IKPMX) = PZNUCL (IKPMX) * PNUCL0
         ELSE
            DELTAE = PDTCMP**2 - PNUCL0**2 + PNUCL (IKPMX)**2
            IF ( DELTAE .LT. 0.D+00 ) THEN
               DELTAP = - PDTCMP
               PXNUCL (IKPMX) = PXNUCL (IKPMX) + DELTAP * CXIMPC
               PYNUCL (IKPMX) = PYNUCL (IKPMX) + DELTAP * CYIMPC
               PZNUCL (IKPMX) = PZNUCL (IKPMX) + DELTAP * CZIMPC
               PNUCL0 = SQRT ( PXNUCL (IKPMX)**2
     &                + PYNUCL (IKPMX)**2 + PZNUCL (IKPMX)**2 )
               PNUCL0 = PNUCL (IKPMX) / PNUCL0
               PXNUCL (IKPMX) = PXNUCL (IKPMX) * PNUCL0
               PYNUCL (IKPMX) = PYNUCL (IKPMX) * PNUCL0
               PZNUCL (IKPMX) = PZNUCL (IKPMX) * PNUCL0
            ELSE
               DELTAP = - PDTCMP - SQRT ( DELTAE )
               PXNUCL (IKPMX) = PXNUCL (IKPMX) + DELTAP * CXIMPC
               PYNUCL (IKPMX) = PYNUCL (IKPMX) + DELTAP * CYIMPC
               PZNUCL (IKPMX) = PZNUCL (IKPMX) + DELTAP * CZIMPC
            END IF
         END IF
      END IF
      RETURN
*=== End of subroutine phdset =========================================*
      END
+DECK,  PHDWLL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:02  cernlib
* Geant

*$ CREATE PHDWLL.FOR
*COPY PHDWLL
*=== phdwll ===========================================================*
      SUBROUTINE PHDWLL ( UBIMPT, VBIMPT, WBIMPT )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, NUCGEO.
+CDE, PARNUC.
+CDE, PART.
*
 1000 CONTINUE
      PDIFF = PNUCCO - PPRWLL
      IF ( PDIFF .LT. - ANGLGB ) THEN
         IF ( RIMPTR .LE. RADIU0 ) THEN
            RADHLP = 0.5D+00 * ( RADTOT + RADPRO + MAX ( ABS (RIMPTR),
     &               RADIU0 ) )
            CZHLP  = SQRT ( ( RADHLP + BIMPTR ) * ( RADHLP - BIMPTR ) )
     &             / RADHLP
            HLPHLP = RIMPTR / ( RIMPCT * RADHLP )
            CXHLP  = CZHLP * CXIMPC - XBIMPC * HLPHLP
            CYHLP  = CZHLP * CYIMPC - YBIMPC * HLPHLP
            CZHLP  = CZHLP * CZIMPC - ZBIMPC * HLPHLP
            PXPROJ = PNUCCO * CXIMPC
            PYPROJ = PNUCCO * CYIMPC
            PZPROJ = PNUCCO * CZIMPC
            PDTCMP = PXPROJ * CXHLP + PYPROJ * CYHLP + PZPROJ * CZHLP
            DELTAE = PDTCMP**2 - PNUCCO**2 + PPRWLL**2
            DELTAP = - PDTCMP + SQRT ( DELTAE )
            PXPROJ = PXPROJ + DELTAP * CXHLP
            PYPROJ = PYPROJ + DELTAP * CYHLP
            PZPROJ = PZPROJ + DELTAP * CZHLP
         ELSE
            EKEBIM = MAX ( EKECON + VPRBIM, EKEWLL )
            PBIMSQ = EKEBIM * ( EKEBIM + 2.D+00 * AM (KPRIN) )
            RADHLP = 0.5D+00 * ( RADTOT + RADPRO + MAX ( BIMPTR,
     &               RADIU0 ) )
            CZHLP  = SQRT ( ( RADHLP + BIMPTR ) * ( RADHLP - BIMPTR ) )
     &             / RADHLP
            HLPHLP = RIMPTR / ( RIMPCT * RADHLP )
            CXHLP  = CZHLP * CXIMPC - XBIMPC * HLPHLP
            CYHLP  = CZHLP * CYIMPC - YBIMPC * HLPHLP
            CZHLP  = CZHLP * CZIMPC - ZBIMPC * HLPHLP
            PXPROJ = PNUCCO * CXIMPC
            PYPROJ = PNUCCO * CYIMPC
            PZPROJ = PNUCCO * CZIMPC
            PDTCMP = PXPROJ * CXHLP + PYPROJ * CYHLP + PZPROJ * CZHLP
            DELTAE = PDTCMP**2 - PNUCCO**2 + PBIMSQ
            DELTAP = - PDTCMP + SQRT ( DELTAE )
            PXPROJ = PXPROJ + DELTAP * CXHLP
            PYPROJ = PYPROJ + DELTAP * CYHLP
            PZPROJ = PZPROJ + DELTAP * CZHLP
            PPBIM  = SQRT ( PBIMSQ )
            COSTHE = ( PXPROJ * CXIMPC + PYPROJ * CYIMPC
     &             + PZPROJ * CZIMPC ) / PPBIM
            THETA  = ACOS (COSTHE) * ( 1.D+00 + ( PNUCCO - PPBIM )
     &             / PDIFF )
            SINTHE = SIN (THETA)
            COSTHE = COS (THETA)
            PXPROJ = PPRWLL * ( COSTHE * CXIMPC - SINTHE * UBIMPT )
            PYPROJ = PPRWLL * ( COSTHE * CYIMPC - SINTHE * VBIMPT )
            PZPROJ = PPRWLL * ( COSTHE * CZIMPC - SINTHE * WBIMPT )
         END IF
      ELSE IF ( PDIFF .GT. ANGLGB ) THEN
         STOP 'PHDWLL'
      ELSE
         PXPROJ = PPRWLL * CXIMPC
         PYPROJ = PPRWLL * CYIMPC
         PZPROJ = PPRWLL * CZIMPC
      END IF
      RETURN
*=== End of subroutine phdwll =========================================*
      END
+DECK,  PIOABS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:02  cernlib
* Geant

*$ CREATE PIOABS.FOR
*COPY PIOABS
*=== pioabs ===========================================================*
      SUBROUTINE PIOABS ( IKPMX , KRFLIN, WEE   , ERECMN, LBIMPC,
     &                    LBCHCK, ICYCL , NHOLE , NPROT , NNEUT ,
     &                    LEXIT , LNWINT )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, FINUC.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAREVT.
+CDE, PARNUC.
+CDE, PART.
+CDE, RESNUC.
*
      COMMON / FKPLOC / IABCOU
      REAL RNDM(1)
      LOGICAL LBCHCK, LBIMPC, LTROUB, LEXIT, LNWINT
*
      NPNCLD = NPNUC
 1000 CONTINUE
      IF ( LABRST .OR. LABSRP ) THEN
         LNWINT = .FALSE.
      ELSE
         LEXIT  = .FALSE.
         LNWINT = .TRUE.
         RETURN
      END IF
      NHOLE  = NHOLE + NTARGT
      NTARLD = NTARGT
      ICYCL  = ICYCL + 1
      IF ( NTARGT .EQ. 1 ) THEN
         IF ( .NOT. LABRST )  STOP '???_rad_flight_abs'
         LABRST = .FALSE.
         LABSRP = .FALSE.
         PFROUT = PFRIMP / PFRCEN (1) * PFRCEN (2)
         EKFOUT = SQRT ( AMNUSQ (2) + PFROUT**2 ) - AMNUCL (2)
         POTINC = EKEWLL - EKECON + EKFERM
         POTOUT = EKFERM + EKFOUT + BNENRG (2) - EKFIMP - BNENRG (1)
         ERES   = EKEWLL + AM (KPRIN) + EKFERM + AM (KNUCIM)
     &          + POTOUT - POTINC
         AMNREC = AMNTAR - AMUC12
         ERECMN = 0.5D+00 * PTRES2 / AMNREC
         ERECMN = 0.D+00
         UMO2   = ERES*ERES - PTRES2
         UMO    = SQRT (UMO2)
         GAMCM = ERES  / UMO
         ETAX  = PXRES / UMO
         ETAY  = PYRES / UMO
         ETAZ  = PZRES / UMO
         ECMSNU = 0.5D+00 * ( UMO2 + AMNUSQ (2) ) / UMO
         PCMS   = UMO - ECMSNU
         CALL RACO ( PCMSX, PCMSY, PCMSZ )
         PCMSX = PCMS * PCMSX
         PCMSY = PCMS * PCMSY
         PCMSZ = PCMS * PCMSZ
         NPNUC = NPNUC + 1
         KPNUCL (NPNUC) = 7
         KRFNUC (NPNUC) = KRFLIN + 1
         ETAPCM = ETAX * PCMSX + ETAY * PCMSY + ETAZ * PCMSZ
         PHELP  = PCMS + ETAPCM / ( GAMCM + 1.D+00 )
         ENNUC  (NPNUC) = GAMCM * PCMS + ETAPCM
         PXHELP = PCMSX + ETAX * PHELP
         PYHELP = PCMSY + ETAY * PHELP
         PZHELP = PCMSZ + ETAZ * PHELP
         PXRES = PXRES - PXHELP
         PYRES = PYRES - PYHELP
         PZRES = PZRES - PZHELP
         ERES  = ERES  - ENNUC (NPNUC)
         PTRES2= PXRES**2 + PYRES**2 + PZRES**2
         PXHLP = PXTTOT - PXHELP
         PYHLP = PYTTOT - PYHELP
         PZHLP = PZTTOT - PZHELP
         UMO2  = ( ETTOT - ENNUC (NPNUC) )**2 - PXHLP**2 - PYHLP**2
     &         - PZHLP**2
         EEXMNM = 0.D+00
         DELTU2 = UMO2 - ( AMNRES + EEXMNM )**2
         IF ( DELTU2 .LT. 0.D+00 ) THEN
            NPNUC  = NPNUC - 1
            LBCHCK = .FALSE.
            IF ( LBIMPC ) THEN
               CALL BIMNXT ( LBCHCK )
               RHOMEM = 0.5D+00 * ( RHOIMP + RHOIMT )
               EKFMEM = 0.5D+00 * ( EKFIMP + EKFPRO )
            ELSE
               CALL NWINXT ( LBCHCK )
               IF ( BIMPCT .GT. RADTOT ) THEN
                  NHOLE = NHOLE - NTARLD
                  ICYCL = ICYCL - 1
                  CALL PHDSET ( IKPMX )
                  IBRES = IBRES - IBAR (KPRIN)
                  ICRES = ICRES - ICH  (KPRIN)
                  BBRES = IBRES
                  ZZRES = ICRES
                  AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER
     &                   ( BBRES, ZZRES)
                  AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
                  LTROUB = .FALSE.
                  CALL UMOFIN ( IKPMX, BBRES, ZZRES, LTROUB )
                  IF ( LTROUB ) THEN
                     KPNUCL (IKPMX) = 0
                     UMO2  = ERES**2 - PTRES2
                     UMO = SQRT (UMO2)
                     WRITE ( LUNOUT,* )' PIO0_P:UMO,AMNRES',UMO,AMNRES
                     LEXIT = .TRUE.
                     RETURN
                  END IF
                  NP = NP + 1
                  TKI   (NP) = ENNUC  (IKPMX) - AM (KPRIN)
                  KPART (NP) = KPRIN
                  PLR   (NP) = PNUCL  (IKPMX)
                  CXR   (NP) = PXNUCL (IKPMX) / PLR (NP)
                  CYR   (NP) = PYNUCL (IKPMX) / PLR (NP)
                  CZR   (NP) = PZNUCL (IKPMX) / PLR (NP)
                  WEI   (NP) = WEE
                  KPNUCL (IKPMX) = 0
                  IOTHER = IOTHER + 1
                  PXNUCR = PXNUCR + PXNUCL (IKPMX)
                  PYNUCR = PYNUCR + PYNUCL (IKPMX)
                  PZNUCR = PZNUCR + PZNUCL (IKPMX)
                  ENUCR  = ENUCR  + ENNUC  (IKPMX)
                  IBNUCR = IBNUCR + IBAR   (KPART(NP))
                  ICNUCR = ICNUCR + ICH    (KPART(NP))
                  LEXIT  = .TRUE.
                  RETURN
               END IF
               XSTNUC (IKPMX) = XIMPTR
               YSTNUC (IKPMX) = YIMPTR
               ZSTNUC (IKPMX) = ZIMPTR
               RSTNUC (IKPMX) = ABS (RIMPTR)
            END IF
            NHOLE = NHOLE - NTARLD
            ICYCL = ICYCL - 1
            GO TO 1000
         END IF
         EKFNUC (NPNUC) = - AINFNT
         PXNUCL (NPNUC) = PXHELP
         PYNUCL (NPNUC) = PYHELP
         PZNUCL (NPNUC) = PZHELP
         PNUCL  (NPNUC) = ENNUC (NPNUC)
         XSTNUC (NPNUC) = XIMPTR
         YSTNUC (NPNUC) = YIMPTR
         ZSTNUC (NPNUC) = ZIMPTR
         RSTNUC (NPNUC) = ABS (RIMPTR)
         NPNUC = NPNUC + 1
         KPNUCL (NPNUC) = 8
         KRFNUC (NPNUC) = KRFLIN + 1
         ETAPCM = - ETAPCM
         PHELP  = ECMSNU + ETAPCM / ( GAMCM + 1.D+00 )
         ENNUC  (NPNUC) = GAMCM * ECMSNU + ETAPCM
         DEFRNU = DEFNEU
         IF ( ENNUC (NPNUC) - AM (8) .LE. EKFOUT + DEFRNU ) THEN
            NPNUC  = NPNUC - 2
            LBCHCK = .FALSE.
            IF ( LBIMPC ) THEN
               CALL BIMNXT ( LBCHCK )
               RHOMEM = 0.5D+00 * ( RHOIMP + RHOIMT )
               EKFMEM = 0.5D+00 * ( EKFIMP + EKFPRO )
            ELSE
               CALL NWINXT ( LBCHCK )
               IF ( BIMPCT .GT. RADTOT ) THEN
                  NHOLE = NHOLE - NTARLD
                  ICYCL = ICYCL - 1
                  CALL PHDSET ( IKPMX )
                  IBRES = IBRES - IBAR (KPRIN)
                  ICRES = ICRES - ICH  (KPRIN)
                  BBRES = IBRES
                  ZZRES = ICRES
                  AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER
     &                   ( BBRES, ZZRES)
                  AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
                  LTROUB = .FALSE.
                  CALL UMOFIN ( IKPMX, BBRES, ZZRES, LTROUB )
                  IF ( LTROUB ) THEN
                     KPNUCL (IKPMX) = 0
                     UMO2  = ERES**2 - PTRES2
                     UMO = SQRT (UMO2)
                     WRITE ( LUNOUT,* )' PIO0_T:UMO,AMNRES',UMO,AMNRES
                     LEXIT = .TRUE.
                     RETURN
                  END IF
                  NP = NP + 1
                  TKI   (NP) = ENNUC  (IKPMX) - AM (KPRIN)
                  KPART (NP) = KPRIN
                  PLR   (NP) = PNUCL  (IKPMX)
                  CXR   (NP) = PXNUCL (IKPMX) / PLR (NP)
                  CYR   (NP) = PYNUCL (IKPMX) / PLR (NP)
                  CZR   (NP) = PZNUCL (IKPMX) / PLR (NP)
                  WEI   (NP) = WEE
                  KPNUCL (IKPMX) = 0
                  IOTHER = IOTHER + 1
                  PXNUCR = PXNUCR + PXNUCL (IKPMX)
                  PYNUCR = PYNUCR + PYNUCL (IKPMX)
                  PZNUCR = PZNUCR + PZNUCL (IKPMX)
                  ENUCR  = ENUCR  + ENNUC  (IKPMX)
                  IBNUCR = IBNUCR + IBAR   (KPART(NP))
                  ICNUCR = ICNUCR + ICH    (KPART(NP))
                  LEXIT  = .TRUE.
                  RETURN
               END IF
               XSTNUC (IKPMX) = XIMPTR
               YSTNUC (IKPMX) = YIMPTR
               ZSTNUC (IKPMX) = ZIMPTR
               RSTNUC (IKPMX) = ABS (RIMPTR)
            END IF
            NHOLE = NHOLE - NTARLD
            ICYCL = ICYCL - 1
            GO TO 1000
         END IF
         EKFNUC (NPNUC) = EKFOUT
         PXNUCL (NPNUC) = -PCMSX + ETAX * PHELP
         PYNUCL (NPNUC) = -PCMSY + ETAY * PHELP
         PZNUCL (NPNUC) = -PCMSZ + ETAZ * PHELP
         PNUCL  (NPNUC) = SQRT ( PXNUCL (NPNUC)**2 + PYNUCL (NPNUC)**2
     &                         + PZNUCL (NPNUC)**2 )
         XSTNUC (NPNUC) = XIMPCT
         YSTNUC (NPNUC) = YIMPCT
         ZSTNUC (NPNUC) = ZIMPCT
         RSTNUC (NPNUC) = ABS (RIMPCT)
         LBIMPC = .FALSE.
         LEXIT  = .FALSE.
         NUSCIN = NUSCIN + 1
         ISCTYP (NUSCIN) = - ( KPRIN * 100 + KNUCIM )
         IF ( NUSCIN .EQ. 1 ) IPRTYP = ISCTYP (1)
         NHLEXP = NHLEXP + 1
         HOLEXP (NHLEXP) = EKFIMP - EKFERM
         RHOACT = 0.5D+00 * ( RHOIMP + RHOIMT )
         RHOEXP = RHOEXP + RHOACT
         EKFEXP = EKFEXP + 0.5D+00 * ( EKFIMP + EKFPRO )
         CALL NCLVFX
      ELSE
         LABRST = .FALSE.
         LABSRP = .FALSE.
         ITFRMI = 1 + KNUCIM / 8
         ITFRM2 = 1 + KNUCI2 / 8
         IF ( ICH (KPRIN) .GT. 0 ) THEN
            IOFRMI = 1
            IOFRM2 = ITFRM2
            DEFRPR = DEFPRO
            IF ( IOFRMI .EQ. ITFRM2 ) THEN
               EKFOUT = EKFIM2
               DEFRNU = DEFPRO
            ELSE
               PFROUT = PFRIMP / PFRCEN (1) * PFRCEN (2)
               EKFOUT = SQRT ( AMNUSQ (1) + PFROUT**2 ) - AMNUCL (1)
               DEFRNU = DEFNEU
            END IF
         ELSE IF ( ICH (KPRIN) .LT. 0 ) THEN
            IOFRMI = 2
            IOFRM2 = ITFRM2
            DEFRPR = DEFNEU
            IF ( IOFRMI .EQ. ITFRM2 ) THEN
               EKFOUT = EKFIM2
               DEFRNU = DEFNEU
            ELSE
               PFROUT = PFRIMP / PFRCEN (2) * PFRCEN (1)
               EKFOUT = SQRT ( AMNUSQ (2) + PFROUT**2 ) - AMNUCL (2)
               DEFRNU = DEFPRO
            END IF
         ELSE
            IOFRMI = ITFRMI
            IOFRM2 = ITFRM2
            EKFOUT = EKFIMP
            IF ( ITFRMI .EQ. 1 ) THEN
               DEFRPR = DEFPRO
            ELSE
               DEFRPR = DEFNEU
            END IF
            IF ( ITFRM2 .EQ. 1 ) THEN
               DEFRNU = DEFPRO
            ELSE
               DEFRNU = DEFNEU
            END IF
         END IF
         POTINC = EKEWLL - EKECON + EKFERM + EKFER2
         POTOUT = EKFERM + EKFER2 + EKFOUT + BNENRG (IOFRMI) - EKFIMP
     &          - BNENRG (ITFRMI)
         ERES   = EKEWLL + AM (KPRIN) + EKFERM + AM (KNUCIM)
     &          + EKFER2 + AM (KNUCI2) + POTOUT - POTINC
         AMNREC = AMNTAR - 2.D+00 * AMUC12
         PHLPSQ = ( PXRES - CXIMPC * PNUCCO )**2
     &          + ( PYRES - CYIMPC * PNUCCO )**2
     &          + ( PZRES - CZIMPC * PNUCCO )**2
         ERECMN = 0.5D+00 * PHLPSQ / AMNREC**2
         ERECMN = AMNREC * ERECMN * ( 1.D+00 - 0.25D+00 * ERECMN )
         ERECMN = 0.D+00
         UMO2   = ERES*ERES - PTRES2
         UMO    = SQRT (UMO2)
         GAMCM = ERES  / UMO
         ETAX  = PXRES / UMO
         ETAY  = PYRES / UMO
         ETAZ  = PZRES / UMO
         ECMSPR = 0.5D+00 * ( UMO2 + AMNUSQ (IOFRMI) - AMNUSQ (IOFRM2) )
     &          / UMO
         ECMSNU = UMO - ECMSPR
         PCMS   = SQRT ( ( ECMSPR - AMNUCL (IOFRMI) ) * ( ECMSPR
     &          + AMNUCL (IOFRMI) ) )
         CALL RACO ( PCMSX, PCMSY, PCMSZ )
         PCMSX = PCMS * PCMSX
         PCMSY = PCMS * PCMSY
         PCMSZ = PCMS * PCMSZ
         NPNUC = NPNUC + 1
         KPNUCL (NPNUC) = 1 + 7 * ( IOFRMI - 1 )
         KRFNUC (NPNUC) = KRFLIN + 1
         ETAPCM = ETAX * PCMSX + ETAY * PCMSY + ETAZ * PCMSZ
         PHELP  = ECMSPR + ETAPCM / ( GAMCM + 1.D+00 )
         ENNUC  (NPNUC) = GAMCM * ECMSPR + ETAPCM
         IF ( ENNUC (NPNUC) - AMNUCL (IOFRMI) .LE. EKFOUT + DEFRPR )THEN
            NPNUC  = NPNUC - 1
            LBCHCK = .FALSE.
            IF ( LBIMPC ) THEN
               CALL BIMNXT ( LBCHCK )
               RHOMEM = 0.5D+00 * ( RHOIMP + RHOIMT )
               EKFMEM = 0.5D+00 * ( EKFIMP + EKFPRO )
            ELSE
               CALL NWINXT ( LBCHCK )
               IF ( BIMPCT .GT. RADTOT ) THEN
                  NHOLE = NHOLE - NTARLD
                  ICYCL = ICYCL - 1
                  CALL PHDSET ( IKPMX )
                  IBRES = IBRES - IBAR (KPRIN)
                  ICRES = ICRES - ICH  (KPRIN)
                  BBRES = IBRES
                  ZZRES = ICRES
                  AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER
     &                   ( BBRES, ZZRES)
                  AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
                  LTROUB = .FALSE.
                  CALL UMOFIN ( IKPMX, BBRES, ZZRES, LTROUB )
                  IF ( LTROUB ) THEN
                     KPNUCL (IKPMX) = 0
                     UMO2  = ERES**2 - PTRES2
                     UMO = SQRT (UMO2)
                     WRITE ( LUNOUT,* )' PIO0_P:UMO,AMNRES',UMO,AMNRES
                     LEXIT = .TRUE.
                     RETURN
                  END IF
                  NP = NP + 1
                  TKI   (NP) = ENNUC  (IKPMX) - AM (KPRIN)
                  KPART (NP) = KPRIN
                  PLR   (NP) = PNUCL  (IKPMX)
                  CXR   (NP) = PXNUCL (IKPMX) / PLR (NP)
                  CYR   (NP) = PYNUCL (IKPMX) / PLR (NP)
                  CZR   (NP) = PZNUCL (IKPMX) / PLR (NP)
                  WEI   (NP) = WEE
                  KPNUCL (IKPMX) = 0
                  IOTHER = IOTHER + 1
                  PXNUCR = PXNUCR + PXNUCL (IKPMX)
                  PYNUCR = PYNUCR + PYNUCL (IKPMX)
                  PZNUCR = PZNUCR + PZNUCL (IKPMX)
                  ENUCR  = ENUCR  + ENNUC  (IKPMX)
                  IBNUCR = IBNUCR + IBAR   (KPART(NP))
                  ICNUCR = ICNUCR + ICH    (KPART(NP))
                  LEXIT  = .TRUE.
                  RETURN
               END IF
               XSTNUC (IKPMX) = XIMPTR
               YSTNUC (IKPMX) = YIMPTR
               ZSTNUC (IKPMX) = ZIMPTR
               RSTNUC (IKPMX) = ABS (RIMPTR)
            END IF
            NHOLE = NHOLE - NTARLD
            ICYCL = ICYCL - 1
            GO TO 1000
         END IF
         EKFNUC (NPNUC) = EKFOUT
         PXNUCL (NPNUC) = PCMSX + ETAX * PHELP
         PYNUCL (NPNUC) = PCMSY + ETAY * PHELP
         PZNUCL (NPNUC) = PCMSZ + ETAZ * PHELP
         PNUCL  (NPNUC) = SQRT ( PXNUCL (NPNUC)**2 + PYNUCL (NPNUC)**2
     &                         + PZNUCL (NPNUC)**2 )
         XSTNUC (NPNUC) = XIMPTR
         YSTNUC (NPNUC) = YIMPTR
         ZSTNUC (NPNUC) = ZIMPTR
         RSTNUC (NPNUC) = ABS (RIMPTR)
         NPNUC = NPNUC + 1
         KPNUCL (NPNUC) = 1 + 7 * ( IOFRM2 - 1 )
         KRFNUC (NPNUC) = KRFLIN + 1
         ETAPCM = - ETAPCM
         PHELP  = ECMSNU + ETAPCM / ( GAMCM + 1.D+00 )
         ENNUC  (NPNUC) = GAMCM * ECMSNU + ETAPCM
         IF ( ENNUC (NPNUC) - AMNUCL (IOFRM2) .LE. EKFIM2 + DEFRNU )THEN
            NPNUC  = NPNUC - 2
            LBCHCK = .FALSE.
            IF ( LBIMPC ) THEN
               CALL BIMNXT ( LBCHCK )
               RHOMEM = 0.5D+00 * ( RHOIMP + RHOIMT )
               EKFMEM = 0.5D+00 * ( EKFIMP + EKFPRO )
            ELSE
               CALL NWINXT ( LBCHCK )
               IF ( BIMPCT .GT. RADTOT ) THEN
                  NHOLE = NHOLE - NTARLD
                  ICYCL = ICYCL - 1
                  CALL PHDSET ( IKPMX )
                  IBRES = IBRES - IBAR (KPRIN)
                  ICRES = ICRES - ICH  (KPRIN)
                  BBRES = IBRES
                  ZZRES = ICRES
                  AMMRES = BBRES * AMUAMU + 0.001D+00 * FKENER
     &                   ( BBRES, ZZRES)
                  AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
                  LTROUB = .FALSE.
                  CALL UMOFIN ( IKPMX, BBRES, ZZRES, LTROUB )
                  IF ( LTROUB ) THEN
                     KPNUCL (IKPMX) = 0
                     UMO2  = ERES**2 - PTRES2
                     UMO = SQRT (UMO2)
                     WRITE ( LUNOUT,* )' PIO0_T:UMO,AMNRES',UMO,AMNRES
                     LEXIT = .TRUE.
                     RETURN
                  END IF
                  NP = NP + 1
                  TKI   (NP) = ENNUC  (IKPMX) - AM (KPRIN)
                  KPART (NP) = KPRIN
                  PLR   (NP) = PNUCL  (IKPMX)
                  CXR   (NP) = PXNUCL (IKPMX) / PLR (NP)
                  CYR   (NP) = PYNUCL (IKPMX) / PLR (NP)
                  CZR   (NP) = PZNUCL (IKPMX) / PLR (NP)
                  WEI   (NP) = WEE
                  KPNUCL (IKPMX) = 0
                  IOTHER = IOTHER + 1
                  PXNUCR = PXNUCR + PXNUCL (IKPMX)
                  PYNUCR = PYNUCR + PYNUCL (IKPMX)
                  PZNUCR = PZNUCR + PZNUCL (IKPMX)
                  ENUCR  = ENUCR  + ENNUC  (IKPMX)
                  IBNUCR = IBNUCR + IBAR   (KPART(NP))
                  ICNUCR = ICNUCR + ICH    (KPART(NP))
                  LEXIT  = .TRUE.
                  RETURN
               END IF
               XSTNUC (IKPMX) = XIMPTR
               YSTNUC (IKPMX) = YIMPTR
               ZSTNUC (IKPMX) = ZIMPTR
               RSTNUC (IKPMX) = ABS (RIMPTR)
            END IF
            NHOLE = NHOLE - NTARLD
            ICYCL = ICYCL - 1
            GO TO 1000
         END IF
         EKFNUC (NPNUC) = EKFIM2
         PXNUCL (NPNUC) = -PCMSX + ETAX * PHELP
         PYNUCL (NPNUC) = -PCMSY + ETAY * PHELP
         PZNUCL (NPNUC) = -PCMSZ + ETAZ * PHELP
         PNUCL  (NPNUC) = SQRT ( PXNUCL (NPNUC)**2 + PYNUCL (NPNUC)**2
     &                         + PZNUCL (NPNUC)**2 )
         XSTNUC (NPNUC) = XIMPCT
         YSTNUC (NPNUC) = YIMPCT
         ZSTNUC (NPNUC) = ZIMPCT
         RSTNUC (NPNUC) = ABS (RIMPCT)
         LBIMPC = .FALSE.
         LEXIT  = .FALSE.
         NUSCIN = NUSCIN + 1
         ISCTYP (NUSCIN) = - ( KPRIN * 100 + KNUCIM * 10 + KNUCI2 )
         IF ( NUSCIN .EQ. 1 ) IPRTYP = ISCTYP (1)
         IABCOU = IABCOU + 1
         NHLEXP = NHLEXP + 2
         HOLEXP (NHLEXP-1) = EKFIMP - EKFERM
         HOLEXP (NHLEXP)   = EKFIM2 - EKFER2
         RHOACT = 0.6666666666666666D+00 * RHOIMP
     &          + 0.3333333333333333D+00 * RHOIMT
         RHOEXP = RHOEXP + 2.D+00 * RHOACT
         EKFEXP = EKFEXP + 0.6666666666666666D+00 * ( EKFIMP + EKFIM2
     &          + EKFPRO )
         CALL NCLVFX
      END IF
      DO 3000 KP = NPNCLD+1, NPNUC
         KPNUC = KPNUCL (KP)
         IF ( AM (KPNUC) .LE. 0.D+00 ) THEN
            TAUTAU = RZNUCL / PNUCL (KP)
         ELSE
            TAUEFF = 0.5D+00 * TAUFOR * AM (13) / AM (KPNUC)
            CALL GRNDM(RNDM,1)
            TAUTAU = - TAUEFF / AM (KPNUC) * LOG ( 1.D+00 - RNDM
     &             (1) )
            TAUTAU = MAX ( TAUTAU, RZNUCL / PNUCL (KP) )
         END IF
         XSTNUC (KP) = XSTNUC (KP) + PXNUCL (KP) * TAUTAU
         YSTNUC (KP) = YSTNUC (KP) + PYNUCL (KP) * TAUTAU
         ZSTNUC (KP) = ZSTNUC (KP) + PZNUCL (KP) * TAUTAU
         RSTNUC (KP) = SQRT ( XSTNUC (KP)**2 + YSTNUC (KP)**2
     &               + ZSTNUC (KP)**2 )
         RHNUCL (KP) = RHOACT
 3000 CONTINUE
      RETURN
*=== End of subroutine pioabs =========================================*
      END
+DECK,  PREPRE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:03  cernlib
* Geant

+SELF, IF=HPUX.
$OPTIMIZE OFF
+SELF.
*$ CREATE PREPRE.FOR
*COPY PREPRE
*
*=== prepre ===========================================================*
*
      SUBROUTINE PREPRE ( WEE, NNEUT, NPROT, NHOLE, ICYCL )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, EVA0.
+CDE, FHEAVY.
+CDE, FINUC.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAREVT.
+CDE, PARNUC.
+CDE, PART.
+CDE, RESNUC.
*
      REAL RNDM(2)
      COMMON / FKCOSP / C1ST (3), C2ND (3), LEMISS
      LOGICAL LEMISS
      COMMON / FKCMCY / NPCYCL (20,2), IEVT, LOUT
      COMMON / FKPLOC / IABCOU
*
      DIMENSION ERNCM  (2), EPSMX  (2), AMMAFT (2), AMNAFT (2),
     &          ZAFTR  (2), EEXMNM (2), EEXDLT (2), EEXANW (2),
     &          EPSEEX (2), EPSDLT (2), EPSANY (2), EPSFIX (29),
     &          C (3), UMULEG (0:2), ACOLEG (0:2), NPART (2),
     &          NPRFIX (2)
      LOGICAL LSPREJ, LNUCTS
*
      NPART (1) = NNEUT
      NPART (2) = NPROT
      IF ( LHLFIX ) THEN
         NHLFIX = NHLEXP
         NHOLE  = NHOLE - NHLFIX
         EHLFIX = 0.D+00
         DO 50 IHOLE = 1, NHLFIX
            EHLFIX = EHLFIX + HOLEXP (IHOLE)
   50    CONTINUE
         IF ( NHOLE .GT. 0 ) THEN
            RHOIMP = ( RHOIMP * ( NHOLE + NHLFIX ) - RHOEXP ) / NHOLE
            EKFIMP = ( EKFIMP * ( NHOLE + NHLFIX ) - EKFEXP ) / NHOLE
         ELSE
            RHOIMP = RHOAVE
            EKFIMP = EKFAVE
         END IF
      ELSE
         NHLFIX = 0
         EHLFIX = 0.D+00
      END IF
      NHINI  = NHOLE
      IF ( PTRES .LT. ANGLGB ) THEN
         UMO2  = ERES * ERES
         UMO   = SQRT (UMO2)
         EKRES = 0.D+00
         GAMCM = 1.D+00
         ETAX  = 0.D+00
         ETAY  = 0.D+00
         ETAZ  = 0.D+00
         PXORI = 0.D+00
         PYORI = 0.D+00
         PZORI = 0.D+00
         PCMORI = 0.D+00
         CALL RACO ( CXAXCM, CYAXCM, CZAXCM )
      ELSE
         UMO2  = ( ERES - PTRES ) * ( ERES + PTRES )
         UMO   = SQRT (UMO2)
         EKRES = ERES - UMO
         GAMCM = ERES  / UMO
         ETACM = PTRES / UMO
         ETAX  = PXRES / UMO
         ETAY  = PYRES / UMO
         ETAZ  = PZRES / UMO
         ETAPCM = ETAX * PXORI + ETAY * PYORI + ETAZ * PZORI
         PHELP = EKORI + AM (KPORI) - ETAPCM / ( GAMCM + 1.D+00 )
         PCMSX = PXORI - ETAX * PHELP
         PCMSY = PYORI - ETAY * PHELP
         PCMSZ = PZORI - ETAZ * PHELP
         PCMORI = SQRT ( PCMSX**2 + PCMSY**2 + PCMSZ**2 )
         CXAXCM = PCMSX / PCMORI
         CYAXCM = PCMSY / PCMORI
         CZAXCM = PCMSZ / PCMORI
      END IF
      BBTAR = IBTAR
      ZZTAR = ICHTAR
      TVCMS  = UMO - AMNRES
      EHLFIX = MIN ( TVCMS, EHLFIX )
      TVEFF  = TVCMS - EHLFIX
      IF ( TVEFF .LE. 0.D+00 ) GO TO 7000
      TEMNU = SQRT ( TVCMS / ANOW * ALEVEL  )
      NEXMX = SQRT ( 2.D+00 * ANOW * TVCMS / ALEVEL )
      NPTOT  = NPART (1) + NPART (2)
      IF ( NHOLE + NPTOT + NHLFIX .GE. NEXMX .OR.
     &     NPTOT .GT. NINT (0.5D+00 * ANOW) ) GO TO 7000
      ANPTOT = NPTOT
      ANPROT = NPART (2)
      ANNEUT = NPART (1)
      AVEBIN = ( ( BBTAR - ZZTAR - ACOLL + ZCOLL ) * BNENRG (2)
     &       + ( ZZTAR - ZCOLL ) * BNENRG (1) ) / ( BBTAR - ACOLL )
      IAAFT = IBRES-1
      IZAFT = ICRES
      AAFTR     = IAAFT
      ZAFTR (1) = IZAFT
      AMMAFT(1) = AAFTR * AMUAMU + 1.D-03 * FKENER (AAFTR,ZAFTR(1))
      AMNAFT(1) = AMMAFT (1) - ZAFTR (1) * AMELEC + ELBNDE (IZAFT)
      CALL EEXLVL ( IAAFT, IZAFT, EEXDLT (1), EEXMNM (1), EEXDUM )
      BNDGAV = BNENRG (2)
      EPSMX  (1) = UMO - AMNRES - BNDGAV - EHLFIX
      EPSDLT (1) = UMO - AMNRES - BNDGAV - EEXDLT (1)
      EPSEEX (1) = UMO - AMNRES - BNDGAV - EEXMNM (1)
      IZAFT = ICRES - 1
      ZAFTR (2) = IZAFT
      AMMAFT(2) = AAFTR * AMUAMU + 1.D-03 * FKENER (AAFTR,ZAFTR(2))
      AMNAFT(2) = AMMAFT (2) - ZAFTR (2) * AMELEC + ELBNDE (IZAFT)
      CALL EEXLVL ( IAAFT, IZAFT, EEXDLT (2), EEXMNM (2), EEXDUM )
      BNDGAV = BNENRG (1)
      EPSMX  (2) = UMO - AMNRES - BNDGAV - EHLFIX
      IF ( EPSMX (1) + EPSMX (2) .LT. 2.D+00 * TEMNU ) GO TO 7000
      EPSDLT (2) = UMO - AMNRES - BNDGAV - EEXDLT (2)
      EPSEEX (2) = UMO - AMNRES - BNDGAV - EEXMNM (2)
      IF ( NP .LE. NP0 ) THEN
         IF ( KPORI .EQ. 8 ) THEN
            EEXANW (1) = EEXDLT (1)
            EPSANY (1) = MIN ( EPSDLT (1), EPSMX (1) )
            EEXANW (2) = 0.D+00
            EPSANY (2) = EPSMX  (2)
         ELSE IF ( KPORI .EQ. 1 ) THEN
            EEXANW (1) = 0.D+00
            EPSANY (1) = EPSMX  (1)
            EEXANW (2) = EEXDLT (2)
            EPSANY (2) = MIN ( EPSDLT (2), EPSMX (2) )
         ELSE
            EEXANW (1) = 0.D+00
            EPSANY (1) = EPSMX (1)
            EEXANW (2) = 0.D+00
            EPSANY (2) = EPSMX (2)
         END IF
      ELSE
         EEXANW (1) = 0.D+00
         EPSANY (1) = EPSMX (1)
         EEXANW (2) = 0.D+00
         EPSANY (2) = EPSMX (2)
      END IF
      SIGIN0 = PI * ( R0SIGK * RMASS (IBRES-1) )**2
      NEMISS = 0
      MNUCTS = 0
 1000 CONTINUE
         NPRFIX (1) = 0
         NPRFIX (2) = 0
         JEMFIX = 0
         EPRFIX = 0.D+00
         IF ( .NOT. LEMISS ) ICYCL = ICYCL + 1
         IF ( NPTOT .LE. 0 ) GO TO 4600
         IF ( NNUCTS .GT. MNUCTS ) THEN
            MNUCTS = MNUCTS + 1
            JNUCTS = INUCTS (MNUCTS)
            JEMIS0 = 2 - ABS (KPNUCL(JNUCTS)) / 8
            JEMIS1 = JEMIS0
            JDEMIS = 1
            EKFSAV = EKFIMP
            RHOSAV = RHOIMP
            TMPRHO = 0.001D+00 * RHOAVE
            RHOIMP = MAX ( RHNUCL (JNUCTS), TMPRHO )
            TMPEKF = 0.001D+00 * EKFAVE
            EKFIMP = MAX ( EKFNUC (JNUCTS), TMPEKF )
            LNUCTS = .TRUE.
         ELSE
            LNUCTS = .FALSE.
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. ANNEUT / ANPTOT ) THEN
               JEMIS0 = 1
               JEMIS1 = 2
               JDEMIS = 1
            ELSE
               JEMIS0 = 2
               JEMIS1 = 1
               JDEMIS = -1
            END IF
         END IF
         NEXTOT = NPTOT + NHOLE
         RHORED = ACOLL / BBTAR
         IF ( LGDHPR ) THEN
            EKFCNN = ( ZNOW * EKFCEN (1) + ( ANOW - ZNOW ) * EKFCEN (2)
     &             ) / ANOW
            RHOWEI = 0.5D+00
            IF ( LNUCTS ) THEN
               AEFREF = EKFIMP
               AEFRAV = EKFIMP
               RHONUC = RHOIMP
            ELSE IF ( NPTOT .LE. 2 .AND. ICYCL .EQ. 1 ) THEN
               AHLTOT = MAX ( NHOLE, 1 )
               WEIGH1 = NHINI / AHLTOT
               WEIGH2 = 1.D+00 - WEIGH1
               AEFREF = WEIGH1 * EKFIMP + WEIGH2 * EKFAVE
               RHONUC = WEIGH1 * RHOIMP + WEIGH2 * RHOAVE
               AEFRAV = WEIGH1 * EKFIMP + WEIGH2 * EKFAVE
               RHONUC = RHORED * ( ( AHLTOT + 1.D+00 - RHOWEI )
     &                * RHONUC + RHOWEI * RHOAVE ) / ( AHLTOT + 1.D+00 )
               AEFRAV = ( AHLTOT * AEFRAV + EKFAVE )
     &                / ( AHLTOT + 1.D+00 )
            ELSE
               AHLTOT = MAX ( NHOLE, 1 )
               WEIGH1 = NHINI / AHLTOT
               WEIGH2 = 1.D+00 - WEIGH1
               AEFREF = WEIGH1 * EKFIMP + WEIGH2 * EKFAVE
               RHONUC = WEIGH1 * RHOIMP + WEIGH2 * RHOAVE
               AEFRAV = WEIGH1 * EKFIMP + WEIGH2 * EKFAVE
               RHONUC = RHORED * ( ( AHLTOT + 1.D+00 - RHOWEI )
     &                * RHONUC + RHOWEI * RHOAVE ) / ( AHLTOT + 1.D+00 )
               AEFRAV = ( AHLTOT * AEFRAV + EKFAVE )
     &                / ( AHLTOT + 1.D+00 )
            END IF
            CLAMDI = 1.0D+00
         ELSE
            EKFCNN = AEFRMX
            AEFREF = 0.5D+00 * AEFRMX
            AEFRAV = AEFREF
            RHONUC = 0.5D+00**1.5D+00 * RHONU0
            CLAMDI = 0.5D+00
         END IF
         DO 4500 JEMISS = JEMIS0, JEMIS1, JDEMIS
            IF ( NPART (JEMISS) .LE. 0 ) GO TO 4500
            IEMISS = 3 - JEMISS
            RATEC0 = 2.D+00 * AMNUCL (IEMISS) / PLABRC**3 / PISQ
            BNDGEN = AMNAFT (JEMISS) + AMNUCL (IEMISS) - AMNRES
            IF ( .NOT. LNUCTS .AND. EPRFIX .GT. ANGLGB ) THEN
               TVEFF  = TVEFF - EPRFIX
               NPTOT  = NPTOT - NPRFIX (1) - NPRFIX (2)
               NPART (1) = NPART (1) - NPRFIX (1)
               NPART (2) = NPART (2) - NPRFIX (2)
               JEMFIX = JEMISS
               ERNCM0 = ERNCM (JEMISS)
               EPSMX0 = EPSMX (JEMISS)
               BNDGAV = BNENRG (IEMISS)
               EPSMX (JEMISS) = UMO - AMNRES - BNDGAV - EHLFIX - EPRFIX
            ELSE
               JEMFIX = 0
            END IF
            BNDGAV = BNENRG (IEMISS)
            EPSMIN = BNDGEN - BNDGAV
            BNDHLP = BNENRG (IEMISS)
            IF ( EPSMX (JEMISS) - EPSMIN .LT. TEMNU ) GO TO 4500
            IF ( EHLFIX + EPRFIX .LE. 0.5D+00 * EEXANW (JEMISS) ) THEN
               UUMIN  = TVEFF - 0.5D+00 * ( EPSANY (JEMISS)
     &                + EPSMX (JEMISS) ) - BNDGAV
            ELSE
               UUMIN  = TVEFF - EPSMX (JEMISS) - BNDGAV
            END IF
            UUMAX  = TVEFF - BNDGEN
            BNDUSE = BNENRG (IEMISS)
            IF ( LNUCTS ) THEN
               EKNNUC = ENNUC  (JNUCTS) - AMNUCL (IEMISS) + BNDGEN
     &                - RSTNUC (JNUCTS)
               EPSHLP = BNDHLP - BNDGEN + EPSMIN
               EKNNUC = EKNNUC + EPSHLP
               IF ( EKNNUC .LE. EPSMIN ) THEN
                  GO TO 4500
               ELSE IF ( EKNNUC .LE. 0.D+00 ) THEN
                  DELTAE = 0.5D+00 * ( - EPSMIN - EKNNUC )
                  EKNNUC = EKNNUC + DELTAE
               ELSE
                  DELTAE = 0.D+00
               END IF
               ENNUC (JNUCTS) = EKNNUC + AMNUCL (IEMISS)
               PNUCCO = SQRT ( EKNNUC * ( EKNNUC + 2.D+00
     &                * AMNUCL (IEMISS) ) )
               PHELP = PNUCCO / PNUCL (JNUCTS)
               PCMSX = PXNUCL (JNUCTS) * PHELP
               PCMSY = PYNUCL (JNUCTS) * PHELP
               PCMSZ = PZNUCL (JNUCTS) * PHELP
               ETAPCM = ETAX * PCMSX + ETAY * PCMSY + ETAZ * PCMSZ
               PHELP = ENNUC (JNUCTS) - ETAPCM / ( GAMCM + 1.D+00 )
               PCMSX = PCMSX - ETAX * PHELP
               PCMSY = PCMSY - ETAY * PHELP
               PCMSZ = PCMSZ - ETAZ * PHELP
               PCMST = SQRT ( PCMSX**2 + PCMSY**2 + PCMSZ**2 )
               EPS = GAMCM * ENNUC (JNUCTS) - ETAPCM - AMNUCL (IEMISS)
               IF ( EPS .LE. EPSMIN ) THEN
                  GO TO 4500
               ELSE IF ( EPS .LT. ANGLGB * ENNUC (JNUCTS) ) THEN
                  GO TO 4500
               END IF
               EPS   = EPS - DELTAE
               C (1) = PCMSX / PCMST
               C (2) = PCMSY / PCMST
               C (3) = PCMSZ / PCMST
               EPS = MIN ( EPS, HLFHLF * ( EPSMX (JEMISS)
     &             + EPSANY (JEMISS) ) )
               IF ( JEMISS .EQ. 2 ) THEN
                  FLKCOU = DOST ( 1, ZAFTR (JEMISS) )
                  CCOUL  = DOST ( 3, ZAFTR (JEMISS) )
                  ETHRES = FLKCOU * COULBH * ( ZNOW - 1.D+00 )
     &                   / RMASS (IBRES-1)
               END IF
               FLAMMX = 1.D+00
               NTENT  = 1
               ISAMPL = 0
               LSPREJ = .FALSE.
               GO TO 3000
            END IF
            IF ( UUMIN .GE. UUMAX ) GO TO 4500
            EPSINV = 0.5D+00 * ( UMO2 - ( AMNUCL (IEMISS)
     &             + AMNAFT (JEMISS) )**2 ) / AMNAFT (JEMISS)
            EPSWLL = EPSINV + AEFRAV + BNDUSE + AMNUCL (IEMISS)
            BETWLL = SQRT ( 1.D+00 - AMNUSQ (IEMISS) / EPSWLL**2 )
            EKEWLL = EPSWLL - AMNUCL (IEMISS)
            IF ( JEMISS .EQ. 1 ) THEN
               AALPHA = 0.76D+00 + 2.2D+00 / RMASS (IBRES-1)
               BBETAA = ( 2.22D+00 / RMASS (IBRES-1)**2 - 0.05D+00 )
     &                / AALPHA * 1.D-03
               TMP07  = 0.07D+00
               EPSEFF = MIN ( EPSINV, TMP07 )
               SIGINV = 0.1D+00 * XINNEU ( EPSEFF, ZAFTR (JEMISS),
     &                  BBETAA )
               SFTYMX = 1.1D+00
               GSNGLV = 1.5D+00 * ( ANOW - ZNOW ) / EKFCEN (IEMISS)
               IF ( EKEWLL .LE. 0.04D+00 ) THEN
                  SIGMAP = 3.D+03 * PI / ( 1.206D+03 * EKEWLL + (
     &                   -1.86D+00 + 0.09415D+03 * EKEWLL
     &                   + 0.0001306D+06 * EKEWLL**2 )**2 ) + 1.D+03
     &                   * PI / ( 1.206D+03 * EKEWLL + ( 0.4223D+00
     &                   + 0.13D+03 * EKEWLL )**2 )
                  IF ( EKEWLL .LT. 0.02D+00 ) THEN
                     SIGMAN = 0.3333333333333333D+00 * SIGMAP
                  ELSE
                     SIGMAN = 10.63D+00 / BETWLL**2 - 29.92D+00 / BETWLL
     &                      + 42.9D+00
                  END IF
               ELSE
                  SIGMAP = 34.10D+00 / BETWLL**2 - 82.2D+00 / BETWLL
     &                   + 82.2D+00
                  SIGMAN = 10.63D+00 / BETWLL**2 - 29.92D+00 / BETWLL
     &                   + 42.9D+00
               END IF
               SIGMAP = 0.1D+00 * SIGMAP
               SIGMAN = 0.1D+00 * SIGMAN
               SGNUNU = ( ( ANOW - ZNOW - ANNEUT ) * SIGMAN
     &                + ( ZNOW - ANPROT ) * SIGMAP )
     &                / ( ANOW - ANPTOT )
            ELSE
               EPSCOU = UMO - AMNAFT (JEMISS) - AMNUCL (IEMISS)
               FLKCOU = DOST ( 1, ZAFTR (JEMISS) )
               CCOUL  = DOST ( 3, ZAFTR (JEMISS) )
               ETHRES = FLKCOU * COULBH * ( ZNOW - 1.D+00 )
     &                / RMASS (IBRES-1)
               TMP07  = 0.07D+00
               EPSEFF = MIN ( EPSINV, TMP07 )
               SIGINV = 1.D-01 * XINPRO ( EPSEFF, ZAFTR (JEMISS),
     &                                    ETHRES )
               SFTYMX = 1.2D+00
               GSNGLV = 1.5D+00 * ZNOW / EKFCEN (IEMISS)
               IF ( EKEWLL .LE. 0.04D+00 ) THEN
                  SIGMAN = 3.D+03 * PI / ( 1.206D+03 * EKEWLL + (
     &                   -1.86D+00 + 0.09415D+03 * EKEWLL
     &                   + 0.0001306D+06 * EKEWLL**2 )**2 ) + 1.D+03
     &                   * PI / ( 1.206D+03 * EKEWLL + ( 0.4223D+00
     &                   + 0.13D+03 * EKEWLL )**2 )
                  IF ( EKEWLL .LT. 0.02D+00 ) THEN
                     SIGMAP = 0.3333333333333333D+00 * SIGMAN
                  ELSE
                     SIGMAP = 10.63D+00 / BETWLL**2 - 29.92D+00 / BETWLL
     &                      + 42.9D+00
                  END IF
               ELSE
                  SIGMAN = 34.10D+00 / BETWLL**2 - 82.2D+00 / BETWLL
     &                   + 82.2D+00
                  SIGMAP = 10.63D+00 / BETWLL**2 - 29.92D+00 / BETWLL
     &                   + 42.9D+00
               END IF
               SIGMAP = 0.1D+00 * SIGMAP
               SIGMAN = 0.1D+00 * SIGMAN
               SGNUNU = ( ( ANOW - ZNOW - ANNEUT ) * SIGMAN
     &                + ( ZNOW - ANPROT ) * SIGMAP )
     &                / ( ANOW - ANPTOT )
            END IF
            ZITA   = AEFRAV / EKEWLL
            IF ( ZITA .LE. 0.5D+00 ) THEN
               PZITA = 1.D+00 - 1.4D+00 * ZITA
            ELSE
               PZITA = 1.D+00 - 1.4D+00 * ZITA + 0.4D+00 * ZITA
     &               * ( 2.D+00 - 1.D+00 / ZITA )**2.5D+00
            END IF
            RATEC  = SIGINV * RATEC0 * EPSINV / GSNGLV
            IF ( RATEC .LE. 0.D+00 ) GO TO 4500
            ALAMDC = BETWLL / RATEC
            ALAMDI = 1.D+00 / ( SGNUNU * RHONUC * PZITA ) + MAX (TWOTWO
     &             * PI * PLABRC * BETWLL * EPSWLL / AMNUSQ (IEMISS),
     &             RZNUCL )
            AMUTOT = 1.D+00 / ALAMDI + 1.D+00 / ALAMDC
            RATEI  = BETWLL / ALAMDI
            FLAMMX = SFTYMX * RATEC / ( RATEC + CLAMDI * RATEI )
            IF ( FLAMMX .LT. 0.D+00 ) THEN
               GO TO 4500
            END IF
            LSPREJ = .NOT. ( NHOLE .GT. 2 .OR. NPTOT .GT. 4 )
            IF ( LSPREJ ) THEN
               IF ( NPTOT .EQ. 1 ) THEN
                  IF ( NHOLE .EQ. 0 ) THEN
                     EPS = EPSMX (JEMISS)
                     FLAMMX = 1.D+00
                     NTENT  = 1
                     ISAMPL = 0
                     LSPREJ = .FALSE.
                     GO TO 3000
                  ELSE IF ( NHOLE .EQ. 1 ) THEN
                     ISAMPL = 1
                  ELSE IF ( NHOLE .EQ. 2 ) THEN
                     ISAMPL = 2
                  ELSE
                     ISAMPL = 7
                  END IF
               ELSE IF ( NPTOT .EQ. 2 ) THEN
                  IF ( NHOLE .EQ. 0 ) THEN
                     ISAMPL = 7
                  ELSE IF ( NHOLE .EQ. 1 ) THEN
                     ISAMPL = 3
                  ELSE IF ( NHOLE .EQ. 2 ) THEN
                     ISAMPL = 4
                  ELSE
                     ISAMPL = 7
                  END IF
               ELSE IF ( NPTOT .EQ. 3 ) THEN
                  IF ( NHOLE .EQ. 0 ) THEN
                     ISAMPL = 7
                  ELSE IF ( NHOLE .EQ. 1 ) THEN
                     ISAMPL = 5
                  ELSE IF ( NHOLE .EQ. 2 ) THEN
                     ISAMPL = 6
                  ELSE
                     ISAMPL = 7
                  END IF
               ELSE
                  ISAMPL = 7
               END IF
            ELSE
               ISAMPL = 7
            END IF
            GO TO ( 2100, 2200, 2300, 2400, 2500, 2600, 2700 ), ISAMPL
 2100       CONTINUE
               LSPREJ = .FALSE.
               AEFRPA = AEFREF
               UUMAX  = MIN ( AEFRPA, UUMAX )
               AITOT  = ( AEFRPA**3 - ( AEFRPA + UUMIN - UUMAX )**3 )
     &                / AEFRPA**3
               IF ( UUMAX .GT. TVEFF ) THEN
                  AIPRO = MIN ( AITOT, ONEONE ) * FLAMMX
                  AITOT = AITOT * FLAMMX
               ELSE
                  AITOT = AITOT * FLAMMX
                  AIPRO = AITOT
               END IF
            GO TO 2800
 2200       CONTINUE
               LSPREJ = .FALSE.
               AEFRPA = AEFREF
               UUMAX  = MIN ( TWOTWO * AEFRPA, UUMAX )
               IF ( TVEFF .LE. AEFRPA ) THEN
                  EDENOM = TVEFF**2 * 0.5D+00
               ELSE IF ( TVEFF .LE. 2.D+00 * AEFRPA ) THEN
                  EDENOM = ( TVEFF**2 - 2.D+00 * ( TVEFF - AEFRPA )**2 )
     &                   * 0.5D+00
               ELSE
                  EDENOM = AEFRPA**2
               END IF
               UUMN2 = UUMIN**2
               IF ( UUMAX .GT. AEFRPA ) THEN
                  UUDIV = AEFRPA
                  UUDV2 = UUDIV**2
                  AIPR1 = 0.5D+00 * UUDV2
                  AIPR2 = 0.5D+00 * ( UUMAX - UUDIV ) * ( 3.D+00 * UUDIV
     &                  - UUMAX )
                  IF ( UUMIN .LE. UUDIV ) THEN
                     AITO1 = 0.5D+00 * ( UUDV2 - UUMN2 )
                     AITO2 = AIPR2
                     AIHLP = 0.D+00
                  ELSE
                     AITO1 = 0.D+00
                     AIHLP = 0.5D+00 * ( UUMIN - UUDIV ) * ( 3.D+00
     &                     * UUDIV - UUMIN )
                     AITO2 = AIPR2 - AIHLP
                  END IF
               ELSE
                  UUDIV = UUMAX
                  UUDV2 = UUDIV**2
                  AIPR1 = 0.5D+00 * UUDV2
                  AITO1 = 0.5D+00 * ( UUDV2 - UUMN2 )
                  AITO2 = 0.D+00
                  AIPR2 = 0.D+00
               END IF
               AITOT = AITO1 + AITO2
               AITO1 = AITO1 / AITOT
               AITO2 = AITO2 / AITOT
               AITOT = AITOT * FLAMMX / EDENOM
               IF ( UUMAX .GT. TVEFF ) THEN
                  AIPRO = MIN ( ( AIPR1 + AIPR2 ) / EDENOM, ONEONE )
     &                  * FLAMMX
               ELSE
                  AIPRO = ( AIPR1 + AIPR2 ) * FLAMMX / EDENOM
               END IF
            GO TO 2800
 2300       CONTINUE
               LSPREJ = .FALSE.
               AEFRPA = AEFREF
               IF ( TVEFF .LE. AEFRPA ) THEN
                  EDENOM = 0.25D+00 * TVEFF * TVEFF
               ELSE
                  EDENOM = 0.25D+00 * AEFRPA * ( 2.D+00 * TVEFF
     &                   - AEFRPA )
               END IF
               FCHLP = 0.25D+00 * NPART (JEMISS)
               IF ( UUMAX .LE. AEFRPA ) THEN
                  UUDIV = UUMAX
                  AIPR1 = FCHLP * UUDIV**2
                  AITO1 = AIPR1 - FCHLP * UUMIN**2
                  AITO2 = 0.D+00
                  AIPR2 = 0.D+00
               ELSE
                  UUDIV = AEFRPA
                  AIPR1 = FCHLP * UUDIV**2
                  AIPR2 = FCHLP * ( UUMAX - UUDIV ) * UUDIV
                  IF ( UUMIN .GT. UUDIV ) THEN
                     AITO1 = 0.D+00
                     AIHLP = FCHLP * ( UUMIN - UUDIV ) * UUDIV
                     AITO2 = AIPR2 - AIHLP
                  ELSE
                     AIHLP = 0.D+00
                     AITO1 = AIPR1 - FCHLP * UUMIN**2
                     AITO2 = AIPR2
                  END IF
               END IF
               AITOT = AITO1 + AITO2
               AITO1 = AITO1 / AITOT
               AITO2 = AITO2 / AITOT
               IF ( UUMAX .GT. TVEFF ) THEN
                  DDNPAR = NPART(JEMISS)
                  AIPRO = MIN ( ( AIPR1 + AIPR2 ) / EDENOM,
     &                    DDNPAR ) * FLAMMX
               ELSE
                  AIPRO = ( AIPR1 + AIPR2 ) * FLAMMX / EDENOM
               END IF
            GO TO 2800
 2400       CONTINUE
               LSPREJ = .TRUE.
               AEFRPA = AEFREF
               IF ( TVEFF .LE. AEFRPA ) THEN
                  LSPREJ = .FALSE.
                  FEMAX  = 1.D+00
                  ISAMPL = 7
               ELSE IF ( TVEFF .LE. 2.D+00 * AEFRPA ) THEN
                  FEMAX = TVEFF**3 / ( TVEFF**3 - 2.D+00 * ( TVEFF
     &                  - AEFRPA )**3 )
               ELSE
                  FEMAX = 0.1666666666666667D+00 * TVEFF**3
     &                  / ( AEFRPA**2 * ( TVEFF - AEFRPA ) )
               END IF
               UUMNR  = ( UUMIN / TVEFF )**(NEXTOT-1)
               UUMXR  = ( UUMAX / TVEFF )**(NEXTOT-1)
               AITOT  = NPART (JEMISS) * FLAMMX * ( UUMXR - UUMNR )
     &                * FEMAX
               AIPRO  = NPART (JEMISS) * FLAMMX * UUMXR * FEMAX
            GO TO 2800
 2500       CONTINUE
               LSPREJ = .FALSE.
               AEFRPA = AEFREF
               IF ( TVEFF .LE. AEFRPA ) THEN
                  EDENOM = TVEFF**3 / 36.D+00
               ELSE
                  EDENOM = ( TVEFF**3 - ( TVEFF - AEFRPA )**3 )
     &                   / 26.D+00
               END IF
               IF ( UUMAX .GT. AEFRPA ) THEN
                  UUDIV = AEFRPA
                  UUDV3 = UUDIV**3
                  UUMN3 = UUMIN**3
                  FCHLP = NPART(JEMISS) / 36.D+00
                  AIPR1 = FCHLP * UUDV3
                  AIPR2 = 3.D+00 * FCHLP * UUMAX * UUDIV * ( UUMAX
     &                  - UUDIV )
                  IF ( UUMIN .LE. UUDIV ) THEN
                     AITO1 = AIPR1 - FCHLP * UUMN3
                     AITO2 = AIPR2
                     AIHLP = 0.D+00
                  ELSE
                     AITO1 = 0.D+00
                     AIHLP = 3.D+00 * FCHLP * UUMIN * UUDIV * ( UUMIN
     &                     - UUDIV )
                     AITO2 = AIPR2 - AIHLP
                  END IF
               ELSE
                  UUDIV = UUMAX
                  UUDV3 = UUDIV**3
                  UUMN3 = UUMIN**3
                  FCHLP = NPART(JEMISS) / 36.D+00
                  AIPR1 = FCHLP * UUDV3
                  AITO1 = AIPR1 - FCHLP * UUMN3
                  AIPR2 = 0.D+00
                  AITO2 = 0.D+00
               END IF
               AITOT = AITO1 + AITO2
               AITO1 = AITO1 / AITOT
               AITO2 = AITO2 / AITOT
               AITOT = AITOT * FLAMMX / EDENOM
               IF ( UUMAX .GT. TVEFF ) THEN
                  DDNPAR = NPART(JEMISS)
                  AIPRO = MIN ( ( AIPR1 + AIPR2 ) / EDENOM,
     &                    DDNPAR ) * FLAMMX
               ELSE
                  AIPRO = ( AIPR1 + AIPR2 ) * FLAMMX / EDENOM
               END IF
            GO TO 2800
 2600       CONTINUE
               AEFRPA = AEFREF
               IF ( TVEFF .LE. AEFRPA ) THEN
                  EDENOM = TVEFF**4 / 288.D+00
               ELSE IF ( TVEFF .LE. 2.D+00 * AEFRPA ) THEN
                  EDENOM = ( TVEFF**4 - 2.D+00 * ( TVEFF - AEFRPA )**4 )
     &                   / 288.D+00
               ELSE
                  EDENOM = AEFRPA**2 * ( 0.5D+00 * TVEFF**2 - TVEFF
     &                   * AEFRPA + 7.D+00 / 12.D+00 * AEFRPA**2 )
     &                   / 12.D+00
               END IF
               FCHLP = NPART (JEMISS) / 288.D+00
               IF ( UUMAX .GT. 2.D+00 * AEFRPA ) THEN
                  LSPREJ = .TRUE.
                  UUDIV = AEFRPA
                  UUDI2 = 2.D+00 * AEFRPA
                  UUDV4 = UUDIV**4
                  UUMN4 = UUMIN**4
                  UUD24 = UUDI2**4
                  AIPR1 = FCHLP * UUDV4
                  AIPR2 = FCHLP * ( UUD24 - UUDV4 )
                  AIPR3 = 12.D+00 * FCHLP * AEFRPA**2 * UUMAX
     &                  * ( UUMAX - UUDI2 )
                  IF ( UUMIN .LE. UUDIV ) THEN
                     AITO1 = AIPR1 - FCHLP * UUMN4
                     AITO2 = AIPR2
                     AITO3 = AIPR3
                     AIHLP = 0.D+00
                     AIHL2 = 0.D+00
                  ELSE IF ( UUMIN .LE. UUDI2 ) THEN
                     AITO1 = 0.D+00
                     AIHLP = FCHLP * ( UUMN4 - UUDV4 )
                     AITO2 = AIPR2 - AIHLP
                     AITO3 = AIPR3
                     AIHL2 = 0.D+00
                  ELSE
                     AITO1 = 0.D+00
                     AITO2 = 0.D+00
                     AIHL2 = 12.D+00 * FCHLP * AEFRPA**2 * UUMIN
     &                     * ( UUMIN - UUDI2 )
                     AITO3 = AIPR3 - AIHL2
                  END IF
               ELSE IF ( UUMAX .GT. AEFRPA ) THEN
                  LSPREJ = .TRUE.
                  UUDIV = AEFRPA
                  UUDI2 = UUMAX
                  UUDV4 = UUDIV**4
                  UUMN4 = UUMIN**4
                  UUD24 = UUDI2**4
                  AIPR1 = FCHLP * UUDV4
                  AIPR2 = FCHLP * ( UUD24 - UUDV4 )
                  IF ( UUMIN .LE. UUDIV ) THEN
                     AITO1 = AIPR1 - FCHLP * UUMN4
                     AITO2 = AIPR2
                     AIHLP = 0.D+00
                  ELSE
                     AITO1 = 0.D+00
                     AIHLP = FCHLP * ( UUMN4 - UUDV4 )
                     AITO2 = AIPR2 - AIHLP
                  END IF
                  AIPR3 = 0.D+00
                  AITO3 = 0.D+00
               ELSE
                  LSPREJ = .FALSE.
                  UUDI2 = UUMAX
                  UUDIV = UUMAX
                  UUDV4 = UUDIV**4
                  UUMN4 = UUMIN**4
                  AIPR1 = FCHLP * UUDV4
                  AITO1 = AIPR1 - FCHLP * UUMN4
                  AITO2 = 0.D+00
                  AIPR2 = 0.D+00
                  AITO3 = 0.D+00
                  AIPR3 = 0.D+00
               END IF
               AITOT = AITO1 + AITO2 + AITO3
               AITO1 = AITO1 / AITOT
               AITO2 = AITO2 / AITOT
               AITO3 = AITO3 / AITOT
               AITOT = AITOT * FLAMMX / EDENOM
               AIPRO = ( AIPR1 + AIPR2 + AIPR3 ) * FLAMMX / EDENOM
            GO TO 2800
 2700       CONTINUE
               LSPREJ = .FALSE.
               TVLEFF = LOG(TVEFF)
               IF(UUMAX.LE.0.) THEN
                  UULMXR=-100
               ELSE
                  UULMXR = (LOG(UUMAX)-TVLEFF)*(NEXTOT-1)
               ENDIF
               IF(UULMXR.LT.-88) THEN
                  UUMNR = 0.
                  UUMXR = 0.
               ELSE
                  UUMXR = EXP(UULMXR)
                  IF(UUMIN.LE.0.) THEN
                     UULMNR=-100
                  ELSE
                     UULMNR = (LOG(UUMIN)-TVLEFF)*(NEXTOT-1)
                  ENDIF
                  IF(UULMNR.LT.-88) THEN
                     UUMNR = 0.
                  ELSE
                     UUMNR = EXP(UULMNR)
                  ENDIF
               ENDIF
               AITOT  = NPART (JEMISS) * FLAMMX * ( UUMXR - UUMNR )
               AIPRO  = NPART (JEMISS) * FLAMMX * MIN ( UUMXR, ONEONE )
 2800       CONTINUE
            NTENT  = INT  (AIPRO)
            CALL GRNDM(RNDM,1)
            RNTENT = RNDM (1)
            IF ( RNTENT .LT. AIPRO - NTENT ) NTENT = NTENT + 1
 3000       CONTINUE
            ITACC = 0
            DO 4100 IT = 1, NTENT
               GO TO ( 3100, 3200, 3300, 3400, 3500, 3600, 3700 ),
     &            ISAMPL
               GO TO 4000
 3100          CONTINUE
                  CALL GRNDM(RNDM,1)
                  UURND = AEFRPA * ( 1.D+00 - AITOT / FLAMMX
     &                  * RNDM (1) )**0.3333333333333333D+00
                  UURND = AEFRPA - UURND + UUMIN
               GO TO 3800
 3200          CONTINUE
                  CALL GRNDM(RNDM,1)
                  RNDEPS = RNDM (1)
                  IF ( RNDEPS .LT. AITO1 ) THEN
                     RNDEPS = RNDEPS / AITO1
                     UURND  = SQRT ( RNDEPS * ( UUDV2 - UUMN2 ) + UUMN2)
                  ELSE
                     RNDEPS = RNDEPS - AITO1
                     RNDEPS = AIHLP + RNDEPS * AITOT * EDENOM / FLAMMX
                     UURND  = 2.D+00 * UUDIV - SQRT ( UUDIV**2
     &                      - 2.D+00 * RNDEPS )
                  END IF
               GO TO 3800
 3300          CONTINUE
                  CALL GRNDM(RNDM,1)
                  RNDEPS = RNDM (1)
                  IF ( RNDEPS .LT. AITO1 ) THEN
                     RNDEPS = RNDEPS * AITOT
                     UURND  = RNDEPS / FCHLP + UUMIN**2
                     UURND  = SQRT (UURND)
                  ELSE
                     RNDEPS = ( RNDEPS - AITO1 ) * AITOT + AIHLP
                     UURND  = RNDEPS / FCHLP / UUDIV + UUDIV
                  END IF
               GO TO 3800
 3400          CONTINUE
                  CALL GRNDM(RNDM,1)
                  UURND = TVEFF * ( RNDM (1) * AITOT / FLAMMX
     &                  / FEMAX / NPART(JEMISS) + UUMNR )**
     &                  ( 1.D+00 / (NEXTOT-1) )
                  IF ( UURND .LE. AEFRPA ) THEN
                     LSPREJ = .FALSE.
                     FREJE  = 1.D+00
                  ELSE IF ( UURND .LE. 2.D+00 * AEFRPA ) THEN
                     FREJE  = ( UURND**2 - 2.D+00 * ( UURND - AEFRPA )
     &                      **2 ) / UURND**2
                  ELSE
                     FREJE  = 2.D+00 * AEFRPA**2 / UURND**2
                  END IF
               GO TO 3800
 3500          CONTINUE
                  CALL GRNDM(RNDM,1)
                  RNDEPS = RNDM (1)
                  IF ( RNDEPS .LT. AITO1 ) THEN
                     RNDEPS = RNDEPS / AITO1
                     UURND  = RNDEPS * ( UUDV3 - UUMN3 ) + UUMN3
                     UURND  = UURND**0.333333333333333D+00
                     LSPREJ = .FALSE.
                  ELSE IF ( RNDEPS .LT. AITO1 + AITO2 ) THEN
                     RNDEPS = RNDEPS - AITO1
                     RNDEPS = RNDEPS * AITOT * EDENOM / FLAMMX + AIHLP
                     UURND  = 0.5D+00 * ( UUDIV + SQRT ( UUDIV**2
     &                      + 1.333333333333333D+00 * RNDEPS / FCHLP
     &                      / UUDIV ) )
                     LSPREJ = .FALSE.
                  END IF
               GO TO 3800
 3600          CONTINUE
                  CALL GRNDM(RNDM,1)
                  RNDEPS = RNDM (1)
                  IF ( RNDEPS .LT. AITO1 ) THEN
                     RNDEPS = RNDEPS / AITO1
                     UURND  = RNDEPS * ( UUDV4 - UUMN4 ) + UUMN4
                     UURND  = UURND**0.25D+00
                     LSPREJ = .FALSE.
                  ELSE IF ( RNDEPS .LT. AITO1 + AITO2 ) THEN
                     RNDEPS = RNDEPS - AITO1
                     RNDEPS = RNDEPS * AITOT * EDENOM / FLAMMX + AIHLP
                     UURND  = RNDEPS / FCHLP + UUDV4
                     UURND  = UURND**0.25D+00
                     LSPREJ = .TRUE.
                     FREJE  = 1.D+00 - 2.D+00 * ( 1.D+00 - UUDIV / UURND
     &                      )**3
                  ELSE
                     RNDEPS = RNDEPS - AITO1 - AITO2
                     RNDEPS = RNDEPS * AITOT * EDENOM / FLAMMX + AIHL2
                     UURND  = AEFRPA + SQRT ( AEFRPA**2 + RNDEPS /
     &                      ( 12.D+00 * FCHLP * AEFRPA**2 ) )
                     LSPREJ = .FALSE.
                  END IF
               GO TO 3800
 3700          CONTINUE
                  CALL GRNDM(RNDM,1)
                  UURND = TVEFF * ( RNDM (1) * AITOT / FLAMMX
     &                  / NPART(JEMISS) + UUMNR )**
     &                  ( 1.D+00 / (NEXTOT-1) )
 3800          CONTINUE
               IF ( LSPREJ ) THEN
                  CALL GRNDM(RNDM,1)
                  IF ( RNDM (1) .GE. FREJE ) GO TO 4100
               END IF
               EPS    = TVEFF - UURND - BNDGAV
 4000          CONTINUE
               IF ( LPRFIX ) THEN
                  ITACC = ITACC + 1
                  EPSFIX (ITACC) = EPS - EPSMIN + BNDGEN
               END IF
               DEPSEX = EPS - EPSEEX (JEMISS)
               IF ( DEPSEX .GT. 0.D+00 ) THEN
                  IF ( EEXDLT (JEMISS) .LT. EEXMNM (JEMISS) .AND.
     &               DEPSEX .GT. 0.5D+00 * ( EPSDLT (JEMISS) - EPSEEX
     &              (JEMISS) ) ) THEN
                     DEPSEX = EPS - EPSDLT (JEMISS)
                     IF ( DEPSEX .GT. 0.5D+00 * ( EPSDLT (JEMISS)
     &                  - EPSANY (JEMISS) ) ) THEN
                        EPS = EPSANY (JEMISS)
                     ELSE
                        EPS = EPSDLT (JEMISS)
                     END IF
                  ELSE
                     EPS = EPSEEX (JEMISS)
                  END IF
                  IF ( EPS .LE. EPSMIN ) GO TO 4100
               END IF
               AMNHLP = UMO - EPS + EPSMIN - AMNUCL (IEMISS)
               ERNCM (JEMISS) = 0.5D+00 * ( UMO2 + AMNHLP**2
     &                        - AMNUSQ (IEMISS) ) / UMO
               EPS    = UMO - ERNCM (JEMISS) - AMNUCL (IEMISS)
               EPSINV = 0.5D+00 * ( UMO2 - ( AMNUCL (IEMISS)
     &                + AMNHLP )**2 ) / AMNHLP
               EPSWLL = EPSINV + AEFRAV + BNDUSE + AMNUCL (IEMISS)
               BETWLL = SQRT ( 1.D+00 - AMNUSQ (IEMISS) / EPSWLL**2 )
               EKEWLL = EPSWLL - AMNUCL (IEMISS)
               EPSCOU = UMO - AMNHLP - AMNUCL (IEMISS)
               IF ( JEMISS .EQ. 1 ) THEN
                  GSNGLV = 1.5D+00 * ( ANOW - ZNOW ) * SQRT ( ( EKEWLL
     &                   + EKFCEN (IEMISS) - AEFRAV ) / EKFCEN (IEMISS))
     &                   / EKFCEN (IEMISS)
                  AALPHA = 0.76D+00 + 2.2D+00 / RMASS (IBRES-1)
                  BBETAA = ( 2.22D+00 / RMASS (IBRES-1)**2 - 0.05D+00 )
     &                / AALPHA * 1.D-03
                  SIGINV = 0.1D+00 * XINNEU ( EPSINV, ZAFTR (JEMISS),
     &                                        BBETAA )
                  IF ( EKEWLL .LE. 0.04D+00 ) THEN
                     SIGMAP = 3.D+03 * PI / ( 1.206D+03 * EKEWLL + (
     &                      -1.86D+00 + 0.09415D+03 * EKEWLL
     &                      + 0.0001306D+06 * EKEWLL**2 )**2 ) + 1.D+03
     &                      * PI / ( 1.206D+03 * EKEWLL + ( 0.4223D+00
     &                      + 0.13D+03 * EKEWLL )**2 )
                     IF ( EKEWLL .LT. 0.02D+00 ) THEN
                        SIGMAN = 0.3333333333333333D+00 * SIGMAP
                     ELSE
                        SIGMAN = 10.63D+00 / BETWLL**2 - 29.92D+00
     &                         / BETWLL + 42.9D+00
                     END IF
                  ELSE
                     SIGMAP = 34.10D+00 / BETWLL**2 - 82.2D+00 / BETWLL
     &                      + 82.2D+00
                     SIGMAN = 10.63D+00 / BETWLL**2 - 29.92D+00 / BETWLL
     &                      + 42.9D+00
                  END IF
                  SIGMAP = 0.1D+00 * SIGMAP
                  SIGMAN = 0.1D+00 * SIGMAN
                  SGNUNU = ( ( ANOW - ZNOW - ANNEUT ) * SIGMAN
     &                   + ( ZNOW - ANPROT ) * SIGMAP )
     &                   / ( ANOW - ANPTOT )
               ELSE
                  GSNGLV = 1.5D+00 * ZNOW * SQRT ( ( EKEWLL
     &                   + EKFCEN (IEMISS) - AEFRAV ) / EKFCEN (IEMISS))
     &                   / EKFCEN (IEMISS)
                  SIGINV = 1.D-01 * XINPRO ( EPSINV, ZAFTR (JEMISS),
     &                                       ETHRES )
                  IF ( EKEWLL .LE. 0.04D+00 ) THEN
                     SIGMAN = 3.D+03 * PI / ( 1.206D+03 * EKEWLL + (
     &                      -1.86D+00 + 0.09415D+03 * EKEWLL
     &                      + 0.0001306D+06 * EKEWLL**2 )**2 ) + 1.D+03
     &                      * PI / ( 1.206D+03 * EKEWLL + ( 0.4223D+00
     &                      + 0.13D+03 * EKEWLL )**2 )
                     IF ( EKEWLL .LT. 0.02D+00 ) THEN
                        SIGMAP = 0.3333333333333333D+00 * SIGMAN
                     ELSE
                        SIGMAP = 10.63D+00 / BETWLL**2 - 29.92D+00
     &                         / BETWLL + 42.9D+00
                     END IF
                  ELSE
                     SIGMAN = 34.10D+00 / BETWLL**2 - 82.2D+00 / BETWLL
     &                      + 82.2D+00
                     SIGMAP = 10.63D+00 / BETWLL**2 - 29.92D+00 / BETWLL
     &                      + 42.9D+00
                  END IF
                  SIGMAP = 0.1D+00 * SIGMAP
                  SIGMAN = 0.1D+00 * SIGMAN
                  SGNUNU = ( ( ANOW - ZNOW - ANNEUT ) * SIGMAN
     &                   + ( ZNOW - ANPROT ) * SIGMAP )
     &                   / ( ANOW - ANPTOT )
               END IF
               ZITA   = AEFRAV / EKEWLL
               IF ( ZITA .LE. 0.5D+00 ) THEN
                  PZITA = 1.D+00 - 1.4D+00 * ZITA
               ELSE
                  PZITA = 1.D+00 - 1.4D+00 * ZITA + 0.4D+00 * ZITA
     &                  * ( 2.D+00 - 1.D+00 / ZITA )**2.5D+00
               END IF
               RATEC  = SIGINV * RATEC0 * EPSINV / GSNGLV
               IF ( RATEC .LE. 0.D+00 ) GO TO 4100
               ALAMDC = BETWLL / RATEC
               ALAMDI = 1.D+00 / ( SGNUNU * RHONUC * PZITA ) + MAX (
     &                  TWOTWO * PI * PLABRC * BETWLL * EPSWLL
     &                / AMNUSQ (IEMISS), RZNUCL )
               AMUTOT = 1.D+00 / ALAMDI + 1.D+00 / ALAMDC
               RATEI  = BETWLL / ALAMDI
               FLAMDA = RATEC / ( RATEC + CLAMDI * RATEI ) / FLAMMX
               CALL GRNDM(RNDM,1)
               IF ( RNDM (1) .LT. FLAMDA ) GO TO 4200
 4100       CONTINUE
            IF ( JEMISS .EQ. JEMIS1 ) GO TO 4500
            IF ( ITACC .LE. NPART (JEMISS) ) THEN
               NPRFIX (JEMISS) = NPRFIX (JEMISS) + ITACC
               DO 4150 IT = 1, ITACC
                  EPRFIX = EPRFIX + EPSFIX (IT)
 4150          CONTINUE
            ELSE
               NPRFIX (JEMISS) = NPART (JEMISS)
               ACCEP = 0.D+00
               DO 4160 IT = 1, ITACC
                  PRACC  = ( NPART (JEMISS) - ACCEP )
     &                   / ( ITACC - IT + 1 )
                  CALL GRNDM(RNDM,1)
                  IF ( RNDM (1) .LT. PRACC ) THEN
                     EPRFIX = EPRFIX + EPSFIX (IT)
                     ACCEP  = ACCEP  + 1.D+00
                  END IF
 4160          CONTINUE
            END IF
            GO TO 4500
 4200       CONTINUE
            ZNOW = ZAFTR (JEMISS)
            ANOW = AAFTR
            IBRES = IBRES - 1
            ICRES = ICRES - JEMISS + 1
            AMMRES = AMMAFT (JEMISS)
            AMNRES = AMNAFT (JEMISS)
            EEPCM  = EPS + AMNUCL (IEMISS)
            ERESCM = UMO - EEPCM
            IF ( LNUCTS ) THEN
            ELSE IF ( ICYCL .EQ. 1 .AND. LEMISS ) THEN
               C (1) = C2ND (1)
               C (2) = C2ND (2)
               C (3) = C2ND (3)
            ELSE IF ( ICYCL .LE. 1 .AND. PCMORI .LE. ANGLGB ) THEN
               C (1) = C1ST (1)
               C (2) = C1ST (2)
               C (3) = C1ST (3)
            ELSE IF ( ICYCL .LE. 1 ) THEN
               PCMSXT = - AMNUCL (IEMISS) * ETAX
               PCMSYT = - AMNUCL (IEMISS) * ETAY
               PCMSZT = - AMNUCL (IEMISS) * ETAZ
               APSHAR = MAX ( ANPTOT + NEMISS - 1, ONEONE )
               PCMSX  = ( CXAXCM * PCMORI + PCMSXT ) / APSHAR - PCMSXT
               PCMSY  = ( CYAXCM * PCMORI + PCMSYT ) / APSHAR - PCMSYT
               PCMSZ  = ( CZAXCM * PCMORI + PCMSZT ) / APSHAR - PCMSZT
*
               PCMSTT = PCMSXT**2 + PCMSYT**2 + PCMSZT**2
               PCMSPT = PCMSX**2  + PCMSY**2  + PCMSZ**2
               ECMSTT = SQRT ( AMNUSQ (IEMISS) + PCMSTT )
               ECMSPT = SQRT ( AMNUSQ (IEMISS) + PCMSPT )
*
               UMMO2  = 2.D+00 * AMNUSQ (IEMISS) + 2.D+00 * ECMSTT
     &                * ECMSPT - 2.D+00 * ( PCMSXT * PCMSX + PCMSYT
     &                * PCMSY + PCMSZT * PCMSZ )
               UMMO   = SQRT ( UMMO2 )
               GAMCCM = ( ECMSTT + ECMSPT ) / UMMO
               ETAXM  = ( PCMSX + PCMSXT ) / UMMO
               ETAYM  = ( PCMSY + PCMSYT ) / UMMO
               ETAZM  = ( PCMSZ + PCMSZT ) / UMMO
               ETAPCM = ETAXM * PCMSX + ETAYM * PCMSY + ETAZM * PCMSZ
               PHELP  = ECMSPT - ETAPCM / ( GAMCCM + 1.D+00 )
               PCCMSX = PCMSX - ETAXM * PHELP
               PCCMSY = PCMSY - ETAYM * PHELP
               PCCMSZ = PCMSZ - ETAZM * PHELP
               PCCMSP = SQRT ( PCCMSX**2 + PCCMSY**2 + PCCMSZ**2 )
               CALL RACO (C(1),C(2),C(3))
               SCAPRO = PCCMSX * C (1) + PCCMSY * C (2) + PCCMSZ * C (3)
               IF ( SCAPRO .LT. 0.D+00 ) THEN
                  C (1) = - C (1)
                  C (2) = - C (2)
                  C (3) = - C (3)
               END IF
               PCCMSX = C(1) * PCCMSP
               PCCMSY = C(2) * PCCMSP
               PCCMSZ = C(3) * PCCMSP
               ETAPCM = ETAXM * PCCMSX + ETAYM * PCCMSY + ETAZM * PCCMSZ
               PHELP  = 0.5D+00 * UMMO + ETAPCM / ( GAMCCM + 1.D+00 )
               PCMSX  = PCCMSX + ETAXM * PHELP
               PCMSY  = PCCMSY + ETAYM * PHELP
               PCMSZ  = PCCMSZ + ETAZM * PHELP
               PCMSPT = SQRT ( PCMSX**2 + PCMSY**2 + PCMSZ**2 )
               C (1)  = PCMSX / PCMSPT
               C (2)  = PCMSY / PCMSPT
               C (3)  = PCMSZ / PCMSPT
               ETAPCM = - ETAPCM
               PHELP  = 0.5D+00 * UMMO + ETAPCM / ( GAMCCM + 1.D+00 )
               PCMSX  = - PCCMSX + ETAXM * PHELP
               PCMSY  = - PCCMSY + ETAYM * PHELP
               PCMSZ  = - PCCMSZ + ETAZM * PHELP
               PCMSPT = SQRT ( PCMSX**2 + PCMSY**2 + PCMSZ**2 )
               C2ND (1) = PCMSX / PCMSPT
               C2ND (2) = PCMSY / PCMSPT
               C2ND (3) = PCMSZ / PCMSPT
            ELSE
               UMULEG (0) = 1.0D+00
               UMULEG (1) = 0.6666666666666667D+00
               UMULEG (2) = 0.25D+00
               ACOLEG (0) = 0.5D+00
               ACOLEG (1) = 1.5D+00 * UMULEG (1)**ICYCL
               ACOLEG (2) = 2.5D+00 * UMULEG (2)**ICYCL
               COSTHE = COSLEG ( ACOLEG )
               SINTHE = SQRT ( ( 1.D+00 - COSTHE ) * ( 1.D+00 + COSTHE )
     &                )
 4300          CONTINUE
                  CALL GRNDM(RNDM,2)
                  RPHI1 = 2.D+00 * RNDM (1) - 1.D+00
                  RPHI2 = 2.D+00 * RNDM (2) - 1.D+00
                  RPHI12 = RPHI1 * RPHI1
                  RPHI22 = RPHI2 * RPHI2
                  RSQ = RPHI12 + RPHI22
               IF ( RSQ .GT. 1.D+00 ) GO TO 4300
               SINPHI = 2.D+00 * RPHI1 * RPHI2 / RSQ
               COSPHI = ( RPHI12 - RPHI22 ) / RSQ
               SINT02 = ( 1.D+00 - CZAXCM ) * ( 1.D+00 + CZAXCM )
               IF ( SINT02 .LT. ANGLSQ ) THEN
                  C (1) = COSPHI * SINTHE
                  C (2) = SINPHI * SINTHE
                  C (3) = CZAXCM * COSTHE
               ELSE
                  SINTH0 = SQRT ( SINT02 )
                  UPRIME = SINTHE * COSPHI
                  VPRIME = SINTHE * SINPHI
                  COSPH0 = CXAXCM / SINTH0
                  SINPH0 = CYAXCM / SINTH0
                  C (1) = UPRIME * COSPH0 * CZAXCM - VPRIME * SINPH0
     &                  + COSTHE * CXAXCM
                  C (2) = UPRIME * SINPH0 * CZAXCM + VPRIME * COSPH0
     &                  + COSTHE * CYAXCM
                  C (3) = - UPRIME * SINTH0 + COSTHE * CZAXCM
               END IF
            END IF
            PCMS  = SQRT ( ( EEPCM - AMNUCL (IEMISS) ) * ( EEPCM
     &            + AMNUCL (IEMISS) ) )
            UMO2   = ( ERESCM - PCMS ) * ( ERESCM + PCMS )
            UMO    = SQRT (UMO2)
            PCMSX = PCMS * C (1)
            PCMSY = PCMS * C (2)
            PCMSZ = PCMS * C (3)
            ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
            NP = NP + 1
            KPART (NP) = 1 - 7 * ( JEMISS - 2 )
            TKI   (NP) = GAMCM * EEPCM + ETAPCM - AMNUCL (IEMISS)
            PHELP = ETAPCM / ( GAMCM + 1.D+00 ) + EEPCM
            WEI   (NP) = WEE
            PLBPX = PCMSX + ETAX * PHELP
            PLBPY = PCMSY + ETAY * PHELP
            PLBPZ = PCMSZ + ETAZ * PHELP
            PHELP = SQRT ( PLBPX * PLBPX + PLBPY * PLBPY
     &            + PLBPZ * PLBPZ )
            CXR   (NP) = PLBPX / PHELP
            CYR   (NP) = PLBPY / PHELP
            CZR   (NP) = PLBPZ / PHELP
            PLR   (NP) = PHELP
            IGREYP = IGREYP + JEMISS - 1
            IGREYN = IGREYN + 2 - JEMISS
            IF ( JEMISS .EQ. 1 ) THEN
               ISTORE = IGREYN
            ELSE
               ISTORE = IGREYP
            END IF
            IF ( LNUCTS ) THEN
               NPCYCL (ISTORE,JEMISS) = -ICYCL
            ELSE
               NPCYCL (ISTORE,JEMISS) = ICYCL
            END IF
            EINTR  = EINTR  + TKI (NP) + AMNUCL (IEMISS)
            PXINTR = PXINTR + CXR (NP) * PLR (NP)
            PYINTR = PYINTR + CYR (NP) * PLR (NP)
            PZINTR = PZINTR + CZR (NP) * PLR (NP)
            IBINTR = IBINTR + IBAR ( KPART (NP) )
            ICINTR = ICINTR + ICH  ( KPART (NP) )
            ERES  = GAMCM * ERESCM - ETAPCM
            EKRES = ERES - UMO
            PHELP = - ETAPCM / ( GAMCM + 1.D+00 ) + ERESCM
            PXRES = - PCMSX + ETAX * PHELP
            PYRES = - PCMSY + ETAY * PHELP
            PZRES = - PCMSZ + ETAZ * PHELP
            PTRES2= PXRES * PXRES + PYRES * PYRES + PZRES * PZRES
            PTRES = SQRT (PTRES2)
            TVCMS = UMO - AMNRES
            IF ( TVCMS .LT. 0.D+00 ) THEN
               IF ( TVCMS .LT. - GAMMIN ) THEN
                  WRITE (LUNOUT,*)' PREPRE: TVCMS',TVCMS
                  WRITE (LUNERR,*)' PREPRE: TVCMS',TVCMS
                  WRITE (77,*)' ^^^ PREPRE: TVCMS',TVCMS
               END IF
               TVCMS = 0.D+00
            END IF
            EHLFIX = MIN ( TVCMS, EHLFIX )
            TVEFF = TVCMS - EHLFIX
            IF ( TVEFF .LE. 0.D+00 ) GO TO 7000
            GAMCM = ERES  / UMO
            ETACM = PTRES / UMO
            ETAX  = PXRES / UMO
            ETAY  = PYRES / UMO
            ETAZ  = PZRES / UMO
            ETAPCM = ETAX * PXORI + ETAY * PYORI + ETAZ * PZORI
            PHELP = EKORI + AM (KPORI) - ETAPCM / ( GAMCM + 1.D+00 )
            PCMSX = PXORI - ETAX * PHELP
            PCMSY = PYORI - ETAY * PHELP
            PCMSZ = PZORI - ETAZ * PHELP
            PCMORI = PCMSX**2 + PCMSY**2 + PCMSZ**2
            IF ( PCMORI .LE. ANGLGB ) THEN
               PCMORI = 0.D+00
               CALL RACO ( CXAXCM, CYAXCM, CZAXCM )
            ELSE
               PCMORI = SQRT ( PCMORI )
               CXAXCM = PCMSX / PCMORI
               CYAXCM = PCMSY / PCMORI
               CZAXCM = PCMSZ / PCMORI
            END IF
            IAAFT = IBRES-1
            IZAFT = ICRES
            AAFTR = IAAFT
            ZAFTR (1) = IZAFT
            AMMAFT(1) = AAFTR * AMUAMU + 1.D-03
     &                * FKENER (AAFTR,ZAFTR(1))
            AMNAFT(1) = AMMAFT (1) - ZAFTR (1) * AMELEC
     &                + ELBNDE (IZAFT)
            CALL EEXLVL ( IAAFT, IZAFT, EEXDLT (1), EEXMNM (1), EEXDUM )
            BNDGAV = BNENRG (2)
            EPSMX  (1) = UMO - AMNRES - BNDGAV - EHLFIX
            EPSDLT (1) = UMO - AMNRES - BNDGAV - EEXDLT (1)
            EPSEEX (1) = UMO - AMNRES - BNDGAV - EEXMNM (1)
            IZAFT = ICRES - 1
            ZAFTR (2) = IZAFT
            AMMAFT(2) = AAFTR * AMUAMU + 1.D-03
     &                * FKENER (AAFTR,ZAFTR(2))
            AMNAFT(2) = AMMAFT (2) - ZAFTR (2) * AMELEC
     &                + ELBNDE (IZAFT)
            CALL EEXLVL ( IAAFT, IZAFT, EEXDLT (2), EEXMNM (2), EEXDUM )
            BNDGAV = BNENRG (1)
            EPSMX  (2) = UMO - AMNRES - BNDGAV - EHLFIX
            EPSDLT (2) = UMO - AMNRES - BNDGAV - EEXDLT (2)
            EPSEEX (2) = UMO - AMNRES - BNDGAV - EEXMNM (2)
            EEXANW (1) = 0.D+00
            EPSANY (1) = EPSMX (1)
            EEXANW (2) = 0.D+00
            EPSANY (2) = EPSMX (2)
            NPART (JEMISS) = NPART (JEMISS) - 1
            IF ( JEMFIX .GT. 0 ) THEN
               NPART (1) = NPART (1) + NPRFIX (1)
               NPART (2) = NPART (2) + NPRFIX (2)
            END IF
            NEMISS = NEMISS + 1
            LEMISS = .TRUE.
            TEMNU = SQRT ( TVCMS / ANOW * ALEVEL  )
            IF ( EPSMX (1) + EPSMX (2) .LT. 2.D+00 * TEMNU )
     &         GO TO 7000
            SIGIN0 = PI * ( R0SIGK * RMASS (IBRES-1) )**2
            NEXMX = SQRT ( 2.D+00 * ANOW * TVCMS / ALEVEL )
            ANPROT =  NPART (2)
            ANNEUT =  NPART (1)
            NPTOT  = NPART (1) + NPART (2)
            ANPTOT = NPTOT
            GO TO 6000
 4500    CONTINUE
 4600    CONTINUE
         IF ( LNUCTS ) THEN
            LEMISS = .TRUE.
            GO TO 6000
         ELSE
            LEMISS = .FALSE.
            NPART (1) = NPART (1) + NPRFIX (1)
            NPART (2) = NPART (2) + NPRFIX (2)
            IF ( JEMFIX .GT. 0 ) THEN
               TVEFF = TVCMS - EHLFIX
               EPSMX (JEMFIX) = EPSMX0
               ERNCM (JEMFIX) = ERNCM0
            END IF
         END IF
 5000    CONTINUE
         ANPROT =  NPART (2)
         ANNEUT =  NPART (1)
         IF ( NPTOT .GT. 0 ) THEN
            PNPROT = ( ZNOW - ANPROT ) * ( 3.D+00 * ANNEUT + ANPROT )
     &             / ( ANPROT * ( ZNOW - ANPROT + 3.D+00 * ( ANOW
     &             - ANNEUT - ZNOW ) ) + ANNEUT * ( 3.D+00 * ( ZNOW
     &             - ANPROT ) + ANOW - ANNEUT - ZNOW ) )
         ELSE
            PNPROT = ZNOW / ANOW
         END IF
         CALL GRNDM(RNDM,1)
         IF ( RNDM (1) .LT. PNPROT ) THEN
            NPART (2) = NPART (2) + 1
            ZCOLL = ZCOLL - 1.D+00
         ELSE
            NPART (1) = NPART (1) + 1
         END IF
         NPTOT  = NPART (1) + NPART (2)
         ANPTOT = NPTOT
         NHOLE  = NHOLE + 1
         ACOLL  = ACOLL - 1.D+00
         AVEBIN = ( ( BBTAR - ZZTAR - ACOLL + ZCOLL ) * BNENRG (2)
     &          + ( ZZTAR - ZCOLL ) * BNENRG (1) ) / ( BBTAR - ACOLL )
 6000    CONTINUE
         IF ( LNUCTS ) THEN
            RHOIMP = RHOSAV
            EKFIMP = EKFSAV
         END IF
      IF ( NHOLE + NHLFIX + NPTOT .LT. NEXMX .AND.
     &     NPTOT .LE. NINT (0.5D+00 * ANOW) ) GO TO 1000
 7000 CONTINUE
*=== End of subroutine prepre =========================================*
      RETURN
      END
+SELF, IF=HPUX.
$OPTIMIZE ON
+SELF.
+DECK,  RSTSEL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:03  cernlib
* Geant

*$ CREATE RSTSEL.FOR
*COPY RSTSEL
*=== rstsel ===========================================================*
      SUBROUTINE RSTSEL ( JPROJ )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PART.
+CDE, PAREVT.
+CDE, RESNUC.
*
      REAL RNDM(1)
      SAVE ABTAR , ZZTAR , PACORE, PASKIN,
     &     PAHALO, PACHLP, XHLP  , AUSFL , ZUSFL , ONUSFL, KPROJ ,
     &     ITFRMI, ITFRM2
*
      KPROJ  = JPROJ
      ABTAR  = IBTAR
      ZZTAR  = ICHTAR
      AUSFL  = ABTAR
      ZUSFL  = ZZTAR
      ONUSFL = 0.D+00
      CALL RACO ( CXIMPC, CYIMPC, CZIMPC )
      UBIMPC = CXIMPC
      VBIMPC = CYIMPC
      WBIMPC = CZIMPC
      PACORE = FRHINC (RADIU0) / ABTAR
      PASKIN = FRHINC (RADIU1) / ABTAR - PACORE
      PAHALO = 1.D+00 - PACORE - PASKIN
      GO TO 500
      ENTRY RSTNXT
  500 CONTINUE
      LABRST = .TRUE.
      IF ( KPROJ .EQ. 2 ) THEN
         NTARGT = 1
         STOP 'pbar_rest'
      ELSE IF ( KPROJ .EQ. 9 ) THEN
         NTARGT = 1
         STOP 'nbar_rest'
      ELSE IF ( KPROJ .EQ. 14 ) THEN
         CALL GRNDM(RNDM,1)
         IF ( RNDM (1) .LT. RADPIM * ( ABTAR + RDPMHL ) / ABTAR )
     &      THEN
            NTARGT = 1
            KNUCIM = 1
            ITFRMI = 1
            IPRTYP = - ( 14 * 10 + KNUCIM )
         ELSE
            NTARGT = 2
            KNUCIM = 1
            ITFRMI = 1
            PRCOL0 = APMRST
            PRCOLP = PRCOL0 * ( ZUSFL - ONUSFL )
            PRCOLP = PRCOLP / ( PRCOLP + ( 1.D+00 - PRCOL0 ) * ( AUSFL
     &             - ZUSFL ) )
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. PRCOLP ) THEN
               KNUCI2 = 1
               ITFRM2 = 1
            ELSE
               KNUCI2 = 8
               ITFRM2 = 2
            END IF
            IPRTYP = - ( 14 * 100 + KNUCIM * 10 + KNUCI2 )
         END IF
      ELSE IF ( KPROJ .EQ. 15 ) THEN
         NTARGT = 1
         NTARGT = 2
         STOP 'K-_rest'
      ELSE
         STOP '???_rest'
      END IF
      CALL GRNDM(RNDM,1)
      RNDMAB = RNDM (1)
      IF ( RNDMAB .LT. PACORE ) THEN
         RNDMAB = RNDMAB / PACORE
         RADSAM = RADIU0
         RHOSAM = RHOCEN
         XHLP   = 0.D+00
      ELSE IF ( RNDMAB - PACORE .LT. PASKIN ) THEN
         RNDMAB = ( RNDMAB - PACORE ) / PASKIN
         RADSAM = RADIU1
         RHOSAM = RHOCOR
         XHLP   = RADIU0 / RADIU1
      ELSE
         RNDMAB = ( RNDMAB - PACORE - PASKIN ) / PAHALO
         RHOSAM = RHOSKN
         RADSAM = RADTOT
         XHLP   = RADIU1 / RADTOT
      END IF
      XHLP3  = XHLP * XHLP * XHLP
 1000 CONTINUE
         BIMPCT = RADSAM * ( RNDMAB * ( 1.D+00 - XHLP3 ) + XHLP3 )
     &          **0.3333333333333333D+00
         RHOIMP = FRHONC (BIMPCT)
         CALL GRNDM(RNDM,1)
         RNDMAB = RNDM (1)
         RHORAT = RHOIMP / RHOSAM
         IF ( RNDMAB .GE. RHORAT ) THEN
            RNDMAB = ( RNDMAB - RHORAT ) / ( 1.D+00 - RHORAT )
            GO TO 1000
         END IF
      PFRIMP = FPFRNC ( RHOIMP, ITFRMI )
      EKFIMP = FEKFNC ( PFRIMP, ITFRMI )
      RHOIMT = RHOIMP
      IF ( NTARGT .EQ. 2 ) THEN
         IF ( RHOIMP .GE. RHOCEN ) THEN
            PFRIM2 = PFRCEN (ITFRM2)
            EKFIM2 = EKFCEN (ITFRM2)
            EKFPRO = EKFCEN (IPWELL)
            PFRPRO = PFRCEN (IPWELL)
         ELSE IF ( ITFRM2 .NE. ITFRMI ) THEN
            PFRIM2 = PFRIMP * PFRCEN (ITFRM2) / PFRCEN (ITFRMI)
            EKFIM2 = SQRT ( PFRIM2 * PFRIM2 + AMNUSQ (ITFRM2) )
     &             - AMNUCL (ITFRM2)
            IF ( IPWELL .EQ. ITFRMI ) THEN
               EKFPRO = EKFIMP
               PFRPRO = PFRIMP
            ELSE
               PFRPRO = PFRIM2
               EKFPRO = EKFIM2
            END IF
         ELSE
            PFRIM2 = PFRIMP
            EKFIM2 = EKFIMP
            IF ( IPWELL .EQ. ITFRMI ) THEN
               PFRPRO = PFRIMP
               EKFPRO = EKFIMP
            ELSE
               PFRPRO = PFRIMP * PFRCEN (IPWELL) / PFRCEN (ITFRMI)
               EKFPRO = SQRT ( PFRPRO * PFRPRO + AMNUSQ (IPWELL) )
     &                - AMNUCL (IPWELL)
            END IF
         END IF
      ELSE
         IF ( RHOIMP .GE. RHOCEN ) THEN
            PFRPRO = PFRCEN (IPWELL)
            EKFPRO = EKFCEN (IPWELL)
         ELSE IF ( IPWELL .EQ. ITFRMI ) THEN
            PFRPRO = PFRIMP
            EKFPRO = EKFIMP
         ELSE
            PFRPRO = PFRIMP * PFRCEN (IPWELL) / PFRCEN (ITFRMI)
            EKFPRO = SQRT ( PFRPRO * PFRPRO + AMNUSQ (IPWELL) )
     &             - AMNUCL (IPWELL)
         END IF
      END IF
      VPRWLL = WLLRED * ( EKFPRO + BNDNUC )
      BIMPTR = BIMPCT
      BIMMEM = BIMPTR
      RIMPCT = BIMPCT
      RIMPTR = BIMPTR
      XBIMPC = UBIMPC * BIMPCT
      YBIMPC = VBIMPC * BIMPCT
      ZBIMPC = WBIMPC * BIMPCT
      XIMPCT = XBIMPC
      YIMPCT = YBIMPC
      ZIMPCT = ZBIMPC
      XIMPTR = XIMPCT
      YIMPTR = YIMPCT
      ZIMPTR = ZIMPCT
      EKEWLL = EKECON + VPRWLL
      PPRWLL = SQRT ( EKEWLL * ( EKEWLL + 2.D+00 * AM (KPROJ) ) )
      PXPROJ = PPRWLL * CXIMPC
      PYPROJ = PPRWLL * CYIMPC
      PZPROJ = PPRWLL * CZIMPC
      PNFRMI = PFNCLV ( ITFRMI, .TRUE. )
      IF ( PNFRMI .LT. -100.D+00 ) GO TO 500
      CALL RACO ( PXFERM, PYFERM, PZFERM )
      PXFERM = PXFERM * PNFRMI
      PYFERM = PYFERM * PNFRMI
      PZFERM = PZFERM * PNFRMI
      EKFIMP = MAX ( EKFERM, EKFIMP )
      IF ( NTARGT .EQ. 2 ) THEN
         PNFRM2 = PFNCLV ( ITFRM2, .FALSE. )
         IF ( PNFRM2 .LT. -100.D+00 ) GO TO 500
         CALL RACO ( PXFER2, PYFER2, PZFER2 )
         PXFER2 = PXFER2 * PNFRM2
         PYFER2 = PYFER2 * PNFRM2
         PZFER2 = PZFER2 * PNFRM2
         EKFIM2 = MAX ( EKFER2, EKFIM2 )
         ERES   = EKEWLL + AM (KPROJ) + AM (KNUCIM) + EKFERM
     &          + AM (KNUCI2) + EKFER2
         PXRES  = PXPROJ + PXFERM + PXFER2
         PYRES  = PYPROJ + PYFERM + PYFER2
         PZRES  = PZPROJ + PZFERM + PZFER2
         PTRES2 = PXRES**2 + PYRES**2 + PZRES**2
      ELSE
         ERES   = EKEWLL + AM (KPROJ) + AM (KNUCIM) + EKFERM
         PXRES  = PXPROJ + PXFERM
         PYRES  = PYPROJ + PYFERM
         PZRES  = PZPROJ + PZFERM
         PTRES2 = PXRES**2 + PYRES**2 + PZRES**2
      END IF
      RETURN
*=== End of subroutine rstsel =========================================*
      END
+DECK,  SBCOMP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:03  cernlib
* Geant

*$ CREATE SBCOMP.FOR
*COPY SBCOMP
*=== sbcomp ===========================================================*
      SUBROUTINE SBCOMP ( SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1,
     &                    SBHAL1 )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, NUCGEO.
*
      SAVE  R0HLA , R0HLB , R0SKA , R0SKB , R0CEA , R0CEB ,
     &      R1CEA , R1CEB , R1SKA , R1SKB , R1HLA , R1HLB ,
     &      SQRH0A, SQRH0B, SQRS0A, SQRS0B, SQRC0A, SQRC0B,
     &      SQRC1A, SQRC1B, SQRS1A, SQRS1B, SQRH1A, SQRH1B,
     &      BIMPSQ
+CDE, NUCSTF.
*
      IF ( ABS (R0TRAJ) .LT. BIMPCT .OR. ABS (R1TRAJ) .LT. BIMPCT )
     &   STOP 'BIMPCT'
      BIMPSQ = BIMPCT * BIMPCT
      IF ( R0TRAJ .GE. 0.D+00 ) THEN
         SBHAL0 = 0.D+00
         SBSKI0 = 0.D+00
         SBCEN0 = 0.D+00
      ELSE
         IF ( BIMPCT .GE. RADIU1 ) THEN
            SBSKI0 = 0.D+00
            SBCEN0 = 0.D+00
            SBCEN1 = 0.D+00
            SBSKI1 = 0.D+00
            R0HLA = ABS (R0TRAJ)
            R0HLB = MAX ( BIMPCT, - R1TRAJ )
            SQRH0A = SQRT ( ( R0HLA - BIMPCT ) * ( R0HLA + BIMPCT ) )
            SQRH0B = SQRT ( ( R0HLB - BIMPCT ) * ( R0HLB + BIMPCT ) )
            SBHAL0 = RHOSKN * ( ( 1.D+00 + RADIU1 / HALODP ) * ( SQRH0A
     &             - SQRH0B ) - 0.5D+00 * ( R0HLA / HALODP * SQRH0A
     &             - R0HLB / HALODP * SQRH0B + BIMPSQ / HALODP
     &             * LOG ( ( R0HLA + SQRH0A ) / ( R0HLB + SQRH0B ) ) ) )
         ELSE IF ( R0TRAJ .GE. -RADIU0 ) THEN
            SBHAL0 = 0.D+00
            SBSKI0 = 0.D+00
            R0CEA = - R0TRAJ
            R0CEB = MAX ( BIMPCT, - R1TRAJ )
            SQRC0A = SQRT ( ( R0CEA - BIMPCT ) * ( R0CEA + BIMPCT ) )
            SQRC0B = SQRT ( ( R0CEB - BIMPCT ) * ( R0CEB + BIMPCT ) )
            SBCEN0 = RHOCEN * ( SQRC0A - SQRC0B )
         ELSE IF ( R0TRAJ .GE. -RADIU1 ) THEN
            SBHAL0 = 0.D+00
            RHELP = MAX ( BIMPCT, - R1TRAJ )
            R0SKA = ABS (R0TRAJ)
            R0SKB = MAX ( RHELP, RADIU0 )
            SQRS0A = SQRT ( ( R0SKA - BIMPCT ) * ( R0SKA + BIMPCT ) )
            SQRS0B = SQRT ( ( R0SKB - BIMPCT ) * ( R0SKB + BIMPCT ) )
            SBSKI0 = RHOCEN * ( ( 1.D+00 + RADIU0 / SKNEFF ) * ( SQRS0A
     &             - SQRS0B ) - 0.5D+00 * ( R0SKA / SKNEFF * SQRS0A
     &             - R0SKB / SKNEFF * SQRS0B + BIMPSQ / SKNEFF
     &             * LOG ( ( R0SKA + SQRS0A ) / ( R0SKB + SQRS0B ) ) ) )
            IF ( RHELP .LT. RADIU0 ) THEN
               R0CEA = RADIU0
               R0CEB = RHELP
               SQRC0A = SQRT ( ( R0CEA - BIMPCT ) * ( R0CEA + BIMPCT ) )
               SQRC0B = SQRT ( ( R0CEB - BIMPCT ) * ( R0CEB + BIMPCT ) )
               SBCEN0 = RHOCEN * ( SQRC0A - SQRC0B )
            ELSE
               SBCEN0 = 0.D+00
            END IF
         ELSE
            RHELP = MAX ( BIMPCT, - R1TRAJ )
            R0HLA = ABS (R0TRAJ)
            R0HLB = MAX ( RHELP, RADIU1 )
            SQRH0A = SQRT ( ( R0HLA - BIMPCT ) * ( R0HLA + BIMPCT ) )
            SQRH0B = SQRT ( ( R0HLB - BIMPCT ) * ( R0HLB + BIMPCT ) )
            SBHAL0 = RHOSKN * ( ( 1.D+00 + RADIU1 / HALODP ) * ( SQRH0A
     &             - SQRH0B ) - 0.5D+00 * ( R0HLA / HALODP * SQRH0A
     &             - R0HLB / HALODP * SQRH0B + BIMPSQ / HALODP
     &             * LOG ( ( R0HLA + SQRH0A ) / ( R0HLB + SQRH0B ) ) ) )
            IF ( RHELP .LT. RADIU1 ) THEN
               R0SKA = RADIU1
               R0SKB = MAX ( RHELP, RADIU0 )
               SQRS0A = SQRT ( ( R0SKA - BIMPCT ) * ( R0SKA + BIMPCT ) )
               SQRS0B = SQRT ( ( R0SKB - BIMPCT ) * ( R0SKB + BIMPCT ) )
               SBSKI0 = RHOCEN * ( ( 1.D+00 + RADIU0 / SKNEFF )
     &                * ( SQRS0A - SQRS0B ) - 0.5D+00 * ( R0SKA / SKNEFF
     &                * SQRS0A - R0SKB / SKNEFF * SQRS0B + BIMPSQ
     &                / SKNEFF * LOG ( ( R0SKA + SQRS0A ) / ( R0SKB
     &                + SQRS0B ) ) ) )
               IF ( RHELP .LT. RADIU0 ) THEN
                  R0CEA = RADIU0
                  R0CEB = MAX ( BIMPCT, - R1TRAJ )
                  SQRC0A = SQRS0B
                  SQRC0B = SQRT ( ( R0CEB - BIMPCT )*( R0CEB + BIMPCT ))
                  SBCEN0 = RHOCEN * ( SQRC0A - SQRC0B )
               ELSE
                  SBCEN0 = 0.D+00
               END IF
            ELSE
               SBSKI0 = 0.D+00
               SBCEN0 = 0.D+00
            END IF
         END IF
      END IF
      IF ( R1TRAJ .EQ. - R0TRAJ ) THEN
         R1HLA  = R0HLB
         R1HLB  = R0HLA
         SQRH1A = SQRH0B
         SQRH1B = SQRH0A
         R1SKA  = R0SKB
         R1SKB  = R0SKA
         SQRS1A = SQRS0B
         SQRS1B = SQRS0A
         R1CEA  = R0CEB
         R1CEB  = R0CEA
         SQRC1A = SQRC0B
         SQRC1B = SQRC0A
         SBCEN1 = SBCEN0
         SBSKI1 = SBSKI0
         SBHAL1 = SBHAL0
      ELSE IF ( R1TRAJ .LE. 0.D+00 ) THEN
         SBCEN1 = 0.D+00
         SBSKI1 = 0.D+00
         SBHAL1 = 0.D+00
      ELSE
         IF ( BIMPCT .GE. RADIU1 ) THEN
            SBSKI1 = 0.D+00
            SBCEN1 = 0.D+00
            R1HLB = R1TRAJ
            R1HLA = MAX ( BIMPCT, R0TRAJ )
            SQRH1A = SQRT ( ( R1HLA - BIMPCT ) * ( R1HLA + BIMPCT ) )
            SQRH1B = SQRT ( ( R1HLB - BIMPCT ) * ( R1HLB + BIMPCT ) )
            SBHAL1 = RHOSKN * ( ( 1.D+00 + RADIU1 / HALODP ) * ( SQRH1B
     &             - SQRH1A ) - 0.5D+00 * ( R1HLB / HALODP * SQRH1B
     &             - R1HLA / HALODP * SQRH1A + BIMPSQ / HALODP
     &             * LOG ( ( R1HLB + SQRH1B ) / ( R1HLA + SQRH1A ) ) ) )
         ELSE IF ( R1TRAJ .LE. RADIU0 ) THEN
            SBHAL1 = 0.D+00
            SBSKI1 = 0.D+00
            R1CEB = R1TRAJ
            R1CEA = MAX ( BIMPCT, R0TRAJ )
            SQRC1A = SQRT ( ( R1CEA - BIMPCT ) * ( R1CEA + BIMPCT ) )
            SQRC1B = SQRT ( ( R1CEB - BIMPCT ) * ( R1CEB + BIMPCT ) )
            SBCEN1 = RHOCEN * ( SQRC1B - SQRC1A )
         ELSE IF ( R1TRAJ .LE. RADIU1 ) THEN
            SBHAL1 = 0.D+00
            RHELP = MAX ( BIMPCT, R0TRAJ )
            R1SKB = R1TRAJ
            R1SKA = MAX ( RHELP, RADIU0 )
            SQRS1A = SQRT ( ( R1SKA - BIMPCT ) * ( R1SKA + BIMPCT ) )
            SQRS1B = SQRT ( ( R1SKB - BIMPCT ) * ( R1SKB + BIMPCT ) )
            SBSKI1 = RHOCEN * ( ( 1.D+00 + RADIU0 / SKNEFF ) * ( SQRS1B
     &             - SQRS1A ) - 0.5D+00 * ( R1SKB / SKNEFF * SQRS1B
     &             - R1SKA / SKNEFF * SQRS1A + BIMPSQ / SKNEFF
     &             * LOG ( ( R1SKB + SQRS1B ) / ( R1SKA + SQRS1A ) ) ) )
            IF ( RHELP .LT. RADIU0 ) THEN
               R1CEB = RADIU0
               R1CEA = RHELP
               SQRC1A = SQRT ( ( R1CEA - BIMPCT ) * ( R1CEA + BIMPCT ) )
               SQRC1B = SQRT ( ( R1CEB - BIMPCT ) * ( R1CEB + BIMPCT ) )
               SBCEN1 = RHOCEN * ( SQRC1B - SQRC1A )
            ELSE
               SBCEN1 = 0.D+00
            END IF
         ELSE
            RHELP = MAX ( BIMPCT, R0TRAJ )
            R1HLB = R1TRAJ
            R1HLA = MAX ( RHELP, RADIU1 )
            SQRH1A = SQRT ( ( R1HLA - BIMPCT ) * ( R1HLA + BIMPCT ) )
            SQRH1B = SQRT ( ( R1HLB - BIMPCT ) * ( R1HLB + BIMPCT ) )
            SBHAL1 = RHOSKN * ( ( 1.D+00 + RADIU1 / HALODP ) * ( SQRH1B
     &             - SQRH1A ) - 0.5D+00 * ( R1HLB / HALODP * SQRH1B
     &             - R1HLA / HALODP * SQRH1A + BIMPSQ / HALODP
     &             * LOG ( ( R1HLB + SQRH1B ) / ( R1HLA + SQRH1A ) ) ) )
            IF ( RHELP .LT. RADIU1 ) THEN
               R1SKB = RADIU1
               R1SKA = MAX ( RHELP, RADIU0 )
               SQRS1A = SQRT ( ( R1SKA - BIMPCT ) * ( R1SKA + BIMPCT ) )
               SQRS1B = SQRT ( ( R1SKB - BIMPCT ) * ( R1SKB + BIMPCT ) )
               SBSKI1 = RHOCEN * ( ( 1.D+00 + RADIU0 / SKNEFF )
     &                * ( SQRS1B - SQRS1A ) - 0.5D+00 * ( R1SKB / SKNEFF
     &                * SQRS1B - R1SKA / SKNEFF * SQRS1A + BIMPSQ
     &                / SKNEFF * LOG ( ( R1SKB + SQRS1B ) / ( R1SKA
     &                + SQRS1A ) ) ) )
               IF ( RHELP .LT. RADIU0 ) THEN
                  R1CEB = RADIU0
                  R1CEA = RHELP
                  SQRC1B = SQRS1A
                  SQRC1A = SQRT ( ( R1CEA - BIMPCT )*( R1CEA + BIMPCT ))
                  SBCEN1 = RHOCEN * ( SQRC1B - SQRC1A )
               ELSE
                  SBCEN1 = 0.D+00
               END IF
            ELSE
               SBCEN1 = 0.D+00
               SBSKI1 = 0.D+00
            END IF
         END IF
      END IF
      RETURN
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
      ENTRY RSCOMP ( SBHAL0, SBSKI0, SBCEN0, SBCEN1, SBSKI1, SBHAL1 )
      SBTTOT = SBHAL0 + SBSKI0 + SBCEN0 + SBCEN1 + SBSKI1 + SBHAL1
      IF ( SBUSED .GT. SBTTOT ) STOP 'RSCOMP'
      IF ( SBUSED .LT. SBHAL0 ) THEN
         SBUSEF = SBUSED
         RDLESS = R0HLA
         RDMORE = R0HLB
         SBLESS = 0.D+00
         SBMORE = SBHAL0
         DO 1000 IBIS = 1,4
            RIMPCT = 0.5D+00 * ( RDMORE + RDLESS )
            SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
            SBRIMP = RHOSKN * ( ( 1.D+00 + RADIU1 / HALODP ) * ( SQRH0A
     &             - SQRIMP ) - 0.5D+00 * ( R0HLA / HALODP * SQRH0A
     &             - RIMPCT / HALODP * SQRIMP + BIMPSQ / HALODP
     &             * LOG ( ( R0HLA + SQRH0A ) / ( RIMPCT + SQRIMP ) ) ))
            IF ( SBRIMP .GE. SBUSEF ) THEN
               SBMORE = SBRIMP
               RDMORE = RIMPCT
            ELSE
               SBLESS = SBRIMP
               RDLESS = RIMPCT
            END IF
 1000    CONTINUE
         RIMPCT = RDLESS + ( SBUSEF - SBLESS ) / ( SBMORE - SBLESS )
     &          * ( RDMORE - RDLESS )
         RIMPCT = - RIMPCT
         SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
      ELSE IF ( SBUSED .LT. SBHAL0 + SBSKI0 ) THEN
         SBUSEF = SBUSED - SBHAL0
         RDLESS = R0SKA
         RDMORE = R0SKB
         SBLESS = 0.D+00
         SBMORE = SBSKI0
         DO 2000 IBIS = 1,4
            RIMPCT = 0.5D+00 * ( RDMORE + RDLESS )
            SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
            SBRIMP = RHOCEN * ( ( 1.D+00 + RADIU0 / SKNEFF ) * ( SQRS0A
     &             - SQRIMP ) - 0.5D+00 * ( R0SKA / SKNEFF * SQRS0A
     &             - RIMPCT / SKNEFF * SQRIMP + BIMPSQ / SKNEFF
     &             * LOG ( ( R0SKA + SQRS0A ) / ( RIMPCT + SQRIMP ) ) ))
            IF ( SBRIMP .GE. SBUSEF ) THEN
               SBMORE = SBRIMP
               RDMORE = RIMPCT
            ELSE
               SBLESS = SBRIMP
               RDLESS = RIMPCT
            END IF
 2000    CONTINUE
         RIMPCT = RDLESS + ( SBUSEF - SBLESS ) / ( SBMORE - SBLESS )
     &          * ( RDMORE - RDLESS )
         RIMPCT = - RIMPCT
         SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
      ELSE IF ( SBUSED .LT. SBHAL0 + SBSKI0 + SBCEN0 ) THEN
         SBUSEF = SBUSED - SBHAL0 - SBSKI0
         SQRIMP = SQRC0A - SBUSEF / RHOCEN
         RIMPCT = SQRT ( SQRIMP**2 + BIMPSQ )
         RIMPCT = - RIMPCT
      ELSE IF ( SBUSED .LT. SBTTOT - SBSKI1 - SBHAL1 ) THEN
         SBUSEF = SBUSED - SBHAL0 - SBSKI0 - SBCEN0
         SQRIMP = SBUSEF / RHOCEN + SQRC1A
         RIMPCT = SQRT ( SQRIMP**2 + BIMPSQ )
      ELSE IF ( SBUSED .LT. SBTTOT - SBHAL1 ) THEN
         SBUSEF = SBUSED - SBHAL0 - SBSKI0 - SBCEN0 - SBCEN1
         RDLESS = R1SKA
         RDMORE = R1SKB
         SBLESS = 0.D+00
         SBMORE = SBSKI1
         DO 3000 IBIS = 1,4
            RIMPCT = 0.5D+00 * ( RDMORE + RDLESS )
            SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
            SBRIMP = RHOCEN * ( ( 1.D+00 + RADIU0 / SKNEFF ) * ( SQRIMP
     &             - SQRS1A ) - 0.5D+00 * ( RIMPCT / SKNEFF * SQRIMP
     &             - R1SKA / SKNEFF * SQRS1A + BIMPSQ / SKNEFF
     &             * LOG ( ( RIMPCT + SQRIMP ) / ( R1SKA + SQRS1A ) ) ))
            IF ( SBRIMP .GE. SBUSEF ) THEN
               SBMORE = SBRIMP
               RDMORE = RIMPCT
            ELSE
               SBLESS = SBRIMP
               RDLESS = RIMPCT
            END IF
 3000    CONTINUE
         RIMPCT = RDLESS + ( SBUSEF - SBLESS ) / ( SBMORE - SBLESS )
     &          * ( RDMORE - RDLESS )
         SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
      ELSE
         SBUSEF = SBUSED - SBHAL0 - SBSKI0 - SBCEN0 - SBCEN1 - SBSKI1
         RDLESS = R1HLA
         RDMORE = R1HLB
         SBLESS = 0.D+00
         SBMORE = SBHAL1
         DO 4000 IBIS = 1,4
            RIMPCT = 0.5D+00 * ( RDMORE + RDLESS )
            SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
            SBRIMP = RHOSKN * ( ( 1.D+00 + RADIU1 / HALODP ) * ( SQRIMP
     &             - SQRH1A ) - 0.5D+00 * ( RIMPCT / HALODP * SQRIMP
     &             - R1HLA / HALODP * SQRH1A + BIMPSQ / HALODP
     &             * LOG ( ( RIMPCT + SQRIMP ) / ( R1HLA + SQRH1A ) ) ))
            IF ( SBRIMP .GE. SBUSEF ) THEN
               SBMORE = SBRIMP
               RDMORE = RIMPCT
            ELSE
               SBLESS = SBRIMP
               RDLESS = RIMPCT
            END IF
 4000    CONTINUE
         RIMPCT = RDLESS + ( SBUSEF - SBLESS ) / ( SBMORE - SBLESS )
     &          * ( RDMORE - RDLESS )
         SQRIMP = SQRT ( ( RIMPCT - BIMPCT ) * ( RIMPCT + BIMPCT ) )
      END IF
      IF ( RIMPCT .GT. 0.D+00 ) THEN
         XIMPCT = XBIMPC + CXIMPC * SQRIMP
         YIMPCT = YBIMPC + CYIMPC * SQRIMP
         ZIMPCT = ZBIMPC + CZIMPC * SQRIMP
      ELSE
         XIMPCT = XBIMPC - CXIMPC * SQRIMP
         YIMPCT = YBIMPC - CYIMPC * SQRIMP
         ZIMPCT = ZBIMPC - CZIMPC * SQRIMP
      END IF
      IF ( BIMPCT .GT. ANGLGB ) THEN
         TRUFAC = BIMPTR / BIMPCT
         XIMPTR = XIMPCT * TRUFAC
         YIMPTR = YIMPCT * TRUFAC
         ZIMPTR = ZIMPCT * TRUFAC
         RIMPTR = RIMPCT * TRUFAC
      ELSE
         XIMPTR = XIMPCT
         YIMPTR = YIMPCT
         ZIMPTR = ZIMPCT
         RIMPTR = RIMPCT
      END IF
      RETURN
*=== End of subroutine Sbcomp =========================================*
      END
+DECK,  SIGFER, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:04  cernlib
* Geant

*$ CREATE SIGFER.FOR
*COPY SIGFER
*=== sigfer ===========================================================*
      SUBROUTINE SIGFER ( KP, EKIN, POO, LFERMI )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAPROP.
      LOGICAL LFERMI
*
      IF ( LFERMI ) THEN
         EKEWLL = EKIN   + VPRBIM
         EEMAX  = EKEWLL + EKFBIM + AMNUCL (ITNCMX) + AM (KP)
         PPRWLL = SQRT ( EKEWLL * ( EKEWLL + 2.D+00 * AM (KP) ) )
         IF ( PFRBIM .LT. PPRWLL ) THEN
            PPMAX  = PPRWLL + PFRBIM
            PPMIN  = PPRWLL - PFRBIM
            UMO2   = ( EEMAX + PPMAX ) * ( EEMAX - PPMAX )
            EKEMIN = 0.5D+00 * ( UMO2 - AM (KP)**2 - AMNUSQ (ITNCMX) )
     &             / AMNUCL (ITNCMX) - AM (KP)
            EKEMIN = MIN ( EKIN, EKEMIN )
            TMPEKI = 0.1666D+00 * EKIN
            EKEMIN = MAX ( EKEMIN, TMPEKI )
         ELSE
            EKEMIN = MAX ( 0.005D+00, 0.1666D+00 * EKIN )
            PPMIN  = 0.D+00
         END IF
         PPRMIN = SQRT ( EKEMIN * ( EKEMIN + 2.D+00 * AM (KP) ) )
         UMO2   = ( EEMAX + PPMIN ) * ( EEMAX - PPMIN  )
         EKEMAX =  0.5D+00 * ( UMO2 - AM (KP)**2 - AMNUSQ (ITNCMX) )
     &          / AMNUCL (ITNCMX) - AM (KP)
         PPRMAX = SQRT ( EKEMAX * ( EKEMAX + 2.D+00 * AM (KP) ) )
      ELSE
         EKEMIN = EKIN
         PPRMIN = POO
         EKEMAX = EKIN
         PPRMAX = POO
      END IF
*
  50  CONTINUE
      GO TO (  100,  200,  300,  400,  500,  600,  700,  800,  900,
     &        1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800,
     &        1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700,
     &        2800, 2900, 3000, 3100, 3200, 3300, 3400, 3500, 3600,
     &        3700, 3800, 3900 ), KP
      STOP 'GEO-KP'
  100 CONTINUE
         IF ( EKEMIN .LE. 0.700D+00 ) THEN
            BETAPR = PPRMIN / ( EKEMIN + AM (KP) )
            IF ( EKEMIN .LE. 0.04D+00 ) THEN
               SIGMAN = 3.D+03 * PI / ( 1.206D+03 * EKEMIN + ( -1.86D+00
     &                + 0.09415D+03 * EKEMIN + 0.0001306D+06 * EKEMIN**2
     &                )**2 ) + 1.D+03 * PI / ( 1.206D+03 * EKEMIN
     &                + ( 0.4223D+00 + 0.13D+03 * EKEMIN )**2 )
               IF ( EKEMIN .LT. 0.02D+00 ) THEN
                  SIGMAP = 0.3333333333333333D+00 * SIGMAN
               ELSE
                  SIGMAP = 10.63D+00 / BETAPR**2 - 29.92D+00 / BETAPR
     &                   + 42.9D+00
               END IF
            ELSE
               SIGMAN = 34.10D+00 / BETAPR**2 - 82.2D+00 / BETAPR
     &                + 82.2D+00
               SIGMAP = 10.63D+00 / BETAPR**2 - 29.92D+00 / BETAPR
     &                + 42.9D+00
            END IF
         ELSE
            STOP 'Sigfer: EKE'
         END IF
      GO TO 4000
  200 CONTINUE
      GO TO 4000
  300 CONTINUE
      GO TO 4000
  400 CONTINUE
      GO TO 4000
  500 CONTINUE
      GO TO 4000
  600 CONTINUE
      GO TO 4000
  700 CONTINUE
         SIGMAN = 0.D+00
         SIGMAP = 0.D+00
      GO TO 4000
  800 CONTINUE
         IF ( EKEMIN .LE. 0.700D+00 ) THEN
            BETAPR = PPRMIN / ( EKEMIN + AM (KP) )
            IF ( EKEMIN .LE. 0.04D+00 ) THEN
               SIGMAP = 3.D+03 * PI / ( 1.206D+03 * EKEMIN + ( -1.86D+00
     &                + 0.09415D+03 * EKEMIN + 0.0001306D+06 * EKEMIN**2
     &                )**2 ) + 1.D+03 * PI / ( 1.206D+03 * EKEMIN
     &                + ( 0.4223D+00 + 0.13D+03 * EKEMIN )**2 )
               IF ( EKEMIN .LT. 0.02D+00 ) THEN
                  SIGMAN = 0.3333333333333333D+00 * SIGMAP
               ELSE
                  SIGMAN = 10.63D+00 / BETAPR**2 - 29.92D+00 / BETAPR
     &                   + 42.9D+00
               END IF
            ELSE
               SIGMAP = 34.10D+00 / BETAPR**2 - 82.2D+00 / BETAPR
     &                + 82.2D+00
               SIGMAN = 10.63D+00 / BETAPR**2 - 29.92D+00 / BETAPR
     &                + 42.9D+00
            END IF
         ELSE
            STOP 'Sigfer: EKE'
         END IF
      GO TO 4000
  900 CONTINUE
      GO TO 4000
 1000 CONTINUE
      GO TO 4000
 1100 CONTINUE
      GO TO 4000
 1200 CONTINUE
      GO TO 4000
 1300 CONTINUE
      GO TO 4000
 1400 CONTINUE
      GO TO 4000
 1500 CONTINUE
      GO TO 4000
 1600 CONTINUE
      GO TO 4000
 1700 CONTINUE
      GO TO 4000
 1800 CONTINUE
      GO TO 4000
 1900 CONTINUE
      GO TO 4000
 2000 CONTINUE
      GO TO 4000
 2100 CONTINUE
      GO TO 4000
 2200 CONTINUE
      GO TO 4000
 2300 CONTINUE
      GO TO 4000
 2400 CONTINUE
      GO TO 4000
 2500 CONTINUE
      GO TO 4000
 2600 CONTINUE
      GO TO 4000
 2700 CONTINUE
      GO TO 4000
 2800 CONTINUE
      GO TO 4000
 2900 CONTINUE
      GO TO 4000
 3000 CONTINUE
      GO TO 4000
 3100 CONTINUE
      GO TO 4000
 3200 CONTINUE
      GO TO 4000
 3300 CONTINUE
      GO TO 4000
 3400 CONTINUE
      GO TO 4000
 3500 CONTINUE
      GO TO 4000
 3600 CONTINUE
      GO TO 4000
 3700 CONTINUE
      GO TO 4000
 3800 CONTINUE
      GO TO 4000
 3900 CONTINUE
      GO TO 4000
 4000 CONTINUE
      SIGMAP = 0.1D+00 * SIGMAP
      SIGMAN = 0.1D+00 * SIGMAN
      RETURN
*=== End of subroutine sigfer =========================================*
      END
+DECK,  UMOFIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:04  cernlib
* Geant

*$ CREATE UMOFIN.FOR
*COPY UMOFIN
*=== umofin ===========================================================*
      SUBROUTINE UMOFIN ( IKPMX, BBRES, ZZRES, LTRPPD )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAREVT.
+CDE, PARNUC.
+CDE, PART.
+CDE, RESNUC.
*
      LOGICAL LTRPPD
*
      PXRES = PXTTOT - PXNUCR - PXINTR - PXNUCL (IKPMX)
      PYRES = PYTTOT - PYNUCR - PYINTR - PYNUCL (IKPMX)
      PZRES = PZTTOT - PZNUCR - PZINTR - PZNUCL (IKPMX)
      ERES  = ETTOT  - EINTR  - ENUCR  - ENNUC  (IKPMX)
      PTRES2 = PXRES**2 + PYRES**2 + PZRES**2
      UMO2   = ERES**2 - PTRES2
      DELTU2 = ( AMNRES + EEXMIN )**2 - UMO2
      IF ( DELTU2 .LT. 0.D+00 ) RETURN
*
      PNUCC0 = PNUCCO
      ENNUC0 = ENNUC (IKPMX)
*
      PXRES = PXTTOT - PXNUCR - PXINTR
      PYRES = PYTTOT - PYNUCR - PYINTR
      PZRES = PZTTOT - PZNUCR - PZINTR
      ERES  = ETTOT  - EINTR  - ENUCR
      PTRES2 = PXRES**2 + PYRES**2 + PZRES**2
      UMO2   = ERES**2  - PTRES2
      AMSQ   = AM (KPRIN)**2
      ENEMIN = 0.5D+00 * ( UMO2 - ( AMNRES + EEXMIN )**2 - AMSQ )
     &       / ( AMNRES + EEXMIN )
      ENEDLT = 0.5D+00 * ( UMO2 - ( AMNRES + EEXDEL )**2 - AMSQ )
     &       / ( AMNRES + EEXDEL )
      ENEANY = 0.5D+00 * ( UMO2 - ( AMNRES + EEXANY )**2 - AMSQ )
     &       / ( AMNRES + EEXANY )
      IF ( ENEANY .LE. AM (KPRIN) ) THEN
         IBRES = IBRES + IBAR (KPRIN)
         ICRES = ICRES + ICH  (KPRIN)
         BBRES = IBRES
         ZZRES = ICRES
         AMMRES = BBRES * AMUAMU + 0.001D+00
     &          * FKENER ( BBRES, ZZRES )
         AMNRES = AMMRES - ZZRES * AMELEC + ELBNDE ( ICRES )
         LTRPPD = .TRUE.
         EEXMIN = 0.D+00
         RETURN
      END IF
      IF ( ENNUC (IKPMX) .GT. 0.5D+00 * ( ENEANY + ENEDLT ) ) THEN
         ENNUC (IKPMX) = ENEANY
         PNUCL (IKPMX) = SQRT ( ( ENNUC (IKPMX) - AM (KPRIN) )
     &                 * ( ENNUC (IKPMX) + AM (KPRIN) ) )
         PHELP = PNUCL (IKPMX) / PNUCC0
         PXNUCL (IKPMX) = PXNUCL (IKPMX) * PHELP
         PYNUCL (IKPMX) = PYNUCL (IKPMX) * PHELP
         PZNUCL (IKPMX) = PZNUCL (IKPMX) * PHELP
      ELSE IF ( ENNUC (IKPMX) .GT. 0.5D+00 * ( ENEDLT + ENEMIN ) ) THEN
         ENNUC (IKPMX) = ENEDLT
         PNUCL (IKPMX) = SQRT ( ( ENNUC (IKPMX) - AM (KPRIN) )
     &                 * ( ENNUC (IKPMX) + AM (KPRIN) ) )
         PHELP = PNUCL (IKPMX) / PNUCC0
         PXNUCL (IKPMX) = PXNUCL (IKPMX) * PHELP
         PYNUCL (IKPMX) = PYNUCL (IKPMX) * PHELP
         PZNUCL (IKPMX) = PZNUCL (IKPMX) * PHELP
      ELSE IF ( ENNUC (IKPMX) .GE. ENEMIN ) THEN
         ENNUC (IKPMX) = ENEMIN
         PNUCL (IKPMX) = SQRT ( ( ENNUC (IKPMX) - AM (KPRIN) )
     &                 * ( ENNUC (IKPMX) + AM (KPRIN) ) )
         PHELP = PNUCL (IKPMX) / PNUCC0
         PXNUCL (IKPMX) = PXNUCL (IKPMX) * PHELP
         PYNUCL (IKPMX) = PYNUCL (IKPMX) * PHELP
         PZNUCL (IKPMX) = PZNUCL (IKPMX) * PHELP
      ELSE
      END IF
      UMO = SQRT (UMO2)
      AMNHLP = SQRT ( UMO2 + PNUCL (IKPMX)**2 ) - ENNUC (IKPMX)
      GAMLAB = ERES  / UMO
      ETXLAB = PXRES / UMO
      ETYLAB = PYRES / UMO
      ETZLAB = PZRES / UMO
      GAMRES = ( AMNHLP + ENNUC (IKPMX) ) / UMO
      ETXRES = PXNUCL (IKPMX) / UMO
      ETYRES = PYNUCL (IKPMX) / UMO
      ETZRES = PZNUCL (IKPMX) / UMO
      ETAPCM = ETXRES * PXNUCL (IKPMX) + ETYRES * PYNUCL (IKPMX)
     &       + ETZRES * PZNUCL (IKPMX)
      ECMSPR = GAMRES * ENNUC (IKPMX) - ETAPCM
      PHELP  = ENNUC (IKPMX) - ETAPCM / ( GAMRES + 1.D+00 )
      PCMSX  = PXNUCL (IKPMX) - ETXRES * PHELP
      PCMSY  = PYNUCL (IKPMX) - ETYRES * PHELP
      PCMSZ  = PZNUCL (IKPMX) - ETZRES * PHELP
      ETAPCM = ETXLAB * PCMSX + ETYLAB * PCMSY + ETZLAB * PCMSZ
      ENNUC  (IKPMX) = GAMLAB * ECMSPR + ETAPCM
      PHELP  = ECMSPR + ETAPCM / ( GAMLAB + 1.D+00 )
      PXNUCL (IKPMX) = PCMSX + ETXLAB * PHELP
      PYNUCL (IKPMX) = PCMSY + ETYLAB * PHELP
      PZNUCL (IKPMX) = PCMSZ + ETZLAB * PHELP
      PNUCL  (IKPMX) = SQRT ( ( ENNUC (IKPMX) - AM (KPRIN) )
     &               * ( ENNUC (IKPMX) + AM (KPRIN) ) )

      RETURN
*=== End of subroutine UMOFIN =========================================*
      END
+DECK,  XINNEU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:04  cernlib
* Geant

*$ CREATE XINNEU.FOR
*COPY XINNEU
*=== xinneu ===========================================================*
      FUNCTION XINNEU ( E, ZTAR, BBETAA )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, ISOTOP.
+CDE, XSEPAR.
*
      IZ = NINT ( ZTAR )
      EEE = 0.015D+00 * ( 1.D+00 + 1.D-04 * ZTAR * ZTAR )
      TMPZZN = 2.D-01 * ZZNXSE (IZ)
      EEE = MAX ( EEE, TMPZZN )
      IF ( E .GT. 0.1D+00 ) THEN
         ATAR = 0.D+00
         DO 25 IS = ISONDX (1,IZ), ISONDX (2,IZ)
             ATAR = ATAR +  ISOMNM (IS) * ABUISO (IS)
   25    CONTINUE
         EMEV = E * 1.D+03
         XINNEU = SITSAO ( EMEV, IZ, ATAR )
      ELSE IF ( E .LT. EEE ) THEN
         X = 1.D+01 * EEE
         XSENE1 = AANXSE (IZ) * ( X - ZZNXSE (IZ) ) / X * ( 1.D+00
     &          + BBNXSE (IZ) * X / ( 1.D+00 + (CCNXSE(IZ)*X)**2 )
     &          + DDNXSE (IZ) * X * X / ( 1.D+00 + (EENXSE(IZ)*X)**4 ))
         BBCOFF = XSENE1 / ( 1.D+00 + BBETAA / EEE )
         AACOFF = BBCOFF * BBETAA
         XINNEU = AACOFF / E + BBCOFF
      ELSE IF ( E .GT. 0.012D+00 ) THEN
         X  = 1.D+01 * E
         XINNEU = AANXSE (IZ) * ( X - ZZNXSE (IZ) ) / X * ( 1.D+00
     &          + BBNXSE (IZ) * X / ( 1.D+00 + (CCNXSE(IZ)*X)**2 )
     &          + DDNXSE (IZ) * X * X / ( 1.D+00 + (EENXSE(IZ)*X)**4 ))
      ELSE
         XINNEU = 0.D+00
      END IF
      XINNEU = MAX ( XINNEU, ZERZER )
*=== End of function xinneu ===========================================*
      RETURN
      END
+DECK,  XINPRO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:22:04  cernlib
* Geant

*$ CREATE XINPRO.FOR
*COPY XINPRO
*=== xinpro ===========================================================*
      FUNCTION XINPRO ( E, ZTAR, VCOUL )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
*
+CDE, ISOTOP.
+CDE, XSEPAR.
      COMMON / FKNEGX / XSENEG
*
      IZ = NINT ( ZTAR )
      IF ( E .GT. 0.1D+00 ) THEN
         ATAR = 0.D+00
         DO 25 IS = ISONDX (1,IZ), ISONDX (2,IZ)
             ATAR = ATAR + ISOMNM (IS) * ABUISO (IS)
   25    CONTINUE
         EMEV = E * 1.D+03
         XINPRO = SITSAO ( EMEV, IZ, ATAR )
      ELSE
         ZZCOUL = 1.D+01 * VCOUL
         X  = 1.D+01 * E
         X2 = X * X
         XINPRO = AAPXSE (IZ) * ( X - ZZCOUL ) / X * ( 1.D+00
     &          + BBPXSE (IZ) * X + CCPXSE (IZ) * X2 + DDPXSE (IZ)
     &          * X * X2 + EEPXSE (IZ) * X2 * X2 + FFPXSE (IZ) * X2
     &          * X * X2 )
         IF ( XINPRO .LT. 0.D+00 ) THEN
            XSENEG = XINPRO
            XINPRO = 0.D+00
         END IF
      END IF
*=== End of function XINPRO ===========================================*
       RETURN
       END
+PATCH, FLUKA.
+DECK,  ABBRCH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:53  cernlib
* Geant

*$ CREATE ABBRCH.FOR
*COPY ABBRCH
*=== abbrch ===========================================================*
      SUBROUTINE ABBRCH(IT,LL,LA,LT,E0,PGX,PGY,PGZ,KFR1,KFR2,RE,
     *KR1R,KR2R,KR1L,KR2L,RPX,RPY,RPZ,RPXR,RPYR,RPZR,RPXL,RPYL,RPZL,
     *RER,REL,IV,B1,B2,KFA1,KFA2,KFA3,KFA4,IOPT,IYY)
+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      DIMENSION RE(*),KFR1(*),KFR2(*),RPX(*),RPY(*),IV(*)
      REAL RNDM(6)
C*****POSSIBILITY OF THE CUT OFF OF THE RIGHT AND LEFT JET
*      CUTBAM=0.2D+00/(2.D+00+0.5D+00*LOG(E0+2.D+00))
      CUTBAM=0.D0
      I=IT
      J=IT-1
      IVA=1
      IF (LT.EQ.1) WRITE(LUNOUT,288)IT,LL,LA,LT,E0,PGX,PGY,PGZ,KR1R,
     *KR2R,KR1L,KR2L,RPZ,RPXR,RPYR,RPZR,RPXL,RPYL,RPZL,RER,REL,B1,B2,
     *KFA1,KFA2,KFA3,KFA4,IOPT,IYY
  288 FORMAT(4I5,4E12.4,4I5/11E11.3/6I5/
     *  ' ABBRCH ,IT,LL,LA,LT,E0,PGX,PGY,PGZ,KR1R,KR2R,
     *KR1L,KR2L,RPZ,RPXR,RPYR,RPZR,RPXL,RPYL'/' RPZL,RER,REL,B1,B2,
     *KFA1,KFA2,KFA3,KFA4,IOPT,IYY')
      RM=0.764D0
      RMK=0.891D0
      DM=1.863D0
      IF(LA.EQ.1)GOTO10
C*****CHOICE OF THE CUT OFF ENERGY
      IF(I.GT.1)GOTO50
      AM0=1.D0
      KFAA=KFA1
      IF(IOPT.EQ.2) KFAA=MAX(KFA2,KFA3)
      IF(IOPT.EQ.5) KFAA=MAX(KFA3,KFA4)
      IF (KFAA.GT.6)KFAA=KFAA-6
      IF(KFAA.EQ.1.OR.KFAA.EQ.2) AM0=RM
      IF(KFAA.EQ.3) AM0=RMK
      IF(KFAA.EQ.4) AM0=DM
      GOTO60
   50 CONTINUE
      IF(KFR1(J).EQ.1.OR.KFR1(J).EQ.2)AM0=RM
      IF(KFR1(J).EQ.7.OR.KFR1(J).EQ.8)AM0=RM
      IF(KFR1(J).EQ.3.OR.KFR1(J).EQ.9)AM0=RMK
      IF(KFR1(J).EQ.4.OR.KFR1(J).EQ.10)AM0=DM
      BM0=0.D0
      IF(KFR2(J).EQ.3.OR.KFR2(J).EQ.9) BM0=RMK
      IF(KFR2(J).EQ.4.OR.KFR2(J).EQ.10)BM0=DM
      IF(AM0.LT.BM0)AM0=BM0
   60 CONTINUE
      CALL GRNDM(RNDM,6)
      X=RNDM(1)
      IF(I.EQ.1)RX=E0
      IF(I.GT.1)RX=RE(J)
      AM=AM0-1.D0/B1*LOG(1.D0-X)
      IF (RNDM(2).LT.CUTBAM)AM=AM0+0.9D0*RX*RNDM(3)
      X=RNDM(4)
      ESA=AM0-1.D0/B2*LOG(1.D0-X)
      IF (RNDM(5).LT.CUTBAM)ESA=AM0+0.9D0*RX*RNDM(6)
*  *** Now: ***
      PSA=ABS(ESA-AM0)*(ESA+AM0)
      EAB=SQRT(3.D0*.5D0*PSA+AM**2)
      IF(RX.GT.EAB)GOTO30
      IF(IYY.EQ.1.AND.I.EQ.1.AND.IOPT.NE.5) GOTO 30
   10 CONTINUE
      LA=1
      IF(I.EQ.1) GO TO 40
      IF(LL.EQ.1)GOTO20
      KR1R=KFR1(J)
      KR2R=KFR2(J)
      RER=RE(J)
      RPXR=-PGX
      RPYR=-PGY
      RPZR=-PGZ
      RE(J)=E0
      KFR1(J)=KFA2
      KFR2(J)=0
      IV(J)=IVA+5
      IF(IOPT.EQ.5) KFR2(J)=KFA2
      IF(IOPT.EQ.5) KFR1(J)=KFA1
      IF(IOPT.EQ.5) IV(J)=7
      RPX(J)=0.D0
      RPY(J)=0.D0
      IF(IOPT.NE.4.OR.KFA1.GT.6) GO TO 1111
      IV(J)=7
      KFR1(J)=KFA2
      KFR2(J)=KFA3
 1111 CONTINUE
      PGX=0.D0
      PGY=0.D0
      PGZ=0.D0
      IF(LT.EQ.0)GOTO101
      WRITE(LUNOUT,2)KR1R,KR2R,RER,RPXR,RPYR,RPZR
    2 FORMAT(1H0,27HQR1,QR2,RER,RPXR,RPYR,RPZR=,2I3,4F8.4)
  101 CONTINUE
      GO TO 30
   20 CONTINUE
      KR1L=KFR1(J)
      KR2L=KFR2(J)
      REL=RE(J)
      RPXL=-PGX
      RPYL=-PGY
      RPZL=-PGZ
      IF(IOPT.NE.4.OR.KFA1.LT.6) GO TO 4444
      IV(J)=2
      KFR1(J)=KFA2
      KFR2(J)=KFA3
      RE(J)=E0
      RPX(J)=0.D0
      RPY(J)=0.D0
      PGX=0.D0
      PGY=0.D0
      PGZ=0.D0
 4444 CONTINUE
      IF(LT.EQ.0)GO TO 102
      WRITE(LUNOUT,3)KR1L,KR2L,REL,RPXL,RPYL,RPZL
    3 FORMAT(1H0,27HQL1,QL2,REL,RPXL,RPYL,RPZL=,2I3,4F8.4)
  102 CONTINUE
      GOTO30
   40 CONTINUE
      IF(LL.EQ.1)GO TO 70
      KR1R=KFA1
      KR2R=0
      IF(IOPT.EQ.5) KR1R=KFA3
      IF(IOPT.EQ.5) KR2R=KFA4
      RER=E0
      RPXR=0.D0
      RPYR=0.D0
      RPZR=0.D0
      PGX=0.D0
      PGY=0.D0
      PGZ=0.D0
      IF (IOPT.EQ.2)  KR1R=KFA1
      IF (IOPT.EQ.2)KR2R=KFA2
      IF(IOPT.NE.4.OR.KFA1.LE.6) GO TO 3333
 3331 CONTINUE
      KR1R=KFA2
      KR2R=KFA3
 3333 CONTINUE
      IF(LT.EQ.0)GO TO 103
      WRITE(LUNOUT,2)KR1R,KR2R,RER,RPXR,RPYR,RPZR
  103 CONTINUE
      GO TO 30
   70 CONTINUE
      KR1L=KFA2
      KR2L=0
      IF(IOPT.EQ.5) KR1L=KFA1
      IF(IOPT.EQ.5) KR2L=KFA2
      REL=E0
      RPXL=0.D0
      RPYL=0.D0
      RPZL=0.D0
      IF(IOPT.EQ.2) KR1L=KFA1
      IF(IOPT.EQ.2)KR2L=KFA2
      IF(IOPT.NE.4.OR.KFA1.GT.6) GO TO 2222
 2221 CONTINUE
      KR1L=KFA2
      KR2L=KFA3
 2222 CONTINUE
      IF(LT.EQ.0)GO TO 104
      WRITE(LUNOUT,3)KR1L,KR2L,REL,RPXL,RPYL,RPZL
  104 CONTINUE
      GO TO 30
   30 CONTINUE
      IF(LT.EQ.0)GO TO 100
      WRITE(LUNOUT,1)I,LL,LA,AM0,AM,PSA,EAB,RX
    1 FORMAT(1H0,26HI,LL,LA,AM0,AM,APS,EAB,RX=,3I3,5F8.4)
  100 CONTINUE
      RETURN
      END
+DECK,  AINEL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE AINEL.FOR
*COPY AINEL
*                                                                      *
*=== ainel ============================================================*
*                                                                      *
      FUNCTION AINEL(IJ,ILO,E,A,SQA)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C     LAST CHANGE 16. JULY 81 BY     PERTTI AARNIO
C                                    HELSINKI UNIVERSITY OF
C                                    TECHNOLOGY, FINLAND
C
C
C     FUNCTION OF FLUKA TO GIVE INELASTICITIES FOR PRODUCTION OF
C     PARTICLES ILO BY PARTICLE IJ
C
C     NOTE!!!!!!! NON-STANDARD PARTICLE NUMBERING
C
C     INPUT VARIABLES:
C        IJ    = TYPE OF THE PRIMARY
C                1=PROTON
C                2=NEUTRON
C                3=CHARGED PION
C
C        ILO   = TYPE OF THE SECONDARY
C                1=PROTON
C                2=NEUTRON
C                3=CHARGED PION
C                4=NEUTRAL PION
C                5=NUCLEAR EXCITATION EXCLUDING LOW ENERGY
C                  SECONDARIES FROM INTRANUCLEAR CASCADE
C                6=INTRANUCLEAR PROTON
C                7=INTRANUCLEAR NEUTRON
C
C        E     = KINETIC ENERGY OF THE PRIMARY IN GEV
C        A     = ATOMIC WEIGHT OF THE MEDIUM
C        SQA   = SQRT(A)
C
C     OTHER VARIABLES:
C        AK    = LOOK-UP TABLE FOR INELASTCITIES
C
C********************************************************************
C
      DIMENSION AK(4,3)
      SAVE AK
      DATA AK/
     10.35D0,0.3D0,0.25D0,0.1D0,
     10.3D0,0.35D0,0.25D0,0.1D0,
     10.15D0,0.15D0,0.5D0,0.2D0/
C
C
      GO TO (1234,1234,1234,1234,5,6,7),ILO
C
C
 1234 CONTINUE
      IF(E.LT.0.125D0) GO TO 10
      AINEL=AK(ILO,IJ)*(1.D0-EEXI(IJ,E,A)/E)
      RETURN
C
C
 5    CONTINUE
      IF(E.LT.0.125D0) GO TO 11
      ANEL=EEXI(IJ,E,A)/E
      AKEK=EKEKA(2,E,A,SQA)/E+EKEKA(3,E,A,SQA)/E
      AINEL=ANEL-AKEK
      IF (AKEK.GE.ANEL) AINEL=EKEKA(1,E,A,SQA)/E
      RETURN
C
C
    6 CONTINUE
      IF(E.LT.0.125D0) GO TO 10
      AINEL=EKEKA(2,E,A,SQA)/E
      RETURN
C
C
    7 CONTINUE
      IF(E.LT.0.125D0) GO TO 10
      AINEL=EKEKA(3,E,A,SQA)/E
      RETURN
C
C
   10 CONTINUE
      AINEL=0.D0
      RETURN
C
C
 11   CONTINUE
      AINEL=1.D0
      RETURN
      END
+DECK,  AKEKA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE AKEKA.FOR
*COPY AKEKA
*                                                                      *
*=== akeka ============================================================*
*                                                                      *
      FUNCTION AKEKA(IT,TO,AMSS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C     LAST CHANGE 05. DECEMBER 83    PERTTI AARNIO
C                                    HELSINKI UNIVERSITY OF
C                                    TECHNOLOGY, FINLAND
C
C
C     TO BE CALLED FROM HIGH ENERGY PRODUCTION
C
C
C     SLOPE OF THE ENERGY DISTRIBUTION OF THE HIGHER ENERGY PARTICLES
C     OF THE INTRANUCLEAR CASCADE PROTONS AND NEUTRONS (ALFA-2P
C     AND ALFA-2N). NOTE THAT IT IS ASSUMED IN EKEKA AND RAKEKA
C     THAT ALFA-2N=6*ALFA-1N AND ALFA-2P=6*ALFA-1P.
C
C     NOTE!!!!!!! NON-STANDARD PARTICLE NUMBERING
C
C     INPUT VARIABLES:
C        IT   = TYPE OF THE SECONDARY; 1=PROTON, 2=NEUTRON
C        TO   = KINETIC ENERGY OF THE PRIMARY HADRON IN GEV
C        AMSS = ATOMIC WEIGHT OF THE NUCLEUS
C
C     SEE RANFT/ROUTTI PARTICLE ACC. VOL 4 P 105
C********************************************************************
C
      DIMENSION A(2),B(2)
      SAVE A,B
      DATA  A/0.11D0,0.1D0/
      DATA B/0.21D0,0.20D0/
      IF (TO .LT. 10.D0) THEN
         AKEKA=(1.D0-0.001D0*AMSS)*(A(IT)+0.01D0*TO)
      ELSE
         AKEKA=B(IT)*(1.D0-0.001D0*AMSS)
      END IF
      RETURN
      END
+DECK,  ALTRA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE ALTRA.FOR
*COPY ALTRA
*=== altra ============================================================*
      SUBROUTINE ALTRA(GA,BGX,BGY,BGZ,PCX,PCY,PCZ,EC,P,PX,PY,PZ,E)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C*** ARBITRARY LORENTZ TRANSFORM
      EP = PCX * BGX + PCY * BGY + PCZ * BGZ
      E  = GA * EC + EP
      PE = EP / (GA + 1.D0) + EC
      PX = PCX + BGX * PE
      PY = PCY + BGY * PE
      PZ = PCZ + BGZ * PE
      TMP30 = 1.D30
      PX = MIN(TMP30, MAX(-TMP30,PX))
      PY = MIN(TMP30, MAX(-TMP30,PY))
      PZ = MIN(TMP30, MAX(-TMP30,PZ))
      P  = SQRT (PX * PX + PY * PY + PZ * PZ)
      RETURN
      END
+DECK,  ALTRAF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE ALTRAF.FOR
*COPY ALTRAF
*=== altraf ===========================================================*
      SUBROUTINE ALTRAF(GA,BGA,CX,CY,CZ,COD,COF,SIF,PC,EC,P,PX,PY,PZ,E)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C
C--------------------------------------------------
C*** (S1 IN S2 / PARTICLE IN S1 / RESULT: PARTICLE IN S2)
C*** ARBITRARY LORENTZ TRANSFORM
C*** SI ARE THE DIFFERENT LORENTZ-SYSTEMS
C--------------------------------------------------
      BGX  = BGA * CX
      BGY  = BGA * CY
      BGZ  = BGA * CZ
      COD2 = COD * COD
      IF (COD2 .GT. 1.D0) COD2 = 1.D0
      SID  = SQRT(1.D0 - COD2) * PC
      PCX  = SID * COF
      PCY  = SID * SIF
      PCZ  = COD * PC
      EP = PCX * BGX + PCY * BGY + PCZ * BGZ
      E  = GA * EC + EP
      PE = EP / (GA + 1.D0) + EC
      PX = PCX + BGX * PE
      PY = PCY + BGY * PE
      PZ = PCZ + BGZ * PE
      P  = SQRT (PX * PX + PY * PY + PZ * PZ)
      PM = 1.D0 / P
      PX = PX * PM
      PY = PY * PM
      PZ = PZ * PM
      RETURN
      END
+DECK,  AMGA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE AMGA.FOR
*COPY AMGA
*=== amga =============================================================*
      FUNCTION AMGA(IT)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C*** RANDOM SELECTION OF MASSES OF DECAYING PARTICLES
      COMMON/FKABLT/AMM(110),GA(110),TAU(110),ICH(110)
     *,IBAR(110),K1(110),K2(110)
      COMMON /FKGAMR/ REDU,AMO,AM (15 )
      DIMENSION GASUNI(14)
      REAL RNDM(1)
      SAVE GASUNI, GAUNO, GAUNON, IO, NSTAB
      DATA GASUNI/
     *-1.D0,-.98D0,-.95D0,-.87D0,-.72D0,-.48D0,-.17D0,.17D0,.48D0,
     *.72D0,.87D0,.95D0,.98D0,1.D0/
      DATA GAUNO/2.352D0/
      DATA GAUNON/2.4D0/
      DATA IO/14/
      DATA NSTAB/23/
      I=1
      IF (IT.LE.0) GO TO 3
      IF (IT.LE.NSTAB) GO TO 2
      DGAUNI=GAUNO*GAUNON/(IO-1.D0)
      CALL GRNDM(RNDM,1)
      VV = RNDM(1)
      VV = VV*2.D0-1.D0+1.D-16
    1 CONTINUE
      VO=GASUNI(I)
      I=I+1
      V1=GASUNI(I)
      IF (VV.GT.V1) GO TO 1
      UNIGA=DGAUNI*(I-2.D0+(VV-VO+1.D-16)/(V1-VO)-(IO-1.D0)*.5D0)
      DAM=GA(IT)*UNIGA/GAUNO
      AAM=AMM(IT)+DAM
      AMGA=AAM
      RETURN
    2 CONTINUE
      AMGA=AMM(IT)
      RETURN
    3 CONTINUE
      AMGA=0.D0
      RETURN
      END
+DECK,  ANKEKA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE ANKEKA.FOR
*COPY ANKEKA
*                                                                      *
*=== ankeka ===========================================================*
*                                                                      *
      FUNCTION ANKEKA(IT,TO,AMSS,SQAMSS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C     LAST CHANGE 05. DECEMBER 83    PERTTI AARNIO
C                                    HELSINKI UNIVERSITY OF
C                                    TECHNOLOGY, FINLAND
C
C     TO BE CALLED FROM THE HIGH ENERGY PRODUCTION
C
C     TO GIVE THE PROTON AND NEUTRON MULTIPLICITIES OF THE HIGH
C     ENERGY PART OF THE INTRANUCLEAR CASCADE  (N-2P,N-2N).
C     NOTE THAT IT IS SUPPOSED IN EKEKA AND RAKEKA THAT
C     N-1P=9*N-2P, N-1N=9*N-2N.
C
C     NOTE!!!!!!! NON-STANDARD PARTICLE NUMBERING
C
C     INPUT VARIABLES:
C        IT     = TYPE OF THE PARTICLE
C                 1=INTRANUCLEAR PROTON
C                 2=INTRANUCLEAR NEUTRON
C        TO     = ENERGY OF THE COLLIDING PARTICLE IN GEV
C        AMSS   = ATOMIC WEIGHT OF THE MEDIUM
C        SQAMSS = SQRT(AMSS)
C
C     SEE RANFT/ROUTTI PARTICLE ACC. VOL 4 P 105
C********************************************************************
C
      DIMENSION A(2),B(2),C(2),D(2)
      SAVE A,B,C,D
C
C
C     THESE ARE EFFECTIVE FLUKA81 MULTIPLICITIES
C
      DATA A/1.D0,1.3D0/
      DATA B/0.06D0,0.09D0/
      DATA C/1.104D0,1.90D0/
C     DATA D/0.14D0,0.19D0/
C  This ones for continuity !!
      DATA D/0.245333D0,0.33333D0/
      IF(TO.GT.0.1D0)GO TO 1
      ANKEKA=SQAMSS*B(IT)*0.1D0
      RETURN
 1    CONTINUE
      IF(TO.GE.10.D0)GO TO 2
      ANKEKA=0.1D0*SQAMSS*(0.5D0+A(IT)*(1.D0+LOG10(TO))**2)*D(IT)
      RETURN
 2    CONTINUE
      ANKEKA=SQAMSS*0.1D0*C(IT)
      RETURN
      END
+DECK,  BAMJEV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:53  cernlib
* Geant

*$ CREATE BAMJEV.FOR
*COPY BAMJEV
*=== bamjev ===========================================================*
      SUBROUTINE BAMJEV ( IHAD, KFA1, KFA2, KFA3, KFA4, AE0, IOPT )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Bamjet90: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*     Ihad   = number of final hadrons and hadron resonances           *
*     Ae0    = initial energy in GeV                                   *
*     Kfai   = initial quark flavours (u=1,d=2,s=3,c=4,ubar=7,dbar=8,  *
*                                      sbar=9, cbar=10)                *
*     Iopt   = 1,2,3,4,5 means:                                        *
*              1: single (anti)quark jet,   (kfa1)                     *
*              2: single (anti)diquark jet, (kfa1-kfa2)                *
*              3: complete quark antiquark twojet event, (kfa1,kfa2)   *
*              4: complete (anti)quark-(anti)diquark two jet event,    *
*                 (kfa1,kfa2-kfa3)                                     *
*              5: complete diquark-(anti)diquark two jet event,        *
*                 (kfa1-kfa2,kfa3-kfa4)                                *
*     Common/finpar/ contains the momenta,energies and quantum numbers *
*     of the created hadrons                                           *
*     Iv     = actual vertex,iv=1,4,5,6,9,10 are meson verteces        *
*              iv=2,3,7,8 are baryon verteces                          *
*     La     = 1 means cut-off                                         *
*     Ll     = 0,1 means quark jet, antiquark jet, (diquark jet, anti- *
*              diquark jet)                                            *
*     Common/remain/ contains rest jet energy,momenta and quantumnum-  *
*                    bers                                              *
*----------------------------------------------------------------------*
*
+CDE, BAMJCM.
+CDE, FINPAR2.
+CDE, PART.
+CDE, INPDAT.

      COMMON/FKREMA/ RPXR,RPYR,RPZR,RER,KR1R,KR2R
      SAVE NCOU, ITMX
*
      DATA NCOU/0/
      DATA ITMX/0/
      NCOU=NCOU+1
      A1SAVE = A1
      B1SAVE = B1
      B2SAVE = B2
      B3SAVE = B3
      IF ( AE0 .LE. 4.D+00 )THEN
         A1 = 0.88D+00
      ELSE IF ( AE0 .LE. 8.0D+00 ) THEN
         A1 = 0.88D+00
      ELSE IF ( AE0 .LT. 30.D+00 ) THEN
         A1 = 0.88D+00
      ELSE
         A1 = 0.88D+00
      END IF
         FRB12 = 0.5D+00
         B1 = 4.D+00 + 1.D+00 / ( FRB12 * AE0 )**2
         B2 = 4.D+00 + 1.D+00 / ( FRB12 * AE0 )**2
      E00 = 40.D+00
* The following is consistent with B3=6
      B3 = B3 * LOG10 ( E00 ) /
     &   ( LOG10 ( 1.D+00 + ( AE0 / E00 )**2 ) + LOG10 ( E00 ) )
C     IF (NCOU.EQ.4701)LT=1
*or   IF (LT.EQ.1)WRITE(LUNOUT,3399)IOPT,NCOU
 3399 FORMAT('  BAMJET',2I10 )
*or   IF (LT.EQ.1)WRITE(LUNOUT,288)IHAD,KFA1,KFA2,KFA3,KFA4,AE0,IOPT
  288 FORMAT (5I5,2E12.4,' BAMJET,IHAD,KFA1,KFA2,KFA3,KFA4,AE0,IOPT')
   63 CONTINUE
      DO 62  I=1,ITMX
         KFR1(I) = 0
         KFR2(I) = 0
   62 CONTINUE
      ITMX=0
   60 CONTINUE
      IYY=0
      IHAD=0
      IT=0
      E0=AE0*.5D0
      IF(IOPT.EQ.1.OR.IOPT.EQ.2) E0=AE0
      LL=0
      IF(KFA1.GT.6.AND.IOPT.EQ.1) LL=1
      IF(KFA1.LE.6.AND.IOPT.EQ.2) LL=1
      IF(KFA1.GT.6.AND.IOPT.EQ.4) LL=1
      PGX = 0.D0
      PGY = 0.D0
      PGZ = 0.D0
      RPX0 = 0.D0
      RPY0 = 0.D0
* The following 6 initializations might be useless, but they make the
* code much clearer
      KR1R = 0
      KR2R = 0
      KR1L = 0
      KR2L = 0
      RER  = 0.D+00
      REL  = 0.D+00
      DO 10 I=1,KMXJCM
         KFR1(I) = 0
         KFR2(I) = 0
         LA = 0
         IT = IT+1
         J  = IT-1
* The following line seems useless
*        K  = IT+1
   40    CONTINUE
C*****CUT OFF TASK
*  | Abbrch is called to cut the chain
         CALL ABBRCH(IT,LL,LA,LT,E0,PGX,PGY,PGZ,KFR1,KFR2,RE,
     &   KR1R,KR2R,KR1L,KR2L,RPX,RPY,RPZ,RPXR,RPYR,RPZR,RPXL,RPYL,RPZL,
     &   RER,REL,IV,B1,B2,KFA1,KFA2,KFA3,KFA4,IOPT,IYY)
         ITMX=MAX(ITMX,IT)
         IF(LA .EQ. 0) GO TO 20
         IT=IT-1
         IF(IOPT.EQ.3.AND.LL.EQ.0) GO TO 70
         IF(IOPT.EQ.4.AND.KFA1.LE.6.AND.LL.EQ.0) GO TO 70
         IF(IOPT.EQ.4.AND.KFA1.GT.6.AND.LL.EQ.1) GO TO 70
         IF(IOPT.EQ.5.AND.LL.EQ.0) GO TO 70
         GO TO 50
   70    CONTINUE
         IYY = 1
         LL  = 1
         IF(IOPT.EQ.4.AND.KFA1.GT.6) LL = 0
         IAR=IT
         GO TO 30
   20    CONTINUE
C*****CHOICE OF THE VERTEX
         CALL FKVERT(IT,LT,LL,KFA1,E0,IV,RE,KFR1,KFR2,AME,IOPT)
C*****CHOICE OF THE FLAVOUR
         CALL FKFLAV(IT,LT,LL,E0,IV,RE,KFR1,KFR2,ISU,BET,KFA1,KFA2,
     &               KFA3,KFA4,IOPT)
C*****CLASSIFICATION OF THE PARTICLES
         CALL HKLASS(IT,LT,LA,LL,KFR1,KFR2,KR1R,KR2R,KR1L,KR2L,IV,IMPS,
     &         IMVE,IB08,IA08,IB10,IA10,AS,B8,KFA1,KFA2,KFA3,KFA4,IOPT)
         ITMX=MAX(ITMX,IT)
         IF (IT .EQ. 1) RX = E0
         IF (IT .GT. 1) RX = RE(J)
         IF(AMF(IT) .GT. RX) GO TO 63
         IF(AMF(IT) .LE. RX) GO TO 19
         LA = 1
         GO TO 40
   19    CONTINUE
         IHAD = IHAD + 1
*or         IF(LT .EQ. 0) GO TO 31
*or         WRITE(LUNOUT,32)IHAD
*or   31    CONTINUE
C*****CHOICE OF THE ENERGY
         CALL ENERGI(IT,LL,LT,IV,RE,HMA,HE,E0,A1)
C*****CHOICE OF THE MOMENTUM
*  |
*  |  He is the total energy, hma the mass one (input) hpx, hpy, hpz
*  |  the momentum components (output values), hps the transversal
*  |  momentum (output)
*  |
         CALL FKIMPU(HE,HMA,HPS,HPX,HPY,HPZ,LT,LL,B3)
         IF (IT .GT. 1) GO TO 13
         RPX(IT)=RPX0-HPX
         RPY(IT)=RPY0-HPY
         GO TO 14
   13    RPX(IT)=RPX(J)-HPX
         RPY(IT)=RPY(J)-HPY
   14    CONTINUE
         IF (IOPT.EQ.1.AND.LL.EQ.1)HPZ=-HPZ
         IF(IOPT.EQ.2.AND.LL.EQ.1) HPZ=-HPZ
         IF(IOPT.EQ.4.AND.KFA1.GT.6) HPZ=-HPZ
         IF(IOPT.EQ.5) HPZ=-HPZ
         PGX=PGX+HPX
         PGY=PGY+HPY
         PGZ=PGZ+HPZ
         PXF(IT)=HPX
         PYF(IT)=HPY
         PZF(IT)=HPZ
*or         IF (LT .EQ. 0) GO TO 15
*or            WRITE(LUNOUT,16)PGX,PGY,PGZ
*or   16       FORMAT(1H0,12HPGX,PGY,PGZ=,3F8.4)
*or   15    CONTINUE
   30    CONTINUE

   10 CONTINUE
*
* we suppose that exiting from loop must be achieved via " go to 50
*
      WRITE (LUNERR,*)' BAMJEV: EXITING FROM LOOP ABNORMALLY!!!! '
      WRITE (LUNOUT,*)' BAMJEV: EXITING FROM LOOP ABNORMALLY!!!! '
   50 CONTINUE
      ITMX=MAX(ITMX,IT)
      IF(IOPT.EQ.1.OR.IOPT.EQ.2) GO TO 51
C*****PUT THE RIGHT AND LEFT JET TOGETHER
      CALL VEREIN(IT,LA,LT,RER,REL,RPXR,RPYR,RPZR,RPXL,RPYL,RPZL,
     &KR1R,KR2R,KR1L,KR2L,IHAD,LL,KFR1,KFR2,IMPS,IMVE,IB08,IA08,
     &IB10,IA10,B3,AS,B8,IAR,KFA1,KFA2,KFA3,KFA4,IOPT)
      IF(LA.EQ.3) GO TO 63
      IF(LA.EQ.2) GO TO 63
   51 CONTINUE
      IF(IOPT.EQ.3.OR.IOPT.EQ.4.OR.IOPT.EQ.5) GO TO 52
      IF(LL.EQ.0) GO TO 52
      RPXR=RPXL
      RPYR=RPYL
      RPZR=RPZL
      RER=REL
      KR1R=KR1L
      KR2R=KR2L
   52 CONTINUE
      IF(LE.EQ.0) GO TO 1000
      WRITE(LUNOUT,92)
   92 FORMAT(2X,'NF,NAME,MASS,IQ,IB,PX,PY,PZ,E')
      DO 91 J=1,IT
         WRITE(LUNOUT,90)NREF(J),ANF(J),AMF(J),ICHF(J),IBARF(J),PXF(J),
     &   PYF(J),PZF(J),HEF(J)
   90    FORMAT(2X,I3,A6,F6.3,2I4,4F8.4)
   91 CONTINUE
 1000 CONTINUE
   64 FORMAT(1H0,38HNUMBER OF EVENTS WITH PREST GT. EREST=,I4,
     */,21HNUMBER OF ALL EVENTS=,I4)
 2000 FORMAT(1H0,'NUMBER OF EVENTS WITH ONLY ONE PARTICLE=',I4)
*or      IF(LT.EQ.0) GO TO 17
*or      WRITE(LUNOUT,18)IHAD
*or   18 FORMAT(1H0,15HMULTIPLIZITAET=,I3)
*or   32 FORMAT(1H0,13HHADRONANZAHL=,I3)
*or   17 CONTINUE
      A1 = A1SAVE
      B1 = B1SAVE
      B2 = B2SAVE
      B3 = B3SAVE
      RETURN
      END
+DECK,  BEEXI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE BEEXI.FOR
*COPY BEEXI
*                                                                      *
*=== beexi ============================================================*
*                                                                      *
      FUNCTION BEEXI(IJ,E,A)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C-----------------------------------------------
C     NUCLEAR EXCITATION ENERGY INCLUDING ALL LOW ENERGY SECONDARIES IN
C     COLLISIONS OF PARTICLE IJ OF ENERGY E GEV ON NUCLEI A
C-----------------------------------------------
      IF (E.LE.0.125D0) GO TO 20
      B=SQRT(A)/9.D0-.2D0
      IF (B.GT.A*0.01D0) B=A*0.01D0
      IF (E.GE.3.D0) GO TO 10
      IF (B.LT.0.125D0) B=0.125D0
      BEEXI=0.125D0+(E-0.125D0)*(B-0.125D0)/2.875D0
      RETURN
   10 CONTINUE
      BEEXI=B
      RETURN
   20 CONTINUE
      BEEXI=E
      RETURN
      END
+DECK,  BEKEKA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE BEKEKA.FOR
*COPY BEKEKA
*                                                                      *
*=== bekeka ===========================================================*
*                                                                      *
      FUNCTION BEKEKA(IX,TO,AMSS,SQAMSS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C*** CALCULATION OF AVERAGE CASCADE AND EXCITATION ENERGY
C*****IX=1 EEV    2EPK    3 ENK     4 EEX=EPK+EEV    5 EEXT=EEX+ENK
      GO TO (1,2,3,1,1),IX
    1 CONTINUE
      IF(TO-0.1D0) 11,11,12
   11 CONTINUE
      AA=0.001D0*SQAMSS
      GO TO 19
   12 CONTINUE
      APAR=0.035D0
      BPAR=3.D0
      CPAR=0.1D0
      AA=CPAR*SQAMSS*(0.01D0+APAR*(BPAR+LOG10(TO))**2)
   19 CONTINUE
      IF(IX.GT.3) GO TO 2
C    ENERGYADJUST
      ENADJ=1.D0
      AA=AA*ENADJ
      BEKEKA=AA
      RETURN
    2 CONTINUE
      AN=BNKEKA(1,TO,AMSS,SQAMSS)
      A =BKEKA (1,TO,AMSS)
      EXTOA=0.D0
      IF(TO.LT.5.D0*A) EXTOA=EXP(-TO/A)
      TPKAV=A*(1.D0-(TO/A+1.D0)*EXTOA)/(1.D0-EXTOA)
      BB=TPKAV*AN
      IF(IX.EQ.4) GO TO 4
      IF(IX.EQ.5) GO TO 3
      BEKEKA=BB
      RETURN
    4 CONTINUE
      BEKEKA=AA+BB
      RETURN
    3 CONTINUE
      AN=BNKEKA(2,TO,AMSS,SQAMSS)
      A =BKEKA (2,TO,AMSS)
      EXTOA=0.D0
      IF(TO.LT.5.D0*A) EXTOA=EXP(-TO/A)
      TNKAV=A*(1.D0-(TO/A+1.D0)*EXTOA)/(1.D0-EXTOA)
      CC=TNKAV*AN
      IF(IX.EQ.5) GO TO 5
      BEKEKA=CC
      RETURN
    5 CONTINUE
      BEKEKA=AA+BB+CC
      RETURN
      END
+DECK,  BERTTP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*=== berttp ===========================================================*
*                                                                      *
      SUBROUTINE BERTTP

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C---------------------------------------------------------------------
C SUBNAME = BERTTP --- READ BERTINI DATA
C---------------------------------------------------------------------
C     --------------------------------- EVAPORATION DATA
+CDE, EVA0.
+CDE, HETTP.
+CDE, INPFLG.
+CDE, ISOTOP.
+CDE, NUCGEO.
+CDE, NUCLEV.
+CDE, PAREVT.
+CDE, XSEPAR.
      LOGICAL OPENED,EXISTS
      LOGICAL LRMSCH, LRD1O2, LTRASP
      CHARACTER*100 FILNAM
+SELF, IF=UNIX,VAX,CRAY.
      CHARACTER*100 CHROOT
+SELF.
C---------------------------------------------------------------------
+SELF, IF=FDEBUG.
      WRITE( LUNOUT,'(A,I2)')
     & ' -/BERTTP(I): EVAP   DATA READ FROM UNIT ', NBERTP
+SELF.
      INQUIRE(UNIT=NBERTP, OPENED=OPENED)
      IF(OPENED) THEN
         REWIND NBERTP
      ELSE
+SELF, IF=UNIX,CRAY.
         CHROOT=' '
         CALL GETENVF('CERN_ROOT',CHROOT)
         LNROOT = LNBLNK(CHROOT)
         IF(LNROOT.LE.0) THEN
            FILNAM='flukaaf.dat'
         ELSE
            FILNAM=CHROOT(1:LNROOT)//'/lib/flukaaf.dat'
         ENDIF
         INQUIRE(FILE=FILNAM,EXIST=EXISTS)
         IF(.NOT.EXISTS) THEN
           PRINT*,'**********************************'
           PRINT*,'*        F I F A C E             *'
           PRINT*,'*        -----------             *'
           PRINT*,'*   File FLUKAAF.DAT not found   *'
           PRINT*,'*         Program STOP           *'
           PRINT*,'*   Check CERN_ROOT environment  *'
           PRINT*,'*           variable             *'
           PRINT*,'**********************************'
           STOP
         ENDIF
         OPEN(NBERTP,FILE=FILNAM,STATUS='OLD')
+SELF, IF=VAX.
         ISTAT = LIB$SYS_TRNLOG ('CERN_ROOT',NALL,CHROOT,,,%VAL(0))
         IF(ISTAT.NE.1) THEN
            FILNAM='flukaaf.dat'
         ELSE
            FILNAM='CERN_ROOT:[LIB]flukaaf.dat'
         ENDIF
         INQUIRE(FILE=FILNAM,EXIST=EXISTS)
         IF(.NOT.EXISTS) THEN
           PRINT*,'**********************************'
           PRINT*,'*        F I F A C E             *'
           PRINT*,'*        -----------             *'
           PRINT*,'*   File FLUKAAF.DAT not found   *'
           PRINT*,'*         Program STOP           *'
           PRINT*,'*   Check CERN_ROOT environment  *'
           PRINT*,'*           variable             *'
           PRINT*,'**********************************'
           STOP
         ENDIF
         OPEN(NBERTP,FILE=FILNAM,STATUS='OLD',READONLY)
+SELF, IF=IBM.
         FILNAM='/FLUKAAF DAT *'
         OPEN(NBERTP,FILE=FILNAM,STATUS='OLD')
+SELF.
      ENDIF

C A. Ferrari: first of all read isotopic data
      READ (NBERTP,2100) ISONDX
      READ (NBERTP,2100) ISOMNM
      READ (NBERTP,2000) ABUISO
      READ (NBERTP,2000) (P0(I),P1(I),P2(I),I=1,1001)
      READ (NBERTP,2100) IA,IZ
      DO 2 I=1,6
         FLA(I)=IA(I)
         FLZ(I)=IZ(I)
    2 CONTINUE
      READ (NBERTP,2000) RHO,OMEGA
      READ (NBERTP,2000) EXMASS
      READ (NBERTP,2000) CAM2
      READ (NBERTP,2000) CAM3
      READ (NBERTP,2000) CAM4
      READ (NBERTP,2000) CAM5
      READ (NBERTP,2000) ((T(I,J),J=1,7),I=1,3)
      DO 3 I=1,7
         T(4,I)=0.D0
    3 CONTINUE
      READ (NBERTP,2000) RMASS
      READ (NBERTP,2000) ALPH
      READ (NBERTP,2000) BET
      READ (NBERTP,2000) WAPS
      READ (NBERTP,2000) APRIME
+SELF, IF=FDEBUG.
      WRITE( LUNOUT,'(A)' ) ' /DRES(I): USING 1977 WAPS DATA '
+SELF.
      READ (NBERTP,2200) AHELP , BHELP , LRMSCH, LRD1O2, LTRASP
      IF ( AHELP .NE. ALPHA0 .OR. BHELP .NE. GAMSK0 ) THEN
         WRITE (LUNOUT,*)
     &         ' *** Inconsistent Nuclear Geometry data on file ***'
         STOP
      END IF
      READ (NBERTP,2000) RHOTAB, RHATAB, ALPTAB, RADTAB, SKITAB, HALTAB,
     &              EKATAB, PFATAB, PFRTAB
      READ (NBERTP,2000) AANXSE, BBNXSE, CCNXSE, DDNXSE, EENXSE, ZZNXSE,
     &              EMNXSE, XMNXSE
      READ (NBERTP,2000) AAPXSE, BBPXSE, CCPXSE, DDPXSE, EEPXSE, FFPXSE,
     &              ZZPXSE, EMPXSE, XMPXSE
2000  FORMAT (3(1X,G23.16))
2100  FORMAT (18(1X,I3))
2200  FORMAT (2(1X,G23.16),3(1X,L1))
      CLOSE (UNIT=NBERTP)
      DO 100 JZ = 1, 130
         SHENUC ( JZ, 1 ) = 1.D-03 * ( CAM2 (JZ) + CAM4 (JZ) )
  100 CONTINUE
      DO 200 JA = 1, 200
         SHENUC ( JA, 2 ) = 1.D-03 * ( CAM3 (JA) + CAM5 (JA) )
  200 CONTINUE
      CALL STALIN
      ILVMOD = 1
      IB0 = ILVMOD
+SELF, IF=FDEBUG.
      WRITE (LUNOUT,*)
      WRITE (LUNOUT,*)' **** Standard EVAP level density used ****'
      WRITE (LUNOUT,*)
     &   ' **** Original Gilbert/Cameron pairing energy used ****'
+SELF.
      ILVMOD = IB0
      DO 500 JZ = 1, 130
         PAENUC ( JZ, 1 ) = 1.D-03 * CAM4 (JZ)
  500 CONTINUE
      DO 600 JA = 1, 200
         PAENUC ( JA, 2 ) = 1.D-03 * CAM5 (JA)
  600 CONTINUE
      RETURN
      END
+DECK,  BETA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE BETA.FOR
*COPY BETA
*=== beta =============================================================*
      FUNCTION BETA(X1,X2,BET)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      AX=0.D0
      BETX1=BET*X1
      IF(BETX1.LT.70.D0) AX=-1.D0/BET**2*(BETX1+1.D0)*EXP(-BETX1)
      AY=1.D0/BET**2*(BET*X2+1.D0)*EXP(-BET*X2)
      BETA=AX+AY
      RETURN
      END
+DECK,  BETARN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*$ CREATE BETARN.FOR
*COPY BETARN
*=== betarn ===========================================================*
      FUNCTION BETARN(GAM,ETA)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     New version:                                                     *
*     Created on 20 february 1991  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 20-feb-91     by    Alfredo Ferrari               *
*                                                                      *
*     Sampling from beta distribution in [0,1) :                       *
*                                                                      *
*     P(X) = X**(GAM-1.D0)*(1.D0-X)**(ETA-1)*GAMM(ETA+GAM)             *
*          / (GAMM(GAM*GAMM(ETA))                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
      REAL RNDM(2)
*
      GAMI  = 1.D+00 / GAM
      ETAM1 = ETA - 1.D+00
      NTAM1 = NINT (ETA - 1.D+00)
*  +-------------------------------------------------------------------*
*  |
      IF ( ETAM1 - NTAM1 .NE. 0.D+00 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |  First sample from X**(gam-1) and then reject according to
*  |  |  (1-X)**(eta-1)
  100    CONTINUE
            CALL GRNDM(RNDM,2)
            BETARN = RNDM (1)**GAMI
            REJE   = ( 1.D+00 - BETARN )**ETAM1
         IF ( RNDM (2) .GE. REJE ) GO TO 100
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
*  |  +----------------------------------------------------------------*
*  |  |  First sample from X**(gam-1) and then reject according to
*  |  |  (1-X)**(eta-1)
  200    CONTINUE
            CALL GRNDM(RNDM,2)
            BETARN = RNDM (1)**GAMI
            REJE   = ( 1.D+00 - BETARN )**NTAM1
         IF ( RNDM (2) .GE. REJE ) GO TO 200
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
      RETURN
*=== End of function betarn ===========================================*
      END
+DECK,  BETRST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*$ CREATE BETRST.FOR
*COPY BETRST
*=== betrst ===========================================================*
      FUNCTION BETRST ( GAM, ETA, X0, X1 )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     New version:                                                     *
*     Created on 20 february 1991  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 20-feb-91     by    Alfredo Ferrari               *
*                                                                      *
*     Sampling from beta distribution in [X0,X1) :                     *
*                                                                      *
*     P(X) = X**(GAM-1.D0)*(1.D0-X)**(ETA-1)*GAMM(ETA+GAM)             *
*          / (GAMM(GAM*GAMM(ETA))                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
      REAL RNDM(2)
*
*  +-------------------------------------------------------------------*
*  |
      IF ( X1 .LT. X0 ) THEN
         WRITE (LUNOUT,*)' Betrst: x1<x0, gam, eta', X1, X0, GAM, ETA
         WRITE (LUNERR,*)' Betrst: x1<x0, gam, eta', X1, X0, GAM, ETA
         X0 = MIN ( X0, ONEONE-0.05 )
         X1 = MIN ( ONEONE, X0/TWOTHI )
      END IF
*  |
*  +-------------------------------------------------------------------*
      GAMI  = 1.D+00 / GAM
      X0GAM = X0**GAM
      X1GAM = X1**GAM
      X0TO1 = 1.D+00 - X0
      CNORM = X1GAM - X0GAM
      ETAM1 = ETA - 1.D+00
      NTAM1 = NINT (ETA - 1.D+00)
*  +-------------------------------------------------------------------*
*  |
      IF ( ETAM1 - NTAM1 .NE. 0.D+00 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |  First sample from X**(gam-1) and then reject according to
*  |  |  (1-X)**(eta-1)
  100    CONTINUE
            CALL GRNDM(RNDM,2)
            BETRST = ( RNDM (1) * CNORM + X0GAM )**GAMI
            REJE   = ( ( 1.D+00 - BETRST ) / X0TO1 )**ETAM1
         IF ( RNDM (2) .GE. REJE ) GO TO 100
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
*  |  +----------------------------------------------------------------*
*  |  |  First sample from X**(gam-1) and then reject according to
*  |  |  (1-X)**(eta-1)
  200    CONTINUE
            CALL GRNDM(RNDM,2)
            BETRST = ( RNDM (1) * CNORM + X0GAM )**GAMI
            REJE   = ( ( 1.D+00 - BETRST ) / X0TO1 )**NTAM1
         IF ( RNDM (2) .GE. REJE ) GO TO 200
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
      RETURN
*=== End of function betrst ===========================================*
      END
+DECK,  BKEKA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE BKEKA.FOR
*COPY BKEKA
*                                                                      *
*=== bkeka ============================================================*
*                                                                      *
      FUNCTION BKEKA(IT,TO,AMSS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C*** NUCLEAR CASCADE NUCLEON EMISSION PARAMETERS
      DIMENSION A(2),B(2)
      SAVE A,B
      DATA A/0.11D0,0.1D0/
      DATA B/0.21D0,0.20D0/
      IF (TO-10.D0) 1,2,2
    1 CONTINUE
C    ENERGYADJUST
      ENADJ=1.D0
      BKEKA=ENADJ*(1.D0-0.001D0*AMSS)*(A(IT)+0.01D0*TO)
      RETURN
    2 CONTINUE
      BKEKA=B(IT)*(1.D0-0.001D0*AMSS)
      RETURN
      END
+DECK,  BKLASS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE BKLASS.FOR
*COPY BKLASS
*=== bklass ===========================================================*
      SUBROUTINE BKLASS(I,J,K,I8,I10)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C*** I,J,K QUARK FLAVOURS U,D,S,C=1,2,3,4
C*** AQ = -Q
C*** I8,I10 BARYON INDICES
+CDE, INPDAT.
      IF (I) 10,10,100
C*** BARYON
100   CONTINUE
      CALL INDEX2(J,K,IND)
      I8=IB08(I,IND)
      I10=IB10(I,IND)
         IF (I8.LE.0) I8=I10
      RETURN
10    CONTINUE
C*** ANTIBARYONS
      II=IABS(I)
      JJ=IABS(J)
      KK=IABS(K)
      CALL INDEX2(JJ,KK,IND)
      I8=IA08(II,IND)
      I10=IA10(II,IND)
         IF (I8.LE.0) I8=I10
      RETURN
      END
+DECK,  BNKEKA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE BNKEKA.FOR
*COPY BNKEKA
*                                                                      *
*=== bnkeka ===========================================================*
*                                                                      *
      FUNCTION BNKEKA(IT,TO,AMSS,SQAMSS )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C*** CASCADE PARAMETER CALCULATION
      DIMENSION A(2),B(2),C(2),D(2)
      SAVE A,B,C,D
      DATA A/1.D0,1.3D0/
      DATA B/.15D0,.225D0/
      DATA C /1.35D0,2.28D0/
      DATA D/.3D0,.4D0/
      IF(TO-0.1D0) 1,1,2
    1 CONTINUE
      BNKEKA=SQAMSS*B(IT)*0.1D0
      RETURN
    2 CONTINUE
      IF (TO-10.D0) 3,4,4
    3 CONTINUE
      BNKEKA=0.1D0*SQAMSS*(0.5D0+A(IT)*(1.D0+LOG10(TO))**2)*D(IT)
      RETURN
    4 CONTINUE
      BNKEKA=SQAMSS*0.1D0*C(IT)
      RETURN
      END
+DECK,  CALUMO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE CALUMO.FOR
*COPY CALUMO
*=== calumo ===========================================================*
      SUBROUTINE CALUMO (N,ITTA)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C*** C.M.S.-ENERGY AND REACTION CHANNEL THRESHOLD CALCULATION
*
+CDE, REAC.
+CDE, REDVER.
+CDE, SPLIT.
*
**** *,IEII,IKII,NURE
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
      IRE=NURE(N,ITTA/8+1)
      IEO=IEII (IRE)+1
      IEE=IEII (IRE+1)
      AM1  = AM (N)
      AM12 = AM1**2
      AM2  = AM (ITTA)
      AM22 = AM2**2
      DO 1 IE=IEO,IEE
         PLAB2=PLABF(IE)**2
         ELAB=SQRT(AM12+AM22+2.D+00*SQRT(PLAB2+AM12)*AM2)
         UMO(IE)=ELAB
    1 CONTINUE
      IKO=IKII(IRE)+1
      IKE=IKII(IRE +1)
      UMOO=UMO(IEO)
      DO 2 IK=IKO,IKE
         IF (NRK(2,IK).GT.0) GO TO 2
         IKI=NRK(1,IK)
         AMSS=5.D+00
         K11=K1(IKI)
         K22=K2(IKI)
         DO 3 IK1=K11,K22
            IN=NZK(IK1,1)
            AMS=AM(IN)
            IN=NZK(IK1,2)
            IF (IN.GT.0) AMS=AMS+AM(IN)
            IN=NZK(IK1,3)
            IF (IN.GT.0) AMS=AMS+AM(IN)
            IF (AMS.LT.AMSS) AMSS=AMS
    3    CONTINUE
         IF ( UMOO .LT. AMSS ) UMOO=AMSS
         THRESH (IK) = UMOO
    2 CONTINUE
      RETURN
      END
+DECK,  CALUMV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*$ CREATE CALUMV.FOR
*COPY CALUMV
*=== calumv ===========================================================*
      SUBROUTINE CALUMV (N,ITTA)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, REAC.
+CDE, REDVER.
+CDE, SPLIT.
*
C*** C.M.S.-ENERGY AND REACTION CHANNEL THRESHOLD CALCULATION
****  INTEGER * 2 ICH,IBAR,K1,K2,NZK,NRK
**** *,IEII,IKII,NURE
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
      IRE=NURE(N,ITTA/8+1)
      IEO=IEII (IRE)+1
      IEE=IEII (IRE+1)
      AM1  = AM (N)
      AM12 = AM1**2
      AM2  = AM (ITTA)
      AM22 = AM2**2
*  +-------------------------------------------------------------------*
*  |  Loop on the momentum/invariant mass tabulation
      DO 1 IE=IEO,IEE
         PLAB2=PLABF(IE)**2
         ELAB=SQRT(AM12+AM22+2.D+00*SQRT(PLAB2+AM12)*AM2)
         UMO(IE)=ELAB
    1 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      IKO=IKII(IRE)+1
      IKE=IKII(IRE +1)
      UMOO=UMO(IEO)
*  +-------------------------------------------------------------------*
*  |  Loop on the exit channels
      DO 2 IK=IKO,IKE
         INRK1=NRK(1,IK)
         INRK2=NRK(2,IK)
*  |  +----------------------------------------------------------------*
*  |  |  One resonance exit channel
         IF (INRK2.LE.0) THEN
            IF ( GA (INRK1) .GT. ANGLGB ) THEN
               AM111 = AM(INRK1) - 5.D+00 * GA (INRK1)
            ELSE
               AM111 = 0.D+00
            END IF
            INRKK=K1(INRK1)
            AMSS =5.D+00
            INRKO=K2(INRK1)
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Loop over the decay channels
            DO 3 INKK=INRKK,INRKO
               INZK1=NZK(INKK,1)
               INZK2=NZK(INKK,2)
               INZK3=NZK(INKK,3)
*  |  |  |  We allow for a width of at least 1 gamma for resonances !!!
               AMS=AM(INZK1)+AM(INZK2)-GA(INZK1)-GA(INZK2)
               IF (INZK3 .GT. 0) AMS=AMS+AM(INZK3)-GA(INZK3)
               IF (AMSS  .GT.AMS) AMSS=AMS
    3       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            AMS=MAX(AMSS,AM111)
            IF (AMS.LT.UMO(IEO)) AMS=UMO(IEO)
            THRESH(IK)=AMS
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
    2 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      RETURN
      END
+DECK,  CHANWT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE CHANWT.FOR
*COPY CHANWT
*=== CHANWT ===========================================================*
      SUBROUTINE CHANWT

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
+CDE, DECAYC.
+CDE, PART.
      COMMON/FKPRUN/ISYS
      DIMENSION HWT(IDMAX9)
C  CHANGE OF WEIGHTS WT FROM ABSOLUT VALUES INTO THE SUM OF WT OF A DEC.
      DO 3  J=1,IDMAX9
    3 HWT(J)=0.D0
      DO 1  I=1,IDMAX8
      IK1=K1(I)
      IK2=K2(I)
      HV=0.D0
      DO 2 J=IK1,IK2
      HV=HV+WT(J)
      HWT(J)=HV
*
*  Modified by A.Ferrari to avoid false error messages
*
*     IF(HWT(J).GT.1.D0) WRITE(ISYS,101) HWT(J),J,I,IK1
      IF(HWT(J) - 1.D0 .GT. 1.D-14) WRITE(ISYS,101) HWT(J),J,I,IK1
    2 CONTINUE
  101 FORMAT(2X,15H ERROR IN HWT =,1F10.5,8H J,I,K1=,3I5)
    1 CONTINUE
      DO 4  J=1,IDMAX9
    4 WT(J)=HWT(J)
      RETURN
      END
+DECK,  COREVT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*$ CREATE COREVT.FOR
*COPY COREVT
*                                                                      *
*=== corevt ===========================================================*
*                                                                      *
      SUBROUTINE COREVT ( ZZTAR, BBTAR, KPROJ, PPROJ, EKE )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*    Last change   on  07-may-92   by   Alfredo Ferrari, INFN-Milan    *
*                                                                      *
*    This version has been developed by A. Ferrari trying to take into *
*    account a few papers about correlations between projectile colli- *
*    sions and secondary collisions. An improved (but slower) version  *
*    is going on.                                                      *
*    This subroutine correlates intranuclear cascade with the number   *
*    of projectile collisions sampled in the nucleus                   *
*                                                                      *
*              input parameters:                                       *
*      bbtar - atomic number of the target                             *
*      kproj - type of the projectile                                  *
*      pproj - momentum of the projectile                              *
*                                                                      *
*              output parameters (in common corinc)                    *
*      frainc - reduction factor for intran. cascade energy,           *
*               inc. correlat.                                         *
*      nsea+1 - number of high energy collisions in the nucleus        *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, CORINC.
+CDE, NUCDAT.
+CDE, PAREVT.
+CDE, PART.
+CDE, QQUARK.
+CDE, RESNUC.
*
      PARAMETER ( PIO2   = 0.5D+00 * PIPIPI )
      PARAMETER ( SQPI   = 1.772453850905516 D+00 )
      PARAMETER ( SQPIT3 = 3.D+00 * SQPI )
      PARAMETER ( TWOSQT = 2.828427124746190 D+00 )
      PARAMETER ( ECUTRF = 100.0 D+00 )
      PARAMETER ( UMOREF = 13.83 D+00 )
      PARAMETER ( FINCFR = 1.0 D+00 )
      PARAMETER ( ANUC00 = 1.4 D+00 )
      PARAMETER ( RAOB00 = 3.0 D+00 )
      PARAMETER ( ACPAR0 = 0.5D+00 - 0.5D+00 * ( ANUC00 - 1.D+00 )
     &                   / RAOB00 )
*
      COMMON / FKNUCO / HELP (2), HHLP (2), FTVTH (2), FINCX (2),
     &                  EKPOLD (2), BBOLD, ZZOLD, SQROLD, ASEASQ,
     &                  FSPRED, FEX0RD
      DIMENSION KPA (39)
      DIMENSION FRA(2,110)
      REAL RNDM(3)
      SAVE BBONE, FRA, KPA, XIXIXI, ANCOSQ
      LOGICAL LNUCNW, LUFFA
      DATA BBONE / 1.D+00 /
      DATA KPA/1,1,3,3,3,3,3,2,2,3,3,3,3,3,3,3,2,2,3,1,1,2,3,3,3,3,
     &         3,3,3,3,1,2,1,2,2,1,1,1,1/
*  Reduction factors for intran. cascade energy, taken from Alsmiller
*  Incoming baryons
      DATA (FRA(1,I), I=1,107) / .048D0,.076D0,0.10D0,.12D0,
     * .14D0,.16D0,.17D0,.19D0,.21D0,.22D0,.24D0,
     1 .25D0,.26D0,.28D0,.29D0,.30D0,.315D0,.33D0,.34D0,
     * .35D0,.36D0,.38D0,.39D0,.40D0,.41D0,.42D0,
     2 .43D0,.44D0,.46D0,.47D0,.48D0,.49D0,.50D0,.51D0,
     * .52D0,.53D0,.54D0,.55D0,.56D0,.57D0,.58D0,.59D0,
     3 .60D0,.61D0,.62D0,.63D0,.635D0,.64D0,.65D0,.66D0,
     * .67D0,.675D0,.68D0,.69D0,.70D0,.71D0,.715D0,
     4 .72D0,.725D0,.73D0,.735D0,.74D0,.75D0,.755D0,
     * .76D0,.767D0,.77D0,.77D0,.775D0,.78D0,.783D0,
     5 .786D0,.79D0,.795D0,.80D0,.805D0,.81D0,.812D0,
     * .815D0,.82D0,.822D0,.824D0,.825D0,.825D0,.83D0,
     6 .832D0,.834D0,.836D0,.838D0,.84D0,.843D0,.836D0,
     * .849D0,.852D0,.855D0,.856D0,.857D0,.858D0,
     7 .859D0,.860D0,.862D0,.864D0,.866D0,.868D0,.870D0,
     * .872D0,.874D0/
*  Incoming mesons
      DATA (FRA(2,I), I=1,63) / .048D0,.076D0,0.10D0,.12D0,
     * .14D0,.16D0,.17D0,.19D0,.21D0,.22D0,.24D0,
     1 .25D0,.262D0,.274D0,.285D0,.295D0,.305D0,.315D0,
     * .327D0,.340D0,.345D0,.350D0,.360D0,
     2 .370D0,.380D0,.385D0,.390D0,.398D0,.406D0,.415D0,
     * .420D0,.425D0,.430D0,.435D0,.440D0,.446D0,
     3 .452D0,.458D0,.464D0,.470D0,.474D0,.478D0,.482D0,
     * .486D0,.490D0,.495D0,.500D0,.505D0,.510D0,
     4 .515D0,.519D0,.523D0,.526D0,.520D0,.533D0,.537D0,
     * .540D0,.543D0,.547D0,.550D0,.555D0,.559D0,
     5 .5625D0 /
*
*   The calculation of number of collisions inside nucleus is moved
*   from subroutine nucevt; nsea is stored in common corinc
*
      IBPROJ = IBAR (KPROJ)
*  Get the "paprop" index
      IJ     = KPTOIP (KPROJ)
      IJJ    = KPA    (IJ)
*  +-------------------------------------------------------------------*
*  |                                        Incoming baryons
      IF ( IBPROJ .NE. 0 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( IBTAR .LE. 107 ) THEN
            FRAC = FRA ( 1, IBTAR )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF (IBTAR .LE. 206) THEN
            FRAC = 0.739D+00 + 0.00126D+00 * BBTAR
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            FRAC = 1.D+00
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |   This is a very simple patch to slightly increase the cascade
*  |  |   yield at low energies for antibaryons. The factor 0.5 to
*  |  |   take into account very roughly that not all interactions will
*  |  |   result in complete annihilation
         IF ( IBPROJ .LT. 0 ) THEN
            EKEFF = EKE + 0.5D+00 * AMDISC (KPROJ)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            EKEFF = EKE
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         STRRED = 0.D+00
*  |  +----------------------------------------------------------------*
*  |  |  Apply a 50 % reduction in the intranuclear cascade probability
*  |  |  for each s/sbar quark of the projectile
         DO 100 IQ = 1,3
            STRRED = STRRED + 0.1666666666666667D+00
     &             * ABS ( IQSCHR ( MQUARK (IQ,IJ) ) )
  100    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |   Make the strangeness reduction effective only at low energies
*  |   (where secondaries are few ==> the s composition of the projecti-
*  |    le is relevant)
         STRRED = STRRED * AM (KPROJ) / ( EKE + AM (KPROJ) )
         FRAC   = ( 1.D+00 - STRRED ) * FRAC
*  |
*  +-------------------------------------------------------------------*
*  |                                         Incoming mesons
      ELSE
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( IBTAR .LE. 63 ) THEN
            WEIGH1 = 1.D+00 / ( 1.D+00 + ( 60.D+00 / EKE ) )
            FRAC = FRA ( 2, IBTAR ) * ( ( 1.D+00 + 0.1333D+00 * MAX (
     &             0.D+00, BBTAR - 35.D+00 ) / 28.D+00 ) * WEIGH1 +
     &             1.D+00 - WEIGH1 )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( IBTAR .LE. 107 ) THEN
            WEIGH1 = 1.D+00 / ( 1.D+00 + ( 60.D+00 / EKE ) )
            FRAC = ( 0.75D+00 + WEIGH1 * 0.1D+00 ) * FRA ( 1, IBTAR )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( IBTAR .LE. 206 ) THEN
            WEIGH1 = 1.D+00 / ( 1.D+00 + ( 60.D+00 / EKE )    )
            FRAC = ( 0.6279D+00 + 0.001077D+00 * BBTAR ) * WEIGH1
     &           + ( 1.D+00 - WEIGH1 ) * ( 0.554D+00 + 0.00095D+00
     &           * BBTAR )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            WEIGH1 = 1.D+00 / ( 1.D+00 + ( 60.D+00 / EKE )    )
            FRAC = 0.75D+00 + 0.1D+00 * WEIGH1
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         EKEFF = EKE
         STRRED = 0.D+00
*  |  +----------------------------------------------------------------*
*  |  |  Apply a 50 % reduction in the intranuclear cascade probability
*  |  |  for each s/sbar quark of the projectile
         DO 150 IQ = 1,2
            STRRED = STRRED + 0.25D+00
     &             * ABS ( IQSCHR ( MQUARK (IQ,IJ) ) )
  150    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |   Make the strangeness reduction effective only at low energies
*  |   (where secondaries are few ==> the s composition of the projecti-
*  |    le is relevant)
         STRRED = STRRED * AM (KPROJ) / ( EKE + AM (KPROJ) )
         FRAC   = ( 1.D+00 - STRRED ) * FRAC
      END IF
*  |
*  +-------------------------------------------------------------------*
*  The following is a reduction factor to bring Hannes's parametri-
*  zations for the average energy carried by cascade nucleons in
*  better agreement with experimental data
      FSPRED = FSPRD0 + ( 1.D+00 - FSPRD0 ) * MAX ( 10.D+00 - EKE,
     &         0.D+00 ) / 10.D+00
      FEX0RD = FSPRD0**ABS(IBPROJ)
*  +-------------------------------------------------------------------*
*  | Check whether it is the same target nucleus of the last call
      IF ( BBTAR .NE. BBOLD .OR. ZZTAR .NE. ZZOLD ) THEN
         LNUCNW = .TRUE.
         SQRAMS = SQRT ( BBTAR )
         ATO1O3 = BBTAR**0.3333333333333333D+00
*        ZTO1O3 = ZZTAR**0.3333333333333333D+00
         BBOLD  = BBTAR
         ZZOLD  = ZZTAR
         SQROLD = SQRAMS
         HKAP  = BBTAR**2 / ( ZZTAR**2 + ( BBTAR - ZZTAR )**2 )
         HHLP (1) = ( HKAP * ZZTAR )**0.3333333333333333D+00 / ATO1O3
         HHLP (2) = ( HKAP * ( BBTAR - ZZTAR ) )
     &              **0.3333333333333333D+00 / ATO1O3
         RDSNUC = R0NUCL * ATO1O3
         RDSCOU = RCCOUL * ATO1O3
         FLKCOU = DOST ( 1, ZZTAR )
*  |  Coulomb barrier "a la Evap"
         VEFFNU (1) = FLKCOU * COULPR * ZZTAR / RDSCOU
         VEFFNU (2) = 0.D+00
         AMRCAV = MAX ( 1.D+00, ( BBTAR - 2.D+00 ) ) * AMUC12
         AMRCSQ = AMRCAV * AMRCAV
*  |  +----------------------------------------------------------------*
*  |  |
         DO 3000 I = 1, 2
            PFRMMX (I) = HHLP (I) * APFRMX
            P2HELP     = PFRMMX (I)**2
            EFRMMX (I) = SQRT ( P2HELP + AMNUSQ (I) ) - AMNUCL (I)
            EFRMAV (I) = 0.3D+00 * P2HELP / AMNUCL (I) * ( 1.D+00
     &                 - P2HELP / ( 5.6D+00 * AMNUSQ (I) ) )
            ERCLAV (I) = 0.3D+00 * P2HELP / AMRCAV * ( 1.D+00
     &                 - P2HELP / ( 5.6D+00 * AMRCSQ ) )
            V0WELL (I) = EFRMMX (I) + EBNDNG (I)
            VEFFNU (I) = VEFFNU (I) + V0WELL (I)
            ERCLMX     = 0.5D+00 * P2HELP / AMRCAV * ( 1.D+00
     &                 - 0.25D+00 * P2HELP / AMRCSQ )
            EKMNNU (I) = VEFFNU (I) + EBNDNG (I)
     &                 - EFRMMX (I) + ERCLMX
            EKMXNU (I) = VEFFNU (I) + EBNDNG (I)
            EKMNAV (I) = VEFFNU (I) + EBNDNG (I)
     &                 - EFRMAV (I) + ERCLAV (I)
            ESWELL (I) = EBNDNG (I) + V0WELL (I)
     &                 - EFRMAV (I) + ERCLAV (I)
            FTVTH  (I) = ( EKMNNU (I) / EFRMMX (I) )**3
            FTVTH  (I) = 0.4D+00 * SQRT  ( FTVTH (I) )
            FINCUP (I) = AKEKA ( I, EKEFF, BBTAR ) * FSPRED
3000     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
*  | It is the same target nucleus of the last call to Nucevv/Nucriv
      ELSE
         LNUCNW = .FALSE.
         SQRAMS = SQROLD
         FINCUP (1) = AKEKA ( 1, EKEFF, BBTAR ) * FSPRED
         FINCUP (2) = AKEKA ( 2, EKEFF, BBTAR ) * FSPRED
      END IF
*  |
*  +-------------------------------------------------------------------*
      CALL NIZL (IJ, BBTAR, EKE, PPROJ, SIHA, ZLA)
      CALL NIZL (IJ, BBONE, EKE, PPROJ, SIHN, ZLP)
      ANUAV = BBTAR  * SIHN / SIHA
*  Anuav= average number of collisions in nucleus
      ANUSEA = ANUAV - 1.D+00
*  +-------------------------------------------------------------------*
*  |                Call the function sampling the distribution for the
*  |                number of high energy collisions
      IF ( ANUSEA .GT. 0.D+00 .AND. PPROJ .GT. 5.D+00 ) THEN
         EXPLAM = EXP ( -ANUSEA )
         NSEA   = NUDISV ( ANUAV, IBPROJ, EXPLAM, ASEASQ, APOWER,
     &                     PRZERO ) - 1
         NSEA   = MIN ( NSEA, IBTAR - 1 )
         LUFFA  = .FALSE.
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         ASEASQ = 0.D+00
         ANUSEA = 0.D+00
         APOWER = 1.D+00
         ANUAV  = 1.D+00
         PRZERO = 1.D+00
         ANUCSQ = 1.D+00
         NSEA   = 0
         RATOLD = 0.D+00
         ACFACT = 0.D+00
         BCFACT = 2.D+00
         ANUC11 = ANUC00
         ANUCOR = ANUC00
         ACPARM = 0.D+00
         RRPCO  = 0.D+00
         LUFFA  = .TRUE.
      END IF
*  |
*  +-------------------------------------------------------------------*
      NSEALD = NSEA
*  +-------------------------------------------------------------------*
*  |  Check if the parameterized intranuclear cascade is requested
      IF ( LINCTV ) THEN
         IF ( LUFFA ) GO TO 3500
         CALL GRNDM(RNDM,1)
         RRPCR = RNDM (1)
*  |  +----------------------------------------------------------------*
*  |  |              Check for negative <n_sea^2>
         IF ( ASEASQ .LT. 0.D+00 ) THEN
            ANUCOR = ANUC00 / ( 1.D+00 + 2.D+00 / PPROJ )
            ASEASQ = ANUCOR * ANUAV**2 - 2.D+00 * ANUAV + 1.D+00
            ANUCSQ = ANUCOR * ANUAV**2
            ACPARM = ACPAR0
            ANUC11 = ANUC00
            PRZERO = EXPLAM
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            ANUCSQ = ASEASQ + 2.D+00 * ANUAV - 1.D+00
            ANUC11 = ANUCSQ / ANUAV**2
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if a power different from 2 must be used for the
*  |  |  |  cascade particle distributions
*  |  |  |  Power = 2:
            IF ( .NOT. LPOWER ) THEN
               APOWER = ANUCSQ
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               IPOWER = NINT (-DPOWER)
               IF ( IPOWER .EQ. 17 ) THEN
                  FEX0RD = FEX0RD * FSPRD0
               ELSE IF ( IPOWER .EQ. 8 .OR. IPOWER .EQ. 1 .OR. IPOWER
     &            .GE. 12 ) THEN
                  FEX0RD = FEX0RD * FSPRD0
               END IF
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            ANUC11 = MIN ( ANUC11, ANUC00 )
            ANUCOR = ANUC11 / ( 1.D+00 + 5.D+00 * ( ANUC11 - 1.D+00 )
     &             / PPROJ )
            ANUCOR = MAX ( ANUCOR, ONEONE )
            BBCOF  = ( ANUC11 * ANUAV**2 - 2.D+00 * ANUCOR * ANUAV**2
     &             + 2.D+00 * ANUCOR * ANUAV - 1.D+00 )
            BBCOF  = ABS (BBCOF)
            AACOF  = ANUCOR * ( ANUAV - 1.D+00 )**2
            CCCOF  = - ANUAV**2 * ( ANUC11 - ANUCOR )
            IF ( AACOF - CCCOF .GT. ANGLGB ) THEN
               RRPCO = 0.5D+00 * ( - BBCOF + SQRT ( BBCOF**2 - 4.D+00
     &               * AACOF * CCCOF ) ) / AACOF
            ELSE
               RRPCO = 0.D+00
            END IF
            RRPCO  = MIN ( ONEONE, RRPCO )
            RRPCO  = MAX ( ZERZER, RRPCO )
            RRPCO  = 1.D+00 - RRPCO
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  Supply the fraction of the total kinetic energy to be
*  |  used for intranuclear cascade nucleons
 3500    CONTINUE
         EKUPNU (1) = AINEL (IJJ, 6, EKEFF, BBTAR, SQRAMS) * EKEFF
     &              * FSPRED
         EKUPNU (2) = AINEL (IJJ, 7, EKEFF, BBTAR, SQRAMS) * EKEFF
     &              * FSPRED
         EINCP  = FRAC * EKUPNU (1)
         EINCN  = FRAC * EKUPNU (2)
         FRAMAX = FRAC
*  |  +----------------------------------------------------------------*
*  |  |  Now start Fincup (i) calculation!!!!
         DO 4000 I = 1, 2
            EKPOLD (I) = EKUPNU (I)
            EKUPNU (I) = MAX ( FRAMAX  * EKUPNU (I), EKMXNU (I)/TWOTHI
     &                         , FOUFOU * FINCUP (I) )
            EKUPNU (I) = MIN ( EKUPNU (I), FOUFOU * FINCUP (I) )
            AHELP = - ( EKUPNU (I) - EKMNAV (I) ) / FINCUP (I)
            CHELP = EKMNAV (I) / FINCUP (I)
            DHELP = EKUPNU (I) / FINCUP (I)
            FINC0 = FINCFR + ESWELL (I) / FINCUP (I)
            BHELP = EXP ( AHELP / FINC0 )
            FINCA = FINC0
            FUNCA = - ( CHELP - DHELP * BHELP ) / ( 1.D+00 - BHELP )
            FINCB = 2.D+00 * FINC0
            BHELP = EXP ( AHELP / FINCB )
            FUNCB = FINC0 - FINCB - ( CHELP - DHELP * BHELP ) /
     &            ( 1.D+00 - BHELP )
            ICOU = 1
            FINCLD = FINC0
*  |  |  +-------------------------------------------------------------*
*  |  |  |
3800        CONTINUE
               FINCX (I) = FINCA - FUNCA * ( FINCB - FINCA ) /
     &                   ( FUNCB - FUNCA )
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( ABS ( FINCX (I) - FINCLD ) .GT. 0.03D+00 .AND.
     &              ICOU .LT. 20 ) THEN
                  ICOU   = ICOU + 1
                  FINCLD = FINCX (I)
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( ABS (FUNCA) .LT. ABS (FUNCB) ) THEN
                     FINCB = FINCLD
                     BHELP = EXP ( AHELP / FINCB )
                     FUNCB = FINC0 - FINCB - ( CHELP - DHELP * BHELP
     &                     ) / ( 1.D+00 - BHELP )
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     FINCA = FINCLD
                     BHELP = EXP ( AHELP / FINCA )
                     FUNCA = FINC0 - FINCA - ( CHELP - DHELP * BHELP
     &                     ) / ( 1.D+00 - BHELP )
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  GO TO 3800
*  |  |  |  |
*  |  |  +-<|--<--<--<--<--<
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            ESLOPE (I) = FINCUP (I) * FINCX (I)
            AHELP      = EXP ( - EKPOLD (I) / FINCUP (I) )
            EKNOLD     = FINCUP (I) - EKPOLD (I) * AHELP /
     &                 ( 1.D+00 - AHELP )
            EXMNAV (I) = EXP ( - EKMNAV (I) / ESLOPE (I) )
            EXMNNU (I) = EXP ( - EKMNNU (I) / ESLOPE (I) )
            EXUPNU (I) = EXP ( - EKUPNU (I) / ESLOPE (I) )
            EKINAV (I) = ESLOPE (I) + ( EKMNAV (I) * EXMNAV (I) -
     &                   EKUPNU (I) * EXUPNU (I) ) / ( EXMNAV (I) -
     &                   EXUPNU (I) )
            EKPOLD (I) = EKPOLD (I) * FRAC
            FINCUP (I) = EKINAV (I) / EKNOLD
4000     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         EINCP = EINCP * FINCUP (1)
         EINCN = EINCN * FINCUP (2)
         AGREYP = EINCP / EKINAV (1)
         AGREYN = EINCN / EKINAV (2)
         AGREYT = AGREYP + AGREYN
         CALL GRNDM(RNDM,1)
         RNPCO  = RNDM ( 1 )
*  |  +----------------------------------------------------------------*
*  |  |  Check if we have to sample from a distribution with <n_casc>
*  |  |  prop. <nu^power> or to <nu>
         IF ( RNPCO .LT. RRPCO ) THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Power .ne. 2:
            IF ( LPOWER ) THEN
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  1**Y = 1
               IF ( NSEA .EQ. 0 ) THEN
                  IF ( IPOWER .LT. 7 ) THEN
                     ANCOSQ = 1.D+00
                  ELSE
                     ANCOSQ = FPOWER ( IPOWER, 1, ANUAV )
                  END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  The exponent has a fixed value
               ELSE IF ( DPOWER .GT. 0.D+00 ) THEN
                  ANCOSQ = ( NSEA + 1 )**DPOWER
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  The function Fpower supplies the exponent
               ELSE
                  IF ( IPOWER .LT. 7 ) THEN
                     ANCOSQ = ( NSEA + 1 )**FPOWER ( IPOWER,
     &                          NSEA + 1, ANUAV )
                  ELSE IF ( IPOWER .LT. 11 ) THEN
                     ANCOSQ = ( NSEA + 1 ) * FPOWER ( IPOWER,
     &                        NSEA + 1, ANUAV )
                  ELSE
                     ANCOSQ = ( NSEA + 1 )**FPOWER ( IPOWER,
     &                        NSEA + 1, ANUAV )
                  END IF
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Power = 2:
            ELSE
               ANCOSQ = ( NSEA + 1 )**2
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            XIXIXI = AGREYP / ( AGREYP + APOWER )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            ANCOSQ = NSEA + 1
            XIXIXI = AGREYP / ( AGREYP + ANUAV )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         RRPC0  = ( 1.D+00 - XIXIXI )**ANCOSQ
         RRPCR  = RRPC0
         CALL GRNDM(RNDM,1)
         RNPCR  = RNDM (1)
         IF ( RRPCR .GE. RNPCR ) THEN
            NGREYP = 0
         ELSE
            DO 4600 I = 1, ICHTAR
               RRPC0 = RRPC0 * ( I - 1 + ANCOSQ ) * XIXIXI
     &               / I
               RRPCR = RRPCR + RRPC0
               IF ( RNPCR .LE. RRPCR ) GO TO 4700
 4600       CONTINUE
            I = I - 1
            IF ( BBTAR .GT. 12.D+00 )
     &      WRITE (LUNERR,*)' *** RRPCR,I,NSEA,ANCOSQ*XIXIXI ***',
     &                            RRPCR,I,NSEA,ANCOSQ*XIXIXI
 4700       CONTINUE
            NGREYP = I
         END IF
*  |  +----------------------------------------------------------------*
*  |  |  Check if we have to sample from a distribution with <n_casc>
*  |  |  prop. <nu^power> or to <nu>
         IF ( RNPCO .LT. RRPCO ) THEN
            XIXIXI = AGREYN / ( AGREYN + APOWER )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            ANCOSQ = NSEA + 1
            XIXIXI = AGREYN / ( AGREYN + ANUAV )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         RRNC0  = ( 1.D+00 - XIXIXI )**ANCOSQ
         RRNCR  = RRNC0
*  |  Correlate cascade neutrons to cascade protons:
*  |  No correlation
         CALL GRNDM(RNDM,1)
         RNNCR  = RNDM (1)
         RN1GSC = RNPCR
         RN2GSC = RNNCR
         IF ( RRNCR .GE. RNNCR ) THEN
            NGREYN = 0
         ELSE
            DO 4650 I = 1, IBTAR - ICHTAR
               RRNC0 = RRNC0 * ( I - 1 + ANCOSQ ) * XIXIXI
     &               / I
               RRNCR = RRNCR + RRNC0
               IF ( RNNCR .LE. RRNCR ) GO TO 4750
 4650       CONTINUE
            I = I - 1
            IF ( BBTAR .GT. 12.D+00 )
     &      WRITE (LUNERR,*)' *** RRNCR,I,NSEA,ANCOSQ*XIXIXI ***',
     &                            RRNCR,I,NSEA,ANCOSQ*XIXIXI
 4750       CONTINUE
            NGREYN = I
         END IF
         NGREYT = NGREYN + NGREYP
         NGREYN = 0
         NGREYP = 0
         PROBPR = AGREYP / ( AGREYP + AGREYN )
         DO 4760 I = 1, NGREYT
            CALL GRNDM(RNDM,1)
            RNDPPR = RNDM (1)
            IF ( RNDPPR .LT. PROBPR .AND. NGREYP .LT. ICHTAR )
     &         THEN
               NGREYP = NGREYP + 1
            ELSE IF ( NGREYN .LT. IBTAR - ICHTAR ) THEN
               NGREYN = NGREYN + 1
            ELSE
               NGREYP = NGREYP + 1
            END IF
 4760    CONTINUE
         FRAMAX = FRAC
*  |  The number of grey particles is now correlated to the number
*  |  of high energy collisions
         EINCP = NGREYP * EKINAV (1)
         EINCN = NGREYN * EKINAV (2)
         TVTENT = ( NSEA + 1 ) * ( AV0WEL - AEFRMA )
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         EINCP = 0.D+00
         EINCN = 0.D+00
         EKUPNU (1) = 1.D+01
         EKUPNU (2) = 1.D+01
         ESLOPE (1) = 0.D+00
         ESLOPE (2) = 0.D+00
         EKINAV (1) = 1.D+10
         EKINAV (2) = 1.D+10
         FRAC  = 0.D+00
         PCR   = 1.D+00
         FRAINC = 0.D+00
         TVTENT = 0.D+00
      END IF
*  |
*  +-------------------------------------------------------------------*
      PCROLD = PCR
      EKTRIA = EKE - EINCP - EINCN - TVTENT
      IF ( EKTRIA .LE. 0.5D+00 * EKE ) THEN
         EKTRIA = 0.5D+00 * EKE
      END IF
      ETRIAL = EKTRIA + AM (KPROJ)
*  +-------------------------------------------------------------------*
*  |
      IF ( ETRIAL .LT. ECUTRF ) THEN
         PTRIAL = SQRT ( ETRIAL**2 - AM (KPROJ)**2 )
         XCUTFF =  0.3D+00 * ETHSEA / EKTRIA
*        XCUTFF =  0.3D+00 / PTRIAL
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         PTRIAL = ETRIAL
         UMO = SQRT ( 2.D+00*AM(1) * ETRIAL + AM (KPROJ)**2 + AM(1)**2 )
         XCUTFF = 0.30D+00 * ETHSEA * UMO / ( UMOREF * EKTRIA )
      END IF
*  |
*  +-------------------------------------------------------------------*
 200  CONTINUE
      IF ( NSEA .EQ. 0 ) GO TO 1000
* *** Sample X-values of nsea sea-quark-antiquark pairs
      NC3 = 0
*  +-------------------------------------------------------------------*
*  |
 300  CONTINUE
* *** Sea distribution X**(-1)*(1-X)**5
         NC3 = NC3 + 1
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( NC3 .GT. 10 ) THEN
            NSEA = NSEA - 1
            GO TO 200
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         XO = 1.D+00
         UNOSEA = 2.0D+00
         GAMSEA = 0.05D+00
         XSEAMX = 1.0D+00
*  |  +----------------------------------------------------------------*
*  |  |
         DO 400 I=1,NSEA
            NCOU= 0
  22        CONTINUE
            NCOU = NCOU + 1
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( NCOU .LT. 11 ) THEN
               XSEA(I) = BETRST ( GAMSEA, UNOSEA, XCUTFF, XSEAMX )
               IF ( XSEA(I) .LT. XCUTFF ) GO TO 22
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            NCOU = 0
  23        CONTINUE
            NCOU = NCOU + 1
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( NCOU .LT. 11 ) THEN
               XASEA(I) = BETRST ( GAMSEA, UNOSEA, XCUTFF, XSEAMX )
               IF ( XASEA(I) .LT. XCUTFF ) GO TO 23
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            XO = XO * ( 1.D+00 - XSEA (I) - XASEA(I) )
 400     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( XO * PTRIAL .LT. 4.D+00 ) THEN
            NSEA = NSEA - 1
            IF ( NSEA  .LE. 0 ) GO TO 1000
            GO TO 300
*  |  |
*  +--+--<--<--<--<--< go to resample
*  |  |
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         ILOW = 0
*  |  +----------------------------------------------------------------*
*  |  |
         DO 500 I = 1, NSEA
            EMSEA = EKTRIA * ( XSEA (I) + XASEA (I) )
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( EMSEA .LE. ETHSEA + AM (23) ) THEN
               ILOW = ILOW + 1
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( I .LT. NSEA ) THEN
                  II = I + 1
                  XSEA  (II) = XSEA  (II) + XSEA  (I)
                  XASEA (II) = XASEA (II) + XASEA (I)
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE IF ( I - ILOW .GT. 0 ) THEN
                  II = I - ILOW
                  EKTRIA = EKTRIA * ( 1.D+00 - XSEA(I) - XASEA (I) )
                  XSEA  (II) = XSEA  (II) + XSEA  (I)
                  XASEA (II) = XASEA (II) + XASEA (I)
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               XSEA  (I-ILOW) = XSEA  (I)
               XASEA (I-ILOW) = XASEA (I)
               EKTRIA = EKTRIA * ( 1.D+00 - XSEA(I) - XASEA (I) )
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 500     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         NSEA = NSEA - ILOW
*  |
*  +-------------------------------------------------------------------*
1000  CONTINUE
*  +-------------------------------------------------------------------*
*  |     Now sample the target nucleons for the high energy collisions
      DO 1200 I = 1, NSEA + 1
         ZAPU = ZNOW / ANOW
*  |  +----------------------------------------------------------------*
*  |  |  Wounded nucleon selection:
*  |  |  Kt is the index of the target nucleon (1=proton, 8=neutron)
         CALL GRNDM(RNDM,1)
         IF ( RNDM(1) .LE. ZAPU ) THEN
            IJTARG (I) = 1
            ZNOW  = ZNOW - 1.D0
            KTARP = KTARP + 1
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IJTARG (I) = 8
            KTARN = KTARN + 1
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         ANOW   = ANOW - 1.D0
1200  CONTINUE
*  |
*  +-------------------------------------------------------------------*
      ZNCOLL = KTARP
      ANCOLL = NSEA + 1
      AHELP  = EKMNNU (1) / ESLOPE (1)
      AHELP  = AHELP * FTVTH (1) * ( 1.D+00 + 0.3333333333333333D+00
     &       * AHELP ) / ( 1.D+00 - EXUPNU (1) )
      AHELPP = AHELP
      AHELP  = EKMNNU (2) / ESLOPE (2)
      AHELP  = AHELP * FTVTH (2) * ( 1.D+00 + 0.3333333333333333D+00
     &       * AHELP ) / ( 1.D+00 - EXUPNU (2) )
      AHELPN = AHELP
      FEXTRA = 0.3D+00 * AGREYP
      TVCHCP = EFRMMX (1) - EFRMAV (1) + EBNDNG (1)
      TVGRYP = AHELPP * ( EINCP + FEXTRA * EKINAV (1) ) * AGREYP
     &       / ( AGREYP + FEXTRA ) * FEX0RD
      NHELP  = INT ( TVGRYP / TVCHCP )
      TVGRE0 = NHELP * TVCHCP
      PROB0  = ( TVGRYP - TVGRE0 ) / TVCHCP
      CALL GRNDM(RNDM,1)
      IF ( RNDM (1) .LT. PROB0 ) THEN
         CALL GRNDM(RNDM,3)
         P2HELP = ( PFRMMX (1) * MAX ( RNDM (1),
     &              RNDM (2), RNDM (3) ) )**2
         TVGRYP = 0.5D+00 * P2HELP / AMNUCL (1) * ( 1.D+00
     &          - 0.25D+00 * P2HELP / AMNUSQ (1) )
         TVGRYP = EFRMMX (1) - TVGRYP + EBNDNG (1) + TVGRE0
      ELSE
         TVGRYP = TVGRE0
      END IF
      FEXTRA = 0.3D+00 * AGREYN
      TVCHCN = EFRMMX (2) - EFRMAV (2) + EBNDNG (2)
      TVGRYN = AHELPN * ( EINCN + FEXTRA * EKINAV (2) ) * AGREYN
     &       / ( AGREYN + FEXTRA ) * FEX0RD
      NHELP  = INT ( TVGRYN / TVCHCN )
      TVGRE0 = NHELP * TVCHCN
      PROB0  = ( TVGRYN - TVGRE0 ) / TVCHCN
      CALL GRNDM(RNDM,1)
      IF ( RNDM (1) .LT. PROB0 ) THEN
         CALL GRNDM(RNDM,3)
         P2HELP = ( PFRMMX (2) * MAX ( RNDM (1),
     &              RNDM (2), RNDM (3) ) )**2
         TVGRYN = 0.5D+00 * P2HELP / AMNUCL (2) * ( 1.D+00
     &          - 0.25D+00 * P2HELP / AMNUSQ (2) )
         TVGRYN = EFRMMX (2) - TVGRYN + EBNDNG (2) + TVGRE0
      ELSE
         TVGRYN = TVGRE0
      END IF
      TVGRE0 = TVGRYP + TVGRYN
      TVGREY = 0.D+00
      NDIFFT = NGREYT - NINT (ANOW)
      IF ( NINT (ZNOW) - NGREYP .LT. 0 ) THEN
         NDIFFP = NGREYP - NINT ( ZNOW )
         NGREYP = NGREYP - NDIFFP
         EINCP  = EINCP - NDIFFP * EKINAV (1)
         NGREYN = NGREYN + NDIFFP
         EINCN  = EINCN + NDIFFP * EKINAV (2)
         IF ( NINT (ANOW-ZNOW) - NGREYN .LT. 0 ) THEN
            NDIFFN = NGREYN - NINT ( ANOW - ZNOW )
            NGREYN = NGREYN - NDIFFN
            EINCN  = EINCN - NDIFFN * EKINAV (2)
         END IF
      ELSE IF ( NINT (ANOW-ZNOW) - NGREYN .LT. 0 ) THEN
         NDIFFN = NGREYN - NINT ( ANOW - ZNOW )
         NGREYN = NGREYN - NDIFFN
         EINCN  = EINCN - NDIFFN * EKINAV (2)
         NGREYP = NGREYP + NDIFFN
         EINCP  = EINCP + NDIFFN * EKINAV (1)
         IF ( NINT (ZNOW) - NGREYP .LT. 0 ) THEN
            NDIFFP = NGREYP - NINT ( ZNOW )
            NGREYP = NGREYP - NDIFFP
            EINCP  = EINCP - NDIFFP * EKINAV (1)
         END IF
      END IF
      NGREYT = NGREYP + NGREYN
      RETURN
      END
+DECK,  CORRIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*$ CREATE CORRIN.FOR
*COPY CORRIN
*                                                                      *
*=== corrin ===========================================================*
*                                                                      *
      SUBROUTINE CORRIN ( ZZTAR, BBTAR, KPROJ, PPROJ, EKE )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on  10  may  1990    by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 23-mar-93     by    Alfredo Ferrari               *
*                                                                      *
*    This version has been developed by A. Ferrari starting from the   *
*    the one by J. M. Zazula: it includes a few differences mainly in  *
*    the correlation since now we try to get the excitation energy     *
*    from a correct energy balance                                     *
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, CORINC.
+CDE, NUCDAT.
+CDE, PAREVT.
+CDE, PART.
+CDE, RESNUC.
      PARAMETER ( ALFMAX = 5.00D+00 )
      PARAMETER ( FINCFR = 1.00D+00 )
      PARAMETER ( TMNOLD = 0.02D+00 )
      COMMON / FKNUCO / HELP (2), HHLP (2), FTVTH (2), FINCX (2),
     &                  EKPOLD (2), BBOLD, ZZOLD, SQROLD, ASEASQ,
     &                  FSPRED, FEX0RD
      DIMENSION KPA (26)
      DIMENSION FRA(2,110), ESLOLD (2), AVMULT (2), EXDUMM (2),
     &          V0WSAV (2), VEWSAV (2)
      REAL RNDM(3)
      LOGICAL LSTOP, LNUCNW, LLLIN, LLPOW
      SAVE FRA, FRAC, FRAC0, FRAMAX, KPA, IJJ, LSTOP, V0WSAV, VEWSAV
      DATA KPA/1,1,3,3,3,3,3,2,2,3,3,3,3,3,3,3,2,2,3,1,1,2,3,3,3,3/
*
*  Reduction factors for intran. cascade energy, taken from Alsmiller
*  Incoming baryons
      DATA (FRA(1,I), I=1,107) / .048D0,.076D0,0.10D0,.12D0,
     * .14D0,.16D0,.17D0,.19D0,.21D0,.22D0,.24D0,
     1 .25D0,.26D0,.28D0,.29D0,.30D0,.315D0,.33D0,.34D0,
     * .35D0,.36D0,.38D0,.39D0,.40D0,.41D0,.42D0,
     2 .43D0,.44D0,.46D0,.47D0,.48D0,.49D0,.50D0,.51D0,
     * .52D0,.53D0,.54D0,.55D0,.56D0,.57D0,.58D0,.59D0,
     3 .60D0,.61D0,.62D0,.63D0,.635D0,.64D0,.65D0,.66D0,
     * .67D0,.675D0,.68D0,.69D0,.70D0,.71D0,.715D0,
     4 .72D0,.725D0,.73D0,.735D0,.74D0,.75D0,.755D0,
     * .76D0,.767D0,.77D0,.77D0,.775D0,.78D0,.783D0,
     5 .786D0,.79D0,.795D0,.80D0,.805D0,.81D0,.812D0,
     * .815D0,.82D0,.822D0,.824D0,.825D0,.825D0,.83D0,
     6 .832D0,.834D0,.836D0,.838D0,.84D0,.843D0,.836D0,
     * .849D0,.852D0,.855D0,.856D0,.857D0,.858D0,
     7 .859D0,.860D0,.862D0,.864D0,.866D0,.868D0,.870D0,
     * .872D0,.874D0/
*  Incoming mesons
      DATA (FRA(2,I), I=1,63) / .048D0,.076D0,0.10D0,.12D0,
     * .14D0,.16D0,.17D0,.19D0,.21D0,.22D0,.24D0,
     1 .25D0,.262D0,.274D0,.285D0,.295D0,.305D0,.315D0,
     * .327D0,.340D0,.345D0,.350D0,.360D0,
     2 .370D0,.380D0,.385D0,.390D0,.398D0,.406D0,.415D0,
     * .420D0,.425D0,.430D0,.435D0,.440D0,.446D0,
     3 .452D0,.458D0,.464D0,.470D0,.474D0,.478D0,.482D0,
     * .486D0,.490D0,.495D0,.500D0,.505D0,.510D0,
     4 .515D0,.519D0,.523D0,.526D0,.520D0,.533D0,.537D0,
     * .540D0,.543D0,.547D0,.550D0,.555D0,.559D0,
     5 .5625D0 /
*
      IBPROJ = IBAR (KPROJ)
      IJJ    = KPA  (KPROJ)
      ANUAV  = 1.D+00
      ANCOLL = 1.D+00
      ANUSEA = 1.D+00
      NSEA   = 0
      LSTOP = .FALSE.
*  +-------------------------------------------------------------------*
*  |                                        Incoming baryons
      IF ( IBPROJ .NE. 0 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( IBTAR .LE. 107 ) THEN
            FRAC = FRA ( 1, IBTAR )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF (IBTAR .LE. 206) THEN
            FRAC = 0.739D+00 + 0.00126D+00 * BBTAR
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            FRAC = 1.D+00
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
*  |                                         Incoming mesons
      ELSE
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( IBTAR .LE. 63 ) THEN
            FRAC = FRA ( 2, IBTAR ) * ( 1.D+00 + 0.1333D+00 * MAX (
     &             0.D+00, BBTAR - 35.D+00 ) / 28.D+00 )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( IBTAR .LE. 107 ) THEN
            FRAC = 0.85D+00 * FRA ( 1, IBTAR )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( IBTAR .LE. 206 ) THEN
            FRAC = 0.6279D+00 + 0.001077D+00 * BBTAR
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            FRAC = 0.85D+00
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      IF ( BBTAR .NE. BBOLD .OR. ZZTAR .NE. ZZOLD ) THEN
         LNUCNW = .TRUE.
*  |  Supply the fraction of the total kinetic energy to be
*  |  used for intranuclear cascade nucleons
         SQRAMS = SQRT ( BBTAR )
         ATO1O3 = BBTAR**0.3333333333333333D+00
*        ZTO1O3 = ZZTAR**0.3333333333333333D+00
         HKAP   = BBTAR**2 / ( ZZTAR**2 + ( BBTAR - ZZTAR )**2 )
         HHLP (1) = ( HKAP * ZZTAR )**0.3333333333333333D+00 / ATO1O3
         HHLP (2) = ( HKAP * ( BBTAR - ZZTAR ) )
     &              **0.3333333333333333D+00 / ATO1O3
         RDSNUC = R0NUCL * ATO1O3
         RDSCOU = RCCOUL * ATO1O3
         FLKCOU = DOST ( 1, ZZTAR )
         VEFFNU (1) = COULPR * FLKCOU * ZZTAR / RDSCOU
         VEFFNU (2) = 0.D+00
         AMRCAV = MAX ( 1.D+00, ( BBTAR - 2.D+00 ) ) * AMUC12
         AMRCSQ = AMRCAV * AMRCAV
*  |  +----------------------------------------------------------------*
*  |  |
         DO 3000 I = 1, 2
            PFRMMX (I) = HHLP (I) * APFRMX
            P2HELP     = PFRMMX (I)**2
            EFRMMX (I) = SQRT ( P2HELP + AMNUSQ (I) ) - AMNUCL (I)
            EFRMAV (I) = 0.3D+00 * P2HELP / AMNUCL (I) * ( 1.D+00
     &                 - P2HELP / ( 5.6D+00 * AMNUSQ (I) ) )
            ERCLAV (I) = 0.3D+00 * P2HELP / AMRCAV * ( 1.D+00
     &                 - P2HELP / ( 5.6D+00 * AMRCSQ ) )
            V0WELL (I) = EFRMMX (I) + EBNDNG (I)
            VEFFNU (I) = VEFFNU (I) + V0WELL (I)
            V0WSAV (I) = V0WELL (I)
            VEWSAV (I) = VEFFNU (I)
            ERCLMX     = 0.5D+00 * P2HELP / AMRCAV * ( 1.D+00
     &                 - 0.25D+00 * P2HELP / AMRCSQ )
            EKMNNU (I) = VEFFNU (I) + EBNDNG (I)
     &                 - EFRMMX (I) + ERCLMX
            EKMXNU (I) = VEFFNU (I) + EBNDNG (I)
            EKMNAV (I) = VEFFNU (I) + EBNDNG (I)
     &                 - EFRMAV (I) + ERCLAV (I)
            ESWELL (I) = EBNDNG (I) + V0WELL (I)
     &                 - EFRMAV (I) + ERCLAV (I)
            FTVTH  (I) = ( EKMNNU (I) / EFRMMX (I) )**3
            FTVTH  (I) = 0.4D+00 * SQRT  ( FTVTH (I) )
3000     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         BBOLD  = BBTAR
         ZZOLD  = ZZTAR
         SQROLD = SQRAMS
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         V0WSAV (1) = V0WELL (1)
         VEWSAV (1) = VEFFNU (1)
         V0WSAV (2) = V0WELL (2)
         VEWSAV (2) = VEFFNU (2)
         LNUCNW = .FALSE.
      END IF
*  |
*  +-------------------------------------------------------------------*
      FRAC0 = FRAC
      RETURN
      ENTRY CORSTP ( EKEFF )
         LSTOP = .TRUE.
      ENTRY CORRNC ( EKEFF )
      WEIGH1 = MIN ( 1.D+00, EKEFF / 4.D+00 )
      FRAC   = ( WEIGH1 * 2.5D+00 + ( 1.D+00 - WEIGH1 ) ) * FRAC0
      FRAMAX = 2.5D+00
*  The following is a reduction factor to bring Hannes's parametri-
*  zations for the average energy carried by cascade nucleons in
*  better agreement with experimental data
      FSPRED = FSPRD0 + ( 1.D+00 - FSPRD0 ) * MAX ( 8.D+00 - EKEFF,
     &         0.D+00 ) / 8.D+00
      FSPRED = FSPRED * MIN ( EKEFF / 0.8D+00, 1.D+00 )
      TMPFSP = 1.25D+00 * FSPRD0
      FSPRED = MIN ( FSPRED, TMPFSP )
      AVMULT (1) = FRAC * BNKEKA ( 1, EKEFF, BBOLD, SQROLD )
      AVMULT (2) = FRAC * BNKEKA ( 2, EKEFF, BBOLD, SQROLD )
      EKUPNU (1) = BEKEKA ( 2, EKEFF, BBOLD, SQROLD )
      EKUPNU (2) = BEKEKA ( 3, EKEFF, BBOLD, SQROLD )
      EINCP  = FRAC * EKUPNU (1)
      EINCN  = FRAC * EKUPNU (2)
      EKMAX  = EKEFF - EBNDAV
      EKUPN0 = MAX ( EKUPNU (1), EKUPNU (2) )
*  +-------------------------------------------------------------------*
*  |
      DO 4000 I = 1, 2
         FINCUP (I) = BKEKA ( I, EKEFF, BBOLD )
         RATRAT  =  MIN ( 1.D+00, 0.5D+00 * EKMAX / FINCUP (I) )
         TMPFIN  = 0.5D+00 * EKMAX
         FINCUP (I) = MIN ( FINCUP (I), TMPFIN )
         EKPOLD (I) = EKUPNU (I) * FRAC * RATRAT
         EKUPNU (I) = FINCUP (I)
         TMPEKU     = 1.5D+00 * EKMXNU (I)
         EKUPNU (I) = MAX ( FRAMAX * EKUPNU (I), TMPEKU )
         TMPEKU     = 0.7D+00 * EKEFF
         EKUPNU (I) = MIN ( EKUPNU (I), TMPEKU )
         ESLOLD (I) = MAX ( FINCUP (I), TMNOLD )
         FINCX  (I) = ( ESLOLD (I) + ESWELL (I) ) / ESLOLD (I) * FSPRED
         ESLOPE (I) = MIN ( ESLOLD (I) * FINCX (I), EKMAX )
         AHELP      = EXP ( - EKPOLD (I) / ESLOLD (I) )
         EKNOLD     = ESLOLD (I) - EKPOLD (I) * AHELP /
     &              ( 1.D+00 - AHELP )
         EXMNAV (I) = EXP ( - EKMNAV (I) / ESLOPE (I) )
         EXMNNU (I) = EXP ( - EKMNNU (I) / ESLOPE (I) )
         EXUPNU (I) = EXP ( - EKUPNU (I) / ESLOPE (I) )
         EKINAV (I) = ESLOPE (I) + ( EKMNAV (I) * EXMNAV (I) -
     &                EKUPNU (I) * EXUPNU (I) ) / ( EXMNAV (I) -
     &                EXUPNU (I) )
         FINCUP (I) = AVMULT (I) * EKINAV (I) / EKPOLD (I)
*        FINCUP (I) = EKINAV (I) / EKNOLD
4000  CONTINUE
*  |
*  +-------------------------------------------------------------------*
      EINCP = EKPOLD (1)
      EINCN = EKPOLD (2)
      IF ( LSTOP ) RETURN
*  Power sampling
      LLPOW  = .TRUE.
      LLLIN  = .FALSE.
*  Take into account that a fraction 1/A^2/3 is lost because of
*  peripheral collisions
      PERCOR = ATO1O3 * ATO1O3
      PERCOR = PERCOR / ( PERCOR - 1.D+00 )
      EINCP0 = EINCP  * FINCUP (1) * PERCOR
      EINCN0 = EINCN  * FINCUP (2) * PERCOR
      EINCT  = EINCP0 + EINCN0
* For the other distr,:
      EINCMX = EKEFF - EBNDAV - ( AV0WEL - AEFRMA ) / ( 1.D+00 +
     &         4.D+00 * ( AV0WEL - AEFRMA ) / EKEFF )
      EIUSE  = 0.5D+00 * ( EINCMX + EKMAX )
      AHNORM = 0.D+00
      EINCM0 = - AINFNT
*  +-------------------------------------------------------------------*
*  |  Compute alfa:
      IF ( EINCMX .GT. 2.1D+00 * EINCT ) THEN
         EINFIN = MIN ( 0.95D+00 * EINCMX, ( ALFMAX + 2.D+00 ) * EINCT )
         ALFA   = EINFIN / EINCT - 2.D+00
*  |
*  +-------------------------------------------------------------------*
*  |  Energy interval too small, sample E uniformly
      ELSE
         LLPOW  = .FALSE.
      END IF
*  |
*  +-------------------------------------------------------------------*
      EINCMN = 0.D+00
*  +-------------------------------------------------------------------*
*  | Energy is so small that we cannot produce cascade nucleons,
*  | sample an excitation energy and return
      IF ( EINCMX .LE. EINCMN + 0.25D+00 * EBNDAV ) THEN
         ISAMPL = 50
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         ISAMPL = 0
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Now make the linear sampling for Eincp, Eincn, on [0,Eicnmx]
*  |  according to P(E)dE=A(Efin-E)^a dE
5000  CONTINUE
         ISAMPL = ISAMPL + 1
         CALL GRNDM(RNDM,1)
         IF ( LLPOW ) THEN
            EIHELP = EINFIN * ( 1.D+00 - RNDM (1)**(1.D+00
     &             /(ALFA+1.D+00)) )
         ELSE IF ( LLLIN ) THEN
            EINCMX = EINCM0
            EIHELP = EINFIN - SQRT ( EINFIN**2 - 2.D+00 * RNDM (1)
     &             / AHNORM )
         ELSE
            EIHELP = EINCMX * RNDM (1)
         END IF
*  |  *** end linear sampling ***
         EINCP  = EINCP0 * EIHELP / EINCT
         EINCN  = EINCN0 * EIHELP / EINCT
         AHELP  = EKMNNU (1) / ESLOPE (1)
         AHELP  = AHELP * FTVTH (1) * EINCP * ( 1.D+00 + AHELP *
     &            0.3333333333333333D+00 ) / ( 1.D+00 - EXUPNU (1) )
         TVGRE0 = AHELP
         AHELP  = EKMNNU (2) / ESLOPE (2)
         AHELP  = AHELP * FTVTH (2) * EINCN * ( 1.D+00 + AHELP *
     &            0.3333333333333333D+00 ) / ( 1.D+00 - EXUPNU (2) )
         TVGRE0 = TVGRE0 + AHELP
*  |  +----------------------------------------------------------------*
*  |  |  Energy is so small that we cannot produce cascade nucleons,
*  |  |  sample an excitation energy and return
         IF ( ISAMPL .GE. 50 ) THEN
            CALL GRNDM(RNDM,3)
            PRNDM  = MAX ( RNDM (1), RNDM (2), RNDM (3) )
            TVGRE0 = MAX ( AV0WEL - PRNDM**2 * AEFRMX - EBNDAV, ZERZER )
            EINCP  = 0.D+00
            EINCN  = 0.D+00
            TVGREY = 0.D+00
            RETURN
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  | Changed:
         IF ( EIHELP + TVGRE0 .GE. EIUSE )  GO TO 5000
*  |
*  +--<--<--<--<--<  Resampling!
*  |
*  +-------------------------------------------------------------------*
      PCR    = EIHELP / EINCT
      FRAINC = FRAC * PCR
      TVGREY = 0.D+00
      AGREYP = EINCP / EKINAV (1)
      AGREYN = EINCN / EKINAV (2)
* ==== Discretize the distribution !!! ==== *
      CALL GRNDM(RNDM,2)
      NGREYP = INT ( AGREYP )
      IF ( RNDM(1) .LT. AGREYP - NGREYP ) NGREYP = NGREYP + 1
      NGREYN = INT ( AGREYN )
      IF ( RNDM(2) .LT. AGREYN - NGREYN ) NGREYN = NGREYN + 1
* ====
      AGREYT = AGREYP + AGREYN
      NGREYT = NGREYP + NGREYN
      PPROCS = AGREYP / AGREYT
      NGREYP = 0
      NGREYN = 0
      EINCP  = 0.D+00
      EINCN  = 0.D+00
      IF ( NGREYT .LE. 0 ) GO TO 9000
      ARDUMM = MAX ( 1.D+00, BBOLD - 2.D+00 )
      CALL RBKINI ( 1, .TRUE., EXDUMM, TKDUMM, TSDUMM,
     &               PSDUMM, ARDUMM, TRDUMM )
      V0SAV1 = V0WELL (1)
      V0SAV2 = V0WELL (2)
      VESAV1 = VEFFNU (1)
      VESAV2 = VEFFNU (2)
      V0WELL (1) = V0WSAV (1)
      V0WELL (2) = V0WSAV (2)
      VEFFNU (1) = VEWSAV (1)
      VEFFNU (2) = VEWSAV (2)
      IRETRY = 0
      DO 8000 I = 1, NGREYT
         CALL GRNDM(RNDM,1)
         RNDMPR = RNDM (1)
         ARDUMM = MAX ( 1.D+00, ARDUMM - 1.D+00 )
 7500    CONTINUE
         IF ( RNDMPR .LT. PPROCS ) THEN
            NGREYP = NGREYP + 1
            CALL RBKINI ( 1, .FALSE., EXDUMM, TKDUMM, TSDUMM,
     &                    PSDUMM, ARDUMM, TRDUMM )
            EINCP = EINCP + TKDUMM
            IF ( EINCP + EINCN .GT. EINCMX .AND. IRETRY .LT. 5 ) THEN
               EINCP = EINCP - TKDUMM
               CALL RBKMIN (1)
               IRETRY = IRETRY + 1
               GO TO 7500
            END IF
         ELSE
            NGREYN = NGREYN + 1
            CALL RBKINI ( 2, .FALSE., EXDUMM, TKDUMM, TSDUMM,
     &                    PSDUMM, ARDUMM, TRDUMM )
            EINCN = EINCN + TKDUMM
            IF ( EINCP + EINCN .GT. EINCMX .AND. IRETRY .LT. 5 ) THEN
               EINCN = EINCN - TKDUMM
               CALL RBKMIN (2)
               IRETRY = IRETRY + 1
               GO TO 7500
            END IF
         END IF
 8000 CONTINUE
      V0WELL (1) = V0SAV1
      V0WELL (2) = V0SAV2
      VEFFNU (1) = VESAV1
      VEFFNU (2) = VESAV2
 9000 CONTINUE
      EINCT  = EINCP  + EINCN
      IF ( EINCT + TVGRE0 .GT. EIUSE ) THEN
         TVGRE0 = 0.D+00
         EIUSE = MIN ( ONEONE, EINCMX / EINCT )
         EINCP = EINCP * EIUSE
         EINCN = EINCN * EIUSE
         EINCT = EINCP + EINCN
      END IF
      RETURN
*=== End of subroutine corrin =========================================*
      END
+DECK,  DATAR3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE DATAR3.FOR
*COPY DATAR3
*=== datar3 ===========================================================*
      SUBROUTINE DATAR3

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, BAMJCM.
+CDE, INPDAT.
      LOGICAL LSWTCH
      COMMON /FKVALI/ LSWTCH
      DIMENSION IVV(36),IP(36),IB(126),IBB(126),IA(126),IAA(126)
C     DEFINE THE FIELDS FOR PARTICLE CLASSIFICATION
C     IMPS=PSEUDO SCALAR MESONS (SPIN=0)
C     IMVE=VECTOR MESONS (SPIN=1)
C     IB08(IA08)=BARYONS (ANTIBARYONS) (SPIN=1/2)
C     IB10(IA10)=BARYONS (ANTIBARYONS) (SPIN=3/2)
      DATA IP/
     *23,14,16,116,0,0,13,23,25,117,0,0,15,24,31,120,0,0,119,118,121,
     *122,14*0/
      LSWTCH = .FALSE.
      L=0
C     PRINT 7769
C7769  FORMAT (' ***********************************************'/
C    1' *********************************************************'/
C    1'         ETA SUPRESSED IN DATAR3 AND HKLASS   SEPT 85 J.RANFT'/
C    1'     ETA (31)--->RHO0(33);  ETA*(95)--->OMEG(35)          '/
C    1'*************************************************************'/
C    1'*************************************************************')
      DO 1 I=1,6
      DO 2 J=1,6
      L=L+1
      IMPS(I,J)=IP(L)
    2 CONTINUE
    1 CONTINUE
      DATA IVV/
     *33,34,38,123,0,0,32,33,39,124,0,0,36,37,96,127,0,0,126,125,128,
     *129,14*0/
      L=0
      DO 3 I=1,6
      DO 4 J=1,6
      L=L+1
      IMVE(I,J)=IVV(L)
    4 CONTINUE
    3 CONTINUE
      DATA IB/
     *0,1,21,140,0,0,8,22,137,0,0,97,138,0,0,146,5*0,
     *1,8,22,137,0,0,0,20,142,0,0,98,139,0,0,147,5*0,
     *21,22,97,138,0,0,20,98,139,0,0,0,145,0,0,148,5*0,
     *140,137,138,146,0,0,142,139,147,0,0,145,148,50*0/
      L=0
      DO 5 I=1,6
      DO 6 J=1,21
      L=L+1
      IB08(I,J)=IB(L)
    6 CONTINUE
    5 CONTINUE
      DATA IBB/
     *53,54,104,161,0,0,55,105,162,0,0,107,164,0,0,167,5*0,
     *54,55,105,162,0,0,56,106,163,0,0,108,165,0,0,168,5*0,
     *104,105,107,164,0,0,106,108,165,0,0,109,166,0,0,169,5*0,
     *161,162,164,167,0,0,163,165,168,0,0,166,169,0,0,170,47*0/
      L=0
      DO 7 I=1,6
      DO 8 J=1,21
      L=L+1
      IB10(I,J)=IBB(L)
    8 CONTINUE
    7 CONTINUE
      DATA IA/
     *0,2,99,152,0,0,9,100,149,0,0,102,150,0,0,158,5*0,
     *2,9,100,149,0,0,0,101,154,0,0,103,151,0,0,159,5*0,
     *99,100,102,150,0,0,101,103,151,0,0,0,157,0,0,160,5*0,
     *152,149,150,158,0,0,154,151,159,0,0,157,160,50*0/
      L=0
      DO 9 I=1,6
      DO 10 J=1,21
      L=L+1
      IA08(I,J)=IA(L)
   10 CONTINUE
    9 CONTINUE
      DATA IAA/
     *67,68,110,171,0,0,69,111,172,0,0,113,174,0,0,177,5*0,
     *68,69,111,172,0,0,70,112,173,0,0,114,175,0,0,178,5*0,
     *110,111,113,174,0,0,112,114,175,0,0,115,176,0,0,179,5*0,
     *171,172,174,177,0,0,173,175,178,0,0,176,179,0,0,180,47*0/
      L=0
      DO 11 I=1,6
      DO 12 J=1,21
      L=L+1
      IA10(I,J)=IAA(L)
   12 CONTINUE
   11 CONTINUE
C     DEFINE THE FREE PARAMETERS FOR THE MONTE-CARLO PROGRAMMES BAMJET
C     PARJET HAPAQ
      A1=0.88D0
      B3=6.D0
      B1=8.D0
      B2=8.D0
      ISU=4
      BET=8.D0
      AS=0.25D0
      AME=0.93D0
      LT=0
      LE=0
      B8=0.33D0
      DIQ=0.375D0
C
C     BAMJCM INITIALIZATION
      DO 13 J = 1,KMXJCM
         IV (J) = 0
         RE (J) = 0.D+00
         KFR1 (J) = 0
         KFR2 (J) = 0
         RPX (J) = 0.D+00
         RPY (J) = 0.D+00
   13 CONTINUE
      RETURN
      END
+DECK,  DECAUX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

*$ CREATE DECAUX.FOR
*COPY DECAUX
*=== decaux ===========================================================*
      SUBROUTINE DECAUX(NHAD,NUMU)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Decaux89: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
+CDE, FINPAR2.
+CDE, AUXPAR.
C      STORE VARIABLES FROM HADPAR INTO FINPAR
      DO 1 I=1,NHAD
         PXF(I)  = PXA(I)
         PYF(I)  = PYA(I)
         PZF(I)  = PZA(I)
         HEF(I)  = HEPA(I)
         AMF(I)  = AMA(I)
         ICHF(I) = ICHA(I)
         IBARF(I)= IBARA(I)
         ANF(I)  = ANA(I)
         NREF(I) = NREA(I)
C     PRINT 3358,PXA(I),PYA(I),PZA(I),HEPA(I),AMA(I),ICHA(I),IBARA(I),
C    1ANA(I),NREA(I)
C3358 FORMAT (5E15.5,2I10,A8,I10)
    1 CONTINUE
C
      CALL FKDECA (NHAD,NUMU)
C
      DO 2 I=1,NHAD
         PXA(I)  = PXF(I)
         PYA(I)  = PYF(I)
         PZA(I)  = PZF(I)
         HEPA(I) = HEF(I)
         AMA(I)  = AMF(I)
         ICHA(I) = ICHF(I)
         IBARA(I)= IBARF(I)
         ANA(I)  = ANF(I)
         NREA(I) = NREF(I)
C     PRINT 3358,PXA(I),PYA(I),PZA(I),HEPA(I),AMA(I),ICHA(I),IBARA(I),
C    1ANA(I),NREA(I)
    2 CONTINUE
      RETURN
      END
+DECK,  DECAY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:59  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== decay ============================================================*
      SUBROUTINE DECAY(IHAD,ISTAB)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Decay89: slight revision by A. Ferrari                              *
*----------------------------------------------------------------------*
*
+CDE, FINPAR2.
+CDE, METLSP.
+CDE, PART.
+CDE, DECAYC.
      COMMON /FKDREI/ TEST(12)
      COMMON /FKGAMR/REDU,AMO,AMM(15)
      COMMON /FKPRUN/ISYS
      REAL RNDM(1)
C
C
      REDU=2.D0
      DO 801 I=1,IHAD
         ITS(I) = NREF(I)
         PLS(I) = SQRT(PXF(I)**2 + PYF(I)**2 + PZF(I)**2)
         IF (PLS(I) .NE. 0.D0) THEN
            CXS(I) = PXF(I)/PLS(I)
            CYS(I) = PYF(I)/PLS(I)
            CZS(I) = PZF(I)/PLS(I)
         END IF
         ELS(I) = HEF(I)
  801 CONTINUE
      IST = IHAD
      IR  = 0
  200 CONTINUE
C*****TEST STABLE OR UNSTABLE
C$$$$$ISTAB=1/2/3 MEANS  STRONG + WEAK DECAYS / ONLY STRONG DECAYS /
C*****STRONG DECAYS + WEAK DECAYS FOR CHARMED PARTICLES AND TAU LEPTONS
      IF(ISTAB.EQ.1) GOTO 793
      IF(ISTAB.EQ.2) GOTO 737
      IF(ISTAB.EQ.3) GOTO 738
  793 IF(ITS(IST).EQ.135.OR.ITS(IST).EQ.136) GOTO 202
      IF(ITS(IST).GE.1.AND.ITS(IST).LE.7) GOTO 202
      GOTO 300
  738 IF(ITS(IST).GE.1.AND.ITS(IST).LE.23) GOTO 202
      IF(ITS(IST).GE. 97.AND.ITS(IST).LE.103) GOTO 202
      IF(ITS(IST).EQ.109.AND.ITS(IST).EQ.115) GOTO 202
      IF(ITS(IST).GE.133.AND.ITS(IST).LE.136) GOTO 202
      GOTO 300
  737 IF(ITS(IST).GE.  1.AND.ITS(IST).LE. 30) GOTO 202
      IF(ITS(IST).GE. 97.AND.ITS(IST).LE.103) GOTO 202
      IF(ITS(IST).GE.115.AND.ITS(IST).LE.122) GOTO 202
      IF(ITS(IST).GE.131.AND.ITS(IST).LE.136) GOTO 202
      IF(ITS(IST).EQ.109) GO TO 202
      IF(ITS(IST).GE.137.AND.ITS(IST).LE.160) GOTO 202
      GO TO 300
  202 IR = IR + 1
      NREF(IR) = ITS(IST)
      ITT = ITS(IST)
      AMF(IR) = AM(ITT)
      ANF(IR) = ANAME(ITT)
      ICHF(IR)  = ICH(ITT)
      IBARF(IR) = IBAR(ITT)
      HEF(IR) = ELS(IST)
      PXF(IR) = CXS(IST)*PLS(IST)
      PYF(IR) = CYS(IST)*PLS(IST)
      PZF(IR) = CZS(IST)*PLS(IST)
      IST = IST - 1
      IF(IST .GE. 1) GO TO 200
      GO TO 500
  300 IT = ITS(IST)
      GAM = ELS(IST)/AM(IT)
      BGAM = PLS(IST)/AM(IT)
      ECO = AM(IT)
      KZ1 = K1(IT)
  310 CONTINUE
      CALL GRNDM(RNDM,1)
      VV = RNDM(1) - 1.D-17
      IIK = KZ1 - 1
  301 IIK = IIK + 1
      IF (VV.GT.WT(IIK)) GO TO 301
C  IIK IS THE DECAY CHANNEL
      IT1 = NZK(IIK,1)
      IT2 = NZK(IIK,2)
      IF (IT2-1 .LT. 0) GO TO 110
      IT3 = NZK(IIK,3)
C  IT1,IT2, IT3 ARE THE PRODUCED PARTICLES FROM  IT
      IF(IT3 .EQ. 0) GO TO 400
      CALL THREPD(ECO,ECM1,ECM2,ECM3,PCM1,PCM2,PCM3,COD1,COF1,SIF1,COD2,
     &            COF2,SIF2,COD3,COF3,SIF3,AM(IT1),AM(IT2),AM(IT3))
      GO TO 411
  400 CALL TWOPAD(ECO,ECM1,ECM2,PCM1,PCM2,COD1,COF1,SIF1,COD2,COF2,SIF2,
     &            AM(IT1),AM(IT2))
  411 CONTINUE
  110 CONTINUE
      ITS(IST) = IT1
      IF (IT2-1 .LT. 0) GO TO 305
      ITS(IST+1) = IT2
      ITS(IST+2) = IT3
      RX = CXS(IST)
      RY = CYS(IST)
      RZ = CZS(IST)
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD1,COF1,SIF1,PCM1,ECM1,
     &           PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IST = IST + 1
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD2,COF2,SIF2,PCM2,ECM2,
     &           PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IF (IT3 .LE. 0) GO TO 305
      IST = IST + 1
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD3,COF3,SIF3,PCM3,ECM3,
     &           PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
  305 CONTINUE
      GO TO 200
  500 CONTINUE
      IDAPU = IDMAX3
      IF(IR .GT. IDMAX3) WRITE(ISYS,928)IDAPU
  928 FORMAT(' NUMBER OF STAB. FINAL PART. IS GREATER THAN',I5)
      IHAD = IR
      RETURN
      END
+SELF.
+DECK,  DIFEVV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*$ CREATE DIFEVV.FOR
*COPY DIFEVV
*=== difevv ===========================================================*
      SUBROUTINE DIFEVV ( NHAD, KPROJ, KTARG, PPROJ, EPROJ, UMO )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*----------------------------------------------------------------------*
C
C          DIFFRACTIVE HADRON -HADRON COLLISIONS
C     GENERATE HADRON PRODUCTION EVENT IN  KPROJ - KTARG  COLLISION
C     WITH  LAB PROJECTILE MOMENTUM  PPROJ
C
C********************************************************************
C
+CDE, AUXPAR.
+CDE, BALANC.
+CDE, CMSRES.
+CDE, FINPAR.
+CDE, HADPAR.
+CDE, INPDAT2.
+CDE, PART.
+CDE, QQUARK.
      COMMON /FKPRIN/ IPRI, INIT
      REAL RNDM(2)
C
C*******************************************************************"
C
C     KINEMATICS
C
C********************************************************************
C
      IPRI = 0
      AMPROJ = AM(KPROJ)
      AMTAR  = AM(KTARG)
* The following are the Lorentz parameters to come from the system
* (projectile + target) rest frame to the starting one, which is the
* one where the target is at rest and the projectile is moving
* along the +z direction with Pproj: from now down to 600 continue
* we are working in the system rest frame !!!
      GAMCM = (EPROJ+AMTAR)/UMO
      BGCM  = PPROJ/UMO
C
*or      IF(IPRI.EQ.1) WRITE(LUNOUT,101)KPROJ,KTARG,PPROJ,AMPROJ,AMTAR,
*or     *EPROJ,UMO,GAMCM,BGCM
*or101   FORMAT(2I5,10F11.5)
C
C
      IBPROJ = IBAR(KPROJ)
      IBTARG = IBAR(KTARG)
C
C
C=====================================================================
C
C     SAMPLE X-VALUES OF QUARK-ANTIQUARK PAIRS
C
C======================================================================
      IF ( KPROJ .GT. 2 ) THEN
         UNOSEA = 5.D+00
      ELSE
         UNOSEA = 3.D+00
      END IF
* Come here if we need to resample xsea and xasea!!
  211 CONTINUE
      TMP005 = 0.05D+00
      XSEA  = BETARN(TMP005,UNOSEA)
      XASEA = BETARN(TMP005,UNOSEA)
      XPIO  = XSEA+XASEA
      IF (XPIO .GE. 1.D+00) GO TO 211
      XHAD = 1.D+00 - XPIO
      CALL GRNDM(RNDM,1)
      ISAM = 2.D+00 * RNDM(1) + 1.D+00
*or      IF (IPRI.EQ.1) WRITE(LUNOUT,371)XSEA,XASEA,XPIO,XHAD,ISAM
*or  371 FORMAT (' XSEA,XASEA,XPIO,XHAD,ISAM',4F10.5,I10)
C=====================================================================
C
C      CALL EQUIVALENT PIO HADRON COLLISIONS
C
C=====================================================================
      GO TO (250,260),ISAM
*  +-------------------------------------------------------------------*
*  | Target excited !!!!
  250 CONTINUE
         LPRDIF = .TRUE.
C=======================================================================
C     PROJECTILE MOVING WITH XHAD, TARGET EXCITED
C=======================================================================
         IIDIF = 1
         AMCH  = SQRT (XPIO) * UMO
         BITBIT = 0.5D+00
*  |  +----------------------------------------------------------------*
*  |  | The following condition roughly guarantees 1 GeV for the total
*  |  | energy of the pseudo-pion!
         IF ( AMCH .LE. AMTAR + BITBIT ) THEN
            AMCH = AMTAR + BITBIT
            XPIO = ( AMCH / UMO )**2
            XHAD = 1.D+00 - XPIO
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  | The following instructions make the division of the invariant
*  | mass of the system between the two particles, the two resulting
*  | energies being Eh1s and Eh2ex and the momentum Ph1s: the two
*  | particles are the original projectile and the excited target,
*  | ("mass" = amch)
         EH1S = (UMO**2 + AMPROJ**2 - AMCH**2) / (2.D0*UMO)
         IF (EH1S .LE. AMPROJ) GO TO 211
         EH2EX = UMO - EH1S
         PH1S  = SQRT (EH1S**2 - AMPROJ**2)
C*** AND  INT. CHAIN TRANSVERSE MOMENTA
         B3SAVE = B3BAMJ
         CALL GRNDM(RNDM,2)
         ES  = -2.D0/(B3BAMJ**2)*LOG(RNDM(1)*RNDM(2))
         HPS = SQRT(ES*ES+2.D0*ES*AMTAR)
         CALL SFECFE(SFE,CFE)
         PTXCH1 = HPS * CFE
         PTYCH1 = HPS * SFE
6171  CONTINUE
         PX1 = PTXCH1
         PY1 = PTYCH1
         ACH = PH1S**2 - PX1**2 - PY1**2
         IF (ACH .LE. 0.D+00) THEN
            PTXCH1 = 0.75D+00 * PTXCH1
            PTYCH1 = 0.75D+00 * PTYCH1
            GO TO 6171
         END IF
         PZ1  = SQRT (ACH)
*  | Now transform back the excited target to the lab system
         ECHCK  = GAMCM * EH2EX - BGCM * PZ1
         PXCHCK = - PX1
         PYCHCK = - PY1
         PZCHCK = - GAMCM * PZ1 + BGCM * EH2EX
*  | Now ..chck are the kinematical variables of the excited target
*  | in the lab frame, the invariant mass is always Amch
         CALL GRNDM(RNDM,1)
         IF (RNDM (1) .LE. 0.5D+00 ) THEN
            KPIO = 26
         ELSE
            KPIO = 23
         END IF
         AMPIO = AM (KPIO)
         EPIOL = 0.5D+00 * ( AMCH**2 - AMPIO**2 - AMTAR**2 ) / AMTAR
         PPIOL = SQRT ( EPIOL**2 - AMPIO**2 )
         ETOTX  = EPIOL + AMTAR
         AAFACT = ECHCK + ETOTX
         BBFACT = PPIOL - PZCHCK
         DDENOM = ETOTX * AAFACT - PPIOL * BBFACT
         GAM1 = ( ECHCK * AAFACT + PPIOL * BBFACT ) / DDENOM
         BGZ1 = - BBFACT * AAFACT / DDENOM
         BGX1 = PXCHCK * ( GAM1 + 1.D+00 ) / AAFACT
         BGY1 = PYCHCK * ( GAM1 + 1.D+00 ) / AAFACT
         CALL HADEVV ( NHAD, KPIO, KTARG, PPIOL, EPIOL, AMCH )
*   Restore the original b3bamj parameter
         B3BAMJ = B3SAVE
C     PRINT 888,PX1,PY1,PZ1,EH2EX
C        PRINT 888,PXX1,PYY1,PZZ1,EXXX
C 888    FORMAT(4F12.4)
*  | The following to go back to the original (lab) frame
*  |  +----------------------------------------------------------------*
*  |  |                      Looping over the produced particles
         DO 800 I=1,NHAD
            CALL ALTRA ( GAM1, BGX1, BGY1, BGZ1, PXH(I), PYH(I), PZH(I),
     &                   HEPH(I), PLR, PLRX, PLRY, PLRZ, ELR )
            PXH(I) = PLRX
            PYH(I) = PLRY
            PZH(I) = PLRZ
            HEPH(I) = ELR
*  |  |  Updating conservation counters
 800     CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  |  Add the original projectile to the final particles, transforming
*  |  it back to the lab system
         NHAD = NHAD+1
         PXH  (NHAD) = PX1
         PYH  (NHAD) = PY1
         PZH  (NHAD) = GAMCM * PZ1 + BGCM * EH1S
         HEPH (NHAD) = GAMCM * EH1S + BGCM * PZ1
         AMH  (NHAD) = AMPROJ
         ICHH (NHAD) = ICH  (KPROJ)
         IBARH(NHAD) = IBAR (KPROJ)
         ANH  (NHAD) = ANAME(KPROJ)
         NREH (NHAD) = KPROJ
      GO TO 600
*  |  end of excited target treatment !!
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |  Excited projectile !!!!!!
 260  CONTINUE
         LPRDIF = .FALSE.
C=======================================================================
C   THE TARGET PARTICLE GETS XHAD , THE PROJECTILE BECOMES EXCITED
C   WE GO TO THE PROJECTILE REST FRAME
C=======================================================================
         IIDIF = 2
         AMCH  = SQRT (XPIO) * UMO
         MK = 0
         DO 270 IQ = 1, 3
            MK = MK + ABS ( IQSCHR ( MQUARK ( IQ, KPTOIP(KPROJ) ) ) )
 270     CONTINUE
         BITBIT = 0.5D+00 + 0.2D+00 * MK
*  |  +----------------------------------------------------------------*
*  |  | The following condition roughly guarantees 1 GeV for the total
*  |  | energy of the pseudo-pion if the projectile has no strangeness
*  |  | a bit more if it has
         IF ( AMCH .LE. AMPROJ + BITBIT ) THEN
            AMCH = AMPROJ + BITBIT
            XPIO = ( AMCH / UMO )**2
            XHAD = 1.D+00 - XPIO
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  | The following instructions make the division of the invariant
*  | mass of the system between the two particles, the two resulting
*  | energies being Eh1s and Eh2ex and the momentum Ph1s: the two
*  | particles are the target nucleon and the excited projectile,
*  | ("mass" = amch)
         EH1S = (UMO**2 + AMTAR**2 -  AMCH**2) / (2.D+00*UMO)
         IF (EH1S .LE. AMTAR) GO TO 211
         EH2EX = UMO-EH1S
         PH1S  = SQRT (EH1S**2 - AMTAR**2)
C*** AND  INT. CHAIN TRANSVERSE MOMENTA
         B3SAVE = B3BAMJ
         CALL GRNDM(RNDM,2)
         ES  = -2.D0/(B3BAMJ**2)*LOG(RNDM(1)*RNDM(2))
         HPS = SQRT(ES*ES+2.D0*ES*AMPROJ)
         CALL SFECFE(SFE,CFE)
         PTXCH1 = HPS * CFE
         PTYCH1 = HPS * SFE
6181  CONTINUE
         PX1 = PTXCH1
         PY1 = PTYCH1
         ACH = PH1S**2 - PX1**2 - PY1**2
         IF (ACH .LE. 0.D+00) THEN
            PTXCH1 = 0.75D+00 * PTXCH1
            PTYCH1 = 0.75D+00 * PTYCH1
            GO TO 6181
         END IF
         PZ1  = SQRT (ACH)
*  | Now transform back the excited projectile to the lab system
         ECHCK  = GAMCM * EH2EX + BGCM * PZ1
         PXCHCK = PX1
         PYCHCK = PY1
         PZCHCK = GAMCM * PZ1   + BGCM * EH2EX
*  | Now ..chck are the kinematical variables of the excited projectile
*  | in the lab frame, the invariant mass is always Amch
         CALL GRNDM(RNDM,1)
         IF (RNDM (1) .LE. 0.5D+00 ) THEN
            KPIO = 26
         ELSE
            KPIO = 23
         END IF
         AMPIO = AM (KPIO)
         EPIOL = 0.5D+00 * ( AMCH**2 - AMPIO**2 - AMPROJ**2 ) / AMPROJ
         PPIOL = SQRT ( EPIOL**2 - AMPIO**2 )
         ETOTX  = EPIOL + AMPROJ
         AAFACT = ECHCK + ETOTX
         BBFACT = PPIOL - PZCHCK
         DDENOM = ETOTX * AAFACT - PPIOL * BBFACT
         GAM1 = ( ECHCK * AAFACT + PPIOL * BBFACT ) / DDENOM
         BGZ1 = - BBFACT * AAFACT / DDENOM
         BGX1 = PXCHCK * ( GAM1 + 1.D+00 ) / AAFACT
         BGY1 = PYCHCK * ( GAM1 + 1.D+00 ) / AAFACT
         CALL HADEVV ( NHAD, KPIO, KPROJ, PPIOL, EPIOL, AMCH )
*   Restore the original b3bamj parameter
         B3BAMJ = B3SAVE
C     PRINT 888,PX1,PY1,PZ1,EH2EX
C        PRINT 888,PXX1,PYY1,PZZ1,EXXX
*  | The following to go back to the original (lab) frame
*  |  +----------------------------------------------------------------*
*  |  |                      Looping over the produced particles
         DO 900 I=1,NHAD
            CALL ALTRA ( GAM1, BGX1, BGY1, BGZ1, PXH(I), PYH(I), PZH(I),
     &                   HEPH(I), PLR, PLRX, PLRY, PLRZ, ELR )
            PXH(I) = PLRX
            PYH(I) = PLRY
            PZH(I) = PLRZ
            HEPH(I) = ELR
*  |  |  Updating conservation counters
 900     CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  |  Add the target nucleon to the final particles, transforming
*  |  it back to the lab system
         NHAD = NHAD + 1
         PXH  (NHAD) = - PX1
         PYH  (NHAD) = - PY1
         PZH  (NHAD) = - GAMCM * PZ1  + BGCM * EH1S
         HEPH (NHAD) =   GAMCM * EH1S - BGCM * PZ1
         AMH  (NHAD) = AMTAR
         ICHH (NHAD) = ICH  (KTARG)
         IBARH(NHAD) = IBAR (KTARG)
         ANH  (NHAD) = ANAME(KTARG)
         NREH (NHAD) = KTARG
      GO TO 600
*  |  end of excited projectile !!!
*  +-------------------------------------------------------------------*
  600 CONTINUE
C
C********************************************************************
C
C*** PRINT AND TEST ENERGY CONSERVATION
C
C********************************************************************
C
      PUZZ = 0.D+00
      EUZZ = 0.D+00
      PUXX = 0.D+00
      PUYY = 0.D+00
      ICUU = 0
      IBUU = 0
      DO 82 I=1,NHAD
         PUXX = PUXX + PXH(I)
         PUYY = PUYY + PYH(I)
         PUZZ = PUZZ + PZH(I)
         EUZZ = EUZZ + HEPH(I)
         ICUU = ICUU + ICHH(I)
         IBUU = IBUU + IBARH(I)
  82  CONTINUE
      ICHTOT=ICH(KPROJ)+ICH(KTARG)
      IBTOT =IBAR(KPROJ)+IBAR(KTARG)
      PCHMIN = 1.D-10 * PPROJ
      IF ((ABS(PUXX) .GE. PCHMIN) .OR. (ABS(PUYY) .GE. PCHMIN) .OR.
     &    (ABS(PUZZ-PPROJ) .GE. PCHMIN) .OR. (ABS(EPROJ+AMTAR-EUZZ) .GE.
     &     1.D-10*EUZZ) .OR. (ICHTOT .NE. ICUU) .OR. (IBTOT .NE. IBUU))
     &   THEN
         WRITE(LUNERR,*)
     &               ' Difevt: failure!!!: NHAD, KPROJ, KTARG, IIDIF: ',
     &                 NHAD, KPROJ, KTARG, IIDIF
         WRITE(LUNERR,*)'                     ',
     &                  'ICHTOT, ICUU, IBTOT, IBUU: ',
     &                   ICHTOT, ICUU, IBTOT, IBUU
         WRITE(LUNERR,*)'                     ',
     &                  'PPROJ, PUXX, PUYY, PUZZ: ',
     &                   PPROJ, PUXX, PUYY, PUZZ
         WRITE(LUNERR,*)'                     EPROJ, EUZZ: ',
     &                   EPROJ, EUZZ
      END IF
      IF (IPRI .NE. 1) GO TO 90
      DO 84 I=1,NHAD
         WRITE(LUNERR,85)I,NREH(I),ICHH(I),IBARH(I),ANH(I),
     &                   PXH(I),PYH(I),PZH(I),HEPH(I),AMH(I)
  85     FORMAT (4I5,A8,5F12.6)
  84  CONTINUE
  90  CONTINUE
      RETURN
      END
+DECK,  DOST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

*$ CREATE DOST.FOR
*COPY DOST
*                                                                      *
*=== dost==============================================================*
*                                                                      *
      FUNCTION DOST(I,Z)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C--------------------------------------------------------------------
C SUBNAME = DOST
C--------------------------------------------------------------------
+CDE, EVA0.
C--------------------------------------------------------------------
      IF(Z-70.D0)1,2,2
    2 DOST=T(I,7)
    3 RETURN
    1 IF(Z-10.D0)5,5,6
    5 DOST=T(I,1)
      GOTO3
    6 N=.1D0*Z+1.D0
      X=10*N
      X=(X-Z)*.1D0
      DOST=X*T(I,N-1)+(1.D0-X)*T(I,N)
      GOTO3
      END
+DECK,  DRELAB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

*$ CREATE DRELAB.FOR
*COPY DRELAB
*=== drelab ===========================================================*
      SUBROUTINE DRELAB(X,Y,Z,COTE,SITE,COPS,SIPS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      X1=COPS*X-SIPS*COTE*Y+SIPS*SITE*Z
      X2=SIPS*X+COPS*COTE*Y-COPS*SITE*Z
      X3=SITE*Y+COTE*Z
      X=X1
      Y=X2
      Z=X3
      RETURN
      END
+DECK,  DRES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:54  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== dres =============================================================*
*                                                                      *
      SUBROUTINE DRES ( M2, M3, T1, U, EREC, LOPPAR, JFISS )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  New version of DRES created  by A.Ferrari & P.Sala, INFN - Milan    *
*                                                                      *
*  Last change  on  10-apr-93  by  Alfredo Ferrari, INFN - Milan       *
*                                                                      *
*  Dres93: Dres91 plus the RAL fission model taken from LAHET thanks   *
*          to R.E.Prael                                                *
*  Dres91: new version from A. Ferrari and P. Sala, INFN - Milan       *
*          This routine has been adapted from the original one of the  *
*          Evap-5 module (KFA - Julich). Main modifications concern    *
*          with kinematics which is now fully relativistic and with    *
*          the treatment of few nucleons nuclei, which are now frag-   *
*          mented, even though in a very rough manner. Changes have    *
*          been made also to other routines of the Evap-5 package      *
*                                                                      *
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*                                                                      *
*  Input variables:                                                    *
*     M2 = Mass number of the residual nucleus                         *
*     M3 = Atomic number of the residual nucleus                       *
*     T1 = Excitation energy of the residual nucleus before evaporation*
*     U  = Excitation energy of the residual nucleus after evaporation *
*     Erec = Recoil kinetic energy of the residual nucleus             *
*            The recoil direction is given by Coslbr (i)               *
*                                                                      *
*  Significant variables:                                              *
*     JA = Present mass number of the residual nucleus                 *
*     JZ = Present atomic number of the residual nucleus               *
*     Smom1 = Energy accumulators for the six types of evaporated      *
*             particles                                                *
*                                                                      *
*    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     *
*    !!!! Please note that the following variables concerning !!!!     *
*    !!!! with the present residual nucleus must be set before!!!!     *
*    !!!! entering DRES91: Ammres, Ptres                      !!!!     *
*    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     *
*                                                                      *
*----------------------------------------------------------------------*
*
C---------------------------------------------------------------------
C SUBNAME = DRES --- EVAPORATION
C           EVAPORATION DATA SHOUD BE READ ON INPUT STAGE
C---------------------------------------------------------------------
C*****A LA EVAP III(TWA,8-68)
+CDE, EVA0.
+CDE, EVA1.
+CDE, FORCN.
+CDE, HIGFIS.
+CDE, INPFLG.
+CDE, LABCOS.
+CDE, NUCDAT.
+CDE, RESNUC.
      DIMENSION ZMASS (6), Z2MASS(6), C(3), Q(0:6), FLKCOU(6), CCOUL(6),
     &          THRESH(6), SMALLA(6), R(6), S  (6), SOS   (6), STRUN(6),
     &          EYE1  (6), EYE0  (6), SMOM1    (6), BNMASS(6)
      DIMENSION CORRRR(6)
      REAL RNDM(2)
      LOGICAL LOPPAR, PENBAR, LFIRST
      SAVE ZMASS, Z2MASS, EMHN, EMNUM, UM, AMUMEV, AMEMEV, QBRBE8,
     &     BNMASS, IEVEVP, NBE8, NRNEEP, LFIRST
      DATA IEVEVP / 0 /
      DATA LFIRST / .TRUE. /
*
      IEVEVP = IEVEVP + 1
C-------------------------------------- 1.ST CALL INIT
      IF ( LFIRST ) THEN
         LFIRST = .FALSE.
         FKEY   = ZERZER
         NBE8   = 0
         NRNEEP = 0
         EXMASS(1) = 1.D+03 * ( AMNEUT - AMUAMU )
         EXMASS(2) = ENERGY ( ONEONE, ONEONE )
         EXMASS(3) = ENERGY ( TWOTWO, ONEONE )
         EXMASS(4) = ENERGY ( THRTHR, ONEONE )
         EXMASS(5) = ENERGY ( THRTHR, TWOTWO )
         EXMASS(6) = ENERGY ( FOUFOU, TWOTWO )
         ZMASS(1) = 1.D+03 * AMUAMU + EXMASS (1)
         ZMASS(2) = 1.D+03 * AMUAMU + EXMASS (2)
         ZMASS(3) = 2.D+03 * AMUAMU + EXMASS (3)
         ZMASS(4) = 3.D+03 * AMUAMU + EXMASS (4)
         ZMASS(5) = 3.D+03 * AMUAMU + EXMASS (5)
         ZMASS(6) = 4.D+03 * AMUAMU + EXMASS (6)
         BNMASS (1) = 0.D+00
         BNMASS (2) = 0.D+00
         BNMASS (3) = ZMASS (1) + ZMASS (2) - ZMASS (3)
         BNMASS (4) = TWOTWO * ZMASS (1) + ZMASS (2) - ZMASS (4)
         BNMASS (5) = ZMASS (1) + TWOTWO * ZMASS (2) - ZMASS (5)
         BNMASS (6) = TWOTWO * ( ZMASS (1) + ZMASS (2) ) - ZMASS (6)
         DO 1234 KK = 1,6
            Z2MASS (KK) = ZMASS (KK) * ZMASS (KK)
1234     CONTINUE
         AMUMEV = 1.D+03 * AMUAMU
         AMEMEV = 1.D+03 * AMELEC
         QBRBE8 = ENERGY ( EIGEIG, FOUFOU ) - TWOTWO * EXMASS (6)
         EMN = 1.D+03 * AMNEUT
         EMH = ZMASS (2)
         TMP16 = 16.D+00
         UM  = AMUMEV + ENERGY ( TMP16, EIGEIG ) / 16.D+00
         EMHN  = EMH - EMN
         EMNUM = EMN - UM
      END IF
*  |  End of initialization:
*  +-------------------------------------------------------------------*
C     --------------------------------- START OF PROCESS
*  +-------------------------------------------------------------------*
*  |  Initialize Npart and Smom if nothing has been already evaporated
*  |  for this event
      IF ( JFISS .LE. 0 ) THEN
         DO 775 I=1,6
            NPART(I) = 0
            SMOM1(I) = ZERZER
  775    CONTINUE
      END IF
*  |
*  +-------------------------------------------------------------------*
      JA = M2
      JZ = M3
      U  = T1
      RNMASS = 1.D+03 * AMMRES + U
* P2res and  Ptres are the squared momentum and the momentum of the
* residual nucleus (now in relativistic kinematics), Umo the
* invariant mass of the system!
      UMO  = RNMASS
      UMO2 = UMO * UMO
      ELBTOT  = RNMASS + EREC
      GAMCM   = ELBTOT / RNMASS
      ETACM   = 1.D+03 * PTRES / RNMASS
      HEVSUM  = ZERZER
 1000 CONTINUE
      LOPPAR = .FALSE.
*  +-------------------------------------------------------------------*
*  |                Check for starting data inconsistencies
      IF (JA-JZ .LT. 0) THEN
         WRITE(LUNOUT,6401)
         WRITE(LUNERR,6401)
 6401    FORMAT('1 Dres: cascade residual nucleus has mass no. less',
     &       ' than Z!!')
         RETURN
*  |
*  +-------------------------------------------------------------------*
*  |                Rough treatment for very few nucleon residual
*  |                nuclei. The basic ideas are:
*  |        a) as many as possible alpha particles are emitted
*  |        b) particles are emitted one per time leaving a residual
*  |           excitation energy proportional to number of nucleons
*  |           left in the residual nucleus (so we deal only with
*  |           two body kinematics)
*  |       T A K E   I N T O   A C C O U N T   T H A T   T H I S
*  |       T R E A T M E N T   I S   E X T R E M E L Y   R O U G H
*  |       T H E   T A S K   B E I N G   O N L Y   T O   S U P P L Y
*  |       S O M E T H I N G   T O   S H A R E   E N E R G Y   A N D
*  |       M O M E N T U M   A M O N G   A   F E W   F R A G M E N T S
      ELSE IF ( JA .LE. 6 .OR. JZ .LE. 2 ) THEN
*  | 1000 continue moved above according to FCA suggestion
*1000    CONTINUE
         JRESID = 0
         IF ( JA .GT. 4 ) GO TO 2000
*  |  +----------------------------------------------------------------*
*  |  | First check we are not concerning with a couple of neutrons or
*  |  | protons
         IF ( JA .EQ. 2 .AND. JZ .NE. 1 ) THEN
            JEMISS = 1 + JZ / 2
            JRESID = JEMISS
            RNMASS = ZMASS (JRESID)
            U = 0.D+00
            DELTU = UMO - 2.D+00 * ZMASS (JEMISS)
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( DELTU .LE. 0.D+00 ) THEN
               IF ( DELTU .LT. - 2.D+00 * ANGLGB * UMO ) THEN
                  WRITE ( LUNERR, * )' *** Dres: insufficient Umo for',
     &                               ' a nucleon couple', UMO,
     &                                 2.D+00 * ZMASS (JEMISS)
               END IF
               UMO = ( UMO + DELTU ) * ( 1.D+00 + ANGLGB )
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            GO TO 2500
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  | Then check we are not concerning with one of the six
*  |  | standard particles
         DO 1700 J = 6, 1, -1
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( JZ .EQ. IZ (J) .AND. JA .EQ. IA (J) ) THEN
               HEVSUM = SMOM1(3) + SMOM1(5) + SMOM1(6) + SMOM1(4)
               GO TO ( 1100, 1100, 1600, 1500, 1400, 1300 ), J
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Proton or neutron, nothing can be done
 1100          CONTINUE
                  RETURN
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Alpha:
 1300          CONTINUE
                  DEUDEU = MAX ( ZERZER, U + TWOTWO * BNMASS (3)
     &                           - BNMASS (6) )
                  PROTRI = MAX ( ZERZER, U + BNMASS (4) - BNMASS (6) )
                  UEU3HE = MAX ( ZERZER, U + BNMASS (5) - BNMASS (6) )
                  QNORM  = DEUDEU + PROTRI + UEU3HE
*  |  |  |  |  If we cannot split then return
                  IF ( QNORM .LE. ZERZER ) RETURN
                  CALL GRNDM(RNDM,1)
                  V = RNDM (1)
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split or into two deuterons or a triton and a proton
*  |  |  |  |  | or a 3-He and a neutron: no account is made for
*  |  |  |  |  | Coulomb effects, probability is simply assumed
*  |  |  |  |  | proportional to reaction Qs
                  IF ( V .LT. DEUDEU / QNORM ) THEN
*  |  |  |  |  | Two deuterons selected
                     JEMISS = 3
                     JRESID = 3
                     RNMASS = ZMASS (3)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into a triton and a proton
                  ELSE IF ( V .LT. ( DEUDEU + PROTRI ) / QNORM ) THEN
                     JEMISS = 2
                     JRESID = 4
                     RNMASS = ZMASS (4)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into a 3-He and a neutron
                  ELSE
                     JEMISS = 1
                     JRESID = 5
                     RNMASS = ZMASS (5)
                     U = ZERZER
                     GO TO 2500
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  3-He:
 1400          CONTINUE
                  DEUPRO = MAX ( ZERZER, U + BNMASS (3) - BNMASS (5) )
                  PRPRNE = MAX ( ZERZER, U - BNMASS (5) )
                  QNORM  = DEUPRO + PRPRNE
*  |  |  |  |  If we cannot split then return
                  IF ( QNORM .LE. ZERZER ) RETURN
                  CALL GRNDM(RNDM,1)
                  V = RNDM (1)
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split or into a deuteron and a proton
*  |  |  |  |  | or into two protons and one neutron: no account is
*  |  |  |  |  | made for Coulomb effects, probability is simply assumed
*  |  |  |  |  | prportional to reaction Qs
                  IF ( V .LT. DEUPRO / QNORM ) THEN
*  |  |  |  |  | A deuteron and a proton selected
                     JEMISS = 2
                     JRESID = 3
                     RNMASS = ZMASS (3)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into 2 protons and 1 neutron: part of the exci-
*  |  |  |  |  | tation energy is conserved to allow the further
*  |  |  |  |  | splitting of the deuteron
                  ELSE
                     JEMISS = 2
                     JRESID = 0
                     FACT = ONEONE
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  | Loop to compute the residual excitation energy
 1450                CONTINUE
                        FACT = FACT * 0.6666666666666667D+00
*  |  |  |  |  |  | Erncm, Eepcm are the total energies of the residual
*  |  |  |  |  |  | nucleus and of the emitted particle in the CMS frame
                        U      = FACT * PRPRNE + BNMASS (3)
                        RNMASS = ZMASS (3) + U
                        ERNCM  = HLFHLF * ( UMO2 + RNMASS**2
     &                         - Z2MASS (JEMISS) ) / UMO
                        EEPCM  = UMO - ERNCM
                     IF ( EEPCM .LE. ZMASS (JEMISS) ) GO TO 1450
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
                     GO TO 2600
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Triton:
 1500          CONTINUE
                  DEUNEU = MAX ( ZERZER, U + BNMASS (3) - BNMASS (4) )
                  PRNENE = MAX ( ZERZER, U - BNMASS (4) )
                  QNORM  = DEUNEU + PRNENE
*  |  |  |  |  If we cannot split then return
                  IF ( QNORM .LE. ZERZER ) RETURN
                  CALL GRNDM(RNDM,1)
                  V = RNDM (1)
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split or into a deuteron and a neutron
*  |  |  |  |  | or into two protons and one neutron: no account is
*  |  |  |  |  | made for Coulomb effects, probability is simply assumed
*  |  |  |  |  | proportional to reaction Qs
                  IF ( V .LT. DEUNEU / QNORM ) THEN
*  |  |  |  |  | A deuteron and a proton selected
                     JEMISS = 1
                     JRESID = 3
                     RNMASS = ZMASS (3)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into 1 proton and 2 neutrons: part of the exci-
*  |  |  |  |  | tation energy is conserved to allow the further
*  |  |  |  |  | splitting of the deuteron
                  ELSE
                     JEMISS = 1
                     JRESID = 0
                     FACT = ONEONE
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  | Loop to compute the residual excitation energy
 1550                CONTINUE
                        FACT = FACT * 0.6666666666666667D+00
*  |  |  |  |  |  | Erncm, Eepcm are the total energies of the residual
*  |  |  |  |  |  | nucleus and of the emitted particle in the CMS frame
                        U      = FACT * PRNENE + BNMASS (3)
                        RNMASS = ZMASS (3) + U
                        ERNCM  = HLFHLF * ( UMO2 + RNMASS**2
     &                         - Z2MASS (JEMISS) ) / UMO
                        EEPCM  = UMO - ERNCM
                     IF ( EEPCM .LE. ZMASS (JEMISS) ) GO TO 1550
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
                     GO TO 2600
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Deuteron:
 1600          CONTINUE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into a proton and a neutron if it is possible
                  IF ( U .GT. BNMASS (3) ) THEN
                     JEMISS = 1
                     JRESID = 2
                     RNMASS = ZMASS (2)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Energy too low to split the deuteron, return
                  ELSE
                     WRITE (LUNERR,*)' **Dres: energy too low to split',
     &                               ' a deuteron! M2,M3',M2,M3
                     RETURN
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 1700    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
 2000    CONTINUE
         A = JA
         Z = JZ
         Q (0)  = ZERZER
         ENERG0 = ENERGY (A,Z)
*  |  +----------------------------------------------------------------*
*  |  |   Note that Q(i) are not the reaction Qs but the remaining
*  |  |   energy after the reaction
         DO 2100 K = 1, 6
            JJA = JA - IA (K)
            JJZ = JZ - IZ (K)
            JJN = JJA - JJZ
            IF ( JJN .LT. 0 .OR. JJZ .LT. 0 ) THEN
               Q (K) = Q (K-1)
               GO TO 2100
            END IF
            DDJJA = JJA
            DDJJZ = JJZ
            Q (K) = MAX ( U + ENERG0 - ENERGY ( DDJJA, DDJJZ )
     &            - EXMASS (K), ZERZER ) + Q (K-1)
 2100    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |  If no emission channel is open then return
         IF ( Q (6) .LE. ZERZER ) THEN
            HEVSUM = SMOM1(3) + SMOM1(5) + SMOM1(6) + SMOM1(4)
            RETURN
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         CALL GRNDM(RNDM,1)
         V = RNDM (1)
         FACT = ONEONE
*  |  +----------------------------------------------------------------*
*  |  |
         DO 2200 J = 1, 6
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( V .LT. Q (J) / Q (6) ) THEN
               JEMISS = J
               JJA    = JA - IA (JEMISS)
               JJZ    = JZ - IZ (JEMISS)
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               DO 2150 JJ = 1, 6
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( JJA .EQ. IA (JJ) .AND. JJZ .EQ. IZ (JJ) ) THEN
                     JRESID = JJ
                     RNMASS = ZMASS (JRESID)
                     ERNCM  = HLFHLF * ( UMO2 + Z2MASS (JRESID)
     &                      - Z2MASS (JEMISS) ) / UMO
                     EEPCM  = UMO - ERNCM
                     U = ZERZER
                     GO TO 2600
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
 2150          CONTINUE
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               AJJA   = JJA
               ZJJZ   = JJZ
               RNMAS0 = AJJA * AMUMEV + ENERGY ( AJJA, ZJJZ )
               GO TO 2300
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 2200    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         WRITE ( LUNOUT,* )' **** error in Dres, few nucleon treatment',
     &                     ' ****'
         WRITE ( LUNERR,* )' **** error in Dres, few nucleon treatment',
     &                     ' ****'
         RETURN
*  |  +----------------------------------------------------------------*
*  |  | Loop to compute the residual excitation energy
 2300    CONTINUE
            FACT = FACT * AJJA / A
            U = FACT * ( Q (JEMISS) - Q (JEMISS-1) )
*  |  | Erncm, Eepcm are the total energies of the residual
*  |  | nucleus and of the emitted particle in the CMS frame
            RNMASS = RNMAS0 + U
            ERNCM  = HLFHLF * ( UMO2 + RNMASS**2
     &             - Z2MASS (JEMISS) ) / UMO
            EEPCM  = UMO - ERNCM
         IF ( EEPCM .LE. ZMASS (JEMISS) ) THEN
            IF ( Q (JEMISS) - Q (JEMISS-1) .GE. 1.D-06 ) GO TO 2300
*  |  +--<--<--<--<--<--< Loop back
*  |  |  Actually there is no excitation energy available!
            U = ANGLGB
            RNMASS = ONEPLS * RNMAS0
            ERNCM  = ONEPLS * RNMASS
            EEPCM  = ONEPLS * ZMASS (JEMISS)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         GO TO 2600
*  |  From here standard two bodies kinematics with Jemiss, Rnmass
*  |  (new excitation energy is U)
 2500    CONTINUE
*  |  Erncm, Eepcm are the total energies of the residual
*  |  nucleus and of the emitted particle in the CMS frame
         ERNCM = HLFHLF * ( UMO2 + RNMASS**2 - Z2MASS (JEMISS) ) / UMO
         EEPCM = UMO - ERNCM
 2600    CONTINUE
*  |  C(i) are the direction cosines of the emitted particle
*  |  (Jemiss) in the CMS frame, of course - C(i)
*  |  are the ones of the residual nucleus (Jresid if one of the
*  |  standard partcles, say the proton)
         CALL RACO (C(1),C(2),C(3))
         PCMS  = SQRT ( EEPCM**2 - Z2MASS (JEMISS) )
*  |  Now we perform the Lorentz transformation back to the original
*  |  frame (lab frame)
*  |  First the emitted particle:
         ETAX = ETACM * COSLBR (1)
         ETAY = ETACM * COSLBR (2)
         ETAZ = ETACM * COSLBR (3)
         PCMSX = PCMS * C (1)
         PCMSY = PCMS * C (2)
         PCMSZ = PCMS * C (3)
         ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
         EPS = GAMCM * EEPCM + ETAPCM - ZMASS (JEMISS)
         PHELP = ETAPCM / ( GAMCM + ONEONE ) + EEPCM
         PLBPX = PCMSX + ETAX * PHELP
         PLBPY = PCMSY + ETAY * PHELP
         PLBPZ = PCMSZ + ETAZ * PHELP
         PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
         COSLBP (1) = PLBPX / PHELP
         COSLBP (2) = PLBPY / PHELP
         COSLBP (3) = PLBPZ / PHELP
*  |  Then the residual nucleus ( for it c (i) --> - c (i) ):
         EREC  = GAMCM * ERNCM - ETAPCM - RNMASS
         EKRES = 1.D-03 * EREC
         PHELP = - ETAPCM / ( GAMCM + ONEONE ) + ERNCM
         PXRES = 1.D-03 * ( - PCMSX + ETAX * PHELP )
         PYRES = 1.D-03 * ( - PCMSY + ETAY * PHELP )
         PZRES = 1.D-03 * ( - PCMSZ + ETAZ * PHELP )
         P2RES = PXRES * PXRES + PYRES * PYRES + PZRES * PZRES
         PTRES = SQRT (P2RES)
         COSLBR (1) = PXRES / PTRES
         COSLBR (2) = PYRES / PTRES
         COSLBR (3) = PZRES / PTRES
*  |  Score the emitted particle
         NPART (JEMISS) = NPART (JEMISS) + 1
         SMOM1 (JEMISS) = SMOM1 (JEMISS) + EPS
         ITEMP=NPART(JEMISS)
         EPART(ITEMP,JEMISS)=EPS
         COSEVP(1,ITEMP,JEMISS)=COSLBP(1)
         COSEVP(2,ITEMP,JEMISS)=COSLBP(2)
         COSEVP(3,ITEMP,JEMISS)=COSLBP(3)
*  |  +----------------------------------------------------------------*
*  |  |  Check if the residual nucleus is one of the emitted particles
         IF ( JRESID .GT. 0 ) THEN
            J = JRESID
            GO TO 6102
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         JA = JA - IA (JEMISS)
         JZ = JZ - IZ (JEMISS)
* Umo is the invariant mass of the system!!
         UMO  = RNMASS
         UMO2 = UMO * UMO
         ELBTOT  = RNMASS + EREC
         GAMCM   = ELBTOT / RNMASS
         ETACM   = 1.D+03 * PTRES / RNMASS
         GO TO 1000
      END IF
*  |
*  +-------------------------------------------------------------------*
* Come to 23 at the beginning and after the end of a "normal"
* evaporation cycle
   23 CONTINUE
      A = JA
      Z = JZ
      IF(JA-8)8486,8488,8486
 8488 CONTINUE
      IF(JZ-4)8486,1224,8486
 8486 CONTINUE
      DO 2 K=1,6
         IF((A-FLA(K)).LE.(Z-FLZ(K))) THEN
            Q(K)=99999.D0
            GO TO 2
         END IF
         IF(A-TWOTWO*FLA(K))2,727,727
  727    CONTINUE
         IF(Z-TWOTWO*FLZ(K))2,728,728
  728    CONTINUE
         Q(K) = QNRG(A-FLA(K),Z-FLZ(K),A,Z) + EXMASS(K)
C 728    Q(K)=ENERGY(A-FLA(K),Z-FLZ(K))-ENERGY(A,Z)+EXMASS(K)
    2 CONTINUE
      FLKCOU(1)=ZERZER
      FLKCOU(2)=DOST(1,Z-FLZ(2))
      FLKCOU(3)=FLKCOU(2)+.06D+00
      FLKCOU(4)=FLKCOU(2)+.12D+00
      FLKCOU(6)=DOST(2,Z-FLZ(6))
      FLKCOU(5)=FLKCOU(6)-.06D+00
      CCOUL(1)=ONEONE
      CCOU2=DOST(3,Z-FLZ(2))
      CCOUL(2)=CCOU2+ONEONE
      CCOUL(3)=CCOU2*1.5D0+THRTHR
      CCOUL(4)=CCOU2+THRTHR
      CCOUL(6)=DOST(4,Z-FLZ(6))*TWOTWO+TWOTWO
      CCOUL(5)=TWOTWO*CCOUL(6)-ONEONE
      SIGMA=ZERZER
*  Initialize the flag which checks for open particle decay with
*  zero excitation and pairing --> for particle unstable residual
*  nuclei
      LOPPAR = .FALSE.
      DO 33 J=1,6
         IF(A-TWOTWO*FLA(J))5,725,725
  725    CONTINUE
         IF(Z-TWOTWO*FLZ(J))5,726,726
  726    CONTINUE
         MM=JA-IA(J)
         ZZ=Z-FLZ(J)
         AA=A-FLA(J)
         IF(AA.LE.ZZ)GO TO 5
*  Energy threshold for the emission of the jth-particle
         THRESH(J)=Q(J)+.88235D+00*FLKCOU(J)*FLZ(J)*
     &   ZZ/(RMASS(MM)+RHO(J))
         LOPPAR = LOPPAR .OR. THRESH (J) .GT. ZERZER
         IAA = NINT(AA)
         IZZ = NINT(ZZ)
         NN  = IAA - IZZ
*  The residual nucleus excitation energy ranges from 0 up
*  to U - Q (J)
         ILVMOD = IB0
         UMXRES = U - THRESH (J)
*  This is the a lower case of the level density
         SMALLA (J) = GETA ( UMXRES, IZZ, NN, ILVMOD, ISDUM, ASMMAX,
     &                       ASMMIN )
         CALL EEXLVL (IAA,IZZ,EEX1ST,EEX2ND,CORR)
         EEX1ST = 1.D+03 * EEX1ST
         EEX2ND = 1.D+03 * EEX2ND
         CORR   = 1.D+03 * MAX ( CORR, ZERZER )
         IF ( NN .EQ. 4 .AND. IZZ .EQ. 4 ) THEN
            IF ( U - THRESH (J) - 6.1D+00 .GT. ZERZER ) THEN
               CORR = SIXSIX
            ELSE
               TMPVAR = U-THRESH(J)-0.1D+00
               CORR = MAX ( ZERZER, TMPVAR )
            END IF
         END IF
         IF (NINT(FKEY).EQ.1) CORR=ZERZER
         CORRRR(J)=CORR
* Standard calculation:
         ARG=U-THRESH(J)-CORR
         IF(ARG)5,4,4
    5    CONTINUE
         R(J)=ZERZER
         S(J)=ZERZER
         SOS(J)=ZERZER
         GO TO 33
    4    CONTINUE
         S(J)=SQRT (SMALLA(J)*ARG)*TWOTWO
         SOS(J)=TENTEN*S(J)
   33 CONTINUE
      N1=1
      SES = MAX (S(1),S(2),S(3),S(4),S(5),S(6))
      DO 1131 J=1,6
         JS  = SOS(J) + ONEONE
         FJS = JS
         STRUN(J) = FJS - ONEONE
         IF ( S(J) .GT. ZERZER ) THEN
            MM  = JA-IA(J)
            SAS = EXP (S(J)-SES)
            SUS = EXP (-S(J))
            EYE1(J) = ( TWOTWO * S(J)**2 -SIXSIX * S(J)
     &              + SIXSIX + SUS * ( S(J)**2 - SIXSIX ) )
     &              / ( EIGEIG * SMALLA(J)**2 )
            IF ( J .EQ. 1 ) THEN
               EYE0(J) = ( S(J) - ONEONE + SUS ) / ( TWOTWO*SMALLA(J) )
* Standard calculation
               R   (J) = RMASS(MM)**2 * ALPH(MM) * ( EYE1(J) + BET(MM)
     &                 * EYE0(J) ) * SAS
            ELSE
               R   (J) = CCOUL(J) * RMASS(MM)**2 * EYE1(J) * SAS
            END IF
            R (J) = MAX ( ZERZER, R (J) )
            SIGMA = SIGMA + R (J)
         END IF
 1131 CONTINUE
      NCOUNT = 0
 6202 CONTINUE
      IF(SIGMA)9,9,10
 9    CONTINUE
      DO 6100 J = 1,6
         IF(JA-IA(J))6100,6101,6100
 6101    CONTINUE
         IF(JZ-IZ(J))6100,6102,6100
 6100 CONTINUE
      GO TO 6099
 6102 CONTINUE
      IF ( U .GT. ANGLGB ) GO TO 1000
      JEMISS = J
C*****STORE,RESIDUAL NUC IS OF EMITTED PARTICLE TYPE
* If we are here this means that the residual nucleus is equal to
* one of the six emitted particle (the j-th one). So give to it
* all the energy, score it and return with 0 recoil and excitation
* energy for the residual nucleus
      EPS = EREC
      NPART(JEMISS) = NPART(JEMISS)+1
      ITEMP=NPART(JEMISS)
      NRNEEP = NRNEEP + 1
      SMOM1(JEMISS) = SMOM1(JEMISS) + EPS
      ITEMP=NPART(JEMISS)
      EPART(ITEMP,JEMISS)=EPS
      COSEVP(1,ITEMP,JEMISS) = COSLBR(1)
      COSEVP(2,ITEMP,JEMISS) = COSLBR(2)
      COSEVP(3,ITEMP,JEMISS) = COSLBR(3)
      GO TO 8002
*
*-->-->-->-->--> go to return
 6099 CONTINUE
      IF(JA-8)72,51,72
   51 CONTINUE
      IF(JZ-4)72,1224,72
* Come here for a "normal" step
   10 CONTINUE
      LOPPAR = .FALSE.
      CALL GRNDM(RNDM,1)
      URAN=RNDM(1)*SIGMA
      SUM = ZERZER
      DO 16 J=1,6
         K   = J
         SUM = R(J)+SUM
         IF ( SUM - URAN .GT. 0.D+00 ) GO TO 17
   16 CONTINUE
   17 CONTINUE
      JEMISS=K
      NPART(JEMISS) = NPART (JEMISS) + 1
      JS = SOS (JEMISS) + ONEONE
      IF(JS-1000)4344,4345,4345
 4345 CONTINUE
      RATIO2=(S(JEMISS)**3-6.D0*S(JEMISS)**2+15.D0*
     &S(JEMISS)-15.D0)/((2.D0*S(JEMISS)**2-6.D0*S(JEMISS)+6.D0)*SMALLA
     &(JEMISS))
      GO TO 4347
 4344 CONTINUE
      RATIO2=(P2(JS)+(P2(JS+1)-P2(JS))*
     &(SOS(JEMISS)-STRUN(JEMISS)))/SMALLA(JEMISS)
 4347 CONTINUE
      EPSAV=RATIO2*TWOTWO
*  +-------------------------------------------------------------------*
*  |  Neutron channel selected:
      IF (JEMISS .EQ. 1) THEN
         MM=JA-IA(J)
         EPSAV=(EPSAV+BET(MM))/(ONEONE+BET(MM)*EYE0(JEMISS)
     &        /EYE1(JEMISS))
*  |  +----------------------------------------------------------------*
*  |  |  Compute the fission width relative to the neutron one:
*  |  |  this part is taken from subroutine EMIT of LAHET
         IF ( IFISS .GT. 0 .AND. JZ .GE. 71 .AND. .NOT. FISINH ) THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Compute the correction factor for the fission width:
            IF ( JZ .GT. 88 ) THEN
               AGOES = ONEONE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               AGOES = MAX ( ONEONE, ( U-SEVSEV ) / ( EPSAV+SEVSEV ) )
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  Finally this is the relative fission width:
*  |  |  This is : Probfs = 1 / ( 1 + G_n / G_f )
            PROBFS = FPROB ( Z, A, U ) / AGOES
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if it will be fission:
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. PROBFS ) THEN
               FISINH = .TRUE.
               KFISS  = 1
*  |  |  |  Undo the counting of the neutron evaporation
               NPART (JEMISS) = NPART (JEMISS) -1
               GO TO 9260
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
  20  CONTINUE
      CALL GRNDM(RNDM,2)
      E1=-HLFHLF*LOG(RNDM(1))
      E2=-HLFHLF*LOG(RNDM(2))
* Eps should be the total kinetic energy in the CMS frame
* Standard calculation:
      EPS=(E1+E2)*EPSAV+THRESH(JEMISS)-Q(JEMISS)
      AR = A - IA(JEMISS)
      ZR = Z - IZ(JEMISS)
* The CMS energy is updated
      IMASS = NINT (AR)
      IF ( IMASS .EQ. 8 .AND. NINT (ZR) .EQ. 4 ) THEN
         UNEW = U - EPS - Q(JEMISS)
         UMAX = U - THRESH(JEMISS)
         IF ( UNEW .GT. 6.D+00 ) THEN
            UMIN = 6.D+00
         ELSE IF ( UNEW .GT. 4.47D+00 .AND. UMAX .GT. 6.D+00 ) THEN
            UMIN = 4.47D+00
            UNEW = 6.D+00
         ELSE IF ( UNEW .GT. 1.47D+00 .AND. UMAX .GT. 2.94D+00 ) THEN
            UMIN = 1.47D+00
            UNEW = 2.94D+00
         ELSE
            UMIN = -0.1D+00
            UNEW = ANGLGB * 0.1D+00
         END IF
      ELSE IF ( IMASS .LE. 4 ) THEN
         IPRO = NINT ( ZR )
         INEU = IMASS - IPRO
         IF ( IMASS .EQ. 1 ) THEN
*  Be sure that residual neutrons or protons are not left excited
            UMIN = 0.D+00
            UNEW = 0.D+00
            EPS  = U - Q(JEMISS)
         ELSE IF ( IPRO .EQ. 0 .OR. INEU .EQ. 0 ) THEN
*  Ipro protons or ineu neutrons arrived here!
            UMIN = CORRRR(JEMISS)
            UNEW = U - EPS - Q(JEMISS)
         ELSE IF ( IMASS .LE. 2 ) THEN
*  Be sure that residual deuterons are not left excited!
            UMIN = 0.D+00
            UNEW = 0.D+00
            EPS  = U - Q(JEMISS)
         ELSE IF ( ABS ( INEU - IPRO ) .LE. 1 ) THEN
*  For the moment also residual 3-H, 3-He and 4-He are not left
*  excited !
            UMIN = 0.D+00
            UNEW = 0.D+00
            EPS  = U - Q(JEMISS)
         ELSE
            UMIN = CORRRR(JEMISS)
            UNEW = U - EPS - Q(JEMISS)
         END IF
      ELSE
         UMIN = CORRRR(JEMISS)
         UNEW = U - EPS - Q(JEMISS)
      END IF
* Standard calculation
      IF(UNEW-UMIN)6200,6220,6220
 6220 CONTINUE
*or   RNMASS = AR * AMUMEV + ENERGY (AR,ZR)
      RNMASS = AR * AMUMEV + ENERGY (AR,ZR) + UNEW
      UMIN2  = ( RNMASS + ZMASS (JEMISS) )**2
      IF ( UMIN2 .GE. UMO2 ) THEN
         GO TO 6200
      END IF
      U = UNEW
* C(i) are the direction cosines of the evaporated particle in the CMS
* frame, of course - C(i) are the ones of the residual nucleus
      CALL RACO(C(1),C(2),C(3))
* Erncm, Eepcm are the total energies of the residual nucleus and
* of the evaporated particle in the CMS frame
      ERNCM = 0.5D+00 * ( UMO2 + RNMASS**2 - Z2MASS (JEMISS) ) / UMO
      EEPCM = UMO - ERNCM
      PCMS  = SQRT ( EEPCM**2 - Z2MASS (JEMISS) )
* Now we perform the Lorentz transformation back to the original
* frame (lab frame)
* First the evaporated particle:
      ETAX = ETACM * COSLBR (1)
      ETAY = ETACM * COSLBR (2)
      ETAZ = ETACM * COSLBR (3)
      PCMSX = PCMS * C (1)
      PCMSY = PCMS * C (2)
      PCMSZ = PCMS * C (3)
      ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
      EPS = GAMCM * EEPCM + ETAPCM - ZMASS (JEMISS)
      PHELP = ETAPCM / (GAMCM + 1.D0) + EEPCM
      PLBPX = PCMSX + ETAX * PHELP
      PLBPY = PCMSY + ETAY * PHELP
      PLBPZ = PCMSZ + ETAZ * PHELP
      PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
      COSLBP (1) = PLBPX / PHELP
      COSLBP (2) = PLBPY / PHELP
      COSLBP (3) = PLBPZ / PHELP
* Then the residual nucleus ( for it c (i) --> - c (i) ):
      EREC  = GAMCM * ERNCM - ETAPCM - RNMASS
      EKRES = 1.D-03 * EREC
      PHELP = - ETAPCM / (GAMCM + 1.D0) + ERNCM
      PXRES = 1.D-03 * ( - PCMSX + ETAX * PHELP )
      PYRES = 1.D-03 * ( - PCMSY + ETAY * PHELP )
      PZRES = 1.D-03 * ( - PCMSZ + ETAZ * PHELP )
      P2RES = PXRES * PXRES + PYRES * PYRES + PZRES * PZRES
      PTRES = SQRT (P2RES)
      COSLBR (1) = PXRES / PTRES
      COSLBR (2) = PYRES / PTRES
      COSLBR (3) = PZRES / PTRES
* Check energy and momentum conservation !!
      IF (EREC .LE. 0.D+00) THEN
         PTRES = 0.D+00
         EREC  = 0.D+00
      END IF
* Umo is the invariant mass of the system!!
      UMO  = RNMASS
      UMO2 = UMO * UMO
      ELBTOT  = RNMASS + EREC
      GAMCM   = ELBTOT / RNMASS
      ETACM   = 1.D+03 * PTRES / RNMASS
      GO TO 76
 6200 CONTINUE
      NCOUNT = NCOUNT + 1
      IF ( NCOUNT .LE. 10 ) GO TO 20
      SIGMA = SIGMA - R(JEMISS)
* if we are here we have sampled for > 10 times a negative energy Unew
      NPART(JEMISS)=NPART(JEMISS)-1
      R(JEMISS) = 0.D0
      NCOUNT = 0
      GO TO 6202
   76 CONTINUE
      JAT=JA-IA(JEMISS)
      JZT=JZ-IZ(JEMISS)
      IF(JAT-JZT)9,9,77
   77 CONTINUE
      JA=JAT
      JZ=JZT
C*****STORE,END OF NORMAL CYCLE
      SMOM1(JEMISS)=SMOM1(JEMISS)+EPS
      ITEMP=NPART(JEMISS)
      EPART(ITEMP,JEMISS)=EPS
      COSEVP(1,ITEMP,JEMISS)=COSLBP(1)
      COSEVP(2,ITEMP,JEMISS)=COSLBP(2)
      COSEVP(3,ITEMP,JEMISS)=COSLBP(3)
* The following card switch to the rough splitting treatment
      IF (JA .LE. 2) GO TO 1000
      IF(JA-8)23,1223,23
 1223 CONTINUE
      IF(JZ-4)23,1224,23
* If we are here the residual nucleus is a 8-Be one, break it into
* two alphas with all the available energy (U plus the Q of the breakup)
* , score them and return with 0 recoil and excitation energy
 1224 CONTINUE
      LOPPAR = .FALSE.
      IF(U)1228,1229,1229
 1228 CONTINUE
      EPS=0.D0
      GO TO 1230
 1229 CONTINUE
 1230 CONTINUE
      NBE8=NBE8+1
* C(i) are the direction cosines of the first alpha in the CMS
* frame, of course - C(i) are the ones of the other
      CALL RACO(C(1),C(2),C(3))
* Ecms is the total energy of the alphas in the CMS frame
      ECMS  = 0.5D+00 * UMO
      PCMS  = SQRT ( ECMS**2 - Z2MASS (6) )
* Now we perform the Lorentz transformation back to the original
* frame (lab frame)
* First alpha:
      ETAX = ETACM * COSLBR (1)
      ETAY = ETACM * COSLBR (2)
      ETAZ = ETACM * COSLBR (3)
      PCMSX = PCMS * C (1)
      PCMSY = PCMS * C (2)
      PCMSZ = PCMS * C (3)
      ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
      EPS = GAMCM * ECMS + ETAPCM - ZMASS (6)
      PHELP = ETAPCM / (GAMCM + 1.D0) + ECMS
      PLBPX = PCMSX + ETAX * PHELP
      PLBPY = PCMSY + ETAY * PHELP
      PLBPZ = PCMSZ + ETAZ * PHELP
      PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
* Store the first alpha!!
      SMOM1(6) = SMOM1(6) + EPS
      NPART(6) = NPART(6) + 1
      ITEMP = NPART(6)
      EPART (ITEMP,6) = EPS
      COSEVP (1,ITEMP,6) = PLBPX / PHELP
      COSEVP (2,ITEMP,6) = PLBPY / PHELP
      COSEVP (3,ITEMP,6) = PLBPZ / PHELP
* Then the second alpha ( for it c (i) --> - c (i) ):
      EPS = GAMCM * ECMS - ETAPCM - ZMASS (6)
      PHELP = - ETAPCM / (GAMCM + 1.D0) + ECMS
      PLBPX = - PCMSX + ETAX * PHELP
      PLBPY = - PCMSY + ETAY * PHELP
      PLBPZ = - PCMSZ + ETAZ * PHELP
      PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
* Store the second alpha !!
      SMOM1(6) = SMOM1(6) + EPS
      NPART(6) = NPART(6) + 1
      ITEMP = NPART(6)
      EPART (ITEMP,6) = EPS
      COSEVP (1,ITEMP,6) = PLBPX / PHELP
      COSEVP (2,ITEMP,6) = PLBPY / PHELP
      COSEVP (3,ITEMP,6) = PLBPZ / PHELP
 8002 CONTINUE
      LOPPAR = .FALSE.
      EREC   = ZERZER
      U      = ZERZER
      EKRES  = ZERZER
      PTRES  = ZERZER
   72 CONTINUE
      HEVSUM=SMOM1(3)+SMOM1(5)+SMOM1(6)+SMOM1(4)
      RETURN
*.......................................................................
*///// RAL FISSION ROUTINE /////
 9260 CONTINUE
*  +-------------------------------------------------------------------*
*  |  Record the direction cosines of the fissioning nucleus
      DO 9270 I=1,3
         COSLF0 (I) = COSLBR (I)
 9270 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      CALL FISFRA ( JA, JZ, U, EREC, UMO, GAMCM, ETACM )
*  +-------------------------------------------------------------------*
*  |  Check for fission failures!!
      IF ( .NOT. FISINH ) THEN
         PENBAR = .FALSE.
         GO TO 23
      END IF
*  |
*  +-------------------------------------------------------------------*
*  Do not pick up the fission fragments, rather go back to Evevap
      HEVSUM=SMOM1(3)+SMOM1(5)+SMOM1(6)+SMOM1(4)
      RETURN
      END
+SELF.
+DECK,  EEXI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE EEXI.FOR
*COPY EEXI
*                                                                      *
*=== eexi =============================================================*
*                                                                      *
      FUNCTION EEXI(IJ,E,A)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C
C     NUCLEAR EXCITATION ENERGY INCLUDING ALL LOW ENERGY SECONDARIES
C     IN COLLISIONS OF PARTICLE IJ OF ENERGY E GEV ON NUCLEI A
C
C     NOTE!!!!!!! NON-STANDARD PARTICLE NUMBERING
C
C********************************************************************
C
      IF (E.LE.0.125D0) GO TO 20
      B=SQRT(A)/9.D0-.2D0
      IF (B.GT.A*0.01D0) B=A*0.01D0
      IF (E.GE.3.D0) GO TO 10
      IF (B.LT.0.125D0) B=0.125D0
      EEXI=0.125D0+(E-0.125D0)*(B-0.125D0)/2.875D0
      RETURN
   10 CONTINUE
      EEXI=B
      RETURN
   20 CONTINUE
      EEXI=E
      RETURN
      END
+DECK,  EEXLVL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:55  cernlib
* Geant

*$ CREATE EEXLVL.FOR
*COPY EEXLVL
*=== eexlvl ===========================================================*
      SUBROUTINE EEXLVL ( JA, JZ, EEX1ST, EEX2ND, EEXCON )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 06 december 1991  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 28-apr-92     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, EVA0.
*
      SAVE SQATAR, JAOLD
      DATA JAOLD / 0 /
*
      IF ( JA .EQ. JZ ) THEN
         EEXCON = 0.D+00
         EEX1ST = 0.D+00
         EEX2ND = 0.D+00
         RETURN
      END IF
      IF ( JZ .EQ. 0 .OR. JA .EQ. JZ ) THEN
         EEXCON = 0.D+00
      ELSE
         EEXCON = 1.D-03 * ( CAM4 (JZ) + CAM5 (JA-JZ) )
      END IF
*  **** Very tentative selection of Eex1st, Eex2nd, based on pairing
*       energies according to delta = 12 MeV / A^1/2 ****
      IZODD  = 1 - MOD ( JZ, 2 )
      INODD  = 1 - MOD ( JA-JZ, 2 )
      IODD   = IZODD + INODD
*  +-------------------------------------------------------------------*
*  |  Even-even nucleus
      IF ( IODD .GE. 2 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( JA .NE. JAOLD ) THEN
            JAOLD  = JA
            DJA = JA
            SQATAR = SQRT ( DJA )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         EEX1ST = 12.0D-03 / SQATAR
         EEX2ND = 2.D+00 * EEX1ST
*  |
*  +-------------------------------------------------------------------*
*  |  even-odd nucleus
      ELSE IF ( IODD .GT. 0 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( JA .NE. JAOLD ) THEN
            JAOLD  = JA
            DJA    = JA
            SQATAR = SQRT ( DJA )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         EEX1ST = 12.0D-03 / SQATAR
         EEX2ND = EEX1ST
*  |
*  +-------------------------------------------------------------------*
*  |  odd-odd nucleus
      ELSE
         EEX2ND = 0.D+00
         EEX1ST = 0.D+00
      END IF
*  |
*  +-------------------------------------------------------------------*
      RETURN
*=== End of subroutine eexlvl =========================================*
      END
+DECK,  EKEKA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE EKEKA.FOR
*COPY EKEKA
*                                                                      *
*=== ekeka ============================================================*
*                                                                      *
      FUNCTION EKEKA(IX,TO,AMSS,SQAMSS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C     LAST CHANGE 05. DECEMBER BY    PERTTI AARNIO
C                                    HELSINKI UNIVERSITY OF
C                                    TECHNOLOGY, FINLAND
C
C     TO BE CALLED FROM THE HIGH ENERGY PRODUCTION
C
C     THIS IS A SUBROUTINE OF FLUKA TO CALCULATE THE ENERGY AVAILABLE
C     FOR THE REACTION "IX".
C
C     NOTE!!!!!!! REACTION NUMBERING IS NOT
C     COMPATIBLE WITH PARTICLE NUMBERING
C
C     INPUT VARIABLES:
C        IX     = TYPE OF THE REACTION
C                 1=NUCLEAR EXCITATION
C                 2=INTRANUCLEAR PROTON
C                 3=INTRANUCLEAR NEUTRON
C                 4=1+2
C                 5=1+2+3
C        TO     = KINETIC ENERGY OF THE COLLIDING PARTICLE IN GEV
C        AMSS   = ATOMIC WEIGHT OF THE MEDIUM
C        SQAMSS = SQRT(AMSS)
C
C     SEE RANFT/ROUTTI PARTICLE ACC VOL 4 P 106
C
C     NOTE THAT IN INTRANUCLEAR PART AVERAGE TOTAL ENERGY IS
C     OBTAINED BY MULTPLYING THE AVERAGE ENERGY OF THE HIGH ENERGY
C     PARTICLES BY THE MULTIPLICITY OF THE HIGH ENERGY PARTICLES
C     I.1. E-TOT,AV=2.5*N2*E-AV(ALFA-2).  THE FACTOR 2.5 IS
C     NEEDED TO TAKE INTO ACCOUNT THE LOW ENERGY PART ALSO.
C     2.5 IS BASED ON THE ASSUMPTION THAT N1/N2=9 AND THAT
C     (E-AV(ALFA-2))/(E-AV(ALFA-1))=6.
C********************************************************************
C
      GO TO (1,2,3,1,1),IX
C
C
    1 CONTINUE
      IF (TO.GT.01D0)GO TO 12
      AA=0.001D0*SQAMSS
      GO TO 19
   12 CONTINUE
      APAR=0.035D0
      BPAR=3.D0
      CPAR=0.1D0
      AA=CPAR*SQAMSS*(0.01D0+APAR*(BPAR+LOG10(TO))**2)
C
   19 CONTINUE
      IF (IX.GT.3) GO TO 2
      EKEKA=AA
      RETURN
C
C
    2 CONTINUE
      AN=ANKEKA(1,TO,AMSS,SQAMSS)
      A=AKEKA(1,TO,AMSS)
      EXTOA=0.D0
      IF(TO.LT.5.D0*A) EXTOA=EXP(-TO/A)
      TPKAV=A*(1.D0-(TO/A+1.)*EXTOA)/(1.D0-EXTOA)
      BB=2.5D0*TPKAV*AN
C
      IF (IX.EQ.4) GO TO 4
      IF (IX.EQ.5) GO TO 3
      EKEKA=BB
      RETURN
C
C
    3 CONTINUE
      AN=ANKEKA(2,TO,AMSS,SQAMSS)
      A=AKEKA(2,TO,AMSS)
      EXTOA=0.D0
      IF (TO.LT.5.D0*A) EXTOA=EXP(-TO/A)
      TNKAV=A*(1.D0-(TO/A+1.D0)*EXTOA)/(1.D0-EXTOA)
      CC=2.5D0*TNKAV*AN
C
      IF (IX.EQ.5) GO TO 5
      EKEKA=CC
      RETURN
C
C
    4 CONTINUE
      EKEKA=AA+BB
      RETURN
C
C
    5 CONTINUE
      EKEKA=AA+BB+CC
      RETURN
      END
+DECK,  ENERGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

*$ CREATE ENERGI.FOR
*COPY ENERGI
*=== energi ===========================================================*
      SUBROUTINE ENERGI(IT,LL,LT,IV,RE,HMA,HE,E0,A1)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Energi89: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
*      INCLUDE '(BAMJCM)'
+CDE, FINPAR2.
      DIMENSION IV(*),RE(*)
      REAL RNDM(1)
C     SAMPLES THE ENERGY OF THE CREATED HADRON
C*****HE IS THE ENERGY OF THE ACTUAL HADRON
      I=IT
      J=IT-1
      HMA=AMF(I)
      IF(IT .EQ. 1) RX=E0
      IF(IT .GT. 1) RX=RE(J)
      CALL GRNDM(RNDM,1)
      X   = RNDM(1)
      IVY = IV(I)
      GO TO (1,2,2,1,1,1,2,2,1,1),IVY
C     MESON VERTEX
    1 AX=(1.D0-A1)/(3.D0*A1)
      C=1.D0/((1.D0-A1)*(1.D0-HMA/RX)+3.D0*.5D0*A1*(1.D0-HMA/RX)**2)
      ETA=-AX+SQRT(AX**2+X*2.D0/(3.D0*A1*C))
      GO TO 3
C     BARYON VERTEX
    2 CY=1.D0/((1.D0-A1)*(1.D0-HMA/RX)+A1*(1.D0-HMA/RX)**3)
      BY=X/(2.D0*A1*CY)
      BZ=((1.D0-A1)/(3.D0*A1))**3
      BV=BY+SQRT(BY**2+BZ)
      BU=BY-SQRT(BY**2+BZ)
      IF(BU.LT.0.D0) BU1=ABS(BU)
      BU3=BU1**(1.D0/3.D0)
      BV3=BV**(1.D0/3.D0)
      IF(BU.LT.0.D0) BU3=-BU3
      ETA=BU3+BV3
      GO TO 3
    3 CONTINUE
      RE(I)=ETA*RX
      HE=(1.D0-ETA)*RX
      HEF(I)=HE
      RETURN
      END
+DECK,  ENERGY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:55  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== energy ===========================================================*
*                                                                      *
      FUNCTION ENERGY(A,Z)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C--------------------------------------------------------------------
C SUBNAME = ENERGY
C--------------------------------------------------------------------
+CDE, EVA0.
C--------------------------------------------------------------------
      KA0 = NINT ( A )
      KZ0 = NINT ( Z )
      N   = KA0 - KZ0
      IF ( N .LE. 0 ) THEN
         IF ( KA0 .NE. 1 ) THEN
            IF ( N .LT. 0 ) THEN
               WRITE ( LUNOUT, * )
     &         ' Stopped in energy: mass number =< atomic number !!',
     &           KA0, KZ0
            END IF
         ELSE
            ENERGY = WAPS ( 1, 3 )
            RETURN
         END IF
      END IF
      IZZ = NINT ( WAPS ( KA0, 1 ) )
      IF ( KZ0 .LT. IZZ .OR. KZ0 .GT. IZZ + 9 ) THEN
         ENERGY = ENRG ( A, Z )
         RETURN
      ELSE
         IZ0 = KZ0 - IZZ + 2
         ENERGY = WAPS ( KA0, IZ0 )
         IF ( ENERGY .EQ. 0.D+00 .AND. (KA0 .NE. 12 .OR. KZ0 .NE. 6) )
     &        ENERGY = ENRG ( A, Z )
         RETURN
      END IF
*     RETURN
      END
+SELF.
+DECK,  ENRG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:55  cernlib
* Geant

*$ CREATE ENRG.FOR
*COPY ENRG
*                                                                      *
*=== enrg =============================================================*
*                                                                      *
      FUNCTION ENRG(A,Z)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C--------------------------------------------------------------------
C SUBNAME = ENRG
C--------------------------------------------------------------------
      PARAMETER ( O16OLD = 931.145  D+00 )
      PARAMETER ( O16NEW = 931.19826D+00 )
      PARAMETER ( O16RAT = O16NEW / O16OLD )
      PARAMETER ( C12NEW = 931.49432D+00 )
      PARAMETER ( ADJUST = -8.322737768178909D-02 )
+CDE, EVA0.
      LOGICAL LFIRST
      SAVE LFIRST, EXHYDR, EXNEUT
      DATA LFIRST / .TRUE. /
      IF ( LFIRST ) THEN
         LFIRST = .FALSE.
         EXHYDR = FKENER ( ONEONE, ONEONE )
         EXNEUT = FKENER ( ONEONE, ZERZER )
      END IF
C--------------------------------------------------------------------
  100 IZ0 = NINT (Z)
      IF ( IZ0 .LE. 0 ) THEN
         ENRG = A * EXNEUT
         RETURN
      END IF
      N   = NINT (A-Z)
      IF ( N .LE. 0 ) THEN
         ENRG = Z * EXHYDR
         RETURN
      END IF
      AM2ZOA= (A-Z-Z)/A
      AM2ZOA=AM2ZOA*AM2ZOA
      A13 = RMASS(NINT(A))
      AM13 = 1.D0/A13
      EV=-17.0354D0*(1.D0 -1.84619D0*AM2ZOA)*A
      ES= 25.8357D0*(1.D0 -1.712185D0*AM2ZOA)*
     &    (1.D0 -0.62025D0*AM13*AM13)*
     &    (A13*A13 -.62025D0)
      EC= 0.799D0*Z*(Z-1.D0)*AM13*(((1.5772D0*AM13 +1.2273D0)*
     &    AM13-1.5849D0)*
     &    AM13*AM13 +1.D0)
      EEX= -0.4323D0*AM13*Z**1.3333333D0*
     &   (((0.49597D0*AM13 -0.14518D0)*AM13 -0.57811D0) * AM13 + 1.D0)
      ENRG  =8.367D0*A -0.783D0*Z +EV +ES +EC +EEX +CAM2(IZ0)+CAM3(N)
      ENRG  = ( ENRG + A * O16OLD ) * O16RAT - A * ( C12NEW - ADJUST )
      ENRG  = MIN ( ENRG, Z * EXHYDR + ( A - Z ) * EXNEUT )
      RETURN
      END
+DECK,  ERUP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:55  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== erup =============================================================*
*                                                                      *
      SUBROUTINE ERUP (JFISS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created  on   15 may 1990     by     Alfredo & Paola Sala        *
*                                              INFN - Milan            *
*     Last change  on   10-apr-93   by     Alfredo Ferrari, INFN-Milan *
*                                                                      *
*     Derived from the ERUP routine of EVAP-V, HERMES, KFA-Julich      *
*                                                                      *
*----------------------------------------------------------------------*
*
C*****MODIFIED TO OBTAIN APR,ZPR AFTER CAS + EVAP (8-68,T.W.A.)
+CDE, EVA1.
+CDE, FORCN.
+CDE, INPFLG.
+CDE, HETC5.
+CDE, HETC7.
+CDE, HETTP.
+CDE, HIGFIS.
*     COMMON / AZ /    LOWAZ
      LOGICAL LOPPAR
      DIMENSION  FPART (6)
C     -------------------------------------- CHECK PARAMETER
      FISINH=.FALSE.
*  +-------------------------------------------------------------------*
*  |  Check the excitation energy
      IF ( EX .LE. ZERZER ) THEN
*  |  No excitation energy:
         IF ( JFISS .LE. 0 ) THEN
            DO 201 I=1,6
               NPART(I)=0
  201       CONTINUE
            HEVSUM = ZERZER
         END IF
*        UU = ZERZER
         UU = EX
         RETURN
*  |
*  +-------------------------------------------------------------------*
*  |  Positive excitation energy:
      ELSE
*  |  Try evaporation
         M2 = NINT (APR)
         M3 = NINT (ZPR)
 8801    CONTINUE
         CALL FKDRES (M2,M3,EX,UU,EREC,LOPPAR,JFISS)
         FPARTT = ZERZER
*  |  +----------------------------------------------------------------*
*  |  |  No previous evaporation for this event
         IF ( JFISS .LE. 0 ) THEN
            DO 801 I=1,6
               FPART(I) = NPART(I)
               FPARTT   = FPARTT + FPART (I)
  801       CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |  Other evaporation trials already performed for this event
         ELSE
            DO 802 I=1,6
               FPART(I) = NPART(I)-NPARTF(I,JFISS-1)
               FPARTT   = FPARTT + FPART (I)
  802       CONTINUE
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |  No particle evaporated and pairing corrections accounted for
         IF ( FPARTT + FKEY .LT. ANGLGB ) THEN
            IF ( .NOT. LOPPAR ) GO TO 8802
            FKEY = ONEONE
            GO TO 8801
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 8802    CONTINUE
         FKEY = ZERZER
         ZPR  = ZPR - FPART(2) - FPART(3) - TWOTWO * ( FPART(5)
     &        + FPART(6)) - FPART(4)
         APR  = APR - FPART(1) - FPART(2) - TWOTWO * FPART(3)
     &        - THRTHR * ( FPART(4) + FPART(5) ) - FOUFOU * FPART(6)
         IF (IANG .GT. 0) THEN
         ELSE
            DO 440 K=1,6
               NP = NPART(K)
               IF ( JFISS .GT. 0 ) THEN
                  NP0 = NPARTF(K,JFISS-1) + 1
               ELSE
                  NP0 = 1
               END IF
               DO 410 J=NP0,NP
                  CALL RACO(COSEVP(1,J,K),COSEVP(2,J,K),COSEVP(3,J,K))
  410          CONTINUE
  440       CONTINUE
         END IF
      END IF
*  |
*  +-------------------------------------------------------------------*
      RETURN
*=== End of subroutine Erup ===========================================*
      END
+SELF.
+DECK,  EVDEEX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:55  cernlib
* Geant

*$ CREATE EVDEEX.FOR
*COPY EVDEEX
*=== evdeex ===========================================================*
      SUBROUTINE EVDEEX ( WEE )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  Evdeex :  created on 5-10-1990 by A. Ferrari & P. Sala, INFN Milan  *
*                                                                      *
*    Last change  on  28-jan-93   by   Alfredo Ferrari, INFN-Milan     *
*                                                                      *
*    This routine provides a simple model for sampling nuclear deexci- *
*    tation gammas following the evaporation step                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, EVA0.
+CDE, FINUC.
+CDE, NUCDAT.
+CDE, PAREVT.
+CDE, RESNUC.
*
*----------------------------------------------------------------------*
*  Entering the routine we have:                                       *
*            Ammres is the atomic mass of the residual nucleus         *
*            Ibres (Anow) its mass number                              *
*            Icres (Znow) its atomic number                            *
*            Eres         its total energy                             *
*            Ptres        its momentum                                 *
*            Pxres        x-component of the momentum                  *
*            Pyres        y-component of the momentum                  *
*            Pzres        z-component of the momentum                  *
*            Tvrecl       kinetic energy                               *
*            Tvcms        excitation energy                            *
*----------------------------------------------------------------------*
*
      PARAMETER ( C0M1E1 = 0.306 D+00 )
      PARAMETER ( C0E2E1 = 7.1   D-01 )
      PARAMETER ( HNDFE1 = 5.0   D-03 )
      PARAMETER ( HNDFM1 = 5.0   D-02 )
      PARAMETER ( HNDFE2 = 1.0   D+01 )
*
      DIMENSION COSGAM (3)
      REAL RNDM(2)
*
      IDEEXG = 0
      IF ( IBRES .LE. 0 .OR. TVCMS .LE. GAMMIN ) THEN
         TVCMS = 0.D+00
         RETURN
      END IF
      ECHCK  = ERES - AMMRES
      ECHCK0 = ECHCK
      IBHELP = IBRES / 2
      IF ( IBHELP * 2 .LT. IBRES ) THEN
         CALL EEXLVL ( IBRES, ICRES, DELTA, EEX2ND, EEXDUM )
         IPAR  = 1
         JPAR  = 1
      ELSE
         ICHELP = ICRES / 2
         JPAR   = 0
         IF ( ICHELP * 2 .LT. ICRES ) THEN
            CALL EEXLVL ( IBRES, ICRES, DELTA, EEX1ST, EEXDUM )
            IPAR  = 1
         ELSE
            CALL EEXLVL ( IBRES, ICRES, EEX1ST, DELTA, EEXDUM )
            IPAR  = 2
         END IF
      END IF
      DELPAI = MIN ( EEXDUM, DELTA )
      RNUCL  = R0NUCL * RMASS (IBRES)
      AINERM = 0.24D+00 * AMMRES * RNUCL * RNUCL
      ROTEN0 = 0.5D+00 * PLABRC * PLABRC / AINERM
      ENMIN  = MAX ( DELTA, TWOTWO * ROTEN0 )
      RNMASS = AMMRES + TVCMS
      UMO = RNMASS
      GAMCM  = ERES  / RNMASS
      ETAX   = PXRES / RNMASS
      ETAY   = PYRES / RNMASS
      ETAZ   = PZRES / RNMASS
      IF ( TVCMS .LE. ENMIN .OR. IBRES .LE. 4 ) GO TO 3000
      AHELP  = HNDFE1 * RMASS (IBRES) * RMASS (IBRES)
      CFM1E1 = C0M1E1 * HNDFM1 / AHELP
      CFE2E1 = C0E2E1 * HNDFE2 / AHELP
 1000 CONTINUE
         UMEV   = 1.D+03 * TVCMS
         ASMALL = GETA ( UMEV  , ICRES , IBRES-ICRES, ILVMOD, ISDUM,
     &                   AOGMAX, AOGMIN )
         TEMPSQ = 1.D-03 * ( TVCMS - DELPAI ) / ASMALL
         TEMPER = SQRT ( TEMPSQ )
         HHH    = TVCMS / TEMPER
         HHHSQ  = HHH * HHH
         IF(HHH.GT.88) THEN
            AHELP=0.0
         ELSE
            AHELP  = EXP ( - HHH )
         ENDIF
         BRE1M1 = 6.D+00 - AHELP * ( HHHSQ * HHH + 3.D+00 * HHHSQ
     &          + 6.D+00 * HHH )
         BRE2   = 20.D+00 * BRE1M1 - AHELP * ( HHHSQ * HHHSQ * HHH
     &          + 5.D+00 * HHHSQ * HHHSQ )
         BRE1M1 = BRE1M1 * ( 1.D+00 + CFM1E1 )
         BRE2   = BRE2 * TEMPSQ * CFE2E1
         CALL GRNDM(RNDM,1)
         IF ( RNDM (1) .LT. BRE1M1 / ( BRE1M1 + BRE2 ) ) THEN
            LMULT = 1
         ELSE
            LMULT = 2
         END IF
         LEXPN = 2 * LMULT + 1
         DDLEXP = LEXPN
         XDISMX = MIN ( DDLEXP, HHH )
         IF(XDISMX.GT.88) THEN
            DISMX=0.
         ELSE
            DISMX  = XDISMX ** LEXPN * EXP ( - XDISMX )
         ENDIF
 2000    CONTINUE
            CALL GRNDM(RNDM,2)
            XTENT = RNDM (1) * HHH
            IF(XTENT.GT.88) THEN
               FREJE = 0.
            ELSE
               FREJE = XTENT ** LEXPN * EXP ( - XTENT ) / DISMX
            ENDIF
         IF ( RNDM (2) .GE. FREJE ) GO TO 2000
         ENERG0 = XTENT * TEMPER
         TVCMS  = TVCMS - ENERG0
         RNMASS = AMMRES + TVCMS
         CALL RACO ( COSGAM (1), COSGAM (2), COSGAM (3) )
         ERNCM = 0.5D+00 * ( UMO * UMO + RNMASS * RNMASS ) / UMO
         EEGCM = UMO - ERNCM
         PCMS  = EEGCM
         PCMSX = PCMS * COSGAM (1)
         PCMSY = PCMS * COSGAM (2)
         PCMSZ = PCMS * COSGAM (3)
         ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
         ENERG = GAMCM * EEGCM + ETAPCM
         PHELP = ETAPCM / ( GAMCM + 1.D+00 ) + EEGCM
         PLBGX = PCMSX + ETAX * PHELP
         PLBGY = PCMSY + ETAY * PHELP
         PLBGZ = PCMSZ + ETAZ * PHELP
         ERES  = GAMCM * ERNCM - ETAPCM
         EKRES = ERES - RNMASS
         PHELP = - ETAPCM / ( GAMCM + 1.D+00 ) + ERNCM
         PXRES = - PCMSX + ETAX * PHELP
         PYRES = - PCMSY + ETAY * PHELP
         PZRES = - PCMSZ + ETAZ * PHELP
         ECHCK  = ECHCK - ENERG
         IDEEXG = IDEEXG + 1
         NP     = NP + 1
         WEI   (NP) = WEE
         KPART (NP) = 7
         TKI   (NP) = ENERG
         PLR   (NP) = ENERG
         CXR   (NP) = PLBGX / ENERG
         CYR   (NP) = PLBGY / ENERG
         CZR   (NP) = PLBGZ / ENERG
         GAMCM  = ERES  / RNMASS
         ETAX   = PXRES / RNMASS
         ETAY   = PYRES / RNMASS
         ETAZ   = PZRES / RNMASS
         UMO    = RNMASS
      IF ( TVCMS .GT. ENMIN ) GO TO 1000
      IF ( NP .GE. MXP ) THEN
         WRITE ( LUNOUT, * )' **** Finuc overflow in Evdeex,',
     &                      ' program stopped ****'
         WRITE ( LUNERR, * )' **** Finuc overflow in Evdeex,',
     &                      ' program stopped ****'
         STOP
      END IF
 3000 CONTINUE
         IF ( TVCMS .LE. ( 6 + 2 * JPAR ) * ROTEN0 ) THEN
            ENERG0 = TVCMS
            TVCMS  = 0.D+00
            CALL RACO ( COSGAM (1), COSGAM (2), COSGAM (3) )
            ERNCM = 0.5D+00 * ( UMO * UMO + AMMRES * AMMRES ) / UMO
            EEGCM = UMO - ERNCM
            PCMS  = EEGCM
            PCMSX = PCMS * COSGAM (1)
            PCMSY = PCMS * COSGAM (2)
            PCMSZ = PCMS * COSGAM (3)
            ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
            ENERG = GAMCM * EEGCM + ETAPCM
            PHELP = ETAPCM / ( GAMCM + 1.D+00 ) + EEGCM
            PLBGX = PCMSX + ETAX * PHELP
            PLBGY = PCMSY + ETAY * PHELP
            PLBGZ = PCMSZ + ETAZ * PHELP
            ERES  = GAMCM * ERNCM - ETAPCM
            EKRES = ERES - AMMRES
            PHELP = - ETAPCM / ( GAMCM + 1.D+00 ) + ERNCM
            PXRES = - PCMSX + ETAX * PHELP
            PYRES = - PCMSY + ETAY * PHELP
            PZRES = - PCMSZ + ETAZ * PHELP
            ECHCK  = ECHCK - ENERG
            IDEEXG = IDEEXG + 1
            NP     = NP + 1
            WEI   (NP) = WEE
            KPART (NP) = 7
            TKI   (NP) = ENERG
            PLR   (NP) = ENERG
            CXR   (NP) = PLBGX / ENERG
            CYR   (NP) = PLBGY / ENERG
            CZR   (NP) = PLBGZ / ENERG
         ELSE
            AIAMOM = SQRT ( 0.25D+00 + TVCMS / ROTEN0
     &             + 0.75D+00 * JPAR ) - 0.25D+00
            IF ( IPAR .EQ. 1 ) THEN
               IF ( JPAR .EQ. 1 ) THEN
                  JAMIN = 2 * INT ( AIAMOM ) + 1
                  IAMIN = JAMIN / 2
                  IF ( MOD ( IAMIN, 2 ) .GT. 0 ) THEN
                     EGROUN = 3.75D+00 * ROTEN0
                  ELSE
                     EGROUN = 0.75D+00 * ROTEN0
                  END IF
               ELSE
                  IAMIN = INT ( AIAMOM )
                  JAMIN = 2 * IAMIN
                  IF ( MOD ( IAMIN, 2 ) .GT. 0 ) THEN
                     EGROUN = 2.D+00 * ROTEN0
                  ELSE
                     EGROUN = 0.D+00
                  END IF
               END IF
            ELSE
               IAMIN  = INT ( AIAMOM ) / IPAR
               IAMIN  = IAMIN * IPAR
               JAMIN  = 2 * IAMIN
               EGROUN = 0.D+00
            END IF
            DELTAE = TVCMS + EGROUN - 0.25D+00 * ROTEN0 * JAMIN *
     &             ( JAMIN + 2 )
            DO 4000 JAMOM = JAMIN, 4, -4
               ENERG0 = ROTEN0 * ( 2 * JAMOM - 2 )
     &                + DELTAE
               DELTAE = 0.D+00
               TVCMS  = TVCMS - ENERG0
               RNMASS = AMMRES + TVCMS
               CALL RACO ( COSGAM (1), COSGAM (2), COSGAM (3) )
               ERNCM = 0.5D+00 * ( UMO * UMO + RNMASS * RNMASS ) / UMO
               EEGCM = UMO - ERNCM
               PCMS  = EEGCM
               PCMSX = PCMS * COSGAM (1)
               PCMSY = PCMS * COSGAM (2)
               PCMSZ = PCMS * COSGAM (3)
               ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
               ENERG = GAMCM * EEGCM + ETAPCM
               PHELP = ETAPCM / ( GAMCM + 1.D+00 ) + EEGCM
               PLBGX = PCMSX + ETAX * PHELP
               PLBGY = PCMSY + ETAY * PHELP
               PLBGZ = PCMSZ + ETAZ * PHELP
               ERES  = GAMCM * ERNCM - ETAPCM
               EKRES = ERES - RNMASS
               PHELP = - ETAPCM / ( GAMCM + 1.D+00 ) + ERNCM
               PXRES = - PCMSX + ETAX * PHELP
               PYRES = - PCMSY + ETAY * PHELP
               PZRES = - PCMSZ + ETAZ * PHELP
               ECHCK  = ECHCK - ENERG
               IDEEXG = IDEEXG + 1
               NP     = NP + 1
               WEI   (NP) = WEE
               KPART (NP) = 7
               TKI   (NP) = ENERG
               PLR   (NP) = ENERG
               CXR   (NP) = PLBGX / ENERG
               CYR   (NP) = PLBGY / ENERG
               CZR   (NP) = PLBGZ / ENERG
               GAMCM  = ERES / RNMASS
               ETAX   = PXRES / RNMASS
               ETAY   = PYRES / RNMASS
               ETAZ   = PZRES / RNMASS
               UMO    = RNMASS
 4000       CONTINUE
         END IF
      ECHCK  = ECHCK - EKRES
      IF ( ABS ( ECHCK ) .GT. 1.D-7 * ECHCK0 ) THEN
         WRITE ( LUNERR, * )' **** No energy conservation in Evdeex',
     &                      ' ****', ECHCK, IDEEXG
      END IF
      TVCMS = 0.D+00
      IF ( NP .GT. MXP ) THEN
         WRITE ( LUNOUT, * )' **** Finuc overflow in Evdeex,',
     &                      ' program stopped ****'
         WRITE ( LUNERR, * )' **** Finuc overflow in Evdeex,',
     &                      ' program stopped ****'
         STOP
      END IF
      TVRECL = EKRES
      P2RES = PXRES * PXRES + PYRES * PYRES + PZRES * PZRES
      PTRES = SQRT (P2RES)
*=== End of subroutine Evdeex =========================================*
      RETURN
      END
+DECK,  EVENTV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:55  cernlib
* Geant

*$ CREATE EVENTV.FOR
*COPY EVENTV
*=== eventv ===========================================================*
      SUBROUTINE EVENTV ( IJIJ, POO, EKE, TXI, TYI, TZI, WE, IMAT )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  Created  on  7 september 1989      by         Alfredo Ferrari       *
*                                                 INFN - Milan         *
*                                                                      *
*  Last change  on  15 april 1993     by         Alfredo Ferrari       *
*                                                                      *
*  This routine is a strongly modified and improved version of the     *
*  original Eventq routine of the Fluka package: it requires modified  *
*  versions of many other routines                                     *
*                                                                      *
*  Eventv90: new version by A. Ferrari, INFN-Milan and CERN-SPS, 7-9-89*
*       main modifications:                                            *
*                  - new treatment for hydrogen (following Moehring's  *
*                                                suggestion)           *
*                  - new commons and coding for energy, momentum,      *
*                    electric and baryonic charge conservation         *
*                  - new correlations both in the "low" (p < 5 GeV/c)  *
*                    and in the "high" energy models                   *
*                  - complete revision of kinematics for both models   *
*                  - tentative treatment for Lambdas, Sigmas with the  *
*                    "high" energy model down to 2.5 GeV/c to overcome *
*                    the impossibility of Hadrin to treat these parti- *
*                    cles                                              *
*                  - tentative introduction of Xsi0, Xsi-, Omega and   *
*                    their antiparticles and of Sigmabars's            *
*                  - complete new treatment of cascade nucleons        *
*                  - accurate treatment of binding energy effects,     *
*                    using atomic mass tables and the proper isotopic  *
*                    composition of elements                           *
*                  - possibility to use an evaporation module (derived *
*                    from the Hetc-Kfa one) after the interaction      *
*                  - possibility to use a nuclear gamma deexcitation   *
*                    module (written by P.Sala, INFN-Milan) to produce *
*                    deexcitation gammas after the evaporation step    *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER ( COS45 = 0.7071067811865475D+00 )
      PARAMETER ( SIN30 = 0.5D+00 )
      PARAMETER ( COS30 = 0.8660254037844387D+00 )
      PARAMETER ( CSNPRN = 50.D+00 * CSNNRM )
+CDE, BALANC.
+CDE, CORINC.
+CDE, DEPNUC.
+CDE, FHEAVY.
+CDE, FINLSP3.
+CDE, FINUC.
+CDE, HADFLG.
+CDE, HADPAR.
+CDE, ISOTOP.
+CDE, MAPA.
+CDE, NUCDAT.
+CDE, NUCPAR.
+CDE, PART.
+CDE, PAREVT.
+CDE, RESNUC.
      COMMON / FKCASF / PKFRMI, COSTH, PKIN
      COMMON /FKEVNT/ LNUCRI, LHADRI
      LOGICAL LNUCRI, LHADRI, LINCCK, LACCEP, LCHTYP
      REAL RNDM(1)
*  Note Pthrsh is also in Ferevv!!
      DIMENSION SOPPP(2),EXSOP(2),PTHRSH(39),IJNUCR(39)
* Use this "save" if common dbgdbg is commented
      SAVE PTHRSH, IPRI, IEVT, IJNUCR
      DATA PTHRSH / 16*5.D+00,2*2.5D+00,5.D+00,3*2.5D+00,8*5.D+00,
     &              9*2.5D+00 /
      DATA IJNUCR / 16*1,2*0,1,3*0,8*1,9*0 /
      DATA IPRI / 0 /
      DATA IEVT / 0 /
*
*  +-------------------------------------------------------------------*
*  |  Heavy ions are treated in eventa: now switched off!!
      IF (IJIJ .EQ. 30) THEN
         STOP 'HEAVY ION'
      END IF
*  |
*  +-------------------------------------------------------------------*
*   First of all: get the "part" index of the incoming "paprop" ijij
      IJ = IPTOKP (IJIJ)
      IEVT = IEVT + 1
      AMCHCK = 0.5D+00 * ( POO * POO - EKE * EKE ) / EKE
      AHELP  =  ABS ( AMCHCK - AM ( IJ ) )
*  +-------------------------------------------------------------------*
*  |
      IF ( AHELP .GT. ANGLGB * AM ( IJ ) ) THEN
         POO = SQRT ( EKE * ( EKE + 2.D+00 * AM (IJ) ) )
      END IF
*  |
*  +-------------------------------------------------------------------*
*
*  Variable initialization for conservation checks
*
      PTTOT  = POO
      PXTTOT = PTTOT*TXI
      PYTTOT = PTTOT*TYI
      PZTTOT = PTTOT*TZI
      ICHTAR = NINT(ZTAR(IMAT))
      ICHTOT = ICHTAR + ICH(IJ)
*  +-------------------------------------------------------------------*
*  |    Choice of the mass number of the target nucleus: use the input
*  |    one if any
      IF ( MSSNUM (IMAT) .GT. 0 ) THEN
         IBTAR = MSSNUM (IMAT)
*  |
*  +-------------------------------------------------------------------*
*  |    Choice of the mass number of the target nucleus according
*  |    to the natural isotopic composition of element ichtar
      ELSE
         CALL GRNDM(RNDM,1)
         RNDISO = RNDM (1)
*  |  +----------------------------------------------------------------*
*  |  |    Loop on the stable isotopes
         DO 25 IS = ISONDX (1,ICHTAR), ISONDX (2,ICHTAR) - 1
            RNDISO = RNDISO - ABUISO (IS)
            IF ( RNDISO .LT. 0.D+00 ) GO TO 30
   25    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         IS = ISONDX (2,ICHTAR)
   30    CONTINUE
         IBTAR = ISOMNM (IS)
      END IF
*  |
*  +-------------------------------------------------------------------*
      IBTOT  = IBTAR + IBAR(IJ)
      BBTAR  = IBTAR
      ZZTAR  = ICHTAR
      ZTO103 = ZZTAR**0.3333333333333333D+00
*  +-------------------------------------------------------------------*
*  |
      IF ( IBTAR .EQ. 1 ) THEN
         ITTA   = 8 - 7 * ICHTAR
         ETTOT  = AM (ITTA) + EKE + AM(IJ)
         AMNTAR = AM (ITTA)
*  |
*  +-------------------------------------------------------------------*
*  | The following should be done with the proper mass of the nuclide
      ELSE
*        AMNTAR = BBTAR * AMUC12
         AMMTAR = BBTAR * AMUAMU + 0.001D+00 * FKENER ( BBTAR, ZZTAR )
         AMNTAR = AMMTAR - ZZTAR * AMELEC + ELBNDE ( ICHTAR )
         ETTOT  = AMNTAR + EKE + AM (IJ)
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Kaon-short and kaon-long are transformed into a kaon0 or a
*  |  kaon0-bar
      IF (IJ .EQ. 12 .OR. IJ. EQ. 19) THEN
         IJ = 24
         CALL GRNDM(RNDM,1)
         IF (RNDM(1) .GT. 0.5D0) IJ = 25
*  |
*  +-------------------------------------------------------------------*
*  |  Pi0 quark configurations are selected according to 50% uubar and
*  |  50% ddbar
      ELSE IF ( IJ .EQ. 23 .OR. IJ .EQ. 26 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         CALL GRNDM(RNDM,1)
         IF ( RNDM (1) .LT. 0.5D+00 ) THEN
            IJ = 23
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IJ = 26
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
      ETEPS  = MAX ( 1.D-10 * EKE, 1.D-10 )
  50  CONTINUE
*-->-->-->-->--> Come here for resampling
* Reset all the accumulators
      NP     = NP0
      NPHEAV = 0
      LRNFSS = .FALSE.
      LEVDIF = .FALSE.
      LHADRI = .FALSE.
      ICHTOT = ICHTAR + ICH(IJ)
      TV = 0.D+00
      TVRECL = 0.D+00
      TVHEAV = 0.D+00
      TVCMS  = 0.D+00
      EOTEST = ETTOT
      LRESMP = .FALSE.
      LLASTN = .FALSE.
      LLAST1 = .FALSE.
      EUZ = 0.D+00
      PUX = 0.D+00
      PUY = 0.D+00
      PUZ = 0.D+00
      TVEUZ = 0.D+00
      ICU = 0
      IBU = 0
      EINTR  = 0.D+00
      PXINTR = 0.D+00
      PYINTR = 0.D+00
      PZINTR = 0.D+00
      ICINTR = 0
      IBINTR = 0
      ENUCR  = 0.D+00
      PXNUCR = 0.D+00
      PYNUCR = 0.D+00
      PZNUCR = 0.D+00
      ICNUCR = 0
      IBNUCR = 0
      EFRM  = 0.D+00
      PXFRM = 0.D+00
      PYFRM = 0.D+00
      PZFRM = 0.D+00
      PSEA  = 0.D+00
      TVGRE0  = 0.D+00
      TVGREY  = 0.D+00
      IGREYP  = 0
      IGREYN  = 0
      KTARP = 0
      KTARN = 0
      IEVAPL = 0
      IEVAPH = 0
      IEVPRO = 0
      IEVNEU = 0
      IEVDEU = 0
      IEVTRI = 0
      IEV3HE = 0
      IEV4HE = 0
      IDEEXG = 0
      ANOW   = BBTAR
      ZNOW   = ZZTAR
      DSOPP  = 0.D+00
      NNHAD  = 0
      RN1GSC = -1.D+00
      RN2GSC = -1.D+00
      IF ( POO .GE. PTHRSH (IJIJ) ) GO TO 200
* Below 5 GeV/c use Nucrin:
 100  CONTINUE
      ANCOLL = 1.D+00
*  +-------------------------------------------------------------------*
*  |  Check for Hydrogen
      IF ( IBTAR .NE. 1  ) THEN
*  |  +----------------------------------------------------------------*
*  |  |  Steering for Peanut: very temporary
*  |  |  Protons and Neutrons below 260 MeV:
         IF ( EKE .LT. 0.260D+00 .AND. ( IJ .EQ. 1 .OR. IJ .EQ. 8 )
     &        .AND. IBTAR .GT. 4 ) THEN
            CALL PEANUT ( IJ, EKE, POO, TXI, TYI, TZI, WE )
            IF ( LRESMP ) GO TO 50
            RETURN
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |  Stopping pi-s:
         ELSE IF ( IJ .EQ. 14 .AND. EKE .LT. 2.D+00 * GAMMIN .AND. IBTAR
     &             .GT. 4 ) THEN
            CALL PEANUT ( IJ, EKE, POO, TXI, TYI, TZI, WE )
            IF ( LRESMP ) GO TO 50
            RETURN
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  Now at first we sample the number of interactions
         CALL CORRIN ( ZZTAR, BBTAR, IJ, POO, EKE )
      END IF
      LNUCRI = .TRUE.
      NP = NP0
      ELAB  = EKE + AM(IJ)
*  Redefinition of particle types: the recovery of proper charge and
*  strangeness conservation after the interaction is not yet implemented
      KPROJ = IJ
      LCHTYP = .FALSE.
*  +-------------------------------------------------------------------*
*  |
      IF ( KPROJ .LE. 30 ) THEN
         GO TO ( 2017, 2018, 2999, 2020, 2021, 2022, 2999, 2999, 2999,
     &           2026 ), KPROJ - 16
         GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         GO TO ( 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039 ),
     &      KPTOIP (KPROJ) - 30
         GO TO 2999
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Lambdas are considered as neutrons: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi- --> K-, or an eventual neutron into
*  |  a Sigma0/Lambda,
*  |  (we must flip a d quark into an s quark), or a pi0 --> K0bar,
*  |  or a p --> Sigma+
 2017 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 8
*  |   Adjusting mass and momentum for lambdas (now n)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Alambdas are considered as antineutrons : after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi+ --> K+, or an eventual neutronbar into a
*  |  Lambdabar, (we must flip a dbar quark into an sbar quark),
*  |  or a pi0 --> K0, or a pbar --> Sigma+bar (ASigma-) ( there
*  |  are also possible ways through eta, rho and omega mesons )
 2018 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 9
*  |   Adjusting mass and momentum for alambdas (now an)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Sigma-s are considered as neutrons : after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi+ --> K0bar, or an eventual neutron into a Sigma-,
*  |  (we must flip a u quark into an s quark), or a pi0 --> K-,
*  |  or a p --> Sigma0/Lambda
 2020 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 8
*  |   The following card must be commented following the strangeness
*  |   and charge conservation recovery implementation
         ICHTOT = ICHTOT + 1
*  |   Adjusting mass and momentum for Sigma-s (now n)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Sigma+s are considered as protons : after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi- --> K-, or an eventual proton into a Sigma+,
*  |  (we must flip a d quark into an s quark), or a pi0 --> K0bar,
*  |  or a n --> Sigma0/Lambda
 2021 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 1
*  |   Adjusting mass and momentum for Sigma+s (now p)
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Sigma0s are considered as neutrons: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi- --> K-, or an eventual neutron into
*  |  a Sigma0/Lambda,
*  |  (we must flip a d quark into an s quark), or a pi0 --> K0bar,
*  |  or a p --> Sigma+
 2022 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 8
*  |   Adjusting mass and momentum for Sigma0s (now n)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Pi0 must be 23 for Nucrin
 2026 CONTINUE
         KPROJ = 23
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  ASigma-s are considered as pbars: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi+ --> K+, or an eventual pbar into a ASigma-,
*  |  (we must flip a dbar quark into an sbar quark), or a pi0 --> K0,
*  |  or a nbar --> ASigma0/ALambda
 2031 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 2
*  |   Adjusting mass and momentum for ASigma-s (now pbar)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  ASigma0s are considered as nbar: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi+ --> K+, or an eventual nbar into
*  |  a ASigma0/ALambda,
*  |  (we must flip a dbar quark into an sbar quark), or a pi0 --> K0,
*  |  or a pbar --> ASigma-
 2032 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 9
*  |   Adjusting mass and momentum for ASigma0s (now nbar)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  ASigma+s are considered as nbar : after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip a pi- --> K0, or an eventual nbar into a ASigma+,
*  |  (we must flip a ubar quark into an sbar quark), or a pi0 --> K+,
*  |  or a pbar --> ASigma0/ALambda
 2033 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 9
*  |   The following card must be commented following the strangeness
*  |   and charge conservation recovery implementation
         ICHTOT = ICHTOT - 1
*  |   Adjusting mass and momentum for ASigma+s (now nbar)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Xsi0s are considered as neutrons: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip an eventual neutron into a Xsi0,
*  |  or a proton --> Sigma+ and a pi- --> K- (or a pi0 --> K0bar) etc.
*  |  (we must flip two d quarks into s quarks)
 2034 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 8
*  |   Adjusting mass and momentum for Xsi0s (now n)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  AXsi0s are considered as nbars: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip an eventual nbar into a AXsi0,
*  |  or a pbar --> ASigma- and a pi+ --> K+ (or a pi0 --> K0) etc.
*  |  (we must flip two dbar quarks into sbar quarks)
 2035 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 9
*  |   Adjusting mass and momentum for AXsi0s (now nbar)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Xsi-s are considered as protons: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip an eventual proton into a Xsi-,
*  |  or a neutron --> Sigma- and a pi+ --> K0bar (or a pi0 --> K-) etc.
*  |  (we must flip two u quarks into s quarks)
 2036 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 1
*  |   The following card must be commented following the strangeness
*  |   and charge conservation recovery implementation
         ICHTOT = ICHTOT + 2
*  |   Adjusting mass and momentum for Xsi-s (now p)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  AXsi+s are considered as pbars: after the interaction
*  |  a possible way to recover strangeness and charge conservation
*  |  is to flip an eventual pbar into a AXsi+,
*  |  or a nbar --> ASigma+ and a pi- --> K0 (or a pi0 --> K+) etc.
*  |  (we must flip two ubar quarks into sbar quarks)
 2037 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 2
*  |   The following card must be commented following the strangeness
*  |   and charge conservation recovery implementation
         ICHTOT = ICHTOT - 2
*  |   Adjusting mass and momentum for AXsi+s (now pbar)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Omega-s are considered as protons: after the interaction there
*  |  are many possible ways to recover strangeness and charge
*  |  conservation (we must flip a d quark into an s quark and two u
*  |  quarks into s quarks).
 2038 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 1
*  |   The following card must be commented following the strangeness
*  |   and charge conservation recovery implementation
         ICHTOT = ICHTOT + 2
*  |   Adjusting mass and momentum for Omega-s (now p)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
*  |  Omegabar+s are considered as pbars: after the interaction there
*  |  are many possible ways to recover strangeness and charge
*  |  conservation (we must flip a dbar quark into an sbar quark and
*  |  two ubar quarks into sbar quarks).
 2039 CONTINUE
         LCHTYP = .TRUE.
         KPROJ = 2
*  |   The following card must be commented following the strangeness
*  |   and charge conservation recovery implementation
         ICHTOT = ICHTOT - 2
*  |   Adjusting mass and momentum for AOmega+s (now pbar)
         POO = SQRT ( ( ELAB + AM(KPROJ) ) * ( ELAB - AM(KPROJ) ) )
         PTTOT  = POO
         PXTTOT = PTTOT*TXI
         PYTTOT = PTTOT*TYI
         PZTTOT = PTTOT*TZI
      GO TO 2999
*  |
*  +-------------------------------------------------------------------*
 2999 CONTINUE
*  +-------------------------------------------------------------------*
*  |                                   Check for hydrogen!!!!
      IF ( IBTAR .EQ. 1 ) THEN
         TV = 0.D+00
         NP = NP0
         ITTA = 8 - 7 * ICHTAR
         IF ( KPROJ .EQ. 14 .AND. EKE .LT. 2.D+00 * GAMMIN ) THEN
            CALL PMPRAB ( KPROJ, EKE, POO, TXI, TYI, TZI, WE )
            RETURN
         END IF
*  |   Set a flag to avoid elastic collision in Hadrin
         IELFLG = +1
*  |   Set a flag to fully exploit charge exchange
         ICXFLG = 0
         CALL HADRIV ( KPROJ, POO, ELAB, TXI, TYI, TZI, ITTA )
         IELFLG = -1
         ICXFLG = -1
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( IH .LE. 1 ) THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( ITH (1) .EQ. KPROJ ) THEN
               IH  = IH + 1
               ITH (2) = 1
               CXH (2) = TXI
               CYH (2) = TYI
               CZH (2) = TZI
               PLH (2) = 0.D+00
               ELH (2) = AM (1)
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE IF ( ITH (1) .EQ. 1 ) THEN
               IH  = IH + 1
               ITH (2) = KPROJ
               CXH (2) = TXI
               CYH (2) = TYI
               CZH (2) = TZI
               PLH (2) = 0.D+00
               ELH (2) = AM (KPROJ)
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
          END IF
*  |  |
*  |  +----------------------------------------------------------------*

*  |  +----------------------------------------------------------------*
*  |  |                  Looping over the particles produced in hadrin
         DO 110 J=1,IH
            NP = NP + 1
            TKI(NP) = ELH(J) - AM(ITH(J))
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( TKI(NP) .GE. 0.D+00 ) THEN
               KPART(NP) = ITH(J)
               CXR(NP)   = CXH(J)
               CYR(NP)   = CYH(J)
               CZR(NP)   = CZH(J)
               PLR(NP)   = PLH(J)
               WEI(NP)   = WE
*  |  |  |  Updating conservation counters
               ENUCR  = ENUCR + ELH(J)
               PXNUCR = PXNUCR + PLR(NP)*CXR(NP)
               PYNUCR = PYNUCR + PLR(NP)*CYR(NP)
               PZNUCR = PZNUCR + PLR(NP)*CZR(NP)
               ICNUCR = ICNUCR + ICH(KPART(NP))
               IBNUCR = IBNUCR + IBAR(KPART(NP))
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE IF ( ABS ( TKI (NP) ) .LE. ANGLGB ) THEN
*  |  |  |  Updating conservation counters
               ENUCR  = ENUCR  + ELH(J)
               ICNUCR = ICNUCR + ICH(ITH(J))
               IBNUCR = IBNUCR + IBAR(ITH(J))
               NP = NP - 1
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               NP = NP - 1
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 110     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         KTARP = 1
         ANOW = 0.D+00
         ZNOW = 0.D+00
         ICRES = 0
         IBRES = 0
         ERES  = 0.D+00
         EOTEST = EOTEST - ENUCR
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( ABS (EOTEST) .GT. ETEPS ) THEN
            WRITE (LUNERR,*)' Eventq: eotest failure with Hadrin',
     &                        EOTEST
            LRESMP = .TRUE.
            GO TO 50
*  |
*  +-<|--<--<--<--<--< go to resampling
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         RETURN
      END IF
*  |                                       end hydrogen check
*  +-------------------------------------------------------------------*
*
*  Now calling Nucrin to produce secondary particles, which are put
*  into the /Finuc/ common
*
      CALL NUCRIV ( KPROJ, ELAB, TXI, TYI, TZI, BBTAR,
     &              ZZTAR, RHO(IMAT) )
      IF ( LRESMP ) GO TO 50
*--<--<--<--<--< go to resampling if something was wrong
      TVGRE0 = TV - TVGREY
      TVEUZ  = 0.D+00
      TVTENT = TV
      TV = 0.D+00
      IF (NP .GT. MXP) GO TO 400
*  +-------------------------------------------------------------------*
*  |                     Looping over the particles produced in nucrin
*  |                     No need for Nucrin produced particles to
*  |                     change the numbering
      DO 101 I=NP0+1,NP
         I1 = KPART(I)
         WEI(I) = WE
         TKI(I) = TKI(I) - AM(I1)
         TXYZ   = CXR (I)**2 + CYR (I)**2 + CZR (I)**2
         IF ( ABS (TXYZ-1.D0) .GT. CSNPRN ) THEN
            WRITE ( LUNERR,* )
     &      ' **** Bad normalized cosines from Nucriv!!!',I,TXYZ,CXR(I),
     &        CYR(I),CZR(I)
            TXYZ = TXYZ - 1.D+00
            TXYZ = 1.D+00 - 0.5D+00 * TXYZ + 0.375D+00 * TXYZ * TXYZ
            CXR (I) = CXR (I) * TXYZ
            CYR (I) = CYR (I) * TXYZ
            CZR (I) = CZR (I) * TXYZ
            TXYZ   = CXR (I)**2 + CYR (I)**2 + CZR (I)**2
            IF ( ABS (TXYZ-1.D0) .GT. CSNPRN ) THEN
               LRESMP = .TRUE.
               GO TO 50
            END IF
         END IF
         IF (TKI(I) .GE. 0.D+00) GO TO 101
            TKI(I) = 0.D+00
            PLR(I) = 0.D+00
 101  CONTINUE
*  |
*  +-------------------------------------------------------------------*
      GO TO 500
C
C********************************************************************
C     GENERATE FIRST THE LOW ENERGY NUCLEONS FROM THE INTRANUCLEAR
C     CASCADE - CHECK IF ACCEPTABLE.
C     NOTE THAT AINEL AND RAKEKA ARE USING THE OLD PARTICLE NUMBERING
C********************************************************************
C
 200  CONTINUE
      NP = NP0
      LNUCRI = .FALSE.
*  +-------------------------------------------------------------------*
*  |                                   Check for hydrogen!!!!
      IF ( IBTAR .EQ. 1 ) THEN
         ANCOLL = 1.D+00
         NHAD = 0
         KPROJ = IJ
         KTARG = 1
         EPROJ = EKE + AM (KPROJ)
         UMO   = SQRT ( AM (1)**2 + AM (KPROJ)**2 + 2.D+00 * AM (1) *
     &                  EPROJ )
*  |  +----------------------------------------------------------------*
*  |  | Now diffractive events are taken into account for projectile
*  |  | -proton collisions!!! A. Ferrari and J. Ranft, 25-3-90
         IF ( LDIFFR (KPTOIP(KPROJ)) ) THEN
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. FRDIFF ) THEN
               IF ( POO .GT. PTHDFF ) THEN
                  LEVDIF = .TRUE.
                  CALL DIFEVV ( NHAD, KPROJ, KTARG, POO, EPROJ, UMO )
               ELSE
                  CALL HADEVV ( NHAD, KPROJ, KTARG, POO, EPROJ, UMO )
               END IF
            ELSE
               CALL HADEVV ( NHAD, KPROJ, KTARG, POO, EPROJ, UMO )
            END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            CALL HADEVV ( NHAD, KPROJ, KTARG, POO, EPROJ, UMO )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |                   Loop over particles produced in hadevt/difevt
         DO 207 J=1,NHAD
            NP  = NP + 1
            CFE = 1.D+00
            SFE = 0.D+00
*  |  |   Get the "paprop" index
            KPART(NP) = KPTOIP (NREH(J))
            IF ( KPART (NP) .EQ. 0 ) THEN
               WRITE (LUNERR,*)
     &         ' **** Charmed particle produced in Hadevv/Difevv',
     &         NREH(J),HEPH(J),AMH(J),' ****'
               KPART (NP) = NREH (J)
            END IF
            PLR(NP) = SQRT ( PXH(J)**2 + PYH(J)**2 + PZH(J)**2 )
            PTH = SQRT( PXH(J)**2 + PYH(J)**2 )
            CDE = PZH(J) / PLR(NP)
            SDE = PTH    / PLR(NP)
            IF (SDE .GE. ANGLGB) THEN
               CFE = PXH(J) / PTH
               SFE = PYH(J) / PTH
            END IF
            CALL TTRANS ( TXI, TYI, TZI, CDE, SDE, SFE, CFE,
     &                    CXR(NP), CYR(NP), CZR(NP) )
            TKI(NP) = HEPH(J) - AMH(J)
            WEI(NP) = WE
*  |  |  +-------------------------------------------------------------*
*  |  |  |                   Updating conservation counters
            IF ( TKI(NP) .GT. 0.D+00 ) THEN
               EUZ = EUZ + HEPH(J)
               PUX = PUX + PLR(NP)*CXR(NP)
               PUY = PUY + PLR(NP)*CYR(NP)
               PUZ = PUZ + PLR(NP)*CZR(NP)
               ICU = ICU + ICH(NREH(J))
               IBU = IBU + IBAR(NREH(J))
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               NP = NP-1
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 207     CONTINUE
*  |  |                                end loop
*  |  +----------------------------------------------------------------*
         ANOW = 0.D+00
         ZNOW = 0.D+00
         KTARP = 1
         ICRES = 0
         IBRES = 0
         ERES  = 0.D+00
         EOTEST = EOTEST - EUZ
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( ABS (EOTEST) .GT. ETEPS ) THEN
            WRITE (LUNERR,*)' Eventq: eotest failure with',
     &                      ' Hadevt/Diffevt',EOTEST
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         RETURN
      END IF
*  |                                       end hydrogen check
*  +-------------------------------------------------------------------*
*  Now at first we sample the number of interactions
      CALL COREVT ( ZZTAR, BBTAR, IJ, POO, EKE )
*
*  First decide how much energy will go into the intranuclear cascade
*
      EKIN = EKE
*  Here starts the cascade particle production module!!!
      SOPPP (1) = EINCP
      SOPPP (2) = EINCN
      ARECL  = MAX ( ANOW - 1.D+00, 1.D+00 )
      KREJE  = 0
      NGREYT = NGREYP + NGREYN
      TVTENT = ANCOLL * ( AV0WEL - AEFRMA ) + TVGRE0
      TMP015 = 0.15D+00
      EEXTRA = 2.D+00* MIN ( TWOTWO * ( EKUPNU (1) + EKUPNU (2) )
     &                     , TMP015 *
     &       ( EKE - EINCP - EINCN - TVTENT ), EINCP + EINCN )
      EEXTRA = MAX ( EEXTRA, EKUPNU (1), EKUPNU (2) )
      LINCCK = .FALSE.
      PXCASC = 0.D+00
      PYCASC = 0.D+00
      PZCASC = 0.D+00
      PTXINT = 0.D+00
      PTYINT = 0.D+00
      PPINTR = 0.D+00
      EKRECL = 0.D+00
      IEXTRN = 0
      IEXTRP = 0
      LACCEP = .FALSE.
      IGREYT = 0
      IF ( NGREYT .EQ. 0 ) GO TO 206
*  +-------------------------------------------------------------------*
*  | Now looping until we reach the correct number of cascade
*  | nucleons
 205  CONTINUE
         IGREYT = IGREYP + IGREYN
         DSOPP  = SOPPP (1) + SOPPP (2)
*  |  Now it is not possible to reduce too heavily the available energy
         IF ( EKIN - TVGRE0 .LT. 0.5D+00 * EKE .OR.  PZCASC .GE.
     &        0.5D+00 * POO ) GO TO 206
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( IGREYT .GE. NGREYT ) THEN
            AEXTRA = 2.D+00 * DSOPP / ( EKINAV (1) + EKINAV (2)
     &             + ESWELL (1) + ESWELL (2) )
     &             / ( IGREYT - NGREYT + 1 )
            CALL GRNDM(RNDM,1)
            RNDUMO = RNDM (1)
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( RNDUMO .LT. AEXTRA .AND. LACCEP .AND. NINT (ANOW)
     &           .GT. 0 ) THEN
               REJE = ZNOW / ANOW
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               CALL GRNDM(RNDM,1)
               IF ( RNDM (1) .LT. REJE ) THEN
                  IEXTRP = MIN ( 1, NINT (ZNOW), NGREYP / 2 )
                  IF ( NGREYP + IEXTRP - IGREYP .LE. 0 ) GO TO 206
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE
*                 IEXTRN = MIN ( IEXTRN + 1, NINT (ANOW - ZNOW), 2 )
                  IEXTRN = MIN ( 1, NINT (ANOW - ZNOW), NGREYN / 2 )
                  IF ( NGREYN + IEXTRN - IGREYN .LE. 0 ) GO TO 206
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               GO TO 206
*  |  |  |
*  |  |  |-->-->-->-->--> We have finished particles!!
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( DSOPP .LE. - EEXTRA ) THEN
            GO TO 206
*  |  |
*  |  |-->-->-->-->--> We have finished energy
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         LACCEP = .FALSE.
*  |  +----------------------------------------------------------------*
*  |  | Check how many nucleons are still available for cascade
         IF ( ANOW .LT. 1.5D+00 ) THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  | Check if at least two high energy collisions are foreseen
*  |  |  | if yes the proper energy / momentum balance for the last
*  |  |  | two nucleons will be done inside Ferevv
            IF ( ANCOLL .GT. 1.5D+00 ) THEN
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |     Only the valence collision is foreseen: we are forced
*  |  |  |     to perform here the balance for the 2 last nucleons!
*  |  |  |     (One might be used here for cascading, the other
*  |  |  |     will be used by Hadevv / Difevv)
            ELSE
               LLASTN = .TRUE.
               KTLAST = IJTARG (1)
               AMLAST = AM ( KTLAST )
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( NINT ( ZNOW ) .GT. 0 ) THEN
                  KTINC = 1
                  IGREYP = IGREYP + 1
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE
                  KTINC = 8
                  IGREYN = IGREYN + 1
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               AMINC = AM (KTINC)
               UMIN2 = ( AMLAST + AMINC )**2
               DSOPP = MAX ( DSOPP, AV0WEL - AEFRMA )
  216          CONTINUE
               EKIN   = EKIN  - DSOPP
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Check if we can get enough invariant mass
               IF ( EKIN .LE. 0.2D+00 * EKE ) THEN
                  WRITE ( LUNOUT, * )
     &            ' *** Eventv: impossible to get enough invariant',
     &            ' mass for the last two nucleons! ****'
                  WRITE ( LUNERR, * )
     &            ' *** Eventv: impossible to get enough invariant',
     &            ' mass for the last two nucleons! ****'
                  LRESMP = .TRUE.
                  GO TO 50
*  |  |  |  |---<---<---<  Go to resampling
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               ELEFT  = ETTOT - EINTR  - EKIN - AM (IJ)
               PLA    = SQRT ( EKIN * ( EKIN + 2.D+00 * AM (IJ) ) )
               PXLEFT = PXTTOT - PXINTR - PLA * TXI
               PYLEFT = PYTTOT - PYINTR - PLA * TYI
               PZLEFT = PZTTOT - PZINTR - PLA * TZI
*  |  |  |  Now we will divide Eleft and Pleft between the two
*  |  |  |  left nucleons!
               UMO2 = ELEFT**2 - PXLEFT**2 - PYLEFT**2 - PZLEFT**2
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( UMO2 .LE. UMIN2 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( KTINC .EQ. 1 ) THEN
                     EINCP = EINCP + DSOPP
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     EINCN = EINCN + DSOPP
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  GO TO 216
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               UMO = SQRT ( UMO2 )
               ELACMS = 0.5D+00 * ( UMO2 + AMLAST**2 - AMINC**2 )
     &                / UMO
               EINCMS = UMO - ELACMS
               PCMS   = SQRT ( ELACMS**2 - AMLAST**2 )
               GAMCM = ELEFT  / UMO
               ETAX  = PXLEFT / UMO
               ETAY  = PYLEFT / UMO
               ETAZ  = PZLEFT / UMO
               CALL RACO ( CXXINC, CYYINC, CZZINC )
               PCMSX = PCMS * CXXINC
               PCMSY = PCMS * CYYINC
               PCMSZ = PCMS * CZZINC
*  |  |  |  Now go back from the CMS frame to the lab frame!!!
*  |  |  |  First the inc nucleon:
               ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
               NP = NP + 1
               IF (NP .GT. MXP) GO TO 400
               KPART(NP)= KTINC
               WEI (NP) = WE
               TKI (NP) = GAMCM * EINCMS + ETAPCM - AMINC
               PHELP  = ETAPCM / (GAMCM + 1.D0) + EINCMS
               CXXINC = PCMSX + ETAX * PHELP
               CYYINC = PCMSY + ETAY * PHELP
               CZZINC = PCMSZ + ETAZ * PHELP
*  |  |  |  Updating conservation counters
               EINTR  = EINTR  + TKI(NP) + AMINC
               PXINTR = PXINTR + CXXINC
               PYINTR = PYINTR + CYYINC
               PZINTR = PZINTR + CZZINC
               ICINTR = ICINTR + ICH  (KPART(NP))
               IBINTR = IBINTR + IBAR (KPART(NP))
               PLR (NP) = SQRT (CXXINC * CXXINC + CYYINC * CYYINC +
     &                          CZZINC * CZZINC)
               CXR (NP) = CXXINC / PLR (NP)
               CYR (NP) = CYYINC / PLR (NP)
               CZR (NP) = CZZINC / PLR (NP)
*  |  |  |  Now the high energy collision nucleon
               EKLAST = GAMCM * ELACMS - ETAPCM - AMLAST
               PHELP  = - ETAPCM / (GAMCM + 1.D0) + ELACMS
               PXLAST = - PCMSX + ETAX * PHELP
               PYLAST = - PCMSY + ETAY * PHELP
               PZLAST = - PCMSZ + ETAZ * PHELP
*  |  |  |  Now we perform a Lorentz transformation to the rest fra-
*  |  |  |  me of the "last" nucleon, with the projectile momentum
*  |  |  |  along the +z axis
               AMPROJ = AM (IJ)
               EPROJ  = EKIN + AMPROJ
               ECHCK  = EPROJ + AMLAST + EKLAST
               PXCHCK = PLA * TXI + PXLAST
               PYCHCK = PLA * TYI + PYLAST
               PZCHCK = PLA * TZI + PZLAST
               UMO  = SQRT ( ECHCK**2 - PXCHCK**2 - PYCHCK**2 -
     &                       PZCHCK**2 )
               EPROJX = 0.5D+00 * ( UMO**2 - AMPROJ**2 - AMLAST**2 )
     &                / AMLAST
               PPROJX = SQRT ( EPROJX**2 - AMPROJ**2 )
               ETOTX  = EPROJX + AMLAST
*  |  |  |  Now set the parameters for the Lorentz transformation
               AAFACT = ECHCK  + ETOTX
               BBFACT = PPROJX - PZCHCK
               DDENOM = ETOTX * AAFACT - PPROJX * BBFACT
               GAMTRA = ( ECHCK * AAFACT + PPROJX * BBFACT ) / DDENOM
               ETAZ = - BBFACT * AAFACT / DDENOM
               ETAX = PXCHCK * ( GAMTRA + 1.D+00 ) / AAFACT
               ETAY = PYCHCK * ( GAMTRA + 1.D+00 ) / AAFACT
               PLABS = PPROJX
               ELABS = EPROJX
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( .NOT. LDIFFR (KPTOIP(IJ)) .OR. PLABS .LE. PTHDFF )
     &            THEN
                  RUUN = 1.D0
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE
                  CALL GRNDM(RNDM,1)
                  RUUN = RNDM (1)
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               NHAD = 0
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |   Diffractive event
               IF ( RUUN .LE. FRDIFF ) THEN
                  LEVDIF = .TRUE.
                  CALL DIFEVV ( NHAD, IJ, KTLAST, PLABS, ELABS, UMO )
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |   Usual event
               ELSE
                  CALL HADEVV ( NHAD, IJ, KTLAST, PLABS, ELABS, UMO )
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  Now we have the particles in the nucleon rest frame,
*  |  |  |  transform back in the lab frame
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |           Looping over the produced particles
               DO 236 I = 1, NHAD
                  NP = NP + 1
                  IF (NP .GT. MXP) GO TO 400
                  CALL ALTRA ( GAMTRA, ETAX, ETAY, ETAZ, PXH (I),
     &                         PYH (I), PZH (I), HEPH (I), PLR (NP),
     &                         CXR (NP), CYR (NP), CZR (NP), ELR )
*  |  |  |  |  Updating conservation counters
                  EUZ  = EUZ + ELR
                  PUX  = PUX + CXR (NP)
                  PUY  = PUY + CYR (NP)
                  PUZ  = PUZ + CZR (NP)
                  KPART (NP) = KPTOIP ( NREH (I) )
                  IF ( KPART (NP) .EQ. 0 ) THEN
                     WRITE (LUNERR,*)
     &               ' **** Charmed particle produced in Hadevv',
     &               NREH(I),ELR,AMH(I),' ****'
                     KPART (NP) = NREH (I)
                  END IF
                  ICU = ICU + ICH  (NREH(I))
                  IBU = IBU + IBAR (NREH(I))
                  CXR (NP) = CXR (NP) / PLR (NP)
                  CYR (NP) = CYR (NP) / PLR (NP)
                  CZR (NP) = CZR (NP) / PLR (NP)
                  TKI (NP) = ELR - AMH (I)
                  WEI (NP) = WE
  236          CONTINUE
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  | Now perform the standard tests for energy and momentum
*  |  |  | conservation
               ERES  = ETTOT  - EUZ - ENUCR  - EINTR
               PXRES = PXTTOT - PUX - PXNUCR - PXINTR
               PYRES = PYTTOT - PUY - PYNUCR - PYINTR
               PZRES = PZTTOT - PUZ - PZNUCR - PZINTR
               ICRES = ICHTOT - ICU - ICNUCR - ICINTR
               IBRES = IBTOT  - IBU - IBNUCR - IBINTR
               PTRES = MAX ( ABS (PXRES), ABS (PYRES), ABS (PZRES) )
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( IBRES .NE. 0 .OR. ICRES .NE. 0 .OR. ABS (ERES)
     &              .GT. 1.D-10*EPROJ .OR. PTRES .GT. 1.D-10*PTTOT )
     &              THEN
                  WRITE ( LUNERR, * )
     &                   ' Eventq: last nucleon failure!!', ICRES,
     &                     IBRES, REAL (ERES), REAL (PXRES),
     &                     REAL (PYRES), REAL (PZRES)
                  LRESMP = .TRUE.
                  GO TO 50
*  |  |  |--|--<--<--<--<--< go to resampling
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               PTRES = 0.D+00
               RETURN
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*

*  |  +----------------------------------------------------------------*
*  |  |
         IF ( NINT ( ANOW - ZNOW ) .LE. 0 ) THEN
            REJE = 1.D+00
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            REJE = MAX ( ZNOW * ( NGREYP + IEXTRP - IGREYP ),
     &                   ZERZER )
            HELP = REJE + ( ANOW - ZNOW ) * ( NGREYN +
     &             IEXTRN - IGREYN )
            IF ( HELP .GT. 0.D+00 ) THEN
               REJE = REJE / HELP
            ELSE
               REJE = 1.D+00
               WRITE(LUNERR,*)' EVENTV: HELP=0, ANOW,ZNOW',ANOW,ZNOW
     &                       ,' NGREYN,IGREYN,IEXTRN',
     &                          NGREYN,IGREYN,IEXTRN,
     &                        ' NGREYP,IGREYP,IEXTRP',
     &                          NGREYP,IGREYP,IEXTRP
            END IF
         END IF
*  |  |
*  |  +----------------------------------------------------------------*

*  |  +----------------------------------------------------------------*
*  |  |
         CALL GRNDM(RNDM,1)
         IF ( RNDM (1) .LT. REJE ) THEN
            ILO  = 1
            ILLO = 2
            KP   = 1
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            ILO  = 2
            ILLO = 1
            KP   = 8
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         CALL RAKEKV ( ILO, EXSOP, BBTAR, TKIN, TSTRCK, PLA, ARECL,
     &                 TKRECL, EFERMI, CDE, SDE )
         IF ( EKIN - TKIN .LT. 0.5D+00 * EKE ) GO TO 206
*  |--|--<--<--<--<--< avoid to deplete too much the energy
*  |  +----------------------------------------------------------------*
*  |  |  Now check if the nucleon energy is acceptable:
         IF ( SOPPP (ILO) .LT. TKIN )  THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( TKIN - SOPPP (ILO) .LT. SOPPP (ILLO) + 1.5D+00 *
     &           EEXTRA ) THEN
               SOPPP (ILLO) = SOPPP (ILLO) + SOPPP (ILO) - TKIN
     &                      - EXSOP (ILO)
               SOPPP (ILO)  = 0.D+00
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               KREJE = KREJE + 1
               IF ( KREJE .GT. 10 ) GO TO 206
               SOPPP (ILLO) = SOPPP (ILLO) + SOPPP (ILO)
               SOPPP (ILO)  = 0.D+00
               GO TO 205
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            SOPPP (ILO) = SOPPP (ILO) - TKIN - EXSOP (ILO)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         IF ( NINT ( ANOW ) .LE. 0 ) GO TO 206
*  |  +----------------------------------------------------------------*
*  |  |   Update the current atomic and mass number
         IF ( ILO .EQ. 1 ) THEN
            IF ( NINT ( ZNOW ) .LE. 0 ) GO TO 206
            IGREYP = IGREYP + 1
            ZNOW   = ZNOW   - 1.D+00
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IGREYN = IGREYN + 1
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         ANOW = ANOW - 1.D+00
*  |  Now make the kinematical tests!!
         FRSURV = ARECL / BBTAR
         NP = NP + 1
         IF ( NP .GT. MXP ) GO TO 400
         EKIN   = EKIN - TKIN
*  Note the change!!
         LINCCK = ARECL .LT. 30.D+00 .AND. FRSURV .LE. 0.33D+00
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( .NOT. LINCCK ) THEN
            CALL SFECFE ( SFE, CFE )
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IF ( CDE .GT. 0.D+00 ) THEN
               CDE = CDE * FRSURV / 0.33D+00
               SDE = SQRT ( 1.D+00 - CDE**2 )
            END IF
            CALL SFECFE ( SFE, CFE )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         PTXINT = PTXINT + PLA * CFE * SDE
         PTYINT = PTYINT + PLA * SFE * SDE
         PPINTR = PPINTR + PLA * CDE
         CALL TTRANS ( TXI, TYI, TZI, CDE, SDE, SFE, CFE,
     &                 CXR (NP), CYR (NP), CZR (NP) )
*  | Generated nucleon is acceptable - save it
         LACCEP = .TRUE.
         TVGRE0 = TVGRE0 + EXSOP (ILO)
         TVGREY = TVGREY + TKIN + TKRECL - TSTRCK - EBNDNG (ILO)
         EKRECL = EKRECL + TKRECL
         ARECL  = MAX ( ARECL - 1.D+00, 1.D+00 )
         KPART(NP)= KP
         WEI(NP)  = WE
         TKI(NP)  = TSTRCK
         PLR(NP)  = PLA
*  |                        Updating the counters for spent momenta
*  |                        of the cascade nucleons (the momentum
*  |                        spent by the high energy particles)
         SINTH = SQRT ( 1.D+00 - COSTH * COSTH )
         PLA = SQRT ( ( EFERMI + TKIN )**2 - AMNUSQ (ILO) )
         PZLEFT = PLA * CDE - COSTH * PKFRMI
         IF ( PZLEFT + PZCASC .LT. EKE - EKIN + TVGRE0 ) THEN
            PZCASC = EKE - EKIN + TVGRE0
            PXCASC = PXCASC + CFE * ( PLA * SDE - SINTH * PKFRMI )
            PYCASC = PYCASC + SFE * ( PLA * SDE - SINTH * PKFRMI )
         ELSE
            PZCASC = PZCASC + PZLEFT
            PXCASC = PXCASC + CFE * ( PLA * SDE - SINTH * PKFRMI )
            PYCASC = PYCASC + SFE * ( PLA * SDE - SINTH * PKFRMI )
         END IF
*  |                        Updating conservation counters
         EINTR  = EINTR  + TKI(NP) + AM (KPART(NP))
         PXINTR = PXINTR + PLR(NP) * CXR(NP)
         PYINTR = PYINTR + PLR(NP) * CYR(NP)
         PZINTR = PZINTR + PLR(NP) * CZR(NP)
         ICINTR = ICINTR + ICH  (KPART(NP))
         IBINTR = IBINTR + IBAR (KPART(NP))
      GO TO 205
*  |
*  +--<--<--<--<--< go to sample another nucleon
 206  CONTINUE
*  +-------------------------------------------------------------------*
*  |  First check charge and baryonic number conservation:
      IF ( IGREYP .NE. ICINTR .OR. ( IGREYP + IGREYN ) .NE.
     &     IBINTR ) THEN
         WRITE ( LUNERR,* )' Eventq: charge or baryon number',
     &                     ' conservation failure in the Inc',
     &                     ' section!!', IGREYP, ICINTR,
     &                       IGREYP + IGREYN, IBINTR
         LRESMP = .TRUE.
         GO TO 50
*--|--<--<--<--<--< go to resampling
      END IF
*  |
*  +-------------------------------------------------------------------*
      TVTENT = TVGRE0
* Tvgrey is already inside Eincp and Eincn since Rakekv updates the
* estimated excitation energy (and Tvgre0, Eincp, Eincn and the
* Soppp array)
      EINCP  = EINCP - SOPPP (1)
      EINCN  = EINCN - SOPPP (2)
      EKIN   = EKIN  - TVTENT
*  +-------------------------------------------------------------------*
*  |   Check if we have not spent too much energy!!!
      IF ( EKIN .LT. 0.5D+00 * EKE ) THEN
         LRESMP = .TRUE.
         WRITE ( LUNERR,* ) ' Eventq: Ekin after inc too low!! ',
     &                        EKIN, EKE, IJIJ
      END IF
*  |
*  +-------------------------------------------------------------------*
      IF ( LRESMP ) GO TO 50
*
*--<--<--<--<--<--< go to resampling if something was wrong
*   Here the modification to take into account properly the
*   cascade nucleon momenta
*   New version: rotate the spent momentum in the lab frame
      IF ( IGREYT .GT. 0 ) THEN
         PZCASC = MAX ( PZCASC, ZERZER )
         PTH = PXCASC * PXCASC + PYCASC * PYCASC
         PLA = SQRT ( PTH + PZCASC * PZCASC )
         PTH = SQRT ( PTH )
         CDE = PZCASC / PLA
         SDE = PTH    / PLA
         IF (SDE .GE. ANGLGB) THEN
            CFE = PXCASC / PTH
            SFE = PYCASC / PTH
         ELSE
            CFE = 1.D+00
            SFE = 0.D+00
         END IF
         CALL TTRANS ( TXI, TYI, TZI, CDE, SDE, SFE, CFE,
     &                 CXXINC, CYYINC, CZZINC )
         PXCASC = PLA * CXXINC
         PYCASC = PLA * CYYINC
         PZCASC = PLA * CZZINC
      END IF
      PXLEFT = PXTTOT - PXCASC - TXI * TVGRE0
      PYLEFT = PYTTOT - PYCASC - TYI * TVGRE0
      PZLEFT = PZTTOT - PZCASC - TZI * TVGRE0
      PLA = SQRT ( PXLEFT * PXLEFT + PYLEFT * PYLEFT + PZLEFT
     &           * PZLEFT )
      DEKVSP = PLA - EKIN - AM (IJ)
*  +-------------------------------------------------------------------*
*  |  Check the momentum versus the total energy
      IF ( DEKVSP .GE. 0.D+00 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |  There are good reasons to believe that the following attempt
*  |  |  is dangerous rather than useful, leading to a Dp > DEk
         IF ( TVGRE0 .GT. 0.D+00 ) THEN
            TVTENT = TVTENT - TVGRE0
            EKIN   = EKIN + TVGRE0
            TVGRE0 = 0.D+00
            PXLEFT = PXTTOT - PXCASC
            PYLEFT = PYTTOT - PYCASC
            PZLEFT = PZTTOT - PZCASC
            PLA = SQRT ( PXLEFT * PXLEFT + PYLEFT * PYLEFT + PZLEFT
     &                 * PZLEFT )
            IF ( EKIN + AM (IJ) .GT. PLA ) GO TO 300
*  |  |  This part is new (1-10-91)
            DEEXTR = EKE - EKIN - EINTR + IGREYP * AM (1)
     &             + IGREYN * AM (8) - 1.5D+00
     &             * (IGREYP+IGREYN) * EBNDAV
            IF ( DEEXTR .GT. 0.D+00 ) THEN
               EKIN  = EKIN  + 0.5D+00 * DEEXTR
               EINCP = EINCP - 0.5D+00 * DEEXTR
               EINCN = EINCN - 0.5D+00 * DEEXTR
               PXLEFT = PXTTOT - PXCASC + 0.5D+00 * TXI * DEEXTR
               PYLEFT = PYTTOT - PYCASC + 0.5D+00 * TYI * DEEXTR
               PZLEFT = PZTTOT - PZCASC + 0.5D+00 * TZI * DEEXTR
               PLA = SQRT ( PXLEFT * PXLEFT + PYLEFT * PYLEFT + PZLEFT
     &                    * PZLEFT )
               IF ( EKIN + AM (IJ) .GT. PLA ) GO TO 300
            END IF
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         IF ( PLA - EKIN - AM (IJ) .LE. 1.D-04 * PLA ) GO TO 300
*  |  +----------------------------------------------------------------*
*  |  |  Printing condition relaxed, A.F., 23-12-92
         IF ( PLA - EKIN - AM (IJ) .GT. 1.D-02 * PLA ) THEN
            WRITE ( LUNERR,* )' Eventv: ekin+am < pla,ij,igreyt',
     &                          EKIN+AM(IJ),PLA,IJ,IGREYT
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         PTH = PLA
         PLA = EKIN + AM(IJ)
         PXLEFT = PXLEFT * PLA / PTH
         PYLEFT = PYLEFT * PLA / PTH
         PZLEFT = PZLEFT * PLA / PTH
      END IF
*  |
*  +-------------------------------------------------------------------*
  300 CONTINUE
*  end new version
*  +-------------------------------------------------------------------*
*  |  Check if we have enough energy to enter the high energy module
*  |  if not reset the accumulators and go to nucrin
      IF ( PLA .LT. PTHRSH (IJIJ) ) THEN
         PREF = 0.45D+00 * POO
*  |  +----------------------------------------------------------------*
*  |  |  Check if the momentum is much smaller than the original one
         IF ( PLA .LE. PREF ) THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( PLA .LE. 0.4D+00 * POO ) THEN
               WRITE ( LUNERR,* )' Eventv: Pla < 0.4 Poo',PLA,POO,IJIJ,
     &                             TKIN,IMAT
               LRESMP = .TRUE.
               GO TO 50
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         PREF = MAX ( PREF, TWOTWO )
         PREF = MIN ( PREF, FOUFOU )
*  |  +----------------------------------------------------------------*
*  |  |  Originally it was < 10, but with Fermi momentum sometimes
*  |  |  we were calling Hadrin with p > 10 GeV/c
*        IF ( POO .LE. 9.75D+00 ) THEN
         IF ( ( POO .LE. 9.75D+00 .AND. IJNUCR (IJIJ) .LE. 0 )
     &        .OR. PLA .LT. PREF ) THEN
            IGREYP = 0
            IGREYN = 0
            KTARP  = 0
            KTARN  = 0
            TVGRE0 = 0.D+00
            TVGREY = 0.D+00
            EINTR  = 0.D+00
            PXINTR = 0.D+00
            PYINTR = 0.D+00
            PZINTR = 0.D+00
            ICINTR = 0
            IBINTR = 0
            ANOW   = BBTAR
            ZNOW   = ZZTAR
            IF ( IJ .EQ. 26 ) IJ = 23
            GO TO 100
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
      TXX = PXLEFT / PLA
      TYY = PYLEFT / PLA
      TZZ = PZLEFT / PLA
      ZTEMP = ZZTAR - IGREYP
      ATEMP = BBTAR - IGREYN
      ERES  = ETTOT - EKIN - AM (IJ) - EINTR
      AMNRES = AMUAMU * ATEMP + 1.D-03 * FKENER ( ATEMP, ZTEMP ) -
     &         ZTEMP * AMELEC + ELBNDE ( NINT (ZTEMP) )
C
C********************************************************************
C     FOR MOMENTA ABOVE 5.0 GEV/C USE NUCEVT
C********************************************************************
C
*
*  From here the high energy model....
*
      NNHAD = 0
      CALL NUCEVV ( NNHAD, IJ, PLA, EKIN, TXX, TYY, TZZ )
      IF ( LRESMP ) GO TO 50
*--<--<--<--<--< go to resampling if something was wrong
*  +-------------------------------------------------------------------*
*  |
      IF ( LLASTN .AND. NINT ( ANOW ) .EQ. 1 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( KTINC .EQ. 1 ) THEN
            IGREYP = IGREYP + 1
            EINCP  = EINCP  + EKINC
            ZNOW   = ZNOW - 1.D+00
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IGREYN = IGREYN + 1
            EINCN  = EINCN  + EKINC
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         ANOW = ANOW - 1.D+00
         NP = NP + 1
         IF (NP .GT. MXP) GO TO 400
         KPART(NP)= KPTOIP (KTINC)
         WEI (NP) = WE
         TKI (NP) = EKINC
*  |  Updating conservation counters
         EINTR  = EINTR  + TKI (NP) + AMINC
         PXINTR = PXINTR + PXXINC
         PYINTR = PYINTR + PYYINC
         PZINTR = PZINTR + PZZINC
         ICINTR = ICINTR + ICH  (KTINC)
         IBINTR = IBINTR + IBAR (KTINC)
         PLR (NP) = SQRT (PXXINC * PXXINC + PYYINC * PYYINC +
     &                    PZZINC * PZZINC)
         CXR (NP) = PXXINC / PLR (NP)
         CYR (NP) = PYYINC / PLR (NP)
         CZR (NP) = PZZINC / PLR (NP)
      END IF
*  |
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |                          Loop over particles produced in nucevt
      DO 301 I=1,NNHAD
         NP = NP+1
         IF (NP .GT. MXP) GO TO 400
*  |  Get the "paprop" index for Nucevt produced particles
         KPART(NP) = KPTOIP (NRENU(I))
         IF ( KPART (NP) .EQ. 0 ) THEN
            WRITE (LUNERR,*)' **** Charmed particle produced in Nucevv',
     &      NRENU(I),HEPNU(I),AMNU(I),' ****'
            KPART (NP) = NRENU (I)
         END IF
         PLR  (NP) = SQRT ( PXNU (I)**2 + PYNU (I)**2 + PZNU (I)**2 )
         CXR  (NP) = PXNU (I) / PLR (NP)
         CYR  (NP) = PYNU (I) / PLR (NP)
         CZR  (NP) = PZNU (I) / PLR (NP)
         TKI(NP) = HEPNU(I) - AMNU(I)
         WEI(NP) = WE
*  |  +----------------------------------------------------------------*
*  |  |
         IF (TKI(NP) .LE. 0.D+00) THEN
*  |  | Is this the only check on the generated particle energy??
            EUZ = EUZ - HEPNU(I)
            PUX = PUX - PXNU(I)
            PUY = PUY - PYNU(I)
            PUZ = PUZ - PZNU(I)
            ICU = ICU - ICHNU(I)
            IBU = IBU - IBARNU(I)
            WRITE (LUNERR,*) ' Eventq: Kin en. < 0 from nucevt',TKI(NP)
            NP  = NP - 1
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 301  CONTINUE
*  |
*  +-------------------------------------------------------------------*
 500  CONTINUE
*
*  Now we have to compute the excitation energy: we have used Eincp and
*  Eincn for cascade protons and neutrons, Tvgre0 and Tvgrey have been
*  generated by cascade nucleons under threshold, Tveuz has been gene-
*  rated by the high energy collisions: however Tveuz and Tvgrey are
*  only approximate since they have been computed starting from an
*  average binding energy, furthermore Tvgrey is already accounted for
*  inside Eincp and Eincn. The actual energy spent inside high energy
*  collisions was Eke - Eincp - Eincn - Tvgre0 + Efrm, the one in ca-
*  scade nucleons (approximately) Eincp + Eincn - Tvgrey: so first
*  check the energy balance without excitation energy
*  and then compute Tv!!!
*
*  Now the balance!!!!!!!!!!!!!!!
*
      ERES  = ETTOT  - EUZ - ENUCR  - EINTR
      PXRES = PXTTOT - PUX - PXNUCR - PXINTR
      PYRES = PYTTOT - PUY - PYNUCR - PYINTR
      PZRES = PZTTOT - PUZ - PZNUCR - PZINTR
      ICRES = ICHTOT - ICU - ICNUCR - ICINTR
      IBRES = IBTOT  - IBU - IBNUCR - IBINTR
*  +-------------------------------------------------------------------*
*  |
      IF ( NINT (ZNOW) .NE. ICRES .OR. NINT (ANOW) .NE. IBRES ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( LNUCRI ) THEN
            WRITE (LUNERR,*)' Eventq: charge/baryon conservation',
     &                      ' failure with Nucrin',
     &                      NINT (ZNOW), ICRES, NINT (ANOW), IBRES
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            WRITE (LUNERR,*)' Eventq: charge/baryon conservation',
     &                      ' failure with Nucevt',
     &                      NINT (ZNOW), ICRES, NINT (ANOW), IBRES
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         LRESMP = .TRUE.
         GO TO 50
*  |--<--<--<--<--< go to resampling
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      IF ( IBRES .GT. 0 ) THEN
         AMMRES = ANOW * AMUAMU + 0.001D+00 * FKENER ( ANOW, ZNOW )
         AMNRES = AMMRES - ZNOW * AMELEC + ELBNDE ( ICRES )
*        AMNRES = ANOW * AMUC12
         EKR0   = ERES - AMNRES
*  |  Now switch to atomic masses:
         ERES   = ERES + AMMTAR - AMNTAR - ( ZZTAR - ZNOW ) * AMELEC
         EKRES  = ERES - AMMRES
         TVTENT = TVGRE0 + TVGREY + TVEUZ
         TVCOMP = ERES - ANOW * AMUC12
         IF ( LNUCRI ) TVCOMP = TVCOMP + ( AMNTAR - BBTAR * AMUC12 )
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         AMMRES = 0.D+00
         AMNRES = 0.D+00
         ERES   = 0.D+00
         EKR0   = 0.D+00
         EKRES  = 0.D+00
         TVTENT = 0.D+00
         GO TO 600
      END IF
*  |
*  +-------------------------------------------------------------------*
*  Check that the kinetic energy of the residual nuclei is not much
*  different from our prevision and kinematically consistent with
*  its momentum
*  +-------------------------------------------------------------------*
*  |
      IF ( EKRES .LE. 0.D+00 ) THEN
         WRITE ( LUNERR,* )' Eventq: negative kinetic energy for',
     &                     ' the residual nucleus!!',ICRES,IBRES,
     &                       REAL (EKRES), LNUCRI
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( EKRES .LT. -3.D-3 ) THEN
            LRESMP = .TRUE.
            GO TO 50
*--|--|--<--<--<--<--< go to resampling
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         EKRES  = 0.D+00
         TVRECL = 0.D+00
         AMSTAR = AMMRES
         TVCMS  = 0.D+00
         PTRES2 = 0.D+00
         PXRES  = 0.D+00
         PYRES  = 0.D+00
         PZRES  = 0.D+00
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         PTRES2 = PXRES**2 + PYRES**2 + PZRES**2
         AMSTAR = ERES**2  - PTRES2
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( AMSTAR .GE. AMMRES**2 ) THEN
            AMSTAR = SQRT ( AMSTAR )
            TVCMS  = AMSTAR - AMMRES
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |              If the following condition is satisfied it is only
*  |  |              a rounding problem, set the excitation energy to 0
*  |  |              and continue
         ELSE IF ( AMMRES**2 - AMSTAR .LT. 2.D+00 * AMSTAR * TVEPSI
     &             ) THEN
            AMSTAR = AMMRES
            TVCMS  = 0.D+00
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( AMSTAR .LE. 0.D+00 ) THEN
            WRITE ( LUNERR,* )' Eventq: immaginary mass for',
     &                        ' the residual nucleus!!',ICRES,IBRES,
     &                          REAL (AMSTAR)
            LRESMP = .TRUE.
            GO TO 50
*--|--|--<--<--<--<--< go to resampling
*           AMSTAR = AMMRES
*           TVCMS  = 0.D+00
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            AMSTAR = SQRT ( AMSTAR )
*  |  |  +-------------------------------------------------------------*
*  |  |  |           If the following condition is satisfied it is only
*  |  |  |           a rounding problem, set the excitation energy to 0
*  |  |  |           and continue
            IF ( AMMRES - AMSTAR .LT. TVEPSI ) THEN
               AMSTAR = AMMRES
               TVCMS  = 0.D+00
               TVRECL = ERES - AMSTAR
               GO TO 550
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            WRITE ( LUNERR,* )' Eventq: negative excitation energy for',
     &                        ' the residual nucleus!!',ICRES,IBRES,
     &                          REAL ( AMSTAR - AMMRES ), LNUCRI
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( AMSTAR - AMMRES .LT. -3.D-3 ) THEN
               LRESMP = .TRUE.
               GO TO 50
*--|--|--|--<--<--<--<--< go to resampling
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            AMSTAR = AMMRES
            TVCMS  = 0.D+00
            AMSTAR = AMMRES
            TVCMS  = 0.D+00
            HELP   = SQRT ( ( ERES - AMMRES ) * ( ERES + AMMRES )
     &             / PTRES2 )
            PXRES = PXRES * HELP
            PYRES = PYRES * HELP
            PZRES = PZRES * HELP
            PTRES2 = PTRES2 * HELP * HELP
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         TVRECL = ERES - AMSTAR
      END IF
*  |
*  +-------------------------------------------------------------------*
  550 CONTINUE
*  The following two cards are equivalent providing the kinematical
*  limits are ok and we use for both amnres or ammres! Now Tv is left
*  = 0
      TV     = 0.D+00
*     TV     = EKRES
*     TV     = TVRECL + TVCMS
*  +-------------------------------------------------------------------*
*  |
      IF ( .NOT. LEVPRT .AND. ABS ( ( TVTENT - TVCOMP ) / TVCOMP )
     &     .GT. 30000000.D+00 ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( LINCTV ) THEN
            WRITE ( LUNERR,* )
     &                      ' Eventq: excitation energy very different',
     &                      ' from the approximate one!!', ICRES, IBRES,
     &                        REAL (TVTENT), REAL (TVCOMP), LNUCRI
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
      EKRES = TVRECL
 600  CONTINUE
      EOTEST = EOTEST - EUZ - ENUCR - EINTR - EKR0 - AMNRES
*  +-------------------------------------------------------------------*
*  |
      IF ( ABS (EOTEST) .GT. ETEPS ) THEN
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( LNUCRI ) THEN
            WRITE (LUNERR,*)' Eventq: eotest failure with Nucrin',
     &                      EOTEST
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            WRITE (LUNERR,*)' Eventq: eotest failure with Nucevt',
     &                      EOTEST
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         LRESMP = .TRUE.
         GO TO 50
*  |--|--<--<--<--<--< go to resampling
      END IF
*  |
*  +-------------------------------------------------------------------*
      IF ( IBRES .EQ. 0 ) RETURN
*-->-->-->-->--> Here for the evaporation step!!!
*  +-------------------------------------------------------------------*
*  |                      Check if the evaporation is requested
      IF ( LEVPRT ) THEN
         PTRES = SQRT ( PTRES2 )
         CALL EVEVAP ( WE )
         IF ( LRESMP ) GO TO 50
*
*--|--<--<--<--<--<--< go to resampling
*  |
*  +-------------------------------------------------------------------*
*  |                      No evaporation
      ELSE
         TVHEAV = 0.D+00
      END IF
*  |
*  +-------------------------------------------------------------------*
      IF (IPRI.NE.1) RETURN
C
C********************************************************************
C     TEST PRINTOUT
C********************************************************************
C
      WRITE(LUNOUT,590)NP-NP0,NNHAD,IJ,IMAT,POO,EKE,TXI,TYI,TZI,WE
 590  FORMAT (4I7,6F12.6)
      DO 501 I=NP0+1,NP
      WRITE(LUNOUT,591)I,KPART(I),CXR(I),CYR(I),CZR (I),TKI(I),PLR (I),
     *                         WEI(I)
 591  FORMAT (2I5,6F12.6)
 501  CONTINUE
      RETURN
C
C********************************************************************
C     FINUC FLOWS OVER - THIS IS FATAL - INCREASE THE SIZE OF IT
C********************************************************************
C
 400  CONTINUE
      WRITE(LUNOUT,490)
 490  FORMAT(1X,'OVERFLOW IN EVENTQ - INCREASE THE SIZE OF THE',
     1' COMMON BLOCK FINUC.')
      STOP
      END
+DECK,  EVEVAP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

*$ CREATE EVEVAP.FOR
*COPY EVEVAP
*=== evevap ===========================================================*
      SUBROUTINE EVEVAP ( WEE )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  EVent EVAPoration: this routine is used to steer both the evapora-  *
*  tion, the high energy fission, possibly a future fragmentation      *
*  and the gamma deexcitation routines                                 *
*                                                                      *
*  Created  on  15  may  1991   by   Alfredo Ferrari & Paola Sala      *
*                                             INFN - Milan             *
*                                                                      *
*  Last change  on 19-apr-93    By   Alfredo Ferrari, INFN - Milan     *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, EVA1.
+CDE, FHEAVY.
+CDE, FINUC.
+CDE, HETC5.
+CDE, HETC7.
+CDE, HETTP.
+CDE, HIGFIS.
+CDE, LABCOS.
+CDE, NUCDAT.
+CDE, PAREVT.
+CDE, PART.
+CDE, RESNUC.
*
      PARAMETER ( AMUMEV = 1.D+03 * AMUAMU )
*
      COMMON /FKEVNT/ LNUCRI, LHADRI
      LOGICAL LNUCRI, LHADRI
*  The initial excitation energy, mass and charge of the nucleus are
*  put into Ex, Apr, Zpr (common Hetc5)
      EX  = MAX ( 1000 * TVCMS, ANGLGB )
      APR = ANOW
      ZPR = ZNOW
*  Reset the fission/fragmentation counter:
      NFISS = 0
*  Ammres is the atomic mass of the residual nucleus
*  Reset accumulators for the energy conservation check (they are only
*  local)
      EOTEST = AMMRES + TVCMS + TVRECL
      ETEVAP = 0.D+00
*  +-------------------------------------------------------------------*
*  |  Set the variables recording the recoil direction of the residual
*  |  nucleus:
      IF ( PTRES .GT. 0.D+00 ) THEN
         COSLBR (1) = PXRES / PTRES
         COSLBR (2) = PYRES / PTRES
         COSLBR (3) = PZRES / PTRES
*  |
*  +-------------------------------------------------------------------*
*  |  It can happen for pion capture for example that ptres=0
*  |  ( it is always 0 if no "direct" particle is emitted )
      ELSE
         COSLBR (1) = 0.D+00
         COSLBR (2) = 0.D+00
         COSLBR (3) = 1.D+00
      END IF
*  |
*  +-------------------------------------------------------------------*
*  The call to getrig is useless, since we actually need no rotation
*     CALL GETRIG ( ZERZER, ZERZER, ONEONE )
      EREC = 1.D+03 * TVRECL
      CALL FKERUP (0)
*  +-------------------------------------------------------------------*
*  |  Check for fission/fragmentation: if it occurred loop back on the
*  |  fission fragments to possibly evaporate further particles:
      IF ( FISINH ) THEN
         LRNFSS = .TRUE.
         FISINH = .FALSE.
         JFISS  = 0
*  |  +----------------------------------------------------------------*
*  |  |  Update the partial counters of evaporated particles
         DO 40 J = 1,6
            NPARTF (J,JFISS) = NPART (J)
            HEVFIS (JFISS)   = HEVSUM
   40    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |  The following "do" is not structured as a do since Nfiss can
*  |  |  be incremented during evaporation/fragmentation of the
*  |  |  previously generated fragments
   50    CONTINUE
            JFISS  = JFISS + 1
            AMMRES = 1.D-03 * AMFIS (JFISS)
            PTRES  = 1.D-03 * PPFIS (JFISS)
            EREC = EKFIS (JFISS)
            APR  = AFIS  (JFISS)
            ZPR  = ZFIS  (JFISS)
            EX   = MAX ( UFIS (JFISS), ANGLGB )
            COSLBR (1) = COSLFF (1,JFISS)
            COSLBR (2) = COSLFF (2,JFISS)
            COSLBR (3) = COSLFF (3,JFISS)
*  |  |  The call to getrig is useless, since we need no rotation
*           CALL GETRIG ( ZERZER, ZERZER, ONEONE )
            CALL FKERUP (JFISS)
            ANOW = APR
            ZNOW = ZPR
            ICHLP = NINT (ZNOW)
            IBHLP = NINT (ANOW)
*  |  |  +-------------------------------------------------------------*
*  |  |  |  If we enter this branch the present fragment has been
*  |  |  |  completely evaporated without further fragmentation and
*  |  |  |  it is ready for the final gamma deexcitation and for
*  |  |  |  residual nuclei scoring
            IF ( .NOT. FISINH .AND. IBHLP .GT. 0 ) THEN
               AMTFIS (JFISS) = ANOW * AMUMEV +  FKENER ( ANOW, ZNOW )
               UTFIS  (JFISS) = UU
               RECFIS (JFISS) = EREC
               PPTFIS (JFISS) = SQRT ( EREC * ( EREC + TWOTWO
     &                        * ( AMTFIS (JFISS) + UTFIS (JFISS) ) ) )
               ATFIS  (JFISS) = ANOW
               ZTFIS  (JFISS) = ZNOW
               COSLFF (1,JFISS) = COSLBR (1)
               COSLFF (2,JFISS) = COSLBR (2)
               COSLFF (3,JFISS) = COSLBR (3)
               ETEVAP = ETEVAP + 1.D-03 * ( EREC + AMTFIS (JFISS)
     &                + UTFIS (JFISS) )
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Fragment furtherly fragmented or completely evaporated into
*  |  |  |  p,n,d,t,3-He and alphas
            ELSE
               FISINH = .FALSE.
               ATFIS  (JFISS) = ZERZER
               ZTFIS  (JFISS) = ZERZER
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Update the partial counters of evaporated particles
            DO 60 J = 1,6
               NPARTF (J,JFISS) = NPART (J)
               HEVFIS (JFISS)   = HEVSUM
   60       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         IF ( JFISS .LT. NFISS ) GO TO 50
*  |  |
*  |  +----------------------------------------------------------------*
         FISINH = .FALSE.
      END IF
*  |
*  +-------------------------------------------------------------------*
      IEVNEU = NPART (1)
      IEVPRO = NPART (2)
      IEVDEU = NPART (3)
      IEVTRI = NPART (4)
      IEV3HE = NPART (5)
      IEV4HE = NPART (6)
      IEVAPL = IEVNEU + IEVPRO
      IEVAPH = IEVDEU + IEVTRI + IEV3HE + IEV4HE
*  +-------------------------------------------------------------------*
*  |              Add to the secondary stack the evaporated neutrons
      DO 100 IP = 1, NPART (1)
         NP = NP + 1
         KPART (NP) = 8
         TKI   (NP) = 1.D-03 * EPART ( IP, 1 )
         WEI   (NP) = WEE
         CXR   (NP) = COSEVP ( 1, IP, 1 )
         CYR   (NP) = COSEVP ( 2, IP, 1 )
         CZR   (NP) = COSEVP ( 3, IP, 1 )
         PLR   (NP) = SQRT ( TKI (NP) * ( TKI (NP) + 2.D+00 * AM (8) ) )
         ETEVAP = ETEVAP + TKI (NP) + AMHEAV (1)
  100 CONTINUE
*  |
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |              Add to the secondary stack the evaporated protons
      DO 200 IP = 1, NPART (2)
         NP = NP + 1
         KPART (NP) = 1
         TKI   (NP) = 1.D-03 * EPART ( IP, 2 )
         WEI   (NP) = WEE
         CXR   (NP) = COSEVP ( 1, IP, 2 )
         CYR   (NP) = COSEVP ( 2, IP, 2 )
         CZR   (NP) = COSEVP ( 3, IP, 2 )
         PLR   (NP) = SQRT ( TKI (NP) * ( TKI (NP) + 2.D+00 * AM (1) ) )
         ETEVAP = ETEVAP + TKI (NP) + AMHEAV (2)
  200 CONTINUE
*  |
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |         Add to the heavy stack the other evaporated (if requested)
      IF ( LHEAVY ) THEN
         NPHEAV = 0
*  |  +----------------------------------------------------------------*
*  |  |  Loop over the particle types:
         DO 400 JP = 3, 6
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            DO 300 IP = 1, NPART (JP)
               NPHEAV = NPHEAV + 1
               KHEAVY (NPHEAV) = JP
               TKHEAV (NPHEAV) = 1.D-03 * EPART ( IP, JP )
               WHEAVY (NPHEAV) = WEE
               CXHEAV (NPHEAV) = COSEVP ( 1, IP, JP )
               CYHEAV (NPHEAV) = COSEVP ( 2, IP, JP )
               CZHEAV (NPHEAV) = COSEVP ( 3, IP, JP )
               PHEAVY (NPHEAV) = SQRT ( ( TKHEAV (NPHEAV) + TWOTWO
     &                         * AMHEAV (JP) ) * TKHEAV (NPHEAV) )
               ETEVAP = ETEVAP + TKHEAV (NPHEAV) + AMHEAV (JP)
  300       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
  400    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         NPHEAV = 0
         ETEVAP = ETEVAP + 1.D-03 * HEVSUM + IEVDEU * AMHEAV (3)
     &          + IEVTRI * AMHEAV (4)
     &          + IEV3HE * AMHEAV (5)
     &          + IEV4HE * AMHEAV (6)
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Fission and/or fragmentation occurred:
      IF ( LRNFSS ) THEN
         TVHEAV = 1.D-03 * HEVSUM
         IF ( ABS ( ETEVAP - EOTEST )/ EOTEST .GT. 1.D-07 ) THEN
            WRITE ( LUNOUT, * )
     &            ' Evevap_fis: failure in energy conservation!!',
     &                        ETEVAP, EOTEST
            WRITE ( LUNERR, * )
     &            ' Evevap_fis: failure in energy conservation!!',
     &                        ETEVAP, EOTEST
         END IF
         TVCHLP = ZERZER
         IDEHLP = 0
*  |  +----------------------------------------------------------------*
*  |  |  Loop on fission/fragmentation fragments
         DO 5000 JFISS = 1, NFISS
            ANOW  = ATFIS (JFISS)
            ZNOW  = ZTFIS (JFISS)
            IBRES = NINT ( ANOW )
            ICRES = NINT ( ZNOW )
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check the residual nucleus:
            IF ( IBRES .EQ. 0 ) THEN
               AMMRES = ZERZER
               TVCMS  = ZERZER
               TVRECL = ZERZER
               PTRES  = ZERZER
               PXRES  = ZERZER
               PYRES  = ZERZER
               PZRES  = ZERZER
               ERES   = ZERZER
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |  real fragment:
            ELSE
               AMMRES = 1.D-03 * AMTFIS (JFISS)
               TVCMS  = 1.D-03 * UTFIS  (JFISS)
               TVRECL = 1.D-03 * RECFIS (JFISS)
               PTRES  = 1.D-03 * PPTFIS (JFISS)
               PXRES  = PTRES * COSLFF (1,JFISS)
               PYRES  = PTRES * COSLFF (2,JFISS)
               PZRES  = PTRES * COSLFF (3,JFISS)
               ERES   = AMMRES + TVCMS + TVRECL
               EKRES  = TVRECL
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if the deexcitation module have to be called
            IF ( LDEEXG ) THEN
               IDEEXG = 0
               CALL EVDEEX ( WEE )
               IDEHLP = IDEHLP + IDEEXG
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               TVCHLP = TVCHLP + TVCMS
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if fission fragments have to be put on stack
            IF ( LHEAVY .AND. IBRES .GT. 0 ) THEN
               NPHEAV = NPHEAV + 1
               TKHEAV (NPHEAV) = EKRES
               PHEAVY (NPHEAV) = PTRES
               CXHEAV (NPHEAV) = PXRES / PTRES
               CYHEAV (NPHEAV) = PYRES / PTRES
               CZHEAV (NPHEAV) = PZRES / PTRES
               WHEAVY (NPHEAV) = WEE
               KHEAVY (NPHEAV) = 6 + JFISS
               AMHEAV (KHEAVY(NPHEAV)) = AMMRES
               IBHEAV (KHEAVY(NPHEAV)) = IBRES
               ICHEAV (KHEAVY(NPHEAV)) = ICRES
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            TVHEAV = TVHEAV + TVRECL
 5000    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         IDEEXG = IDEHLP
         TVCMS  = TVCHLP
         ANOW   = ZERZER
         ZNOW   = ZERZER
         IBRES  = 0
         ICRES  = 0
         AMMRES = ZERZER
         TVRECL = ZERZER
         PTRES  = ZERZER
         PXRES  = ZERZER
         PYRES  = ZERZER
         PZRES  = ZERZER
         ERES   = ZERZER
*  |
*  +-------------------------------------------------------------------*
*  |  Normal evaporation:
      ELSE
         ANOW  = APR
         ZNOW  = ZPR
         IBRES = NINT ( ANOW )
         ICRES = NINT ( ZNOW )
*  |  Ammres is the atomic mass of the residual nucleus
*  |  +----------------------------------------------------------------*
*  |  |  Check the residual nucleus:
         IF ( IBRES .EQ. 0 ) THEN
            AMMRES = ZERZER
            TVCMS  = ZERZER
            TVRECL = ZERZER
            PTRES  = ZERZER
            PXRES  = ZERZER
            PYRES  = ZERZER
            PZRES  = ZERZER
            ERES   = ZERZER
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            AMMRES = ANOW * AMUAMU + 1.D-03 * FKENER ( ANOW, ZNOW )
            TVCMS  = 1.D-03 * UU
            TVRECL = 1.D-03 * EREC
            PTRES  = SQRT ( TVRECL * ( TVRECL + 2.D+00 * ( AMMRES +
     &                      TVCMS ) ) )
            PXRES  = PTRES * COSLBR (1)
            PYRES  = PTRES * COSLBR (2)
            PZRES  = PTRES * COSLBR (3)
            ERES   = AMMRES + TVCMS + TVRECL
            EKRES  = TVRECL
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         TVHEAV = 1.D-03 * HEVSUM
         ETEVAP = ETEVAP + ERES
         IF ( ABS ( ETEVAP - EOTEST )/ EOTEST .GT. 1.D-07 ) THEN
            WRITE ( LUNOUT, * )
     &            ' Evevap: failure in energy conservation!!',
     &                        ETEVAP, EOTEST
            WRITE ( LUNERR, * )
     &            ' Evevap: failure in energy conservation!!',
     &                        ETEVAP, EOTEST
         END IF
*  |   Check if the deexcitation module have to be called
         IF ( LDEEXG ) CALL EVDEEX ( WEE )
      END IF
*  |
*  +-------------------------------------------------------------------*
      RETURN
*=== End of subroutine Evevap =========================================*
      END
+DECK,  EVVINI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

*$ CREATE EVVINI.FOR
*COPY EVVINI
*=== evvini ===========================================================*
      SUBROUTINE EVVINI (WHAT,SDUM)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Version march 1990   by          Alfredo Ferrari, INFN-Milan     *
*                                                                      *
*     Last change  on  20-apr-92   by  Alfredo Ferrari, INFN-Milan     *
*     This subroutine initialises the quark model subroutines and the  *
*     evaporation module (Evap5 from Hetc-Kfa).                        *
*                                                                      *
*     input variables:                                                 *
*        what has currently no meaning                                 *
*        sdum = material name of a heavy ion beam                      *
*                                                                      *
*     output variables: none                                           *
*                                                                      *
*     Common blocks:                                                   *
*                                                                      *
*     /print/ printing control for the nucevt package                  *
*     /inpdat/ parameters for the nucevt package                       *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, INPDAT2.
+CDE, PAREVT.
      CHARACTER*8 SDUM
      DIMENSION WHAT(6)
      COMMON/FKPRIN/IPRI,INIT
      IF (.NOT.LEVPRT) LDEEXG=.FALSE.
      CALL DATAR3
      CALL HADDEN
      CALL RCHANV
      CALL CHANWT
      ONEDUM = ONEONE
      ZERDUM = ZERZER
      NUD = NUDISV ( ONEDUM, 1, ZERDUM, ZERDUM, DPOWER, ZERDUM )
      CALL BERTTP
      CALL INCINI
      IPRI=0
      INIT=0
      LTBAMJ=0
      ASBAMJ = 0.5D+00
      B8BAMJ = 0.4D+00
      RETURN
      END
+DECK,  FEREVV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

      SUBROUTINE FEREVV ( NHAD, KP, KT, PM, EKM, TXX, TYY, TZZ, ATEMP,
     &                    ZTEMP, IVVFLG )
+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  Ferevt90 by A. Ferrari                                              *
*                                                                      *
*      Last change  on  15-aug-93   by   Alfredo Ferrari, INFN - Milan *
*                                                                      *
*      Ferevt calculates hadron nucleon collisions                     *
*      including the Fermi momentum of the target:                     *
*      now there are two entries, one for valence collisions (or for   *
*      sea collisions with one of the last two nucleons) and one       *
*      (fersea) for sea collisions.                                    *
*                                                                      *
*      Nhad = number of final hadrons                                  *
*      Kp and Kt are indices of the projectile and target nucleons     *
*      Pm   = momentum of the projectile (for ferevv entry)            *
*      Ekm  = kinetic energy of the projectile (for both entries)      *
*      Txx, Tyy, Tzz = direction cosines of the incident projectile,   *
*                      THEY ARE CHANGED in the routine for sea intera- *
*                      ctions                                          *
*      Atemp, Ztemp  = mass and atomic number of the residula nucleus  *
*                      after the "use" of the Kt nucleon               *
*      Kprim = index of the real projectile (only for Fersea)          *
*      Eprim = energy of the real projectile after the emission of     *
*              the virtual meson (only for Fersea)                     *
*      Pprim = momentum of the real projectile after the emission of   *
*              the virtual meson (only for Fersea)                     *
*      Eprold= energy of the real projectile before the emission of    *
*              the virtual meson (only for Fersea)                     *
*      Pprold= momentum of the real projectile before the emission of  *
*              the virtual meson (only for Fersea)                     *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, DEPNUC.
+CDE, HADPAR.
+CDE, INPDAT2.
+CDE, NUCDAT.
+CDE, PAREVT.
+CDE, PART2.
+CDE, RESNUC.
      COMMON /FKPRIN/ IPRI, INIT
      LOGICAL LSEACL, LSMPAN
      DIMENSION PTHRSH (NALLWP), IJNUCR (NALLWP)
      COMMON /FKEVNT/ LNUCRI, LHADRI
      LOGICAL LNUCRI, LHADRI
      REAL FRNDM(3)
      REAL FRUUN(1)
      SAVE PTHRSH, IJNUCR
      DATA PTHRSH / 16*5.D+00,2*2.5D+00,5.D+00,3*2.5D+00,8*5.D+00,
     &              9*2.5D+00 /
      DATA IJNUCR / 16*1,2*0,1,3*0,8*1,9*0 /
      IVFLAG = IVVFLG
      AMPROJ = AAM (KP)
      AMTAR  = AAM (KT)
      PSPENT = PM
      ESPENT = EKM + AMPROJ
      PSPTOT = PSPENT
      ESPTOT = ESPENT
      LSEACL = .FALSE.
      IF ( AMPROJ .LT. 1.D+00 ) THEN
         AFACT = 2.8D+00
      ELSE
         AFACT = 1.8D+00
      END IF
      URMIN2 = ( AMPROJ + AMTAR )**2 + ( 1.2D+00 + DBLE (IVFLAG)
     &       * AFACT ) * ETHSEA * AMTAR
      GO TO 100
         ENTRY FERSEA ( NHAD, KP, KT, EKM, TXX, TYY, TZZ, ATEMP, ZTEMP,
     &                  KPRIM, EPRIM, PPRIM, EPROLD, PPROLD )
   50    CONTINUE
         LSEACL = .TRUE.
         IVFLAG = 0
         AMPROJ = AAM (KP)
         AMTAR  = AAM (KT)
         PSPTOT = PPROLD
         ESPTOT = EPROLD
         PSPENT = PPROLD - PPRIM
         ESPENT = EKM + AMPROJ
         IF ( KP .EQ. 26 .AND. KT .EQ. 8 ) THEN
            URMIN2 = ( AAM (13) + AAM (56) )**2 + 0.2D+00 * ETHSEA
     &             * AAM (56)
         ELSE IF ( KP .EQ. 23 .AND. KT .EQ. 1 ) THEN
            URMIN2 = ( AAM (14) + AAM (53) )**2 + 0.2D+00 * ETHSEA
     &             * AAM (53)
         ELSE
            URMIN2 = ( AMPROJ + AMTAR )**2 + 1.2D+00 * ETHSEA * AMTAR
         END IF
 100  CONTINUE
      ITJ = MIN ( 2, KT )
      B1SAVE = B1BAMJ
      B2SAVE = B2BAMJ
      IF ( LLASTN ) THEN
         IF ( LLAST1 ) THEN
            PXNUC = PXXINC
            PYNUC = PYYINC
            PZNUC = PZZINC
            EKNUC = EKINC
         ELSE
            LLAST1 = .TRUE.
            EKNUC  = EKLAST
            PXNUC  = PXLAST
            PYNUC  = PYLAST
            PZNUC  = PZLAST
         END IF
         EM    = EKM   + AMPROJ
         EFER  = EKNUC + AMTAR
         EKFER = EFER  - AMNUCL (ITJ) + EBNDNG (ITJ)
         EFRM  = EFRM  + EKFER
         PXFRM = PXFRM + PXNUC
         PYFRM = PYFRM + PYNUC
         PZFRM = PZFRM + PZNUC
         ECHCK  = EM + EFER
         PXCHCK = PXNUC + PM * TXX
         PYCHCK = PYNUC + PM * TYY
         PZCHCK = PZNUC + PM * TZZ
         UMO  = SQRT ( ECHCK**2 - PXCHCK**2 - PYCHCK**2 - PZCHCK**2 )
      ELSE
         CALL GRNDM(FRNDM,3)
         P2  = MAX ( FRNDM (1), FRNDM (2), FRNDM (3) )
         P2  = PFRMMX (ITJ) * P2
         P2SQ   = P2 * P2
         AMTEMP = ATEMP * AMUC12
         AMTMSQ = AMTEMP * AMTEMP
         EKRECL = 0.5D+00 * P2SQ / AMTEMP * ( 1.D+00 - 0.25D+00 * P2SQ
     &          / AMTMSQ )
         EKREC0 = EKRECL
         CALL POLI   (POLC, POLS)
         CALL SFECFE (SFE , CFE )
         CXTA = POLS * CFE
         CYTA = POLS * SFE
         CZTA = POLC
         PXNUC = P2 * CXTA
         PYNUC = P2 * CYTA
         PZNUC = P2 * CZTA
         PXFRM = PXFRM + PXNUC
         PYFRM = PYFRM + PYNUC
         PZFRM = PZFRM + PZNUC
         EFER  = SQRT ( AMNUSQ (ITJ) + PXNUC**2 + PYNUC**2 + PZNUC**2 )
         FRSURV = ANOW /  DBLE ( IBTAR )
         IF ( .NOT. LSEACL .OR. FRSURV .LT. 0.66D+00 .OR. ATEMP .LT.
     &        40.D+00 ) THEN
            IATEMP = NINT (ATEMP)
            IZTEMP = NINT (ZTEMP)
            AMMRES = AMUAMU * ATEMP + 1.D-03 * FKENER ( ATEMP, ZTEMP )
            AMMRE2 = AMMRES * AMMRES
            EKRECL = SQRT ( P2SQ + AMMRE2 ) - AMMRES
            EKREC0 = EKRECL
            ELEFT  = ETTOT  - EINTR  - EUZ - ESPTOT - EFER + EKRECL
     &             + V0WELL (ITJ) + EBNDNG (ITJ)
            PXLAST = PXTTOT - PXINTR - PUX - PSPTOT * TXX - PXNUC
            PYLAST = PYTTOT - PYINTR - PUY - PSPTOT * TYY - PYNUC
            PZLAST = PZTTOT - PZINTR - PUZ - PSPTOT * TZZ - PZNUC
            PPLAS2 = PXLAST**2 + PYLAST**2 + PZLAST**2
            IUMO = 0
            DELEFT = AMMTAR - AMNTAR - ( DBLE (ICHTAR) - ZTEMP )
     &             * AMELEC
 200        CONTINUE
               EELEFT = ELEFT + DELEFT
               UMO2 = EELEFT**2 - PPLAS2
               DELTU2 = AMMRE2 - UMO2
               IF ( DELTU2 .GT. 0.D+00 ) THEN
                  IUMO = IUMO + 1
                  IF ( LSEACL ) THEN
                     DELTAE = 0.5D+00 * DELTU2 / EELEFT
                     IF ( IUMO .GT. 2 ) THEN
                     ELSE IF ( DELTAE .LT. 2.D+00 * EKREC0 ) THEN
                        EKRECL = EKRECL + DELTAE
                        ELEFT  = ELEFT  + DELTAE
                        GO TO 200
                     ELSE
                        EKRECL = EKRECL + EKREC0
                        ELEFT  = ELEFT  + EKREC0
                        EELEFT = ELEFT + DELEFT
                        UMO2 = EELEFT**2 - PPLAS2
                        DELTU2 = AMMRE2 - UMO2
                        PFDTPL = PXNUC * PXLAST + PYNUC * PYLAST
     &                         + PZNUC * PZLAST
                        PPLAST = SQRT ( PPLAS2 )
                        DELTPR = 0.51D+00 * DELTU2 / ( PPLAST - EELEFT
     &                         * PFDTPL / ( EFER * PPLAST ) )
                        DELTPR = SIGN ( MIN ( ABS ( DELTPR ), HLFHLF
     &                         * P2 ), DELTPR ) / PPLAST
                        PXXINC = PXLAST * DELTPR
                        PYYINC = PYLAST * DELTPR
                        PZZINC = PZLAST * DELTPR
                        PXLAST = PXLAST - PXXINC
                        PYLAST = PYLAST - PYYINC
                        PZLAST = PZLAST - PZZINC
                        PXFRM = PXFRM + PXXINC
                        PYFRM = PYFRM + PYYINC
                        PZFRM = PZFRM + PZZINC
                        PXNUC = PXNUC + PXXINC
                        PYNUC = PYNUC + PYYINC
                        PZNUC = PZNUC + PZZINC
                        EFER0 = EFER
                        EFER  = SQRT ( PXNUC**2 + PYNUC**2 +
     &                                 PZNUC**2 + AMNUSQ  (ITJ) )
                        DELTAE = EFER0 - EFER
                        IF ( DELTAE .GT. 0.D+00 ) THEN
                           ELEFT = ELEFT + DELTAE
                        ELSE
                           EFER = EFER0
                        END IF
                        PPLAS2 = PXLAST**2 + PYLAST**2 + PZLAST**2
                        DELTAE = EKREC0
                        GO TO 200
                     END IF
                  ELSE
                     DELTAE = 0.5D+00 * DELTU2 / EELEFT
                     IF ( IUMO .GT. 3 ) THEN
                        WRITE ( LUNOUT, * )' Ferevv: valence call,',
     &                  ' impossible to get',
     &                  ' enough invariant mass for the residual',
     &                  ' nucleus!!',IATEMP,IZTEMP,AMMRE2,UMO2,UMO,
     &                    DELTAE
                        WRITE ( LUNERR, * )' Ferevv: valence call,',
     &                  ' impossible to get',
     &                  ' enough invariant mass for the residual',
     &                  ' nucleus!!',IATEMP,IZTEMP,AMMRE2,UMO2,UMO,
     &                    DELTAE
                     ELSE IF ( DELTAE .LT. 3.D+00 * EKREC0 ) THEN
                        EKRECL = EKRECL + DELTAE
                        ELEFT  = ELEFT  + DELTAE
                        GO TO 200
                     ELSE
                        EKRECL = EKRECL + 2.D+00 * EKREC0
                        ELEFT  = ELEFT  + 2.D+00 * EKREC0
                        EELEFT = ELEFT + DELEFT
                        UMO2 = EELEFT**2 - PPLAS2
                        DELTU2 = AMMRE2 - UMO2
                        PPDTPL = PM * ( PXLAST * TXX + PYLAST * TYY
     &                         + PZLAST * TZZ )
                        PPLAST = SQRT ( PPLAS2 )
                        DELTPR = 0.51D+00 * DELTU2 / ( PPLAST - EELEFT
     &                         * PPDTPL / ( ( EKM + AMPROJ ) * PPLAST
     &                           ) )
                        TMPPM  = 0.3D+00 * PM
                        TMPPPL = 0.8D+00 * PPLAST
                        DELTPR = SIGN ( MIN ( ABS ( DELTPR ), TMPPM
     &                          , TMPPPL ), DELTPR )
     &                         / PPLAST
                        PXXINC = PXLAST * DELTPR
                        PYYINC = PYLAST * DELTPR
                        PZZINC = PZLAST * DELTPR
                        PXLAST = PXLAST - PXXINC
                        PYLAST = PYLAST - PYYINC
                        PZLAST = PZLAST - PZZINC
                        PXFRM = PXFRM + PXXINC
                        PYFRM = PYFRM + PYYINC
                        PZFRM = PZFRM + PZZINC
                        PXXINC = PM * TXX + PXXINC
                        PYYINC = PM * TYY + PYYINC
                        PZZINC = PM * TZZ + PZZINC
                        PM  = SQRT ( PXXINC**2 + PYYINC**2
     &                             + PZZINC**2 )
                        TXX = PXXINC / PM
                        TYY = PYYINC / PM
                        TZZ = PZZINC / PM
                        DELTAE = EKM
                        EKM = SQRT ( PM * PM + AMPROJ * AMPROJ )
     &                      - AMPROJ
                        DELTAE = DELTAE - EKM
                        ELEFT  = ELEFT  + DELTAE
                        EFRM   = EFRM   - DELTAE
                        PPLAS2 = PXLAST**2 + PYLAST**2 + PZLAST**2
                        PSPENT = PM
                        ESPENT = EKM + AMPROJ
                        PSPTOT = PSPENT
                        ESPTOT = ESPENT
                        GO TO 200
                     END IF
                  END IF
                  UMO = ( ESPENT + EFER - V0WELL (ITJ) - EKRECL
     &                  - EBNDNG (ITJ) )**2
     &                - ( TXX * PSPENT + PXNUC )**2
     &                - ( TYY * PSPENT + PYNUC )**2
     &                - ( TZZ * PSPENT + PZNUC )**2
                  IF ( UMO .LT. URMIN2 ) THEN
                     WRITE ( LUNOUT, * )' Ferevv: impossible to get',
     &                      ' enough invariant mass for interaction',
     &                        IATEMP,IZTEMP,AMMRE2,UMO2,UMO
                     WRITE ( LUNERR, * )' Ferevv: impossible to get',
     &                      ' enough invariant mass for interaction',
     &                        IATEMP,IZTEMP,AMMRE2,UMO2,UMO
                  END IF
               END IF
            IF ( IUMO .GT. 0 .AND. .NOT. LSEACL .AND. DELTU2 .LT.
     &           0.D+00 ) THEN
               DELTAE = SQRT ( DELTU2 + EELEFT**2 )
     &                - EELEFT
               DELTAE = DELTAE + 10.D+00 * ANGLGB * AMMRES
               EKRECL = EKRECL + DELTAE
               ELEFT  = ELEFT  + DELTAE
               EELEFT = ELEFT + DELEFT
               UMO2 = EELEFT**2 - PPLAS2
               DELTU2 = AMMRE2 - UMO2
            END IF
         ELSE
            AMTEMP = ATEMP * AMUC12
            AMTMSQ = AMTEMP * AMTEMP
            EKRECL = 0.5D+00 * P2SQ / AMTEMP * ( 1.D+00 - 0.25D+00
     &             * P2SQ / AMTMSQ )
            EKREC0 = EKRECL
         END IF
         EKFER = EFER - AMNUCL (ITJ)
         IF ( LSEACL ) THEN
            AMPRI2 = EPRIM * EPRIM - PPRIM * PPRIM
            PXCHCK = PXNUC + PPROLD * TXX
            PYCHCK = PYNUC + PPROLD * TYY
            PZCHCK = PZNUC + PPROLD * TZZ
            P2CHCK = PXCHCK**2 + PYCHCK**2 + PZCHCK**2
            ECHCK  = EPROLD + EFER
            UMO2   = ECHCK**2 - P2CHCK
            IF ( UMO2 .LT. 0.D+00 ) THEN
               LRESMP = .TRUE.
               WRITE (LUNERR,*)' FEREVV: SEA INT. UMO2 < 0 ',UMO2
               RETURN
            END IF
            UMO    = SQRT ( UMO2 )
            RMIN2  = URMIN2 / UMO2
            GAMCM = ECHCK  / UMO
            ETAX  = PXCHCK / UMO
            ETAY  = PYCHCK / UMO
            ETAZ  = PZCHCK / UMO
            ETACM = SQRT ( ETAX**2 + ETAY**2 + ETAZ**2 )
            CXCMS = ETAX / ETACM
            CYCMS = ETAY / ETACM
            CZCMS = ETAZ / ETACM
            CALL SFECFE ( SFE, CFE )
            IF ( ABS (CZCMS) .GT. 1.D-04 ) THEN
               CXXTR  = - SFE * CZCMS
               CYYTR  = CFE * CZCMS
               CZZTR  = CXCMS * SFE - CYCMS * CFE
            ELSE IF ( ABS (CYCMS) .GT. 1.D-04 ) THEN
               CXXTR  = CYCMS * CFE
               CYYTR  = CZCMS * SFE - CXCMS * CFE
               CZZTR  = - SFE * CYCMS
            ELSE
               CXXTR  = CYCMS * SFE - CZCMS * CFE
               CYYTR  = - SFE * CXCMS
               CZZTR  = CFE * CXCMS
            END IF
            TXXOLD = TXX
            TYYOLD = TYY
            TZZOLD = TZZ
            PCMSMX = PPRIM - ETACM * ( EPRIM - ETACM * PPRIM / ( GAMCM
     &             + 1.D+00 ) )
            RMAX2  = 1.D+00 + AMPRI2 / UMO2 - 2.D+00 * ( EPRIM -
     &               ETACM * PCMSMX ) / ECHCK
            IF ( RMAX2 .GT. RMIN2 ) THEN
               PTRANS = 0.D+00
            ELSE
               PTRANS = 0.D+00
            END IF

1220        CONTINUE
               PLONG2 = ( PPRIM - PTRANS ) * ( PPRIM + PTRANS )
               PLONGI = SQRT ( PLONG2 )
               PXLAST = PTRANS * CXXTR + PLONGI * CXCMS
               PYLAST = PTRANS * CYYTR + PLONGI * CYCMS
               PZLAST = PTRANS * CZZTR + PLONGI * CZCMS
               PCMSLN = PLONGI - ETACM * ( EPRIM - ETACM * PLONGI /
     &                ( GAMCM + 1.D+00 ) )
               RURM2  = 1.D+00 + AMPRI2 / UMO2 - 2.D+00 * ( EPRIM -
     &                  ETACM * PCMSLN ) / ECHCK
               TXX = PXLAST / PPRIM
               TYY = PYLAST / PPRIM
               TZZ = PZLAST / PPRIM
               IF ( RURM2 .LE. RMIN2 ) THEN
                  PTRANS = 0.5D+00 * PTRANS
                  WRITE ( LUNERR, * )' Ferevv: R2 < Rmin2 for Pt',
     &                                 RURM2, RMIN2, URMIN2
                  IF ( PTRANS .GT. ANGLGB ) GO TO 1220
               END IF
            PCMSX  = PCMSLN * CXCMS + PTRANS * CXXTR
            PCMSY  = PCMSLN * CYCMS + PTRANS * CYYTR
            PCMSZ  = PCMSLN * CZCMS + PTRANS * CZZTR
            ERCMS  = 0.5D+00 * ( UMO2 * ( 1.D+00 + RURM2 ) - AMPRI2 )
     &             / UMO
            ETAPCM = PCMSLN * ETACM
            ECHCK  = GAMCM * ERCMS - ETAPCM
            PHELP  = - ETAPCM / (GAMCM + 1.D+00) + ERCMS
            PXCHCK = - PCMSX + ETAX * PHELP
            PYCHCK = - PCMSY + ETAY * PHELP
            PZCHCK = - PCMSZ + ETAZ * PHELP
            ECHCK = ECHCK - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
            UMO   = ECHCK**2 - PXCHCK**2 - PYCHCK**2
     &            - PZCHCK**2
            IF ( UMO .LT. 0.D+00 ) THEN
               LRESMP = .TRUE.
               RETURN
            END IF
            UMO   = SQRT ( UMO )
         ELSE
            EM = EKM + AMPROJ - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
            ECHCK  = EM + EFER
            PXCHCK = PXNUC + PM * TXX
            PYCHCK = PYNUC + PM * TYY
            PZCHCK = PZNUC + PM * TZZ
            UMO    = ECHCK**2 - PXCHCK**2 - PYCHCK**2
     &             - PZCHCK**2
            IF ( UMO .LT. 0.D+00 ) THEN
               WRITE (LUNOUT,*)' *** Ferevv: Umo < 0 ',UMO
               WRITE (LUNERR,*)' *** Ferevv: Umo < 0 ',UMO
               LRESMP = .TRUE.
               NHAD = 0
               RETURN
            END IF
            UMO    = SQRT ( UMO )
         END IF
         EFRM  = EFRM  + EKFER - V0WELL (ITJ) - EKRECL
         TVEUZ = TVEUZ + V0WELL (ITJ) - EKFER + EKRECL
      END IF
      UMO2   = UMO * UMO
      EPROJX = HLFHLF * ( UMO2 - AMPROJ**2 - AMTAR**2 ) / AMTAR
      IF ( EPROJX .LE. AMPROJ ) THEN
         WRITE (LUNOUT,*)' Ferevv: Eprojx < Amproj after kin. sel. !',
     &                     EPROJX, AMPROJ, LSEACL
         WRITE (LUNERR,*)' Ferevv: Eprojx < Amproj after kin. sel. !',
     &                     EPROJX, AMPROJ, LSEACL
         PXFRM = PXFRM - PXNUC
         PYFRM = PYFRM - PYNUC
         PZFRM = PZFRM - PZNUC
         EFRM  = EFRM  - EKFER + V0WELL (ITJ) + EKRECL
         TVEUZ = TVEUZ - V0WELL (ITJ) + EKFER - EKRECL
         IF ( LSEACL ) GO TO 50
         LRESMP = .TRUE.
         NHAD   = 0
         RETURN
      END IF
      PPROJX = SQRT ( ( EPROJX - AMPROJ ) * ( EPROJX + AMPROJ ) )
      ETOTX  = EPROJX + AMTAR
      PTOSCA = PXCHCK * TXX + PYCHCK * TYY + PZCHCK * TZZ
      PXTART = PXCHCK - PTOSCA * TXX
      PYTART = PYCHCK - PTOSCA * TYY
      PZTART = PZCHCK - PTOSCA * TZZ
      PTRASQ = PXTART**2 + PYTART**2 + PZTART**2
      AMTRSQ = AMTAR**2  + PTRASQ
      UMOTR2 = UMO2 + PTRASQ
      UMOTR  = SQRT (UMOTR2)
      PPARSQ = ECHCK**2 - UMOTR2
      PPARTT = SQRT (PPARSQ)
      GAMCMS = ECHCK  / UMOTR
      ETACMS = PPARTT / UMOTR
      EPRCMS = HLFHLF * ( UMOTR2 + AMPROJ**2 - AMTRSQ ) / UMOTR
      PPRCMS = SQRT ( ( EPRCMS - AMPROJ ) * ( EPRCMS + AMPROJ ) )
      EPRLAB = GAMCMS * EPRCMS + ETACMS * PPRCMS
      ETRLAB = ECHCK  - EPRLAB
      PPRLAB = SQRT ( ( EPRLAB - AMPROJ ) * ( EPRLAB + AMPROJ ) )
      PXTARG = PXCHCK - PPRLAB * TXX
      PYTARG = PYCHCK - PPRLAB * TYY
      PZTARG = PZCHCK - PPRLAB * TZZ
      GAM    = ETRLAB / AMTAR
      BGX    = PXTARG / AMTAR
      BGY    = PYTARG / AMTAR
      BGZ    = PZTARG / AMTAR
      PPHELP = ( BGX * TXX + BGY * TYY + BGZ * TZZ ) * PPRLAB
      ETAPCM = EPRLAB - PPHELP / ( GAM + ONEONE )
      PXPROJ = PPRLAB * TXX - BGX * ETAPCM
      PYPROJ = PPRLAB * TYY - BGY * ETAPCM
      PZPROJ = PPRLAB * TZZ - BGZ * ETAPCM
      UUOLD  = PXPROJ / PPROJX
      VVOLD  = PYPROJ / PPROJX
      WWOLD  = PZPROJ / PPROJX
      SINT02 = UUOLD**2 + VVOLD**2
      IF ( SINT02 .LE. ANGLSQ ) THEN
         LSMPAN = .TRUE.
         SINTH0 = ZERZER
         COSPH0 = ONEONE
         SINPH0 = ZERZER
      ELSE
         LSMPAN = .FALSE.
         SINTH0 = SQRT (SINT02)
         COSPH0 = UUOLD / SINTH0
         SINPH0 = VVOLD / SINTH0
      END IF
      PLABS  = PPROJX
      ELABS  = EPROJX
      IF ( LSEACL .OR. .NOT. LDIFFR (KPTOIP(KP)) .OR. PLABS .LE. PTHDFF
     &    ) THEN
         FRUUN(1) = ONEONE
      ELSE
         IF ( RN1GSC .GE. ZERZER ) THEN
            CALL GRNDM(FRUUN,1)
            IF ( FRUUN(1) .LT. HLFHLF ) THEN
               FRUUN(1) = RN1GSC
            ELSE
               FRUUN(1) = RN2GSC
            END IF
         ELSE
            CALL GRNDM(FRUUN,1)
         END IF
      END IF

      IF ( UMO * UMO .LT. URMIN2 ) THEN
         IF ( URMIN2 - UMO2 .LT. 0.1D+00 * URMIN2 .AND. IIBAR (KP) .LT.
     &      0 ) GO TO 1550
         IF ( .NOT. LSEACL .AND. PLABS .GT. 2.D+00 ) GO TO 1550
         WRITE ( LUNOUT,* )' Ferevv: Umo2 < Urmin2 !!',UMO*UMO,URMIN2,
     &                       KP,KT,AMPROJ,AMTAR
         WRITE ( LUNERR,* )' Ferevv: Umo2 < Urmin2 !!',UMO*UMO,URMIN2,
     &                       KP,KT,AMPROJ,AMTAR
         NHAD = 2
         NREH(1) = KT
         PXH(1) = 0.D+00
         PYH(1) = 0.D+00
         PZH(1) = 0.D+00
         HEPH(1) = AMTAR
         AMH (1) = AMTAR
         IBARH (1) = IIBAR (KT)
         ICHH  (1) = IICH  (KT)
         ANH   (1) = ANAME (KT)
         IF ( LSEACL .OR. IVFLAG .EQ. 0 ) THEN
            NREH(2) = 23
         ELSE
            NREH(2) = KP
         END IF
         PXH(2) = 0.D+00
         PYH(2) = 0.D+00
         PZH(2) = PLABS
         HEPH(2) = ELABS
         AMH (2) = AMPROJ
         IBARH (2) = IIBAR (NREH(2))
         ICHH  (2) = IICH  (NREH(2))
         ANH   (2) = ANAME (NREH(2))
         GO TO 1122
      END IF
 1550 CONTINUE
      IF ( FRUUN(1) .LE. FRDIFF ) THEN
         CALL DIFEVV ( NHAD, KP, KT, PLABS, ELABS, UMO )
         LEVDIF = .TRUE.
      ELSE IF ( .NOT. LSEACL .AND. PLABS .LT. DBLE(IJNUCR(KPTOIP(KP)))
     &        * 0.8D+00 * PTHRSH (KPTOIP(KP)) ) THEN
         IF ( KP .EQ. 26 ) THEN
            KPP = 23
         ELSE
            KPP = KP
         END IF
         CALL HEVHIN ( NHAD, KPP, KT, PLABS, ELABS, UMO )
         LHADRI = .TRUE.
      ELSE
         IF ( .NOT. LSEACL ) THEN
            LEVDIF = .FALSE.
            LHADRI = .FALSE.
         END IF
         CALL HADEVV ( NHAD, KP, KT, PLABS, ELABS, UMO )
      END IF
1122  CONTINUE
      DO 2000 I=1,NHAD
         IF ( LSMPAN ) THEN
            PZH (I) = WWOLD * PZH (I)
         ELSE
            PLRX = PXH (I) * COSPH0 * WWOLD - PYH (I) * SINPH0
     &           + PZH (I) * UUOLD
            PLRY = PXH (I) * SINPH0 * WWOLD + PYH (I) * COSPH0
     &           + PZH (I) * VVOLD
            PLRZ = - PXH (I) * SINTH0 + PZH (I) * WWOLD
            PXH (I) = PLRX
            PYH (I) = PLRY
            PZH (I) = PLRZ
         END IF
         CALL ALTRA ( GAM, BGX, BGY, BGZ, PXH(I), PYH(I), PZH(I),
     &                HEPH(I), PLR, PLRX, PLRY, PLRZ, ELR )
         PXH(I) = PLRX
         PYH(I) = PLRY
         PZH(I) = PLRZ
         HEPH(I) = ELR
2000  CONTINUE

      B1BAMJ = B1SAVE
      B2BAMJ = B2SAVE
      RETURN
      END
+DECK,  FERHAV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

      SUBROUTINE FERHAV ( KP, EPROJ, PPROJ, TXX, TYY, TZZ )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
+CDE, BALANC.
+CDE, FINLSP.
+CDE, HADFLG.
+CDE, NUCDAT.
+CDE, QQUARK.
+CDE, PART3.
+CDE, RESNUC.
      COMMON /FKABLT/ AM(110), GAA(110), TAU(110), ICH(110), IBAR(110),
     &                K1(110), K2(110)
      COMMON / FKNUCF / DELEFT, EKRECL, V0EXTR, ITTA, ITJ, LVMASS
      LOGICAL LVMASS, LSMPAN
      COMMON / FKEVNT / LNUCRI, LHADRI
      LOGICAL LNUCRI, LHADRI
      REAL FRNDM(3)
      SAVE ONEDUM, ZERDUM
      DATA ONEDUM / 1.D+00 /
      DATA ZERDUM / 0.D+00 /
      AMPROJ = AM (KP)
      AMTAR  = AM (ITTA)
      ECHCK  = EPROJ + EFRM - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
      PXCHCK = PXFRM + PPROJ * TXX
      PYCHCK = PYFRM + PPROJ * TYY
      PZCHCK = PZFRM + PPROJ * TZZ
      UMIN2  = ( AMPROJ + AMTAR )**2
      P2CHCK = PXCHCK**2 + PYCHCK**2 + PZCHCK**2
      UMO2   = ECHCK**2  - P2CHCK
      IF ( ABS ( UMO2 - UMIN2 ) .GT. TWOTWO * ANGLGB * UMO2 ) THEN
         EPROJX = HLFHLF * ( UMO2 - AMPROJ**2 - AMTAR**2 ) / AMTAR
         IF ( EPROJX .LT. AMPROJ ) THEN
            WRITE (LUNERR,*)' Ferhav: trouble with pseudo-masses!!',
     &      EPROJX,AMPROJ,LVMASS
            EPROJX = AMPROJ
            PPROJX = ZERZER
            LRESMP = .TRUE.
            RETURN
         ELSE
            PPROJX = SQRT ( ( EPROJX - AMPROJ ) * ( EPROJX + AMPROJ ) )
         END IF
         ETOTX  = EPROJX + AMTAR
         AMTRMX = HLFHLF * ( UMO2 - AMPROJ**2 - AMTAR**2 ) / AMPROJ
         AMSQMX = AMTRMX**2
         PTOSCA = PXCHCK * TXX + PYCHCK * TYY + PZCHCK * TZZ
         PXTART = PXCHCK - PTOSCA * TXX
         PYTART = PYCHCK - PTOSCA * TYY
         PZTART = PZCHCK - PTOSCA * TZZ
         PTRASQ = PXTART**2 + PYTART**2 + PZTART**2
         AMTRSQ = AMTAR**2  + PTRASQ
         IF ( AMTRSQ .GT. AMSQMX ) THEN
            PPCHCK = SQRT (P2CHCK)
            PTOOLD = PTOSCA
            PTRASQ = ( AMTRMX - AMTAR ) * ( AMTRMX + AMTAR )
******            AMTRSQ = AMTRMX + PTRASQ
******            PTOSCA = SIGN (ONEONE,PTOOLD) * SQRT ( P2CHCK - PTRASQ )
            AMTRSQ = AMSQMX
            PTOSCA = SQRT ( P2CHCK - PTRASQ )
            ALPTUU = ( PTOSCA * SQRT ( ( PPCHCK - PTOOLD ) * ( PPCHCK
     &             + PTOOLD ) / ( PPCHCK - PTOSCA ) / ( PPCHCK + PTOSCA
     &             ) ) - PTOOLD ) / PPCHCK
            FNORM  = SQRT ( ONEONE + ALPTUU**2 + TWOTWO * ALPTUU
     &             * PTOOLD / PPCHCK )
            ALPTUU = ALPTUU / PPCHCK
            TXXX   = ( TXX + ALPTUU * PXCHCK ) / FNORM
            TYYY   = ( TYY + ALPTUU * PYCHCK ) / FNORM
            TZZZ   = ( TZZ + ALPTUU * PZCHCK ) / FNORM
            UMOTR2 = UMO2 + PTRASQ
            UMOTR  = SQRT (UMOTR2)
            AMTRAN = AMTRMX
            PPARSQ = PTOSCA**2
            PPARTT = PTOSCA
            GAMCMS = ECHCK  / UMOTR
            ETACMS = PPARTT / UMOTR
            EPRCMS = AMPROJ
            PPRCMS = ZERZER
         ELSE
            TXXX = TXX
            TYYY = TYY
            TZZZ = TZZ
            PTOOLD = PTOSCA
            UMOTR2 = UMO2 + PTRASQ
            UMOTR  = SQRT (UMOTR2)
            PPARTT = PTOSCA
            GAMCMS = ECHCK  / UMOTR
            ETACMS = PPARTT / UMOTR
            EPRCMS = HLFHLF * ( UMOTR2 + AMPROJ**2 - AMTRSQ ) / UMOTR
            PPRCMS = SQRT ( ( EPRCMS - AMPROJ ) * ( EPRCMS + AMPROJ ) )
         END IF
         EPRLAB = GAMCMS * EPRCMS + ETACMS * PPRCMS
         ETRLAB = ECHCK  - EPRLAB
         PPRLAB = SQRT ( ( EPRLAB - AMPROJ ) * ( EPRLAB + AMPROJ ) )
         PXTARG = PXCHCK - PPRLAB * TXXX
         PYTARG = PYCHCK - PPRLAB * TYYY
         PZTARG = PZCHCK - PPRLAB * TZZZ
         GAM    = ETRLAB / AMTAR
         BGX    = PXTARG / AMTAR
         BGY    = PYTARG / AMTAR
         BGZ    = PZTARG / AMTAR
         PPHELP = ( BGX * TXXX + BGY * TYYY + BGZ * TZZZ ) * PPRLAB
         ETAPCM = EPRLAB - PPHELP / ( GAM + ONEONE )
         PXPROJ = PPRLAB * TXXX - BGX * ETAPCM
         PYPROJ = PPRLAB * TYYY - BGY * ETAPCM
         PZPROJ = PPRLAB * TZZZ - BGZ * ETAPCM
         UUOLD  = PXPROJ / PPROJX
         VVOLD  = PYPROJ / PPROJX
         WWOLD  = PZPROJ / PPROJX
         SINT02 = UUOLD**2 + VVOLD**2
         IF ( SINT02 .LE. ANGLSQ ) THEN
            LSMPAN = .TRUE.
            SINTH0 = ZERZER
            COSPH0 = ONEONE
            SINPH0 = ZERZER
         ELSE
            LSMPAN = .FALSE.
            SINTH0 = SQRT (SINT02)
            COSPH0 = UUOLD / SINTH0
            SINPH0 = VVOLD / SINTH0
         END IF
      ELSE
         UMO2   = UMIN2
         EPROJX = AMPROJ
         PPROJX = ZERZER
         ETOTX  = AMPROJ + AMTAR
         LSMPAN = .FALSE.
         CALL POLI   ( COSTH0, SINTH0 )
         CALL SFECFE ( SINPH0, COSPH0 )
         UUOLD  = SINTH0 * COSPH0
         VVOLD  = SINTH0 * SINPH0
         WWOLD  = COSTH0
         AAFACT = ECHCK  + ETOTX
         BBFACT = PPROJX - PZCHCK
         DDENOM = ETOTX * AAFACT - PPROJX * BBFACT
         GAM = ( ECHCK * AAFACT + PPROJX * BBFACT ) / DDENOM
         BGZ = - BBFACT * AAFACT / DDENOM
         BGX = PXCHCK * ( GAM + ONEONE ) / AAFACT
         BGY = PYCHCK * ( GAM + ONEONE ) / AAFACT
      END IF
      PLABS  = PPROJX
      ELABS  = EPROJX
      IF ( PLABS .LT. 1.D-04 ) THEN
         WRITE (LUNERR,*)' Ferhav: kp,plabs,elabs,pprox,y,z,pfrmix,y,z'
     &   ,KP,PLABS,ELABS,PPROJ*TXX,PPROJ*TYY,PPROJ*TZZ,PXFRM,PYFRM,
     &    PZFRM
         WRITE (LUNERR,*)'   Lvmass,Am(kp),Eproj:',LVMASS,AM(KP),EPROJ
      ELSE IF ( PLABS .GT. 1.D+01 ) THEN
         WRITE (LUNERR,*)' Ferhav: kp,plabs,elabs,pprox,y,z,pfrmix,y,z'
     &   ,KP,PLABS,ELABS,PPROJ*TXX,PPROJ*TYY,PPROJ*TZZ,PXFRM,PYFRM,
     &    PZFRM
         WRITE (LUNERR,*)'   Lvmass,Am(kp),Eproj:',LVMASS,AM(KP),EPROJ
      END IF
      ISSU = 0
      DO 100 IQ = 1,3
         ISSU = ISSU + MQUARK (IQ,KP) / 3
  100 CONTINUE
      IF ( LVMASS ) THEN
         LHADRI = .TRUE.
         CALL HADRIN ( KP, PLABS, ELABS, ZERDUM, ZERDUM, ONEDUM, ITTA )
         IOLDHD = 0
      ELSE IF ( PLABS .GT. 7.D+00 ) THEN
         LHADRI = .FALSE.
         CALL HINHEV ( KP, PLABS, ELABS, ITTA )
      ELSE
         LHADRI = .TRUE.
         CALL HADRIV ( KP, PLABS, ELABS, ZERDUM, ZERDUM, ONEDUM, ITTA )
      END IF
      DO 2000 I=1,IR
         ECMS  = ELR (I)
         PCMSX = PLR (I) * CXR (I)
         PCMSY = PLR (I) * CYR (I)
         PCMSZ = PLR (I) * CZR (I)
         IF ( LSMPAN ) THEN
            PCMSX = PLR (I) * CXR (I)
            PCMSY = PLR (I) * CYR (I)
            PCMSZ = WWOLD * PLR (I) * CZR (I)
         ELSE
            PLRX = CXR (I) * COSPH0 * WWOLD - CYR (I) * SINPH0
     &           + CZR (I) * UUOLD
            PLRY = CXR (I) * SINPH0 * WWOLD + CYR (I) * COSPH0
     &           + CZR (I) * VVOLD
            PLRZ = - CXR (I) * SINTH0 + CZR (I) * WWOLD
            PCMSX = PLRX * PLR (I)
            PCMSY = PLRY * PLR (I)
            PCMSZ = PLRZ * PLR (I)
         END IF
         CALL ALTRA ( GAM, BGX, BGY, BGZ, PCMSX, PCMSY, PCMSZ,
     &                ECMS, PLR (I), PLRX, PLRY, PLRZ, ELR (I) )
         CXR (I) = PLRX / PLR (I)
         CYR (I) = PLRY / PLR (I)
         CZR (I) = PLRZ / PLR (I)
         DO 200 IQ = 1,3
            ISSU = ISSU - MQUARK (IQ,KPTOIP(ITR(I))) / 3
  200    CONTINUE
2000  CONTINUE
      IF ( ISSU .NE. 0 ) THEN
         WRITE (LUNOUT,*)' *** Strangeness non conservation in Hadriv',
     &                     ISSU,KP,ITTA,' ***'
         WRITE (LUNERR,*)' *** Strangeness non conservation in Hadriv',
     &                     ISSU,KP,ITTA,' ***'
         LRESMP = .TRUE.
      END IF
      V0WELL (ITJ) = V0WELL (ITJ) - V0EXTR
      RETURN
      ENTRY FERSET
      FERM = PFRMMX (ITJ)
      CALL GRNDM(FRNDM,3)
      P2 = MAX ( FRNDM (1), FRNDM (2), FRNDM (3) )
      IF ( IBTAR .LE. 1 ) THEN
         FERM = ZERZER
      END IF
      P2=FERM*P2
      P2SQ   = P2 * P2
      IATEMP = IBTAR - 1
      ATEMP  = DBLE ( IBTAR ) - ONEONE
      IF ( ITJ .EQ. 1 ) THEN
         IZTEMP = ICHTAR - 1
      ELSE
         IZTEMP = ICHTAR
      END IF
      ZTEMP =  DBLE ( IZTEMP )
      DELCTR = ( DBLE (ICHTAR) - ZTEMP ) * AMELEC
      DELEFT = AMMTAR - AMNTAR - DELCTR
      AMMRES = AMUAMU * ATEMP + 1.D-03 * FKENER ( ATEMP, ZTEMP )
      AMNRES = AMMRES - ZTEMP * AMELEC + ELBNDE ( IZTEMP )
      AMTMSQ = AMMRES * AMMRES
      EKRECL = SQRT ( AMTMSQ + P2SQ ) - AMMRES
      CALL POLI ( POLC, POLS )
      CALL COSI ( SFE,  CFE )
      PXFRM = CFE * POLS * P2
      PYFRM = SFE * POLS * P2
      PZFRM = POLC * P2
      EFRM  = SQRT ( AMNUSQ (ITJ) + P2SQ )
      EKFER  = EFRM  - AMNUCL (ITJ)
      TVEUZ  = V0WELL (ITJ) - EFRM + EBNDNG (ITJ) + AMMTAR - AMMRES
     &       - DELCTR
      IF ( TVEUZ .LT. ZERZER ) THEN
         V0EXTR = - TVEUZ + TENTEN * TVEPSI
         TVEUZ  = TVEUZ  + V0EXTR
         V0WELL (ITJ) = V0WELL (ITJ) + V0EXTR
      ELSE
         V0EXTR = ZERZER
      END IF
      RETURN
      END
+DECK,  FISFRA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

*$ CREATE FISFRA.FOR
*COPY FISFRA
*=== fisfra ===========================================================*
      SUBROUTINE FISFRA ( JA, JZ, U, EREC, UMO, GAMCM, ETACM )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  FISsion FRAgments emission:                                         *
*                                                                      *
*                                                                      *
*      Subroutine to pick post fission parameters for nucleus          *
*      JZ,JA excited to U and recoiling with Erec.                     *
*                                                                      *
*  Created  on  08 april 1993  by  A.Ferrari & P.Sala, INFN - Milan    *
*                                                                      *
*  Last change  on  14-apr-93  by  Alfredo Ferrari, INFN - Milan       *
*                                                                      *
*  This routine is just the FLUKA equivalent of the routines FISSED and*
*  FISDIS of LAHET, taken thanks to R.E.Prael                          *
*                                                                      *
*  Input variables:                                                    *
*     JA = Mass number of the fissioning nucleus                       *
*     JZ = Atomic number of the fissioning nucleus                     *
*     U  = Excitation energy (MeV) of the fissioning nucleus           *
*     Erec = Recoil kinetic energy (MeV) of the residual nucleus       *
*            The recoil direction is given by Coslf0 (i)               *
*     Umo  = invariant mass of the fissioning system (mass+excitation) *
*     Gamcm= CMS Lorentz boost "gamma"                                 *
*     Etacm= CMS Lorentz boost "eta"                                   *
*                                                                      *
*----------------------------------------------------------------------*
*
      STOP 'FISFRA'
*      RETURN
*=== Fisfra ===========================================================*
      END
+DECK,  FKDECA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== decay ============================================================*
      SUBROUTINE FKDECA(IHAD,ISTAB)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Decay89: slight revision by A. Ferrari                              *
*----------------------------------------------------------------------*
*
+CDE, FINPAR2.
+CDE, METLSP.
+CDE, PART.
+CDE, DECAYC.
      COMMON /FKDREI/ TEST(12)
      COMMON /FKGAMR/REDU,AMO,AMM(15)
      COMMON /FKPRUN/ISYS
      REAL RNDM(1)
C
C
      REDU=2.D0
      DO 801 I=1,IHAD
         ITS(I) = NREF(I)
         PLS(I) = SQRT(PXF(I)**2 + PYF(I)**2 + PZF(I)**2)
         IF (PLS(I) .NE. 0.D0) THEN
            CXS(I) = PXF(I)/PLS(I)
            CYS(I) = PYF(I)/PLS(I)
            CZS(I) = PZF(I)/PLS(I)
         END IF
         ELS(I) = HEF(I)
  801 CONTINUE
      IST = IHAD
      IR  = 0
  200 CONTINUE
C*****TEST STABLE OR UNSTABLE
C$$$$$ISTAB=1/2/3 MEANS  STRONG + WEAK DECAYS / ONLY STRONG DECAYS /
C*****STRONG DECAYS + WEAK DECAYS FOR CHARMED PARTICLES AND TAU LEPTONS
      IF(ISTAB.EQ.1) GOTO 793
      IF(ISTAB.EQ.2) GOTO 737
      IF(ISTAB.EQ.3) GOTO 738
  793 IF(ITS(IST).EQ.135.OR.ITS(IST).EQ.136) GOTO 202
      IF(ITS(IST).GE.1.AND.ITS(IST).LE.7) GOTO 202
      GOTO 300
  738 IF(ITS(IST).GE.1.AND.ITS(IST).LE.30) GOTO 202
      IF(ITS(IST).GE. 97.AND.ITS(IST).LE.103) GOTO 202
      IF(ITS(IST).EQ.109.OR.ITS(IST).EQ.115) GOTO 202
      IF(ITS(IST).GE.133.AND.ITS(IST).LE.136) GOTO 202
      GOTO 300
  737 IF(ITS(IST).GE.  1.AND.ITS(IST).LE. 30) GOTO 202
      IF(ITS(IST).GE. 97.AND.ITS(IST).LE.103) GOTO 202
      IF(ITS(IST).GE.115.AND.ITS(IST).LE.122) GOTO 202
      IF(ITS(IST).GE.131.AND.ITS(IST).LE.136) GOTO 202
      IF(ITS(IST).EQ.109) GO TO 202
      IF(ITS(IST).GE.137.AND.ITS(IST).LE.160) GOTO 202
      GO TO 300
  202 IR = IR + 1
      NREF(IR) = ITS(IST)
      ITT = ITS(IST)
      AMF(IR) = AM(ITT)
      ANF(IR) = ANAME(ITT)
      ICHF(IR)  = ICH(ITT)
      IBARF(IR) = IBAR(ITT)
      HEF(IR) = ELS(IST)
      PXF(IR) = CXS(IST)*PLS(IST)
      PYF(IR) = CYS(IST)*PLS(IST)
      PZF(IR) = CZS(IST)*PLS(IST)
      IST = IST - 1
      IF(IST .GE. 1) GO TO 200
      GO TO 500
  300 IT = ITS(IST)
      GAM = ELS(IST)/AM(IT)
      BGAM = PLS(IST)/AM(IT)
      ECO = AM(IT)
      KZ1 = K1(IT)
  310 CONTINUE
      CALL GRNDM(RNDM,1)
      VV = RNDM(1) - 1.D-17
      IIK = KZ1 - 1
  301 IIK = IIK + 1
      IF (VV.GT.WT(IIK)) GO TO 301
C  IIK IS THE DECAY CHANNEL
      IT1 = NZK(IIK,1)
      IT2 = NZK(IIK,2)
      IF (IT2-1 .LT. 0) GO TO 110
      IT3 = NZK(IIK,3)
C  IT1,IT2, IT3 ARE THE PRODUCED PARTICLES FROM  IT
      IF(IT3 .EQ. 0) GO TO 400
      CALL THREPD(ECO,ECM1,ECM2,ECM3,PCM1,PCM2,PCM3,COD1,COF1,SIF1,COD2,
     &            COF2,SIF2,COD3,COF3,SIF3,AM(IT1),AM(IT2),AM(IT3))
      GO TO 411
  400 CALL TWOPAD(ECO,ECM1,ECM2,PCM1,PCM2,COD1,COF1,SIF1,COD2,COF2,SIF2,
     &            AM(IT1),AM(IT2))
  411 CONTINUE
  110 CONTINUE
      ITS(IST) = IT1
      IF (IT2-1 .LT. 0) GO TO 305
      ITS(IST+1) = IT2
      ITS(IST+2) = IT3
      RX = CXS(IST)
      RY = CYS(IST)
      RZ = CZS(IST)
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD1,COF1,SIF1,PCM1,ECM1,
     &           PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IST = IST + 1
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD2,COF2,SIF2,PCM2,ECM2,
     &           PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IF (IT3 .LE. 0) GO TO 305
      IST = IST + 1
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD3,COF3,SIF3,PCM3,ECM3,
     &           PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
  305 CONTINUE
      GO TO 200
  500 CONTINUE
      IDAPU = IDMAX3
      IF(IR .GT. IDMAX3) WRITE(ISYS,928)IDAPU
  928 FORMAT(' NUMBER OF STAB. FINAL PART. IS GREATER THAN',I5)
      IHAD = IR
      RETURN
      END
+DECK,  FKDRES, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:05  cernlib
* Geant

*=== dres =============================================================*
*                                                                      *
      SUBROUTINE FKDRES ( M2, M3, T1, U, EREC, LOPPAR, JFISS )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  New version of DRES created  by A.Ferrari & P.Sala, INFN - Milan    *
*                                                                      *
*  Last change  on  10-apr-93  by  Alfredo Ferrari, INFN - Milan       *
*                                                                      *
*  Dres93: Dres91 plus the RAL fission model taken from LAHET thanks   *
*          to R.E.Prael                                                *
*  Dres91: new version from A. Ferrari and P. Sala, INFN - Milan       *
*          This routine has been adapted from the original one of the  *
*          Evap-5 module (KFA - Julich). Main modifications concern    *
*          with kinematics which is now fully relativistic and with    *
*          the treatment of few nucleons nuclei, which are now frag-   *
*          mented, even though in a very rough manner. Changes have    *
*          been made also to other routines of the Evap-5 package      *
*                                                                      *
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*                                                                      *
*  Input variables:                                                    *
*     M2 = Mass number of the residual nucleus                         *
*     M3 = Atomic number of the residual nucleus                       *
*     T1 = Excitation energy of the residual nucleus before evaporation*
*     U  = Excitation energy of the residual nucleus after evaporation *
*     Erec = Recoil kinetic energy of the residual nucleus             *
*            The recoil direction is given by Coslbr (i)               *
*                                                                      *
*  Significant variables:                                              *
*     JA = Present mass number of the residual nucleus                 *
*     JZ = Present atomic number of the residual nucleus               *
*     Smom1 = Energy accumulators for the six types of evaporated      *
*             particles                                                *
*                                                                      *
*    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     *
*    !!!! Please note that the following variables concerning !!!!     *
*    !!!! with the present residual nucleus must be set before!!!!     *
*    !!!! entering DRES91: Ammres, Ptres                      !!!!     *
*    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     *
*                                                                      *
*----------------------------------------------------------------------*
*
C---------------------------------------------------------------------
C SUBNAME = DRES --- EVAPORATION
C           EVAPORATION DATA SHOUD BE READ ON INPUT STAGE
C---------------------------------------------------------------------
C*****A LA EVAP III(TWA,8-68)
+CDE, EVA0.
+CDE, EVA1.
+CDE, FORCN.
+CDE, HIGFIS.
+CDE, INPFLG.
+CDE, LABCOS.
+CDE, NUCDAT.
+CDE, RESNUC.
      DIMENSION ZMASS (6), Z2MASS(6), C(3), Q(0:6), FLKCOU(6), CCOUL(6),
     &          THRESH(6), SMALLA(6), R(6), S  (6), SOS   (6), STRUN(6),
     &          EYE1  (6), EYE0  (6), SMOM1    (6), BNMASS(6)
      DIMENSION CORRRR(6)
      REAL RNDM(2)
      LOGICAL LOPPAR, PENBAR, LFIRST
      PARAMETER (EXPMIN=-88,EXPMAX=88)
      SAVE ZMASS, Z2MASS, EMHN, EMNUM, UM, AMUMEV, AMEMEV, QBRBE8,
     &     BNMASS, IEVEVP, NBE8, NRNEEP, LFIRST
      DATA IEVEVP / 0 /
      DATA LFIRST / .TRUE. /
*
      IEVEVP = IEVEVP + 1
C-------------------------------------- 1.ST CALL INIT
      IF ( LFIRST ) THEN
         LFIRST = .FALSE.
         FKEY   = ZERZER
         NBE8   = 0
         NRNEEP = 0
         EXMASS(1) = 1.D+03 * ( AMNEUT - AMUAMU )
         EXMASS(2) = FKENER ( ONEONE, ONEONE )
         EXMASS(3) = FKENER ( TWOTWO, ONEONE )
         EXMASS(4) = FKENER ( THRTHR, ONEONE )
         EXMASS(5) = FKENER ( THRTHR, TWOTWO )
         EXMASS(6) = FKENER ( FOUFOU, TWOTWO )
         ZMASS(1) = 1.D+03 * AMUAMU + EXMASS (1)
         ZMASS(2) = 1.D+03 * AMUAMU + EXMASS (2)
         ZMASS(3) = 2.D+03 * AMUAMU + EXMASS (3)
         ZMASS(4) = 3.D+03 * AMUAMU + EXMASS (4)
         ZMASS(5) = 3.D+03 * AMUAMU + EXMASS (5)
         ZMASS(6) = 4.D+03 * AMUAMU + EXMASS (6)
         BNMASS (1) = 0.D+00
         BNMASS (2) = 0.D+00
         BNMASS (3) = ZMASS (1) + ZMASS (2) - ZMASS (3)
         BNMASS (4) = TWOTWO * ZMASS (1) + ZMASS (2) - ZMASS (4)
         BNMASS (5) = ZMASS (1) + TWOTWO * ZMASS (2) - ZMASS (5)
         BNMASS (6) = TWOTWO * ( ZMASS (1) + ZMASS (2) ) - ZMASS (6)
         DO 1234 KK = 1,6
            Z2MASS (KK) = ZMASS (KK) * ZMASS (KK)
1234     CONTINUE
         AMUMEV = 1.D+03 * AMUAMU
         AMEMEV = 1.D+03 * AMELEC
         QBRBE8 = FKENER ( EIGEIG, FOUFOU ) - TWOTWO * EXMASS (6)
         EMN = 1.D+03 * AMNEUT
         EMH = ZMASS (2)
         TMP16 = 16.D+00
         UM  = AMUMEV + FKENER ( TMP16, EIGEIG ) / 16.D+00
         EMHN  = EMH - EMN
         EMNUM = EMN - UM
      END IF
*  |  End of initialization:
*  +-------------------------------------------------------------------*
C     --------------------------------- START OF PROCESS
*  +-------------------------------------------------------------------*
*  |  Initialize Npart and Smom if nothing has been already evaporated
*  |  for this event
      IF ( JFISS .LE. 0 ) THEN
         DO 775 I=1,6
            NPART(I) = 0
            SMOM1(I) = ZERZER
  775    CONTINUE
      END IF
*  |
*  +-------------------------------------------------------------------*
      JA = M2
      JZ = M3
      U  = T1
      RNMASS = 1.D+03 * AMMRES + U
* P2res and  Ptres are the squared momentum and the momentum of the
* residual nucleus (now in relativistic kinematics), Umo the
* invariant mass of the system!
      UMO  = RNMASS
      UMO2 = UMO * UMO
      ELBTOT  = RNMASS + EREC
      GAMCM   = ELBTOT / RNMASS
      ETACM   = 1.D+03 * PTRES / RNMASS
      HEVSUM  = ZERZER
 1000 CONTINUE
      LOPPAR = .FALSE.
*  +-------------------------------------------------------------------*
*  |                Check for starting data inconsistencies
      IF (JA-JZ .LT. 0) THEN
         WRITE(LUNOUT,6401)
         WRITE(LUNERR,6401)
 6401    FORMAT('1 Dres: cascade residual nucleus has mass no. less',
     &       ' than Z!!')
         RETURN
*  |
*  +-------------------------------------------------------------------*
*  |                Rough treatment for very few nucleon residual
*  |                nuclei. The basic ideas are:
*  |        a) as many as possible alpha particles are emitted
*  |        b) particles are emitted one per time leaving a residual
*  |           excitation energy proportional to number of nucleons
*  |           left in the residual nucleus (so we deal only with
*  |           two body kinematics)
*  |       T A K E   I N T O   A C C O U N T   T H A T   T H I S
*  |       T R E A T M E N T   I S   E X T R E M E L Y   R O U G H
*  |       T H E   T A S K   B E I N G   O N L Y   T O   S U P P L Y
*  |       S O M E T H I N G   T O   S H A R E   E N E R G Y   A N D
*  |       M O M E N T U M   A M O N G   A   F E W   F R A G M E N T S
      ELSE IF ( JA .LE. 6 .OR. JZ .LE. 2 ) THEN
*  | 1000 continue moved above according to FCA suggestion
*1000    CONTINUE
         JRESID = 0
         IF ( JA .GT. 4 ) GO TO 2000
*  |  +----------------------------------------------------------------*
*  |  | First check we are not concerning with a couple of neutrons or
*  |  | protons
         IF ( JA .EQ. 2 .AND. JZ .NE. 1 ) THEN
            JEMISS = 1 + JZ / 2
            JRESID = JEMISS
            RNMASS = ZMASS (JRESID)
            U = 0.D+00
            DELTU = UMO - 2.D+00 * ZMASS (JEMISS)
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( DELTU .LE. 0.D+00 ) THEN
               IF ( DELTU .LT. - 2.D+00 * ANGLGB * UMO ) THEN
                  WRITE ( LUNERR, * )' *** Dres: insufficient Umo for',
     &                               ' a nucleon couple', UMO,
     &                                 2.D+00 * ZMASS (JEMISS)
               END IF
               UMO = ( UMO + DELTU ) * ( 1.D+00 + ANGLGB )
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            GO TO 2500
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  | Then check we are not concerning with one of the six
*  |  | standard particles
         DO 1700 J = 6, 1, -1
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( JZ .EQ. IZ (J) .AND. JA .EQ. IA (J) ) THEN
               HEVSUM = SMOM1(3) + SMOM1(5) + SMOM1(6) + SMOM1(4)
               GO TO ( 1100, 1100, 1600, 1500, 1400, 1300 ), J
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Proton or neutron, nothing can be done
 1100          CONTINUE
                  RETURN
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Alpha:
 1300          CONTINUE
                  DEUDEU = MAX ( ZERZER, U + TWOTWO * BNMASS (3)
     &                           - BNMASS (6) )
                  PROTRI = MAX ( ZERZER, U + BNMASS (4) - BNMASS (6) )
                  UEU3HE = MAX ( ZERZER, U + BNMASS (5) - BNMASS (6) )
                  QNORM  = DEUDEU + PROTRI + UEU3HE
*  |  |  |  |  If we cannot split then return
                  IF ( QNORM .LE. ZERZER ) RETURN
                  CALL GRNDM(RNDM,1)
                  V = RNDM (1)
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split or into two deuterons or a triton and a proton
*  |  |  |  |  | or a 3-He and a neutron: no account is made for
*  |  |  |  |  | Coulomb effects, probability is simply assumed
*  |  |  |  |  | proportional to reaction Qs
                  IF ( V .LT. DEUDEU / QNORM ) THEN
*  |  |  |  |  | Two deuterons selected
                     JEMISS = 3
                     JRESID = 3
                     RNMASS = ZMASS (3)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into a triton and a proton
                  ELSE IF ( V .LT. ( DEUDEU + PROTRI ) / QNORM ) THEN
                     JEMISS = 2
                     JRESID = 4
                     RNMASS = ZMASS (4)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into a 3-He and a neutron
                  ELSE
                     JEMISS = 1
                     JRESID = 5
                     RNMASS = ZMASS (5)
                     U = ZERZER
                     GO TO 2500
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  3-He:
 1400          CONTINUE
                  DEUPRO = MAX ( ZERZER, U + BNMASS (3) - BNMASS (5) )
                  PRPRNE = MAX ( ZERZER, U - BNMASS (5) )
                  QNORM  = DEUPRO + PRPRNE
*  |  |  |  |  If we cannot split then return
                  IF ( QNORM .LE. ZERZER ) RETURN
                  CALL GRNDM(RNDM,1)
                  V = RNDM (1)
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split or into a deuteron and a proton
*  |  |  |  |  | or into two protons and one neutron: no account is
*  |  |  |  |  | made for Coulomb effects, probability is simply assumed
*  |  |  |  |  | prportional to reaction Qs
                  IF ( V .LT. DEUPRO / QNORM ) THEN
*  |  |  |  |  | A deuteron and a proton selected
                     JEMISS = 2
                     JRESID = 3
                     RNMASS = ZMASS (3)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into 2 protons and 1 neutron: part of the exci-
*  |  |  |  |  | tation energy is conserved to allow the further
*  |  |  |  |  | splitting of the deuteron
                  ELSE
                     JEMISS = 2
                     JRESID = 0
                     FACT = ONEONE
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  | Loop to compute the residual excitation energy
 1450                CONTINUE
                        FACT = FACT * 0.6666666666666667D+00
*  |  |  |  |  |  | Erncm, Eepcm are the total energies of the residual
*  |  |  |  |  |  | nucleus and of the emitted particle in the CMS frame
                        U      = FACT * PRPRNE + BNMASS (3)
                        RNMASS = ZMASS (3) + U
                        ERNCM  = HLFHLF * ( UMO2 + RNMASS**2
     &                         - Z2MASS (JEMISS) ) / UMO
                        EEPCM  = UMO - ERNCM
                     IF ( EEPCM .LE. ZMASS (JEMISS) ) GO TO 1450
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
                     GO TO 2600
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Triton:
 1500          CONTINUE
                  DEUNEU = MAX ( ZERZER, U + BNMASS (3) - BNMASS (4) )
                  PRNENE = MAX ( ZERZER, U - BNMASS (4) )
                  QNORM  = DEUNEU + PRNENE
*  |  |  |  |  If we cannot split then return
                  IF ( QNORM .LE. ZERZER ) RETURN
                  CALL GRNDM(RNDM,1)
                  V = RNDM (1)
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split or into a deuteron and a neutron
*  |  |  |  |  | or into two protons and one neutron: no account is
*  |  |  |  |  | made for Coulomb effects, probability is simply assumed
*  |  |  |  |  | proportional to reaction Qs
                  IF ( V .LT. DEUNEU / QNORM ) THEN
*  |  |  |  |  | A deuteron and a proton selected
                     JEMISS = 1
                     JRESID = 3
                     RNMASS = ZMASS (3)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into 1 proton and 2 neutrons: part of the exci-
*  |  |  |  |  | tation energy is conserved to allow the further
*  |  |  |  |  | splitting of the deuteron
                  ELSE
                     JEMISS = 1
                     JRESID = 0
                     FACT = ONEONE
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  | Loop to compute the residual excitation energy
 1550                CONTINUE
                        FACT = FACT * 0.6666666666666667D+00
*  |  |  |  |  |  | Erncm, Eepcm are the total energies of the residual
*  |  |  |  |  |  | nucleus and of the emitted particle in the CMS frame
                        U      = FACT * PRNENE + BNMASS (3)
                        RNMASS = ZMASS (3) + U
                        ERNCM  = HLFHLF * ( UMO2 + RNMASS**2
     &                         - Z2MASS (JEMISS) ) / UMO
                        EEPCM  = UMO - ERNCM
                     IF ( EEPCM .LE. ZMASS (JEMISS) ) GO TO 1550
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
                     GO TO 2600
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Deuteron:
 1600          CONTINUE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Split into a proton and a neutron if it is possible
                  IF ( U .GT. BNMASS (3) ) THEN
                     JEMISS = 1
                     JRESID = 2
                     RNMASS = ZMASS (2)
                     U = ZERZER
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Energy too low to split the deuteron, return
                  ELSE
                     WRITE (LUNERR,*)' **Dres: energy too low to split',
     &                               ' a deuteron! M2,M3',M2,M3
                     RETURN
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 1700    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
 2000    CONTINUE
         A = JA
         Z = JZ
         Q (0)  = ZERZER
         ENERG0 = FKENER (A,Z)
*  |  +----------------------------------------------------------------*
*  |  |   Note that Q(i) are not the reaction Qs but the remaining
*  |  |   energy after the reaction
         DO 2100 K = 1, 6
            JJA = JA - IA (K)
            JJZ = JZ - IZ (K)
            JJN = JJA - JJZ
            IF ( JJN .LT. 0 .OR. JJZ .LT. 0 ) THEN
               Q (K) = Q (K-1)
               GO TO 2100
            END IF
            DDJJA = JJA
            DDJJZ = JJZ
            Q (K) = MAX ( U + ENERG0 - FKENER ( DDJJA, DDJJZ )
     &            - EXMASS (K), ZERZER ) + Q (K-1)
 2100    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |  If no emission channel is open then return
         IF ( Q (6) .LE. ZERZER ) THEN
            HEVSUM = SMOM1(3) + SMOM1(5) + SMOM1(6) + SMOM1(4)
            RETURN
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         CALL GRNDM(RNDM,1)
         V = RNDM (1)
         FACT = ONEONE
*  |  +----------------------------------------------------------------*
*  |  |
         DO 2200 J = 1, 6
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( V .LT. Q (J) / Q (6) ) THEN
               JEMISS = J
               JJA    = JA - IA (JEMISS)
               JJZ    = JZ - IZ (JEMISS)
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               DO 2150 JJ = 1, 6
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( JJA .EQ. IA (JJ) .AND. JJZ .EQ. IZ (JJ) ) THEN
                     JRESID = JJ
                     RNMASS = ZMASS (JRESID)
                     ERNCM  = HLFHLF * ( UMO2 + Z2MASS (JRESID)
     &                      - Z2MASS (JEMISS) ) / UMO
                     EEPCM  = UMO - ERNCM
                     U = ZERZER
                     GO TO 2600
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
 2150          CONTINUE
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               AJJA   = JJA
               ZJJZ   = JJZ
               RNMAS0 = AJJA * AMUMEV + FKENER ( AJJA, ZJJZ )
               GO TO 2300
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 2200    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         WRITE ( LUNOUT,* )' **** error in Dres, few nucleon treatment',
     &                     ' ****'
         WRITE ( LUNERR,* )' **** error in Dres, few nucleon treatment',
     &                     ' ****'
         RETURN
*  |  +----------------------------------------------------------------*
*  |  | Loop to compute the residual excitation energy
 2300    CONTINUE
            FACT = FACT * AJJA / A
            U = FACT * ( Q (JEMISS) - Q (JEMISS-1) )
*  |  | Erncm, Eepcm are the total energies of the residual
*  |  | nucleus and of the emitted particle in the CMS frame
            RNMASS = RNMAS0 + U
            ERNCM  = HLFHLF * ( UMO2 + RNMASS**2
     &             - Z2MASS (JEMISS) ) / UMO
            EEPCM  = UMO - ERNCM
         IF ( EEPCM .LE. ZMASS (JEMISS) ) THEN
            IF ( Q (JEMISS) - Q (JEMISS-1) .GE. 1.D-06 ) GO TO 2300
*  |  +--<--<--<--<--<--< Loop back
*  |  |  Actually there is no excitation energy available!
            U = ANGLGB
            RNMASS = ONEPLS * RNMAS0
            ERNCM  = ONEPLS * RNMASS
            EEPCM  = ONEPLS * ZMASS (JEMISS)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         GO TO 2600
*  |  From here standard two bodies kinematics with Jemiss, Rnmass
*  |  (new excitation energy is U)
 2500    CONTINUE
*  |  Erncm, Eepcm are the total energies of the residual
*  |  nucleus and of the emitted particle in the CMS frame
         ERNCM = HLFHLF * ( UMO2 + RNMASS**2 - Z2MASS (JEMISS) ) / UMO
         EEPCM = UMO - ERNCM
 2600    CONTINUE
*  |  C(i) are the direction cosines of the emitted particle
*  |  (Jemiss) in the CMS frame, of course - C(i)
*  |  are the ones of the residual nucleus (Jresid if one of the
*  |  standard partcles, say the proton)
         CALL RACO (C(1),C(2),C(3))
         PCMS  = SQRT ( EEPCM**2 - Z2MASS (JEMISS) )
*  |  Now we perform the Lorentz transformation back to the original
*  |  frame (lab frame)
*  |  First the emitted particle:
         ETAX = ETACM * COSLBR (1)
         ETAY = ETACM * COSLBR (2)
         ETAZ = ETACM * COSLBR (3)
         PCMSX = PCMS * C (1)
         PCMSY = PCMS * C (2)
         PCMSZ = PCMS * C (3)
         ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
         EPS = GAMCM * EEPCM + ETAPCM - ZMASS (JEMISS)
         PHELP = ETAPCM / ( GAMCM + ONEONE ) + EEPCM
         PLBPX = PCMSX + ETAX * PHELP
         PLBPY = PCMSY + ETAY * PHELP
         PLBPZ = PCMSZ + ETAZ * PHELP
         PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
         COSLBP (1) = PLBPX / PHELP
         COSLBP (2) = PLBPY / PHELP
         COSLBP (3) = PLBPZ / PHELP
*  |  Then the residual nucleus ( for it c (i) --> - c (i) ):
         EREC  = GAMCM * ERNCM - ETAPCM - RNMASS
         EKRES = 1.D-03 * EREC
         PHELP = - ETAPCM / ( GAMCM + ONEONE ) + ERNCM
         PXRES = 1.D-03 * ( - PCMSX + ETAX * PHELP )
         PYRES = 1.D-03 * ( - PCMSY + ETAY * PHELP )
         PZRES = 1.D-03 * ( - PCMSZ + ETAZ * PHELP )
         P2RES = PXRES * PXRES + PYRES * PYRES + PZRES * PZRES
         PTRES = SQRT (P2RES)
         COSLBR (1) = PXRES / PTRES
         COSLBR (2) = PYRES / PTRES
         COSLBR (3) = PZRES / PTRES
*  |  Score the emitted particle
         NPART (JEMISS) = NPART (JEMISS) + 1
         SMOM1 (JEMISS) = SMOM1 (JEMISS) + EPS
         ITEMP=NPART(JEMISS)
         EPART(ITEMP,JEMISS)=EPS
         COSEVP(1,ITEMP,JEMISS)=COSLBP(1)
         COSEVP(2,ITEMP,JEMISS)=COSLBP(2)
         COSEVP(3,ITEMP,JEMISS)=COSLBP(3)
*  |  +----------------------------------------------------------------*
*  |  |  Check if the residual nucleus is one of the emitted particles
         IF ( JRESID .GT. 0 ) THEN
            J = JRESID
            GO TO 6102
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         JA = JA - IA (JEMISS)
         JZ = JZ - IZ (JEMISS)
* Umo is the invariant mass of the system!!
         UMO  = RNMASS
         UMO2 = UMO * UMO
         ELBTOT  = RNMASS + EREC
         GAMCM   = ELBTOT / RNMASS
         ETACM   = 1.D+03 * PTRES / RNMASS
         GO TO 1000
      END IF
*  |
*  +-------------------------------------------------------------------*
* Come to 23 at the beginning and after the end of a "normal"
* evaporation cycle
   23 CONTINUE
      A = JA
      Z = JZ
      IF(JA-8)8486,8488,8486
 8488 CONTINUE
      IF(JZ-4)8486,1224,8486
 8486 CONTINUE
      DO 2 K=1,6
         IF((A-FLA(K)).LE.(Z-FLZ(K))) THEN
            Q(K)=99999.D0
            GO TO 2
         END IF
         IF(A-TWOTWO*FLA(K))2,727,727
  727    CONTINUE
         IF(Z-TWOTWO*FLZ(K))2,728,728
  728    CONTINUE
         Q(K) = QNRG(A-FLA(K),Z-FLZ(K),A,Z) + EXMASS(K)
C 728    Q(K)=FKENER(A-FLA(K),Z-FLZ(K))-FKENER(A,Z)+EXMASS(K)
    2 CONTINUE
      FLKCOU(1)=ZERZER
      FLKCOU(2)=DOST(1,Z-FLZ(2))
      FLKCOU(3)=FLKCOU(2)+.06D+00
      FLKCOU(4)=FLKCOU(2)+.12D+00
      FLKCOU(6)=DOST(2,Z-FLZ(6))
      FLKCOU(5)=FLKCOU(6)-.06D+00
      CCOUL(1)=ONEONE
      CCOU2=DOST(3,Z-FLZ(2))
      CCOUL(2)=CCOU2+ONEONE
      CCOUL(3)=CCOU2*1.5D0+THRTHR
      CCOUL(4)=CCOU2+THRTHR
      CCOUL(6)=DOST(4,Z-FLZ(6))*TWOTWO+TWOTWO
      CCOUL(5)=TWOTWO*CCOUL(6)-ONEONE
      SIGMA=ZERZER
*  Initialize the flag which checks for open particle decay with
*  zero excitation and pairing --> for particle unstable residual
*  nuclei
      LOPPAR = .FALSE.
      DO 33 J=1,6
         IF(A-TWOTWO*FLA(J))5,725,725
  725    CONTINUE
         IF(Z-TWOTWO*FLZ(J))5,726,726
  726    CONTINUE
         MM=JA-IA(J)
         ZZ=Z-FLZ(J)
         AA=A-FLA(J)
         IF(AA.LE.ZZ)GO TO 5
*  Energy threshold for the emission of the jth-particle
         THRESH(J)=Q(J)+.88235D+00*FLKCOU(J)*FLZ(J)*
     &   ZZ/(RMASS(MM)+RHO(J))
         LOPPAR = LOPPAR .OR. THRESH (J) .GT. ZERZER
         IAA = NINT(AA)
         IZZ = NINT(ZZ)
         NN  = IAA - IZZ
*  The residual nucleus excitation energy ranges from 0 up
*  to U - Q (J)
         ILVMOD = IB0
         UMXRES = U - THRESH (J)
*  This is the a lower case of the level density
         SMALLA (J) = GETA ( UMXRES, IZZ, NN, ILVMOD, ISDUM, ASMMAX,
     &                       ASMMIN )
         CALL EEXLVL (IAA,IZZ,EEX1ST,EEX2ND,CORR)
         EEX1ST = 1.D+03 * EEX1ST
         EEX2ND = 1.D+03 * EEX2ND
         CORR   = 1.D+03 * MAX ( CORR, ZERZER )
         IF ( NN .EQ. 4 .AND. IZZ .EQ. 4 ) THEN
            IF ( U - THRESH (J) - 6.1D+00 .GT. ZERZER ) THEN
               CORR = SIXSIX
            ELSE
               TMPVAR = U-THRESH(J)-0.1D+00
               CORR = MAX ( ZERZER, TMPVAR )
            END IF
         END IF
         IF (NINT(FKEY).EQ.1) CORR=ZERZER
         CORRRR(J)=CORR
* Standard calculation:
         ARG=U-THRESH(J)-CORR
         IF(ARG)5,4,4
    5    CONTINUE
         R(J)=ZERZER
         S(J)=ZERZER
         SOS(J)=ZERZER
         GO TO 33
    4    CONTINUE
         S(J)=SQRT (SMALLA(J)*ARG)*TWOTWO
         SOS(J)=TENTEN*S(J)
   33 CONTINUE
      N1=1
      SES = MAX (S(1),S(2),S(3),S(4),S(5),S(6))
      DO 1131 J=1,6
         JS  = SOS(J) + ONEONE
         FJS = JS
         STRUN(J) = FJS - ONEONE
         IF ( S(J) .GT. ZERZER ) THEN
            MM  = JA-IA(J)
            EXPSAS=MIN(EXPMAX,MAX(EXPMIN,S(J)-SES))
            SAS = EXP (EXPSAS)
            EXPSUS=MIN(EXPMAX,MAX(EXPMIN,-S(J)))
            SUS = EXP (EXPSUS)
            EYE1(J) = ( TWOTWO * S(J)**2 -SIXSIX * S(J)
     &              + SIXSIX + SUS * ( S(J)**2 - SIXSIX ) )
     &              / ( EIGEIG * SMALLA(J)**2 )
            IF ( J .EQ. 1 ) THEN
               EYE0(J) = ( S(J) - ONEONE + SUS ) / ( TWOTWO*SMALLA(J) )
* Standard calculation
               R   (J) = RMASS(MM)**2 * ALPH(MM) * ( EYE1(J) + BET(MM)
     &                 * EYE0(J) ) * SAS
            ELSE
               R   (J) = CCOUL(J) * RMASS(MM)**2 * EYE1(J) * SAS
            END IF
            R (J) = MAX ( ZERZER, R (J) )
            SIGMA = SIGMA + R (J)
         END IF
 1131 CONTINUE
      NCOUNT = 0
 6202 CONTINUE
      IF(SIGMA)9,9,10
 9    CONTINUE
      DO 6100 J = 1,6
         IF(JA-IA(J))6100,6101,6100
 6101    CONTINUE
         IF(JZ-IZ(J))6100,6102,6100
 6100 CONTINUE
      GO TO 6099
 6102 CONTINUE
      IF ( U .GT. ANGLGB ) GO TO 1000
      JEMISS = J
C*****STORE,RESIDUAL NUC IS OF EMITTED PARTICLE TYPE
* If we are here this means that the residual nucleus is equal to
* one of the six emitted particle (the j-th one). So give to it
* all the energy, score it and return with 0 recoil and excitation
* energy for the residual nucleus
      EPS = EREC
      NPART(JEMISS) = NPART(JEMISS)+1
      ITEMP=NPART(JEMISS)
      NRNEEP = NRNEEP + 1
      SMOM1(JEMISS) = SMOM1(JEMISS) + EPS
      ITEMP=NPART(JEMISS)
      EPART(ITEMP,JEMISS)=EPS
      COSEVP(1,ITEMP,JEMISS) = COSLBR(1)
      COSEVP(2,ITEMP,JEMISS) = COSLBR(2)
      COSEVP(3,ITEMP,JEMISS) = COSLBR(3)
      GO TO 8002
*
*-->-->-->-->--> go to return
 6099 CONTINUE
      IF(JA-8)72,51,72
   51 CONTINUE
      IF(JZ-4)72,1224,72
* Come here for a "normal" step
   10 CONTINUE
      LOPPAR = .FALSE.
      CALL GRNDM(RNDM,1)
      URAN=RNDM(1)*SIGMA
      SUM = ZERZER
      DO 16 J=1,6
         K   = J
         SUM = R(J)+SUM
         IF ( SUM - URAN .GT. 0.D+00 ) GO TO 17
   16 CONTINUE
   17 CONTINUE
      JEMISS=K
      NPART(JEMISS) = NPART (JEMISS) + 1
      JS = SOS (JEMISS) + ONEONE
      IF(JS-1000)4344,4345,4345
 4345 CONTINUE
      RATIO2=(S(JEMISS)**3-6.D0*S(JEMISS)**2+15.D0*
     &S(JEMISS)-15.D0)/((2.D0*S(JEMISS)**2-6.D0*S(JEMISS)+6.D0)*SMALLA
     &(JEMISS))
      GO TO 4347
 4344 CONTINUE
      RATIO2=(P2(JS)+(P2(JS+1)-P2(JS))*
     &(SOS(JEMISS)-STRUN(JEMISS)))/SMALLA(JEMISS)
 4347 CONTINUE
      EPSAV=RATIO2*TWOTWO
*  +-------------------------------------------------------------------*
*  |  Neutron channel selected:
      IF (JEMISS .EQ. 1) THEN
         MM=JA-IA(J)
         EPSAV=(EPSAV+BET(MM))/(ONEONE+BET(MM)*EYE0(JEMISS)
     &        /EYE1(JEMISS))
*  |  +----------------------------------------------------------------*
*  |  |  Compute the fission width relative to the neutron one:
*  |  |  this part is taken from subroutine EMIT of LAHET
         IF ( IFISS .GT. 0 .AND. JZ .GE. 71 .AND. .NOT. FISINH ) THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Compute the correction factor for the fission width:
            IF ( JZ .GT. 88 ) THEN
               AGOES = ONEONE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               AGOES = MAX ( ONEONE, ( U-SEVSEV ) / ( EPSAV+SEVSEV ) )
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  Finally this is the relative fission width:
*  |  |  This is : Probfs = 1 / ( 1 + G_n / G_f )
            PROBFS = FPROB ( Z, A, U ) / AGOES
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if it will be fission:
            CALL GRNDM(RNDM,1)
            IF ( RNDM (1) .LT. PROBFS ) THEN
               FISINH = .TRUE.
               KFISS  = 1
*  |  |  |  Undo the counting of the neutron evaporation
               NPART (JEMISS) = NPART (JEMISS) -1
               GO TO 9260
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
  20  CONTINUE
      CALL GRNDM(RNDM,2)
      E1=-HLFHLF*LOG(RNDM(1))
      E2=-HLFHLF*LOG(RNDM(2))
* Eps should be the total kinetic energy in the CMS frame
* Standard calculation:
      EPS=(E1+E2)*EPSAV+THRESH(JEMISS)-Q(JEMISS)
      AR = A - IA(JEMISS)
      ZR = Z - IZ(JEMISS)
* The CMS energy is updated
      IMASS = NINT (AR)
      IF ( IMASS .EQ. 8 .AND. NINT (ZR) .EQ. 4 ) THEN
         UNEW = U - EPS - Q(JEMISS)
         UMAX = U - THRESH(JEMISS)
         IF ( UNEW .GT. 6.D+00 ) THEN
            UMIN = 6.D+00
         ELSE IF ( UNEW .GT. 4.47D+00 .AND. UMAX .GT. 6.D+00 ) THEN
            UMIN = 4.47D+00
            UNEW = 6.D+00
         ELSE IF ( UNEW .GT. 1.47D+00 .AND. UMAX .GT. 2.94D+00 ) THEN
            UMIN = 1.47D+00
            UNEW = 2.94D+00
         ELSE
            UMIN = -0.1D+00
            UNEW = ANGLGB * 0.1D+00
         END IF
      ELSE IF ( IMASS .LE. 4 ) THEN
         IPRO = NINT ( ZR )
         INEU = IMASS - IPRO
         IF ( IMASS .EQ. 1 ) THEN
*  Be sure that residual neutrons or protons are not left excited
            UMIN = 0.D+00
            UNEW = 0.D+00
            EPS  = U - Q(JEMISS)
         ELSE IF ( IPRO .EQ. 0 .OR. INEU .EQ. 0 ) THEN
*  Ipro protons or ineu neutrons arrived here!
            UMIN = CORRRR(JEMISS)
            UNEW = U - EPS - Q(JEMISS)
         ELSE IF ( IMASS .LE. 2 ) THEN
*  Be sure that residual deuterons are not left excited!
            UMIN = 0.D+00
            UNEW = 0.D+00
            EPS  = U - Q(JEMISS)
         ELSE IF ( ABS ( INEU - IPRO ) .LE. 1 ) THEN
*  For the moment also residual 3-H, 3-He and 4-He are not left
*  excited !
            UMIN = 0.D+00
            UNEW = 0.D+00
            EPS  = U - Q(JEMISS)
         ELSE
            UMIN = CORRRR(JEMISS)
            UNEW = U - EPS - Q(JEMISS)
         END IF
      ELSE
         UMIN = CORRRR(JEMISS)
         UNEW = U - EPS - Q(JEMISS)
      END IF
* Standard calculation
      IF(UNEW-UMIN)6200,6220,6220
 6220 CONTINUE
*or   RNMASS = AR * AMUMEV + FKENER (AR,ZR)
      RNMASS = AR * AMUMEV + FKENER (AR,ZR) + UNEW
      UMIN2  = ( RNMASS + ZMASS (JEMISS) )**2
      IF ( UMIN2 .GE. UMO2 ) THEN
         GO TO 6200
      END IF
      U = UNEW
* C(i) are the direction cosines of the evaporated particle in the CMS
* frame, of course - C(i) are the ones of the residual nucleus
      CALL RACO(C(1),C(2),C(3))
* Erncm, Eepcm are the total energies of the residual nucleus and
* of the evaporated particle in the CMS frame
      ERNCM = 0.5D+00 * ( UMO2 + RNMASS**2 - Z2MASS (JEMISS) ) / UMO
      EEPCM = UMO - ERNCM
      PCMS  = SQRT ( EEPCM**2 - Z2MASS (JEMISS) )
* Now we perform the Lorentz transformation back to the original
* frame (lab frame)
* First the evaporated particle:
      ETAX = ETACM * COSLBR (1)
      ETAY = ETACM * COSLBR (2)
      ETAZ = ETACM * COSLBR (3)
      PCMSX = PCMS * C (1)
      PCMSY = PCMS * C (2)
      PCMSZ = PCMS * C (3)
      ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
      EPS = GAMCM * EEPCM + ETAPCM - ZMASS (JEMISS)
      PHELP = ETAPCM / (GAMCM + 1.D0) + EEPCM
      PLBPX = PCMSX + ETAX * PHELP
      PLBPY = PCMSY + ETAY * PHELP
      PLBPZ = PCMSZ + ETAZ * PHELP
      PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
      COSLBP (1) = PLBPX / PHELP
      COSLBP (2) = PLBPY / PHELP
      COSLBP (3) = PLBPZ / PHELP
* Then the residual nucleus ( for it c (i) --> - c (i) ):
      EREC  = GAMCM * ERNCM - ETAPCM - RNMASS
      EKRES = 1.D-03 * EREC
      PHELP = - ETAPCM / (GAMCM + 1.D0) + ERNCM
      PXRES = 1.D-03 * ( - PCMSX + ETAX * PHELP )
      PYRES = 1.D-03 * ( - PCMSY + ETAY * PHELP )
      PZRES = 1.D-03 * ( - PCMSZ + ETAZ * PHELP )
      P2RES = PXRES * PXRES + PYRES * PYRES + PZRES * PZRES
      PTRES = SQRT (P2RES)
      COSLBR (1) = PXRES / PTRES
      COSLBR (2) = PYRES / PTRES
      COSLBR (3) = PZRES / PTRES
* Check energy and momentum conservation !!
      IF (EREC .LE. 0.D+00) THEN
         PTRES = 0.D+00
         EREC  = 0.D+00
      END IF
* Umo is the invariant mass of the system!!
      UMO  = RNMASS
      UMO2 = UMO * UMO
      ELBTOT  = RNMASS + EREC
      GAMCM   = ELBTOT / RNMASS
      ETACM   = 1.D+03 * PTRES / RNMASS
      GO TO 76
 6200 CONTINUE
      NCOUNT = NCOUNT + 1
      IF ( NCOUNT .LE. 10 ) GO TO 20
      SIGMA = SIGMA - R(JEMISS)
* if we are here we have sampled for > 10 times a negative energy Unew
      NPART(JEMISS)=NPART(JEMISS)-1
      R(JEMISS) = 0.D0
      NCOUNT = 0
      GO TO 6202
   76 CONTINUE
      JAT=JA-IA(JEMISS)
      JZT=JZ-IZ(JEMISS)
      IF(JAT-JZT)9,9,77
   77 CONTINUE
      JA=JAT
      JZ=JZT
C*****STORE,END OF NORMAL CYCLE
      SMOM1(JEMISS)=SMOM1(JEMISS)+EPS
      ITEMP=NPART(JEMISS)
      EPART(ITEMP,JEMISS)=EPS
      COSEVP(1,ITEMP,JEMISS)=COSLBP(1)
      COSEVP(2,ITEMP,JEMISS)=COSLBP(2)
      COSEVP(3,ITEMP,JEMISS)=COSLBP(3)
* The following card switch to the rough splitting treatment
      IF (JA .LE. 2) GO TO 1000
      IF(JA-8)23,1223,23
 1223 CONTINUE
      IF(JZ-4)23,1224,23
* If we are here the residual nucleus is a 8-Be one, break it into
* two alphas with all the available energy (U plus the Q of the breakup)
* , score them and return with 0 recoil and excitation energy
 1224 CONTINUE
      LOPPAR = .FALSE.
      IF(U)1228,1229,1229
 1228 CONTINUE
      EPS=0.D0
      GO TO 1230
 1229 CONTINUE
 1230 CONTINUE
      NBE8=NBE8+1
* C(i) are the direction cosines of the first alpha in the CMS
* frame, of course - C(i) are the ones of the other
      CALL RACO(C(1),C(2),C(3))
* Ecms is the total energy of the alphas in the CMS frame
      ECMS  = 0.5D+00 * UMO
      PCMS  = SQRT ( ECMS**2 - Z2MASS (6) )
* Now we perform the Lorentz transformation back to the original
* frame (lab frame)
* First alpha:
      ETAX = ETACM * COSLBR (1)
      ETAY = ETACM * COSLBR (2)
      ETAZ = ETACM * COSLBR (3)
      PCMSX = PCMS * C (1)
      PCMSY = PCMS * C (2)
      PCMSZ = PCMS * C (3)
      ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
      EPS = GAMCM * ECMS + ETAPCM - ZMASS (6)
      PHELP = ETAPCM / (GAMCM + 1.D0) + ECMS
      PLBPX = PCMSX + ETAX * PHELP
      PLBPY = PCMSY + ETAY * PHELP
      PLBPZ = PCMSZ + ETAZ * PHELP
      PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
* Store the first alpha!!
      SMOM1(6) = SMOM1(6) + EPS
      NPART(6) = NPART(6) + 1
      ITEMP = NPART(6)
      EPART (ITEMP,6) = EPS
      COSEVP (1,ITEMP,6) = PLBPX / PHELP
      COSEVP (2,ITEMP,6) = PLBPY / PHELP
      COSEVP (3,ITEMP,6) = PLBPZ / PHELP
* Then the second alpha ( for it c (i) --> - c (i) ):
      EPS = GAMCM * ECMS - ETAPCM - ZMASS (6)
      PHELP = - ETAPCM / (GAMCM + 1.D0) + ECMS
      PLBPX = - PCMSX + ETAX * PHELP
      PLBPY = - PCMSY + ETAY * PHELP
      PLBPZ = - PCMSZ + ETAZ * PHELP
      PHELP = SQRT (PLBPX * PLBPX + PLBPY * PLBPY + PLBPZ * PLBPZ)
* Store the second alpha !!
      SMOM1(6) = SMOM1(6) + EPS
      NPART(6) = NPART(6) + 1
      ITEMP = NPART(6)
      EPART (ITEMP,6) = EPS
      COSEVP (1,ITEMP,6) = PLBPX / PHELP
      COSEVP (2,ITEMP,6) = PLBPY / PHELP
      COSEVP (3,ITEMP,6) = PLBPZ / PHELP
 8002 CONTINUE
      LOPPAR = .FALSE.
      EREC   = ZERZER
      U      = ZERZER
      EKRES  = ZERZER
      PTRES  = ZERZER
   72 CONTINUE
      HEVSUM=SMOM1(3)+SMOM1(5)+SMOM1(6)+SMOM1(4)
      RETURN
*.......................................................................
*///// RAL FISSION ROUTINE /////
 9260 CONTINUE
*  +-------------------------------------------------------------------*
*  |  Record the direction cosines of the fissioning nucleus
      DO 9270 I=1,3
         COSLF0 (I) = COSLBR (I)
 9270 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      CALL FISFRA ( JA, JZ, U, EREC, UMO, GAMCM, ETACM )
*  +-------------------------------------------------------------------*
*  |  Check for fission failures!!
      IF ( .NOT. FISINH ) THEN
         PENBAR = .FALSE.
         GO TO 23
      END IF
*  |
*  +-------------------------------------------------------------------*
*  Do not pick up the fission fragments, rather go back to Evevap
      HEVSUM=SMOM1(3)+SMOM1(5)+SMOM1(6)+SMOM1(4)
      RETURN
      END
+DECK,  FKENER, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== energy ===========================================================*
*                                                                      *
      FUNCTION FKENER(A,Z)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C--------------------------------------------------------------------
C SUBNAME = ENERGY
C--------------------------------------------------------------------
+CDE, EVA0.
C--------------------------------------------------------------------
      KA0 = NINT ( A )
      KZ0 = NINT ( Z )
      N   = KA0 - KZ0
      IF ( N .LE. 0 ) THEN
         IF ( KA0 .NE. 1 ) THEN
            IF ( N .LT. 0 ) THEN
               WRITE ( LUNOUT, * )
     &         ' Stopped in energy: mass number =< atomic number !!',
     &           KA0, KZ0
            END IF
         ELSE
            FKENER = WAPS ( 1, 3 )
            RETURN
         END IF
      END IF
      IZZ = NINT ( WAPS ( KA0, 1 ) )
      IF ( KZ0 .LT. IZZ .OR. KZ0 .GT. IZZ + 9 ) THEN
         FKENER = ENRG ( A, Z )
         RETURN
      ELSE
         IZ0 = KZ0 - IZZ + 2
         FKENER = WAPS ( KA0, IZ0 )
         IF ( FKENER .EQ. 0.D+00 .AND. (KA0 .NE. 12 .OR. KZ0 .NE. 6) )
     &        FKENER = ENRG ( A, Z )
         RETURN
      END IF
*     RETURN
      END
+DECK,  FKERUP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== erup =============================================================*
*                                                                      *
      SUBROUTINE FKERUP (JFISS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created  on   15 may 1990     by     Alfredo & Paola Sala        *
*                                              INFN - Milan            *
*     Last change  on   10-apr-93   by     Alfredo Ferrari, INFN-Milan *
*                                                                      *
*     Derived from the ERUP routine of EVAP-V, HERMES, KFA-Julich      *
*                                                                      *
*----------------------------------------------------------------------*
*
C*****MODIFIED TO OBTAIN APR,ZPR AFTER CAS + EVAP (8-68,T.W.A.)
+CDE, EVA1.
+CDE, FORCN.
+CDE, INPFLG.
+CDE, HETC5.
+CDE, HETC7.
+CDE, HETTP.
+CDE, HIGFIS.
*     COMMON / AZ /    LOWAZ
      LOGICAL LOPPAR
      DIMENSION  FPART (6)
C     -------------------------------------- CHECK PARAMETER
      FISINH=.FALSE.
*  +-------------------------------------------------------------------*
*  |  Check the excitation energy
      IF ( EX .LE. ZERZER ) THEN
*  |  No excitation energy:
         IF ( JFISS .LE. 0 ) THEN
            DO 201 I=1,6
               NPART(I)=0
  201       CONTINUE
            HEVSUM = ZERZER
         END IF
*        UU = ZERZER
         UU = EX
         RETURN
*  |
*  +-------------------------------------------------------------------*
*  |  Positive excitation energy:
      ELSE
*  |  Try evaporation
         M2 = NINT (APR)
         M3 = NINT (ZPR)
 8801    CONTINUE
         CALL FKDRES (M2,M3,EX,UU,EREC,LOPPAR,JFISS)
         FPARTT = ZERZER
*  |  +----------------------------------------------------------------*
*  |  |  No previous evaporation for this event
         IF ( JFISS .LE. 0 ) THEN
            DO 801 I=1,6
               FPART(I) = NPART(I)
               FPARTT   = FPARTT + FPART (I)
  801       CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |  Other evaporation trials already performed for this event
         ELSE
            DO 802 I=1,6
               FPART(I) = NPART(I)-NPARTF(I,JFISS-1)
               FPARTT   = FPARTT + FPART (I)
  802       CONTINUE
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |  No particle evaporated and pairing corrections accounted for
         IF ( FPARTT + FKEY .LT. ANGLGB ) THEN
            IF ( .NOT. LOPPAR ) GO TO 8802
            FKEY = ONEONE
            GO TO 8801
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 8802    CONTINUE
         FKEY = ZERZER
         ZPR  = ZPR - FPART(2) - FPART(3) - TWOTWO * ( FPART(5)
     &        + FPART(6)) - FPART(4)
         APR  = APR - FPART(1) - FPART(2) - TWOTWO * FPART(3)
     &        - THRTHR * ( FPART(4) + FPART(5) ) - FOUFOU * FPART(6)
         IF (IANG .GT. 0) THEN
         ELSE
            DO 440 K=1,6
               NP = NPART(K)
               IF ( JFISS .GT. 0 ) THEN
                  NP0 = NPARTF(K,JFISS-1) + 1
               ELSE
                  NP0 = 1
               END IF
               DO 410 J=NP0,NP
                  CALL RACO(COSEVP(1,J,K),COSEVP(2,J,K),COSEVP(3,J,K))
  410          CONTINUE
  440       CONTINUE
         END IF
      END IF
*  |
*  +-------------------------------------------------------------------*
      RETURN
*=== End of subroutine Erup ===========================================*
      END
+DECK,  FKFLAV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== flavor ===========================================================*
      SUBROUTINE FKFLAV(IT,LT,LL,E0,IV,RE,KFR1,KFR2,ISU,BETE,KFA1,KFA2,
     &                  KFA3,KFA4,IOPT)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     New version from A. Ferrari ( 22 august 1990 ): it is almost the *
*     the same as before, but with a few corrections important for isu *
*     2 and 3 and also for isu=4 if it switchs to 100 continue         *
*                                                                      *
*----------------------------------------------------------------------*
+CDE, PART.
*
*   The following are the masses of the quarks: the d quark mass is
*   assumed to be the same as the u one. They are quite different from
*   the last values from the particle data group, but any change
*   can imply a change also in the BET parameter in common INPDAT
      PARAMETER ( UQUARM = 0.3D+00 )
      PARAMETER ( SQUARM = 0.5D+00 )
      PARAMETER ( CQUARM = 2.1D+00 )
      PARAMETER ( BQUARM = 5.0D+00 )
*
      DIMENSION RE(*),KFR1(*),KFR2(*),IV(*)
      REAL RNDM(2)
*
C     CHOICE OF THE QUARK FLAVOUR
      IF (LT.EQ.1)WRITE(LUNOUT,288)IT,LT,LL,E0,ISU,BETE,KFA1,KFA2
  288 FORMAT(3I5,E12.4,I5,E12.4,2I5
     *,' FLAVOR IT,LT,LL,E0,ISU,BETE,KFA1,KFA2')
      I=IT
      J=IT-1
      IVA=1
      IVX=IV(I)
      IF (I .LE. 1) THEN
         IF (IOPT.EQ.2) THEN
            KX1 = KFA1
            KX2 = KFA2
         ELSE IF (IOPT.EQ.3.AND.LL.EQ.1) THEN
            KX1=KFA2
            KX2=0
         ELSE IF (IOPT.EQ.4 .AND. KFA1.LE.6 .AND. LL.EQ.1) THEN
            KX1=KFA2
            KX2=KFA3
         ELSE IF (IOPT.EQ.4 .AND. KFA1.GT.6 .AND. LL.EQ.0) THEN
            KX1=KFA2
            KX2=KFA3
         ELSE IF (IOPT.EQ.5 .AND. LL.EQ.0) THEN
            KX1=KFA3
            KX2=KFA4
         ELSE IF (IOPT.EQ.5 .AND. LL.EQ.1) THEN
            KX1=KFA1
            KX2=KFA2
         ELSE
            KX1=KFA1
            KX2=0
         END IF
         RX = E0
      ELSE
         KX1=KFR1(J)
         KX2=KFR2(J)
         RX =RE(J)
      END IF
      IF (KX1.GT.0.AND.KX2.GT.0) THEN
         BET=10.D+00
      ELSE
         BET=BETE
      END IF
      CALL GRNDM(RNDM,2)
      Z1=RNDM(1)
      Z2=RNDM(2)
      IF(ISU.EQ.4) GO TO 300
      IF(ISU.EQ.3) GO TO 200
      IF(ISU.EQ.2) GO TO 100
C     U FLAVOUR
         KF1=1
         KF2=1
      GO TO 20
C     U/D FLAVOURS
  100 CONTINUE
         IF (KX1.EQ.1.OR.KX1.EQ.7) THEN
            IIAA=1
         ELSE IF (KX1.EQ.2.OR.KX1.EQ.8) THEN
            IIAA=2
         ELSE
            IIAA=0
         END IF
  110 CONTINUE
         IF (IIAA .EQ. 1) THEN
            PD=0.6666666666666667D+00
            PU=0.3333333333333333D+00
         ELSE IF (IIAA .EQ. 2) THEN
            PU=0.6666666666666667D+00
            PD=0.3333333333333333D+00
         ELSE
            PU=0.5D+00
            PD=0.5D+00
         END IF
         PS=0.D+00
         PC=0.D+00
         IF (Z1 .LE. PD) THEN
            KF1=2
         ELSE
            KF1=1
         END IF
         IF (Z2 .LE. PD) THEN
            KF2=2
         ELSE
            KF2=1
         END IF
      GO TO 20
C     U/D/S FLAVOURS
  200 CONTINUE
         IF (KX1.EQ.1.OR.KX1.EQ.7) THEN
            IIAA=1
         ELSE IF (KX1.EQ.2.OR.KX1.EQ.8) THEN
            IIAA=2
         ELSE
            IIAA=0
         END IF
  210 CONTINUE
         IF (RX .LE. 1.019D+00 ) GO TO 110
         X1=RX
         X2=UQUARM
         PU=BETA(X1,X2,BET)
         X2=SQUARM
         PS=BETA(X1,X2,BET)
         PTOT=2.D+00*PU+PS
         PU1=PU/PTOT
         PS =PS/PTOT
         PC=0.D+00
         IF (IIAA .EQ. 1) THEN
            PU=0.6666666666666667D+00*PU1
            PD=2.D+00*PU1-PU
         ELSE IF (IIAA .EQ. 2) THEN
            PD=0.6666666666666667D+00*PU1
            PU=2.D+00*PU1-PD
         ELSE
            PU=PU1
            PD=PU
         END IF
         IF (Z1 .LE. PU) THEN
            KF1 = 1
         ELSE IF ( Z1 .LE. PU + PD ) THEN
            KF1 = 2
         ELSE
            KF1 = 3
         END IF
         IF (Z2 .LE. PU) THEN
            KF2 = 1
         ELSE IF ( Z2 .LE. PU + PD ) THEN
            KF2 = 2
         ELSE
            KF2 = 3
         END IF
      GO TO 20
C     U/D/S/C FLAVOUR
  300 CONTINUE
         GO TO (11,12,13,14,14,11,12,13,14,14),IVX
   11    CONTINUE
            IF (KX1.EQ.4.OR.KX1.EQ.10) THEN
               GM=AM(129)
            ELSE
               GM=AM(127)
            END IF
            IF (KX1.EQ.1.OR.KX1.EQ.7) THEN
               IIAA=1
            ELSE IF (KX1.EQ.2.OR.KX1.EQ.8) THEN
               IIAA=2
            ELSE
               IIAA=0
            END IF
         GO TO 15
   12    CONTINUE
            IF (KX1.EQ.4.OR.KX1.EQ.10) THEN
               GM=AM(170)
            ELSE
               GM=AM(127)
            END IF
            IIAA=0
         GO TO 15
   13    CONTINUE
*  |  |  +-------------------------------------------------------------*
*  |  |  | The following if replaces the cards:
*  |  |  |      GM=3.85D0
*  |  |  |      IF(KX1.EQ.4.AND.KX2.EQ.4) GM=4.89D0
*  |  |  |      IF(KX1.NE.4.AND.KX2.NE.4) GM=2.770D0
*  |  |  |      IF(KX1.EQ.10.AND.KX2.EQ.10) GM=4.89D0
*  |  |  |      IF(KX1.NE.10.AND.KX2.NE.10) GM=2.770D0
*  |  |  | It is completely equivalent except for the combination
*  |  |  | 4-4 which now gives GM = 4.89, while in the original
*  |  |  | coding gave GM = 2.77, because of the last condition
*  |  |  | always overrides the first one (it seems to be a mistake)
            IF (KX1 .EQ. 4 .OR. KX1 .EQ. 10 ) THEN
               IF ( KX2 .EQ. KX1 ) THEN
                  GM = AM(170)
               ELSE
                  GM = AM(169)
               END IF
            ELSE IF (KX2 .EQ. 4 .OR. KX2 .EQ. 10 ) THEN
               GM = AM(169)
            ELSE
               GM = AM(166)
            END IF
            IIAA=0
         GO TO 15
   14    CONTINUE
*  |  |  +-------------------------------------------------------------*
*  |  |  | The following if replaces the cards:
*  |  |  |      GM=3.684D0
*  |  |  |      IF(KX1.NE.4.AND.KX2.NE.4) GM=2.140D0
*  |  |  |      IF(KX1.NE.10.AND.KX2.NE.10) GM=2.140D0
*  |  |  | It is equivalent: only for the combinations
*  |  |  | 4-10 and 10-4 we get GM = 3.684
*  |  |  | It is not clear if it is correct since 4-x,x-4 (x.ne.10),
*  |  |  | 10-x,x-10 (x.ne.4) give GM = 2.14
            IF ((KX1.EQ.4.AND.KX2.EQ.10).OR.(KX1.EQ.10.AND.KX2.EQ.4))
     &         THEN
               GM = AM(129)
            ELSE
               GM = AM(127)
            END IF
            IF (IVX.EQ.4.OR.IVX.EQ.9) THEN
               KAXI=KX1
            ELSE IF (IVX.EQ.5.OR.IVX.EQ.10) THEN
               KAXI=KX2
            ELSE
*  |  |  |   Kaxi = 0 added for completeness, maybe it is useless
               KAXI=0
            END IF
            IF (KAXI.EQ.1.OR.KAXI.EQ.7) THEN
               IIAA=1
            ELSE IF (KAXI.EQ.2.OR.KAXI.EQ.8) THEN
               IIAA=2
            ELSE
               IIAA=0
            END IF
         GO TO 15
   15    CONTINUE
         IF (RX .LE. GM) GO TO 200
         X1=RX
         X2=UQUARM
         PU=BETA(X1,X2,BET)
         X2=SQUARM
         PS=BETA(X1,X2,BET)
         X2=CQUARM
         PC=BETA(X1,X2,BET)
         PTOT=2.D+00*PU+PS+PC
         PU1=PU/PTOT
         PS=PS/PTOT
         PC=PC/PTOT
         IF (IIAA .EQ. 1) THEN
            PU=0.6666666666666667D+00*PU1
            PD=2.D+00*PU1-PU
         ELSE IF (IIAA .EQ. 2) THEN
            PD=0.6666666666666667D+00*PU1
            PU=2.D+00*PU1-PD
         ELSE
            PU=PU1
            PD=PU
         END IF
         IF (Z1 .LE. PU) THEN
            KF1 = 1
         ELSE IF ( Z1 .LE. PU + PD ) THEN
            KF1 = 2
         ELSE IF ( Z1 .LE. PU + PD + PS ) THEN
            KF1 = 3
         ELSE
            KF1 = 4
         END IF
         IF (Z2 .LE. PU) THEN
            KF2 = 1
         ELSE IF ( Z2 .LE. PU + PD ) THEN
            KF2 = 2
         ELSE IF ( Z2 .LE. PU + PD + PS ) THEN
            KF2 = 3
         ELSE
            KF2 = 4
         END IF
      GO TO 20
   20 CONTINUE
C*****CHOICE OF THE QUARKFLAVOURS IN DEPENDENCE OF THE VERTEX IV
      IVX=IV(I)
      GO TO (1,2,3,4,5,1,2,3,4,5),IVX
    1 CONTINUE
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1+6
         ELSE
            KFR1(I)=KF1
         END IF
         KFR2(I)=0
      GO TO 30
    2 CONTINUE
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1
            KFR2(I)=KF2
         ELSE
            KFR1(I)=KF1+6
            KFR2(I)=KF2+6
         END IF
      GO TO 30
    3 CONTINUE
         KFR2(I)=0
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1+6
         ELSE
            KFR1(I)=KF1
         END IF
      GO TO 30
    4 CONTINUE
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1
         ELSE
            KFR1(I)=KF1+6
         END IF
         KFR2(I)=KX2
      GO TO 30
    5 CONTINUE
         KFR1(I)=KX1
         IF (LL.EQ.1) THEN
            KFR2(I)=KF2
         ELSE
            KFR2(I)=KF2+6
         END IF
      GO TO 30
   30 CONTINUE
      IF(LT.EQ.0) GO TO 80
      WRITE(LUNOUT,6)PU,PD,PS,PC,KX1,KX2
    6 FORMAT(1H0,' FLAVOR PU,PD,PS,PC,KX1,KX2',4F8.4,2I5)
      IF(I.EQ.1) GO TO 40
      WRITE(LUNOUT,60)IV(I),LL,KFR1(J),KFR2(J),KFR1(I),KFR2(I)
      GO TO 50
   40 WRITE(LUNOUT,70)IV(I),LL,KFA1,KFA2,KFR1(I),KFR2(I)
   50 CONTINUE
   60 FORMAT(1H0,22HIV,LL,Q1A,Q2A,Q1N,Q2N=,6I3)
   70 FORMAT(1H0,'IV(I),LL,KFA1,KFA2,KFR1(I),KFR2(I)=',6I3 )
   80 CONTINUE
      RETURN
      END
+DECK,  FKIMPU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== impuls ===========================================================*
      SUBROUTINE FKIMPU(HE,HMA,HPS,HPX,HPY,HPZ,LT,LL,B3)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(2)
*
*----------------------------------------------------------------------*
*  Impuls89: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
C*****CHOICE OF THE TRANSVERSAL MOMENTUM AND CALCULATION OF THE
C*****LONGITUDINAL MOMENTUM
C*****HPS,HPZ ARE THE TRANSVERSAL AND LONGITUDINAL MOMENTUM

      ESMAX = HE - HMA
    1 CONTINUE
*
*  He is the total energy, hma the mass one (input) hpx, hpy, hpz
*  the momentum components (output values), hps the transversal
*  momentum (output)
*
*  +-------------------------------------------------------------------*
*  |                            cut off for the longitudinal momentum
      IF (ESMAX .LE. 0.05D0) THEN
*  |
*  | only transversal momentum!
*  |
         HPS = SQRT(HE**2 - HMA**2)
         HPZ = 0.D0
      ELSE
*  |
*  | hps is the transversal momentum
*  |
         CALL GRNDM(RNDM,2)
         X = RNDM(1)
         Y = RNDM(2)
*  |
*  |  Es is the transverse kinetic energy
*  |
         ES = -2.D0/(B3**2)*LOG(X*Y)
         IF (ES .GT. ESMAX) GO TO 1
         HPS = ES**2 + 2.D0*ES*HMA
         IF (LL .EQ. 0) Y1 = 1.D0
         IF (LL .EQ. 1) Y1 =-1.D0
         HPZ = SQRT(HE**2 - HMA**2 - HPS) * Y1
         HPS = SQRT (HPS)
      END IF
*  |
*  +-------------------------------------------------------------------*
      CALL SFECFE(SFE,CFE)
      SIP = SFE
      COP = CFE
      HPX = HPS*COP
      HPY = HPS*SIP
      IF (LT .EQ. 0) GO TO 2
      WRITE(LUNOUT,3) HPS,HPX,HPY,HPZ,HE,HMA,LL
    3 FORMAT(1H0,19HPS,PX,PY,PZ,E,M,LL=,6F8.4,I3)
    2 CONTINUE
      RETURN
      END
+DECK,  FKSIGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== sigint ===========================================================*
      SUBROUTINE FKSIGI (IRE ,PLAB,N,IE ,AMT ,AMN,ECM ,SI ,ITAR)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, REAC.
+CDE, REDVER.
*
**** *,IEII,IKII,NURE
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
*
      IE=IEFUN(PLAB,IRE)
      IF (IE.LE.IEII(IRE)) IE=IE+1
      AMT=AM(ITAR)
      AMN=AM(N)
      AMN2=AMN*AMN
      AMT2=AMT*AMT
      ECM=SQRT(AMN2+AMT2+2.D0*AMT*SQRT(AMN2+PLAB**2))
C*** INTERPOLATION PREPARATION
      ECMO=UMO(IE)
      ECM1=UMO(IE-1)
      DECM=ECMO-ECM1
      DEC=ECMO-ECM
      IIKI=IKII(IRE)+1
      EKLIM=-THRESH(IIKI)
      WOK=SIIN(IE)
      WDK=WOK-SIIN(IE-1)
      IF (ECM.GT.ECMO) WDK=0.D0
C*** INTERPOLATION IN CHANNEL WEIGHTS
      IELIM=IEFUN(EKLIM,IRE)
      DELIM=UMO(IELIM)+EKLIM
     *+1.D-16
      DETE=(ECM-(ECMO-EKLIM)*.5D0)*2.D0
      IF (DELIM*DELIM-DETE*DETE) 112,112,113
  113 DECC=DELIM
      GO TO 114
  112 DECC=DECM
  114 CONTINUE
      WKK=WOK-WDK*DEC/(DECC+1.D-9)
      IF (WKK.LT.0.D0) WKK=0.D0
      SI=WKK+1.D-12
      IF (-EKLIM.GT.ECM) SI=1.D-14
      RETURN
      END
+DECK,  FKVERT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== vertex ===========================================================*
      SUBROUTINE FKVERT(IT,LT,LL,KFA,E0,IV,RE,KFR1,KFR2,AME,IOPT)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(2)
C     CHOICE OF THE VERTEX
      DIMENSION RE(*),KFR1(*),KFR2(*),IV(*)
C     WAEHLT PASSENDEN VERTEX IV AUS
       IF(LT.EQ.1) WRITE(LUNOUT,288)IT,LT,LL,KFA,E0,AME,IOPT
  288 FORMAT (4I5,2E12.4,I5,' VERTEX IT,LT,LL,KFA,E0,AME')
      PDB=0.8D0
      IVA=1
      I=IT
      J=IT-1
      IVX=IVA
      IF(IOPT.EQ.2) IVX=2
      IF(IOPT.EQ.4.AND.KFA.GT.6.AND.LL.EQ.0) IVX=2
      IF(IOPT.EQ.4.AND.KFA.LE.6.AND.LL.EQ.1) IVX=2
      IF(IOPT.EQ.5) IVX=2
      IF(I.GT.1)IVX=IV(J)
      IF(LL.EQ.1.AND.I.GT.1)IVX=IV(J)-5
      CALL GRNDM(RNDM,2)
      Z=RNDM(1)
      Y=RNDM(2)
      GO TO (1,2,1,2,2),IVX
    1 IVX=1
      IF(Z.GE.AME) IVX=2
      GO TO 20
    2 IVX=3
      IF(Z.GT.PDB) IVX=4
      IF(Z.GT.PDB.AND.Y.LE.0.5D0)  IVX=5
      GO TO 20
   20 CONTINUE
      IF(LL.EQ.1)IVX=IVX+5
      IV(I)=IVX
      IF(LT.EQ.0)GO TO 60
C     AUSDRUCKEN
      IF(I.EQ.1)GO TO 30
      WRITE(LUNOUT,50)IV(J),IV(I),LL
      GO TO 40
   30 WRITE(LUNOUT,50)IVA,IV(I),LL
   40 CONTINUE
   50 FORMAT(1H0,15HIV(J),IV(I),LL=,3I5)
   60 CONTINUE
      RETURN
      END
+DECK,  FKZERO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant

*=== zeroin ===========================================================*
      SUBROUTINE FKZERO

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*======================================================================*
*                                                                      *
*     Created by Alfredo Ferrari on 11 july 1990   INFN - Milan        *
*                                                                      *
*     Last change  on    23-apr-93  by  Alfredo Ferrari                *
*                                                                      *
*     This routine zeroes a few arrays, and initialize some data       *
*                                                                      *
*======================================================================*
*
+CDE, PAPROP.
+CDE, PART2.
*
*  +-------------------------------------------------------------------*
*  |               Set the "effective" masses for particles
      DO 8000 I = 1, IDMAX8
*  |  +----------------------------------------------------------------*
*  |  |            Baryons: "effective" mass = actual one - baryon
*  |  |                      number x proton mass (final state of any
*  |  |                      baryon)
         IF ( IIBAR (I) .GT. 0 ) THEN
            AAMDSC (I) = AAM (I) - IIBAR (I) * AAM (1)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |            Antibaryons: "effective mass" = actual mass +
*  |  |                          |baryon number| x proton mass
         ELSE IF ( IIBAR (I) .LT. 0 ) THEN
            AAMDSC (I) = AAM (I) - IIBAR (I) * AAM (1)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |            Mesons: "effective" mass = actual mass
         ELSE
            AAMDSC (I) = AAM (I)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 8000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*    Electron: "effective" mass = 0
      AAMDSC (3) = ZERZER
*    Positron: "effective" mass = 2 x mass
      AAMDSC (4) = 2.D+00 * AAM (4)
*    Neutron: "effective" mass = 0 (it should be taken into account the
*                         neutrino energy when decaying)
      AAMDSC (8) = ZERZER
*    Muon+: "effective" mass = muon mass + positron mass
      AAMDSC (10) = AAM (10) + AAM (4)
*    Muon-: "effective" mass = muon mass - electron mass
*           (final stable state)
      AAMDSC (11) = AAM (11) - AAM (3)
*    Tau+: "effective" mass = Tau mass + positron mass
      AAMDSC (131) = AAM (131) + AAM (4)
*    Tau-: "effective" mass = Tau mass - electron mass
*           (final stable state)
      AAMDSC (132) = AAM (132) - AAM (3)
*  +-------------------------------------------------------------------*
*  |               Set the "effective" masses for particles in Paprop
      DO 8500 I = 1, NALLWP
         KP = IPTOKP (I)
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( KP .GT. 0 ) THEN
            AMDISC (I) = AAMDSC (KP)
            AM     (I) = AAM  (KP)
            ICHRGE (I) = IICH (KP)
            THALF  (I) = TAU  (KP)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( I .NE. 30 ) THEN
            AMDISC (I) = ZERZER
            AM     (I) = ZERZER
            ICHRGE (I) = 0
            THALF  (I) = ZERZER
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            AMDISC (I) = AAMDSC (1)
            AM     (I) = AAM  (1)
            ICHRGE (I) = IICH (1)
            THALF  (I) = TAU  (1)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |   Set the particle spin (in 1/2 units)
*  |  |   If the particle is a hadron :
*  |  |            mesons         --> 0 spin
*  |  |       baryons,antibaryons --> 1/2 spin
*  |  |   otherwise :
*  |  |       e-/+,mu-/+,vu,vubar --> 1/2 spin
*  |  |             photons       --> 1 spin
         IF ( LHADRO (I) .AND. IIBAR (KP) .EQ. 0 ) THEN
            JSPINP (I) = 0
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IF ( I .EQ. 7 ) THEN
               JSPINP (I) = 2
            ELSE
               JSPINP (I) = 1
            END IF
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 8500 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*=== end of subroutine zeroin =========================================*
      RETURN
      END
+DECK,  FLAVOR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== flavor ===========================================================*
      SUBROUTINE FLAVOR(IT,LT,LL,E0,IV,RE,KFR1,KFR2,ISU,BETE,KFA1,KFA2,
     &                  KFA3,KFA4,IOPT)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     New version from A. Ferrari ( 22 august 1990 ): it is almost the *
*     the same as before, but with a few corrections important for isu *
*     2 and 3 and also for isu=4 if it switchs to 100 continue         *
*                                                                      *
*----------------------------------------------------------------------*
+CDE, PART.
*
*   The following are the masses of the quarks: the d quark mass is
*   assumed to be the same as the u one. They are quite different from
*   the last values from the particle data group, but any change
*   can imply a change also in the BET parameter in common INPDAT
      PARAMETER ( UQUARM = 0.3D+00 )
      PARAMETER ( SQUARM = 0.5D+00 )
      PARAMETER ( CQUARM = 2.1D+00 )
      PARAMETER ( BQUARM = 5.0D+00 )
*
      DIMENSION RE(*),KFR1(*),KFR2(*),IV(*)
      REAL RNDM(2)
*
C     CHOICE OF THE QUARK FLAVOUR
      IF (LT.EQ.1)WRITE(LUNOUT,288)IT,LT,LL,E0,ISU,BETE,KFA1,KFA2
  288 FORMAT(3I5,E12.4,I5,E12.4,2I5
     *,' FLAVOR IT,LT,LL,E0,ISU,BETE,KFA1,KFA2')
      I=IT
      J=IT-1
      IVA=1
      IVX=IV(I)
      IF (I .LE. 1) THEN
         IF (IOPT.EQ.2) THEN
            KX1 = KFA1
            KX2 = KFA2
         ELSE IF (IOPT.EQ.3.AND.LL.EQ.1) THEN
            KX1=KFA2
            KX2=0
         ELSE IF (IOPT.EQ.4 .AND. KFA1.LE.6 .AND. LL.EQ.1) THEN
            KX1=KFA2
            KX2=KFA3
         ELSE IF (IOPT.EQ.4 .AND. KFA1.GT.6 .AND. LL.EQ.0) THEN
            KX1=KFA2
            KX2=KFA3
         ELSE IF (IOPT.EQ.5 .AND. LL.EQ.0) THEN
            KX1=KFA3
            KX2=KFA4
         ELSE IF (IOPT.EQ.5 .AND. LL.EQ.1) THEN
            KX1=KFA1
            KX2=KFA2
         ELSE
            KX1=KFA1
            KX2=0
         END IF
         RX = E0
      ELSE
         KX1=KFR1(J)
         KX2=KFR2(J)
         RX =RE(J)
      END IF
      IF (KX1.GT.0.AND.KX2.GT.0) THEN
         BET=10.D+00
      ELSE
         BET=BETE
      END IF
      CALL GRNDM(RNDM,2)
      Z1=RNDM(1)
      Z2=RNDM(2)
      IF(ISU.EQ.4) GO TO 300
      IF(ISU.EQ.3) GO TO 200
      IF(ISU.EQ.2) GO TO 100
C     U FLAVOUR
         KF1=1
         KF2=1
      GO TO 20
C     U/D FLAVOURS
  100 CONTINUE
         IF (KX1.EQ.1.OR.KX1.EQ.7) THEN
            IIAA=1
         ELSE IF (KX1.EQ.2.OR.KX1.EQ.8) THEN
            IIAA=2
         ELSE
            IIAA=0
         END IF
  110 CONTINUE
         IF (IIAA .EQ. 1) THEN
            PD=0.6666666666666667D+00
            PU=0.3333333333333333D+00
         ELSE IF (IIAA .EQ. 2) THEN
            PU=0.6666666666666667D+00
            PD=0.3333333333333333D+00
         ELSE
            PU=0.5D+00
            PD=0.5D+00
         END IF
         PS=0.D+00
         PC=0.D+00
         IF (Z1 .LE. PD) THEN
            KF1=2
         ELSE
            KF1=1
         END IF
         IF (Z2 .LE. PD) THEN
            KF2=2
         ELSE
            KF2=1
         END IF
      GO TO 20
C     U/D/S FLAVOURS
  200 CONTINUE
         IF (KX1.EQ.1.OR.KX1.EQ.7) THEN
            IIAA=1
         ELSE IF (KX1.EQ.2.OR.KX1.EQ.8) THEN
            IIAA=2
         ELSE
            IIAA=0
         END IF
  210 CONTINUE
         IF (RX .LE. 1.019D+00 ) GO TO 110
         X1=RX
         X2=UQUARM
         PU=BETA(X1,X2,BET)
         X2=SQUARM
         PS=BETA(X1,X2,BET)
         PTOT=2.D+00*PU+PS
         PU1=PU/PTOT
         PS =PS/PTOT
         PC=0.D+00
         IF (IIAA .EQ. 1) THEN
            PU=0.6666666666666667D+00*PU1
            PD=2.D+00*PU1-PU
         ELSE IF (IIAA .EQ. 2) THEN
            PD=0.6666666666666667D+00*PU1
            PU=2.D+00*PU1-PD
         ELSE
            PU=PU1
            PD=PU
         END IF
         IF (Z1 .LE. PU) THEN
            KF1 = 1
         ELSE IF ( Z1 .LE. PU + PD ) THEN
            KF1 = 2
         ELSE
            KF1 = 3
         END IF
         IF (Z2 .LE. PU) THEN
            KF2 = 1
         ELSE IF ( Z2 .LE. PU + PD ) THEN
            KF2 = 2
         ELSE
            KF2 = 3
         END IF
      GO TO 20
C     U/D/S/C FLAVOUR
  300 CONTINUE
         GO TO (11,12,13,14,14,11,12,13,14,14),IVX
   11    CONTINUE
            IF (KX1.EQ.4.OR.KX1.EQ.10) THEN
               GM=AM(129)
            ELSE
               GM=AM(127)
            END IF
            IF (KX1.EQ.1.OR.KX1.EQ.7) THEN
               IIAA=1
            ELSE IF (KX1.EQ.2.OR.KX1.EQ.8) THEN
               IIAA=2
            ELSE
               IIAA=0
            END IF
         GO TO 15
   12    CONTINUE
            IF (KX1.EQ.4.OR.KX1.EQ.10) THEN
               GM=AM(170)
            ELSE
               GM=AM(127)
            END IF
            IIAA=0
         GO TO 15
   13    CONTINUE
*  |  |  +-------------------------------------------------------------*
*  |  |  | The following if replaces the cards:
*  |  |  |      GM=3.85D0
*  |  |  |      IF(KX1.EQ.4.AND.KX2.EQ.4) GM=4.89D0
*  |  |  |      IF(KX1.NE.4.AND.KX2.NE.4) GM=2.770D0
*  |  |  |      IF(KX1.EQ.10.AND.KX2.EQ.10) GM=4.89D0
*  |  |  |      IF(KX1.NE.10.AND.KX2.NE.10) GM=2.770D0
*  |  |  | It is completely equivalent except for the combination
*  |  |  | 4-4 which now gives GM = 4.89, while in the original
*  |  |  | coding gave GM = 2.77, because of the last condition
*  |  |  | always overrides the first one (it seems to be a mistake)
            IF (KX1 .EQ. 4 .OR. KX1 .EQ. 10 ) THEN
               IF ( KX2 .EQ. KX1 ) THEN
                  GM = AM(170)
               ELSE
                  GM = AM(169)
               END IF
            ELSE IF (KX2 .EQ. 4 .OR. KX2 .EQ. 10 ) THEN
               GM = AM(169)
            ELSE
               GM = AM(166)
            END IF
            IIAA=0
         GO TO 15
   14    CONTINUE
*  |  |  +-------------------------------------------------------------*
*  |  |  | The following if replaces the cards:
*  |  |  |      GM=3.684D0
*  |  |  |      IF(KX1.NE.4.AND.KX2.NE.4) GM=2.140D0
*  |  |  |      IF(KX1.NE.10.AND.KX2.NE.10) GM=2.140D0
*  |  |  | It is equivalent: only for the combinations
*  |  |  | 4-10 and 10-4 we get GM = 3.684
*  |  |  | It is not clear if it is correct since 4-x,x-4 (x.ne.10),
*  |  |  | 10-x,x-10 (x.ne.4) give GM = 2.14
            IF ((KX1.EQ.4.AND.KX2.EQ.10).OR.(KX1.EQ.10.AND.KX2.EQ.4))
     &         THEN
               GM = AM(129)
            ELSE
               GM = AM(127)
            END IF
            IF (IVX.EQ.4.OR.IVX.EQ.9) THEN
               KAXI=KX1
            ELSE IF (IVX.EQ.5.OR.IVX.EQ.10) THEN
               KAXI=KX2
            ELSE
*  |  |  |   Kaxi = 0 added for completeness, maybe it is useless
               KAXI=0
            END IF
            IF (KAXI.EQ.1.OR.KAXI.EQ.7) THEN
               IIAA=1
            ELSE IF (KAXI.EQ.2.OR.KAXI.EQ.8) THEN
               IIAA=2
            ELSE
               IIAA=0
            END IF
         GO TO 15
   15    CONTINUE
         IF (RX .LE. GM) GO TO 200
         X1=RX
         X2=UQUARM
         PU=BETA(X1,X2,BET)
         X2=SQUARM
         PS=BETA(X1,X2,BET)
         X2=CQUARM
         PC=BETA(X1,X2,BET)
         PTOT=2.D+00*PU+PS+PC
         PU1=PU/PTOT
         PS=PS/PTOT
         PC=PC/PTOT
         IF (IIAA .EQ. 1) THEN
            PU=0.6666666666666667D+00*PU1
            PD=2.D+00*PU1-PU
         ELSE IF (IIAA .EQ. 2) THEN
            PD=0.6666666666666667D+00*PU1
            PU=2.D+00*PU1-PD
         ELSE
            PU=PU1
            PD=PU
         END IF
         IF (Z1 .LE. PU) THEN
            KF1 = 1
         ELSE IF ( Z1 .LE. PU + PD ) THEN
            KF1 = 2
         ELSE IF ( Z1 .LE. PU + PD + PS ) THEN
            KF1 = 3
         ELSE
            KF1 = 4
         END IF
         IF (Z2 .LE. PU) THEN
            KF2 = 1
         ELSE IF ( Z2 .LE. PU + PD ) THEN
            KF2 = 2
         ELSE IF ( Z2 .LE. PU + PD + PS ) THEN
            KF2 = 3
         ELSE
            KF2 = 4
         END IF
      GO TO 20
   20 CONTINUE
C*****CHOICE OF THE QUARKFLAVOURS IN DEPENDENCE OF THE VERTEX IV
      IVX=IV(I)
      GO TO (1,2,3,4,5,1,2,3,4,5),IVX
    1 CONTINUE
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1+6
         ELSE
            KFR1(I)=KF1
         END IF
         KFR2(I)=0
      GO TO 30
    2 CONTINUE
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1
            KFR2(I)=KF2
         ELSE
            KFR1(I)=KF1+6
            KFR2(I)=KF2+6
         END IF
      GO TO 30
    3 CONTINUE
         KFR2(I)=0
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1+6
         ELSE
            KFR1(I)=KF1
         END IF
      GO TO 30
    4 CONTINUE
         IF (LL.EQ.1) THEN
            KFR1(I)=KF1
         ELSE
            KFR1(I)=KF1+6
         END IF
         KFR2(I)=KX2
      GO TO 30
    5 CONTINUE
         KFR1(I)=KX1
         IF (LL.EQ.1) THEN
            KFR2(I)=KF2
         ELSE
            KFR2(I)=KF2+6
         END IF
      GO TO 30
   30 CONTINUE
      IF(LT.EQ.0) GO TO 80
      WRITE(LUNOUT,6)PU,PD,PS,PC,KX1,KX2
    6 FORMAT(1H0,' FLAVOR PU,PD,PS,PC,KX1,KX2',4F8.4,2I5)
      IF(I.EQ.1) GO TO 40
      WRITE(LUNOUT,60)IV(I),LL,KFR1(J),KFR2(J),KFR1(I),KFR2(I)
      GO TO 50
   40 WRITE(LUNOUT,70)IV(I),LL,KFA1,KFA2,KFR1(I),KFR2(I)
   50 CONTINUE
   60 FORMAT(1H0,22HIV,LL,Q1A,Q2A,Q1N,Q2N=,6I3)
   70 FORMAT(1H0,'IV(I),LL,KFA1,KFA2,KFR1(I),KFR2(I)=',6I3 )
   80 CONTINUE
      RETURN
      END
+SELF.
+DECK,  FPOWER, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

*$ CREATE FPOWER.FOR
*COPY FPOWER
*=== fpower ===========================================================*
      FUNCTION FPOWER ( IPOWER, NU, ANUAV )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on   05  may  1992   by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 10-jun-92     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER ( TWOLOG = 0.6931471805599453D+00 )
*
      IF ( IPOWER .NE. 13 ) STOP 'FPOWER'
         IF ( ANUAV .LT. 2.D+00 ) THEN
            AKAPP0 = -0.93699278D+00*ANUAV**2 + 3.9082338D+00
         ELSE
            AKAPP0 = 4.2019D+00 / ANUAV**2.2835973D+00
         END IF
         IF ( NU .LE. 1 ) THEN
            FPOWER = AKAPP0
         ELSE
            AFACT  = ( NU - 1.D+00 ) / ( ANUAV + NU - 1.D+00 )
*  |  This correction (1 card) has been put by A.F. on 29-12-92, trying
*  |  to widen a bit the residual nuclei distribution without
*  |  spoiling the good agreement with the grey particle distribution
            AFACT  = AFACT / SQRT (ANUAV)
            AKAPPA = ( 1.D+00 - AFACT ) * AKAPP0 + AFACT
            APOWER = ANUAV / NU + 1.D+00 * ANUAV / ( ANUAV + 1.D+00 )
            DDNU   = NU
            FPOWER = APOWER + LOG ( AKAPPA ) / LOG ( DDNU )
         END IF
*=== End of function fpower ===========================================*
      RETURN
      END
+DECK,  FPROB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

*$ CREATE FPROB.FOR
*COPY FPROB
*=== fprob ============================================================*
      FUNCTION FPROB (Z,A,U)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  Fission PROBability:                                                *
*                                                                      *
*  Created  on  8 april 1993   by     Alfredo Ferrari & Paola Sala     *
*                                                INFN - Milan          *
*                                                                      *
*  Last change  on  09-apr-93  by  Alfredo Ferrari, INFN - Milan       *
*                                                                      *
*  This function is just a translation into Fluka of the same function *
*  of LAHET kindly provided by R.E. Prael                              *
*                                                                      *
*     Input variables:                                                 *
*                       Z = present nucleus atomic number              *
*                       A =    "       "     mass    "                 *
*                       U =    "       "    excitation energy (MeV)    *
*                                                                      *
*----------------------------------------------------------------------*
*
      FPROB = 0
      STOP 'FPROB'
*      RETURN
*=== End of function Fprob ============================================*
      END
+DECK,  GAMRN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE GAMRN.FOR
*COPY GAMRN
*=== gamrn ============================================================*
      FUNCTION GAMRN(ALAM,ETA)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(2)
C
C********************************************************************
C
C     RANDOM NUMBER SELECTION FROM GAMMA DISTRIBUTION
C     F(X) = ALAM**ETA*X**(ETA-1)*EXP(-ALAM*X) / GAM(ETA)
C
C********************************************************************
C
      NCOU = 0
      N = ETA
      F = ETA - N
      IF (F .EQ. 0.D0) GO TO 100
  10  CALL GRNDM(RNDM,1)
      R = RNDM(1)
      NCOU = NCOU + 1
      IF (NCOU.GE.11) GO TO 100
      IF (R .LT. F/(F + 2.718281828459045D0)) GO TO 20
      CALL GRNDM(RNDM,1)
      YYY = LOG(RNDM(1)+1.0D-38)/F
      IF (ABS(YYY) .GT. 50.D0) GO TO 100
      Y = EXP(YYY)
      CALL GRNDM(RNDM,1)
      IF (LOG(RNDM(1) + 1.0D-38) .GT. -Y) GO TO 10
      GO TO 50
 100  Y = 0.D0
      GO TO 70
  20  CALL GRNDM(RNDM,2)
      Y = 1.D0 - LOG(RNDM(1) + 1.0D-38)
      IF (RNDM(2) .GT. Y**(F-1.D0)) GO TO 10
  50  IF (N .EQ. 0) GO TO 150
  70  Z = 1.D0
      IF (N .LE. 0) N = 1
      DO 80 I = 1,N
  80  CALL GRNDM(RNDM,1)
      Z = Z * RNDM(1)
      Y = Y - LOG(Z + 1.0D-38)
 150  GAMRN = Y/ALAM
      RETURN
      END
+DECK,  GETA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

*$ CREATE GETA.FOR
*COPY GETA
*=== geta =============================================================*
      FUNCTION GETA ( U, JZ, JN, MODE, IS, AOGMAX,
     &                                 AOGMIN )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 18 january 1993   by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 28-jan-93     by    Alfredo Ferrari               *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, EVA0.
+SELF, IF=-SINGLE.
      PARAMETER ( ASMTOG = 6.0D0 / PIPIPI**2 )
+SELF, IF=SINGLE.
      PARAMETER ( ASMTOG = 6.0e0 / PIPIPI**2 )
+SELF.
      LOGICAL LASMLL
*
      LASMLL = .TRUE.
      IF ( JZ .LE. 0 .OR. JN .LE. 0 ) THEN
         GETA = ( JZ + JN) / B0
         AOGMAX = GETA
         AOGMIN = GETA
         RETURN
      END IF
      GO TO 5
      ENTRY GETG ( U, JZ, JN, MODE, IS, AOGMAX, AOGMIN )
      LASMLL = .FALSE.
    5 CONTINUE
      JA = JN + JZ
      AA = JA
      ZZ = JZ
      GO TO (10,20,30), MODE
*  +-------------------------------------------------------------------*
*  |  Standard EVAP parametrization for the level density
   10 CONTINUE
         TEMP = AA * ( ONEONE + Y0 * ( ( AA - TWOTWO*ZZ ) / AA )**2) /B0
         AOGMAX = TEMP
         AOGMIN = TEMP
      GO TO 40
*  |
*  +-------------------------------------------------------------------*
*  |  Gilbert & Cameron level density (with Z and A dependent correction
*  |  smoothly going into the Ignatyuk high energy limit, according
*  |  to the Ignatyuk interpolation formula
   20 CONTINUE
         STOP 'GETA:20'
***      GO TO 40
*  |
*  +-------------------------------------------------------------------*
*  |  Julich zero energy A-dependent level density:
   30 CONTINUE
         STOP 'GETA:30'
   40 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  geta = a (U) (aogmax = a_max)
      IF ( LASMLL ) THEN
         GETA   = TEMP
*  |
*  +-------------------------------------------------------------------*
*  |  getg = g (U) (aogmax = g_max)
      ELSE
         GETG   = ASMTOG * TEMP
         AOGMAX = ASMTOG * AOGMAX
         AOGMIN = ASMTOG * AOGMIN
      END IF
*  |
*  +-------------------------------------------------------------------*
*=== End of Function geta =============================================*
      RETURN
      END
+DECK,  HADDEN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

*$ CREATE HADDEN.FOR
*COPY HADDEN
*=== hadden ===========================================================*
      SUBROUTINE HADDEN

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Hadden89: slight modifications by A. Ferrari, INFN-Milan and CERN-SPS
*            7-9-89
*----------------------------------------------------------------------*
*
+CDE, DECAYC2.
+CDE, PART3.
+CDE, SPLIT.
*
      COMMON /FKNAMS/ ANAME(110),ZKNAME(460),RKNAME(268)
C
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
      CHARACTER*8 ANAME,ZKNAME,RKNAME,ANAMZ,ZKNAMZ
      COMMON /FKADHP/AMZ(16),GAZ(16),TAUZ(16),ICHZ(16),IBARZ(16),K1Z(16)
     *,K2Z(16),WTZ(153),II22,
     * NZKZ(153,3)
      COMMON/FKADHN/ANAMZ(16),ZKNAMZ(153)
      DATA IRETUR/0/
      IRETUR=IRETUR+1
      IF (IRETUR.GT.1) RETURN
      DO 1 I=1,94
         ANAME(I) = ANAMC(I)
         AM   (I) = AMC  (I)
         GA   (I) = GAC  (I)
         TAU  (I) = TAUC (I)
         ICH  (I) = ICHC (I)
         IBAR (I) = IBARC(I)
         K1   (I) = K1C  (I)
         K2   (I) = K2C  (I)
   1  CONTINUE
      AM(31) = 0.48D0
      DO 5 I=26,30
         K1(I) = 452
         K2(I) = 452
   5  CONTINUE
      DO 2 I=1,307
         ZKNAME(I) = ZKNAMC(I)
         WT    (I) = WTC   (I)
         NZK (I,1) = NZKC(I,1)
         NZK (I,2) = NZKC(I,2)
         NZK (I,3) = NZKC(I,3)
   2  CONTINUE
      DO 3 I=1,16
         L=I+94
         ANAME(L) = ANAMZ(I)
         AM   (L) = AMZ  (I)
         GA   (L) = GAZ  (I)
         TAU  (L) = TAUZ (I)
         ICH  (L) = ICHZ (I)
         IBAR (L) = IBARZ(I)
         K1   (L) = K1Z  (I)
         K2   (L) = K2Z  (I)
   3  CONTINUE
      DO 4 I=1,153
         L=I+307
         ZKNAME(L) = ZKNAMZ(I)
         WT    (L) = WTZ   (I)
         NZK (L,3) = NZKZ(I,3)
         NZK (L,2) = NZKZ(I,2)
         NZK (L,1) = NZKZ(I,1)
   4  CONTINUE
      RETURN
      END
+DECK,  HADEVV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:56  cernlib
* Geant

*$ CREATE HADEVV.FOR
*COPY HADEVV
*=== hadevv ===========================================================*
      SUBROUTINE HADEVV ( NHAD, KPROJ, KTARG, PPROJ, EPROJ, UMO )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*    Modified version of Hadevt created by Alfredo Ferrari, INFN-Milan *
*                                                                      *
*    Last change  on  20-jun-93  by  Alfredo Ferrari, INFN - MIlan     *
*                                                                      *
*  Hadevt90: kinematics completed revised by A. Ferrari, before it was *
*            always wrong every time the second jet to be sampled was  *
*            a "parjet". A few other bugs corrected: maybe others are  *
*            still in!!!                                               *
*----------------------------------------------------------------------*
*
C
C     GENERATE HADRON PRODC
C     GENERATE HADRON PRODUCTION EVENT IN  KPROJ - KTARG  COLLISION
C     WITH  LAB PROJECTILE MOMENTUM  PPROJ
C     INCLUDING MESON MESON AND MESON ANTIBARYON COLLISIONS
C
C********************************************************************
C
+CDE, AUXPAR.
+CDE, BALANC.
+CDE, CMSRES.
+CDE, FINPAR.
+CDE, HADPAR.
+CDE, INPDAT2.
+CDE, PART.
+CDE, QQUARK.
      COMMON /FKINVT/PNUC(3),INUCVT
      COMMON /FKPRIN/ IPRI, INIT
      REAL RNDM(2)
      LOGICAL LISSU, LQTARG, LQPROJ
*
      SAVE UNON,UNOM,UNOMS
      DATA UNON/2.0D0/
      DATA UNOM/1.5D0/
      DATA UNOMS/0.5D0/
*
C
C*******************************************************************"
C
C     KINEMATICS
C
C********************************************************************
C
 8899 CONTINUE
* Ijproj = paprop numbering
      IJPROJ = KPTOIP (KPROJ)
      IJTARG = KPTOIP (KTARG)
      AMPROJ = AM(KPROJ)
      AMTAR = AM(KTARG)
*  The usual gamma and sqrt[beta**2/(1-beta**2)]=eta=gamma*beta factors
*  for the CMS system
*
      GAMCM = (EPROJ+AMTAR)/UMO
      BGCM  = PPROJ / UMO
C
*or      IF(IPRI.EQ.1) WRITE(LUNOUT,101)KPROJ,KTARG,PPROJ,AMPROJ,AMTAR,
*or     &EPROJ,UMO,GAMCM,BGCM
*or 101  FORMAT(2I5,10F11.5)
C
C********************************************************************
C
C     SELECTION OF  QUARK - DIQUARK - CHAINS
C
C********************************************************************
C
*
*  Ibproj = baryonic charge of the projectile
*
      IBPROJ = IBAR(KPROJ)
*
*  Ibtarg = baryonic charge of the target nucleon
*
      IBTARG = IBAR(KTARG)
*
*  Ipq1,ipq2,ipq3 = quarks of the projectile
*
      IQP1 = MQUARK(1,IJPROJ)
      IQP2 = MQUARK(2,IJPROJ)
      IQP3 = MQUARK(3,IJPROJ)
*
*  Iqt1,iqt2,iqt3 = quarks of the projectile
*
      IQT1 = MQUARK(1,IJTARG)
      IQT2 = MQUARK(2,IJTARG)
      IQT3 = MQUARK(3,IJTARG)
*or      IF (IPRI .EQ. 1)
*or     &WRITE(LUNOUT,102)IBPROJ, IQP1,IQP2,IQP3,IQT1,IQT2,
*or     &IQT3
*or 102  FORMAT(12I10)
      IF (IBPROJ) 11, 12, 13
  11  CONTINUE
C
C********************************************************************
C
C     SELECTION OF CHAINS
C     ANTIBARYON - BARYON   COLLISION
C
C********************************************************************
C
*  +-------------------------------------------------------------------*
*  | The incoming projectile is an antibaryon!!!
*  |
         CALL GRNDM(RNDM,1)
         ISAM1 = 1.D0 + 3.D0*RNDM(1)
         GO TO (111,112,113),ISAM1
 111     CONTINUE
            IBF = IQP1
            IFF1 = IQP2
            IFF2 = IQP3
            GO TO 114
 112     CONTINUE
            IBF = IQP2
            IFF1 = IQP1
            IFF2 = IQP3
            GO TO 114
 113     CONTINUE
            IBF = IQP3
            IFF1 = IQP1
            IFF2 = IQP2
 114     CONTINUE
         CALL GRNDM(RNDM,1)
         ISAM2 = 1.D0 + 3.D0*RNDM(1)
         GO TO (115,116,117),ISAM2
 115     CONTINUE
            IBB = IQT1
            IFB1 = IQT2
            IFB2 = IQT3
            GO TO 118
 116     CONTINUE
            IBB = IQT2
            IFB1 = IQT1
            IFB2 = IQT3
            GO TO 118
 117     CONTINUE
            IBB = IQT3
            IFB1 = IQT1
            IFB2 = IQT2
 118     CONTINUE
         GO TO 14
*  | Quark selection for incoming antibaryon has been completed
*  +-->-->-->-->-->-->-->-->-->--> go to 14 continue

  12  CONTINUE
*  +-------------------------------------------------------------------*
*  | The incoming projectile is a meson!!!
*  |
         IF (IBTARG)712,812,912
*  |  +----------------------------------------------------------------*
*  |  | The target nucleon is a baryon (meson projectile)
*  |  |
 912        CONTINUE
C
C********************************************************************
C
C     SELECTION OF CHAINS
C     MESON - BARYON  COLLISION
C
C********************************************************************
C
            CALL GRNDM(RNDM,1)
            ISAM3 = 1.D0 + 2.D0*RNDM(1)
            GO TO (121,122),ISAM3
 121        CONTINUE
               IFF = IQP1
               IBF = IQP2
               GO TO 123
 122        CONTINUE
               IFF = IQP2
               IBF = IQP1
 123        CONTINUE
            CALL GRNDM(RNDM,1)
            ISAM4 = 1.D0 + 3.D0*RNDM(1)
            GO TO (124,125,126),ISAM4
 124        CONTINUE
               GO TO (1241,1242),ISAM3
1241           CONTINUE
                  IBB = IQT1
                  IFB1 = IQT2
                  IFB2 = IQT3
                  GO TO 127
1242           CONTINUE
                  IBB1 = IQT2
                  IBB2 = IQT3
                  IFB = IQT1
                  GO TO 127
 125        CONTINUE
               GO TO (1251,1252),ISAM3
1251           CONTINUE
                  IBB = IQT2
                  IFB1 = IQT1
                  IFB2 = IQT3
                  GO TO 127
1252           CONTINUE
                  IBB1 = IQT1
                  IBB2 = IQT3
                  IFB = IQT2
                  GO TO 127
 126        CONTINUE
               GO TO (1261,1262),ISAM3
1261           CONTINUE
                  IBB = IQT3
                  IFB1 = IQT1
                  IFB2 = IQT2
                  GO TO 127
1262           CONTINUE
                  IBB1 = IQT1
                  IBB2 = IQT2
                  IFB = IQT3
 127        CONTINUE
            GO TO 14
*  |  | Quark selection for incoming meson and baryon target completed
*  |  +-->-->-->-->-->-->-->-->-->--> go to 114 continue

*  |  +----------------------------------------------------------------*
*  |  | The target nucleon is a meson (meson projectile)
*  |  |
 812        CONTINUE
C===============================================================
C
C     SELECTION OF CHAINS
C        MESON MESON COLLISIONS
C
C================================================================
            CALL GRNDM(RNDM,1)
            ISAM3 = 1.D0 + 2.D0*RNDM(1)
            GO TO (1218,1228),ISAM3
1218        CONTINUE
               IFF = IQP1
               IBF = IQP2
               IBB = IQT1
               IFB = IQT2
               GO TO 1238
1228        CONTINUE
               IFF = IQP2
               IBF = IQP1
               IBB = IQT2
               IFB = IQT1
1238        CONTINUE
            GO TO 14
*  |  | Quark selection for incoming meson and meson target completed
*  |  +-->-->-->-->-->-->-->-->-->--> go to 14 continue

*  |  +----------------------------------------------------------------*
*  |  | The target nucleon is an anti-baryon (meson projectile)
*  |  |
 712        CONTINUE
C=================================================================
C
C     SELECTION OF CHAINS
C      MESON ANTIBARYON COLLISIONS
C
C==================================================================
            ISAM3 = 2
            IFF = IQP1
            IBF = IQP2
            CALL GRNDM(RNDM,1)
            ISAM4 = 1.D0 + 3.D0*RNDM(1)
            GO TO (1247,1257,1267),ISAM4
1247        CONTINUE
               GO TO (12417,12427),ISAM3
12417          CONTINUE
                  IBB = IQT1
                  IFB1 = IQT2
                  IFB2 = IQT3
                  GO TO 1277
12427          CONTINUE
                  IBB1 = IQT2
                  IBB2 = IQT3
                  IFB = IQT1
                  GO TO 1277
1257        CONTINUE
               GO TO (12517,12527),ISAM3
12517          CONTINUE
                  IBB = IQT2
                  IFB1 = IQT1
                  IFB2 = IQT3
                  GO TO 1277
12527          CONTINUE
                  IBB1 = IQT1
                  IBB2 = IQT3
                  IFB = IQT2
                  GO TO 1277
1267        CONTINUE
               GO TO (12617,12627),ISAM3
12617          CONTINUE
                  IBB = IQT3
                  IFB1 = IQT1
                  IFB2 = IQT2
                  GO TO 1277
12627          CONTINUE
                  IBB1 = IQT1
                  IBB2 = IQT2
                  IFB = IQT3
1277        CONTINUE
            GO TO 14
*  |  | Quark selection for incoming meson and a-baryon target completed
*  |  +-->-->-->-->-->-->-->-->-->--> go to 14 continue
*  |
*  |                                     end meson projectile
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |  The incoming projectile is a baryon!!!
*  |
  13  CONTINUE
C
C********************************************************************
C
C     SELECTION OF CHAINS
C     BARYON - BARYON   COLLISION
C
C********************************************************************
C
         CALL GRNDM(RNDM,1)
         ISAM5 = 1.D0 + 3.D0*RNDM(1)
         GO TO (131,132,133),ISAM5
 131     CONTINUE
            IBF = IQP1
            IFF1 = IQP2
            IFF2 = IQP3
            GO TO 134
 132     CONTINUE
            IBF = IQP2
            IFF1 = IQP1
            IFF2 = IQP3
            GO TO 134
 133     CONTINUE
            IBF = IQP3
            IFF1 = IQP1
            IFF2 = IQP2
 134     CONTINUE
         CALL GRNDM(RNDM,1)
         ISAM6 = 1.D0 + 3.D0*RNDM(1)
         GO TO (135,136,137),ISAM6
 135     CONTINUE
            IFB = IQT1
            IBB1 = IQT2
            IBB2 = IQT3
            GO TO 138
 136     CONTINUE
            IFB = IQT2
            IBB1 = IQT1
            IBB2 = IQT3
            GO TO 138
 137     CONTINUE
            IFB = IQT3
            IBB1 = IQT1
            IBB2 = IQT2
 138     CONTINUE
*  |  | Quark selection for incoming baryon and baryon target completed
*  +  |-->-->-->-->-->-->-->-->-->--> go to 14 continue
  14  CONTINUE
*  | Quark selection completed
*  +-------------------------------------------------------------------*

*or      IF (IPRI.EQ.1) WRITE(LUNOUT,102)IFF,IBF,IFF1,IFF2,IFB1,IFB2,
*or     &IFB,IBB,IBB1,IBB2
C
C********************************************************************
C
C*** SAMPLING MOMENTUM FRACTIONS OF QUARKS AND DIQUARKS
C
C********************************************************************
C
      IXPXT = 0
  25  CONTINUE
      IXPXT = IXPXT + 1
*  +-------------------------------------------------------------------*
*  | Selection of xp and xt from beta distribution:
*  |   xp and xt are then used to select the fraction of momentum and
*  |   energy for each jet, according to the following relations:
*  |   (where we assume to use xp, xt for the jet n. 1)
*  |
*  |      xxp = 1 - xp
*  |      xxt = 1 - xt
*  |      Ech1 = umo * (xp  + xt ) / 2
*  |      Ech2 = umo * (xxp + xxt) / 2
*  |      Pch1 = umo * (xp  - xt ) / 2
*  |      Pch2 = umo * (xxp - xxt) / 2
*  |      Amch1 = umo * sqrt (xp  * xt )
*  |      Amch2 = umo * sqrt (xxp * xxt)
*  |
      IF (IBPROJ) 21,22,23
  21  CONTINUE
*  |  Note for antibaryon projectile xp and xt are sampled from the
*  |  same distribution, ===> no difference in exchanging them!
         UNO = UNON
         XP  = BETARN(HLFHLF,UNO)
         XXP = 1.D0 - XP
         UNO = UNON
         XT  = BETARN(HLFHLF,UNO)
         XXT = 1.D0 - XT
         GO TO 24
  23  CONTINUE
*  |  Note for baryon projectile xp and xt are sampled from the
*  |  same distribution, ===> no difference in exchanging them!
         UNO = UNON
         XP  = BETARN(HLFHLF,UNO)
         XXP = 1.D0 - XP
         UNO = UNON
         XT  = BETARN(HLFHLF,UNO)
         XXT = 1.D0 - XT
         GO TO 24
  22  CONTINUE
*  |  Note for meson projectile xp and xt are not sampled from the
*  |  same distribution, ===> difference in exchanging them!
         UNO = UNOM
         IF (IFF.EQ.3 .OR. IFF.EQ.-3) UNO = UNOMS
         XP  = BETARN(HLFHLF,UNO)
         XXP = 1.D0 - XP
         IF (IBTARG .EQ. 0) GO TO 2288
            UNO = UNON
2288     CONTINUE
         XT  = BETARN(HLFHLF,UNO)
         XXT = 1.D0 - XT
  24  CONTINUE
*  |  Now xp and xt have been selected from the appropriate beta
*  |  distributions, xxp and xxt are the complements to one of xp and xt
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |  From here to 1124 it is likely to be obsolete (inucvt is now used
*  |  nowhere in the code, the same for pnuc
*  |
*or      RNDMVV=RNDM(V)
*or      IF (INUCVT.EQ.0) GO TO 1124
*or      IF (RNDMVV.LT.PNUC(1)) GO TO 1124
*or      XT=2.D0*BETARN(0.5D0,UNO+6.D0)
*or      XXT=1.D0-XT
*or      IF (XXT.LE.0.D0) XXT=RNDM(V)
*or      IF (RNDMVV.LT.PNUC(2)) GO TO 1124
*or      XT=3.D0*BETARN(0.5D0,UNO+12.D0)
*or      XXT=1.D0-XT
*or      IF (XXT.LE.0.D0) XXT=RNDM(V)
*or 1124 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*or      IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XP,XT,XXP,XXT
*or 103  FORMAT (10F10.5)
C
C********************************************************************
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C
C********************************************************************
C
****
****===================================================================*
*  |  Now selecting the kinematical parameters for the two jets:
*  |
*  |      amch1 = invariant mass of the 1st jet
*  |      ech1  = total energy of the 1st jet in CMS
*  |      pch1  = total momentum of the 1st jet in CMS (with sign)
*  |
*  |      amch2 = invariant mass of the 2nd jet
*  |      ech2  = total energy of the 2nd jet in CMS
*  |      pch2  = total momentum of the 2nd jet in CMS (with sign)
*  |
*  |  The following relations must be fulfilled:
*  |
*  |      ech1 + ech2 = umo (energy in CMS = inv. mass of the system)
*  |      ech1 = sqrt (pch1**2 + amch1**2)
*  |      ech2 = sqrt (pch2**2 + amch2**2)
*  |      pch1 + pch2 = 0
*  |
****===================================================================*
****
      IF (IBPROJ) 31,32,33
*  +-------------------------------------------------------------------*
*  |   antibaryon projectile!!! (note that only antibaryon projectile
*  |   baryon target is allowed, antibaryon projectile meson target is
*  |   considered as meson projectile antibaryon target)
*  |
  31  CONTINUE
C
C********************************************************************
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C*** ANTINUCLEON-NUCLEUON
C*** LONG ANTIDIQUARK - DIQUARK CHAIN
C
C********************************************************************
C
*  |  Ibb, ifb1, ifb2 contain the quark numbers of the target, ibf,
*  |  iff1, iff2 the quark numbers of the projectile
*  |  iff...= forward chain, forward quark (diquark)
*  |  ifb...= forward chain, backward quark (diquark)
*  |  ibf...= backward chain, forward quark
*  |  ibb...= backward chain, backward quark
*  |  By definition all i..f.. come from the projectile and all
*  |  i..b.. from the target
*  |  Of course, since we are treating an antibaryon projectile and
*  |  a baryon target all i..f.. are antiquark and all i..b.. are
*  |  quark
*  |  Of course the two following cards are equivalent to
*  |     IIFF1 = IABS (IFF1) ...
         IIFF1 = -IFF1
         IIFF2 = -IFF2
         IF (IIFF1 .EQ. IFB1) GO TO 3111
         IF (IIFF1 .EQ. IFB2) GO TO 3112
         IF (IIFF2 .EQ. IFB1) GO TO 3113
         IF (IIFF2 .EQ. IFB2) GO TO 3114
*  |    Get the index and the mass of the pseudoscalar meson corre-
*  |    sponding to the lowest energy for chain 2 ("b")
         IIBF = IABS(IBF)
         IBPS = IMPS(IIBF,IBB)
         AMBPS = AM(IBPS)
*  |  *****************************************************************
*  |    New version: of course, as it is explained below it is not    *
*  |    correct to comment the "go to 3115", however it is not correct*
*  |    also to use it in its original form, we need to compute a de- *
*  |    tailed threshold, also for the Amff value: we can believe that*
*  |    the lowest threshold is given by the two scalar mesons resul- *
*  |    ting from the combinations of the 4 quarks (iff1,iff2,ibf1,   *
*  |    ibf2).  Remember that the Imps(i,j) array gives the index of  *
*  |    the pseudoscalar meson with antiquark -i and quark j, the same*
*  |    apply to the Imve array but for vector mesons                 *
*  |    But, since bamjev it is likely to produce at least one baryon *
*  |    and one antibaryon when called with Iopt=5 (since it hadroni- *
*  |    zes a chain with a diquark and an anti-diquark at the extremi-*
*  |    ties) a more realistic threshold could be to check for the    *
*  |    masses of the baryon-antibaryon combinations corresponding to *
*  |    a uubar or a ddbar sea pair added to the original diquarks    *
*  |  *****************************************************************
*  |  Selection of the mass threshold from the two pseudoscalar mesons
*        IMPS11 = IMPS(IIFF1,IFB1)
*        IMPS21 = IMPS(IIFF2,IFB2)
*        IMPS12 = IMPS(IIFF1,IFB2)
*        IMPS22 = IMPS(IIFF2,IFB1)
*  |  Amff is selected as the maximum of the two possible meson configu-
*  |  rations, to be sure that no problem will result during frag-
*  |  mentation
*        AMFF = MAX ( AM (IMPS11) + AM (IMPS21), AM (IMPS12) +
*    &                AM (IMPS22) )
*  |  Of course at least two mesons must be produced
*  |  First check that the total invariant mass is enough (it must
*  |  be larger than the two meson masses and the pseudoscalar
*  |  meson mass of the second chain)
*        AMFF = AMFF
*  |  Selection of the mass threshold from the two baryon configura-
*  |  tions
         CALL BKLASS (-1, IFF1, IFF2, IA1F8, IA1F10 )
         CALL BKLASS ( 1, IFB1, IFB2,  I1F8,  I1F10 )
         CALL BKLASS (-2, IFF1, IFF2, IA2F8, IA2F10 )
         CALL BKLASS ( 2, IFB1, IFB2,  I2F8,  I2F10 )
         AMFF = MIN ( AM (IA1F8) + AM (I1F8), AM (IA2F8) + AM (I2F8) )
     &        + 0.3D+00
*  |  +----------------------------------------------------------------*
*  |  |  New treatment: check the mass threshold
         IF ( AMFF + AMBPS .LT. UMO ) THEN
            XSQ   = SQRT(XXP*XXT)
            AMCH1 = UMO*XSQ
            NNCH1 = 0
            AMCH2 = UMO*UMO*XP*XT
*  |  |  +------------------------------------------------------------*
*  |  |  |  Check if we have enough energy for the "f" jet
            IF ( AMCH1 .LE. AMFF .OR. AMCH2 .LE. AMBPS * AMBPS ) THEN
               IXPXT = IXPXT + 1
               IF ( IXPXT .LT. 5 ) GO TO 25
*  |  |  |   if amch1 < amfps xp and xt are resampled, but if we are
*  |  |  |   resampling too often force amch1 to be above
*  |  |  |   the minimum required, anyway the kinematic region
*  |  |  |   allowed for xp, xt seems to be marginal
*  |  |  *-->-->-->-->-->-->-->-->-->--> xp, xt resampling
               XSQ1 = ( AMFF  / UMO )**2
               XSQ2 = ( AMBPS / UMO )**2
               XXXMN = XSQ1
               XXYMX = 0.5D+00 * ( 1.D+00 + XSQ1 - XSQ2 )
               XXYMN = SQRT ( 1.D+00 - XSQ1 / ( XXYMX * XXYMX ) )
               XXXMN = MAX  ( XSQ1, XXYMX * ( ONEONE - XXYMN ) )
               XXXMX = MIN  ( 1.D+00, XXYMX * ( 1.D+00 + XXYMN ) )
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
 3161          CONTINUE
                  CALL GRNDM(RNDM,1)
                  XXP = XXXMN + ( XXXMX - XXXMN ) * RNDM (1)
                  XP  = 1.D+00 - XXP
                  XXYMN = XSQ1 / XXP
                  XXYMX = 1.D+00 - XSQ2 / XP
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( XXYMN .GT. XXYMX ) THEN
                     XXXMN = XXP
                     GO TO 3161
*  |  |  |  |-<|--<--<--<--< no allowed interval for xxt, resample
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               CALL GRNDM(RNDM,1)
               XXT = XXYMN + ( XXYMX - XXYMN ) * RNDM (1)
               XT  = 1.D+00 - XXT
               XSQ   = SQRT(XXP*XXT)
               AMCH1 = UMO*XSQ
               NNCH1 = 0
            END IF
*  |  |  |
*  |  |  +------------------------------------------------------------*
            IOPBAM = 5
            GO TO 3116
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |           We are in troubles: the selected quark combinations
*  |  |           for the two chains are unphysical since the invariant
*  |  |           mass is too low to produce the required three mesons
*  |  |           First try to change the quark combinations:
         ELSE
            CALL GRNDM(RNDM,1)
            IRNDM = 1.D+00 + RNDM (1)
            LQPROJ = .FALSE.
            LQTARG = .FALSE.
            GO TO (3171,3181) IRNDM
*  |  |  +-------------------------------------------------------------*
*  |  |  |        Try to change one of the projectile quarks in the
*  |  |  |        first chain
 3171       CONTINUE
               LQPROJ = .TRUE.
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |     The third antibaryon quark can combine with the
*  |  |  |  |     first or/and the second quark of the target diquark
               IF ( -IBF .EQ. IFB1 .OR. -IBF .EQ. IFB2 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  Make a random choiche of the quark to be substituted
                  CALL GRNDM(RNDM,1)
                  IF ( RNDM (1) .LT. 0.5D+00 ) THEN
                     IBF0 = IBF
                     IBF  = IFF1
                     IFF1 = IBF0
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     IBF0 = IBF
                     IBF  = IFF2
                     IFF2 = IBF0
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  GO TO 31
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  No possibility to solve the situation changing one of
*  |  |  |  |  the projectile quarks inside the "f" chain, try with
*  |  |  |  |  the projectile quarks (if not yet tried)
               ELSE
                  IF ( .NOT. LQTARG ) GO TO 3181
                  GO TO 3191
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |        Try to change one of the target quarks in the
*  |  |  |        first chain (for uud and udd targets this is usually
*  |  |  |        useless, but it has been included for the sake of
*  |  |  |        completness )
 3181       CONTINUE
               LQTARG = .TRUE.
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |     The third target quark can combine with the first
*  |  |  |  |     or/and the second quark of the projectile diquark
               IF ( IBB .EQ. -IFF1 .OR. IBB .EQ. -IFF2 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  Make a random choiche of the quark to be substituted
                  CALL GRNDM(RNDM,1)
                  IF ( RNDM (1) .LT. 0.5D+00 ) THEN
                     IBB0 = IBB
                     IBB  = IFB1
                     IFB1 = IBB0
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     IBB0 = IBB
                     IBB  = IFB2
                     IFB2 = IBB0
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  GO TO 31
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  No possibility to solve the situation changing one of
*  |  |  |  |  the target quarks inside the "f" chain, try with
*  |  |  |  |  the projectile quarks (if not yet tried)
               ELSE
                  IF ( .NOT. LQPROJ ) GO TO 3171
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 3191       CONTINUE
*  |  |  If we are here we cannot perform an interaction conserving
*  |  |  all additive quantum numbers: ignore one (typically it is
*  |  |  strangeness) and go on
            WRITE (LUNERR,*)
     &      ' *** Hadevv, impossible interaction, kp,kt, Umo',
     &        KPROJ,KTARG,UMO
            WRITE (LUNOUT,*)
     &      ' *** Hadevv, impossible interaction, kp,kt, Umo',
     &        KPROJ,KTARG,UMO
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  Now we want to get the indexes of the pseudo-scalar and vector
*  |  mesons which can be created from the first (forward) chain.
*  |  Of course if one of the ff quark is the antiquark of one of
*  |  fb quarks then the mesons are defined completely by the remaining
*  |  two quarks: we have anyway to deal also with the situation
*  |  were no ff quark is the antiquark of a fb quark (the goto 3115...)
*  |  which clearly requires at least two mesons!!! So no Amfps and
*  |  Amfv can be defined in this situation, and the "go to 3115" was
*  |  really important to assure that we are not producing single
*  |  particle jets which are not possible, we have only to substitute
*  |  the 1.5 threshold with the proper threshold for the two
*  |  mesons (at least the two scalar mesons): this is also true for
*  |  the Amff value which of course should be equal to the sum
*  |  of the two scalar mesons resulting from the combinations
*  |  of the 4 quarks (see above)
3111     CONTINUE
            IIFF2 = IABS(IFF2)
            IFPS  = IMPS(IIFF2,IFB2)
            IAIFF = IFF2
            IFB   = IFB2
            IFPS2 = IMPS(IIFF1,IFB1)
            IFV   = IMVE(IIFF2,IFB2)
            GO TO 3117
3112     CONTINUE
            IIFF2 = IABS(IFF2)
            IFPS  = IMPS(IIFF2,IFB1)
            IAIFF = IFF2
            IFB   = IFB1
            IFPS2 = IMPS(IIFF1,IFB2)
            IFV   = IMVE(IIFF2,IFB1)
            GO TO 3117
3113     CONTINUE
            IIFF1 = IABS(IFF1)
            IFPS  = IMPS(IIFF1,IFB2)
            IAIFF = IFF1
            IFB   = IFB2
            IFPS2 = IMPS(IIFF2,IFB1)
            IFV   = IMVE(IIFF1,IFB2)
            GO TO 3117
3114     CONTINUE
            IIFF1 = IABS(IIFF1)
            IFPS  = IMPS(IIFF1,IFB1)
            IAIFF = IFF1
            IFB   = IFB1
            IFPS2 = IMPS(IIFF2,IFB2)
            IFV   = IMVE(IIFF1,IFB1)
3117     CONTINUE
*  Amfps, amfv are the masses of the pseudoscalar and vector mesons
*  corresponding to the two unpaired quarks of the 1 (f) chain
         AMFPS = AM(IFPS)
         AMFV  = AM(IFV )
         AMFPS2= AM(IFPS2)
         NNCH1 = 0
C     ATTENTION THIS MIGHT LEAD TO TOO LOW ANNIHILATION MULTIPLICITIES
C        AMFF = AMFV+0.3D0
*        AMFF = 2.3D0
         AMFF  = MAX ( AMFV + 0.3D+00, AMFV + AMFPS2 + 0.1D+00 )
*  | This expression for Amff0 (threshold for a complete diquark-diquark
*  | jet) is not correct: this jet will fragment at least into two
*  | hadrons corresponding to the lowest energy hadrons with respecti-
*  | vely the first and the second diquark. Of corse one will be an
*  | antibaryon. It must be checked that bamjet produces a baryon-
*  | antibaryon pair any time it is called with iopt = 5 (corresponding
*  | to the fragmentation of a complete diquark-antidiquark jet)
*  | It is also questionable if it is correct to call bamjet with
*  | iopt=5 whenever energetically possible: this clearly implies
*  | that no annihilation takes place (an antibaryon will emerge
*  | from the interaction). This is a question to be addressed
*  | to Hannes!!
*        AMFF0 = 2.D+00 * AMFF
*  | A tentative way could be to check for the masses of the
*  | baryon-antibaryon combinations corresponding to a uubar
*  | or a ddbar sea pair
         CALL BKLASS (-1, IFF1, IFF2, IA1F8, IA1F10 )
         CALL BKLASS ( 1, IFB1, IFB2,  I1F8,  I1F10 )
         CALL BKLASS (-2, IFF1, IFF2, IA2F8, IA2F10 )
         CALL BKLASS ( 2, IFB1, IFB2,  I2F8,  I2F10 )
         AMFF0 = MIN ( AM (IA1F8) + AM (I1F8), AM (IA2F8) + AM (I2F8) )
     &         + 0.3D+00
*  |
*  |  here xxt and xxp are used for the first jet
*  |
         XSQ  = SQRT(XXP*XXT)
         AMCH1 = UMO*XSQ
         AAPS  = IFPS
         AAV  = IFV
*or         IF (IPRI.EQ.1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2,AAPS,AAV,
*or     &                                   AMFPS,AMFV

*  |  +----------------------------------------------------------------*
*  |  |
         IF (AMCH1 .LT. AMFPS) GO TO 25
*  |  |   if amch1 < amfps xp and xt are resampled
*  |  *-->-->-->-->-->-->-->-->-->--> xp, xt resampling

*  |  Kinematical parameters xxp, xxt for the 1st jet
         IF (AMCH1 .GT. AMFV ) GO TO 3151
C*** PRODUCE AMFPS
            AMCH1 = AMFPS
            NNCH1 = -1
            XSQ = AMFPS/UMO
*  |  |  recalculating xxp, xp
            XXP = XSQ**2/XXT
            XP  = 1.D0 - XXP
            GO TO 3153
3151     CONTINUE
         IF (AMCH1 .GT. AMFF) GO TO 3153
C*** PRODUCE AMFV
            AMCH1 = AMFV
            NNCH1 = 1
            XSQ = AMFV/UMO
*  |  |  recalculating xxp, xp
            XXP = XSQ**2/XXT
            XP  = 1.D0 - XXP
            GO TO 3153
3153     CONTINUE
         IF (AMCH1 .LE. AMFF0) THEN
            IOPBAM = 3
         ELSE
            IOPBAM = 5
         END IF
         GO TO 3116
3116     CONTINUE
C
C********************************************************************
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C     ANTINUCLEON NUCLEON
C*** SHORT ANTIQUARK - QUARK CHAIN
C
C********************************************************************
C
         IIBF = IABS(IBF)
         IBPS = IMPS(IIBF,IBB)
         IBV  = IMVE(IIBF,IBB)
         AMBPS = AM(IBPS)
         AMBV  = AM(IBV)
         NNCH2 = 0
         AMBB = AMBV + 0.3D0
         AAPS = IBPS
         AAV  = IBV
*  |  +----------------------------------------------------------------*1
*  |  |
*  |  | Now commented, is useless!!!
*         IF (XP .LE. 0.D0 .OR. XT .LE. 0.D0) GO TO 25
*  |  | resample xp and xt if one is negative or zero
*  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

*  |  Now xp and xt are used for the second jet
         XXSQ  = SQRT(XP*XT)
         AMCH2 = UMO*XXSQ
*or         IF (IPRI.EQ.1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &                  ,AAPS,AAV,AMBPS,AMBV

*  |  +----------------------------------------------------------------*
*  |  |
         IF (AMCH2 .LT. AMBPS) THEN
            IXPXT = IXPXT + 1
            GO TO 25
*  |  |   if amch1 < amfps xp and xt are resampled
*  |  *-->-->-->-->-->-->-->-->-->--> xp, xt resampling
         END IF
*  |  |
*  |  +----------------------------------------------------------------*

         IF (AMCH2 .GT. AMBV ) GO TO 3121
C*** PRODUCE AMBPS
* For Prof. Ranft: here there was a "large" mistake, amch2 = ambps
* was missing
            AMCH2 = AMBPS
            NNCH2 = -1
            XXSQ  = AMBPS/UMO
*or            IF (INUCVT .EQ. 1) GO TO 3123
            GO TO 31236
3121     CONTINUE
         IF (AMCH2 .GT. AMBB) GO TO 3123
C*** PRODUCE AMBV
            AMCH2 = AMBV
            NNCH2 = 1
            XXSQ  = AMBV/UMO
*or            IF (INUCVT .EQ. 1) GO TO 3123
            GO TO 31236
*  |  +----------------------------------------------------------------*
*  |  |  Here adjusting kinematics!!!!!
*  |  |  Now, chain 2 is a single particle jet, so we have to reset the
*  |  |  kinematical parameters xp, xxp, xt and xxt
*  |  |
31236       CONTINUE
            XXSQ2  = XXSQ  * XXSQ
*  |  |  +-------------------------------------------------------------*
*  |  |  |  If also chain 1 is a parjet (nnch1 .ne. 0) then the paramet.
*  |  |  |  to be recomputed are xp and xt, from alpha and beta, in
*  |  |  |  such a way to conserve the original momentum direction
*  |  |  |
            IF (NNCH1 .NE. 0) THEN
               XSQ2 = XSQ * XSQ
               HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 * (XXSQ2 - 2.D0)
     &                 - 2.D0 * XSQ2 * XXSQ2
               DDIFF = SQRT (HELP + 1.D0)
               SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XXSQ2)
               ALPHA = (SSUM + DDIFF) * 0.5D0
               BETA  = (SSUM - DDIFF) * 0.5D0
               IF (XP .GT. XT) THEN
                  XP  = ALPHA
                  XT  = BETA
               ELSE
                  XT  = ALPHA
                  XP  = BETA
               END IF
               XXP = 1.D0 - XP
               XXT = 1.D0 - XT
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            ELSE
*  |  |  +-------------------------------------------------------------*
*  |  |  |  If chain 1 is not a parjet (nnch1 .eq. 0) then the paramet.
*  |  |  |  xp, xt are to be recomputed in such a way to conserve the
*  |  |  |  original momentum direction and modulus
*  |  |  |
               DDIFF = XP  - XT
               SSUM  = SQRT (4.D0 * XXSQ2 + DDIFF**2)
               XP  = (SSUM + DDIFF) * 0.5D0
               XT  = (SSUM - DDIFF) * 0.5D0
               XXP = 1.D0 - XP
               XXT = 1.D0 - XT
               XSQ   = SQRT (XXP * XXT)
               AMCH1 = XSQ * UMO
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |                             end kinematics correction
*  |  +----------------------------------------------------------------*

3123     CONTINUE
C
         PCH1 = UMO*(XXP - XXT)*.5D0
         ECH1 = UMO*(XXP + XXT)*.5D0
         GAMCH1 = ECH1/AMCH1
         BGCH1  = PCH1/AMCH1
         PCH2 = UMO*(XP - XT)*.5D0
         ECH2 = UMO*(XP + XT)*.5D0
         GAMCH2 = ECH2/AMCH2
         BGCH2  = PCH2/AMCH2
         GO TO 34
*  |              end kin. sel. for antibaryon projectile
*  +-->-->-->-->-->-->-->-->-->--> go to 34

*  +-------------------------------------------------------------------*
*  |   baryon projectile!!!
*  |
  33  CONTINUE
C
C********************************************************************
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C*** NUCLEON - NUCLEON
C*** FORWARD DIQUARK - QUARK CHAIN
C
C********************************************************************
C
         GO TO 332
*  |
*  +-->-->-->-->-->-->-->-->-->--> jump # 1 to 332

*  +--<--<--<--<--<--<--<--<--<--< here from jump # 3
*  |

3310     CONTINUE
         CALL BKLASS (IFB,IFF1,IFF2,IF8,IF10)
         AMF8  = AM(IF8)
         AMF10 = AM(IF10)
         AMFF  = AMF10 + 0.3D0
         NNCH1 = 0
*  |  here xxp, xt are used for the jet # 1
         XSQ = SQRT(ABS(XXP*XT))
         AMCH1 = UMO*XSQ
         AA8   = IF8
         AA10  = IF10
*or         IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &                  ,AA8,AA10,AMF8,AMF10

*  |  +----------------------------------------------------------------*
*  |  | This check added by A. Ferrari, to avoid negative x(x)p or
*  |  | x(x)t !!!!!?????? Maybe also "go to 33366" if we want to create
*  |  | the jet anyway
* I (A. Ferrari) think this check was missing and is
* actually needed, else we can get negative energies
         IF (AMCH1 .LT. AMF8) GO TO 25
*  |  |   if amch1 < amf8 xp and xt are resampled
*  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

         IF (AMCH1 .GT. AMF10) GO TO 331
C*** PRODUCE AMF8
            AMCH1 = AMF8
            NNCH1 = -1
            XSQ = AMF8/UMO
            GO TO 33366
 331     CONTINUE
         IF (AMCH1 .GT. AMFF) GO TO 333
C*** PRODUCE AMF10
            AMCH1 = AMF10
            NNCH1 = 1
            XSQ = AMF10/UMO
            GO TO 33366
*  |  +----------------------------------------------------------------*
*  |  |  Here adjusting kinematics!!!!!
*  |  |  Now, chain 1 is a single particle jet, so we have to reset the
*  |  |  kinematical parameters xp, xxp, xt and xxt
*  |  |
33366       CONTINUE
            XSQ2  = XSQ  * XSQ
*  |  |  +-------------------------------------------------------------*
*  |  |  |  If also chain 2 is a parjet (nnch2 .ne. 0) then the paramet.
*  |  |  |  to be recomputed are xxp and xt, from alpha and beta, in
*  |  |  |  such a way to conserve the original momentum direction
*  |  |  |
            IF (NNCH2 .NE. 0) THEN
               XXSQ2 = XXSQ * XXSQ
               HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 * (XXSQ2 - 2.D0)
     &                 - 2.D0 * XSQ2 * XXSQ2
               DDIFF = SQRT (HELP + 1.D0)
               SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XSQ2)
               ALPHA = (SSUM + DDIFF) * 0.5D0
               BETA  = (SSUM - DDIFF) * 0.5D0
               IF (XXP .GT. XT) THEN
                  XXP = ALPHA
                  XT  = BETA
               ELSE
                  XT  = ALPHA
                  XXP = BETA
               END IF
               XP  = 1.D0 - XXP
               XXT = 1.D0 - XT
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            ELSE
*  |  |  +-------------------------------------------------------------*
*  |  |  |  If chain 2 is not a parjet (nnch2 .eq. 0) then the paramet.
*  |  |  |  xxp,xt have to be recomputed in such a way to conserve the
*  |  |  |  original momentum direction and modulus
*  |  |  |
               DDIFF = XXP - XT
               SSUM  = SQRT (4.D0 * XSQ2 + DDIFF**2)
               XXP = (SSUM + DDIFF) * 0.5D0
               XT  = (SSUM - DDIFF) * 0.5D0
               XP  = 1.D0 - XXP
               XXT = 1.D0 - XT
               XXSQ  = SQRT (XP * XXT)
               AMCH2 = XXSQ * UMO
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |                             end kinematics correction
*  |  +----------------------------------------------------------------*

 333     CONTINUE
*  |  we are using xp and xxt for chain 2
         PCH1 = UMO*(XXP - XT)*.5D0
         ECH1 = UMO*(XXP + XT)*.5D0
         GAMCH1 = ECH1/AMCH1
         BGCH1  = PCH1/AMCH1
         PCH2 = UMO*(XP - XXT)*.5D0
         ECH2 = UMO*(XP + XXT)*.5D0
         GAMCH2 = ECH2/AMCH2
         BGCH2  = PCH2/AMCH2
         GO TO 34
*  |              end kin. sel. for baryon projectile
*  +-->-->-->-->-->-->-->-->-->--> go to 34

C
C********************************************************************
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C     NUCLEON NUCLEON
C*** BACKWARD QUARK - DIQUARK CHAIN
C
C********************************************************************
C
*  +--<--<--<--<--<--<--<--<--<--< here from the previous jump # 1
*  |
 332     CONTINUE
*  |  Starting from chain # 2!!!
         CALL BKLASS (IBF,IBB1,IBB2,IB8,IBIO)
         NNCH2 = 0
         AMB8  = AM(IB8)
         AMB10 = AM(IBIO)
         AMBB  = AMB10 + 0.3D0
*  |  here xp, xxt are used for the jet # 2
         XXSQ  = SQRT(XP*XXT)
         AMCH2 = UMO*XXSQ
         AAB8  = IB8
         AAB10 = IBIO
*or         IF (IPRI.EQ.1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &                  ,AAB8,AAB10,AMB8,AMB10

*  |  +----------------------------------------------------------------*
*  |  | This check added by A. Ferrari, to avoid negative x(x)p or
*  |  | x(x)t !!!!!??????  Maybe also "go to 335" if we want to create
*  |  | the jet anyway
* I (A. Ferrari) think this check was missing and is
* actually needed, else we can get negative energies
         IF (AMCH2 .LT. AMB8) GO TO 25
*  |  |   if amch2 < amb8 xp and xt are resampled
*  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

         IF (AMCH2 .GT. AMB10) GO TO 334
C*** PRODUCE AMB8
            AMCH2 = AMB8
            NNCH2 = -1
            XXSQ = AMB8/UMO
            XP   = XXSQ**2/XXT
            XXP  = 1.D0 - XP
            GO TO 335
 334     CONTINUE
         IF (AMCH2 .GT. AMBB) GO TO 335
C*** PRODUCE AMB10
            AMCH2 = AMB10
            NNCH2 = 1
            XXSQ = AMB10/UMO
            XP   = XXSQ**2/XXT
            XXP  = 1.D0 - XP

C     PCH1=UMO*(XXP-XT)*.5D0
C     ECH1=UMO*(XXP+XT)*.5D0
C     GAMCH1=ECH1/AMCH1
C     BGCH1=PCH1/AMCH1
C     GO TO 335

 335     CONTINUE
         GO TO 3310
*  |
*  +-->-->-->-->-->-->-->-->-->--> jump # 3 to 3310

*  +-------------------------------------------------------------------*
*  |   meson projectile!!!
*  |
  32  CONTINUE
C
C********************************************************************
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C*** MESON NUCLEON
C
C********************************************************************
C
         IF (IBTARG)3277,3288,3299
*  |  +----------------------------------------------------------------*
*  |  |  meson projectile, baryon target!!!!
*  |  |
3299     CONTINUE
            GO TO (321,325),ISAM3
*  |  |  +-------------------------------------------------------------*
*  |  |  |  meson projectile, baryon target, isam3 = 1
*  |  |  |
 321        CONTINUE
C*** MESON NUCLEON Q(XXP)-QQ(XXT)+AQ(XP-Q(XT)
               GO TO 322
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 4 to 322

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 5
*  |  |  |
3259           CONTINUE
C=================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C      MESON NUCLEON
C*** FIRST LONG Q(XXP)-QQ(XXT) CHAIN
C
C===================================================================
               CALL BKLASS (IFF,IFB1,IFB2,IF8,IFIO)
               AMF8  = AM(IF8)
               AMF10 = AM(IFIO)
               NNCH1 = 0
               AMFF  = AMF10 + 0.3D0
*  |  here xxp, xxt are used for the jet # 1
               XSQ   = SQRT(XXP*XXT)
               AMCH1 = UMO*XSQ
               AA8   = IF8
               AA10  = IFIO
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AA8,AA10,AMF8,AMF10

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH1 .LT. AMF8) GO TO 25
*  |  |  |  | if amch1 < amf8 xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH1 .GT. AMF10) GO TO 3211
C*** PRODUCE AMF8
                  AMCH1 = AMF8
                  NNCH1 = -1
                  XSQ = AMF8/UMO
                  GO TO 32136
3211           CONTINUE
               IF (AMCH1 .GT. AMFF) GO TO 3213
C*** PRODUCE AMF10
                  AMCH1 = AMF10
                  NNCH1 = 1
                  XSQ = AMF10/UMO
                  GO TO 32136
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Here adjusting kinematics!!!!!
*  |  |  |  |  Now, chain 1 is a single particle jet, so we have to
*  |  |  |  |  reset the kinematical parameters xp, xxp, xt and xxt
*  |  |  |  |
32136             CONTINUE
                  XSQ2  = XSQ  * XSQ
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If also chain 2 is a parjet (nnch2 .ne. 0) then the
*  |  |  |  |  |  param. to be recomputed are xxp and xxt, from alpha
*  |  |  |  |  |  and beta, in such a way to conserve the original
*  |  |  |  |  |  momentum direction
*  |  |  |  |  |
                  IF (NNCH2 .NE. 0) THEN
                     XXSQ2 = XXSQ * XXSQ
                     HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 *
     &                      (XXSQ2 - 2.D0) - 2.D0 * XSQ2 * XXSQ2
                     DDIFF = SQRT (HELP + 1.D0)
                     SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XSQ2)
                     ALPHA = (SSUM + DDIFF) * 0.5D0
                     BETA  = (SSUM - DDIFF) * 0.5D0
                     IF (XXP .GT. XXT) THEN
                         XXP = ALPHA
                         XXT = BETA
                     ELSE
                         XXT = ALPHA
                         XXP = BETA
                     END IF
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  ELSE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If chain 2 is not a parjet (nnch2 .eq. 0) then the
*  |  |  |  |  |  paramet. xxp,xxt have to be recomputed in such a way
*  |  |  |  |  |  to conserve the original momentum direction and
*  |  |  |  |  |  modulus
*  |  |  |  |  |
                     DDIFF = XXP - XXT
                     SSUM  = SQRT (4.D0 * XSQ2 + DDIFF**2)
                     XXP = (SSUM + DDIFF) * 0.5D0
                     XXT  = (SSUM - DDIFF) * 0.5D0
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
                     XXSQ  = SQRT (XP * XT)
                     AMCH2 = XXSQ * UMO
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |                       end kinematics correction
*  |  |  |  +----------------------------------------------------------*

3213           CONTINUE
               PCH1 = UMO*(XXP - XXT)*.5D0
               ECH1 = UMO*(XXP + XXT)*.5D0
               GAMCH1 = ECH1/AMCH1
               BGCH1  = PCH1/AMCH1
               PCH2 = UMO*(XP - XT)*.5D0
               ECH2 = UMO*(XP + XT)*.5D0
               GAMCH2 = ECH2/AMCH2
               BGCH2  = PCH2/AMCH2
               GO TO 34
*  |  |  | end kin. sel. for meson proj. (baryon target), isam3 = 1
*  |  |  +-->-->-->-->-->-->-->-->-->--> go to 34

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 4
*  |  |  |
 322           CONTINUE
C===============================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C       MESON NUCLEON
C*** SHORT AQ(XP)-Q(XT) CHAIN
C
C================================================================
               IIBF = IABS(IBF)
               IBPS = IMPS(IIBF,IBB)
               IBV  = IMVE(IIBF,IBB)
               AMBPS = AM(IBPS)
               AMBV  = AM(IBV)
               NNCH2 = 0
               AMBB  = AMBV + 0.3D0
*  |  here xp, xt are used for the jet # 2
               XXSQ  = SQRT(XP*XT)
               AMCH2 = UMO*XXSQ
               AAPS  = IBPS
               AAV   = IBV
*or               IF (IPRI.EQ.1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AAPS,AAV,AMBPS,AMBV

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH2 .LT. AMBPS) GO TO 25
*  |  |  |  | if amch2 < ambps xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH2 .GT. AMBV) GO TO 3221
C*** PRODUCE AMBPS
                  AMCH2 = AMBPS
                  NNCH2 = -1
                  XXSQ  = AMBPS/UMO
                  XT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 3223
                  XXT = 1.D0 - XT
                  GO TO 3223
3221           CONTINUE
               IF (AMCH2 .GT. AMBB) GO TO 3223
C*** PRODUCE AMBV
                  AMCH2 = AMBV
                  NNCH2 = 1
                  XXSQ  = AMBV/UMO
                  XT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 3223
                  XXT = 1.D0 - XT

C     PCH1=UMO*(XXP-XXT)*.5D0
C     ECH1=UMO*(XXP+XXT)*.5D0
C     GAMCH1=ECH1/AMCH1
C     BGCH1=PCH1/AMCH1
C     GO TO 3223

3223           CONTINUE
               GO TO 3259
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 5 to 3259

*  |  |  +-------------------------------------------------------------*
*  |  |  |  meson projectile, baryon target, isam3 = 2
*  |  |  |
 325        CONTINUE
C=================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C*** MESON NUCLEUS
C*** FORWARD ANTIQUARK-DIQUARK CHAIN
C
C=================================================================
               GO TO 326
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 6 to 326

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 7
*  |  |  |
3250           CONTINUE
C*** MESON NUCLEON FORWARD AQ(XXP)-Q(XT) AND BACKWARD CHAINS Q(XP)-QQ(
C*** XXT) CHAINS
C=====================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C     MESON NUCLEON
C*** FORWARD AQ(XXP)-Q(XT) CHAIN
C
C====================================================================
               IIFF = IABS(IFF)
               IFPS = IMPS(IIFF,IFB)
               IFV  = IMVE(IIFF,IFB)
               AMFPS = AM(IFPS)
               AMFV  = AM(IFV)
               NNCH1 = 0
               AMFF = AMFV + 0.3D0
*  |  |  |  here xxp, xt are used for the jet # 1
               XSQ  = SQRT(XXP*XT)
               AMCH1 = UMO*XSQ
               AAPS  = IFPS
               AAV   = IFV
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AAPS,AAV,AMFPS,AMFV

*  |  |  +-------------------------------------------------------------*
*  |  |  |
               IF (AMCH1 .LT. AMFPS) GO TO 25
*  |  |  | if amch1 < amfps xp and xt are resampled
*  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH1 .GT. AMFV) GO TO 3251
C*** PRODUCE AMFPS
                  AMCH1 = AMFPS
                  NNCH1 = -1
                  XSQ = AMFPS/UMO
                  GO TO 32536
3251           CONTINUE
               IF (AMCH1.GT.AMFF) GO TO 3253
C*** PRODUCE AMFV
                  AMCH1 = AMFV
                  NNCH1 = 1
                  XSQ = AMFV/UMO
                  GO TO 32536
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Here adjusting kinematics!!!!!
*  |  |  |  |  Now, chain 1 is a single particle jet, so we have to
*  |  |  |  |  reset the kinematical parameters xp, xxp, xt and xxt
*  |  |  |  |
32536             CONTINUE
                  XSQ2  = XSQ  * XSQ
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If also chain 2 is a parjet (nnch2 .ne. 0) then the
*  |  |  |  |  |  param. to be recomputed are xxp and xt, from alpha
*  |  |  |  |  |  and beta, in such a way to conserve the original
*  |  |  |  |  |  momentum direction
*  |  |  |  |  |
                  IF (NNCH2 .NE. 0) THEN
                     XXSQ2 = XXSQ * XXSQ
                     HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 *
     &                      (XXSQ2 - 2.D0) - 2.D0 * XSQ2 * XXSQ2
                     DDIFF = SQRT (HELP + 1.D0)
                     SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XSQ2)
                     ALPHA = (SSUM + DDIFF) * 0.5D0
                     BETA  = (SSUM - DDIFF) * 0.5D0
                     IF (XXP .GT. XT) THEN
                         XXP = ALPHA
                         XT  = BETA
                     ELSE
                         XT  = ALPHA
                         XXP = BETA
                     END IF
                     XP  = 1.D0 - XXP
                     XXT = 1.D0 - XT
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  ELSE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If chain 2 is not a parjet (nnch2 .eq. 0) then the
*  |  |  |  |  |  paramet. xxp,xt have to be recomputed in such a way
*  |  |  |  |  |  to conserve the original momentum direction and
*  |  |  |  |  |  modulus
*  |  |  |  |  |
                     DDIFF = XXP - XT
                     SSUM  = SQRT (4.D0 * XSQ2 + DDIFF**2)
                     XXP = (SSUM + DDIFF) * 0.5D0
                     XT  = (SSUM - DDIFF) * 0.5D0
                     XP  = 1.D0 - XXP
                     XXT = 1.D0 - XT
                     XXSQ  = SQRT (XP * XXT)
                     AMCH2 = XXSQ * UMO
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |                       end kinematics correction
*  |  |  |  +----------------------------------------------------------*

3253           CONTINUE
               PCH1 = UMO*(XXP - XT)*.5D0
               ECH1 = UMO*(XXP + XT)*.5D0
               GAMCH1 = ECH1/AMCH1
               BGCH1  = PCH1/AMCH1
               PCH2 = UMO*(XP - XXT)*.5D0
               ECH2 = UMO*(XP + XXT)*.5D0
               GAMCH2 = ECH2/AMCH2
               BGCH2  = PCH2/AMCH2
               GO TO 34
*  |  |  | end kin. sel. for meson proj. (baryon target), isam3 = 2
*  |  |  +-->-->-->-->-->-->-->-->-->--> go to 34

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 6
*  |  |  |
 326           CONTINUE
C*** BACKWARD Q(XP)-QQ(XXT) CHAIN
               CALL BKLASS (IBF,IBB1,IBB2,IB8,IBIO)
               AMB8  = AM(IB8)
               AMB10 = AM(IBIO)
               NNCH2 = 0
               AMBB  = AMB10 + 0.3D0
C===================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C      MESON NUCLEON
C*** BACKWARD QUARK -DIQUARK CHAIN
C
C====================================================================
*  |  |  |  here xp, xxt are used for the jet # 2
               XXSQ  = SQRT(XP*XXT)
               AMCH2 = UMO*XXSQ
               AA8   = IB8
               AA10  = IBIO
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XXSQ,AMCH1,AMCH2
*or     &         ,AA8,AA10,AMB8,AMB10

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH2 .LT. AMB8 ) GO TO 25
*  |  |  |  |  if amch2 < amb8 xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH2 .GT. AMB10) GO TO 3261
C*** PRODUCE AMB8
                  AMCH2 = AMB8
                  NNCH2 = -1
                  XXSQ = AMB8/UMO
                  XXT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 3263
                  XT  = 1.D0 - XXT
                  GO TO 3263
3261           CONTINUE
               IF (AMCH2 .GT. AMBB) GO TO 3263
C*** PRODUCE AMB10
                  AMCH2 = AMB10
                  NNCH2 = 1
                  XXSQ = AMB10/UMO
                  XXT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 3263
                  XT  = 1.D0 - XXT

C     PCH1=UMO*(XXP-XT)*.5D0
C     ECH1=UMO*(XXP+XT)*.5D0
C     GAMCH1=ECH1/AMCH1
C     BGCH1=PCH1/AMCH1

                  GO TO 3263
3263           CONTINUE
               GO TO 3250
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 7 to 3250
*  |  +----------------------------------------------------------------*
*  |
*  |  +----------------------------------------------------------------*
*  |  |  Meson projectile, meson target!!!
*  |  |
3288     CONTINUE

C================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C           MESON MESON
C
C================================================================
            CALL GRNDM(RNDM,1)
            IF (RNDM(1) .LE. 0.5D0) GO TO 93288
               XT  = XXT
               XXT = 1.D0 - XT
93288       CONTINUE
            GO TO (3218,3258),ISAM3
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Meson projectile, meson target, isam3 = 1
*  |  |  |
3218        CONTINUE
C==================================================================
C*** MESON MESON Q(XXP)-AQ(XXT)+AQ(XP)-Q(XT)
C=================================================================
               GO TO 3228
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 8 to 3228

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 9
*  |  |  |
32598          CONTINUE
C=================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C      MESON MESON
C*** FIRST LONG Q(XXP)-AQ(XXT) CHAIN
C
C===================================================================
               IIFB = IABS(IFB)
               IFPS = IMPS(IIFB,IFF)
               IFV  = IMVE(IIFB,IFF)
               AMFPS = AM(IFPS)
*  |  |  |  Of course AMPV seems to be a mistyping for AMFV
*              AMPV  = AM(IFV)
               AMFV  = AM(IFV)
               NNCH1 = 0
               AMFF = AMFV + 0.3D0
*  |  |  |  here we are using xxp, xxt for the jet # 1
               XSQ  = SQRT(XXP*XXT)
               AMCH1 = UMO*XSQ
               AAPS  = IFPS
               AAV   = IFV
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AAPS,AAV,AMFPS,AMFV

*  |  |  +-------------------------------------------------------------*
*  |  |  |
               IF (AMCH1 .LT. AMFPS) GO TO 25
*  |  |  | if amch2 < amfps xp and xt are resampled
*  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH1 .GT. AMFV ) GO TO 32118
C*** PRODUCE AMFPS
                  AMCH1 = AMFPS
                  NNCH1 = -1
                  XSQ = AMFPS/UMO
                  GO TO 32133
32118          CONTINUE
               IF (AMCH1 .GT. AMFF) GO TO 32138
C*** PRODUCE AMFV
                  AMCH1 = AMFV
                  NNCH1 = 1
                  XSQ = AMFV/UMO
                  GO TO 32133
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Here adjusting kinematics!!!!!
*  |  |  |  |  Now, chain 1 is a single particle jet, so we have to
*  |  |  |  |  reset the kinematical parameters xp, xxp, xt and xxt
*  |  |  |  |
32133             CONTINUE
                  XSQ2  = XSQ  * XSQ
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If also chain 2 is a parjet (nnch2 .ne. 0) then the
*  |  |  |  |  |  param. to be recomputed are xxp and xxt, from alpha
*  |  |  |  |  |  and beta, in such a way to conserve the original
*  |  |  |  |  |  momentum direction
*  |  |  |  |  |
                  IF (NNCH2 .NE. 0) THEN
                     XXSQ2 = XXSQ * XXSQ
                     HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 *
     &                      (XXSQ2 - 2.D0) - 2.D0 * XSQ2 * XXSQ2
                     DDIFF = SQRT (HELP + 1.D0)
                     SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XSQ2)
                     ALPHA = (SSUM + DDIFF) * 0.5D0
                     BETA  = (SSUM - DDIFF) * 0.5D0
                     IF (XXP .GT. XXT) THEN
                         XXP = ALPHA
                         XXT = BETA
                     ELSE
                         XXT = ALPHA
                         XXP = BETA
                     END IF
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  ELSE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If chain 2 is not a parjet (nnch2 .eq. 0) then the
*  |  |  |  |  |  paramet. xxp,xxt have to be recomputed in such a way
*  |  |  |  |  |  to conserve the original momentum direction and
*  |  |  |  |  |  modulus
*  |  |  |  |  |
                     DDIFF = XXP - XXT
                     SSUM  = SQRT (4.D0 * XSQ2 + DDIFF**2)
                     XXP = (SSUM + DDIFF) * 0.5D0
                     XXT = (SSUM - DDIFF) * 0.5D0
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
                     XXSQ  = SQRT (XP * XT)
                     AMCH2 = XXSQ * UMO
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |                       end kinematics correction
*  |  |  |  +----------------------------------------------------------*

32138          CONTINUE
               PCH1 = UMO*(XXP - XXT)*.5D0
               ECH1 = UMO*(XXP + XXT)*.5D0
               GAMCH1 = ECH1/AMCH1
               BGCH1  = PCH1/AMCH1
               PCH2 = UMO*(XP - XT)*.5D0
               ECH2 = UMO*(XP + XT)*.5D0
               GAMCH2 = ECH2/AMCH2
               BGCH2  = PCH2/AMCH2
               GO TO 348
*  |  |  | end kin. sel. for meson proj. (meson target), isam3 = 1
*  |  |  +-->-->-->-->-->-->-->-->-->--> go to 348

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 8
*  |  |  |
3228           CONTINUE
C===============================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C       MESON MESON
C*** SHORT AQ(XP)-Q(XT) CHAIN
C
C================================================================
               IIBF = IABS(IBF)
               IBPS = IMPS(IIBF,IBB)
               IBV  = IMVE(IIBF,IBB)
               AMBPS = AM(IBPS)
               AMBV  = AM(IBV)
               NNCH2 = 0
               AMBB  = AMBV + 0.3D0
*  |  |  |  here we are using xp, xt for the jet # 2
               XXSQ  = SQRT(XP*XT)
               AMCH2 = UMO*XXSQ
               AAPS = IBPS
               AAV  = IBV
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XXSQ,AMCH1,AMCH2
*or     &         ,AAPS,AAV,AMBPS,AMBV

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH2 .LT. AMBPS) GO TO 25
*  |  |  |  | if amch2 < ambps xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH2 .GT. AMBV ) GO TO 32218
C*** PRODUCE AMBPS
                  AMCH2 = AMBPS
                  NNCH2 = -1
                  XXSQ  = AMBPS/UMO
                  XT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 32238
                  XXT = 1.D0 - XT
                  GO TO 32238
32218          CONTINUE
               IF (AMCH2 .GT. AMBB) GO TO 32238
C*** PRODUCE AMBV
                  AMCH2 = AMBV
                  NNCH2 = 1
                  XXSQ  = AMBV/UMO
                  XT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 32238
                  XXT = 1.D0 - XT

C     PCH1=UMO*(XXP-XXT)*.5D0
C     ECH1=UMO*(XXP+XXT)*.5D0
C     GAMCH1=ECH1/AMCH1
C     BGCH1=PCH1/AMCH1
C     GO TO 32238

32238          CONTINUE
               GO TO 32598
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 9 to 32598

*  |  |  +-------------------------------------------------------------*
*  |  |  |  Meson projectile, meson target, isam3 = 2
*  |  |  |
3258        CONTINUE
C=================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C*** MESON MESON
C*** FORWARD ANTIQUARK-DIQUARK CHAIN
C
C=================================================================
               GO TO 3268
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 10 to 3268

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 11
*  |  |  |
32508          CONTINUE
C===================================================================
C*** MESON MESON FORWARD AQ(XXP)-Q(XT) AND BACKWARD CHAINS Q(XP)-AQ(
C*** XXT) CHAINS
C====================================================================
C=====================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C     MESON MESON
C*** FORWARD AQ(XXP)-Q(XT) CHAIN
C
C====================================================================
               IIFF = IABS(IFF)
               IFPS = IMPS(IIFF,IFB)
               IFV  = IMVE(IIFF,IFB)
               AMFPS = AM(IFPS)
               AMFV  = AM(IFV)
               NNCH1 = 0
               AMFF  = AMFV + 0.3D0
*  |  |  |  here we are using xxp, xt for the jet # 1
               XSQ   = SQRT(XXP*XT)
               AMCH1 = UMO*XSQ
               AAPS = IFPS
               AAV  = IFV
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AAPS,AAV,AMFPS,AMFV

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH1 .LT. AMFPS) GO TO 25
*  |  |  |  | if amch1 < amfps xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH1 .GT. AMFV) GO TO 32518
C*** PRODUCE AMFPS
                  AMCH1 = AMFPS
                  NNCH1 = -1
                  XSQ = AMFPS/UMO
                  GO TO 32535
32518          CONTINUE
               IF (AMCH1 .GT. AMFF) GO TO 32538
C*** PRODUCE AMFV
                  AMCH1 = AMFV
                  NNCH1 = 1
                  XSQ = AMFV/UMO
                  GO TO 32535
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Here adjusting kinematics!!!!!
*  |  |  |  |  Now, chain 1 is a single particle jet, so we have to
*  |  |  |  |  reset the kinematical parameters xp, xxp, xt and xxt
*  |  |  |  |
32535             CONTINUE
                  XSQ2  = XSQ  * XSQ
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If also chain 2 is a parjet (nnch2 .ne. 0) then the
*  |  |  |  |  |  param. to be recomputed are xxp and xt, from alpha
*  |  |  |  |  |  and beta, in such a way to conserve the original
*  |  |  |  |  |  momentum direction
*  |  |  |  |  |
                  IF (NNCH2 .NE. 0) THEN
                     XXSQ2 = XXSQ * XXSQ
                     HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 *
     &                      (XXSQ2 - 2.D0) - 2.D0 * XSQ2 * XXSQ2
                     DDIFF = SQRT (HELP + 1.D0)
                     SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XSQ2)
                     ALPHA = (SSUM + DDIFF) * 0.5D0
                     BETA  = (SSUM - DDIFF) * 0.5D0
                     IF (XXP .GT.  XT) THEN
                         XXP = ALPHA
                         XT  = BETA
                     ELSE
                         XT  = ALPHA
                         XXP = BETA
                     END IF
                     XP  = 1.D0 - XXP
                     XXT = 1.D0 - XT
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  ELSE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If chain 2 is not a parjet (nnch2 .eq. 0) then the
*  |  |  |  |  |  paramet. xxp,xt have to be recomputed in such a way
*  |  |  |  |  |  to conserve the original momentum direction and
*  |  |  |  |  |  modulus
*  |  |  |  |  |
                     DDIFF = XXP - XT
                     SSUM  = SQRT (4.D0 * XSQ2 + DDIFF**2)
                     XXP = (SSUM + DDIFF) * 0.5D0
                     XT  = (SSUM - DDIFF) * 0.5D0
                     XP  = 1.D0 - XXP
                     XXT = 1.D0 - XT
                     XXSQ  = SQRT (XP * XXT)
                     AMCH2 = XXSQ * UMO
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |                       end kinematics correction
*  |  |  |  +----------------------------------------------------------*

32538          CONTINUE
               PCH1 = UMO*(XXP - XT)*.5D0
               ECH1 = UMO*(XXP + XT)*.5D0
               GAMCH1 = ECH1/AMCH1
               BGCH1  = PCH1/AMCH1
               PCH2 = UMO*(XP - XXT)*.5D0
               ECH2 = UMO*(XP + XXT)*.5D0
               GAMCH2 = ECH2/AMCH2
               BGCH2  = PCH2/AMCH2
               GO TO 348
*  |  |  | end kin. sel. meson proj. (meson target), isam3 = 2
*  |  |  +-->-->-->-->-->-->-->-->-->--> go to 348

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 10
*  |  |  |
3268           CONTINUE
C*** BACKWARD Q(XP)-AQ(XXT) CHAIN
               IIBB = IABS(IBB)
               IBPS = IMPS(IIBB,IBF)
               IBV  = IMVE(IIBB,IBF)
               AMBPS = AM(IBPS)
               AMBV  = AM(IBV)
               NNCH2 = 0
               AMBB  = AMBV + 0.3D0
C===================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C      MESON MESON
C*** BACKWARD QUARK -ANTIQUARK CHAIN
C
C====================================================================
*  |  |  |  here we are using xp, xxt for the jet # 2
               XXSQ  = SQRT(XP*XXT)
               AMCH2 = UMO*XXSQ
               AAPS  = IBPS
               AAV   = IBV
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AAPS,AAV,AMBPS,AMBV

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH2 .LT. AMBPS) GO TO 25
*  |  |  |  | if amch2 < ambps xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH2 .GT. AMBV) GO TO 32618
C*** PRODUCE AMBPS
                  AMCH2 = AMBPS
                  NNCH2 = -1
                  XXSQ = AMBPS/UMO
                  XXT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 32638
                  XT = 1.D0 - XXT
                  GO TO 32638
32618          CONTINUE
               IF (AMCH2 .GT. AMBB) GO TO 32638
C*** PRODUCE AMBV
                  AMCH2 = AMBV
                  NNCH2 = 1
                  XXSQ = AMBV /UMO
                  XXT  = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 32638
                  XT  = 1.D0 - XXT

C     PCH1=UMO*(XXP-XT)*.5D0
C     ECH1=UMO*(XXP+XT)*.5D0
C     GAMCH1=ECH1/AMCH1
C     BGCH1=PCH1/AMCH1

                  GO TO 32638
32638          CONTINUE
               GO TO 32508
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 11 to 32508
*  |  +----------------------------------------------------------------*

 348  CONTINUE
*or      IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XP,XT,XXP,XXT
*or      IF (IPRI .EQ. 1) WRITE(LUNOUT,103)AMCH1,AMCH2,PCH1,PCH2,ECH1,
*or     &ECH2,GAMCH1,GAMCH2,BGCH1,BGCH2
      GO TO 34
*  |  | end kin. sel. meson proj. (meson target)
*  |  +-->-->-->-->-->-->-->-->-->--> go to 34

*  |  +----------------------------------------------------------------*
*  |  | meson projectile, antibaryon target!!!
*  |  |
3277     CONTINUE
C=================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C       MESON ANTIBARYON
C
C===============================================================
C====================================================================
C====================================================================
C     TO BE CORRECTED
C
C====================================================================
C`===================================================================
            GO TO (3217,3257),ISAM3
*  |  |  +-------------------------------------------------------------*
*  |  |  |  meson projectile, antibaryon target, isam = 2
*  |  |  |
3257        CONTINUE
C*** MESON NUCLEON AQ(XXP)-AQAQ(XXT)+Q(XP)-AQ(XT)
               GO TO 3227
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 12 to 3227

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 13
*  |  |  |
32597 CONTINUE
C=================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C      MESON ANTINUCLEON
C*** FIRST LONG AQ(XXP)-AQAQ(XXT) CHAIN
C
C===================================================================
               CALL BKLASS (IBF,IBB1,IBB2,IF8,IFIO)
               AMF8  = AM(IF8)
               AMF10 = AM(IFIO)
               NNCH1 = 0
               AMFF  = AMF10 + 0.3D0
*  |  |  |  here we are using xxp, xxt for the jet # 1
               XSQ   = SQRT(XXP*XXT)
               AMCH1 = UMO*XSQ
               AA8   = IF8
               AA10  = IFIO
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AA8,AA10,AMF8,AMF10

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH1 .LT. AMF8) GO TO 25
*  |  |  |  | if amch1 < amf8 xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH1 .GT. AMF10) GO TO 32117
C*** PRODUCE AMF8
                  AMCH1 = AMF8
                  NNCH1 = -1
                  XSQ = AMF8/UMO
                  GO TO 32135
32117          CONTINUE
               IF (AMCH1 .GT. AMFF) GO TO 32137
C*** PRODUCE AMF10
                  AMCH1 = AMF10
                  NNCH1 = 1
                  XSQ = AMF10/UMO
                  GO TO 32135
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Here adjusting kinematics!!!!!
*  |  |  |  |  Now, chain 1 is a single particle jet, so we have to
*  |  |  |  |  reset the kinematical parameters xp, xxp, xt and xxt
*  |  |  |  |
32135             CONTINUE
                  XSQ2  = XSQ  * XSQ
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If also chain 2 is a parjet (nnch2 .ne. 0) then the
*  |  |  |  |  |  param. to be recomputed are xxp and xxt, from alpha
*  |  |  |  |  |  and beta, in such a way to conserve the original
*  |  |  |  |  |  momentum direction
*  |  |  |  |  |
                  IF (NNCH2 .NE. 0) THEN
                     XXSQ2 = XXSQ * XXSQ
                     HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 *
     &                      (XXSQ2 - 2.D0) - 2.D0 * XSQ2 * XXSQ2
                     DDIFF = SQRT (HELP + 1.D0)
                     SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XSQ2)
                     ALPHA = (SSUM + DDIFF) * 0.5D0
                     BETA  = (SSUM - DDIFF) * 0.5D0
                     IF (XXP .GT. XXT) THEN
                         XXP = ALPHA
                         XXT = BETA
                     ELSE
                         XXT = ALPHA
                         XXP = BETA
                     END IF
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  ELSE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If chain 2 is not a parjet (nnch2 .eq. 0) then the
*  |  |  |  |  |  paramet. xxp,xxt have to be recomputed in such a way
*  |  |  |  |  |  to conserve the original momentum direction and
*  |  |  |  |  |  modulus
*  |  |  |  |  |
                     DDIFF = XXP - XXT
                     SSUM  = SQRT (4.D0 * XSQ2 + DDIFF**2)
                     XXP = (SSUM + DDIFF) * 0.5D0
                     XXT = (SSUM - DDIFF) * 0.5D0
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
                     XXSQ  = SQRT (XP * XT)
                     AMCH2 = XXSQ * UMO
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |                       end kinematics correction
*  |  |  |  +----------------------------------------------------------*

32137          CONTINUE
               PCH1 = UMO*(XXP - XXT)*.5D0
               ECH1 = UMO*(XXP + XXT)*.5D0
               GAMCH1 = ECH1/AMCH1
               BGCH1  = PCH1/AMCH1
               PCH2 = UMO*(XP - XT)*.5D0
               ECH2 = UMO*(XP + XT)*.5D0
               GAMCH2 = ECH2/AMCH2
               BGCH2  = PCH2/AMCH2
               GO TO 34
*  |  |  | end kin. sel. meson proj. (abaryon target), isam3 = 2
*  |  |  +-->-->-->-->-->-->-->-->-->--> go to 34

*  |  |  +--<--<--<--<--<--<--<--<--<--< here from jump # 12
*  |  |  |
3227           CONTINUE
C===============================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C       MESON ANTINUCLEON
C*** SHORT AQ(XP)-Q(XT) CHAIN
C
C================================================================
              IIFB = IABS(IFB)
              IBPS = IMPS(IIFB,IFF)
              IBV  = IMVE(IIFB,IFF)
              AMBPS = AM(IBPS)
              AMBV  = AM(IBV)
              NNCH2 = 0
              AMBB = AMBV + 0.3D0
*  |  |  | here we are using xp,xt for jet # 2
              XXSQ  = SQRT(XP*XT)
              AMCH2 = UMO*XXSQ
              AAPS  = IBPS
              AAV   = IBV
*or              IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &        ,AAPS,AAV,AMBPS,AMBV

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH2 .LT. AMBPS) GO TO 25
*  |  |  |  | if amch2 < ambps xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH2 .GT. AMBV) GO TO 32217
C*** PRODUCE AMBPS
                  AMCH2 = AMBPS
                  NNCH2 = -1
                  XXSQ = AMBPS/UMO
                  XT   = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 32237
                  XXT = 1.D0 - XT
                  GO TO 32237
32217          CONTINUE
               IF (AMCH2 .GT. AMBB) GO TO 32237
C*** PRODUCE AMBV
                  AMCH2 = AMBV
                  NNCH2 = 1
                  XXSQ = AMBV/UMO
                  XT   = XXSQ**2/XP
*or                  IF (INUCVT .EQ. 1) GO TO 32237
                  XXT = 1.D0 - XT

C     PCH1=UMO*(XXP-XXT)*.5D0
C     ECH1=UMO*(XXP+XXT)*.5D0
C     GAMCH1=ECH1/AMCH1
C     BGCH1=PCH1/AMCH1
C     GO TO 32237

32237          CONTINUE
               GO TO 32597
*  |  |  |
*  |  |  +-->-->-->-->-->-->-->-->-->--> jump # 13 to 32597

*  |  |  +-------------------------------------------------------------*
*  |  |  |  meson projectile, antibaryon target, isam = 1
*  |  |  |
3217           CONTINUE
C=================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C*** MESON ANTINUCLEUS
C*** BACKWARD    QUARK-  ANTIQUARK CHAIN
C
C=================================================================
32507          CONTINUE
C=====================================================================
C
C     MESON ANTINUCLEON
C*** BACKWARD Q(XP)-AQ(XT) CHAIN
C
C====================================================================
               IIBB = IABS(IBB)
               IFPS = IMPS(IIBB,IBF)
               IFV  = IMVE(IIBB,IBF)
               AMFPS = AM(IFPS)
               AMFV  = AM(IFV)
               NNCH1 = 0
               AMFF = AMFV + 0.3D0
*  |  |  | here we are using xp,xt for jet # 1
               XSQ  = SQRT(XP*XT)
               AMCH1 = UMO*XSQ
               AAPS  = IFPS
               AAV   = IFV
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AAPS,AAV,AMFPS,AMFV

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH1 .LT. AMFPS) GO TO 25
*  |  |  |  | if amch1 < amfps xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH1 .GT. AMFV) GO TO 32517
C*** PRODUCE AMFPS
                  AMCH1 = AMFPS
                  NNCH1 = -1
                  XSQ = AMFPS/UMO
                  XP  = XSQ**2/XT
                  XXP = 1.D0 - XP
                  GO TO 32537
32517          CONTINUE
               IF (AMCH1 .GT. AMFF) GO TO 32537
C*** PRODUCE AMFV
                  AMCH1 = AMFV
                  NNCH1 = 1
                  XSQ = AMFV/UMO
                  XP  = XSQ**2/XT
                  XXP = 1.D0 - XP
                  GO TO 32537
32537          CONTINUE
               GO TO 3267
3267           CONTINUE
C***FORWARD AQ(XXP)-AQAQ(XXT) CHAIN
               CALL BKLASS(IFF,IFB1,IFB2,IB8,IBIO)
               AMB8  = AM(IB8)
               AMB10 = AM(IBIO)
               NNCH2 = 0
               AMBB  = AMB10 + 0.3D0
C===================================================================
C
C*** KINEMATICAL PARAMETERS OF BOTH CHAINS IN CMS
C               MESON ANTINUCLEON
C*** FORWARD ANTIQUARK -ANTIDIQUARK CHAIN
C
C====================================================================
*  |  |  | here we are using xxp,xXt for jet # 2
               XXSQ = SQRT(XXP*XXT)
               AMCH2 = UMO*XXSQ
               AA8   = IB8
               AA10  = IBIO
*or               IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XSQ,AMCH1,AMCH2
*or     &         ,AA8,AA10,AMB8,AMB10

*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF (AMCH2 .LT. AMB8 ) GO TO 25
*  |  |  |  | if amch2 < amb8 xp and xt are resampled
*  |  |  |  +-->-->-->-->-->-->-->-->-->--> xp, xt resampling

               IF (AMCH2 .GT. AMB10) GO TO 32617
C*** PRODUCE AMB8
                  AMCH2 = AMB8
                  NNCH2 = -1
                  XXSQ = AMB8/UMO
*or                  IF (INUCVT .EQ. 1) GO TO 32637
                  GO TO 32636
32617          CONTINUE
               IF (AMCH2 .GT. AMBB) GO TO 32637
C*** PRODUCE AMB10
                  AMCH2 = AMB10
                  NNCH2 = 1
                  XXSQ = AMB10/UMO
*or                  IF (INUCVT .EQ. 1) GO TO 32637

C     PCH1=UMO*(XXP-XT)*.5D0
C     ECH1=UMO*(XXP+XT)*.5D0
C     GAMCH1=ECH1/AMCH1
C     BGCH1=PCH1/AMCH1
* Here there was a "large" mistake in the old Hadevt!!!
                  GO TO 32636
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Here adjusting kinematics!!!!!
*  |  |  |  |  Now, chain 2 is a single particle jet, so we have to
*  |  |  |  |  reset the kinematical parameters xp, xxp, xt and xxt
*  |  |  |  |
32636             CONTINUE
                  XXSQ2 = XXSQ  * XXSQ
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If also chain 1 is a parjet (nnch1 .ne. 0) then the
*  |  |  |  |  |  param. to be recomputed are xxp and xxt, from alpha
*  |  |  |  |  |  and beta, in such a way to conserve the original
*  |  |  |  |  |  momentum direction
*  |  |  |  |  |
                  IF (NNCH1 .NE. 0) THEN
                     XSQ2  = XSQ * XSQ
                     HELP  = XSQ2 * (XSQ2 - 2.D0) + XXSQ2 *
     &                      (XXSQ2 - 2.D0) - 2.D0 * XSQ2 * XXSQ2
                     DDIFF = SQRT (HELP + 1.D0)
                     SSUM  = SQRT (HELP + 1.D0 + 4.D0 * XXSQ2)
                     ALPHA = (SSUM + DDIFF) * 0.5D0
                     BETA  = (SSUM - DDIFF) * 0.5D0
                     IF (XXP .GT.  XXT) THEN
                         XXP = ALPHA
                         XXT = BETA
                     ELSE
                         XXT = ALPHA
                         XXP = BETA
                     END IF
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  ELSE
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  If chain 1 is not a parjet (nnch1 .eq. 0) then the
*  |  |  |  |  |  paramet. xxp,xxt have to be recomputed in such a way
*  |  |  |  |  |  to conserve the original momentum direction and
*  |  |  |  |  |  modulus
*  |  |  |  |  |
                     DDIFF = XXP - XXT
                     SSUM  = SQRT (4.D0 * XXSQ2 + DDIFF**2)
                     XXP = (SSUM + DDIFF) * 0.5D0
                     XXT = (SSUM - DDIFF) * 0.5D0
                     XP  = 1.D0 - XXP
                     XT  = 1.D0 - XXT
                     XSQ   = SQRT (XP * XT)
                     AMCH1 = XSQ * UMO
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |                       end kinematics correction
*  |  |  |  +----------------------------------------------------------*

32637          CONTINUE
               PCH1 = UMO*(XP - XT)*.5D0
               ECH1 = UMO*(XP + XT)*.5D0
               GAMCH1 = ECH1/AMCH1
               BGCH1  = PCH1/AMCH1
               PCH2 = UMO*(XXP - XXT)*.5D0
               ECH2 = UMO*(XXP + XXT)*.5D0
               GAMCH2 = ECH2/AMCH2
               BGCH2  = PCH2/AMCH2
               GO TO 34
*  |  |  | end kin. sel. meson proj. (abaryon target), isam3 = 1
*  |  |  +-->-->-->-->-->-->-->-->-->--> go to 34
*  |  +----------------------------------------------------------------*
  34  CONTINUE
*  |            end of kinematical selections!!!!!!!!!
*  +-------------------------------------------------------------------*
*or      IF (IPRI .EQ. 1) WRITE(LUNOUT,103)XP,XT,XXP,XXT
*or      IF (IPRI .EQ. 1) WRITE(LUNOUT,103)AMCH1,AMCH2,PCH1,PCH2,
*or     &ECH1,ECH2,GAMCH1,GAMCH2,BGCH1,BGCH2
C
C********************************************************************
C
C*** MC SAMPLING OF FORWARD CHAIN
C
C********************************************************************
C
      IF (IBPROJ) 41,42,43
C==================================================================
C         FORWARD CHAIN OF ANTIBARYON BARYON
C==================================================================
  41  CONTINUE
         IF (NNCH1) 4111,4112,4113
4111     CONTINUE
            ICH1 = IFPS
            GO TO 4114
4113     CONTINUE
            ICH1 = IFV
            GO TO 4114
4112     CONTINUE
            IF (IOPBAM .EQ. 5) THEN
               IAIFF1 = IABS(IFF1) + 6
               IAIFF2 = IABS(IFF2) + 6
*or               IF (IPRI .EQ. 1)WRITE(LUNOUT,991)IFB1,IFB2,IAIFF1
*or 991           FORMAT (' BAMJEV 4112',5I5)
               CALL BAMJEV(IHAD,IFB1,IFB2,IAIFF1,IAIFF2,AMCH1,5)
            ELSE
               IAIFF = IABS(IAIFF) + 6
               CALL BAMJEV(IHAD,IFB,IAIFF,IFB,IFB,AMCH1,IOPBAM)
            END IF
            GO TO 4115
4114  CONTINUE
*or      IF (IPRI .EQ. 1) WRITE(LUNOUT,992)ICH1
*or  992 FORMAT (' PARJET 4114 ',5I5)
            CALL PARJET(IHAD,ICH1)
4115     CONTINUE
C
C
C
C     CALL DECAY(IHAD,2)
         GO TO 44
42    CONTINUE
C=====================================================================
C*** FORWARD CHAIN OF MESON NUCLEON
C======================================================================
         IF (IBTARG) 427,428,429
 429     CONTINUE
            GO TO (421,422),ISAM3
 421        CONTINUE
               IF (NNCH1) 4211,4212,4213
4211           CONTINUE
                  ICH1 = IF8
                  GO TO 4214
4213           CONTINUE
                  ICH1 = IFIO
                  GO TO 4214
4212           CONTINUE
                  CALL BAMJEV(IHAD,IFF,IFB1,IFB2,IFF,AMCH1,4)
                  GO TO 4215
4214           CONTINUE
                  CALL PARJET(IHAD,ICH1)
4215           CONTINUE
C     CALL DECAY(IHAD,2)
               GO TO 44
422         CONTINUE
C*** IFA - IFB AQ - Q EXISTIERT NICHT
               IF (NNCH1) 4221,4222,4223
4221           CONTINUE
                  ICH1 = IFPS
                  GO TO 4224
4223           CONTINUE
                  ICH1 = IFV
                  GO TO 4224
4222           CONTINUE
                  IAIFF = IABS(IFF) + 6
                  CALL BAMJEV(IHAD,IFB,IAIFF,IFB,IFB,AMCH1,3)
                  GO TO 4225
4224           CONTINUE
                  CALL PARJET(IHAD,ICH1)
4225           CONTINUE
C     CALL DECAY(IHAD,2)
               GO TO 44
C===================================================================
C
C   FORWARD CHAIN OF MESON MESON
C
C====================================================================
C=====================================================================
 428     CONTINUE
            GO TO (4218,4228),ISAM3
4218        CONTINUE
               IF (NNCH1) 42118,42128,42138
42118          CONTINUE
                  ICH1 = IFPS
                  GO TO 42148
42138          CONTINUE
                  ICH1 = IFV
                  GO TO 42148
42128          CONTINUE
                  IAIFB = IABS(IFB) + 6
                  CALL BAMJEV(IHAD,IFF,IAIFB,IFB2,IFF,AMCH1,3)
                  GO TO 42158
42148          CONTINUE
                  CALL PARJET(IHAD,ICH1)
42158          CONTINUE
C     CALL DECAY(IHAD,2)
               GO TO 44
4228        CONTINUE
C*** IFA - IFB AQ - Q EXISTIERT NICHT
               IF (NNCH1) 42218,42228,42238
42218          CONTINUE
                  ICH1 = IFPS
                  GO TO 42248
42238          CONTINUE
                  ICH1 = IFV
                  GO TO 42248
42228          CONTINUE
                  IAIFF = IABS(IFF) + 6
                  CALL BAMJEV(IHAD,IFB,IAIFF,IFB,IFB,AMCH1,3)
                  GO TO 42258
42248          CONTINUE
                  CALL PARJET(IHAD,ICH1)
42258          CONTINUE
C     CALL DECAY(IHAD,2)
               GO TO 44
C================================================================
C
C      FORWARD CHAIN OF MESON ANTIBARYON
C
C==================================================================
 427     CONTINUE
C=================================================================
C    TO BE CORRECTED
C=================================================================
            GO TO (4217,4227),ISAM3
4227        CONTINUE
               IF (NNCH1) 42117,42127,42137
42117          CONTINUE
                  ICH1 = IF8
                  GO TO 42147
42137          CONTINUE
                  ICH1 = IFIO
                  GO TO 42147
42127          CONTINUE
                  IAIBF = IABS(IBF) + 6
                  IAIBB1= IABS(IBB1) + 6
                  IAIBB2= IABS(IBB2) + 6
*or                  IF (IPRI.EQ.1) WRITE(LUNOUT,994)IAIBF,IAIBB1,IAIBB2
*or  994 FORMAT(' BAMJEV 43147',5I5)
                  CALL BAMJEV(IHAD,IAIBF,IAIBB1,IAIBB2,IBB,AMCH1,4)
                  GO TO 42157
42147          CONTINUE
*or                  IF (IPRI.EQ.1) WRITE(LUNOUT,993)ICH1
*or 993              FORMAT (' PARJET 42147',5I5)
                  CALL PARJET(IHAD,ICH1)
42157          CONTINUE
C     CALL DECAY(IHAD,2)
               GO TO 44
4217        CONTINUE
C*** IFA - IFB AQ - Q EXISTIERT NICHT
               IF (NNCH2) 42217,42227,42237
42217          CONTINUE
                  ICH1 = IB8
                  GO TO 42247
42237          CONTINUE
                  ICH1 = IBIO
                  GO TO 42247
42227          CONTINUE
                  IAIFF = IABS(IFF) + 6
                  IAIFB1= IABS(IFB1) + 6
                  IAIFB2= IABS(IFB2) + 6
*or                  IF (IPRI.EQ.1) WRITE(LUNOUT,995)IAIFF,IAIFB1,IAIFB2
*or 995              FORMAT (' BAMJEV 42227',5I5)
                  CALL BAMJEV(IHAD,IAIFF,IAIFB1,IAIFB2,IFB,AMCH2,4)
                  GO TO 42257
42247          CONTINUE
*or                  IF (IPRI.EQ.1) WRITE(LUNOUT,996)ICH1
*or 996              FORMAT ('PARJET 42247',5I5)
                  CALL PARJET(IHAD,ICH1)
42257          CONTINUE
C     CALL DECAY(IHAD,2)
               GO TO 44
  43  CONTINUE
C==================================================================
C*** FORWARD CHAIN OF NUCLEON NUCLEON
C===================================================================
         IF (NNCH1) 431,432,433
 431     CONTINUE
            ICH1 = IF8
            GO TO 434
 433     CONTINUE
            ICH1 = IF10
            GO TO 434
 432     CONTINUE
            CALL BAMJEV(IHAD,IFB,IFF1,IFF2,IFB,AMCH1,4)
            GO TO 435
 434     CONTINUE
            CALL PARJET(IHAD,ICH1)
 435     CONTINUE
C     CALL DECAY(IHAD,2)
  44  CONTINUE
C*** TURN CHAINS AROUND IF NECESSARY
      IF (IBPROJ) 51,52,53
  51  CONTINUE
         GO TO 55
  52  CONTINUE
C*** MESON NUCLEON
         GO TO (521,522),ISAM3
 521     CONTINUE
            GO TO 54
 522     CONTINUE
C*** TURN JET
            GO TO 55
  53  CONTINUE
C*** NUCLEON-NUCLEON
C*** TURN JET
         GO TO 55
  55  CONTINUE
C*** TURN JET AROUND
         DO 56 I=1,IHAD
            PZF(I) = -PZF(I)
  56     CONTINUE
  54  CONTINUE
      IIIHAD = IHAD
C*** AND  INT. CHAIN TRANSVERSE MOMENTA
      B3SAVE = B3BAMJ
* This is consistent with b3bamj = 10 for an initial value of 6
      B3BAMJ = 1.666666666666667D+00 * B3BAMJ
*     B3BAMJ = 5.D+00 / ( LOG10 ( 1.D+00 + ( UMO / E00 )**1.5D+00 )
*    &       + 1.D+00 )
      CALL GRNDM(RNDM,2)
      ES  = -2.D0/(B3BAMJ**2)*LOG(RNDM(1)*RNDM(2))
      B3BAMJ = B3SAVE
*     HPS = SQRT(ES*ES+2.D0*ES*AMCH1)
      HPS = SQRT(ES*ES+2.D0*ES*AM(1))
      CALL SFECFE(SFE,CFE)
*
*  tentative guess
*
      PTXCH1 = HPS * CFE
      PTYCH1 = HPS * SFE
*  +-------------------------------------------------------------------*
*  |                  Loop to establish the transverse momentum
      GO TO 6171
6170  CONTINUE
         PTXCH1 = 0.75D0 * PTXCH1
         PTYCH1 = 0.75D0 * PTYCH1
6171     CONTINUE
         IHAD = IIIHAD
*  |         The following two cards provide momentum conservation for
*  |         x and y components
         PTXCH2 = -PTXCH1
         PTYCH2 = -PTYCH1
         BGCH1X = PTXCH1/AMCH1
         BGCH1Y = PTYCH1/AMCH1
         ACH1 = BGCH1**2-(PTXCH1**2+PTYCH1**2)/AMCH1**2
         IF (ACH1.LE.0.D0) GO TO 6170
*  |
*  +--<--<--<--<--< if Pt is too large loop again on the forward jet
         BGCH2X = PTXCH2/AMCH2
         BGCH2Y = PTYCH2/AMCH2
         ACH2   = BGCH2**2-(PTXCH2**2+PTYCH2**2)/AMCH2**2
      IF (ACH2.LE.0.D0) GO TO 6170
*  |
*  +--<--<--<--<--<--<--<--<--<--< if Pt is too large loop again
      BGCH1Z = SQRT(ACH1)
      BGCH1Z = SIGN(BGCH1Z,BGCH1)
      BGCH2Z = SQRT(ACH2)
      BGCH2Z = SIGN(BGCH2Z,BGCH2)

      CALL LORTRA(IHAD,1,GAMCH1,BGCH1X,BGCH1Y,BGCH1Z)
C==============================================================
C
C*** TRANSFORM FORWARD JET INTO CMS
C
C================================================================
      IHAD = IIIHAD
      NAUX = IHAD
C===============================================================
C
C*** SAMPLING OF BACKWARD CHAIN
C
C===============================================================
      IF (IBPROJ) 61,62,63
  61  CONTINUE
C================================================================
C      BACKWARD CHAIN OF ANTINUCLEON NUCLEON
C=================================================================
         IF (NNCH2) 6111,6112,6113
6111     CONTINUE
            ICH2 = IBPS
            GO TO 6114
6113     CONTINUE
            ICH2 = IBV
            GO TO 6114
6112     CONTINUE
            IAIBF = IABS(IBF) + 6
            CALL BAMJEV(IHAD,IBB,IAIBF,IBB,IBB,AMCH2,3)
            GO TO 6115
6114     CONTINUE
            CALL PARJET(IHAD,ICH2)
6115     CONTINUE
C
C
C     CALL DECAY(IHAD,2)
         GO TO 64
  62  CONTINUE
C================================================================
C*** BACKWARD CHAIN OF MESON - BARYON
C==================================================================
         IF (IBTARG) 627,628,629
 629     CONTINUE
            GO TO (621,622),ISAM3
 621        CONTINUE
               IF (NNCH2) 6211,6212,6213
6211           CONTINUE
                 ICH2 = IBPS
                 GO TO 6214
6213          CONTINUE
                 ICH2 = IBV
                 GO TO 6214
6212          CONTINUE
                 IAIBF = IABS(IBF) + 6
                 CALL BAMJEV(IHAD,IBB,IAIBF,IBB,IBB,AMCH2,3)
                 GO TO 6215
6214          CONTINUE
                 CALL PARJET(IHAD,ICH2)
6215          CONTINUE
C     CALL DECAY(IHAD,2)
              GO TO 64
622        CONTINUE
              IF (NNCH2) 6221,6222,6223
6221          CONTINUE
                 ICH2 = IB8
                 GO TO 6224
6223          CONTINUE
                 ICH2 = IBIO
                 GO TO 6224
6222          CONTINUE
                 CALL BAMJEV(IHAD,IBF,IBB1,IBB2,IBF,AMCH2,4)
                 GO TO 6225
6224          CONTINUE
                 CALL PARJET(IHAD,ICH2)
6225             CONTINUE
C     CALL DECAY(IHAD,2)
                 GO TO 64
C==================================================================
C
C     BACKWARD CHAIN OF MESON MESON
C
C===================================================================
C        TO BE CORRECTED
C===================================================================
 628    CONTINUE
           GO TO(6218,6228),ISAM3
6218       CONTINUE
              IF (NNCH2) 62118,62128,62138
62118         CONTINUE
                 ICH2 = IBPS
                 GO TO 62148
62138         CONTINUE
                 ICH2 = IBV
                 GO TO 62148
62128         CONTINUE
                 IAIBF = IABS(IBF) + 6
                 CALL BAMJEV(IHAD,IBB,IAIBF,IBB,IBB,AMCH2,3)
                 GO TO 62158
62148         CONTINUE
                 CALL PARJET(IHAD,ICH2)
62158         CONTINUE
C     CALL DECAY(IHAD,2)
              GO TO 64
6228       CONTINUE
              IF (NNCH2) 62218,62228,62238
62218         CONTINUE
                 ICH2 = IBPS
                 GO TO 62248
62238         CONTINUE
                 ICH2 = IBV
                 GO TO 62248
62228         CONTINUE
                 IAIBB = IABS(IBB) + 6
                 CALL BAMJEV(IHAD,IBF,IAIBB,IBB2,IBF,AMCH2,3)
                 GO TO 62258
62248         CONTINUE
                 CALL PARJET(IHAD,ICH2)
62258 CONTINUE
C     CALL DECAY(IHAD,2)
              GO TO 64
C================================================================
C
C       BACKWARD CHAIN OF MESON ANTIBARYON
C=================================================================
C     TO BE CORRECTED
C=================================================================
 627     CONTINUE
            GO TO(6217,6227),ISAM3
6227        CONTINUE
               IF (NNCH2) 62117,62127,62137
62117          CONTINUE
                 ICH2 = IBPS
                 GO TO 62147
62137         CONTINUE
                 ICH2 = IBV
                 GO TO 62147
62127         CONTINUE
                 IAIFB = IABS(IFB) + 6
*or                 IF (IPRI.EQ.1) WRITE(LUNOUT,997)IFF,IAIFB
*or 997             FORMAT (' BAMJEV 62127',5I5)
                 CALL BAMJEV(IHAD,IFF,IAIFB,IBB,IBB,AMCH2,3)
                 GO TO 62157
62147         CONTINUE
*or                 IF (IPRI.EQ.1) WRITE(LUNOUT,998)ICH2
*or 998             FORMAT ('PARJET 62147',5I5)
                 CALL PARJET(IHAD,ICH2)
62157         CONTINUE
C     CALL DECAY(IHAD,2)
              GO TO 64
6217       CONTINUE
              IF (NNCH1) 62217,62227,62237
62217         CONTINUE
                 ICH2 = IFPS
                 GO TO 62247
62237         CONTINUE
                 ICH2 = IFV
                 GO TO 62247
62227         CONTINUE
                 IAIBB = IABS(IBB) + 6
*or                 IF (IPR1.EQ.1) WRITE(LUNOUT,9911)IBF,IAIBB
*or9911             FORMAT (' BAMJEV 62227',5I5)
                 CALL BAMJEV(IHAD,IBF,IAIBB,IAIFB2,IBF,AMCH1,3)
                 GO TO 62257
62247         CONTINUE
*or                 IF (IPRI .EQ. 1) WRITE(LUNOUT,9912)ICH2
*or9912             FORMAT ('PARJET 62247',5I5)
                 CALL PARJET(IHAD,ICH2)
62257         CONTINUE
C     CALL DECAY(IHAD,2)
              GO TO 64
63    CONTINUE
C==================================================================
C*** BACKWARD CHAIN OF BARYON BARYON
C==================================================================
         IF (NNCH2) 631,632,633
631      CONTINUE
            ICH2 = IB8
            GO TO 634
633      CONTINUE
            ICH2 = IBIO
            GO TO 634
632      CONTINUE
            CALL BAMJEV(IHAD,IBF,IBB1,IBB2,IBF,AMCH2,4)
            GO TO 635
 634     CONTINUE
            CALL PARJET(IHAD,ICH2)
 635     CONTINUE
C     CALL DECAY(IHAD,2)
*
*  We arrive here after jet creation: created particles are in
*  /finpar/ common (there are ihad particles)
*
  64  CONTINUE
C*** TURN CHAIN AROUND IF NECESSARY
      IF (IBPROJ) 71,72,73
  71  CONTINUE
         GO TO 75
  72  CONTINUE
         GO TO (721,722),ISAM3
 721     CONTINUE
C*** TURN JET
            GO TO 75
 722     CONTINUE
            GO TO 74
  73  CONTINUE
C*** KEEP JET
         GO TO 74
  75  CONTINUE
C*** TURN JET AROUND
         DO 76 I=1,IHAD
            PZF(I) = -PZF(I)
  76     CONTINUE
  74  CONTINUE
C================================================================
C
C*** TRANSFORM BACKWARD JET INTO CMS
C
C=================================================================
      NAUX   = NAUX+1


      CALL LORTRA(IHAD,NAUX,GAMCH2,BGCH2X,BGCH2Y,BGCH2Z)
      NAUX = IHAD + NAUX - 1
      DO 181 I=1,NAUX
         PXR(I)  = PXA(I)
         PYR(I)  = PYA(I)
         PZR(I)  = PZA(I)
         AMR(I)  = AMA(I)
         ICHR(I) = ICHA(I)
         ANR(I)  = ANA(I)
         IBARR(I)= IBARA(I)
         NRER(I) = NREA(I)
         HER(I)  = HEPA(I)
 181  CONTINUE

      NRES=NAUX
      CALL DECAUX(NAUX,3)


*or      IF (IPRI.EQ.1) WRITE(LUNOUT,85)(I,NREA(I),ICHA(I),IBARA(I),
*or     &ANA(I)PXA(I),PYA(I),PZA(I),HEPA(I),AMA(I),I=1,NAUX)

      EVZ = 0.D0
      PVX = 0.D0
      PVY = 0.D0
      PVZ = 0.D0
      ICCU = 0
      IBBU = 0
      ISSU = 0
      LISSU = .TRUE.

C*** TRANSFORM INTO LABSYSTEM
*  +-------------------------------------------------------------------*
*  |   particles from /auxpar/ common  are transformed back in the lab
*  |   system (which is actually the system of the target nucleon with
*  |   the projectile along the z-axis)
*  |   and put in /hadpar/ common
*  |
*  | The transformation is:
*  |     Elab  =  Ecms * gamma + ETAzlab * Pzcms
*  |     Pzlab = Pzcms * gamma + ETAzlab * Ecms
*  |                note ETAzlab = -ETAzcms!!!!
*  |
      DO 81 I=1,NAUX
         HEPH(I) = GAMCM*HEPA(I) + BGCM*PZA(I)
         PZH(I)  = GAMCM*PZA(I)  + BGCM*HEPA(I)
         PXH(I)  = PXA(I)
         PYH(I)  = PYA(I)
         AMH(I)  = AMA(I)
         ICHH(I) = ICHA(I)
         ANH(I)  = ANA(I)
         IBARH(I)= IBARA(I)
         NREH(I) = NREA(I)
         EVZ = EVZ + HEPH(I)
         PVX = PVX + PXH(I)
         PVY = PVY + PYH(I)
         PVZ = PVZ + PZH(I)
         ICCU = ICCU + ICHH(I)
         IBBU = IBBU + IBARH(I)
         IJNREH = KPTOIP ( NREH (I) )
         IF (IJNREH .LE. 0 .OR. IJNREH .GT. 39) THEN
            WRITE (LUNOUT,*)' Hadevt: Ijnreh = 0, > 39 after decay!!',
     &      IJNREH,NREH(I),I,HEPH(I)
            WRITE (LUNERR,*)' Hadevt: Ijnreh = 0, > 39 after decay!!',
     &      IJNREH,NREH(I),I,HEPH(I)
            LISSU = .FALSE.
         ELSE
            DO 8011 J=1,3
               ISSU = ISSU + IQSCHR (MQUARK(J,IJNREH))
8011        CONTINUE
         END IF
  81  CONTINUE
*  |
*  +-------------------------------------------------------------------*

      NHAD = NAUX
      ICHTOT = ICH(KPROJ) + ICH(KTARG)
      IBTOT  = IBPROJ + IBTARG
      ISTOT  = 0
      DO 8111 J=1,3
         ISTOT = ISTOT + IQSCHR(MQUARK(J,IJPROJ))
     &         + IQSCHR(MQUARK(J,IJTARG))
8111  CONTINUE
*  +-------------------------------------------------------------------*
*  |
      IF (ICCU .NE. ICHTOT) THEN
*  | write an error message and then resample!!!
         WRITE(LUNOUT,*)' Hadevt: charge conservation failure: ',
     &                  ' ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT',
     &                  ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT
         WRITE(LUNERR,*)' Hadevt: charge conservation failure: ',
     &                  ' ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT',
     &                  ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT
         LRESMP = .TRUE.
      ELSE IF (IBBU .NE. IBTOT) THEN
*  | write an error message and then resample!!!
         WRITE(LUNOUT,*)' Hadevt: baryon conservation failure: ',
     &                  ' ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT',
     &                  ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT
         WRITE(LUNERR,*)' Hadevt: baryon conservation failure: ',
     &                  ' ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT',
     &                  ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT
         LRESMP = .TRUE.
      ELSE IF (ISSU .NE. ISTOT .AND. LISSU) THEN
*  | write an error message and then resample!!!
         WRITE(LUNOUT,*)' Hadevt: strangeness conservation failure: ',
     &                  ' ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT',
     &                  ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT
         WRITE(LUNERR,*)' Hadevt: strangeness conservation failure: ',
     &                  ' ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT',
     &                  ICCU,ICHTOT,IBBU,IBTOT,ISSU,ISTOT
         LRESMP = .TRUE.
      ELSE
      END IF
*  |
*  +-------------------------------------------------------------------*
      EPSEPS = MAX ( 10.D+00*ANGLGB, 1.D-12 )
*  +-------------------------------------------------------------------*
*  |
      IF (ABS(EVZ-AMTAR-EPROJ)/(AMTAR+EPROJ) .GT. EPSEPS) THEN
      ELSE IF (ABS(PVX)/PPROJ .GT. EPSEPS) THEN
      ELSE IF (ABS(PVY)/PPROJ .GT. EPSEPS) THEN
      ELSE IF (ABS(PVZ-PPROJ)/PPROJ .GT. EPSEPS) THEN
      ELSE
         GO TO 90
      END IF
*  |
*  +-------------------------------------------------------------------*

C
C********************************************************************
C
C*** PRINT AND TEST ENERGY CONSERVATION
C
C********************************************************************
C
*or      PVZ = 0.D0
*or      EVZ = 0.D0
*or      PVX = 0.D0
*or      PVY = 0.D0
*or      ICCU = 0
*or      IBBU = 0
*or      DO 82 I=1,NHAD
*or         PVX = PVX + PXH(I)
*or         PVY = PVY + PYH(I)
*or         PVZ = PVZ + PZH(I)
*or         EVZ = EVZ + HEPH(I)
*or         ICCU = ICCU + ICHH(I)
*or         IBBU = IBBU + IBARH(I)
*or  82  CONTINUE
*or      IF (IBTOT  .NE. IBBU) GO TO 9999
*or      IF (ICHTOT .NE. ICCU) GO TO 9999
*or      IF (ABS(PVX).GE.0.01D0) GO TO 9999
*or      IF (ABS(PVY).GE.0.01D0) GO TO 9999
*or      IF ((PVZ.GT.1.02D0*PPROJ).OR.(PVZ.LT.0.98D0*PPROJ)) GO TO 9999
*or      IF (IPRI.NE.1) GO TO 90
9999  CONTINUE
*
*  If a failure occured the event is resampled!!!
*
      GO TO 8899
*or      IF (IPRI.EQ.0) GO TO 8899
*or      WRITE(LUNOUT,83)NHAD,KPROJ,KTARG,PPROJ,EPROJ,PVX,PVY,PVZ,EVZ,
*or     &ICCU,IBBU,NHAD
*or  83  FORMAT (3I5,6F12.6,3I5)
*or      DO 84 I=1,NHAD
*or         WRITE(LUNOUT,85)I,NREH(I),ICHH(I),IBARH(I),ANH(I),PXH(I),
*or     &   PYH(I),PZH(I),HEPH(I),AMH(I)
*or  85     FORMAT (4I5,A8,5F12.6)
*or  84  CONTINUE
*
*  If a failure occured the event is resampled!!!
*
*or      IF (IPRI.EQ.0)GO TO 8899

  90  CONTINUE
      RETURN
      END
+DECK,  HADRIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

*$ CREATE HADRIN.FOR
*COPY HADRIN
*=== hadrin ===========================================================*
*----------------------------------------------------------------------*
*    hadrin89: slight modifications by A. Ferrari
*----------------------------------------------------------------------*
      SUBROUTINE HADRIN (N,PLAB,ELAB,CX,CY,CZ,ITTA)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
+CDE, METLSP.
+CDE, FINLSP.
      PARAMETER ( AMPROT = 0.93827231D+00 )
*
+CDE, REAC.
+CDE, REDVER.
+CDE, SPLIT.
*
****  INTEGER*2ICH,IBAR,K1,K2,NZK,NRK,IEII,IKII,NURE
      COMMON / FKGAMR / REDU, AMO, AMM (15)
C
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
      COMMON / FKCODS / COD1, COD2, COD3, COF1, COF2, COF3, SIF1, SIF2,
     &                  SIF3, ECM1, ECM2, ECM3, PCM1, PCM2, PCM3
      COMMON / FKRUN    / RUNTES, EFTES
*
      SAVE UMODA, ITPRF, NNN
      DIMENSION ITPRF(110)
      REAL RNDM(1)
      DATA NNN/0/
      DATA UMODA/0.D0/
      DATA ITPRF/-1,-1,5*1,-1,-1,1,1,1,-1,-1,-1,-1,6*1,-1,-1,-1,85*1/
C
C-----------------------------
C*** INPUT VARIABLES LIST:
C*** SAMPLING OF HADRON NUCLEON INTERACTION FOR (ABOUT) 0.1 LE PLAB LE 6
C*** GEV/C LABORATORY MOMENTUM REGION
C*** N    - PROJECTILE HADRON INDEX
C*** PLAB - LABORATORY MOMENTUM OF N (GEV/C)
C*** ELAB - LABORATORY ENERGY OF N (GEV)
C*** CX,CY,CZ - DIRECTION COSINES OF N IN THE LABORATORY SYSTEM
C*** ITTA - TARGET NUCLEON INDEX
C*** OUTPUT VARIABLES LIST OF PARTICLE CHARACTERISTICS IN /FINLSP/
C  IR COUNTS THE NUMBER OF PRODUCED PARTICLES
C*** ITR - PARTICLE INDEX, CXR,CYR,CZR - DIRECTION COSINES (LAB. SYST.)
C*** ELR,PLR LAB. ENERGY AND LAB. MOMENTUM OF THE SAMPLED PARTICLE
C*** RESPECT., UNITS (GEV/C AND GEV)
C----------------------------
      LOWP=0
      IF (ITPRF(  N  ).LT.0) GO TO 99999
      WRITE(LUNOUT,99998) N
*     STOP    Commented out A. Fasso' 1989
      IR=0
      RETURN
99998 FORMAT (3(5H ****/),
     *45H FALSE USE OF THE PARTICLE TYPE INDEX, VALUE ,I4,3(5H ****/))
99999 CONTINUE
      IATMPT=0
         IF (ABS(PLAB-5.D0).GE.4.99999D0) THEN
            WRITE(LUNOUT,99996) PLAB
*           STOP     Commented out A. Fasso' 1989
            IR=0
            RETURN
99996       FORMAT (3(5H ****/),64
     *H PROJECTILE HADRON MOMENTUM OUTSIDE OF THE ALLOWED REGION, PLAB=,
     *1E15.5/,3(5H ****/))
      END IF
      UMODAT=N*1.11111D0+ITTA*2.19291D0
      IF (UMODAT.NE.UMODA.OR.(AMPROT-AM(1)).GT.1.D-6)CALL CALUMO(N,ITTA)
      UMODA=UMODAT
 1009 CONTINUE
      IATMPT=0
      LOWP=LOWP+1
 1000 CONTINUE
      IMACH=0
      REDU=2.D0
      IW1=0
      IF (LOWP.GT.20) GO TO 8
      NNN=N
      IF (NNN.EQ.N) GO TO 4322
      RUNTES=0.D0
      EFTES=0.D0
 4322 CONTINUE
      IS=1
      IR=0
      IST=1
      NSTAB=25
      IF ( ITTA .EQ. 1 ) THEN
         IRE=NURE(N,1)
      ELSE
         IRE=NURE(N,2)
      END IF
C
C-----------------------------
C*** IE,AMT,ECM,SI DETERMINATION
C----------------------------
      CALL FKSIGI(IRE,PLAB,N,IE,AMT,AMN,ECM,SI,ITTA)
      IF ( AMPROT - AM(1) .GT. 1.D-6 ) THEN
         IANTH = 1
         SI = 1.D0
      ELSE
         IANTH = -1
      END IF
      ECMMH=ECM
C
C-----------------------------
C    ENERGY INDEX
C  IRE CHARACTERIZES THE REACTION
C  IE IS THE ENERGY INDEX
C----------------------------
      IF (SI.LT.1.D-6) GO TO 8
      IF (N .LE.NSTAB) GO TO 1
      RUNTES=RUNTES+1.D0
      IF (RUNTES.LT.20.D0) WRITE(LUNOUT,602)N
 602   FORMAT(3H N=,I10,30H THE PROEKTILE IS A RESONANCE  )
      IF(IBAR(N).EQ.1) N=8
      IF(IBAR(N).EQ.-1)  N=9
   1  CONTINUE
      IMACH=IMACH+1
      IF (IMACH.GT.10) GO TO 8
      ECM =ECMMH
      AMN2=AMN**2
      AMT2=AMT**2
      ECMN=(ECM**2+AMN2-AMT2)/(2.D0*ECM)
      IF(ECMN.LE.AMN) ECMN=AMN
      PCMN=SQRT(ECMN**2-AMN2)
      GAM=(ELAB+AMT)/ECM
      BGAM=PLAB/ECM
      IF (IANTH.GE.0) ECM=2.1D0
C
C-----------------------------
C*** RANDOM CHOICE OF REACTION CHANNEL
C----------------------------
      IST=0
      CALL GRNDM(RNDM,1)
      VV = RNDM (1)
C
C-----------------------------
C***  PLACE REDUCED VERSION
C----------------------------
      IIEI=IEII(IRE)
      IDWK=IEII(IRE+1)-IIEI
      IIWK=IRII(IRE)
      IIKI=IKII(IRE)
C
C-----------------------------
C***  SHRINKAGE TO THE CONSIDERED ENERGY REGION FOR THE USE OF WEIGHTS
C----------------------------
      HECM=ECM
* The following cards assure that Ecm =< Umax + DUmax for this reaction
* where:
*       Umax  = max cms energy at which data are tabulated
*       DUmax = width of the last interval for the tabulated data
      HUMO=2.D0*UMO(IIEI+IDWK)-UMO(IIEI+IDWK-1)
      IF (HUMO.LT.ECM) ECM=HUMO
C
C-----------------------------
C*** INTERPOLATION PREPARATION
C----------------------------
* Cms energy of the upper limit of the considered energy interval
      ECMO=UMO(IE)
* Cms energy of the lower limit of the considered energy interval
      ECM1=UMO(IE-1)
* Width of the considered interval
      DECM=ECMO-ECM1
* Width from actual value to the upper limit (note that if Ecm > Ecmo
* it can be negative but its | | is always less than decm for the
* above condition on Humo
      DEC=ECMO-ECM
C
C-----------------------------
C*** RANDOM LOOP
C----------------------------
* Ik : index of the exit channel
      IK=0
      VFW=VV
      WKK=0.D+00
      WICOR=0.D+00
  111 CONTINUE
      IK=IK+1
* Save the weight accumulated up to now
      VFWO=WKK
* Get the index for the weight of ikth channel at ieth energy (upper
* limit of the interval in energy)
      IWK=IIWK+(IK-1)*IDWK+IE-IIEI
* Cumulative Weight of channels 1...ik at energy Ie
      WOK=WK(IWK)
* Difference for the cumulative weight of channels 1...ik at Ie and Ie-1
      WDK=WOK-WK(IWK-1)
* This card is not clear at all, it should zeroes the weight difference
* if we are in the first interval (that means take only the weights
* at the upper boundary of the interval)
      IF (PLAB.LT.PLABF(IIEI+2)) WDK=0.D+00
C
C-----------------------------
C*** TESTVARIABLE WICO/WICOR: IF CHANNEL IK HAS THE SAME WEIGHTS LIKE IK
C    GO TO NEXT CHANNEL, BECAUSE WKK((IK))-WKK((IK-1))=0, IK CAN NOT
C    CONTRIBUTE
C----------------------------
      WICO=WOK*1.23459876D0+WDK*1.735218469D0
      IF (WICO.EQ.WICOR) GO TO 111
* This card zeroes the weight difference if we are beyond the last
* interval
      IF (UMO(IIEI+IDWK).LT.HECM) WDK=0.D+00
* Save wico
      WICOR=WICO
C
C-----------------------------
C*** INTERPOLATION IN CHANNEL WEIGHTS
C----------------------------
* Set Eklim to a negative value to flag for Iefun it is a
* cms energy and not a lab momentum: this is the cms threshold
* for the exit channel ik
      EKLIM=-THRESH(IIKI+IK)
* Iefun returns the energy index of upper limit of the interval
* containing the threshold
      IELIM=IEFUN(EKLIM,IRE)
* Compute the difference between the upper limit and the
* threshold
      DELIM=UMO(IELIM)+EKLIM+ANGLSQ
* Dete is twice the difference between the actual energy value and
* the average value between Ecmo and the threshold
      DETE=(ECM-(ECMO-EKLIM)*.5D0)*2.D0
      IF ( DELIM*DELIM-DETE*DETE .GT. 0.D+00 ) THEN
         DECC=DELIM
      ELSE
         DECC=DECM
      END IF
      WKK=WOK-WDK*DEC/(DECC+ANGLSQ)
C
C-----------------------------
C*** RANDOM CHOICE
C----------------------------
C
      IF (VV.GT.WKK) GO TO 111
C
C***IK IS THE REACTION CHANNEL
C----------------------------
      INRK=IKII(IRE)+IK
      ECM=HECM
      I1001 =0
C
 1001 CONTINUE
      IT1=NRK(1,INRK)
      AM1=AMGA(IT1)
      IT2=NRK(2,INRK)
      AM2=AMGA(IT2)
      AMS=AM1+AM2
      I1001=I1001+1
      IF (I1001.GT.50) GO TO 1
C
      IF (IT2*AMS.GT.IT2*ECM) GO TO 1001
      IT11=IT1
      IT22=IT2
      IF (IANTH.GE.0) ECM=ELAB+AMT+0.00000001D0
      AM11=AM1
      AM22=AM2
      IF (IT2.GT.0) GO TO 401
C
C-----------------------------
C  INCLUSION OF DIRECT RESONANCES
C  RANDOM CHOICE OF DECAY CHANNELS OF THE DIRECT RESONANCE  IT1
C------------------------
      KZ1=K1(IT1)
      IST=IST+1
      IECO=0
*   Here was the mistake in the pseudo-masses treatment!!!!!
*     ECO=ECM
      ECO=ECMMH
      GAM=(ELAB+AMT)/ECO
      BGAM=PLAB/ECO
      CXS(1)=CX
      CYS(1)=CY
      CZS(1)=CZ
      GO TO 310
  401 CONTINUE
      CALL GRNDM(RNDM,1)
      IF ( RNDM(1) .LT. 0.5D0) GO TO 902
      IT1=IT22
      IT2=IT11
      AM1=AM22
      AM2=AM11
  902   CONTINUE
C
C-----------------------------
C   THE FIRST PARTICLE IS DEFINED TO BE THE FORWARD GOING ONE AT SMALL T
      IBN=IBAR(N)
      IB1=IBAR(IT1)
      IT11=IT1
      IT22=IT2
      AM11=AM1
      AM22=AM2
      IF(IB1.EQ.IBN) GO TO 901
      IT1=IT22
      IT2=IT11
      AM1=AM22
      AM2=AM11
 901  CONTINUE
C-----------------------------
C***IT1,IT2 ARE THE CREATED PARTICLES
C***MOMENTA AND DIRECTION COSINA IN THE CM - SYSTEM
C------------------------
      CALL TWOPAR(ECM1,ECM2,PCM1,PCM2,COD1,COD2,COF1,COF2,SIF1,SIF2,
     *IT1,IT2,ECM,ECMN,PCMN,N,AM1,AM2)
      IST=IST+1
      ITS(IST)=IT1
      AMM(IST)=AM1
C
C-----------------------------
C***TRANSFORMATION INTO LAB SYSTEM AND ROTATION
C----------------------------
      CALL TRAFO(GAM,BGAM,CX,CY,CZ,COD1,COF1,SIF1,PCM1,ECM1,PLS(IST),
     *CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IST=IST+1
      ITS(IST)=IT2
      AMM(IST)=AM2
      CALL TRAFO(GAM,BGAM,CX,CY,CZ,COD2,COF2,SIF2,PCM2,ECM2,PLS(IST),CXS
     *(IST),CYS(IST),CZS(IST),ELS(IST))
  200 CONTINUE
C
C-----------------------------
C***TEST   STABLE OR UNSTABLE
C----------------------------
      IF(ITS(IST).GT.NSTAB) GO TO 300
      IR=IR+1
C
C-----------------------------
C***IR IS THE NUMBER OF THE FINAL STABLE PARTICLE
C----------------------------
      IF (REDU.LT.0.D0) GO TO 1009
      ITR(IR)=ITS(IST)
       PLR(IR)=PLS(IST)
      CXR(IR)=CXS(IST)
      CYR(IR)=CYS(IST)
      CZR(IR)=CZS(IST)
      ELR(IR)=ELS(IST)
      IST=IST-1
      IF(IST.GE.1) GO TO 200
         GO TO 500
  300 CONTINUE
C
C  RANDOM CHOICE OF DECAY CHANNELS
C----------------------------
C
      IT=ITS(IST)
      ECO=AMM(IST)
      GAM=ELS(IST)/ECO
      BGAM=PLS(IST)/ECO
      IECO=0
      KZ1=K1(IT)
  310 CONTINUE
      IECO=IECO+1
      CALL GRNDM(RNDM,1)
      VV=RNDM(1)
      IIK=KZ1-1
  301 CONTINUE
      IIK=IIK+1
      IF (VV.GT.WT(IIK)) GO TO 301
C
C  IIK IS THE DECAY CHANNEL
C----------------------------
      IT1=NZK(IIK,1)
      I310=0
 1310 CONTINUE
      I310=I310+1
      AM1=AMGA(IT1)
      IT2=NZK(IIK,2)
      AM2=AMGA(IT2)
      IF (IT2-1.LT.0) GO TO 110
      IT3=NZK(IIK,3)
      AM3=AMGA(IT3)
      AMS=AM1+AM2+AM3
C
C  IF  IIK-KIN.LIM.GT.ACTUAL TOTAL CM-ENERGY, DO AGAIN RANDOM IIK-CHOICE
C----------------------------
      IF (IECO.LE.10) GO TO 1002
      IATMPT=IATMPT+1
* Note: we can go to 8 also for too many iterations
      IF (IATMPT.GT.3) GO TO 8
      GO TO 1000
 1002 CONTINUE
      IF (I310.GT.50) GO TO 310
      IF (AMS.GT.ECO) GO TO 1310
C
C  FOR THE DECAY CHANNEL
C  IT1,IT2, IT3 ARE THE PRODUCED PARTICLES FROM  IT
C----------------------------
      IF (REDU.LT.0.D0) GO TO 1009
      ITWTHC=0
      REDU=2.D0
      IF(IT3.EQ.0) GO TO 400
 4001 CONTINUE
      ITWTH=1
      CALL THREPD(ECO,ECM1,ECM2,ECM3,PCM1,PCM2,PCM3,COD1,COF1,SIF1,
     *COD2,COF2,SIF2,COD3,COF3,SIF3,AM1,AM2,AM3)
      GO TO 411
  400 CONTINUE
      CALL TWOPAD(ECO,ECM1,ECM2,PCM1,PCM2,COD1,COF1,SIF1,COD2,COF2,SIF2,
     *AM1,AM2)
      ITWTH=-1
      IT3=0
  411 CONTINUE
      ITWTHC=ITWTHC+1
      IF (REDU.GT.0.D0) GO TO 110
      REDU=2.D0
      IF (ITWTHC.GT.100) GO TO 1009
      IF (ITWTH) 400,400,4001
  110 CONTINUE
      ITS(IST  )=IT1
      IF (IT2-1.LT.0) GO TO 305
      ITS(IST+1)  =IT2
      ITS(IST+2)=IT3
      RX=CXS(IST)
      RY=CYS(IST)
      RZ=CZS(IST)
      AMM(IST)=AM1
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD1,COF1,SIF1,PCM1,ECM1,
     *PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IST=IST+1
      AMM(IST)=AM2
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD2,COF2,SIF2,PCM2,ECM2,
     *PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IF (IT3.LE.0) GO TO 305
      IST=IST+1
      AMM(IST)=AM3
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD3,COF3,SIF3,PCM3,ECM3,
     *PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
  305 CONTINUE
      GO TO 200
  500 CONTINUE
  631 CONTINUE
      RETURN
    8 CONTINUE
C
C----------------------------
C
C   ZERO CROSS SECTION CASE
C
C----------------------------
C
         IR=1
         ITR(1)=N
         CXR(1)=CX
         CYR(1)=CY
         CZR(1)=CZ
         ELR(1)=ELAB
         PLR(1)=PLAB
      RETURN
      END
+DECK,  HADRIV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:57  cernlib
* Geant

*$ CREATE HADRIV.FOR
*COPY HADRIV
*=== hadriv ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*    Modified version of Hadrin created by Alfredo Ferrari, INFN-Milan *
*                                                                      *
*    Last change  on  20-jun-92  by  Alfredo Ferrari, INFN - MIlan     *
*                                                                      *
*    hadriv: this is a modified version of Hadrin, used by the Eventv  *
*            package for hadron-hadron interactions below 5 GeV        *
*                                                                      *
*----------------------------------------------------------------------*
      SUBROUTINE HADRIV ( N, PLAB, ELAB, CX, CY, CZ, ITTA )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, FINLSP.
+CDE, HADFLG.
+CDE, METLSP.
+CDE, REAC.
+CDE, REDVER.
+CDE, SPLIT.
*
      COMMON / FKGAMR / REDU, AMO, AMM (15)
C
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
      COMMON / FKCODS / COD1, COD2, COD3, COF1, COF2, COF3, SIF1, SIF2,
     &                  SIF3, ECM1, ECM2, ECM3, PCM1, PCM2, PCM3
      COMMON / FKRUN    / RUNTES, EFTES
*
      PARAMETER ( AMPROT = 0.93827231D+00 )
      DIMENSION WCHANN (40), WCUMCH (0:40), IKIK (40)
      DIMENSION ITPRF(110)
      REAL RNDM(1)
      LOGICAL LSWAP
*
      SAVE IKIK,ITPRF
      DATA NNN / 0 /
      DATA IKIK /  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
     &            16, 17, 18 ,19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
     &            29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40 /
      DATA ITPRF/-1,-1,5*1,-1,-1,1,1,1,-1,-1,-1,-1,6*1,-1,-1,-1,85*1/
C
C-----------------------------
C*** INPUT VARIABLES LIST:
C*** SAMPLING OF HADRON NUCLEON INTERACTION FOR (ABOUT) 0.1 LE PLAB LE 6
C*** GEV/C LABORATORY MOMENTUM REGION
C*** N    - PROJECTILE HADRON INDEX
C*** PLAB - LABORATORY MOMENTUM OF N (GEV/C)
C*** ELAB - LABORATORY ENERGY OF N (GEV)
C*** CX,CY,CZ - DIRECTION COSINES OF N IN THE LABORATORY SYSTEM
C*** ITTA - TARGET NUCLEON INDEX
C*** OUTPUT VARIABLES LIST OF PARTICLE CHARACTERISTICS IN /FINLSP/
C  IR COUNTS THE NUMBER OF PRODUCED PARTICLES
C*** ITR - PARTICLE INDEX, CXR,CYR,CZR - DIRECTION COSINES (LAB. SYST.)
C*** ELR,PLR LAB. ENERGY AND LAB. MOMENTUM OF THE SAMPLED PARTICLE
C*** RESPECT., UNITS (GEV/C AND GEV)
C----------------------------
      LOWP=0
      IF (ITPRF(  N  ).LT.0) GO TO 99999
      WRITE(LUNOUT,99998) N
*     STOP    Commented out A. Fasso' 1989
      IR=0
      RETURN
99998 FORMAT (3(5H ****/),
     *45H FALSE USE OF THE PARTICLE TYPE INDEX, VALUE ,I4,3(5H ****/))
99999 CONTINUE
      IATMPT=0
         IF (ABS(PLAB-5.D0).GE.4.99999D0) THEN
            WRITE(LUNOUT,99996) PLAB
*           STOP     Commented out A. Fasso' 1989
            IR=0
            RETURN
99996       FORMAT (3(5H ****/),64
     *H PROJECTILE HADRON MOMENTUM OUTSIDE OF THE ALLOWED REGION, PLAB=,
     *1E15.5/,3(5H ****/))
      END IF
      INEWHD = N + 1000 * ITTA
      IF ( INEWHD .NE. IOLDHD ) THEN
         CALL CALUMV (N,ITTA)
      ELSE IF ( (AMPROT-AM(1)) .GT. 1.D-6 ) THEN
         CALL CALUMV (N,ITTA)
         INEWHD = - INEWHD
      END IF
      IOLDHD = INEWHD
 1009 CONTINUE
      IATMPT=0
      LOWP=LOWP+1
 1000 CONTINUE
      IMACH=0
      REDU=2.D0
      IW1=0
      IF (LOWP.GT.20) GO TO 8
      NNN=N
*  +-------------------------------------------------------------------*
*  |  The following condition is never verified
      IF (NNN.NE.N) THEN
         RUNTES=0.D0
         EFTES=0.D0
      END IF
*  |
*  +-------------------------------------------------------------------*
      IS=1
      IR=0
      IST=1
      NSTAB=25
*  +-------------------------------------------------------------------*
*  |  Select the reaction channel Ire: proton target
      IF ( ITTA .EQ. 1 ) THEN
         IRE = NURE(N,1)
*  |
*  +-------------------------------------------------------------------*
*  |  neutron target
      ELSE
         IRE = NURE(N,2)
      END IF
*  |
*  +-------------------------------------------------------------------*
*  Elastic scattering index:
      IELSCT = MIN (N,ITTA) + 1000 * MAX (N,ITTA)
C
C-----------------------------
C*** IE,AMT,ECM,SI DETERMINATION
C----------------------------
      CALL FKSIGI(IRE,PLAB,N,IE,AMT,AMN,ECM,SI,ITTA)
*  +------------------------------------------------------------------*
*  |  Check if masses have been changed for annihilation treated with
*  |  pseudo masses
      IF ( AMPROT - AM(1) .GT. 1.D-6 ) THEN
         IANTH = 1
         SI = 1.D0
*  |
*  +------------------------------------------------------------------*
*  |
      ELSE
         IANTH = -1
      END IF
*  |
*  +------------------------------------------------------------------*
      ECMMH=ECM
C
C-----------------------------
C    ENERGY INDEX
C  IRE CHARACTERIZES THE REACTION
C  IE IS THE ENERGY INDEX
C----------------------------
      IF (SI.LT.1.D-10) GO TO 8
* The following condition should be always verified
      IF (N .LE.NSTAB) GO TO 1
      RUNTES=RUNTES+1.D0
      IF (RUNTES.LT.20.D0) WRITE(LUNOUT,602)N
 602   FORMAT(3H N=,I10,30H THE PROEKTILE IS A RESONANCE  )
      IF(IBAR(N).EQ.1) N=8
      IF(IBAR(N).EQ.-1)  N=9
*  **** Come here ( 1 continue ) every time we unsuccessfully selected
*       for more than 50 times the mass of the produced resonaces ****
   1  CONTINUE
      IMACH=IMACH+1
      IF (IMACH.GT.10) GO TO 8
      ECM =ECMMH
      AMN2=AMN**2
      AMT2=AMT**2
*  CMS energy of the projectile
      ECMN=(ECM**2+AMN2-AMT2)/(2.D0*ECM)
*  It should never happen
      IF(ECMN.LE.AMN) ECMN=AMN
*  CMS momentum of the projectile (and of the target)
      PCMN=SQRT(ECMN**2-AMN2)
      GAM=(ELAB+AMT)/ECM
      BGAM=PLAB/ECM
      IF (IANTH.GE.0) ECM=2.1D0
*  From this point starts the random choiche of the reaction channel:
*  it was extensively modified by A. Ferrari
      IST=0
* Initial energy index for the reaction IRE (index 0)
      IIEI=IEII(IRE)
* Number of energy intervals for the reaction IRE
      IDWK=IEII(IRE+1)-IIEI
* Initial index for the exit channel weights
      IIWK=IRII(IRE)
* Initial index (for 0) of the exit channels
      IIKI=IKII(IRE)
* Number of exit channels of reaction ire
      IKE =IKII(IRE+1)-IIKI
* *** Shrinkage to the considered energy region for the use of weights
      HECM=ECM
* The following cards assure that Ecm =< Umax + DUmax for this reaction
* where:
*       Umax  = max cms energy at which data are tabulated
*       DUmax = width of the last interval for the tabulated data
      HUMO=2.D0*UMO(IIEI+IDWK)-UMO(IIEI+IDWK-1)
      IF (HUMO.LT.ECM) ECM=HUMO
* *** Interpolation preparation
* Cms energy of the upper limit of the considered energy interval
      ECMO=UMO(IE)
* Cms energy of the lower limit of the considered energy interval
      ECM1=UMO(IE-1)
* Width of the considered interval
      DECM=ECMO-ECM1
* Width from actual value to the lower limit (note that if Ecm > Ecmo
* it can be larger than Decm but it is always less than 2xdecm for the
* above condition on Humo
      DEC0=ECM -ECM1
* Set to 1 the default total weight
      WACCUM = 1.D+00
      WCUMCH (0) = 0.D+00
      WCUMIE = 0.D+00
      WCUMI0 = 0.D+00
      WCSUM0 = 0.D+00
      CALL GRNDM(RNDM,1)
      RNDMIK = RNDM (1)
      IOUT1  = NRK (1,IIKI+1)
      IOUT2  = NRK (2,IIKI+1)
      IELCHK = MIN ( IOUT1, IOUT2 ) + 1000 * MAX ( IOUT1, IOUT2 )
*  +-------------------------------------------------------------------*
*  |  Look for "inverse" reactions for which the elastic channel is not
*  |  the first: for these reactions we must exchange the weight of
*  |  the elastic channel with the charge exchange one at minimum, to
*  |  fulfill the detailed balance theorem
      IF ( IELCHK .NE. IELSCT ) THEN
         LSWAP  = .TRUE.
         IELCHA = IKCHXG (IRE)
         ICXCHA = 1
         IKIK (1) = IELCHA
         IKIK (IELCHA) = 1
*  |
*  +-------------------------------------------------------------------*
*  |  Loop to find the elastic channel
      ELSE
         LSWAP  = .FALSE.
         IELCHA = 1
         ICXCHA = IKCHXG (IRE)
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Loop on the exit channels:
*  |                              Jkk = index for weights
*  |                              Ik  = index for reaction
*  |  usually they are the same, but for "inverse" reactions where the
*  |  elastic and the charge exchange channels are exchanged, for these
*  |  two channels they are crossed
      DO 2000 JKK = 1, IKE
*  |  Ik : index of the exit channel under consideration
         IK = IKIK (JKK)
*  |  Get the index for the weight of ikth channel at ieth energy (upper
*  |  limit of the interval in energy)
         IWK = IIWK + (JKK-1) * IDWK + IE - IIEI
*  |  Cumulative Weight of channels 1...ik at energy Ie
         WIEK   = WK (IWK)
*  |  +----------------------------------------------------------------*
*  |  |  Check if we are in the first interval: is so all the weights
*  |  |  are set to zero for Ie-1, for all channels, so set them to the
*  |  |  same value as for Ie to get the proper normalization to 1,
*  |  |  then possible thresholds are accounted for after
         IF ( IE .LE. IIEI+2 ) THEN
            WIEM1K = WIEK
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |  Cumulative Weight of channels 1...ik at energy Ie-1
         ELSE
            WIEM1K = WK (IWK-1)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  Compute the weight at Ie for this channel
         WIEK   = WIEK   - WCUMIE
*  |  Compute the weight at Ie-1 for this channel
         WIEM1K = WIEM1K - WCUMI0
*  |  +----------------------------------------------------------------*
*  |  |  This channel is not open at energies Ie and Ie-1
         IF ( WIEM1K + WIEK .LE. ANGLGB ) THEN
            WCHANN (JKK) = 0.D+00
            WCUMCH (JKK) = WCUMCH (JKK-1)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
*  |  |  Set Eklim to a negative value to flag for Iefun it is a
*  |  |  cms energy and not a lab momentum: this is the cms threshold
*  |  |  for the exit channel ik
            EKLIM = - THRESH (IIKI+IK)
*  |  |  Iefun returns the energy index of upper limit of the interval
*  |  |  containing the threshold
            IELIM = IEFUN (EKLIM,IRE)
            EKLIM = - EKLIM
            WCHAN0 = WIEM1K + ( WIEK - WIEM1K ) * DEC0 / DECM
            WCSUM0 = WCSUM0 + WCHAN0
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if we are below threshold
            IF ( ECM .LE. EKLIM ) THEN
               WCHANN (JKK) = 0.D+00
               WCUMCH (JKK) = WCUMCH (JKK-1)
               WCUMIE = WCUMIE + WIEK
               WCUMI0 = WCUMI0 + WIEM1K
               RNDRED = WCHAN0
               WACCUM = WACCUM - RNDRED
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |  We are above threshold
            ELSE
               WCUMIE = WCUMIE + WIEK
               WCUMI0 = WCUMI0 + WIEM1K
               ECMD   = MAX ( EKLIM, ECM1 )
               DEC    = ECM  - ECMD
               DECC   = ECMO - ECMD
               WCHANN (JKK) = WIEM1K + ( WIEK - WIEM1K ) * DEC / DECC
*  |  |  |  If we are beyond the last tabulated point and the xsec for
*  |  |  |  this channel is going down it can happen that Wchann < 0
*  |  |  |  set it to 0 and correct according to the usual formalism
               WCHANN (JKK) = MAX ( WCHANN (JKK), ZERZER )
               RNDRED = WCHAN0 - WCHANN (JKK)
               WACCUM = WACCUM - RNDRED
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Ielflg check: first of all check if this channel
*  |  |  |  |  is the elastic one and if so if reduction must be applied
*  |  |  |  |  to
               IF ( IK .EQ. IELCHA .AND. IELFLG .NE. 0 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  Elastic scattering reduced due to collision in the
*  |  |  |  |  |  nucleus and not with a free proton/neutron
                  IF ( IELFLG .LT. 0 ) THEN
                     IF ( IBAR (N) .NE. 0 ) THEN
                        REDUC = PLAB / PPAMXB
                        REDUC = PAUMXB * REDUC / ( 1.D+00 + REDUC**2 )
                     ELSE
                        REDUC = PLAB / PPAMXM
                        REDUC = PAUMXM * REDUC / ( 1.D+00 + REDUC**2 )
                     END IF
                     RNDRED = WCHANN (JKK) * ( 1.D+00 - REDUC )
                     WCHANN (JKK) = WCHANN (JKK) - RNDRED
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  Elastic scattering forbidden
                  ELSE
                     RNDRED = WCHANN (JKK)
                     WCHANN (JKK) = 0.D+00
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  WACCUM = WACCUM - RNDRED
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Icxflg check: first of all check if this channel
*  |  |  |  |  is the charge exchange one and if so if reduction must
*  |  |  |  |  be applied to
               ELSE IF ( IK .EQ. ICXCHA .AND. ICXFLG .NE. 0 )THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  Charge exchange reduced due to collision in the
*  |  |  |  |  |  nucleus and not with a free proton/neutron
                  IF ( ICXFLG .LT. 0 ) THEN
                     IF ( IBAR (N) .NE. 0 ) THEN
                        REDUC = PLAB / PPAMXB
                        REDUC = PAUMXB * REDUC / ( 1.D+00 + REDUC**2 )
                     ELSE
                        REDUC = PLAB / PPAMXM
                        REDUC = PAUMXM * REDUC / ( 1.D+00 + REDUC**2 )
                     END IF
                     RNDRED = WCHANN (JKK) * ( 1.D+00 - REDUC )
                     WCHANN (JKK) = WCHANN (JKK) - RNDRED
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  | Charge exchange forbidden
                  ELSE
                     RNDRED = WCHANN (JKK)
                     WCHANN (JKK) = 0.D+00
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  WACCUM = WACCUM - RNDRED
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               WCUMCH (JKK) = WCUMCH (JKK-1) + WCHANN (JKK)
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            RNDMCH = RNDMIK * WACCUM
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if a possible decrease/increase of this channel
*  |  |  |  opened one of the already examinated channels
            IF ( RNDMCH .LT. WCUMCH (JKK-1) ) THEN
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Loop on the previous channels
               DO 1900 JPK = 1, JKK - 1
                  IF ( RNDMCH .LT. WCUMCH (JPK) ) THEN
                     IK = IKIK (JPK)
                     GO TO 2100
                  END IF
 1900          CONTINUE
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check if this one is the right channel
            ELSE IF ( RNDMCH .LT. WCUMCH (JKK) ) THEN
               GO TO 2100
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 2000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      IK = IELCHA
      WRITE (LUNERR,*)' **** Hadriv: elastic channel selected when',
     &                ' prohibited ! ****',N,ELAB,PLAB
*  Finally we selected channel ik
 2100 CONTINUE
* *** Ik is the reaction channel ***
*  +-------------------------------------------------------------------*
*  |  Set to the default values the array Ikik
      IF ( LSWAP ) THEN
         IKIK (1) = 1
         IKIK (IELCHA) = IELCHA
      END IF
*  |
*  +-------------------------------------------------------------------*
      INRK=IKII(IRE)+IK
*  First resonance to be created
      IT1=NRK(1,INRK)
*  Second resonance to be created
      IT2=NRK(2,INRK)
      ECM=HECM
      I1001 =0
*  +-------------------------------------------------------------------*
*  |  Rejection loop for the choiche of the resonance masses
 1001 CONTINUE
         IF (I1001.GT.50) GO TO 1
*  |  Selection of the resonance mass according to its width
         AM1=AMGA(IT1)
*  |  Selection of the resonance mass according to its width
         AM2=AMGA(IT2)
         AMS=AM1+AM2
         I1001=I1001+1
      IF ( IT2*AMS .GT. IT2*ECM ) GO TO 1001
*  |--<--<--<--<--<--<  Loop back if m1+m2 > Ecm
*  +-------------------------------------------------------------------*
      IT11=IT1
      IT22=IT2
      IF (IANTH.GE.0) ECM=ELAB+AMT+0.00000001D0
      AM11=AM1
      AM22=AM2
*  +-------------------------------------------------------------------*
*  |  Direct (single) resonances
      IF (IT2.LE.0) THEN
*  | Random choice of decay channels of the direct resonance  it1
         KZ1=K1(IT1)
         IST=IST+1
         IECO=0
*  |   Here was the mistake in the pseudo-masses treatment!!!!!
*        ECO=ECM
         ECO=ECMMH
         GAM=(ELAB+AMT)/ECO
         BGAM=PLAB/ECO
         CXS(1)=CX
         CYS(1)=CY
         CZS(1)=CZ
         GO TO 310
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      CALL GRNDM(RNDM,1)
      IF ( RNDM(1) .LT. 0.5D+00 ) THEN
         IT1=IT22
         IT2=IT11
         AM1=AM22
         AM2=AM11
      END IF
*  |
*  +-------------------------------------------------------------------*
C
C-----------------------------
C   THE FIRST PARTICLE IS DEFINED TO BE THE FORWARD GOING ONE AT SMALL T
      IBN=IBAR(N)
      IB1=IBAR(IT1)
      IT11=IT1
      IT22=IT2
      AM11=AM1
      AM22=AM2
*  +-------------------------------------------------------------------*
*  |
      IF(IB1.NE.IBN) THEN
         IT1=IT22
         IT2=IT11
         AM1=AM22
         AM2=AM11
      END IF
*  |
*  +-------------------------------------------------------------------*
C-----------------------------
C***IT1,IT2 ARE THE CREATED PARTICLES
C***MOMENTA AND DIRECTION COSINA IN THE CM - SYSTEM
C------------------------
      CALL TWOPAR(ECM1,ECM2,PCM1,PCM2,COD1,COD2,COF1,COF2,SIF1,SIF2,
     *IT1,IT2,ECM,ECMN,PCMN,N,AM1,AM2)
      IST=IST+1
      ITS(IST)=IT1
      AMM(IST)=AM1
C
C-----------------------------
C***TRANSFORMATION INTO LAB SYSTEM AND ROTATION
C----------------------------
      CALL TRAFO(GAM,BGAM,CX,CY,CZ,COD1,COF1,SIF1,PCM1,ECM1,PLS(IST),
     *CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IST=IST+1
      ITS(IST)=IT2
      AMM(IST)=AM2
      CALL TRAFO(GAM,BGAM,CX,CY,CZ,COD2,COF2,SIF2,PCM2,ECM2,PLS(IST),CXS
     *(IST),CYS(IST),CZS(IST),ELS(IST))
  200 CONTINUE
C
C-----------------------------
C***TEST   STABLE OR UNSTABLE
C----------------------------
      IF(ITS(IST).GT.NSTAB) GO TO 300
      IR=IR+1
C
C-----------------------------
C***IR IS THE NUMBER OF THE FINAL STABLE PARTICLE
C----------------------------
      IF (REDU.LT.0.D0) GO TO 1009
      ITR(IR)=ITS(IST)
      PLR(IR)=PLS(IST)
      CXR(IR)=CXS(IST)
      CYR(IR)=CYS(IST)
      CZR(IR)=CZS(IST)
      ELR(IR)=ELS(IST)
      IST=IST-1
      IF(IST.GE.1) GO TO 200
         GO TO 500
  300 CONTINUE
C
C  RANDOM CHOICE OF DECAY CHANNELS
C----------------------------
C
      IT=ITS(IST)
      ECO=AMM(IST)
      GAM=ELS(IST)/ECO
      BGAM=PLS(IST)/ECO
      IECO=0
      KZ1=K1(IT)
  310 CONTINUE
      IECO=IECO+1
      CALL GRNDM(RNDM,1)
      VV=RNDM(1)
      IIK=KZ1-1
  301 CONTINUE
         IIK=IIK+1
      IF (VV.GT.WT(IIK)) GO TO 301
C
C  IIK IS THE DECAY CHANNEL
C----------------------------
      IT1=NZK(IIK,1)
      I310=0
 1310 CONTINUE
         I310=I310+1
         AM1=AMGA(IT1)
         IT2=NZK(IIK,2)
         AM2=AMGA(IT2)
         IF (IT2-1.LT.0) GO TO 110
         IT3=NZK(IIK,3)
         AM3=AMGA(IT3)
         AMS=AM1+AM2+AM3
C
C  IF  IIK-KIN.LIM.GT.ACTUAL TOTAL CM-ENERGY, DO AGAIN RANDOM IIK-CHOICE
C----------------------------
         IF (IECO.GT.10) THEN
            IATMPT=IATMPT+1
* Note: we can go to 8 also for too many iterations
            IF (IATMPT.GT.3) GO TO 8
            GO TO 1000
         END IF
         IF (I310.GT.50) GO TO 310
      IF (AMS.GT.ECO) GO TO 1310
C
C  FOR THE DECAY CHANNEL
C  IT1,IT2, IT3 ARE THE PRODUCED PARTICLES FROM  IT
C----------------------------
      IF (REDU.LT.0.D0) GO TO 1009
      ITWTHC=0
      REDU=2.D0
      IF(IT3.EQ.0) GO TO 400
 4001 CONTINUE
      ITWTH=1
      CALL THREPD(ECO,ECM1,ECM2,ECM3,PCM1,PCM2,PCM3,COD1,COF1,SIF1,
     *COD2,COF2,SIF2,COD3,COF3,SIF3,AM1,AM2,AM3)
      GO TO 411
  400 CONTINUE
      CALL TWOPAD(ECO,ECM1,ECM2,PCM1,PCM2,COD1,COF1,SIF1,COD2,COF2,SIF2,
     *AM1,AM2)
      ITWTH=-1
      IT3=0
  411 CONTINUE
      ITWTHC=ITWTHC+1
      IF (REDU.GT.0.D0) GO TO 110
      REDU=2.D0
      IF (ITWTHC.GT.100) GO TO 1009
      IF (ITWTH) 400,400,4001
  110 CONTINUE
      ITS(IST)=IT1
      IF (IT2.LE.0) GO TO 305
      ITS(IST+1)=IT2
      ITS(IST+2)=IT3
      RX=CXS(IST)
      RY=CYS(IST)
      RZ=CZS(IST)
      AMM(IST)=AM1
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD1,COF1,SIF1,PCM1,ECM1,
     *PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IST=IST+1
      AMM(IST)=AM2
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD2,COF2,SIF2,PCM2,ECM2,
     *PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
      IF (IT3.LE.0) GO TO 305
      IST=IST+1
      AMM(IST)=AM3
      CALL TRAFO(GAM,BGAM,RX,RY,RZ,COD3,COF3,SIF3,PCM3,ECM3,
     *PLS(IST),CXS(IST),CYS(IST),CZS(IST),ELS(IST))
  305 CONTINUE
      GO TO 200
  500 CONTINUE
  631 CONTINUE
      RETURN
    8 CONTINUE
C
C----------------------------
C
C   ZERO CROSS SECTION CASE
C
C----------------------------
C
         IR=1
         ITR(1)=N
         CXR(1)=CX
         CYR(1)=CY
         CZR(1)=CZ
         ELR(1)=ELAB
         PLR(1)=PLAB
      RETURN
      END
+DECK,  HEVHIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:57  cernlib
* Geant

*$ CREATE HEVHIN.FOR
*COPY HEVHIN
*=== hevhin ===========================================================*
      SUBROUTINE HEVHIN ( NHAD, KPROJ, KTARG, PPROJ, EPROJ, UMO )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 01 october 1991   by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 01-oct-91     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, FINLSP.
+CDE, HADPAR.
+CDE, PART.
      PARAMETER ( CXDUM = 0.D+00 )
      PARAMETER ( CYDUM = 0.D+00 )
      PARAMETER ( CZDUM = 1.D+00 )
*
      ELAB = EPROJ
      PLAB = PPROJ
      N    = KPROJ
      ITTA = KTARG
      CALL HADRIV ( N, PLAB, ELAB, CXDUM, CYDUM, CZDUM, ITTA )
      NHAD = IR
      DO 1000 I = 1, IR
         HEPH (I) = ELR (I)
         PXH  (I) = PLR (I) * CXR (I)
         PYH  (I) = PLR (I) * CYR (I)
         PZH  (I) = PLR (I) * CZR (I)
         NREH (I) = ITR (I)
         ICHH (I) = ICH  (NREH(I))
         IBARH(I) = IBAR (NREH(I))
         AMH  (I) = AM   (NREH(I))
         ANH  (I) = ANAME(NREH(I))
 1000 CONTINUE
*=== End of subroutine Hevhin =========================================*
      RETURN
      END
+DECK,  HINHEV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:57  cernlib
* Geant

*$ CREATE HINHEV.FOR
*COPY HINHEV
*=== hinhev ===========================================================*
      SUBROUTINE HINHEV ( N, PLAB, ELAB, ITTA )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 01 october 1991   by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 01-oct-91     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, FINLSP.
+CDE, HADPAR.
+CDE, PART.
*
      EPROJ = ELAB
      PPROJ = PLAB
      KPROJ = N
      KTARG = ITTA
      AMTAR = AM (KTARG)
      UMO   = SQRT ( ( EPROJ + AMTAR - PPROJ ) * ( EPROJ + AMTAR
     &      + PPROJ ) )
      NHAD  = 0
      CALL HADEVV ( NHAD, KPROJ, KTARG, PPROJ, EPROJ, UMO )
      IR = NHAD
      DO 1000 I = 1, NHAD
         ELR (I) = HEPH (I)
         PLR (I) = SQRT ( ( HEPH (I) - AMH (I) ) * ( HEPH (I) + AMH (I)
     &           ) )
         CXR (I) = PXH (I) / PLR (I)
         CYR (I) = PYH (I) / PLR (I)
         CZR (I) = PZH (I) / PLR (I)
         ITR (I) = NREH (I)
 1000 CONTINUE
*=== End of subroutine hinhev =========================================*
      RETURN
      END
+DECK,  HKLASS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

*$ CREATE HKLASS.FOR
*COPY HKLASS
*=== hklass ===========================================================*
      SUBROUTINE HKLASS(IT,LT,LA,LL,KFR1,KFR2,KR1R,KR2R,KR1L,KR2L,IV,
     *IMPS,IMVE,IB08,IA08,IB10,IA10,AS,B8,KFA1,KFA2,KFA3,KFA4,IOPT)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Hklass89: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
+CDE, FINPAR2.
+CDE, PART.
      LOGICAL LSWTCH
      COMMON/FKVALI/LSWTCH
      DIMENSION KFR1(*),KFR2(*),IV(*),IMPS(6,6),IMVE(6,6),
     *IB08(6,21),IB10(6,21),IA08(6,21),IA10(6,21)
      REAL RNDM(2)
C     CLASSIFICATION OF THE HADRONS ACCORDING TO THEIR FLAVOUR CONTENTS
*
*or      IF (LT.EQ.1)WRITE(LUNOUT,288)IT,LT,LA,LL,KR1R,KR2R,KR1L,KR2L,
*or     *AS,B8,KFA1,KFA2,KFA3,KFA4,IOPT
*or  288 FORMAT (8I5,2E12.4,5I5/
*or     *' HKLASS IT,LT,LA,LL,KR1R,KR2R,KR1L,KR2L,AS,B8,KFA1,KFA2,KFA3,'
*or     *,'KFA4,IOPT')
C**RESC=PROBABILITY FOR AN U,AU/D,AD/U,AD/D,AU PAIR TO BECOME E HEAVY
C**RESONANCE RO,R+,R-
      RESC=0.5D0
      IX=0
      CALL GRNDM(RNDM,2)
      X=RNDM(1)
      Z=RNDM(2)
      IF(LA.EQ.0) GO TO 100
      A=KR1R*KR2R*KR1L*KR2L
      IF(A.EQ.0) GO TO 90
      IX=1
      LI=KR1R-6
      LJ=KR1L
      I=IT
      GO TO 10
  101 IX=2
      LI=KR2R-6
      LJ=KR2L
      I=IT+1
      IT=IT+1
      GO TO 10
   90 B=KR1R*KR2R
      C=KR1L*KR2L
      IF(B.GT.0.D0.OR.C.GT.0.D0) GO TO 91
      LJ=KR1R
      IF(KR1R.EQ.0)LJ=KR2R
      LI=KR1L-6
      IF(KR1L.EQ.0)LI=KR2L-6
      I=IT
      GO TO 10
   91 IF(B.GT.0.D0) GO TO 92
      LI=KR1R
      IF(KR1R.EQ.0)LI=KR2R
      KA=KR1L
      KB=KR2L
      CALL INDEX2(KA,KB,IND)
      LJ=IND
      I=IT
      GO TO 20
   92 LI=KR1L-6
      IF(KR1L.EQ.0)LI=KR2L-6
      KA=KR1R-6
      KB=KR2R-6
      CALL INDEX2(KA,KB,IND)
      LJ=IND
      I=IT
      GO TO 30
C     LA=0
  100 CONTINUE
      I=IT
      J=IT-1
      K1I=KFR1(I)
      K2I=KFR2(I)
      K2J=0
      K1J=KFA1
      IF(I.GT.1) GO TO 5555
      IF(IOPT.EQ.3.AND.LL.EQ.1) K1J=KFA2
      IF(IOPT.EQ.2) K1J=KFA1
      IF(IOPT.EQ.2) K2J=KFA2
      IF(IOPT.EQ.4.AND.KFA1.LE.6.AND.LL.EQ.1) K1J=KFA2
      IF(IOPT.EQ.4.AND.KFA1.LE.6.AND.LL.EQ.1) K2J=KFA3
      IF(IOPT.EQ.4.AND.KFA1.GT.6.AND.LL.EQ.0) K1J=KFA2
      IF(IOPT.EQ.4.AND.KFA1.GT.6.AND.LL.EQ.0) K2J=KFA3
      IF(IOPT.EQ.5.AND.LL.EQ.0) K1J=KFA3
      IF(IOPT.EQ.5.AND.LL.EQ.0) K2J=KFA4
      IF(IOPT.EQ.5.AND.LL.EQ.1) K1J=KFA1
      IF(IOPT.EQ.5.AND.LL.EQ.1) K2J=KFA2
 5555 CONTINUE
      IF(I.GT.1)K1J=KFR1(J)
      IF(I.GT.1)K2J=KFR2(J)
      IVY=IV(I)
*or      IF(LT.EQ.0) GO TO 606
*or      WRITE(LUNOUT,601)K1I,K2I,K1J,K2J,IVY,I,LL,LA
*or  601 FORMAT(1H0,8I3,27HK1I,K2I,K1J,K2J,IVY,I,LL,LA)
*or  606 CONTINUE
      GO TO(1,4,5,2,3,1,4,5,2,3),IVY
    1 LI=K1I
      LJ=K1J
      IF(LL.EQ.1)LI=K1J-6
      IF(LL.EQ.1)LJ=K1I-6
      GO TO 10
    2 LI=K1J-6
      LJ=K1I-6
      IF(LL.EQ.1) LI=K1I
      IF(LL.EQ.1)LJ=K1J
      GO TO 10
    3 LI=K2J-6
      LJ=K2I-6
      IF(LL.EQ.1)LI=K2I
      IF(LL.EQ.1)LJ=K2J
      GO TO 10
    4 LI=K1J
      IF(LL.EQ.1)LI=K1J-6
      KA=K1I
      KB=K2I
      IF(LL.EQ.0)KA=K1I-6
      IF(LL.EQ.0)KB=K2I-6
      IF(LL.EQ.1)KA=K1I
      IF(LL.EQ.1)KB=K2I
      CALL INDEX2(KA,KB,IND)
      LJ=IND
      IF(LL.EQ.1) GO TO 30
      GO TO 20
    5 LI=K1I
      IF(LL.EQ.1)LI=K1I-6
      KA=K1J
      KB=K2J
      IF(LL.EQ.0)KA=K1J-6
      IF(LL.EQ.0)KB=K2J-6
      CALL INDEX2(KA,KB,IND)
      LJ=IND
      IF(LL.EQ.1) GO TO 20
      GO TO 30
C     MESONENAUSWAHL
   10 CONTINUE
      IF(X.LE.AS) GO TO 11
      INDEX=IMVE(LI,LJ)
      IF(INDEX.EQ.33.AND.Z.LE.0.5D0)INDEX=35
      IF(.NOT.LSWTCH) GO TO 40
      CALL GRNDM(RNDM,1)
      X=RNDM(1)
      IF(X.GE.RESC) GO TO 40
      IF(INDEX.EQ.33.OR.INDEX.EQ.35.OR.INDEX.EQ.96) INDEX=181
      IF(INDEX.EQ.32) INDEX=182
      IF(INDEX.EQ.34) INDEX=183
      GO TO 40
   11 INDEX=IMPS(LI,LJ)
      IF(INDEX.EQ.23) GO TO 15
      IF(INDEX.EQ.31.AND.Z.LE.0.33D0)INDEX=95
      IF(.NOT.LSWTCH) GO TO 40
      IF(INDEX.EQ.31.AND.Z.LE.0.97D0)INDEX=95
      CALL GRNDM(RNDM,1)
      X=RNDM(1)
      IF(X.GE.RESC) GO TO 40
      IF(INDEX.EQ.23.OR.INDEX.EQ.31.OR.INDEX.EQ.95) INDEX=181
      IF(INDEX.EQ.13) INDEX=182
      IF(INDEX.EQ.14) INDEX=183
      GO TO 40
C     BARYONMULTIPLETTS
   20 CONTINUE
      B10=1.D0-B8
      IF(X.LE.B8)GO TO 21
   24 INDEX=IB10(LI,LJ)
      GO TO 40
   21 INDEX=IB08(LI,LJ)
      IF(INDEX.EQ.22.AND.Z.LE.0.5D0)INDEX=17
      IF(INDEX.EQ.137.AND.Z.LE.0.5D0)INDEX=141
      IF(INDEX.EQ.138.AND.Z.LE.0.5D0)INDEX=143
      IF(INDEX.EQ.139.AND.Z.LE.0.5D0)INDEX=144
      IF(INDEX.EQ.0)GO TO 24
      GO TO 40
C     ANTIBARYONMULTIPLETTS
   30 CONTINUE
      A8=B8
      A10=1.D0-A8
      IF(X.LE.A8)GO TO 31
   34 INDEX=IA10(LI,LJ)
      GO TO 40
   31 INDEX=IA08(LI,LJ)
      IF(INDEX.EQ.100.AND.Z.LE.0.5D0)INDEX=18
      IF(INDEX.EQ.149.AND.Z.LE.0.5D0)INDEX=153
      IF(INDEX.EQ.150.AND.Z.LE.0.5D0)INDEX=155
      IF(INDEX.EQ.151.AND.Z.LE.0.5D0)INDEX=156
      IF(INDEX.EQ.0)GO TO 34
      GO TO 40
 15   CONTINUE
      IF(LSWTCH)THEN
        IF(Z.LE.0.5D0)INDEX=31
        IF(Z.LE.0.5D0*0.03D0)INDEX=95
      ELSE
        IF(Z.LE.0.5D0)INDEX=33
        IF(Z.LE.0.5D0*0.67D0)INDEX=95
      ENDIF
      GO TO 40
C     UEBERLESEN DER HADRONDATEN
   40 CONTINUE
      IF(LT.EQ.0) GO TO 604
      WRITE(LUNOUT,602)INDEX
  602 FORMAT(1H0,I3,6H=INDEX)
  604 CONTINUE
      ANF(I)=ANAME(INDEX)
      AMF(I)=AM(INDEX)
      ICHF(I)=ICH(INDEX)
      IBARF(I)=IBAR(INDEX)
      NREF(I)=INDEX
      IF(IX.EQ.1)GO TO 101
      IF(IX.EQ.2)GO TO 500
      GO TO 500
  500 CONTINUE
      IF(LT.EQ.0) GO TO 600
      IZ=0
      IF(IX.EQ.2)I=I-1
  504 CONTINUE
      WRITE(LUNOUT,503)ANF(I),AMF(I),ICHF(I),IBARF(I),NREF(I),LL
  503 FORMAT((1X,A7,1X,F6.3,1X,4(I3,1X),
     *'MAME,MASS,Q,BQ,NR,LL'))
      IF(IX.EQ.0) GO TO 600
      IZ=IZ+1
      IF(IZ.EQ.2) GO TO 600
      I=I+1
      GO TO 504
  600 CONTINUE
      RETURN
      END
+DECK,  HYPERO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

*$ CREATE HYPERO.FOR
*COPY HYPERO
*=== hypero ===========================================================*
      SUBROUTINE HYPERO(IT,ITNUCR,SICO,PLABCO)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      COMMON /FKABLT/ AM(330),ICH(110),IBAR(110),K(220)
*     DIMENSION SICOR(30)
      DIMENSION IHATRS(30),INUTRS(30)
      DATA IHATRS/16*30,25,24,30,16,15,25,8*30/
C
C--------------------------------------------------
C*** ATTENSION, IN CASE OF IT=SIG+=21 NO STRANGENES-CONS.,DIFFER.1UNIT
C--------------------------------------------------
      DATA INUTRS/16*30,8,2,30,8,1,8,8*30/
      ITNUCR=INUTRS(IT)
      ITHACR=IHATRS(IT)
      PLABCO=1.D0
      ITHATR=ITHACR
      IF (ITNUCR.GE.30) ITHATR=IT
      IF (ITNUCR.GE.30) ITNUCR=IT
      SICO=1.D0
      IF (ITHATR.LT.30) SICO=42.D0/39.D0
      IF (IT.EQ.21) SICO=42.D0/40.D0
      IF (ITHATR.LT.30) PLABCO=AM(IT)/(AM(ITNUCR)+1.D-10)
      IT=ITHATR
      RETURN
      END
+DECK,  IEFUN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

*$ CREATE IEFUN.FOR
*COPY IEFUN
*=== iefun ============================================================*
      INTEGER FUNCTION IEFUN(PL,IRE)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, REAC.
+CDE, REDVER.
*
C*****IEFUN CALCULATES A MOMENTUM INDEX
      COMMON / FKRUN    / RUNTES, EFTES
*
      IPLA=IEII(IRE)+1+1
      IPLE=IEII(IRE+1)
      IF (PL.LT.0.D0) GO TO 13
      DO 2 I=IPLA,IPLE
      J=I-IPLA+1
      IF (PL.LE.PLABF(I)) GO TO 3
    2 CONTINUE
      I=IPLE
      IF ( EFTES.GT.40.D0) GO TO 4321
      EFTES=EFTES+1.D0
      WRITE(LUNOUT,10)PL,J
 4321 CONTINUE
      GO TO 4323
   13 CONTINUE
      DO 12 I=IPLA,IPLE
      J=I-IPLA+1
      IF (-PL.LE.UMO(I)) GO TO 3
   12 CONTINUE
      I=IPLE
      IF ( EFTES.GT.40.D0) GO TO 4322
      EFTES=EFTES+1.D0
      WRITE(LUNOUT,10)PL,I
 4322 CONTINUE
    3 CONTINUE
 4323 CONTINUE
      IEFUN=I
      RETURN
   10 FORMAT(14H PLAB OR -ECM=,E10.4,27H IS OUT OF CONSIDERED RANGE
     *,7H IEFUN=,I5)
      END
+DECK,  IMPULS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:00  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== impuls ===========================================================*
      SUBROUTINE IMPULS(HE,HMA,HPS,HPX,HPY,HPZ,LT,LL,B3)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(2)
*
*----------------------------------------------------------------------*
*  Impuls89: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
C*****CHOICE OF THE TRANSVERSAL MOMENTUM AND CALCULATION OF THE
C*****LONGITUDINAL MOMENTUM
C*****HPS,HPZ ARE THE TRANSVERSAL AND LONGITUDINAL MOMENTUM

      ESMAX = HE - HMA
    1 CONTINUE
*
*  He is the total energy, hma the mass one (input) hpx, hpy, hpz
*  the momentum components (output values), hps the transversal
*  momentum (output)
*
*  +-------------------------------------------------------------------*
*  |                            cut off for the longitudinal momentum
      IF (ESMAX .LE. 0.05D0) THEN
*  |
*  | only transversal momentum!
*  |
         HPS = SQRT(HE**2 - HMA**2)
         HPZ = 0.D0
      ELSE
*  |
*  | hps is the transversal momentum
*  |
         CALL GRNDM(RNDM,2)
         X = RNDM(1)
         Y = RNDM(2)
*  |
*  |  Es is the transverse kinetic energy
*  |
         ES = -2.D0/(B3**2)*LOG(X*Y)
         IF (ES .GT. ESMAX) GO TO 1
         HPS = ES**2 + 2.D0*ES*HMA
         IF (LL .EQ. 0) Y1 = 1.D0
         IF (LL .EQ. 1) Y1 =-1.D0
         HPZ = SQRT(HE**2 - HMA**2 - HPS) * Y1
         HPS = SQRT (HPS)
      END IF
*  |
*  +-------------------------------------------------------------------*
      CALL SFECFE(SFE,CFE)
      SIP = SFE
      COP = CFE
      HPX = HPS*COP
      HPY = HPS*SIP
      IF (LT .EQ. 0) GO TO 2
      WRITE(LUNOUT,3) HPS,HPX,HPY,HPZ,HE,HMA,LL
    3 FORMAT(1H0,19HPS,PX,PY,PZ,E,M,LL=,6F8.4,I3)
    2 CONTINUE
      RETURN
      END
+SELF.
+DECK,  INCINI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:57  cernlib
* Geant

*=== incini ===========================================================*
*                                                                      *
      SUBROUTINE INCINI

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on  10  june  1990   by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 14-apr-93     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER ( PI = PIPIPI )
+CDE, FHEAVY.
+CDE, INPDAT2.
+CDE, INPFLG.
+CDE, NUCDAT.
+CDE, PAREVT.
      COMMON / FKNUCO / HELP (2), HHLP (2), FTVTH (2), FINCX (2),
     &                  EKPOLD (2), BBOLD, ZZOLD, SQROLD, ASEASQ,
     &                  FSPRED, FEX0RD
      BBOLD  = - 1.D+10
      ZZOLD  = - 1.D+10
      SQROLD = - 1.D+10
      APFRMX = PLABRC * ( 9.D+00 * PI / 8.D+00 )**0.3333333333333333D+00
     &       / R0NUCL
      AMNUCL (1) = AMPROT
      AMNUCL (2) = AMNEUT
      AMNUSQ (1) = AMPROT * AMPROT
      AMNUSQ (2) = AMNEUT * AMNEUT
      AMNHLP = 0.5D+00 * ( AMNUCL (1) + AMNUCL (2) )
      ASQHLP = AMNHLP**2
*     ASQHLP = 0.5D+00 * ( AMNUSQ (1) + AMNUSQ (2) )
      AEFRMX = SQRT ( ASQHLP + APFRMX**2 ) - AMNHLP
      AEFRMA = 0.3D+00 * APFRMX**2 / AMNHLP * ( 1.D+00 - APFRMX**2 /
     &         ( 5.6D+00 * ASQHLP ) )
      AV0WEL = AEFRMX + EBNDAV
      EBNDNG (1) = EBNDAV
      EBNDNG (2) = EBNDAV
      AEXC12 = 0.001D+00 * FKENER ( ONEONE*12, SIXSIX )
      CEXC12 = 0.001D+00 * ENRG   ( ONEONE*12, SIXSIX )
      AMMC12 = 12.D+00 * AMUAMU + AEXC12
      AMNC12 = AMMC12 - 6.D+00 * AMELEC +
     &         FERTHO * 6.D+00**EXPEBN
      AEXO16 = 0.001D+00 * FKENER ( ONEONE*16, EIGEIG )
      CEXO16 = 0.001D+00 * ENRG   ( ONEONE*16, EIGEIG )
      AMMO16 = 16.D+00 * AMUAMU + AEXO16
      AMNO16 = AMMO16 - 8.D+00 * AMELEC +
     &         FERTHO * 8.D+00**EXPEBN
      AEXS28 = 0.001D+00 * FKENER ( ONEONE*28, ONEONE*14 )
      CEXS28 = 0.001D+00 * ENRG   ( ONEONE*28, ONEONE*14 )
      AMMS28 = 28.D+00 * AMUAMU + AEXS28
      AMNS28 = AMMS28 - 14.D+00 * AMELEC +
     &         FERTHO * 14.D+00**EXPEBN
      AEXC40 = 0.001D+00 * FKENER ( ONEONE*40, ONEONE*20 )
      CEXC40 = 0.001D+00 * ENRG   ( ONEONE*40, ONEONE*20 )
      AMMC40 = 40.D+00 * AMUAMU + AEXC40
      AMNC40 = AMMC40 - 20.D+00 * AMELEC +
     &         FERTHO * 20.D+00**EXPEBN
      AEXF56 = 0.001D+00 * FKENER ( ONEONE*56, ONEONE*26 )
      CEXF56 = 0.001D+00 * ENRG   ( ONEONE*56, ONEONE*26 )
      AMMF56 = 56.D+00 * AMUAMU + AEXF56
      AMNF56 = AMMF56 - 26.D+00 * AMELEC +
     &         FERTHO * 26.D+00**EXPEBN
      AEX107 = 0.001D+00 * FKENER ( ONEONE*107, ONEONE*47 )
      CEX107 = 0.001D+00 * ENRG   ( ONEONE*107, ONEONE*47 )
      AMM107 = 107.D+00 * AMUAMU + AEX107
      AMN107 = AMM107 - 47.D+00 * AMELEC +
     &         FERTHO * 47.D+00**EXPEBN
      AEX132 = 0.001D+00 * FKENER ( ONEONE*132, ONEONE*54 )
      CEX132 = 0.001D+00 * ENRG   ( ONEONE*132, ONEONE*54 )
      AMM132 = 132.D+00 * AMUAMU + AEX132
      AMN132 = AMM132 - 54.D+00 * AMELEC +
     &         FERTHO * 54.D+00**EXPEBN
      AEX181 = 0.001D+00 * FKENER ( ONEONE*181, ONEONE*73 )
      CEX181 = 0.001D+00 * ENRG   ( ONEONE*181, ONEONE*73 )
      AMM181 = 181.D+00 * AMUAMU + AEX181
      AMN181 = AMM181 - 73.D+00 * AMELEC +
     &         FERTHO * 73.D+00**EXPEBN
      AEX208 = 0.001D+00 * FKENER ( ONEONE*208, ONEONE*82 )
      CEX208 = 0.001D+00 * ENRG   ( ONEONE*208, ONEONE*82 )
      AMM208 = 208.D+00 * AMUAMU + AEX208
      AMN208 = AMM208 - 82.D+00 * AMELEC +
     &         FERTHO * 82.D+00**EXPEBN
      AEX238 = 0.001D+00 * FKENER ( ONEONE*238, ONEONE*92 )
      CEX238 = 0.001D+00 * ENRG   ( ONEONE*238, ONEONE*92 )
      AMM238 = 238.D+00 * AMUAMU + AEX238
      AMN238 = AMM238 - 92.D+00 * AMELEC +
     &         FERTHO * 92.D+00**EXPEBN
+SELF, IF=FDEBUG.
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Maximum Fermi momentum  : ',REAL(APFRMX),
     &                  ' GeV/c ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Maximum Fermi energy    : ',REAL(AEFRMX),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Average Fermi energy    : ',REAL(AEFRMA),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Average binding energy  : ',REAL(EBNDAV),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear well depth      : ',REAL(AV0WEL),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 12-C  : ',REAL(AEXC12),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 12-C  : ',REAL(CEXC12),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 12-C  : ',REAL(AMMC12),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 12-C  : ',REAL(AMNC12),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 16-O  : ',REAL(AEXO16),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 16-O  : ',REAL(CEXO16),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 16-O  : ',REAL(AMMO16),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 16-O  : ',REAL(AMNO16),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 40-Ca : ',REAL(AEXC40),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 40-Ca : ',REAL(CEXC40),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 40-Ca : ',REAL(AMMC40),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 40-Ca : ',REAL(AMNC40),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 56-Fe : ',REAL(AEXF56),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 56-Fe : ',REAL(CEXF56),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 56-Fe : ',REAL(AMMF56),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 56-Fe : ',REAL(AMNF56),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 107-Ag: ',REAL(AEX107),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 107-Ag: ',REAL(CEX107),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 107-Ag: ',REAL(AMM107),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 107-Ag: ',REAL(AMN107),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 132-Xe: ',REAL(AEX132),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 132-Xe: ',REAL(CEX132),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 132-Xe: ',REAL(AMM132),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 132-Xe: ',REAL(AMN132),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 181-Ta: ',REAL(AEX181),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 181-Ta: ',REAL(CEX181),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 181-Ta: ',REAL(AMM181),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 181-Ta: ',REAL(AMN181),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 208-Pb: ',REAL(AEX208),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 208-Pb: ',REAL(CEX208),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 208-Pb: ',REAL(AMM208),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 208-Pb: ',REAL(AMN208),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Excess  mass  for 238-U : ',REAL(AEX238),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Cameron E. m. for 238-U : ',REAL(CEX238),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Atomic  mass  for 238-U : ',REAL(AMM238),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
      WRITE ( LUNOUT,* )' **** Nuclear mass  for 238-U : ',REAL(AMN238),
     &                  ' GeV   ****'
      WRITE ( LUNOUT,* )
+SELF.
      AMHEAV (1) = AMUAMU + 1.D-03 * FKENER ( ONEONE, ZERZER )
      AMHEAV (2) = AMUAMU + 1.D-03 * FKENER ( ONEONE, ONEONE )
      AMHEAV (3) = 2.D+00 * AMUAMU + 1.D-03 * FKENER ( TWOTWO, ONEONE )
      AMHEAV (4) = 3.D+00 * AMUAMU + 1.D-03 * FKENER ( THRTHR, ONEONE )
      AMHEAV (5) = 3.D+00 * AMUAMU + 1.D-03 * FKENER ( THRTHR, TWOTWO )
      AMHEAV (6) = 4.D+00 * AMUAMU + 1.D-03 * FKENER ( FOUFOU, TWOTWO )
      ELBNDE (0) = 0.D+00
      DO 2000 IZ = 1, 100
         ELBNDE ( IZ ) = FERTHO *  IZ **EXPEBN
2000  CONTINUE
      IF ( LEVPRT ) THEN
+SELF, IF=FDEBUG.
         WRITE ( LUNOUT, * )' **** Evaporation from residual nucleus',
     &                      ' activated **** '
         IF ( LDEEXG ) WRITE ( LUNOUT, * )' **** Deexcitation gamma',
     &                      ' production activated **** '
         IF ( LHEAVY ) WRITE ( LUNOUT, * )' **** Evaporated "heavies"',
     &                      ' transport activated **** '
         IF ( IFISS .GT. 0 )
     &                 WRITE ( LUNOUT, * )' **** High Energy fission ',
     &                      ' requested & activated **** '
+SELF.
      ELSE
         LDEEXG = .FALSE.
         LHEAVY = .FALSE.
         IFISS  = 0
      END IF
      RETURN
*=== End of subroutine incini =========================================*
      END
+DECK,  INDEX2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE INDEX2.FOR
*COPY INDEX2
*=== index2 ===========================================================*
      SUBROUTINE INDEX2(KA,KB,IND)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      KP=KA*KB
      KS=KA+KB
      IF(KP.EQ.1)IND=1
      IF(KP.EQ.2)IND=2
      IF(KP.EQ.3)IND=3
      IF(KP.EQ.4.AND.KS.EQ.5)IND=4
      IF(KP.EQ.5)IND=5
      IF(KP.EQ.6.AND.KS.EQ.7)IND=6
      IF(KP.EQ.4.AND.KS.EQ.4)IND=7
      IF(KP.EQ.6.AND.KS.EQ.5)IND=8
      IF(KP.EQ.8)IND=9
      IF(KP.EQ.10)IND=10
      IF(KP.EQ.12.AND.KS.EQ.8)IND=11
      IF(KP.EQ.9)IND=12
      IF(KP.EQ.12.AND.KS.EQ.7)IND=13
      IF(KP.EQ.15)IND=14
      IF(KP.EQ.18)IND=15
      IF(KP.EQ.16)IND=16
      IF(KP.EQ.20)IND=17
      IF(KP.EQ.24)IND=18
      IF(KP.EQ.25)IND=19
      IF(KP.EQ.30)IND=20
      IF(KP.EQ.36)IND=21
      RETURN
      END
+DECK,  KINPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE KINPAR.FOR
*COPY KINPAR
*=== kinpar ===========================================================*
      SUBROUTINE KINPAR(PXYZ,E,RCPMV)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      COMMON /FKKINP/AMTA,AMIT,PXTA,PYTA,PZTA,PSX,PSY,PSZ,PGES2,PGES,
     *PGESM,PTA2,PTAM,UMO2,CCX,CCY,CCZ,CXTA,CYTA,CZTA,GA,BGA
C*** CALCULATION OF KINEMATIC PARAMETERS
      DIMENSION PXYZ(10),E(2)
      PXTA=PXYZ(  2)
      PYTA=PXYZ(  6)
      PZTA=PXYZ( 10)
      PSX=PXYZ( 1)+P XTA
      PSY=PXYZ( 5)+P YTA
      PSZ=PXYZ( 9)+P ZTA
      PGES2=PSX*PSX+PSY*PSY+PSZ*PSZ
      PGES=SQRT(PGES2)
      PGESM=1.D0/PGES
      PTA2=PXTA*PXTA+PYTA*PYTA+PZTA*PZTA
      PTAM=1.D0/SQRT(PTA2)
      UMO2=((E(1)+E(2))**2-PGES2)/(RCPMV*RCPMV)
      UMO2=UMO2*0.000001D0
      CCX=PS X*PGESM
      CCY=PS Y*PGESM
      CCZ=PS Z*PGESM
      CXTA=P XTA*PTAM
      CYTA=P YTA*PTAM
      CZTA=P ZTA*PTAM
      GA=(E(1)+E(2))*0.001D0/(RCPMV*SQRT(UMO2))
      BGA=SQRT(GA*GA-1.D0)
      RETURN
      END
+DECK,  KPOIS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE KPOIS.FOR
*COPY KPOIS
*=== kpois ============================================================*
      FUNCTION KPOIS(EXPLAM)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(1)
C*** EXPLAM IS EXP(-LAMBDA)
C*** SQMPLING FROM POISSON DISTRIBUTION, AVERAGE LAMBDA
C*** PK = EXP(-LAMBDA)*LAMBDA**K/(K-FACTORIAL)
      Y=1.D0
      KPOISS=0
5     CONTINUE
      CALL GRNDM(RNDM,1)
      Y=Y*RNDM(1)
      IF (Y.LT.EXPLAM) GO TO 10
      KPOISS=KPOISS+1
      GO TO 5
10    CONTINUE
      KPOIS=KPOISS
      RETURN
      END
+DECK,  LORTRA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE LORTRA.FOR
*COPY LORTRA
*=== lortra ===========================================================*
      SUBROUTINE LORTRA(N,NAUX,GAM,BGX,BGY,BGZ)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C
C     LORENTZ TRANSFORMATION OF  N PARTICLES IN  FINPAR  TO BE
C     STORED IN  AUXPAR  STARTING AT NAUX
C
C********************************************************************
C
+CDE, FINPAR.
+CDE, AUXPAR.
      DO 1  I=1,N
         J = NAUX + I - 1
         AMA(J)  = AMF(I)
         ICHA(J) = ICHF(I)
         IBARA(J)= IBARF(I)
         ANA(J)  = ANF(I)
         NREA(J) = NREF(I)
         CALL ALTRA(GAM,BGX,BGY,BGZ,PXF(I),PYF(I),PZF(I),HEP(I),
     &              PPA,PXA(J),PYA(J),PZA(J),HEPA(J))
   1  CONTINUE
      RETURN
      END
+DECK,  NIZL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE NIZL.FOR
*COPY NIZL
*                                                                      *
*=== nizl =============================================================*
*                                                                      *
      SUBROUTINE NIZL ( IT, AAA, EKE, PO, SI, ZL )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*=====================================================================*
*
*     Revision september 90 by       A. Ferrari
*                                    Milan
*     last change 12 Febr. 1991      by Alfredo Ferrari
*                                    INFN-Milan
*
C********************************************************************
C     VERSION SEPTEMBER 90 BY        A. FERRARI
C                                    INFN, MILAN
C     LAST CHANGE ON 09 JUNE -92 BY  ALFREDO FERRARI
C
C
C     SEE: H.J. MOEHRING, HADRON-NUCLEUS INELASTIC CROSS-SECTIONS FOR
C     USE IN HADRON-CASCADE CALCULATIONS AT HIGH ENERGIES,
C     TIS DIVISION REPORT 14. OCTOBER 1983, TIS-RP/116, CERN GENEVA
C
C
C     THIS IS A SUBROUTINE OF FLUKA82 TO CALCULATE THE INELASTIC
C     SCATTERING LENGTH OF THE MATERIAL IN G/CM**2.
C
C     INPUT VARIABLES:
C        IT     = TYPE OF THE PARTICLE
C        AA     = ATOMIC WEIGHT OF THE NUCLEUS
C        PO     = PARTICLE MOMENTUM IN GEV/C
C
C     OUTPUT VARIABLES:
C        SI     = INTERPOLATED CROSS SECTION IN MILLIBARNS
C        ZL     = INTERPOLATED ABSORPTION LENGTH IN G/CM**2
C
C
C     OTHER INPORTANT VARIABLES:
C        SIG    = PROTON/NUCLEI CROSS SECTIONS
C        SEG    = PION-/NUCLEI CROSS SECTIONS ABOVE 0.3 GEV/C
C        SEGP   = PION+/NUCLEI CROSS SECTIONS ABOVE 0.3 GEV/C
C        SIGKM  = K+ AND K0/NUCLEI CROSS SECTIONS ABOVE 3.0 GEV/C
C        SIGKP  = K+ AND K0 BAR/NUCLEI CROSS SECTIONS ABOVE 3.0 GEV/C
C        SIGAP  = ANTINUCLEON/NUCLEI CROSS SECTIONS ABOVE 3.0 GEV/C
C        SEEG   = PION/NUCLEI CROSS SECTIONS BELOW 0.3 GEV/C
C        P      = MOMENTUMS FOR WHICH THE CROSS SECTIONS ARE GIVEN IN
C                 SIG, SEG, SEGP, SIGKM, SIGKP AND SIGAP
C        PEE    = MOMENTUMS FOR WHICH THE CROSS SECTIONS ARE GIVEN IN
C                 SEEG
C        A      = NUCLEI FOR WHICH THE CROSS SECTIONS ARE GIVEN IN
C                 SIG, SEG, SEGP, SIGKM, SIGKP, SIGAP AND SEEG
C        PLAB   = MOMENTUMS FOR WHICH THE TOTAL CROSS SECTIONS ARE
C                 GIVEN IN TOTCRS
C        TOTCRS = TOTAL CROSS SECTIONS AS A FUNCTION OF MOMENTUM
C                 TOTCRS(K,I) WHERE K=MOMENTUM INDEX,I=REACTION TYPE
C                 I=1:NEGATIVE KAON-PROTON  = KAON ZERO BAR-NEUTRON
C                 I=2:NEGATIVE KAON-NEUTRON = KAON ZERO BAR-PROTON
C                 I=3:POSITIVE KAON-PROTON  = KAON ZERO NEUTRON
C                 I=4:POSITIVE KAON-NEUTRON = KAON ZERO-PROTON
C                 I=5:ANTI NUCLEON-NUCLEON
C
C
C     NOTE1: PRESENTLY CROSS SECTIONS ARE ASSUMED TO BE CONSTANT
C     ABOVE 10000.0 GEV/C FOR ALL PARTICLES AND
C     BELOW 0.13 GEV/C FOR PIONS AND BELOW 0.3 GEV/C FOR OTHERS
C
C     NOTE2: SEE TABLE ITT TO FIND OUT HOW DIFFERENT HADRONS
C     ARE TREATED. ALL PARTICLES WITH PARTICLE NUMBER BIGGER THAN
C     25 ARE TREATED AS PROTONS.
C
C     NOTE3: FOR LEPTONS AND PHOTONS PRACTICALLY ZERO CROSS SECTION
C     IS RETURNED.
C********************************************************************
C
+CDE, PAPROP.
C
      PARAMETER ( AVOGMB = 1.0D+27 / AVOGAD )
      PARAMETER ( AMPROT = 0.93827231D+00 )
      PARAMETER ( AMNEUT = 0.93956563D+00 )
      PARAMETER ( AMNTM2 = AMPROT + AMNEUT )
      PARAMETER ( AMNCSQ = 0.25D+00 * AMNTM2 * AMNTM2 )
C
C     DIMENSION SIG1(20,5),SEG1(20,5),SEGP1(20,5),SIG2(20,4),
C    *SEG2(20,4),SEGP2(20,4)
C     EQUIVALENCE (SIG(1),SIG1(1)),(SIG(101),SIG2(1)),
C    *(SEG(1),SEG1(1)),(SEG(101),SEG2(1)),
C    *(SEGP(1),SEGP1(1)),(SEGP(101),SEGP2(1))
      DIMENSION SEEG(4,9),PEE(4),SIGKP(20,9),SIGKM(20,9),SIGAP(20,9)
      DIMENSION SEG(20,9),SIG(20,9),SEGP(20,9),P(20),A(9),ITT(39)
      DIMENSION BET(4),ALPH(4)
      DIMENSION TOTCRS(19,5)
      DIMENSION PLAB(19)
      REAL RNDM(1)
      SAVE ALPH, BET, A, P, SEEG, PEE, SIG, SEG, SEGP, PLAB, TOTCRS,
     &     SIGKP, SIGKM, SIGAP, RND, ITT, IROU1, IROU2
      DATA ALPH/.748D0,.803D0,.63D0,.63D0/
      DATA BET/1.27D0,1.22D0,.9D0,.9D0/
      DATA A/1.D0,9.D0,12.D0,27.D0,55.9D0,63.5D0,112.4D0,
     *207.2D0,238.1D0/
      DATA P/0.3D0,0.4D0,0.5D0,0.6D0,0.8D0,1.D0,1.5D0,
     *2.D0,3.D0,4.D0,5.D0,6.D0,10.D0,
     *20.D0,50.D0,100.D0,200.D0,400.D0,1000.D0,10000.D0/
      DATA SEEG/0.1D0,16.D0,35.D0,42.D0,360.D0,370.D0,310.D0,290.D0,
     * 430.D0,435.D0,380.D0,350.D0,
     * 670.D0,650.D0,630.D0,610.D0,
     * 1130.D0,1040.D0,1000.D0,1000.D0,
     * 1240.D0,1140.D0,1100.D0,1090.D0,
     * 1880.D0,1750.D0,1645.D0,1630.D0,
     * 2930.D0,2750.D0,2540.D0,2500.D0,
     * 3240.D0,3050.D0,2800.D0,2750.D0/
      DATA PEE /0.13D0,0.19D0,0.25D0,0.30D0/

      DATA ((SIG  (I,J),I= 1,20),J= 1, 3) /
     & 1.0000D-04,1.0000D-04,1.0000D-04,1.0000D-01,1.0000D+00,
     & 4.0000D+00,2.4500D+01,2.5000D+01,2.7200D+01,2.7800D+01,
     & 2.8500D+01,2.9200D+01,2.9700D+01,3.0500D+01,3.1500D+01,
     & 3.1700D+01,3.2100D+01,3.2900D+01,3.4500D+01,4.1200D+01,
     & 2.0200D+02,1.9400D+02,1.8700D+02,1.7500D+02,1.5800D+02,
     & 1.5300D+02,2.1700D+02,2.2000D+02,2.1200D+02,2.0700D+02,
     & 2.0300D+02,2.0100D+02,1.9900D+02,1.9600D+02,1.9400D+02,
     & 1.9500D+02,1.9600D+02,1.9900D+02,2.0400D+02,2.2600D+02,
     & 2.5000D+02,2.4000D+02,2.3000D+02,2.1600D+02,1.9600D+02,
     & 1.9000D+02,2.5000D+02,2.6000D+02,2.5900D+02,2.5400D+02,
     & 2.4900D+02,2.4700D+02,2.4400D+02,2.4100D+02,2.3900D+02,
     & 2.4000D+02,2.4100D+02,2.4400D+02,2.5100D+02,2.7600D+02 /

      DATA ((SEG  (I,J),I= 1,20),J= 1, 3) /
     & 4.2000D+01,1.9000D+01,1.6100D+01,1.7000D+01,2.2700D+01,
     & 3.2500D+01,2.4600D+01,2.6200D+01,2.5000D+01,2.3700D+01,
     & 2.3000D+01,2.2500D+01,2.2000D+01,2.1200D+01,2.0800D+01,
     & 2.0700D+01,2.1000D+01,2.1900D+01,2.3800D+01,2.8400D+01,
     & 2.9000D+02,2.6400D+02,2.1200D+02,1.9000D+02,1.8900D+02,
     & 1.9700D+02,1.9000D+02,1.8500D+02,1.8000D+02,1.7500D+02,
     & 1.7000D+02,1.6800D+02,1.6400D+02,1.5500D+02,1.4500D+02,
     & 1.4500D+02,1.4800D+02,1.5000D+02,1.5500D+02,1.7200D+02,
     & 3.5000D+02,3.0000D+02,2.5000D+02,2.4000D+02,2.4500D+02,
     & 2.6000D+02,2.4500D+02,2.3000D+02,2.1500D+02,2.1000D+02,
     & 2.0900D+02,2.0800D+02,2.0500D+02,1.8500D+02,1.7500D+02,
     & 1.7000D+02,1.7000D+02,1.7300D+02,1.8100D+02,2.0500D+02 /

      DATA ((SEGP (I,J),I= 1,20),J= 1, 3) /
     & 1.0000D-01,1.0000D-01,1.0000D-01,1.0000D-01,6.1000D+00,
     & 1.2000D+01,1.7700D+01,1.9500D+01,2.0500D+01,2.0700D+01,
     & 2.0600D+01,2.0600D+01,2.0200D+01,1.9800D+01,1.9700D+01,
     & 1.9900D+01,2.0500D+01,2.1500D+01,2.3500D+01,3.2200D+01,
     & 2.9000D+02,2.6400D+02,2.1200D+02,1.9000D+02,1.8900D+02,
     & 1.9700D+02,1.9000D+02,1.8500D+02,1.8000D+02,1.7500D+02,
     & 1.7000D+02,1.6800D+02,1.6400D+02,1.5500D+02,1.4500D+02,
     & 1.4500D+02,1.4800D+02,1.5000D+02,1.5500D+02,1.7200D+02,
     & 3.5000D+02,3.0000D+02,2.5000D+02,2.4000D+02,2.4500D+02,
     & 2.6000D+02,2.4500D+02,2.3000D+02,2.1500D+02,2.1000D+02,
     & 2.0900D+02,2.0800D+02,2.0500D+02,1.8500D+02,1.7500D+02,
     & 1.7000D+02,1.7000D+02,1.7300D+02,1.8100D+02,2.0500D+02 /

      DATA ((SIGKP(I,J),I= 1,20),J= 1, 3) /
     & 1.0000D-03,1.0000D-03,1.0000D-03,1.0000D-03,2.0000D-01,
     & 4.5000D+00,8.9000D+00,1.1600D+01,1.2200D+01,1.3400D+01,
     & 1.3600D+01,1.3700D+01,1.3700D+01,1.4900D+01,1.5900D+01,
     & 1.6500D+01,1.7400D+01,1.8600D+01,2.0900D+01,2.8800D+01,
     & 1.7440D+02,1.7440D+02,1.7440D+02,1.7440D+02,1.7440D+02,
     & 1.7440D+02,1.7440D+02,1.2960D+02,1.2460D+02,1.2610D+02,
     & 1.2460D+02,1.2290D+02,1.1900D+02,1.1700D+02,1.1900D+02,
     & 1.2900D+02,1.3100D+02,1.3600D+02,1.4400D+02,1.7400D+02,
     & 2.1630D+02,2.1630D+02,2.1630D+02,2.1630D+02,2.1630D+02,
     & 2.1630D+02,2.1630D+02,1.6330D+02,1.5700D+02,1.5880D+02,
     & 1.5700D+02,1.5480D+02,1.5000D+02,1.4800D+02,1.5000D+02,
     & 1.6100D+02,1.6400D+02,1.6900D+02,1.7900D+02,2.1900D+02 /

      DATA ((SIGKM(I,J),I= 1,20),J= 1, 3) /
     & 3.8000D+01,4.3000D+01,2.3000D+01,1.8500D+01,2.0000D+01,
     & 2.9000D+01,2.5000D+01,2.3000D+01,2.2500D+01,2.1000D+01,
     & 2.0500D+01,2.0000D+01,1.9200D+01,1.8500D+01,1.7800D+01,
     & 1.7800D+01,1.8300D+01,1.9200D+01,2.1200D+01,2.8900D+01,
     & 1.7440D+02,1.7440D+02,1.7440D+02,1.7440D+02,1.7440D+02,
     & 1.7440D+02,1.7440D+02,1.7440D+02,1.6160D+02,1.4900D+02,
     & 1.4800D+02,1.5000D+02,1.4600D+02,1.3100D+02,1.2900D+02,
     & 1.2900D+02,1.3100D+02,1.3600D+02,1.4400D+02,1.7400D+02,
     & 2.1630D+02,2.1630D+02,2.1630D+02,2.1630D+02,2.1630D+02,
     & 2.1630D+02,2.1630D+02,2.1630D+02,2.0040D+02,1.8700D+02,
     & 1.8540D+02,1.8700D+02,1.8200D+02,1.6500D+02,1.6100D+02,
     & 1.6100D+02,1.6400D+02,1.6900D+02,1.7900D+02,2.1900D+02 /

      DATA ((SIGAP(I,J),I= 1,20),J= 1, 3) /
     & 1.6400D+02,1.2600D+02,1.1400D+02,9.8000D+01,8.6000D+01,
     & 7.2400D+01,5.9000D+01,5.7000D+01,5.3000D+01,5.2000D+01,
     & 4.8000D+01,4.5500D+01,4.3500D+01,4.0400D+01,3.6500D+01,
     & 3.5200D+01,3.4500D+01,3.4500D+01,3.5400D+01,4.1500D+01,
     & 3.2400D+02,3.2400D+02,3.2400D+02,3.2400D+02,3.2400D+02,
     & 3.2400D+02,3.2400D+02,3.2400D+02,3.0100D+02,2.9200D+02,
     & 2.8400D+02,2.7600D+02,2.7200D+02,2.4500D+02,2.0200D+02,
     & 1.9800D+02,1.9600D+02,1.9600D+02,1.9900D+02,2.1900D+02,
     & 3.8800D+02,3.8800D+02,3.8800D+02,3.8800D+02,3.8800D+02,
     & 3.8800D+02,3.8800D+02,3.8800D+02,3.6000D+02,3.5000D+02,
     & 3.4000D+02,3.3000D+02,3.2500D+02,2.9600D+02,2.4600D+02,
     & 2.4200D+02,2.4000D+02,2.4000D+02,2.4400D+02,2.6600D+02 /

      DATA ((SIG  (I,J),I= 1,20),J= 4, 6) /
     & 4.5600D+02,4.3400D+02,4.1600D+02,3.9000D+02,3.6100D+02,
     & 3.5200D+02,4.6700D+02,4.7100D+02,4.5800D+02,4.5300D+02,
     & 4.5000D+02,4.5500D+02,4.6000D+02,4.4500D+02,4.3500D+02,
     & 4.3000D+02,4.3200D+02,4.3700D+02,4.4600D+02,4.8100D+02,
     & 7.8200D+02,7.3800D+02,7.0600D+02,6.6100D+02,6.2600D+02,
     & 6.1100D+02,7.7600D+02,7.8000D+02,7.6400D+02,7.6000D+02,
     & 7.5000D+02,7.6000D+02,7.5500D+02,7.4000D+02,7.3000D+02,
     & 7.2600D+02,7.2900D+02,7.3600D+02,7.4800D+02,7.9200D+02,
     & 8.6000D+02,8.1000D+02,7.7500D+02,7.2500D+02,6.9000D+02,
     & 6.8000D+02,8.4700D+02,8.5300D+02,8.5000D+02,8.4500D+02,
     & 8.4000D+02,8.3500D+02,8.2500D+02,8.0500D+02,7.9500D+02,
     & 7.9600D+02,7.9900D+02,8.0600D+02,8.1900D+02,8.6400D+02 /

      DATA ((SEG  (I,J),I= 1,20),J= 4, 6) /
     & 6.1000D+02,5.4000D+02,4.9000D+02,4.6000D+02,4.3500D+02,
     & 4.5000D+02,4.4000D+02,4.1500D+02,4.1000D+02,3.9800D+02,
     & 3.9200D+02,3.8700D+02,3.7000D+02,3.5000D+02,3.3300D+02,
     & 3.3300D+02,3.3500D+02,3.3800D+02,3.4800D+02,3.8300D+02,
     & 1.0000D+03,9.1000D+02,8.6000D+02,8.0000D+02,7.8000D+02,
     & 7.7500D+02,7.6000D+02,7.1000D+02,6.8300D+02,6.7000D+02,
     & 6.6300D+02,6.5400D+02,6.3400D+02,5.9800D+02,5.7000D+02,
     & 5.7000D+02,5.7500D+02,5.8000D+02,6.0000D+02,6.5300D+02,
     & 1.0900D+03,1.0000D+03,9.6000D+02,9.5000D+02,8.8000D+02,
     & 8.5000D+02,8.3500D+02,7.8000D+02,7.5000D+02,7.4000D+02,
     & 7.3000D+02,7.2000D+02,7.0000D+02,6.6000D+02,6.3000D+02,
     & 6.3000D+02,6.3500D+02,6.4000D+02,6.6000D+02,7.2000D+02 /

      DATA ((SEGP (I,J),I= 1,20),J= 4, 6) /
     & 6.1000D+02,5.4000D+02,4.9000D+02,4.6000D+02,4.3500D+02,
     & 4.5000D+02,4.4000D+02,4.1500D+02,4.1000D+02,3.9800D+02,
     & 3.9200D+02,3.8700D+02,3.7000D+02,3.5000D+02,3.3300D+02,
     & 3.3300D+02,3.3500D+02,3.3800D+02,3.4800D+02,3.8300D+02,
     & 1.0000D+03,9.1000D+02,8.6000D+02,8.0000D+02,7.8000D+02,
     & 7.7500D+02,7.6000D+02,7.1000D+02,6.8300D+02,6.7000D+02,
     & 6.6300D+02,6.5400D+02,6.3400D+02,5.9800D+02,5.7000D+02,
     & 5.7000D+02,5.7500D+02,5.8000D+02,6.0000D+02,6.5300D+02,
     & 1.0900D+03,1.0000D+03,9.6000D+02,9.5000D+02,8.8000D+02,
     & 8.5000D+02,8.3500D+02,7.8000D+02,7.5000D+02,7.4000D+02,
     & 7.3000D+02,7.2000D+02,7.0000D+02,6.6000D+02,6.3000D+02,
     & 6.3000D+02,6.3500D+02,6.4000D+02,6.6000D+02,7.2000D+02 /

      DATA ((SIGKP(I,J),I= 1,20),J= 4, 6) /
     & 3.1750D+02,3.1750D+02,3.1750D+02,3.1750D+02,3.1750D+02,
     & 3.1750D+02,3.1750D+02,3.1320D+02,3.0110D+02,3.0460D+02,
     & 3.0110D+02,2.9680D+02,2.8700D+02,2.8400D+02,2.8600D+02,
     & 2.9900D+02,3.0200D+02,3.1100D+02,3.2800D+02,3.8600D+02,
     & 6.8380D+02,6.8380D+02,6.8380D+02,6.8380D+02,6.8380D+02,
     & 6.8380D+02,6.8380D+02,5.6180D+02,5.4020D+02,5.4640D+02,
     & 5.4020D+02,5.3250D+02,5.1500D+02,5.1000D+02,5.1000D+02,
     & 5.2200D+02,5.2600D+02,5.3900D+02,5.6700D+02,6.5400D+02,
     & 7.5220D+02,7.5220D+02,7.5220D+02,7.5220D+02,7.5220D+02,
     & 7.5220D+02,7.5220D+02,6.2240D+02,5.9840D+02,6.0530D+02,
     & 5.9840D+02,5.8990D+02,5.7000D+02,5.6500D+02,5.6500D+02,
     & 5.7500D+02,5.7900D+02,5.9400D+02,6.2400D+02,7.1800D+02 /

      DATA ((SIGKM(I,J),I= 1,20),J= 4, 6) /
     & 3.9680D+02,3.9680D+02,3.9680D+02,3.9680D+02,3.9680D+02,
     & 3.9680D+02,3.9680D+02,3.9680D+02,3.6760D+02,3.5300D+02,
     & 3.5000D+02,3.5000D+02,3.4100D+02,3.1700D+02,3.0300D+02,
     & 2.9900D+02,3.0200D+02,3.1100D+02,3.2800D+02,3.8600D+02,
     & 6.8380D+02,6.8380D+02,6.8380D+02,6.8380D+02,6.8380D+02,
     & 6.8380D+02,6.8380D+02,6.8380D+02,6.3360D+02,6.2400D+02,
     & 6.2000D+02,6.1600D+02,5.9800D+02,5.6900D+02,5.3400D+02,
     & 5.2200D+02,5.2600D+02,5.3900D+02,5.6700D+02,6.5400D+02,
     & 7.5220D+02,7.5220D+02,7.5220D+02,7.5220D+02,7.5220D+02,
     & 7.5220D+02,7.5220D+02,7.5220D+02,6.9700D+02,6.9000D+02,
     & 6.8500D+02,6.8000D+02,6.6000D+02,6.3000D+02,5.9000D+02,
     & 5.7500D+02,5.7900D+02,5.9400D+02,6.2400D+02,7.1800D+02 /

      DATA ((SIGAP(I,J),I= 1,20),J= 4, 6) /
     & 6.4800D+02,6.4800D+02,6.4800D+02,6.4800D+02,6.4800D+02,
     & 6.4800D+02,6.4800D+02,6.4800D+02,5.9800D+02,5.8100D+02,
     & 5.6400D+02,5.4800D+02,5.4000D+02,5.0000D+02,4.3400D+02,
     & 4.2900D+02,4.2700D+02,4.2700D+02,4.3200D+02,4.6400D+02,
     & 1.0240D+03,1.0240D+03,1.0240D+03,1.0240D+03,1.0240D+03,
     & 1.0240D+03,1.0240D+03,1.0240D+03,9.4100D+02,9.1500D+02,
     & 8.8800D+02,8.6200D+02,8.4900D+02,8.0100D+02,7.2000D+02,
     & 7.1600D+02,7.1500D+02,7.1500D+02,7.2200D+02,7.6300D+02,
     & 1.1100D+03,1.1100D+03,1.1100D+03,1.1100D+03,1.1100D+03,
     & 1.1100D+03,1.1100D+03,1.1100D+03,1.0200D+03,9.9200D+02,
     & 9.6300D+02,9.3500D+02,9.2100D+02,8.7000D+02,7.8800D+02,
     & 7.8400D+02,7.8400D+02,7.8400D+02,7.9200D+02,8.3400D+02 /

      DATA ((SIG  (I,J),I= 1,20),J= 7, 9) /
     & 1.2360D+03,1.1780D+03,1.1400D+03,1.0800D+03,1.0250D+03,
     & 1.0370D+03,1.2610D+03,1.2670D+03,1.2500D+03,1.2500D+03,
     & 1.2240D+03,1.2200D+03,1.2130D+03,1.2100D+03,1.2000D+03,
     & 1.2000D+03,1.2100D+03,1.2130D+03,1.2300D+03,1.2800D+03,
     & 1.8200D+03,1.7600D+03,1.7200D+03,1.6500D+03,1.5700D+03,
     & 1.6490D+03,1.9300D+03,1.9350D+03,1.9200D+03,1.9000D+03,
     & 1.8930D+03,1.8880D+03,1.8800D+03,1.8700D+03,1.8600D+03,
     & 1.8650D+03,1.8700D+03,1.8800D+03,1.9000D+03,1.9450D+03,
     & 1.9900D+03,1.9300D+03,1.8900D+03,1.8200D+03,1.7300D+03,
     & 1.8320D+03,2.1270D+03,2.1310D+03,2.1200D+03,2.1330D+03,
     & 2.0900D+03,2.0850D+03,2.0800D+03,2.0700D+03,2.0600D+03,
     & 2.0600D+03,2.0700D+03,2.0770D+03,2.0950D+03,2.1400D+03 /

      DATA ((SEG  (I,J),I= 1,20),J= 7, 9) /
     & 1.6300D+03,1.4800D+03,1.3100D+03,1.2600D+03,1.2400D+03,
     & 1.2200D+03,1.2000D+03,1.1500D+03,1.1150D+03,1.1050D+03,
     & 1.0950D+03,1.0800D+03,1.0620D+03,1.0000D+03,9.6000D+02,
     & 9.6000D+02,9.6500D+02,9.7100D+02,1.0000D+03,1.0850D+03,
     & 2.5000D+03,2.2500D+03,1.9600D+03,1.8500D+03,1.8200D+03,
     & 1.8000D+03,1.7800D+03,1.7000D+03,1.6900D+03,1.6850D+03,
     & 1.6800D+03,1.6750D+03,1.6600D+03,1.5800D+03,1.5000D+03,
     & 1.4800D+03,1.4800D+03,1.4950D+03,1.5300D+03,1.6500D+03,
     & 2.7500D+03,2.4750D+03,2.2000D+03,2.1000D+03,2.1000D+03,
     & 2.1000D+03,2.0700D+03,1.9600D+03,1.8800D+03,1.8700D+03,
     & 1.8400D+03,1.8200D+03,1.8000D+03,1.7400D+03,1.6650D+03,
     & 1.6650D+03,1.6780D+03,1.6920D+03,1.7440D+03,1.8780D+03 /

      DATA ((SEGP (I,J),I= 1,20),J= 7, 9) /
     & 1.6300D+03,1.4800D+03,1.3100D+03,1.2600D+03,1.2400D+03,
     & 1.2200D+03,1.2000D+03,1.1500D+03,1.1150D+03,1.1050D+03,
     & 1.0950D+03,1.0800D+03,1.0620D+03,1.0000D+03,9.6000D+02,
     & 9.6000D+02,9.6500D+02,9.7100D+02,1.0000D+03,1.0850D+03,
     & 2.5000D+03,2.2500D+03,1.9600D+03,1.8500D+03,1.8200D+03,
     & 1.8000D+03,1.7800D+03,1.7000D+03,1.6900D+03,1.6850D+03,
     & 1.6800D+03,1.6750D+03,1.6600D+03,1.5800D+03,1.5000D+03,
     & 1.4800D+03,1.4800D+03,1.4950D+03,1.5300D+03,1.6500D+03,
     & 2.7500D+03,2.4750D+03,2.2000D+03,2.1000D+03,2.1000D+03,
     & 2.1000D+03,2.0700D+03,1.9600D+03,1.8800D+03,1.8700D+03,
     & 1.8400D+03,1.8200D+03,1.8000D+03,1.7400D+03,1.6650D+03,
     & 1.6650D+03,1.6780D+03,1.6920D+03,1.7440D+03,1.8780D+03 /

      DATA ((SIGKP(I,J),I= 1,20),J= 7, 9) /
     & 1.1530D+03,1.1530D+03,1.1530D+03,1.1530D+03,1.1530D+03,
     & 1.1530D+03,1.1530D+03,9.8450D+02,9.4660D+02,9.5740D+02,
     & 9.4660D+02,9.3310D+02,9.0000D+02,8.8600D+02,8.8000D+02,
     & 8.8600D+02,8.9300D+02,9.1500D+02,9.5600D+02,1.0850D+03,
     & 1.8219D+03,1.8219D+03,1.8219D+03,1.8219D+03,1.8219D+03,
     & 1.8219D+03,1.8219D+03,1.6088D+03,1.5469D+03,1.5646D+03,
     & 1.5469D+03,1.5248D+03,1.4660D+03,1.4330D+03,1.4070D+03,
     & 1.4070D+03,1.4210D+03,1.4520D+03,1.5130D+03,1.6890D+03,
     & 2.0215D+03,2.0215D+03,2.0215D+03,2.0215D+03,2.0215D+03,
     & 2.0215D+03,2.0215D+03,1.7987D+03,1.7296D+03,1.7493D+03,
     & 1.7296D+03,1.7049D+03,1.6400D+03,1.6000D+03,1.5700D+03,
     & 1.5630D+03,1.5800D+03,1.6130D+03,1.6790D+03,1.8680D+03 /

      DATA ((SIGKM(I,J),I= 1,20),J= 7, 9) /
     & 1.1530D+03,1.1530D+03,1.1530D+03,1.1530D+03,1.1530D+03,
     & 1.1530D+03,1.1530D+03,1.1530D+03,1.0683D+03,1.0590D+03,
     & 1.0530D+03,1.0460D+03,1.0180D+03,9.3700D+02,8.9800D+02,
     & 8.8600D+02,8.9300D+02,9.1500D+02,9.5600D+02,1.0850D+03,
     & 1.8219D+03,1.8219D+03,1.8219D+03,1.8219D+03,1.8219D+03,
     & 1.8219D+03,1.8219D+03,1.8219D+03,1.6881D+03,1.6750D+03,
     & 1.6700D+03,1.6600D+03,1.6200D+03,1.4330D+03,1.4070D+03,
     & 1.4070D+03,1.4210D+03,1.4520D+03,1.5130D+03,1.6890D+03,
     & 2.0215D+03,2.0215D+03,2.0215D+03,2.0215D+03,2.0215D+03,
     & 2.0215D+03,2.0215D+03,2.0215D+03,1.8731D+03,1.8590D+03,
     & 1.8540D+03,1.8440D+03,1.8000D+03,1.6200D+03,1.5800D+03,
     & 1.5630D+03,1.5800D+03,1.6130D+03,1.6790D+03,1.8680D+03 /

      DATA ((SIGAP(I,J),I= 1,20),J= 7, 9) /
     & 1.5900D+03,1.5900D+03,1.5900D+03,1.5900D+03,1.5900D+03,
     & 1.5900D+03,1.5900D+03,1.5900D+03,1.4570D+03,1.4170D+03,
     & 1.3760D+03,1.3360D+03,1.3160D+03,1.2600D+03,1.1750D+03,
     & 1.1720D+03,1.1760D+03,1.1760D+03,1.1850D+03,1.2330D+03,
     & 2.3380D+03,2.3380D+03,2.3380D+03,2.3380D+03,2.3380D+03,
     & 2.3380D+03,2.3380D+03,2.3380D+03,2.1360D+03,2.0760D+03,
     & 2.0170D+03,1.9580D+03,1.9280D+03,1.8730D+03,1.8000D+03,
     & 1.8040D+03,1.8160D+03,1.8160D+03,1.8260D+03,1.8740D+03,
     & 2.5520D+03,2.5520D+03,2.5520D+03,2.5520D+03,2.5520D+03,
     & 2.5520D+03,2.5520D+03,2.5520D+03,2.3300D+03,2.2650D+03,
     & 2.2000D+03,2.1360D+03,2.1030D+03,2.0500D+03,1.9840D+03,
     & 1.9900D+03,2.0040D+03,2.0040D+03,2.0150D+03,2.0610D+03 /

      DATA ((TOTCRS(I,J),I= 1,19),J= 1, 3) /
     & 7.9400D+01,7.6200D+01,4.4700D+01,3.6500D+01,3.3100D+01,
     & 4.0200D+01,4.3400D+01,5.1700D+01,4.3600D+01,3.6900D+01,
     & 3.1200D+01,3.1600D+01,3.3500D+01,3.0400D+01,2.7400D+01,
     & 2.5400D+01,2.4500D+01,2.4000D+01,2.2500D+01,
     & 5.4200D+01,5.1000D+01,3.6000D+01,2.6000D+01,2.9100D+01,
     & 3.0000D+01,3.0000D+01,3.6600D+01,3.3000D+01,2.9600D+01,
     & 2.8300D+01,2.7000D+01,2.6400D+01,2.2700D+01,2.1800D+01,
     & 2.0500D+01,2.1000D+01,2.1900D+01,2.0600D+01,
     & 1.2000D+01,1.3700D+01,1.3000D+01,1.2500D+01,1.1200D+01,
     & 1.2000D+01,1.4300D+01,1.6000D+01,1.7200D+01,1.8100D+01,
     & 1.7900D+01,1.8300D+01,1.7900D+01,1.7600D+01,1.7200D+01,
     & 1.7600D+01,1.7200D+01,1.7000D+01,1.7300D+01 /

      DATA ((TOTCRS(I,J),I= 1,19),J= 4, 5) /
     & 1.3000D+01,1.4500D+01,1.4000D+01,1.3000D+01,1.4500D+01,
     & 1.5800D+01,1.6900D+01,1.8500D+01,2.0600D+01,2.0900D+01,
     & 2.0000D+01,1.9400D+01,1.9000D+01,1.8800D+01,1.7800D+01,
     & 1.7800D+01,1.7800D+01,1.7500D+01,1.7500D+01,
     & 2.8000D+02,1.9970D+02,1.7110D+02,1.5430D+02,1.4000D+02,
     & 1.3000D+02,1.1680D+02,1.1740D+02,1.1160D+02,1.0900D+02,
     & 1.0650D+02,1.0280D+02,1.0000D+02,9.0200D+01,7.6700D+01,
     & 6.8000D+01,6.2800D+01,6.0700D+01,5.6000D+01 /

C  PLAB - LAB MOMENTUM SCALE FOR TOTCRS
      DATA PLAB/.3D0,.4D0,.5D0,.6D0,.7D0,.8D0,.9D0,1.D0,1.1D0,
     *1.2D0,1.3D0,
     &1.4D0,1.5D0,2.D0,3.D0,4.D0,
     *5.D0,6.D0,10.D0/
* Original correspondence
*                p    ap   e-   e+   nu  anu gamma  n    an  mu+  mu-
*     DATA ITT/   1,   7,   0,   0,   0,   0,   0,   2,   8,   0,   0,
*              Klong pi+  pi-   K+   K- Lam  Alam Kshrt Sig- Sig+ Sig0
*    &           10,   3,   4,   6,   5,   1,   2,  10,   1,   1,   1,
*               pi0   K0  AK0
*    &            3,  10,   9/
*                p    ap   e-   e+   nu  anu gamma  n    an  mu+  mu-
      DATA ITT/   1,   7,   0,   0,   0,   0,   0,   2,   8,   0,   0,
*              Klong pi+  pi-   K+   K- Lam  Alam Kshrt Sig- Sig+ Sig0
     &           10,   3,   4,   6,   5,   2,   8,  10,   2,   1,   2,
*               pi0   K0  AK0  pi0  res. res. res. res. Asi- Asi0 Asi+
     &            3,  10,   9,   3,   0,   0,   0,   0,   8,   8,   7,
*                X0  Ax0   X-  AX-  Om- Aom+
     &            2,   8,   2,   8,   2,   8 /
*
*
*     Modified by A. Ferrari to use RNDM2
*
*
*     Comment the next 1 card for Rndm2, activate for Rndm
*
*     DATA ROU1/-2.D0/
*
*     Comment the next 1 card on Rndm, activate for Rndm2
*
      DATA IROU1, IROU2 /2*0/
      AA=AAA
      SI=AZRZRZ
      ZL=AINFNT
      IF ( AA .LT. 1.5D+00 ) THEN
         IF ( IT .EQ. 13 .AND. PO .LE. 0.270436311984990D+00 ) THEN
            SI = 0.D+00
            ZL = AINFNT
            RETURN
         ELSE IF ( IT .EQ. 1 .AND. PO .LE. 0.776527236216833D+00 ) THEN
            SI = 0.D+00
            ZL = AINFNT
            RETURN
         ELSE IF ( IT .EQ. 8 .AND. PO .LE. 0.777284775476990D+00 ) THEN
            SI = 0.D+00
            ZL = AINFNT
            RETURN
         END IF
      END IF
*  Check the kinetic energy: no interaction below 50 MeV at present
*     IF ( IT .LE. 30 ) THEN
         IF ( EKE .LT. 0.0499D+00 ) RETURN
*     ELSE
*        IF ( EKE .LT. 2.5D+00 ) RETURN
*     END IF
      IF(AA.LT.0.99D0)RETURN
C
C     CALCULATE THE NEW PARTICLE NUMBER IIT:   1=P,2=N,3=PI+,4=PI-,
C     5=K-,6=K+,7=P BAR,8=N BAR,9=K ZERO BAR,10=K ZERO
C
      IIT=ITT(IT)
      IF(IIT.EQ.0)RETURN
C
C     RNDM IS CALLED ONLY ONCE EVEN IF 'CALL NIZL' IS IN A DO-LOOP
C     (I.E. CURRENT MATERIAL IS A COMPOUND).
C
      IF(IT.EQ.19.OR.IT.EQ.12) THEN
        CALL GRNDMQ(JROU1,JROU2,0,'G')
        IF(IROU1.NE.JROU1.AND.IROU2.NE.JROU2) THEN
           CALL GRNDM(RNDM,1)
           RND=RNDM(1)
        ENDIF
        IF(RND.GT.0.5D0) IIT=9
        CALL GRNDMQ(IROU1,IROU2,0,'G')
      END IF
      IF(AA.LT.2.D0) GOTO 9
      IF(IIT.GE.5.AND.PO.LE.2.D0) GOTO 102
C
C********************************************************************
C     P, N , PI+, PI-  OR ANY HIGH ENERGY (> 2 GEV/C) HADRON
C********************************************************************
C
C     CALCULATE THE MOMENTUM INDEX K
C
 9    CONTINUE
      DO 22 K=1,20
         IF(PO.LE.P(K)) GO TO 23
   22 CONTINUE
      K=20
   23 CONTINUE
C
C     CALCULATE THE MASS INDEX J
C
      IF(AA.GE.2.D0) GOTO 8
      AA=1.D+00
      J=1
      JJ=1
      GOTO 7
 8    CONTINUE
      DO 5 I=2,8
         IF(AA.LE.A(I)) GO TO 6
         GO TO 5
    6    CONTINUE
         J=I-1
         JJ=J+1
         GO TO 7
    5 CONTINUE
      J=8
      JJ=J+1
    7 CONTINUE
      GO TO (101,101,114,113,116,115,1002,1002,116,115)    ,IIT
C
C     NUCLEONS
C
 101  CONTINUE
      SI1=SIG(K,J)*(AA/A(J))**(LOG(SIG(K,JJ)/SIG(K,J))/LOG(A(J+1)/A(J
     *)))
      IF (K.EQ.1) THEN
         SI=SI1
         GO TO 121
      END IF
      KK=K-1
      SI2=SIG(KK,J)*(AA/A(J))**(LOG(SIG(KK,JJ)/SIG(KK,J))/LOG(A(J+1)/
     *A(J)))
      IF (PO.GE.10000.D0) THEN
         AMITSQ=AM(IT)*AM(IT)
         S1SQ=AMITSQ+AMNCSQ+AMNTM2*(P(K)+0.5D+00*AMITSQ/P(K))
         S2SQ=AMITSQ+AMNCSQ+AMNTM2*(P(KK)+0.5D+00*AMITSQ/P(KK))
         SSSQ=AMITSQ+AMNCSQ+AMNTM2*(PO+0.5D+00*AMITSQ/PO)
         ALS2SQ=LOG(S2SQ)
         BCOEF=(SI2-SI1)/(ALS2SQ-LOG(S1SQ))
         ACOEF=SI2-BCOEF*ALS2SQ
         SI=ACOEF+BCOEF*LOG(SSSQ)
         GO TO 121
      ELSE
         GO TO 120
      END IF
C
C     PI -
C
  113 CONTINUE
      IF(K.EQ.1) GOTO 1113
      SI1=SEG(K,J)*(AA/A(J))**(LOG(SEG(K,JJ)/SEG(K,J))/LOG(A(J+1)/A(J
     *)))
      KK=K-1
      SI2=SEG(KK,J)*(AA/A(J))**(LOG(SEG(KK,JJ)/SEG(KK,J))/LOG(A(J+1)/
     *A(J)))
      IF (PO.GE.10000.D0) THEN
         AMITSQ=AM(IT)*AM(IT)
         S1SQ=AMITSQ+AMNCSQ+AMNTM2*(P(K)+0.5D+00*AMITSQ/P(K))
         S2SQ=AMITSQ+AMNCSQ+AMNTM2*(P(KK)+0.5D+00*AMITSQ/P(KK))
         SSSQ=AMITSQ+AMNCSQ+AMNTM2*(PO+0.5D+00*AMITSQ/PO)
         ALS2SQ=LOG(S2SQ)
         BCOEF=(SI2-SI1)/(ALS2SQ-LOG(S1SQ))
         ACOEF=SI2-BCOEF*ALS2SQ
         SI=ACOEF+BCOEF*LOG(SSSQ)
         GO TO 121
      ELSE
         GO TO 120
      END IF
C
C     PI +
C
  114 CONTINUE
      IF(K.EQ.1) GOTO 1113
      SI1=SEGP(K,J)*(AA/A(J))**(LOG(SEGP(K,JJ)/SEGP(K,J))/LOG(A(J+1)/
     *A(J)))
      KK=K-1
      SI2=SEGP(KK,J)*(AA/A(J))**(LOG(SEGP(KK,JJ)/SEGP(KK,J))/LOG(A(J+
     *1)/A(J)))
      IF (PO.GE.10000.D0) THEN
         AMITSQ=AM(IT)*AM(IT)
         S1SQ=AMITSQ+AMNCSQ+AMNTM2*(P(K)+0.5D+00*AMITSQ/P(K))
         S2SQ=AMITSQ+AMNCSQ+AMNTM2*(P(KK)+0.5D+00*AMITSQ/P(KK))
         SSSQ=AMITSQ+AMNCSQ+AMNTM2*(PO+0.5D+00*AMITSQ/PO)
         ALS2SQ=LOG(S2SQ)
         BCOEF=(SI2-SI1)/(ALS2SQ-LOG(S1SQ))
         ACOEF=SI2-BCOEF*ALS2SQ
         SI=ACOEF+BCOEF*LOG(SSSQ)
         GO TO 121
      ELSE
         GO TO 120
      END IF
C
C     K -  AND K0 BAR
C
  116 CONTINUE
C     IF(K.EQ.1) GOTO 1113
      SI1=SIGKM(K,J)*(AA/A(J))**(LOG(SIGKM(K,JJ)/SIGKM(K,J))/LOG(A(J+
     *1)/A(J)))
      IF (K.EQ.1) THEN
         SI=SI1
         GO TO 121
      END IF
      KK=K-1
      SI2=SIGKM(KK,J)*(AA/A(J))**(LOG(SIGKM(KK,JJ)/SIGKM(KK,J))/LOG(A
     *(J+1)/A(J)))
      IF (PO.GE.10000.D0) THEN
         AMITSQ=AM(IT)*AM(IT)
         S1SQ=AMITSQ+AMNCSQ+AMNTM2*(P(K)+0.5D+00*AMITSQ/P(K))
         S2SQ=AMITSQ+AMNCSQ+AMNTM2*(P(KK)+0.5D+00*AMITSQ/P(KK))
         SSSQ=AMITSQ+AMNCSQ+AMNTM2*(PO+0.5D+00*AMITSQ/PO)
         ALS2SQ=LOG(S2SQ)
         BCOEF=(SI2-SI1)/(ALS2SQ-LOG(S1SQ))
         ACOEF=SI2-BCOEF*ALS2SQ
         SI=ACOEF+BCOEF*LOG(SSSQ)
         GO TO 121
      ELSE
         GO TO 120
      END IF
C
C     K +  AND K0
C
  115 CONTINUE
      SI1=SIGKP(K,J)*(AA/A(J))**(LOG(SIGKP(K,JJ)/SIGKP(K,J))/LOG(A(J+
     *1)/A(J)))
      IF (K.EQ.1) THEN
         SI=SI1
         GO TO 121
      END IF
      KK=K-1
      SI2=SIGKP(KK,J)*(AA/A(J))**(LOG(SIGKP(KK,JJ)/SIGKP(KK,J))/LOG(A
     *(J+1)/A(J)))
      IF (PO.GE.10000.D0) THEN
         AMITSQ=AM(IT)*AM(IT)
         S1SQ=AMITSQ+AMNCSQ+AMNTM2*(P(K)+0.5D+00*AMITSQ/P(K))
         S2SQ=AMITSQ+AMNCSQ+AMNTM2*(P(KK)+0.5D+00*AMITSQ/P(KK))
         SSSQ=AMITSQ+AMNCSQ+AMNTM2*(PO+0.5D+00*AMITSQ/PO)
         ALS2SQ=LOG(S2SQ)
         BCOEF=(SI2-SI1)/(ALS2SQ-LOG(S1SQ))
         ACOEF=SI2-BCOEF*ALS2SQ
         SI=ACOEF+BCOEF*LOG(SSSQ)
         GO TO 121
      ELSE
         GO TO 120
      END IF
C
C     ANTI-NUCLEONS
C
 1002 CONTINUE
      SI1=SIGAP(K,J)*(AA/A(J))**(LOG(SIGAP(K,JJ)/SIGAP(K,J))/LOG(A(J+
     *1)/A(J)))
      IF (K.EQ.1) THEN
         SI=SI1
         GO TO 121
      END IF
      KK=K-1
      SI2=SIGAP(KK,J)*(AA/A(J))**(LOG(SIGAP(KK,JJ)/SIGAP(KK,J))/LOG(A
     *(J+1)/A(J)))
      IF (PO.GE.10000.D0) THEN
         AMITSQ=AM(IT)*AM(IT)
         S1SQ=AMITSQ+AMNCSQ+AMNTM2*(P(K)+0.5D+00*AMITSQ/P(K))
         S2SQ=AMITSQ+AMNCSQ+AMNTM2*(P(KK)+0.5D+00*AMITSQ/P(KK))
         SSSQ=AMITSQ+AMNCSQ+AMNTM2*(PO+0.5D+00*AMITSQ/PO)
         ALS2SQ=LOG(S2SQ)
         BCOEF=(SI2-SI1)/(ALS2SQ-LOG(S1SQ))
         ACOEF=SI2-BCOEF*ALS2SQ
         SI=ACOEF+BCOEF*LOG(SSSQ)
         GO TO 121
      END IF
C
C     INTERPOLATE LINEARLY WITH RESPECT TO MOMENTUM
C
  120 CONTINUE
      SI=SI1+(PO-P(K))*(SI2-SI1)/(P(KK)-P(K))
      GO TO 121
C
C********************************************************************
C     LOW ENERGY  (<2.0 GEV/C) K-, K+, PBAR, NBAR, K ZERO BAR, K ZERO
C********************************************************************
C
  102 CONTINUE
      IF(IIT.GE.9) IIT=IIT-4
C
C     CALCULATE MOMENTUM INDEX K AND INTERACTION INDICES I1 AND I2
C
      DO 33 K=1,19
      IF(PO.LE.PLAB(K)) GO TO 34
   33 CONTINUE
      K=19
   34 KK=K-1
      PO1=PO-PLAB(K)
      IIT=IIT-4
      I2=2*IIT
      I1=I2-1
      IF(I1.LT.5) GO TO 41
      I1=5
      I2=5
 41   CONTINUE
C
C     TAKE THE AVERAGE OVER -/NEUTRON AND -/PROTON CROSS SECTIONS
C     AND INTERPOLATE LINEARLY WITH RESPECT TO MOMENTUM
C
      SI=(TOTCRS(K,I1)+TOTCRS(K,I2))*0.5D0
      IF(K.EQ.1) GOTO 2008
      DS=(TOTCRS(KK,I1)+TOTCRS(KK,I2)-TOTCRS(K,I1)-TOTCRS(K,I2))*0.5D0
      SI=SI+PO1*DS/(PLAB(KK)-PLAB(K))
 2008 CONTINUE
      SI=BET(IIT)*SI*AA**ALPH(IIT)
      IF(IT.NE.16.OR.PO.GE.1.41D0) GOTO 121
C
C     SPECIAL TREATMENT FOR LOW ENERGY K-
C
      SI=SI*0.5D0*(1.D0+SQRT(PO**2+0.244D0)-0.494D0)
      GO TO 121
C
C********************************************************************
C        LOW ENERGY PIONS (<0.3GEV/C)
C********************************************************************
C
 1113 CONTINUE
      SI=0.01D0
      IF(IT.EQ.13.AND.J.EQ.1) THEN
        SI = ANGLGB
        GOTO 121
      END IF
      DO 1122 K=1,4
         IF(PO.LE.PEE(K)) GOTO 1123
 1122 CONTINUE
      K=4
 1123 CONTINUE
      SI1=SEEG(K,J)*(AA/A(J))**(LOG(SEEG(K,JJ)/SEEG(K,J))
     * /LOG(A(J+1)/A(J)))
      SI=SI1
      IF(K.EQ.1)GO TO 121
      KK=K-1
      SI2=SEEG(KK,J)*(AA/A(J))**(LOG(SEEG(KK,JJ)
     * /SEEG(KK,J))/LOG(A(J+1)/A(J)))
C
C     INTERPOLATE LINEARLY WITH RESPECT TO MOMENTUM
C
      SI=SI1 + (PO-PEE(K))*(SI2-SI1)/(PEE(KK)-PEE(K))
C
C********************************************************************
C     CALCULATE THE INTERACTION LENGTH
C********************************************************************
C
 121  CONTINUE
* A. Ferrari: commented out, no 1.07 factor is applied now to neutrons
*     IF(J.EQ.1.AND.IIT.EQ.2) SI=SI*1.07D+00
C     ZL=10000.D0*AA/(6.022D0*SI)
      ZL=AVOGMB*AA/SI
      RETURN
      END
+DECK,  NIZLNW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE NIZLNW.FOR
*COPY NIZLNW
*                                                                      *
*=== nizlnw ===========================================================*
*                                                                      *
      SUBROUTINE NIZLNW ( IT, ZZZ, AAA, EKE, PO, SI, ZL )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C
+CDE, PAPROP.
C
      PARAMETER ( AVOGMB = 1.0D+27 / AVOGAD )
C
      DIMENSION ITT (39)
      SAVE ITT
      DATA ITT/   1,   7,   0,   0,   0,   0,   0,   2,   8,   0,   0,
*              Klong pi+  pi-   K+   K- Lam  Alam Kshrt Sig- Sig+ Sig0
     &           10,   3,   4,   6,   5,   2,   8,  10,   2,   1,   2,
*               pi0   K0  AK0  pi0  res. res. res. res. Asi- Asi0 Asi+
     &            3,  10,   9,   3,   0,   0,   0,   0,   8,   8,   7,
*                X0  Ax0   X-  AX-  Om- Aom+
     &            2,   8,   2,   8,   2,   8 /
*
      SI = AZRZRZ
      ZL = AINFNT
C
C     CALCULATE THE NEW PARTICLE NUMBER IIT:   1=P,2=N,3=PI+,4=PI-,
C     5=K-,6=K+,7=P BAR,8=N BAR,9=K ZERO BAR,10=K ZERO
C
      IIT = ITT (IT)
      IF ( IIT .LE. 0 ) RETURN
*  Check the kinetic energy: no interaction below 50 MeV at present
      IF ( IIT .LE. 2 .AND. EKE .LT. 0.400D+00 .AND. AAA .GT. 1.5D+00 )
     &   THEN
         IF ( IIT .EQ. 1 ) THEN
            SI = XSEPRO ( EKE, ZZZ, AAA )
         ELSE
            SI = XSENEU ( EKE, ZZZ, AAA )
         END IF
         IF ( EKE .GT. 0.200D+00 ) THEN
            CALL NIZL ( IT, AAA, EKE, PO, SI2, ZL2 )
            WEIGH1 = ( 0.400D+00 - EKE ) / 0.200D+00
            SI = WEIGH1 * SI + ( 1.D+00 - WEIGH1 ) * SI2
         END IF
         IF ( SI .GT. 0.D+00 ) THEN
            ZL = AVOGMB * AAA / SI
         ELSE
            SI = 0.D+00
            ZL = AINFNT
         END IF
      ELSE
         CALL NIZL ( IT, AAA, EKE, PO, SI, ZL )
      END IF
      RETURN
      END
+DECK,  NUCEVV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:57  cernlib
* Geant

*$ CREATE NUCEVV.FOR
*COPY NUCEVV
*=== nucevv ===========================================================*
      SUBROUTINE NUCEVV ( NNHAD, KPROJ, PPPROJ, EKPROJ, TXI, TYI, TZI )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*----------------------------------------------------------------------*
*     Nucevt90: new version by A. Ferrari INFN-Milan and CERN-SPS
*
*       Besides code cleaning, some changes have been made to extract
*       the quantities needed for a correct energy, momentum, electric
*       charge and baryonic charge conservation. This quantities are put
*       in /balanc/ common
*----------------------------------------------------------------------*
*
C
C**************************************************************
C        /NUCPAR/
C        PARTICLES CREATED IN NUCEVT
C           PXNU,PYNU,PZNU = X-, Y- AND Z-COMPONENTS OF THE
C           LAB MOMENTUM OF THE SECONDARY. COORDINATE SYSTEM
C           DEFINED BY THE PRIMARY PARTICLE.
C           HEPNU    =  TOTAL ENERGY IN THE LAB
C           AMNU     =  REST MASS
C           ICHNU    =  CHARGE
C           IBARNU   =  BARYONIC NUMBER
C           ANNU     =  NAME OF THE PARTICLE
C           NRENU    =  TYPE NUMBER OF THE PARTICLE
C**************************************************************
C
+CDE, BALANC.
+CDE, CORINC.
+CDE, DEPNUC.
+CDE, HADPAR.
+CDE, INPDAT2.
+CDE, NUCDAT.
+CDE, NUCPAR.
+CDE, PAREVT.
+CDE, PART.
+CDE, RESNUC.
      COMMON /FKPRIN/ IPRI, INIT
*  The following dimension statement is now obsolete
*     DIMENSION XQT(20), XDQT(20), IFQT(3,20)
      REAL RNDM(1)
      LOGICAL LDSAVE
      DIMENSION PTHRSH (39)
      SAVE PTHRSH
      DATA PTHRSH / 16*5.D+00,2*2.5D+00,5.D+00,3*2.5D+00,8*5.D+00,
     &              9*2.5D+00 /
*
*
*
*----------------------------------------------------------------------*
*         Eproj  = total energy of the projectile
*         Amproj = mass energy of the projectile
*         Ekproj = kinetic energy of the projectile
*         Pproj  = momentum of the projectile
*         Eeproj = original total energy of the projectile
*         Ppproj = original momentum of the projectile
*         Ibproj = barionic charge of the projectile
*         Icproj = electric charge of the projectile
*         Nnhad  = number of particles produced in Nucevt
*         Nevt   = number of high energy collisions
*         Atemp  = local variable with the mass number of the residual
*                  nucleus : it is updated at any interaction and alrea-
*                  dy includes contributions from cascade particles
*                  (even though actually they are produced after the
*                   high energy interactions: since there is no real
*                   correlation except for the one with Nsea, this does
*                   not represent a problem)
*         Ztemp  = same as Atemp for the atomic number
*----------------------------------------------------------------------*
*
      TXX = TXI
      TYY = TYI
      TZZ = TZI
      PPROJ = PPPROJ
      AMPROJ= AM (KPROJ)
      EPROJ = EKPROJ + AMPROJ
      EEPROJ= EPROJ
C
      IBPROJ= IBAR (KPROJ)
      ICPROJ= ICH  (KPROJ)
*  Set Atemp and Ztemp to their initial values
      ATEMP = IBTAR  - IGREYP - IGREYN
      ZTEMP = ICHTAR - IGREYP
      NNHAD = 0
      NEVT  = 0
* Now Nsea is sampled inside Corrin and passed through common /corrinc
      IF ( NSEA .EQ. 0 ) GO TO 1000
      IF ( INIT .EQ. 1 ) WRITE(LUNOUT,1)NNHAD,KPROJ,PPROJ,
     *                   AMPROJ,EPROJ,ANUAV,NSEA
   1  FORMAT (1X,2I5,4F12.5,I10)
*
*  We have now sampled Nsea, the number of quark-antiquark pairs
*  interacting besides the valence interaction (total interactions
*  = Nsea+1
*
*or      IF (INIT.EQ.1) WRITE(LUNOUT,4)XO,(XSEA(I),XASEA(I),I=1,NSEA)
*or   4  FORMAT (10F12.6)
*  +-------------------------------------------------------------------*
*  |  Sample effective meson nucleus collisions
*  |  Em, im, ekm, pm refer to the meson quantities
      DO 6 I = 1, NSEA
         EM = EKPROJ * ( XSEA(I) + XASEA(I) )
*  |  +----------------------------------------------------------------*
*  |  |  Selection of the ddbar or qqbar composition
         CALL GRNDM(RNDM,1)
         IF ( RNDM (1) .LT. 0.5D+00 ) THEN
            IM = 23
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IM = 26
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         AMPIO  = AM (IM)
         EKM = EM - AMPIO
*  |  +----------------------------------------------------------------*
*  |  |  Energy and/or momentum is too low!!!
         IF ( EKM .LT. ETHSEA .OR. PPROJ .LT. PTHRSH (KPTOIP(KPROJ)) )
     &      THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( I .LT. NSEA ) THEN
               II = I + 1
               XSEA(II) = XSEA(II)  + XSEA(I)
               XASEA(II)= XASEA(II) + XASEA(I)
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            KT = IJTARG (I)
*  |  |  +-------------------------------------------------------------*
*  |  |  | Kt is the index of the target nucleon (1=proton,8=neutron)
            IF ( KT .EQ. 1 ) THEN
               ZNOW  = ZNOW + 1.D+00
               KTARP = KTARP - 1
               ZNCOLL = ZNCOLL - 1.D+00
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               KTARN = KTARN - 1
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            ANOW   = ANOW   + 1.D+00
            ANCOLL = ANCOLL - 1.D+00
            GO TO 6
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         AMPIO2 = AMPIO * AMPIO
         EPROLD = EKPROJ + AMPROJ
         PPROLD = PPROJ
*  | After selection of the meson energy, Ekproj is updated
         EKPROJ = EKPROJ - EM
         EPROJ  = EKPROJ + AMPROJ
*  |  +----------------------------------------------------------------*
*  |  | All ekproj energy is transferred to em if ekproj < 4 GeV
*  |  | Now modified since it causes troubles to energy conservation by
*  |  | A. Ferrari: force them to have only a valence interaction
         IF ( EKPROJ .LT. 3.99D0 ) THEN
            EKPROJ = EKPROJ + EM
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            DO 666 IN = I, NSEA
               KT = IJTARG (IN)
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  | Kt is the index of the target nucleon (1=proton,8=neutron)
               IF ( KT .EQ. 1 ) THEN
                  ZNOW  = ZNOW + 1.D0
                  KTARP = KTARP - 1
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE
                  KTARN = KTARN - 1
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               ANOW  = ANOW + 1.D0
 666        CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            GO TO 66
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  Now the wounded nucleus is selected inside Corevt
         KT    = IJTARG (I)
         ATEMP = ATEMP - 1.D+00
         IF ( KT .EQ. 1 ) ZTEMP = ZTEMP - 1.D+00
*  |  +---------------------------------------------------------------*
*  |  |
         IF ( NINT ( ATEMP ) .EQ. 1 ) THEN
            LLASTN = .TRUE.
            KTLAST = KT
            KTINC  = IJTARG ( NSEA + 1 )
            PM = SQRT ( EM**2 - AMPIO2 )
            AMLAST = AM (KTLAST)
            AMINC  = AM (KTINC)
            UMIN2  = ( AMINC + AMLAST )**2
            ITJ = MIN ( KTINC, 2 )
            DELTAE = V0WELL (ITJ) - EFRMAV (ITJ)
*  |  |  +------------------------------------------------------------*
*  |  |  |   Selection of the invariant mass of the two last nucleon
*  |  |  |   system
2020        CONTINUE
               EKPROJ = EKPROJ - DELTAE
               EFRM   = EFRM  - DELTAE
               ELEFT  = ETTOT - EINTR - EUZ - EKPROJ - AMPROJ - EM
               PPROJ  = SQRT ( EKPROJ * ( EKPROJ + 2.D+00 * AMPROJ ) )
               PXLEFT = PXTTOT - PXINTR - PUX - ( PPROJ + PM ) * TXX
               PYLEFT = PYTTOT - PYINTR - PUY - ( PPROJ + PM ) * TYY
               PZLEFT = PZTTOT - PZINTR - PUZ - ( PPROJ + PM ) * TZZ
               UMO2 = ELEFT**2 - PXLEFT**2 - PYLEFT**2 - PZLEFT**2
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( UMO2 .LE. UMIN2 ) THEN
                  PPDTPL = PXLEFT * TXX + PYLEFT * TYY + PZLEFT * TZZ
                  DELTAE = 0.51D+00 * ( UMIN2 - UMO2 ) / ( ELEFT -
     &                     PPDTPL * ( EKPROJ + AMPROJ ) / PPROJ )
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |   Skip the sea interaction if deltae < 0
                  IF ( DELTAE .LT. 0.D+00 ) THEN
                     EKPROJ = EKPROJ + EM
                     ATEMP = ATEMP + 1.D+00
                     IF ( KT .EQ. 1 ) ZTEMP = ZTEMP + 1.D+00
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     DO 777 IN = I, NSEA
                        KT = IJTARG (IN)
*  |  |  |  |  |  |  +-------------------------------------------------*
*  |  |  |  |  |  |  |  Kt is the index of the target nucleon
*  |  |  |  |  |  |  | (1=proton,8=neutron)
                        IF ( KT .EQ. 1 ) THEN
                           ZNOW  = ZNOW + 1.D0
                           KTARP = KTARP - 1
*  |  |  |  |  |  |  |
*  |  |  |  |  |  |  +-------------------------------------------------*
*  |  |  |  |  |  |  |
                        ELSE
                           KTARN = KTARN - 1
                        END IF
*  |  |  |  |  |  |  |
*  |  |  |  |  |  |  +-------------------------------------------------*
                        ANOW  = ANOW + 1.D0
 777                 CONTINUE
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
                     PPROJ  = SQRT ( EKPROJ * ( EKPROJ + 2.D+00
     &                      * AMPROJ ) )
                     GO TO 66
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE IF ( DELTAE .GE. EKPROJ ) THEN
                     WRITE ( LUNERR,* )' Nucevv: sea call impossible ',
     &                                 ' to get Umin2, go to resampling'
                     LRESMP = .TRUE.
                     RETURN
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  GO TO 2020
*  |  |  |
*  |  |  +-<|--<--<--<--< We need more invariant mass!!
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  Now we will divide Eleft and Pleft between the two
*  |  |  left nucleons!
            UMO = SQRT ( UMO2 )
            ELACMS = 0.5D+00 * ( UMO2 + AMLAST**2 - AMINC**2 )
     &             / UMO
            EINCMS = UMO - ELACMS
            PCMS   = SQRT ( ELACMS**2 - AMLAST**2 )
            GAMCM = ELEFT  / UMO
            ETAX  = PXLEFT / UMO
            ETAY  = PYLEFT / UMO
            ETAZ  = PZLEFT / UMO
            CALL RACO ( CXXINC, CYYINC, CZZINC )
            PCMSX = PCMS * CXXINC
            PCMSY = PCMS * CYYINC
            PCMSZ = PCMS * CZZINC
*  |  |  Now go back from the CMS frame to the lab frame!!!
*  |  |  First the "inc" nucleon:
            ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
            EKINC  = GAMCM * EINCMS + ETAPCM - AMINC
            PHELP  = ETAPCM / (GAMCM + 1.D+00) + EINCMS
            PXXINC = PCMSX + ETAX * PHELP
            PYYINC = PCMSY + ETAY * PHELP
            PZZINC = PCMSZ + ETAZ * PHELP
*  |  |  Now the "last" nucleon
            EKLAST = GAMCM * ELACMS - ETAPCM - AMLAST
            PHELP  = - ETAPCM / (GAMCM + 1.D+00) + ELACMS
            PXLAST = - PCMSX + ETAX * PHELP
            PYLAST = - PCMSY + ETAY * PHELP
            PZLAST = - PCMSZ + ETAZ * PHELP
            TVEUZ  = 0.D+00
            TVGRE0 = 0.D+00
            EINCT  = EINCP + EINCN
            IF ( EINCT .GT. 0.D+00 ) THEN
               EINCP  = EINCP - EINCP / EINCT * TVGREY
               EINCN  = EINCN - EINCN / EINCT * TVGREY
            END IF
            TVGREY = 0.D+00
            PSEA = PM + PPROJ - PPROLD
            LDSAVE = LDIFFR (KPTOIP(IM))
            LDIFFR (KPTOIP(IM)) = .FALSE.
*  |  |  The last argument for ferevv is set to 0 to signal that it
*  |  |  is not a true valence call
            IVFLAG = 0
            CALL FEREVV ( NHAD, IM, KT, PM, EKM, TXX, TYY, TZZ, ATEMP,
     &                    ZTEMP, IVFLAG )
            LDIFFR (KPTOIP(IM)) = LDSAVE
            IF ( LRESMP ) RETURN
*  |  |
*  |  +---------------------------------------------------------------*
*  |  |
         ELSE
            TXXOLD = TXX
            TYYOLD = TYY
            TZZOLD = TZZ
            PPROJ  = SQRT ( EKPROJ * ( EKPROJ + 2.D+00 * AMPROJ ) )
            IF ( PPROJ .GT. PPROLD ) THEN
               PPROJ = PPROLD * EPROJ / EPROLD
            END IF
            CALL FERSEA ( NHAD, IM, KT, EKM, TXX, TYY, TZZ, ATEMP,
     &                    ZTEMP, KPROJ, EPROJ, PPROJ, EPROLD, PPROLD )
            IF ( LRESMP ) RETURN
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         NEVT = NEVT + 1
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( NNHAD + NHAD .GT. MXPNUC ) THEN
            WRITE (LUNOUT,1101) NNHAD
1101        FORMAT('  NHAD IN NUCEVT TOO BIG CHANGE DIMENSION',
     *             '  NNHAD=',I10)
            STOP
         END IF
*  |  |
*  |  +----------------------------------------------------------------*

*  |  +----------------------------------------------------------------*
*  |  |          Looping over the produced particles!!!
         DO 7 JJ = 1, NHAD
            NNHAD = NNHAD + 1
            J     = NNHAD
            PXNU(J)  = PXH(JJ)
            PYNU(J)  = PYH(JJ)
            PZNU(J)  = PZH(JJ)
            HEPNU(J) = HEPH(JJ)
            AMNU(J)  = AMH(JJ)
            IBARNU(J)= IBARH(JJ)
            ICHNU(J) = ICHH(JJ)
            NRENU(J) = NREH(JJ)
            ANNU(J)  = ANH(JJ)
*  |  |          Updating energy and momentum accumulators
            PUX = PUX+PXNU(J)
            PUY = PUY+PYNU(J)
            PUZ = PUZ+PZNU(J)
            EUZ = EUZ+HEPNU(J)
            ICU = ICU+ICHNU(J)
            IBU = IBU+IBARNU(J)
   7     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
   6  CONTINUE
*  |
*  +-------------------------------------------------------------------*
  66  CONTINUE
*
*  Computing the actual pproj
*
      EPROJ = EKPROJ + AMPROJ
1000  CONTINUE
*  +-------------------------------------------------------------------+
*  |  Now modified because of troubles to energy conservation by
*  |  A. Ferrari: if the incident projectile is a proton or a neutron
*  |  maybe it was stopped in the nucleus, else it is added to the stack,
*  |  other particles are also added to the secondary stack.
*  |  May be is not physical, but better than nothing!!! A different
*  |  solution maybe to let meson and other baryons decay at rest or
*  |  also force them to have only a valence interaction or also
*  |  convert a charged meson plus a residual neutron/proton to a
*  |  proton/neutron and add the extra energy to the sea meson and
*  |  so on        ????????????????????
*  |  Now the condition Pproj .ge. .4 is always fulfilled!!!!!
      IF (PPROJ .LT. 4.D0) THEN
*  |  +---------------------------------------------------------------*
*  |  |
         DKPR30 = KPROJ-30
         IF ( PPROJ - 1.5D+00 * SIGN ( ONEONE, DKPR30 )
     &        .LT. 4.D0 ) THEN
            WRITE ( LUNERR,* )' Nucevt: Pproj < 4 GeV/c!!!', PPROJ,
     &                          KPROJ
         END IF
*  |  |
*  |  +---------------------------------------------------------------*
      END IF
*  |
*  +------------------------------------------------------------------*
*   Now the wounded nucleus is selected inside Corevt
      KT = IJTARG ( NSEA + 1 )
*   Update the Nsea value
      NSEA = NEVT
*or      IF (INIT.EQ.1) WRITE(LUNOUT,162)NEVT,NHAD,IM,KPROJ,KT,PM,
*or     &EM,EKM,PM,EKPROJ,PPROJ,EPROJ
*
*  Now ferevt performs the interaction: no longer a meson but the actual
*  projectile
*
      ATEMP = ATEMP - 1.D+00
      IF ( KT .EQ. 1 ) ZTEMP = ZTEMP - 1.D+00
*  +-------------------------------------------------------------------*
*  |
      IF ( NINT ( ATEMP ) .EQ. 1 ) THEN
         LLASTN = .TRUE.
         KTLAST = KT
         IF ( ZNOW .GT. 0.D+00 ) THEN
            KTINC  = 1
         ELSE
            KTINC  = 8
         END IF
         AMLAST = AM (KTLAST)
         AMINC  = AM (KTINC)
         UMIN2  = ( AMINC + AMLAST )**2
         ITJ = MIN ( KTINC, 2 )
*  |  +----------------------------------------------------------------*
*  |  |   Selection of the invariant mass of the two last nucleon
*  |  |   system
2040     CONTINUE
            ELEFT  = ETTOT - EINTR - EUZ - EKPROJ - AMPROJ
            PXLEFT = PXTTOT - PXINTR - PUX - PPROJ * TXX
            PYLEFT = PYTTOT - PYINTR - PUY - PPROJ * TYY
            PZLEFT = PZTTOT - PZINTR - PUZ - PPROJ * TZZ
            UMO2 = ELEFT**2 - PXLEFT**2 - PYLEFT**2 - PZLEFT**2
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( UMO2 .LE. UMIN2 ) THEN
               PPDTPL = PXLEFT * TXX + PYLEFT * TYY + PZLEFT * TZZ
               DELTAE = 0.51D+00 * ( UMIN2 - UMO2 ) / ( ELEFT -
     &                  PPDTPL * ( EKPROJ + AMPROJ ) / PPROJ )
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( DELTAE .GE. EKPROJ .OR. DELTAE .LT. 0.D+00 ) THEN
                  WRITE ( LUNERR,* )' Nucevv: valence call impossible ',
     &                              ' to get Umin2, go to resampling'
                  LRESMP = .TRUE.
                  RETURN
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               EKPROJ = EKPROJ - DELTAE
               PLA    = PPROJ
               PPROJ  = SQRT ( EKPROJ * ( EKPROJ + 2.D+00 * AMPROJ ) )
               PLA    = PPROJ - PLA
               EFRM   = EFRM  - DELTAE
               PXFRM  = PXFRM + TXX * PLA
               PYFRM  = PYFRM + TYY * PLA
               PZFRM  = PZFRM + TZZ * PLA
               GO TO 2040
*  |  |
*  |  +-<|--<--<--<--< We need more invariant mass!!
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  Now we will divide Eleft and Pleft between the two
*  |  left nucleons!
         UMO = SQRT ( UMO2 )
         ELACMS = 0.5D+00 * ( UMO2 + AMLAST**2 - AMINC**2 ) / UMO
         EINCMS = UMO - ELACMS
         PCMS   = SQRT ( ELACMS**2 - AMLAST**2 )
         GAMCM = ELEFT  / UMO
         ETAX  = PXLEFT / UMO
         ETAY  = PYLEFT / UMO
         ETAZ  = PZLEFT / UMO
         CALL RACO ( CXXINC, CYYINC, CZZINC )
         PCMSX = PCMS * CXXINC
         PCMSY = PCMS * CYYINC
         PCMSZ = PCMS * CZZINC
*  |  Now go back from the CMS frame to the lab frame!!!
*  |  First the "inc" nucleon:
         ETAPCM = PCMSX * ETAX + PCMSY * ETAY + PCMSZ * ETAZ
         EKINC  = GAMCM * EINCMS + ETAPCM - AMINC
         PHELP  = ETAPCM / (GAMCM + 1.D+00) + EINCMS
         PXXINC = PCMSX + ETAX * PHELP
         PYYINC = PCMSY + ETAY * PHELP
         PZZINC = PCMSZ + ETAZ * PHELP
*  |  Now the "last" nucleon
         EKLAST = GAMCM * ELACMS - ETAPCM - AMLAST
         PHELP  = - ETAPCM / (GAMCM + 1.D+00) + ELACMS
         PXLAST = - PCMSX + ETAX * PHELP
         PYLAST = - PCMSY + ETAY * PHELP
         PZLAST = - PCMSZ + ETAZ * PHELP
         TVEUZ  = 0.D+00
         TVGRE0 = 0.D+00
         EINCT  = EINCP + EINCN
         IF ( EINCT .GT. 0.D+00 ) THEN
            EINCP  = EINCP - EINCP / EINCT * TVGREY
            EINCN  = EINCN - EINCN / EINCT * TVGREY
         END IF
         TVGREY = 0.D+00
      END IF
*  |
*  +-------------------------------------------------------------------*
*  The last argument for ferevv is set to 1 to signal that it
*  is a true valence call
      IVFLAG = 1
      CALL FEREVV ( NHAD, KPROJ, KT, PPROJ, EKPROJ, TXX, TYY, TZZ,
     &              ATEMP, ZTEMP, IVFLAG )
      IF ( LRESMP ) RETURN
      NEVT = NEVT + 1
*  +-------------------------------------------------------------------*
*  |
      IF ( NNHAD + NHAD .GT. MXPNUC ) THEN
         WRITE (LUNOUT,1101) NNHAD
         STOP
      END IF
*  |
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |       Looping over the produced particles
      DO 8 JJ=1,NHAD
         NNHAD = NNHAD+1
         J = NNHAD
         PXNU(J)  = PXH(JJ)
         PYNU(J)  = PYH(JJ)
         PZNU(J)  = PZH(JJ)
         HEPNU(J) = HEPH(JJ)
         AMNU(J)  = AMH(JJ)
         IBARNU(J)= IBARH(JJ)
         ICHNU(J) = ICHH(JJ)
         NRENU(J) = NREH(JJ)
         ANNU(J)  = ANH(JJ)
*  |             Updating energy and momentum accumulators
         PUX = PUX+PXNU(J)
         PUY = PUY+PYNU(J)
         PUZ = PUZ+PZNU(J)
         EUZ = EUZ+HEPNU(J)
         ICU = ICU+ICHNU(J)
         IBU = IBU+IBARNU(J)
   8  CONTINUE
*  |
*  +-------------------------------------------------------------------*
 888  CONTINUE
*     IF (PPROJ .LT. 4.D0) INIT=1
**** print and test energy conservation
*
      ETOT  = EEPROJ + KTARP * ( AMNUCL (1) - EBNDNG (1) )
     &      + KTARN * ( AMNUCL (2) - EBNDNG (2) ) + EFRM
      ICTOT = ICH  (KPROJ) + KTARP
      IBTOT = IBAR (KPROJ) + KTARP + KTARN
      EMIN  = 1.D-10 * ETOT
      PMIN  = 1.D-10 * PPPROJ
*  +-------------------------------------------------------------------*
*  |
      IF (ICTOT .NE. ICU .OR. IBTOT .NE. IBU) THEN
         LRESMP = .TRUE.
         WRITE(LUNERR,*)' NUCEVT-FEREVT CHARGE CONSERVATION FAILURE:',
     &                  ' ICU,ICTOT,IBU,IBTOT',ICU,ICTOT,IBU,IBTOT
      END IF
*  |
*  +-------------------------------------------------------------------*
      PXCHCK = PPPROJ * TXI + PSEA * TXX
      PYCHCK = PPPROJ * TYI + PSEA * TYY
      PZCHCK = PPPROJ * TZI + PSEA * TZZ
*  +-------------------------------------------------------------------*
*  |
      IF ( ABS ( PUX - PXFRM - PXCHCK ) .GT. PMIN ) THEN
         LRESMP = .TRUE.
         WRITE(LUNERR,*)' NUCEVT-FEREVT PX CONSERVATION FAILURE:',
     &                  ' PUX,PXFRM+PXCHCK',PUX,PXFRM+PXCHCK
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      IF ( ABS ( PUY - PYFRM - PYCHCK ) .GT. PMIN ) THEN
         WRITE(LUNERR,*)' NUCEVT-FEREVT PY CONSERVATION FAILURE:',
     &                  ' PUY,PYFRM+PYCHCK*TYY',PUY,PYFRM+PYCHCK
         LRESMP = .TRUE.
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      IF ( ABS ( PUZ - PZFRM - PZCHCK ) .GT. PMIN ) THEN
         LRESMP = .TRUE.
         WRITE(LUNERR,*)' NUCEVT-FEREVT PZ CONSERVATION FAILURE:',
     &                  ' PUZ,PZFRM+PZCHCK',PUZ,PZFRM+PZCHCK
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      IF ( ABS ( ETOT - EUZ ) .GT. EMIN ) THEN
         LRESMP = .TRUE.
         WRITE(LUNERR,*)' NUCEVT-FEREVT E CONSERVATION FAILURE:',
     &                  ' EUZ,ETOT',EUZ,ETOT
      END IF
*  |
*  +-------------------------------------------------------------------*
      EUZ0 = EUZ-NEVT*AM(1)
      IF (INIT.NE.1) GO TO 11
      WRITE(LUNOUT,12)NNHAD,KPROJ,PPPROJ,EPROJ,PUX,PUY,PUZ,EUZ0,
     *ICU,IBU,NNHAD
  12  FORMAT (1X,2I5,6F12.6,3I5)
*  +-------------------------------------------------------------------*
*  |
      DO 13 I=1,NNHAD
         WRITE(LUNOUT,14)I,NRENU(I),ICHNU(I),IBARNU(I),ANNU(I),PXNU(I),
     *                   PYNU(I),PZNU(I),HEPNU(I),AMNU(I)
  14     FORMAT (1X,4I5,A8,6F12.6)
  13  CONTINUE
*  |
*  +-------------------------------------------------------------------*
      INIT=0
  11  CONTINUE
      RETURN
      END
+DECK,  NUCREL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE NUCREL.FOR
*COPY NUCREL
*=== nucrel ===========================================================*
C
C   HJM 17/11/88
C
C                MODIFIED ELASTIC SCATTERING ROUTINE
C                (COMP. KMU-HEP INTERNAL NOTE 88-01)
C
C------------------------------------------------------------------
C
      SUBROUTINE NUCREL(IT,PLAB,EKIN,CX,CY,CZ,ANUC,WEE)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION JULY 81 BY             J. RANFT
C                                    LEIPZIG
C     LAST CHANGE A. FERRARI 26-9-89: RECOIL ENERGY SCORING ADDED
C
C     THIS IS A SUBROUTINE OF FLUKA82 TO SAMPLE ELASTIC INTERACTIONS
C
C     INPUT VARIABLES:
C     IT       = TYPE OF THE PRIMARY
C     PLAB     = PRIMARY PARTICLE LAB MOMENTUM (GEV/C)
C     CX,CY,CZ = PRIMARY PARTICLE DIRECTION COSINES
C     ANUC     = ATOMIC WEIGHT OF THE TARGET NUCLEUS
C
C     OUTPUT VARIABLES:
C     CCX,CCY,CCZ = DIRECTION COSINES OF SCATTERED PARTICLE
C
C********************************************************************
C
      PARAMETER (AMUC12 = 0.9314943228D0)
+CDE, AADAT.
+CDE, FINUC.
*------ Common part has been added by A. Ferrari ----------------------*
+CDE, PART2.
C----------------------------------------------------------------
      REAL RNDM(1)
      DIMENSION ITT(NALLWP),SHP(6),BP(6),XNN(6,6),BA(6,6),XNA(6),AM(6)
      SAVE ITT,SHP,BP,XNN,BA,XNA,AM
      DATA ITT/1,2,0,0,0,0,0,1,2,0,0,5,3,4,5,6,1,2,5,1,1,1,3,5,6,
     &         3,0,0,0,1,2,2,2,1,2,1,2,1,2/
C     ITT(IT) - INTERNAL PARTICLE NUMBER
      DATA AM/ 9.01D0, 12.01D0, 26.98D0, 63.55D0, 118.69D0, 207.19D0/
C     AM - ATOMIC WEIGHTS OF SEVERAL TARGET MATERIALS
      DATA XNA/3.5D0, 3.4D0, 4.5D0, 6.7D0, 8.2D0, 9.5D0/
C     XNA(AM) - EFFECTIVE NUCLEON NUMBER
      DATA BP/12.D0, 12.D0, 4*10.D0/
C     BP(IIT) - INCOHERENT SLOPE (GEV/C)**-2
      DATA SHP/2*40.D0, 2*25.D0, 2*20.D0/
C     SHP(IIT) - TOTAL HADRON - NUCLEON CROSS SECTION  (MB)
C(((((((((((((((      BA(IIT,A)    XNN(IIT,A)       (((((((((((((((((
C     BA - COHERENT SLOPE   (GEV/C)**-2
C     XNN - NORMALIZATION FOR PROJECTILE -NUCLEUS SCATTERING  (MB)
      DATA XNN/
     ( 256.6D0,  240.5D0,  181.0D0,  167.1D0,  144.0D0,  139.0D0,
     ( 335.3D0,  355.0D0,  241.0D0,  229.7D0,  181.5D0,  196.0D0,
     ( 755.1D0, 1344.0D0,  506.0D0,  480.8D0,  431.0D0,  403.0D0,
     (1656.0D0, 1886.0D0, 1104.0D0, 1144.0D0,  914.0D0,  939.0D0,
     (3005.0D0, 2559.0D0, 2112.0D0, 2068.0D0, 1723.0D0, 1791.0D0,
     (5123.0D0, 5444.0D0, 4071.0D0, 3391.0D0, 3368.0D0, 3168.0D0/
      DATA BA/
     ( 72.0D0,  69.3D0,  65.2D0,  63.4D0,  60.0D0,  65.6D0,
     ( 72.3D0,  75.9D0,  65.5D0,  63.1D0,  59.5D0,  68.1D0,
     (119.4D0, 128.7D0, 107.3D0, 105.0D0, 105.6D0,  98.8D0,
     (201.0D0, 212.0D0, 188.9D0, 183.0D0, 179.0D0, 178.0D0,
     (311.0D0, 315.0D0, 286.0D0, 277.0D0, 270.0D0, 266.0D0,
     (454.0D0, 448.0D0, 435.0D0, 397.0D0, 416.0D0, 403.0D0/
C
C********************************************************************
C     PARAMETRIZATION
C     DSIGMA/DOMEGA=C*EXP(-DS*THETA**2)+E*EXP(-FS*THETA**2)
C                   COHERENT PART             INCOHERENT PART
C********************************************************************
C
C***
      NP=1
      TV=0.D0
C***
      IF(IT.EQ.30) GO TO 301
      IF(ANUC.LT.0.99D0) THEN
         CXR(1)=CX
         CYR(1)=CY
         CZR(1)=CZ
         TKI(1)=EKIN
         PLR(1)=PLAB
         KPART(1)=IT
         RETURN
      ENDIF
C
C--------------------------------------------------------------------
C         HJM 10/88       ELASTIC SCATTERING INTO 2-BODY FINALSTATE
C                         FOR NUCLEON-PROTON INITIAL STATE
C         AF  9/91        ALSO PBAR,NBAR-PROTON
C                         FINAL STATE PARTICLES IN /FINUC/
      IF( (ANUC.LT.1.5D0) .AND. (IT.LE.2 .OR. IT.EQ.8 .OR. IT.EQ.9)
     &    .AND. (EKIN.LT.3.5D0) ) THEN
         CALL NUPREL(IT,EKIN,PLAB,CX,CY,CZ)
         WEI(1)=WEE
         WEI(2)=WEE
C
         RETURN
      ENDIF
C-------------------------------------------------------------------
C
C********************************************************************
C     1=P,N, 2=AP,AN, 3=PI+, 4=PI-, 5=K+,K0, 6=K-,K0 BAR
C********************************************************************
C
      IIT=ITT(IT)
      IF(IIT.EQ.0)RETURN
      AP=PLAB
      AP2=AP**2
      A=ANUC
      IF(IIT.GE.2) GO TO 101
      IF(AP.GT.20.D0) GO TO 101
C
C********************************************************************
C     FOR PROTONS BELOW 20 GEV/C
C     DSIGMA/DOMEGA=12.5*A**1.63*EXP(-14.5*A**0.66*T)+
C                   17.5*A**0.33*EXP(-10*T)    FOR A<62
C
C     DSIGMA/DOMEGA=50*A**1.33*EXP(-60*A**0.33*T)+
C     20*A**0.4*EXP(-10*T)  FOR A>62
C********************************************************************
C
      A3=A**0.3333333333333333D0
      ATAR=A
      IF (ATAR .GT. 62.D0) GO TO 1
      C=12.5D0*A**1.63D0
      DS=14.5D0*A3*A3*AP2
      E=17.5D0*A3
      GO TO 2
  1   CONTINUE
      C=50.D0*A3*A
      DS=60.D0*A3*AP2
      E=20.D0*A**0.4D0
  2   CONTINUE
      FS=10.D0*AP2
      GO TO 3
C
C********************************************************************
C     FOR PROTONS OVER 20 GEV/C AND OTHER PARTICLES
C********************************************************************
C
  101 CONTINUE
      DO 200 I=1,6
      IF(A.LE.AM(I)) GO TO 201
  200 CONTINUE
      K=6
      GO TO 202
  201 K=I
  202 KK=K+1
      IF(KK.GT.6) KK=K-1
      XNEL=XNN(IIT,K)+(A-AM(K))*(XNN(IIT,KK)-XNN(IIT,K))/(AM(KK)-AM(K))
      C=XNEL**2
      DS=LOG(BA(IIT,KK)/BA(IIT,K))/LOG(AM(KK)/AM(K))
      DS=BA(IIT,K)*(A/AM(K))**DS
      DS=DS*AP2
      E=XNA(K)+(A-AM(K))*(XNA(KK)-XNA(K))/(AM(KK)-AM(K))
      E=E*SHP(IIT)**2
      FS=BP(IIT)*AP2
      GO TO 3
C
C********************************************************************
C     FOR HEAVY IONS:
C
C       FOR APROJ>25 OR (APROJ>10 AND ATARG>100)
C DSIG/DOM = 216 * PTOT**1.86 * (AP**0.7 + AT**0.7)**2.2 *
C          EXP(-16.1 * (AP**1.2 + AT**0.9)**0.8 * T) +
C          0.3 * PTOT**1.86 * (AP**0.7 + AT**0.7)**2.2 * EXP(-23 * T)
C
C       FOR LIGHTER NUCLIDES:
C DSIG/DOM = 78 * PTOT**1.78 * (AP + AT**0.9)**2.1 *
C          EXP(-16.1 * (AP**1.2 + AT**0.9)**0.8 * T) +
C          0.5 * PTOT**1.78 * (AP + AT**0.9)**2.1 * EXP(-30 * T)
C
C       THE PARAMETRIZATION IS OBTAINED BY FITTING TO
C       DATA GENERATED BY THE SOFT-SPHERES MODEL.
C       (REF. CHAUVIN & AL. PHYS.REV.C. 28 1970 (1983))
C       THE PARAMETRIZATION IS QUITE CRUDE AND FAILS AT LARGE
C       ANGLES.
C       THERE IS NO EXPERIMENTAL VERIFICATION FOR THE MODEL AT
C       ENERGIES ABOVE 100 MEV/A
C                                   MIKA HUHTINEN 25.8.88
C********************************************************************
C
  301 CONTINUE
      ITARA=NINT(ANUC)
C     ALWAYS LET THE LIGHTER PARTICLE BE THE PROJECTILE (THEN THE
C     PARAMETRIZATION WILL GIVE BETTER RESULTS)
      IF (ITARA.GE.IPROA) THEN
        PROA=IPROA
        TARA=ITARA
      ELSE
        PROA=ITARA
        TARA=IPROA
      ENDIF
C     TOTAL LAB. MOMENTUM
      PLTOT=PLAB*PROA
C     SQUARE OF CMS MOMENTUM
      AP2=((PLTOT*TARA)/(TARA+PROA))**2

      DS=16.1D0*(PROA**1.2D0 + TARA**0.9D0)**0.8D0*AP2

      IF (PROA.GT.25.D0) GO TO 302
      IF ((PROA.GT.10.D0).AND.(TARA.GT.100.D0)) GO TO 302

      CFF=PLTOT**1.78D0*(PROA + TARA**0.9D0)**2.1D0
      C=78.D0*CFF
      E=0.5D0*CFF
      FS=30.D0*AP2
      GO TO 3

  302 CONTINUE
      CFF=PLTOT**1.86D0*(PROA**0.7D0 + TARA**0.7D0)**2.2D0
      C=216.D0*CFF
      E=0.3D0*CFF
      FS=23.D0*AP2
C
C********************************************************************
C     SAMPLE THE ANGLE AND ROTATE TO GET NEW DIRECTION COSINES
C********************************************************************
C
    3 CONTINUE
      EDS=1.D-9
      IF(DS.LT.10.5D0) EDS=EXP(-2.D0*DS)
      EDS2=EDS**2
      DD=C*(1.D0-EDS2)/DS
      EFS=1.D-9
      IF(FS.LT.10.5D0) EFS=EXP(-2.D0*FS)
      EFS2=EFS**2
      FF=E*(1.D0-EFS2)/FS
      DF=2.D0*DS
      CALL GRNDM(RNDM,1)
      VV=RNDM(1)*(DD+FF)
      IF (VV.GT.DD) DF=2.D0*FS
  31  CONTINUE
      CALL GRNDM(RNDM,1)
      V2=LOG(RNDM(1))/DF
      IF (ABS(V2).GT.2.D0) GO TO 31
      V1=V2
      COD=V1+1.D0
      SID=SQRT(-V1*(2.D0+V1))
*  ******* Computing the recoil energy!!!! A. Ferrari, 26-9-89 ******* *
      KP    = IPTOKP (IT)
      APP2  = AAM(KP)**2
      EPROJ = EKIN + AAM(KP)
*  +-------------------------------------------------------------------*
*  |  Hydrogen: generate the recoil proton
      IF ( ANUC .LT. 1.2D+00 ) THEN
         ATT  = AAM (1)
         ATT2 = ATT**2
         ETTT = EPROJ + ATT
         PTTL = PLAB
         PTTT = 0.D+00
         HELP = ATT2 - APP2 * ( 1.D+00 - COD ) * ( 1.D+00 + COD )
*  | Now: it can happen for amproj > amprot on hydrogen.
         IF ( HELP .LT. 0.D+00 ) GO TO 3
         PLAB = PLAB * ( ( APP2  + ATT*EPROJ ) * COD + (EPROJ + ATT)
     &        * SQRT (HELP) ) / ( (EPROJ + ATT)**2 - (PLAB*COD)**2 )
         NP = 2
         TV = 0.D+00
         WEI   (1) = WEE
         WEI   (2) = WEE
         KPART (1) = IT
         KPART (2) = 1
         TKI   (1) = SQRT ( PLAB**2 + APP2 ) - AAM (KP)
         TKI   (2) = EKIN - TKI (1)
         EKIN      = TKI (1)
         PLR   (1) = PLAB
         PLR   (2) = SQRT ( TKI (2) * ( TKI (2) + 2.D+00 * AAM (1) ) )
         CALL SFECFE ( SFE, CFE )
         CALL TTRANS ( CX, CY, CZ, COD, SID, SFE, CFE, CCX, CCY, CCZ )
         CXR (1) = CCX
         CYR (1) = CCY
         CZR (1) = CCZ
         SINTHE  = PLAB / PLR (2) * SID
         COSTHE  = SQRT ( ( 1.D+00 - SINTHE ) * ( 1.D+00 + SINTHE ) )
         CFE     = - CFE
         SFE     = - SFE
         CALL TTRANS ( CX, CY, CZ, COSTHE, SINTHE, SFE, CFE, CXR (2),
     &                 CYR (2), CZR (2) )
         RETURN
*  |
*  +-------------------------------------------------------------------*
*  |  "Heavy" nuclei
*  |  the following line to patch el. scatt. of an, ap, lambdas, sigmas
*  |  etc on hydrogen ( Now it should be useless )
      ELSE
         ATT  = MAX ( ANUC * AMUC12, AAM (KP) )
         ATT2 = ATT**2
         HELP  = ATT2 - APP2 * ( 1.D+00 - COD ) * ( 1.D+00 + COD )
         PLAB  = PLAB*( (APP2  + ATT*EPROJ)*COD + (EPROJ + ATT)
     &         * SQRT (HELP) ) / ( (EPROJ + ATT)**2 - (PLAB*COD)**2 )
         TV = EPROJ - SQRT ( PLAB**2 + APP2 )
         EKIN = EKIN - TV
*  | ***** The following lines only for debugging *****
         IF ( PLAB .LE. 0.D+00 ) THEN
            WRITE (LUNOUT,*)' *** Nucrel: plab',PLAB,' ***'
            WRITE (LUNERR,*)' *** Nucrel: plab',PLAB,' ***'
         END IF
*  | ***** End debugging lines *****
      END IF
*  |              Now the recoil energy is put into Tv
*  +-------------------------------------------------------------------*
      CALL SFECFE(SFE,CFE)
      CALL TTRANS(CX,CY,CZ,COD,SID,SFE,CFE,CCX,CCY,CCZ)
C---------------------------------------------------------
C   MODIFICATION HJM 28/10/88
C   NOTE:  HEAVY ION OPTION  NOT CONSISTENTLY TREATED NOW]]]
C
      WEI(1)=WEE
      CXR(1)=CCX
      CYR(1)=CCY
      CZR(1)=CCZ
      TKI(1)=EKIN
      PLR(1)=PLAB
      KPART(1)=IT
      RETURN
      END
+DECK,  NUCRIV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:57  cernlib
* Geant

*$ CREATE NUCRIV.FOR
*COPY NUCRIV
*=== nucriv ===========================================================*
      SUBROUTINE NUCRIV (ITTTT,ELAB,CX,CY,CZ,BBTAR,ZZTAR,RHOO)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*  Last change  on  16-sep-92    by    Alfredo Ferrari, Infn - Milan   *
*                                                                      *
*  Nucrin90 by A. Ferrari: tentative version to overcome many troubles *
*                          in energy, momentum and charges conservation*
*                                                                      *
*----------------------------------------------------------------------*
*
C
C--------------------------------------------------
C*** FINUC: NUCRIN FINAL STATE PARTICLE LIST WITH KINEM. VARIABLES
C*** FINLSP HADRIN FINAL STATE PARTICLE LIST WITH KINEM. VARIABLES
C*** (NUMBER OF PARTICLES,PARTICLE TYPE INDEX,DIRECTION COSINES,ENERGY
C*** ABSOLUTE MOMENTUM AND IN FINUC IN ADDIT. EXCITATION ENERGY
C--------------------------------------------------
+CDE, BALANC.
+CDE, CORINC.
+CDE, FINUC2.
+CDE, FINLSP2.
+CDE, NUCDAT.
+CDE, RESNUC.
*     PARAMETER ( TVEPSI = 1.D-05 )
      COMMON / FKNUCF / DELEFT, EKRECL, V0EXTR, ITTA, ITJ, LVMASS
      DIMENSION EXSOP (2)
      REAL RNDM(1),RANGS1,RANGS2
      COMMON /FKFERM/ELABKE,A,TPNVK,ELATE,IFERT
C
C--------------------------------------------------
C***
C***
C***  SAMPLING OF A HADRON-NUCLEUS COLLISION EVENT
C***
C   ITTTT - TYPE OF INCOMING HADRON
C
C--------------------------------------------------
C***  POSSIBLE: N, AN,PI,K,AK,Y,AY BY THE INDEX ITTTT=IT=1,2,8-25
C   PLAB - MOMENTUM OF INCOMING HADRON
C
C***  RANGE UP TO 5. GEV/C (FROM ABOUT 0. ... 0.1 GEV/C)
C   ELAB - TOTAL ENERGY OF INCOMING HADRON IN GEV
C   CX,CY,CZ - DIRECTION COSINES
C***  ANUC,ZNUC = NUMBERS OF NUCLEONS AND PROTONS
C*** RHOO = MATERIAL DENSITY (G/CM**3)
C
C*** FINAL STATE PARTICLE CHARACTERISTICS TABLE IN /FINUC/:
C*** IRN   - NUMBER OF FINAL STATE PARTICLES
C*** ITRN(I) - FINAL STATE PARTICLE TYPE INDEX
C*** CXRN,CYRN,CZRN (I) - DIRECTION COSINES OF F.S.P. (LAB SYST.)
C*** ELR,PLR (I) - LAB.ENERGY AND MOMENTUM OF F.S.P. (GEV, GEV/C)
C*** TV    - EXCITATION ENERGY (GEV)
C
C--------------------------------------------------
      DIMENSION THRESR(30)
      SAVE THRESR,ITPRF,IAMC,JAMC,INS,IXPI,JNUC
      DATA THRESR/1.9D0, 0.D0, 5*9.D0, 1.9D0, 0.D0, 3*9.D0, 1.08D0,
     * 1.08D0, 1.44D0, 1.08D0, 6*9.D0, 1.08D0,
     * 1.44D0, 1.08D0, 5*9.D0/
      DIMENSION IXPI (30)
*
*----------------------------------------------------------------------*
*                                                                      *
*     Ixpi :                                                           *
*             = -1 for antinucleons ( pbar, nbar, and for Lambdabar,   *
*                  see below )                                         *
*             =  0 for pi-, K- ( stopping particles )                  *
*             =  1 for other mesons and particles (p, n, pi+, pi0, K+, *
*                  K0, K0bar )                                         *
*             =  2 for leptons (e-, e+, nu, nubar, mu+, mu-, photons,  *
*                  Klong, Kshort )                                     *
*             =  4 for hyperons ( Lambda, Lambdabar, Sigma-, Sigma+,   *
*                  Sigma0 ). Actually for Lambdabar the inxpi flag in  *
*                  the code, which corresponds to the ixpi one of the  *
*                  projectile, is then set to - 1 as for antinucleons  *
*                                                                      *
*----------------------------------------------------------------------*
*
      DATA IXPI/1,-1,5*2,1,-1,3*2,1,0,1,0,4,4,2,3*4,1,1,1,5*2/
      COMMON /FKPERC/ IPERCO
      COMMON /FKENCO/ ETEST,TNKTE
C
C--------------------------------------------------
C***  PARTICLE CHARACTERISTICS: MASSES, DECAY WIDTH, LIFE TIME,ELECT.AND
C***  BARYONIC CHARGE, DECAY CHANNEL INDICEES
C--------------------------------------------------
*
*  /Abltis/ common is initialized in Hadden. Masses are the same as in
*  /Part/ common at least up to particle n. 94, the same for the baryonic
*  charge and the electric charge : what about particle 26????????????
*
      COMMON / FKABLT / AM (110), GA (110), TAU (110), ICH (110),
     &                  IBAR (110), K1(110), K2(110)
      COMMON / FKNUCT / ETHR, PTHR
      DIMENSION INS(30)
      DIMENSION AMHH(15),IAMC(15),JAMC(30)
      DATA IAMC/1,2,8,9,12,15,16,17,18,19,20,21,22,24,25/
      DATA JAMC/2*1,5*0,2*1,2*0,1,2*0,16*0/
      DATA INS/13,13,5*32,14,14,3*32,10,10
     *,12,11,7*32,15,15,5*32/
      DATA JNUC/0/
      DIMENSION ITPRF(110)
      DATA ITPRF/-1,-1,5*1,-1,-1,1,1,1,-1,-1,-1,-1,6*1,-1,-1,-1,85*1/
      LOGICAL LEMINU, LPRONU, LPCASC, LNCASC, LCORIN, LDELTX, LVMASS,
     &        LHYPER
*
      LCORIN = .FALSE.
      LVMASS = .FALSE.
      ANUC = BBTAR
      ZNUC = ZZTAR
      TPNVK  = 0.D+00
      IRNTOT = 0
      INNUC=1
      ITNUCR=ITTTT
      SICO   = 1.D0
      ELPH   = 0.D0
      PLABCO = 1.D0
C
C--------------------------------------------------
C*** SICO,PLABCO - EFFECTIVE CROSS SECTION- AND EFFECT. LABMOMENTUM
C***      CORRECTION FACTORS FOR Y-A- AND AY-A-COLLISIONS
C*** ITNUCR - HYPERON NUCLEUS COLL. PARTICLE TYPE FOR USE IN NIZL,
C***      IT - USED IN HADRIN
C--------------------------------------------------
      IBAT = 0
C--------------------------------------------------
C*** INXPI:
C*** ORDERING INDICEES FOR STOPPING PARTICLES (0), OTHER MESONS (1),
C*** ANTINUCLEONS (-1), HYPERONS (4),LEPTONS,KO,AKO(2),OTHER PART. (1)
C
C--------------------------------------------------
C*** INCLUSION OF HYPERON-NUCLEUS-COLLISIONS
C*** PRELIMINARY FOR SIGMA+ NO STRANGENES-CONSERVATION
C
C--------------------------------------------------
*
*  From here it is the number of the incoming nucleon
*
      IT = ITTTT
*
*  Nxpi = 0 means hadrin call is possible
*
      NXPI  = 0
      INXPI = IXPI(IT)
      IF ( IT .EQ. 23 .AND. ELAB - AM(IT) .LE. 0.05D+00 ) INXPI = 0
*  +-------------------------------------------------------------------*
*  |
      IF ( INXPI .EQ. 4 ) THEN
         CALL HYPERO ( IT, ITNUCR, SICO, PLABCO )
         LHYPER = .TRUE.
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         LHYPER = .FALSE.
      END IF
*  |
*  +-------------------------------------------------------------------*
C
C--------------------------------------------------
C*** CUT OFF ENERGY CONSTANTS:
C--------------------------------------------------
      ETHR  = 0.001D+00
C
C--------------------------------------------------
C*** CDDT,CEET PARAMETERS FOR GAUSSIAN WIDTH'
C--------------------------------------------------
      N = ITTTT
*
*  Particle 18 is Alambda
*
      IF ( ITTTT .EQ. 18 ) INXPI = -1
C
C--------------------------------------------------
C*** ETEST = ENERGY CONSERVATION TEST VARIABLE (SHOULD BE 0 AT RETURN)
C*** TLAB = KINETIC ENERGY
C--------------------------------------------------
      JJ    = JNUC
      CDDT  = 0.5D0
      IHACA = 0
      IN    = INS(N)
C
C--------------------------------------------------
C*** JJ=1:
C*** OPTION 1: GO TO NIZL, CROSS SECTION CALCULATION
C*** JJ=2:
C*** OPTION 2: EVENT SAMPLING
C--------------------------------------------------
      TLAB  = ELAB - AM (IT)
*  +-------------------------------------------------------------------*
*  |  Decide which is the target nucleon ( flag Itta ) : a proton .....
      CALL GRNDM(RNDM,1)
      IF ( RNDM (1) .LT. ZNUC / ANUC ) THEN
         ITTA = 1
         ITJ  = 1
*  |
*  +-------------------------------------------------------------------*
*  |                                            .... or a neutron
      ELSE
         ITTA = 8
         ITJ  = 2
      END IF
*  |
*  +-------------------------------------------------------------------*
      V0OLD = V0WELL (ITJ)
      PLAB = SQRT ( TLAB * ( ELAB + AM (IT) ) )
*  +-------------------------------------------------------------------*
*  |
      IF ( ABS ( PLAB - 5.D0 ) .GE. 4.99999D0 ) THEN
         WRITE(LUNOUT,99996) PLAB
         WRITE(LUNERR,99996) PLAB
*        STOP         Commented out A. Fasso' 1989
         IRN = NP0
         RETURN
99996    FORMAT (3(5H ****/),' Nucrin: projectile momentum',
     &          ' outside of the allowed region, plab, kproj:',
     *   1P,E15.5,3X,0P,I3,/,3(5H ****/))
      END IF
*  |
*  +-------------------------------------------------------------------*
*     IF ( JJ .EQ. 1 ) GO TO 1000
*-->-->-->-->--> go to cross section calculation if this option was se-
*                lected
C
C--------------------------------------------------
C*** IF LOW KINETIC ENERGY ( TLAB < ETHR ): ONLY EXCITATION
C*** STOPPING PARTICLES
C*** AND ANNIHILATION , INXPI=IXPI(IT) LE 0
C--------------------------------------------------
*  +-------------------------------------------------------------------*
*  |  Inxpi > 0: p, n, pi+, K+, Lambda, Sigma+, Sigma-, Sigma0
*  |  ( no lepton or pi0 projectile of course, now also pi0
*  |    are possible projectiles )
      IF (INXPI .GT. 0) THEN
C
C--------------------------------------------------
C*** ETHRR=THRESHOLD VALUE, FOR TLAB<ETHRR IS NO H-N COLLISION POSSIBLE,
C*** ONLY EXCITATION + CASCADE AND/OR ANNIHILATION CORRESP TO THE HADRN
*  |  +----------------------------------------------------------------*
*  |  |  Raised to 10 MeV: A. Ferrari, 11-apr-1991
         IF (TLAB .LE. 10.D+00 * ETHR) THEN
*  |  |   Here particles not stopping and not to be annihilated below
*  |  |   threshold
            ANOW  = ANOW  + IBAR (IT)
            KTARN = KTARN - IBAR (IT) + ICH (IT)
            ZNOW  = ZNOW  + ICH  (IT)
            KTARP = KTARP - ICH  (IT)
            AMNRES = AMUAMU * ANOW + 1.D-03 * FKENER ( ANOW, ZNOW ) -
     &               ZNOW * AMELEC + ELBNDE ( NINT (ZNOW) )
            TV  = ETTOT - AMNRES
            IRN = NP0
            RETURN
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
*  |    Here for ap, an, pi-, k-, alambda
      ELSE
*  |  +----------------------------------------------------------------*
*  |  |  Threshold is raised for particles with ixpi < 0 (ap, an,
*  |  |  alambda) to 80 MeV
         IF (INXPI .LT. 0) THEN
            ETHRR = 0.08D+00
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |  for pi-, K- the threshold is Ethr = 1 MeV
         ELSE
            ETHRR = ETHR
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
C
C--------------------------------------------------
C*** UP TO ETHRR=.08 GEV NO AN, AP IN FINAL STATE
C--------------------------------------------------
         AIO  = 10.D0
         XPI  = 1.D0 - AIO * ( TLAB - ETHRR )
*  |  Patch for pseudo pi0
         IF ( IT .EQ. 23 ) XPI = 1.D+00
*  |  For pi- and K- :
*  |                   Xpi < 0 for Tlab > 1/Aio + Ethrr = 101 MeV
*  |                   Xpi > 1 for Tlab < Ethrr = 1 MeV
*  |  For antibaryons:
*  |                   Xpi < 0 for Tlab > 1/Aio + Ethrr = 180 MeV
*  |                   Xpi > 1 for Tlab < Ethrr = 80 MeV
*  |  +----------------------------------------------------------------*
*  |  |   Nxpi=0 means hadrin-call is possible, else impossible
*  |  |   So Hadrin call is always possible for pi- and K- if
*  |  |   Tlab > 101 MeV, and for antibaryons if Tlab > 180 MeV.
*  |  |   Hadrin call is always impossible for pi- and K- if
*  |  |   Tlab < 1 MeV (never possible) and for antibaryons if
*  |  |   Tlab < 80 MeV. Actually Nxpi > 1 for antibaryons means forced
*  |  |   annihilation, but Hadrin can be called the same, even though
*  |  |   only final states with annihilation will be accepted
         CALL GRNDM(RNDM,1)
         IF ( RNDM(1) .GT. XPI ) THEN
            NXPI = 0
*  |  |                       particle non stopping (annihilating)
*  |  +----------------------------------------------------------------*
*  |  |                       particle stopping (annihilating)
         ELSE
            NXPI = 1
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |    Incident pi- or K- stopping in the nucleus, no possibility
*  |    to call hadrin: it must be updated using the new stopping
*  |    particle module as soon as it will be available!!
      IF ( NXPI .GT. 0 .AND. IBAR (IT) .EQ. 0 ) THEN
*  |  Give the total lab energy of stopping pi-, K- into cascade and
*  |  exit: label 405 is where this is performed.
*  |  Before change a proton into a neutron to account for charge
*  |  conservation and adjust the total energy with the mass
*  |  difference (Note that for K- no strangeness conservation occurs
         IF ( IT .NE. 23 ) THEN
            ZNOW  = ZNOW - 1.D+00
            KTARP = KTARP + 1
            KTARN = KTARN - 1
         END IF
         TPK  = 0.D0
         TNK  = 0.D0
         TV   = 0.D0
         TOEFF = ELAB
         LCORIN = .TRUE.
         CALL CORSTP ( TOEFF )
         CALL GRANOR(RANGS1, RANGS2)
         TNKTE = MAX ( 0.003D+00, EKMNNU (2)
     &         * ( 0.5D+00 - 0.25D+00 * RANGS1 ) )
         TPKTE = MAX ( 0.003D+00, EKMNNU (1)
     &         * ( 0.5D+00 - 0.25D+00 * RANGS2 ) )
         GO TO 405
*  |
*  +-->-->-->-->--> go to the cascade simulation
      END IF
*  |
*  +----------------------------------------------------------------*
C
C--------------------------------------------------
C*** ELABKE = INVARIANT KINETIC ENERGY OF THE H-A-SYSTEM+PROJ.H.MASS
C*** A = TOTAL ENERGY OF THE PRIMARY PARTICLE IN LABSYSTEM
C*** IFORBI,IFERT LOOP COUNTING INDICEES FOR CHOICE OF FERMION MOMENTUM
C*** AMNTAR - NUCLEUS MASS
C*** UMOJAN - H-A-C.M.S.-ENERGY
C*** ELABKE - KINETIC H-A-ENERGY IN C.M.S
C--------------------------------------------------
*
      UMOJAN = SQRT ( AM(IT)**2 + AMNTAR**2 + 2.D+00 * ELAB * AMNTAR )
C
C--------------------------------------------------
C***  START WITH THE EVENT SIMULATION
C--------------------------------------------------
      ELABKE = UMOJAN - AMNTAR
      A = ELAB
      IFORBI = 0
      IFERT  = 0
*  Call Ferset for setting up anything for the Fermi motion
      CALL FERSET
      AMMIT = AM (IT)
      AMMTA = AM (ITTA)
      AIT2  = AMMIT**2
      ATA2  = AMMTA**2
*  Ecmo is the square of the invariant mass of the projectile-nucleon
*  system
*     ECMO = AIT2 + ATA2 + 2.D+00 * AMMTA * ELAB
*  Put here the correct value for Ecmo taking into account
*  Fermi motion etc.
*  Compute Ekrecl in the most favourable situation, with final
*  excitation energy zero (tvepsi) and all the energy given to the
*  projectile
*  Dex = - Tveuz, Ekres = sqrt(amnres**2 + pfrmi**2) - amnres,
*  Ekrecl = Ekres + Dex
*  **** Now the checks are done using atomic masses directly **** *
      EKREC0 = EKRECL
      TVEUZ0 = TVEUZ
      PFRMSQ = PXFRM**2 + PYFRM**2 + PZFRM**2
      EKRES  = SQRT ( ( AMMRES + 2.D+00 * TVEPSI )**2 + PFRMSQ ) -
     &         AMMRES - 2.D+00 * TVEPSI
*  -TVEUZ to reduce the excitation energy not the recoil one
* (it would have been more exact to set
*  Efrm = Efrm + Tveuz, but it is better to conserve Efrm
*  coherent with the original value)
      EKRECL = EKRES - TVEUZ + 2.D+00 * TVEPSI
      EZERO  = EFRM - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
      ECHCK  = ELAB + EZERO
      PLABSQ = PLAB * PLAB
      PFRSCA = PXFRM * CX + PYFRM * CY + PZFRM * CZ
      ECMO   = ECHCK**2 - PLABSQ - PFRMSQ - 2.D+00 * PLAB * PFRSCA
      UMIN2  = ( AMMIT + AMMTA )**2
*  +----------------------------------------------------------------*
*  |   Check if the Hadrin call is energetically possible, else
*  |   give the total energy to cascade and excitation:
      IF ( ECMO .LT. UMIN2 .AND. NXPI .LE. 0 ) THEN
         V0WELL (ITJ) = V0WELL (ITJ) - V0EXTR
         ANOW  = ANOW  + IBAR (IT)
         KTARN = KTARN - IBAR (IT) + ICH (IT)
         ZNOW  = ZNOW  + ICH  (IT)
         KTARP = KTARP - ICH  (IT)
         TPK  = 0.D+00
         TNK  = 0.D+00
         TV   = 0.D+00
         TPNVK  = 0.D+00
         TOEFF  = ELAB - IBAR (IT) * AMMIT
         LCORIN = .TRUE.
         CALL CORSTP ( TOEFF )
         CALL GRANOR(RANGS1, RANGS2)
         TNKTE = MAX ( 0.003D+00, EKMNNU (2)
     &         * ( 0.5D+00 - 0.25D+00 * RANGS1 ) )
         TPKTE = MAX ( 0.003D+00, EKMNNU (1)
     &         * ( 0.5D+00 - 0.25D+00 * RANGS2 ) )
         GO TO 405
*  |
*  |-->-->-->-->--> go to the cascade simulation
      END IF
*  |
*  +-------------------------------------------------------------------*
      EKRECL = EKREC0
*  ******  The check for peripheral collisions is now moved here: *****
*   The old comment was:
*   " I.E.,H-COLLISION WITH N IN THE MOST OUTSIDE NUCLEUS SHELL
*     WITH THE THICKNESS OF ONE NUCLEON RADIUS
*     RATIO OF THE SHELL VOLUME TO NUCLEUS VOLUME IS ELANU3
*     THE H-N-COLL. WILL BE SAMPLED FIRSTLY WITH THE TOTAL PRIMARY
*     ENERGY ELAB, THE REMAINING ENERGY IS USED IN THE ABOVE SAMPLED
*     RATIO FOR CASCADE AND EXCITATION SWITCH VARIABLE IS IPERCO=1 "
*   The old coding was: ....
*     ELRAN  = RNDM (V)
*     ELANU3 = ANUC**(-0.6666666666666667D+00)
*     IF ( ELRAN .LE. ELANU3 .AND. ABS (ELPP-T3) .GT. 0.0001D0)
*    ..... but
*    in my opinion we must perform peripheral collisions checking
*    the ratio between the total area (r**2) and the circular
*    corona corresponding to 1 nucleon radius, so checking:
*    (now to switch off peripheral collisions we need Elanu3 = 1)
*    Furthermore no cascade and excitation energy is computed since
*    it is extremely likely that the remaining energy (not more than
*    Tveuz) will go thouroly in excitation one: anyway it is divided
*    among the 3 contributions in the usual way
*     ELRAN  = RNDM (V)
*     ELANU3 = ( ( ANUC - 1.D+00 ) / ANUC )**0.6666666666666667D+00
*    We changed again to the original idea, which can be geometrically
*    explained as a corona of dr = r0 , corresponding roughly to
*    1 nucleon. Anyway we need a much more detailed insight of this
*    problem with possibly checks with experimental data
      CALL GRNDM(RNDM,1)
      ELRAN  = RNDM (1)
      ELANU3 = 1.D+00 - 1.D+00 / ANUC**0.6666666666666667D+00
*  +-------------------------------------------------------------------*
*  |  Check for peripheral collisions: note that in this way peripheral
*  |  collisions are switched off for stopping antibaryons!!
      IF ( ELRAN .GE. ELANU3 .AND. NXPI .EQ. 0 ) THEN
         IPERCO = 1
         TOEFF  = ELAB - AMMIT
         LCORIN = .TRUE.
         CALL CORSTP ( TOEFF )
         CALL GRANOR(RANGS1, RANGS2)
         TNKTE = MAX ( 0.003D+00, EKMNNU (2)
     &         * ( 0.5D+00 - 0.25D+00 * RANGS1 ) )
         TPKTE = MAX ( 0.003D+00, EKMNNU (1)
     &         * ( 0.5D+00 - 0.25D+00 * RANGS2 ) )
         EKRECL = EKREC0
         ELPP   = ELAB
         PLPP   = PLAB
         DEX    = 0.D+00
         PSPESQ = PLABSQ + PFRMSQ + 2.D+00 * PLAB * PFRSCA
         IUMO   = 0
*  |  +----------------------------------------------------------------*
*  |  |
1500     CONTINUE
            IUMO   = IUMO   + 1
            EEX    = TVEUZ  + DEX
*  |  |  Now for iperco we are working with atomic masses
*           AMSTAR = AMNRES + EEX
            AMSTAR = AMMRES + EEX
            EKRES  = SQRT ( AMSTAR**2 + PFRMSQ ) - AMSTAR
*  |  |   Note +DEX to reduce actually the excitation energy, not
*  |  |   the recoil one (it would have been more exact to set
*  |  |   Efrm = Efrm - Dex, but it is better to conserve Efrm
*  |  |   coherent with the original value)
            EKRECL = EKRES + DEX
            EZERO  = EFRM  - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
            ESPENT = ELPP  + EZERO
*           ELEFT  = ETTOT - ESPENT
            ELEFT  = ETTOT - ESPENT + DELEFT
            UMO2   = ESPENT**2 - PSPESQ
            DELTU2 = UMIN2 - UMO2
*  |  |  +-------------------------------------------------------------*
*  |  |  |  We need more invariant mass for the collision!!!
            IF ( DELTU2 .GT. 0.D+00 ) THEN
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( IUMO .GT. 3 ) THEN
                  V0WELL (ITJ) = V0WELL (ITJ) - V0EXTR
                  ANOW  = ANOW  + IBAR (IT)
                  KTARN = KTARN - IBAR (IT) + ICH (IT)
                  ZNOW  = ZNOW  + ICH  (IT)
                  KTARP = KTARP - ICH  (IT)
                  GO TO 405
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               DELTEX = 0.5D+00 * DELTU2 * ELEFT / ( ESPENT * AMSTAR )
               DELTEX = MIN ( DELTEX, EEX )
               DEX    = DEX - DELTEX
            GO TO 1500
*  |  |  |
*  |  +-<|--<--<--<--<--< go to compute the new invariant mass!!
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               TVEUZ = EEX
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  we are ready for the interaction !!!!!
         IHACA = 0
*  |  +----------------------------------------------------------------*
*  |  |
1600     CONTINUE
            ITFRHD = IT
            IHACA  = IHACA + 1
            IF ( PLPP .LT. 1.D-04 ) THEN
               WRITE (LUNERR,*)
     &              ' Nucriv: iperco=1,plpp,elpp,it',
     &                PLPP,ELPP,IT
               WRITE (LUNERR,*)'      IHACA,LVMASS,ELAB,PLAB',
     &                                IHACA,LVMASS,ELAB,PLAB
            END IF
            CALL FERHAV ( IT, ELPP, PLPP, CX, CY, CZ )
*  |  |  +-------------------------------------------------------------*
*  |  |  | Check if we have reached the maximum numbers of calls
            IF ( IHACA .GT. 15 ) THEN
               GO TO 1700
*  |  |  |-->-->-->-->--> give up !!!
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  | Ir is the number of secondaries produced in the
*  |  | Ferhad/Hadrin call
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( IR .EQ. 0 ) THEN
               V0WELL (ITJ) = V0WELL (ITJ) + V0EXTR
               GO TO 1600
*  |  |  |
*  |  +-<|-<--<--<--<--< go to resampling the interaction
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  | Of course ir=1 means that the only outgoing particle is
*  |  | still the projectile !! If we have an incoming antibaryon
*  |  | we need at least 2 particles in the final state (why???)
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( IR .LT. 2 .AND. INXPI .LT. 0 ) THEN
               V0WELL (ITJ) = V0WELL (ITJ) + V0EXTR
               GO TO 1600
*  |  |  |
*  |  +-<|-<--<--<--<--< go to resampling the interaction
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
1700     CONTINUE
         TVEUZ = TVEUZ + EKRECL
         TV  = TVEUZ
         TPK = 0.D+00
         TNK = 0.D+00
         GO TO 2800
*  |  |                           End loop for Ferhad/hadrin call
*  |  +----------------------------------------------------------------*
*  |    Yes peripheral collison
*  +-------------------------------------------------------------------*
*  |    No peripheral collision
      ELSE
         IPERCO = -1
      END IF
*  |
*  +-------------------------------------------------------------------*
      I1651 = 0
*  +-------------------------------------------------------------------*
*  |  It is possible to come here for resampling !!!!
1651  CONTINUE
         TVEUZ = TVEUZ0
         IRN = NP0
         DDT = CDDT * TLAB
         EMD = 0.D+00
C
C--------------------------------------------------
C*** EFFECTIVE COLLISION ENERGY CALCULATION FOR USE IN CASCADE
C*** AND EXCITATION ENERGY CALCULATION FOR ANNIHILATION
C--------------------------------------------------
C
C--------------------------------------------------
C*** I653 LOOP COUNTER INTEGER FOR BAD ENERGY CORRECTION IN ANNIHILATION
C--------------------------------------------------
         I653 = 0
*  |  +----------------------------------------------------------------*
*  |  |  It is possible to come here for resampling !!!!
 653     CONTINUE
C
C--------------------------------------------------
C*** TOEFF = EFFECTIVE KINETIC COLLISION ENERGY
C--------------------------------------------------
            I653 = I653 + 1
            TOEFF= TLAB
C
C--------------------------------------------------
C*** TOEFF ONLY FOR ANNIHILATION NE TLAB POSSIBLE, ELSE JUST SELECTION
C*** OF ENERGY FRACTIONS
C--------------------------------------------------
*  |  |  +-------------------------------------------------------------*
*  |  |  |   If we are here with a pi- or a K- this means Nxpi = 0,
*  |  |  |   ==> no stopping (annihilating) particle but Hadrin call
*  |  |  |   for pi-, K-, while for ap, an, alambdas may be that Nxpi=1
*  |  |  |   ==> no Hadrin call (more exactly, Hadrin can be called but
*  |  |  |   the particle is stopping ( annihilating ) )
            IF ( INXPI .LE. 0 ) THEN
*  |  |  |   Note, Ibar (itta) = 1 of course, Ibar (it) maybe 0 or -1
*  |  |  |   so Ibl = 0 for pi-, K- and Ibl = 1 for ap, an, alambdas
               IBL = IBAR (ITTA) * IBAR (IT)
               IBL = ABS  (IBL)
*  |  |  |   Icl = -1 for pi-, K-, ap, Icl = 0 for an and alambdas
               ICL = ICH (IT)
*  |  |  |   ( Ibar (itta) - Ibar (it) ) * Ibl = 2 for ap, an, alambdas
*  |  |  |   ( Ibar (itta) - Ibar (it) ) * Ibl = 0 for pi-, K-
*  |  |  |   ( 1 - Ibl ) * |Icl| = 0 for ap, an, alambdas
*  |  |  |   ( 1 - Ibl ) * |Icl| = 1 for K-, pi-
               EMD = AM (IT) * ( ( ( IBAR (ITTA) - IBAR(IT) ) * IBL
     &             + ( 1 - IBL ) * ABS (ICL) ) )
*  |  |  |   Finally Emd = 2 Am(it) for antibaryons and Am (it) for
*  |  |  |   pi- and K-. Other particles cannot enter the if, however
*  |  |  |   for baryons it is 0 regardless of the charge and for
*  |  |  |   positive charged mesons is Am (it): the conclusion is
*  |  |  |   that who wrote the code is a ......... . Even not
*  |  |  |   taking into account the "if" all the stuff could be:
*              EMD = AM (IT) * ( 1 - IBAR (IT) )
C
C--------------------------------------------------
C*** EMD=2*AM(IT) FOR ANNIHILATION, =AM(IT) FOR MESONS, =0ELSE
C--------------------------------------------------
               THRES = THRESR (IT)
*  |  |  | Ecms is the total available energy in the Cms frame
*  |  |  | and of course is the invariant mass of the projectile-
*  |  |  | nucleon system
               ECMS  = SQRT  (ECMO)
               IF (ECMS .LT. THRES) EMD = 0.D0
*  |  |  | This card means Emd = 0 always for pi-, K- !! and also
*  |  |  | Emd = 0 for ap, an and alambdas if Hadrin will be called
*  |  |  | (they are not stopping!!)
               IF (NXPI .LT. 1) EMD = 0.D0
C
C--------------------------------------------------
C*** EMD=0 FOR MESONS AND BARYONS,IF NO STOPPING OF PARTICLES IF H-N-CMS
C*** -ENERGY LT TABULATED THRESHOLD
C--------------------------------------------------
*  |  |  | This card means Emd = 0 always for pi-, K- (and baryons, but
*  |  |  | for them we don't enter the if)
               IF ( IBAR(IT) .GE. 0 ) EMD = 0.D0
C--------------------------------------------------
C*** ECI = TOTAL EFFECTIVE ENERGY IN H-N-CMS-SYSTEM
C--------------------------------------------------
*  |  |  | Eci is the total energy of the projectile in the frame
*  |  |  | were the target is at rest, if the "effective" invariant
*  |  |  | mass id Ecms + Emd (see kinematics inside Ferevv and
*  |  |  | Difevv )
               ECI   = 0.5D+00 * ( ( ECMS + EMD )**2 - AIT2 - ATA2 ) /
     &                 AMMTA
               TOEFF = ECI - AMMIT
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( TOEFF .LT. TLAB ) THEN
                  TOEFF = TLAB
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            LCORIN = .TRUE.
*  |  | Now the entry Corrnc in Corrin set the correct values for the
*  |  | excitation energy Tv and the cascade energies Tpk and Tnk
            CALL CORRNC ( TOEFF )
            CALL GRANOR(RANGS1, RANGS2)
            TNKTE = MAX ( 0.003D+00, EKMNNU (2)
     &            * ( 0.5D+00 - 0.25D+00 * RANGS1 ) )
            TPKTE = MAX ( 0.003D+00, EKMNNU (1)
     &            * ( 0.5D+00 - 0.25D+00 * RANGS2 ) )
            TV  = TVGRE0
            TPK = EINCP
            TNK = EINCN
C--------------------------------------------------
C*** ELPP=TOTAL PROJECTILE ENERGY,PLPP=ABSOLUT MOMENTUM OF THE PROJECTIL
C*** IN THE LABSYSTEM
C
C--------------------------------------------------
            T3   = AM (IT)
            TPNVK = TV + TNK + TPK
            ELPP  = ELAB - TPNVK
*  |  |  +-------------------------------------------------------------*
*  |  |  | Check for stopping pi- and K-: in my mind this point can
*  |  |  | never be reached by stopping pi-, K- since they should be
*  |  |  | already gone to 405. Anyway...
            IF ( INXPI .EQ. 0 .AND. NXPI .NE. 0 ) THEN
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |    Again in my mind Inxpi = 0 <==> Ibar (itttt) = 0,
*  |  |  |  |    anyway ....
               IF ( IBAR (ITTTT) .GE. 0 ) THEN
                  TVEUZ = 0.D+00
                  V0WELL (ITJ) = V0WELL (ITJ) - V0EXTR
                  ANOW  = ANOW  + IBAR (IT)
                  KTARN = KTARN - IBAR (IT) + ICH (IT)
                  ZNOW  = ZNOW  + ICH  (IT)
                  KTARP = KTARP - ICH  (IT)
                  GO TO 405
*  |  |  |  |-->-->-->-->--> go to the cascade simulation !!
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
C
C--------------------------------------------------
C*** IF NO PRIMARY PI-,K- OR IF HADRIN FOR PI-,K- WILL BE CALLED
C*** (NO STOPPING PARTICLE CASE) GO TO 403
C--------------------------------------------------
C
C--------------------------------------------------
C*** CASE OF ENERGY CORRECTION IF LOOP IN ANNIHILATION
C--------------------------------------------------
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( IBAR (IT) .GE. 0 .AND. NXPI .EQ. 0 ) THEN
               ELIM = T3 + TVEPSI
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               ELIM = AM (13)
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
 6530       CONTINUE
*  |  |  +-------------------------------------------------------------*
*  |  |  |   If Elpp < 0 for less then 10 iterations (I653), start
*  |  |  |   again with effective collision energy calculation, else
*  |  |  |   correct TPK, TNK and TV. Now the maximum number of itera-
*  |  |  |   tion has been decreased to 4, and we check Elpp < T3.
*  |  |  |   We have no enough energy or we have looped too many
*  |  |  |   times, so give up and force the "effective" energy to
*  |  |  |   be 0, reducing cascade and excitation energy
            IF ( I653 .GE. 4 .AND. ELPP .LT. ELIM ) THEN
*  |  |  |   The following cards simply take away the negative
*  |  |  |   "Elpp" to cascade and excitation in the same proportion
*  |  |  |   they were
*  |  |  |   Modified to take into account the Fermi energy:
               A65 = 1.D+00 + ( ELPP - ELIM ) / TPNVK
               TPK = TPK * A65
               TNK = TNK * A65
               TV  = TV  * A65
               TPNVK  = TPNVK * A65
               TVGRE0 = TV
               ELPP   = ELIM
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE IF ( ELPP .LT. 0.D+00 ) THEN
               GO TO 653
*  |  |  |
*  |  +-<|--<--<--<--< go to resampling Tv, Tnk, Tpk
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*

*  |  |  +-------------------------------------------------------------*
*  |  |  |              If the available energy is larger than the
*  |  |  |              mass energy of the projectile check the inva-
*  |  |  |              riant mass of the system
            IF ( ELPP .GT. T3 .AND. NXPI .EQ. 0 ) THEN
               IUMO = 0
               DEX  = 0.D+00
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
2500           CONTINUE
*  |  |  |  |   Now also here work with atomic masses
                  IUMO = IUMO + 1
                  PLPPSQ = ( ELPP + AMMIT ) * ( ELPP - AMMIT )
                  PLPP   = SQRT ( PLPPSQ )
                  PPLUS  = PLAB - PLPP
                  EPLUS  = ELAB - ELPP
                  EEX    = TVEUZ  + DEX
                  AMSTAR = AMMRES + EEX
                  EKRES  = SQRT ( AMSTAR**2 + PPLUS**2 + PFRMSQ - 2.D+00
     &                   * PFRSCA * PPLUS ) - AMSTAR
*  |  |  |  |   Note +DEX to reduce actually the excitation energy, not
*  |  |  |  |   the recoil one (it would have been more exact to set
*  |  |  |  |   Efrm = Efrm - Dex, but it is better to conserve Efrm
*  |  |  |  |   coherent with the original value)
                  EKRECL = EKRES - EPLUS + DEX
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  Check the recoil energy:
                  IF ( EKRECL .LT. 0.D+00 .AND. IUMO .LE. 2 ) THEN
                     EKRECL = EKREC0
                     LDELTX = .FALSE.
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     LDELTX = .TRUE.
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  EZERO  = EFRM  - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
                  ESPENT = ELPP  + EZERO
                  ELEFT  = ETTOT - ESPENT
                  EELEFT = ELEFT + DELEFT
                  UMO2   = AIT2 + EZERO**2 - PFRMSQ + 2.D+00 * ( EZERO
     &                   * ELPP - PLPP * PFRSCA )
                  DELTU2 = UMIN2 - UMO2
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |  We need more invariant mass for the collision!!!
                  IF ( DELTU2 .GT. 0.D+00 ) THEN
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     IF ( IUMO .GT. 4 ) THEN
                        GO TO 653
*  |  |  |  |  |  |
*  |  +-<|-<|-<|-<|--<--<--<
                     END IF
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*

*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     IF ( LDELTX .AND. TPNVK .GT. 0.D+00 ) THEN
                        AHELP  = ESPENT / ELEFT
                        FFRAC  = ( EEX - TVEPSI ) / TPNVK
                        BHELP  = - ELPP - ELPP / PLPP * ( PFRSCA + AHELP
     &                         * ( PFRSCA - PPLUS ) )
                        DELTAE = 0.5D+00 * DELTU2 / ( BHELP + FFRAC *
     &                           AMSTAR * AHELP )
                        TMPDEL = 1.01D+00 * DELTAE
                        DELTAE = MIN ( TMPDEL, TPNVK )
                        DELTEX = FFRAC * DELTAE
                        TKOR = 1.D+00 - DELTAE / TPNVK
                        TPK  = TPK * TKOR
                        TNK  = TNK * TKOR
                        TV   = TV  * TKOR
                        TVGRE0 = TV
                        TPNVK  = TPNVK - DELTAE
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     ELSE IF ( TPNVK .GT. 0.D+00 ) THEN
                        DELTAE = 0.5D+00 * DELTU2 / ( EZERO - PFRSCA *
     &                           ELPP / PLPP )
                        TMPDEL = 1.01D+00 * DELTAE
                        DELTAE = MIN ( TMPDEL, TPNVK )
                        DELTEX = 0.D+00
                        TKOR = 1.D+00 - DELTAE / TPNVK
                        TPK  = TPK * TKOR
                        TNK  = TNK * TKOR
                        TV   = TV  * TKOR
                        TVGRE0 = TV
                        TPNVK  = TPNVK - DELTAE
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     ELSE IF ( LDELTX ) THEN
                        DELTAE = 0.D+00
                        DELTEX = 0.5D+00 * DELTU2 * ELEFT / ( ESPENT *
     &                           AMSTAR )
                        TMPDEL = 1.01D+00 * DELTEX
                        DELTEX = MIN ( TMPDEL, EEX - TVEPSI )
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     ELSE
                        DELTAE = 0.D+00
                        DELTEX = 0.D+00
                     END IF
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
*                    ELPP   = ELPP  + DELTAE, AMMIT
                     TMPAMM = AMMIT + 0.01D+00
                     ELPP   = MAX ( ELPP  + DELTAE, TMPAMM )
                     DEX    = DEX   - DELTEX
                     GO TO 2500
*  |  |  |  |  |
*  |  |  |  +-<|--<--<--<--<--< go to compute the new invariant mass!!
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     TVEUZ = EEX
                     GO TO 510
*  |  |  |  |  |
*  |  |  |  |  |-->-->-->-->--> invariant mass larger than the projec-
*  |  |  |  |  |                tile mass plus target nucleon mass, go
*  |  |  |  |  |                to the event simulation !!
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            IF ( IBAR (IT) .GE. 0 ) GO TO 653
*  |  |
*  |  +--<--<--<--<--< go to resampling Tv, Tnk, Tpk, Elpp < T3 and no
*  |  |                antinucleon projectile
            PLPPSQ = ( ELPP - AMMIT ) * ( ELPP + AMMIT )
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( PLPPSQ .GT. 0.D+00 ) THEN
               PLPP = SQRT ( PLPPSQ )
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               PLPP = 0.D+00
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            PPLUS  = PLAB - PLPP
            EPLUS  = ELAB - ELPP
            EEX    = TVEUZ
            AMSTAR = AMNRES + EEX
            EKRES  = SQRT ( AMSTAR**2 + PPLUS**2 + PFRMSQ - 2.D+00
     &             * PFRSCA * PPLUS ) - AMSTAR
            EKRECL = EKRES - EPLUS
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Check the recoil energy:
            IF ( EKRECL .LT. EKREC0 ) THEN
               EKRECL = EKREC0
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            EZERO  = EFRM  - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
            ESPENT = ELPP  + EZERO
            ELEFT  = ETTOT - ESPENT
            UMO2   = AIT2 + EZERO**2 - PFRMSQ + 2.D+00 * ( EZERO
     &             * ELPP - PLPP * PFRSCA )
            DELTU2 = UMIN2 - UMO2
            IF ( DELTU2 .LT. 0.D+00 ) GO TO 510
*  |  |
*  |  |-->-->-->-->--> invariant mass larger than the projec-
*  |  |                tile mass plus target nucleon mass, go
*  |  |                to the event simulation !!
*  |  |  If we are here we are dealing with an antibaryon and the total
*  |  |  available energy in the centre of mass frame is less than the
*  |  |  projectile mass plus the target nucelon mass
C--------------------------------------------------
C*** IF ELPP GREATERTHEN THE MASS OF IT, GO TO MOMENTUM LIMITATION FOR H
C*** ELSE IF NO EFFECTIVE  ENERGY WAS CALCULATED DO THE SAME
C*** ELSE IF IT IS NO ANTINUCLEON AND ELPP LT MASS OF IT, START AGAIN WI
C***   EFFECTIVE COLLISION ENERGY CALCULATION
C*** ELSE NEW ENERGY DEFINITION FOR IT AND NEW MASS DEFINITION FOR BARYO
C*** AND ANTIBARYONS
C--------------------------------------------------
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( EMD .LE. 0.D+00 ) THEN
               ELPP = T3
               PLPP = 0.D+00
               GO TO 1510
*  |  |  |
*  |  |  |-->-->-->-->--> Skip mass redefinition if Emd is negative or
*  |  |  | zero. In my opinion now Emd is always = 0 for non stopping
*  |  |  | antibaryons, because of the if inside the Emd stuff and I am
*  |  |  | not sure we have really to arrive here under the minimum
*  |  |  | invariant mass...
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
C
C--------------------------------------------------
C*** CASE OF ANNIHILATION,PSEUDO MASS DEFINITION
C--------------------------------------------------
            PLPP = 0.D+00
            UMO2 = ( ELPP + EZERO )**2 - PFRMSQ
            T3   = 0.5D+00 * SQRT ( UMO2 )
            IUMO = 0
            INEG = 0
*  |  |  +-------------------------------------------------------------*
*  |  |  |
5050        CONTINUE
               T3   = 0.9D+00 * T3
               T3SQ = T3 * T3
               PLPPSQ = ELPP**2 - T3SQ
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( PLPPSQ .GT. 0.D+00 ) THEN
                  IUMO = IUMO + 1
                  PLPP = SQRT ( PLPPSQ )
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE
                  INEG = INEG + 1
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( INEG .GT. 100 ) THEN
                     WRITE (LUNOUT,*)
     &               ' Nucriv: impossible to get the pseudo-mass!!',
     &               ' Plpp always negative, Plpp,Elpp', PLPP, ELPP
                     WRITE (LUNERR,*)
     &               ' Nucriv: impossible to get the pseudo-mass!!',
     &               ' Plpp always negative, Plpp,Elpp', PLPP, ELPP
                     V0WELL (ITJ) = V0WELL (ITJ) - V0EXTR
                     ANOW  = ANOW  + IBAR (IT)
                     KTARN = KTARN - IBAR (IT) + ICH (IT)
                     ZNOW  = ZNOW  + ICH  (IT)
                     KTARP = KTARP - ICH  (IT)
                     GO TO 405
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  GO TO 5050
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               PPLUS  = PLAB - PLPP
               EPLUS  = ELAB - ELPP
               EEX    = TVEUZ
               AMSTAR = AMNRES + EEX
               EKRES  = SQRT ( AMSTAR**2 + PPLUS**2 + PFRMSQ - 2.D+00
     &                * PFRSCA * PPLUS ) - AMSTAR
               EKRECL = EKRES - EPLUS
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Check the recoil energy:
               IF ( EKRECL .LT. EKREC0 ) THEN
                  EKRECL = EKREC0
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               EZERO  = EFRM - V0WELL (ITJ) - EKRECL - EBNDNG (ITJ)
               UMO2   = T3SQ + EZERO**2 - PFRMSQ + 2.D+00 * ( EZERO
     &                * ELPP - PLPP * PFRSCA )
               DELTU2 = 2.D+00 * T3 - UMO2
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( IUMO .GT. 10 ) THEN
                  WRITE (LUNERR,*)
     &            ' Nucriv: impossible to get the pseudo-mass!!',
     &              IUMO,DELTU2
                  V0WELL (ITJ) = V0WELL (ITJ) - V0EXTR
                  ANOW  = ANOW  + IBAR (IT)
                  KTARN = KTARN - IBAR (IT) + ICH (IT)
                  ZNOW  = ZNOW  + ICH  (IT)
                  KTARP = KTARP - ICH  (IT)
                  GO TO 405
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               IF ( DELTU2 .GT. 0.D+00 ) GO TO 5050
*  |  |  |
*  |  |  |--<--<--<--<--< invariant mass too small !!
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |   Check the pseudo-mass value (note that the following check
*  |  |  |   becomes useless (except for I653 > 10)
            IF ( T3 .LT. 0.3D+00 * AM (1) .AND. I653 .LT. 10 ) THEN
               I653 = MAX ( I653 + 1, 4 )
               ELIM = 0.33D+00 * AM (1) * ELPP / T3
               T3 = AM (IT)
               GO TO 6530
*  |  |  |--<--<--<--<--< pseudo-mass is too small !!
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  | However let a warning message if it is met!!!
            IF ( T3 .LT. 0.14D+00 .AND. INXPI .LT. 0 .AND. NXPI .GT. 0 )
     &           THEN
               NXPI  = 1
               V0WELL (ITJ) = V0WELL (ITJ) - V0EXTR
               ANOW  = ANOW  + IBAR (IT)
               KTARN = KTARN - IBAR (IT) + ICH (IT)
               ZNOW  = ZNOW  + ICH  (IT)
               KTARP = KTARP - ICH  (IT)
               GO TO 405
*  |  |  |
*  |  |  |-->-->-->-->--> go to the cascade simulation
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*

*  |  |  +-------------------------------------------------------------*
*  |  |  |  Enter this if only with anti-nucleons!!!!!
            IF ( IBAR (ITTTT) .LT. 0 ) THEN
               ETDD  = 0.D0
*  |  |  |  Etkor
               ETKOR = TPNVK + AMMIT
1800           CONTINUE
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  | Check if it was a stopping particle or not !!
               IF ( NXPI .LE. 0 ) THEN
                  ET = ELAB
C
C--------------------------------------------------
C*** THE PARTICLE IT (=AN) IS NOT STOPPED IN THE NUCLEUS
C--------------------------------------------------
                  ETREST = ET - ETKOR
                  IF ( ETREST .LT. 0.D0 ) ETDD = ETREST
                  TKOR = 1.D0 + ETDD / ( TPNVK + 1.D-10 )
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |   Treat it as a stopped particle
                  IF ( TKOR .LT. 1.D-6 ) THEN
                     NXPI = 1
                     GO TO 1800
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |        update tv, tnk, tpk to account for etdd < 0
                  ELSE
                     TV  = TV  * TKOR
                     TPK = TPK * TKOR
                     TNK = TNK * TKOR
                     TVGRE0 = TV
                     TPNVK = TPK + TNK + TV
                     ELPP= ET - TPNVK
                     GO TO 510
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |       It is a stopping antibaryon !!
               ELSE
                  ETDD  = 0.D0
C
C--------------------------------------------------
C*** THE PARTICLE IT (=AN) IS STOPPED IN THE NUCLEUS
C--------------------------------------------------
                  ET = ELAB + AMMTA
                  ETREST = ET - ETKOR
                  IF ( ETREST .LT. 0.D0 ) ETDD = ETREST
                  TKOR = 1.D+00 + ETDD / TPNVK
                  IF ( TKOR .LT. 1.D-6 ) GO TO 653
*  |  |  |  |
*  |  +-<|-<|--<--<--< go to resampling Tv, Tnk, Tpk
                  TV  = TV  * TKOR
                  TPK = TPK * TKOR
                  TNK = TNK * TKOR
                  TVGRE0 = TV
                  TPNVK = TPK + TNK + TV
                  ELPP = ELAB - TPNVK
                  PLPP = SQRT ( ELPP**2 - T3SQ )
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  | end of the "653" loop for bad energy correction in annihilation
*  |  +----------------------------------------------------------------*
C
C--------------------------------------------------
C*** NEW MASS DEFINITION OF BARYONS AND ANTIBARYONS
C*** (ONLY FOR REMAINING EFFECTIVE CM-ENERGIES,LOWER THAN THE TOTAL
C*** 1.88GEV-THRESHOLD CM-ENERGY IN ANNIHILATION)
C--------------------------------------------------
*  |  +----------------------------------------------------------------*
*  |  |  First pass through mass redefinition
         IF ( .NOT. LVMASS ) THEN
            LVMASS = .TRUE.
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Loop over masses to be redefined
            DO 1511 IAM=1,15
               JAM        = IAMC (IAM)
               AMHH (IAM) = AM   (JAM)
               IF ( IBAR (JAM) .NE. 0 ) AM (JAM) = MIN  ( T3, AM (JAM) )
1511        CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |  Masses already redefined
         ELSE
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Loop over masses to be redefined
            DO 15111 IAM=1,15
               JAM        = IAMC (IAM)
               IF ( IBAR (JAM) .NE. 0 ) AM (JAM) = MIN ( T3, AMHH (IAM))
15111       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  | We will arrive here also with T3 = AM (IT) and ELPP < T3 from
*  | the if on EMD =< 0, it is not clear if it is correct!!
1510     CONTINUE
*  |  +----------------------------------------------------------------*
*  |  |                             Loop for Ferhad/hadrin call
510      CONTINUE
C
C--------------------------------------------------
C*** MOMENTUM LIMITATION FOR HADRIN IN FERMI-MOM.-VERSION
C--------------------------------------------------
            PLABOU=15.D0
*  |  |  +-------------------------------------------------------------*
*  |  |  |  This check seems to me to be useless, since the maximum
*  |  |  |  allowed momentum is 10 GeV/c .... anyway get a warning
*  |  |  |  message if this condition is met
            IF ( PLPP .GE. PLABOU ) THEN
               WRITE ( LUNERR, * )' Nucriv: momentum limitation met!!',
     &                              PLPP, PLABOU
               APL  = PLPP - PLABOU
               ELPP = SQRT (PLABOU**2 + AM(IT)**2)
               TPK  = TPK + APL*.3D0
               TNK  = TNK + APL*.3D0
               TV   = TV  + APL*.4D0
               IFORBI = IFORBI + 1
               IF ( IFORBI .GT. 10 ) GO TO 405
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            EELAB = ELPP
            PPLAB = PLPP
            IHACA = IHACA + 1
            ITFRHD = IT
            IF ( PPLAB .LT. 1.D-04 ) THEN
               WRITE (LUNERR,*)
     &              ' Nucriv: iperco=0,eelab,pplab,it',
     &                EELAB,PPLAB,IT
               WRITE (LUNERR,*)'      IHACA,LVMASS,ELAB,PLAB',
     &                                IHACA,LVMASS,ELAB,PLAB
            END IF
            CALL FERHAV ( IT, EELAB, PPLAB, CX, CY, CZ )
C
C--------------------------------------------------
C***
C***
C*** HADRON NUCLEON COLLISION SIMULATION
C*** EELAB=LABENERGY OF H,PPLAB=ABSOLUT MOMENTUM OF H, CX,CY,CZ DIRECTIO
C*** COSINES OF H,IN THE LAB SYSTEM, ITTA TARGET NUCLEON INDEX,
C*** ANUC,ZNUC NUCLEON AND PROTON NUMBERS
C***
C*** REGARDING FERMI MOMENTUM OF THE NUCLEON
C***
C--------------------------------------------------
C--------------------------------------------------
C***
C***
C*** IHACA TIMES CALLED H-N-COLL., IF IN FINAL STATE NO PARTICLE,CALL
C*** AGAIN,
C*** IF IN ANNIHILATION OF A STOPPING NUCLEON,   IN THE FINAL
C*** STATE IS A BARYON, CALL AGAIN H-N-COLL.
C*** (NOT MORE THAN 30 TIMES, ELSE TAKE THIS STATE)
C***
C***
C--------------------------------------------------
*  |  |  +-------------------------------------------------------------*
*  |  |  | Check if we have reached the maximum numbers of calls (which
*  |  |  | has been reduced to 15 .... 30 seems to be a bit too large
*  |  |  | but there were two "IHACA = IHACA + 1" ....
            IF ( IHACA .GT. 15 ) THEN
              GO TO 88
*  |  |  |-->-->-->-->--> give up !!!
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  | Ir is the number of secondaries produced in the Ferhad/Hadrin
*  |  | call
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF (IR .EQ. 0) THEN
               V0WELL (ITJ) = V0WELL (ITJ) + V0EXTR
               GO TO 510
*  |  |  |
*  +-<|-<|-<--<--<--<--< go to resampling the ferhad/hadrin interaction
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  | Check that for annihilated antibaryons we have no (anti)baryon
*  |  | in the final state: if yes resample !
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( INXPI .LT. 0 .AND. NXPI .GT. 0 ) THEN
               IBAROT = 0
               DO 520 IRZ = 1, IR
                  IBAROT = IBAROT + ABS (IBAR(ITR(IRZ)))
  520          CONTINUE
               IF ( IBAROT .GT. 0 ) THEN
                  V0WELL (ITJ) = V0WELL (ITJ) + V0EXTR
                  GO TO 510
               END IF
*  |  |  |
*  +-<|-<|-<--<--<--<--< go to resampling the ferhad/hadrin interaction
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
C
C--------------------------------------------------
C*** IF NO ANNIHILATION INTO MESONS FOR AN+N
C--------------------------------------------------
*  |  | Of course ir=1 means that the only outgoing particle is still
*  |  | the projectile !! If we have an incoming antibaryon
*  |  | we need at least 2 particles in the final state (why????, if
*  |  | we have no annihilation for example a charge exchange recation
*  |  | can give ir=2)
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( IR .LT. 2 .AND. INXPI .LT. 0 ) THEN
               V0WELL (ITJ) = V0WELL (ITJ) + V0EXTR
               GO TO 510
*  |  |  |
*  +-<|-<|-<--<--<--<--< go to resampling the ferhad/hadrin interaction
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
88       CONTINUE
*  |  |                                End loop for Ferhad/hadrin call
*  |  +----------------------------------------------------------------*

*  |  +----------------------------------------------------------------*
*  |  |  Redefinition of masses, if they were changed for annihilation
*  |  |  beyond 1.88 GeV - threshold
         IF ( LVMASS ) THEN
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            DO 1512 IAM=1,15
               AM (IAMC(IAM)) = AMHH (IAM)
1512        CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
C
C--------------------------------------------------
C*** CORRECTION OF CASCADE AND EXCITATION ENERGIES FOR FERMI-MOMENTUM
C*** IF ENERGY CONSERVATION ALLOWS NO H-N-COLLISION, GO TO THE START
C*** POINT OF EVENT SIMUL.
C*** ELSE ENERGY CORRECTION BY VARIABLE EKIKOR
C--------------------------------------------------
C--------------------------------------------------
2800     CONTINUE
         ECHCK  = ETTOT
         PXCHCK = PXTTOT
         PYCHCK = PYTTOT
         PZCHCK = PZTTOT
*  |  +----------------------------------------------------------------*
*  |  |
         DO 3000 IPART = 1, IR
            ECHCK  = ECHCK  - EL (IPART)
            PXCHCK = PXCHCK - PL (IPART) * CXR (IPART)
            PYCHCK = PYCHCK - PL (IPART) * CYR (IPART)
            PZCHCK = PZCHCK - PL (IPART) * CZR (IPART)
3000     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         UMO2 = (ECHCK + DELEFT)**2 - PXCHCK**2 - PYCHCK**2 - PZCHCK**2
*  |  +----------------------------------------------------------------*
*  |  |    Now moved to atomic masses !!!
         IF ( IR .GT. 1 ) THEN
            AMMRE2 = AMMRES**2
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |    It is supposed that the only emitted particle is still the
*  |  |    projectile
         ELSE
            AMMRES = AMMTAR
            AMNRES = AMNTAR
            AMMRE2 = AMMTAR**2
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( UMO2 .LT. AMMRE2 ) THEN
            I1651 = I1651 + 1
            IF ( I1651 .GT. 4 .OR. IHACA .GT. 10 ) THEN
               LRESMP = .TRUE.
               RETURN
            END IF
            V0WELL (ITJ) = V0WELL (ITJ) + V0EXTR
            GO TO 1651
*  |  |
*  +-<|-<--<--<--<--<--< go to the beginning of the event simulation!
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |              End of the event simulation: finally we got it
*  +-------------------------------------------------------------------*
*   Update Tv, Tnk, Tpk taking into account Ekikor: simply ekikor is
*   added (with its sign) leaving unchanged the ratios
*   Again this stuff is now obsolete, we make the same from the energy
*   balance
*  +-------------------------------------------------------------------*
*  |
      IF ( IPERCO .LT. 0 ) THEN
         ELRES  = ECHCK - AMNRES
         ELRES0 = TVEUZ + TPNVK
         AA65 = ELRES / ELRES0
*  | Tpnvk records the sum of the energy available for cascade protons,
*  | neutrons and excitation
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( TPNVK .LE. 0.D+00 ) THEN
            TPK = 0.4D+00 * ELRES
            TNK = 0.5D+00 * ELRES
            TV  = 0.1D+00 * ELRES
            TVGRE0 = 0.5D+00 * TV
            TVEUZ  = 0.5D+00 * TV
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            TPK = TPK * AA65
            TNK = TNK * AA65
            TVGRE0 = TVGRE0 * AA65
            TVEUZ  = TVEUZ  * AA65
            TV = TVGRE0 + TVEUZ
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
*  |                           peripheral collision, no cascade
      ELSE
         ELRES0 = TVEUZ
         ELRES  = ECHCK - AMNRES
         AA65 = ELRES / ELRES0
         TPK = 0.D+00
         TNK = 0.D+00
         TVGRE0 = 0.D+00
         TVEUZ  = TVEUZ * AA65
         TV = TVEUZ
      END IF
*  |
*  +-------------------------------------------------------------------*
C
C--------------------------------------------------
C
C*** REDEFINE THE ENERGIES OF SAMPLED PARTICLES IN
C*** CASE OF CHANGED MASSES
C
C--------------------------------------------------
*  +-------------------------------------------------------------------*
*  |
      IF ( LVMASS ) THEN
         MESON=0
*  |  +----------------------------------------------------------------*
*  |  |
         DO 2510 IRZ=1,IR
            ITRZ   = MIN (ITR(IRZ),30)
            IBAROT = JAMC(ITRZ)
*  |  |  +-------------------------------------------------------------*
*  |  |  |   Check if we need to redefine the energy
            IF ( ABS (IBAROT) .GE. 1 ) THEN
*  |  |  |   This energy redefinition can be very dangerous for any
*  |  |  |   energy balance, since we retain momentum and not energy!!
               ECHCK = ECHCK + EL (IRZ)
               EL (IRZ) = SQRT ( PL (IRZ)**2 + AM (ITRZ)**2 )
               ECHCK = ECHCK - EL (IRZ)
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
                MESON = MESON + 1
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
2510     CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |                           No particle in the secondary stack
      IF ( IR .EQ. 0 ) THEN
         ANOW  = ANOW  + IBAR (IT)
         KTARN = KTARN - IBAR (IT) + ICH (IT)
         ZNOW  = ZNOW  + ICH  (IT)
         KTARP = KTARP - ICH  (IT)
         GO TO 405
*  |
*  +-->-->-->-->--> go to the cascade simulation
*  |
*  +-------------------------------------------------------------------*
*  |  Only one particle in the final state, it should be the projectile
*  |  since it is assumed that no nucleon number correction occurs
*  |  ( see below ): give random angle like for cascade particles to the
*  |  single secondary from Hadrin
      ELSE IF ( IR .EQ. 1 ) THEN
         AMMRES = AMMTAR
         AMNRES = AMNTAR
         TKI = EL(1) - AM (ITR(1))
         IF(TKI .LE. 1.D-20 ) GO TO 1221
         ADE=0.12D0*(1.D0+0.003D0*BBTAR)/TKI
         DEX=EXP(-1.57D0*1.57D0/ADE)
         AN1=(1.D0-DEX)*ADE*.5D0
         AN2=DEX*1.57D0
         AN=AN1+AN2
         AN1=AN1/AN
         CALL GRNDM(RNDM,1)
         IF (RNDM(1) .GT. AN1) GO TO 1222
 1223    CONTINUE
C
C--------------------------------------------------
C*** TETA ANGLE DETERMINATION (SINGLE PART.CASE), = DE
C--------------------------------------------------
         CALL GRNDM(RNDM,1)
         DE=SQRT(-ADE*LOG(1.D0-RNDM(1)*(1.D0-DEX)))
         IF(DE.GT.1.57D0) GO TO 1223
         GOTO 1224
 1222    CONTINUE
         CALL GRNDM(RNDM,1)
         DE=-RNDM(1)
         DE=ATAN2(SQRT(ONEONE-DE**2),DE)
 1224    CONTINUE
         CALL COSI(SFE,CFE)
C
C--------------------------------------------------
C*** COS PHI, SIN PHI DETERMINATION(S.P.CASE)
C--------------------------------------------------
         SID=SIN(DE)
         COD=COS(DE)
         CALL TTRANS (CXR(1), CYR(1), CZR(1), COD, SID, SFE, CFE,
     &                CCXR, CCYR, CCZR)
C
C--------------------------------------------------
C*** TURNING OF ANGLE S INTO THE LABSYSTEM (S.P.CASE)
C--------------------------------------------------
         CXR(1)=CCXR
         CYR(1)=CCYR
         CZR(1)=CCZR
 1221    CONTINUE
*  |
*  +-------------------------------------------------------------------+
*  |                           Two or more particles produced
      ELSE
         I1 = ITJ - 1
         A1 = I1
         ANOW = ANOW - 1.D0
         ZNOW = ZNOW - 1.D0 + A1
         KTARP = KTARP + 1 - I1
         KTARN = KTARN + I1
      END IF
*  |
*  +-------------------------------------------------------------------+
      IRN   = NP0
*  +-------------------------------------------------------------------*
*  |
      DO 10 I = 1,IR
C
C--------------------------------------------------
C*** STORAGE OF H-N-COLL. PRODUCTS INTO NUCLEUS FINAL STATE C./FINUC/
C*** CUT OFF FOR KINETIC ENERGIES LESS THEN ETHR, PUSH THEM INTO EX.EN.
C*** TV
C--------------------------------------------------
         T1 = EL  (I)
         I1 = ITR (I)
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( T1 .LE. ETHR + AM (I1) ) THEN
            ANOW  = ANOW  + IBAR (I1)
            KTARN = KTARN - IBAR (I1) + ICH (I1)
            ZNOW  = ZNOW  + ICH (I1)
            KTARP = KTARP - ICH  (I1)
            AMMRES = ANOW * AMUAMU + 1.D-03 * FKENER ( ANOW, ZNOW )
            AMNRES = AMMRES - ZNOW * AMELEC + ELBNDE ( NINT (ZNOW) )
            EAVAIL = ECHCK - AMNRES + T1
            TPNVK  = TNK + TPK + TV
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( TPNVK .GT. 0.D+00 ) THEN
               TKOR   = EAVAIL / TPNVK
               TPK = TPK * TKOR
               TNK = TNK * TKOR
               TV  = TV  * TKOR
               TVEUZ  = TVEUZ  * TKOR
               TVGRE0 = TVGRE0 * TKOR
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               TPK = 0.4444444444444444D+00 * EAVAIL
               TNK = 0.5555555555555556D+00 * EAVAIL
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |                                  particle acceptable
         ELSE
            IRN = IRN+1
C
C--------------------------------------------------
C*** STORE THE PARTICLE CHARACTERISTICS INTO C./FINUC/, THEN TAKE NEXT
C*** PARTICLE
C--------------------------------------------------
            ITRN(IRN) = I1
            CXRN(IRN) = CXR(I)
            CYRN(IRN) = CYR(I)
            CZRN(IRN) = CZR(I)
            ELR(IRN)  = EL(I)
            PLR(IRN)  = PL(I)
            IBAT = IBAT+1
*  |  |   updating the conservation counters in common balanc
            ENUCR  = ENUCR  + ELR(IRN)
            PXNUCR = PXNUCR + PLR(IRN)*CXRN(IRN)
            PYNUCR = PYNUCR + PLR(IRN)*CYRN(IRN)
            PZNUCR = PZNUCR + PLR(IRN)*CZRN(IRN)
            ICNUCR = ICNUCR + ICH(ITRN(IRN))
            IBNUCR = IBNUCR + IBAR(ITRN(IRN))
            IRNTOT = IRNTOT + 1
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
  10  CONTINUE
*  |
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |
      IF ( IRN - NP0 - IGREYP - IGREYN .EQ. 1 ) THEN
*  |  The following balance is ok if and only if both the incident and
*  |  the emitted particles were nucleons (proton or neutron), or the
*  |  emitted particle is equal to the incident one
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( ITTTT .NE. ITRN (NP0+1) ) THEN
            LPRONU = ITTTT .EQ. 1 .OR. ITTTT .EQ. 8
            LEMINU = ITRN (NP0+1) .EQ. 1 .OR. ITRN (NP0+1) .EQ. 8
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( .NOT. LPRONU .OR. .NOT. LEMINU ) THEN
               ICNOW = NINT (ZNOW)
               IBNOW = NINT (ANOW)
               ICCC = ICHTAR + ICH  (ITTTT) - ICNUCR - ICINTR
               IBBB = IBTAR  + IBAR (ITTTT) - IBNUCR - IBINTR
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( IBBB .NE. IBNOW .AND. LEMINU .AND. IBAR (ITTTT)
     &              .EQ. 0 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( ICCC .GT. ICNOW ) THEN
                     KTARP = KTARP - 1
                     KTARN = KTARN + 2
                     ANOW  = ANOW - 1.D+00
                     ZNOW  = ZNOW + 1.D+00
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE IF (ICCC .LT. ICNOW) THEN
                     KTARP = KTARP + 1
                     KTARN = KTARN
                     ANOW  = ANOW - 1.D+00
                     ZNOW  = ZNOW - 1.D+00
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     KTARN = KTARN + 1
                     ANOW  = ANOW - 1.D+00
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE IF ( ICCC .NE. ICNOW .AND. LEMINU .AND. IBAR (ITTTT)
     &                   .EQ. 0 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( ICCC .GT. ICNOW ) THEN
                     KTARP = KTARP - 1
                     KTARN = KTARN + 1
                     ZNOW  = ZNOW + 1.D+00
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     KTARP = KTARP + 1
                     KTARN = KTARN - 1
                     ZNOW  = ZNOW - 1.D+00
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
      END IF
*  |
*  +-------------------------------------------------------------------*
      GO TO 406
*  +-->-->-->-->--> go to the cascade simulation!!!
C
C--------------------------------------------------
C*** IF ITTTT IS A STOPPED NEGATIVE MESON,(BUT ALSO FOR ANNIHILATION)
C*** DISTRIBUTE THE AVAILABLE TOTAL ENERGY OF THE PARTICLE TO THE CASCAD
C*** AND EXCITATION
C--------------------------------------------------
*  +-------------------------------------------------------------------*
*  | Zero secondary part. case (h-n-coll.), stopping mesons or anyway
*  | all situations not allowing a call to Hadrin
405   CONTINUE
         V0WELL (ITJ) = V0OLD
         IRN = NP0
         AMMRES = AMUAMU * ANOW + 1.D-03 * FKENER ( ANOW, ZNOW )
         AMNRES = AMMRES - ZNOW * AMELEC + ELBNDE ( NINT (ZNOW) )
         TPNVK  = TPK + TNK + TV
         EAVAIL = ETTOT - AMNRES - TPNVK
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( TPNVK .GT. 0.D+00 ) THEN
            TKOR = 1.D+00 + EAVAIL / TPNVK
            TPK  = TPK * TKOR
            TNK  = TNK * TKOR
            TV     = TV * TKOR
            TVGRE0 = TV
            TVEUZ  = 0.D+00
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            TPK  = 0.4D+00 * EAVAIL
            TNK  = 0.5D+00 * EAVAIL
            TVGRE0 = 0.1D+00 * EAVAIL
            TV     = TVGRE0
            TVEUZ  = 0.D+00
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         ELPP = 0.0D+00
*  |
*  +-------------------------------------------------------------------*
*  Now the cascade simulation!!!
406   CONTINUE
      EINCP = 0.D+00
      EINCN = 0.D+00
      IU  = IRN - NP0
C
C--------------------------------------------------
C
C   SIMULATION OF CASCADE NEUTRONS
C
C--------------------------------------------------
C
C--------------------------------------------------
C*** NUCLEON NUMBER AND CASCADE ENERGY(VERSUS CUT OFF)-TEST
C*** GIVE THE ENERGY TO  THE EXCITATION , IF TEST DEMANDS THIS
C--------------------------------------------------
*  +-------------------------------------------------------------------*
*  |
      IF ((TPK.LE.TPKTE).OR.(ZNOW.LT.0.5D0)) THEN
         TV=TV+TPK
         TPK = 0.D+00
         LPCASC = .FALSE.
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         LPCASC = .TRUE.
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      IF ((TNK.LE.TNKTE).OR.(ANOW-ZNOW.LT.0.5D0)) THEN
         TV=TV+TNK
         TNK = 0.D+00
         LNCASC = .FALSE.
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         LNCASC = .TRUE.
      END IF
*  |
*  +-------------------------------------------------------------------*
      KNREJE = 0
      KPREJE = 0
*  +-------------------------------------------------------------------*
*  |    Cascade nucleons selection !!!!
1900  CONTINUE
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( LPCASC ) THEN
            ZSAMP = ZNOW
            IF ( ZSAMP .LE. 0.5D+00 ) THEN
               LPCASC = .FALSE.
            END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            ZSAMP = 0.D+00
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( LNCASC ) THEN
            ANSMP = ANOW - ZNOW
            IF ( ANSMP .LE. 0.5D+00 ) THEN
               LNCASC = .FALSE.
            END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            ANSMP = 0.D+00
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         IF ( ( .NOT. LPCASC ) .AND. ( .NOT. LNCASC ) ) GO TO 2000
         IF ( NINT (ANOW) .LE. 0 ) THEN
            WRITE(LUNERR,*)' Nucriv: <<<< ANOW < 0 >>>>',
     &      ANOW,ZNOW,LPCASC,LNCASC
            LPCASC = .FALSE.
            LNCASC = .FALSE.
            GO TO 2000
         END IF
         CALL GRNDM(RNDM,1)
         IF ( RNDM (1) .LT. ANSMP / ( ANSMP + ZSAMP ) ) THEN
            GO TO 20
         ELSE
            GO TO 30
         END IF
   20    CONTINUE
         T2=AM(8)
C
C--------------------------------------------------
C*** NEUTRON NUMBER AND NEUTRON CASCADE ENERGY TEST
C--------------------------------------------------
         IF ( ANSMP .LT. 0.5D+00 .OR. TNK .LE. TNKTE ) THEN
            LNCASC = .FALSE.
            TV  = TV + TNK
            TNK = 0.D+00
            GO TO 1900
         END IF
C
C--------------------------------------------------
C*** SAMPLING OF KINETIC ENERGY TN AND TETA ANGLE DN OF THE EMITTED NEU
C--------------------------------------------------
         CALL RBKEKV ( 2, EXSOP, TOEFF, BBTAR, TKIN, TSTRCK,
     &                 PSTRCK, ANOW, TKRECL, COD, SID )
         TN  = TKIN
         TNK = TNK-TN
C
C--------------------------------------------------
C*** TEST: IF THE REMAINING ENERGY AND CORRESP.NUCLEON NUMBER ALLOWS FUR
C*** THER CORRESP. NUCLEON EMISSION, ELSE GIVE THE  THE ENERGY OR TAKE
C*** THE MISSING FROM THE EXCITATION
C*** IF FOR LAST CHOSEN NUCLEON TN>REMAINING REST, TAKE IN 90% THE ENER
C*** DIFFERENCE FROM EXCIT.ENERGY, IN 10% OR IF TV WOULD BE LESS THEN 0.
C***  ADD TN TO TV (It does the opposite!!! A. Ferrari)
C--------------------------------------------------
         IF ( ANSMP .LT. 1.5D+00 .OR. TNK .LE. ETHR  ) THEN
            LNCASC = .FALSE.
            CALL GRNDM(RNDM,1)
            VT = RNDM (1)
            THK=TV+TNK
            IF (VT .GT. 0.9D+00 .OR. THK .LT. 0.D+00) THEN
               TV  = TV + TNK + TN
               TNK = 0.D+00
               GO TO 1900
            END IF
            TNK=0.D0
            TV=THK
         END IF
C
C--------------------------------------------------
C*** CORRESP. NUCLEON NUMBER COUNTING
C--------------------------------------------------
         IF ( TSTRCK .LT. ETHR ) THEN
            TV = TV + TN
            GO TO 1900
*  |  |
*  +-<|--<--<--<--<--< Try to select another nucleon!!
         END IF
         ANOW   = ANOW - 1.D+00
         FRSURV = ANOW / BBTAR
C
C--------------------------------------------------
C*** TAKE THE EMITTED CORRESP. NUCLEON INTO THE FINAL PARTICLE TABLE
C*** C./FINUC/ AFTER CHOICE OF PHI AND TURNING INTO THE LAB SYSTEM
C--------------------------------------------------
         IRN = IRN + 1
         CALL COSI ( SFE, CFE )
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( ANOW .LT. 30.D+00 .OR. FRSURV .LT. 0.66D+00 ) THEN
            PXLAST = PXTTOT - PXINTR - PXNUCR
            PYLAST = PYTTOT - PYINTR - PYNUCR
            PZLAST = PZTTOT - PZINTR - PZNUCR
            PPLAS2 = PXLAST**2 + PYLAST**2 + PZLAST**2
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( PPLAS2 .GT. 1.D-6 * PTTOT**2 ) THEN
               PPLAST = SQRT ( PPLAS2 )
               CXXINC = PXLAST / PPLAST
               CYYINC = PYLAST / PPLAST
               CZZINC = PZLAST / PPLAST
               CDMIN = MIN ( ONEONE, PSTRCK / PPLAST ) * ( 1.D+00 -
     &                       0.8D+00 * FRSURV )
               COD = 1.D+00 - 0.5D+00 * ( 1.D+00 - COD ) * ( 1.D+00 -
     &               CDMIN )
               COD = MIN ( COD, ONEONE )
               SID = SQRT ( 1.D+00 - COD**2 )
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               CXXINC = CX
               CYYINC = CY
               CZZINC = CZ
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            CALL TTRANS ( CXXINC, CYYINC, CZZINC, COD, SID, SFE, CFE,
     &                    CXRN (IRN), CYRN (IRN), CZRN (IRN) )
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( NINT (ANOW) .GT. 0 ) THEN
               AMNRES = AMUAMU * ANOW - ZNOW * AMELEC + 1.D-03 * FKENER
     &                ( ANOW, ZNOW ) + ELBNDE ( NINT ( ZNOW ) )
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               AMNRES = 0.D+00
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            AMNRE2 = AMNRES  * AMNRES
            ELEFT  = ETTOT - ENUCR - EINTR - TSTRCK - T2
*  |  | Update TV !!!
            TV     = ELEFT - TPK - TNK - AMNRES
            IUMO   = 0
*  |  |  +-------------------------------------------------------------*
*  |  |  |
2020        CONTINUE
               PXLEFT = PXLAST - PSTRCK * CXRN (IRN)
               PYLEFT = PYLAST - PSTRCK * CYRN (IRN)
               PZLEFT = PZLAST - PSTRCK * CZRN (IRN)
               PPLEF2 = PXLEFT**2 + PYLEFT**2 + PZLEFT**2
               UMO2   = ELEFT**2 - PPLEF2
               DELTU2 = AMNRE2 - UMO2
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( DELTU2 .GT. 0.D+00 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( IUMO .EQ. 0 .AND. PSTRCK .GE. PPLAST ) THEN
                     CXRN (IRN) = CXXINC
                     CYRN (IRN) = CYYINC
                     CZRN (IRN) = CZZINC
                     IUMO   = IUMO + 1
                     GO TO 2020
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  PLDOTU = PXLEFT * CXRN (IRN) + PYLEFT * CYRN (IRN) +
     &                     PZLEFT * CZRN (IRN)
                  DELTAE = 0.51D+00 * DELTU2 / ( ELEFT - ( T2 + TSTRCK )
     &                   * PLDOTU / PSTRCK )
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( DELTAE .GE. TSTRCK .OR. IUMO .GT. 3 ) THEN
                     IRN   = IRN - 1
                     KNREJE = KNREJE + 1
                     ANOW  = ANOW + 1.D+00
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     IF ( KNREJE .GT. 3 ) THEN
                        LNCASC = .FALSE.
*  |  |  |  |  |  |  +-------------------------------------------------*
*  |  |  |  |  |  |  |
                        IF ( LPCASC ) THEN
                           TPK = TPK + TNK + TN
*  |  |  |  |  |  |  |
*  |  |  |  |  |  |  +-------------------------------------------------*
*  |  |  |  |  |  |  |
                        ELSE
                           TV = TV + TNK + TN
                        END IF
*  |  |  |  |  |  |  |
*  |  |  |  |  |  |  +-------------------------------------------------*
                        TNK = 0.D+00
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     ELSE
                        TNK = TNK + TN
                     END IF
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
                     GO TO 1900
*  |  |  |  |  |
*  +-<|-<|-<|-<|--<--<--<--<--<
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     TSTRCK = TSTRCK - DELTAE
                     PSTRCK = SQRT ( TSTRCK * ( TSTRCK + 2.D+00 * T2 ) )
                     TKRECL = TKRECL + DELTAE
                     ELEFT  = ELEFT  + DELTAE
                     GO TO 2020
*  |  |  |  |
*  |  |  +-<|-<|--<--<--<--<
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            CALL TTRANS ( CX, CY, CZ, COD, SID, SFE, CFE, CXRN (IRN),
     &                    CYRN (IRN), CZRN (IRN) )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         IGREYN = IGREYN + 1
         EINCN  = EINCN + TKIN
         ITRN(IRN) = 8
*
*  T2 is the mass energy of the neutron (see before)
*
         TVGRE0 = TVGRE0
         TVGREY = TVGREY + TKIN + TKRECL - TSTRCK - EBNDNG (2)
         EEX = TKIN + TKRECL - TSTRCK - EBNDNG (2)
         TV  = TV + EEX
         ELR (IRN)  = TSTRCK + T2
         PLR(IRN) = PSTRCK
*  |   updating the conservation counters in common balanc
         EINTR  = EINTR + ELR(IRN)
         PXINTR = PXINTR + PLR(IRN)*CXRN(IRN)
         PYINTR = PYINTR + PLR(IRN)*CYRN(IRN)
         PZINTR = PZINTR + PLR(IRN)*CZRN(IRN)
         ICINTR = ICINTR + ICH(ITRN(IRN))
         IBINTR = IBINTR + IBAR(ITRN(IRN))
         IRNTOT = IRNTOT + 1
      GO TO 1900
*  |
*  +--<--<--<--<--< Try to select another cascade nucleon!!!!

*  +-------------------------------------------------------------------*
*  |    Cascade protons selection!!!!!
   30 CONTINUE
         IF ( ZNOW .LT. 0.5D+00 .OR. TPK .LE. TPKTE ) THEN
            LPCASC = .FALSE.
            TV  = TV + TPK
            TPK = 0.D+00
            GO TO 1900
         END IF
C
C--------------------------------------------------
C
C   SIMULATION OF CASCADE PROTONS
C
C--------------------------------------------------
C*** PROTON NUMBER  AND PROTON CASCADE ENERGY TEST
C
C
C--------------------------------------------------
C*** SAMPLING OF KINETIC ENERGY TN AND TETA ANGLE DN OF THE EMITTED P
C--------------------------------------------------
C--------------------------------------------------
         T2 = AM(1)
         CALL RBKEKV ( 1, EXSOP, TOEFF, BBTAR, TKIN, TSTRCK,
     &                 PSTRCK, ANOW, TKRECL, COD, SID )
         TN = TKIN
         TPK = TPK - TN
C
C--------------------------------------------------
C*** TEST: IF THE REMAINING ENERGY AND CORRESP.NUCLEON NUMBER ALLOWS FOR
C*** THE CORRESP. NUCLEON EMISSION, ELSE GIVE THE ENERGY OR TAKE
C*** THE MISSING FROM THE EXCITATION
C*** IF FOR LAST CHOSEN NUCLEON TN>REMAINING REST, TAKE IN 90% THE ENERG
C*** DIFFERENCE FROM EXCIT.ENERGY, IN 10% OR IF TV WOULD BE LESS THEN 0.
C***  ADD TN TO TV
C--------------------------------------------------
         IF ( ZNOW .LT. 1.5D+00 .OR. TPK .LE. ETHR  ) THEN
            LPCASC = .FALSE.
            CALL GRNDM(RNDM,1)
            VT  = RNDM(1)
            THK = TV + TPK
            IF ( VT .GT. 0.9D+00 .OR. THK .LT. 0.D+00 ) THEN
               TV=TV+TPK+TN
               TPK = 0.D+00
               GO TO 1900
            END IF
            TPK = 0.D0
            TV  = THK
         END IF
C
C--------------------------------------------------
C*** CORRESP. NUCLEON NUMBER COUNTING
C--------------------------------------------------
         IF (TN .LT. ETHR) THEN
            TV = TV + TN
            GO TO 1900
*  |  |
*  +-<|--<--<--<--<--< try to select another nucleon
         END IF
         ANOW = ANOW - 1.D0
         ZNOW = ZNOW - 1.D0
         FRSURV = ANOW / BBTAR
C
C--------------------------------------------------
C*** TAKE THE EMITTED CORRESP. NUCLEON INTO THE FINAL PARTICLE TABLE
C*** C./FINUC/ AFTER CHOICE OF PHI AND TURNING INTO THE LAB SYSTEM
C--------------------------------------------------
         IRN = IRN + 1
         CALL COSI ( SFE, CFE )
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( ANOW .LT. 30.D+00 .OR. FRSURV .LT. 0.66D+00 ) THEN
            PXLAST = PXTTOT - PXINTR - PXNUCR
            PYLAST = PYTTOT - PYINTR - PYNUCR
            PZLAST = PZTTOT - PZINTR - PZNUCR
            PPLAS2 = PXLAST**2 + PYLAST**2 + PZLAST**2
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( PPLAS2 .GT. 1.D-6 * PTTOT**2 ) THEN
               PPLAST = SQRT ( PPLAS2 )
               CXXINC = PXLAST / PPLAST
               CYYINC = PYLAST / PPLAST
               CZZINC = PZLAST / PPLAST
               CDMIN = MIN ( ONEONE, PSTRCK / PPLAST ) * ( 1.D+00 -
     &                       0.8D+00 * FRSURV )
               COD = 1.D+00 - 0.5D+00 * ( 1.D+00 - COD ) * ( 1.D+00 -
     &               CDMIN )
               COD = MIN ( COD, ONEONE )
               SID = SQRT ( 1.D+00 - COD**2 )
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               CXXINC = CX
               CYYINC = CY
               CZZINC = CZ
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            CALL TTRANS ( CXXINC, CYYINC, CZZINC, COD, SID, SFE, CFE,
     &                    CXRN (IRN), CYRN (IRN), CZRN (IRN) )
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( NINT (ANOW) .GT. 0 ) THEN
               AMNRES = AMUAMU * ANOW - ZNOW * AMELEC + 1.D-03 * FKENER
     &                ( ANOW, ZNOW ) + ELBNDE ( NINT ( ZNOW ) )
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               AMNRES = 0.D+00
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            AMNRE2 = AMNRES  * AMNRES
            ELEFT  = ETTOT  - ENUCR  - EINTR  - TSTRCK - T2
            IUMO   = 0
*  |  |  +-------------------------------------------------------------*
*  |  |  |
3030        CONTINUE
               PXLEFT = PXLAST - PSTRCK * CXRN (IRN)
               PYLEFT = PYLAST - PSTRCK * CYRN (IRN)
               PZLEFT = PZLAST - PSTRCK * CZRN (IRN)
               PPLEF2 = PXLEFT**2 + PYLEFT**2 + PZLEFT**2
               UMO2   = ELEFT**2 - PPLEF2
               DELTU2 = AMNRE2 - UMO2
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( DELTU2 .GT. 0.D+00 ) THEN
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( IUMO .EQ. 0 .AND. PSTRCK .GE. PPLAST ) THEN
                     CXRN (IRN) = CXXINC
                     CYRN (IRN) = CYYINC
                     CZRN (IRN) = CZZINC
                     IUMO = IUMO + 1
                     GO TO 3030
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
                  IUMO   = IUMO + 1
                  PLDOTU = PXLEFT * CXRN (IRN) + PYLEFT * CYRN (IRN) +
     &                     PZLEFT * CZRN (IRN)
                  DELTAE = 0.51D+00 * DELTU2 / ( ELEFT - ( T2
     &                   + TSTRCK ) * PLDOTU / PSTRCK )
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  IF ( DELTAE .GE. TSTRCK .OR. IUMO .GT. 3 ) THEN
                     IRN   = IRN - 1
                     KPREJE = KPREJE + 1
                     ANOW  = ANOW + 1.D+00
                     ZNOW  = ZNOW + 1.D+00
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     IF ( KPREJE .GT. 3 ) THEN
                        LPCASC = .FALSE.
*  |  |  |  |  |  |  +-------------------------------------------------*
*  |  |  |  |  |  |  |
                        IF ( LNCASC ) THEN
                           TNK = TPK + TNK + TN
*  |  |  |  |  |  |  |
*  |  |  |  |  |  |  +-------------------------------------------------*
*  |  |  |  |  |  |  |
                        ELSE
                           TV = TV + TPK + TN
                        END IF
*  |  |  |  |  |  |  |
*  |  |  |  |  |  |  +-------------------------------------------------*
                        TPK = 0.D+00
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
*  |  |  |  |  |  |
                     ELSE
                        TPK = TPK + TN
                     END IF
*  |  |  |  |  |  |
*  |  |  |  |  |  +----------------------------------------------------*
                     GO TO 1900
*  |  |  |  |  |
*  +-<|-<|-<|-<|--<--<--<--<--<
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
*  |  |  |  |  |
                  ELSE
                     TSTRCK = TSTRCK - DELTAE
                     PSTRCK = SQRT ( TSTRCK * ( TSTRCK + 2.D+00 * T2 ) )
                     TKRECL = TKRECL + DELTAE
                     ELEFT  = ELEFT  + DELTAE
                     GO TO 3030
*  |  |  |  |  |
*  |  |  +-<|-<|--<--<--<--<
                  END IF
*  |  |  |  |  |
*  |  |  |  |  +-------------------------------------------------------*
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            CALL TTRANS ( CX, CY, CZ, COD, SID, SFE, CFE, CXRN (IRN),
     &                    CYRN (IRN), CZRN (IRN) )
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
         IGREYP = IGREYP + 1
         EINCP  = EINCP + TKIN
C
         ITRN (IRN) = 1
*
*  T2 is the mass energy of the proton (see before)
*
*        TVGRE0 = TVGRE0 + EXSOP (1)
         TVGRE0 = TVGRE0
         TVGREY = TVGREY + TKIN + TKRECL - TSTRCK - EBNDNG (1)
         EEX = TKIN + TKRECL - TSTRCK - EBNDNG (1)
         TV  = TV + EEX
         ELR (IRN) = TSTRCK + T2
         PLR (IRN) = PSTRCK
*  |   updating the conservation counters in common balanc
         EINTR  = EINTR + ELR(IRN)
         PXINTR = PXINTR + PLR(IRN)*CXRN(IRN)
         PYINTR = PYINTR + PLR(IRN)*CYRN(IRN)
         PZINTR = PZINTR + PLR(IRN)*CZRN(IRN)
         ICINTR = ICINTR + ICH(ITRN(IRN))
         IBINTR = IBINTR + IBAR(ITRN(IRN))
         IRNTOT = IRNTOT + 1
      GO TO 1900
*  |
*  +--<--<--<--<--< Try to select another cascade nucleon!!!!
C
C--------------------------------------------------
C*** END OF CASCADE NUCLEON EMISSION
C*** HANDLING OF THE CASES: NO OR ONE PARTICLE IN H-A-FINAL STATE
C*** FINAL CALCULATION OF TV
C--------------------------------------------------
2000  CONTINUE
*  +-------------------------------------------------------------------*
*  |   Now working with atomic masses !
      IF ( NINT (ANOW) .GT. 0 ) THEN
         AMMRES = AMUAMU * ANOW + 1.D-03 * FKENER ( ANOW, ZNOW )
         AMNRES = AMMRES - ZNOW * AMELEC + ELBNDE ( NINT (ZNOW) )
         DELEFT = AMMTAR - AMNTAR - ( ICHTAR - ZNOW ) * AMELEC
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         AMMRES = 0.D+00
         AMNRES = 0.D+00
         DELEFT = 0.D+00
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |                        Check the number of emitted particles
      IF ( IRN - NP0 - 1 ) 4001,4002,4003
4001  CONTINUE
*  |  No particle emitted !!!
*  |  Now working with atomic masses
         TV = ETTOT - AMNRES
      GO TO 4013
*  |
*  +-------------------------------------------------------------------*
*  |  One particle emitted
4002  CONTINUE
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( TV .LE. 0.001D+00 ) THEN
            TV  = TVEUZ0
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |   Now working with atomic masses
         UMO2   = ( ETTOT + DELEFT )**2 - PTTOT**2
         IUMO   = 0
*  |  +----------------------------------------------------------------*
*  |  |
4040     CONTINUE
            AMSTAR = AMMRES + TV
            AMEMIT = AM ( ITRN (NP0+1) )
            UMIN2  = ( AMEMIT + AMSTAR )**2
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( UMO2 .LE. UMIN2 ) THEN
               DELTAE = 0.51D+00 * ( UMIN2 - UMO2 ) / ( AMEMIT +
     &                  AMSTAR )
               IUMO = IUMO + 1
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( TV .GE. DELTAE .AND. IUMO .LE. 3 ) THEN
                  TV = TV - DELTAE
                  GO TO 4040
*  |  |  |  |
*  |  +-<|-<|--<--<--<--<--<
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE
                  WRITE ( LUNERR, * ) ' Nucriv: single particle emiss',
     &                  'ion not possible for missing invariant mass!!',
     &                     NINT (ANOW), NINT (ZNOW), UMIN2, UMO2,
     &                     ITRN (NP0+1), IUMO
                  ANOW = BBTAR
                  ZNOW = ZZTAR
                  KTARP = 0
                  KTARN = 0
                  IGREYP = 0
                  IGREYN = 0
                  ENUCR  = 0.D+00
                  PXNUCR = 0.D+00
                  PYNUCR = 0.D+00
                  PZNUCR = 0.D+00
                  EINTR   = 0.D+00
                  PXINTR  = 0.D+00
                  PYINTR  = 0.D+00
                  PZINTR  = 0.D+00
                  TVGREY  = 0.D+00
                  UMO     = SQRT ( UMO2 )
                  TVGRE0  = UMO - AMMTAR
                  TV  = TVGRE0
                  IRN = NP0
                  RETURN
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |
*  |  +----------------------------------------------------------------*
         UMO    = SQRT ( UMO2 )
         GAMCM  = ( ETTOT + DELEFT ) / UMO
         ETACM  = PTTOT / UMO
         ETAX   = PXTTOT / UMO
         ETAY   = PYTTOT / UMO
         ETAZ   = PZTTOT / UMO
         PXNUCR = PLR (NP0+1) * CXRN (NP0+1)
         PYNUCR = PLR (NP0+1) * CYRN (NP0+1)
         PZNUCR = PLR (NP0+1) * CZRN (NP0+1)
         ETAPCM = - ETAX * PXNUCR - ETAY * PYNUCR - ETAZ * PZNUCR
         PHELP  = ETAPCM / ( GAMCM + 1.D+00 ) + ELR (NP0+1)
*  |  Old direction cosines of the emitted particle in CMS
         PXINTR = PXNUCR - ETAX * PHELP
         PYINTR = PYNUCR - ETAY * PHELP
         PZINTR = PZNUCR - ETAZ * PHELP
         PCMS   = SQRT ( PXINTR**2 + PYINTR**2 + PZINTR**2 )
         CXXINC = PXINTR / PCMS
         CYYINC = PYINTR / PCMS
         CZZINC = PZINTR / PCMS
         ECMSST = 0.5D+00 * ( UMO2 + AMSTAR**2 - AMEMIT**2 ) / UMO
         ECMSEM = UMO - ECMSST
         PCMS   = SQRT ( ECMSEM**2 - AMEMIT**2 )
*  |   Now save the old direction
         PXINTR = PCMS * CXXINC
         PYINTR = PCMS * CYYINC
         PZINTR = PCMS * CZZINC
         ETAPCM = ETAX * PXINTR + ETAY * PYINTR + ETAZ * PZINTR
         ELR (NP0+1) = GAMCM * ECMSEM + ETAPCM
         PHELP   = ETAPCM / ( GAMCM + 1.D+00 ) + ECMSEM
         PXNUCR  = PXINTR + ETAX * PHELP
         PYNUCR  = PYINTR + ETAY * PHELP
         PZNUCR  = PZINTR + ETAZ * PHELP
         PLR (NP0+1) = SQRT ( PXNUCR**2 + PYNUCR**2 + PZNUCR**2 )
         ENUCR   = ELR  (NP0+1)
         CXRN (NP0+1) = PXNUCR / PLR (NP0+1)
         CYRN (NP0+1) = PYNUCR / PLR (NP0+1)
         CZRN (NP0+1) = PZNUCR / PLR (NP0+1)
         KTARP   = KTARP + IGREYP
         KTARN   = KTARN + IGREYN
         IGREYP  = 0
         IGREYN  = 0
         EINTR   = 0.D+00
         PXINTR  = 0.D+00
         PYINTR  = 0.D+00
         PZINTR  = 0.D+00
         TVGRE0  = 0.D+00
         TVGREY  = 0.D+00
         TVEUZ   = TV
      GO TO 4013
*  |
*  +-------------------------------------------------------------------*

*  +-------------------------------------------------------------------*
*  |  More than one particle emitted!!
4003  CONTINUE
*  |  Now working with atomic masses !
         TV = ETTOT + DELEFT - AMMRES - ENUCR - EINTR
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( TV .LE. 0.D+00 ) THEN
            WRITE ( LUNERR, * )' *** Nucrin failure: Tv < 0!!',TV
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 4013 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Check if a neutron/proton has been left: if so add to the
*  |  emitted particle list, conserving energyu (but not momentum)
      IF ( NINT (ANOW) .EQ. 1 ) THEN
         IF ( TV .LT. 0.D+00 ) THEN
            LRESMP = .TRUE.
            RETURN
         END IF
         PXRES = PXTTOT - PXINTR - PXNUCR
         PYRES = PYTTOT - PYINTR - PYNUCR
         PZRES = PZTTOT - PZINTR - PZNUCR
         PTRES = SQRT ( PXRES**2 + PYRES**2 + PZRES**2 )
         IRN = IRN + 1
         ANOW  = ANOW  - 1.D+00
         IF ( NINT (ZNOW) .GT. 0.D+00 ) THEN
            ITRN (IRN) = 1
            ZNOW  = ZNOW  - 1.D+00
            KTARP = KTARP + 1
            IGREYP = IGREYP + 1
            TSTRCK = ETTOT - AM (ITRN(IRN)) - ENUCR - EINTR
            EINCP  = EINCP + TSTRCK
         ELSE
            ITRN (IRN) = 1
            KTARN = KTARN + 1
            IGREYN = IGREYN + 1
            TSTRCK = ETTOT - AM (ITRN(IRN)) - ENUCR - EINTR
            EINCN  = EINCN + TSTRCK
         END IF
         TV  = 0.D+00
         ELR (IRN) = TSTRCK + AM (ITRN(IRN))
         PLR (IRN) = SQRT ( TSTRCK * ( TSTRCK + 2.D+00 * AM(ITRN(IRN)) )
     &             )
         PTRES = PLR (IRN) / MAX ( PTRES, ANGLGB )
         CXRN (IRN) = PXRES * PTRES
         CYRN (IRN) = PYRES * PTRES
         CZRN (IRN) = PZRES * PTRES
*  |   updating the conservation counters in common balanc
         EINTR  = EINTR + ELR(IRN)
         PXINTR = PXINTR + PLR(IRN)*CXRN(IRN)
         PYINTR = PYINTR + PLR(IRN)*CYRN(IRN)
         PZINTR = PZINTR + PLR(IRN)*CZRN(IRN)
         ICINTR = ICINTR + ICH(ITRN(IRN))
         IBINTR = IBINTR + IBAR(ITRN(IRN))
         IRNTOT = IRNTOT + 1
      END IF
*  |
*  +-------------------------------------------------------------------*
      RETURN
      END
+DECK,  NUDISV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE NUDISV.FOR
*COPY NUDISV
*=== nudisv ===========================================================*
      INTEGER FUNCTION NUDISV ( ANU, KB, EXPLAM, ASEASQ, APOWER, PRZERO)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Last change  on  05-may-92    by  Alfredo Ferrari, INFN-Milan    *
*                                                                      *
*     Nudist91:                                                        *
*      multiplicity distribution of chains produced in hadron-nucleus  *
*      collisions                                                      *
*                                                                      *
*      Input variables:                                                *
*                       anu    = average number of collisions          *
*                       kb     = baryon number of the projectile       *
*                       explam = exp ( - (anu-1) )                     *
*      Output variables:                                               *
*                       nudisv = number of high energy collisions      *
*----------------------------------------------------------------------*
*
      PARAMETER ( INMAX  = 30 )
      PARAMETER ( IAMAX  = 13 )
      PARAMETER ( ANUMAX = 6.0D+00 )
      PARAMETER ( ANUMED = 0.5D+00 * ( 3.75D+00 + ANUMAX ) )
*
C      AB,(KB.NE.0) BARYON NUCLEUS
C
      DIMENSION AB (INMAX,IAMAX), ANUB (IAMAX), ANUM (9),
     &          ANSESQ (IAMAX), ANPOWR (IAMAX), NULAST (IAMAX)
      DIMENSION AAB (IAMAX), DIST (0:INMAX), IEX (3,5)
      REAL RNDM(1)
      LOGICAL LFIRST
      SAVE LFIRST, ANUB, ANUM, AB, ANSESQ, NULAST, ANPOWR
      DATA ANUB/1.D0,1.1D0,1.25D0,1.45D0,1.65D0,1.74D0,2.09D0,2.66D0,
     &          3.0D0,3.1D0,3.75D0,ANUMED,ANUMAX/
      DATA ANUM/1.D0,1.45D0,1.52D0,1.77D0,2.19D0,2.42D0,2.47D0,
     *2.90D0,5.D0/
      DATA AB  /   1.D+00, 29*0.D+00, 90*0.D+00,
     & 0.5771D+00, 0.2565D+00, 0.1159D+00, 0.0397D+00,
     & 0.0095D+00, 0.0013D+00, 0.0001D+00, 23*0.D+00,
     & 0.5457D+00, 0.2548D+00, 0.1303D+00, 0.0515D+00,
     & 0.0146D+00, 0.0028D+00, 0.0003D+00, 23*0.D+00,
     & 0.4462D+00, 0.2445D+00, 0.1599D+00, 0.0919D+00, 0.0406D+00,
     & 0.0132D+00, 0.0032D+00, 0.0005D+00, 0.0001D+00, 21*0.D+00,
     & 0.3387D+00, 0.2105D+00, 0.1670D+00, 0.1291D+00, 0.0849D+00,
     & 0.0441D+00, 0.0180D+00, 0.0059D+00, 0.0014D+00, 0.0003D+00,
     & 0.0001D+00, 19*0.D+00,
     & 0.2959D+00, 0.1885D+00, 0.1673D+00, 0.1344D+00, 0.1044D+00,
     & 0.0653D+00, 0.0336D+00, 0.0144D+00, 0.0046D+00, 0.0012D+00,
     & 0.0003D+00, 19*0.D+00,
     & 0.2835D+00, 0.1818D+00, 0.1572D+00, 0.1357D+00, 0.1082D+00,
     & 0.0715D+00, 0.0380D+00, 0.0161D+00, 0.0057D+00, 0.0018D+00,
     & 0.0004D+00, 0.0001D+00, 18*0.D+00,
     & 0.2247D+00, 0.1481D+00, 0.1342D+00, 0.1328D+00, 0.1211D+00,
     & 0.0984D+00, 0.0700D+00, 0.0394D+00, 0.0198D+00, 0.0077D+00,
     & 0.0028D+00, 0.0008D+00, 0.0002D+00, 17*0.D+00,  60*0.D+00/
      DATA IEX / 1, 3, 6, 1, 2, 3, 2, 4, 5, 10, 12, 11, 11, 13, 12 /
      DATA LFIRST / .TRUE. /
*
*  +-------------------------------------------------------------------*
*  |      First call: perform the initialization
      IF ( LFIRST ) THEN
         LFIRST = .FALSE.
         IPOWER = NINT (-APOWER)
*  |  +----------------------------------------------------------------*
*  |  |
         DO 100 IA = 1, IAMAX
            AAB (IA) = 0.D+00
*  |  |  +-------------------------------------------------------------*
*  |  |  |          This loop computes the normalization factor
            DO 80 IN = 1, INMAX
               AAB (IA) = AAB (IA) + AB (IN,IA)
   80       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( AAB (IA) .GT. 0.D+00 ) THEN
               ANUAVE = 0.D+00
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               DO 90 IN = 1, INMAX
                  AB (IN,IA) = AB (IN,IA) / AAB (IA)
                  ANUAVE = ANUAVE + IN * AB (IN,IA)
   90          CONTINUE
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               ANUB (IA) = ANUAVE
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
  100    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |
         DO 200 IE = 1,5
            IA  = IEX (2,IE)
            IR1 = IEX (1,IE)
            IR2 = IEX (3,IE)
            ANUEN1 = 0.D+00
            ANUEN2 = 0.D+00
            AAB (IA) = 0.D+00
            AEXTR1 = 0.5D+00 * MIN ( 1, IR1 - 1 )
            AEXTR2 = 0.5D+00 * MIN ( 1, IR2 - 1 )
*  |  |  +-------------------------------------------------------------*
*  |  |  |          This loop fills the ab(i,ia) array,
*  |  |  |          extrapolating from the data for <nu>s,
*  |  |  |          anub (ir1,r2)
            DO 130 IN = 1, INMAX
               ANUBE1 = ANUEN1
               ANUBE2 = ANUEN2
               ANUEN1 = ( AEXTR1 + IN  ) * ANUB (IA)
     &                / ANUB (IR1)
               ANUEN2 = ( AEXTR2 + IN  ) * ANUB (IA)
     &                / ANUB (IR2)
               NABE1  = INT (ANUBE1)
               NABE2  = INT (ANUBE2)
               NAEN1  = NINT (ANUEN1)
               NAEN2  = NINT (ANUEN2)
               IF ( AB (IN,IR1) .GT. 0.D+00 ) THEN
                  DO 110 INN = MAX (NABE1,1), NAEN1
                     IF (INN .GT. 1) THEN
                        ANUBE0 = 0.5D+00 + (INN-1)
                        IF (INN .GT. INMAX ) GO TO 110
                     ELSE
                        ANUBE0 = 0.D+00
                     END IF
                     ANUEN0 = 0.5D+00 + INN
                     ANUBEG = MAX ( ANUBE1, ANUBE0 )
                     ANUEND = MIN ( ANUEN1, ANUEN0 )
                     WEIGHT = AB (IN,IR1) * MAX ( ZERZER, ( ANUEND
     &                      - ANUBEG ) / ( ANUEN1 - ANUBE1 ) )
                     AB (INN,IA) = AB (INN,IA) + WEIGHT
                     AAB (IA) = AAB (IA) + WEIGHT
  110             CONTINUE
               END IF
               IF ( AB (IN,IR2) .GT. 0.D+00 ) THEN
                  DO 120 INN = MAX (NABE2,1), NAEN2
                     IF (INN .GT. 1) THEN
                        ANUBE0 = 0.5D+00 + (INN-1)
                        IF (INN .GT. INMAX ) GO TO 120
                     ELSE
                        ANUBE0 = 0.D+00
                     END IF
                     ANUEN0 = 0.5D+00 + INN
                     ANUBEG = MAX ( ANUBE2, ANUBE0 )
                     ANUEND = MIN ( ANUEN2, ANUEN0 )
                     WEIGHT = AB (IN,IR2) * MAX ( ZERZER, ( ANUEND
     &                      - ANUBEG ) / ( ANUEN2 - ANUBE2 ) )
                     AB (INN,IA) = AB (INN,IA) + WEIGHT
                     AAB (IA) = AAB (IA) + WEIGHT
  120             CONTINUE
               END IF
  130       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            DO 140 IN =1, INMAX
               AB (IN,IA) = AB (IN,IA) / AAB (IA)
  140       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
  200    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |             This loop simply creates a cumulative distribution
         DO 12 IA = 1, IAMAX
            AAB (IA) = 0.D+00
            NULAST (IA) = INMAX
*  |  |  +-------------------------------------------------------------*
*  |  |  |          This loop computes the normalization factor
            DO 18 IN = INMAX, 1, -1
               AAB (IA) = AAB (IA) + AB (IN,IA)
               IF ( AB (IN,IA) .LE. 0.D+00 ) NULAST (IA) = IN - 1
   18       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            ANUAVE = AB (1,IA)
            ANSESQ (IA) = 0.D+00
            AB   (1,IA) = AB (1,IA) / AAB (IA)
*  |  |  +-------------------------------------------------------------*
*  |  |  |          Create the cumulative distribution
            DO 13 IN = 2, INMAX
               AB (IN,IA) = AB (IN,IA) / AAB (IA) + AB (IN-1,IA)
               ANUAVE = ANUAVE + IN * ( AB (IN,IA)
     &                - AB (IN-1,IA) )
               ANSESQ (IA) = ANSESQ (IA) + (IN-1)*(IN-1)
     &                     * ( AB (IN,IA) - AB (IN-1,IA) )
   13       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            ANUB   (IA) = ANUAVE
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( IPOWER .LT. 7 ) THEN
               ANPOWR (IA) = AB (1,IA)
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE IF ( IPOWER .LT. 11 ) THEN
               ANPOWR (IA) = AB (1,IA) * FPOWER ( IPOWER, 1, ANUAVE )
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               ANPOWR (IA) = AB (1,IA) * FPOWER ( IPOWER, 1, ANUAVE )
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |          Compute < nu**y(nu) >:
            DO 11 IN = 2, INMAX
               IF ( IPOWER .LT. 7 ) THEN
                  IF ( APOWER .GT. 0.D+00 ) THEN
                     DPOWER = APOWER
                  ELSE
                     DPOWER = FPOWER ( IPOWER, IN, ANUAVE )
                  END IF
                  ANPOWR (IA) = ANPOWR (IA) + IN**DPOWER
     &                        * ( AB (IN,IA) - AB (IN-1,IA) )
               ELSE IF ( IPOWER .LT. 11 ) THEN
                  ANPOWR (IA) = ANPOWR (IA) + IN
     &                        * FPOWER ( IPOWER, IN, ANUAVE )
     &                        * ( AB (IN,IA) - AB (IN-1,IA) )
               ELSE
                  ANPOWR (IA) = ANPOWR (IA) + IN
     &                        **FPOWER ( IPOWER, IN, ANUAVE )
     &                        * ( AB (IN,IA) - AB (IN-1,IA) )
               END IF
   11       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
   12    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |
         DO 17 IA = 1, IAMAX
            ANUAC = AB (1,IA)
            ANUSQ = AB (1,IA)
            ANUTH = AB (1,IA)
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            DO 15 I = 2, NULAST (IA)
               ANUAC = ANUAC + I     * ( AB (I,IA) - AB(I-1,IA) )
               ANUSQ = ANUSQ + I*I   * ( AB (I,IA) - AB(I-1,IA) )
               ANUTH = ANUTH + I*I*I * ( AB (I,IA) - AB(I-1,IA) )
   15       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( IA .GT. 1 ) THEN
               ANUSE2 = ( ANUSQ - 2.D+00 * ANUB (IA) + 1.D+00 ) /
     &                ( ANUB (IA) - 1.D+00 )**2
               ANUSE3 = ( ANUTH - 3.D+00 * ANUSQ + 3.D+00 * ANUB (IA)
     &                - 1.D+00 ) / ( ANUB (IA) - 1.D+00 )**3
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            ELSE
               ANUSE2 = 1.D+00
               ANUSE3 = 1.D+00
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
   17    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         NUDISV = -1
         RETURN
      END IF
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |                Select the proper distributions for interpolations
      DO 40 I = 1, IAMAX
         IF (ANU .LT. ANUB(I)) GO TO 41
   40 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      I=IAMAX + 1
   41 CONTINUE
      NANU  = I - 1
      IF (NANU.GE.IAMAX) GO TO 50
      IF (NANU.LE.0) NANU = 1
      NANUN = NANU + 1
      WEIGH1 = ( ANU - ANUB (NANU)  ) / ( ANUB (NANUN) - ANUB (NANU) )
      WEIGH2 = ( ANUB (NANUN) - ANU ) / ( ANUB (NANUN) - ANUB (NANU) )
      DIST (0) = 0.D+00
      ASEASQ = WEIGH1 * ANSESQ (NANUN) + WEIGH2 * ANSESQ (NANU)
      APOWER = WEIGH1 * ANPOWR (NANUN) + WEIGH2 * ANPOWR (NANU)
*  +-------------------------------------------------------------------*
*  |   Create the proper cumulative distribution by interpolation
*  |   ( note that since weigh1 + weigh2 = 1 it will be automatically
*  |   normalized )
      DO 20 IN = 1, NULAST (NANUN)
          DIST (IN) = WEIGH1 * AB (IN,NANUN) + WEIGH2 * AB (IN,NANU)
          WEIGHT = (IN-1) * ( DIST (IN) - DIST (IN-1) )
   20 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      PRZERO = DIST (1)
      CALL GRNDM(RNDM,1)
      X=RNDM(1)
*  +-------------------------------------------------------------------*
*  |   Compute the proper nu from the cumulative distribution
      DO 30 IN = 1, NULAST (NANUN)
         IF ( X .LE. DIST (IN) ) GO TO 31
   30 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      IN = NULAST (NANUN)
   31 CONTINUE
      NUDISV = IN
      RETURN
*  Come here for <nu> larger than 8
   50 CONTINUE
      APOWER = -1.D+00
      ASEASQ = -1.D+00
      NUD    = KPOIS (EXPLAM)
      NUDISV = NUD + 1
      PRZERO = EXPLAM
      WRITE (LUNERR,*)' *** Nudisv called with <nu> >= 8 !!',REAL(ANU),
     &                ' ***'
      RETURN
*=== end of function Nudisv ===========================================*
      END
+DECK,  NUPREL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE NUPREL.FOR
*COPY NUPREL
*=== nuprel ===========================================================*
      SUBROUTINE NUPREL(KPROJ,EKIN,PLAB,CTX,CTY,CTZ)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C
C     Last change on  16  september  1991  by  Alfredo Ferrari
C
C  HJM  24/10/88
C
C                 NUCLEON-PROTON ELASTIC SCATTERING EVENTS
C                 PARAMETRIZATION FOR COS(THETA) SAMPLING
C                                 FROM HETKFA2 / CLOTH VERSION
C
C ( Now also antiproton, antineutron - proton scattering )
C-------------------------------------------------------------------
C
+CDE, PAPROP.
+CDE, FINUC.
C
      AMP=AM(KPROJ)
      AMP2=AMP**2
      AMT=AM(1)
      AMT2=AMT**2
      ELAB=EKIN + AMP
      S=AMT2 + AMP2 + 2.D0*AMT*ELAB
      WS=SQRT(S)
      BGAM=PLAB/WS
      GAM=(ELAB + AMT)/WS
      ECMP=(S + AMP2 - AMT2)*0.5D0/WS
      PCM=SQRT((ECMP + AMP)*(ECMP - AMP))
      ECMT=WS - ECMP
*  +-------------------------------------------------------------------*
*  |  Horrible patch for ap, an
      IF ( KPROJ .EQ. 2 ) THEN
         KSAMC = 8
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE IF ( KPROJ .EQ. 9 ) THEN
         KSAMC = 1
*  |
*  +-------------------------------------------------------------------*
*  |
      ELSE
         KSAMC = KPROJ
      END IF
*  |
*  +-------------------------------------------------------------------*
C
      CALL SAMCST(KSAMC,EKIN,CST)
C
      PCPL=PCM*CST
      EPF=GAM*ECMP + BGAM*PCPL
      PPLF=BGAM*ECMP + GAM*PCPL
      ETF=GAM*ECMT - BGAM*PCPL
      PTLF=BGAM*ECMT - GAM*PCPL
C
      PPF=SQRT((EPF+AMP)*(EPF-AMP))
      CTPR=PPLF/PPF
      STPR=SQRT((1.D0-CTPR)*(1.D0+CTPR))
      PTF=SQRT((ETF+AMT)*(ETF-AMT))
      CTTA=PTLF/PTF
      STTA=SQRT((1.D0-CTTA)*(1.D0+CTTA))
C
      CALL SFECFE(SFE,CFE)
      CALL TTRANS(CTX,CTY,CTZ,CTPR,STPR,SFE,CFE,CXR(1),CYR(1),CZR(1))
      SFE=-SFE
      CFE=-CFE
      CALL TTRANS(CTX,CTY,CTZ,CTTA,STTA,SFE,CFE,CXR(2),CYR(2),CZR(2))
C
      NP=2
      KPART(1)=KPROJ
      KPART(2)=1
      TKI(1)=EPF - AMP
      PLR(1)=PPF
      TKI(2)=ETF - AMT
      PLR(2)=PTF
      TV=0.D0
C
      RETURN
      END
+DECK,  PARJET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE PARJET.FOR
*COPY PARJET
*=== parjet ===========================================================*
      SUBROUTINE PARJET(IHAD,I)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
+CDE, FINPAR.
+CDE, PART.
+CDE, INPDAT2.
      IHAD=1
      NREF(1)=I
      PXF(1)=0.D0
      PYF(1)=0.D0
      PZF(1)=0.D0
      HEP(1)=AM(I)
      AMF(1)=AM(I)
      ICHF(1)=ICH(I)
      IBARF(1)=IBAR(I)
      ANF(1)=ANAME(I)
      RETURN
      END
+DECK,  PMPRAB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE PMPRAB.FOR
*COPY PMPRAB
*=== pmprab ===========================================================*
      SUBROUTINE PMPRAB ( KPROJ, EKIN, PPROJ, TXX, TYY, TZZ, WEE )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 22 september 1991 by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 22-sep-91     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, BALANC.
+CDE, FINUC.
+CDE, NUCDAT.
+CDE, NUCGEO.
+CDE, PAREVT.
+CDE, PARNUC.
+CDE, PART.
+CDE, RESNUC.
*
      REAL RNDM(1)
*
      IF ( KPROJ .NE. 14 .OR. EKIN .GT. 2.D+00 * GAMMIN .OR. IBTAR .NE.
     &     1 .OR. ICHTAR .NE. 1 ) THEN
         WRITE (LUNOUT,*)' **** Pmprab: kproj,ekin,ibtar,ichtar',
     &                     KPROJ,EKIN,IBTAR,ICHTAR
         WRITE (LUNERR,*)' **** Pmprab: kproj,ekin,ibtar,ichtar',
     &                     KPROJ,EKIN,IBTAR,ICHTAR
      END IF
      PXRES  = PXTTOT
      PYRES  = PYTTOT
      PZRES  = PZTTOT
      PTRES  = PTTOT
      CALL GRNDM(RNDM,1)
      RNDPAN = RNDM (1)
      IF ( RNDPAN .GE. 1.D+00 / PNFRAT ) THEN
         ERES   = EKIN + AM (KPROJ) + EKFERM + AM (1)
         UMO2   = ( ERES - PTRES ) * ( ERES + PTRES )
         UMO    = SQRT (UMO2)
         GAMCM = ERES  / UMO
         ETAX  = PXRES / UMO
         ETAY  = PYRES / UMO
         ETAZ  = PZRES / UMO
         ECMSNU = 0.5D+00 * ( UMO2 + AMNUSQ (2) ) / UMO
         PCMS   = UMO - ECMSNU
         CALL RACO ( PCMSX, PCMSY, PCMSZ )
         PCMSX = PCMS * PCMSX
         PCMSY = PCMS * PCMSY
         PCMSZ = PCMS * PCMSZ
         ETAPCM = ETAX * PCMSX + ETAY * PCMSY + ETAZ * PCMSZ
         PHELP  = PCMS + ETAPCM / ( GAMCM + 1.D+00 )
         ENPHOT = GAMCM * PCMS + ETAPCM
         PXHELP = PCMSX + ETAX * PHELP
         PYHELP = PCMSY + ETAY * PHELP
         PZHELP = PCMSZ + ETAZ * PHELP
         PXRES = PXRES - PXHELP
         PYRES = PYRES - PYHELP
         PZRES = PZRES - PZHELP
         ERES  = ERES  - ENPHOT
         NP = NP + 1
         TKI   (NP) = ENPHOT
         KPART (NP) = 7
         PLR   (NP) = ENPHOT
         CXR   (NP) = PXHELP / PLR (NP)
         CYR   (NP) = PYHELP / PLR (NP)
         CZR   (NP) = PZHELP / PLR (NP)
         WEI   (NP) = WEE
         IOTHER = IOTHER + 1
         PXNUCR = PXNUCR + PXHELP
         PYNUCR = PYNUCR + PYHELP
         PZNUCR = PZNUCR + PZHELP
         ENUCR  = ENUCR  + TKI (NP)
         IBNUCR = IBNUCR + IBAR (KPART(NP))
         ICNUCR = ICNUCR + ICH  (KPART(NP))
         ETAPCM = - ETAPCM
         PHELP  = ECMSNU + ETAPCM / ( GAMCM + 1.D+00 )
         ENNEU  = GAMCM * ECMSNU + ETAPCM
         PXHELP = -PCMSX + ETAX * PHELP
         PYHELP = -PCMSY + ETAY * PHELP
         PZHELP = -PCMSZ + ETAZ * PHELP
         NP = NP + 1
         TKI   (NP) = ENNEU - AM (8)
         KPART (NP) = 8
         PLR (NP) = SQRT ( PXHELP**2 + PYHELP**2 + PZHELP**2 )
         CXR   (NP) = PXHELP / PLR (NP)
         CYR   (NP) = PYHELP / PLR (NP)
         CZR   (NP) = PZHELP / PLR (NP)
         WEI   (NP) = WEE
         ERES  = ERES  - ENNEU
         PXRES = PXRES - PXHELP
         PYRES = PYRES - PYHELP
         PZRES = PZRES - PZHELP
         IBRES = 0
         ICRES = 0
         PTRES = 0.D+00
         ANOW  = 0.D+00
         ZNOW  = 0.D+00
      ELSE
         ERES   = EKIN + AM (KPROJ) + EKFERM + AM (1)
         UMO2   = ( ERES - PTRES ) * ( ERES + PTRES )
         UMO    = SQRT (UMO2)
         GAMCM = ERES  / UMO
         ETAX  = PXRES / UMO
         ETAY  = PYRES / UMO
         ETAZ  = PZRES / UMO
         ECMSNU = 0.5D+00 * ( UMO2 + AM (8)* AM (8) - AM (23) * AM (23)
     &          ) / UMO
         ECMSP0 = UMO - ECMSNU
         PCMS = SQRT ( ( ECMSP0 - AM (23) ) * ( ECMSP0 + AM (23) ) )
         CALL RACO ( PCMSX, PCMSY, PCMSZ )
         PCMSX = PCMS * PCMSX
         PCMSY = PCMS * PCMSY
         PCMSZ = PCMS * PCMSZ
         ETAPCM = ETAX * PCMSX + ETAY * PCMSY + ETAZ * PCMSZ
         PHELP  = ECMSP0 + ETAPCM / ( GAMCM + 1.D+00 )
         ENPIO0 = GAMCM * ECMSP0 + ETAPCM
         PXHELP = PCMSX + ETAX * PHELP
         PYHELP = PCMSY + ETAY * PHELP
         PZHELP = PCMSZ + ETAZ * PHELP
         PXRES = PXRES - PXHELP
         PYRES = PYRES - PYHELP
         PZRES = PZRES - PZHELP
         ERES  = ERES  - ENPIO0
         NP = NP + 1
         TKI   (NP) = ENPIO0 - AM (23)
         KPART (NP) = 23
         PLR (NP) = SQRT ( PXHELP**2 + PYHELP**2 + PZHELP**2 )
         CXR   (NP) = PXHELP / PLR (NP)
         CYR   (NP) = PYHELP / PLR (NP)
         CZR   (NP) = PZHELP / PLR (NP)
         WEI   (NP) = WEE
         IOTHER = IOTHER + 1
         PXNUCR = PXNUCR + PXHELP
         PYNUCR = PYNUCR + PYHELP
         PZNUCR = PZNUCR + PZHELP
         ENUCR  = ENUCR  + TKI (NP)
         IBNUCR = IBNUCR + IBAR (KPART(NP))
         ICNUCR = ICNUCR + ICH  (KPART(NP))
         ETAPCM = - ETAPCM
         PHELP  = ECMSNU + ETAPCM / ( GAMCM + 1.D+00 )
         ENNEU  = GAMCM * ECMSNU + ETAPCM
         PXHELP = -PCMSX + ETAX * PHELP
         PYHELP = -PCMSY + ETAY * PHELP
         PZHELP = -PCMSZ + ETAZ * PHELP
         NP = NP + 1
         TKI   (NP) = ENNEU - AM (8)
         KPART (NP) = 8
         PLR (NP) = SQRT ( PXHELP**2 + PYHELP**2 + PZHELP**2 )
         CXR   (NP) = PXHELP / PLR (NP)
         CYR   (NP) = PYHELP / PLR (NP)
         CZR   (NP) = PZHELP / PLR (NP)
         WEI   (NP) = WEE
         ERES  = ERES  - ENNEU
         PXRES = PXRES - PXHELP
         PYRES = PYRES - PYHELP
         PZRES = PZRES - PZHELP
         IBRES = 0
         ICRES = 0
         PTRES = 0.D+00
         ANOW  = 0.D+00
         ZNOW  = 0.D+00
      END IF
      RETURN
*=== End of subroutine PMPRAB =========================================*
      END
+DECK,  POLI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE POLI.FOR
*COPY POLI
*=== poli =============================================================*
      SUBROUTINE POLI(CS,SI)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(1)
C
C--------------------------------------------------
C*** RANDOM CHOICE OF ANGLE TETA (CS = COS(TETA),SI = SIN(TETA)
C--------------------------------------------------
      CALL GRNDM(RNDM,1)
      CS = 2.D+00 * RNDM(1) - 1.D+00
      SI = SQRT( ( 1.D+00 - CS ) * ( 1.D+00 + CS ) )
      RETURN
      END
+DECK,  QNRG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE QNRG.FOR
*COPY QNRG
*                                                                      *
*=== qnrg =============================================================*
*                                                                      *
      FUNCTION QNRG ( A1, Z1, A2, Z2 )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C--------------------------------------------------------------------
C SUBNAME = QNRG
C--------------------------------------------------------------------
+CDE, EVA0.
C--------------------------------------------------------------------
      KA1  = NINT (A1)
      KZ1  = NINT (Z1)
      KA2  = NINT (A2)
      KZ2  = NINT (Z2)
      N1= KA1 - KZ1
      N2= KA2 - KZ2
      IF (N1 .LE. 0) STOP 105
      IF (N2 .LE. 0) STOP 106
      IZZ1 = NINT ( WAPS (KA1,1) )
      IZZ2 = NINT ( WAPS (KA2,1) )
      IF ( KZ1 .LT. IZZ1 .OR. KZ1 .GT. IZZ1 + 9 ) THEN
         ENRG1 = ENRG ( A1, Z1 )
      ELSE
         IZ1   = KZ1 - IZZ1 + 2
         ENRG1 = WAPS ( KA1, IZ1 )
         IF ( ENRG1 .EQ. 0.D0 .AND. ( KA1 .NE. 12 .OR. KZ1 .NE. 6) )
     &        THEN
            ENRG1 = ENRG ( A1, Z1 )
         END IF
      END IF
      IF ( KZ2 .LT. IZZ2 .OR. KZ2 .GT. IZZ2 + 9 ) THEN
         ENRG2 = ENRG ( A2, Z2 )
      ELSE
         IZ2   = KZ2 - IZZ2 + 2
         ENRG2 = WAPS ( KA2, IZ2 )
         IF ( ENRG2 .EQ. 0.D0 .AND. ( KA2 .NE. 12 .OR. KZ2 .NE. 6) )
     &        THEN
            ENRG2 = ENRG ( A2, Z2 )
         END IF
      END IF
      QNRG = ENRG1 - ENRG2
      RETURN
      END
+DECK,  RACO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE RACO.FOR
*COPY RACO
*=== raco =============================================================*
      SUBROUTINE RACO(WX,WY,WZ)
+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(2)
C********************************************************************
C     VERSION JUNE 81 BY             PERTTI AARNIO
C     LAST CHANGE 22. JUNE 81 BY     PERTTI AARNIO
C                                    HELSINKI UNIVERSITY OF
C                                    TECHNOLOGY, FINLAND
C
C
C     SUBROUTINE OF FLUKA TO GIVE THE DIRECTION COSINES OF RANDOM
C     UNIFORM (ISOTROPIC) DIRECTION IN THREE DIMENSIONAL SPACE.
C********************************************************************
C
 10   CALL GRNDM(RNDM,2)
      X=2.D0*RNDM(1)-1.D0
      Y=RNDM(2)
      X2=X*X
      Y2=Y*Y
      IF (X2+Y2.GT.1.D0) GO TO 10
      CFE=(X2-Y2)/(X2+Y2)
      SFE=2.D0*X*Y/(X2+Y2)
      CALL GRNDM(RNDM,1)
      Z=RNDM(1)
      Z2=Z*Z
      WZ=SQRT(Z-Z2)
      WX=2.D0*WZ*CFE
      WY=2.D0*WZ*SFE
      WZ=2.D0*Z-1.D0
      RETURN
      END
+DECK,  RAKEKV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE RAKEKV.FOR
*COPY RAKEKV
*                                                                      *
*=== rakekv ===========================================================*
*                                                                      *
      SUBROUTINE RAKEKV ( IT, EXSOP, BBTAR, TKIN, TSTRCK, PSTRCK,
     &                    ARECL, TKRECL, EFERMI, CDE, SDE )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*     version by                     Alfredo Ferrari
*                                    INFN - Milan
*     last change 03 january 93 by   Alfredo Ferrari
*                                    INFN - Milan
*
*     To be called from the high energy production
*
*     this is a subroutine of fluka to sample intranuclear cascade
*     particles: it is based on the old Rakeka from J. Ranft
*
*     input variables:
*        it    = type of the secondary requested; 1=proton, 2=neutron
*        bbtar = atomic weight of the medium
*
*     output variables:
*        tkin  = kinetic energy of the secondary in GeV before applying
*                the nuclear well (and eventually the Coulomb barreer)
*        tstrck= kinetic energy of the secondary in GeV
*        pstrck= momentum of the secondary in GeV/c
*        cde,sde = cosine and sine of the angle between the
*                  directions of the primary
*                  and secondary particles
*
*********************************************************************
*
+CDE, NUCDAT.
+CDE, PAREVT.
      COMMON / FKNUCO / HELP (2), HHLP (2), FTVTH (2), FINCX (2),
     &                  EKPOLD (2), BBOLD, ZZOLD, SQROLD, ASEASQ,
     &                  FSPRED, FEX0RD
      COMMON / FKCASF / PKFRMI, COSTH, PKIN
      DIMENSION EXSOP (2)
      REAL RNDM(4), RNGSS, DUMNOR
*  In this version the low energy component has been suppressed, since
*  they are now produced by the evaporation model, A. Ferrari.
*  The parameters needed for the sampling have been already set in
*  Corrin
      EXSOP (IT) = 0.D+00
*  +-------------------------------------------------------------------*
*  |
 100  CONTINUE
*  |  Sample the Fermi momentum
         CALL GRNDM(RNDM,4)
         PKFRMI = PFRMMX (IT) * MAX ( RNDM (1), RNDM (2),
     &            RNDM (3) )
         PKFRSQ = PKFRMI * PKFRMI
         TKIN   = - ESLOPE (IT) * LOG ( EXMNNU (IT) - RNDM (4) * (
     &              EXMNNU (IT) - EXUPNU (IT) ) )
         TKRECL = 0.5D+00 * PKFRSQ / ( AMUC12 * ARECL ) * ( 1.D+00 -
     &            0.25D+00 * PKFRSQ / ( ARECL**2 * AMUCSQ ) )
         EFERMI = SQRT ( AMNUSQ (IT) + PKFRSQ )
         TSTRCK = EFERMI + TKIN - AMNUCL (IT) - V0WELL (IT) - TKRECL -
     &            EBNDNG (IT)
*  |  +----------------------------------------------------------------*
*  |  |  Record the energy spent without emitting nucleons
         IF ( TSTRCK .LE. VEFFNU (IT) - V0WELL (IT) ) THEN
*  |  |  Reduce that energy according to Fspred:
            EXSOP (IT) = EXSOP (IT) + TKIN * FEX0RD
            GO TO 100
*  +-<|--<--<--<--<--< go to resampling
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |
*  +-------------------------------------------------------------------*
      PSTRCK = SQRT ( TSTRCK * ( TSTRCK + 2.D+00 * AMNUCL (IT) ) )
*   Sample the angle between the incident particle and the Fermi
*   momentum
*   Solution assuming that the momentum transfer is equal to the
*   the momentum loss of the projectile for the energy loss Tkin,
*   roughly given by Tkin again. Use this with the "usual" eventv
      PKIN   = TKIN
      PKIN2  = PKIN * PKIN
      CALL GRNDM(RNDM,1)
      COSTH  = 2.D+00 * RNDM (1) - 1.D+00
      COSDE2 = PKFRMI * COSTH + PKIN
      CSIGN  = SIGN ( ONEONE, COSDE2 )
      COSDE2 = COSDE2 * COSDE2 / ( PKIN2 + PKFRSQ +
     &           2.D+00 * COSTH * PKIN * PKFRMI )
      CDE = CSIGN * SQRT ( COSDE2 )
* Original
      SDE0 = MAX ( ONEONE - CDE, ANGLGB )
      SDE1 = SDE0
      FCORR0 = 0.10D+00
      TMPSDE = 3.5D+00 * SDE0
      FCORR  = ATO1O3 * MIN ( FCORR0, TMPSDE )
 2000 CONTINUE
         CALL GRANOR ( RNGSS, DUMNOR )
         SDE = SDE0 + FCORR * RNGSS
         CDE = 1.D+00 - SDE
      IF ( ABS ( CDE ) .GE. 1.D+00 ) GO TO 2000
      SDE = SQRT ( ( 1.D+00 - CDE ) * ( 1.D+00 + CDE ) )
      RETURN
      END
+DECK,  RBKEKV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE RBKEKV.FOR
*COPY RBKEKV
*                                                                      *
*=== rbkekv ===========================================================*
*                                                                      *
      SUBROUTINE RBKEKV ( IT, EXSOP, TO, AMSS, TKIN, TSTRCK,
     &                    PSTRCK, ARECL, TKRECL, COD, SID )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*     version by                     Alfredo Ferrari
*                                    INFN - Milan
*     last change 19 april 93 by     Alfredo Ferrari
*                                    INFN - Milan
*
*     To be called from the high energy production
*
*     this is a subroutine of fluka to sample intranuclear cascade
*     particles: it is based on the old Rakeka from J. Ranft
*
*     input variables:
*        it    = type of the secondary requested; 1=proton, 2=neutron
*        bbtar = atomic weight of the medium
*
*     output variables:
*        tkin  = kinetic energy of the secondary in GeV before applying
*                the nuclear well (and eventually the Coulomb barreer)
*        tstrck= kinetic energy of the secondary in GeV
*        pstrck= momentum of the secondary in GeV/c
*        sid,cod = sine and cosine of the angle between
*                  the directions of the primary
*                  and secondary particles
*
*********************************************************************
*
      PARAMETER ( PI   = PIPIPI )
      PARAMETER ( PIO2 = PI / 2.D+00 )
+CDE, NUCDAT.
      LOGICAL LINIT, LZEROI
      DIMENSION EXSOP (2), AMMOLD (2)
      DIMENSION PFINIT (50,2), TKINIT (50,2), TSINIT (50,2),
     &          TRINIT (50,2), NINI (2)
      REAL RNDM(4)
      SAVE AMMOLD, PFINIT, TKINIT, TSINIT, TRINIT, NINI
      DATA AMMOLD / 0.9382796D+00, 0.9395731D+00 /
*
      LINIT = .FALSE.
      IF ( NINI (IT) .GT. 0 ) THEN
         PKFRMI = PFINIT (NINI(IT),IT)
         TKIN   = TKINIT (NINI(IT),IT)
         TSTRCK = TSINIT (NINI(IT),IT)
         TKRECL = TRINIT (NINI(IT),IT)
         NINI  (IT) = NINI (IT) - 1
         EXSOP (IT) = 0.D+00
         GO TO 3500
      ELSE
         GO TO 200
      END IF
      ENTRY RBKINI ( IT, LZEROI, EXSOP, TKIN, TSTRCK,
     &               PSTRCK, ARECL, TKRECL )
      LINIT = .TRUE.
      IF ( LZEROI ) THEN
         NINI (1) = 0
         NINI (2) = 0
         RETURN
      END IF
  200 CONTINUE
*  In this version the low energy component has been suppressed, since
*  they are now produced by the evaporation model, A. Ferrari.
*  The parameters needed for the sampling have been already set in
*  Corrin:
      EXSOP (IT) = 0.D+00
*  Sample the Fermi momentum
      ESLPFF = ESLOPE (IT)
      EXUPFF = EXUPNU (IT)
      EKUPFF = EKUPNU (IT)
      EXDWFF = EXMNNU (IT)
      EKDWFF = EKMNNU (IT)
      ERCLFF = ERCLAV (IT)
      IRECNT = 0
*  +-------------------------------------------------------------------*
*  |
 100  CONTINUE
*  |  Sample the Fermi momentum
         CALL GRNDM(RNDM,4)
         PKFRMI = PFRMMX (IT) * MAX ( RNDM (1), RNDM (2),
     &            RNDM (3) )
         PKFRSQ = PKFRMI * PKFRMI
         TKIN   = - ESLPFF * LOG ( EXDWFF - RNDM (4) * (
     &              EXDWFF - EXUPFF ) )
         TKRECL = 0.5D+00 * PKFRSQ / ( AMUC12 * ARECL ) * ( 1.D+00 -
     &            0.25D+00 * PKFRSQ / ( ARECL**2 * AMUCSQ ) )
         TSTRCK = SQRT ( AMNUSQ (IT) + PKFRSQ ) + TKIN - AMNUCL (IT)
     &          - V0WELL (IT) - TKRECL - EBNDNG (IT)
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( TSTRCK .LE. VEFFNU (IT) - V0WELL (IT) ) THEN
            EXSOP (IT) = EXSOP (IT) + TKIN
            IRECNT = IRECNT + 1
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF ( IRECNT .GT. 10 ) THEN
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               IF ( TKRECL - ERCLFF .GT. EKUPFF - EKDWFF .AND.
     &              IRECNT .LT. 20 ) THEN
                  ERCLFF = ERCLFF + TKRECL - ERCLFF
                  EKUPFF = EKUPFF + TKRECL - ERCLFF
                  EKDWFF = EKDWFF + TKRECL - ERCLFF
                  AHELP  = EXP ( - ( TKRECL - ERCLFF ) / ESLPFF )
                  EXUPFF = EXUPFF * AHELP
                  EXDWFF = EXDWFF * AHELP
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE IF ( IRECNT .GT. 15 ) THEN
                  TKRECL = MAX ( TKRECL, ERCLFF )
                  ERCLFF = ERCLFF + TKRECL
                  EKUPFF = EKUPFF + TKRECL - ERCLFF
                  EKDWFF = EKDWFF + TKRECL - ERCLFF
                  AHELP  = EXP ( - TKRECL / ESLPFF )
                  EXUPFF = EXUPFF * AHELP
                  EXDWFF = EXDWFF * AHELP
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            GO TO 100
*  +-<|--<--<--<--<--< go to resampling
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      IF ( LINIT ) THEN
         NINI (IT) = NINI (IT) + 1
         PFINIT (NINI(IT),IT) = PKFRMI
         TKINIT (NINI(IT),IT) = TKIN
         TSINIT (NINI(IT),IT) = TSTRCK
         TRINIT (NINI(IT),IT) = TKRECL
         RETURN
      END IF
*  |
*  +-------------------------------------------------------------------*
 3500 CONTINUE
*  | Masses have been updated
      PSTRCK = SQRT ( TSTRCK * ( TSTRCK + 2.D+00 * AMNUCL (IT) ) )
*
********************* Sample the angle ********************************
* Polar angle selection
      ADE=0.090D0*(1.D0+0.081D0*ATO1O3)/TKIN
      DEX=EXP(- PIO2 * PIO2 / ADE)
      AN1=(1.D0-DEX)*ADE/2.D0
      AN2=DEX*PIO2
      AN=AN1+AN2
      AN1=AN1/AN
      CALL GRNDM(RNDM,1)
      IF(RNDM(1).GT.AN1)  GO TO 3
    2 CONTINUE
      CALL GRNDM(RNDM,1)
      DE=SQRT(-ADE*LOG(1.D0-RNDM(1)*(1.D0-DEX)))
      IF(DE.GT.PIO2) GO TO 2
C     WRITE(LUNOUT,*)IT,TO,AMSS,SQAMSS,T,P,DE
      COD = COS (DE)
      SID = SIN (DE)
      RETURN
    3 CONTINUE
      CALL GRNDM(RNDM,1)
      COD = - RNDM(1)
      SID = SQRT ( (1.D0 + COD ) * ( 1.D0 - COD ) )
C     WRITE(LUNOUT,*)IT,TO,AMSS,SQAMSS,T,P,DE
      RETURN
      ENTRY RBKMIN (IT)
      NINI(IT) = NINI(IT)-1
      RETURN
      END
+DECK,  RCHANV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE RCHANV.FOR
*COPY RCHANV
*=== rchanv ===========================================================*
      SUBROUTINE RCHANV

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, HADFLG.
+CDE, REAC.
+CDE, REDVER.
+CDE, SPLIT.
*
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
*  Note: 296 are the total number of energy at which data are tabulated
*        (of course for the 17 reactions considered, depending on the
*         reaction there could be different numbers of tabulated
*         energies)
*        268 is the number of possible exit channels
*        Umo (ieii(ire)+ie) is the cms energy corresponding to the ieth
*        energy at which data are tabulated for the reaction ire
*        Plabf (ieii(ire)+ie) is the corresponding lab momentum
*        Siin  (ieii(ire)+ie) is the cross section
      DIMENSION HWT(460)
      DIMENSION HWK(40)
      DIMENSION SI(5184)
      EQUIVALENCE (WK(1),SI(1))
C*** WEIGHTS FOR THE SAMPLING PROCEDURE (ADDED ONE TO EACH OTHER IN
C*** CORRESP. CHANNELS) SPECIFIC FOR NUCRIN ONLY
C*** CALCULATION OF THRESHOLD ENERGY OF THE REACTION CHANNELS
C
      IREG=16
*  +-------------------------------------------------------------------*
*  |  Loop on the possible reactions (pi+ p, .... )
      DO 222 IRE=1,IREG
*  |  Initial index for the exit channel sigmas/weights for reaction IRE
*  |  (wk(ire+1)-wk(ire+iee), weights at the various energies for the
*  |  first channel, wk(ire+(ik-1)*iee+ie), weight of the ikth channel
*  |  at ieth energy)
         IWKO=IRII(IRE)
*  |  Number of energy tabulations for reaction ire
         IEE=IEII(IRE+1)-IEII(IRE)
*  |  Number of exit channels of reaction ire
         IKE=IKII(IRE+1)-IKII(IRE)
*  |  Index for the initial energy tabulation for reaction ire (this is
*  |  for index 1!!, ieii is for index 0)
         IEO=IEII(IRE)+1
*  |  Index for the initial exit channel of the reaction ire
*  |  (the initial channel is IIKI + 1)
         IIKI=IKII(IRE)
*  |  +----------------------------------------------------------------*
*  |  |  This loop checks the threshold (expressed in invariant mass)
*  |  |  for the several reaction channels:
*  |  |  Channels resulting in two exit particles/resonances are
*  |  |  checked for Thresh >= m(1) + m(2)
*  |  |  Channels resulting in only one resonance are checked for
*  |  |  Thresh >= Min_j (m_j(1)+m_j(2)+m_j(3)), where the minimum
*  |  |  is carried out looping over all possible decay channels j
*  |  |  and now also looking for the mass of the resonance
*  |  |  less 5 x width
         DO 226 IK=1,IKE
            INRK1 = NRK(1,IIKI+IK)
            INRK2 = NRK(2,IIKI+IK)
            AM111 = AM (INRK1)
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Two particles/resonances exit channels
            IF ( INRK2 .GT. 0 ) THEN
               AM222 = AM (INRK2)
               THRESH (IIKI+IK) = AM111 + AM222
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  |  One resonance exit channel
            ELSE
               IF ( GA (INRK1) .GT. ANGLGB ) THEN
                  AM111 = AM111 - 5.D+00 * GA (INRK1)
               ELSE
                  AM111 = 0.D+00
               END IF
               INRKK = K1(INRK1)
               AMSS  = 5.D+00
               INRKO = K2(INRK1)
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Loop over the decay channels
               DO 228 INKK=INRKK,INRKO
                  INZK1=NZK(INKK,1)
                  INZK2=NZK(INKK,2)
                  INZK3=NZK(INKK,3)
                  AMS = AM(INZK1)+AM(INZK2)-2.D+00*(GA(INZK1)+GA(INZK2))
                  IF (INZK3 .GT. 0)  AMS =AMS+AM(INZK3)-2.D+00*GA(INZK3)
                  IF (AMSS  .GT.AMS) AMSS=AMS
  228          CONTINUE
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
               AMS = MAX (AMSS,AM111)
               IF ( AMS .LT. UMO(IEO) ) AMS = UMO (IEO)
               THRESH (IIKI+IK) = AMS
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
  226    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
         SINORC = 1.D+00
*  |  +----------------------------------------------------------------*
*  |  |  Loop on the energy tabulations
         DO 221 IE=1,IEE
            SIS=ANGLGB/10.D+00
            PLASQ = PLABF (IEO+IE-1)**2
            UMOSQ = ( SQRT ( AM (INNURE(1,1,IRE))**2 + PLASQ )
     &            + AM (INNURE(2,1,IRE)) )**2 - PLASQ
            IF ( INNURE (1,2,IRE) .GT. 0 )
     &         UMOSQ = MAX ( UMOSQ, ( SQRT ( AM (INNURE(1,2,IRE))**2
     &               + PLASQ ) + AM (INNURE(2,2,IRE)) )**2 - PLASQ )
*  |  |  +-------------------------------------------------------------*
*  |  |  |  Loop on the exit channels
            DO 223 IK=1,IKE
*  |  |  |  IWK index of the sigma (weight) of the IKth exit channel of
*  |  |  |  reaction IRE at energy IE
               IWK=IWKO+IEE*(IK-1)+IE
*  |  |  |  NRK (i,iiki+ik), i=1,2 are the two resonances produced by
*  |  |  |  the exit channel ik of the reaction ire: 0 means no second
*  |  |  |  resonance
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |  Check that cross section is 0 below the computed
*  |  |  |  |  threshold
               IF ( UMOSQ .GE. THRESH (IIKI+IK)**2 ) THEN
                  SIS=SIS+SI(IWK)*SINORC
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
*  |  |  |  |
               ELSE
                  SI(IWK)=0.D+00
               END IF
*  |  |  |  |
*  |  |  |  +----------------------------------------------------------*
  223       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
            SIIN(IEO+IE-1)=SIS
            SIO=0.D+00
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            IF (SIS.LE.ANGLGB) THEN
               SIS=1.D+00
               SIO=1.D+00
            END IF
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            DO 224 IK=1,IKE
               IWK=IWKO+IEE*(IK-1)+IE
               SIO=SIO+SI(IWK)/SIS*SINORC
               HWK(IK)=SIO
  224       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
*  |  |  +-------------------------------------------------------------*
*  |  |  |
            DO 225 IK=1,IKE
               IWK=IWKO+IEE*(IK-1)+IE
               WK(IWK)=HWK(IK)
  225       CONTINUE
*  |  |  |
*  |  |  +-------------------------------------------------------------*
  221    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
  222 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      DO 3 J=1,460
         HWT(J)=0.D+00
    3 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      DO 1 I=1,110
         IK1=K1(I)
         IK2=K2(I)
         HV=0.D+00
         DO 2 J=IK1,IK2
            HV=HV+WT(J)
            HWT(J)=HV
            JI=J
    2    CONTINUE
         IF (ABS(HV-1.D0).GT.1.D-4)WRITE(LUNOUT,101)
  101    FORMAT(44H ERROR IN HWT BECAUSE OF FALSE USE OF RCHANW)
    1 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      DO 4 J=1,460
         WT(J)=HWT(J)
    4 CONTINUE
*  |
*  +-------------------------------------------------------------------*
* Set a flag for hadrin that elastic collisions must be reduced
* because they will occur inside nuclei
      IELFLG = -1
      ICXFLG = -1
      RETURN
      END
+DECK,  ROTAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE ROTAT.FOR
*COPY ROTAT
*=== rotat ============================================================*
      SUBROUTINE ROTAT(PX,PY,PZ,PXN,PYN,PZN,COTE,SITE,COPS,SIPS)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      PXN=-PX*SIPS-PY*COTE*COPS+PZ*SITE*COPS
      PYN=PX*COPS-PY*COTE*SIPS+PZ*SITE*SIPS
      PZN=PY*SITE+PZ*COTE
      RETURN
      END
+DECK,  SAMCST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE SAMCST.FOR
*COPY SAMCST
*=== samcst ===========================================================*
C
C*******************************************************************
C
      SUBROUTINE SAMCST(KPROJ,EKIN,CST)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C
C  HJM 24/10/88
C
C                 SAMPLING OF COS(THETA)
C                 FOR NUCLEON-PROTON ELASTIC SCATTERING
C                 ACCORDING TO HETKFA2/BERTINI PARAMETRIZATION
C
C-------------------------------------------------------------------
C
      DIMENSION DCLIN(195),DCHN(143),DCHNA(36),DCHNB(60)
      DIMENSION PDCI(60),PDCH(55)
      REAL RNDM(4)
      SAVE DCLIN, DCHN, DCHNA, DCHNB, PDCI, PDCH
C
      DATA (DCLIN(I),I=1,80) /
C***     DCLN ARRAY
     *     5.000D-01,  1.000D+00,  0.000D+00,  1.000D+00,  0.000D+00,
     *     4.993D-01,  9.881D-01,  5.963D-02,  9.851D-01,  5.945D-02,
     *     4.936D-01,  8.955D-01,  5.224D-01,  8.727D-01,  5.091D-01,
     *     4.889D-01,  8.228D-01,  8.859D-01,  7.871D-01,  8.518D-01,
     *     4.874D-01,  7.580D-01,  1.210D+00,  7.207D-01,  1.117D+00,
     *     4.912D-01,  6.969D-01,  1.516D+00,  6.728D-01,  1.309D+00,
     *     5.075D-01,  6.471D-01,  1.765D+00,  6.667D-01,  1.333D+00,
     *     5.383D-01,  6.054D-01,  1.973D+00,  7.059D-01,  1.176D+00,
     *     5.397D-01,  5.990D-01,  2.005D+00,  7.023D-01,  1.191D+00,
     *     5.336D-01,  6.083D-01,  1.958D+00,  6.959D-01,  1.216D+00,
     *     5.317D-01,  6.075D-01,  1.962D+00,  6.897D-01,  1.241D+00,
     *     5.300D-01,  6.016D-01,  1.992D+00,  6.786D-01,  1.286D+00,
     *     5.281D-01,  6.063D-01,  1.969D+00,  6.786D-01,  1.286D+00,
     *     5.280D-01,  5.960D-01,  2.020D+00,  6.667D-01,  1.333D+00,
     *     5.273D-01,  5.920D-01,  2.040D+00,  6.604D-01,  1.358D+00,
     *     5.273D-01,  5.862D-01,  2.069D+00,  6.538D-01,  1.385D+00/
      DATA (DCLIN(I),I=81,160) /
C***     DCIN ARRAY
     *     5.223D-01,  5.980D-01,  2.814D+00,  6.538D-01,  1.385D+00,
     *     5.202D-01,  5.969D-01,  2.822D+00,  6.471D-01,  1.412D+00,
     *     5.183D-01,  5.881D-01,  2.883D+00,  6.327D-01,  1.469D+00,
     *     5.159D-01,  5.866D-01,  2.894D+00,  6.250D-01,  1.500D+00,
     *     5.133D-01,  5.850D-01,  2.905D+00,  6.170D-01,  1.532D+00,
     *     5.106D-01,  5.833D-01,  2.917D+00,  6.087D-01,  1.565D+00,
     *     5.084D-01,  5.801D-01,  2.939D+00,  6.000D-01,  1.600D+00,
     *     5.063D-01,  5.763D-01,  2.966D+00,  5.909D-01,  1.636D+00,
     *     5.036D-01,  5.730D-01,  2.989D+00,  5.814D-01,  1.674D+00,
     *     5.014D-01,  5.683D-01,  3.022D+00,  5.714D-01,  1.714D+00,
     *     4.986D-01,  5.641D-01,  3.051D+00,  5.610D-01,  1.756D+00,
     *     4.964D-01,  5.580D-01,  3.094D+00,  5.500D-01,  1.800D+00,
     *     4.936D-01,  5.573D-01,  3.099D+00,  5.431D-01,  1.827D+00,
     *     4.909D-01,  5.509D-01,  3.144D+00,  5.313D-01,  1.875D+00,
     *     4.885D-01,  5.512D-01,  3.142D+00,  5.263D-01,  1.895D+00,
     *     4.857D-01,  5.437D-01,  3.194D+00,  5.135D-01,  1.946D+00/
      DATA (DCLIN(I),I=161,195) /
     *     4.830D-01,  5.353D-01,  3.253D+00,  5.000D-01,  2.000D+00,
     *     4.801D-01,  5.323D-01,  3.274D+00,  4.915D-01,  2.034D+00,
     *     4.770D-01,  5.228D-01,  3.341D+00,  4.767D-01,  2.093D+00,
     *     4.738D-01,  5.156D-01,  3.391D+00,  4.643D-01,  2.143D+00,
     *     4.701D-01,  5.010D-01,  3.493D+00,  4.444D-01,  2.222D+00,
     *     4.672D-01,  4.990D-01,  3.507D+00,  4.375D-01,  2.250D+00,
     *     4.634D-01,  4.856D-01,  3.601D+00,  4.194D-01,  2.323D+00/
C
      DATA PDCI /
     *     4.400D+02,  1.896D-01,  1.931D-01,  1.982D-01,  1.015D-01,
     *     1.029D-01,  4.180D-02,  4.228D-02,  4.282D-02,  4.350D-02,
     *     2.204D-02,  2.236D-02,  5.900D+02,  1.433D-01,  1.555D-01,
     *     1.774D-01,  1.000D-01,  1.128D-01,  5.132D-02,  5.600D-02,
     *     6.158D-02,  6.796D-02,  3.660D-02,  3.820D-02,  6.500D+02,
     *     1.192D-01,  1.334D-01,  1.620D-01,  9.527D-02,  1.141D-01,
     *     5.283D-02,  5.952D-02,  6.765D-02,  7.878D-02,  4.796D-02,
     *     6.957D-02,  8.000D+02,  4.872D-02,  6.694D-02,  1.152D-01,
     *     9.348D-02,  1.368D-01,  6.912D-02,  7.953D-02,  9.577D-02,
     *     1.222D-01,  7.755D-02,  9.525D-02,  1.000D+03,  3.997D-02,
     *     5.456D-02,  9.804D-02,  8.084D-02,  1.208D-01,  6.520D-02,
     *     8.233D-02,  1.084D-01,  1.474D-01,  9.328D-02,  1.093D-01/
C
      DATA PDCH /
     *     1.000D+03,  9.453D-02,  9.804D-02,  8.084D-02,  1.208D-01,
     *     6.520D-02,  8.233D-02,  1.084D-01,  1.474D-01,  9.328D-02,
     *     1.093D-01,  1.400D+03,  1.072D-01,  7.450D-02,  6.645D-02,
     *     1.136D-01,  6.750D-02,  8.580D-02,  1.110D-01,  1.530D-01,
     *     1.010D-01,  1.350D-01,  2.170D+03,  4.004D-02,  3.013D-02,
     *     2.664D-02,  5.511D-02,  4.240D-02,  7.660D-02,  1.364D-01,
     *     2.300D-01,  1.670D-01,  2.010D-01,  2.900D+03,  1.870D-02,
     *     1.804D-02,  1.320D-02,  2.970D-02,  2.860D-02,  5.160D-02,
     *     1.020D-01,  2.400D-01,  2.250D-01,  3.370D-01,  4.400D+03,
     *     1.196D-03,  8.784D-03,  1.517D-02,  2.874D-02,  2.488D-02,
     *     4.464D-02,  8.330D-02,  2.008D-01,  2.360D-01,  3.567D-01/
C
      DATA (DCHN(I),I=1,90) /
     *     4.770D-01,  4.750D-01,  4.715D-01,  4.685D-01,  4.650D-01,
     *     4.610D-01,  4.570D-01,  4.550D-01,  4.500D-01,  4.450D-01,
     *     4.405D-01,  4.350D-01,  4.300D-01,  4.250D-01,  4.200D-01,
     *     4.130D-01,  4.060D-01,  4.000D-01,  3.915D-01,  3.840D-01,
     *     3.760D-01,  3.675D-01,  3.580D-01,  3.500D-01,  3.400D-01,
     *     3.300D-01,  3.200D-01,  3.100D-01,  3.000D-01,  2.900D-01,
     *     2.800D-01,  2.700D-01,  2.600D-01,  2.500D-01,  2.400D-01,
     *     2.315D-01,  2.240D-01,  2.150D-01,  2.060D-01,  2.000D-01,
     *     1.915D-01,  1.850D-01,  1.780D-01,  1.720D-01,  1.660D-01,
     *     1.600D-01,  1.550D-01,  1.500D-01,  1.450D-01,  1.400D-01,
     *     1.360D-01,  1.320D-01,  1.280D-01,  1.250D-01,  1.210D-01,
     *     1.180D-01,  1.150D-01,  1.120D-01,  1.100D-01,  1.070D-01,
     *     1.050D-01,  1.030D-01,  1.010D-01,  9.900D-02,  9.700D-02,
     *     9.550D-02,  9.480D-02,  9.400D-02,  9.200D-02,  9.150D-02,
     *     9.100D-02,  9.000D-02,  8.990D-02,  8.900D-02,  8.850D-02,
     *     8.750D-02,  8.700D-02,  8.650D-02,  8.550D-02,  8.500D-02,
     *     8.499D-02,  8.450D-02,  8.350D-02,  8.300D-02,  8.250D-02,
     *     8.150D-02,  8.100D-02,  8.030D-02,  8.000D-02,  7.990D-02/
      DATA (DCHN(I),I=91,143) /
     *     7.980D-02,  7.950D-02,  7.900D-02,  7.860D-02,  7.800D-02,
     *     7.750D-02,  7.650D-02,  7.620D-02,  7.600D-02,  7.550D-02,
     *     7.530D-02,  7.500D-02,  7.499D-02,  7.498D-02,  7.480D-02,
     *     7.450D-02,  7.400D-02,  7.350D-02,  7.300D-02,  7.250D-02,
     *     7.230D-02,  7.200D-02,  7.100D-02,  7.050D-02,  7.020D-02,
     *     7.000D-02,  6.999D-02,  6.995D-02,  6.993D-02,  6.991D-02,
     *     6.990D-02,  6.870D-02,  6.850D-02,  6.800D-02,  6.780D-02,
     *     6.750D-02,  6.700D-02,  6.650D-02,  6.630D-02,  6.600D-02,
     *     6.550D-02,  6.525D-02,  6.510D-02,  6.500D-02,  6.499D-02,
     *     6.498D-02,  6.496D-02,  6.494D-02,  6.493D-02,  6.490D-02,
     *     6.488D-02,  6.485D-02,  6.480D-02/
C
      DATA DCHNA /
     *     6.300D+02,  7.810D-02,  1.421D-01,  1.979D-01,  2.479D-01,
     *     3.360D-01,  5.400D-01,  7.236D-01,  1.000D+00,  1.540D+03,
     *     2.225D-01,  3.950D-01,  5.279D-01,  6.298D-01,  7.718D-01,
     *     9.405D-01,  9.835D-01,  1.000D+00,  2.560D+03,  2.625D-01,
     *     4.550D-01,  5.963D-01,  7.020D-01,  8.380D-01,  9.603D-01,
     *     9.903D-01,  1.000D+00,  3.520D+03,  4.250D-01,  6.875D-01,
     *     8.363D-01,  9.163D-01,  9.828D-01,  1.000D+00,  1.000D+00,
     *     1.000D+00/
C
      DATA DCHNB /
     *     6.300D+02,  3.800D-02,  7.164D-02,  1.275D-01,  2.171D-01,
     *     3.227D-01,  4.091D-01,  5.051D-01,  6.061D-01,  7.074D-01,
     *     8.434D-01,  1.000D+00,  2.040D+03,  1.200D-01,  2.115D-01,
     *     3.395D-01,  5.295D-01,  7.251D-01,  8.511D-01,  9.487D-01,
     *     9.987D-01,  1.000D+00,  1.000D+00,  1.000D+00,  2.200D+03,
     *     1.344D-01,  2.324D-01,  3.754D-01,  5.674D-01,  7.624D-01,
     *     8.896D-01,  9.808D-01,  1.000D+00,  1.000D+00,  1.000D+00,
     *     1.000D+00,  2.850D+03,  2.330D-01,  4.130D-01,  6.610D-01,
     *     9.010D-01,  9.970D-01,  1.000D+00,  1.000D+00,  1.000D+00,
     *     1.000D+00,  1.000D+00,  1.000D+00,  3.500D+03,  3.300D-01,
     *     5.450D-01,  7.950D-01,  1.000D+00,  1.000D+00,  1.000D+00,
     *     1.000D+00,  1.000D+00,  1.000D+00,  1.000D+00,  1.000D+00/
C
C---------------------------------------------------------------
        CST=1.0D+0
C
C*      IS THE KINETIC ENERGY GREATER THAN LIMIT ?
C
        IF (EKIN .GT. 3.5D0) RETURN
C
        IF(KPROJ.EQ.8) GOTO 101
        IF(KPROJ.EQ.1) GOTO 102
C*                                INVALID REACTION
        RETURN
C-------------------------------- NP ELASTIC SCATTERING----------
101   CONTINUE
      IF (EKIN.GT.0.740D+0)GOTO 1000
      IF (EKIN.LT.0.300D+0)THEN
C                                 EKIN .LT. 300 MEV
         IDAT=1
      ELSE
C                                 300 MEV < EKIN < 740 MEV
         IDAT=6
      END IF
C
      ENER=EKIN
      IE=ABS(ENER/0.020D+0)
      UNIV=(ENER-IE*0.020D+0)/0.020D+0
C                                            FORWARD/BACKWARD DECISION
      K=IDAT+5*IE
      BWFW=(DCLIN(K+5)-DCLIN(K))*UNIV + DCLIN(K)
      CALL GRNDM(RNDM,1)
      RND=RNDM(1)
      IF (RND.LT.BWFW)THEN
         VALUE2=-1.0D+0
         K=K+1
      ELSE
         VALUE2=1.0D+0
         K=K+3
      END IF
C
      COEF=(DCLIN(K+5)-DCLIN(K))*UNIV + DCLIN(K)
      CALL GRNDM(RNDM,1)
      RND=RNDM(1)
C
      IF(RND.LT.COEF)THEN
         CALL GRNDM(RNDM,1)
         CST=RNDM(1)
         CST=CST*VALUE2
      ELSE
         CALL GRNDM(RNDM,4)
         R1=RNDM(1)
         R2=RNDM(2)
         R3=RNDM(3)
         R4=RNDM(4)
C
         IF(VALUE2.GT.0.D0)THEN
            CST=MAX(R1,R2,R3,R4)
            GOTO 1500
         ELSE
            CALL GRNDM(RNDM,1)
            R5=RNDM(1)
C
            IF (IDAT.EQ.1)THEN
               CST=-MAX(R1,R2,R3,R4,R5)
            ELSE
               CALL GRNDM(RNDM,2)
               R6=RNDM(1)
               R7=RNDM(2)
               CST=-MAX(R1,R2,R3,R4,R5,R6,R7)
            END IF
C
         END IF
C
      END IF
C
      GOTO 1500
C
C********                                EKIN  .GT.  0.74 GEV
C
1000  CONTINUE
      ENER=EKIN - 0.66D0
C     IE=ABS(ENER/0.02D0)
      IE=ENER/0.02D0
      EMEV=EKIN*1.D+03
C
      UNIV=(ENER-IE*0.020D+0)/0.020D+0
      K=IE
      BWFW=(DCHN(K+1)-DCHN(K))*UNIV + DCHN(K)
      CALL GRNDM(RNDM,1)
      RND=RNDM(1)
C                                        FORWARD NEUTRON
      IF (RND.GE.BWFW)THEN
         DO 1200 K=10,36,9
           IF (DCHNA(K).GT.EMEV) THEN
              UNIVE=(EMEV-DCHNA(K-9))/(DCHNA(K)-DCHNA(K-9))
              CALL GRNDM(RNDM,1)
              UNIV=RNDM(1)
              DO 1100 I=1,8
                 II=K+I
                 P=(DCHNA(II)-DCHNA(II-9))*UNIVE + DCHNA(II-9)
C
                 IF (P.GT.UNIV)THEN
                    CALL GRNDM(RNDM,1)
                    UNIV=RNDM(1)
                    FLTI=I-UNIV
                    GOTO(290,290,290,290,330,340,350,360) I
                 END IF
 1100         CONTINUE
           END IF
 1200    CONTINUE
C
      ELSE
C                                        BACKWARD NEUTRON
         DO 1400 K=13,60,12
            IF (DCHNB(K).GT.EMEV) THEN
               UNIVE=(EMEV-DCHNB(K-12))/(DCHNB(K)-DCHNB(K-12))
               CALL GRNDM(RNDM,1)
               UNIV=RNDM(1)
               DO 1300 I=1,11
                 II=K+I
                 P=(DCHNB(II)-DCHNB(II-12))*UNIVE + DCHNB(II-12)
C
                 IF (P.GT.UNIV)THEN
                   CALL GRNDM(RNDM,1)
                   UNIV=RNDM(1)
                   FLTI=I-UNIV
                   GOTO(120,120,140,150,160,160,180,190,200,210,220) I
                 END IF
 1300          CONTINUE
            END IF
 1400    CONTINUE
      END IF
C
120   CST=1.0D-2*FLTI-1.0D+0
      GOTO 1500
140   CST=2.0D-2*UNIV-0.98D+0
      GOTO 1500
150   CST=4.0D-2*UNIV-0.96D+0
      GOTO 1500
160   CST=6.0D-2*FLTI-1.16D+0
      GOTO 1500
180   CST=8.0D-2*UNIV-0.80D+0
      GOTO 1500
190   CST=1.0D-1*UNIV-0.72D+0
      GOTO 1500
200   CST=1.2D-1*UNIV-0.62D+0
      GOTO 1500
210   CST=2.0D-1*UNIV-0.50D+0
      GOTO 1500
220   CST=3.0D-1*(UNIV-1.0D+0)
      GOTO 1500
C
290   CST=1.0D0 - 2.5D-2*FLTI
      GOTO 1500
330   CST=0.85D0 + 0.5D-1*UNIV
      GOTO 1500
340   CST=0.70D0 + 1.5D-1*UNIV
      GOTO 1500
350   CST=0.50D0 + 2.0D-1*UNIV
      GOTO 1500
360   CST=0.50D0*UNIV
C
1500  RETURN
C
C-----------------------------------  PP ELASTIC SCATTERING -------
C
 102  CONTINUE
      EMEV=EKIN*1.D+03
C
      IF (EKIN.LE.0.500D0) THEN
         CALL GRNDM(RNDM,1)
         RND=RNDM(1)
         CST=2.0D0*RND-1.0D0
         RETURN
C
      ELSE IF (EKIN.LT.1.D0) THEN
         DO 2200 K=13,60,12
            IF (PDCI(K).GT.EMEV) THEN
               UNIVE=(EMEV-PDCI(K-12))/(PDCI(K)-PDCI(K-12))
               CALL GRNDM(RNDM,1)
               UNIV=RNDM(1)
               SUM=0.0D0
               DO 2100 I=1,11
                 II=K+I
                 SUM=SUM + (PDCI(II)-PDCI(II-12))*UNIVE + PDCI(II-12)
C
                 IF (UNIV.LT.SUM)THEN
                   CALL GRNDM(RNDM,1)
                   UNIV=RNDM(1)
                   FLTI=I-UNIV
                   GOTO(55,55,55,60,60,65,65,65,65,70,70) I
                 END IF
 2100          CONTINUE
            END IF
 2200    CONTINUE
      ELSE
         DO 2400 K=12,55,11
            IF (PDCH(K).GT.EMEV) THEN
              UNIVE=(EMEV-PDCH(K-11))/(PDCH(K)-PDCH(K-11))
              CALL GRNDM(RNDM,1)
              UNIV=RNDM(1)
              SUM=0.D0
              DO 2300 I=1,10
                II=K+I
                SUM=SUM + (PDCH(II)-PDCH(II-11))*UNIVE + PDCH(II-11)
C
                IF (UNIV.LT.SUM)THEN
                  CALL GRNDM(RNDM,1)
                  UNIV=RNDM(1)
                  FLTI=UNIV+I
                  GOTO(50,55,60,60,65,65,65,65,70,70) I
                END IF
 2300         CONTINUE
            END IF
 2400    CONTINUE
      END IF
C
50    CST=0.4D0*UNIV
      GOTO 2500
55    CST=0.2D0*FLTI
      GOTO 2500
60    CST=0.3D0 + 0.1D0*FLTI
      GOTO 2500
65    CST=0.6D0 + 0.04D0*FLTI
      GOTO 2500
70    CST=0.78D0 + 0.02D0*FLTI
C
2500  CONTINUE
      CALL GRNDM(RNDM,1)
      RND=RNDM(1)
      IF (RND.GT.0.5D+00)CST=-CST
C
      RETURN
      END
+DECK,  SFECFE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE SFECFE.FOR
*COPY SFECFE
*=== sfecfe ===========================================================*
      SUBROUTINE SFECFE(SFE,CFE)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(2)
      ENTRY         COSI(SFE,CFE)
C********************************************************************
C     VERSION JUNE 81 BY             PERTTI AARNIO
C     LAST CHANGE 11. DECEMBER 85 BY PERTTI AARNIO
C                                    HELSINKI UNIVERSITY OF
C                                    TECHNOLOGY, FINLAND
C
C
C     SUBROUTINE OF FLUKA TO GIVE SINE AND COSINE OF AN
C     RANDOM ANGLE UNIFORMLY DISTRIBUTED BETWEEN 0 AND 2*PI
C********************************************************************
C
 10   CALL GRNDM(RNDM,2)
      X=2.D0*RNDM(1)-1.D0
      Y=RNDM(2)
      X2=X*X
      Y2=Y*Y
      IF (X2+Y2.GT.1.D0) GO TO 10
      CFE=(X2-Y2)/(X2+Y2)
      SFE=2.D0*X*Y/(X2+Y2)
      RETURN
      END
+DECK,  SHPTOT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE SHPTOT.FOR
*COPY SHPTOT
*=== shptot ===========================================================*
      FUNCTION SHPTOT(IT,PO)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C   LAST CHANGE 25.11 -86 BY PERTTI AARNIO
C
C
C   TOTAL HADRON-PROTON CROSS SECTIONS
C   PLAB.GE.10 GEV
C
C********************************************************************
+CDE, PAPROP.
      REAL RNDM(1)
C
      F1=1.D0
      ITT=IT
      AMIT2=AM(ITT)**2
      UMO2=AMIT2 + AM(1)**2 + 2.D0*AM(1)*(PO+0.5D0*AMIT2/PO)
      UMO=SQRT(UMO2)
C
      A4=0.D0
      A5=0.D0
      A6=0.D0
C
      GO TO
     * (1,1,50,50,50,50,50,2,2,50,50,5,3,3,4,4,8,8,5,8,8,8,50,6,7,
     *  1,1,1,1,1,1,1,1,1,1,1,1,1,1), ITT
C
 1    CONTINUE
      A1=38.4D0
      A2=0.46D0
      A3=125.D0
      IF(ITT.EQ.1) GOTO 100
      A5=84.1D0
      A6=0.43D0
      GOTO 100
C
 2    CONTINUE
      A1=38.5D0
      A2=0.46D0
      A3=125.D0
      A4=15.D0
      IF(ITT.EQ.8) GOTO 100
      A5=77.43D0
      A6=0.40D0
      GOTO 100
C
 3    CONTINUE
      IF(UMO.LT.47.D0) GOTO 31
      F1=0.6667D0
      ITT=1
      GOTO 1
 31   CONTINUE
      A1=24.D0
      A2=0.60D0
      A3=160.D0
*   Very very crude patch for the pion- elastic xsec problem
*     IF(ITT.EQ.13) GOTO 100
      IF(ITT.EQ.13.OR.ITT.EQ.14) GOTO 100
      A5=7.9D0
      A6=0.54D0
      GOTO 100
C
 4    CONTINUE
      IF(UMO.LT.110.D0) GOTO 41
      F1=0.6667D0
      ITT=1
      GOTO 1
 41   CONTINUE
      A1=20.3D0
      A2=0.59D0
      A3=140.D0
      IF(ITT.EQ.15) GOTO 100
      A5=30.13D0
      A6=0.42D0
      GOTO 100
C
 5    CONTINUE
      ITT=15
      CALL GRNDM(RNDM,1)
      IF(RNDM(1).LT.0.5D0) ITT=16
      GOTO 4
C
 6    CONTINUE
C***
C   K-ZERO:  SET EQUAL TO K-/PROTON
C            (SHOULD BE K-/NEUTRON)
C***
      ITT=16
      GOTO 4
C
 7    CONTINUE
C***
C   K-ZERO BAR:  SET EQUAL TO K+/PROTON
C                (SHOULD BE K+/NEUTRON)
C***
      ITT=15
      GOTO 4
C
 8    CONTINUE
C***
C   SIGMA +/-/0  AND  LAMBDA/LAMBDA BAR:  SET EQUAL TO P-P
C***
      ITT=1
      GOTO 1
C
 50   CONTINUE
C***
C   LEPTONS AND PI0
C***
      SHPTOT=1.D-10
      RETURN
C
 100  CONTINUE
C
      SHPTOT=A1+A2*(LOG(UMO2/A3))**2+A4/UMO2+A5*UMO2**A6
      SHPTOT=F1*SHPTOT
      RETURN
      END
+DECK,  SIGEL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE SIGEL.FOR
*COPY SIGEL
*=== sigel ============================================================*
      SUBROUTINE SIGEL ( IT, AA, EKIN, POO, SEL, ZL )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C
C     Slightly changed on 11 february 1991  by  Alfredo Ferrari
C     (The kinetic energy has been added to the input variables,
C      a check is made on the minimum kinetic energy to have a
C      an elastic scattering with the present coding, sigmabar,
C      xsi, xsibar, omega, omegabar have been added with very
C      rough correspondence to the existing particles)
C
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C     LAST CHANGE 18. JULY 92 BY     A. FERRARI
C                                    INFN - MILAN
C
C
C     THIS IS A SUBROUTINE OF FLUKA82 TO GIVE ELASTIC SCATTERING
C     LENGTH AND CROSS SECTION
C
C     INPUT VARIABLES:
C     IT     = PARTICLE TYPE
C     AA     = ATOMIC WEIGHT OF THE NUCLEUS
C     EKIN   = PARTICLE KINETIC ENERGY
C     POO    = PARTICLE MOMENTUM IN GEV/C
C
C     OUTPUT VARIABLES:
C     SEL    = ELASTIC CROSS SECTION IN MB
C     ZL     = INTERACTION LENGTH IN G/CM**2
C
C     OTHER IMPORTANT VARIABLES:
C        SIG    = PROTON/NUCLEI CROSS SECTIONS
C        SEG    = PION/NUCLEI CROSS SECTIONS
C        P      = MOMENTUMS FOR WHICH THE CROSS SECTIONS ARE GIVEN IN
C                 SIG AND SEG
C        A      = NUCLEI FOR WHICH THE CROSS SECTIONS ARE GIVEN IN
C                 SIG AND SEG
C        PLAB   = MOMENTUMS FOR WHICH THE TOTAL CROSS SECTIONS ARE
C                 GIVEN IN SITO
C        SITO   = TOTAL HADRON NUCLEON CROSS SECTIONS FOR NUCLEONS,
C                 PIONS, KAONS AND ANTI-NUCLEONS.
C        ALP    =  EXPONENT OF THE PARAMETRIZATION FOR ANTI-PROTONS,
C                  RANTI-NEUTRONS AND KAONS
C        BET    =  MULTIPLIER OF PARAMETRIZATION FOR ANTI-PROTONS,
C                  ANTI-NEUTRONS AND KAONS
C
C     NOTE1: PRESENTLY CROSS SECTIONS ARE ASSUMED TO BE CONSTANT
C     ABOVE 10.0 GEV/C FOR ALL PARTICLES AND
C     BELOW 0.3 GEV/C FOR NUCLEONS AND BELOW 0.13 GEV/C FOR PIONS
C
C     NOTE2: FOR HADRONS OTHER THAN (1=PROTON,2=ANTI PROTON,8=
C     NEUTRON,9=ANTI NEUTRON,13=POSITIVE PION,14=NEGATIVE PION,15=
C     POSITIVE KAON,16=NEGATIVE KAON,24=NEUTRAL KAON,25=NEUTRAL ANTI
C     KAON) SEE TABLE ITT TO SEE THE CORRESPONDANCE
C
C     NOTE3: FOR LEPTONS AND PHOTONS PRACTICALLY ZERO CROSS SECTION
C     IS RETURNED.
C
C********************************************************************
C
+CDE, PAPROP.
      PARAMETER (AVOGMB=AVOGAD*1.D-27)
C--------------------------------------------------------------------
      DIMENSION SIG(13,9),SEG(16,9),P(16),A(9),ITT(39)
      DIMENSION PLAB(19),SITO(19,4),ALP(3),BET(3)
      DIMENSION REA(9,9),STOT(9)
      SAVE A, P, SIG, SEG, ITT, SITO, PLAB, ALP, BET, STOT, REA
      DATA A/9.D0,12.D0,27.D0,47.9D0,55.9D0,63.5D0,112.4D0,
     &207.2D0,238.1D0/
      DATA P/.13D0,.19D0,.25D0,.3D0,.4D0,.5D0,.6D0,.8D0,1.D0,
     &1.5D0,2.D0,3.D0,4.D0,5.D0,6.D0,10.D0/
      DATA SIG/ 485.D0,223.D0,112.D0,82.D0,66.D0,78.D0,96.D0,102.D0,
     &100.D0,98.D0,95.D0,90.D0,79.D0,
     (680.D0,348.D0,175.D0,103.D0,84.D0,87.D0,106.D0,112.D0,111.D0,
     &108.D0,107.D0,105.D0,101.D0,
     (1200.D0,738.D0,387.D0,196.D0,191.D0,200.D0,248.D0,264.D0,
     &264.D0,257.D0,252.D0,247.D0,228.D0,
     (1658.D0,1110.D0,635.D0,364.D0,332.D0,356.D0,404.D0,408.D0,
     &407.D0,404.D0,398.D0,396.D0,384.D0,
     (1730.D0,1270.D0,725.D0,400.D0,375.D0,412.D0,495.D0,505.D0,
     &495.D0,492.D0,487.D0,485.D0,475.D0,
     (1875.D0,1470.D0,835.D0,480.D0,450.D0,450.D0,535.D0,
     &580.D0,555.D0,540.D0,535.D0,530.D0,
     (525.D0,2040.D0,2160.D0,1335.D0,850.D0,740.D0,760.D0,880.D0,
     &905.D0,860.D0,840.D0,820.D0,815.D0,800.D0,
     (2340.D0,2980.D0,2270.D0,1450.D0,1230.D0,1230.D0,
     &1380.D0,1420.D0,1410.D0,1380.D0,1360.D0,
     (1350.D0,1320.D0,2680.D0,3220.D0,2530.D0,1630.D0,1420.D0,1450.D0,
     &1570.D0,1600.D0,1590.D0,1575.D0,1560.D0,1550.D0,1540.D0/
      DATA SEG/24.D0,128.D0,249.D0,256.D0,202.D0,124.D0,73.D0,60.D0,
     &64.D0,69.D0,62.D0,50.D0,44.D0,42.D0,42.D0,41.D0,21.D0,156.D0,
     (273.D0,280.D0,220.D0,212.D0,94.D0,80.D0,82.D0,85.D0,80.D0,73.D0,
     (69.D0,67.D0,66.D0,64.D0,56.D0,296.D0,560.D0,574.D0,467.D0,350.D0,
     &235.D0,210.D0,210.D0,200.D0,190.D0,183.D0,176.D0,170.D0,165.D0,
     (155.D0,100.D0,500.D0,895.D0,880.D0,690.D0,520.D0,378.D0,
     (355.D0,384.D0,373.D0,352.D0,320.D0,300.D0,288.D0,280.D0,
     &262.D0,75.D0,500.D0,965.D0,990.D0,775.D0,525.D0,410.D0,410.D0,
     (433.D0,440.D0,425.D0,395.D0,374.D0,355.D0,340.D0,303.D0,125.D0,
     (570.D0,1025.D0,1100.D0,825.D0,575.D0,418.D0,458.D0,500.D0,
     &480.D0,460.D0,440.D0,422.D0,400.D0,384.D0,355.D0,300.D0,880.D0,
     (1480.D0,1550.D0,1380.D0,940.D0,710.D0,720.D0,810.D0,760.D0,
     (740.D0,700.D0,665.D0,645.D0,620.D0,570.D0,550.D0,1475.D0,
     &2250.D0,2350.D0,1850.D0,1500.D0,
     (1120.D0,1210.D0,1480.D0,1440.D0,1400.D0,1320.D0,
     &1250.D0,1210.D0,1170.D0,1065.D0,540.D0,
     (1300.D0,2220.D0,2560.D0,1980.D0,1650.D0,1160.D0,
     &1360.D0,1600.D0,1560.D0,1510.D0,1410.D0,
     (1350.D0,1300.D0,1270.D0,1200.D0/
C     DATA ITT/1,7,0,0,0,0,0,2,8,0,0,9,3,4,6,5,1,2,9,1,1,1,3,9,10,
      DATA ITT/1,7,0,0,0,0,0,2,8,0,0,9,3,4,6,5,2,8,9,1,1,2,3,9,10,
     &         3,0,0,0,0,7,2,7,2,8,1,7,1,7/
      DATA PLAB/.3D0,.4D0,.5D0,.6D0,.7D0,.8D0,.9D0,1.D0,1.1D0,
     &1.2D0,1.3D0,1.4D0,1.5D0,2.D0,3.D0,4.D0,
     *5.D0,6.D0,10.D0/
      DATA SITO/66.8D0,63.6D0,40.35D0,31.25D0,31.1D0,
     *35.1D0,36.7D0,44.15D0,38.3D0,33.25D0,
     *29.75D0,29.3D0,29.95D0,26.55D0,24.6D0,22.95D0,
     *22.75D0,22.95D0,21.55D0,
     *12.5D0,14.1D0,13.5D0,12.75D0,12.85D0,13.9D0,15.6D0,
     *17.25D0,18.9D0,19.5D0,18.95D0,18.85D0,
     *18.45D0,18.2D0,17.5D0,17.7D0,17.5D0,17.25D0,17.4D0,
     *39.65D0,38.75D0,26.9D0,22.D0,22.D0,24.5D0,26.15D0,30.7D0,28.6D0,
     &26.4D0,24.35D0,24.1D0,24.2D0
     (,22.4D0,21.05D0,20.3D0,20.1D0,20.1D0,19.5D0,
     (280.D0,199.7D0,171.1D0,154.3D0,140.D0,130.D0,116.8D0,117.4D0,
     &111.6D0,109.D0,106.5D0,
     (102.8D0,100.D0,90.2D0,76.7D0,68.D0,62.8D0,60.7D0,56.D0/
      DATA ALP/0.823D0,0.843D0,0.630D0/
      DATA BET/1.26D0,1.31D0,0.90D0/
      DATA STOT /15.D0,20.D0,30.D0,40.D0,60.D0,80.D0,
     &100.D0,150.D0,200.D0/
      DATA REA / .20D0,.23D0,.27D0,.30D0,.35D0,.40D0,.47D0,.55D0,.60D0,
     2           .22D0,.26D0,.31D0,.35D0,.40D0,.45D0,.51D0,.59D0,.63D0,
     3           .24D0,.29D0,.36D0,.42D0,.50D0,.56D0,.60D0,.66D0,.68D0,
     4           .26D0,.32D0,.42D0,.49D0,.58D0,.63D0,.66D0,.71D0,.72D0,
     5           .27D0,.33D0,.44D0,.51D0,.61D0,.65D0,.68D0,.72D0,.74D0,
     6           .28D0,.35D0,.46D0,.53D0,.63D0,.66D0,.69D0,.73D0,.745D0,
     7           .35D0,.42D0,.53D0,.62D0,.69D0,.72D0,.74D0,.77D0,.78D0,
     8           .42D0,.51D0,.62D0,.69D0,.75D0,.77D0,.79D0,.81D0,.82D0,
     9           .44D0,.53D0,.64D0,.70D0,.76D0,.78D0,.80D0,.81D0,.82D0 /
C
C
C
      SEL = AZRZRZ
      ZL  = AINFNT
      IF(AA.LT.0.99D0)RETURN
      IPOL=0
      PO=POO
      EKE=EKIN
* Set a very large kinetic energy for the call to Nizl to bypass
* any check on inelastic events thresholds
      EKINFN=AINFNT
      IIT=ITT(IT)
      IF (IIT.EQ.0) RETURN
C---------------------------------------------------------
C**                          ELASTIC SCATTERING ON PROTONS
C         HJM 10/88             REASONABLE FOR P, N, PI+/-
C**
      IF((AA.LT.1.5D0).AND. (IT.EQ.1.OR.IT.EQ.8.OR.IT.EQ.13
     *  .OR.IT.EQ.14.OR.IT.EQ.2.OR.IT.EQ.9)) THEN
C**      EKE=SQRT(PO**2+AM(IT)**2) - AM(IT)
* Return if kinetic energy is below 15 MeV (A. Ferrari)
         IF ( EKE .LT. 0.015D+00 ) RETURN
         IF ( IT .EQ. 9 ) THEN
            IJT = 1
         ELSE IF ( IT .EQ. 2 ) THEN
            IJT = 8
         ELSE
            IJT = IT
         END IF
         CALL SIHAEL(IJT,EKE,PO,AA,SEL)
         GOTO 124
      END IF
C**
C                            NEUTRON-NUCLEUS ELASTIC SCATTERING
C                            DATA FROM HETKFA2 FOR  EKIN .GT. 15 MEV
C                            FOR PLOTS SEE
C                               P. CLOTH ET AL.,
C                               HERMES - A MC PROGRAM SYSTEM ...
C                               JUEL-2203 (MAY 1988)
C
*     IF((IT.EQ.8.OR.IT.EQ.1.OR.IT.EQ.2.OR.IT.EQ.9).AND.PO.LT.20.D0)
*    &   THEN
      IF(IT.EQ.8.AND.PO.LT.20.D0)THEN
* Return if kinetic energy is below 15 MeV (A. Ferrari)
         IF ( EKE .LT. 0.015D+00 ) RETURN
         IF ( IT .EQ. 9 ) THEN
            IJT = 1
         ELSE IF ( IT .EQ. 2 ) THEN
            IJT = 8
         ELSE
            IJT = IT
         END IF
         IF(PO.GT.10.D0) THEN
            IPOL=1
            PO=10.D0
            EKE=SQRT(PO**2+AM(IT)**2) - AM(IT)
         END IF
C**      EKE=SQRT(PO**2+AM(IT)**2) - AM(IT)
         CALL SIHAEL(IJT,EKE,PO,AA,SEL)
         IF(IPOL.EQ.1) GOTO 210
         GOTO 124
      ENDIF
      IF ( EKE .LT. 0.020D+00 ) RETURN
C-----------------------------------------------------------
C
C
C********************************************************************
C     CALCULATE THE NEW PARTICLE NUMBER IIT:   1=P,2=N,3=PI+,4=PI-,
C     5=K-,6=K+,7=P BAR,8=N BAR,9=K ZERO ,10=K ZERO BAR
C********************************************************************
C
      IF((IIT.EQ.7).OR.(IIT.EQ.8)) GOTO 200
      IF (PO.GT.20.D0) GOTO 200
      IF(PO.LE.10.D0) GOTO 30
      PO=10.D0
      IPOL=1
 30   CONTINUE
      IF(IIT.LE.4) GO TO 10
C
C********************************************************************
C     MOMENTUM INDEX K FOR KAONS ANTI KAONS AND ANTI NUCLEONS
C********************************************************************
C
      DO 3 K=1,19
      IF(PO.LE.PLAB(K)) GO TO 40
    3 CONTINUE
      K=19
   40 GO TO 7
C
C********************************************************************
C     CALCULATE THE MOMENTUM INDEX K FOR NUCLEONS AND PIONS
C     CALCULATE THE MASS INDEX J OF THE NUCLEUS
C********************************************************************
C
   10 CONTINUE
      DO 22 K=1,16
      IF(PO.LE.P(K)) GO TO 23
   22 CONTINUE
      K=16
   23 CONTINUE
      DO 5 I=2,8
      IF(AA.LE.A(I)) GO TO 6
      GO TO 5
    6 CONTINUE
      J=I-1
      GO TO 7
    5 CONTINUE
      J=8
C
C********************************************************************
C     SELECT THE FORMULEI TO BE USED FOR DIFFERENT PARTICLE TYPES
C********************************************************************
C
    7 CONTINUE
C             P , N ,PI+,PI-,K- ,K+ ,AP ,AN ,K0 ,AK0
      GO TO (101,101,113,113,116,115,102,109,115,116),IIT
C******************** PROTONS,NEUTRONS,OTHERS
  101 K=K-3
      IF(K.LT.1) K=1
      ALOGA=LOG(A(J+1)/A(J))
      AAA=AA/A(J)
      SI1=SIG(K,J)* AAA     **(LOG(SIG(K,J+1)/SIG(K,J))/ALOGA)
      IF(K.EQ.1) GO TO 2000
      KK=K-1
      SI2=SIG(KK,J)* AAA     **(LOG(SIG(KK,J+1)/SIG(KK,J))/ALOGA)
      K=K+3
      KK=KK+3
      SI=SI1+(PO-P(K))*(SI2-SI1)/(P(KK)-P(K))
C
      SEL=SI
C
      GO TO 121
C******************** CHARGED PIONS
  113 CONTINUE
      ALOGA=LOG(A(J+1)/A(J))
      AAA=AA/A(J)
      SI1=SEG(K,J)* AAA     **(LOG(SEG(K,J+1)/SEG(K,J))/ALOGA)
      IF(K.EQ.1) GO TO 2000
      KK=K-1
      SI2=SEG(KK,J)* AAA     **(LOG(SEG(KK,J+1)/SEG(KK,J))/ALOGA)
      SI=SI1+(PO-P(K))*(SI2-SI1)/(P(KK)-P(K))
C
      SEL=SI
C
      GO TO 121
C******************** K-,K ZERO BAR
  116 CONTINUE
      IA=1
      IS=1
      GO TO 122
C******************** K+, K ZERO
  115 CONTINUE
      IA=2
      IS=2
      GO TO 122
C******************** P BAR
  102 CONTINUE
C******************** N BAR
  109 CONTINUE
C
      PO=POO
      GOTO 200
C
C
C********************************************************************
C     KAONS, ANTI KAONS
C********************************************************************
C
  122 KK=K-1
      IF(K.EQ.1) GO TO 140
      PKK=PLAB(KK)
      SIKK=SITO(KK,IS)
      SI=(SITO(K,IS)-SIKK)*(PO-PKK)/(PLAB(K)-PKK)+SIKK
      GO TO 141
  140 SI=SITO(K,IS)
  141 SI1=SI
      SI=BET(IA)*SI*AA**ALP(IA)
      IV=IT
      IF(IV.NE.24)GO TO 150
      IV=15
      SI=SI*2.06D0
      GO TO 151
 150  IF(IV.EQ.25) IV=16
 151  CALL NIZL(IV,AA,EKINFN,PO,SINEL,ZLIN)
C
      SEL=SI-SINEL
      IF(IPOL.EQ.1) GOTO 210
      GOTO 121
C
C********************************************************************
C     AND NOW THE SCATTERING LENGTH IN G/CM**2
C********************************************************************
C
 121  CONTINUE
      IF(IPOL.EQ.1) GOTO 210
 124  CONTINUE
C
      IF (SEL.LT.ANGLGB) THEN
         SEL = AZRZRZ
         ZL  = AINFNT
      ELSE
         ZL=AA/(AVOGMB*SEL)
      END IF
      RETURN
C
C********************************************************************
C     WE ARE IN THE LOWEST MOMENTUM BIN
C********************************************************************
C
 2000 CONTINUE
      SI=SI1
      SEL=SI
      GO TO 121
C***
C   ENTRY FOR SMOOTHING OF SIGEL BETWEEN 10. AND 20. GEV/C
C***
 210  CONTINUE
      PO=20.D0
C***
C   APPROXIMATION FOR HIGH ENERGIES
C***
 200  CONTINUE
C
      IT1=IT
      IF((IT.EQ.2).OR.(IT.EQ.9)) IT1=1
C
      STO=SHPTOT(IT1,PO)
C
C   MASS NUMBER INDEX
C***
      DO 201 IA=2,8
      IF(AA.GT.A(IA)) GOTO 201
      JA=IA-1
      GOTO 202
 201  CONTINUE
      JA=8
 202  CONTINUE
C***
C   SIGTOT INDEX
C***
      DO 203 IS=2,8
      IF(STO.GT.STOT(IS)) GOTO 203
      JS=IS-1
      GOTO 204
 203  CONTINUE
      JS=8
 204  CONTINUE
C
      DA1=A(JA+1)-A(JA)
      DA2=AA - A(JA)
      RR=REA(JS,JA)
      R1=RR + DA2*(REA(JS,JA+1)-RR)/DA1
      RR=REA(JS+1,JA)
      R2=RR + DA2*(REA(JS+1,JA+1)-RR)/DA1
      RACT=R1 + (STO-STOT(JS))*(R2-R1)/(STOT(JS+1)-STOT(JS))
C
      CALL NIZL(IT,AA,EKINFN,PO,SINEL1,ZLIN)
      SEL1=RACT*SINEL1
      IF(IPOL.EQ.1) GOTO 211
      SEL=SEL1
      GOTO 124
C
 211  CONTINUE
      SEL=SEL + (SEL1-SEL)*(POO-10.D0)/10.D0
      GOTO 124
C
C
C********************************************************************
C     FORMATS
C********************************************************************
C
 1000 FORMAT('          WARNING AT CALL SIGEL  ',I5)
      END
+DECK,  SIGINT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== sigint ===========================================================*
      SUBROUTINE SIGINT (IRE ,PLAB,N,IE ,AMT ,AMN,ECM ,SI ,ITAR)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
+CDE, REAC.
+CDE, REDVER.
*
**** *,IEII,IKII,NURE
      COMMON / FKABLT / AM   (110), GA   (110), TAU  (110), ICH   (110),
     &                  IBAR (110), K1   (110), K2   (110)
*
      IE=IEFUN(PLAB,IRE)
      IF (IE.LE.IEII(IRE)) IE=IE+1
      AMT=AM(ITAR)
      AMN=AM(N)
      AMN2=AMN*AMN
      AMT2=AMT*AMT
      ECM=SQRT(AMN2+AMT2+2.D0*AMT*SQRT(AMN2+PLAB**2))
C*** INTERPOLATION PREPARATION
      ECMO=UMO(IE)
      ECM1=UMO(IE-1)
      DECM=ECMO-ECM1
      DEC=ECMO-ECM
      IIKI=IKII(IRE)+1
      EKLIM=-THRESH(IIKI)
      WOK=SIIN(IE)
      WDK=WOK-SIIN(IE-1)
      IF (ECM.GT.ECMO) WDK=0.D0
C*** INTERPOLATION IN CHANNEL WEIGHTS
      IELIM=IEFUN(EKLIM,IRE)
      DELIM=UMO(IELIM)+EKLIM
     *+1.D-16
      DETE=(ECM-(ECMO-EKLIM)*.5D0)*2.D0
      IF (DELIM*DELIM-DETE*DETE) 112,112,113
  113 DECC=DELIM
      GO TO 114
  112 DECC=DECM
  114 CONTINUE
      WKK=WOK-WDK*DEC/(DECC+1.D-9)
      IF (WKK.LT.0.D0) WKK=0.D0
      SI=WKK+1.D-12
      IF (-EKLIM.GT.ECM) SI=1.D-14
      RETURN
      END
+SELF.
+DECK,  SIHAEL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:05  cernlib
* Geant

*$ CREATE SIHAEL.FOR
*COPY SIHAEL
*                                                                      *
*=== sihael ===========================================================*
*                                                                      *
      SUBROUTINE SIHAEL(KPROJ,EKIN,PLAB,ANUC,SIGELA)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C***
C        HJM 22/10/88
C
C        CROSS SECTIONS FOR ELASTIC SCATTERING
C
C        INCLUDING - PION/NUCLEON PROTON DATA FROM BERTINI (HETKFA2)
C
C                  - ...  HIGH-ENERGY APPROXIMATION:
C                                       SIGEL/SIGTOT = CONST
C
C                  - NUCLEON-NUCLEUS DATA FROM HETKFA2
C***
      PARAMETER (NEN=106)
      PARAMETER (NEA=23)
      PARAMETER (NNAA=10)
      DIMENSION EKIHN(NEN),EKIHA(NEA),AMASS(NNAA)
      DIMENSION SEPIMP(NEN),SEPIPP(NEN),SEPP(NEN),SENP(NEN)
      DIMENSION SENA(NEA,NNAA),SEPA(NEA,NNAA)
      DIMENSION TSIG(2)
      DIMENSION RELTO(14)
C
+CDE, PAPROP.
C***
C   KINETIC ENERGIES FOR TABLE LOOK-UP

      DATA EKIHN /
     &   0.00D0, 0.02D0, 0.04D0, 0.06D0, 0.08D0, 0.10D0, 0.12D0, 0.14D0,
     &   0.16D0, 0.18D0, 0.20D0, 0.22D0, 0.24D0, 0.26D0, 0.28D0, 0.30D0,
     &   0.32D0, 0.34D0, 0.36D0, 0.38D0, 0.40D0, 0.42D0, 0.44D0, 0.46D0,
     &   0.48D0, 0.50D0, 0.52D0, 0.54D0, 0.56D0, 0.58D0, 0.60D0, 0.62D0,
     &   0.64D0, 0.66D0, 0.68D0, 0.70D0, 0.72D0, 0.74D0, 0.76D0, 0.78D0,
     &   0.80D0, 0.82D0, 0.84D0, 0.86D0, 0.88D0, 0.90D0, 0.92D0, 0.94D0,
     &   0.96D0, 0.98D0, 1.00D0, 1.02D0, 1.04D0, 1.06D0, 1.08D0, 1.10D0,
     &   1.12D0, 1.14D0, 1.16D0, 1.18D0, 1.20D0, 1.22D0, 1.24D0, 1.26D0,
     &   1.28D0, 1.30D0, 1.32D0, 1.34D0, 1.36D0, 1.38D0, 1.40D0, 1.42D0,
     &   1.44D0, 1.46D0, 1.48D0, 1.50D0, 1.52D0, 1.54D0, 1.56D0, 1.58D0,
     &   1.60D0, 1.62D0, 1.64D0, 1.66D0, 1.68D0, 1.70D0, 1.72D0, 1.74D0,
     &   1.76D0, 1.78D0, 1.80D0, 1.82D0, 1.84D0, 1.86D0, 1.88D0, 1.90D0,
     &   1.92D0, 1.94D0, 1.96D0, 1.98D0, 2.00D0, 2.5D0,  3.0D0,  3.5D0,
     &   5.0D0, 10.0D0/
      DATA EKIHA /
     &   0.015D0, 0.02D0, 0.025D0, 0.03D0,  0.04D0, 0.05D0, 0.06D0,
     &   0.08D0,  0.10D0, 0.125D0, 0.15D0, 0.175D0, 0.20D0, 0.225D0,
     &   0.25D0,  0.3D0,  0.4D0,   0.6D0,  1.0D0,   2.0D0,  5.0D0,
     &   10.0D0,  22.5D0/
      DATA AMASS /
     &   4.D0, 9.D0, 12.D0, 27.D0, 47.9D0, 55.9D0, 63.5D0, 112.4D0,
     &   207.2D0, 238.1D0/
C-------------------------------------------------------------------
C
C***     PI(-)-P ELASTIC CROSS SECTION DATA
      DATA (SEPIMP(IE),IE=1,50) /
     *     1.250D+00,  1.500D+00,  1.750D+00,  2.450D+00,  3.800D+00,
     *     6.000D+00,  9.700D+00,  1.500D+01,  2.140D+01,  2.310D+01,
     *     2.295D+01,  2.070D+01,  1.795D+01,  1.550D+01,  1.360D+01,
     *     1.230D+01,  1.130D+01,  1.070D+01,  1.050D+01,  1.070D+01,
     *     1.120D+01,  1.175D+01,  1.235D+01,  1.300D+01,  1.400D+01,
     *     1.500D+01,  1.600D+01,  1.700D+01,  1.835D+01,  1.970D+01,
     *     2.050D+01,  1.915D+01,  1.770D+01,  1.650D+01,  1.570D+01,
     *     1.520D+01,  1.510D+01,  1.525D+01,  1.550D+01,  1.600D+01,
     *     1.685D+01,  1.800D+01,  2.000D+01,  2.230D+01,  2.475D+01,
     *     2.635D+01,  2.510D+01,  2.300D+01,  2.140D+01,  2.000D+01/
      DATA (SEPIMP(IE),IE=51,106) /
     *     1.870D+01,  1.750D+01,  1.670D+01,  1.585D+01,  1.505D+01,
     *     1.440D+01,  1.395D+01,  1.340D+01,  1.299D+01,  1.260D+01,
     *     1.215D+01,  1.175D+01,  1.140D+01,  1.099D+01,  1.060D+01,
     *     1.040D+01,  1.010D+01,  9.990D+00,  9.900D+00,  9.750D+00,
     *     9.600D+00,  9.550D+00,  9.450D+00,  9.350D+00,  9.250D+00,
     *     9.250D+00,  9.350D+00,  9.650D+00,  9.850D+00,  1.000D+01,
     *     1.015D+01,  1.030D+01,  1.060D+01,  1.080D+01,  1.095D+01,
     *     1.100D+01,  1.095D+01,  1.090D+01,  1.070D+01,  1.035D+01,
     *     1.000D+01,  9.600D+00,  9.050D+00,  8.550D+00,  8.200D+00,
     *     8.000D+00,  7.850D+00,  7.800D+00,  7.750D+00,  7.700D+00,
     *     7.650D+00,
     *     7.600D+00,  7.240D+00,  6.770D+00,  5.840D+00,  4.570D+00/
* *** The previous 5 points have been substituted to the erroneous
* *** ones from H.J. Mohring by A. Ferrari
C---------------------------------------------------------------------
C
C***     PI(+)-P ELASTIC CROSS SECTION DATA
      DATA (SEPIPP(IE),IE=1,50) /
     *     1.800D+00,  4.000D+00,  9.900D+00,  2.170D+01,  4.000D+01,
     *     6.580D+01,  9.680D+01,  1.392D+02,  1.800D+02,  2.000D+02,
     *     1.655D+02,  1.420D+02,  1.225D+02,  1.032D+02,  8.400D+01,
     *     6.725D+01,  5.510D+01,  4.725D+01,  4.130D+01,  3.690D+01,
     *     3.230D+01,  2.885D+01,  2.600D+01,  2.300D+01,  2.090D+01,
     *     1.875D+01,  1.675D+01,  1.500D+01,  1.340D+01,  1.200D+01,
     *     1.100D+01,  9.980D+00,  9.200D+00,  8.600D+00,  8.200D+00,
     *     8.100D+00,  8.100D+00,  8.250D+00,  8.500D+00,  8.750D+00,
     *     9.000D+00,  9.400D+00,  9.750D+00,  1.000D+01,  1.030D+01,
     *     1.075D+01,  1.130D+01,  1.200D+01,  1.275D+01,  1.330D+01/
      DATA (SEPIPP(IE),IE=51,106) /
     *     1.350D+01,  1.335D+01,  1.330D+01,  1.330D+01,  1.345D+01,
     *     1.355D+01,  1.380D+01,  1.400D+01,  1.460D+01,  1.500D+01,
     *     1.555D+01,  1.625D+01,  1.700D+01,  1.800D+01,  1.875D+01,
     *     1.920D+01,  1.925D+01,  1.890D+01,  1.830D+01,  1.790D+01,
     *     1.725D+01,  1.690D+01,  1.640D+01,  1.600D+01,  1.550D+01,
     *     1.505D+01,  1.475D+01,  1.430D+01,  1.400D+01,  1.365D+01,
     *     1.335D+01,  1.300D+01,  1.280D+01,  1.250D+01,  1.225D+01,
     *     1.205D+01,  1.195D+01,  1.175D+01,  1.150D+01,  1.135D+01,
     *     1.105D+01,  1.095D+01,  1.080D+01,  1.060D+01,  1.030D+01,
     *     1.020D+01,  1.005D+01,  9.900D+00,  9.800D+00,  9.700D+00,
     *     9.600D+00,
     *     7.350D+00,  7.200D+00,  7.000D+00,  5.800D+00,  4.800D+00/
C---------------------------------------------------------------------
C
C***     P-P ELASTIC CROSS SECTION DATA
      DATA (SEPP(IE),IE=1,50) /
     *     6.750D+02,  1.550D+02,  6.750D+01,  4.420D+01,  3.230D+01,
     *     2.800D+01,  2.520D+01,  2.370D+01,  2.300D+01,  2.275D+01,
     *     2.260D+01,  2.260D+01,  2.260D+01,  2.260D+01,  2.270D+01,
     *     2.280D+01,  2.295D+01,  2.300D+01,  2.310D+01,  2.330D+01,
     *     2.350D+01,  2.380D+01,  2.395D+01,  2.420D+01,  2.460D+01,
     *     2.485D+01,  2.500D+01,  2.530D+01,  2.565D+01,  2.600D+01,
     *     2.620D+01,  2.640D+01,  2.660D+01,  2.675D+01,  2.690D+01,
     *     2.700D+01,  2.705D+01,  2.710D+01,  2.715D+01,  2.720D+01,
     *     2.725D+01,  2.725D+01,  2.720D+01,  2.715D+01,  2.710D+01,
     *     2.700D+01,  2.695D+01,  2.680D+01,  2.670D+01,  2.660D+01/
      DATA (SEPP(IE),IE=51,106) /
     *     2.640D+01,  2.625D+01,  2.605D+01,  2.590D+01,  2.570D+01,
     *     2.545D+01,  2.525D+01,  2.500D+01,  2.480D+01,  2.470D+01,
     *     2.450D+01,  2.430D+01,  2.410D+01,  2.395D+01,  2.370D+01,
     *     2.360D+01,  2.340D+01,  2.325D+01,  2.305D+01,  2.290D+01,
     *     2.275D+01,  2.270D+01,  2.260D+01,  2.250D+01,  2.230D+01,
     *     2.225D+01,  2.210D+01,  2.200D+01,  2.195D+01,  2.190D+01,
     *     2.175D+01,  2.165D+01,  2.150D+01,  2.140D+01,  2.125D+01,
     *     2.120D+01,  2.105D+01,  2.100D+01,  2.090D+01,  2.075D+01,
     *     2.065D+01,  2.055D+01,  2.045D+01,  2.030D+01,  2.020D+01,
     *     2.005D+01,  2.000D+01,  1.995D+01,  1.980D+01,  1.975D+01,
     *     1.965D+01,
     *     17.15D+00,  14.45D+00,  13.00D+00,  11.50D+00,  10.50D+00/
C--------------------------------------------------------------------
C
C***     N-P ELASTIC CROSS SECTION DATA
      DATA (SENP(IE),IE=1,50) /
     *     1.965D+03,  4.750D+02,  2.200D+02,  1.300D+02,  9.180D+01,
     *     7.300D+01,  6.030D+01,  5.180D+01,  4.680D+01,  4.320D+01,
     *     4.080D+01,  3.910D+01,  3.760D+01,  3.650D+01,  3.550D+01,
     *     3.480D+01,  3.415D+01,  3.370D+01,  3.325D+01,  3.290D+01,
     *     3.275D+01,  3.250D+01,  3.255D+01,  3.275D+01,  3.285D+01,
     *     3.275D+01,  3.220D+01,  3.150D+01,  3.075D+01,  2.990D+01,
     *     2.875D+01,  2.775D+01,  2.695D+01,  2.630D+01,  2.590D+01,
     *     2.565D+01,  2.560D+01,  2.560D+01,  2.560D+01,  2.565D+01,
     *     2.570D+01,  2.575D+01,  2.578D+01,  2.580D+01,  2.585D+01,
     *     2.580D+01,  2.575D+01,  2.560D+01,  2.540D+01,  2.505D+01/
      DATA (SENP(IE),IE=51,106) /
     *     2.470D+01,  2.425D+01,  2.375D+01,  2.315D+01,  2.275D+01,
     *     2.230D+01,  2.200D+01,  2.175D+01,  2.155D+01,  2.145D+01,
     *     2.130D+01,  2.125D+01,  2.115D+01,  2.105D+01,  2.100D+01,
     *     2.095D+01,  2.090D+01,  2.080D+01,  2.070D+01,  2.060D+01,
     *     2.050D+01,  2.045D+01,  2.040D+01,  2.030D+01,  2.025D+01,
     *     2.020D+01,  2.015D+01,  2.010D+01,  2.005D+01,  2.002D+01,
     *     2.000D+01,  1.999D+01,  1.990D+01,  1.985D+01,  1.975D+01,
     *     1.970D+01,  1.965D+01,  1.960D+01,  1.950D+01,  1.945D+01,
     *     1.940D+01,  1.925D+01,  1.920D+01,  1.915D+01,  1.910D+01,
     *     1.900D+01,  1.898D+01,  1.895D+01,  1.890D+01,  1.880D+01,
     *     1.875D+01,
     *     17.00D+00,  14.40D+00,  12.00D+00,  11.00D+00,  10.00D+00/
C---------------------------------------------------------------------
C
C***     N-A ELASTIC CROSS SECTION DATA
      DATA (SENA(IE,1),IE=1,NEA) /
C*                  NEUTRON - HELIUM
     *     5.103D-01,  5.157D-01,  5.103D-01,  4.777D-01,  4.072D-01,
     *     3.420D-01,  2.714D-01,  1.683D-01,  6.700D-02,  6.100D-02,
     *     5.800D-02,  4.900D-02,  3.800D-02,  3.300D-02,  3.000D-02,
     *     2.400D-02,  2.300D-02,  2.900D-02,  3.600D-02,  4.100D-02,
     *     4.000D-02,  3.700D-02,  3.400D-02/
C
C*                  NEUTRON - BERYLLIUM
      DATA (SENA(IE,2),IE=1,NEA) /
     *     8.762D-01,  8.856D-01,  8.762D-01,  8.203D-01,  6.991D-01,
     *     5.873D-01,  4.661D-01,  2.890D-01,  1.401D-01,  1.305D-01,
     *     1.238D-01,  1.069D-01,  8.495D-02,  7.480D-02,  6.750D-02,
     *     5.565D-02,  5.230D-02,  6.470D-02,  7.765D-02,  8.722D-02,
     *     8.440D-02,  7.821D-02,  7.259D-02/
C
C*                  NEUTRON - CARBON
      DATA (SENA(IE,3),IE=1,NEA) /
     *     9.200D-01,  9.500D-01,  9.400D-01,  8.800D-01,  7.500D-01,
     *     6.100D-01,  5.000D-01,  3.700D-01,  1.820D-01,  1.710D-01,
     *     1.620D-01,  1.410D-01,  1.130D-01,  1.000D-01,  9.000D-02,
     *     7.500D-02,  7.000D-02,  8.600D-02,  1.020D-01,  1.140D-01,
     *     1.100D-01,  1.020D-01,  9.500D-02/
C
C*                  NEUTRON - ALUMINUM
      DATA (SENA(IE,4),IE=1,NEA) /
     *     1.090D+00,  1.180D+00,  1.240D+00,  1.280D+00,  1.260D+00,
     *     1.160D+00,  9.300D-01,  6.300D-01,  3.580D-01,  3.450D-01,
     *     3.350D-01,  2.990D-01,  2.480D-01,  2.220D-01,  2.020D-01,
     *     1.730D-01,  1.610D-01,  1.920D-01,  2.200D-01,  2.420D-01,
     *     2.370D-01,  2.220D-01,  2.060D-01/
C
C*                  NEUTRON - TITANIUM
      DATA (SENA(IE,5),IE=1,NEA) /
     *     1.029D+00,  9.469D-01,  1.091D+00,  1.284D+00,  1.591D+00,
     *     1.691D+00,  1.258D+00,  9.241D-01,  5.620D-01,  5.493D-01,
     *     5.375D-01,  4.907D-01,  4.182D-01,  3.800D-01,  3.484D-01,
     *     3.038D-01,  2.823D-01,  3.307D-01,  3.720D-01,  4.040D-01,
     *     3.959D-01,  3.743D-01,  3.517D-01/
C
C*                  NEUTRON - IRON
      DATA (SENA(IE,6),IE=1,NEA) /
     *     1.178D+00,  9.793D-01,  1.090D+00,  1.271D+00,  1.650D+00,
     *     1.799D+00,  1.339D+00,  1.009D+00,  6.223D-01,  6.132D-01,
     *     6.042D-01,  5.572D-01,  4.812D-01,  4.402D-01,  4.053D-01,
     *     3.554D-01,  3.304D-01,  3.814D-01,  4.244D-01,  4.603D-01,
     *     4.523D-01,  4.293D-01,  4.053D-01/
C
C*                  NEUTRON - COPPER
      DATA (SENA(IE,7),IE=1,NEA) /
     *     1.386D+00,  1.050D+00,  1.134D+00,  1.302D+00,  1.722D+00,
     *     1.922D+00,  1.449D+00,  1.103D+00,  6.762D-01,  6.686D-01,
     *     6.602D-01,  6.131D-01,  5.344D-01,  4.912D-01,  4.541D-01,
     *     4.004D-01,  3.728D-01,  4.273D-01,  4.725D-01,  5.103D-01,
     *     5.022D-01,  4.781D-01,  4.524D-01/
C
C*                  NEUTRON - CADMIUM
      DATA (SENA(IE,8),IE=1,NEA) /
     *     2.029D+00,  1.537D+00,  1.660D+00,  1.906D+00,  2.520D+00,
     *     2.812D+00,  2.121D+00,  1.614D+00,  1.014D+00,  1.012D+00,
     *     1.006D+00,  9.557D-01,  8.607D-01,  8.038D-01,  7.541D-01,
     *     6.775D-01,  6.334D-01,  7.080D-01,  7.669D-01,  8.156D-01,
     *     8.074D-01,  7.769D-01,  7.404D-01/
C
C*                  NEUTRON - LEAD
      DATA (SENA(IE,9),IE=1,NEA) /
     *     3.050D+00,  2.310D+00,  2.495D+00,  2.865D+00,  3.789D+00,
     *     4.228D+00,  3.188D+00,  2.426D+00,  1.536D+00,  1.538D+00,
     *     1.536D+00,  1.488D+00,  1.384D+00,  1.317D+00,  1.256D+00,
     *     1.153D+00,  1.089D+00,  1.185D+00,  1.255D+00,  1.315D+00,
     *     1.307D+00,  1.269D+00,  1.224D+00/
C
C*                  NEUTRON - URANIUM
      DATA (SENA(IE,10),IE=1,NEA) /
     *     3.346D+00,  2.535D+00,  2.738D+00,  3.143D+00,  4.157D+00,
     *     4.639D+00,  3.498D+00,  2.662D+00,  1.685D+00,  1.687D+00,
     *     1.685D+00,  1.632D+00,  1.518D+00,  1.445D+00,  1.378D+00,
     *     1.265D+00,  1.194D+00,  1.300D+00,  1.377D+00,  1.443D+00,
     *     1.434D+00,  1.392D+00,  1.343D+00/
C---  ----------------------------------------------------------------
C
C***     P-A ELASTIC CROSS SECTION DATA
      DATA (SEPA(IE,1),IE=1,NEA) /
C*                  PROTON - HELIUM
     *   8*0.000D+00,                          6.700D-02,  6.100D-02,
     *     5.800D-02,  4.900D-02,  3.800D-02,  3.300D-02,  3.000D-02,
     *     2.400D-02,  2.300D-02,  2.900D-02,  3.600D-02,  4.100D-02,
     *     4.000D-02,  3.700D-02,  3.400D-02/
C
C*                  PROTON - BERYLLIUM
      DATA (SEPA(IE,2),IE=1,NEA) /
     *   8*0.000D+00,                          1.401D-01,  1.305D-01,
     *     1.238D-01,  1.069D-01,  8.495D-02,  7.480D-02,  6.750D-02,
     *     5.565D-02,  5.230D-02,  6.470D-02,  7.765D-02,  8.722D-02,
     *     8.440D-02,  7.821D-02,  7.259D-02/
C
C*                  PROTON - CARBON
      DATA (SEPA(IE,3),IE=1,NEA) /
     *   8*0.000D+00,                          1.820D-01,  1.710D-01,
     *     1.620D-01,  1.410D-01,  1.130D-01,  1.000D-01,  9.000D-02,
     *     7.500D-02,  7.000D-02,  8.600D-02,  1.020D-01,  1.140D-01,
     *     1.100D-01,  1.020D-01,  9.500D-02/
C
C*                  PROTON - ALUMINUM
      DATA (SEPA(IE,4),IE=1,NEA) /
     *   8*0.000D+00,                          3.650D-01,  3.540D-01,
     *     3.420D-01,  3.060D-01,  2.530D-01,  2.260D-01,  2.040D-01,
     *     1.750D-01,  1.610D-01,  1.900D-01,  2.200D-01,  2.430D-01,
     *     2.370D-01,  2.220D-01,  2.070D-01/
C
C*                  PROTON - TITANIUM
      DATA (SEPA(IE,5),IE=1,NEA) /
     *   8*0.000D+00,                          5.828D-01,  5.726D-01,
     *     5.594D-01,  5.100D-01,  4.310D-01,  3.897D-01,  3.561D-01,
     *     3.084D-01,  2.829D-01,  3.262D-01,  3.714D-01,  4.066D-01,
     *     3.985D-01,  3.764D-01,  3.517D-01/
C
C*                  NEUTRON - IRON
      DATA (SEPA(IE,6),IE=1,NEA) /
     *   8*0.000D+00,                          6.383D-01,  6.313D-01,
     *     6.212D-01,  5.732D-01,  4.913D-01,  4.483D-01,  4.113D-01,
     *     3.594D-01,  3.304D-01,  3.764D-01,  4.243D-01,  4.623D-01,
     *     4.543D-01,  4.313D-01,  4.053D-01/
C
C*                  NEUTRON - COPPER
      DATA (SEPA(IE,7),IE=1,NEA) /
     *   8*0.000D+00,                          6.950D-01,  6.895D-01,
     *     6.803D-01,  6.322D-01,  5.471D-01,  5.014D-01,  4.619D-01,
     *     4.048D-01,  3.728D-01,  4.211D-01,  4.722D-01,  5.135D-01,
     *     5.051D-01,  4.804D-01,  4.527D-01/
C
C*                  NEUTRON - CADMIUM
      DATA (SEPA(IE,8),IE=1,NEA) /
     *   8*0.000D+00,                          1.045D+00,  1.043D+00,
     *     1.036D+00,  9.718D-01,  8.822D-01,  8.211D-01,  7.679D-01,
     *     6.828D-01,  6.325D-01,  6.951D-01,  7.647D-01,  8.232D-01,
     *     8.138D-01,  7.935D-01,  7.415D-01/
C
C*                  NEUTRON - LEAD
      DATA (SEPA(IE,9),IE=1,NEA) /
     *   8*0.000D+00,                          1.589D+00,  1.584D+00,
     *     1.577D+00,  1.528D+00,  1.417D+00,  1.345D+00,  1.277D+00,
     *     1.159D+00,  1.086D+00,  1.159D+00,  1.252D+00,  1.331D+00,
     *     1.320D+00,  1.278D+00,  1.256D+00/
C
C*                  NEUTRON - URANIUM
      DATA (SEPA(IE,10),IE=1,NEA) /
     *   8*0.000D+00,                          1.743D+00,  1.738D+00,
     *     1.730D+00,  1.676D+00,  1.554D+00,  1.475D+00,  1.401D+00,
     *     1.271D+00,  1.191D+00,  1.271D+00,  1.373D+00,  1.460D+00,
     *     1.448D+00,  1.402D+00,  1.378D+00/
C
      DATA RELTO / 0.175D0, 6*0.D0, 0.175D0, 4*0.D0, 0.14D0, 0.14D0/
C
C--------------------------------------------------------------------
C
      IF(ANUC.LT.1.5D0) THEN
C                               HADRON-PROTON ELASTIC CROSS SECTIONS
         IPOL=0
         EK1=EKIN
         IF(EKIN.GT.20.D0) THEN
            SIGELA=RELTO(KPROJ)*SHPTOT(KPROJ,PLAB)
            RETURN
         ELSEIF(EKIN.GT.10.D0) THEN
            IPOL=1
            PO2=20.D0
            EK2=SQRT(PO2**2+AM(KPROJ)**2) - AM(KPROJ)
            SEL2=RELTO(KPROJ)*SHPTOT(KPROJ,PO2)
            EK1=10.D0
         ENDIF
C
         DO 101 IE=1,NEN
            IF(EK1.LT.EKIHN(IE)) THEN
               JE1=IE-1
               JE2=IE
               DDEE=EKIHN(JE2) - EKIHN(JE1)
               GOTO 102
            ENDIF
 101     CONTINUE
         JE1=NEN
         JE2=NEN
         DDEE=1.D0
 102     CONTINUE
C****
C                                  PROTON-PROTON
         IF(KPROJ.EQ.1) THEN
            S1=SEPP(JE1)
            S2=SEPP(JE2)
C                                  NEUTRON-PROTON
         ELSEIF(KPROJ.EQ.8) THEN
            S1=SENP(JE1)
            S2=SENP(JE2)
C                                  PI(+)-PROTON
         ELSEIF(KPROJ.EQ.13) THEN
            S1=SEPIPP(JE1)
            S2=SEPIPP(JE2)
C                                  PI(-)-PROTON
         ELSEIF(KPROJ.EQ.14) THEN
            S1=SEPIMP(JE1)
            S2=SEPIMP(JE2)
C                                  UNDEFINED ENTRY CONDITIONS
         ELSE
            SIGELA=0.D0
            RETURN
         ENDIF
C
         SIGELA=S1 + (S2-S1)*(EK1-EKIHN(JE1))/DDEE
C
C                                  INTERPOLATION BETWEEN 10/20 GEV
         IF(IPOL.EQ.1) THEN
            SEL1=SIGELA
            SIGELA=SEL1 + (SEL2-SEL1)*(EKIN-EK1)/(EK2-EK1)
         ENDIF
C
         RETURN
C
      ENDIF
C***************************************
C                               HADRON-NUCLEUS ELASTIC CROSS SECTIONS
      DO 201 IE=1,NEA
         IF(EKIN.LT.EKIHA(IE)) THEN
            JE=IE - 1
            GOTO 202
         ENDIF
 201  CONTINUE
      IF(EKIN.EQ.EKIHA(NEA)) THEN
         JE=NEA - 1
      ELSE
         JE=-1
      ENDIF
 202  CONTINUE
C
      DO 203 IA=1,NNAA
         IF(ANUC.LT.AMASS(IA)) THEN
            JA=IA - 1
            GOTO 204
         ENDIF
 203  CONTINUE
      IF(ANUC.EQ.AMASS(NNAA)) THEN
         JA=NNAA - 1
      ELSE
         JA=-1
      ENDIF
 204  CONTINUE
C
      IF (JA) 230,220,210
  210 IF (JE) 240,250,211
  211 TEMP1=ANUC/AMASS(JA)
      TEMP2=LOG(AMASS(JA+1)/AMASS(JA))
      KE=JE
      DO 212 I=1,2
         IF(KPROJ.EQ.8) THEN
            SLOW=SENA(KE,JA)
            POWER=LOG(SENA(KE,JA+1)/SLOW)/TEMP2
         ELSE
            SLOW=SEPA(KE,JA)
            POWER=LOG(SEPA(KE,JA+1)/SLOW)/TEMP2
         ENDIF
         TSIG(I)=SLOW*TEMP1**POWER
      KE=KE+1
  212 CONTINUE
C
  213 SIGELA=TSIG(1)
     *       + (EKIN-EKIHA(JE))*(TSIG(2)-TSIG(1))
     *         /(EKIHA(JE+1)-EKIHA(JE))
      SIGELA=SIGELA * 1E3
      RETURN
C*
C                                          A IS LESS THAN A MIN
  220 JA=1
      TEMP1= (ANUC/AMASS(JA)) **0.6666666666666667D0
  221 IF (JE) 260,270,222
  222 IF(KPROJ.EQ.8) THEN
         TSIG(1) = SENA(JE,JA) * TEMP1
         TSIG(2) = SENA(JE+1,JA) *TEMP1
      ELSE
         TSIG(1) = SEPA(JE,JA) * TEMP1
         TSIG(2) = SEPA(JE+1,JA) *TEMP1
      ENDIF
      GO TO 213
C*
C                                         A IS GREATER THAN A MAX
  230 JA=NNAA
      TEMP1= (ANUC/AMASS(JA))**0.6666666666666667D0
      GO TO 221
C*
C                                         EKIN  LT.  EMIN
  250 JE=1
  251 TEMP1=ANUC/AMASS(JA)
      TEMP2=LOG(AMASS(JA+1)/AMASS(JA))
      IF(KPROJ.EQ.8) THEN
         SLOW=SENA(JE,JA)
         POWER=LOG(SENA(JE,JA+1)/SLOW)/TEMP2
      ELSE
         SLOW=SEPA(JE,JA)
         POWER=LOG(SEPA(JE,JA+1)/SLOW)/TEMP2
      ENDIF
      SIGELA=SLOW*TEMP1**POWER
      SIGELA=SIGELA * 1.D+03
      RETURN
C
  270 JE=1
  271 IF(KPROJ.EQ.8) THEN
         SIGELA=SENA(JE,JA)*TEMP1
      ELSE
         SIGELA=SEPA(JE,JA)*TEMP1
      ENDIF
      SIGELA=SIGELA * 1.D+03
      RETURN
C*
C                                         EKIN  GT.  EMAX
  240 JE=NEA
      GO TO 251
  260 JE=NEA
      GO TO 271
      END
+DECK,  SITSAO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:05  cernlib
* Geant

*$ CREATE SITSAO.FOR
*COPY SITSAO
*=== sitsao ===========================================================*
      FUNCTION SITSAO ( E, IZ, A )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Original from A. Fasso`, CERN-TIS                                *
*                                                                      *
*     Created on 20 september 1991 by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 20-sep-91     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*   Calculates proton-nucleus inelastic cross-section by the formula   *
*   of Letaw, Silberberg and Tsao, Astrophys. J. Suppl. 51, 271 (1983) *
*----------------------------------------------------------------------*
*   E = Energy in MeV, IZ = Atomic number, A = Mass number (At. weight)*
*----------------------------------------------------------------------*
*                                                formula (2)
      SITSAO = 45.D+00 * A**0.7D+00 * ( 1.D+00 + 0.016D+00 * SIN
     &       ( 5.3D+00 - 2.63D+00 * LOG(A)) )
*                                                formula (5)
      IF(E .LT. 2000.D+00) SITSAO = SITSAO * ( 1.D+00 - 0.62D+00
     &                            / EXP ( E / 200.D+00 )
     &                            * SIN ( 10.9D+00 / E**0.28D+00 ) )
      IF (IZ .EQ. 2) THEN
         SITSAO=SITSAO*0.8D+00
      ELSE IF (IZ .EQ. 4) THEN
         SITSAO=SITSAO*(1.D+00 + 0.75D+00/EXP(E/75.D+00))
      END IF
      RETURN
      END
+DECK,  STALIN, T=FORT.
* Revision 1.4  1997/10/17 10:11:47  mclareni
* Negative square root protection
* Revision 1.3  1996/05/03 07:31:39  cernlib
* Replace in Max( .., 0.0) the 0.0 by ZERO to have the proper variable type.
* Revision 1.2  1996/04/26 12:19:59  ravndal
* neg. SQRT protection
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE STALIN.FOR
*COPY STALIN
*                                                                      *
*=== stalin ===========================================================*
*                                                                      *
      SUBROUTINE STALIN

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
       PARAMETER (ZERO=0)
*----------------------------------------------------------------------*
*                                                                      *
*     STAbility LINe calculation:                                      *
*                                                                      *
*     Created on 04 december 1992  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 04-dec-92     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, ISOTOP.
*
      DIMENSION ZNORM (260)
*  +-------------------------------------------------------------------*
*  |
      DO 1000 IZ=1,100
         DO 500 J=1,2
            ASTLIN (J,IZ) = 0.D+00
  500    CONTINUE
 1000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |
      DO 2000 IA=1,260
         ZNORM (IA) = 0.D+00
         DO 1500 J=1,2
            ZSTLIN (J,IA) = 0.D+00
 1500    CONTINUE
 2000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Loop on the Atomic Number
      DO 3000 IZ=1,100
*  |  +----------------------------------------------------------------*
*  |  |    Loop on the stable isotopes
         DO 2500 IS = ISONDX (1,IZ), ISONDX (2,IZ)
            IA = ISOMNM (IS)
            ASTLIN (1,IZ) = ASTLIN (1,IZ) + ABUISO (IS) * IA
            ASTLIN (2,IZ) = ASTLIN (2,IZ) + ABUISO (IS) * IA**2
            ZNORM    (IA) = ZNORM (IA) + ABUISO (IS)
            ZSTLIN (1,IA) = ZSTLIN (1,IA) + ABUISO (IS) * IZ
            ZSTLIN (2,IA) = ZSTLIN (2,IA) + ABUISO (IS) * IZ**2
 2500    CONTINUE
*  |  |
*  |  +----------------------------------------------------------------*
*  |  Normalize and print A_stab versus Z data:
         ASTLIN (2,IZ) = MAX ( SQRT (
     &                   MAX ( ASTLIN(2,IZ)-ASTLIN(1,IZ)**2,ZERO)),
     &                   HLFHLF )
 3000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Normalize and print Z_stab versus A data:
      TMP10 = 1.D-10
      TMP03 = 0.3D+00
      DO 4000 IA=1,260
         ZSTLIN (1,IA) = ZSTLIN (1,IA) / MAX ( ZNORM (IA), TMP10 )
         ZSTLIN (2,IA) = ZSTLIN (2,IA) / MAX ( ZNORM (IA), TMP10 )
         ZSTLIN (2,IA) = MAX ( ZSTLIN (2,IA), ZSTLIN (1,IA)**2 )
         IF ( ZNORM (IA) .GT. ANGLGB )
     &     ZSTLIN (2,IA) = MAX ( SQRT (
     &                     MAX ( ZSTLIN(2,IA)-ZSTLIN(1,IA)**2,ZERO)),
     &                     TMP03 )
 4000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*  +-------------------------------------------------------------------*
*  |  Normalize and print Z_stab versus A data:
      DO 5000 IA=1,260
         IF ( ZNORM (IA) .LE. ANGLGB ) THEN
            DO 4200 JA = IA-1,1,-1
               IF ( ZNORM (JA) .GT. ANGLGB ) THEN
                  IA1 = JA
                  GO TO 4300
               END IF
 4200       CONTINUE
 4300       CONTINUE
            DO 4400 JA = IA+1,260
               IF ( ZNORM (JA) .GT. ANGLGB ) THEN
                  IA2 = JA
                  GO TO 4500
               END IF
 4400       CONTINUE
            IA2 = IA1
            IA1 = IA1 - 1
 4500       CONTINUE
            DIAIA1 = IA-IA1
            DIA2IA = IA2-IA1
            ZSTLIN (1,IA) = DIAIA1 / DIA2IA
     &                    * ( ZSTLIN (1,IA2) - ZSTLIN (1,IA1) )
     &                    + ZSTLIN (1,IA1)
            ZSTLIN (2,IA) = DIAIA1 / DIA2IA
     &                    * ( ZSTLIN (2,IA2) - ZSTLIN (2,IA1) )
     &                    + ZSTLIN (2,IA1)
         END IF
         IZ = MIN ( 100, NINT (ZSTLIN(1,IA)) )
         ATOZ = IZ / ASTLIN (1,IZ)
         ZSTLIN (2,IA) = MAX ( ZSTLIN (2,IA), ATOZ * ASTLIN (2,IZ) )
 5000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
      RETURN
      END
+DECK,  TCHOIC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE TCHOIC.FOR
*COPY TCHOIC
*=== tchoic ===========================================================*
      SUBROUTINE TCHOIC(T,P,PP,E,EE,I,II,N,AM1,AM2)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C     ****************************
C     TCHOIC CALCULATES A RANDOM VALUE
C     FOR THE FOUR-MOMENTUM-TRANSFER T
C     ****************************
      COMMON /FKGAMR/ REDU,AMO,AMM(15 )
      COMMON/FKABLT/AM(110),GA(110),TAU(110),ICH(110)
     *,IBAR(110),K1(110),K2(110)
      COMMON/FKSLOP/SM(25),BBM(25),BBB(25)
      REAL RNDM(1)
      AMA=AM1
      AMB=AM2
      IF (I.GT.30.AND.II.GT.30) GO TO 1
      III=II
      AM3=AM2
      IF (I.LE.30) GO TO 11
      III=I
      AM3=AM1
   11 CONTINUE
      GO TO 10
    1 CONTINUE
      III=II
      AM3=AM2
      IF (AMA.LE.AMB) GO TO 10
      III=I
      AM3=AM1
   10 CONTINUE
      IB=IBAR(III)
      AMA=AM3
      K=(AMA-0.75D0)/0.05D0
      IF (K-2.LT.0) K=1
      IF (K-26.GE.0) K=25
      IF (IB)21,22,21
   22 BM=BBM(K)
      GO TO 23
   21 BM=BBB(K)
   23 CONTINUE
C     NORMALIZATION
      TMIN=-2.D0*(E*EE-P*PP)+AM(N)**2+AM1  **2
      TMAX=-2.D0*(E*EE+P*PP)+AM(N)**2+AM1  **2
      CALL GRNDM(RNDM,1)
      VB = RNDM(1)
      IF (VB.LT.0.2D0) BM=BM*0.1D0
     **0.5D0
      TMI=BM*TMIN
      TMA=BM*TMAX
      ETMA=0.D0
      IF (ABS(TMA).GT.120.D0) GO TO 100
      ETMA=EXP(TMA)
  100 CONTINUE
      AN=(1.D0/BM)*(EXP(TMI)-ETMA)
C*** RANDOM CHOICE OF THE T - VALUE
      CALL GRNDM(RNDM,1)
      R = RNDM(1)
      T=(1.D0/BM)*LOG(ETMA+R*AN*BM)
      RETURN
      END
+DECK,  THREPD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE THREPD.FOR
*COPY THREPD
*=== threpd ===========================================================*
      SUBROUTINE THREPD(UMO,ECM1,ECM2,ECM3,PCM1,PCM2,PCM3,COD1,COF1,
     *SIF1,COD2,COF2,SIF2,COD3,COF3,SIF3,AM1,AM2,AM3)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Threpd89: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
      DIMENSION F(5),XX(5)
C***THREE PARTICLE DECAY IN THE CM - SYSTEM
      COMMON /FKGAMR/ REDU,AMO,AMM(15 )
      COMMON/FKDREI/UUMO,AAM1,AAM2,AAM3,S22,UMO2,AM11,AM22,AM33,S2SUP
     *,S2SAP(2)
      COMMON/FKPRUN/ISYS
      REAL RNDM(2)
      SAVE EPS
      DATA EPS/1.D-16/
      UMOO=UMO+UMO
C***S1, S2, S3 ARE THE INVARIANT MASSES OF THE PARTICLES 1, 2, 3
C***J. VON NEUMANN - RANDOM - SELECTION OF S2
C***CALCULATION OF THE MAXIMUM OF THE S2 - DISTRIBUTION
      UUMO=UMO
      AAM1=AM1
      AAM2=AM2
      AAM3=AM3

      GU=(AM2+AM3)**2
      GO=(UMO-AM1)**2
      UFAK=1.0000000000001D0
      IF (GU.GT.GO) UFAK=0.9999999999999D0
      OFAK=2.D0-UFAK
      GU=GU*UFAK
      GO=GO*OFAK
      DS2=(GO-GU)/99.D0
      AM11=AM1*AM1
      AM22=AM2*AM2
      AM33=AM3*AM3
      UMO2=UMO*UMO
      RHO2=0.D0
      S22=GU
      DO 124 I=1,100
         S21=S22
         S22=GU+(I-1.D0)*DS2
         RHO1=RHO2
         RHO2=XLAMB(S22,UMO2,AM11)*XLAMB(S22,AM22,AM33)/(S22+EPS)
         IF(RHO2.LT.RHO1) GO TO 125
  124 CONTINUE
  125 S2SUP=(S22-S21)*.5D0+S21
      SUPRHO=XLAMB(S2SUP,UMO2,AM11)*XLAMB(S2SUP,AM22,AM33)/(S2SUP+EPS)
      SUPRHO=SUPRHO*1.05D0
      XO=S21-DS2
      IF (GU.LT.GO.AND.XO.LT.GU) XO=GU
      IF (GU.GT.GO.AND.XO.GT.GU) XO=GU
      XX(1)=XO
      XX(3)=S22
      X1=(XO+S22)*0.5D0
      XX(2)=X1
      F(3)=RHO2
      F(1)=XLAMB(XO,UMO2,AM11)*XLAMB(XO,AM22,AM33)/(XO+EPS)
      F(2)=XLAMB(X1,UMO2,AM11)*XLAMB(X1,AM22,AM33)/(X1+EPS)
      DO 126 I=1,16
         X4=(XX(1)+XX(2))*0.5D0
         X5=(XX(2)+XX(3))*0.5D0
         F(4)=XLAMB(X4,UMO2,AM11)*XLAMB(X4,AM22,AM33)/(X4+EPS)
         F(5)=XLAMB(X5,UMO2,AM11)*XLAMB(X5,AM22,AM33)/(X5+EPS)
         XX(4)=X4
         XX(5)=X5
         DO 128 II=1,5
            IA=II
            DO 128 III=IA,5
               IF (F (II).GE.F (III)) GO TO 128
               FH=F(II)
               F(II)=F(III)
               F(III)=FH
               FH=XX(II)
               XX(II)=XX(III)
               XX(III)=FH
128      CONTINUE
         SUPRHO=F(1)
         S2SUP=XX(1)
         DO 129 II=1,3
            IA=II
            DO 129 III=IA,3
               IF (XX(II).GE.XX(III)) GO TO 129
               FH=F(II)
               F(II)=F(III)
               F(III)=FH
               FH=XX(II)
               XX(II)=XX(III)
               XX(III)=FH
129      CONTINUE
126   CONTINUE
      AM23=(AM2+AM3)**2
      ITH=0
      REDU=2.D0
    1 CONTINUE
      ITH=ITH+1
      IF (ITH.GT.200) REDU=-9.D0
      IF (ITH.GT.200) GO TO 400
      CALL GRNDM(RNDM,2)
      C=RNDM(1)
      S2=AM23+C*((UMO-AM1)**2-AM23)
      Y=RNDM(2)
      Y=Y*SUPRHO
      RHO=XLAMB(S2,UMO2,AM11)*XLAMB(S2,AM22,AM33)/S2
      IF(Y.GT.RHO) GO TO 1
C***RANDOM SELECTION OF S3 AND CALCULATION OF S1
      CALL GRNDM(RNDM,1)
      S1=RNDM(1)
      S1=S1*RHO+AM11+AM22-(S2-UMO2+AM11)*(S2+AM22-AM33)/(2.D0*S2)-
     &RHO*.5D0
      S3=UMO2+AM11+AM22+AM33-S1-S2
      ECM1=(UMO2+AM11-S2)/UMOO
      ECM2=(UMO2+AM22-S3)/UMOO
      ECM3=(UMO2+AM33-S1)/UMOO
       PCM1=SQRT((ECM1+AM1)*(ECM1-AM1))
       PCM2=SQRT((ECM2+AM2)*(ECM2-AM2))
       PCM3=SQRT((ECM3+AM3)*(ECM3-AM3))
      CALL SFECFE(SFE,CFE)
C***TH IS THE ANGLE BETWEEN PARTICLES 1 AND 2
C***TH1, TH2 ARE THE ANGLES BETWEEN PARTICLES 1, 2 AND THE DIRECTION OF
      IF ((PCM1.LE.1.D-3).OR.(PCM2.LE.1.D-3)) GO TO 200
      COSTH=(ECM1*ECM2+0.5D0*(AM11+AM22-S1))/(PCM1*PCM2)
      GO TO 300
  200 CALL GRNDM(RNDM,1)
      UW=RNDM(1)
      COSTH=(UW-.5D0)*2.D0
 300  CONTINUE
      TMPONE = 0.9999999999999999D0
      IF(ABS(COSTH).GT.0.9999999999999999D0)
     &COSTH=SIGN(TMPONE,COSTH)
      IF (REDU.LT.1.D0) RETURN
      COSTH2=(PCM3*PCM3+PCM2*PCM2-PCM1*PCM1)/(2.D0*PCM2*PCM3)
      IF(ABS(COSTH2).GT.0.9999999999999999D0)
     &COSTH2=SIGN(TMPONE,COSTH2)
      SINTH2=SQRT(1.D0-COSTH2*COSTH2)
      SINTH1=COSTH2*SQRT(1.D0-COSTH*COSTH)-COSTH*SINTH2
      COSTH1=COSTH*COSTH2+SINTH2*SQRT(1.D0-COSTH*COSTH)
C***RANDOM SELECTION OF THE SPHERICAL COORDINATES OF THE DIRECTION OF PA
C***CFE, SFE ARE COS AND SIN OF THE ROTATION ANGLE OF THE SYSTEM 1, 2 AR
C***THE DIRECTION OF PARTICLE 3
C***CALCULATION OF THE SPHERICAL COORDINATES OF PARTICLES 1, 2
      CX11=-COSTH1
      CY11=SINTH1*CFE
      CZ11=SINTH1*SFE
      CX22=-COSTH2
      CY22=-SINTH2*CFE
      CZ22=-SINTH2*SFE
      CALL SFECFE(SIF3,COF3)
      CALL GRNDM(RNDM,1)
      COD3=RNDM(1)
      COD3=2.D0*COD3-1.D0
      SID3=SQRT(1.D0-COD3*COD3)
    2 FORMAT(5F20.15)
      COD1=CX11*COD3+CZ11*SID3
      IF((1.D0-COD1*COD1).LT.1.D-14)WRITE(ISYS,2)COD1,COF3,SID3,
     &CX11,CZ11
      SID1=SQRT(1.D0-COD1*COD1)
      COF1=(CX11*SID3*COF3-CY11*SIF3-CZ11*COD3*COF3)/SID1
      SIF1=(CX11*SID3*SIF3+CY11*COF3-CZ11*COD3*SIF3)/SID1
      COD2=CX22*COD3+CZ22*SID3
      SID2=SQRT(1.D0-COD2*COD2)
      COF2=(CX22*SID3*COF3-CY22*SIF3-CZ22*COD3*COF3)/SID2
      SIF2=(CX22*SID3*SIF3+CY22*COF3-CZ22*COD3*SIF3)/SID2
  400 RETURN
      END
+DECK,  TRAFO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE TRAFO.FOR
*COPY TRAFO
*=== trafo ============================================================*
      SUBROUTINE TRAFO(GAM,BGAM,CX,CY,CZ,COD,COF,SIF,P,ECM,
     1PL,CXL,CYL,CZL,EL)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C     LORENTZ TRANSFORMATION INTO THE LAB - SYSTEM
      SID=SQRT(1.D0-COD*COD)
      PLX=P*SID*COF
      PLY=P*SID*SIF
      PCMZ=P*COD
      PLZ=GAM*PCMZ+BGAM*ECM
      PL=SQRT(PLX*PLX+PLY*PLY+PLZ*PLZ)
      EL=GAM*ECM+BGAM*PCMZ
C     ROTATION INTO THE ORIGINAL DIRECTION
      COZ=PLZ/PL
      SIZ=SQRT(1.D0-COZ**2)
      CALL TTRANS(CX,CY,CZ,COZ,SIZ,SIF,COF,CXL,CYL,CZL)
      RETURN
      END
+DECK,  TRAHAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:01  cernlib
* Geant

*$ CREATE TRAHAD.FOR
*COPY TRAHAD
*=== trahad ===========================================================*
      SUBROUTINE TRAHAD(N,NAUX,GAM,BGX,BGY,BGZ)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C
C     LORENTZ TRANSFORMATION OF  N PARTICLES IN  FINPAR  TO BE
C     STORED IN  AUXPAR  STARTING AT NAUX
C
C********************************************************************
C
+CDE, HADPAR.
+CDE, AUXPAR.
      DO 1  I=1,N
         J = NAUX + I - 1
         AMH(J)   = AMA(I)
         ICHH(J)  = ICHA(I)
         IBARH(J) = IBARA(I)
         ANH(J)   = ANA(I)
         NREH(J)  = NREA(I)
         CALL ALTRA(GAM,BGX,BGY,BGZ,PXA(I),PYA(I),PZA(I),HEPA(I),
     &              PPA,PXH(J),PYH(J),PZH(J),HEPH(J))
   1  CONTINUE
      RETURN
      END
+DECK,  TRANS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE TRANS.FOR
*COPY TRANS
*  FLUPDATE FORTRAN file
*  These are corrected versions of TRANS and TTRANS which make the
*  correct transformation even in the small-angle, backwards direction
*  Correction installed 11.03.88
      SUBROUTINE TRANS (XO,YO,ZO,DE,SFE,CFE,X,Y,Z)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C     LAST CHANGE 12. APRIL 83    BY PERTTI AARNIO
C                                    HELSINKI UNIVERSITY OF
C                                    TECHNOLOGY, FINLAND
C
C
C     THIS IS A SUBROUTINE OF FLUKA TO GIVE NEW DIRECTION COSINES
C
C     INPUT VARIABLES:
C        XO,YO,ZO = ORIGINAL DIRECTION COSINES
C        DE       = POLAR (THETA) ANGLE OF "SCATTERING"
C        SFE,CFE  = SINE AND COSINE OF THE AZIMUTHAL (PHI) ANGLE
C                   OF "SCATTERING"
C
C     OUTPUT VARIABLES:
C        X,Y,Z     = NEW DIRECTION COSINES
C
C     ROTATION OF COORDINATE SYSTEM (SEE CERN 64-47)
C
C     DUE TO THE IMPLEMENTATION OF THE MULTIPLE COULOMB SCATTERING
C     ALSO VERY SMALL ANGLES HAVE TO BE TREATED CORRECTLY.
C     NOW SMALL ANGLE APPROXIMATION IS USED PRACTICALLY ONLY
C     WHEN XO AND YO ARE EXACTLY 0.
C
C********************************************************************
C
*
      CDE=COS(DE)
      SDE=SIN(DE)
      A = XO**2 + YO**2
      IF ( A .LT. ANGLSQ ) THEN
         X=SDE*CFE
         Y=SDE*SFE
C   Z=CDE CORRECTED AUGUST 88 PA
         Z=CDE*ZO
      ELSE
         XI=SDE*CFE
         YI=SDE*SFE
         ZI=CDE
         A =SQRT(A)
         X=-YO*XI/A-ZO*XO*YI/A+XO*ZI
         Y=XO*XI/A-ZO*YO*YI/A+YO*ZI
         Z=A*YI+ZO*ZI
      END IF
      RETURN
      END
+DECK,  TTRANS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

*$ CREATE TTRANS.FOR
*COPY TTRANS
      SUBROUTINE TTRANS(XO,YO,ZO,CDE,SDE,SFE,CFE,X,Y,Z)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C********************************************************************
C     VERSION BY                     J. RANFT
C                                    LEIPZIG
C
C     THIS IS A SUBROUTINE OF FLUKA TO GIVE NEW DIRECTION COSINES
C
C     INPUT VARIABLES:
C        XO,YO,ZO = ORIGINAL DIRECTION COSINES
C        CDE,SDE  = COSINE AND SINE OF THE POLAR (THETA)
C                   ANGLE OF "SCATTERING"
C        SDE      = SINE OF THE POLAR (THETA) ANGLE OF "SCATTERING"
C        SFE,CFE  = SINE AND COSINE OF THE AZIMUTHAL (PHI) ANGLE
C                   OF "SCATTERING"
C
C     OUTPUT VARIABLES:
C        X,Y,Z     = NEW DIRECTION COSINES
C
C     ROTATION OF COORDINATE SYSTEM (SEE CERN 64-47 )
C********************************************************************
C
*
*  Changed by A. Ferrari
*
      A = XO**2 + YO**2
      IF ( A .LT. ANGLSQ ) THEN
         X=SDE*CFE
         Y=SDE*SFE
C     Z=CDE CORRECTED AUGUST 88 PA
         Z=CDE*ZO
      ELSE
         XI=SDE*CFE
         YI=SDE*SFE
         ZI=CDE
         A=SQRT(A)
         X=-YO*XI/A-ZO*XO*YI/A+XO*ZI
         Y=XO*XI/A-ZO*YO*YI/A+YO*ZI
         Z=A*YI+ZO*ZI
      END IF
      RETURN
      END
+DECK,  TWOPAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:02  cernlib
* Geant

*$ CREATE TWOPAD.FOR
*COPY TWOPAD
*=== twopad ===========================================================*
      SUBROUTINE TWOPAD(UMO,ECM1,ECM2,PCM1,PCM2,COD1,COF1,SIF1,
     *COD2,COF2,SIF2,AM1,AM2)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(1)
C*****TWO PARTICLE DECAY IN THE CM - SYSTEM
      COMMON /FKGAMR/ REDU,AMO,AMM(15 )
      UMO2=UMO*UMO
      AM11=AM1*AM1
      AM22=AM2*AM2
      ECM1=(UMO2+AM11-AM22)/(2.D0*UMO)
      ECM2=UMO-ECM1
      WAU=ECM1**2-AM11
      IF (WAU.LT.0.D0) REDU=REDU-5.D0
      WAU=ABS(WAU)
      PCM1=SQRT(WAU)
      PCM2=PCM1
      CALL COSI(SIF1,COF1)
      CALL GRNDM(RNDM,1)
      COD1=RNDM(1)
      COD1=2.D0*COD1-1.D0
      COD2=-COD1
      COF2=-COF1
      SIF2=-SIF1
      RETURN
      END
+DECK,  TWOPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:58  cernlib
* Geant

*$ CREATE TWOPAR.FOR
*COPY TWOPAR
*=== twopar ===========================================================*
      SUBROUTINE TWOPAR(E1,E2,P1,P2,COD1,COD2,COF1,COF2,SIF1,SIF2,
     1IT1,IT2,UMOO,ECM,P,N,AM1,AM2)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
C     ******************************************************
C     QUASI TWO PARTICLE PRODUCTION
C     TWOPAR CALCULATES THE ENERGYS AND THE MOMENTA
C     FOR THE CREATED PARTICLES OR RESONANCES IT1 AND IT2
C     IN THE CM - SYSTEM
C     COD1,COD2,COF1,COF2,SIF1,SIF2 ARE THE ANGLES FOR
C     SPHERICAL COORDINATES
C     ******************************************************
      COMMON /FKGAMR/ REDU,AMO,AMM(15 )
      COMMON/FKABLT/AM(110),GA(110),TAU(110),ICH(110)
     *,IBAR(110),K1(110),K2(110)
   9   CONTINUE
      AMA=AM1
      AMB=AM2
      AMA2=AMA*AMA
      AMB2=AMB*AMB
      S=UMOO*UMOO
      E1=(S-AMB2+AMA2)/(2.D0*UMOO)
      E2=(S-AMA2+AMB2)/(2.D0*UMOO)
      AMTE=MAX(E1*E1-AMA2,ZERZER)
  11  CONTINUE
      AMTE=AMTE
      P1=SQRT(AMTE)
      P2=P1
C     / P2 / = / P1 /  BUT OPPOSITE DIRECTIONS
C     DETERMINATION  OF  THE ANGLES
C     COS(THETA1)=COD1      COS(THETA2)=COD2
C     SIN(PHI1)=SIF1        SIN(PHI2)=SIF2
C     COS(PHI1)=COF1        COS(PHI2)=COF2
C     PHI IS UNIFORMLY DISTRIBUTED IN ( 0,2*PI )
      CALL COSI(COF1,SIF1)
      COF2=-COF1
      SIF2=-SIF1
C     CALCULATION OF THETA1
      CALL TCHOIC(TR,P,P1,ECM,E1,IT1,IT2,N,AM1,AM2)
      COD1=(TR-AMA2-AM(N)*AM(N)+2.D0*ECM*E1)/(2.D0*P*P1+1.D-18)
      IF (ABS(COD1) .GT. 1.D+00) COD1 = SIGN (ONEONE,COD1)
      COD2=-COD1
      RETURN
      END
+DECK,  VEREIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE VEREIN.FOR
*COPY VEREIN
*=== verein ===========================================================*
      SUBROUTINE VEREIN(IT,LA,LT,RER,REL,RPXR,RPYR,RPZR,RPXL,RPYL,RPZL,
     *KR1R,KR2R,KR1L,KR2L,IHAD,LL,KFR1,KFR2,IMPS,IMVE,IB08,IA08,
     *IB10,IA10,B3,AS,B8,IAR,KFA1,KFA2,KFA3,KFA4,IOPT)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*  Verein89: slight revision by A. Ferrari                             *
*----------------------------------------------------------------------*
*
+CDE, FINPAR2.
+CDE, PART.
      DIMENSION KFR1(*),KFR2(*),IMPS(6,6)
*
      PARAMETER (KMXJCM = 100)
      DIMENSION IV(KMXJCM)
      DIMENSION IMVE(6,6),IB08(6,21),IA08(6,21),IB10(6,21),IA10(6,21)
      REAL RNDM(1)
C*****VEREIN COMBINES THE TWO JETS INTO A COMPLETE E+E- EVENT OR INTO
C*****A COMPLETE QQQ (AQ,AQ,AQ) EVENT
C*****RER,REL,RPXR,RPXL,RPYR,RPYL,RPZR,RPZL ARE REST JET ENERGIES AND
C*****MOMENTA , KR1R,KR1L,KR2R,KR2L ARE REST JET FLAVOURS
*
*     R is for right, L for left!
*
*  Initialize Iv
*
      DATA IV /KMXJCM*0/
      IF(LT.EQ.0) GO TO 300
      WRITE(LUNOUT,202)IT
  202 FORMAT(1H0,I5,3H=IT)
  300 CONTINUE
C*****ONLY ONE RESONANCE WILL BE CREATED IF IT=0
      IF(IT.EQ.0) GO TO 100
      IF(KR2R.EQ.0.OR.KR1R.EQ.0)GO TO 10
      IF(KR1L.EQ.0.OR.KR2L.EQ.0)GO TO 10
C*****RESTJET CONTAINS FOUR QUARKS,THEREFORE TWO MESONS WILL BE FORMED
*
*  Reg is et equal to the sum of the left and right jet energy rest,
*  the same for momenta
*
      REG=RER+REL
      RPXG=RPXR+RPXL
      RPYG=RPYR+RPYL
      RPZG=RPZR+RPZL
      J=IT+1
      I=IT+2
      IT=J
*
*  Hklass uses always only Iv(i) with i >= it, so from the previous
*  instructions, it is always > than the original it , so the used
*  Iv's should be always 0 also in the bamjet original array ?????
*
      CALL HKLASS(IT,LT,LA,LL,KFR1,KFR2,KR1R,KR2R,KR1L,KR2L,IV,IMPS,
     &IMVE,IB08,IA08,IB10,IA10,AS,B8,KFA1,KFA2,KFA3,KFA4,IOPT)
      IHAD=IHAD+2
      IF(LT.EQ.1) WRITE(LUNOUT,301)IHAD
  301 FORMAT(1H0,13HHADRONANZAHL=,I5)
      GO TO 20
C*****RESTJET CONTAINS TWO OR THREE QUARKS,THEREFORE ONE MESON OR ONE
C*****BARYON OR ONE ANTIBARYON  WILL BE FORMED
   10 CONTINUE
      IAK=IT
      CALL GRNDM(RNDM,1)
      X=RNDM(1)
      IF(X.LE.0.5D0.AND.IAR.NE.0) IAK=IAR
      REG=RER+REL+HEF(IAK)
      RPXG=RPXR+RPXL+PXF(IAK)
      RPYG=RPYR+RPYL+PYF(IAK)
      RPZG=RPZR+RPZL+PZF(IAK)
      I=IT+1
      J=IAK
      IT=I
*
*  Hklass uses always only Iv(i) with i >= it, so from the previous
*  instructions, it is always > than the original it , so the used
*  Iv's should be always 0 also in the bamjet original array ?????
*
      CALL HKLASS(IT,LT,LA,LL,KFR1,KFR2,KR1R,KR2R,KR1L,KR2L,IV,IMPS,
     &IMVE,IB08,IA08,IB10,IA10,AS,B8,KFA1,KFA2,KFA3,KFA4,IOPT)
*  Hp1 is not used, also Hp2 !!!
*     HP2=HP1
      IHAD=IHAD+1
      IF(LT.EQ.1) WRITE(LUNOUT,301)IHAD
   20 CONTINUE
      RPG=SQRT(RPXG**2+RPYG**2+RPZG**2)
      IF(RPG.GT.REG) LA=3
      IF(LA.EQ.3.AND.LT.GT.0) WRITE(LUNOUT,71)
   71 FORMAT(2X,'REST JET MOMENTUM IS GREATER THAN REST JET ENERGY')
      IF(LA.EQ.3) RETURN
      RMG=SQRT((REG-RPG)*(REG+RPG))
      HM1=AMF(J)
      HM2=AMF(I)
      IF(RMG.LT.HM1+HM2) LA=3
      IF(LA.EQ.3.AND.LT.GT.0) WRITE(LUNOUT,71)
      IF(LA.EQ.3) RETURN
      IF(LT.EQ.0) GO TO 30
      WRITE(LUNOUT,60)REG,RMG,RPG,HM1,HM2,J,I
   60 FORMAT(1H0,19HEG,MG,PG,M1,M2,J,I=,5F8.4,2I3)
C     LORENZ PARAMETERS
   30 CONTINUE
      GAA=REG/RMG
      GABE=RPG/RMG
C     DECAY INTO 2 HADRONS IN THE CMS OF THE REMAINDER
      HE1=(RMG**2+HM1**2-HM2**2)/(2.D0*RMG)
      HE2=RMG-HE1
*   Hp1 is not used !
*     HP1=SQRT(HE1**2-HM1**2)
C     SAMPLES THE MOMENTUM DIRECTIONS OF THE LAST PARTICLES
      HE=HE1
      HMA=HM1
      CALL FKIMPU(HE,HMA,HPS,HPX,HPY,HPZ,LT,LL,B3)
      HP1X=HPX
      HP1Y=HPY
      HP1Z=HPZ
      HP2X=-HP1X
      HP2Y=-HP1Y
      IF (IOPT.EQ.4.AND.HM2.GT.HM1)  GO TO 999
      HP1Z=-HPZ
      HP2Z=HPZ
  999 CONTINUE
      HP2Z=-HP1Z
      IF(RPG.EQ.0.D0)GO TO 80
C     ROTATION BACK TO THE CMS*
      HEX=HE1*GAA+HP1Z*GABE
      HEY=HE2*GAA+HP2Z*GABE
      HP1Z=HE1*GABE+HP1Z*GAA
      HP2Z=HE2*GABE+HP2Z*GAA
      HE1=HEX
      HE2=HEY
C     ROTATION INTO THE CMS OF THE E+ E-  COLLISION
      X=HP1X
      Y=HP1Y
      Z=HP1Z
      COTE=RPZG/RPG
      SITE=SQRT((1.D0-COTE)*(1.D0+COTE))
      IF(SITE.EQ.0.D0) GO TO 11
      COV=RPXG/(RPG*SITE)
      SIV=RPYG/(RPG*SITE)
      GO TO 12
   11 CONTINUE
      SIV=1.D0
      COV=0.D0
   12 CONTINUE
      COPS=-SIV
      SIPS=COV
      CALL DRELAB(X,Y,Z,COTE,SITE,COPS,SIPS)
      HP1X=X
      HP1Y=Y
      HP1Z=Z
      X=HP2X
      Y=HP2Y
      Z=HP2Z
      CALL DRELAB(X,Y,Z,COTE,SITE,COPS,SIPS)
      HP2X=X
      HP2Y=Y
      HP2Z=Z
   80 CONTINUE
      HEF(J)=HE1
      PXF(J)=HP1X
      PYF(J)=HP1Y
      PZF(J)=HP1Z
      HEF(I)=HE2
      PXF(I)=HP2X
      PYF(I)=HP2Y
      PZF(I)=HP2Z
      IF(LT.EQ.0)GO TO 13
      WRITE(LUNOUT,50)HEF(J),PXF(J),PYF(J),PZF(J)
      WRITE(LUNOUT,50)HEF(I),PXF(I),PYF(I),PZF(I)
   50 FORMAT(1H0,11HE,PX,PY,PZ=,4F8.4)
   13 CONTINUE
      GO TO 200
  100 CONTINUE
C*****ONLY ONE RESONANCE WILL BE CREATED IF IT=0
      IF(LT.EQ.0)GO TO 14
      WRITE(LUNOUT,70)
   70 FORMAT(1H0,'CUT OFF OF THE LEFT AND RIGHT JET BEFOR THE FIRST
     *DECAY STEP',/,'IF ALLOWED ONLY ONE RESONANCE COULD BE CREATED')
   14 CONTINUE
      IHAD=1
*
*  La = 2 means resonance creation
*
      LA=2
  200 CONTINUE
      RETURN
      END
+DECK,  VERTEX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== vertex ===========================================================*
      SUBROUTINE VERTEX(IT,LT,LL,KFA,E0,IV,RE,KFR1,KFR2,AME,IOPT)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      REAL RNDM(2)
C     CHOICE OF THE VERTEX
      DIMENSION RE(*),KFR1(*),KFR2(*),IV(*)
C     WAEHLT PASSENDEN VERTEX IV AUS
       IF(LT.EQ.1) WRITE(LUNOUT,288)IT,LT,LL,KFA,E0,AME,IOPT
  288 FORMAT (4I5,2E12.4,I5,' VERTEX IT,LT,LL,KFA,E0,AME')
      PDB=0.8D0
      IVA=1
      I=IT
      J=IT-1
      IVX=IVA
      IF(IOPT.EQ.2) IVX=2
      IF(IOPT.EQ.4.AND.KFA.GT.6.AND.LL.EQ.0) IVX=2
      IF(IOPT.EQ.4.AND.KFA.LE.6.AND.LL.EQ.1) IVX=2
      IF(IOPT.EQ.5) IVX=2
      IF(I.GT.1)IVX=IV(J)
      IF(LL.EQ.1.AND.I.GT.1)IVX=IV(J)-5
      CALL GRNDM(RNDM,2)
      Z=RNDM(1)
      Y=RNDM(2)
      GO TO (1,2,1,2,2),IVX
    1 IVX=1
      IF(Z.GE.AME) IVX=2
      GO TO 20
    2 IVX=3
      IF(Z.GT.PDB) IVX=4
      IF(Z.GT.PDB.AND.Y.LE.0.5D0)  IVX=5
      GO TO 20
   20 CONTINUE
      IF(LL.EQ.1)IVX=IVX+5
      IV(I)=IVX
      IF(LT.EQ.0)GO TO 60
C     AUSDRUCKEN
      IF(I.EQ.1)GO TO 30
      WRITE(LUNOUT,50)IV(J),IV(I),LL
      GO TO 40
   30 WRITE(LUNOUT,50)IVA,IV(I),LL
   40 CONTINUE
   50 FORMAT(1H0,15HIV(J),IV(I),LL=,3I5)
   60 CONTINUE
      RETURN
      END
+SELF.
+DECK,  XLAMB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:03  cernlib
* Geant

*$ CREATE XLAMB.FOR
*COPY XLAMB
*=== xlamb ============================================================*
      FUNCTION XLAMB(X,Y,Z)

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      COMMON /FKIDGB/ IDGB,IDG
      COMMON /FKGAMR/ REDU,AMO,AMM(15 )
      COMMON/FKDREI/TEST(12)
      COMMON/FKPRUN/ISYS
      YZ=Y-Z
      XLAMB=X*X-2.D0*X*(Y+Z)+YZ*YZ
      XLAM =XLAMB
      IF (IDGB.LE.0) GO TO 11
      IF(XLAMB.GT.1.D-12) GOTO 11
      WRITE(ISYS,12)
      WRITE(ISYS,10) XLAM,X,Y,Z,TEST
      WRITE(ISYS,13)
   12 FORMAT(/,10X,12H XLAMB PRINT)
   13 FORMAT(10X,60(1H*))
   10 FORMAT(4E20.8,5HXLAMB,/,12F10.5)
   11 CONTINUE
      IF(XLAMB.LE.0.D0)XLAMB=ABS(XLAMB)
      XLAMB=SQRT(XLAMB)
      RETURN
      END
+DECK,  XSENEU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:05  cernlib
* Geant

*$ CREATE XSENEU.FOR
*COPY XSENEU
*=== xseneu ===========================================================*
      FUNCTION XSENEU ( E, ZTAR, ATAR )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 20 september 1991 by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 20-sep-91     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, XSEPAR.
*
       IZ = NINT ( ZTAR )
       IF ( E .GT. 0.1D+00 ) THEN
          EMEV = E * 1.D+03
          XSENEU = SITSAO ( EMEV, IZ, ATAR )
       ELSE IF ( E .GT. 0.012D+00 ) THEN
          X  = 1.D+01 * E
          XSENEU = AANXSE (IZ) * ( X - ZZNXSE (IZ) ) / X * ( 1.D+00
     &           + BBNXSE (IZ) * X / ( 1.D+00 + (CCNXSE(IZ)*X)**2 )
     &           + DDNXSE (IZ) * X * X / ( 1.D+00 + (EENXSE(IZ)*X)**4 ))
       ELSE
          XSENEU = 0.D+00
       END IF
       XSENEU = MAX ( XSENEU, ZERZER )
*=== End of function Xseneu ===========================================*
       RETURN
       END
+DECK,  XSEPRO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:05  cernlib
* Geant

*$ CREATE XSEPRO.FOR
*COPY XSEPRO
*=== xsepro ===========================================================*
      FUNCTION XSEPRO ( E, ZTAR, ATAR )

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 20 september 1991 by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 20-sep-91     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, XSEPAR.
       COMMON / FKNEGX / XSENEG
*
       IZ = NINT ( ZTAR )
       IF ( E .GT. 0.1D+00 ) THEN
          EMEV = E * 1.D+03
          XSEPRO = SITSAO ( EMEV, IZ, ATAR )
       ELSE
          X  = 1.D+01 * E
          X2 = X * X
          XSEPRO = AAPXSE (IZ) * ( X - ZZPXSE (IZ) ) / X * ( 1.D+00
     &           + BBPXSE (IZ) * X + CCPXSE (IZ) * X2 + DDPXSE (IZ)
     &           * X * X2 + EEPXSE (IZ) * X2 * X2 + FFPXSE (IZ) * X2
     &           * X * X2 )
          IF ( XSEPRO .LT. 0.D+00 ) THEN
             XSENEG = XSEPRO
             XSEPRO = 0.D+00
          END IF
       END IF
*=== End of function XSEPRO ===========================================*
       RETURN
       END
+DECK,  ZEROIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:04  cernlib
* Geant

+SELF, IF=OLDNAME.
*=== zeroin ===========================================================*
      SUBROUTINE ZEROIN

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*======================================================================*
*                                                                      *
*     Created by Alfredo Ferrari on 11 july 1990   INFN - Milan        *
*                                                                      *
*     Last change  on    23-apr-93  by  Alfredo Ferrari                *
*                                                                      *
*     This routine zeroes a few arrays, and initialize some data       *
*                                                                      *
*======================================================================*
*
+CDE, PAPROP.
+CDE, PART2.
*
*  +-------------------------------------------------------------------*
*  |               Set the "effective" masses for particles
      DO 8000 I = 1, IDMAX8
*  |  +----------------------------------------------------------------*
*  |  |            Baryons: "effective" mass = actual one - baryon
*  |  |                      number x proton mass (final state of any
*  |  |                      baryon)
         IF ( IIBAR (I) .GT. 0 ) THEN
            AAMDSC (I) = AAM (I) - IIBAR (I) * AAM (1)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |            Antibaryons: "effective mass" = actual mass +
*  |  |                          |baryon number| x proton mass
         ELSE IF ( IIBAR (I) .LT. 0 ) THEN
            AAMDSC (I) = AAM (I) - IIBAR (I) * AAM (1)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |            Mesons: "effective" mass = actual mass
         ELSE
            AAMDSC (I) = AAM (I)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 8000 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*    Electron: "effective" mass = 0
      AAMDSC (3) = ZERZER
*    Positron: "effective" mass = 2 x mass
      AAMDSC (4) = 2.D+00 * AAM (4)
*    Neutron: "effective" mass = 0 (it should be taken into account the
*                         neutrino energy when decaying)
      AAMDSC (8) = ZERZER
*    Muon+: "effective" mass = muon mass + positron mass
      AAMDSC (10) = AAM (10) + AAM (4)
*    Muon-: "effective" mass = muon mass - electron mass
*           (final stable state)
      AAMDSC (11) = AAM (11) - AAM (3)
*    Tau+: "effective" mass = Tau mass + positron mass
      AAMDSC (131) = AAM (131) + AAM (4)
*    Tau-: "effective" mass = Tau mass - electron mass
*           (final stable state)
      AAMDSC (132) = AAM (132) - AAM (3)
*  +-------------------------------------------------------------------*
*  |               Set the "effective" masses for particles in Paprop
      DO 8500 I = 1, NALLWP
         KP = IPTOKP (I)
*  |  +----------------------------------------------------------------*
*  |  |
         IF ( KP .GT. 0 ) THEN
            AMDISC (I) = AAMDSC (KP)
            AM     (I) = AAM  (KP)
            ICHRGE (I) = IICH (KP)
            THALF  (I) = TAU  (KP)
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE IF ( I .NE. 30 ) THEN
            AMDISC (I) = ZERZER
            AM     (I) = ZERZER
            ICHRGE (I) = 0
            THALF  (I) = ZERZER
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            AMDISC (I) = AAMDSC (1)
            AM     (I) = AAM  (1)
            ICHRGE (I) = IICH (1)
            THALF  (I) = TAU  (1)
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
*  |  +----------------------------------------------------------------*
*  |  |   Set the particle spin (in 1/2 units)
*  |  |   If the particle is a hadron :
*  |  |            mesons         --> 0 spin
*  |  |       baryons,antibaryons --> 1/2 spin
*  |  |   otherwise :
*  |  |       e-/+,mu-/+,vu,vubar --> 1/2 spin
*  |  |             photons       --> 1 spin
         IF ( LHADRO (I) .AND. IIBAR (KP) .EQ. 0 ) THEN
            JSPINP (I) = 0
*  |  |
*  |  +----------------------------------------------------------------*
*  |  |
         ELSE
            IF ( I .EQ. 7 ) THEN
               JSPINP (I) = 2
            ELSE
               JSPINP (I) = 1
            END IF
         END IF
*  |  |
*  |  +----------------------------------------------------------------*
 8500 CONTINUE
*  |
*  +-------------------------------------------------------------------*
*=== end of subroutine zeroin =========================================*
      RETURN
      END
+SELF.
+PATCH, FIFACE.
+DECK,  FLDIST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:53  cernlib
* Geant

      SUBROUTINE FLDIST
+CDE, GCFLAG.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCTRAK.
+CDE, GCMATE.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCJLOC.
+CDE, DIMPAR.
+SELF, IF=-SINGLE.
+CDE, COMCONT.
+SELF.
+CDE, COMCON.
+SELF, IF=-SINGLE.
+CDE, PARTT.
+SELF.
+CDE, PART.
+CDE, GFKDIS.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION SII, ZLL, SIE, ZEL, ONE, PFLUKA
+SELF.
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/

      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      IGF=0
*     IF (IPART.EQ.13.AND.GEKIN.LE.0.05) THEN
      IF (IPART.EQ.13.AND.GEKIN.LE.0.02) THEN
         IGF=1
         CALL GPGHEI
         SINE = 0.
         SELA = 0.
         FSIG = 0.
         GO TO 999
      ENDIF
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      IJ = IGTOFL(IPART)
      ZINE  = BIG
      ZELA  = BIG
      IF(IJ.GT.0) THEN
         PFLUKA = SQRT(GEKIN*(GEKIN+2*AM(IJ)))
         JMA = LQ(JMATE-NMAT)
         NCOMP = ABS(Q(JMA+11))
         DENS = Q(JMA+8)
         JMIXT = LQ(JMA-5)
         IF ( NCOMP .LE. 1) THEN
            CALL NIZLNW(IJ,ONE*Z,ONE*A,ONE*GEKIN,PFLUKA, SII,ZLL)
            IF (ZLL.LT.BIG) THEN
               ZINE = ZLL/DENS
            END IF
         ELSE
            ZIN1 = 0.
            DO 10 K=1,NCOMP
               CALL NIZLNW(IJ,ONE*Q(JMIXT+NCOMP+K),
     +         ONE*Q(JMIXT+K),ONE*GEKIN,PFLUKA,SII,ZLL)
               IF (ZLL.GT.BIG) THEN
                  ZIN1 = 0.0 + ZIN1
               ELSE
                  ZIN1 = DENS*Q(JMIXT+2*NCOMP+K)/ZLL + ZIN1
               END IF
               CABINX(K) = ZIN1
   10       CONTINUE
            ANXNOR = ZIN1
            IF (ZIN1.GT.0.0) THEN
               ZINE = 1./ZIN1
            END IF
         END IF
         IF ( NCOMP .LE. 1) THEN
            CALL SIGEL (IJ,ONE*A,ONE*GEKIN,PFLUKA, SIE,ZEL)
            IF (ZEL.LT.BIG) THEN
               ZELA = ZEL/DENS
            END IF

         ELSE
            ZEL1 = 0.
            DO 20 I=1,NCOMP
               CALL SIGEL (IJ,ONE*Q(JMIXT+I),ONE*GEKIN, PFLUKA,
     +         SIE,ZEL)
               IF (ZEL.LT.BIG) THEN
                  ZEL1 = DENS*Q(JMIXT+2*NCOMP+I)/ZEL + ZEL1
               END IF
               CABELX(I) = ZEL1
   20       CONTINUE
            ELXNOR = ZEL1
            IF (ZEL1.GT.0.0) THEN
               ZELA = 1./ZEL1
            END IF
         END IF
      ENDIF
      IF (ZINE.EQ.BIG) THEN
         SINE = 0.0
      ELSE
         SINE = 1./ZINE
      END IF
      IF (ZELA.EQ.BIG) THEN
         SELA = 0.0
      ELSE
         SELA = 1./ZELA
      END IF
      FSIG = SINE + SELA
      IF (FSIG .LE. 0) THEN
         SHADR = BIG
      ELSE
         SHADR = ZINTHA/FSIG
      END IF
  999 CONTINUE
      END
+DECK,  FLINIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:53  cernlib
* Geant

      SUBROUTINE FLINIT
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCCUTS.
+CDE, GSECTI.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, DIMPAR.
+SELF, IF=DOUBLE.
+CDE, COMCONT.
+SELF.
+CDE, COMCON.
+CDE, IOUNIT.
+CDE, GFKDIS.
      CHARACTER*(*) SDUM
      PARAMETER (SDUM='        ')
+SELF, IF=DOUBLE.
      DOUBLE PRECISION WHAT(6)
+SELF, IF=SINGLE.
      REAL WHAT(6)
+SELF.
      DATA WHAT/6*0./
+SELF, IF=UNIX,VAX.
      OPEN(UNIT=LUNERR,FILE='flukaerr.dat',STATUS='UNKNOWN')
+SELF, IF=IBM.
      OPEN(UNIT=LUNERR,FILE='/FLUKAERR DAT')
+SELF.
      CALL FDNOPT
      CALL FLKDT1
      CALL FLKDT2
      CALL FLKDT3
      CALL FLKDT4
      CALL FLKDT5
      CALL FLKDT6
      CALL FLKDT7
      CALL FDEVAP
      CALL FDPREE
      CALL FKZERO
      CALL EVVINI(WHAT,SDUM)
      IFINIT(5)=1
      print *,'*****************************************************'
      print *,'**  You are requesting the GEANT-FLUKA interface:  **'
      print *,'**  for conditions and warnings see the comments   **'
      print *,'**  in GUPHAD/GUHADR and/or the GEANT manual.      **'
      print *,'*****************************************************'
*
      END
+DECK,  FLUFIN, T=FORT.
* Revision 1.4  1999/11/05 08:57:23  japost
*      Added Xi- to the list of particles that are forced to decay
*                          Thanks to Federico Carminati
* Revision 1.3  1997/06/20 18:32:55  japost
* A summary of the problem buf fix and its original report:
* ------------------------------------------------------------------------------
* From: Shawn McKee - (313) 764-4395 <mckee@pooh.physics.lsa.umich.edu>
* Subject: RE: Problem with FLUKA interface
* Date: Thu, 12 Jun 97 18:09:31 METDST
* I have seen this error with FLUKA.  I traced it to
* the following statement:
*      IF (RNDEVT .GE. SINE/FSIG) THEN
* Apparently FSIG (for this event) was not initialized
* properly (it is 0.0).  My fix was to insert a check
* on FSIG in the FLUFIN routine source.
* ------------------------------------------------------------------------------
* From: pniemine@estwm0.wm.estec.esa.nl
* Subject: Problem with FLUKA interface - cern.heplib #5667
* Date: Thu, 12 Jun 97 17:21:14 METDST
* In trying to run a GEANT program with FLUKA interface in our VMS-AXP (Alpha)
* cluster, I get the following error message (originating from FLUFIN) once
* a hadronic interaction is to be simulated:
* arithmetic trap, floating/decimal divide by zero
* ------------------------------------------------------------------------------
* Revision 1.2  1996/02/27 14:12:57  ravndal
* Correction for overstopped antiprotons
* Revision 1.1.1.1  1995/10/24 10:19:53  cernlib
* Geant

      SUBROUTINE FLUFIN
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCPHYS.
+CDE, GCTRAK.
+CDE, GSECTI.
+CDE, GCTMED.
+CDE, GCUNIT.
+CDE, DIMPAR.

+SELF, IF=-SINGLE.
+CDE, FINUCT.
+SELF.
+CDE, FINUC.
      REAL RNDM(1)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
+SELF.
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
+SELF, IF=-SINGLE.
+CDE, PART2T.
+SELF.
+CDE, PART2.
+SELF, IF=-SINGLE.
+CDE, COMCONT.
+SELF.
+CDE, COMCON.
+SELF, IF=-SINGLE.
+CDE, FHEAVYT.
+SELF.
+CDE, FHEAVY.
+CDE, PAPROP.
+SELF, IF=-SINGLE.
+CDE, PAPROPT.
+SELF.
+CDE, GFKDIS.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
+SELF.
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/

      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
      NP = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+, K+/K- and Xi- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF ((IGF.EQ.1).OR.
     +      (GEKIN.EQ.0..AND.ITRTYP.EQ.3.AND.IPART.NE.25)) THEN
         CALL GHEISH
         IGF = 0
         GOTO 999
      ELSE IF (GEKIN.EQ.0..AND.
     +   (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11.OR.IPART.EQ.23)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)

*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         NMEC=NMEC+1
         LMEC(NMEC)=17
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         LMEC(NMEC)=30
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)

      IF (FSIG.LE.0.) THEN
         SRAT = 1.E7
      ELSE
         SRAT = SINE/FSIG
      ENDIF
      IF ( RNDEVT .GE. SRAT) THEN
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
      ELSE
         ISTOP=1
         NSTAK1 = MIN(NP,MXGKIN-NGKINE)
         IF(NP.GT.NSTAK1) THEN
            WRITE(CHMAIL,10000) NP-NSTAK1
            CALL GMAIL(0,0)
         ENDIF
         DO 90  K=1,NSTAK1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NSTAK2 = MIN(NPHEAV,MXGKIN-NGKINE)
         IF(NPHEAV.GT.NSTAK2) THEN
            WRITE(CHMAIL,10100) NPHEAV-NSTAK2
            CALL GMAIL(0,0)
         ENDIF
         DO 100 K=1,NSTAK2
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
         KCASE=NAMEC(12)
      END IF
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
10000 FORMAT(' **** FLUFIN: Stack overflow, ',I6,' particles lost')
10100 FORMAT(' **** FLUFIN: Stack overflow, ',I6,
     +' heavy particles lost')
  999 END
+PATCH, BLOCK.
+DECK,  FDEVAP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:35  cernlib
* Geant

*$ CREATE BDEVAP.FOR
*COPY BDEVAP
*=== bdevap ===========================================================*
      SUBROUTINE FDEVAP

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Block Data for the EVAPoration routines:                         *
*                                                                      *
*     Created on    20 may 1990    by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Modified from the original version of J.M.Zazula                 *
*     and, for cookcm, from a LAHET block data kindly provided by      *
*     R.E.Prael-LANL                                                   *
*                                                                      *
*     Last change on  28-jan-93    by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, EVA0.
+CDE, HETTP.
+CDE, HETC7.
+CDE, INPFLG.
*
      DATA B01   / 8.D+00 /, Y01 / 1.5D+00 /
      DATA IANG1 / 1 /, IFISS1 / 0 /,  IB01 / 2 /, IGEOM1 / 0 /
      DATA ISTRA1 /0/, KEYDK1 /0/
      DATA NBERT1 /LUNBER/
      DATA COSTH1 /1.D+00/, SINTH1 /0.D+00/, COSPH1 /1.D+00/,
     &     SINPH1/0.D+00/
*
      B0=B01
      Y0=Y01
      IANG=IANG1
      IFISS=IFISS1
      IB0=IB01
      IGEOM=IGEOM1
      ISTRAG=ISTRA1
      KEYDK=KEYDK1
      NBERTP=NBERT1
      COSTH=COSTH1
      SINTH=SINTH1
      COSPHI=COSPH1
      SINPHI=SINPH1
      END
+DECK,  FDNOPT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:35  cernlib
* Geant

*$ CREATE BDNOPT.FOR
*COPY BDNOPT
*=== bdnopt ===========================================================*
*==                                                                    *
      SUBROUTINE FDNOPT

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*   Created on  20 september 1989    by  Alfredo Ferrari - Infn Milan  *
*                                                                      *
*         Last change on 09-mar-93   by  Alfredo Ferrari               *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, FHEAVY.
+CDE, FINUC.
+CDE, PAREVT.
+CDE, RESNUC.
*
      CHARACTER*8 ANHEA1(12)
      DIMENSION AMHEA1(12),ICHEA1(12),IBHEA1(12)
      LOGICAL LDIFF1,LPOWE1,LINCT1,LEVPR1,LHEAV1,LDEEX1,LGDHP1
     &       ,LPREE1,LHLFI1,LPRFI1,LPARW1
      DIMENSION LDIFF1(39)
      LOGICAL LRNFS1

* /fheavy/
      DATA AMHEA1 / 12 * 0.D+00 /
      DATA ANHEA1 / 'NEUTRON ', 'PROTON  ', 'DEUTERON', '3-H     ',
     &              '3-He    ', '4-He    ', 'H-FRAG-1', 'H-FRAG-2',
     &              'H-FRAG-3', 'H-FRAG-4', 'H-FRAG-5', 'H-FRAG-6'/
      DATA ICHEA1 / 0, 1, 1, 1, 2, 2, 6*0 /,
     &     IBHEA1 / 1, 1, 2, 3, 3, 4, 6*0 /
      DATA NPHEA1 / 0 /

* /finuc/
      DATA NP1/ 0 /, TV1/ 0.D+00 /, TVCMS1/ 0.D+00 /, TVREC1 / 0.D+00/,
     &     TVHEA1 / 0.D+00 /, TVBIN1 / 0.D+00 /

* /parevt/
      DATA DPOWE1 /-13.D+00 /, FSPRD1 / 0.6D+00 /, FSHPF1 / 0.0D+00 /,
     &     RN1GS1 /-1.0D+00 /, RN2GS1 /-1.0D+00 /
      DATA LDIFF1 /  .TRUE., .FALSE., 6 * .TRUE., .FALSE., 8 * .TRUE.,
     &              .FALSE., 4 * .TRUE., .TRUE., 2 * .TRUE.,
     &              8 * .FALSE., .TRUE., .FALSE., .TRUE., .FALSE.,
     &              .TRUE., .FALSE. /
      DATA LPOWE1 / .TRUE.  /, LINCT1 / .TRUE.  /, LEVPR1 / .TRUE.  /,
     &     LHEAV1 / .TRUE.  /, LDEEX1 / .TRUE.  /, LGDHP1 / .TRUE.  /,
     &     LPREE1 / .TRUE.  /, LHLFI1 / .FALSE. /, LPRFI1 / .FALSE. /,
     &     LPARW1 / .TRUE. /
      DATA ILVMO1 / 0 /

* /resnuc/
      DATA IEVPL1 / 0 /, IEVPH1 / 0 /, IEVNE1 / 0 /, IEVPR1 / 0 /,
     &     IEVTR1 / 0 /, IEVDE1 / 0 /, IEV3H1 / 0 /, IEV4H1 / 0 /,
     &     IDEEX1 / 0 /
      DATA LRNFS1 / .FALSE. /
*
      DO 10 J=1,12
         AMHEAV(J) = AMHEA1(J)
         ANHEAV(J) = ANHEA1(J)
         ICHEAV(J) = ICHEA1(J)
         IBHEAV(J) = IBHEA1(J)
  10  CONTINUE
      NPHEAV = NPHEA1
*
      NP=NP1
      TV=TV1
      TVCMS=TVCMS1
      TVRECL=TVREC1
      TVHEAV=TVHEA1
      TVBIND=TVBIN1
*
      DPOWER = DPOWE1
      FSPRD0 = FSPRD1
      FSHPFN = FSHPF1
      RN1GSC = RN1GS1
      RN2GSC = RN2GS1
      DO 20 J=1,39
        LDIFFR(J) = LDIFF1(J)
  20  CONTINUE
      LPOWER = LPOWE1
      LINCTV = LINCT1
      LEVPRT = LEVPR1
      LHEAVY = LHEAV1
      LDEEXG = LDEEX1
      LGDHPR = LGDHP1
      LPREEX = LPREE1
      LHLFIX = LHLFI1
      LPRFIX = LPRFI1
      LPARWV = LPARW1
      ILVMOD = ILVMO1
*
      IEVAPL = IEVPL1
      IEVAPH = IEVPH1
      IEVNEU = IEVNE1
      IEVPRO = IEVPR1
      IEVTRI = IEVTR1
      IEVDEU = IEVDE1
      IEV3HE = IEV3H1
      IEV4HE = IEV4H1
      IDEEXG = IDEEX1
      LRNFSS = LRNFS1
*=                                               end*block.bdnopt      *
      END
+DECK,  FDPREE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:36  cernlib
* Geant

*=== bdpree ===========================================================*
      SUBROUTINE FDPREE

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 16 september 1991 by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 23-feb-93     by    Alfredo Ferrari               *
*                                                                      *
*                                                                      *
*----------------------------------------------------------------------*
*
+CDE, NUCGEO.
+CDE, NUCLEV.
      LOGICAL LABRS1,LELST1,LINEL1, LCHEX1, LBSRP1, LABST1
      DIMENSION JUSNU1(160,2), MAGNU1(8)
*
*
      DATA LABRS1, LELST1, LINEL1, LCHEX1, LBSRP1, LABST1 / 6*.FALSE. /
      DATA POTBA1 / POTBA0 /, POTME1 / POTME0 /, WLLRE1 / 0.D+00 /
      DATA JUSNU1 / 320 * 0 /, INUCL1 / 1 /, IEVPR1 / 0 /
      DATA MAGNU1 / 2, 8, 20, 28, 50, 82, 126, 160 /
*
      LABRST = LABRS1
      LELSTC = LELST1
      LINELS = LINEL1
      LCHEXC = LCHEX1
      LABSRP = LBSRP1
      LABSTH = LABST1
*
      POTBAR = POTBA1
      POTMES = POTME1
      WLLRES = WLLRE1
*
      DO 10 I=1,160
        JUSNUC(I,1) = JUSNU1(I,1)
        JUSNUC(I,2) = JUSNU1(I,2)
  10  CONTINUE
      INUCLV = INUCL1
      IEVPRE = IEVPR1
*
      DO 20 I=1,8
        MAGNUM(I) = MAGNU1(I)
 20   CONTINUE
*=== End of Block Data Bdpree =========================================*
      END
+DECK,  FLKDT1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:35  cernlib
* Geant

*$ CREATE BLKDT1.FOR
*COPY BLKDT1
*=== blkdt1 ===========================================================*
*==                                                                    *
      SUBROUTINE FLKDT1

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*----------------------------------------------------------------------*
*     Version May 81                 Pertti Aarnio                     *
*                                    Helsinki University of            *
*                                    Technology, Finland               *
*     Last change  17  march  92  by Alfredo Ferrari                   *
*                                                                      *
*                                                                      *
*     This is a block data subroutine of Fluka86, which should contain *
*     the common blocks, which can and should be initialised before    *
*     the run.                                                         *
*                                                                      *
*     Note that most of the default values for input parameters are    *
*     set here.                                                        *
*----------------------------------------------------------------------*
* The commons are INCLUDEd from Fluka87 Maclib                         *
*                 ---> Now from Flukadd Maclib  (A. Fasso' 1989)       *
*----------------------------------------------------------------------*
+CDE, PAPROP.
*
*----------------------------------------------------------------------*
*
      CHARACTER*8 GENPA1(30), BTYPE1(39)
      LOGICAL LHADR1(39), LPRBD1, LPRBI1
      DIMENSION ISCOR1(10), IJDIS1(39)
* /Paprop/                                                             *
      DATA BTYPE1/'PROTON  ' , 'APROTON ' , 'ELECTRON' ,
     1            'POSITRON' , 'NEUTRIE ' , 'ANEUTRIE' ,
     2            'PHOTON  ' , 'NEUTRON ' , 'ANEUTRON' ,
     3            'MUON+   ' , 'MUON-   ' , 'KAONLONG' ,
     4            'PION+   ' , 'PION-   ' , 'KAON+   ' ,
     5            'KAON-   ' , 'LAMBDA  ' , 'ALAMBDA ' ,
     6            'KAONSHRT' , 'SIGMA-  ' , 'SIGMA+  ' ,
     7            'SIGMAZER' , 'PIZERO  ' , 'KAONZERO' ,
     8            'AKAONZER' , 'RESERVED' , 'BLANK   ' ,
     9            'BLANK   ' , 'BLANK   ' , 'HEAVYION' ,
     A            'ASIGMA- ' , 'ASIGMAZE' , 'ASIGMA+ ' ,
     B            'XSIZERO ' , 'AXSIZERO' , 'XSI-    ' ,
     C            'AXSI+   ' , 'OMEGA-  ' , 'AOMEGA+ ' /
      DATA ISCOR1 / 201, 9*0 /
      DATA GENPA1 / 'ALL-PART', 'ALL-CHAR', 'ALL-NEUT', 'ALL-NEGA',
     &  'ALL-POSI', 'NUCLEONS', 'NUC&PI+-', 'ENERGY  ', 'PIONS+- ',
     &  'BEAMPART', 'EM-ENRGY', 19*'BLANK   ' /
      DATA IJDIS1 / 4*0,2*1,33*0 /
      DATA LHADR1 / 2 *.TRUE., 5 * .FALSE., 2 * .TRUE., 2 * .FALSE.,
     &              28 * .TRUE. /
      DATA LPRBD1, LPRBI1 / 2*.FALSE. /
*
      DO 10 J=1,39
         BTYPE(J)=BTYPE1(J)
         IJDISC(J)=IJDIS1(J)
         LHADRO(J)=LHADR1(J)
  10  CONTINUE
      DO 20 J=1,30
         GENPAR(J)=GENPA1(J)
   20 CONTINUE
      DO 30 J=1,10
         ISCORE(J)=ISCOR1(J)
   30 CONTINUE
      LPRBSD = LPRBD1
      LPRBSI = LPRBI1
*=                                               end*block.blkdt1      *
      END
+DECK,  FLKDT2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:35  cernlib
* Geant

*$ CREATE BLKDT2.FOR
*COPY BLKDT2
*=== blkdt2 ===========================================================*
*==                                                                    *
      SUBROUTINE FLKDT2

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*         CHARACTER*8 EDI, EDI1, EDI2      Not used here! A.F.
*
      DIMENSION RUNT1(2)
*
      COMMON /FKCD97/ CDDT
        DATA CDDT1 / .3D0 /
      COMMON /FKRUN/ RUNT(2)
        DATA RUNT1 / 2*100.D0 /
      COMMON/FKIDGB/ IDGB, IGB
        DATA IDGB1,IGB1 / 0, 0 /
      COMMON / FKENCO/ ETEST, TNKTE
      COMMON / FKNUCT / ETHR, PTHR
        DATA ETHR1,TNKTE1 / 2*1.D-3 /
*
      CDDT    = CDDT1
      RUNT(1) = RUNT1(1)
      RUNT(2) = RUNT1(2)
      IDGB    = IDGB1
      IGB     = IGB1
      ETHR    = ETHR1
      TNKTE   = TNKTE1
*=                                               end*block.blkdt2      *
      END
+DECK,  FLKDT3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:35  cernlib
* Geant

*$ CREATE BLKDT3.FOR
*COPY BLKDT3
*=== blkdt3 ===========================================================*
*==                                                                    *
      SUBROUTINE FLKDT3

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
* * * reaction channel cross section data                              *
+CDE, REAC.
      DIMENSION
     & UMOPI(92), UMOKC(68), UMOP(39), UMON(63), UMOK0(34),
     & PLAPI(92), PLAKC(68), PLAP(39), PLAN(63), PLAK0(34),
     & SPIKP1(315), SPIKPU(278), SPIKPV(372),
     & SPIKPW(278), SPIKPX(372), SPIKP4(315),
     & SPIKP5(187), SPIKP6(289),
     & SKMPEL(102), SPIKP7(289), SKMNEL(68), SPIKP8(187),
     & SPIKP9(143), SPIKP0(169), SPKPV(143),
     & SAPPEL(105), SPIKPE(399), SAPNEL(84), SPIKPZ(273),
     & SANPEL(84) , SPIKPF(273),
     & SPKP15(187), SPKP16(272),
     & NRKPI(164), NRKKC(132), NRKP(70), NRKN(116), NRKK0(54),
     & NURELN(60)
*
       DIMENSION NRKLIN(532)
       EQUIVALENCE (NRK(1,1), NRKLIN(1))
       EQUIVALENCE (   UMO(  1),  UMOPI(1)), (   UMO( 93),  UMOKC(1))
       EQUIVALENCE (   UMO(161),   UMOP(1)), (   UMO(200),   UMON(1))
       EQUIVALENCE (   UMO(263),  UMOK0(1))
       EQUIVALENCE ( PLABF(  1),  PLAPI(1)), ( PLABF( 93),  PLAKC(1))
       EQUIVALENCE ( PLABF(161),   PLAP(1)), ( PLABF(200),   PLAN(1))
       EQUIVALENCE ( PLABF(263),  PLAK0(1))
       EQUIVALENCE (   WK(   1), SPIKP1(1)), (   WK( 316), SPIKPU(1))
       EQUIVALENCE (   WK( 594), SPIKPV(1)), (   WK( 966), SPIKPW(1))
       EQUIVALENCE (   WK(1244), SPIKPX(1)), (   WK(1616), SPIKP4(1))
       EQUIVALENCE (   WK(1931), SPIKP5(1)), (   WK(2118), SPIKP6(1))
       EQUIVALENCE (   WK(2407), SKMPEL(1)), (   WK(2509), SPIKP7(1))
       EQUIVALENCE (   WK(2798), SKMNEL(1)), (   WK(2866), SPIKP8(1))
       EQUIVALENCE (   WK(3053), SPIKP9(1)), (   WK(3196), SPIKP0(1))
       EQUIVALENCE (   WK(3365),  SPKPV(1)), (   WK(3508), SAPPEL(1))
       EQUIVALENCE (   WK(3613), SPIKPE(1)), (   WK(4012), SAPNEL(1))
       EQUIVALENCE (   WK(4096), SPIKPZ(1)), (   WK(4369), SANPEL(1))
       EQUIVALENCE (   WK(4453), SPIKPF(1)), (   WK(4726), SPKP15(1))
       EQUIVALENCE (   WK(4913), SPKP16(1))
       EQUIVALENCE (NRK(1,1), NRKLIN(1))
       EQUIVALENCE (NRKLIN(   1), NRKPI(1)), (NRKLIN( 165), NRKKC(1))
       EQUIVALENCE (NRKLIN( 297),  NRKP(1)), (NRKLIN( 367),  NRKN(1))
       EQUIVALENCE (NRKLIN( 483), NRKK0(1))
       EQUIVALENCE (NURE(1,1), NURELN(1))
*
       DIMENSION UMOPI1(92), UMOKC1(68), UMOP1(39), UMON1(63),
     & UMOK01(34), PLAPI1(92), PLAKC1(68), PLAP1(39), PLAN1(63),
     & PLAK01(34), SIIN1(296),
     & SPKP11(315), SPKPU1(278), CPKPV1(372),
     & SPKPW1(278), SPKPX1(372), SPKP41(315),
     & SPKP51(187), SPKP61(289),
     & SKMPL1(102), SPKP71(289), SKMNL1(68), SPKP81(187),
     & SPKP91(143), SPKP01(169), SPKPV1(143),
     & SAPPL1(105), SPKPE1(399), SAPNL1(84), SPKPZ1(273),
     & SANPL1(84) , SPKPF1(273),
     & CPKP51(187), CPKP61(272),
     & NRKPI1(164), NRKKC1(132), NRKP1(70), NRKN1(116),
     & NRKK01(54), NURE1(60)
*
**** pi- p data                                                        *
**** pi+ n data                                                        *
      DATA PLAPI1/ 0.D0, .3D0, .5D0, .6D0, .7D0, .8D0, .9D0, .95D0,1.D0,
     & 1.15D0, 1.3D0, 1.5D0, 1.6D0, 1.8D0, 2.D0, 2.3D0, 2.5D0, 2.8D0,
     & 3.D0, 3.5D0, 4.D0, 0.D0, .285D0, .4D0, .45D0, .5D0, .6D0, .7D0,
     & .75D0, .8D0, .85D0, .9D0, 1.D0, 1.15D0, 1.3D0, 1.5D0, 1.6D0,
     & 1.8D0, 2.D0, 2.3D0, 2.5D0, 2.8D0, 3.D0, 3.5D0, 4.D0, 4.5D0, 0.D0,
     & .285D0, .4D0, .45D0, .5D0, .6D0, .7D0, .75D0, .8D0, .85D0, .9D0,
     & 1.D0, 1.15D0, 1.3D0, 1.5D0, 1.6D0, 1.8D0, 2.D0, 2.3D0, 2.5D0,
     & 2.8D0, 3.D0, 3.5D0, 4.D0, 4.5D0, 0.D0, .3D0, .5D0, .6D0, .7D0,
     & .8D0, .9D0, .95D0, 1.D0, 1.15D0, 1.3D0, 1.5D0, 1.6D0, 1.8D0,
     & 2.D0, 2.3D0, 2.5D0, 2.8D0, 3.D0, 3.5D0, 4.D0 /
      DATA PLAKC1/
     &   0.D0,  .58D0,   .8D0, 1.01D0, 1.23D0, 1.45D0, 1.68D0, 1.94D0,
     & 2.18D0, 2.42D0, 2.68D0, 2.96D0, 3.24D0,
     & 3.51D0, 3.84D0, 4.16D0, 4.49D0,
     &   0.D0,  .58D0,   .8D0, 1.01D0, 1.23D0, 1.45D0, 1.68D0, 1.94D0,
     & 2.18D0, 2.42D0, 2.68D0, 2.96D0, 3.24D0,
     & 3.51D0, 3.84D0, 4.16D0, 4.49D0,
     &   0.D0,  .58D0,   .8D0, 1.01D0, 1.23D0, 1.45D0, 1.68D0, 1.94D0,
     & 2.18D0, 2.42D0, 2.68D0, 2.96D0, 3.24D0,
     & 3.51D0, 3.84D0, 4.16D0, 4.49D0,
     &   0.D0,  .58D0,   .8D0, 1.01D0, 1.23D0, 1.45D0, 1.68D0, 1.94D0,
     & 2.18D0, 2.42D0, 2.68D0, 2.96D0, 3.24D0,
     & 3.51D0, 3.84D0, 4.16D0, 4.49D0/
      DATA PLAK01/
     &   0.D0,  .58D0,   .8D0, 1.01D0, 1.23D0, 1.45D0, 1.68D0, 1.94D0,
     & 2.18D0, 2.42D0, 2.68D0, 2.96D0, 3.24D0,
     & 3.51D0, 3.84D0, 4.16D0, 4.49D0,
     &   0.D0,  .58D0,   .8D0, 1.01D0, 1.23D0, 1.45D0, 1.68D0, 1.94D0,
     & 2.18D0, 2.42D0, 2.68D0, 2.96D0, 3.24D0,
     & 3.51D0, 3.84D0, 4.16D0, 4.49D0/
*                 pp   pn   np   nn                                    *
      DATA PLAP1/
     &   0.D0, 1.06D0, 1.34D0, 1.63D0, 1.92D0, 2.2D0, 2.5D0,2.8D0,3.1D0,
     & 3.43D0, 3.75D0, 4.07D0, 4.43D0,
     &   0.D0, 1.06D0, 1.34D0, 1.63D0, 1.92D0, 2.2D0, 2.5D0,2.8D0,3.1D0,
     & 3.43D0, 3.75D0, 4.07D0, 4.43D0,
     &   0.D0, 1.06D0, 1.34D0, 1.63D0, 1.92D0, 2.2D0, 2.5D0,2.8D0,3.1D0,
     & 3.43D0, 3.75D0, 4.07D0, 4.43D0 /
*    app   apn   anp   ann                                             *
      DATA PLAN1/
     &  0.D0,   1.D-3,   .1D0,   .2D0,   .3D0,  .4D0,  .5D0, .6D0,
     & .74D0,  1.06D0, 1.34D0, 1.63D0, 1.92D0, 2.2D0, 2.5D0,2.8D0,3.1D0,
     & 3.43D0, 3.75D0, 4.07D0, 4.43D0,
     &  0.D0,   1.D-3,   .1D0,   .2D0,   .3D0,  .4D0,  .5D0, .6D0,
     & .74D0,  1.06D0, 1.34D0, 1.63D0, 1.92D0, 2.2D0, 2.5D0,2.8D0,3.1D0,
     & 3.43D0, 3.75D0, 4.07D0, 4.43D0,
     &  0.D0,   1.D-3,   .1D0,   .2D0,   .3D0,  .4D0,  .5D0, .6D0,
     & .74D0,  1.06D0, 1.34D0, 1.63D0, 1.92D0, 2.2D0, 2.5D0,2.8D0,3.1D0,
     & 3.43D0, 3.75D0, 4.07D0, 4.43D0  /
      DATA SIIN1/ 296*0.D0 /
      DATA UMOPI1/ 1.08D0,1.233D0,1.302D0,1.369D0,1.496D0,
     & 1.557D0,1.615D0,1.6435D0,
     & 1.672D0,1.753D0,1.831D0,1.930D0,1.978D0,2.071D0,2.159D0,
     & 2.286D0,2.366D0,2.482D0,2.56D0,
     & 2.735D0,2.90D0,
     &             1.08D0,1.222D0,1.302D0,1.3365D0,1.369D0,1.434D0,
     & 1.496D0,1.527D0,1.557D0,
     & 1.586D0,1.615D0,1.672D0,1.753D0,1.831D0,1.930D0,1.978D0,
     & 2.071D0,2.159D0,2.286D0,2.366D0,
     & 2.482D0,2.560D0,2.735D0,2.90D0,3.06D0,
     &             1.08D0,1.222D0,1.302D0,1.3365D0,1.369D0,1.434D0,
     & 1.496D0,1.527D0,1.557D0,
     & 1.586D0,1.615D0,1.672D0,1.753D0,1.831D0,1.930D0,1.978D0,
     & 2.071D0,2.159D0,2.286D0,2.366D0,
     & 2.482D0,2.560D0,2.735D0,2.90D0,3.06D0,
     &                   1.08D0,1.233D0,1.302D0,1.369D0,1.496D0,
     & 1.557D0,1.615D0,1.6435D0,
     & 1.672D0,1.753D0,1.831D0,1.930D0,1.978D0,2.071D0,2.159D0,
     & 2.286D0,2.366D0,2.482D0,2.56D0,
     &  2.735D0, 2.90D0/
      DATA UMOKC1/ 1.44D0,
     &  1.598D0,1.7D0,1.8D0,1.9D0,2.0D0,2.1D0,2.2D0,2.3D0,2.4D0,2.5D0,
     & 2.6D0,2.7D0,2.8D0,2.9D0,3.0D0,
     & 3.1D0,1.44D0,
     &  1.598D0,1.7D0,1.8D0,1.9D0,2.0D0,2.1D0,2.2D0,2.3D0,2.4D0,2.5D0,
     & 2.6D0,2.7D0,2.8D0,2.9D0,3.0D0,
     & 3.1D0,1.44D0,
     &  1.598D0,1.7D0,1.8D0,1.9D0,2.0D0,2.1D0,2.2D0,2.3D0,2.4D0,2.5D0,
     & 2.6D0,2.7D0,2.8D0,2.9D0,3.0D0,
     & 3.1D0,1.44D0,
     &  1.598D0,1.7D0,1.8D0,1.9D0,2.0D0,2.1D0,2.2D0,2.3D0,2.4D0,2.5D0,
     & 2.6D0,2.7D0,2.8D0,2.9D0,3.0D0,
     &  3.1D0/
      DATA UMOK01/ 1.44D0,
     &  1.598D0,1.7D0,1.8D0,1.9D0,2.0D0,2.1D0,2.2D0,2.3D0,2.4D0,2.5D0,
     & 2.6D0,2.7D0,2.8D0,2.9D0,3.0D0,
     & 3.1D0,1.44D0,
     &  1.598D0,1.7D0,1.8D0,1.9D0,2.0D0,2.1D0,2.2D0,2.3D0,2.4D0,2.5D0,
     & 2.6D0,2.7D0,2.8D0,2.9D0,3.0D0,
     &  3.1D0/
*                 pp   pn   np   nn                                    *
      DATA UMOP1/
     & 1.88D0,2.102D0,2.2D0,2.3D0,2.4D0,2.5D0,2.6D0,2.7D0,2.8D0,2.9D0,
     & 3.D0,3.1D0,3.2D0,
     & 1.88D0,2.102D0,2.2D0,2.3D0,2.4D0,2.5D0,2.6D0,2.7D0,2.8D0,2.9D0,
     & 3.D0,3.1D0,3.2D0,
     & 1.88D0,2.102D0,2.2D0,2.3D0,2.4D0,2.5D0,2.6D0,2.7D0,2.8D0,2.9D0,
     & 3.D0,3.1D0,3.2D0/
*    app   apn   anp   ann                                             *
      DATA UMON1 /
     & 1.877D0,1.87701D0,1.879D0,1.887D0,1.9D0,1.917D0,1.938D0,1.962D0,
     & 2.D0,2.102D0,2.2D0,2.3D0,2.4D0,2.5D0,2.6D0,2.7D0,2.8D0,2.9D0,
     & 3.D0,3.1D0,3.2D0,
     & 1.877D0,1.87701D0,1.879D0,1.887D0,1.9D0,1.917D0,1.938D0,1.962D0,
     & 2.D0,2.102D0,2.2D0,2.3D0,2.4D0,2.5D0,2.6D0,2.7D0,2.8D0,2.9D0,
     & 3.D0,3.1D0,3.2D0,
     & 1.877D0,1.87701D0,1.879D0,1.887D0,1.9D0,1.917D0,1.938D0,1.962D0,
     & 2.D0,2.102D0,2.2D0,2.3D0,2.4D0,2.5D0,2.6D0,2.7D0,2.8D0,2.9D0,
     &  3.D0,3.1D0,3.2D0/
**** reaction channel state particles                                  *
      DATA NRKPI1/ 13, 1, 15, 21, 81, 0, 13, 54, 23, 53, 13, 63, 13, 58,
     & 23, 57, 13, 65, 1, 32, 53, 31, 54, 32, 53, 33, 53, 35, 63, 32,
     & 13, 8, 23, 1, 17, 15, 21, 24, 22, 15, 82, 0, 61, 0, 13, 55, 23,
     & 54, 14, 53, 13, 64, 23, 63, 13, 59, 23, 58, 14, 57, 13, 66, 23,
     & 65, 1, 31, 8, 32, 1, 33, 1, 35, 54, 31, 55, 32, 54, 33, 53, 34,
     & 54, 35, 14, 1, 23, 8, 17, 24, 20, 15, 22, 24, 83, 0, 62, 0, 14,
     & 54, 23, 55, 13, 56, 14, 63, 23, 64, 14, 58, 23, 59, 13, 60, 14,
     & 65, 23, 66, 8, 31, 1, 34, 8, 33, 8, 35, 55, 31, 54, 34, 55, 33,
     & 56, 32, 55, 35, 14, 8, 24, 20, 84, 0, 14, 55, 23, 56, 14, 64, 14,
     & 59, 23, 60, 14, 66, 8, 34, 56, 31, 55, 34, 56, 33, 56, 35, 64,34/
      DATA NRKKC1/15, 1, 89, 0, 24, 53, 15, 54, 1, 36, 1, 40, 1, 44, 36,
     & 63, 15, 63, 45, 53, 44, 54, 15, 8, 24, 1, 91, 0, 24, 54, 15, 55,
     & 8, 36, 1, 37, 8, 40, 1, 41, 8, 44, 1, 45, 36, 64, 37, 63, 15, 64,
     & 24, 63, 45, 54, 44, 55, 16, 1, 25, 8, 17, 23, 21, 14, 20,
     & 13, 22, 23, 90, 0, 38, 1, 39, 8, 16, 54, 25, 55, 1, 42, 8, 43,
     & 16, 63, 25, 64, 39, 64, 38, 63, 46, 54, 47, 55, 8, 47, 1, 46, 52,
     & 0, 51, 0, 16, 8, 17, 14, 20, 23, 22, 14, 92, 0, 8, 38, 16, 55,
     & 25, 56, 8, 42, 16, 64, 38, 64, 46, 55, 47, 56, 8, 46, 94, 0 /
*                                                                      *
*   k0 p   k0 n   ak0 p   ak/ n                                        *
*                                                                      *
      DATA NRKK01/ 24, 8, 106, 0, 15, 56, 24, 55, 37, 8, 41, 8, 45, 8,
     & 37, 64, 24, 64, 44, 56, 45, 55, 25, 1, 17, 13,   22, 13, 21, 23,
     & 107, 0, 39, 1, 25, 54, 16, 53, 43, 1, 25, 63, 39, 63, 47, 54, 46,
     & 53, 47, 1, 103, 0, 93, 0/
*   pp  pn   np   nn                                                   *
      DATA NRKP1/ 1, 1, 85, 0, 8, 53, 1, 54, 1, 63, 8, 57, 1, 58, 2*54,
     & 53, 55, 63, 54, 64, 53, 1, 8, 86, 0, 8, 54, 1, 55, 8, 63, 1, 64,
     & 8, 58, 1, 59, 64, 54, 63, 55, 54, 55, 53, 56, 77, 0, 2*8, 95, 0,
     & 8, 55, 1, 56, 8, 64, 8, 59, 1, 60, 2*55, 54, 56, 64, 55, 63, 56 /
*     app   apn   anp   ann                                            *
      DATA NRKN1/ 1, 2, 17, 18, 15, 16, 8, 9, 13, 14, 99, 0, 87, 0, 1,
     & 68, 8, 69, 2, 54, 9, 55, 102, 0, 2, 63, 9, 64, 1, 75, 8, 76, 53,
     & 67, 54, 68, 55, 69, 56, 70, 63, 68, 64, 69, 75, 54, 76, 55, 2, 8,
     & 18, 20, 16, 24, 14, 23, 101, 0, 88, 0, 2, 55, 9, 56, 1, 67, 8,
     & 68, 2, 64, 8, 75, 2, 59, 8, 72, 68, 55, 67, 54, 69, 56, 1, 9, 18,
     & 21, 15, 25, 13, 23, 100, 0, 96, 0, 2, 53, 9, 54, 1, 69, 8, 70, 1,
     & 76, 9, 63, 1, 73, 9, 58, 55, 70, 53, 68, 54, 69 /
**** channel cross section                                             *
      DATA SPKP11/ 0.D0, 300.D0, 40.D0, 20.D0, 13.D0,8.5D0,8.D0, 9.5D0,
     & 12.D0,14.D0,15.5D0,20.D0,17.D0,13.D0,10.D0,9.D0,8.5D0,8.D0,7.8D0,
     & 7.3D0, 6.7D0, 9*0.D0,.23D0,.35D0,.7D0,.52D0,.4D0,.3D0,.2D0,.15D0,
     & .13D0, .11D0, .09D0, .07D0, 0.D0, .033D0,.8D0,1.35D0,1.35D0,.5D0,
     & 15*0.D0, 3*0.D0,.00D0,0.80D0,2.2D0,3.6D0,4.6D0,4.7D0,3.5D0,2.4D0,
     &1.8D0,1.4D0,.75D0,.47D0,.25D0,.13D0,.08D0,6*0.D0,0.D0,1.2D0,3.3D0,
     & 5.4D0,6.9D0,7.3D0,5.3D0,3.6D0,2.7D0,2.2D0,1.1D0,.73D0,.4D0,.22D0,
     & .12D0,9*0.D0,.0D0,0.D0,2.0D0,4.4D0,6.8D0,9.9D0,7.9D0,6.0D0,3.8D0,
     &2.5D0,2.D0,1.4D0,1.D0,.6D0,.35D0,10*0.D0,.25D0,.55D0,.75D0,1.25D0,
     & 1.9D0,2.D0,1.8D0,1.5D0,1.25D0,1.D0,.8D0,6*0.D0,4*0.D0,.4D0,.85D0,
     & 1.1D0, 1.85D0, 2.8D0, 3.D0,2.7D0,2.2D0,1.85D0,1.5D0,1.2D0,6*0.D0,
     & 6*0.D0, .5D0, 1.2D0, 1.7D0, 3.4D0, 5.2D0, 6.4D0, 6.1D0, 5.6D0,
     & 5.2D0, 6*0.D0, 2*0.D0, .0D0, 1.D0, 3.3D0, 5.2D0, 4.45D0, 3.6D0,
     & 2.75D0, 1.9D0, 1.65D0, 1.3D0, .95D0, .6D0, .45D0, 6*0.D0, 3*0.D0,
     & .0D0, .45D0, 1.4D0, 1.5D0, 1.1D0, .85D0, .5D0, .3D0, .2D0, .15D0,
     & 8*0.D0, 5*0.D0, .0D0, .0D0, .6D0, .8D0, .95D0, .8D0, .7D0, .6D0,
     & .5D0, .4D0, 6*0.D0, 5*0.D0, .0D0, .00D0, .85D0, 1.2D0, 1.4D0,
     & 1.2D0, 1.05D0, .9D0, .7D0, .55D0, 6*0.D0, 5*0.D0, .0D0, .00D0,
     & 1.D0, 1.5D0, 3.5D0, 4.15D0, 3.7D0, 2.7D0, 2.3D0, 1.75D0, 6*0.D0,
     & 10*0.D0, .5D0, 2.0D0, 3.3D0, 5.4D0, 7.D0 /
**** pi+ n data                                                        *
      DATA SPKPU1/   0.D0, 25.D0, 13.D0,  11.D0, 10.5D0, 14.D0,  20.D0,
     & 20.D0, 16.D0, 14.D0, 19.D0, 28.D0, 17.5D0, 13.5D0, 12.D0, 10.5D0,
     & 10.D0, 10.D0, 9.5D0,  9.D0, 8.D0, 7.5D0, 7.D0, 6.5D0, 6.D0, 0.D0,
     & 48.D0, 19.D0, 15.D0, 11.5D0, 10.D0, 8.D0, 6.5D0,   5.5D0,  4.8D0,
     & 4.2D0, 7.5D0, 3.4D0,  2.5D0, 2.5D0, 2.1D0, 1.4D0,   1.D0,   .8D0,
     &  .6D0, .46D0,  .3D0, .2D0, .15D0, .13D0, 11*0.D0,  .95D0,  .65D0,
     & .48D0, .35D0,  .2D0, .18D0, .17D0, .16D0,  .15D0,   .1D0,  .09D0,
     & .065D0, .05D0, .04D0, 12*0.D0, .2D0, .25D0, .25D0,  .2D0,   .1D0,
     & .08D0, .06D0, .045D0,   .03D0, .02D0, .01D0,      .005D0, .003D0,
     & 12*0.D0, .3D0, .24D0,   .18D0, .15D0, .13D0,  .12D0, .11D0, .1D0,
     & .09D0,  .08D0, .05D0,   .04D0, .03D0,  0.D0, 0.16D0, .7D0, 1.3D0,
     & 3.1D0,  4.5D0,  2.D0, 18*0.D0, 3*.0D0,  0.D0, 0.D0, 4.0D0, 11.D0,
     & 11.4D0, 10.3D0, 7.5D0, 6.8D0, 4.75D0, 2.5D0,  1.5D0, .9D0, .55D0,
     &  .35D0, 13*0.D0, .1D0, .34D0, .5D0, .8D0, 1.1D0,   2.25D0, 3.3D0,
     & 2.3D0, 1.6D0, .95D0, .45D0, .28D0, .15D0, 10*0.D0, 2*0.D0, .17D0,
     & .64D0,  1.D0, 1.5D0, 2.1D0, 4.25D0, 6.2D0,  4.4D0,   3.D0, 1.8D0,
     &  .9D0, .53D0, .28D0,      10*0.D0, 2*0.D0,  .25D0,  .82D0,
     & 1.3D0, 1.9D0, 2.8D0, 5.5D0 , 8.D0,  5.7D0, 3.9D0, 2.35D0, 1.15D0,
     & .69D0, .37D0, 10*0.D0,     7*0.D0,   .0D0, .34D0,  1.5D0, 3.47D0,
     & 5.87D0, 6.23D0, 4.27D0, 2.6D0, 1.D0, .6D0,  .3D0,  .15D0, 6*0.D0/
*
      DATA CPKPV1/ 7*0.D0, .00D0, .16D0, .75D0, 1.73D0, 2.93D0, 3.12D0,
     & 2.13D0, 1.3D0, .5D0, .3D0, .15D0, .08D0, 6*0.D0, 10*0.D0, .2D0,
     & .6D0, .92D0, 2.4D0, 4.9D0, 6.25D0, 5.25D0, 3.5D0, 2.15D0, 1.4D0,
     & 1.D0, .7D0, 13*0.D0, .13D0, .4D0, .62D0, 1.6D0, 3.27D0, 4.17D0,
     & 3.5D0, 2.33D0, 1.43D0, .93D0, .66D0, .47D0, 13*0.D0, .07D0, .2D0,
     & .31D0, .8D0, 1.63D0, 2.08D0, 1.75D0, 1.17D0, .72D0, .47D0, .34D0,
     & .23D0, 17*0.D0, .33D0, 1.D0, 1.8D0, 2.67D0, 5.33D0, 6.D0, 5.53D0,
     & 5.D0, 17*0.D0, .17D0, .5D0, .9D0, 1.83D0, 2.67D0, 3.0D0, 2.77D0,
     & 2.5D0, 3*0.D0, 3*0.D0, 1.D0, 3.3D0, 2.8D0, 2.5D0, 2.3D0, 1.8D0,
     & 1.5D0, 1.1D0, .8D0, .7D0, .55D0, .3D0, 10*0.D0, 9*0.D0, .1D0,
     & .4D0, 1.D0, 1.4D0, 2.2D0, 2.5D0, 2.2D0, 1.65D0, 1.35D0, 1.1D0,
     & .8D0, .6D0, .4D0, 12*0.D0, .15D0, .6D0, 1.5D0, 2.1D0, 3.3D0,
     & 3.8D0, 3.3D0, 2.45D0, 2.05D0, 1.65D0, 1.2D0, .9D0, .6D0, 3*0.D0,
     & 9*0.D0, .10D0, .2D0, .5D0, .7D0, 1.3D0, 1.55D0, 1.9D0, 1.8D0,
     & 1.55D0, 1.35D0, 1.15D0, .95D0, .7D0, 13*0.D0, .2D0, .5D0, .7D0,
     & 1.3D0, 1.55D0, 1.9D0, 1.8D0, 1.55D0, 1.35D0, 1.15D0, .95D0, .7D0,
     & 17*0.D0, .2D0, .5D0, .85D0, 2.D0, 2.15D0, 2.05D0, 1.75D0, 1.D0,
     & 17*0.D0, .13D0, .33D0, .57D0, 1.33D0, 1.43D0, 1.36D0, 1.17D0,
     & .67D0, 17*0.D0, .07D0, .17D0, .28D0, .67D0, .72D0, .69D0, .58D0,
     & .33D0,17*0.D0,.4D0, .7D0, 1.D0, 1.6D0, 1.8D0, 2.3D0,1.9D0,1.7D0 /
**** pi- p data                                                        *
      DATA SPKPW1/ 0.D0, 25.D0, 13.D0, 11.D0, 10.5D0, 14.D0, 2*20.D0,
     & 16.D0, 14.D0, 19.D0, 28.D0, 17.5D0, 13.5D0, 12.D0, 10.5D0,
     & 2*10.D0, 9.5D0, 9.D0, 8.D0, 7.5D0, 7.D0, 6.5D0, 6.D0, 0.D0,
     & 48.D0, 19.D0, 15.D0, 11.5D0, 10.D0, 8.D0, 6.5D0, 5.5D0, 4.8D0,
     & 4.2D0, 7.5D0, 3.4D0, 2*2.5D0, 2.1D0, 1.4D0, 1.D0, .8D0, .6D0,
     & .46D0, .3D0, .2D0, .15D0, .13D0, 11*0.D0, .95D0, .65D0, .48D0,
     & .35D0, .2D0, .18D0, .17D0, .16D0, .15D0, .1D0, .09D0, .065D0,
     & .05D0, .04D0, 12*0.D0, .2D0, 2*.25D0, .2D0, .1D0, .08D0, .06D0,
     & .045D0, .03D0, .02D0, .01D0, .005D0, .003D0, 12*0.D0, .3D0,
     & .24D0, .18D0, .15D0, .13D0, .12D0, .11D0, .1D0, .09D0, .08D0,
     & .05D0, .04D0, .03D0, 0.D0, 0.16D0, .7D0, 1.3D0, 3.1D0, 4.5D0,
     & 2.D0, 23*0.D0, 4.0D0, 11.D0, 11.4D0, 10.3D0, 7.5D0, 6.8D0,
     & 4.75D0, 2.5D0, 1.5D0, .9D0, .55D0, .35D0, 13*0.D0, .1D0, .34D0,
     & .5D0, .8D0, 1.1D0, 2.25D0, 3.3D0, 2.3D0, 1.6D0, .95D0, .45D0,
     & .28D0, .15D0, 12*0.D0, .17D0, .64D0, 1.D0, 1.5D0, 2.1D0, 4.25D0,
     & 6.2D0, 4.4D0, 3.D0, 1.8D0, .9D0, .53D0, .28D0, 12*0.D0, .25D0,
     & .82D0, 1.3D0, 1.9D0, 2.8D0, 5.5D0, 8.D0, 5.7D0, 3.9D0, 2.35D0,
     & 1.15D0, .69D0, .37D0, 18*0.D0, .34D0, 1.5D0, 3.47D0, 5.87D0,
     & 6.23D0, 4.27D0, 2.6D0, 1.D0, .6D0, .3D0, .15D0, 6*0.D0/
*
      DATA SPKPX1/ 8*0.D0, .16D0, .75D0, 1.73D0, 2.93D0, 3.12D0,
     & 2.13D0, 1.3D0, .5D0, .3D0, .15D0, .08D0, 16*0.D0, .2D0, .6D0,
     & .92D0, 2.4D0, 4.9D0, 6.25D0, 5.25D0, 3.5D0, 2.15D0, 1.4D0, 1.D0,
     & .7D0, 13*0.D0, .13D0, .4D0, .62D0, 1.6D0, 3.27D0, 4.17D0, 3.5D0,
     & 2.33D0, 1.43D0, .93D0, .66D0, .47D0, 13*0.D0, .07D0, .2D0, .31D0,
     & .8D0, 1.63D0, 2.08D0, 1.75D0, 1.17D0, .72D0, .47D0, .34D0, .23D0,
     & 17*0.D0, .33D0, 1.D0, 1.8D0, 2.67D0, 5.33D0, 6.D0, 5.53D0, 5.D0,
     & 17*0.D0, .17D0, .5D0, .9D0, 1.83D0, 2.67D0, 3.0D0, 2.77D0, 2.5D0,
     & 6*0.D0, 1.D0, 3.3D0, 2.8D0, 2.5D0, 2.3D0, 1.8D0, 1.5D0, 1.1D0,
     & .8D0, .7D0, .55D0, .3D0, 19*0.D0, .1D0, .4D0, 1.D0, 1.4D0, 2.2D0,
     & 2.5D0, 2.2D0, 1.65D0, 1.35D0, 1.1D0, .8D0, .6D0, .4D0, 12*0.D0,
     & .15D0, .6D0, 1.5D0, 2.1D0, 3.3D0, 3.8D0, 3.3D0, 2.45D0, 2.05D0,
     & 1.65D0, 1.2D0, .9D0, .6D0, 12*0.D0, .10D0, .2D0, .5D0, .7D0,
     & 1.3D0, 1.55D0, 1.9D0, 1.8D0, 1.55D0, 1.35D0, 1.15D0, .95D0, .7D0,
     & 13*0.D0, .2D0, .5D0, .7D0, 1.3D0, 1.55D0, 1.9D0, 1.8D0, 1.55D0,
     & 1.35D0, 1.15D0, .95D0, .7D0, 17*0.D0, .2D0, .5D0, .85D0, 2.D0,
     & 2.15D0, 2.05D0, 1.75D0, 1.D0, 17*0.D0, .13D0, .33D0, .57D0,
     & 1.33D0, 1.43D0, 1.36D0, 1.17D0, .67D0, 17*0.D0, .07D0, .17D0,
     & .28D0, .67D0, .72D0, .69D0, .58D0, .33D0, 17*0.D0, .4D0, .7D0,
     & 1.D0, 1.6D0, 1.8D0, 2.3D0, 1.9D0, 1.7D0 /
**** pi- n data                                                        *
      DATA SPKP41 / 0.D0, 300.D0, 40.D0, 20.D0, 13.D0, 8.5D0, 8.D0,
     & 9.5D0, 12.D0, 14.D0, 15.5D0, 20.D0, 17.D0, 13.D0, 10.D0, 9.D0,
     & 8.5D0, 8.D0, 7.8D0, 7.3D0, 6.7D0, 9*0.D0, .23D0, .35D0, .7D0,
     & .52D0, .4D0, .3D0, .2D0, .15D0, .13D0, .11D0, .09D0, .07D0, 0.D0,
     & .033D0, .8D0, 2*1.35D0, .5D0, 19*0.D0, 0.8D0, 2.2D0, 3.6D0,
     & 4.6D0, 4.7D0, 3.5D0, 2.4D0, 1.8D0, 1.4D0, .75D0, .47D0, .25D0,
     & .13D0, .08D0, 7*0.D0, 1.2D0, 3.3D0, 5.4D0, 6.9D0, 7.3D0, 5.3D0,
     & 3.6D0, 2.7D0, 2.2D0, 1.1D0, .73D0, .4D0, .22D0, .12D0, 11*0.D0,
     & 2.0D0, 4.4D0, 6.8D0, 9.9D0, 7.9D0, 6.0D0, 3.8D0, 2.5D0, 2.D0,
     & 1.4D0, 1.D0, .6D0, .35D0, 10*0.D0, .25D0, .55D0, .75D0, 1.25D0,
     & 1.9D0, 2.D0, 1.8D0, 1.5D0, 1.25D0, 1.D0, .8D0, 10*0.D0, .4D0,
     & .85D0, 1.1D0, 1.85D0, 2.8D0, 3.D0, 2.7D0, 2.2D0, 1.85D0, 1.5D0,
     & 1.2D0, 12*0.D0, .5D0, 1.2D0, 1.7D0, 3.4D0, 5.2D0, 6.4D0, 6.1D0,
     & 5.6D0, 5.2D0, 9*0.D0, 1.D0, 3.3D0, 5.2D0, 4.45D0, 3.6D0, 2.75D0,
     & 1.9D0, 1.65D0, 1.3D0, .95D0, .6D0, .45D0, 10*0.D0, .45D0, 1.4D0,
     & 1.5D0, 1.1D0, .85D0, .5D0, .3D0, .2D0, .15D0, 15*0.D0, .6D0,
     & .8D0, .95D0, .8D0, .7D0, .6D0, .5D0, .4D0, 13*0.D0, .85D0, 1.2D0,
     & 1.4D0, 1.2D0, 1.05D0, .9D0, .7D0, .55D0, 13*0.D0, 1.D0, 1.5D0,
     & 3.5D0, 4.15D0, 3.7D0, 2.7D0, 2.3D0, 1.75D0, 16*0.D0, .5D0, 2.0D0,
     & 3.3D0, 5.4D0, 7.D0 /
**** k+  p data                                                        *
      DATA SPKP51/ 0.D0, 20.D0, 14.D0, 12.D0, 11.5D0, 10.D0, 8.D0,
     & 7.D0, 6.D0, 5.5D0, 5.3D0, 5.D0, 4.5D0, 4.4D0, 3.8D0, 3.D0, 2.8D0,
     & 0.D0, .5D0, 1.15D0, 2.D0, 1.3D0, .8D0, .45D0, 13*0.D0, 0.9D0,
     & 2.5D0, 3.D0, 2.5D0, 2.3D0, 2.D0, 1.7D0, 1.5D0, 1.2D0, .9D0, .6D0,
     & .45D0, .21D0, .2D0, 3*0.D0, .9D0, 2.5D0, 3.D0, 2.5D0, 2.3D0,
     & 2.D0, 1.7D0, 1.5D0, 1.2D0, .9D0, .6D0, .45D0, .21D0, .2D0,
     & 4*0.D0, 1.D0, 2.1D0, 2.6D0, 2.3D0, 2.1D0, 1.8D0, 1.7D0, 1.4D0,
     & 1.2D0, 1.05D0, .9D0, .66D0, .5D0, 7*0.D0, .3D0, 2*1.D0, .9D0,
     & .7D0, .4D0, .3D0, .2D0, 11*0.D0, .1D0, 1.D0, 2.2D0, 3.5D0, 4.2D0,
     & 4.55D0, 4.85D0, 4.9D0, 10*0.D0, .2D0, .7D0, 1.6D0, 2.5D0, 2.2D0,
     & 1.71D0, 1.6D0, 6*0.D0, 1.4D0, 3.8D0, 5.D0, 4.7D0, 4.4D0, 4.D0,
     & 3.5D0, 2.85D0, 2.35D0, 2.01D0, 1.8D0, 12*0.D0, .1D0, .8D0,2.05D0,
     & 3.31D0, 3.5D0, 12*0.D0, .034D0, .2D0, .75D0, 1.04D0, 1.24D0 /
**** k+  n data                                                        *
      DATA SPKP61/ 0.D0, 6.D0, 11.D0, 13.D0, 6.D0, 5.D0, 3.D0, 2.2D0,
     & 1.5D0, 1.2D0, 1.D0, .7D0, .6D0, .5D0, .45D0, .35D0, .3D0, 0.D0,
     & 6.D0, 11.D0, 13.D0, 6.D0, 5.D0, 3.D0, 2.2D0, 1.5D0, 1.2D0, 1.D0,
     & .7D0, .6D0, .5D0, .45D0, .35D0, .3D0, 0.D0, .5D0, 1.3D0, 2.8D0,
     & 2.3D0, 1.6D0, .9D0, 13*0.D0, 0.9D0, 2.5D0, 3.D0, 2.5D0, 2.3D0,
     & 2.D0, 1.7D0, 1.5D0,1.2D0,.9D0,.6D0,.45D0,.21D0,.2D0,3*0.D0,0.9D0,
     & 2.5D0, 3.D0, 2.5D0, 2.3D0,2.D0,1.7D0,1.5D0,1.2D0,.9D0,.6D0,.45D0,
     & .21D0, .2D0,4*0.D0,1.D0,2.1D0,2.6D0,2.3D0,2.D0,1.8D0,1.7D0,1.4D0,
     & 1.2D0,1.15D0,.9D0,.66D0,.5D0,4*0.D0,1.D0,2.1D0,2.6D0,2.3D0,2.1D0,
     & 1.8D0,1.7D0,1.4D0,1.2D0, 1.15D0, .9D0, .66D0, .5D0, 7*0.D0, .3D0,
     & 2*1.D0, .9D0, .7D0, .4D0, .35D0, .2D0, 9*0.D0, .3D0, 2*1.D0,.9D0,
     & .7D0, .4D0, .35D0, .2D0, 11*0.D0, .1D0, 1.D0, 2.4D0,3.5D0,4.25D0,
     & 4.55D0, 4.85D0, 4.9D0, 9*0.D0, .1D0, 1.D0, 2.4D0, 3.5D0, 4.25D0,
     & 4.55D0, 4.85D0, 4.9D0, 10*0.D0, .2D0, .7D0, 1.6D0, 2.5D0, 2.2D0,
     & 1.71D0, 1.6D0, 10*0.D0, .2D0, .7D0, 1.6D0, 2.5D0, 2.2D0, 1.71D0,
     & 1.6D0, 6*0.D0, 1.4D0, 3.8D0, 5.D0, 4.7D0,4.4D0,4.D0,3.5D0,2.85D0,
     & 2.35D0, 2.01D0, 1.8D0, 6*0.D0, 1.4D0,3.8D0,5.D0,4.7D0,4.4D0,4.D0,
     & 3.5D0,2.85D0,2.35D0,2.01D0,1.8D0,12*0.D0,.1D0,.8D0,2.05D0,3.31D0,
     & 3.5D0, 12*0.D0, .034D0,.2D0,.75D0,1.04D0,1.24D0 /
**** k-  p data                                                        *
      DATA SKMPL1/ 0.D0, 35.D0, 22.D0, 25.D0, 17.D0, 9.D0, 9.5D0, 8.D0,
     &     7.D0, 6.5D0, 6.1D0, 5.D0, 4.8D0, 4.6D0, 4.45D0, 4.3D0, 4.2D0,
     &    0.D0, 8.D0, 3.5D0, 8.D0, 3.D0, 1.9D0, 1.7D0, 1.D0, .9D0, .8D0,
     &    .75D0, .5D0, .42D0, .38D0, .34D0, .25D0, .2D0,
     &    0.D0, 3.D0, 3.2D0, 3.5D0, 1.5D0, 1.4D0, 1.1D0, .6D0, .5D0,
     &    .35D0, .28D0, .25D0, .18D0, .12D0, .1D0, .08D0, .04D0,
     &    0.D0, 8.5D0, 2.4D0, 1.7D0, 1.3D0, 1.3D0, 1.1D0, .5D0,
     &    .4D0, .4D0, .35D0, .3D0, .28D0, .2D0, .16D0, .13D0, .11D0,
     &    0.D0, 7.D0, 4.8D0, 1.4D0, 1.9D0, .9D0, .4D0, .2D0, .13D0,
     &    .1D0, .08D0, .06D0, .04D0, .02D0, .015D0, .01D0, .01D0,
     &    0.D0, 5.5D0, 1.D0, .8D0, .75D0, .32D0, .2D0, .1D0, .09D0,
     &    .08D0, .065D0, .05D0, .04D0, .022D0, .017D0, 2*.01D0/
      DATA SPKP71 / 0.D0, .56D0, 1.46D0, 3.16D0, 2.01D0, 1.28D0, .74D0,
     & 14*0.D0, 1.13D0, 2.61D0, 2.91D0, 2.58D0, 2.35D0, 2.02D0,
     & 1.91D0, 1.57D0, 1.35D0, 1.29D0, 1.01D0, .74D0, .65D0, 4*0.D0,
     & 1.13D0, 2.61D0, 2.91D0, 2.58D0, 2.35D0, 2.02D0, 1.91D0, 1.57D0,
     & 1.35D0, 1.29D0, 1.01D0, .74D0, .65D0,  3*0.D0, 1.0D0, 3.03D0,
     & 3.36D0, 2.8D0, 2.58D0, 2.24D0, 1.91D0, 1.68D0, 1.35D0, 1.01D0,
     & .67D0, .5D0, .24D0, .23D0, 3*0.D0, 1.0D0, 3.03D0, 3.36D0, 2.8D0,
     & 2.58D0, 2.24D0, 1.91D0, 1.68D0, 1.35D0, 1.01D0, .67D0, .5D0,
     & .24D0, .23D0, 7*0.D0, .34D0, 1.12D0, 1.12D0, 1.01D0, .78D0,
     & .45D0, .39D0, .22D0, .07D0, 0.D0, 7*0.D0, .34D0, 1.12D0, 1.12D0,
     & 1.01D0, .78D0, .45D0, .39D0, .22D0, .07D0, 0.D0, 6*0.D0, 1.71D0,
     & 4.26D0, 5.6D0, 5.57D0, 4.93D0, 4.48D0, 3.92D0, 3.19D0, 2.63D0,
     & 2.25D0, 2.D0, 6*0.D0, 1.71D0, 4.26D0, 5.6D0, 5.57D0, 4.93D0,
     & 4.48D0, 3.92D0, 3.19D0, 2.63D0, 2.25D0, 2.D0, 10*0.D0, .22D0,
     & .8D0, .75D0, 1.D0, 1.3D0, 1.5D0, 1.3D0, 10*0.D0, .22D0, .8D0,
     & .75D0, 1.D0, 1.3D0, 1.5D0, 1.3D0, 13*0.D0, .1D0, .3D0, .7D0,1.D0,
     & 13*0.D0, .1D0, .3D0, .7D0, 1.D0, 9*0.D0, .11D0, 1.72D0, 2.69D0,
     & 3.92D0, 4.76D0, 5.10D0, 5.44D0, 5.3D0, 9*0.D0, .11D0, 1.72D0,
     & 2.69D0, 3.92D0, 4.76D0, 5.1D0, 5.44D0, 5.3D0, 5*0.D0,9.2D0,4.7D0,
     & 1.9D0, 10*0.D0, 2.5D0, 15.D0, 21.5D0, 15.3D0, 3.D0,1.5D0,10*0.D0/
***** k- n data                                                        *
      DATA SKMNL1/0.D0, 4.D0, 9.5D0, 20.D0, 13.D0, 9.5D0, 6.D0, 4.4D0,
     &        3.D0, 2.4D0, 2.D0, 1.4D0, 1.2D0, 1.D0, .9D0, .7D0, .6D0,
     &        0.D0, 4.5D0, 6.D0, 5.D0, 2.5D0, 2.D0, 1.7D0, 2.1D0,
     &        1.9D0, .9D0, .5D0, .3D0, .24D0, .2D0, .18D0, .1D0, .09D0,
     &        0.D0, 1.8D0, 2.D0, 1.1D0, .9D0, .5D0, .5D0, .4D0, .4D0,
     &        .2D0, .1D0, .06D0, .05D0, .04D0, .03D0, .02D0, .02D0,
     &        0.D0, 1.5D0, 2.D0, .9D0, 1.1D0, .4D0, .6D0, .7D0, .65D0,
     &       .3D0, .17D0, .1D0, .08D0, .07D0, .06D0, .04D0, .03D0/
      DATA SPKP81/0.D0, .56D0, 1.29D0, 2.26D0, 1.01D0, .64D0, .37D0,
     &  14*0.D0, 1.13D0, 2.61D0, 2.91D0, 2.58D0, 2.35D0, 2.02D0,
     &  1.91D0, 1.57D0, 1.35D0, 1.29D0, 1.01D0, .74D0, .65D0,
     &  3*0.D0, 1.D0, 3.03D0, 3.36D0, 2.8D0, 2.58D0, 2.24D0,
     &  1.91D0, 1.68D0, 1.35D0, 1.01D0, .67D0, .5D0, .24D0, .23D0,
     &  3*0.D0, 1.D0, 3.03D0, 3.36D0, 2.8D0, 2.58D0, 2.24D0,
     &  1.91D0, 1.68D0, 1.35D0, 1.01D0, .67D0, .5D0, .24D0, .23D0,
     &  7*0.D0, .34D0, 1.12D0, 1.12D0, 1.01D0, .78D0, .45D0,
     &  .39D0, .22D0, .07D0, 0.D0,
     &  6*0.D0, 1.71D0, 4.26D0, 5.6D0, 5.57D0, 4.93D0,
     &  4.48D0, 3.92D0, 3.19D0, 2.63D0, 2.25D0, 2.D0,
     &  10*0.D0, .22D0, .8D0, .75D0, 1.D0, 1.3D0, 1.5D0, 1.3D0,
     &  13*0.D0, .1D0, .3D0, .7D0, 1.D0,
     &  13*0.D0, .1D0, .3D0, .7D0, 1.D0,
     &  9*0.D0, .11D0, 1.72D0, 2.69D0, 3.92D0, 4.76D0,
     &  5.10D0, 5.44D0, 5.3D0,
     &  4*0.D0, 0.00D0, 9.2D0, 4.7D0, 1.9D0, 9*0.D0/
*****  p p data                                                        *
      DATA SPKP91/ 0.D0, 24.D0, 25.D0, 27.D0, 23.D0, 21.D0, 20.D0,
     &              19.D0, 17.D0, 15.5D0, 14.D0, 13.5D0, 13.D0,
     &              0.D0, 3.6D0, 1.7D0, 10*0.D0,
     &              .0D0, 0.D0, 8.7D0, 17.7D0, 18.8D0, 15.9D0,
     &              11.7D0, 8.D0, 6.D0, 5.3D0, 4.5D0, 3.9D0, 3.5D0,
     &              .0D0, .0D0, 2.8D0, 5.8D0, 6.2D0, 5.1D0, 3.8D0,
     &              2.7D0, 2.1D0, 1.8D0, 1.5D0, 1.3D0, 1.1D0,
     &              5*0.D0, 4.6D0, 10.2D0, 15.1D0,
     &              16.9D0, 16.5D0, 11.D0, 5.5D0, 3.5D0,
     &              10*0.D0, 4.3D0, 7.6D0, 9.D0,
     &              10*0.D0, 1.7D0, 2.6D0, 3.D0,
     &              6*0.D0, .3D0, .6D0, 1.D0, 1.6D0, 1.3D0, .8D0, .6D0,
     &              6*0.D0, .7D0, 1.2D0, 1.8D0, 2.5D0, 1.8D0, 1.3D0,
     &              1.2D0, 10*0.D0, .6D0, 1.4D0, 1.7D0,
     &              10*0.D0, 1.9D0, 4.1D0, 5.2D0/
*****  p n data                                                        *
      DATA SPKP01/ 0.D0, 24.D0, 25.D0, 27.D0, 23.D0, 21.D0, 20.D0,
     &              19.D0, 17.D0, 15.5D0, 14.D0, 13.5D0, 13.D0,
     &              0.D0, 1.8D0, .2D0,  12*0.D0,
     &              3.2D0, 6.05D0, 9.9D0, 5.1D0,
     &              3.8D0, 2.7D0, 1.9D0, 1.5D0, 1.4D0, 1.3D0, 1.1D0,
     &              2*.0D0, 3.2D0, 6.05D0, 9.9D0, 5.1D0,
     &              3.8D0, 2.7D0, 1.9D0, 1.5D0, 1.4D0, 1.3D0, 1.1D0,
     &              5*0.D0, 4.6D0, 10.2D0, 15.1D0,
     &              16.4D0, 15.2D0, 11.D0, 5.4D0, 3.5D0,
     &              5*0.D0, 4.6D0, 10.2D0, 15.1D0,
     &              16.4D0, 15.2D0, 11.D0, 5.4D0, 3.5D0,
     &              10*0.D0, .7D0, 5.1D0, 8.D0,
     &              10*0.D0, .7D0, 5.1D0, 8.D0,
     &              10*.0D0, .3D0, 2.8D0, 4.7D0,
     &              10*.0D0, .3D0, 2.8D0, 4.7D0,
     &              7*0.D0, 1.2D0, 2.5D0, 3.5D0, 6.D0, 5.3D0, 2.9D0,
     &              7*0.D0, 1.7D0, 3.6D0, 5.4D0, 9.D0, 7.6D0, 4.2D0,
     &              5*0.D0, 7.7D0, 6.1D0, 2.9D0, 5*0.D0/
*   nn - data                                                          *
*                                                                      *
      DATA SPKPV1/ 0.D0, 24.D0, 25.D0, 27.D0, 23.D0, 21.D0, 20.D0,
     &              19.D0, 17.D0, 15.5D0, 14.D0, 13.5D0, 13.D0,
     &              0.D0, 3.6D0, 1.7D0, 12*0.D0,
     &              8.7D0, 17.7D0, 18.8D0, 15.9D0,
     &              11.7D0, 8.D0, 6.D0, 5.3D0, 4.5D0, 3.9D0, 3.5D0,
     &              .0D0, .0D0, 2.8D0, 5.8D0, 6.2D0, 5.1D0, 3.8D0,
     &              2.7D0, 2.1D0, 1.8D0, 1.5D0, 1.3D0, 1.1D0,
     &              5*0.D0, 4.6D0, 10.2D0, 15.1D0, 16.9D0, 16.5D0,
     &              11.D0, 5.5D0, 3.5D0,
     &              10*0.D0, 4.3D0, 7.6D0, 9.D0,
     &              10*0.D0, 1.7D0, 2.6D0, 3.D0,
     &              6*0.D0, .3D0, .6D0, 1.D0, 1.6D0, 1.3D0, .8D0, .6D0,
     &              6*0.D0, .7D0, 1.2D0, 1.8D0, 2.5D0, 1.8D0, 1.3D0,
     &              1.2D0, 10*0.D0, .6D0, 1.4D0, 1.7D0,
     &              10*0.D0, 1.9D0, 4.1D0, 5.2D0/
****************   ap - p - data                                       *
      DATA SAPPL1/ 0.D0,  176.D0, 160.D0, 105.D0, 75.D0, 68.D0, 65.D0,
     &  50.D0,  50.D0, 43.D0, 42.D0, 40.5D0, 35.D0, 30.D0, 28.D0,
     &  25.D0,  22.D0, 21.D0, 20.D0, 18.D0, 17.D0,  11*0.D0,
     &  .05D0,  .15D0, .18D0, .2D0, .2D0, .3D0, .4D0, .6D0, .7D0, .85D0,
     &  0.D0,  1.D0, .9D0, .46D0, .3D0, .23D0, .18D0, .16D0, .14D0,
     &  .1D0,  .08D0, .05D0, .02D0, .015D0, 4*.011D0, 3*.005D0,
     &  0.D0,  55.D0, 50.D0, 25.D0, 15.D0, 15.D0, 14.D0, 12.D0,
     &  10.D0,  7.D0, 6.D0, 4.D0, 3.3D0, 2.8D0, 2.4D0, 2.D0, 1.8D0,
     &  1.55D0,  1.3D0, .95D0, .75D0,
     &  0.D0,  3.3D0, 3.D0, 1.5D0, 1.D0, .7D0, .4D0, .35D0, .4D0,
     &  .25D0,  .18D0, .08D0, .04D0, .03D0, .023D0, .016D0, .014D0,
     & .01D0,  .008D0, .006D0, .005D0/
      DATA SPKPE1/0.D0, 215.D0, 193.D0, 170.D0, 148.D0, 113.D0, 97.D0,
     & 84.D0, 78.D0, 68.D0, 64.D0, 61.D0, 46.D0, 36.D0, 31.3D0, 28.5D0,
     & 25.7D0, 22.6D0, 21.4D0, 20.7D0, 19.9D0,
     & 9*0.D0, 2.D0, 2.5D0, .2D0, 19*0.D0, .3D0, 1.4D0, 2.2D0, 1.2D0,
     & 1.1D0, 1.D0, .8D0, .6D0, .5D0, .4D0, .3D0, 10*0.D0, .3D0, 1.4D0,
     & 2.2D0, 1.2D0, 1.1D0, 1.D0, .8D0, .6D0, .5D0, .4D0, .3D0, 10*0.D0,
     & .3D0, 1.4D0, 2.2D0, 1.2D0, 1.1D0, 1.D0, .8D0, .6D0, .5D0, .4D0,
     & .3D0, 10*0.D0, .3D0, 1.4D0, 2.2D0, 1.2D0, 1.1D0, 1.D0, .8D0,
     & .6D0, .5D0, .4D0, .3D0, 9*0.D0, .6D0, 2.5D0, 5.D0, 5.2D0, 5.1D0,
     & 5.4D0, 5.8D0, 2.8D0, 2.1D0, 1.8D0, 1.6D0, 1.2D0, 13*0.D0, 1.3D0,
     & 1.5D0, 2.D0, 2.5D0, 2.5D0, 2.3D0, 1.8D0, 1.4D0, 13*0.D0, 1.3D0,
     & 1.5D0, 2.D0, 2.5D0, 2.5D0, 2.3D0, 1.8D0, 1.4D0, 13*0.D0, 1.3D0,
     & 1.5D0, 2.D0, 2.5D0, 2.5D0, 2.3D0, 1.8D0, 1.4D0, 13*0.D0, 1.3D0,
     & 1.5D0, 2.D0, 2.5D0, 2.5D0, 2.3D0, 1.8D0, 1.4D0, 14*0.D0, .2D0,
     & .5D0, 1.1D0, 1.6D0, 1.4D0, 1.1D0, .9D0, 14*0.D0, .2D0, .5D0,
     & 1.1D0, 1.6D0, 1.4D0, 1.1D0, .9D0, 14*0.D0, .2D0, .5D0, 1.1D0,
     & 1.6D0, 1.4D0, 1.1D0, .9D0, 14*0.D0, .2D0, .5D0, 1.1D0, 1.6D0,
     & 1.4D0, 1.1D0, .9D0, 17*0.D0, .3D0, 1.6D0, 2.6D0, 3.6D0, 17*0.D0,
     & .3D0, 1.6D0, 2.6D0, 3.6D0, 17*0.D0, .3D0, 1.6D0, 2.6D0,
     & 3.6D0, 17*0.D0, .3D0, 1.6D0, 2.6D0, 3.6D0 /
****************   ap - n - data                                       *
      DATA SAPNL1/
     & 0.D0,  176.D0, 160.D0, 105.D0, 75.D0,  68.D0, 65.D0,
     & 50.D0, 50.D0,  43.D0,  42.D0,  40.5D0, 35.D0, 30.D0,  28.D0,
     & 25.D0, 22.D0,  21.D0,  20.D0,  18.D0,  17.D0, 11*0.D0,
     & .05D0, .15D0, .18D0,  .2D0,    .2D0,  .3D0,  .4D0,   .6D0,  .7D0,
     & .85D0,  0.D0,  1.D0,  .9D0,    .46D0, .3D0,  .23D0, .18D0, .16D0,
     & .14D0,  .1D0, .08D0, .05D0,    .02D0, .015D0, 4*.011D0, 3*.005D0,
     & 0.D0,  3.3D0,  3.D0, 1.5D0,     1.D0, .7D0,  .4D0,  .35D0, .4D0,
     & .25D0, .18D0, .08D0, .04D0,    .03D0, .023D0, .016D0, .014D0,
     & .01D0, .008D0, .006D0, .005D0 /
       DATA SPKPZ1/ 0.D0, 215.D0, 193.D0, 170.D0, 148.D0, 113.D0, 97.D0,
     &  84.D0, 78.D0, 68.D0, 64.D0, 61.D0, 46.D0, 36.D0, 31.3D0, 28.5D0,
     & 25.7D0, 22.6D0, 21.4D0, 20.7D0, 19.9D0, 9*0.D0, 2.4D0, .2D0,
     & 20*0.D0, 1.8D0, 2.8D0, 3.6D0, 2.3D0, 1.8D0, 1.5D0, 1.3D0, 1.D0,
     & .7D0, .5D0, .3D0, 10*0.D0, 1.8D0, 2.8D0, 3.6D0, 2.3D0, 1.8D0,
     & 1.5D0, 1.3D0, 1.D0, .7D0, .5D0, .3D0, 10*0.D0, 1.8D0, 2.8D0,
     & 3.6D0, 2.3D0, 1.8D0, 1.5D0, 1.3D0, 1.D0, .7D0, .5D0, .3D0,
     & 10*0.D0, 1.8D0, 2.8D0, 3.6D0, 2.3D0, 1.8D0, 1.5D0, 1.3D0, 1.D0,
     & .7D0, .5D0, .3D0, 13*0.D0, 5.2D0, 8.7D0, 11.4D0, 14.D0, 11.9D0,
     & 7.6D0, 6.D0, 5.D0, 13*0.D0, 5.2D0, 8.7D0, 11.4D0, 14.D0, 11.9D0,
     & 7.6D0, 6.D0, 5.D0, 18*0.D0, 1.D0, 4.9D0, 8.5D0, 18*0.D0, 1.D0,
     & 4.9D0, 8.5D0,  15*0.D0, 1.9D0, 2.3D0, 4.D0, 6.5D0, 5.2D0, 3.4D0,
     & 15*0.D0, 1.9D0, 2.3D0, 4.D0, 6.5D0, 5.2D0, 3.4D0, 15*0.D0, 1.9D0,
     & 2.3D0, 4.D0, 6.5D0, 5.2D0, 3.4D0 /
*                                                                      *
*                                                                      *
****************   an - p - data                                       *
*                                                                      *
      DATA SANPL1/
     & 0.D0,  176.D0, 160.D0, 105.D0, 75.D0, 68.D0, 65.D0, 50.D0,
     & 50.D0, 43.D0,  42.D0,  40.5D0, 35.D0, 30.D0, 28.D0,
     & 25.D0, 22.D0,  21.D0,  20.D0,  18.D0, 17.D0, 11*0.D0, .05D0,
     & .15D0, .18D0,   .2D0,   .2D0,   .3D0,  .4D0, .6D0,   .7D0, .85D0,
     & 0.D0,   1.D0,   .9D0,  .46D0,  .3D0,  .23D0, .18D0, .16D0, .14D0,
     & .1D0,  .08D0,  .05D0,  .02D0, .015D0, 4*.011D0, 3*.005D0,
     & 0.D0,  3.3D0,  3.D0, 1.5D0, 1.D0, .7D0, .4D0, .35D0, .4D0, .25D0,
     & .18D0, .08D0, .04D0, .03D0, .023D0, .016D0, .014D0,
     & .01D0, .008D0, .006D0, .005D0 /
      DATA SPKPF1/ 0.D0, 215.D0, 193.D0, 170.D0, 148.D0, 113.D0, 97.D0,
     & 84.D0, 78.D0, 68.D0, 64.D0, 61.D0, 46.D0, 36.D0, 31.3D0, 28.5D0,
     & 25.7D0, 22.6D0, 21.4D0, 20.7D0, 19.9D0, 9*0.D0, 2.4D0, .2D0,
     & 20*0.D0, 1.8D0, 2.8D0, 3.6D0, 2.3D0, 1.8D0, 1.5D0, 1.3D0, 1.D0,
     & .7D0, .5D0, .3D0, 10*0.D0, 1.8D0, 2.8D0, 3.6D0, 2.3D0, 1.8D0,
     & 1.5D0, 1.3D0, 1.D0, .7D0, .5D0, .3D0, 10*0.D0, 1.8D0, 2.8D0,
     & 3.6D0, 2.3D0, 1.8D0, 1.5D0, 1.3D0, 1.D0, .7D0, .5D0, .3D0,
     & 10*0.D0, 1.8D0, 2.8D0, 3.6D0, 2.3D0, 1.8D0, 1.5D0, 1.3D0, 1.D0,
     & .7D0, .5D0, .3D0, 13*0.D0, 5.2D0, 8.7D0, 11.4D0, 14.D0, 11.9D0,
     & 7.6D0, 6.D0, 5.D0, 13*0.D0, 5.2D0, 8.7D0, 11.4D0, 14.D0, 11.9D0,
     & 7.6D0, 6.D0, 5.D0, 18*0.D0, 1.D0, 4.9D0, 8.5D0, 18*0.D0, 1.D0,
     & 4.9D0, 8.5D0, 15*0.D0, 1.9D0, 2.3D0, 4.D0, 6.5D0, 5.2D0, 3.4D0,
     & 15*0.D0, 1.9D0, 2.3D0, 4.D0, 6.5D0, 5.2D0, 3.4D0, 15*0.D0, 1.9D0,
     & 2.3D0, 4.D0, 6.5D0, 5.2D0, 3.4D0 /
****  ko - n - data                                                    *
      DATA CPKP51/0.D0, 20.D0, 14.D0, 12.D0, 11.5D0, 10.D0, 8.D0, 7.D0,
     &      6.D0, 5.5D0, 5.3D0, 5.D0, 4.5D0, 4.4D0, 3.8D0, 3.D0, 2.8D0,
     &      0.D0, .5D0, 1.15D0, 2.D0, 1.3D0, .8D0, .45D0, 10*0.D0,
     &    3*0.D0, 0.9D0, 2.5D0, 3.D0, 2.5D0, 2.3D0, 2.D0, 1.7D0,
     &     1.5D0, 1.2D0, .9D0, .6D0, .45D0, .21D0, .2D0,
     &    3*0.D0, 0.9D0, 2.5D0, 3.D0, 2.5D0, 2.3D0, 2.D0, 1.7D0,
     &     1.5D0, 1.2D0, .9D0, .6D0, .45D0, .21D0, .2D0,
     &    4*0.D0, 1.D0, 2.1D0, 2.6D0, 2.3D0, 2.1D0, 1.8D0, 1.7D0,
     &     1.4D0, 1.2D0, 1.05D0, .9D0, .66D0,  .5D0,
     &    7*0.D0, .3D0, 1.D0, 1.D0, .9D0, .7D0, .4D0, .30D0, .2D0,
     &   11*0.D0, .1D0, 1.D0, 2.2D0, 3.5D0, 4.20D0, 4.55D0,
     &    4.85D0, 4.9D0,
     &   10*0.D0, .2D0, .7D0, 1.6D0, 2.5D0, 2.2D0, 1.71D0, 1.6D0,
     &    6*0.D0, 1.4D0, 3.8D0, 5.D0, 4.7D0, 4.4D0, 4.D0, 3.5D0,
     &    2.85D0, 2.35D0, 2.01D0, 1.8D0,
     &   12*0.D0, .1D0, .8D0, 2.05D0, 3.31D0, 3.5D0,
     &   12*0.D0, .034D0, .20D0, .75D0, 1.04D0, 1.24D0  /
**** ako - p - data                                                    *
      DATA CPKP61/ 0.D0,4.D0,9.5D0,20.D0,13.D0,9.5D0,6.D0,4.4D0,
     & 3.D0,2.4D0,2.D0,1.4D0,1.2D0,1.D0,.9D0,.7D0,.6D0,0.D0,
     & 4.5D0,6.D0,5.D0,2.5D0,2.D0,1.7D0,2.1D0,1.9D0,.9D0,.5D0,
     & .3D0,.24D0,.2D0,.18D0,.1D0,.09D0,0.D0,1.8D0,2.D0,1.1D0,
     & .9D0,.5D0,.5D0,.4D0,.4D0,.2D0,.1D0,.06D0,.05D0,.04D0,
     & .03D0,.02D0,.02D0,0.D0,1.5D0,2.D0,.9D0,1.1D0,.4D0,.6D0,
     & .7D0,.65D0,.3D0,.17D0,.1D0,.08D0,.07D0,.06D0,.04D0,
     & .03D0,0.D0,.56D0,1.29D0,2.26D0,1.01D0,.64D0,.37D0,
     & 14*0.D0,1.13D0,2.61D0,2.91D0,2.58D0,2.35D0,2.02D0,1.91D0,
     & 1.57D0,1.35D0,1.29D0,1.01D0,.74D0,.65D0,3*0.D0,1.0D0,
     & 3.03D0,3.36D0,2.8D0,2.58D0,2.24D0,1.91D0,1.68D0,1.35D0,
     & 1.01D0,.67D0,.5D0,.24D0,.23D0,3*0.D0,1.0D0,3.03D0,3.36D0,
     & 2.8D0,2.58D0,2.24D0,1.91D0,1.68D0,1.35D0,1.01D0,.67D0,
     & .5D0,.24D0,.23D0,7*0.D0,.34D0,1.12D0,1.12D0,1.01D0,.78D0,
     & .45D0,.39D0,.22D0,.07D0,7*0D0,1.71D0,4.26D0,5.6D0,5.57D0,4.93D0,
     & 4.48D0,3.92D0,3.19D0,2.63D0,2.25D0,2.D0,10*0.D0,.22D0,.8D0,
     & .75D0,1.D0,1.3D0,1.5D0,1.3D0,13*0.D0,.1D0,.3D0,.7D0,1.D0,
     & 13*0.D0,.1D0,.3D0,.7D0,1.D0,9*0.D0,.11D0,1.72D0,2.69D0,3.92D0,
     & 4.76D0,5.10D0,5.44D0,5.3D0,5*0.D0,9.2D0,4.7D0,1.9D0,9*0.D0,
     & .0D0,2.5D0,15.D0,21.5D0,15.3D0,3.D0,1.5D0,10*0.D0 /
      DATA NURE1/9, 12, 5*0, 10, 14, 3*0, 1, 3, 5, 7, 6*0, 2, 6, 16,
     & 5*0, 10, 13, 5*0, 11, 12, 3*0, 2, 4, 6, 8, 6*0, 3, 15, 7, 5*0 /
*
      DO 10 J=1,92
         UMOPI(J)=UMOPI1(J)
         PLAPI(J)=PLAPI1(J)
  10  CONTINUE
      DO 20 J=1,68
         UMOKC(J)=UMOKC1(J)
         PLAKC(J)=PLAKC1(J)
  20  CONTINUE
      DO 30 J=1,39
         UMOP(J)=UMOP1(J)
         PLAP(J)=PLAP1(J)
  30  CONTINUE
      DO 40 J=1,63
         UMON(J)=UMON1(J)
         PLAN(J)=PLAN1(J)
  40  CONTINUE
      DO 50 J=1,34
         UMOK0(J)=UMOK01(J)
         PLAK0(J)=PLAK01(J)
  50  CONTINUE
      DO 60 J=1,296
         SIIN(J)=SIIN1(J)
  60  CONTINUE
      DO 70 J=1,315
         SPIKP1(J)=SPKP11(J)
         SPIKP4(J)=SPKP41(J)
  70  CONTINUE
      DO 80 J=1,278
         SPIKPU(J)=SPKPU1(J)
         SPIKPW(J)=SPKPW1(J)
  80  CONTINUE
      DO 90 J=1,372
         SPIKPV(J)=CPKPV1(J)
         SPIKPX(J)=SPKPX1(J)
  90  CONTINUE
      DO 100 J=1,187
         SPIKP5(J)=SPKP51(J)
         SPIKP8(J)=SPKP81(J)
         SPKP15(J)=CPKP51(J)
  100 CONTINUE
      DO 110 J=1,289
         SPIKP6(J)=SPKP61(J)
  110 CONTINUE
      DO 120 J=1,102
         SKMPEL(J)=SKMPL1(J)
  120 CONTINUE
      DO 130 J=1,289
         SPIKP7(J)=SPKP71(J)
  130 CONTINUE
      DO 140 J=1,68
         SKMNEL(J)=SKMNL1(J)
  140 CONTINUE
      DO 150 J=1,143
         SPIKP9(J)=SPKP91(J)
         SPKPV(J)=SPKPV1(J)
  150 CONTINUE
      DO 160 J=1,169
         SPIKP0(J)=SPKP01(J)
  160 CONTINUE
      DO 170 J=1,105
         SAPPEL(J)=SAPPL1(J)
  170 CONTINUE
      DO 180 J=1,399
         SPIKPE(J)=SPKPE1(J)
  180 CONTINUE
      DO 190 J=1,84
         SAPNEL(J)=SAPNL1(J)
         SANPEL(J)=SANPL1(J)
  190 CONTINUE
      DO 200 J=1,273
         SPIKPZ(J)=SPKPZ1(J)
         SPIKPF(J)=SPKPF1(J)
  200 CONTINUE
      DO 210 J=1,272
         SPKP16(J)=CPKP61(J)
  210 CONTINUE
      DO 220 J=1,164
         NRKPI(J)=NRKPI1(J)
  220 CONTINUE
      DO 230 J=1,132
         NRKKC(J)=NRKKC1(J)
  230 CONTINUE
      DO 240 J=1,70
         NRKP(J)=NRKP1(J)
  240 CONTINUE
      DO 250 J=1,116
         NRKN(J)=NRKN1(J)
  250 CONTINUE
      DO 270 J=1,54
         NRKK0(J)=NRKK01(J)
  270 CONTINUE
      DO 280 J=1,60
         NURELN(J)=NURE1(J)
  280 CONTINUE


*=                                               end*block.blkdt3      *
      END
+DECK,  FLKDT4, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:35  cernlib
* Geant

*$ CREATE BLKDT4.FOR
*COPY BLKDT4
*=== blkdt4 ===========================================================*
*==                                                                    *
      SUBROUTINE FLKDT4

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*-----  Block Data without names
+CDE, HADFLG.
+CDE, REDVER.
      COMMON / FKSLOP  / AMBMBB(75)
      DIMENSION IKII1(17), IEII1(17), IRII1(17)
      DIMENSION AMBMB1(75)
      DIMENSION IKCHX1(16), INNUR1(2,2,16)
*
*     datas     datas    datas      datas     datas
*------          *********
      DATA IKII1/ 0, 15, 41, 67, 82, 93, 110, 133, 148, 159, 172, 183,
     &           207, 224, 241, 252, 268 /
      DATA IEII1/ 0, 21, 46, 71, 92, 109, 126, 143, 160, 173, 186, 199,
     &           220, 241, 262, 279, 296 /
      DATA IRII1/ 0,315, 965, 1615, 1930, 2117, 2406, 2797, 3052, 3195,
     &           3364, 3507, 4011, 4368, 4725, 4912, 5184/

*
*     Masses for the slope B(M) in GeV
*     Slope B(M) for an mesonic system
*     Slope B(M) for a baryonic system
*
      DATA AMBMB1/  0.8D0, 0.85D0,  0.9D0, 0.95D0, 1.D0,
     &     1.05D0,  1.1D0, 1.15D0,  1.2D0, 1.25D0,
     &      1.3D0,  1.35D0, 1.4D0,  1.45D0,  1.5D0,
     &     1.55D0,  1.6D0,  1.65D0, 1.7D0,   1.75D0,
     &      1.8D0,  1.85D0, 1.9D0,  1.95D0,  2.D0,
     &     15.6D0, 14.95D0, 14.3D0, 13.65D0, 13.D0,
     &    12.35D0, 11.7D0, 10.85D0, 10.D0,  9.15D0,
     &      8.3D0,  7.8D0,  7.3D0,  7.25D0,  7.2D0,
     &     6.95D0,  6.7D0,  6.6D0,  6.5D0,   6.3D0,
     &      6.1D0,  5.85D0, 5.6D0,  5.35D0,  5.1D0,
     &      15.D0,   15.D0, 15.D0,  15.D0,   15.D0, 15.D0, 15.D0,
     &     14.2D0,  13.4D0, 12.6D0,
     &     11.8D0, 11.2D0, 10.6D0,  9.8D0,    9.D0,
     &     8.25D0,  7.5D0, 6.25D0,  5.D0,    4.5D0, 5*4.D0 /
*
*  /Hadflg/
      DATA IELFL1, ICXFL1, IOLDH1 / 3*0 /
      DATA IKCHX1 / 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0 /
      DATA INNUR1 / 13, 1, 2*0, 14, 8, 23, 1, 14, 1, 23, 8, 14, 8, 2*0,
     &              15, 1, 2*0, 15, 8, 24, 1, 16, 1, 25, 8, 16, 8, 2*0,
     &               1, 1, 2*0,  1, 8,  8, 1,  8, 8, 2*0,  2, 1,  9, 8,
     &               2, 8, 2*0,  9, 1, 2*0, 24, 8, 2*0, 25, 1, 2*0 /
*
      DO 10 J=1,17
        IKII(J) = IKII1(J)
        IEII(J) = IEII1(J)
        IRII(J) = IRII1(J)
  10  CONTINUE
*
      DO 20 J=1,75
         AMBMBB(J) = AMBMB1(J)
   20 CONTINUE
*
      DO 30 J=1,16
         IKCHXG(J) = IKCHX1(J)
   30 CONTINUE
      DO 60 J1=1,2
        DO 50 J2=1,2
          DO 40 J3=1,16
            INNURE(J1,J2,J3) = INNUR1(J1,J2,J3)
   40     CONTINUE
   50   CONTINUE
   60 CONTINUE
      IELFLG = IELFL1
      ICXFLG = ICXFL1
      IOLDHD = IOLDH1
*=                                               end*block.blkdt4      *
      END
+DECK,  FLKDT5, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:36  cernlib
* Geant

*$ CREATE BLKDT5.FOR
*COPY BLKDT5
*=== blkdt5 ===========================================================*
*==                                                                    *
      SUBROUTINE FLKDT5

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
      CHARACTER*8 ZKNM51(90),ZKNM61(54),ANAMZ1(16),ZKNM41(9)
      DIMENSION AMZ1(16),GAZ1(16),TAUZ1(16),ICHZ1(16),IBARZ1(16),
     & K1Z1(16),K2Z1(16),WTZ1(153),NZK11(153),NZK21(153),NZK31(153)
*
      CHARACTER*8 ZKNAM5,ZKNAM6,ANAMZ,ZKNAM4
      COMMON /FKADHP/ AMZ(16),GAZ(16),TAUZ(16),ICHZ(16),IBARZ(16),
     &       K1Z(16),K2Z(16),WTZ(153),II22,NZK1(153),NZK2(153),NZK3(153)
      COMMON /FKADHN/ ANAMZ(16),ZKNAM4(9),ZKNAM5(90),ZKNAM6(54)
*     Particle masses in GeV                                           *
      DATA AMZ1/ 3*2.2D0, 0.9576D0, 3*1.887D0, 2.4D0, 2.03D0, 2*1.43D0,
     &          2*1.7D0, 3*0.D0/
*     Resonance width Gamma in GeV                                     *
      DATA GAZ1/ 3*.2D0, .1D0, 4*.2D0, .18D0, 2*.2D0, 2*.15D0, 3*0.D0 /
*     Mean life time in seconds                                        *
      DATA TAUZ1 / 16*0.D0 /
*     Charge of particles and resonances                               *
      DATA ICHZ1/ 0, 1, 3*0, 1, -1, 0, 1, -1, 0, 0, 1 , 3*0 /
*     Baryonic charge                                                  *
      DATA IBARZ1/ 2, 7*0, 1, -1, -1, 1, 1, 3*0 /
*     First number of decay channels used for resonances               *
*     and decaying particles                                           *
      DATA K1Z1/ 308,310,313,317,322,365,393,421,425,434,440,446,449,
     &          3*460/
*     Last number of decay channels used for resonances                *
*     and decaying particles                                           *
      DATA K2Z1/ 309,312,316,321,364,392,420,424,433,439,445,448,451,
     &          3*460/
*     Weight of decay channel                                          *
      DATA WTZ1/ .17D0, .83D0, 2*.33D0, .34D0, .17D0, 2*.33D0, .17D0,
     & .01D0, .13D0, .36D0, .27D0, .23D0, .0014D0, .0029D0, .0014D0,
     & .0029D0, 4*.0007D0, .0517D0, .0718D0, .0144D0, .0431D0, .0359D0,
     & .0718D0, .0014D0, .0273D0, .0014D0, .0431D0, 2*.0129D0, .0259D0,
     & .0517D0, .0359D0, .0014D0, 2*.0144D0, .0129D0, .0014D0, .0259D0,
     & .0359D0, .0072D0, .0474D0, .0948D0, .0259D0, .0072D0, .0144D0,
     & .0287D0, .0431D0, .0144D0, .0287D0, .0474D0, .0144D0, .0075D0,
     & .0057D0, .0019D0, .0038D0, .0095D0, 2*.0014D0, .0191D0, .0572D0,
     & .1430D0, 2*.0029D0, 5*.0477D0, .0019D0, .0191D0, .0686D0,.0172D0,
     & .0095D0, .1888D0, .0172D0, .0191D0, .0381D0, 2*.0571D0, .0190D0,
     & .0057D0, .0019D0, .0038D0, .0095D0, .0014D0, .0014D0, .0191D0,
     & .0572D0, .1430D0, 2*.0029D0, 5*.0477D0, .0019D0, .0191D0,.0686D0,
     & .0172D0, .0095D0, .1888D0, .0172D0, .0191D0, .0381D0, 2*.0571D0,
     & .0190D0, 4*.25D0, 2*.2D0, .12D0, .1D0, .07D0, .07D0, .14D0,
     & 2*.05D0, .4D0, .2D0, .125D0, 2*.075D0, .125D0, .4D0, .075D0,
     & .125D0, .2D0, .125D0, .075D0, .3D0, .05D0, .65D0, .3D0, .05D0,
     & .65D0, 9*1.D0 /
*     Particle numbers in decay channel                                *
      DATA NZK11/ 8, 1, 2, 9, 1, 2, 9, 2, 9, 7, 13, 31, 15, 24, 23, 13,
     & 23, 13, 2*23, 14, 13, 23, 31, 98, 2*33, 32, 23, 14, 13, 35, 2*23,
     & 14, 13, 33, 23, 98, 31, 23, 14, 13, 35, 2*33, 32, 23, 35, 33, 32,
     & 98, 5*35, 4*13, 23, 13, 98, 32, 33, 23, 13, 23, 13, 14, 13, 32,
     & 13, 98, 23, 13, 2*32, 13, 33, 32, 98, 2*35, 4*14, 23, 14, 98,
     & 2*34, 23, 14, 23, 2*14, 13, 34, 14, 98, 23, 14, 2*34, 14, 33, 32,
     & 98, 2*35, 104, 61, 105, 62, 1, 17, 21, 17, 22, 2*21, 22, 21, 2,
     & 67, 68, 69, 2, 2*9, 68, 69, 70, 2, 9, 2*24, 15, 2*25, 16, 9*0/
      DATA NZK21/ 2*8, 1, 8, 9, 2*8, 2*1, 7, 14, 13, 16, 25, 23, 14, 23,
     & 14, 31, 33, 32, 34, 35, 31, 23, 31, 33, 34, 31, 32, 34, 31, 33,
     & 32, 2*33, 35, 31, 33, 31, 33, 32, 34, 35, 31, 33, 34, 35, 31,
     & 4*33, 32, 3*35,  2*23, 13, 31, 32, 33, 13, 31, 32, 2*31, 32, 33,
     & 32, 32, 35, 31, 2*32, 33, 31, 33, 35, 33, 3*32, 35, 2*23, 14,
     & 31, 34, 33, 14, 31, 33, 2*31, 34, 32, 33, 34, 35, 31, 2*34, 33,
     & 31, 33, 35, 33, 2*34, 33, 35, 1, 2, 8, 9, 25, 13, 35, 2*32, 33,
     & 31, 13, 23, 31, 13, 23, 14, 79, 80, 31, 13, 23, 14, 78, 79, 8,
     & 1, 8, 1, 8, 1, 9*0 /
      DATA NZK31/ 23, 14, 2*13, 23, 13, 2*23, 14, 0, 7, 14, 4*0, 2*23,
     & 10*0, 33, 2*31, 0, 33, 34, 32, 34, 0, 35, 0, 31, 3*35, 0, 3*31,
     & 35, 31, 33, 34, 31, 33, 34, 31, 33, 35, 0, 23, 14, 6*0, 32, 3*33,
     & 32, 34, 0, 35, 0, 2*35, 2*31, 35, 32, 34, 31, 33, 32, 0, 23, 13,
     & 6*0, 34, 2*33, 34, 33, 34, 0, 35, 0,2*35, 2*31, 35, 2*34, 31,
     & 2*34, 25*0, 23, 2*14, 23, 2*13, 9*0 /
*     Particle  names                                                  *
      DATA ANAMZ1 /'NNPI', 'ANPPI', 'ANNPI', ' ETS  ',' PAP  ',' PAN  ',
     & 'APN', 'DEO   ', 'S+2030', 'AN*-14', 'AN*014','KONPI ','AKOPPI',
     & 3*'BLANK' /
*     Name of decay channel                                            *
      DATA ZKNM41/'NNPI0','PNPI-','APPPI+','ANNPI+','ANPPI0','APNPI+',
     & 'ANNPI0','APPPI0','ANPPI-'/
      DATA ZKNM51/' GAGA ','P+P-GA','ETP+P-','K+K-  ','K0AK0 ',
     & ' POPO ',' P+P- ','POPOPO','P+P0P-','P0ET  ','&0R0  ','P-R+  ',
     & 'P+R-  ','POOM  ',' ETET ','ETSP0 ','R0ET  ',' R0R0 ','R+R-  ',
     & 'P0ETR0','P-ETR+','P+ETR-',' OMET ','P0R0R0','P0R+R-','P-R+R0',
     & 'P+R-R0','R0OM  ','P0ETOM','ETSR0 ','ETETET','P0R0OM','P-R+OM',
     & 'P+R-OM','OMOM  ','R0ETET','R0R0ET','R+R-ET','P0OMOM','OMETET',
     & 'R0R0R0','R+R0R-','ETSRET','OMR0R0','OMR+R-','OMOMET','OMOMR0',
     & 'OMOMOM',
     & ' P+PO ','P+POPO','P+P+P-','P+ET  ','P0R+  ','P+R0  ','ETSP+ ',
     & 'R+ET  ',' R0R+ ','POETR+','P+ETR0','POR+R-','P+R0R0','P-R+R+',
     & 'P+R-R+','R+OM  ','P+ETOM','ETSR+ ','POR+OM','P+R0OM','R+ETET',
     & 'R+R0ET','P+OMOM','R0R0R+','R+R+R-','ETSR+E','OMR+R0','OMOMR+',
     & 'P-PO  ','P-POPO','P-P-P+','P-ET  ','POR-  ','P-R0  ','ETSP- ',
     & 'R-ET  ','R-R0  ','POETR-','P-ETR0','POR-R0','P-R+R-','P-R0R0'/
      DATA ZKNM61/'P+R-R-','R-OM  ','P-ETOM','ETSR- ','POR-OM','P-R0OM',
     & 'R-ETET','R-R0ET','P-OMOM','R0R0R-','R+R-R-','ETSR-E','OMR0R-',
     & 'OMOMR-', 'PAN-14','APN+14','NAN014','ANN014','PAKO  ','LPI+  ',
     & 'SI+OM','LAMRO+','SI0RO+','SI+RO0','SI+ETA','SI0PI+','SI+PI0',
     & 'APETA ','AN=P+ ','AN-PO ','ANOPO ','APRHOO','ANRHO-','ANETA ',
     & 'AN-P+ ','AN0PO ','AN+P- ','APRHO+','ANRHO0',
     & 'KONPIO','KOPPI-','K+NPI-','AKOPPO','AKONP+','K-PPI+',
     & 9*'BLANK'/
*
      DO 10 J=1,16
         AMZ(J)=AMZ1(J)
         GAZ(J)=GAZ1(J)
         TAUZ(J)=TAUZ1(J)
         ICHZ(J)=ICHZ1(J)
         IBARZ(J)=IBARZ1(J)
         K1Z(J)=K1Z1(J)
         K2Z(J)=K2Z1(J)
         ANAMZ(J)=ANAMZ1(J)
  10  CONTINUE
      DO 20 J=1,153
         WTZ(J)=WTZ1(J)
         NZK1(J)=NZK11(J)
         NZK2(J)=NZK21(J)
         NZK3(J)=NZK31(J)
  20  CONTINUE
      DO 30 J=1,9
         ZKNAM4(J)=ZKNM41(J)
  30  CONTINUE
      DO 40 J=1,90
         ZKNAM5(J)=ZKNM51(J)
  40  CONTINUE
      DO 50 J=1,54
         ZKNAM6(J)=ZKNM61(J)
  50  CONTINUE

*=                                               end*block.blkdt5      *
      END
+DECK,  FLKDT6, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:36  cernlib
* Geant

*$ CREATE BLKDT6.FOR
*COPY BLKDT6
*=== blkdt6 ===========================================================*
*==                                                                    *
      SUBROUTINE FLKDT6

+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
*---Block Data 6 (ex 1)                                                *
+CDE, PART.
+CDE, QQUARK.
      CHARACTER*8 ANAME1(IDMAX8)
      DIMENSION AM1(IDMAX8),GA1(IDMAX8),TAU1(IDMAX8),
     & ICH1(IDMAX8),IBAR1(IDMAX8),K11(IDMAX8),K21(IDMAX8),
     & KPTIP1(IDMAX8),IPTKP1(39),
     & IQECH1(-6:6),IQBCH1(-6:6),IQICH1(-6:6),IQSCH1(-6:6),
     & IQCCH1(-6:6),IQUCH1(-6:6),IQTCH1(-6:6),MQUAR1(3,39)
*
* / Part /
*     datas     datas    datas      datas     datas                    *
*     ---------------------------------------------                    *
*                                                                      *
*     Particle  masses                                                 *
*                                                                      *
      DATA ( AM1 ( I ), I =   1, 54 ) /
     & 9.38272310000000D-01, 9.38272310000000D-01,       AMELCT        ,
     &       AMELCT        , 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 9.39565630000000D-01, 9.39565630000000D-01,
     &       AMMUON        ,       AMMUON        , 4.97671000000000D-01,
     & 1.39567500000000D-01, 1.39567500000000D-01, 4.93646000000000D-01,
     & 4.93646000000000D-01, 1.11563000000000D+00, 1.11563000000000D+00,
     & 4.97671000000000D-01, 1.19743000000000D+00, 1.18937000000000D+00,
     & 1.19255000000000D+00, 1.34973900000000D-01, 4.97671000000000D-01,
     & 4.97671000000000D-01, 1.34973900000000D-01, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 5.48800000000000D-01, 7.68300000000000D-01, 7.68300000000000D-01,
     & 7.68300000000000D-01, 7.81950000000000D-01, 8.91830000000000D-01,
     & 8.96100000000000D-01, 8.91830000000000D-01, 8.96100000000000D-01,
     & 1.25000000000000D+00, 1.25000000000000D+00, 1.25000000000000D+00,
     & 1.25000000000000D+00, 1.42100000000000D+00, 1.42100000000000D+00,
     & 1.42100000000000D+00, 1.42100000000000D+00, 1.38280000000000D+00,
     & 1.38370000000000D+00, 1.38720000000000D+00, 1.82000000000000D+00,
     & 2.03000000000000D+00, 1.23200000000000D+00, 1.23200000000000D+00/
      DATA ( AM1 ( I ), I =  55,108 ) /
     & 1.23200000000000D+00, 1.23200000000000D+00, 1.67500000000000D+00,
     & 1.67500000000000D+00, 1.67500000000000D+00, 1.67500000000000D+00,
     & 1.44000000000000D+00, 1.44000000000000D+00, 1.52000000000000D+00,
     & 1.52000000000000D+00, 1.77500000000000D+00, 1.77500000000000D+00,
     & 1.23200000000000D+00, 1.23200000000000D+00, 1.23200000000000D+00,
     & 1.23200000000000D+00, 1.67500000000000D+00, 1.67500000000000D+00,
     & 1.67500000000000D+00, 1.67500000000000D+00, 1.52000000000000D+00,
     & 1.52000000000000D+00, 2.40000000000000D+00, 4.89000000000000D-01,
     & 4.89000000000000D-01, 4.89000000000000D-01, 1.30000000000000D+00,
     & 1.30000000000000D+00, 1.30000000000000D+00, 1.30000000000000D+00,
     & 2.20000000000000D+00, 2.20000000000000D+00, 2.20000000000000D+00,
     & 2.20000000000000D+00, 1.70000000000000D+00, 1.70000000000000D+00,
     & 1.70000000000000D+00, 1.70000000000000D+00, 1.82000000000000D+00,
     & 2.03000000000000D+00, 9.57500000000000D-01, 1.01941200000000D+00,
     & 1.31490000000000D+00, 1.32132000000000D+00, 1.18937000000000D+00,
     & 1.19255000000000D+00, 1.19743000000000D+00, 1.31490000000000D+00,
     & 1.32132000000000D+00, 1.38280000000000D+00, 1.38370000000000D+00,
     & 1.38720000000000D+00, 1.53180000000000D+00, 1.53500000000000D+00/
      DATA ( AM1 ( I ), I = 109,162 ) /
     & 1.67243000000000D+00, 1.38280000000000D+00, 1.38370000000000D+00,
     & 1.38720000000000D+00, 1.53180000000000D+00, 1.53500000000000D+00,
     & 1.67243000000000D+00, 1.86450000000000D+00, 1.86930000000000D+00,
     & 1.86930000000000D+00, 1.86450000000000D+00, 1.96880000000000D+00,
     & 1.96880000000000D+00, 2.03000000000000D+00, 2.00710000000000D+00,
     & 2.01010000000000D+00, 2.01010000000000D+00, 2.00710000000000D+00,
     & 2.11030000000000D+00, 2.11030000000000D+00, 3.68600000000000D+00,
     & 3.09693000000000D+00, 1.78410000000000D+00, 1.78410000000000D+00,
     & 3.50000000000000D-02, 3.50000000000000D-02, 2.70000000000000D-04,
     & 2.70000000000000D-04, 2.26000000000000D+00, 2.47000000000000D+00,
     & 2.47000000000000D+00, 2.41000000000000D+00, 2.42000000000000D+00,
     & 2.41000000000000D+00, 2.56000000000000D+00, 2.56000000000000D+00,
     & 2.73000000000000D+00, 3.61000000000000D+00, 3.61000000000000D+00,
     & 3.79000000000000D+00, 2.26000000000000D+00, 2.47000000000000D+00,
     & 2.47000000000000D+00, 2.41000000000000D+00, 2.42000000000000D+00,
     & 2.41000000000000D+00, 2.56000000000000D+00, 2.56000000000000D+00,
     & 2.73000000000000D+00, 3.61000000000000D+00, 3.61000000000000D+00,
     & 3.79000000000000D+00, 2.49000000000000D+00, 2.49000000000000D+00/
      DATA ( AM1 ( I ), I = 163,183 ) /
     & 2.49000000000000D+00, 2.61000000000000D+00, 2.61000000000000D+00,
     & 2.77000000000000D+00, 3.67000000000000D+00, 3.67000000000000D+00,
     & 3.85000000000000D+00, 4.89000000000000D+00, 2.49000000000000D+00,
     & 2.49000000000000D+00, 2.49000000000000D+00, 2.61000000000000D+00,
     & 2.61000000000000D+00, 2.77000000000000D+00, 3.67000000000000D+00,
     & 3.67000000000000D+00, 3.85000000000000D+00, 4.89000000000000D+00,
     & 1.25000000000000D+00, 1.25000000000000D+00, 1.25000000000000D+00/
*                                                                      *
*     Particle  mean lives                                             *
*                                                                      *
      DATA ( TAU1 ( I ), I =   1, 54 ) /
     & 1.00000000000000D+18, 1.00000000000000D+18, 1.00000000000000D+18,
     & 1.00000000000000D+18, 1.00000000000000D+18, 1.00000000000000D+18,
     & 1.00000000000000D+18, 8.88600000000000D+02, 8.88600000000000D+02,
     & 2.19703000000000D-06, 2.19703000000000D-06, 5.17000000000000D-08,
     & 2.60300000000000D-08, 2.60300000000000D-08, 1.23710000000000D-08,
     & 1.23710000000000D-08, 2.63200000000000D-10, 2.63200000000000D-10,
     & 8.92200010000000D-11, 1.47900000000000D-10, 7.99000000000000D-11,
     & 7.40000000000000D-20, 8.40000000000000D-17, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00/
      DATA ( TAU1 ( I ), I =  55,108 ) /
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 2.90000000000000D-10, 1.63900000000000D-10, 7.99000000000000D-11,
     & 7.40000000000000D-20, 1.47900000000000D-10, 2.90000000000000D-10,
     & 1.63900000000000D-10, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00/
      DATA ( TAU1 ( I ), I = 109,162 ) /
     & 8.22000000000000D-11, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 8.22000000000000D-11, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 3.03000000000000D-13, 3.03000000000000D-13,
     & 1.00000000000000D+18, 1.00000000000000D+18, 1.00000000000000D+18,
     & 1.00000000000000D+18, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00/
      DATA ( TAU1 ( I ), I = 163,183 ) /
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00/
*                                                                      *
*     Resonance width Gamma in GeV                                     *
*                                                                      *
      DATA ( GA1 ( I ), I =   1, 54 ) /
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 1.19000000000000D-06, 1.49100000000000D-01, 1.49100000000000D-01,
     & 1.49100000000000D-01, 8.43000000000000D-03, 4.98000000000000D-02,
     & 4.98000000000000D-02, 4.98000000000000D-02, 4.98000000000000D-02,
     & 4.50000000000000D-01, 4.50000000000000D-01, 4.50000000000000D-01,
     & 4.50000000000000D-01, 1.08000000000000D-01, 1.08000000000000D-01,
     & 1.08000000000000D-01, 1.08000000000000D-01, 3.58000000000000D-02,
     & 3.65000000000000D-02, 3.94000000000000D-02, 8.50000000000000D-02,
     & 1.80000000000000D-01, 1.15000000000000D-01, 1.15000000000000D-01/
      DATA ( GA1 ( I ), I =  55,108 ) /
     & 1.15000000000000D-01, 1.15000000000000D-01, 2.00000000000000D-01,
     & 2.00000000000000D-01, 2.00000000000000D-01, 2.00000000000000D-01,
     & 2.00000000000000D-01, 2.00000000000000D-01, 1.00000000000000D-01,
     & 1.00000000000000D-01, 2.00000000000000D-01, 2.00000000000000D-01,
     & 1.15000000000000D-01, 1.15000000000000D-01, 1.15000000000000D-01,
     & 1.15000000000000D-01, 2.00000000000000D-01, 2.00000000000000D-01,
     & 2.00000000000000D-01, 2.00000000000000D-01, 1.00000000000000D-01,
     & 1.00000000000000D-01, 2.00000000000000D-01, 1.00000000000000D-01,
     & 1.00000000000000D-01, 1.00000000000000D-01, 1.00000000000000D-01,
     & 1.00000000000000D-01, 1.00000000000000D-01, 1.00000000000000D-01,
     & 2.00000000000000D-01, 2.00000000000000D-01, 2.00000000000000D-01,
     & 2.00000000000000D-01, 1.50000000000000D-01, 1.50000000000000D-01,
     & 1.50000000000000D-01, 1.50000000000000D-01, 8.50000000000000D-02,
     & 1.80000000000000D-01, 2.08000000000000D-04, 4.41000000000000D-03,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 3.58000000000000D-02, 3.65000000000000D-02,
     & 3.94000000000000D-02, 9.10000000000000D-03, 9.90000000000000D-03/
      DATA ( GA1 ( I ), I = 109,162 ) /
     & 0.00000000000000D+00, 3.40000000000000D-02, 3.40000000000000D-02,
     & 3.60000000000000D-02, 9.10000000000000D-03, 9.90000000000000D-03,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 2.10000000000000D-03,
     & 1.10000000000000D-03, 1.10000000000000D-03, 5.00000000000000D-03,
     & 2.00000000000000D-03, 2.00000000000000D-03, 2.43000000000000D-04,
     & 6.80000000000000D-05, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00/
      DATA ( GA1 ( I ), I = 163,183 ) /
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 0.00000000000000D+00, 0.00000000000000D+00, 0.00000000000000D+00,
     & 3.00000000000000D-01, 3.00000000000000D-01, 3.00000000000000D-01/
*                                                                      *
*     Particle  names                                                  *
*                                                                      *
*     S+1385+Sigma+(1385)    L02030+Lambda0(2030)                      *
*     Rho77=Rho(770) Om783=Omega(783) K*14=K*(1420) and so on          *
*     designation N*@@ means N*@1(@2)                                  *
*                                                                      *
*                                                                      *
      DATA (    ANAME1 ( I ), I =   1,108 ) /
     &'P       ','AP      ','E-      ','E+      ','NUE     ','ANUE    ',
     &'GAM     ','NEU     ','ANEU    ','MUE+    ','MUE-    ','K0L     ',
     &'PI+     ','PI-     ','K+      ','K-      ','LAM     ','ALAM    ',
     &'K0S     ','SIGM-   ','SIGM+   ','SIGM0   ','PI0     ','K0      ',
     &'AK0     ','BLANK   ','BLANK   ','BLANK   ','BLANK   ','BLANK   ',
     &'ETA550  ','RHO+77  ','RHO077  ','RHO-77  ','OM0783  ','K*+892  ',
     &'K*0892  ','K*-892  ','AK*089  ','KA+125  ','KA0125  ','KA-125  ',
     &'AKA012  ','K*+142  ','K*0142  ','K*-142  ','AK*014  ','S+1385  ',
     &'S01385  ','S-1385  ','L01820  ','L02030  ','DE++12  ','DEL+12  ',
     &'DEL012  ','DEL-12  ','N*++16  ','N*+16   ','N*016   ','N*-16   ',
     &'N*+14   ','N*014   ','N*+15   ','N*015   ','N*+18   ','N*018   ',
     &'AD--12  ','ADE-12  ','ADE012  ','ADE+12  ','AN--16  ','AN*-16  ',
     &'AN*016  ','AN*+16  ','AN*-15  ','AN*015  ','DE*=24  ','RPI+49  ',
     &'RPI049  ','RPI-49  ','PIN++   ','PIN+0   ','PIN+-   ','PIN-0   ',
     &'PPPI    ','PNPI    ','APPPI   ','APNPI   ','K+PPI   ','K-PPI   ',
     &'K+NPI   ','K-NPI   ','S+1820  ','S-2030  ','ETA*    ','PHI     ',
     &'XSI0    ','XSI-    ','ASIG-   ','ASIG0   ','ASIG+   ','AXSI0   ',
     &'AXSI+   ','SIG*+   ','SIG*0   ','SIG*-   ','XSI*0   ','XSI*-   '/
      DATA (    ANAME1 ( I ), I = 109,183 ) /
     &'OMEGA-  ','ASIG*-  ','ASIG*0  ','ASIG*+  ','AXSI*0  ','AXSI*+  ',
     &'OMEGA+  ','D0      ','D+      ','D-      ','AD0     ','DS+     ',
     &'DS-     ','ETAC    ','D*0     ','D*+     ','D*-     ','AD*0    ',
     &'DS*+    ','DS*-    ','PSI     ','JPSI    ','TAU+    ','TAU-    ',
     &'NUET    ','ANUET   ','NUEM    ','ANUEM   ','C0+     ','A+      ',
     &'A0      ','C1++    ','C1+     ','C10     ','S+      ','S0      ',
     &'T0      ','XU++    ','XD+     ','XS+     ','AC0-    ','AA-     ',
     &'AA0     ','AC1--   ','AC1-    ','AC10    ','AS-     ','AS0     ',
     &'AT0     ','AXU--   ','AXD-    ','AXS     ','C1*++   ','C1*+    ',
     &'C1*0    ','S*+     ','S*0     ','T*0     ','XU*++   ','XD*+    ',
     &'XS*+    ','TETA++  ','AC1*--  ','AC1*-   ','AC1*0   ','AS*-    ',
     &'AS*0    ','AT*0    ','AXU*--  ','AXD*-   ','AXS*-   ','ATET--  ',
     &'RO      ','R+      ','R-      '/
*                                                                      *
*     Charge of particles and resonances                               *
*                                                                      *
      DATA ( ICH1 ( I ), I =   1,183 ) /
     &  1, -1, -1,  1,  0,  0,  0,  0,  0,  1, -1,  0,  1, -1,  1,
     & -1,  0,  0,  0, -1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     &  0,  1,  0, -1,  0,  1,  0, -1,  0,  1,  0, -1,  0,  1,  0,
     & -1,  0,  1,  0, -1,  0,  0,  2,  1,  0, -1,  2,  1,  0, -1,
     &  1,  0,  1,  0,  1,  0, -2, -1,  0,  1, -2, -1,  0,  1, -1,
     &  0,  1,  1,  0, -1,  2,  1,  0, -1,  2,  1,  0, -1,  2,  0,
     &  1, -1,  1, -1,  0,  0,  0, -1, -1,  0,  1,  0,  1,  1,  0,
     & -1,  0, -1, -1, -1,  0,  1,  0,  1,  1,  0,  1, -1,  0,  1,
     & -1,  0,  0,  1, -1,  0,  1, -1,  0,  0,  1, -1,  0,  0,  0,
     &  0,  1,  1,  0,  2,  1,  0,  1,  0,  0,  2,  1,  1, -1, -1,
     &  0, -2, -1,  0, -1,  0,  0, -2, -1, -1,  2,  1,  0,  1,  0,
     &  0,  2,  1,  1,  2, -2, -1,  0, -1,  0,  0, -2, -1, -1, -2,
     &  0,  1, -1/
*                                                                      *
*     Particle  baryonic charges                                       *
*                                                                      *
      DATA ( IBAR1 ( I ), I =   1,183 ) /
     &  1, -1,  0,  0,  0,  0,  0,  1, -1,  0,  0,  0,  0,  0,  0,
     &  0,  1, -1,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,
     &  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     &  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     &  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     & -1,  2,  0,  0,  0,  1,  1,  1,  1,  2,  2,  0,  0,  1,  1,
     &  1,  1,  1,  1,  0,  0,  1,  1, -1, -1, -1, -1, -1,  1,  1,
     &  1,  1,  1,  1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,
     &  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     &  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1,
     & -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,
     &  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     &  0,  0,  0/
*                                                                      *
*     First number of decay channels used for resonances               *
*     and decaying particles                                           *
*                                                                      *
      DATA K11/1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16, 17, 18, 24, 30,
     & 34, 38, 40, 41, 43, 44, 136, 138, 5*330, 46, 51, 52, 54, 55, 58,
     &  60, 62, 64, 66, 68, 70, 72, 74, 82, 90, 98, 106, 109, 112, 114,
     & 123, 140, 141, 143, 145, 146, 150, 157, 164, 168, 174, 180, 187,
     & 194, 202, 210, 211, 213, 215, 216, 220, 227, 234, 238, 245, 252,
     & 254, 255, 256, 257, 259, 262, 265, 267, 269, 272, 276, 279, 282,
     & 286, 290, 293, 299, 331, 335, 339, 340, 341, 343, 344, 345, 346,
     & 347, 350, 353, 356, 358, 360, 363, 366, 369, 372, 374, 376, 379,
     & 383, 385, 387, 391, 394, 397, 400, 402, 405, 408, 410, 412, 414,
     & 417, 420, 425, 430, 431, 432, 433, 434, 448, 452, 457, 458, 459,
     & 460, 461, 462, 466, 468, 470, 472, 486, 490, 495, 496, 497, 498,
     & 499, 500, 504, 506, 508, 510, 511, 512, 513, 514, 515, 516, 517,
     & 518, 519, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 534,
     & 537, 539 /
*                                                                      *
*     Last number of decay channels used for resonances                *
*     and decaying particles                                           *
*                                                                      *
      DATA K21/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 15, 16, 17, 23, 29,
     & 31, 35, 39, 40, 42, 43, 45, 137, 139, 5* 330, 50, 51, 53, 54, 57,
     & 59, 61, 63, 65, 67, 69, 71, 73, 81, 89, 97, 105, 108, 111, 113,
     & 122, 135, 140, 142, 144, 145, 149, 156, 163, 167, 173, 179, 186,
     & 193, 201, 209, 210, 212, 214, 215, 219, 226, 233, 237, 244, 251,
     & 253, 254, 255, 256, 258, 261, 264, 266, 268, 271, 275, 278, 281,
     & 285, 289, 292, 298, 307, 334, 338, 339, 340, 342, 343, 344, 345,
     & 346, 349, 352, 355, 357, 359, 362, 365, 368, 371, 373, 375, 378,
     & 382, 384, 386, 390, 393, 396, 399, 401, 404, 407, 409, 411, 413,
     & 416, 419, 424, 429, 430, 431, 432, 433, 447, 451, 456, 457, 458,
     & 459, 460, 461, 465, 467, 469, 471, 485, 489, 494, 495, 496, 497,
     & 498, 499, 503, 505, 507, 509, 510, 511, 512, 513, 514, 515, 516,
     & 517, 518, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 533,
     & 536, 538, 540 /
*                                                                      *
*     Conversion from part to paprop numbering                         *
*                                                                      *
      DATA KPTIP1 / 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
     & 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 66*0,
     & 34, 36, 31, 32, 33, 35, 37, 5*0, 38, 5*0, 39, 68*0 /
*                                                                      *
*     Conversion from paprop to part numbering                         *
*                                                                      *
      DATA IPTKP1 / 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
     & 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 99,
     & 100, 101, 97, 102, 98, 103, 109, 115 /
* / Qquark /
      DATA IQECH1 / -2, 1, -2, 1, 1, -2, 0, 2, -1, -1, 2, -1, 2 /
      DATA IQBCH1 / 6*-1, 0, 6*1 /
      DATA IQICH1 / 4*0, 1, -1, 0, 1, -1, 4*0 /
      DATA IQSCH1 / 3*0, 1, 5*0, -1, 3*0 /
      DATA IQCCH1 / 2*0, -1, 7*0, 1, 2*0 /
      DATA IQUCH1 / 0, 1, 9*0, -1, 0 /
      DATA IQTCH1 / -1, 11*0, 1 /
      DATA MQUAR1 /                1,1,2,    -1,-1,-2,
     *   0,0,0,       0,0,0,       0,0,0,       0,0,0,       0,0,0,
     *   1,2,2,    -1,-2,-2,       0,0,0,       0,0,0,       0,0,0,
     *  1,-2,0,      2,-1,0,      1,-3,0,      3,-1,0,
     *   1,2,3,    -1,-2,-3,       0,0,0,
     *   2,2,3,     1,1,3,     1,2,3,     1,-1,0,
     *   2,-3,0,    3,-2,0,    2,-2,0,    0,0,0,
     *   0,0,0,       0,0,0,       0,0,0,
     *  -1,-1,-3,    -1,-2,-3,    -2,-2,-3,
     *   1,3,3,      -1,-3,-3,     2,3,3,      -2,-3,-3,
     *   3,3,3,      -3,-3,-3 /
*
      DO 10 J=1, 39
         IPTOKP(J)=IPTKP1(J)
   10 CONTINUE
      DO 20 J=1,IDMAX8
         AM(J)=AM1(J)
         GA(J)=GA1(J)
         TAU(J)=TAU1(J)
         ICH(J)=ICH1(J)
         IBAR(J)=IBAR1(J)
         K1(J)=K11(J)
         K2(J)=K21(J)
         KPTOIP(J)=KPTIP1(J)
         ANAME(J)=ANAME1(J)
   20 CONTINUE
      DO 30 J=-6,6
         IQECHR(J)=IQECH1(J)
         IQBCHR(J)=IQBCH1(J)
         IQICHR(J)=IQICH1(J)
         IQSCHR(J)=IQSCH1(J)
         IQCCHR(J)=IQCCH1(J)
         IQUCHR(J)=IQUCH1(J)
         IQTCHR(J)=IQTCH1(J)
   30 CONTINUE
      DO 50 J=1,3
         DO 40 I=1,39
            MQUARK(J,I)=MQUAR1(J,I)
   40    CONTINUE
   50 CONTINUE
*=                                               end*block.blkdt6      *
      END
+DECK,  FLKDT7, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:36  cernlib
* Geant

*$ CREATE BLKDT7.FOR
*COPY BLKDT7
*=== blkdt7 ===========================================================*
*==                                                                    *
      SUBROUTINE FLKDT7
*
+CDE, DBLPRC.
+CDE, DIMPAR.
+CDE, IOUNIT.
* * Block data 7 (ex 2)                                                *
+CDE, DECAYC.
      CHARACTER*8 ZKNAM1
      DIMENSION ZKNAM1(IDMAX9),NZK1(IDMAX9,3),WT1(IDMAX9)
*
*                                                                      *
*     Name of decay channel                                            *
*                                                                      *
      DATA (ZKNAM1(I),I=1,87) / 'P', 'AP', 'E-', 'E+', 'NUE', 'ANUE',
     & 'GAM',   'PE-NUE', 'APEANU', 'EANUNU', 'E-NUAN', '3PI0', 'PI+-0',
     & 'PIMUNU', 'PIE-NU', 'MU+NUE', 'MU-NUE', 'MU+NUE', 'PI+PI0',
     & 'PI++-', 'PI+00',  'M+P0NU', 'E+P0NU', 'MU-NU', 'PI-0', 'PI+--',
     & 'PI-00', 'M-P0NU', 'E-P0NU', 'PPI-',  'NPI0', 'PE-NUE', 'PM-NUE',
     & 'APPI+', 'ANPI0',  'APE+NU', 'APM+NU', 'PI+PI-', 'PI0PI0',
     & 'NPI-',  'PPI0',   'NPI+',   'LAGA',   'GAGA', 'GAE+E-', 'GAGA',
     & 'GAGAP0', 'PI000', 'PI+-0', 'PI+-GA',  'PI+0', 'PI+-',  'PI00',
     & 'PI-0',  'PI+-0',  'PI+-',  'PI0GA',  'K+PI0', 'K0PI+', 'KOPI0',
     & 'K+PI-', 'K-PI0', 'AK0PI-', 'AK0PI0', 'K-PI+', 'K+PI0', 'K0PI+',
     & 'K0PI0', 'K+PI-', 'K-PI0',  'AK0PI-', 'AK0PI0', 'K-PI+', 'K+PI0',
     & 'K0PI+', 'K+89P0', 'K08PI+', 'K+RO77', 'K0RO+7', 'K+OM07',
     & 'K+E055', 'K0PI0', 'K+PI+', 'K089P0', 'K+8PI-', 'K0R077',
     & 'K+R-77'/
      DATA (ZKNAM1(I),I=88,146)/
     & 'K0OM07','K0E055','K-PI0 ','AK0PI-','K-89P0','AK08P-','K-R077',
     & 'AK0R-7','K-OM07','K-E055','AK0PI0','K-PI+ ','AK08P0','K-8PI+',
     & 'AK0R07','K-R+77','AK0OM7','AK0E05','LA0PI+','SI0PI+','SI+PI0',
     & 'LA0PI0','SI+PI-','SI-PI+','LA0PI-','SI0PI-','NEUAK0','PK-   ',
     & 'SI+PI-','SI0PI0','SI-PI+','LA0ET0','S+1PI-','S-1PI+','SO1PI0',
     & 'NEUAK0','PK-   ','LA0PI0','LA0OM0','LA0RO0','SI+RO-','SI-RO+',
     & 'SI0RO0','LA0ET0','SI0ET0','SI+PI-','SI-PI+','SI0PI0',
     & 'K0S   ','K0L   ','K0S   ','K0L   ',
     & 'P PI+ ','P PI0 ','N PI+ ','P PI- ','N PI0 ','N PI- ','P PI+ '/
*                                                                      *
*   Designation N*@ means N*@1(1236)                                   *
*   @1=# means ++,  @1 = = means --                                    *
*   Designation  P+/0/- means Pi+/Pi0/Pi- , respectively               *
*                                                                      *
      DATA (ZKNAM1(I),I=147,251)/
     & 'N*#PI0','N*+PI+','PRHO+ ','P PI0 ','N PI+ ','N*#PI-','N*+PI0',
     & 'N*0PI+','PRHO0 ','NRHO+ ','P PI- ','N PI0 ','N*+PI-','N*0PI0',
     & 'N*-PI+','PRHO- ','NRHO0 ','N PI- ','N*0PI-','N*-PI0','NRHO- ',
     & 'PETA0 ','N*#PI-','N*+PI0','N*0PI+','PRHO0 ','NRHO+ ','NETA0 ',
     & 'N*+PI-','N*0PI0','N*-PI+','PRHO- ','NRHO0 ','P PI0 ','N PI+ ',
     & 'N*#PI-','N*+PI0','N*0PI+','PRHO0 ','NRHO+ ','P PI- ','N PI0 ',
     & 'N*+PI-','N*0PI0','N*-PI+','PRHO- ','NRHO0 ','P PI0 ','N PI+ ',
     & 'PRHO0 ','NRHO+ ','LAMK+ ','S+ K0 ','S0 K+ ','PETA0 ','P PI- ',
     & 'N PI0 ','PRHO- ','NRHO0 ','LAMK0 ','S0 K0 ','S- K+ ','NETA/ ',
     & 'APPI- ','APPI0 ','ANPI- ','APPI+ ','ANPI0 ','ANPI+ ','APPI- ',
     & 'AN*=P0','AN*-P-','APRHO-','APPI0 ','ANPI- ','AN*=P+','AN*-P0',
     & 'AN*0P-','APRHO0','ANRHO-','APPI+ ','ANPI0 ','AN*-P+','AN*0P0',
     & 'AN*+P-','APRHO+','ANRHO0','ANPI+ ','AN*0P+','AN*+P0','ANRHO+',
     & 'APPI0 ','ANPI- ','AN*=P+','AN*-P0','AN*0P-','APRHO0','ANRHO-',
     & 'APPI+','ANPI0  ','AN*-P+','AN*0P0','AN*+P-','APRHO+','ANRHO0'/
      DATA (ZKNAM1(I),I=252,330)/
     & 'PN*014','NN*=14',
     & 'PI+0  ','PI+-','PI-0','P+0','N++','P+-','P00','N+0','N+-','N00',
     & 'P-0   ','N-0   ','P--',
     & 'PPPI0 ','PNPI+ ','PNPI0 ','PPPI- ','NNPI+ ','APPPI0','APNPI+',
     & 'ANNPI0','ANPPI-','APNPI0','APPPI-','ANNPI-','K+PPI0','K+NPI+',
     & 'K0PPI0','K-PPI0','K-NPI+','AKPPI-','AKNPI0','K+NPI0','K+PPI-',
     & 'K0PPI0','K0NPI+','K-NPI0','K-PPI-','AKNPI-',
     & 'PAK0  ','SI+PI0','SI0PI+','SI+ETA','S+1PI0','S01PI+','NEUK- ',
     & 'LA0PI-','SI-OM0','LA0RO-','SI0RO-','SI-RO0','SI-ET0','SI0PI-',
     & 'SI-0', 23*'BLANK'/
      DATA (ZKNAM1(I),I=331,433)/
     & 'EPI+- ','EPI00 ','GAPI+-','GAGA* ','K+-   ','KLKS  ','PI+-0 ',
     & 'EGA   ','LPI0  ','LPI   ','APPI0 ','ANPI- ','ALAGA ','ANPI  ',
     & 'ALPI0 ','ALPI+ ','LAPI+ ','SI+PI0','SI0PI+','LAPI0 ','SI+PI-',
     & 'SI-PI+','LAPI- ','SI-PI0','SI0PI-','TE0PI0','TE-PI+','TE0PI-',
     & 'TE-PI0','TE0PI ','TE-PI ','LAK-  ','ALPI- ','AS-PI0','AS0PI-',
     & 'ALPI0 ','AS+PI-','AS-PI+','ALPI+ ','AS+PI0','AS0PI+','AT0PI0',
     & 'AT+PI-','AT0PI+','AT+PI0','AT0PI ','AT+PI ','ALK+  ',
     & 'K-PI+ ','K-PI+0','K0PI+-','K0PI0 ','K-PI++','AK0PI+','K+PI--',
     & 'K0PI- ','K+PI- ','K+PI-0','AKPI-+','AK0PI0','ETAPIF','K++-  ',
     & 'K+AK0 ','ETAPI-','K--+  ','K-K0  ','PI00  ','PI+-  ','GAGA  ',
     & 'D0PI0 ','D0GA  ','D0PI+ ','D+PI0 ','DFGA  ','AD0PI-','D-PI0 ',
     & 'D-GA  ','AD0PI0','AD0GA ','F+GA  ','F+GA  ','F-GA  ','F-GA  ',
     & 'PSPI+-','PSPI00','PSETA ','E+E-  ','MUE+- ','PI+-0 ','M+NN  ',
     & 'E+NN  ','RHO+NT','PI+ANT','K*+ANT','M-NN  ','E-NN  ','RHO-NT',
     & 'PI-NT ','K*-NT ','NUET  ','ANUET ','NUEM  ','ANUEM '/
      DATA (ZKNAM1(I),I=434,540)/
     & 'SI+ETA','SI+ET*','PAK0  ','TET0K+','SI*+ET','N*+AK0','N*++K-',
     & 'LAMRO+','SI0RO+','SI+RO0','SI+OME','PAK*0 ','N*+AK*','N*++K*',
     & 'SI+AK0','TET0PI','SI+AK*','TET0RO','SI0AK*','SI+K*-','TET0OM',
     & 'TET-RO','SI*0AK','C0+PI+','C0+PI0','C0+PI-','A+GAM ','A0GAM ',
     & 'TET0AK','TET0K*','OM-RO+','OM-PI+','C1++AK','A+PI+ ','C0+AK0',
     & 'A0PI+ ','A+AK0 ','T0PI+ ','ASI-ET','ASI-E*','APK0  ','ATET0K',
     & 'ASI*-E','AN*-K0','AN*--K','ALAMRO','ASI0RO','ASI-RO','ASI-OM',
     & 'APK*0 ','AN*-K*','AN*--K','ASI-K0','ATETPI','ASI-K*','ATETRO',
     & 'ASI0K*','ASI-K*','ATE0OM','ATE+RO','ASI*0K','AC-PI-','AC-PI0',
     & 'AC-PI+','AA-GAM','AA0GAM','ATET0K','ATE0K*','AOM+RO','AOM+PI',
     & 'AC1--K','AA-PI-','AC0-K0','AA0PI-','AA-K0 ','AT0PI-','C1++GA',
     & 'C1++GA','C10GAM','S+GAM ','S0GAM ','T0GAM ','XU++GA','XD+GAM',
     & 'XS+GAM','A+AKPI','T02PI+','C1++2K','AC1--G','AC1-GA','AC10GA',
     & 'AS-GAM','AS0GAM','AT0GAM','AXU--G','AXD-GA','AXS-GA','AA-KPI',
     & 'AT02PI','AC1--K','RH-PI+','RH+PI-','RH3PI0','RH0PI+','RH+PI0',
     & 'RH0PI-','RH-PI0'/
*                                                                      *
*     Weight of decay channel                                          *
*                                                                      *
      DATA (WT1(I),I=1,226)/11*1.D0,.21D0,.12D0,.27D0,.4D0,2*1.D0,.64D0,
     &.21D0,.06D0,.02D0,.03D0,.04D0,.64D0,.21D0,.06D0,.02D0,.03D0,.04D0,
     & .64D0,.36D0,2*0.D0,.64D0,.36D0,2*0.D0, .69D0, .31D0, 1.D0, .52D0,
     & .48D0,1.D0,.99D0,.01D0,.38D0,.03D0,.3D0,.24D0,.05D0,2*1.D0, 0.D0,
     & 1.D0,.9D0,.01D0,.09D0,.33D0,.67D0,.33D0,.67D0,.33D0,.67D0, .33D0,
     &.67D0,.33D0,.67D0,.33D0,.67D0,.33D0,.67D0,.33D0,.67D0,.19D0,.38D0,
     & .09D0,.2D0,.03D0,.04D0,.05D0,.02D0,.19D0,.38D0,.09D0,.2D0, .03D0,
     & .04D0,.05D0,.02D0,.19D0,.38D0,.09D0,.2D0,.03D0,.04D0,.05D0,.02D0,
     & .19D0,.38D0,.09D0,.2D0,.03D0,.04D0, .05D0, .02D0, .88D0, 2*.06D0,
     & .88D0,2*.06D0,.88D0,.12D0,2*.19D0,2*.16D0, .17D0, 3*.03D0, .04D0,
     & 2*.1D0,.2D0,.12D0,.1D0, 2*.04D0, .05D0, 2*.075D0, 2*.03D0, .04D0,
     & 4*.5D0,1.D0,.67D0,2*.33D0,.67D0, 1.D0, .25D0, .27D0, .18D0, .3D0,
     & .17D0,.08D0,.18D0,.03D0,.24D0,.2D0,.1D0,.08D0,.17D0,.24D0, .03D0,
     & .18D0,.1D0,.2D0,.25D0,.18D0,.27D0,.3D0,.4D0,.2D0, .125D0, .075D0,
     & .075D0,.125D0,.4D0,.075D0,.125D0,.2D0,.125D0,.075D0,.18D0, .37D0,
     &.13D0,.08D0,.04D0,.07D0,.13D0,.37D0,.18D0,.04D0,.08D0,.13D0,.13D0,
     & 2*.07D0,.13D0,.23D0,.47D0,.05D0,.02D0,.01D0, .02D0, .13D0, .07D0,
     &.47D0,.23D0,.05D0,.01D0,2*.02D0,1.D0,.67D0,.33D0,.33D0,.67D0,1.D0,
     & .25D0,.27D0,.18D0,.3D0,.17D0,.08D0,.18D0,.03D0,.24D0, .2D0, .1D0/
      DATA (WT1(I),I=227,330) / .08D0, .17D0, .24D0, .03D0, .18D0, .1D0,
     & .2D0, .25D0, .18D0, .27D0, .3D0, .18D0, .37D0, .13D0,.08D0,.04D0,
     & .07D0, .13D0, .37D0, .18D0, .04D0, .08D0, 2*.13D0, .07D0, 2*.5D0,
     & 3*1.D0, .8D0, .2D0, .6D0, .3D0, .1D0, .6D0, .3D0, .1D0,.8D0,.2D0,
     & .33D0, .67D0, .66D0, 2*.17D0, .32D0, .17D0, .32D0, .19D0,2*.33D0,
     & .34D0, .3D0, .05D0, .65D0,.38D0, .12D0, .38D0, .12D0,.38D0,.12D0,
     & .38D0, .12D0, .3D0, .05D0, .65D0, .38D0, 2*.25D0, .02D0, 2*.05D0,
     & 2*.2D0, .12D0, .1D0, 2*.07D0, .14D0, 2*.05D0, 23*1.D0/
      DATA (WT1(I),I=331,433) /.48D0, .24D0, .26D0, .02D0, .47D0, .35D0,
     & .15D0, .03D0, 2*1.D0, .52D0, .48D0, 4*1.D0, .9D0, 2*.05D0, .9D0,
     & 2*.05D0, .9D0, 2*.05D0, .33D0, 2*.67D0, .33D0, 2*.25D0, .5D0,
     & .9D0, 2*.05D0, .9D0, 2*.05D0, .9D0, 2*.05D0, .33D0, 2*.67D0,
     & .33D0, 2*.25D0, .5D0, .1D0, .5D0, .16D0, .24D0, .7D0, .3D0, .7D0,
     & .3D0, .1D0, .5D0, .16D0, .24D0, .3D0, .4D0, 2*.3D0, .4D0, .3D0,
     & .49D0, .49D0, .02D0, .55D0, .45D0, .68D0, .3D0, .02D0, .68D0,
     & .3D0, .02D0, .55D0, .45D0, .9D0, .1D0, .9D0, .1D0, .6D0, .3D0,
     & 3*.1D0, .8D0, 2*.28D0, .35D0, .07D0, .02D0, 2*.28D0, .35D0,
     & .07D0, .02D0, 4*1.D0 /
      DATA (WT1(I),I=434,540) / .02D0, .03D0, .07D0, 2*.02D0, .04D0,
     & .13D0, .07D0, 2*.06D0, .2D0, .14D0, .04D0, .1D0, .25D0, .03D0,
     & .3D0, .42D0, .22D0, .35D0, .19D0, .16D0, .08D0, 5*1.D0, .37D0,
     & .2D0, .36D0, .07D0, 6*.5D0, .02D0, .03D0, .07D0, 2*.02D0, .04D0,
     & .13D0, .07D0, 2*.06D0, .2D0, .14D0, .04D0, .1D0, .25D0, .03D0,
     & .3D0, .42D0, .22D0, .35D0, .19D0, .16D0, .08D0, 5*1.D0, .37D0,
     & .2D0, .36D0, .07D0, 6*.5D0, 9*1.D0, 2*.3D0, .4D0, 9*1.D0, 2*.3D0,
     & .4D0, 2*.33D0, .34D0, 4*.5D0 /
*     Particle numbers in decay channel                                *
*                                                                      *
      DATA (NZK1(I,1),I=1,378) / 1, 2, 3, 4, 5, 6, 7, 1, 2, 4, 3 ,23,
     & 3*13, 10, 11, 10, 3*13, 10, 4, 11, 3*14, 11, 3, 1, 8, 2*1, 2, 9,
     & 2*2, 13, 23, 8, 1, 8, 17, 3*7, 2*23, 4*13, 23, 14, 2*13, 23, 15,
     & 2*24, 15, 16, 2*25, 16, 15, 2*24, 15, 16, 25, 25, 16, 15, 24, 36,
     & 37, 15, 24, 2*15, 24, 15, 37, 36, 24, 15, 2*24, 16, 25, 38, 39,
     & 16, 25, 2*16, 25, 16, 39, 38, 25, 16, 2*25, 17, 22, 21, 17, 21,
     & 20, 17, 22, 8, 1, 21, 22, 20, 17, 48, 50, 49, 8, 1, 3*17, 21, 20,
     & 22, 17, 22, 21, 20, 22, 19, 12, 19, 12, 2*1, 8, 1, 2*8, 1, 53,
     & 54, 2*1, 8, 53, 54, 55, 1, 8, 1, 8, 54, 55, 56, 1, 2*8, 55, 56,
     & 8, 1, 53, 54, 55, 1, 2*8, 54, 55, 56, 1, 8, 1, 8, 53, 54, 55, 1,
     & 8, 1, 8, 54, 55, 56, 1, 8, 1, 8, 1, 8, 17, 21, 22, 2*1, 8, 1, 8,
     & 17, 22, 20, 8, 2*2, 9, 2, 2*9, 2, 67, 68, 2*2, 9, 67, 68, 69, 2,
     & 9, 2, 9, 68, 69, 70, 2, 2*9, 69, 70, 9, 2, 9, 67, 68, 69, 2, 9,2,
     & 9, 68, 69, 70, 2, 9, 1, 8, 2*13, 14, 1, 8, 2*1, 3*8, 1, 8, 5*1,
     & 8, 2*2, 2*9, 2*2, 9, 2*15, 24, 2*16, 2*25, 2*15, 2*24, 2*16, 25,
     & 1, 21, 22, 21, 48, 49, 8, 17, 20, 17, 22, 2*20, 22, 20, 23*0,
     & 2*31, 13, 7, 15, 12, 13, 31, 2*17, 2, 9, 18, 9, 2*18, 17, 21, 22,
     & 17, 21, 20, 17, 20, 22, 97, 98, 97, 98, 97, 98, 17, 18, 99, 100,
     & 18, 101, 99, 18, 101, 100, 102, 103, 102, 103, 102, 103, 18 /
      DATA (NZK1(I,1),I=379,540)/2*16, 2*24, 16, 25, 15, 24, 2*15, 2*25,
     & 31, 2*15, 31, 2*16, 23, 13, 7, 3*116, 2*117, 119, 2*118, 2*119,
     & 2*120, 2*121, 3*130, 4, 10, 13, 10, 4, 32, 13, 36, 11, 3, 34, 14,
     & 38, 133, 134, 135, 136, 2*21, 1, 97, 104, 54, 53, 17, 22, 2*21,
     & 1, 54, 53, 21, 97, 21, 97, 22, 21, 97, 98, 105, 3*137, 138, 139,
     & 2*97, 2*109, 140, 138, 137, 139, 138, 145, 2*99, 2, 102, 110, 68,
     & 67, 18, 100, 2*99, 2, 68, 67, 99, 102, 99, 102, 100, 99, 102,103,
     & 111, 3*149, 150, 151, 2*113, 2*115, 152, 150, 149, 151, 150, 157,
     & 140, 141, 142, 143, 144, 145, 146, 147, 148, 138, 145, 140, 152,
     & 153, 154, 155, 156, 157, 158, 159, 160, 150, 157, 152, 34, 32,
     & 2*33, 32, 33, 34 /
      DATA (NZK1(I,2),I=1,378) /7*0, 3, 4, 6, 5, 23, 14, 11, 3, 3*5, 23,
     & 13, 3*23, 5, 23, 13, 3*23, 14, 23, 3, 11, 13, 23, 4, 10, 14, 23,
     & 14, 23, 13, 2*7, 4, 2*7, 23, 2*14, 23, 14, 2*23, 2*14, 7, 23, 13,
     & 23, 14, 23, 14, 23, 13, 23, 13, 23, 14, 23, 14, 23, 13, 23, 13,
     & 23, 13, 33, 32, 35, 31, 23, 14, 23, 14, 33, 34, 35, 31, 23, 14,
     & 23, 14, 33, 34, 35, 31, 23, 13, 23, 13, 33, 32, 35, 31, 13, 13,
     & 2*23, 14, 13, 2*14, 25, 16, 14, 23, 13, 31, 14, 13, 23, 25, 16,
     & 23, 35, 33, 34, 32, 33, 2*31, 14, 13, 23, 4*0, 13, 23, 13, 14,
     & 23, 14, 13, 23, 13, 78, 23, 13, 14, 23, 13, 79, 78, 14, 23, 14,
     & 23, 13, 80, 79, 2*14, 23, 80, 31, 14, 23, 13, 79, 78, 31, 14, 23,
     & 13, 80, 79, 23, 13, 14, 23, 13, 79, 78, 14, 23, 14, 23, 13, 80,
     & 79, 23, 13, 33, 32, 15, 24, 15, 31, 14, 23, 34, 33, 2*24, 15, 31,
     & 14, 23, 14, 13, 23, 13, 14, 23, 14, 80, 23, 14, 13, 23, 14,79,80,
     & 13, 23, 13, 23, 14, 78, 79, 2*13, 23, 78, 23, 14, 13, 23, 14, 79,
     & 80, 13, 23, 13, 23, 14, 78, 79, 62, 61, 23, 14, 23, 2*13, 13, 23,
     & 2*13, 23, 3*14, 1, 2*8, 1, 8, 1, 2*8, 1, 8, 1, 8, 1, 8, 2*1, 8,1,
     & 2*8, 2*1, 2*8, 1, 8, 25, 23, 13, 31, 23, 13, 16, 14, 35, 2*34,33,
     & 31, 14, 23, 23*0, 13, 23, 14, 7, 16, 19, 14, 7, 23, 14, 23, 14,7,
     & 13, 23, 2*13, 23, 13, 23, 14, 13, 14, 23, 14, 23, 13, 14, 23, 14,
     & 23, 16, 14, 23, 14, 23, 14, 2*13, 23, 13, 23, 14,13,23,13,23,15 /
      DATA (NZK1(I,2),I=379,540) / 3*13, 23, 2*13, 5*14, 23, 13, 16, 25,
     & 14, 15, 24, 23, 14, 7, 23, 7, 13, 23, 7, 14, 23, 7, 23, 5*7, 13,
     & 23, 31, 3, 11, 14, 135, 5, 3*134, 136, 6, 3*133, 4*0, 31, 95, 25,
     & 15, 31, 95, 16, 2*32, 33, 35, 2*39, 38, 25, 13, 39, 32, 39, 38,
     & 35, 32, 39, 13, 23, 14, 2*7, 25, 37, 32, 13, 25, 13, 25, 13, 25,
     & 13, 31, 95, 24, 16, 31, 24,  15, 2*34, 33, 35, 2*37, 36, 24, 14,
     & 37, 34, 37, 36, 35, 34, 37, 14, 23, 13, 2*7, 24, 39, 34, 14, 24,
     & 14, 24, 14, 24, 14, 9*7, 25, 13, 25, 9*7, 24, 14, 24, 13, 14, 23,
     & 13, 23, 14, 23/
      DATA (NZK1(I,3),I=1,378) /7*0, 5, 6, 5, 6, 2*23, 2*5, 4*0, 14, 23,
     & 2*5, 2*0, 14, 23, 2*5, 2*0, 2*5, 2*0, 2*5, 7*0, 3, 0, 7, 2*23, 7,
     & 4*0, 23, 201*0, 23, 13, 14, 2*23, 14, 3*23, 14, 23, 13, 23, 14,
     & 13, 23, 13, 23, 14, 23, 2*14, 23, 2*13, 23, 13, 14, 2*23, 14, 23,
     & 13, 23, 2*14, 38*0, 14, 23, 7, 3*0, 23, 41*0 /
      DATA (NZK1(I,3),I=379,540) / 0, 23, 14, 0, 13, 0, 14, 2*0, 23, 13,
     & 2*0, 15, 2*0, 16, 18*0, 14, 23, 3*0, 23, 2*134, 3*0, 2*133, 92*0,
     & 2*13, 25, 9*0, 2*14, 24, 7*0/
*
      DO 10 J=1,IDMAX9
         ZKNAME(J)=ZKNAM1(J)
         WT(J)=WT1(J)
         DO 20 I=1,3
            NZK(J,I)=NZK1(J,I)
  20     CONTINUE
  10  CONTINUE

*=                                               end.block.blkdt7      *
      END
+PATCH, PAMEND.
*- THIS IS THE LAST LINE OF THE PAM FILE geant321
