+TITLE.
C GEANG.CAR 3.21/05 26/11/99 11.40.28 CVSTOCAR RESTAURATION 
+PATCH, GSCAN.
+DECK,  GSCANI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:36  cernlib
* Geant

      SUBROUTINE GSCANI
*
************************************************************************
*             Generates Kinematics for the SCAN utility                *
*                                                                      *
*          ==>Called by : <USER>,GUKINE                                *
*             Author    R.Brun  *********                              *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCSCAL.
+CDE, GCSCAN.
*
*     -----------------------------------------------------------------
*
      IF(NPHI.LE.0)NPHI=1
      IF(IPHI1.LE.0)IPHI1=1
      IF(IPHI1.GT.NPHI)IPHI1=NPHI
      IF(IPHIL.LT.IPHI1)IPHIL=IPHI1
      IF(IPHIL.GT.NPHI)IPHIL=NPHI
      TETMIN = MAX(TETMID(MODTET), TETMIN)
      TETMAX = MIN(TETMAD(MODTET), TETMAX)
      IF(TETMIN.GT.TETMAX)THEN
         TETMIN = TETMID(MODTET)
         TETMAX = TETMAD(MODTET)
      ENDIF
*             Create top LSCAN bank
*
      IF(LSCAN.NE.0)THEN
         CALL MZDROP(IXCONS,LSCAN,' ')
      ENDIF
      CALL MZFORM('SCAN','10I 10F -H'      ,IOSCAN)
      NL=NPHI
      CALL MZBOOK(IXCONS,LSCAN,LSCAN,1,'SCAN',NL,NL,52,IOSCAN,0)
      IQ(LSCAN+1)=NPHI
      IQ(LSCAN+2)=NTETA
      IQ(LSCAN+3)=MODTET
      IQ(LSCAN+4)=NSLIST
      IQ(LSCAN+5)=NSLMAX
      Q (LSCAN+11)=PHIMIN
      Q (LSCAN+12)=PHIMAX
      Q (LSCAN+13)=TETMIN
      Q (LSCAN+14)=TETMAX
      Q (LSCAN+15)=VSCAN(1)
      Q (LSCAN+16)=VSCAN(2)
      Q (LSCAN+17)=VSCAN(3)
      Q (LSCAN+18)=FACTX0
      Q (LSCAN+19)=FACTL
      Q (LSCAN+20)=FACTR
      DO 10 I=1,NSLIST
         IQ(LSCAN+20+I)=ISLIST(I)
   10 CONTINUE
      END
+DECK,  GSCANK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:36  cernlib
* Geant

      SUBROUTINE GSCANK
*
************************************************************************
*             Generates Kinematics for the SCAN utility                *
*                                                                      *
*          ==>Called by : <USER>,GUKINE                                *
*             Author    R.Brun  *********                              *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCSCAL.
+CDE, GCSCAN.
+CDE, GCFLAG.
+CDE, GCONSP.
*
      DIMENSION VERTEX(3),PLAB(3),BUF(1)
      DATA BUF/0./
*
*     -----------------------------------------------------------------
*
      IF(LSCAN.EQ.0)CALL GSCANI
*
      VERTEX(1)=VSCAN(1)
      VERTEX(2)=VSCAN(2)
      VERTEX(3)=VSCAN(3)
      IKSCAN = 48
      DPHI   = (PHIMAX-PHIMIN)/NPHI
      DTETA  = (TETMAX-TETMIN)/NTETA
      CALL GSVERT(VERTEX,0,0,UBUF,0,NVERT)
*
      DO 20  IPHI=IPHI1,IPHIL
         IF(LQ(LSCAN-IPHI).NE.0)GO TO 20
         PHI=DEGRAD*(PHIMIN+(IPHI-0.5)*DPHI)
         DO 10 ITETA=1,NTETA
            TETA=TETMIN+(ITETA-0.5)*DTETA
            IF(MODTET.EQ.1)THEN
               THETA=2.*ATAN(EXP(-TETA))
            ELSE IF(MODTET.EQ.2) THEN
               THETA=DEGRAD*TETA
            ELSE IF(MODTET.EQ.3) THEN
               THETA=ACOS(TETA)
            ENDIF
            PLAB(1) = SIN(THETA)*COS(PHI)
            PLAB(2) = SIN(THETA)*SIN(PHI)
            PLAB(3) = COS(THETA)
            CALL GSKINE(PLAB,IKSCAN,NVERT,BUF,0,NT)
   10    CONTINUE
         GO TO 30
   20 CONTINUE
*
*              Initialize LSTEMP
*
   30 CONTINUE
      ISCUR=NTETA+1
      IF(LSTEMP.EQ.0)THEN
         CALL MZBOOK(IXCONS,LSTEMP,LSTEMP,1,'LPHI',0,0,30000,1,0)
      ENDIF
*
*              Kinematic debug (controled by ISWIT(1))
*
      IF(IDEBUG.EQ.1.AND.ISWIT(1).EQ.1) THEN
         CALL GPRINT('VERT',0)
         CALL GPRINT('KINE',0)
      ENDIF
*
      END
+DECK,  GSCANO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:36  cernlib
* Geant

      SUBROUTINE GSCANO
*
************************************************************************
*             SCAN utility called at the end of each event.            *
*                                                                      *
*          ==>Called by : <USER>,GUKINE                                *
*             Author    R.Brun  *********                              *
************************************************************************
*                                                                      *
+CDE, GCBANK.
+CDE, GCSCAL.
+CDE, GCSCAN.
C.
C.    ------------------------------------------------------------------
C.
*
*          Insert the temporary LSTEMP structure into LSCAN
*
      IF(IPHI.GT.IQ(LSCAN-2))GO TO 10
      IF(LQ(LSCAN-IPHI).NE.0)GO TO 10
      NPUSH=ISCUR-IQ(LSTEMP-1)-1
      IQ(LSTEMP-5)=IPHI
      CALL MZPUSH(IXCONS,LSTEMP,0,NPUSH,'I')
      CALL ZSHUNT(IXCONS,LSTEMP,LSCAN,-IPHI,0)
      GO TO 999
   10 IF(LSTEMP.NE.0)CALL MZDROP(IXCONS,LSTEMP,' ')
      LSTEMP=0
*
  999 END
+DECK,  GSCANU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:36  cernlib
* Geant

      SUBROUTINE GSCANU
*
************************************************************************
*             SCAN utility called at the end of each tracking step     *
*             INWVOL is different from 0 when the track has reached    *
*                    a volume boundary                                 *
*                                                                      *
*          ==>Called by : <USER>,GUSTEP                                *
*             Author    R.Brun  *********                              *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCSCAL.
+CDE, GCMATE.
+CDE, GCTRAK.
+CDE, GCKINE.
+CDE, GCVOLU.
+CDE, GCSCAN.
      SAVE ISLOLD,IDOLD,IDNUM
*
*     -----------------------------------------------------------------
*
      IF(SLENG.LE.0.)THEN
         SX0=0.
         SABS=0.
         ITETA=ITRA
         ISLOLD=0
         IDOLD=0
      ENDIF
      SX0=SX0+STEP/RADL
      SABS=SABS+STEP/ABSL
      IF(INWVOL.NE.2)THEN
*
*            Compute new ISL,IDET
         ISL=0
         INEW=0
         DO 20 IL=NLEVEL,1,-1
            DO 10 I=1,NSLIST
               IF(NAMES(IL).EQ.ISLIST(I))THEN
                  ISL=I
                  IDNUM=NUMBER(IL)
                  IF(IL.EQ.NLEVEL.OR.IDNUM.NE.IDOLD)INEW=1
                  GO TO 30
               ENDIF
  10        CONTINUE
  20     CONTINUE
  30     CONTINUE
         IF(INWVOL.EQ.3.OR.ISL.NE.ISLOLD.OR.INEW.NE.0)THEN
            CALL GSSCAN(ISLOLD,IDOLD)
            IDOLD=IDNUM
            ISLOLD=ISL
         ENDIF
      ENDIF
*
      CALL GDEBUG
*
      END
+DECK,  GSSCAN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:36  cernlib
* Geant

      SUBROUTINE GSSCAN(ISL,ID)
*
************************************************************************
*             Enter current point in the LSTEMP/LSCAN structure        *
*                                                                      *
*           Layout of the LSCAN data structure                         *
*           ==================================                         *
*                                                                      *
*                          |                                           *
*                          | LSCAN                                     *
*                          |                                           *
*  -nphi      -iphi    -1  V                                           *
* +-----------+---+--------+----------------------------------------   *
* |           | . |        | (1..5)   nphi,nteta,modtet,nslist,free    *
* |           | . |        | (6..10)  phimin,phimax,tetmin,tetmax      *
* |           | . |        | (11..)   islist                           *
* +-----------+---+--------+----------------------------------------   *
*               |                                                      *
*               | LPHI                                                 *
*               |                                                      *
*               V  nteta                                               *
*               +--------------------------------------------------    *
*               |   IDES  |  List of (W1,W2)  |                        *
*               +--------------------------------------------------    *
*                                                                      *
*                                                                      *
*   where  IDES  [ 1:16] = ISCUR pointer in LPHI to first (W1,W2)      *
*                [17:32] = NW Number of pairs (W1,W2) -1               *
*                                                                      *
*           W1   [ 1:17] = IDET                                        *
*                [18:22] = ISL number in ISLIST-1                      *
*                [23:32] = SABS*FACTL                                  *
*                                                                      *
*           W2   [ 1:17] = RIN*FACTR                                   *
*                [18:32] = SX0*FACTX0                                  *
*                                                                      *
*           SX0          = Sum of rad lengths up to current R boundary *
*                                                                      *
*           SABS         = Sum of abs lengths up to current R boundary *
*                                                                      *
*           RIN          = SQRT(X**2+Y**2+Z**2) at current R boundary  *
*                                                                      *
*           FACTX0       = multiplication factor (default=100)         *
*                                                                      *
*           FACTL        = multiplication factor (default=1000)        *
*                                                                      *
*           FACTR        = multiplication factor (default=100)         *
*                                                                      *
*     Bits are numbered from 1 to 32 and the most significative        *
*     bit is bit number 2 (or 1 for unsigned integers)                 *
*                                                                      *
*                                                                      *
*          ==>Called by : <USER>,GUKINE                                *
*             Author    R.Brun  *********                              *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCSCAL.
+CDE, GCFLAG.
+CDE, GCTRAK.
+CDE, GCSCAN.
C.
C.    ------------------------------------------------------------------
C.
      ISX0=FACTX0*SX0
      ISAB=FACTL*SABS
      IRIN=FACTR*SLENG
      IF(IRIN.LE.0)GO TO 999
      IDES=IQ(LSTEMP+ITETA)
      IF(IDES.EQ.0)THEN
         IQ(LSTEMP+ITETA)=ISCUR
         NW=0
      ELSE
         NW=IBITS(IDES,16,16)+1
         IDOLD=IBITS(IQ(LSTEMP+ISCUR-2),0,18)
         IF(IDOLD.EQ.ID)GO TO 999
         CALL MVBITS(NW,0,16,IQ(LSTEMP+ITETA),16)
      ENDIF
      IW1=ID
      CALL MVBITS(ISL,0,5,IW1,17)
      CALL MVBITS(ISAB,0,10,IW1,22)
      IW2=IRIN
      CALL MVBITS(ISX0,0,15,IW2,17)
      IF(ISCUR+5.GT.IQ(LSTEMP-1))THEN
         CALL MZPUSH(IXCONS,LSTEMP,0,1000,'I')
      ENDIF
      IQ(LSTEMP+ISCUR)=IW1
      IQ(LSTEMP+ISCUR+1)=IW2
      ISCUR=ISCUR+2
      IF(IDEBUG.NE.0)THEN
         IF(ISWIT(3).GT.ITETA)THEN
            NAME=IQ(JVOLUM+1)
            IF(ISL.NE.0)NAME=ISLIST(ISL)
            IF(NW.EQ.0)PRINT 10000,IPHI,ITETA
            PRINT 10100,NW+1,NAME,ID,IRIN,ISX0,ISAB
10000       FORMAT(' IPHI =',I3,' ITETA =',I3,
     +             ' NW   NAME      ID      IRIN     ISX0     ISAB')
10100       FORMAT(21X,I3,3X,A4,2X,I6,2X,I8,2X,I7,2X,I7)
         ENDIF
      ENDIF
  999 END
+PATCH, GGEOM.
+DECK,  GBSTAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GBSTAT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Book banks for volume statistics                         *
C.    *                                                                *
C.    *    ==>Called by : GGCLOS                                       *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
C.
C.    ------------------------------------------------------------------
C.
      IF(JGSTAT.GT.0)GO TO 999
      IF(JVOLUM.LE.0)GO TO 999
      CALL MZBOOK(IXCONS,JGSTAT,JGSTAT,1,'GSTA',NVOLUM,NVOLUM,0,2,0)
*
      DO 10 I=1,NVOLUM
         CALL MZBOOK(IXCONS,LBANK,JGSTAT,-I,'GSTA',0,0,9,2,0)
   10 CONTINUE
*
  999 END
+DECK,  GCENT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GCENT(IAX,X0)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       SUBROUTINE TO CENTRE A SLICE OF THE NLEVEL TH            *
C     *       SHAPE, WHEN THE CENTRE OF THE SLICE ALONG AXIS           *
C     *       NUMBER IAX AFTER ROTATION BY MATRIX IROT IS AT           *
C     *       X0(IAX). THE CENTER IN THE UNROTATED FRAME IS            *
C     *       RETURNED.                                                *
C     *                                                                *
C.    *    ==>Called by : GFTRAC, GINVOL, GLVOLU, GMEDIV, GNEXT,       *
C.    *                   GTMEDI, GTNEXT                               *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCUNIT.
      DIMENSION X0(3),PAR(50),ATT(20)
C.
C.    ------------------------------------------------------------------
C.
C
      IVO=LVOLUM(NLEVEL)
      JVO=LQ(JVOLUM-IVO)
      ISH=Q(JVO+2)
C
      IF(ISH.EQ.4) GO TO 20
C
C          NOT A GENERAL TRAPEZOID.
C
      IF(ISH.EQ.10.AND.IAX.NE.1) GO TO 20
C
C         NOT A PARALLELEPIPED WITH NON X AXIS SLICING.
C
      DO 10 I=1,3
      IF(I.NE.IAX) X0(I)=0.0
   10 CONTINUE
C
      GO TO 999
   20 CONTINUE
C
C
      JIN=0
      IF(NLEVEL.LE.1) GO TO 30
C
      IN   = LINDEX(NLEVEL)
      IVOO = LVOLUM(NLEVEL-1)
      JVOO = LQ(JVOLUM-IVOO)
      IF (Q(JVOO+3).LT.0.) THEN
         JIN = LQ(JVOO-1)
      ELSE
         JIN = LQ(JVOO-IN)
      ENDIF
C
   30 CONTINUE
C
C
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPAR = 0
      ELSE
*       (case with structure JVOLUM locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 120
         DO 110 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPAR+1).EQ.0) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
               IF (JPAR.EQ.0) GO TO 120
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               JPAR = JPAR + 5
               NPAR = IQ(JPAR)
               CALL UCOPY (Q(JPAR+1), PAR, NPAR)
            ENDIF
  110    CONTINUE
         GO TO 130
      ENDIF
*      (normal case)
  120 CONTINUE
*
C
      CALL GFIPAR(JVO,JIN,IN,NPAR,NATT,PAR,ATT)
C
  130 CONTINUE
      IF(ISH.EQ.10) GO TO 40
C
C          A GENERAL TRAPEZOID
C
      IF(IAX.NE.3) GO TO 41
C
      X0(1)=PAR(2)*X0(IAX)
      X0(2)=PAR(3)*X0(IAX)
C
      GO TO 999
C
   41 IF(IAX.NE.2) GO TO 900
C
      X0(1) = X0(IAX)*PAR(7)
      GO TO 999
C
   40 CONTINUE
C
C          PARALLELEPIPED WITH NON X AXIS SLICING.
C
      X0(1)=PAR(IAX+2)*X0(IAX)
C
      IF(IAX.EQ.3) GO TO 50
C
      X0(3)=0.0
C
      GO TO 999
   50 CONTINUE
C
      X0(2)=PAR(6)*X0(3)
C
      GO TO 999
C
  900 CONTINUE
C
C          GENERAL TRAPEZOID SLICED OTHER THAN IN Z
C          DOES NOT MAKE SENSE.
C
      WRITE(CHMAIL,1000) ISH,IAX
      CALL GMAIL(0,0)
      WRITE(CHMAIL,2000)
      CALL GMAIL(0,0)
 1000 FORMAT(' ISH,IAX =',2I5,' DOES NOT MAKE SENSE.')
 2000 FORMAT(' IT IS A GENERAL TRAPEZOID SLICED OTHER THAN IN Z')
C
C
  999 CONTINUE
      END
+DECK,  GDTOM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GDTOM(XD,XM,IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Computes coordinates XM (Master Reference System         *
C.    *       knowing the coordinates XD (Detector Ref System)         *
C.    *       The local reference system can be initialized by         *
C.    *         - the tracking routines and GDTOM used in GUSTEP       *
C.    *         - a call to GSCMED(NLEVEL,NAMES,NUMBER)                *
C.    *             (inverse routine is GMTOD)                         *
C.    *                                                                *
C.    *        If IFLAG=1  convert coordinates                         *
C.    *           IFLAG=2  convert direction cosinus                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun ,M Hansroul  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVOLU.
      DIMENSION XD(3),XM(3)
      EQUIVALENCE (N,NLEVEL)
C.
C.    ------------------------------------------------------------------
C.
      IF(IFLAG.EQ.1)THEN
         IF(GRMAT(10,N).NE.0.)THEN
            XM(1) = GTRAN(1,N) + GRMAT(1,N)*XD(1) + GRMAT(4,N)*XD(2) +
     +      GRMAT(7 ,N)*XD(3)
            XM(2) = GTRAN(2,N) + GRMAT(2,N)*XD(1) + GRMAT(5,N)*XD(2) +
     +      GRMAT(8 ,N)*XD(3)
            XM(3) = GTRAN(3,N) + GRMAT(3,N)*XD(1) + GRMAT(6,N)*XD(2) +
     +      GRMAT(9 ,N)*XD(3)
*
         ELSE
            XM(1) = GTRAN(1,N) + XD(1)
            XM(2) = GTRAN(2,N) + XD(2)
            XM(3) = GTRAN(3,N) + XD(3)
*
         ENDIF
*
      ELSE
         IF(GRMAT(10,N).NE.0.)THEN
            XM(1)=GRMAT(1,N)*XD(1)+GRMAT(4,N)*XD(2)+GRMAT(7,N)*XD(3)
            XM(2)=GRMAT(2,N)*XD(1)+GRMAT(5,N)*XD(2)+GRMAT(8,N)*XD(3)
            XM(3)=GRMAT(3,N)*XD(1)+GRMAT(6,N)*XD(2)+GRMAT(9,N)*XD(3)
*
         ELSE
            XM(1) = XD(1)
            XM(2) = XD(2)
            XM(3) = XD(3)
*
         ENDIF
*
      ENDIF
      END
+DECK,  GFATT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFATT(NAME,IAT,IVAL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        Fetch value IVAL of attribute IAT                       *
C.    *        for the volume NAME                                     *
C.    *                                                                *
C.    *    ==>Called by : GDPRTR,GDSPEC,GDTREE,GDTR1                   *
C.    *       Author  R.Brun, P.Zanarini  **********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
      CHARACTER*4 NAME,IAT,KATT(10)
      DIMENSION LATT(10)
      SAVE IFIRST,KATT,LATT
      DATA KATT/'WORK','SEEN','LSTY','LWID','COLO','FILL','SET ',
     +'DET ','DTYP','NODE'/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
C              CHECK IF OPTION EXISTS
C
      IF(NAME.EQ.' ')GO TO 99
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KATT,LATT,4,40)
      ENDIF
C
      CALL GLOOK(IAT,LATT,10,IOP)
      IF(IOP.GT.0)GO TO 10
      WRITE(CHMAIL,2000)IAT
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF VOLUME EXISTS
C
  10  CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVOLU)
      IF(IVOLU.GT.0)GO TO 30
      WRITE(CHMAIL,1000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
  30  JVO=LQ(JVOLUM-IVOLU)
      NPAR=Q(JVO+5)
      IVAL=Q(JVO+NPAR+6+IOP)
      GO TO 99
C
 1000 FORMAT(' GFATT VOLUME ',A4,' DOES NOT EXIST ')
 2000 FORMAT(' GFATT OPTION ',A4,' NOT IMPLEMENTED ')
  99  RETURN
      END
+DECK,  GFCLIM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFCLIM(JVO,IN,IAXIS,CLOW,CHIGH,IERR)
C.
C.    **********************************************************
C.    *                                                        *
C.    *    ROUTINE TO FIND THE COORDINATE LIMITS ALONG AXIS    *
C.    *    IAXIS FOR THE INTH CONTENT OF THE VOLUME POINTED    *
C.    *    TO BY JVO. THE LIMITS ARE RETURNED AS CLOW AND      *
C.    *    CHIGH.IF THEY CANNOT BE FOUND THEN IERR IS SET TO 1.*
C.    *                                                        *
C.    *    ==>Called by : GGORD                                *
C.    *         Author  A.McPherson  *********                 *
C.    *                                                        *
C.    **********************************************************
C.
+CDE, GCBANK.
      DIMENSION PAR(50),ATT(20)
C.
C.         -----------------------------------------
C.
      JIN=LQ(JVO-IN)
      IROT=Q(JIN+4)
      IVOT=Q(JIN+2)
      JVOT=LQ(JVOLUM-IVOT)
      ISH=Q(JVOT+2)
C
      CALL GFIPAR(JVOT,JIN,IN,NPAR,NATT,PAR,ATT)
C
C              X,Y OR Z COORDINATES.
C
      IF(IAXIS.GT.3) GO TO 20
C
      CALL GFLCAR(IAXIS,ISH,IROT,PAR,CL,CH,IERR)
      IF(IERR.NE.0) GO TO 999
C
      CLOW=CL+Q(JIN+IAXIS+4)
      CHIGH=CH+Q(JIN+IAXIS+4)
C
      GO TO 999
C
   20 CONTINUE
      IF(IAXIS.GT.5) GO TO 30
C
C          R COORDINATES.
C
      CALL GFLRAD(IAXIS,ISH,IROT,Q(JIN+5),PAR,CLOW, CHIGH,IERR)

C
      GO TO 999
C
   30 CONTINUE
C
C          PHI OR THETA COORDINATES.
C
      IF(IAXIS.EQ.6) CALL GFLPHI(ISH,IROT,Q(JIN+5), PAR,CLOW,CHIGH,
     +IERR)
C
      IF(IAXIS.EQ.7) CALL GFLTHE(ISH,IROT,Q(JIN+5), PAR,CLOW,CHIGH,
     +IERR)
C
  999 CONTINUE
      END
+DECK,  GFCOOR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFCOOR(X,IAXIS,C)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    ROUTINE TO COMPUTE THE COORDINATE C CORRESPONDING TO THE   *
C.    *    AXIS IAXIS FOR THE POINT X(1-3).                           *
C.    *        IAXIS = 1 IS THE USUAL X AXIS ------>  X(1)            *
C.    *        IAXIS = 2 IS THE USUAL Y AXIS ------>  X(2)            *
C.    *        IAXIS = 3 IS THE USUAL Z AXIS ------>  X(3)            *
C.    *        IAXIS = 4 IS THE X,Y PLANE R VALUE.                    *
C.    *        IAXIS = 5 IS THE FULL X,Y,Z R VALUE.                   *
C.    *        IAXIS = 6 IS AZIMUTH PHI (ANGLE IN X,Y PLANE).         *
C.    *        IAXIS = 7 IS THE POLAR ANGLE THETA (R,Z PLANE).        *
C.    *                                                               *
C.    *    ==>Called by : GFTRAC, GINVOL, GMEDIA, GNEXT, GTMEDI,      *
C.    *                  GTNEXT                                       *
C.    *         Author  A.McPherson  *********                        *
C.    *                                                               *
C.    *****************************************************************
C.
+CDE, GCONSP.
+CDE, GCUNIT.
      DIMENSION X(*)
C.
C.         ----------------------------------------------------
C.
      IF(IAXIS.LE.0.OR.IAXIS.GE.8) THEN
         WRITE(CHMAIL,10000) IAXIS
         CALL GMAIL(0,0)
*
      ELSEIF(IAXIS.LE.3) THEN
         C=X(IAXIS)
*
      ELSEIF(IAXIS.EQ.4) THEN
         C=X(1)*X(1)+X(2)*X(2)
         IF(C.GT.0.0) C=SQRT(C)
*
      ELSEIF(IAXIS.EQ.5) THEN
         C=X(1)*X(1)+X(2)*X(2)+X(3)*X(3)
         IF(C.GT.0.0) C=SQRT(C)
*
      ELSEIF(IAXIS.EQ.6) THEN
         C=0.0
         IF(ABS(X(1)).GE.1.0E-10.AND.ABS(X(2)).GE.1.0E-10) THEN
            C=ATAN2(X(2),X(1))*RADDEG
         ELSEIF(ABS(X(4)).GE.1.0E-10.AND.ABS(X(5)).GE.1.0E-10) THEN
            C=ATAN2(X(5),X(4))*RADDEG
         ENDIF
         IF(C.LT.0.0) C=C+360.0
*
      ELSEIF(IAXIS.EQ.7) THEN
         C=90.0
         IF(ABS(X(3)).LT.1.0E-10) GO TO 999
         R=X(1)*X(1)+X(2)*X(2)
         IF(R.GT.0.0) R=SQRT(R)
         C=ATAN2(R,X(3))*RADDEG
         IF(C.LT.0.0) C=C+180.0
         IF(C.EQ.0.0.AND.X(3).LE.0.0) C=180.0
*
      ENDIF
10000 FORMAT(' ***** GFCOOR: IAXIS =',I5,' NOT SUPPORTED *****')
  999 END
+DECK,  GFCORD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFCORD(NIN,CLOW,CHIGH,CORD,ITYPE,ICON)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    ROUTINE TO ORDER THE VALUES IN CLOW AND CHIGH INTO CORD    *
C.    *    WHILST STORING A 1 IN ITYPE IF THE VALUE IS FROM CLOW      *
C.    *    AND A 2 IF FROM CHIGH. THE SEQUENCE NUMBER OF THE VALUE    *
C.    *    IS STORED IN ICON. THERE ARE NIN VALUES IN EACH OF CLOW    *
C.    *    AND CHIGH.                                                 *
C.    *                                                               *
C.    *    ==>Called by : GGORD                                       *
C.    *         Author  A.McPherson  *********                        *
C.    *                                                               *
C.    *****************************************************************
C.
      DIMENSION CLOW(2),CHIGH(2),CORD(2),ITYPE(2),ICON(2)
C.
C.       -----------------------------------------------------
C.
      IC=0
      DO 60 IN=1,NIN
C
      ITRY=1
      CTRY=CLOW(IN)
C
      IPL=1
      IF(IC.EQ.0) GO TO 50
C
   10 CONTINUE
C
      DO 20 I=1,IC
      IF(CORD(I).LE.CTRY) GO TO 20
      IPL=I
      GO TO 30
   20 CONTINUE
C
      IPL=IC+1
      GO TO 50
C
   30 CONTINUE
      DO 40 I=IPL,IC
C
      IC1=IC+IPL-I
      IC2=IC1+1
      CORD(IC2)=CORD(IC1)
      ICON(IC2)=ICON(IC1)
      ITYPE(IC2)=ITYPE(IC1)
C
   40 CONTINUE
C
   50 CONTINUE
C
      IC=IC+1
      CORD(IPL)=CTRY
      ITYPE(IPL)=ITRY
      ICON(IPL)=IN
C
      IF(ITRY.NE.1) GO TO 60
      ITRY=2
      CTRY=CHIGH(IN)
      GO TO 10
C
   60 CONTINUE
C
      END
+DECK,  GFCVOL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFCVOL
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO RELOAD THE RELEVANT CONTENTS OF THE COMMON       *
C.    *    BLOCK /GCVOLU/ FROM THE COMMON /GCVOL2/                     *
C.    *    THE ROUTINE ASSUMES THAT THE CONTENTS WERE STORED USING     *
C.    *    THE ROUTINE GSCVOL.                                         *
C.    *                                                                *
C.    *    ==>Called by : GDRAW, GDRVOL, GINVOL, GMEDIA, GTMEDI        *
C.    *         Authors : A.McPherson, F.Bruyant                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCVOL2.
C.
C.          ----------------------------------------
C.
      NLEVEL = NLEVE2
      IF (NLEVEL.LE.0) GO TO 99
*
      INFROM = INFRO2
      DO 40 I = 1,NLEVEL
*
         NAMES(I)  = NAMES2(I)
         NUMBER(I) = NUMB2(I)
         LVOLUM(I) = LVOL2(I)
         LINDEX(I) = LIND2(I)
         GONLY(I)  = GONLY2(I)
         NLDEV(I)  = NLDEV2(I)
         LINMX(I)  = LINMX2(I)
*
         DO 10 J = 1,3
            GTRAN(J,I) = GTRAN2(J,I)
   10    CONTINUE
*
         DO 20 J = 1,10
            GRMAT(J,I) = GRMAT2(J,I)
   20    CONTINUE
*
         IQ(JGPAR+I) = IQ(JGPAR2+I)
         LQ(JGPAR-I) = LQ(JGPAR2-I)
*
   40 CONTINUE
*                                                             END GFCVOL
   99 END
+DECK,  GFIPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFIPAR (JVO, JIN, IN, NPAR, NATT, PAR, ATT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routine to fetch internal parameters and attributes for     *
C.    *    the volume from volume address JVO. If it was positioned    *
C.    *    by GSPOSP or declared with negative dimensional parameters, *
C.    *    then JIN and IN must correspond to its positioning inside   *
C.    *    its mother.                                                 *
C.    *                                                                *
C.    *   Called by : GCENT, GFCLIM, GSDVN, GSDVN2, GSDVT, GSDVT2      *
C.    *   Authors   : S.Banerjee, A.McPherson, P.Zanarini              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      PARAMETER  (NLVMAX=15)
      DIMENSION  PAR(*), ATT(*), LVOLS(NLVMAX), LINDX(NLVMAX)
      CHARACTER*4 NAME
      LOGICAL BTEST
C.
C.    ------------------------------------------------------------------
C.
      NPAR = Q(JVO+5)
      NATT = Q(JVO+6)
      JATT = JVO + 6 + NPAR
      IF (.NOT.BTEST(IQ(JVO),1)) THEN
         IF (NPAR.GT.0) THEN
            JPAR = JVO + 6
         ELSE
            IF (JIN.LE.0) GO TO 910
            JPAR = JIN + 9
            NPAR = Q(JPAR)
         ENDIF
      ELSE
         IF (JIN.LE.0) GO TO 910
         JVOM = LQ(JIN+1)
         NIN  = Q(JVOM+3)
         IVO  = Q(JIN+2)
         IF (NIN.GT.0) THEN
            INUM = Q(JIN+3)
         ELSE
            INUM = IN
         ENDIF
         CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
         CALL GLMOTH (NAME, INUM, NLDM, LVOLS, LINDX)
         IF (NLDM.LE.0) GO TO 930
         JPAR = LQ(LQ(JVOLUM-LVOLS(1)))
         IF (NLDM.GT.1) THEN
            DO 10 ILEV = 2, NLDM
               IF (IQ(JPAR+1).EQ.0) THEN
                  JPAR = LQ(JPAR-LINDX(ILEV))
                  IF (JPAR.EQ.0) GO TO 940
               ELSE IF (IQ(JPAR-3).GT.1) THEN
                  JPAR = LQ(JPAR-LINDX(ILEV))
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
   10       CONTINUE
         ENDIF
         IF (NIN.GT.0) THEN
            JPAR = LQ(JPAR-IN)
            IF (JPAR.EQ.0) GO TO 940
         ELSE IF (IQ(JPAR-3).GT.1) THEN
            JPAR = LQ(JPAR-IN)
         ELSE
            JPAR = LQ(JPAR-1)
         ENDIF
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
      ENDIF
*
      IF (NPAR.LE.0) GO TO 950
      CALL UCOPY (Q(JPAR+1), PAR, NPAR)
      CALL UCOPY (Q(JATT+1), ATT, NATT)
*
      GO TO 999
*
  910 CONTINUE
      WRITE (CHMAIL, 1010) JIN
      CALL GMAIL (0, 0)
 1010 FORMAT (' GFIPAR : Error - JIN = ',I8,' LE 0 where Volume ',
     +        'parameters not present in JVO')
      GO TO 999
*
  930 CONTINUE
      WRITE (CHMAIL, 1030)
      CALL GMAIL (0, 0)
 1030 FORMAT (' GFIPAR : Error - NLDM is zero where development ',
     +        'structure is expected')
      GO TO 999
*
  940 CONTINUE
      WRITE (CHMAIL, 1040)
      CALL GMAIL (0, 0)
 1040 FORMAT (' GFIPAR : Error - JPAR is zero where development ',
     +        'structure is expected')
      GO TO 999
*
  950 CONTINUE
      WRITE (CHMAIL,1050) NPAR
      CALL GMAIL (0, 0)
 1050 FORMAT (' GFIPAR : Error - NPAR = ',I8,' LE zero')
  999 CONTINUE
*                                                             END GFIPAR
      END
+DECK,  GFLCAR, T=FORT.
* Revision 1.2  1999/11/04 16:19:49  japost
*  Added protection. In case IROT=0 the address Q(LQ(JROTM-IROT)) should not
*  be calculated because out of bounds.
*                                          Contributed by: fca
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFLCAR(IAXIS,ISH,IROT,PARS,CL,CH,IERR)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    ROUTINE TO FIND THE LIMITS ALONG AXIS IAXIS IN CARTESIAN   *
C.    *    COORDINATES FOR VOLUME OF SHAPE ISH ROTATED BY THE         *
C.    *    ROTATION MATRIX IROT. THE SHAPE HAS NPAR PARAMETERS IN     *
C.    *    THE ARRAY PARS. THE LOWER LIMIT IS RETURNED IN CL, THE     *
C.    *    HIGHER IN CH. IF THE CALCULATION CANNOT BE MADE IERR IS    *
C.    *    SET TO 1 OTHERWISE IT IS SET TO 0.                         *
C.    *                                                               *
C.    *    ==>Called by : GFCLIM                                      *
C.    *         Author  A.McPherson  *********                        *
C.    *                                                               *
C.    *****************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION PARS(11),X(3),XT(3)
C.
C.          ---------------------------------------------------
C.
      IERR=1
      IF (ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C           CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
C
      IERR=0
      CL=0
      CH=0
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      IF(IROT.NE.0) THEN
         JROT=LQ(JROTM-IROT)
         CALL GINROT(X,Q(JROT+1),XT)
      ELSE
         XT(1)=X(1)
         XT(2)=X(2)
         XT(3)=X(3)
      ENDIF
C
C          UPDATE LIMITS IF NECESSARY.
C
      IF(XT(IAXIS).LT.CL) CL=XT(IAXIS)
      IF(XT(IAXIS).GT.CH) CH=XT(IAXIS)
C
   30 CONTINUE
C
      GO TO 999
C
   40 CONTINUE
      IF(ISH.EQ.9) GO TO 90
C
C              TUBES , CONES, POLYGONS, POLYCONES.
C              AND CUT TUBES.
C
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
      IF(IROT.NE.0) THEN
         JROT=LQ(JROTM-IROT)
         CALL GINROT(X,Q(JROT+1),XT)
      ELSE
         XT(1)=X(1)
         XT(2)=X(2)
         XT(3)=X(3)
      ENDIF
C
C          XT IS Z AXIS ROTATED.
C
      IF(ABS(XT(IAXIS)).LT.0.99) GO TO 50
      IF(ISH.EQ.11)GO TO 45
      IF(ISH.EQ.12)GO TO 46
C
C           PARALLEL.
C
      IP=3
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14) IP=1
      CL=-PARS(IP)
      CH=PARS(IP)
      IERR=0
C
      GO TO 999
  45  NZLAST=PARS(4)
      IZLAST=2+3*NZLAST
      CL=PARS(5)
      GO TO 49
C
  46  NZLAST=PARS(3)
      IZLAST=1+3*NZLAST
      CL=PARS(4)
C
  49  CH=PARS(IZLAST)
      IF ( ABS(XT(IAXIS)-X(IAXIS)) .GT.1.) THEN
         TEMP = CL
         CL = -CH
         CH = -TEMP
      ENDIF
      IERR=0
      GO TO 999
C
   50 CONTINUE
**
      IF(ISH.EQ.13) THEN
         CL=-PARS(IAXIS)
         CH=PARS(IAXIS)
         IERR=0
         GOTO 999
      ENDIF
**
      IF(ISH.EQ.14) THEN
C     for hyperboloid, use escribed cylinder
         CH = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
         CL = -CH
         IERR=0
         GOTO 999
      ENDIF
**
      IF(ISH.GT.10.AND.ISH.NE.NSCTUB)GO TO 999
      IF(ABS(XT(IAXIS)).GT.0.01) GO TO 70
C
C         Z AXIS PERPENDICULAR TO IAXIS. ASSUME COMPLETE TUBE OR
C         CONE (I.E. IGNORE PHI SEGMENTATION).
C
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB) GO TO 60
C
      CL=-PARS(2)
      CH=PARS(2)
      IERR=0
C
      GO TO 999
C
   60 CONTINUE
C
      RM=PARS(3)
      IF(PARS(5).GT.PARS(3)) RM=PARS(5)
C
      CL=-RM
      CH=RM
      IERR=0
C
      GO TO 999
C
   70 CONTINUE
C
C           ARBITRARY ROTATION.
C
      DZ=PARS(3)
      RM=PARS(2)
      IF(ISH.EQ.13) THEN
**
**       approxime to a cylinder whit radius
**       equal to the ellipse major axis
**
         IF(PARS(1).GT.RM) RM=PARS(1)
         GOTO 80
      ENDIF
**
      IF(ISH.EQ.14) THEN
        RM = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 80
      ENDIF
*
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RM*S1
      ENDIF
      IF(ISH.LE.6) GO TO 80
C
      DZ=PARS(1)
      RM=PARS(3)
      IF(PARS(5).GT.RM) RM=PARS(5)
C
   80 CONTINUE
C
      COST=ABS(XT(IAXIS))
      SINT=(1+COST)*(1-COST)
      IF(SINT.GT.0.0) SINT=SQRT(SINT)
C
      CH=COST*DZ+SINT*RM
      CL=-CH
      IERR=0
C
      GO TO 999
   90 CONTINUE
C
C           SPHERE - ASSUME COMPLETE SPHERE, TAKE OUTER RADIUS.
C
      IERR=0
      CL=-PARS(2)
      CH=PARS(2)
C
  999 CONTINUE
      END
+DECK,  GFLPHI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFLPHI(ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    **********************************************************
C.    *                                                        *
C.    *    ROUTINE TO FIND THE PHI LIMITS OF THE OBJECT SHAPE  *
C.    *    ISH ROTATED BY MATRIX IROT AND DISPLACED BY VECTOR  *
C.    *    DX. IT HAS NPAR PARAMTERS IN THE ARRAY PARS. THE    *
C.    *    LOWER LIMIT IS RETURNED IN CL AND THE HIGHER IN CH. *
C.    *    NOTE THE OBJECT IS CONTAINED IN THE RANGE OF        *
C.    *    INCREASING PHI FROM CL TO CH THOUGH CL AND CH ARE   *
C.    *    FORCED TO LIE IN THE RANGE 0.0 TO 360.0 SO THAT THE *
C.    *    VALUE OF CL CAN BE HIGHER THAN THAT OF CH.          *
C.    *                                                        *
C.    *    ==>Called by : GFCLIM                               *
C.    *         Author  A.McPherson  *********                 *
C.    *                                                        *
C.    **********************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION DX(3),PARS(11),X(3),XT(3)
C.
C.          -------------------------------------------
C.
      IERR=1
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C
C           CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
      IERR=0
      CL=0.0
      CH=360.0
C
C           IF IN DOUBT SET IT TO FULL RANGE.
C
      IF(DXS.LE.0.0) GO TO 999
C
      PHC=90.
      IF(DX(1).NE.0.)PHC=ATAN2(DX(2),DX(1))*RADDEG
      IF(PHC.LT.0.0) PHC=PHC+360
      PL=0.0
      PH=0.0
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
      XPT=DXS+(DX(1)*XT(1)+DX(2)*XT(2))/DXS
      YPT=(DX(1)*XT(2)-DX(2)*XT(1))/DXS
C
      IF(YPT.EQ.0.0.AND.XPT.EQ.0.0) GO TO 999
      P=ATAN2(YPT,XPT)
      IF(P.GT.PI) P=P-PI*2.0
      IF(P.LT.PL) PL=P
      IF(P.GT.PH) PH=P
C
C
   30 CONTINUE
C
C
      IF(PH-PL.GT.PI) GO TO 999
      CL=PHC+PL*RADDEG
      CH=PHC+PH*RADDEG
C
      SG = SIGN(1.0,CL)
      CL = MOD( ABS(CL),360.0 )
      IF(SG.LE.0.0) CL=360.-CL
      SG=SIGN(1.0,CH)
      CH = MOD( ABS(CH),360.0 )
      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   40 CONTINUE
      IF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14)GO TO 80
C
C             TUBES AND CONES.
C
      IERR=0
      CL=0.0
      CH=360.0
C
C             WHEN IN DOUBT SET TO FULL RANGE.
C
      RM=PARS(2)
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 50
**
      IF(ISH.EQ.13) THEN
**
**       approxime to a cylinder whit radius
**       equal to the ellipse major axis
**
         IF(PARS(1).GT.RM) RM=PARS(1)
         GOTO 50
      ENDIF
      IF(ISH.EQ.14) THEN
        RM = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 50
      ENDIF
      RM=PARS(3)
      IF(PARS(5).GT.RM) RM=PARS(5)
C
   50 CONTINUE
C
      IF(DXS.GT.RM) GO TO 70
      IF(ISH.EQ.5.OR.ISH.EQ.7.OR.ISH.EQ.14) GO TO 999
      IF(ISH.EQ.13) GOTO 999
*                 Here we treat the CONS
      IF(IROT.EQ.0) THEN
*                 This is the simple case, no rotation
*                 Compute the position of the limits on
*                 the X-Y plane.
      PHIMIN=PARS(4)*DEGRAD
      PHIMAX=PARS(5)*DEGRAD
      DDX1 = DX(1)+RM*COS(PHIMIN)
      DDY1 = DX(2)+RM*SIN(PHIMIN)
      DDX2 = DX(1)+RM*COS(PHIMAX)
      DDY2 = DX(2)+RM*SIN(PHIMAX)
      CL = ATAN2(DDY1,DDX1)*RADDEG
      CH = ATAN2(DDY2,DDX2)*RADDEG
      ELSE
*                 Rotated tubes might be more difficult
*                 Just leave it for later
      CONTINUE
      ENDIF
      IF(ISH.LE.6) GO TO 60
      CL=PARS(6)
      CH=PARS(7)
   60 CONTINUE
C
      IF(IROT.EQ.0) GO TO 65
      JROT=LQ(JROTM-IROT)
      IF(Q(JROT+15).NE.0.0.AND.Q(JROT+15).NE.180.0) GO TO 999
C
      PHX=Q(JROT+12)
      PHY=Q(JROT+14)
      IF(PHY.LT.PHX) PHY=PHY+360.0
      ISPH=1
      IF(PHY-PHX.GT.180.0) ISPH=-1
      CL=ISPH*CL+PHX
      CH=ISPH*CH+PHX
      IF(ISPH.EQ.1) GO TO 65
      CHT=CH
      CH=CL
      CL=CHT
C
   65 CONTINUE
C
      SG=SIGN(1.0,CL)
      CL = MOD( ABS(CL),360.0 )
      IF(SG.LE.0.0) CL=360.-CL
      SG=SIGN(1.0,CH)
      CH = MOD( ABS(CH),360.0 )
      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   70 CONTINUE
C
C            DISPLACEMENT GREATER THAN MAXIMUM RADIUS SO
C            ASSUME COMPLETE TUBE TO GENERATE 'WORST CASE'.
C
      DZ=PARS(3)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RM*S1
      ELSEIF(ISH.GT.6.AND.ISH.NE.13.AND.ISH.NE.14) THEN
        DZ=PARS(1)
      ENDIF
C
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
C
C                    LOCAL Z AXIS.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
      COST=ABS(DX(1)*XT(1)+DX(2)*XT(2))
      COS2=ABS(DX(1)*XT(2)-DX(2)*XT(1))
      SINT=(DXS+COST)*(DXS-COST)
      SIN2=(DXS+COS2)*(DXS-COS2)
      IF(SINT.GT.0.0) SINT=SQRT(SINT)
      IF(SIN2.GT.0.0) SIN2=SQRT(SIN2)
C
      XPT=DXS-(COST*DZ+SINT*RM)/DXS
C
      IF(XPT.LE.0.0) GO TO 999
      YPT=(SIN2*RM+COS2*DZ)/DXS
      DP=ATAN(YPT/XPT)
C
      P0=ATAN2(DX(2),DX(1))
      CL=(P0-DP)*RADDEG
      CH=(P0+DP)*RADDEG
C
      SG=SIGN(1.0,CL)
      CL = MOD( ABS(CL),360.0 )
      IF(SG.LE.0.0) CL=360.-CL
      SG=SIGN(1.0,CH)
      CH = MOD( ABS(CH),360.0 )
      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   80 CONTINUE
      IF(ISH.GT.9) GO TO 999
C
C               SPHERE.
C
      IERR=0
      CL=0.0
      CH=360.0
C
      IF(IROT.NE.0.OR.DXS.GT.0.0) GO TO 90
C
C          UNROTATED AND CENTERED.
C
      CL=PARS(5)
      CH=PARS(6)
C
      SG=SIGN(1.0,CL)
      CL = MOD( ABS(CL),360.0 )
      IF(SG.LE.0.0) CL=360.-CL
      SG=SIGN(1.0,CH)
      CH = MOD( ABS(CH),360.0 )
      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   90 CONTINUE
C
C            ROTATED OR NOT CENTERED.
C
      IF(DXS.LT.PARS(2)) GO TO 999
      P0=ATAN2(DX(2),DX(1))
      DP=ASIN(PARS(2)/DXS)
      CL=(P0-DP)*RADDEG
      CH=(P0+DP)*RADDEG
C
      SG=SIGN(1.0,CL)
      CL = MOD( ABS(CL),360.0 )
      IF(SG.LE.0.0) CL=360.-CL
      SG=SIGN(1.0,CH)
      CH = MOD( ABS(CH),360.0 )
      IF(SG.LE.0.0) CH=360.-CH
C
  999 CONTINUE
      END
+DECK,  GFLRAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFLRAD(IAXIS,ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO COMPUTE THE LIMITS IN R FOR THE SHAPE ISH        *
C.    *    DISPLACED BY THE VECTOR DX AND ROTATED BY THE MATRIX IROT.  *
C.    *    IF IAXIS = 4 THE R IS THE XY PLANE R, IF IAXIS = 5 IT IS    *
C.    *    THE 3 DINEMSIONAL SPACE R. THE SHAPE HAS NPAR PARAMETERS    *
C.    *    IN THE ARRAY PARS. THE LOWER LIMIT IS RETURNED IN CL AND    *
C.    *    THE HIGHER IN CH. IF THE CALCULATION CANNOT BE PERFORMED    *
C.    *    IERR IS SET TO 1 OTHERWISE IT IS SET TO 0.                  *
C.    *                                                                *
C.    *    ==>Called by : GFCLIM                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION DX(3),PARS(11),X(3),XT(3)
C.
C.           --------------------------------------------------
C.
      IERR=1
C
C            FIRST CALCULATE THE LENGTH OF THE DISPLACEMENT OF THE
C            ORIGIN.
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(IAXIS.EQ.5) DXS=DXS+DX(3)*DX(3)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C          CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
      CH=0.0
      CL=DXS
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          NOW COMPUTE RMIN = PROJECTED R ON DX AND RMAX = R
C          AND UPDATE LIMITS IF NECESSARY.
C
      R2=(XT(1)+DX(1))**2+(XT(2)+DX(2))**2
      IF(IAXIS.EQ.5) R2=R2+(XT(3)+DX(3))**2
      R=SQRT(R2)
      IF(R.GT.CH) CH=R
C
      IF(CL.LE.0.0) GO TO 30
C
      XPT=DX(1)*XT(1)+DX(2)*XT(2)
      IF(IAXIS.EQ.5) XPT=XPT+DX(3)*XT(3)
      IF(DXS.LE.1.0E-05) GO TO 30
      RMN=DXS+XPT/DXS
      IF(RMN.LT.CL) CL=RMN
C
   30 CONTINUE
C
      IF(CL.LE.0.0) CL=0.0
C
      IERR=0
      GO TO 999
C
   40 CONTINUE
      IF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14)GO TO 80
C
C             TUBES AND CONES.
C
      IP3=3
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14) IP3=1
      DZ=PARS(IP3)
      R=PARS(2)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+R*S1
      ENDIF
**
      IF(ISH.EQ.13) THEN
**
**       APPROXIME TO A CYLINDER WHIT RADIUS
**       EQUAL TO THE ELLIPSE MAJOR AXIS
**
         RMN=0.0
         IF(PARS(1).GT.R) R=PARS(1)
         GOTO 50
      ENDIF
      RMN=PARS(1)
*
      IF(ISH.EQ.14) THEN
        R = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 50
      ENDIF
C
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 50
C
      R=PARS(3)
      IF(PARS(5).GT.R) R=PARS(5)
      RMN=PARS(2)
      IF(PARS(4).LT.RMN) RMN=PARS(4)
C
   50 CONTINUE
C
C          ROTATE THE LOCAL Z AXIS.
C
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          COMPUTE RMIN AND RMAX ASSUMING COMPLETE TUBE HALF
C          LENGTH DZ AND RADIUS R.
C
      ST2=1.0
      IF(IAXIS.EQ.4) ST2=(1+XT(3))*(1-XT(3))
      DR=SQRT(DZ*DZ*ST2+R*R)
      CL=DXS-DR
      IF(CL.LT.0.0) CL=0.0
      CH=DXS+DR
      IF(IROT.EQ.0.AND.DXS.LT.1.0E-05) CL=RMN
      IERR=0
C
      GO TO 999
C
   80 CONTINUE
      IF(ISH.GT.9) GO TO 999
C
C           SPHERE.
C
      CL=DXS-PARS(2)
      IF(CL.LT.0.0) CL=0.0
      CH=DXS+PARS(2)
      IF(IAXIS.EQ.5.AND.DXS.LT.1.0E-05) CL=PARS(1)
      IERR=0
C
  999 CONTINUE
      END
+DECK,  GFLTHE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:48  cernlib
* Geant

      SUBROUTINE GFLTHE(ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO COMPUTE THE THETA LIMITS FOR VOLUME OF SHAPE     *
C.    *    ISH ROTATED BY MATRIX IROT AND DISPLACED BY VECTOR DX.      *
C.    *    THE VOLUME HAS NPAR PARAMETERS IN THE ARRAY PARS. THE LOWER *
C.    *    LIMIT IS RETURNED IN CL THE HIGHER IN CH. IF THE            *
C.    *    CALCULATION CANNOT BE MADE IERR IS SET TO 1 OTHERWISE IT    *
C.    *    IS SET TO 0.                                                *
C.    *                                                                *
C.    *    ==>Called by : GFCLIM                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION DX(3),PARS(11),X(3),XT(3),X1(3),X2(3),XT1(3),XT2(3)
C.
C.          ----------------------------------------------
C.
      IERR=1
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 130
C
C            CUBES, TRAPEZOIDS AND PARALLELEPIPEDS.
C
      IERR=0
      CL=0.0
      CH=180.0
C
      IF(DXS.LE.0.0) GO TO 999
C
      TH=90.
      IF(ABS(DX(3)).LT.1.0E-06)GO TO 5
      TH=ATAN(DXS/DX(3))*RADDEG
      IF(TH.LT.0.0) TH=TH+180.0
   5  TL=TH
C
      DO 50 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
      Z=DX(3)+XT(3)
      R=(DX(1)+XT(1))**2+(DX(2)+XT(2))**2
      RT=R+(DX(3)+XT(3))**2
      IF(RT.LT.1.0E-10) GO TO 999
C
      IF(R.GT.0.0) GO TO 30
      IF(Z.GT.0.0) T=0.0
      IF(Z.LT.0.0) T=180.0
      GO TO 40
C
   30 CONTINUE
      T=90.0
      IF(ABS(Z).LT.1.0E-6) GO TO 40
C
      R=SQRT(R)
      T=ATAN(R/Z)*RADDEG
      IF(T.EQ.0.0.AND.Z.LT.0.0) T=180.0
      IF(T.LT.0.0) T=T+180.0
C
   40 CONTINUE
      IF(T.GT.TH) TH=T
      IF(T.LT.TL) TL=T
C
   50 CONTINUE
C
C           THETA LIMITS SET FROM THE POINTS NOW DO THE EDGES.
C
      DO 120 IL=1,12
C
C           FIND THE END POINT NUMBERS FOR EACH EDGE.
C
      IF(IL.GT.4) GO TO 60
      IPP1=1
      IF(IL.GT.2) IPP1=4
      IPP2=2
      IF(MOD(IL,2).EQ.1) IPP2=3
C
      GO TO 80
   60 CONTINUE
      IF(IL.LT.9) GO TO 70
C
      IPP1=5
      IF(IL.GT.10) IPP1=8
      IPP2=6
      IF(MOD(IL,2).EQ.1) IPP2=7
C
      GO TO 80
   70 CONTINUE
C
      IPP1=IL-4
      IPP2=IL
C
   80 CONTINUE
C
C           NOW GET THE POINTS AND ROTATE THEM.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         ILL=IPP1
         IF(IPP1.EQ.3) ILL=4
         IF(IPP1.EQ.4) ILL=3
         I0=ILL*4+11
         X1(3)=PARS(1)
         IF(IPP1.LT.5) X1(3)=-X1(3)
         X1(1)=PARS(I0)+PARS(I0+2)*X1(3)
         X1(2)=PARS(I0+1)+PARS(I0+3)*X1(3)
         ILL=IPP2
         IF(IPP2.EQ.3) ILL=4
         IF(IPP2.EQ.4) ILL=3
         I0=ILL*4+11
         X2(3)=PARS(1)
         IF(IPP2.LT.5) X2(3)=-X2(3)
         X2(1)=PARS(I0)+PARS(I0+2)*X2(3)
         X2(2)=PARS(I0+1)+PARS(I0+3)*X2(3)
C
         GO TO 100
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X1(3)=PARS(IP3)
      IF(IPP1.LE.4) X1(3)=-X1(3)
      IP2=3
      IF(ISH.GT.2.AND.X1(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X1(3).GT.0.0) IP2=8
      X1(2)=PARS(IP2)
      IF(MOD(IPP1+3,4).LT.2) X1(2)=-X1(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X1(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X1(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X1(2).GT.0.0) IP1=IP1+1
      X1(1)=PARS(IP1)
      IF(MOD(IPP1,2).EQ.1) X1(1)=-X1(1)
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X2(3)=PARS(IP3)
      IF(IPP2.LE.4) X2(3)=-X2(3)
      IP2=3
      IF(ISH.GT.2.AND.X2(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X2(3).GT.0.0) IP2=8
      X2(2)=PARS(IP2)
      IF(MOD(IPP2+3,4).LT.2) X2(2)=-X2(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X2(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X2(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X2(2).GT.0.0) IP1=IP1+1
      X2(1)=PARS(IP1)
      IF(MOD(IPP2,2).EQ.1) X2(1)=-X2(1)
C
      IF(ISH.NE.10) GO TO 90
      X1(1)=X1(1)+X1(2)*PARS(4)+X1(3)*PARS(5)
      X1(2)=X1(2)+X1(3)*PARS(6)
      X2(1)=X2(1)+X2(2)*PARS(4)+X2(3)*PARS(5)
      X2(2)=X2(2)+X2(3)*PARS(6)
   90 CONTINUE
C
      IF(ISH.NE.4) GO TO 100
      IP4=7
      IF(X1(3).GT.0.0) IP4=11
      X1(1)=X1(1)+X1(2)*PARS(IP4)+X1(3)*PARS(2)
      X1(2)=X1(2)+X1(3)*PARS(3)
      IP4=7
      IF(X2(3).GT.0.0) IP4=11
      X2(1)=X2(1)+X2(2)*PARS(IP4)+X2(3)*PARS(2)
      X2(2)=X2(2)+X2(3)*PARS(3)
  100 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT1(1)=X1(1)
      XT1(2)=X1(2)
      XT1(3)=X1(3)
      IF(IROT.NE.0) CALL GINROT(X1,Q(JROT+1),XT1)
      XT2(1)=X2(1)
      XT2(2)=X2(2)
      XT2(3)=X2(3)
      IF(IROT.NE.0) CALL GINROT(X2,Q(JROT+1),XT2)
C
C           NOW WE HAVE THE END POINTS IN THE MASTER SYSTEM.
C           FIND THE TANGENT POINT TO THE SET OF CONES OF CONSTANT
C           THETA.
C
      DS=(XT2(1)-XT1(1))**2+(XT2(2)-XT1(2))**2+(XT2(3)-XT1(3))**2
      IF(DS.LE.0.0) GO TO 120
C
      DS=SQRT(DS)
C
      X0=(XT2(1)+XT1(1))/2.0+DX(1)
      Y0=(XT2(2)+XT1(2))/2.0+DX(2)
      Z0=(XT2(3)+XT1(3))/2.0+DX(3)
      ALX=(XT2(1)-XT1(1))/DS
      ALY=(XT2(2)-XT1(2))/DS
      ALZ=(XT2(3)-XT1(3))/DS
C
      T=90.0
      IF(Z0.EQ.0.0.AND.ALZ.EQ.0.0) GO TO 110
C
      IF(ALX.EQ.0.0.AND.ALY.EQ.0.0) GO TO 120
C             THIS CHECKS WHETHER THE LINE IS PARALLEL TO THE
C             Z AXIS IN WHICH CASE THERE IS NO TANGENT AND
C             THE END POINTS DETERMINE THE THETA RANGE.
C
      SNUM=(X0*Z0*ALX+Y0*Z0*ALY+X0*X0*ALZ+Y0*Y0*ALZ)
      SDEN=(Z0*ALX*ALX-X0*ALX*ALZ+Z0*ALY*ALY-Y0*ALY*ALZ)
C
      IF(ABS(SNUM).GT.0.5*DS*ABS(SDEN)) GO TO 120
C
C           TANGENT EXIST BETWEEN THE TWO ENDS.
C
      S = SNUM/SDEN
      X0=X0+S*ALX
      Y0=Y0+S*ALY
      Z0=Z0+S*ALZ
C
      R=X0*X0+Y0*Y0
      RT=R+Z0*Z0
C
      IF(RT.LT.1.0E-10) GO TO 999
C
      IF(R.GT.0.0) R=SQRT(R)
      T=90.0
      IF(ABS(Z0).LT.1.0E-06) GO TO 110
C
      T=ATAN(R/Z0)*RADDEG
      IF(T.EQ.0.0.AND.Z0.LT.0.0) T=180.0
      IF(T.LT.0.0) T=T+180.0
C
  110 CONTINUE
C
      IF(T.LT.TL) TL=T
      IF(T.GT.TH) TH=T
C
C        CHECK FOR THE POSSIBILITY OF STRADDLING T=0.0 &/OR 180.0.
C
      C=X0*DX(1)+Y0*DX(2)
      IF(C.GT.0.0) GO TO 120
C
C          CHECK IF SAME SIGN OF Z.
C
      IF(Z0*DX(3).LT.0.0) GO TO 999
C
      T=0.0
      IF(Z0.LT.0.0) T=180.0
      IF(T.LT.TL) TL=T
      IF(T.GT.TH) TH=T
C
  120 CONTINUE
C
C            DONE SET THE LIMITS.
C
      CL=TL
      CH=TH
C
      GO TO 999
C
  130 CONTINUE
C
C          TUBES, CONES ETC.
C
      IF(IROT.NE.0.OR.DXS.GT.1.0E-05) GO TO 180
C
C          UNROTATED AND CENTERED.
C
      IF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13
     +           .AND.ISH.NE.14)GO TO 170
C
C               TUBES AND CONES.
C
      IERR=0
      DZ=PARS(3)
      RMN=PARS(1)
      RMX=PARS(2)
      IF(ISH.EQ.13) THEN
**
**         approxime to a cylinder whit radius
**         equal to the ellipse major axis
**
        RMN=0.0
        IF(PARS(1).GT.RMX) RMX=PARS(1)
        GOTO 140
      ENDIF
      IF(ISH.EQ.14) THEN
C   not really sure of the function of these... keep RMN=PARS(1)
        RMX = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 140
      ENDIF
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RMX*S1
      ENDIF
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 140
      DZ=PARS(1)
      RMN=PARS(2)
      RMX=PARS(3)
      IF(PARS(4).LT.RMN) RMN=PARS(4)
      IF(PARS(5).GT.RMX) RMX=PARS(5)
  140 CONTINUE
C
      IF(DZ.GT.ABS(DX(3))) GO TO 160
C
C          ALL FORWARD OR ALL BACK.
C
      DSH=DX(3)-DZ
      DLN=DX(3)+DZ
      IF(DX(3).GT.0.0) GO TO 150
      DSS=DSH
      DSH=DLN
      DLN=DSS
  150 CONTINUE
C
      CL=90.0
      CH=90.0
      IF(DLN.NE.0.0) CL=ATAN(RMN/DLN)*RADDEG
      IF(DSH.NE.0.0) CH=ATAN(RMX/DSH)*RADDEG
      IF(DX(3).GT.0.0) GO TO 999
      CS=CL
      CL=CH
      CH=CS
      IF(CH.EQ.0.0) CH=180.0
      IF(CL.LT.0.0) CL=CL+180.0
      IF(CH.LT.0.0) CH=CH+180.0
C
      GO TO 999
C
  160 CONTINUE
C
      CL=90.0
      CH=90.0
      IF(DZ+DX(3).NE.0.0) CL=ATAN(RMN/(DZ+DX(3)))*RADDEG
      IF(-DZ+DX(3).NE.0.0) CH=ATAN(RMN/(-DZ+DX(3)))*RADDEG
      IF(CH.LE.0.0) CH=CH+180.0
C
      GO TO 999
C
  170 CONTINUE
      IF(ISH.GT.9) GO TO 999
C
C           SPHERE.
C
      IERR=0
      CL=PARS(3)
      CH=PARS(4)
C
      GO TO 999
  180 CONTINUE
C
      IF(ISH.EQ.11.OR.ISH.EQ.12) GOTO 999
**
      RM=PARS(2)
      IF(ISH.EQ.9) GO TO 200
C
      DZ=PARS(3)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RM*S1
      ENDIF
**
      IF(ISH.EQ.13) THEN
        IF(PARS(1).GT.RM) RM=PARS(1)
        GOTO 190
      ENDIF
**
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 190
C
      DZ=PARS(1)
      RM=PARS(3)
      IF(PARS(5).GT.RM) RM=PARS(5)
C
  190 CONTINUE
C
      RM=SQRT(RM**2+DZ**2)
C
  200 CONTINUE
C
      CL=0.0
      CH=180.0
      IERR=0
      RC=DXS**2+DX(3)**2
      IF(RC.GT.0.0) RC=SQRT(RC)
      IF(RM.GE.RC) GO TO 999
C
      TC=90.0
      IF(ABS(DX(3)).GT.0.0) TC=ATAN(DXS/DX(3))*RADDEG
      IF(TC.LT.0.0) TC=TC+180.0
C
      DT=ASIN(RM/RC)*RADDEG
      CL=TC-DT
      CH=TC+DT
      IF(CL.LT.0.0) CL=0.0
      IF(CH.GT.180.0) CH=180.0
C
  999 CONTINUE
      END
+DECK,  GFMOTH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GFMOTH(NAME,MOTHER,KONLY)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Fetch MOTHER and ONLY-flag of volume NAME                *
C.    *                                                                *
C.    *    ==>Called by : no more used                                 *
C.    *         Author  P.Zanarini  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
      COMMON/FMOTH/INGLOB,IVOMGL
      CHARACTER*4 NAME,MOTHER
C.
C.    ------------------------------------------------------------------
C.
      MOTHER=' '
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVOSON)
      IF(IVOSON.LE.0)GO TO 999
      DO 20 IVOMOT=1,NVOLUM
        IVOMGL=IVOMOT
        JVO=LQ(JVOLUM-IVOMOT)
        NIN=Q(JVO+3)
        MNIN=NIN
        IF (NIN.LT.0) MNIN=1
        DO 10 IN=1,MNIN
          INGLOB=IN
          JIN = LQ(JVO-IN)
          IVO=Q(JIN+2)
          IF (IVO.EQ.IVOSON) GO TO 30
   10   CONTINUE
   20 CONTINUE
   30 CALL UHTOC(IQ(JVOLUM+IVOMOT),4,MOTHER,4)
      KONLY=1
      IF (NIN.GT.0) KONLY=Q(JIN+8)
 999  RETURN
      END
+DECK,  GFPARA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GFPARA (NAME, NUMBER, INTEXT, NPAR, NATT, PAR, ATT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Fetch parameters and attributes                             *
C.    *    of the volume NAME-NUMBER.                                  *
C.    *    INTEXT is used to select internal (INTEXT=1)                *
C.    *    or user parameters to be fetched.                           *
C.    *                                                                *
C.    *   Called by : GDPRTR, GDRAW, GDSPEC, GPVOLU                    *
C.    *   Authors   : S.Banerjee, A.McPherson, P.Zanarini              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCONSP.
      CHARACTER*4 NAME
      PARAMETER  (NLVMAX=15)
      DIMENSION  PAR(*), ATT(*), LVOLS(NLVMAX), LINDX(NLVMAX)
      LOGICAL BTEST
C.
C.    ------------------------------------------------------------------
C.
      CALL GLOOK (NAME, IQ(JVOLUM+1), NVOLUM, IVO)
      IF (IVO.LE.0) GO TO 991
      JVO  = LQ(JVOLUM-IVO)
      ISH  = Q(JVO+2)
      NPAR = Q(JVO+5)
      NATT = Q(JVO+6)
      JATT = JVO + 6 + NPAR
*
* *** Find a suitable way to access the volume parameters
*
      IF (INTEXT.NE.1.OR..NOT.BTEST(IQ(JVO),1)) THEN
         IF (NPAR.GT.0) THEN
*
*  **       From the JVO structure
*
            JPAR = JVO + 6
         ELSE
*
*  **       From positioning of the volume in the mother
*
            DO 15 IVOM = 1, NVOLUM
               IF (IVO.EQ.IVOM) GO TO 15
               JVOM = LQ(JVOLUM-IVOM)
               NINM = Q(JVOM+3)
               IF (NINM.LE.0)   GO TO 15
               DO 10 IN = 1, NINM
                  JINM = LQ(JVOM-IN)
                  IVOT = Q(JINM+2)
                  IF (IVOT.NE.IVO) GO TO 10
                  NUMR = Q(JINM+3)
                  IF (NUMR.EQ.NUMBER) GO TO 20
   10          CONTINUE
   15       CONTINUE
            GO TO 991
   20       JPAR = JINM + 9
            NPAR = Q(JPAR)
         ENDIF
*
      ELSE
*
*  **    From development structure
*
         CALL GLMOTH (NAME, NUMBER, NLDM, LVOLS, LINDX)
         IF (NLDM.LE.0) GO TO 991
         JVOM = LQ(JVOLUM-LVOLS(NLDM))
         NINM = Q(JVOM+3)
         IF (NINM.LT.0) THEN
            IN   = NUMBER
         ELSE
            DO 25 IN = 1, NINM
               JINM = LQ(JVOM-IN)
               IF (IFIX(Q(JINM+2)).NE.IVO)    GO TO 25
               IF (IFIX(Q(JINM+3)).EQ.NUMBER) GO TO 30
   25       CONTINUE
            GO TO 991
         ENDIF
   30    JPAR = LQ(LQ(JVOLUM-LVOLS(1)))
         IF (NLDM.GT.1) THEN
            DO 35 ILEV = 2, NLDM
               IF (IQ(JPAR+1).EQ.0) THEN
                  JPAR = LQ(JPAR-LINDX(ILEV))
                  IF (JPAR.EQ.0) GO TO 991
               ELSE IF (IQ(JPAR-3).GT.1) THEN
                  JPAR = LQ(JPAR-LINDX(ILEV))
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
   35       CONTINUE
         ENDIF
         IF (NINM.GT.0) THEN
            JPAR = LQ(JPAR-IN)
            IF (JPAR.EQ.0) GO TO 991
         ELSE
            IF (IN.GT.IQ(JPAR+1)) GO TO 991
            IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-IN)
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
         ENDIF
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
      ENDIF
*
      IF (NPAR.LE.0) GO TO 999
      CALL UCOPY (Q(JPAR+1), PAR, NPAR)
      CALL UCOPY (Q(JATT+1), ATT, NATT)
*
      IF (INTEXT.EQ.1) GO TO 999
      IF (ISH.EQ.28) THEN
*
*  **    NPAR : 30 ---> 12
*
         NPAR = 12
*
      ELSE IF (ISH.EQ.4) THEN
*
*  **    TRAP
*
         NPAR=11
         PH = 0.
         IF (PAR(2).NE.0.) PH = ATAN2(PAR(3),PAR(2))*RADDEG
         TT = SQRT(PAR(2)**2+PAR(3)**2)
         PAR(2) = ATAN(TT)*RADDEG
         IF (PH.LT.0.0) PH = PH+360.0
         PAR(3) = PH
         PAR(7) = ATAN(PAR(7))*RADDEG
         IF (PAR(7).GT.90.0) PAR(7) = PAR(7)-180.0
         PAR(11)= ATAN(PAR(11))*RADDEG
         IF (PAR(11).GT.90.0) PAR(11) = PAR(11)-180.0
*
      ELSE IF (ISH.EQ.10) THEN
*
*  **    PARA
*
         PH = 0.
         IF (PAR(5).NE.0.) PH = ATAN2(PAR(6),PAR(5))*RADDEG
         TT = SQRT(PAR(5)**2+PAR(6)**2)
         PAR(4) = ATAN(PAR(4))*RADDEG
         IF (PAR(4).GT.90.0) PAR(4) = PAR(4)-180.0
         PAR(5) = ATAN(TT)*RADDEG
         IF (PH.LT.0.0) PH = PH+360.0
         PAR(6) = PH
      ENDIF
      GO TO 999
*
  991 NPAR = 0
  999 RETURN
*                                                             END GFPARA
      END
+DECK,  GFSTAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GFSTAT(ICASE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FILL banks for volume statistics                         *
C.    *                                                                *
C.    *    ==>Called by : GINVOL, GMEDIA, GTNEXT, GTMEDI, GTRACK       *
C.    *                                                                *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
C.
C.    ------------------------------------------------------------------
C.
      IF(JGSTAT.LE.0)GO TO 999
      IF(NLEVEL.LE.0)GO TO 999
C
      IF(ICASE.LE.1) THEN
C
C                 GINVOL   ICASE=0,1
C
         IVO=LVOLUM(NLEVEL)
         JG=LQ(JGSTAT-IVO)
         IF(JG.GT.0) THEN
            IQ(JG+1+ICASE)=IQ(JG+1+ICASE)+1
         ENDIF
      ELSEIF(ICASE.LE.10) THEN
C
C         GMEDIA  (ICASE=2), GTNEXT (ICASE=3) or GTMEDI (ICASE=4)
C
         IC = ICASE*2-1
         DO 10 ILEV=1,NLEVEL
            IVO=LVOLUM(ILEV)
            JG=LQ(JGSTAT-IVO)
            IF(JG.GT.0) THEN
               IQ(JG+IC)=IQ(JG+IC)+1
               IF(ILEV.EQ.NLEVEL) THEN
                  IQ(JG+IC+1)=IQ(JG+IC+1)+1
               ENDIF
            ENDIF
   10    CONTINUE
C
C               ICASE=10+ITRTYP  (steps)
C
      ELSE
         IVO=LVOLUM(NLEVEL)
         JG=LQ(JGSTAT-IVO)
         IF(JG.GT.0) THEN
            IQ(JG+9)=IQ(JG+9)+1
         ENDIF
      ENDIF
C
  999 END
+DECK,  GFUPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GFUPAR(JVO,JIN,NPAR,NATT,PAR,ATT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO FETCH USER PARAMETERS AND ATTRIBUTES FOR         *
C.    *    THE VOLUME FROM VOLUME ADDRESS JVO AND IF GSPOSP TYPE       *
C.    *    VERSION DEFINED BY IN ADDRESS JIN.                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *         Author  P.Zanarini  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCONSP.
      DIMENSION PAR(*),ATT(*)
C.
C.               ---------------------------------------
C.
      NPAR=Q(JVO+5)
      NATT=Q(JVO+6)
      ISH=Q(JVO+2)
      JPAR=JVO+7
      JATT=JVO+7+NPAR
C
      IF(NPAR.GT.0) GO TO 10
      IF(NPAR.NE.0) GO TO 900
      IF(JIN.LE.0) GO TO 910
C
      JPAR=JIN+9
      NPAR=Q(JPAR)
      JPAR=JPAR+1
C
   10 CONTINUE
C
C             NPAR : 30 ---> 12
C
      IF(ISH.EQ.28) NPAR=12
C
      IF(NPAR.LE.0) GO TO 920
      CALL UCOPY(Q(JPAR),PAR,NPAR)
      CALL UCOPY(Q(JATT),ATT,NATT)
C
      IF(ISH.NE.4) GO TO 20
C
C              TRAPEZOID
C
      PH=90.0
      IF(PAR(2).NE.0.)PH=ATAN2(PAR(3),PAR(2))*RADDEG
      TT=PAR(2)**2+PAR(3)**2
      IF(TT.GT.0.0) TT=SQRT(TT)
      PAR(2)=ATAN(TT)*RADDEG
      IF(PH.LT.0.0) PH=PH+360.0
      PAR(3)=PH
      PAR(7)=ATAN(PAR(7))*RADDEG
      IF(PAR(7).GT.90.0) PAR(7)=PAR(7)-180.0
      PAR(11)=ATAN(PAR(11))*RADDEG
      IF(PAR(11).GT.90.0) PAR(11)=PAR(11)-180.0
C
      GO TO 99
   20 CONTINUE
C
      IF(ISH.NE.10) GO TO 99
C
C              PARALLELEPIPED.
C
      PH=90.0
      IF(PAR(5).NE.0.)PH=ATAN2(PAR(6),PAR(5))*RADDEG
      TT=PAR(5)**2+PAR(6)**2
      IF(TT.GT.0.0) TT=SQRT(TT)
      PAR(4)=ATAN(PAR(4))*RADDEG
      IF(PAR(4).GT.90.0) PAR(4)=PAR(4)-180.0
      PAR(5)=ATAN(TT)*RADDEG
      IF(PH.LT.0.0) PH=PH+360.0
      PAR(6)=PH
C
      GO TO 99
C
  900 CONTINUE
C
      WRITE(CHMAIL,1000) NPAR
      CALL GMAIL(0,0)
 1000 FORMAT(' **** ERROR IN GFUPAR - NPAR FROM JVO =',I5,' LE 0 ****')
C
      GO TO 99
  910 CONTINUE
C
      WRITE(CHMAIL,1010) JIN
      CALL GMAIL(0,0)
 1010 FORMAT(' **** ERROR IN GFUPAR - NPAR FROM VOL 0 AND JIN ='
     +,I12,' IS LE 0 ****')
C
      GO TO 99
  920 CONTINUE
C
      WRITE(CHMAIL,1020) NPAR
      CALL GMAIL(0,0)
 1020 FORMAT(' **** ERROR IN GFUPAR - NPAR FROM JIN =',I5,' LE 0 ****')
C
   99 CONTINUE
      END
+DECK,  GFVOLU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GFVOLU(NUMB,NAME,NAMS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print VOLUMES data structures JVOLUM          *
C.    *       NUMB     Volume number                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *         Author  R.Brun  S.Giani *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER*4 ISHAP(30),NAME,NAMS
*     DIMENSION PAR(50),ATT(20)
      SAVE ISHAP
      DATA ISHAP/'BOX ','TRD1','TRD2','TRAP','TUBE','TUBS','CONE',
     +           'CONS','SPHE','PARA','PGON','PCON','ELTU','HYPE',
     +13*'    ', 'GTRA','CTUB','    '/
C.
C.    ------------------------------------------------------------------
      IF (JVOLUM.LE.0) GO TO 99
      IF (NUMB  .GT.0) GO TO 10
C
*      WRITE (CHMAIL,1000)
*      CALL GMAIL(0,0)
*      WRITE (CHMAIL,1001)
*      CALL GMAIL(0,1)
C
      N1     = 1
      N2     = NVOLUM
      GO TO 20
C
   10 CONTINUE
*   10 WRITE (CHMAIL,1001)
*      CALL GMAIL(0,1)
C
      N1     = NUMB
      N2     = NUMB
C
   20 DO 30 I=N1,N2
      JVO = LQ(JVOLUM-I)
      IF (JVO.LE.0)   GO TO 30
C
      CALL UHTOC(IQ(JVOLUM+I),4,NAME,4)
      IS   = Q(JVO+2)
*      NMED = Q(JVO+4)
C
**      CALL GFPARA(NAME,1,1,NPAR,NATT,PAR,ATT)
*      IEND10=10
*      IF(NPAR.LT.IEND10)IEND10=NPAR
*
      NAMS=ISHAP(IS)
*
*      WRITE(CHMAIL,1002)I,NAME,NMED,ISHAP(IS),NPAR,(PAR(J),J=1,IEND10)
*      CALL GMAIL(0,0)
**      DO 25 I10=11,NPAR,10
**        IEND10=I10+9
**        IF (NPAR.LT.IEND10) IEND10=NPAR
*        WRITE (CHMAIL,1003) (PAR(J),J = I10,IEND10)
*        CALL GMAIL(0,0)
**   25 CONTINUE
   30 CONTINUE
C
* 1000 FORMAT ('0',51('='),5X,' VOLUMES ',6X,50('='))
* 1001 FORMAT ('0','VOLUME NAME  NUMED SHAPE NPAR  PARAMETERS')
* 1002 FORMAT (' ',I6,1X,A4,2X,I3,3X,A4,I5,2X,10E10.3)
* 1003 FORMAT (31X,10E10.3)
  99  END
+DECK,  GGCAVE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GGCAVE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GGCAVE                                                 *
C.    *                                                                *
C.    *   Decides whether a given volume is convex or concave.         *
C.    *   For concave volumes, it sets up bit 3 of the status word     *
C.    *   of the corresponding Volume bank                             *
C.    *                                                                *
C.    *   Called by : GGCLOS                                           *
C.    *   Authors   : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
*
      IF (IQ(JVOLUM-1).LE.0) GO TO 999
*
* *** Loop over all volumes
*
      DO 20 IVO = 1, IQ(JVOLUM-1)
         JVO = LQ(JVOLUM-IVO)
         ISH = Q(JVO+2)
*
*  **    Some volumes are always convex
*
         IF (ISH.EQ.13)GO TO 20
         IF ((ISH.GT.0.AND.ISH.LE.4).OR.ISH.EQ.10) GO TO 20
*
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
*
*  **       For TUBE/TUBS/SPHR, only when rmin is zero
*  **       For      TUBS/SPHR, D(Phi) should be less than 180.0
*
            IF (Q(JVO+5).GT.0.0) THEN
               IF (Q(JVO+7).EQ.0.0) THEN
                  IF (ISH.EQ.5) THEN
                     GO TO 20
                  ELSE IF (ISH.EQ.6) THEN
                     DPHI = Q(JVO+11) - Q(JVO+10)
                  ELSE
                     DPHI = Q(JVO+12) - Q(JVO+11)
                  ENDIF
                  IF (DPHI.LT.0.0) DPHI = DPHI + 360.0
                  IF (DPHI.LE.180.0.OR.DPHI.GE.360.0) GO TO 20
               ENDIF
            ENDIF
*
         ELSE IF (ISH.EQ.7.OR.ISH.EQ.8) THEN
*
*  **       For CONE/CONS, only when rmin's are zero
*  **       For      CONS, D(Phi) should be less than 180.0
*
            IF (Q(JVO+5).GT.0.0) THEN
               IF (Q(JVO+8).EQ.0.0.AND.Q(JVO+10).EQ.0.0) THEN
                  IF (ISH.EQ.7) THEN
                     GO TO 20
                  ELSE
                     DPHI = Q(JVO+13) - Q(JVO+12)
                     IF (DPHI.LT.0.0) DPHI = DPHI + 360.0
                     IF (DPHI.LE.180.0.OR.DPHI.GE.360.0) GO TO 20
                  ENDIF
               ENDIF
            ENDIF
*
         ELSE IF (ISH.EQ.11.OR.ISH.EQ.12) THEN
*
*  **       For PGON/PCON, only when rmin's are zero, has 2 z-planes
*  **                      and D(phi) less than 180.0 or equal to 360.0
*
            IF (Q(JVO+5).GT.0.0) THEN
               IF (ISH.EQ.11) THEN
                 IPZ  = 10
               ELSE
                 IPZ  = 9
               ENDIF
               NPZ  = Q(JVO+IPZ)
               DPHI = Q(JVO+8)
               IF (DPHI.LT.0.0) DPHI = DPHI + 360.0
               IF (NPZ.EQ.2.AND.Q(JVO+IPZ+2).EQ.0.0.AND.
     +             Q(JVO+IPZ+5).EQ.0.0) THEN
                  IF (DPHI.LE.180.0.OR.DPHI.GE.360.0) GO TO 20
               ENDIF
            ENDIF
*
         ENDIF
C    hyperboloids (ISH=14) are always concave
         IQ(JVO) = IBSET(IQ(JVO),2)
   20 CONTINUE
*                                                             END GGCAVE
  999 END
+DECK,  GGDPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GGDPAR (JVOM, IN, NVAR, LVAR, LVOM, NPAR, PAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GGDPAR (JVOM,IN,NVAR,LVAR,LVOM,NPAR*,PAR*)            *
C.    *                                                                *
C.    *   Computes the actual parameters for the IN'th division of the *
C.    *    mother volume at address JVOM                               *
C.    *   Returns the set of actual parameters in NPAR, PAR            *
C.    *                                                                *
C.    *   Called by : GGDVLP                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *               (Original algorithms of A.McPherson)             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
C.
      PARAMETER (NPAMAX=50)
C.
      DIMENSION LVAR(*), PAR(*)
C.
      REAL      PARM(NPAMAX)
      INTEGER   LAX(10,12)
      SAVE LAX
C.
      DATA      LAX / 1, 2, 3, 7*0, 1, 1, 2, 3, 6*0, 1, 1, 2, 2, 3, 5*0,
     +                3, 0, 0, 2, 1, 1, 0, 2, 1, 1, 1, 1, 3, 7*0,
     +                1, 1, 3, 2, 2, 5*0, 3, 1, 1, 1, 1, 5*0,
     +                3, 1, 1, 1, 1, 2, 2, 3*0, 1, 1, 2, 2, 6*0,
     +                1, 2, 3, 7*0, 2, 2, 0, 0, 3, 1, 1, 3, 1, 1,
     +                2, 2, 0, 3, 1, 1, 3, 1, 1, 0/
C.
C.    ------------------------------------------------------------------
*
* *** Prepares parameters for mother, in PARM, for division, in PAR
*      and the division parameters
*
      JIN = LQ(JVOM-1)
      IF (LQ(JVOM).EQ.LVOM) THEN
*
*      Case when current volume is source of local development
*
         NPARM = Q(JVOM+5)
         CALL UCOPY (Q(JVOM+7), PARM, NPARM)
         NDIV  = Q(JIN+3)
         ORIG  = Q(JIN+4)
         STEP  = Q(JIN+5)
      ELSE
*
*      Other cases
*
         NPARM = IQ(LVOM+5)
         CALL UCOPY (Q(LVOM+6), PARM, NPARM)
         NDIV  = IQ(LVOM+1)
         ORIG  = Q(LVOM+2)
         STEP  = Q(LVOM+3)
      ENDIF
*
      ISHM  = Q(JVOM+2)
*
      ORI   = ORIG + (IN - 1) * STEP
      IAXIS = Q(JIN+1)
      IVO   = Q(JIN+2)
      JVO   = LQ(JVOLUM-IVO)
      ISH   = Q(JVO+2)
      NPAR  = Q(JVO+5)
*
* *** Prepare the division parameters
*
      IF (NPAR.GT.0) THEN
         CALL UCOPY (Q(JVO+7), PAR, NPAR)
      ELSE
         NPAR  = NPARM
         CALL UCOPY (PARM, PAR, NPARM)
*
*  **    Special treatment for phi divisions (when NPAR=0)
*
         IF ((ISHM.GE.5.AND.ISHM.LE.8.AND.IAXIS.EQ.2) .OR.
     +       (ISHM.GE.11.AND.ISHM.LE.12.AND.IAXIS.EQ.2) .OR.
     +       (ISHM.EQ.9.AND.IAXIS.EQ.3)) THEN
            IF (ISHM.EQ.5.OR.ISHM.EQ.7) THEN
               NPAR = NPARM + 2
               PAR(NPAR-1) = -0.5 * STEP
               PAR(NPAR)   =  0.5 * STEP
            ELSE IF (ISHM.EQ.6.OR.ISHM.EQ.8) THEN
               DP   = PARM(NPAR) - PARM(NPAR-1)
               IF (DP.LT.0.0) DP = DP + 360.0
               IF (ORIG-PARM(NPAR-1).LT.0.0) ORIG = ORIG + 360.0
               IF (ORIG-PARM(NPAR-1).GT.DP ) GO TO 910
               DP   = PARM(NPAR) - ORIG
               IF (DP.LT.0.0) DP = DP + 360.0
               PAR(NPAR-1) = -0.5 * DP / NDIV
               PAR(NPAR  ) =  0.5 * DP / NDIV
            ELSE IF (ISHM.EQ.11.OR.ISHM.EQ.12) THEN
               IF (ISHM.EQ.11) NDIV = PARM(3)
               STEP = PARM(2) / NDIV
               PAR(1) = -0.5 * STEP
               PAR(2) = STEP
               PAR(3) = 1.
            ELSE IF (ISHM.EQ.9) THEN
               DP   = PARM(6) - PARM(5)
               IF (DP.LT.0.0) DP = DP + 360.0
               IF (ORIG-PARM(5).LT.0.0) ORIG = ORIG + 360.0
               IF (ORIG-PARM(5).GT.DP ) GO TO 910
               DP   = PARM(6) - ORIG
               IF (DP.LT.0.0) DP = DP + 360.0
               PAR(5) = -0.5 * DP / NDIV
               PAR(6) =  0.5 * DP / NDIV
            ENDIF
         ENDIF
      ENDIF
      IF (NVAR.LE.0)  GO TO 999
*
* *** Compute the actual parameters
*
      IF (ISHM.EQ.1) THEN
*
* BOX
*
         IF (ISH.EQ.1) THEN
            DO 10 I = 1, NVAR
               IAX = LVAR(I)
               IF (IAX.EQ.IAXIS) THEN
                  PAR(IAX) = 0.5 *STEP
               ELSE
                  PAR(IAX) = PARM(IAX)
               ENDIF
   10       CONTINUE
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.2) THEN
*
* TRD1
*
         IF (ISH.EQ.2) THEN
            DO 20 I = 1, NVAR
               IAX = LVAR(I)
               IF (LAX(IAX,ISH).EQ.IAXIS) THEN
                  PAR(IAX) = 0.5 * STEP
               ELSE IF (LAX(IAX,ISH).EQ.1.AND.IAXIS.EQ.3) THEN
                  ZZ   = ORI + PARM(4)
                  DXDZ = 0.5 * (PARM(2) - PARM(1)) / PARM(4)
                  IF (IAX.EQ.2) ZZ = ZZ + STEP
                  PAR(IAX) = PARM(1) + DXDZ * ZZ
               ELSE
                  PAR(IAX) = PARM(IAX)
               ENDIF
   20       CONTINUE
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.3) THEN
*
* TRD2
*
         IF (ISH.EQ.3.AND.IAXIS.EQ.3) THEN
            DO 30 I = 1, NVAR
               IAX = LVAR(I)
               IF (LAX(IAX,ISH).EQ.IAXIS) THEN
                  PAR(IAX) = 0.5 * STEP
               ELSE
                  IP1  = 2 * LAX(IAX,ISH) - 1
                  IP2  = IP1 + 1
                  ZZ   = ORI + PARM(5)
                  DXDZ = 0.5 * (PARM(IP2) - PARM(IP1)) / PARM(5)
                  IF (IAX.EQ.IP2) ZZ = ZZ + STEP
                  PAR(IAX) = PARM(IP1) + DXDZ * ZZ
               ENDIF
   30       CONTINUE
         ELSE IF (ISH.EQ.3) THEN
            GO TO 910
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.4) THEN
*
* TRAP
*
         IF (ISH.EQ.4.AND.IAXIS.NE.1) THEN
         IF(IAXIS.EQ.3) THEN
            DO 40 I = 1, NVAR
               IAX = LVAR(I)
               IF (IAX.EQ.1) THEN
                  PAR(IAX) = 0.5 * STEP
               ELSE IF (IAX.LE.6) THEN
                  ZZ   = ORI + PARM(1)
                  DPDZ = 0.5 * (PARM(IAX+4) - PARM(IAX)) / PARM(1)
                  PAR(IAX) = PARM(IAX) + DPDZ * ZZ
               ELSE
                  ZZ   = ORI + PARM(1) + STEP
                  DPDZ = 0.5 * (PARM(IAX) - PARM(IAX-4)) / PARM(1)
                  PAR(IAX) = PARM(IAX-4) + DPDZ * ZZ
               ENDIF
   40       CONTINUE
            HTAL = PARM(8) * PARM(11)
            HTAH = PARM(4) * PARM(7)
            ZZ1  = 0.5 * (ORI + PARM(1)) / PARM(1)
            ZZ2  = 0.5 * (ORI + PARM(1) + STEP) / PARM(1)
            PAR(7) = (HTAL*(1.0-ZZ1) + HTAH*ZZ1) / PARM(4)
            PAR(11)= (HTAL*(1.0-ZZ2) + HTAH*ZZ2) / PARM(8)
            CALL GNOTR1(PAR)
            ELSE IF (IAXIS.EQ.2) THEN
               DO 41 I = 1, NVAR
               PAR(LVAR(I)) = PARM(LVAR(I))
  41           CONTINUE
               DXDY1 = 0.5*(PARM(6)-PARM(5))/PARM(4)
               DXDY2 = 0.5*(PARM(10)-PARM(9))/PARM(8)
               DXM1  = 0.5*(PARM(6)+PARM(5))
               DXM2  = 0.5*(PARM(10)+PARM(9))
               DXH1  = DXM1+(ORI+STEP)*DXDY1
               DXH2  = DXM2+(ORI+STEP)*DXDY2
               DXL1  = DXM1+ORI*DXDY1
               DXL2  = DXM2+ORI*DXDY2
               PAR(5) = DXL1
               PAR(6) = DXH1
               PAR(9) = DXL2
               PAR(10) = DXH2
            ENDIF
         ELSE IF (ISH.EQ.4) THEN
            GO TO 910
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.5 .OR. ISHM.EQ.6) THEN
*
* TUBE or TUBS
*
         IF (ISH.EQ.5 .OR. ISH.EQ.6) THEN
            DO 50 I = 1, NVAR
               IAX = LVAR(I)
               IF (LAX(IAX,ISH).EQ.IAXIS) THEN
                  IF (IAXIS.EQ.3) THEN
                     PAR(IAX) = 0.5 * STEP
                  ELSE IF (IAXIS.EQ.1) THEN
                     IF (IAX.EQ.1) THEN
                        PAR(IAX) = ORI
                     ELSE
                        PAR(IAX) = ORI + STEP
                     ENDIF
                  ELSE
                     GO TO 910
                  ENDIF
               ELSE
                  PAR(IAX) = PARM(IAX)
               ENDIF
   50       CONTINUE
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.7 .OR. ISHM.EQ.8) THEN
*
* CONE or CONS
*
         IF (ISH.EQ.7 .OR. ISH.EQ.8) THEN
            DO 60 I = 1, NVAR
               IAX = LVAR(I)
               IF (LAX(IAX,ISH).EQ.IAXIS .AND. IAXIS.EQ.3) THEN
                  PAR(IAX) = 0.5 * STEP
               ELSE IF (IAXIS.EQ.3.AND.IAX.GT.1.AND.IAX.LT.6) THEN
                  IF (IAX.EQ.2.OR.IAX.EQ.4) THEN
                     DP   = 0.5 * (PARM(4) - PARM(2)) / PARM(1)
                     PM   = 0.5 * (PARM(4) + PARM(2))
                  ELSE
                     DP   = 0.5 * (PARM(5) - PARM(3)) / PARM(1)
                     PM   = 0.5 * (PARM(5) + PARM(3))
                  ENDIF
                  IF (IAX.GT.3) THEN
                     DZ   = ORI + STEP
                  ELSE
                     DZ   = ORI
                  ENDIF
                  PAR(IAX) = PM + DP * DZ
               ELSE IF (IAXIS.EQ.1.AND.LAX(IAX,ISH).EQ.IAXIS) THEN
                  IF (IAX.EQ.2) THEN
                     PAR(IAX) = ORI
                  ELSE IF (IAX.EQ.3) THEN
                     PAR(IAX) = ORI + STEP
                  ELSE IF (IAX.EQ.4) THEN
                     PAR(IAX) = ORI * PARM(IAX) / PARM(2)
                  ELSE
                     PAR(IAX) = (ORI + STEP) * PARM(IAX) / PARM(3)
                  ENDIF
               ELSE
                  PAR(IAX) = PARM(IAX)
               ENDIF
   60       CONTINUE
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.9) THEN
*
* SPHE
*
         IF (ISH.EQ.9) THEN
            DO 70 I = 1, NVAR
               IAX = LVAR(I)
               IF (LAX(IAX,ISH).EQ.IAXIS) THEN
                  IF (MOD(IAX,2).NE.0) THEN
                     PAR(IAX) = ORI
                  ELSE
                     PAR(IAX) = ORI + STEP
                  ENDIF
               ELSE
                  PAR(IAX) = PARM(IAX)
               ENDIF
   70       CONTINUE
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.10) THEN
*
* PARA
*
         IF (ISH.EQ.10) THEN
            DO 80 I = 1, NVAR
               IAX = LVAR(I)
               IF (LAX(IAX,ISH).EQ.IAXIS) THEN
                  PAR(IAX) = 0.5 * STEP
               ENDIF
   80       CONTINUE
         ELSE
            GO TO 900
         ENDIF
*
      ELSE IF (ISHM.EQ.11 .OR. ISHM.EQ.12) THEN
*
* PGON or PCON
*
         IF (ISH.EQ.ISHM) THEN
            IF (ISH.EQ.11) THEN
               IPNZ = 4
            ELSE
               IPNZ = 3
            ENDIF
            NZ   = PAR(IPNZ)
            NZ1  = PARM(IPNZ)
            IF (NZ.EQ.NZ1) THEN
               IF (IAXIS.EQ.1) THEN
                  RMN  = ORI
                  RMX  = ORI + STEP
                  DO 90 I = 1, NZ
                     IAX1 = IPNZ + 3*I - 1
                     IAX2 = IAX1 + 1
                     IF (I.EQ.1) THEN
                        PAR(IAX1) = RMN
                        PAR(IAX2) = RMX
                     ELSE
                        PAR(IAX1) = RMN * PARM(IAX1) / PARM(IPNZ+2)
                        PAR(IAX2) = RMX * PARM(IAX2) / PARM(IPNZ+3)
                     ENDIF
   90             CONTINUE
               ELSE IF (IAXIS.EQ.2) THEN
                  DO 100 I = 1, NVAR
                     IAX = LVAR(I)
                     PAR(IAX) = PARM(IAX)
  100             CONTINUE
               ELSE IF (NZ.EQ.2.AND.IAXIS.EQ.3) THEN
                  ZL   = PARM(IPNZ+1)
                  ZH   = PARM(IPNZ+4)
                  DZ   = ZH - ZL
                  DRMIDZ = (PARM(IPNZ+5)-PARM(IPNZ+2))/DZ
                  DRMADZ = (PARM(IPNZ+6)-PARM(IPNZ+3))/DZ
                  PAR(IPNZ+1) = -0.5 * STEP
                  PAR(IPNZ+4) =  0.5 * STEP
                  DO 110 I = 1, NVAR
                     IAX = LVAR(I)-IPNZ
                     IF(IAX.EQ.2) THEN
                        RAD = PARM(IPNZ+2)+(IN-1)*STEP*DRMIDZ
                     ELSEIF (IAX.EQ.3) THEN
                        RAD = PARM(IPNZ+3)+(IN-1)*STEP*DRMADZ
                     ELSEIF (IAX.EQ.5) THEN
                        RAD = PARM(IPNZ+2)+IN*STEP*DRMIDZ
                     ELSEIF (IAX.EQ.6) THEN
                        RAD = PARM(IPNZ+3)+IN*STEP*DRMADZ
                     ENDIF
                     PAR(IPNZ+IAX) = RAD
  110             CONTINUE
               ELSE
                  GO TO 920
               ENDIF
            ELSE
               GO TO 920
            ENDIF
         ELSE
            GO TO 900
         ENDIF
*
      ELSE
         GO TO 900
      ENDIF
*
      GO TO 999
*
  900 WRITE (CHMAIL, 1001) ISH, ISHM
      GO TO 990
*
  910 WRITE (CHMAIL, 1002) ISH, ISHM, IAXIS
      GO TO 990
*
  920 WRITE (CHMAIL, 1003) ISH, NZ, ISHM, NZ1
*
  990 CALL GMAIL( 0, 0)
      IEORUN = 1
*
 1001 FORMAT (' GGDPAR : Not accepted ISH,ISHM=',2I5)
 1002 FORMAT (' GGDPAR : Not accepted ISH,ISHM,IAXIS=',3I5)
 1003 FORMAT (' GGDPAR : Not accepted ISH,NZ,ISHM,NZ1=',4I5)
*                                                             END GGDPAR
  999 END
+DECK,  GGDSPE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GGDSPE (JVO, NPAR, PAR, NL, NDIV, ORIG, STEP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GGDSPE (JVO,NPAR,PAR,NL*,NDIV*,ORIG*,STEP*)           *
C.    *                                                                *
C.    *   Computes the actual division parameters of the mother volume *
C.    *    at address JVO with actual parameters in NPAR, PAR          *
C.    *   Returns the division parameters NDIV, ORIG, STEP and the     *
C.    *    number of different division cells NL                       *
C.    *                                                                *
C.    *   Called by : GGDVLP                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *               (Original algorithms of A.McPherson)             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
C.
      PARAMETER (NPAMAX=50)
C.
      DIMENSION PAR(*)
C.
      REAL      PARM(NPAMAX)
      INTEGER   IDTYP(12)
      SAVE IDTYP
      DATA      IDTYP / 1, 1, 1, 1, 2, 2, 3, 3, 4, 1, 6, 6/
C.
C.    ------------------------------------------------------------------
*
* *** Get the division parameters from JVOLUM structure and check if
*         these have to be developed
*
      JIN   = LQ(JVO-1)
      IAXIS = Q(JIN+1)
      NDIV  = Q(JIN+3)
      ORIG  = Q(JIN+4)
      STEP  = Q(JIN+5)
*
      ISHM  = Q(JVO+2)
      IDTY  = IDTYP(ISHM)
      NPARM = Q(JVO+5)
      IF (NPARM.GT.0) THEN
         CALL UCOPY (Q(JVO+7), PARM, NPARM)
      ELSE
         NPARM = NPAR
         CALL VFILL (PARM, NPARM, -1.0)
      ENDIF
*
* *** Find the actual division parameters
*
      IF (IDTY.EQ.1) THEN
*
* BOX, TRD1, TRD2, TRAP, PARA
*
         IF (ISHM.EQ.4) THEN
            IPAR = 1
         ELSE IF (ISHM.EQ.10) THEN
            IPAR = IAXIS
         ELSE
            IPAR = IAXIS + ISHM - 1
         ENDIF
         IF (PARM(IPAR).LT.0.0) ORIG = -PAR(IPAR)
         IF (STEP.LE.0.0) THEN
            STEP = (PAR(IPAR) - ORIG) / NDIV
         ELSE IF (NDIV.LE.0) THEN
            NDIV = (PAR(IPAR) - ORIG + 0.001) / STEP
         ENDIF
         IF (PARM(IPAR).LT.0.0) ORIG = -0.5 * STEP * NDIV
         IF (ISHM.EQ.1.OR.ISHM.EQ.10.OR.(ISHM.EQ.2.AND.IAXIS.EQ.2)) THEN
            NL = 1
         ELSE
            NL = NDIV
         ENDIF
*
      ELSE IF (IDTY.EQ.4) THEN
*
* SPHE
*
         IF (IAXIS.EQ.1.OR.IAXIS.EQ.2) THEN
            IAX1 = 2*IAXIS - 1
            IAX2 = IAX1 + 1
            IF (PARM(IAX1).LT.0.0) ORIG = PAR(IAX1)
            IF (STEP.LE.0.0) THEN
               STEP = (PAR(IAX2) - ORIG) / NDIV
            ELSE IF (NDIV.LE.0) THEN
               NDIV = (PAR(IAX2) - ORIG + 0.001) / STEP
            ENDIF
            IF (PARM(IAX1).LT.0.0) ORIG = 0.5*(ORIG+PAR(IAX2)-STEP*NDIV)
            NL = NDIV
         ELSE
            IF (STEP.LE.0.0.OR.NDIV.LE.0) THEN
               DP = PAR(6) - PAR(5)
               IF (DP.LT.0.0) DP = DP + 360.0
               IF (ORIG.LT.PAR(5)) ORIG = ORIG + 360.0
               IF (ORIG-PAR(5).GT.DP) THEN
                  PMIN = PAR(5)
                  GO TO 910
               ENDIF
               DP = PAR(6) - ORIG
               IF (DP.LT.0.0) DP = DP + 360.0
               IF (NDIV.LE.0) THEN
                  NDIV = (DP + 0.001) /STEP
                  IF (NDIV.LE.0) GO TO 920
               ELSE
                  STEP = DP / NDIV
               ENDIF
            ENDIF
            NL = 1
         ENDIF
*
      ELSE IF (IDTY.EQ.2.OR.IDTY.EQ.3.OR.IDTY.EQ.6) THEN
*
* TUBE, TUBS, CONE, CONS, PGON, PCON
*
         IF (IAXIS.EQ.3) THEN
            IF (IDTY.NE.6) THEN
               IF (IDTY.EQ.2) THEN
                  IPAR = 3
               ELSE
                  IPAR = 1
               ENDIF
               IF (PARM(IPAR).LT.0.0) ORIG = -PAR(IPAR)
               IF (STEP.LE.0.0) THEN
                  STEP = (PAR(IPAR) - ORIG) / NDIV
               ELSE IF (NDIV.LE.0) THEN
                  NDIV = (PAR(IPAR) - ORIG + 0.001) / STEP
               ENDIF
               IF (PARM(IPAR).LT.0.0) ORIG = -0.5 * STEP * NDIV
               IF (IDTY.EQ.2) THEN
                  NL = 1
               ELSE
                  NL = NDIV
               ENDIF
            ELSE
               IF (ISHM.EQ.11) THEN
                  NZ = PAR(4)
               ELSE
                  NZ = PAR(3)
               ENDIF
               IF (NDIV.LE.0.OR.STEP.LE.0.0.OR.NZ.GT.0) GO TO 930
               NL = NDIV
            ENDIF
*
         ELSE IF (IAXIS.EQ.2) THEN
            IF (STEP.LE.0.0.OR.NDIV.LE.0) THEN
               IF (ISHM.EQ.5.OR.ISHM.EQ.7) THEN
                  PMIN = ORIG
                  PMAX = ORIG + 360.0
                  DP   = 360.0
               ELSE IF (ISHM.EQ.6.OR.ISHM.EQ.8) THEN
                  PMIN = PAR(NPAR-1)
                  PMAX = PAR(NPAR)
                  DP   = PMAX - PMIN
               ELSE
                  PMIN = PAR(1)
                  DP   = PAR(2)
                  PMAX = PMIN + DP
               ENDIF
               IF (DP.LT.0.0) DP = DP + 360.0
               IF (ORIG.LT.PMIN) ORIG = ORIG + 360.0
               IF (ORIG-PMIN.GT.DP) GO TO 910
               DP = PMAX - ORIG
               IF (DP.LT.0.0) DP = DP + 360.0
               IF (NDIV.LE.0) THEN
                  NDIV = (DP + 0.001) / STEP
                  IF (NDIV.LE.0) GO TO 920
               ELSE
                  STEP = DP / NDIV
               ENDIF
            ENDIF
            NL = 1
*
         ELSE
            IF (IDTY.NE.6) THEN
               IF (IDTY.EQ.2) THEN
                  IAX1 = 1
                  IAX2 = 2
               ELSE
                  IAX1 = 2
                  IAX2 = 3
               ENDIF
               IF (PARM(IAX1).LT.0.0) ORIG = PAR(IAX1)
               IF (STEP.LE.0.0) THEN
                  STEP = (PAR(IAX2) - ORIG) / NDIV
               ELSE IF (NDIV.LE.0) THEN
                  NDIV = (PAR(IAX2) - ORIG + 0.001) / STEP
               ENDIF
               IF (PARM(IAX1).LT.0.0)
     +            ORIG = ORIG + 0.5 * (PAR(IAX2)-ORIG-STEP*NDIV)
               NL = NDIV
            ELSE
               IF (STEP.LE.0.0.OR.NDIV.LE.0) THEN
                  IF (ISHM.EQ.11) THEN
                     NZ = PAR(4)
                  ELSE
                     NZ = PAR(3)
                  ENDIF
                  GO TO 930
               ENDIF
               NL = NDIV
            ENDIF
         ENDIF
*
      ELSE
         GO TO 900
      ENDIF
      GO TO 999
*
  900 WRITE (CHMAIL, 1001) ISHM, IAXIS
      GO TO 990
*
  910 WRITE (CHMAIL, 1002) ISHM, IAXIS, PMIN, DP, ORIG
      GO TO 990
*
  920 WRITE (CHMAIL, 1003) ISHM, IAXIS, NDIV, DP, STEP
      GO TO 990
*
  930 WRITE (CHMAIL, 1004) ISHM, IAXIS, NDIV, NZ, STEP
*
  990 CALL GMAIL (0, 0)
      IEORUN = 1
*
 1001 FORMAT (' GGDSPE : Invalid call ISHM,IAXIS=',2I5)
 1002 FORMAT (' GGDSPE : Error ISHM,IAXIS,PMIN,DP,ORIG=',2I5,3G12.4)
 1003 FORMAT (' GGDSPE : Error ISHM,IAXIS,NDIV,DP,STEP=',3I5,2G12.4)
 1004 FORMAT (' GGDSPE : Error ISHM,IAXIS,NDIV,NZ,STEP=',4I5,G12.4)
*                                                             END GGDSPE
  999 END
+DECK,  GGDVLP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GGDVLP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GGDVLP                                                *
C.    *                                                                *
C.    *   DeVeLoPs locally the JVOLUM structure so as not to have to   *
C.    *   recompute variable parameters and division specifications    *
C.    *   at tracking time.                                            *
C.    *                                                                *
C.    *   Called by : GGCLOS                                           *
C.    *   Authors   : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
C.
      PARAMETER (NLVMAX=15, NPAMAX=50)
C.
      COMMON /GCDVLP/ LREF(2), JVO, LJVOM(NLVMAX), LLVODV(NLVMAX), LVODV
C.
      INTEGER     ILINK(NLVMAX), LVAR(NPAMAX), NLINK(NLVMAX)
      INTEGER     NUMB(NLVMAX+1), NBGN(NLVMAX+1), IVOL(5200)
      EQUIVALENCE (IVOL(1), WS(1))
      REAL        PAR(NPAMAX)
      LOGICAL     BTEST
C.
C.    ------------------------------------------------------------------
*
      CALL MZLINT (IXSTOR, '/GCDVLP/', LREF, JVO, LVODV)
*
      CALL MZFORM ('VODV', '1I 2F 2I -F', IOVODV)
*
* *** Create the volume tree in memory
*
      IF (NVOLUM.LT.1) GO TO 990
      NUMB(1) = 1
      NBGN(1) = 1
      IVOL(1) = 1
      NLVT = 1
*
   10 NLEV = NLVT + 1
      NUMB(NLEV) = 0
      NBGN(NLEV) = NBGN(NLVT) + NUMB(NLVT)
      DO 30 I = 1, NUMB(NLVT)
         IVO  = IVOL(NBGN(NLVT) + I - 1)
         JVO  = LQ(JVOLUM-IVO)
         NIN  = Q(JVO+3)
         IF (NIN.GT.0) THEN
            DO 20 IN = 1, NIN
               JIN  = LQ(JVO-IN)
               IVOT = Q(JIN+2)
               DO 15 I1 = 1, NUMB(NLEV)
                  IVOS = IVOL(NBGN(NLEV)+I1-1)
                  IF (IVOS.EQ.IVOT) GO TO 20
   15          CONTINUE
               NUMB(NLEV) = NUMB(NLEV) + 1
               I1         = NBGN(NLEV) + NUMB(NLEV) - 1
               IVOL(I1)   = IVOT
   20       CONTINUE
         ELSE IF (NIN.LT.0) THEN
            JDIV = LQ(JVO-1)
            IVOT = Q(JDIV+2)
            DO 25 I1 = 1, NUMB(NLEV)
               IVOS = IVOL(NBGN(NLEV)+I1-1)
               IF (IVOS.EQ.IVOT) GO TO 30
   25       CONTINUE
            NUMB(NLEV) = NUMB(NLEV) + 1
            I1         = NBGN(NLEV) + NUMB(NLEV) - 1
            IVOL(I1)   = IVOT
         ENDIF
   30 CONTINUE
*
      IF (NUMB(NLEV).GT.0) THEN
         NLVT = NLEV
         GO TO 10
      ENDIF
*
      NLEV  = 1
      NLEVS = 1
*
* *** Loop over volumes in a given level
*
  110 IF (NLEVS.GT.NLVT) GO TO 990
      IF (NUMB(NLEVS).GT.0) THEN
         NUMB(NLEVS) = NUMB(NLEVS) - 1
         IVOM  = IVOL(NBGN(NLEVS)+NUMB(NLEVS))
      ELSE
         NLEVS = NLEVS + 1
         GO TO 110
      ENDIF
*
* *** Check if current volume should be locally developed
*
      LJVOM(1) = LQ(JVOLUM-IVOM)
      IF(LQ(LJVOM(1)).GT.0) THEN
         CALL MZDROP(IXCONS,LQ(LJVOM(1)),'L')
      ENDIF
      NIN  = Q(LJVOM(1)+3)
+SELF, IF=DEBUGG.
      WRITE (CHMAIL,2000) IQ(JVOLUM+IVOM),NIN
      CALL GMAIL (0, 0)
 2000 FORMAT (' GGDVLP : Volume ',A4,'  NIN = ',I3)
+SELF.
*
*  **  Skip it if not a possible source of local development
*
      IF (NIN.EQ.0)                  GO TO 110
      IF (LQ(LJVOM(1)).NE.0)         GO TO 110
      IF (BTEST(IQ(LJVOM(1)),1))     GO TO 110
      CALL GGVCHK (LJVOM(1), 0, NVAR, LVAR)
      IF (NVAR.NE.0) GO TO 110
*
*  **  Otherwise, analyze contents
*
      IOK = 0
      IF (NIN.LT.0) GO TO 120
*
*   *   Current volume has contents defined by position
*
      DO 119 IN = 1,NIN
         CALL GGVCHK (LJVOM(1), IN, NVAR, LVAR)
         IF (NVAR.NE.0) THEN
*
*         In case a content is found with variable parameters,
*          initialize development
*
            NLINK(1) = NIN
            ILINK(1) = IN
            GO TO 200
         ENDIF
  119 CONTINUE
      GO TO 110
*
*   *   Current volume is divided
*
  120 CALL GGVCHK (LJVOM(1), 1, NVAR, LVAR)
      IF (NVAR.EQ.0) GO TO 110
*
*        If cells have variable sizes, initialize development
*
      IOK  = 2
      JDIV = LQ(LJVOM(1)-1)
      NLINK(1) = Q(JDIV+3)
      ILINK(1) = 1
*
  200 CALL MZBOOK (IXCONS, LLVODV(1), LJVOM(1), 0, 'VODV',
     +                         NLINK(1), NLINK(1), 1, 2, 1)
+SELF, IF=DEBUGG.
      WRITE (CHMAIL, 2002) ILINK(1), NLINK(1), NVAR
      CALL GMAIL (0, 0)
 2002 FORMAT (' GGDVLP :         I, N, NVAR = ',3I5)
+SELF.
*
* *** Complete development for current content at current level
*
      IF (IOK.EQ.0) GO TO 250
      IOK = 0
      IQ(LLVODV(1)+1) = NLINK(1)
      GO TO 260
*
  210 NIN = Q(LJVOM(NLEV)+3)
      IF (NIN.LT.0) THEN
         CALL GGVCHK (LJVOM(NLEV), 1, NVAR, LVAR)
      ELSE
         CALL GGVCHK (LJVOM(NLEV), ILINK(NLEV), NVAR, LVAR)
      ENDIF
      IF (NVAR.EQ.0) GO TO 290
+SELF, IF=DEBUGG.
      WRITE (CHMAIL, 2004) NLEV, ILINK(NLEV), NVAR
      CALL GMAIL (0, 0)
 2004 FORMAT (' GGDVLP :              LEVEL,I,NVAR,NIN = ',4I5)
+SELF.
      IF (NIN.LT.0)  GO TO 260
*
*  **  Compute actual parameters for current content
*
*   *   Case with contents obtained by position
*
  250 CALL GGPPAR (LJVOM(NLEV), ILINK(NLEV), NVAR,LVAR, LLVODV(NLEV),
     +                                                     NPAR, PAR)
      JIN = LQ(LJVOM(NLEV)-ILINK(NLEV))
      GO TO 270
*
*   *   Case with contents obtained by division
*
  260 CALL GGDPAR (LJVOM(NLEV), ILINK(NLEV), NVAR,LVAR, LLVODV(NLEV),
     +                                                     NPAR, PAR)
      JIN = LQ(LJVOM(NLEV)-1)
*
*  **  Initialize next level down
*
  270 IVO = Q(JIN+2)
      JVO = LQ(JVOLUM-IVO)
      NIN = Q(JVO+3)
      IF (NIN.GE.0) THEN
         IF (NIN.NE.0) IOK = 1
         NL = NIN
      ELSE
         IOK = 2
*
*   *   Current content is divided, compute division specifications
*
         CALL GGDSPE (JVO, NPAR, PAR, NL, NDIV, ORIG, STEP)
      ENDIF
*
      IQ(JVO) = IBSET(IQ(JVO),1)
      CALL MZBOOK (IXCONS, LVODV, LLVODV(NLEV), -ILINK(NLEV), 'VODV',
     +                  NL, NL, NPAR+5, IOVODV, 3)
      IF (IOK.EQ.2) THEN
         IQ(LVODV+1) = NDIV
          Q(LVODV+2) = ORIG
          Q(LVODV+3) = STEP
+SELF, IF=DEBUGG.
          WRITE (CHMAIL, 2006) NDIV, ORIG, STEP
          CALL GMAIL (0, 0)
 2006     FORMAT (' GGDVLP : After GGDSPE, NDIV ORIG STEP = ',I4,2F10.4)
+SELF.
      ENDIF
      IQ(LVODV+4) = IVO
      IQ(LVODV+5) = NPAR
      CALL UCOPY (PAR, Q(LVODV+6), NPAR)
+SELF, IF=DEBUGG.
      WRITE (CHMAIL, 2008)
      CALL GMAIL (0, 0)
 2008 FORMAT (' GGDVLP : Store parameters into development structure')
+SELF.
*
  290 IF (IOK.EQ.0) THEN
         IF (ILINK(NLEV).EQ.NLINK(NLEV)) THEN
*
*          Go one level up
*
            IF (NLEV.EQ.1) GO TO 110
            NLEV = NLEV -1
            GO TO 290
         ENDIF
*
*       Analyze next content
*
         ILINK(NLEV) = ILINK(NLEV) +1
         GO TO 210
      ENDIF
*
*      A new level has been initialized, start analyzing it
*
      NLEV = NLEV +1
      LJVOM(NLEV)  = JVO
      LLVODV(NLEV) = LVODV
      ILINK(NLEV)  = 1
      NLINK(NLEV)  = NL
      IOK = 0
      GO TO 210
*
  990 DO 991 IVO = 1, NVOLUM
         JVO = LQ(JVOLUM-IVO)
         IF (BTEST(IQ(JVO),1)) THEN
            IF (LQ(JVO).GT.0) THEN
               CALL MZDROP (IXCONS, LQ(JVO), ' ')
               WRITE (CHMAIL, 1001) IQ(JVOLUM+IVO)
            ENDIF
         ENDIF
  991 CONTINUE
      LREF(1) = 0
*
 1001 FORMAT (' GGDVLP : Unnecessary development at volume  ',A4)
*                                                             END GGDVLP
      END
+DECK,  GGEOM_DOC_D, T=DATA, IF=DOC.
*
* $Id: geang321.car100,v 1.1.1.1 2003/04/24 14:25:11 tretiak Exp $
*
* $Log: geang321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:11  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.28  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*            Introduction to the Geometry package                      *
*            ------------------------------------                      *
*                                                                      *
*                                                                      *
* THE GEOMETRY PACKAGE                                                 *
*                                                                      *
*  The geometry package consists of subroutines which can be used in   *
* the initialisation phase  of the program to  describe the geometry   *
* of the  experimental set-up, and  of subroutines which  ensure the   *
* communication  with   the  tracking   package  during   the  event   *
* processing phase.                                                    *
*  The  following paragraphs  review  the concepts  of the  geometry   *
* package  and explain  how  the geometrical  information should  be   *
* provided by the user.                                                *
*  It  is important  to point  out that,  once the  set-up has  been   *
* initialized, the tracking of particles through the different media   *
* can proceed without  any other intervention from  the user [TRAK].   *
* The  connection  between the  geometry  and  tracking packages  is   *
* established  by the  subprograms  GMEDIA/GTMEDI, GNEXT/GTNEXT  and   *
* GINVOL which answer respecti- vely the questions :                   *
*                                                                      *
* - In which medium is a given point ?                                 *
* - What is the path length to the next medium ?                       *
* - Is a given point still in the current medium ?                     *
*                                                                      *
* (The routines GTMEDI  and GTNEXT are used in a  dynamic context at   *
* tracking  time,  where  information  about the  direction  of  the   *
* particle can be used to save time).                                  *
*                                                                      *
* THE VOLUME DEFINITION                                                *
*                                                                      *
*  Experimental set-ups,  as complex  as the detectors  prepared for   *
* LEP, can be described rather  accurately through the definition of   *
* a  set of  simple VOLUMES.   Each VOLUME  is given  a NAME  and is   *
* characterized by:                                                    *
*                                                                      *
* - a  SHAPE identifier,  specifying  one of  the basic  geometrical   *
*   shapes  available [GEOM010],  the shape  parameters, giving  the   *
*   dimensions of the volume,                                          *
* - a local  reference system,  whose origin and  axes are  the ones   *
*   defined for the given shape (cartesian, cylindrical or spherical   *
*   coord.),                                                           *
* - its physical  properties, given  by a set  of constants  for the   *
*   homogeneous MATERIAL which fills the volume [CONS],                *
* - additional  properties, known  as  'TRACKING MEDIUM'  constants,   *
*   which depend  on the characteristics  of the volume  itself (the   *
*   MATERIAL  identifier  is  one  of  the  constants)  and  on  its   *
*   geometrical   and  physical   environment  (properties   of  the   *
*   neighbour media, magnetic field, etc.) [CONS,TRAK],                *
* - a set of attributes, in  connection with the drawing package and   *
*   the detector response package [DRAW,HITS].                         *
*                                                                      *
*  As long as  it is not 'positioned' in a  given reference frame, a   *
* VOLUME is an entity which has no spatial relation with the set-up.   *
* By convention,  a unique  initial volume has  to be  defined which   *
* should match  (or surround) the  outside boundaries of  the entire   *
* set-up.  The reference frame attached to this volume is considered   *
* to be the master reference frame.                                    *
*                                                                      *
* VOLUMES WITH CONTENTS                                                *
*                                                                      *
*  A VOLUME can be declared to have 'contents' and become a 'mother'   *
* volume.   The contents  are  either predefined  volumes which  are   *
* explicitly positioned inside the mother,  or new volumes which are   *
* implicitly defined by a division  mechanism applied to the mother.   *
*  Positioning a  volume with  given shape  and dimensions  inside a   *
* mother  volume  is  achieved  by specifying  its  translation  and   *
* rotation with  respect to  the mother  reference frame.   The user   *
* should make  sure that  no volume overlaps  the boundaries  of its   *
* mother.  When a volume is positioned,  the user gives it a NUMBER.   *
* Multiple copies of a given  volume, with different numbers, can be   *
* positioned inside  a mother  or inside  different mothers  and the   *
* contents of the volume are reproduced implicitly in all copies.      *
*  Divisions can  be performed along  any of  the three axes  of the   *
* mother volume.   The definition of  the axes (X,Y,Z or  R..,.,Z or   *
* R,.,.) depends on  the shape.  The mother volume  can be partially   *
* or  totally divided.   The  division generates  a  cell, which  is   *
* considered as  a new volume with  (usually) the same shape  as the   *
* mother.   Its dimensions  are computed  according to  the declared   *
* division number and/or  step size.  This cell, as  any volume, can   *
* again  be divided  along any  of its  proper axes,  or have  other   *
* volumes positioned into it.  Volumes  positioned within a cell are   *
* reproduced implicitly in all cells.                                  *
*  These operations permit a physical  tree to be defined of volumes   *
* at deeper and deeper levels.                                         *
*  It  is  assumed that  the  'tracking  medium' properties  of  the   *
* contents replace  the ones of  the mother within the  space region   *
* they occupy.                                                         *
*  A  VOLUME  is  therefore  defined   not  only  by  its  intrinsic   *
* characteristics but  also by the definition  of its 'descendants',   *
* namely its contents, the contents of its contents, etc.              *
*                                                                      *
* OVERLAPPING VOLUMES                                                  *
*                                                                      *
*  The user  may define volumes  which have  nothing to do  with the   *
* real physical structure.   It is sometimes convenient  to make use   *
* of  such  volumes, to  artificially  delimit  regions with  simple   *
* shapes.  As a consequence, it may happen that volumes overlap each   *
* other.  (A volume  positioned  inside a  mother  is obviously  not   *
* regarded as overlapping the mother).                                 *
*  The handling  of overlapping  volumes has some  implications that   *
* the user should be aware of:                                         *
*  A flag  'ONLY/MANY' is attached  to each positioned  volume.  The   *
* 'MANY' option  indicates that a point  found to be in  this volume   *
* could also be in other volumes which are not direct descendants of   *
* it.  The user is free to declare one of the overlapping volumes as   *
* 'ONLY', in which  case the medium searching  subroutines will give   *
* priority to this volume.                                             *
*  If  a point  is inside  several  'MANY' volumes  and outside  all   *
* 'ONLY' ones, priority  will be given to the first  volume found at   *
* the  deepest  level  and,  in  order  to  avoid  ambiguities,  two   *
* overlapping 'MANY' volumes should in  general be assigned the same   *
* default tracking medium.                                             *
*                                                                      *
* THE PHYSICAL TREE                                                    *
*                                                                      *
*  The package accepts a maximum of 15 levels, which should be quite   *
* enough to represent even the fine details of a complex set-up.       *
*                                                                      *
* THE DATA STRUCTURE JVOLUM AND THE COMMON BLOCK /GCVOLU/              *
*                                                                      *
*  In practice, the  physical tree is represented by  a logical tree   *
* structure, the  JVOLUM data structure [GEOM  199], which describes   *
* the arrangement of  volumes in a compact and  recurrent way.  Each   *
* generic  volume  appears once,  and  once  only, and  carries  the   *
* information relevant to the volume  itself and to its contents, if   *
* any, by  reference to the  generic volumes corresponding  to those   *
* contents.                                                            *
*  In the situation  where division or multiple  copies occur, there   *
* is no longer a one-to-one correspondence between a given volume in   *
* the logical tree and a unique region in space.  Information has to   *
* be kept at tracking time to  identify which division cell or which   *
* copy was considered at each depth level along the path through the   *
* physical  tree.   This information  is  stored  by the  subroutine   *
* GTMEDI, for the current point of  the current track, in the COMMON   *
* /GCVOLU/.   It contains  the current  LEVEL and,  for each  level,   *
* starting   from   the   first  initial   reference   volume,   the   *
* identification of  the corresponding  volume, e.g.:  NAME, NUMBER,   *
* 'ONLY/MANY'  flag, translation  and rotation  with respect  to the   *
* master reference  frame.  The SHAPE  parameters and the  number of   *
* parameters  (initialy  stored  in  /GCVOLU/)  are  stored  in  the   *
* separate structure JGPAR.                                            *
*                                                                      *
* THE BASIC USER TOOLS                                                 *
*                                                                      *
*  The rules of the game being  established, it is easy to introduce   *
* the  set of  subroutines  which ensure  the  functionality of  the   *
* package.   The user  can define  a volume  through a  call to  the   *
* subroutine:                                                          *
*                                                                      *
* GSVOLU    Input arguments  specify the NAME, SHAPE  and parameters   *
*           of the volume.  An  output argument returns the position   *
*           of the volume inside the bank JVOLUM.                      *
*                                                                      *
* The user can position a volume through a call to either one of the   *
* following subroutines:                                               *
*                                                                      *
* GSPOS     Input arguments specify the NAME  and copy NUMBER of the   *
*           volume to  be positioned,  the NAME  of the  mother, the   *
*           translation and the rotation matrix, and the 'ONLY/MANY'   *
*           flag.                                                      *
* GSPOSP    In case  the user has to  position , inside a  mother, a   *
*           large  number  of  volumes   with  the  same  shape  but   *
*           different dimensions  (lead glass blocks,  BGO crystals,   *
*           etc.)  an  alternative  is proposed  which  consists  of   *
*           defining  the generic  volume once,  with the  number of   *
*           shape parameters  set to  zero, and  to call  GSPOSP for   *
*           each volume  in turn, with  the same arguments  as GSPOS   *
*           plus  the   shape  parameters.   The  volumes   will  be   *
*           identified  by their  NAME+NUMBER  as  for the  multiple   *
*           copies.                                                    *
*                                                                      *
* The user can divide  a volume through a call to  either one of the   *
* following subroutines:                                               *
*                                                                      *
* GSDVN     Input arguments specify the NAME of the cell volume, the   *
*           name  of  the  MOTHER   being  divided,  the  number  of   *
*           divisions NDIV and the axis  along which the division is   *
*           performed.   In  this  simple case,  the  cell  tracking   *
*           medium is assumed to be the same as for the mother.        *
* GSDVS     The division STEP is given  instead of NDIV and the cell   *
*           tracking medium is specified.                              *
* GSDVX     In addition  to both STEP and  NDIV , the origin  of the   *
*           first cell and the cell tracking medium are specified.     *
*                                                                      *
* THE OPTIMISATION TOOLS                                               *
*                                                                      *
*  When a  track enters a volume  with contents, the search  time to   *
* identify whether the  current point is in the mother  or in any of   *
* the contents  is very short  when the contents are  division cells   *
* (straightforward computation  along the relevant axis).   When the   *
* contents have been positioned, the search time can be quite large.   *
* In order  to save  time the  user can  make use  of either  of the   *
* following facilities:                                                *
*                                                                      *
* GSORD/GGORD                                                          *
*   From the  known position of  the contents inside a  given volume   *
*   the subroutine  GGORD computes  fictitious boundaries  along the   *
*   specified  coordinate, simulating  a division  with non  regular   *
*   step size.  A binary search technique is used to identify within   *
*   which pseudo-cell  the current  point is.   The slow  process of   *
*   computing whether the point is inside or outside the contents is   *
*   therefore limited  to the few  (if any) volumes sitting  in that   *
*   pseudo-cell.  The  coordinate selected  for the  pseudo division   *
*   can be any of X, Y, Z, Rxy, R, Phi or Theta.  GSORD is called by   *
*   the user to  flag which volume should have  its contents ordered   *
*   and along which axis.  GGORD is  called by GGCLOS.  The user can   *
*   select via the data record OPTIM to automatically call GSORD for   *
*   all the volumes with content.  In  this case the system will try   *
*   to choose  the best axis  along which  to order the  contents of   *
*   every mother in the tree.                                          *
*                                                                      *
* GSNEXT - GSNEAR                                                      *
*   When a particle enters a mother volume, the contents are scanned   *
*   initially in the  order they have been positioned,  and the user   *
*   should  take  care  over  the  best  sequence  of  GSPOS  calls.   *
*   However, when the particle comes back inside the mother from any   *
*   one of the contents, it is  usually possible to limit the search   *
*   to the neighbour contents.  The subroutines GSNEXT,GSNEAR permit   *
*   the user to  inject at initialisation time, for  each content in   *
*   turn, the  list of neighbours  to search  for.  A proper  use of   *
*   this facility can reduce the search time significantly.            *
*                                                                      *
* GSUNEA/GUNEAR                                                        *
*   To specify any user ordering for the contents of a given volume.   *
*                                                                      *
*       Labelled COMMON blocks related to section GEOM                 *
*       ----------------------------------------------                 *
*                                                                      *
*       COMMON /GCPOLY/ IZSEC, IPSEC                                   *
* C                                                                    *
* IZSEC     Z-section number                                           *
* IPSEC     Phi-sector number                                          *
*                                                                      *
*       COMMON/GCVOLU/NLEVEL,NAMES(15),NUMBER(15),                     *
*      +LVOLUM(15),LINDEX(15),INFROM,NLEVMX,NLDEV(15),LINMX(15),       *
*      +GTRAN(3,15),GRMAT(10,15),GONLY(15),GLX(3)                      *
* C                                                                    *
* NLEVEL    Level number at which the last medium search stopped.      *
* NAMES     Volume names at each level.                                *
* NUMBER    User volume numbers at each level.                         *
* LVOLUM    System volume numbers at each level.                       *
* LINDEX    Physical tree volume indices at each level.                *
* INFROM    Number of  the content  a particle  has just left,  when   *
*           relevant                                                   *
* NLEVMX    Maximum number of levels in given geometry tree            *
* NLDEV     Levels where local development take place, if non 0        *
* LINMX     numbers of contents (position) or cells (division)         *
* GTRAN     X,Y,Z    offsets    of   the    cumulative    coordinate   *
*           transformation from  the master system to  the system at   *
*           each level.                                                *
* GRMAT     Rotation    matrix   elements    for   the    cumulative   *
*           transformation from  the master system to  the system at   *
*           each level.  GRMAT(10,LEVEL) equal  to 0.0 indicates the   *
*           null rotation.                                             *
* GONLY     Uniqueness flags at each level.                            *
* GLS       Current point in the local coordinates of level NLEVEL.    *
*                                                                      *
*                     The System Shapes                                *
*                     -----------------                                *
*                                                                      *
*  The system shapes supported at  present are as follows:             *
*                                                                      *
* 'BOX ' is a  box.  It has 3  parameters, the half lengths  in x, y   *
*        and z.                                                        *
* 'TRD1' is a trapezoid  with only the x length varying  with z.  It   *
*        has  4 parameters,  the  half  length in  x  at  the low  z   *
*        surface, that at  the high z surface, the half  length in y   *
*        and in z.                                                     *
* 'TRD2' is a  trapezoid with both x  and y lengths varying  with z.   *
*        It has  5 parameters,  the half  length in x  at the  low z   *
*        surface, that at  the high z surface, the half  length in y   *
*        at the low z surface, that  at the high z surface, the half   *
*        length in z.                                                  *
* 'TRAP' is  a  general trapezoid,  i.e.  one  for which  the  faces   *
*        perpendicular to z  are trapezia and their  centres are not   *
*        at the same x, y.  It has 11 parameters: Dz the half length   *
*        in z, Th & Phi the polar angles from the centre of the face   *
*        at  z=-Dz to  that at  z=+Dz, H1  the half  length in  y at   *
*        z=-Dz, LB1  the half length in  x at z=-Dz and  y=low edge,   *
*        LH1 the half length in x at z=-Dz and y= high edge, Th1 the   *
*        angle w.r.t. the  y axis from the centre of  the low y edge   *
*        to the centre of the high y edge, and H2, LB2, LH2, Th2 the   *
*        corresponding quantities to the 1s but at z=+Dz.              *
* 'TUBE' is a  tube.  It  has 3 parameters,  the inside  radius, the   *
*        outside radius and the half length in z.                      *
* 'TUBS' is a phi segment of a  tube.  It has 5 parameters, the same   *
*        3 as 'TUBE' plus the phi limits.  The segment starts at the   *
*        first limit  and includes  increasing phi  value up  to the   *
*        second limit or that plus 360 degrees.                        *
* 'CONE' is a conical tube.  It has 5 parameters, the half length in   *
*        z, the  inside and  outside radii  at the  low z  limit and   *
*        those at the high z limit.                                    *
* 'CONS' is a phi  segment of a conical tube.  It  has 7 parameters,   *
*        the same 5 as 'CONE' plus the phi limits.                     *
* 'SPHE' is a  segment of a  spherical shell.  It has  6 parameters,   *
*        the inside radius, the outside radius, the theta limits and   *
*        the phi limits.   At present, for the  drawing package only   *
*        first  two parameters  are significant  (inside radius  and   *
*        outside radius) and such a shape  is always drawn as a full   *
*        sphere.                                                       *
* 'PARA' is a parallelpiped.   It has 6 parameters,  the half length   *
*        in x, the half length in y, the half length in z, the angle   *
*        w.r.t. the y axis from the centre  of the low y edge to the   *
*        centre of the  high y edge, and the theta  phi polar angles   *
*        from the centre of the low z face to the centre of the high   *
*        z face.                                                       *
* 'PGON' is a polygon.  It has at least 10 parameters, the lower phi   *
*        limit, the range  in phi, the number of  straight sides (of   *
*        equal length)  between those  phi limits,  the number  of z   *
*        planes (at least two) where the distances to the z axis are   *
*        changing,  z  coordinate  of   first  plane,  the  shortest   *
*        distances  RMIN  & RMAX  from  the  z  axis to  the  inside   *
*        straight edge and  the outside straight edge  for the first   *
*        plane, Z, RMIN, RMAX for the second plane, and so on.         *
* 'PCON' is a polycone.  It has at least 9 parameters, the lower phi   *
*        limit, the range  in phi, the number of z  planes (at least   *
*        two) where  the radius are  changing, the z  coordinate and   *
*        the minimum and maximum radius for each z boundary.           *
* 'ELTU' is a  cylinder with  an elliptical  section.  It  has three   *
*        parameters:  the  ellipse  semi-axis   in  X,  the  ellipse   *
*        semi-axis in Y  and the half length in Z.   The equation of   *
*        the conical curve is:                                         *
*             X**2/PAR(1)**2  +  Y**2/PAR(2)**2  =  1                  *
*        ELTU is not divisible.                                        *
* 'HYPE' is a hyperbolic  tube, ie the inner and  outer surfaces are   *
*        hyperboloids, as would be formed by a system of cylindrical   *
*        wires  which were  then  rotated  tangentially about  their   *
*        centres.  The 4  parameters are the inner  and outer radii,   *
*        the  half lenght  in z,  and  the "stereo  angle" theta  in   *
*        degrees,  such that  the hyperbolic  surfaces are  given by   *
*        r**2 = (z*tan(theta))**2 + (r at z=0)**2                      *
* 'CTUB' is a cut  tube with 11 parameters.  The  first 5 parameters   *
*        are the same  as for the TUBS.  The  remaining 6 parameters   *
*        are the director  cosines of the surfaces  cutting the tube   *
*        respectively at the low and high Z values.                    *
*                                                                      *
*                  Shapes BOX,TRD1,TRD2,TRAP                           *
*                  Shapes TUBE,TUBS,CONE,CONS                          *
*                  Shapes PARA,SPHE,PGON,PCON                          *
*                  Shapes ELTU,HYPE,CTUB                               *
*                                                                      *
*              The Volume data structure JVOLUM                        *
*              --------------------------------                        *
*                                                                      *
* ISHAPE    system shape number                                        *
* NIN       number of volumes imbedded in  the mother volume.  If it   *
*           is negative then the volume is divided into slices         *
* NMED      medium number for the volume                               *
* NPAR      number of shape parameters                                 *
* NATT      number of drawing attributes                               *
* PAR       array of shape parameters                                  *
* IAT       array of drawing attributes                                *
* IAXIS     defines the direction of the  slices (1,2,3) in the case   *
*           of slice division (NIN < 0):                               *
* IVO       system volume number                                       *
* NDIV      number of slices                                           *
* C0        minimum coordinate limit                                   *
* STEP      coordinate step from slice to slice                        *
* IVO       system volume number  in the case  of  object  insertion   *
*           (NIN > 0):                                                 *
* NR        user number                                                *
* IROT      rotation matrix  number defining the  orientation of the   *
*           volume                                                     *
* X,Y,Z     define the position of the volume                          *
* KONLY     indicates  whether  it is  sufficient  to  find a  point   *
*           within  this  volume  or   whether  there  may  be  some   *
*           ambiguity with other volumes at the same level             *
*                                                                      *
*  User bits  in the bank  status word  are used with  the following   *
* meaning (the least significant bit is number 1):                     *
*                                                                      *
*  Bit       Meaning when set                                          *
*                                                                      *
*    1       Content of the volume has been ordered by GSORD           *
*    2       Content of the volume has been developed by GGDVLP        *
*    3       Volume is convex                                          *
*    4       User routines GSNEAR or GSNEXT have been called           *
*    5       Bit used to exclude a volume from the search in the       *
*            geometrical tree.                                         *
*                                                                      *
*                                                                      *
*                           | JVOLUM                                   *
* NVOLUM   IVO   IVO        v                 NVOLUM                   *
*  .............................................        (*)            *
*  |      | |   | |        | |  Volume names   |-->nlevmx              *
*  .............................................                       *
*          |     |                                                     *
*          |     v JVO = LQ(JVOLUM-IVO)       {NIN < 0}                *
*          |  ...........................................   (**)       *
*          |  | | |ishape|nin|numed|npar|natt|pars|atts.|->dev         *
*          |  ...........................................              *
*          |   |                                                       *
*          |   v JDIV=LQ(JVO-1)                                        *
*          |  .................................                        *
*          |  | | IAXIS |IVO |NDIV| C0 | STEP |                        *
*          |  .................................                        *
*          |                                                           *
*          .....                                                       *
*              |                                                       *
*     NIN IN   v  JVO = LQ(JVOLUM-IVO)      {NIN>0}                    *
* ........................................................  (**)       *
* | | |  | |  | |ishape| nin |numed|npar|natt|pars.|atts.|->dev        *
* ........................................................             *
*  | |    |                                                            *
*  | |    v   JIN = LQ(JVO-IN)                                         *
*  | | .......................................................         *
*  | | | | |-| ivo | nr |irot| x | y | z |konly|npar| pars.. |         *
*  | | .......................................................         *
*  | |  |                                                              *
*  | |  v   JNUP = LQ(JIN-1)  option GSNEXT only                       *
*  | | .............................                                   *
*  | | | | nus | in(1) ... in(nus) |                                   *
*  | | .............................                                   *
*  | |                                                                 *
*  | v   JNDW = LQ(JVO-NIN-1)       JSB = LQ(JNDW)                     *
*  |............................   .............................       *
*  || | nin | in(1) .. in(nin) | --| |IAXIS | NSB | C1..       |       *
*  |............................   .............................       *
*  |                                       option GSORD only           *
*  |                                                                   *
*  | JSC0 = LQ(JVO-NIN-2)  option GSORD only                           *
*  ..............                                                      *
*               |                                                      *
*  NSB-1  IDIV  v                      NSB-1                           *
*   ......................................                             *
*   |    | |   | | NCONT1...             |                             *
*   ......................................                             *
*         |                                                            *
*         |  JSCV = LQ(JSC0-IDIV)                                      *
*         v                      NCONT                                 *
*        ............................                                  *
*        | |  IN1...                |                                  *
*        ............................                                  *
*                                                                      *
* (*)                                                                  *
* Next of same type of JVOLUM filled in by routine GGNLEV/GGCLOS       *
* (**)                                                                 *
* Next of same type of JVO, for local development, filled in by        *
*  GGDVLP/GGCLOS                                                       *
*                                                                      *
************************************************************************
#endif
+DECK,  GGNLEV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GGNLEV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GGNLEV                                                *
C.    *                                                                *
C.    *   Scans the JVOLUM structure to find the maximum Number of     *
C.    *   LEVels and maximum number of volumes in each level.top       *
C.    *   Stores corresponding information in bank next to JVOLUM      *
C.    *   mother bank.                                                 *
C.    *                                                                *
C.    *   Called by : GGCLOS                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      PARAMETER (NLVMAX=15)
      INTEGER ILINK(NLVMAX), LJVOM(NLVMAX), NLINK(NLVMAX)
      INTEGER NDVLP(NLVMAX), MAXVO(NLVMAX)
C.
C.    ------------------------------------------------------------------
*
      CALL VZERO (MAXVO, NLVMAX)
      NLEV = 1
      NLVT = NLEV
      LJVOM(NLEV) = LQ(JVOLUM-1)
      ILINK(NLEV) = 1
      MAXVO(NLEV) = 1
*
* *** Loop over volumes going down the tree
*
   10 IF (NLEV.GT.NLVT) NLVT = NLEV
*
*  ** Check if current volume is a source of local development
*
      IF (LQ(LJVOM(NLEV)).GT.0) THEN
         NDVLP(NLEV) = NLEV
      ELSE IF (NLEV.GT.1) THEN
         NDVLP(NLEV) = NDVLP(NLEV-1)
      ELSE
         NDVLP(NLEV) = NLVMAX
      ENDIF
      NIN = Q(LJVOM(NLEV)+3)
      IF (NIN.GT.0) THEN
*
*   *    Current volume has contents defined by position
*
         NLINK(NLEV) = NIN
         IF (NIN.GT.MAXVO(NLEV+1)) MAXVO(NLEV+1) = NIN
         IF (NLINK(NLEV).EQ.0) GO TO 30
         IN   = NLINK(NLEV)
         NLINK(NLEV) = IN - 1
         JIN  = LQ(LJVOM(NLEV)-IN)
         IVOT = Q(JIN+2)
         NLEV = NLEV + 1
         LJVOM(NLEV) = LQ(JVOLUM-IVOT)
         ILINK(NLEV) = IN
         GO TO 10
*
      ELSE IF (NIN.LT.0) THEN
*
*   *    Current volume is divided
*
         JDIV = LQ(LJVOM(NLEV)-1)
         IVOT = Q(JDIV+2)
         IF (NLEV.GT.NDVLP(NLEV)) THEN
            JPAR = LQ(LJVOM(NDVLP(NLEV)))
            DO 15 ILEV = NDVLP(NLEV), NLEV-1
               IF (IQ(JPAR+1).EQ.0) THEN
                  JPAR = LQ(JPAR-ILINK(ILEV+1))
                  IF (JPAR.EQ.0) GO TO 20
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
               IF (ILEV.EQ.NLEV-1) THEN
                  NDIV = IQ(JPAR+1)
                  GO TO 25
               ENDIF
   15       CONTINUE
         ENDIF
   20    NDIV = Q(JDIV+3)
         IF (NDIV.LT.0) NDIV = -NDIV
   25    NLINK(NLEV) = 0
         IF (NDIV.GT.MAXVO(NLEV+1)) MAXVO(NLEV+1) = NDIV
         NLEV = NLEV + 1
         LJVOM(NLEV) = LQ(JVOLUM-IVOT)
         ILINK(NLEV) = 1
         GO TO 10
      ENDIF
*
*  ** No more content in this volume
*   * Go up the tree
*
   30 NLEV = NLEV - 1
      IF (NLEV.GT.0) THEN
         IF (NLINK(NLEV).EQ.0) GO TO 30
         IN   = NLINK(NLEV)
         NLINK(NLEV) = IN - 1
         JIN  = LQ(LJVOM(NLEV)-IN)
         IVOT = Q(JIN+2)
         NLEV = NLEV + 1
         LJVOM(NLEV) = LQ(JVOLUM-IVOT)
         ILINK(NLEV) = IN
         GO TO 10
      ENDIF
*
* *** Scan is complete; now store the information in next-of-same-type
*  ** link of JVOLUM
*
      JVOLX = LQ(JVOLUM)
      IF (JVOLX.GT.0) CALL MZDROP (IXCONS, JVOLX, ' ')
      CALL MZBOOK (IXCONS, JVOLX, JVOLUM, 0, 'NLEV', 0, 0, NLVT, 2, 0)
      CALL UCOPY (MAXVO, IQ(JVOLX+1), NLVT)
+SELF, IF=DEBUGG.
      IF (IDEBUG.NE.0) THEN
         WRITE (CHMAIL, 2001) NLVT
         CALL GMAIL (1, 0)
         IF (NLVT.GT.0) THEN
            WRITE (CHMAIL, 2002) (MAXVO(I), I = 1, NLVT)
            CALL GMAIL (0, 0)
         ENDIF
      ENDIF
 2001 FORMAT (' GGNLEV : Maximum number of levels = ',I4,
     +        ' -- maximum number of volumes in each level')
 2002 FORMAT (5X,20I6)
+SELF.
*                                                             END GGNLEV
      END
+DECK,  GGORD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GGORD (IVO)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    Find and order the boundaries of the contents of the       *
C.    *    IVOth volume, with respect to coordinate IAX :             *
C.    *           IAX = 1    X Axis                                   *
C.    *           IAX = 2    Y Axis                                   *
C.    *           IAX = 3    Z Axis                                   *
C.    *           IAX = 4    Rxy (static ordering only  -> GTMEDI)    *
C.    *           IAX = 14   Rxy (also dynamic ordering -> GTNEXT)    *
C.    *           IAX = 5    Rxyz (static ordering only -> GTMEDI)    *
C.    *           IAX = 15   Rxyz (also dynamic ordering -> GTNEXT)   *
C.    *           IAX = 6    PHI   (PHI=0 => X axis)                  *
C.    *           IAX = 7    THETA (THETA=0 => Z axis)                *
C.    *                                                               *
C.    *    Called by : GGCLOS                                         *
C.    *    Authors   : R.Brun, F.Bruyant, A.McPherson  *********      *
C.    *                                                               *
C.    *****************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION CLOW(500),CHIGH(500),CORD(1000),ITYPE(1000),
     +ICONT(500),ICON(1000),ICONS(500)
      DIMENSION P(100)
      EQUIVALENCE (CLOW(1),WS(1)),(CHIGH(1),WS(501))
      EQUIVALENCE (CORD(1),WS(1001)),(ITYPE(1),WS(2001))
      EQUIVALENCE (ICONT(1),WS(3001)),(ICON(1),WS(3501))
      EQUIVALENCE (ICONS(1),WS(4501)),(P(1),WS(5001))
C.
C.    ------------------------------------------------------------------
*
      JVO = LQ(JVOLUM-IVO)
      NIN = Q(JVO+3)
      IAX = -Q(JVO+1)
*
* *** Inhibit dynamic ordering in Rxy and R unless explicitly required
*     by user (ordering axis 14 or 15)
*
      IF(IAX.EQ.4.OR.IAX.EQ.5)THEN
*
* *** Only static ordering allowed, dynamic inhibited (GNEXT,GTNEXT)
*
         Q(JVO+1)=-1.
      ELSE
         Q(JVO+1)=-2.
      ENDIF
      IAX=MOD(IAX,10)
*
* *** Find the upper and lower coordinates of each content
*
      DO 50 IN = 1,NIN
         CALL GFCLIM (JVO, IN, IAX, CLOW(IN), CHIGH(IN), IERR)
         IF (IERR.NE.0) THEN
            JIN = LQ(JVO-IN)
            IVOT  = Q(JIN+2)
            IROTT = Q(JIN+4)
            INUMT = Q(JIN+3)
            Q(JVO+1) = 0.
            WRITE (CHMAIL, 1001) IQ(JVOLUM+IVOT), INUMT, IQ(JVOLUM+IVO),
     +                           IAX, IROTT
            CALL GMAIL (0, 0)
            GO TO 999
         ENDIF
   50 CONTINUE
*
* *** Order the coordinate limits, keeping track of the associated
*           content number
*
      CALL GFCORD (NIN, CLOW, CHIGH, CORD, ITYPE, ICON)
*
* *** Book the JSB bank to store the boundaries
*
      JNEAR = LQ(JVO-NIN-1)
      IF(LQ(JNEAR).EQ.0) THEN
         CALL MZBOOK (IXCONS,JSB,JNEAR,0,'VOBO',0,0,NIN*2+2,3,0)
         JVO = LQ(JVOLUM-IVO)
      ELSE
         JSB = LQ(JNEAR)
      ENDIF
      IQ(JSB-5) = IVO
*
      Q(JSB+1) = IAX
      NC = NIN*2
*
*  **   Count and load up the distinct boundaries
*
      IBO = 0
      DO 60 IC = 1,NC
         IBO = IBO +1
         Q(JSB+IBO+2) = CORD(IC)
         IF (IBO.EQ.1) GO TO 60
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) IBO = IBO -1
   60 CONTINUE
      Q(JSB+2) = IBO
      NDIV  = IBO -1
      IF (IAX.EQ.6) NDIV = IBO
*
*  **   Book the JSC0 bank to store the number of contents in each
*        section (between neighbouring boundaries)
*
      JSC0 = LQ(JVO-NIN-2)
      IF(JSC0.GT.0) THEN
         CALL MZDROP(IXCONS,JSC0,'L')
      ENDIF
      CALL MZBOOK (IXCONS,JSC0,JVO,-NIN-2,'VOBC',NDIV,NDIV,NDIV,2,0)
      IQ(JSC0-5) = IVO
*
*   *   Load up number of contents in each section and when greater
*        than 0 book and load bank of contents
*
      IDIV    = 0
      NCONT   = 1
      ICONT(1)= ICON(1)
      IF (IAX.NE.6) GO TO 70
      NCONT   = 0
      NSTOR   = 0
      ICONT(1)= 0
      DO 65 IN = 1,NIN
         IF (CHIGH(IN).GT.CLOW(IN)) GO TO 65
*           (this content straddles PHI=0.)
         NSTOR = NSTOR +1
         ICONS(NSTOR) = IN
         IF (ICON(1).EQ.IN) GO TO 65
*           (IN is in 1st division as well)
         NCONT = NCONT +1
         ICONT(NCONT) = IN
   65 CONTINUE
*
      IF (ITYPE(1).EQ.2) GO TO 70
*            (first boundary is a low, add the new content)
      NCONT = NCONT +1
      ICONT(NCONT) = ICON(1)
*
   70 CONTINUE
*
      DO 130 IC = 2,NC
         IDIV = IDIV +1
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) GO TO 90
*
*          New division, load up last division
*
         IQ(JSC0+IDIV) = NCONT
         IF (NCONT.LE.0) GO TO 100
*
*          Book bank for contents
*
         CALL MZBOOK (IXCONS,JSCV,JSC0,-IDIV,'VODC',0,0,NCONT,2,0)
         JVO = LQ(JVOLUM-IVO)
         JSC0= LQ(JVO-NIN-2)
*
*          Load up contents
*
         DO 80 ICNT = 1,NCONT
            IQ(JSCV+ICNT) = ICONT(ICNT)
   80    CONTINUE
*
         GO TO 100
   90    CONTINUE
         IDIV = IDIV -1
*
  100    CONTINUE
*
*         Update contents of current division
*
         IF (ITYPE(IC).EQ.1) GO TO 120
*
*         This boundary was a high, so one less content
*
         ICP = 0
         DO 110 ICNT = 1,NCONT
            IF (ICONT(ICNT).EQ.ICON(IC)) ICP=1
         IF (ICP.EQ.1) ICONT(ICNT) = ICONT(ICNT+1)
  110    CONTINUE
         NCONT = NCONT -1
         GO TO 130
*
  120    CONTINUE
*
*          This boundary was a low, so one extra content
*
         NCONT = NCONT +1
         ICONT(NCONT) = ICON(IC)
*
  130 CONTINUE
*
      IF (IAX.NE.6) GO TO 150
      IQ(JSC0+NDIV) = NSTOR
      IF (NSTOR.EQ.0) GO TO 150
      CALL MZBOOK (IXCONS,JSCV,JSC0,-NDIV,'VOID',0,0,NSTOR,2,0)
*
      DO 140 IS = 1,NSTOR
         IQ(JSCV+IS) = ICONS(IS)
  140 CONTINUE
      JVO  = LQ(JVOLUM-IVO)
      JSC0 = LQ(JVO-NIN-2)
  150 CONTINUE
      DO 159 I = 1,NDIV
         IF (IQ(JSC0+I).GT.1) GO TO 999
  159 CONTINUE
      IQ(JSC0) = IBSET(IQ(JSC0),0)
*
 1001 FORMAT (' GGORD : Error in GFCLIM for content ',A4,I7,' in ',A4,
     +         ' along axis',I5,' IROT= ',I5)
*                                                              END GGORD
  999 END

+DECK,  GGORDQ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:49  cernlib
* Geant

      SUBROUTINE GGORDQ (IVO)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    Find and order the boundaries of the contents of the       *
C.    *    IVOth volume, with respect to coordinate IAX :             *
C.    *           IAX = 1    X Axis                                   *
C.    *           IAX = 2    Y Axis                                   *
C.    *           IAX = 3    Z Axis                                   *
C.    *           IAX = 4    Rxy                                      *
C.    *           IAX = 5    Rxyz                                     *
C.    *           IAX = 6    PHI   (PHI=0 => X axis)                  *
C.    *           IAX = 7    THETA (THETA=0 => Z axis)                *
C.    *    All values of IAX will be tried and then that value is     *
C.    *    chosen, that results in the smallest number of volumes per *
C.    *    division.                                                  *
C.    *    Called by : GGCLOS                                         *
C.    *    Author: Stephan Egli (large parts are copies of GGORD)     *
C.    *                                                               *
C.    *****************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
*

      DIMENSION CLOW(500),CHIGH(500),CORD(1000),ITYPE(1000),
     +ICONT(500),ICON(1000),ICONS(500)
      EQUIVALENCE (CLOW(1),WS(1)),(CHIGH(1),WS(501))
      EQUIVALENCE (CORD(1),WS(1001)),(ITYPE(1),WS(2001))
      EQUIVALENCE (ICONT(1),WS(3001)),(ICON(1),WS(3501))
      EQUIVALENCE (ICONS(1),WS(4501))
C
      CHARACTER*4 NAME

C.    ------------------------------------------------------------------
*
      JVO = LQ(JVOLUM-IVO)
      CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
      NIN = Q(JVO+3)
      IAXNOW = 0
      IF(IQ(JVO-2).EQ.NIN+2) THEN
*
* *** This is to allow re-entry in the routine from the interactive
* *** version.
         JNEAR = LQ(JVO-NIN-1)
         IF(JNEAR.GT.0) THEN
            JSB = LQ(JNEAR)
            IF(JSB.GT.0) THEN
               IAXNOW = Q(JSB+1)
            ENDIF
         ENDIF
      ENDIF
      IF(IAXNOW.EQ.0) THEN
         IAXNOW=-Q(JVO+1)
      ENDIF
*   assume that ordering can not be done unless proven otherwise
      Q(JVO+1)=0.
      RBEST=1.E9

* try all possible axes

      DO 1 IAX=1,7

*   count number of additional words needed and total number of volumes
*   in all divisions

      NCOALL=0
*
* *** Find the upper and lower coordinates of each content
*
      DO 50 IN = 1,NIN
         CALL GFCLIM (JVO, IN, IAX, CLOW(IN), CHIGH(IN), IERR)
         IF (IERR.NE.0) GOTO 1
   50 CONTINUE
*
* *** Order the coordinate limits, keeping track of the associated
*           content number
*
      CALL GFCORD (NIN, CLOW, CHIGH, CORD, ITYPE, ICON)
      NC = NIN*2
*
*  **   Count and load up the distinct boundaries
*
      IBO = 0
      DO 60 IC = 1,NC
         IBO = IBO +1
         IF (IBO.EQ.1) GO TO 60
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) IBO = IBO -1
   60 CONTINUE
      NDIV  = IBO -1
      IF (IAX.EQ.6) NDIV = IBO

*   *   Load up number of contents in each section
*
      IDIV    = 0
      NCONT   = 1
      ICONT(1)= ICON(1)
      IF (IAX.NE.6) GO TO 70
      NCONT   = 0
      NSTOR   = 0
      ICONT(1)= 0
      DO 65 IN = 1,NIN
         IF (CHIGH(IN).GT.CLOW(IN)) GO TO 65
*           (this content straddles PHI=0.)
         NSTOR = NSTOR +1
         ICONS(NSTOR) = IN
         IF (ICON(1).EQ.IN) GO TO 65
*           (IN is in 1st division as well)
         NCONT = NCONT +1
         ICONT(NCONT) = IN
   65 CONTINUE
*
      IF (ITYPE(1).EQ.2) GO TO 70
*            (first boundary is a low, add the new content)
      NCONT = NCONT +1
      ICONT(NCONT) = ICON(1)
*
   70 CONTINUE
*
      DO 130 IC = 2,NC
         IDIV = IDIV +1
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) GO TO 90
*
*          New division, load up last division
*
         IF (NCONT.LE.0) GO TO 100
         NCOALL=NCOALL+NCONT
         GO TO 100
   90    CONTINUE
         IDIV = IDIV -1
*
  100    CONTINUE
*
*         Update contents of current division
*
         IF (ITYPE(IC).EQ.1) GO TO 120
*
*         This boundary was a high, so one less content
*
         ICP = 0
         DO 110 ICNT = 1,NCONT
            IF (ICONT(ICNT).EQ.ICON(IC)) ICP=1
         IF (ICP.EQ.1) ICONT(ICNT) = ICONT(ICNT+1)
  110    CONTINUE
         NCONT = NCONT -1
         GO TO 130
*
  120    CONTINUE
*
*          This boundary was a low, so one extra content
*
         NCONT = NCONT +1
         ICONT(NCONT) = ICON(IC)
*
  130 CONTINUE
*
      IF(IAX.EQ.6) NCOALL = NCOALL+NSTOR
      RNOW=FLOAT(NCOALL)/NDIV
      IF(RNOW.LT.RBEST)THEN
        IAXOPT=IAX
        RBEST=RNOW
        NDIVB=NDIV
      ENDIF

* end of loop over IAX

1     CONTINUE


* now the best axis is selected - compare with axis requested by CALL
* to GSORD (if any)

      IF(IAXNOW.GT.0)THEN

        WRITE (CHMAIL,1002) NAME,NIN,IAXOPT,NDIVB,RBEST,IAXNOW
        CALL  GMAIL (0, 0)
 1002   FORMAT(' GGORDQ : Volume ',A4,2X,'NIN=',I4,' IAX=',I2,2X,
     +    'NDIV=',I3,2X,'NVOL/DIV=',F5.1,2X,'IAX wanted by user:',I2)

      ELSE

        WRITE (CHMAIL,1003) NAME,NIN,IAXOPT,NDIVB,RBEST
        CALL  GMAIL (0, 0)
 1003   FORMAT(' GGORDQ : Volume ',A4,2X,'NIN=',I4,' IAX=',I2,2X,
     +    'NDIV=',I3,2X,'NVOL/DIV=',F5.1)

      ENDIF

* overwrite old axis and store sorting information for new axis

      Q(JVO+1)=-IAXOPT
      CALL GGORD(IVO)

      END
+DECK,  GGPERP, T=FORT.
* Revision 1.2  1999/11/05 09:53:25  japost
*    Effectively print the message when a shape is not implemented.
*                                      Contributed by Federico Carminati
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GGPERP (X,U,IERR)
C.
C.    ****************************************************************
C.    *                                                              *
C.    *  This routine solves the general problem of calculating the  *
C.    *  unit vector normal to the surface of the current volume at  *
C.    *  the point X. The result is returned in the array U.  X is   *
C.    *  assumed to be on or near a boundary of the current volume.  *
C.    *  The current volume is indicated by the common /GCVOLU/.     *
C.    *  U points from inside to outside in that neighbourhood.      *
C.    *  If X is equidistant to more than one boundary (in a corner) *
C.    *  an arbitrary choice is made based upon the order of         *
C.    *  precedence implied by the IF statements below.  If the      *
C.    *  routine fails to find the unit normal, it returns with      *
C.    *  IERR=1, otherwise IERR=0.                                   *
C.    *                                                              *
C.    *   Called by : GSURFP, GDSTEP                                 *
C.    *   Authors   : F.Carminati, R.Jones, F.Ohlsson-Malek          *
C.    *                                                              *
C.    ****************************************************************
+CDE, GCVOLU.
+CDE, GCONSP.
+CDE, GCBANK.
+CDE, GCSHNO.
+CDE, GCTMED.
+CDE, GCUNIT.
      DIMENSION X(3),U(3),XL(3),UL(3),DXL(3),PAR(50),SPAR(50),ATT(20)
      DIMENSION PERP(10)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION PERP,PMIN0
      DOUBLE PRECISION PAR,DXL,RHO,R,RINV,PHI,THE
      DOUBLE PRECISION PHI1,PHI2,THE1,THE2,XWID
      DOUBLE PRECISION GUARD,DPHI,PHI0,SPHI0,CPHI0
      DOUBLE PRECISION FACT,CALPH,SALPH,TALPH
      DOUBLE PRECISION RAT,RATL,RATH,H,BL,TL,DX,DY,DZ,DU
      DOUBLE PRECISION UU0,VV0,UU,W1,W2,W3,W4
      DOUBLE PRECISION SEW1,SEW2,SEW3,SEW4
      DOUBLE PRECISION TAN1,TAN2,TAN3,TAN4
      DOUBLE PRECISION SEC1,SEC2,SEC3,SEC4
      DOUBLE PRECISION U0,V0,U1,U1L,U2,U2L
      DOUBLE PRECISION ONE,TWO
      DOUBLE PRECISION DSECT,ZERO,FULL,FULL10,DBY2
+SELF.
      LOGICAL LNTFOU
      PARAMETER (ONE=1,TWO=2)
      PARAMETER (ZERO=0.,DBY2=0.5,FULL=360.,FULL10=3600.)
C.
C.    ------------------------------------------------------------------
C.
      LNTFOU = .FALSE.
*
* *** Transform current point into local reference system
      CALL GMTOD(X,XL,1)
      DXL(1) = XL(1)
      DXL(2) = XL(2)
      DXL(3) = XL(3)
*
* *** Fetch the parameters of the current volume
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IN = LINDEX(NLEVEL)
      IF (NLEVEL.GT.1) THEN
        JVOM = LQ(JVOLUM-LVOLUM(NLEVEL-1))
        JIN = LQ(JVOM-IN)
      ENDIF
      ISH = Q(JVO+2)
      NIN = Q(JVO+3)
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
        JPAR = 0
      ELSE
*     (case with structure JVOLUM locally developed)
        JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
        IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 20
        DO 10  ILEV = NLDEV(NLEVEL), NLEVEL-1
          IF (IQ(JPAR+1).EQ.0) THEN
            JPAR = LQ(JPAR-LINDEX(ILEV+1))
            IF (JPAR.EQ.0) GO TO 20
          ELSE IF (IQ(JPAR-3).GT.1) THEN
            JPAR = LQ(JPAR-LINDEX(ILEV+1))
          ELSE
            JPAR = LQ(JPAR-1)
          ENDIF
          IF (ILEV.EQ.NLEVEL-1) THEN
            JPAR = JPAR + 5
            NPAR = IQ(JPAR)
            CALL UCOPY (Q(JPAR+1), SPAR, NPAR)
            DO 100 I=1,NPAR
                PAR(I)=SPAR(I)
  100       CONTINUE
          ENDIF
   10   CONTINUE
        GO TO 30
      ENDIF
*     (normal case)
   20 CONTINUE
      CALL GFIPAR(JVO,JIN,IN,NPAR,NATT,SPAR,ATT)
      DO 101 I=1,NPAR
           PAR(I)=SPAR(I)
  101 CONTINUE
   30 CONTINUE
*
* *** Case of the BOX:
      IF (ISH.EQ.NSBOX) THEN
        PERP(1) = ABS(ABS(DXL(1))-PAR(1))
        PERP(2) = ABS(ABS(DXL(2))-PAR(2))
        PERP(3) = ABS(ABS(DXL(3))-PAR(3))
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3))
        IF (PERP(1).EQ.PMIN0) THEN
          UL(1) = SIGN(ONE,DXL(1))
          UL(2) = 0.
          UL(3) = 0.
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = SIGN(ONE,DXL(2))
          UL(3) = 0.
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = SIGN(ONE,DXL(3))
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the TUBE, TUBeSection:
      ELSE IF (ISH.EQ.NSTUBE.OR.ISH.EQ.NSTUBS) THEN
        RHO = SQRT(DXL(1)**2 + DXL(2)**2)
        PERP(1) = ABS(RHO-PAR(1))
        PERP(2) = ABS(RHO-PAR(2))
        PERP(3) = ABS(ABS(DXL(3))-PAR(3))
        IF (ISH.EQ.NSTUBE) THEN
          PMIN0 = MIN(PERP(1),PERP(2),PERP(3))
        ELSE
          PHI = ATAN2(DXL(2),DXL(1))
          IF (PHI.LT.0.) PHI = PHI+TWOPI
          PHI1 = MOD(PAR(4)+FULL10,FULL)*DEGRAD
          PERP(4) = ABS(PHI-PHI1)
          IF (PERP(4).GT.PI) PERP(4) = TWOPI-PERP(4)
          PHI2 = MOD(PAR(5)+FULL10,FULL)*DEGRAD
          PERP(5) = ABS(PHI-PHI2)
          IF (PERP(5).GT.PI) PERP(5) = TWOPI-PERP(5)
          PERP(4) = PERP(4)*RHO
          PERP(5) = PERP(5)*RHO
          PMIN0 = MIN(PERP(1),PERP(2),PERP(3),PERP(4),PERP(5))
        ENDIF
        IF (PERP(1).EQ.PMIN0) THEN
          UL(1) = -DXL(1)/RHO
          UL(2) = -DXL(2)/RHO
          UL(3) = 0.
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          UL(1) = DXL(1)/RHO
          UL(2) = DXL(2)/RHO
          UL(3) = 0.
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = SIGN(ONE,DXL(3))
        ELSE IF (PERP(4).EQ.PMIN0) THEN
          UL(1) = SIN(PHI1)
          UL(2) = -COS(PHI1)
          UL(3) = 0.
        ELSE IF (PERP(5).EQ.PMIN0) THEN
          UL(1) = -SIN(PHI2)
          UL(2) = COS(PHI2)
          UL(3) = 0.
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the CONE, CONeSection:
      ELSE IF (ISH.EQ.NSCONE.OR.ISH.EQ.NSCONS) THEN
        RHO  = SQRT(DXL(1)**2 + DXL(2)**2)
        TAN1 = (PAR(4)-PAR(2))/(TWO*PAR(1))
        SEC1 = SQRT(ONE+TAN1**2)
        U1   = RHO-DXL(3)*TAN1
        U1L  = PAR(4)-PAR(1)*TAN1
        TAN2 = (PAR(5)-PAR(3))/(TWO*PAR(1))
        SEC2 = SQRT(ONE+TAN2**2)
        U2   = RHO-DXL(3)*TAN2
        U2L  = PAR(5)-PAR(1)*TAN2
        PERP(1) = ABS(ABS(DXL(3))-PAR(1))
        PERP(2) = ABS(U1-U1L)/SEC1
        PERP(3) = ABS(U2-U2L)/SEC2
        IF (ISH.EQ.NSCONE) THEN
          PMIN0 = MIN(PERP(1),PERP(2),PERP(3))
        ELSE
          PHI = ATAN2(DXL(2),DXL(1))
          IF (PHI.LT.0.) PHI = PHI+TWOPI
          PHI1 = MOD(PAR(6)+FULL10,FULL)*DEGRAD
          PERP(4) = ABS(PHI-PHI1)
          IF (PERP(4).GT.PI) PERP(4) = TWOPI-PERP(4)
          PHI2 = MOD(PAR(7)+FULL10,FULL)*DEGRAD
          PERP(5) = ABS(PHI-PHI2)
          IF (PERP(5).GT.PI) PERP(5) = TWOPI-PERP(5)
          PERP(4) = PERP(4)*RHO
          PERP(5) = PERP(5)*RHO
          PMIN0 = MIN(PERP(1),PERP(2),PERP(3),PERP(4),PERP(5))
        ENDIF
        IF (PERP(1).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = SIGN(ONE,DXL(3))
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          RHO = RHO*SEC1
          UL(1) = -DXL(1)/RHO
          UL(2) = -DXL(2)/RHO
          UL(3) = TAN1/SEC1
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          RHO = RHO*SEC2
          UL(1) = DXL(1)/RHO
          UL(2) = DXL(2)/RHO
          UL(3) = -TAN2/SEC2
        ELSE IF (PERP(4).EQ.PMIN0) THEN
          UL(1) = SIN(PHI1)
          UL(2) = -COS(PHI1)
          UL(3) = 0.
        ELSE IF (PERP(5).EQ.PMIN0) THEN
          UL(1) = -SIN(PHI2)
          UL(2) = COS(PHI2)
          UL(3) = 0.
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the PolyCONe:
      ELSE IF (ISH.EQ.NSPCON) THEN
        PERP(1) = ABS(DXL(3)-PAR(4))
        DO 400 I=7,NPAR,3
          PERP(2) = ABS(DXL(3)-PAR(I))
          IF (PERP(2).GT.PERP(1)) GOTO 401
          PERP(1) = PERP(2)
  400   CONTINUE
  401   I = I-3
        IF (I.GT.4) THEN
          PERP(1) = 100.
          RHO  = SQRT(DXL(1)**2 + DXL(2)**2)
          DZ   = PAR(I)-PAR(I-3)+1.e-10
          TAN1 = (PAR(I+1)-PAR(I-2))/DZ
          SEC1 = SQRT(ONE+TAN1**2)
          U1   = RHO-DXL(3)*TAN1
          U1L  = PAR(I+1)-PAR(I)*TAN1
          TAN2 = (PAR(I+2)-PAR(I-1))/DZ
          SEC2 = SQRT(ONE+TAN2**2)
          U2   = RHO-DXL(3)*TAN2
          U2L  = PAR(I+2)-PAR(I)*TAN2
          GUARD = MAX(DXL(3)-PAR(I),ZERO)
          PERP(3) = ABS(U1-U1L)/SEC1 + GUARD*SEC1
          PERP(4) = ABS(U2-U2L)/SEC2 + GUARD*SEC2
        ELSE
          PERP(3) = 100.
          PERP(4) = 100.
        ENDIF
        IF (I.LT.NPAR-2) THEN
          PERP(2) = 100.
          RHO = SQRT(DXL(1)**2 + DXL(2)**2)
          DZ  = PAR(I+3)-PAR(I)+1.e-10
          TAN3 = (PAR(I+4)-PAR(I+1))/DZ
          SEC3 = SQRT(ONE+TAN3**2)
          U1   = RHO-DXL(3)*TAN3
          U1L  = PAR(I+1)-PAR(I)*TAN3
          TAN4 = (PAR(I+5)-PAR(I+2))/DZ
          SEC4 = SQRT(ONE+TAN4**2)
          U2   = RHO-DXL(3)*TAN4
          U2L  = PAR(I+2)-PAR(I)*TAN4
          GUARD = MAX(PAR(I)-DXL(3),ZERO)
          PERP(5) = ABS(U1-U1L)/SEC3 + GUARD*SEC3
          PERP(6) = ABS(U2-U2L)/SEC4 + GUARD*SEC4
        ELSE
          PERP(5) = 100.
          PERP(6) = 100.
        ENDIF
        PHI = ATAN2(DXL(2),DXL(1))
        IF (PHI.LT.0.) PHI = PHI+TWOPI
        PHI1 = MOD(PAR(1)+FULL10,FULL)*DEGRAD
        PERP(7) = ABS(PHI-PHI1)
        IF (PERP(7).GT.PI) PERP(7) = TWOPI-PERP(7)
        PHI2 = MOD(PAR(1)+PAR(2)+FULL10,FULL)*DEGRAD
        PERP(8) = ABS(PHI-PHI2)
        IF (PERP(8).GT.PI) PERP(8) = TWOPI-PERP(8)
        PERP(7) = PERP(7)*RHO
        PERP(8) = PERP(8)*RHO
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3),PERP(4),
     +             PERP(5),PERP(6),PERP(7),PERP(8))
        IF (PERP(1).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = -1.
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = 1.
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          RHO = RHO*SEC1
          UL(1) = -DXL(1)/RHO
          UL(2) = -DXL(2)/RHO
          UL(3) = TAN1/SEC1
        ELSE IF (PERP(4).EQ.PMIN0) THEN
          RHO = RHO*SEC2
          UL(1) = DXL(1)/RHO
          UL(2) = DXL(2)/RHO
          UL(3) = -TAN2/SEC2
        ELSE IF (PERP(5).EQ.PMIN0) THEN
          RHO = RHO*SEC3
          UL(1) = -DXL(1)/RHO
          UL(2) = -DXL(2)/RHO
          UL(3) = TAN3/SEC3
        ELSE IF (PERP(6).EQ.PMIN0) THEN
          RHO = RHO*SEC4
          UL(1) = DXL(1)/RHO
          UL(2) = DXL(2)/RHO
          UL(3) = -TAN4/SEC4
        ELSE IF (PERP(7).EQ.PMIN0) THEN
          UL(1) = SIN(PHI1)
          UL(2) = -COS(PHI1)
          UL(3) = 0.
        ELSE IF (PERP(8).EQ.PMIN0) THEN
          UL(1) = -SIN(PHI2)
          UL(2) = COS(PHI2)
          UL(3) = 0.
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the PolyGON:
      ELSE IF (ISH.EQ.NSPGON) THEN
        RHO = SQRT(DXL(1)**2+DXL(2)**2)
        PHI = ATAN2(DXL(2),DXL(1))
        IF (PHI.LT.0.) PHI = PHI+TWOPI
        DPHI = MOD(PHI*RADDEG-PAR(1)+FULL10,FULL)
        PDIV = PAR(2)/PAR(3)
        DSECT = INT(DPHI/PDIV + ONE)
        IF (DSECT.GT.PAR(3)) THEN
          IF (DPHI.GT.(180.+PAR(2)*DBY2)) THEN
            DSECT = ONE
          ELSE
            DSECT = PAR(3)
          ENDIF
        ENDIF
        PHI0 = MOD(PAR(1)+(DSECT-DBY2)*PDIV+FULL10,FULL)*DEGRAD
        SPHI0 = SIN(PHI0)
        CPHI0 = COS(PHI0)
        U0 = DXL(1)*CPHI0 + DXL(2)*SPHI0
        V0 = DXL(2)*CPHI0 - DXL(1)*SPHI0
        PERP(1) = ABS(DXL(3)-PAR(5))
        DO 500 I=8,NPAR,3
          PERP(2) = ABS(DXL(3)-PAR(I))
          IF (PERP(2).GT.PERP(1)) GOTO 501
          PERP(1) = PERP(2)
  500   CONTINUE
  501   I = I-3
        IF (I.GT.5) THEN
          PERP(1) = 100.
          DZ   = PAR(I)-PAR(I-3)+1.e-10
          TAN1 = (PAR(I+1)-PAR(I-2))/DZ
          SEC1 = SQRT(ONE+TAN1**2)
          U1   = U0-DXL(3)*TAN1
          U1L  = PAR(I+1)-PAR(I)*TAN1
          TAN2 = (PAR(I+2)-PAR(I-1))/DZ
          SEC2 = SQRT(ONE+TAN2**2)
          U2   = U0-DXL(3)*TAN2
          U2L  = PAR(I+2)-PAR(I)*TAN2
          GUARD = MAX(DXL(3)-PAR(I),ZERO)
          PERP(3) = ABS(U1-U1L)/SEC1 + GUARD*SEC1
          PERP(4) = ABS(U2-U2L)/SEC2 + GUARD*SEC2
        ELSE
          PERP(3) = 100.
          PERP(4) = 100.
        ENDIF
        IF (I.LT.NPAR-2) THEN
          PERP(2) = 100.
          DZ   = PAR(I+3)-PAR(I)+1.e-10
          TAN3 = (PAR(I+4)-PAR(I+1))/DZ
          SEC3 = SQRT(ONE+TAN3**2)
          U1   = U0-DXL(3)*TAN3
          U1L  = PAR(I+1)-PAR(I)*TAN3
          TAN4 = (PAR(I+5)-PAR(I+2))/DZ
          SEC4 = SQRT(ONE+TAN4**2)
          U2   = U0-DXL(3)*TAN4
          U2L  = PAR(I+2)-PAR(I)*TAN4
          GUARD = MAX(PAR(I)-DXL(3),ZERO)
          PERP(5) = ABS(U1-U1L)/SEC3 + GUARD*SEC3
          PERP(6) = ABS(U2-U2L)/SEC4 + GUARD*SEC4
        ELSE
          PERP(5) = 100.
          PERP(6) = 100.
        ENDIF
        PHI1 = MOD(PAR(1)+FULL10,FULL)*DEGRAD
        PERP(7) = ABS(PHI-PHI1)
        IF (PERP(7).GT.PI) PERP(7) = TWOPI-PERP(7)
        PHI2 = MOD(PAR(1)+PAR(2)+FULL10,FULL)*DEGRAD
        PERP(8) = ABS(PHI-PHI2)
        IF (PERP(8).GT.PI) PERP(8) = TWOPI-PERP(8)
        PERP(7) = PERP(7)*RHO
        PERP(8) = PERP(8)*RHO
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3),PERP(4),
     +             PERP(5),PERP(6),PERP(7),PERP(8))
        IF (PERP(1).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = -1.
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = 1.
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          FACT = ONE/SEC1
          UL(1) = -CPHI0*FACT
          UL(2) = -SPHI0*FACT
          UL(3) = TAN1*FACT
        ELSE IF (PERP(4).EQ.PMIN0) THEN
          FACT = ONE/SEC2
          UL(1) = CPHI0*FACT
          UL(2) = SPHI0*FACT
          UL(3) = -TAN2*FACT
        ELSE IF (PERP(5).EQ.PMIN0) THEN
          FACT = ONE/SEC3
          UL(1) = -CPHI0*FACT
          UL(2) = -SPHI0*FACT
          UL(3) = TAN3*FACT
        ELSE IF (PERP(6).EQ.PMIN0) THEN
          FACT = ONE/SEC4
          UL(1) = CPHI0*FACT
          UL(2) = SPHI0*FACT
          UL(3) = -TAN4*FACT
        ELSE IF (PERP(7).EQ.PMIN0) THEN
          UL(1) = SIN(PHI1)
          UL(2) = -COS(PHI1)
          UL(3) = 0.
        ELSE IF (PERP(8).EQ.PMIN0) THEN
          UL(1) = -SIN(PHI2)
          UL(2) = COS(PHI2)
          UL(3) = 0.
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the SPHEre:
      ELSE IF (ISH.EQ.NSSPHE) THEN
        R = SQRT(DXL(1)**2+DXL(2)**2+DXL(3)**2)
        RHO = SQRT(DXL(1)**2+DXL(2)**2)
        THE = ATAN2(RHO,DXL(3))
        PHI = ATAN2(DXL(2),DXL(1))
        IF (PHI.LT.0.) PHI = PHI+TWOPI
        THE1 = MOD(PAR(3)+FULL10,FULL)*DEGRAD
        THE2 = MOD(PAR(4)+FULL10,FULL)*DEGRAD
        PHI1 = MOD(PAR(5)+FULL10,FULL)*DEGRAD
        PHI2 = MOD(PAR(6)+FULL10,FULL)*DEGRAD
        PERP(1) = ABS(R-PAR(1))
        PERP(2) = ABS(R-PAR(2))
        PERP(3) = ABS(THE-THE1)*R
        PERP(4) = ABS(THE-THE2)*R
        PERP(5) = ABS(PHI-PHI1)
        IF (PERP(5).GT.PI) PERP(5) = TWOPI-PERP(5)
        PERP(5) = PERP(5)*RHO
        PERP(6) = ABS(PHI-PHI2)
        IF (PERP(6).GT.PI) PERP(6) = TWOPI-PERP(6)
        PERP(6) = PERP(6)*RHO
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3),PERP(4),PERP(5),PERP(6))
        IF (PERP(1).EQ.PMIN0) THEN
          RINV = ONE/R
          UL(1) = -DXL(1)*RINV
          UL(2) = -DXL(2)*RINV
          UL(3) = -DXL(3)*RINV
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          RINV = ONE/R
          UL(1) = DXL(1)*RINV
          UL(2) = DXL(2)*RINV
          UL(3) = DXL(3)*RINV
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          UL(1) = -COS(THE1)*COS(PHI)
          UL(2) = -COS(THE1)*SIN(PHI)
          UL(3) = +SIN(THE1)
        ELSE IF (PERP(4).EQ.PMIN0) THEN
          UL(1) = +COS(THE2)*COS(PHI)
          UL(2) = +COS(THE2)*SIN(PHI)
          UL(3) = -SIN(THE2)
        ELSE IF (PERP(5).EQ.PMIN0) THEN
          UL(1) = +SIN(PHI1)
          UL(2) = -COS(PHI1)
          UL(3) = 0
        ELSE IF (PERP(6).EQ.PMIN0) THEN
          UL(1) = -SIN(PHI2)
          UL(2) = +COS(PHI2)
          UL(3) = 0
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the PARAllelpiped:
***************************************************************
*  Warning:  the parameters for this shape are NOT stored in  *
*  the data structure as the user supplies them.  Rather, the *
*  user supplies PAR(4)=alph, PAR(5)=the, PAR(6)=phi, and the *
*  data structure contains PAR(4)=Tan(alph), PAR(5)=Tan(the)* *
*  Cos(phi), PAR(6)=Tan(the)*Sin(phi).                        *
***************************************************************
      ELSE IF (ISH.EQ.NSPARA) THEN
        DX = PAR(5)
        DY = PAR(6)
        U0 = DXL(1)-DX*DXL(3)
        V0 = DXL(2)-DY*DXL(3)
        CALPH = ONE/SQRT(ONE+PAR(4)**2)
        SALPH = -CALPH*PAR(4)
        U1 = U0*CALPH+V0*SALPH
        U1L = PAR(1)*CALPH
        PERP(1) = ABS(ABS(U1)-U1L)
        PERP(2) = ABS(ABS(V0)-PAR(2))
        PERP(3) = ABS(ABS(DXL(3))-PAR(3))
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3))
        IF (PERP(1).EQ.PMIN0) THEN
          DU = DX*CALPH+DY*SALPH
          FACT = SIGN(ONE/SQRT(ONE+DU**2),U1)
          UL(1) = CALPH*FACT
          UL(2) = SALPH*FACT
          UL(3) = -DU*FACT
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          FACT = SIGN(ONE/SQRT(ONE+DY**2),V0)
          UL(1) = 0.
          UL(2) = FACT
          UL(3) = -DY*FACT
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = SIGN(ONE,DXL(3))
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the trapezoid TRD1
      ELSE IF (ISH.EQ.NSTRD1) THEN
        DZ   = TWO*PAR(4)+1.e-10
        TAN1 = (PAR(2)-PAR(1))/DZ
        SEC1 = SQRT(ONE+TAN1**2)
        U1   = ABS(DXL(1))-DXL(3)*TAN1
        U1L  = PAR(2)-PAR(4)*TAN1
        PERP(1) = ABS(U1-U1L)/SEC1
        PERP(2) = ABS(ABS(DXL(2))-PAR(3))
        PERP(3) = ABS(ABS(DXL(3))-PAR(4))
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3))
        IF (PERP(1).EQ.PMIN0) THEN
          FACT = ONE/SEC1
          UL(1) = SIGN(FACT,DXL(1))
          UL(2) = 0.
          UL(3) = -TAN1*FACT
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = SIGN(ONE,DXL(2))
          UL(3) = 0.
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = SIGN(ONE,DXL(3))
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the trapezoid TRD2
      ELSE IF (ISH.EQ.NSTRD2) THEN
        DZ   = TWO*PAR(5)+1.e-10
        TAN1 = (PAR(2)-PAR(1))/DZ
        SEC1 = SQRT(ONE+TAN1**2)
        U1   = ABS(DXL(1))-DXL(3)*TAN1
        U1L  = PAR(2)-PAR(5)*TAN1
        TAN2 = (PAR(4)-PAR(3))/DZ
        SEC2 = SQRT(ONE+TAN2**2)
        U2   = ABS(DXL(2))-DXL(3)*TAN2
        U2L  = PAR(4)-PAR(5)*TAN2
        PERP(1) = ABS(U1-U1L)/SEC1
        PERP(2) = ABS(U2-U2L)/SEC2
        PERP(3) = ABS(ABS(DXL(3))-PAR(5))
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3))
        IF (PERP(1).EQ.PMIN0) THEN
          FACT = ONE/SEC1
          UL(1) = SIGN(FACT,DXL(1))
          UL(2) = 0.
          UL(3) = -TAN1*FACT
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          FACT = ONE/SEC2
          UL(1) = 0.
          UL(2) = SIGN(FACT,DXL(2))
          UL(3) = -TAN2*FACT
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = SIGN(ONE,DXL(3))
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** Case of the TRAPezoid
***************************************************************
*  Warning:  the parameters for this shape are NOT stored in  *
*  the data structure as the user supplies them.  Rather, the *
*  user supplies PAR(2)=thet, PAR(3)=phi, PAR(7)=alp1, and    *
*  PAR(11)=alp2, while the data structure contains PAR(2)=    *
*  Tan(thet)*Cos(phi), PAR(3)=Tan(thet)*Sin(phi), PAR(7)=     *
*  Tan(alp1), and PAR(11)=Tan(alp2).                          *
***************************************************************
      ELSE IF (ISH.EQ.NSTRAP) THEN
        PERP(1) = ABS(ABS(DXL(3))-PAR(1))
        DX = PAR(2)
        DY = PAR(3)
        U0 = DX*DXL(3)
        V0 = DY*DXL(3)
        UU0 = DX*PAR(1)
        VV0 = DY*PAR(1)
        RAT = DXL(3)/PAR(1)
        RATL = (ONE-RAT)/TWO
        RATH = (ONE+RAT)/TWO
        H = PAR(4)*RATL+PAR(8)*RATH
        BL = PAR(5)*RATL+PAR(9)*RATH
        TL = PAR(6)*RATL+PAR(10)*RATH
        TALPH = PAR(7)*RATL+PAR(11)*RATH
        XWID = (TL+BL)/TWO
        TAN1 = TALPH+(TL-BL)/(TWO*H)
        SEC1 = SQRT(ONE+TAN1**2)
        U1 = DXL(1)-DXL(2)*TAN1
        U1L = U0+XWID-V0*TAN1
        TAN2 = TAN1-TWO*TALPH
        SEC2 = SQRT(ONE+TAN2**2)
        U2 = DXL(1)+DXL(2)*TAN2
        U2L = U0-XWID+V0*TAN2
        IF (DXL(3).LT.0) THEN
          DZ = PAR(1)-DXL(3)+1.e-10
          UU = UU0+(PAR(9)+PAR(10))/TWO
          W1 = (UU-VV0*TAN1-U1L)/DZ
          UU = TWO*UU0-UU
          W2 = (UU+VV0*TAN2-U2L)/DZ
        ELSE
          DZ = -PAR(1)-DXL(3)+1.e-10
          UU = -UU0+(PAR(5)+PAR(6))/TWO
          W1 = (UU+VV0*TAN1-U1L)/DZ
          UU = -TWO*UU0-UU
          W2 = (UU-VV0*TAN2-U2L)/DZ
        ENDIF
        W3 = DY+(PAR(8)-PAR(4))/(TWO*PAR(1))
        W4 = TWO*DY-W3
        SEW1 = SQRT(ONE+W1**2)
        SEW2 = SQRT(ONE+W2**2)
        SEW3 = SQRT(ONE+W3**2)
        SEW4 = SQRT(ONE+W4**2)
        PERP(2) = ABS(U1-U1L)/(SEC1*SEW1)
        PERP(3) = ABS(U2-U2L)/(SEC2*SEW2)
        PERP(4) = ABS(DXL(2)-V0-H)/SEW3
        PERP(5) = ABS(DXL(2)-V0+H)/SEW4
        PMIN0 = MIN(PERP(1),PERP(2),PERP(3),PERP(4),PERP(5))
        IF (PERP(1).EQ.PMIN0) THEN
          UL(1) = 0.
          UL(2) = 0.
          UL(3) = SIGN(ONE,DXL(3))
        ELSE IF (PERP(2).EQ.PMIN0) THEN
          FACT = ONE/(SEC1*SEW1)
          UL(1) = FACT
          UL(2) = -TAN1*FACT
          UL(3) = -W1/SEW1
        ELSE IF (PERP(3).EQ.PMIN0) THEN
          FACT = ONE/(SEC2*SEW2)
          UL(1) = -FACT
          UL(2) = -TAN2*FACT
          UL(3) = W2/SEW2
        ELSE IF (PERP(4).EQ.PMIN0) THEN
          FACT = ONE/SEW3
          UL(1) = 0.
          UL(2) = FACT
          UL(3) = -W3*FACT
        ELSE IF (PERP(5).EQ.PMIN0) THEN
          FACT = ONE/SEW4
          UL(1) = 0.
          UL(2) = -FACT
          UL(3) = W4*FACT
        ELSE
          LNTFOU=.TRUE.
        ENDIF
*
* *** everything else (currently NOT IMPLEMENTED)
      ELSE
        WRITE(CHMAIL,10100) ISH
        CALL GMAIL(0,0)
        IERR = 1
        GOTO 999
      ENDIF

      IF(LNTFOU) THEN
        WRITE(CHMAIL,10000) ISH
        CALL GMAIL(0,0)
        IERR = 1
      ELSE
*
* *** Transform back into the MCS
        CALL GDTOM(UL,U,2)
        IERR = 0
      ENDIF

10000 FORMAT(' GGPERP - geometry check error for shape #',I2,'!')
10100 FORMAT(' GGPERP - non implemented for shape #',I2)
  999 END
+DECK,  GGPPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GGPPAR (JVOM, IN, NVAR, LVAR, LVOM, NPAR, PAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GGPPAR (JVOM,IN,NVAR,LVAR,LVOM,NPAR*,PAR*)            *
C.    *                                                                *
C.    *   Computes the actual parameters for the INth content inside   *
C.    *    the mother volume at address JVOM                           *
C.    *   Returns them in NPAR, PAR                                    *
C.    *                                                                *
C.    *   Called by : GGDVLP                                           *
C.    *   Authors   : F.Bruyant, S.Banerjee                            *
C.    *               (original algorithms from A.McPherson)           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
C.
      PARAMETER (NPAMAX=50)
C.
      DIMENSION LVAR(*), PAR(*)
      DIMENSION DXYZ(3), PARM(NPAMAX)
      DIMENSION IOPT(12,12)
      SAVE IOPT
C.
      DATA IOPT /  1 ,1 ,1 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
     +             0 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
     +             0 ,0 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
     +             0 ,0 ,0 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
     +             0 ,0 ,0 ,0 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
     +             0 ,0 ,0 ,0 ,0 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,
     +             0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,0 ,0 ,0 ,0 ,
     +             0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,0 ,0 ,0 ,
     +             0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,0 ,0 ,
     +             0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,0 ,
     +             0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,
     +             0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 /
C.
C.    ------------------------------------------------------------------
*
* *** Check request
*
      JIN  = LQ(JVOM-IN)
*
      IVO  = Q(JIN+2)
      JVO  = LQ(JVOLUM-IVO)
      NPAR = Q(JVO+5)
      IF (NPAR.EQ.0) THEN
         NPAR = Q(JIN+9)
         CALL UCOPY (Q(JIN+10), PAR, NPAR)
         IF (NVAR.LT.0) GO TO 999
      ELSE
         CALL UCOPY (Q(JVO+7), PAR, NPAR)
      ENDIF
      IROT = Q(JIN+4)
      IF (IROT.NE.0) THEN
         WRITE (CHMAIL, 10300)
         CALL GMAIL (0, 0)
         IEORUN = 1
      ENDIF
*
      ISH  = Q(JVO+2)
      ISHM = Q(JVOM+2)
      IF(ISH.GT.12.OR.ISHM.GT.12.OR.IOPT(ISHM, ISH).EQ.0) THEN
         WRITE (CHMAIL, 10400) ISH, ISHM
         CALL GMAIL (0, 0)
         IEORUN = 1
      ENDIF
*
* *** Prepares parameters for mother, in PARM, for content, in PAR
*      and the translation DXYZ (position of content inside mother)
*
      IF (LQ(JVOM).EQ.LVOM) THEN
*
*      Case when current volume is source of local development
*
         NPARM = Q(JVOM+5)
         CALL UCOPY (Q(JVOM+7), PARM, NPARM)
      ELSE
*
*      Other cases
*
         NPARM = IQ(LVOM+5)
         CALL UCOPY (Q(LVOM+6), PARM, NPARM)
      ENDIF
*
      DXYZ(1) = Q(JIN+5)
      DXYZ(2) = Q(JIN+6)
      DXYZ(3) = Q(JIN+7)
*
* *** Compute the actual parameters
*
      IF (ISH.EQ.1) THEN
*
* BOX
*
         IF (ISHM.EQ.1) THEN
* in BOX
            DO 10 I = 1,NVAR
               IAX = LVAR(I)
               PAR(IAX) = PARM(IAX) -ABS(DXYZ(IAX))
               IF (PAR(IAX).LT.0.) THEN
                  WRITE (CHMAIL, 10500) ISH, ISHM, IAX
                  CALL GMAIL (0, 0)
                  IEORUN = 1
               ENDIF
   10       CONTINUE
         ELSE IF (ISHM.EQ.2) THEN
* in TRD1
            DO 20 I = 1,NVAR
               IAX = LVAR(I)
               IF (IAX.EQ.1) THEN
                  DZ = PAR(3)
                  IF (DZ.LT.0.) DZ = PARM(4)
                  DXDZ = 0.5*(PARM(2)-PARM(1))/PARM(4)
                  DXME = 0.5*(PARM(2)+PARM(1)) +DXDZ*DXYZ(3)
                  DX   = DXME -ABS(DXDZ*DZ)
                  PAR(IAX) = DX -ABS(DXYZ(1))
                  IF (PAR(IAX).LT.0.) THEN
                     WRITE (CHMAIL, 10500) ISH, ISHM, IAX
                     CALL GMAIL (0, 0)
                     IEORUN = 1
                  ENDIF
               ELSE
                  PAR(IAX) = PARM(IAX+1) -ABS(DXYZ(IAX))
                  IF (IAX.EQ.3) THEN
                     DXDZ = 0.5*(PARM(2)-PARM(1))/PARM(4)
                     DX0  = 0.5*(PARM(2)+PARM(1)) -ABS(DXYZ(1))
                     DZ   = (DX0 -PAR(1))/ABS(DXDZ)
                     IF (DZ.LT.0.) THEN
                        WRITE (CHMAIL, 10600) ISH, ISHM, IAX, DZ
                        CALL GMAIL (0, 0)
                        IEORUN = 1
                     ELSE
                        IF (PAR(3).GT.DZ) PAR(3) = DZ
                     ENDIF
                  ENDIF
               ENDIF
   20       CONTINUE
         ELSE IF (ISHM.EQ.3) THEN
* in TRD2
            DO 30 I = 1,NVAR
               IAX   = LVAR(I)
               IF (IAX .LT. 3) THEN
                  DZ  = PAR(3)
                  IP  = 2*IAX -1
                  IF (DZ .LT. 0.) DZ = PARM(5)
                  DXDZ = 0.5*(PARM(IP+1) - PARM(IP))/PARM(5)
                  DXME = 0.5*(PARM(IP+1) + PARM(IP)) + DXDZ*DXYZ(3)
                  DX   = DXME - ABS(DXDZ*DZ)
                  PAR(IAX) = DX - ABS(DXYZ(IAX))
               ELSE
                  PAR(3) = PARM(5) - ABS(DXYZ(3))
                  DXDZ   = 0.5*(PARM(2) - PARM(1))/PARM(5)
                  DX0    = 0.5*(PARM(2) + PARM(1)) - ABS(DXYZ(1))
                  DZ     = (DX0 - PAR(1))/ABS(DXDZ)
                  IF (DZ.LT.0.0) THEN
                     WRITE (CHMAIL, 10600) ISH, ISHM, IAX, DZ
                     CALL GMAIL (0, 0)
                     IEORUN = 1
                  ELSE
                     IF (PAR(IAX).GT.DZ) PAR(IAX) = DZ
                  ENDIF
                  DXDZ   = 0.5*(PARM(4) - PARM(3))/PARM(5)
                  DX0    = 0.5*(PARM(4) + PARM(3)) - ABS(DXYZ(2))
                  DZ     = (DX0 - PAR(2))/ABS(DXDZ)
                  IF (DZ.LT.0.0) THEN
                     WRITE (CHMAIL, 10600) ISH, ISHM, IAX, DZ
                     CALL GMAIL (0, 0)
                     IEORUN = 1
                  ELSE
                     IF (PAR(IAX).GT.DZ) PAR(IAX) = DZ
                  ENDIF
               ENDIF
   30       CONTINUE
         ELSE IF (ISHM.EQ.4) THEN
* in TRAP
*
*        Case of box in trap. Let's keep it simple: we just deal with
*        the case in which phi=0 or 180. If theta .ne. 0, the position along
*        x-axis, and the angles parm(7) and parm(11) must be 0.
*
            IF(ABS(PARM(3)).GT.0.1E-5) THEN
               WRITE(CHMAIL,10000) IQ(JVOLUM+IVO)
10000          FORMAT
     +      (' GGPPAR : Cannot use negative parameters for box ',A4)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,10100)
10100       FORMAT('          in a trap if PAR(2) .ne. 0 or 180')
               CALL GMAIL(0,0)
               IEORUN=1
            ELSEIF(PARM(7).NE.PARM(11)) THEN
               WRITE(CHMAIL,10000) IQ(JVOLUM+IVO)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,10200)
10200       FORMAT('          in a trap if PAR(7) .ne. PAR(11)')
               CALL GMAIL(0,0)
            ELSE
               IVARX=0
               IVARY=0
               IVARZ=0
               DO 40 J=1,NVAR
                  IF(LVAR(J).EQ.1) THEN
                     IVARX=1
                  ELSEIF(LVAR(J).EQ.2) THEN
                     IVARY=1
                  ELSEIF(LVAR(J).EQ.3) THEN
                     IVARZ=1
                  ENDIF
   40          CONTINUE
               DZM = PARM(1)
               IF(IVARZ.EQ.1) THEN
                  PAR(3) = DZM-ABS(DXYZ(3))
               ENDIF
               DYDZ=0.5*(PARM(8)-PARM(4))/PARM(1)
               DYM =0.5*(PARM(8)+PARM(4))
               DY1 = DYM+(DXYZ(3)+PAR(3))*DYDZ
               DY2 = DYM+(DXYZ(3)-PAR(3))*DYDZ
               IF(IVARY.EQ.1) THEN
                  PAR(2) = MIN(DY1,DY2)-ABS(DXYZ(2))
               ENDIF
               IF(IVARX.EQ.1) THEN
                  IF(PARM(7).EQ.0.0.AND.ABS(PARM(2)).LT..1E-5) THEN
                     DXDZL = 0.5*(PARM(9)-PARM(5))/PARM(1)
                     DXDZH = 0.5*(PARM(10)-PARM(6))/PARM(1)
                     DXML = 0.5*(PARM(9)+PARM(5))
                     DXMH = 0.5*(PARM(10)+PARM(6))
                     DXL1 = DXML+(DXYZ(3)+PAR(3))*DXDZL
                     DXL2 = DXML+(DXYZ(3)-PAR(3))*DXDZL
                     DXH1 = DXMH+(DXYZ(3)+PAR(3))*DXDZH
                     DXH2 = DXMH+(DXYZ(3)-PAR(3))*DXDZH
                     DXDY1 = 0.5*(DXH1-DXL1)/DY1
                     DXDY2 = 0.5*(DXH2-DXL2)/DY2
                     DXM1 = 0.5*(DXH1+DXL1)
                     DXM2 = 0.5*(DXH2+DXL2)
                     DX1 = DXM1+(DXYZ(2)+PAR(2))*DXDY1
                     DX2 = DXM1+(DXYZ(2)-PAR(2))*DXDY1
                     DX3 = DXM2+(DXYZ(2)+PAR(2))*DXDY2
                     DX4 = DXM2+(DXYZ(2)-PAR(2))*DXDY2
                     PAR(1) = MIN(DX1,DX2,DX3,DX4)-ABS(DXYZ(1))
* Note; position along x-axis should be 0, when theta .ne. 0:
                  ELSE IF(PARM(7).EQ..0.AND.ABS(PARM(2)).GT..1E-5)THEN
* the maximum length of the lower (DX2) and upper (DX1) lines along x
                     DXDZ= 0.5*(PARM(9)-PARM(5))/PARM(1)
                     DXM = 0.5*(PARM(9)+PARM(5))
                     DX1 = DXM+(DXYZ(3)+PAR(3))*DXDZ
                     DX2 = DXM+(DXYZ(3)-PAR(3))*DXDZ
*
* the shift in the endpoints caused by theta angle compared with
* the symmetrical case when theta = 0
                     TANTHE = PARM(2)
                     SHFX1 = TANTHE*(DXYZ(3)+PAR(3))
                     SHFX2 = TANTHE*(DXYZ(3)-PAR(3))
*
                     DX1P = DX1 + SHFX1
                     DX1N = DX1 - SHFX1
                     DX2P = DX2 + SHFX2
                     DX2N = DX2 - SHFX2
*
* DXP is the lenght of the box that fits in the positive side
* DXN is the one in the negative side
                     DXP  = MIN(DX1P,DX2P)
                     DXN  = MIN(DX1N,DX2N)
                     XPOS = .5*(DXP-DXN)
                     Q(JIN+5) = XPOS
                     PAR(1) = .5*(DXP+DXN)
                  ELSE
                     TANALF = PARM(7)
                     DXDZL = 0.5*(PARM(9)-PARM(5))/PARM(1)
                     DXDZH = 0.5*(PARM(10)-PARM(6))/PARM(1)
                     DXML = 0.5*(PARM(9)+PARM(5))
                     DXMH = 0.5*(PARM(10)+PARM(6))
                     DXL1 = DXML+(DXYZ(3)+PAR(3))*DXDZL
                     DXL2 = DXML+(DXYZ(3)-PAR(3))*DXDZL
                     DXH1 = DXMH+(DXYZ(3)+PAR(3))*DXDZH
                     DXH2 = DXMH+(DXYZ(3)-PAR(3))*DXDZH
                     SHFX1 = TANALF*DY1
                     SHFX2 = TANALF*DY2
*
                     DXH1P = DXH1+SHFX1
                     DXH1N = DXH1-SHFX1
                     DXL1P = DXL1-SHFX1
                     DXL1N = DXL1+SHFX1
                     DXH2P = DXH2+SHFX2
                     DXH2N = DXH2-SHFX2
                     DXL2P = DXL2-SHFX2
                     DXL2N = DXL2+SHFX2
*
                     DXDY1P = 0.5*(DXH1P-DXL1P)/DY1
                     DXDY2P = 0.5*(DXH2P-DXL2P)/DY2
                     DXDY1N = 0.5*(DXH1N-DXL1N)/DY1
                     DXDY2N = 0.5*(DXH2N-DXL2N)/DY2
*
                     DXM1P = 0.5*(DXH1P+DXL1P)
                     DXM2P = 0.5*(DXH2P+DXL2P)
                     DXM1N = 0.5*(DXH1N+DXL1N)
                     DXM2N = 0.5*(DXH2N+DXL2N)
*
                     DX1P = DXM1P+(DXYZ(2)+PAR(2))*DXDY1P
                     DX2P = DXM1P+(DXYZ(2)-PAR(2))*DXDY1P
                     DX3P = DXM2P+(DXYZ(2)+PAR(2))*DXDY2P
                     DX4P = DXM2P+(DXYZ(2)-PAR(2))*DXDY2P
                     DX1N = DXM1N+(DXYZ(2)+PAR(2))*DXDY1N
                     DX2N = DXM1N+(DXYZ(2)-PAR(2))*DXDY1N
                     DX3N = DXM2N+(DXYZ(2)+PAR(2))*DXDY2N
                     DX4N = DXM2N+(DXYZ(2)-PAR(2))*DXDY2N
*
                     PAR(1) =MAX(0.,MIN( MIN(DX1P,DX2P,DX3P,DX4P)-
     +               DXYZ(1), MIN(DX1N,DX2N,DX3N,DX4N)+DXYZ(1)))
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
*
      ELSE IF (ISH.EQ.4) THEN
*
* TRAP
*
         IF (ISHM.EQ.ISH) THEN
* in TRAP
            IF (PAR(1).EQ.PARM(1)) THEN
               IZCUT = 0
            ELSE
               IZCUT = 1
            ENDIF
            DO 50 I = 1,NVAR
               IAX = LVAR(I)
               PAR(IAX) = PARM(IAX)
               IF (IZCUT.EQ.0) GO TO 50
               IF (IAX.NE.1.AND.IAX.LE.6) THEN
                  DZ   = DXYZ(3) +PARM(1) -PAR(1)
                  DPDZ = 0.5*(PARM(IAX+4) -PARM(IAX))/PARM(1)
                  PAR(IAX) = PARM(IAX) + DPDZ*DZ
               ELSE IF (IAX.GT.6) THEN
                  DZ   = DXYZ(3) +PARM(1) +PAR(1)
                  DPDZ = 0.5*(PARM(IAX) -PARM(IAX-4))/PARM(1)
                  PAR(IAX) = PARM(IAX-4) + DPDZ*DZ
               ENDIF
   50       CONTINUE
            IF (IZCUT.NE.0) THEN
               HTAH = PARM(8)*PARM(11)
               HTAL = PARM(4)*PARM(7)
               ZZ1  = 0.5*(DXYZ(3) +PARM(1) -PAR(1))/PARM(1)
               PAR(7) = (HTAL*(1.-ZZ1) + HTAH*ZZ1)/PAR(4)
               ZZ2  = 0.5*(DXYZ(3) +PARM(1) +PAR(1))/PARM(1)
               PAR(11)= (HTAL*(1.-ZZ2) + HTAH*ZZ2)/PAR(8)
            ENDIF
            IF(IAX.EQ.2.AND.IZCUT.EQ.0) THEN
               DXDY1 = 0.5*(PARM(6)-PARM(5))/PARM(4)
               DXDY2 = 0.5*(PARM(10)-PARM(9))/PARM(8)
               DXM1  = 0.5*(PARM(6)+PARM(5))
               DXM2  = 0.5*(PARM(10)+PARM(9))
               DXH1  = DXM1+(DXYZ(2)+PAR(2))*DXDY1
               DXH2  = DXM2+(DXYZ(2)+PAR(2))*DXDY2
               DXL1  = DXM1+(DXYZ(2)-PAR(2))*DXDY1
               DXL2  = DXM2+(DXYZ(2)-PAR(2))*DXDY2
               PAR(5) = DXL1
               PAR(6) = DXH1
               PAR(9) = DXL2
               PAR(10) = DXH2
            ENDIF
         ENDIF
         CALL GNOTR1 (PAR)
*
      ELSE IF (ISH.EQ.5) THEN
*
* TUBE
*
         IF(ISHM.EQ.ISH) THEN
            IRMIN = 0
            IRMAX = 0
            IDZED = 0
            DO 60 JVAR=1,NVAR
               IF(LVAR(JVAR).EQ.1) IRMIN=1
               IF(LVAR(JVAR).EQ.2) IRMAX=1
               IF(LVAR(JVAR).EQ.3) IDZED=1
   60       CONTINUE
            RPOS = SQRT(DXYZ(1)**2+DXYZ(2)**2)
            IF(IRMIN.EQ.1) THEN
*
* Here we settle the minimum radius.
*
               IF(PARM(1).GT.0.) THEN
                  PAR(1) = PARM(1)+RPOS
               ELSE
                  PAR(1) = 0.
               ENDIF
            ENDIF
            IF(IRMAX.EQ.1) THEN
*
* Case in which the max radius is variable.
*
               IF(PAR(1).LE.RPOS-PARM(1).AND.PARM(1).GT.0.) THEN
*
* This is the case in which the 'hole' in the tube does not
* intersect the 'hole' in the mother.
*
                  PAR(2) = MIN(PARM(2)-RPOS,RPOS-PARM(1))
               ELSEIF(PAR(1).GE.RPOS+PARM(1).OR.PARM(1).EQ.0.) THEN
*
* This is the case in which the 'hole' in the tube contains the
* 'hole' in the mother, or there is no 'hole' in the mother.
*
                  PAR(2) = PARM(2)-RPOS
               ELSE
*
* And this is the error condition. The inner tube protrudes in the empty
* space inside the outer one.
*
                  WRITE(CHMAIL,11100) IQ(JVOLUM+IVO)
                  CALL GMAIL(0,0)
                  IEORUN = 1
               ENDIF
            ENDIF
            IF(IDZED.EQ.1) THEN
               PAR(3) = PARM(3)-ABS(DXYZ(3))
            ENDIF
            IF(PAR(1).GE.PAR(2).OR.PAR(2).GT.PARM(2)
     +                         .OR.PAR(3).LE.0.) THEN
               WRITE(CHMAIL,11000) IQ(JVOLUM+IVO)
               CALL GMAIL(0, 0)
               IEORUN = 1
            ENDIF
         ELSE
            WRITE (CHMAIL, 10900) ISH, ISHM
            CALL GMAIL (0, 0)
            IEORUN=1
         ENDIF
      ELSE IF (ISH.LE.10) THEN
*
* TRD1,TRD2,TUBE,TUBS,CONE,CONS,SPHE,PARA
*
         IF (ISHM.EQ.ISH) THEN
* in TRD1,TRD2,TUBE,TUBS,CONE,CONS,SPHE,PARA
            IF (DXYZ(1).NE.0..OR.DXYZ(2).NE.0..OR.DXYZ(3).NE.0.)
     +      THEN
               WRITE (CHMAIL, 10700) ISH, ISHM
               CALL GMAIL (0, 0)
               IEORUN = 1
            ELSE
               DO 70 I= 1, NVAR
                  IAX = LVAR(I)
                  PAR(IAX) = PARM(IAX)
   70          CONTINUE
            ENDIF
         ENDIF
*
      ELSE IF (ISH.LE.12) THEN
*
* PGON,PCON
*
         IF (ISHM.EQ.ISH) THEN
* in PGON,PCON
            IF (ISH.EQ.11) THEN
               IPNZ = 4
            ELSE
               IPNZ = 3
            ENDIF
            NZ = PAR(IPNZ)
            NZ1 = PARM(IPNZ)
            IF (NZ.NE.2 .OR. NZ1.NE.2) THEN
               WRITE (CHMAIL, 10900) ISH, ISHM
               CALL GMAIL (0, 0)
               IEORUN = 1
            ELSE
               ZL = PARM(IPNZ+1)
               ZH = PARM(IPNZ+4)
               DZ = ZH - ZL
               TANLOW = (PARM(IPNZ+5)-PARM(IPNZ+2))/DZ
               TANHIG = (PARM(IPNZ+6)-PARM(IPNZ+3))/DZ
               Z1 = DXYZ(3) + PAR(IPNZ+1) - PARM(IPNZ+1)
               Z2 = DXYZ(3) + PAR(IPNZ+4) - PARM(IPNZ+1)
               PAR(IPNZ+2) = PARM(IPNZ+2) + TANLOW * Z1
               PAR(IPNZ+3) = PARM(IPNZ+3) + TANHIG * Z1
               PAR(IPNZ+5) = PARM(IPNZ+2) + TANLOW * Z2
               PAR(IPNZ+6) = PARM(IPNZ+3) + TANHIG * Z2
            ENDIF
         ENDIF
*
      ENDIF
*
10300 FORMAT (' GGPPAR : Rotations not accepted at the moment')
10400 FORMAT (' GGPPAR : Shape association not accepted', 2I5)
10500 FORMAT (' GGPPAR : PAR(IAX) negative, ISH,ISHM,IAX=',3I5)
10600 FORMAT (' GGPPAR : DZ negative, ISH,ISHM,IAX,DZ=',3I5,G12.4)
10700 FORMAT (' GGPPAR : Not yet coded for ISH,ISHM=',2I5)
10800 FORMAT (' GGPPAR : PARM error for ISH,ISHM,IAX=',3I5)
10900 FORMAT (' GGPPAR : Configuration not accepted, ISH,ISHM=',2I5)
11000 FORMAT (' GGPPAR : Tube ',A4,' has inconsistent parameters')
11100 FORMAT (' GGPPAR : Tube ',A4,' protrudes into the inner space ',
     +        'of the mother')
*                                                             END GGPPAR
  999 END
+DECK,  GGVCHK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GGVCHK (JVOM, IN, NVAR, LVAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GGVCHK (JVOM, IN, NVAR*, LVAR*)                       *
C.    *                                                                *
C.    *   Checks volume parameters of IN'th content of mother volume   *
C.    *    at address JVOM or, when IN = 0, of mother volume itself.   *
C.    *   Returns NVAR = 0, when no variable parameters                *
C.    *       or  NVAR =-1, when no variable parameters AND not a      *
C.    *        possible source of local development                    *
C.    *       otherwise,                                               *
C.    *        the list LVAR of the NVAR variable parameters positions *
C.    *                                                                *
C.    *   Called by : GGDVLP                                           *
C.    *   Author    : F.Bruyant                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCSHNO.
C.
      DIMENSION LVAR(*)
      INTEGER   LDP(7,12), NDP(12)
      SAVE LDP,NDP
C.
      DATA NDP/ 3, 4, 5, 7, 3, 3, 5, 5, 4, 3, 2, 2 /
      DATA LDP/ 1, 2, 3, 4*0,  1, 2, 3, 4, 3*0,  1, 2, 3, 4, 5, 2*0,
     +        1, 4, 5, 6, 8, 9, 10,  1, 2, 3, 4*0,  1, 2, 3, 4*0,
     +        1, 2, 3, 4, 5, 2*0,  1, 2, 3, 4, 5, 2*0,  1, 2, 3, 4, 3*0,
     +        1, 2, 3, 4*0,  2, 3, 5*0,  2, 3, 5*0 /
C.
C.    ------------------------------------------------------------------
*
      NVAR = 0
      NSP  = 0
      IF (IN.EQ.0) THEN
         NPAR = Q(JVOM+5)
         IF (NPAR.LE.0) THEN
            NIN = Q(JVOM+3)
            IF (NIN.LT.0) NVAR = -1
            GO TO 999
         ENDIF
         JPAR = JVOM +6
         ISH = Q(JVOM+2)
      ELSE
         JIN  = LQ(JVOM-IN)
         IVO  = Q(JIN+2)
         JVO  = LQ(JVOLUM-IVO)
         NPAR = Q(JVO+5)
         IF (NPAR.GT.0) THEN
            JPAR = JVO +6
         ELSE
            NIN  = Q(JVOM+3)
            IF (NIN.LT.0) THEN
               JPAR = 0
            ELSE
               JPAR = JIN +9
               NIN  = Q(JVO+3)
               IF (NIN.LT.0) THEN
                  NSP = -1
               ELSE
*
                  DO 9 IIN = 1, NIN
                     JJIN = LQ(JVO-IIN)
                     IIVO = Q(JJIN+2)
                     JJVO = LQ(JVOLUM-IIVO)
                     NNPAR= Q(JJVO+5)
                     IF (NNPAR.GT.0) THEN
                        JJPAR= JJVO + 6
                     ELSE
                        NSP=-1
                        GO TO 10
                     ENDIF
*
                     IISH = Q(JJVO+2)
                     NND  = NDP(IISH)
                     IF (IISH.LE.10) THEN
*
*   *                  Volumes other than PGON or PCON
*
                        DO 6 ID = 1,NND
                           IIDP = LDP(ID,IISH)
                           IF (Q(JJPAR+IIDP).LT.0.) THEN
                              NSP = -1
                              GO TO 10
                           ENDIF
    6                   CONTINUE
*
                     ELSE IF (IISH.LE.12) THEN
*
*   *                  PGON and PCON volumes
*
                        IPZ  = 15 -IISH
                        JJPAR = JJPAR +IPZ
                        NNZ   = 2*Q(JJPAR)
                        DO 8 IZ = 1, NNZ
                           DO 7 ID = 1, NND
                              IIDP = LDP(ID,IISH)
                              IF (Q(JJPAR+IIDP).LT.0.) THEN
                                 NSP = -1
                                 GO TO 10
                              ENDIF
    7                      CONTINUE
    8                   CONTINUE
                     ENDIF
    9             CONTINUE
*
               ENDIF
*
            ENDIF
         ENDIF
  10     ISH = Q(JVO+2)
      ENDIF
*        Shape 28 will not be supported in the future
      IF (ISH.EQ.28.OR.ISH.EQ.13.OR.ISH.EQ.NSCTUB.OR.ISH.EQ.14)THEN
         NVAR = 0
         GO TO 999
      ENDIF
*
      ND = NDP(ISH)
*
      IF (JPAR.LE.0) THEN
         IF (ISH.LE.10) THEN
*
*  *       Volumes other PGON or PCON
*
            NVAR = ND
            DO 11 ID = 1, ND
   11       LVAR(ID) = LDP(ID,ISH)
         ELSE IF (ISH.LE.12) THEN
*
*  *       PGON and PCON volumes
*
            IPZ  = 15 - ISH
            NVAR = 6
            DO 12 ID = 1, NVAR
   12       LVAR(ID) = IPZ + ID
         ELSE
*
            GO TO 900
         ENDIF
         GO TO 999
      ENDIF
*
      IF (ISH.LE.10) THEN
*
*   *   Volumes other than PGON or PCON
*
         DO 19 ID = 1,ND
            IDP = LDP(ID,ISH)
            IF (Q(JPAR+IDP).GE.0.) GO TO 19
            NVAR = NVAR +1
            LVAR(NVAR) = IDP
   19    CONTINUE
*
      ELSE IF (ISH.LE.12) THEN
*
*   *   PGON and PCON volumes
*
         IPZ  = 15 -ISH
         JPAR = JPAR +IPZ
         NZ   = 2*Q(JPAR)
         INC  = IPZ
         DO 29 IZ = 1,NZ
            DO 28 ID = 1,ND
               IDP = LDP(ID,ISH)
               IF (Q(JPAR+IDP).GE.0.) GO TO 28
               NVAR = NVAR +1
               LVAR(NVAR) = INC +IDP
   28       CONTINUE
            INC = INC +3
   29    CONTINUE
      ELSE
*
         GO TO 900
      ENDIF
      IF (NVAR.EQ.0) NVAR = NSP
      GO TO 999
*
 900  WRITE (CHMAIL, 1001) ISH
      CALL GMAIL (0, 0)
 1001 FORMAT (' GGVCHK : No code for shape ISH=',I5)
*                                                             END GGVCHK
 999  END
+DECK,  GINCTU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GINCTU( X     , PAR   , IYES  )
*
***********************************************************************
*.
*...GINCTU tests whether a point inside a cut tube or not.
*.
*. SUBROUTINE GINCTU( X     , PAR   , IYES  )
*. -----------------
*.
*. Routine GINCTU tests whether a point is inside a cur tue or not.
*.
*. INPUT     : X      vector    real length at least 3, x,y,z of
*.           :                  point in local cut tube coords.
*.           : PAR    vector    real length 11 parameters of cut
*.           :                  tube.
*. OUTPUT    : IYES   integer   1 if point inside, 0 if not.
*.
*. SEQUENCES : GCONSP
*. CALLED    : GINME
*.
*.
*. REPORT CONDITIONS
*.
*. Non Stand.: none.
*.
*. AUTHOR    : A.C.McPherson.
*. VERSION   : 1.00
*. CREATED   :  6-May-88
*. LAST MOD  :  6-May-88
*.
*. MODIFICATION LOG.
*.
*.*********************************************************************
*.
+CDE, GCONSP.
      REAL X(*), PAR(*)
*.
*          --------------------
*
      IYES = 0
      ZINL = X(1)*PAR(6) +X(2)*PAR(7) +( X(3)+PAR(3) )*PAR(8)
      IF( ZINL .LT. 0.0 ) THEN
        ZINH = X(1)*PAR(9) +X(2)*PAR(10) +( X(3)-PAR(3) )*PAR(11)
        IF( ZINH .LT. 0.0 ) THEN
          R2 = X(1)*X(1)+X(2)*X(2)
          IF( R2 .GT. PAR(1)*PAR(1) .AND. R2 .LT. PAR(2)*PAR(2) ) THEN
            IF( PAR(4) .EQ. 0 .AND. PAR(5) .EQ. 360.0 ) THEN
              IYES = 1
            ELSEIF( R2 .GT. 0.0 ) THEN
              PHI = ATAN2( X(2), X(1) )/DEGRAD
              DPHI = PHI - PAR(4)
              IF( DPHI .LT. 0.0 ) DPHI = DPHI+360.0
              IF( DPHI .GT. 360.0 ) DPHI = DPHI-360.0
              DPT = PAR(5) - PAR(4)
              IF( DPT .LT. 0.0 ) DPT = DPT+360.0
              IF( DPT .GT. 360.0 ) DPT = DPT-360.0
              IF( DPHI .LE. DPT ) IYES = 1
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      END
+DECK,  GINGTR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GINGTR(X,P,IYES)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *          SUBROUTINE GINGTR(X,P,IYES)                           *
C.    *      Routine performes GINME type function to determine        *
C.    *      whether the point X is in the GTRA shape with parameters  *
C.    *      P. IYES is returned 1 if it is 0 if not.                  *
C.    *          A.C.McPherson 22nd April 1985                         *
C.    *                                                                *
C.    *      Called by : GINME                                         *
C.    *                                                                *
C     ******************************************************************
C.
      DIMENSION X(3),P(30),XPT(4),YPT(4)
C.
C.            ----------------------------------------
C.
C             First the range in Z is checked.
C
      IYES=0
      IF(ABS(X(3)).GT.P(1)) GO TO 30
C
C             Next the four corners at the z of the input point (X(3))
C             are computed as:
C
      DO 10 I=1,4
      I0=I*4+11
      XPT(I) = P(I0)+P(I0+2)*X(3)
      YPT(I) = P(I0+1)+P(I0+3)*X(3)
   10 CONTINUE
C
C             Then the cross product between the vector from that
C             corner to the input point and the vector from that corner
C             to the next corner is computed and its sign is
C             interrogated. Since the quadralateral is convex, if any
C             one of these signs is wrong, the point is outside the
C             shape. This task is performed as follows:
C
      DO 20 I=1,4
      J = I+1
      IF(J.EQ.5) J=1
      CROSS = (X(1)-XPT(I))*(YPT(J)-YPT(I)) -
     +        (X(2)-YPT(I))*(XPT(J)-XPT(I))
      IF(CROSS.GT.0.0) GO TO 30
   20 CONTINUE
      IYES = 1
   30 CONTINUE
      RETURN
      END
+DECK,  GINME, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GINME(X,SH,P,IYES)
C.
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     SUBROUTINE TO COMPUTE WHETHER THE POINT X IS IN THE SHAPE  *
C.    *     NUMBER SH WITH PARAMETERS P.                               *
C.    *     IYES IS SET TO 1 IF SO; TO ZERO IF NOT.                    *
C.    *                                                                *
C.    *    ==>Called by : GFTRAC, GINVOL, GMEDIA, GMEPOS, GSTRAC,      *
C.    *                   GTMEDI                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
+CDE, GCONSP.
+CDE, GCSHNO.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
      DIMENSION X(3),P(*)
C.
C.    ------------------------------------------------------------------
C.
      IYES=0
      ISH=SH
*
      IF(ISH.EQ.5) THEN
*
*          Tube axis = Z axis
         IF (ABS(X(3)).GT.P(3)) GO TO 999
         R2=X(1)**2+X(2)**2
         IF(R2.LT.P(1)**2) GO TO 999
         IF(R2.GT.P(2)**2) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.6) THEN
*
*          Tube segment
         IF (ABS(X(3)).GT.P(3)) GO TO 999
         R2=X(1)**2+X(2)**2
         IF(R2.LT.P(1)**2) GO TO 999
         IF(R2.GT.P(2)**2) GO TO 999
         IYES=1
         IF (R2.LT.1.0E - 6) GO TO 999
         IYES=0
         PHI = ATAN2(X(2),X(1)) * RADDEG
         DP=P(5)-P(4)
         IF(DP.LE.0.0) DP=DP+360.0
         DDP=PHI-P(4)
         SG = SIGN(1.0,DDP)
         DDP = MOD( ABS(DDP), 360. )
         IF(SG.LE.0.) DDP = 360.-DDP
         IF(DDP.GT.DP) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.1) THEN
*
*            Rectilinear box
         IF (ABS(X(1)).GT.P(1)) GO TO 999
         IF (ABS(X(2)).GT.P(2)) GO TO 999
         IF (ABS(X(3)).GT.P(3)) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.2) THEN
*
*          Rectilinear trapezoidal section with only the X
*          thickness changing with z
         DZ =P(4)
         IF (ABS(X(3)).GT.DZ) GO TO 999
         DY = P(3)
         IF (ABS(X(2)).GT.DY) GO TO 999
         DX =0.5*(P(2)*(X(3)+DZ)+P(1)*(DZ-X(3)))/DZ
         IF (ABS(X(1)).GT.DX) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.3) THEN
*
*          Rectilinear trapezoidal section with both X and Y
*          thicknesses varying with Z
         DZ =P(5)
         IF (ABS(X(3)).GT.DZ) GO TO 999
         DX =0.5*(P(2)*(X(3)+DZ)+P(1)*(DZ-X(3)))/DZ
         IF (ABS(X(1)).GT.DX) GO TO 999
         DY = 0.5*(P(4)*(X(3)+DZ)+P(3)*(DZ-X(3)))/DZ
         IF (ABS(X(2)).GT.DY) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.9) THEN
*
*          Spherical segment
         R2 = X(1)**2 + X(2)**2 + X(3)**2
         IF (R2.LT.P(1)**2.OR.R2.GT.P(2)**2) GO TO 999
         IYES=1
         IF (R2.LT.1.0E -12) GO TO 999
         IYES=0
         IF (X(1).EQ.0..AND.X(2).EQ.0.) THEN
            PHI = 0.
         ELSE
            PHI = ATAN2(X(2),X(1))*RADDEG
         ENDIF
         DP=P(6)-P(5)
         IF(DP.LE.0.0) DP=DP+360.0
         DDP=PHI-P(5)
         SG = SIGN(1.0,DDP)
         DDP = MOD( ABS(DDP), 360. )
         IF(SG.LE.0.) DDP = 360.-DDP
         IF(DDP.GT.DP) GO TO 999
         R2 = X(1)**2 + X(2)**2
         IF(R2.GT.0.0) R2=SQRT(R2)
         THETA = ATAN2(R2,X(3)) * RADDEG
         IF (THETA.LT.P(3).OR.THETA.GT.P(4)) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.4) THEN
*
*          General trapezoidal section
         CALL GINTRP(X,P,IYES)
*
      ELSEIF(ISH.EQ.7) THEN
*
*          Conical tube
         DZ =P(1)
         IF (ABS(X(3)).GT.DZ) GO TO 999
         R2 =X(1)**2 + X(2)**2
         RL = 0.5*(P(4)*(X(3)+DZ)+P(2)*(DZ-X(3)))/DZ
         RH = 0.5*(P(5)*(X(3)+DZ)+P(3)*(DZ-X(3)))/DZ
         IF (R2.LT.RL**2.OR.R2.GT.RH**2) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.8) THEN
*
*          Conical tube segment
         DZ =P(1)
         IF (ABS(X(3)).GT.DZ) GO TO 999
         R2 =X(1)**2 + X(2)**2
         RL = 0.5*(P(4)*(X(3)+DZ)+P(2)*(DZ-X(3)))/DZ
         RH = 0.5*(P(5)*(X(3)+DZ)+P(3)*(DZ-X(3)))/DZ
         IF (R2.LT.RL**2.OR.R2.GT.RH**2) GO TO 999
         IYES=1
         IF (R2.LT.1.0E - 6) GO TO 999
         IYES=0
         PHI = ATAN2(X(2),X(1)) * RADDEG
         DP=P(7)-P(6)
         IF(DP.LE.0.0) DP=DP+360.0
         DDP=PHI-P(6)
         SG = SIGN(1.0,DDP)
         DDP = MOD( ABS(DDP), 360. )
         IF(SG.LE.0.) DDP = 360.-DDP
         IF(DDP.GT.DP) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.10) THEN
*
*             Parallelepiped
         CALL GINPAR(X,P,IYES)
*
      ELSEIF(ISH.EQ.11) THEN
*
*            Polygon
         CALL GINPGO(X,P,IYES)
*
      ELSEIF(ISH.EQ.12) THEN
*
*            Polycone
         CALL GINPCO(X,P,IYES)
*
      ELSEIF (ISH.EQ.13) THEN
*
*           Elliptical tube
         IF (ABS(X(3)).GT.P(3)) GOTO 999
         A2=P(1)**2
         B2=P(2)**2
         R2=X(1)**2/A2+X(2)**2/B2
         IF (R2.GT.1.0) GOTO 999
         IYES=1
*
      ELSEIF(ISH.EQ.14) THEN
*
*       HYPErboloid axis = Z axis.
         IF (ABS(X(3)) .GT. P(3)) GO TO 999
         R2 = X(1)**2 + X(2)**2
         DR2 = (X(3) * TAN(P(4)*DEGRAD))**2
         IF (R2 .LT. P(1)**2 + DR2) GO TO 999
         IF (R2 .GT. P(2)**2 + DR2) GO TO 999
         IYES=1
*
      ELSEIF(ISH.EQ.28) THEN
*
*            General twisted trapezoid.
         CALL GINGTR(X,P,IYES)
*
      ELSEIF( ISH.EQ.NSCTUB) THEN
*
*            Cut tube.
         CALL GINCTU(X,P,IYES)
*
      ELSE
*
*            User shape ?
+SELF, IF=-USRJMP.
         CALL GUINME(X,SH,P,IYES)
+SELF, IF=USRJMP.
         CALL JUMPT4(JUINME,X,SH,P,IYES)
+SELF.
*
         IF(IYES.LT.0) THEN
*
*         Shape number not supported by system nor by user
            WRITE(CHMAIL,10000) ISH
            CALL GMAIL(0,0)
         ENDIF
      ENDIF
*
10000 FORMAT(' *** GINME *** Shape number ',I5,' not yet implemented')
  999 END
+DECK,  GINPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GINPAR(X,PAR,IYES)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routine to determine whether a point X is inside the        *
C.    *    parallelepiped with parameters PAR. IYES is returned as 1   *
C.    *    if it is; as zero if it isn't.                              *
C.    *                                                                *
C.    *    ==>Called by : GINME                                        *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),PAR(6)
C.
C.           -------------------------------------
C.
      IYES=0
      IF(ABS(X(3)).GT.PAR(3)) GO TO 99
C
      YT=X(2)-PAR(6)*X(3)
      IF(ABS(YT).GT.PAR(2)) GO TO 99
C
      XT=X(1)-PAR(5)*X(3)-PAR(4)*YT
      IF(ABS(XT).GT.PAR(1)) GO TO 99
C
      IYES=1
C
   99 CONTINUE
      END
+DECK,  GINPCO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GINPCO(X,P,IYES)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO PERFORM GINME FUNCTION FOR A POLYCONE.           *
C.    *        X  -  A VECTOR DIMENSION 3 GIVING THE POINT.            *
C.    *        P  -  THE VECTOR OF PARAMETERS, (1) = PHIMIN,           *
C.    *                   (2) = DPHI, (3) = NZ, (4) = Z(1),            *
C.    *                   (5) = RMIN(1), (6) = RMAX(1), (7) = Z(2),    *
C.    *                   (8) = RMIN(2), (9) = RMAX(2), ETC.           *
C.    *     IYES  -  RETURNED AS 1 IF POINT IS INSIDE, OTHERWISE 0.    *
C.    *                                                                *
C.    *    ==>Called by : GINME                                        *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCPOLY.
      DIMENSION P(9),X(3)
C.
C.                ---------------------------------
C.
      IYES=0
C
C                 FIRST CHECK TOTAL Z RANGE.
C
      NZ=P(3)
      IF(X(3).LT.P(4).OR.X(3).GT.P(NZ*3+1)) GO TO 999
C
C                 NOW CHECK R(SQUARED). FIRST COMPUTE IT.
C
      R2=X(1)*X(1)+X(2)*X(2)
C
C                 NOW FIND WHICH Z SECTION THE POINT IS IN.
C
      IZL=1
      IZH=NZ
      IZT=(NZ+1)/2
      IPL=IZL*3+1
      IPH=IZH*3+1
      IPT=IZT*3+1
C
   10 CONTINUE
      IF(IZH-IZL.LE.1) GO TO 40
C
      IF(X(3).GT.P(IPT)) GO TO 20
C
      IZH=IZT
      IPH=IPT
C
      GO TO 30
C
   20 CONTINUE
C
      IZL=IZT
      IPL=IPT
C
   30 CONTINUE
C
      IZT=(IZL+IZH)/2
      IPT=IZT*3+1
C
      GO TO 10
C
   40 CONTINUE
C
C          THE POINT IS IN THE SECTION BOUNDED BY THE IZL TH AND THE
C          IZH TH Z VALUES.
C
C          NOW COMPUTE RMIN AND RMAX AND TEST THE VALUE OF R SQUARED.
C
      IZSEC=IZH
      IF (P(IPL+2).EQ.0..AND.P(IPH+2).EQ.0.) GO TO 999
C
      IF ( (P(IPH).EQ.P(IPL)) .AND. (X(3).EQ.P(IPL)) ) THEN
         RMN = MAX( P(IPL+1), P(IPH+1) )
         RMX = MIN( P(IPL+2), P(IPH+2) )
      ELSE
         DZ=P(IPH)-P(IPL)
         DZ1=X(3)-P(IPL)
         RMN=(P(IPL+1)*(DZ-DZ1)+P(IPH+1)*DZ1)/DZ
         RMX=(P(IPL+2)*(DZ-DZ1)+P(IPH+2)*DZ1)/DZ
      END IF
C
      IF(R2.LT.RMN*RMN.OR.R2.GT.RMX*RMX) GO TO 999
C
C                 NOW CHECK PHI.
C
      PHI=P(1)+P(2)*0.5
      IF(X(2).NE.0.0.OR.X(1).NE.0) PHI=ATAN2(X(2),X(1))*RADDEG
      IF(PHI.LT.P(1)) PHI=PHI+360.0
      IF(PHI.LT.P(1).OR.PHI-P(1).GT.P(2)) GO TO 999
C
C           POINT IS IN POLYCONE.
C
      IYES=1
C
  999 CONTINUE
      END
+DECK,  GINPGO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:50  cernlib
* Geant

      SUBROUTINE GINPGO(X,P,IYES)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO PERFORM GINME FUNCTION FOR A POLYGON.            *
C.    *        X  -  A VECTOR DIMENSION 3 GIVING THE POINT.            *
C.    *        P  -  THE VECTOR OF PARAMETERS, (1) = PHIMIN,           *
C.    *                   (2) = DPHI, (3) = NDIV, (4) = NZ, (5) = Z(1) *
C.    *                   (6) = RMIN(1), (7) = RMAX(1), (8) = Z(2),    *
C.    *                   (9) = RMIN(2), (10) = RMAX(2), ETC.          *
C.    *                   RMIN IS THE DISTANCE FROM THE ORIGIN TO THE  *
C.    *                   INSIDE EDGE PROJECTED ALONG THE CENTRE LINE  *
C.    *                   OF THE DIVISION. RMAX IS THE CORRESPONDING   *
C.    *                   PROJECTED DISTANCE FOR THE OUTER EDGE.       *
C.    *     IYES  -  RETURNED AS 1 IF POINT IS INSIDE, OTHERWISE 0.    *
C.    *                                                                *
C.    *    ==>Called by : GINME                                        *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCPOLY.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION XX1,XX2,PHI,DELPHI,PH0,R,DZRAT,DIVPHI
      DOUBLE PRECISION RMN,RMX,HNDIV
+SELF.
      DIMENSION P(10),X(3)
C.
C.                ---------------------------------
C.
      IYES=0
C
C                 FIRST CHECK TOTAL Z RANGE.
C
      NZ=P(4)
      IF(X(3).LT.P(5).OR.X(3).GT.P(NZ*3+2)) GO TO 999
C
C             Find smallest RMIN and largest RMAX
C
      RMIN=P(6)
      RMAX=P(7)
      DO 10 I=2,NZ
         IP=I*3+3
         IF(P(IP).LT.RMIN)RMIN=P(IP)
         IF(P(IP+1).GT.RMAX) RMAX=P(IP+1)
   10 CONTINUE
*
* ***         Check R against RMIN
*
      XX1 = X(1)
      XX2 = X(2)
      R   = SQRT(XX1**2+XX2**2)
      IF(R.LT.RMIN)GO TO 999
      HNDIV=P(3)
      DELPHI=P(2)
      DIVPHI=DELPHI/HNDIV
*
* ***     Find the radius of the outscribed circle
*
      RMAX = RMAX/COS(0.5*DIVPHI*DEGRAD)
*
* ***         Check R against RMAX
*
      IF(R.GT.RMAX)GO TO 999
C
C               If R sufficiently small ignore phi structure.
C
      IPSEC=1
C
      IF(R.LT.1.0E-5) GO TO 20
C
C                 NOW CHECK PHI.
C
      PHI=ATAN2(XX2,XX1)*RADDEG
      IF(PHI.LT.P(1)) PHI=PHI+360.0
      IF(PHI.LT.P(1).OR.PHI-P(1).GT.P(2)) GO TO 999
C
C                 NOW FIND PHI DIVISION.
C
      IPSEC=MIN((PHI-P(1))/DIVPHI+1.,HNDIV)
C
      PH0=(P(1)+DIVPHI*(IPSEC-0.5))*DEGRAD
C
C                 NOW CHECK PROJECTED DISTANCE. FIRST COMPUTE IT.
C
      R=XX1*COS(PH0)+XX2*SIN(PH0)
C
   20 CONTINUE
C
C                 NOW FIND WHICH Z SECTION THE POINT IS IN.
C
      IZL=1
      IZH=NZ
      IPL=IZL*3+2
      IPH=IZH*3+2
C
   30 IF(IZH-IZL.GT.1) THEN
C
         IZT=(IZL+IZH)/2
         IPT=IZT*3+2
         IF(X(3).LE.P(IPT)) THEN
C
            IZH=IZT
            IPH=IPT
         ELSE
C
            IZL=IZT
            IPL=IPT
         ENDIF
C
         GO TO 30
      ENDIF
C
C          THE POINT IS IN THE SECTION BOUNDED BY THE IZL TH AND THE
C          IZH TH Z VALUES.
C
C          NOW COMPUTE RMIN AND RMAX AND TEST THE VALUE OF R .
C
      IZSEC=IZL
      DZRAT=X(3)-P(IPL)
      DZRAT=DZRAT/(P(IPH)-P(IPL))
      RMN=P(IPL+1)+DZRAT*(P(IPH+1)-P(IPL+1))
*
* ***     Is the point inside the 'hole' at the centre of the volume?
*
      IF(R.LT.RMN) GO TO 999
*
      RMX=P(IPL+2)+DZRAT*(P(IPH+2)-P(IPL+2))
*
* ***     Is the point outside the volume?
*
      IF(R.GT.RMX) GO TO 999
C
C           POINT IS IN POLYGON.
C
      IYES=1
C
  999 END
+DECK,  GINROT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GINROT(X,RMAT,XNEW)
C.
C.    ******************************************************************
C     *                                                                *
C     *        ROUTINE TO ROTATE THE VECTOR X BY THE INVERSE OF THE    *
C     *       ROTATION MATRIX RMAT AND STORE THE RESULT AS THE         *
C     *        VECTOR XNEW                                             *
C.    *                                                                *
C.    *    ==>Called by : GDFR3D,GDSSUR,GD3D3D,GFLCAR,GFLPHI,GFLRAD    *
C.    *                   GFLTHE                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),XNEW(3),RMAT(10)
C.
C.    ------------------------------------------------------------------
C.
      IF(RMAT(10).NE.0.0) THEN
         XNEW(1) = X(1)*RMAT(1) + X(2)*RMAT(4) + X(3)*RMAT(7)
         XNEW(2) = X(1)*RMAT(2) + X(2)*RMAT(5) + X(3)*RMAT(8)
         XNEW(3) = X(1)*RMAT(3) + X(2)*RMAT(6) + X(3)*RMAT(9)
*
      ELSE
         XNEW(1) = X(1)
         XNEW(2) = X(2)
         XNEW(3) = X(3)
*
      ENDIF
      END
+DECK,  GINTCO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GINTCO (X, RLEFT, RRIGHT, DZ, TAU, TAUL)

C        ********************************************
C        *  This subroutine finds the intersection  *
C        *  of a given ray (described by array X)   *
C        *  with a given cone (described by radii   *
C        *  RLEFT and RRIGHT and half-distance DZ). *
C        *  Output parameter is TAU, and inter-     *
C        *  section point is X = XP + TAU*XD, etc.  *
C        *                                          *
C        *  Called by GNOCON                        *
C        *  Programmed by:  Patrick Weidhaas        *
C        *          CERN,   March 1988              *
C        ********************************************

+CDE, GCONSP.
      DIMENSION X(6)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION XP,YP,ZP,XD,YD,ZD,S,T,U,V,W
      DOUBLE PRECISION DISCR,SQDISC
+SELF.
C----------------------------------------------------

C...... Point of origin of ray:

      XP = X(1)
      YP = X(2)
      ZP = X(3)

C...... Direction cosines:

      XD = X(4)
      YD = X(5)
      ZD = X(6)

      TAU  = BIG
      TAUL = BIG

      S = 0.5 * (RLEFT + RRIGHT)
      T = (RLEFT - RRIGHT) / DZ

C......  Cone equation is:    x**2 + y**2 - Az**2 + Bz + C = 0

      A = 0.25 * T*T
      B = S * T
      C = -S*S

C......  To obtain "TAU", we must solve the quadratic equation
C......  Ut**2 + Vt + W = 0 .

      U = XD**2 + YD**2 - A*ZD**2
      V = 2.0 * (XP*XD + YP*YD - A*ZP*ZD) + B*ZD
      W = XP**2 + YP**2 - A*ZP**2 + B*ZP + C

      DISCR = V*V - 4.0*U*W
      IF (DISCR .LE. 0.0) GO TO 999
      IF(U.EQ.0.)GO TO 999
      SQDISC = SQRT (DISCR)
      TAU1 = (-V + SQDISC) / (2.0*U)
      TAU2 = (-V - SQDISC) / (2.0*U)


C......  Set TAU to the smallest positive root;
C......  otherwise let TAU = BIG .
C
C......  If both roots are positive, set TAUL to
C......  the larger one: it may be needed in the
C......  case of a PHI-segmented cone.

      IF (TAU1 .LT. 0.0) THEN
        IF (TAU2 .LT. 0.0) GO TO 999
        TAU = TAU2
      ELSE
        TAU = TAU1
        IF (TAU2 .GT. 0.0) THEN
          TAUL = TAU2
          IF (TAU2.LT.TAU1) THEN
            TAU = TAU2
            TAUL = TAU1
          ENDIF
        ENDIF
      ENDIF

  999 CONTINUE
      END

+DECK,  GINTRP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GINTRP(X,P,IYES)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO PERFORM GINME FUNCTION FOR A GENERAL TRAPEZOID.  *
C.    *        X  -  A VECTOR DIMENSION 3 GIVING THE POINT.            *
C.    *        P  -  THE VECTOR OF PARAMETERS;                         *
C.    *                  DZ - HALF LENGTH ALONG Z AXIS,                *
C.    *                  TX - DX/DZ OF LINE LINKING FACE CENTRES,      *
C.    *                  TY - DY/DZ   ''                               *
C.    *                  H1 - HALF LENGTH IN Y DIR OF FACE AT Z=-DZ,   *
C.    *                 LB1 - HALF LEN. OF LOW Y EDGE OF SAME FACE,    *
C.    *                 LT1 - HALF LEN. OF HIGH Y EDGE OF SAME FACE,   *
C.    *                TTH1 - DX/DY OF LINE LINKING EDGE CENTRES,      *
C.    *                  H2 - AS 1 FOR FACE AT Z=DZ                    *
C.    *                 LB2 -   ''                                     *
C.    *                 LT2 -   ''                                     *
C.    *                TTH2 -   ''                                     *
C.    *     IYES  -  RETURNED AS 1 IF POINT IS INSIDE, OTHERWISE 0.    *
C.    *                                                                *
C.    *    ==>Called by : GINME                                        *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),P(11)
      SAVE LDZ,LLTAN,LH1,LTTH1,LH2,LTTH2
C
      DATA LDZ,LLTAN,LH1,LTTH1,LH2,LTTH2/1,2,4,7,8,11/
C.
C.              ----------------------------------------
C.
      IYES=0
C
C             CHECK Z FIRST.
C
      IF(ABS(X(3)).GT.P(LDZ)) GO TO 99
C
C             COMPUTE TRAPEZIUM PARAMETERS AND X,Y IN TRAP COORDS.
C
      SP1=(P(LDZ)-X(3))*0.5/P(LDZ)
      SP2=(P(LDZ)+X(3))*0.5/P(LDZ)
      H=P(LH1)*SP1+P(LH2)*SP2
      YL=X(2)-X(3)*P(LLTAN+1)
C
C            CHECK Y.
C
      IF(ABS(YL).GT.H) GO TO 99
      IF ( H .EQ. 0 ) THEN
         TTH = 0.
      ELSE
         TTH=(P(LH1)*P(LTTH1)*SP1+P(LH2)*P(LTTH2)*SP2)/H
      END IF
      BL=P(LH1+1)*SP1+P(LH2+1)*SP2
      TL=P(LH1+2)*SP1+P(LH2+2)*SP2
      XL=X(1)-X(3)*P(LLTAN)
C
C            CHECK X.
C
      DX=BL*(H-YL)*0.5/H+TL*(H+YL)*0.5/H
      XL=XL-YL*TTH
      IF(ABS(XL).GT.DX) GO TO 99
C
C            INSIDE.
C
      IYES=1
C
   99 CONTINUE
      END
+DECK,  GITRAN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GITRAN(X,DX,IROT,XNEW)
C.
C.    ******************************************************************
C     *                                                                *
C     *        ROUTINE TO APPLY THE TRANSFORMATION GIVEN BY            *
C     *        THE POINT DX AND THE ROTATION MATRIX IN THE GEANT       *
C     *        ROTATION MATRIX BANKS WITH INDEX NUMBER IROT TO THE     *
C     *        POINT X, STORING THE RESULT AS THE POINT XNEW.          *
C     *                                                                *
C.    *    ==>Called by : GFTRAC,GINVOL,GMEPOS,GNEXT,GTMEDI,GTNEXT     *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      DIMENSION X(3),DX(3),XNEW(3)
C.
C.    ------------------------------------------------------------------
C.
      IF(IROT.EQ.0) THEN
         XNEW(1) = X(1) - DX(1)
         XNEW(2) = X(2) - DX(2)
         XNEW(3) = X(3) - DX(3)
*
      ELSE
         XL1 = X(1) - DX(1)
         XL2 = X(2) - DX(2)
         XL3 = X(3) - DX(3)
         JR=LQ(JROTM-IROT)
         XNEW(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XNEW(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XNEW(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
      ENDIF
      END
+DECK,  GLMOTH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GLMOTH (IUDET, IUNUM, NLEV, LVOLS, LINDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Loads the top part of the Volume tree in LVOLS (IVO's),      *
C.    *   LINDX (IN indices) for a given volume defined through        *
C.    *   its name IUDET and number IUNUM.                             *
C.    *                                                                *
C.    *   The routine stores only upto the last level where JVOLUM     *
C.    *   data structure is developed. If there is no development      *
C.    *   above the current level, it returns NLEV zero.               *
C.    *                                                                *
C.    *   Called by : GDRAW, GFIPAR, GFPARA, GLVOLU                    *
C.    *   Authors   : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
C.
      DIMENSION  LVOLS(*), LINDX(*)
      CHARACTER*(*) IUDET
      SAVE MULT
C.
C.    ------------------------------------------------------------------
*
      NLEV = 1
      MULT = IUNUM
      NLDV = 0
      CALL UCTOH (IUDET, LINAM, 4, 4)
      IVOS = IUCOMP (LINAM, IQ(JVOLUM+1), IQ(JVOLUM-1))
      LVOLS(1) = IVOS
*
* *** Scan all volumes to check if it could be mother
*       of the current volume
*
   10 IF (IVOS.GT.1) THEN
         DO 25 IVO = 1, IQ(JVOLUM-1)
            IF (IVO.EQ.IVOS)            GO TO 25
            JVO = LQ(JVOLUM-IVO)
            NIN = Q(JVO+3)
            IF (NIN.EQ.0)               GO TO 25
*
            IF (NIN.LT.0) THEN
               JDIV = LQ(JVO-1)
               IVOT = Q(JDIV+2)
               IF (IVOT.NE.IVOS)        GO TO 25
               IF (MULT.EQ.0) THEN
                  IN   = 1
                  MULT = 1
               ELSE
                  IN   = MULT
               ENDIF
*
            ELSE
               DO 15 IN = 1, NIN
                  JIN  = LQ(JVO-IN)
                  IVOT = Q(JIN+2)
                  IF (IVOT.NE.IVOS)     GO TO 15
                  MULTI = Q(JIN+3)
                  IF (MULT.EQ.0) THEN
                     MULT = MULTI
                  ELSE
                     IF (MULT.NE.MULTI) GO TO 15
                  ENDIF
                  GO TO 20
   15          CONTINUE
               GO TO 25
            ENDIF
*
   20       LINDX(NLEV) = IN
            IF (NLDV.NE.0)              GO TO 30
            NLEV = NLEV + 1
            LVOLS(NLEV) = IVO
            IVOS = IVO
            MULT = 0
            IF (LQ(JVO).NE.0) NLDV = NLEV
            GO TO 10
   25    CONTINUE
      ENDIF
*
* *** Now rearrange the order of the volumes
*
   30 IF (IVOS.EQ.1) LINDX(NLEV) = 1
      NLV  = NLEV/2
      IF (NLV.GT.0) THEN
         DO 35 I = 1, NLV
            J   = NLEV - I + 1
            LID = LINDX(I)
            LVO = LVOLS(I)
            LINDX(I) = LINDX(J)
            LVOLS(I) = LVOLS(J)
            LINDX(J) = LID
            LVOLS(J) = LVO
   35    CONTINUE
      ENDIF
      NLEV = NLEV -1
      IF (LQ(LQ(JVOLUM-LVOLS(1))).EQ.0) NLEV = 0
*                                                             END GLMOTH
  999 END
+DECK,  GLVOLU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GLVOLU (NLEV, LNAM, LNUM, IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Loads the common block GCVOLU for the volume at lebel NLEV   *
C.    *   as described by the lists of names (LNAM) and numbers (LNUM) *
C.    *                                                                *
C.    *   The routine is optimized and does not re-compute the part of *
C.    *   history already available in GCVOLU.                         *
C.    *                                                                *
C.    *   IER returns non zero in case of fatal error                  *
C.    *                                                                *
C.    *   Called by : 'User', GDRVOL                                   *
C.    *   Authors   : S.Banerjee, F.Bruyant, A.McPherson               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCUNIT.
+CDE, GCVOLU.
      PARAMETER  (NLVMAX=15)
      INTEGER    LNUM(*), LNAM(*), IDTYP(3,12)
      DIMENSION  LVOLS(NLVMAX), LINDX(NLVMAX)
      REAL       XC(3)
      CHARACTER*4 KNAME
      SAVE IDTYP
C.
      DATA IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +             2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +             2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
      IER = 0
      NLEVL=NLEV
      IF (NLEVL.LE.0.OR.NLEVL.GT.NLVMAX) GO TO 910
      IF (JGPAR.EQ.0) THEN
         CALL MZBOOK (IXCONS, JGPAR, JGPAR, 1, 'GPAR', NLVMAX, 0,
     +                NLVMAX, 2, 0)
      ENDIF
      IF (NLEVEL.EQ.0)                 GO TO 20
*
* *** Scan tree from top to bottom to
*       check if some levels are already filled
*
      NLMX = MIN (NLEVL, NLEVEL)
      NLEVEL = 0
      DO 10 I = 1,NLMX
         IF (LNAM(I).NE.NAMES(I))  GO TO 15
         IF (LNUM(I).NE.NUMBER(I)) GO TO 15
         NLEVEL = NLEVEL +1
   10 CONTINUE
      IF (NLEVL.GT.NLEVEL) GO TO 95
      nlevel=0
   15 IF (NLEVEL.NE.0)    GO TO 95
*
* *** Special case, first volume
*
   20 IF (JVOLUM.EQ.0)    GO TO 920
      IF (IQ(JVOLUM+1).EQ.LNAM(1)) THEN
         IVO = 1
      ELSE
+SELF, IF=DEBUG.
         WRITE (CHMAIL, 7000) LNAM(1)
         CALL GMAIL (0, 0)
+SELF.
         IF (IQ(JVOLUM-1).LE.1) GO TO 920
         DO 25 IV=2,IQ(JVOLUM-1)
            IF (IQ(JVOLUM+IV).EQ.LNAM(1)) THEN
               IVO = IV
               GO TO 30
            ENDIF
   25    CONTINUE
         WRITE (CHMAIL, 8000) LNAM(1)
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
   30 NLEVEL = 1
      JVO = LQ(JVOLUM-IVO)
      LVOLUM(NLEVEL) = IVO
      NAMES(NLEVEL)  = IQ(JVOLUM+IVO)
      NUMBER(NLEVEL) = LNUM(1)
      GONLY(NLEVEL)  = 1.
      IF (LQ(JVO).EQ.0) THEN
         NLDEV(1) = NLVMAX
      ELSE
         NLDEV(1) = 1
      ENDIF
      IF (IVO.EQ.1) THEN
         LINDEX(NLEVEL) = 1
         LINMX (NLEVEL) = 1
         NLDM = 0
         IQ(JGPAR+NLEVEL) = Q(JVO+5)
         LQ(JGPAR-NLEVEL) = JVO + 6
      ELSE
         CALL UHTOC(NAMES,4,KNAME,4)
         CALL GLMOTH (KNAME, NUMBER, NLDM, LVOLS, LINDX)
         IF (NLDM.GT.0) THEN
            JVOM = LQ(JVOLUM-LVOLS(NLDM))
            NIN  = Q(JVOM+3)
            IF (NIN.LT.0) THEN
               LINDEX(NLEVEL) = LNUM(1)
            ELSE
               LINMX(NLEVEL)  = NIN
               DO 70 IN = 1, NIN
                  JIN  = LQ(JVOM-IN)
                  IF (IFIX(Q(JIN+2)).NE.LVOLUM(1)) GO TO 70
                  IF (IFIX(Q(JIN+3)).NE.LNUM(1))   GO TO 70
                  LINDEX(NLEVEL) = IN
                  GO TO 75
   70          CONTINUE
               GO TO 920
            ENDIF
   75       JPAR = LQ(LQ(JVOLUM-LVOLS(1)))
            IF (NLDM.GT.1) THEN
               DO 76 ILEV = 2, NLDM
                  IF (IQ(JPAR+1).EQ.0) THEN
                     JPAR = LQ(JPAR-LINDX(ILEV))
                     IF (JPAR.EQ.0) GO TO 77
                  ELSE IF (IQ(JPAR-3).GT.1) THEN
                     JPAR = LQ(JPAR-LINDX(ILEV))
                  ELSE
                     JPAR = LQ(JPAR-1)
                  ENDIF
   76          CONTINUE
            ENDIF
            IF (NIN.GT.0) THEN
               JPAR = LQ(JPAR-IN)
               IF (JPAR.EQ.0) GO TO 77
            ELSE
               NDIV = IQ(JPAR+1)
               LINMX(NLEVEL) = NDIV
               IF (LINDEX(1).GT.NDIV) THEN
                  NL1  = 1
                  NAME = IQ(JVOLUM+LVOLS(NLDM))
                  GO TO 950
               ENDIF
               IF (IQ(JPAR-3).GT.1) THEN
                  IF (LINDEX(1).GT.0) THEN
                     JPAR = LQ(JPAR-LINDEX(1))
                  ELSE
                     JPAR = LQ(JPAR-1)
                  ENDIF
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
            ENDIF
            IQ(JGPAR+NLEVEL) = IQ(JPAR+5)
            LQ(JGPAR-NLEVEL) = JPAR + 5
            GO TO 78
   77       NPAR = Q(JVO+5)
            IF (NPAR.EQ.0.AND.NIN.GT.0) THEN
               IQ(JGPAR+NLEVEL) = Q(JIN+9)
               LQ(JGPAR-NLEVEL) = JIN+9
            ELSE
               IQ(JGPAR+NLEVEL) = NPAR
               LQ(JGPAR-NLEVEL) = JVO + 6
            ENDIF
         ELSE
            LINDEX(NLEVEL) = 1
            LINMX(NLEVEL)  = 1
            IQ(JGPAR+NLEVEL) = Q(JVO+5)
            LQ(JGPAR-NLEVEL) = JVO + 6
         ENDIF
      ENDIF
   78 CONTINUE
*
      DO 90 I = 1,3
         GTRAN(I,1) = 0.
         DO 80 J = 1,3
            K = (I-1)*3 +J
            GRMAT(K,1) = 0.
   80    CONTINUE
         K = I*4 -3
         GRMAT(K,1) = 1.
   90 CONTINUE
      GRMAT(10,1) = 0.
      IF (NLEVL.GT.1) THEN
         GO TO 100
      ELSE
         GO TO 990
      ENDIF
*
* *** Check if there are volumes up in the tree where development
*           structure exists
*
   95 IF (LVOLUM(1).EQ.1.OR.NLDEV(1).EQ.1) THEN
         NLDM = 0
      ELSE
         CALL UHTOC(NAMES,4,KNAME,4)
         CALL GLMOTH (KNAME, NUMBER, NLDM, LVOLS, LINDX)
      ENDIF
*
*  ** Next level
*
  100 CONTINUE
      IVO = LVOLUM(NLEVEL)
      JVO = LQ(JVOLUM-IVO)
      NLD = NLDEV(NLEVEL)
      NIN = Q(JVO+3)
      IF (NIN.EQ.0) GO TO 930
      NL1 = NLEVEL +1
*
      IF (NIN.GT.0) THEN
*
*  *     Content obtained by positioning
*
         DO 110 IN=1,NIN
            JIN=LQ(JVO-IN)
            IVOT=Q(JIN+2)
            IF (IQ(JVOLUM+IVOT).NE.LNAM(NL1)) GO TO 110
            INUM = Q(JIN+3)
            IF (INUM.EQ.LNUM(NL1)) GO TO 115
  110    CONTINUE
         GO TO 940
  115    IF (NLEVEL.GE.NLD) THEN
*           (case with JVOLUM structure locally developed)
            JPAR = LQ(LQ(JVOLUM-LVOLUM(NLD)))
            DO 120 ILEV = NLD, NLEVEL
               IF (IQ(JPAR+1).EQ.0) THEN
                  IF (ILEV.EQ.NLEVEL) THEN
                     JPAR = LQ(JPAR-IN)
                  ELSE
                     JPAR = LQ(JPAR-LINDEX(ILEV+1))
                  ENDIF
                  IF (JPAR.EQ.0) GO TO 125
               ELSE IF (IQ(JPAR-3).GT.1) THEN
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
  120       CONTINUE
            JPAR = JPAR + 5
            NPAR = IQ(JPAR)
            GO TO 130
         ELSE IF (NLDM.GT.0) THEN
            JPAR = LQ(LQ(JVOLUM-LVOLS(1)))
            IF (NLDM.GT.1) THEN
               DO 121 ILEV = 2, NLDM
                  IF (IQ(JPAR+1).EQ.0) THEN
                     JPAR = LQ(JPAR-LINDX(ILEV))
                     IF (JPAR.EQ.0)   GO TO 125
                  ELSE IF (IQ(JPAR-3).GT.1) THEN
                     JPAR = LQ(JPAR-LINDX(ILEV))
                  ELSE
                     JPAR = LQ(JPAR-1)
                  ENDIF
  121          CONTINUE
            ENDIF
            DO 122 ILEV = 1, NL1
               IF (IQ(JPAR+1).EQ.0) THEN
                  IF (ILEV.EQ.NL1) THEN
                     JPAR = LQ(JPAR-IN)
                  ELSE
                     JPAR = LQ(JPAR-LINDEX(ILEV))
                  ENDIF
                  IF (JPAR.EQ.0) GO TO 125
               ELSE IF (IQ(JPAR-3).GT.1) THEN
                  JPAR = LQ(JPAR-LINDEX(ILEV))
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
  122       CONTINUE
            JPAR = JPAR + 5
            NPAR = IQ(JPAR)
            GO TO 130
         ENDIF
*        (normal case)
  125    JVOT = LQ(JVOLUM-IVOT)
         NPAR = Q(JVOT+5)
         IF (NPAR.EQ.0) THEN
            JPAR = JIN + 9
            NPAR = Q(JPAR)
         ELSE
            JPAR = JVOT + 6
         ENDIF
*
  130    IROTT = Q(JIN+4)
         NINSK = NIN
         GONLY(NL1) = Q(JIN+8)
         CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5), IROTT
     +,               GTRAN(1,NL1), GRMAT(1,NL1))
*
      ELSE
*
*  *     This section for divided objects
*
         JDIV = LQ(JVO-1)
         IVOT = Q(JDIV+2)
         IF (LNAM(NL1).NE.IQ(JVOLUM+IVOT)) GO TO 960
         JVOT = LQ(JVOLUM-IVOT)
         IF (NLEVEL.GT.NLD) THEN
*           (case with JVOLUM structure locally developed)
            JPAR = LQ(LQ(JVOLUM-LVOLUM(NLD)))
            DO 135 ILEV = NLD, NLEVEL-1
               IF (IQ(JPAR+1).EQ.0) THEN
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
                  IF (JPAR.EQ.0) GO TO 140
               ELSE IF (IQ(JPAR-3).GT.1) THEN
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
               IF (ILEV.EQ.NLEVEL-1) THEN
                  NDIV = IQ(JPAR+1)
                  ORIG =  Q(JPAR+2)
                  STEP =  Q(JPAR+3)
               ENDIF
  135       CONTINUE
            GO TO 145
         ELSE IF (NLD.EQ.NLEVEL) THEN
            JPAR = LQ(LQ(JVOLUM-LVOLUM(NLD)))
         ELSE IF (NLDM.GT.0) THEN
            JPAR = LQ(LQ(JVOLUM-LVOLS(1)))
            IF (NLDM.GT.1) THEN
               DO 136 ILEV = 2, NLDM
                  IF (IQ(JPAR+1).EQ.0) THEN
                     JPAR = LQ(JPAR-LINDX(ILEV))
                     IF (JPAR.EQ.0) GO TO 140
                  ELSE IF (IQ(JPAR-3).GT.1) THEN
                     JPAR = LQ(JPAR-LINDX(ILEV))
                  ELSE
                     JPAR = LQ(JPAR-1)
                  ENDIF
  136          CONTINUE
            ENDIF
            DO 137 ILEV = 1, NLEVEL
               IF (IQ(JPAR+1).EQ.0) THEN
                  JPAR = LQ(JPAR-LINDEX(ILEV))
                  IF (JPAR.EQ.0) GO TO 140
               ELSE IF (IQ(JPAR-3).GT.1) THEN
                  JPAR = LQ(JPAR-LINDEX(ILEV))
               ELSE
                  JPAR = LQ(JPAR-1)
               ENDIF
               IF (ILEV.EQ.NLEVEL) THEN
                  NDIV = IQ(JPAR+1)
                  ORIG =  Q(JPAR+2)
                  STEP =  Q(JPAR+3)
               ENDIF
  137       CONTINUE
            GO TO 145
         ELSE
            JPAR = 0
         ENDIF
*        (normal case)
  140    NDIV = Q(JDIV+3)
         ORIG = Q(JDIV+4)
         STEP = Q(JDIV+5)
  145    IN   = LNUM(NL1)
         IF (IN.LT.1.OR.IN.GT.NDIV) THEN
            NAME = NAMES(NLEVEL)
            GO TO 950
         ENDIF
*
         IF (JPAR.NE.0) THEN
            IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-IN)
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
            JPAR = JPAR + 5
            NPAR = IQ(JPAR)
         ELSE
            NPAR = Q(JVOT+5)
            JPAR = JVOT + 6
         ENDIF
         GONLY(NL1) = GONLY(NLEVEL)
*
         IAXIS = Q(JDIV+1)
         ISH   = Q(JVO+2)
         IDT   = IDTYP(IAXIS,ISH)
         NINSK = NDIV
*
         IF (IDT.EQ.1) THEN
            DO 151 I = 1, 3
  151       XC(I) = 0.
            XC(IAXIS) = ORIG + (IN - 0.5) * STEP
            IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
               CALL GCENT (IAXIS, XC)
            ENDIF
            IF (GRMAT(10,NLEVEL).EQ.0.0) THEN
               DO 152 I = 1, 3
  152          GTRAN(I,NL1) = GTRAN(I,NLEVEL)+XC(I)
               DO 153 I = 1, 10
  153          GRMAT(I,NL1) = GRMAT(I,NLEVEL)
            ELSE
               CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), XC, 0,
     +                      GTRAN(1,NL1), GRMAT(1,NL1))
            ENDIF
*
         ELSE IF (IDT.EQ.3.OR.IDT.EQ.4) THEN
            IF (IDT.EQ.3) THEN
               PH0  = DEGRAD * (ORIG + (IN - 0.5) * STEP)
               CPHR = COS (PH0)
               SPHR = SIN (PH0)
            ELSE
               PH0  = 0.0
               CPHR = 1.0
               SPHR = 0.0
            ENDIF
            DO 154 I = 1, 3
               GTRAN(I  ,NL1) = GTRAN(I  ,NLEVEL)
               GRMAT(I  ,NL1) = GRMAT(I  ,NLEVEL)*CPHR
     +                        + GRMAT(I+3,NLEVEL)*SPHR
               GRMAT(I+3,NL1) = GRMAT(I+3,NLEVEL)*CPHR
     +                        - GRMAT(I  ,NLEVEL)*SPHR
               GRMAT(I+6,NL1) = GRMAT(I+6,NLEVEL)
  154       CONTINUE
            IF (PH0.EQ.0.0.AND.GRMAT(10,NLEVEL).EQ.0.0) THEN
               GRMAT(10,NL1) = 0.0
            ELSE
               GRMAT(10,NL1) = 1.0
            ENDIF
*
         ELSE
            DO 155 I = 1, 3
  155       GTRAN(I,NL1) = GTRAN(I,NLEVEL)
            DO 156 I = 1, 10
  156       GRMAT(I,NL1) = GRMAT(I,NLEVEL)
         ENDIF
      ENDIF
*
  200 LINDEX(NL1) = IN
      LVOLUM(NL1) = IVOT
      NAMES(NL1)  = LNAM(NL1)
      NUMBER(NL1) = LNUM(NL1)
      LINMX(NL1)  = NINSK
      IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
         NLDEV(NL1) = NLD
      ELSE
         NLDEV(NL1) = NL1
      ENDIF
      IQ(JGPAR+NL1) = NPAR
      LQ(JGPAR-NL1) = JPAR
      NLEVEL = NL1
      IF (NLEVEL.EQ.NLEVL) GO TO 990
      GO TO 100
*
* *** Error messages
*
  910 IER = 1
      WRITE (CHMAIL, 1000) NLEV
      CALL GMAIL (0, 0)
      GO TO 999
*
  920 IER = 2
      WRITE (CHMAIL, 2000) LNAM(1)
      CALL GMAIL (0, 0)
      GO TO 999
*
  930 IER = 3
      WRITE (CHMAIL, 3000) NLEVEL,NLEV,NAMES(NLEVEL)
      CALL GMAIL (0, 0)
      GO TO 999
*
  940 IER = 4
      WRITE (CHMAIL, 4000) LNAM(NL1),NL1,NAMES(NLEVEL)
      CALL GMAIL (0, 0)
      GO TO 999
*
  950 IER = 5
      WRITE (CHMAIL, 5000) NL1,LNUM(NL1),NAME,NDIV
      CALL GMAIL (0, 0)
      GO TO 999
*
  960 IER = 6
      WRITE (CHMAIL, 6000) NL1,LNAM(NL1),IQ(JVOLUM+IVOT)
      CALL GMAIL (0, 0)
      GO TO 999
*
  990 CONTINUE
+SELF, IF=DEBUG.
      WRITE (CHMAIL, 1001) NLEVEL
      CALL GMAIL (0, 0)
      DO 991 I1=1,NLEVEL,5
         I2 = I1 + 4
         IF (I2.GT.NLEVEL) I2 = NLEVEL
         WRITE (CHMAIL, 1003) (NAMES(I),NUMBER(I),LVOLUM(I),LINDEX(I),
     +   I=I1,I2)
         CALL GMAIL (0, 0)
  991 CONTINUE
      DO 992 I= 1,NLEVEL
         WRITE (CHMAIL, 1002) (GTRAN(J,I),J=1,3),(GRMAT(J,I),J=1,10)
         CALL GMAIL (0, 0)
  992 CONTINUE
 1001 FORMAT (' GLVOLU : NLEVEL =',I3)
 1003 FORMAT (5(1X,A4,3I3))
 1002 FORMAT (1X,13F9.4)
+SELF.
*
 1000 FORMAT (' GLVOLU : called with useless Level # ',I5)
 2000 FORMAT (' GLVOLU : Volume ',A4,' not top of tree, or no tree')
 3000 FORMAT (' GLVOLU : at Level ',I3,' of ',I3,' there are no',
     *        ' contents for Volume ',A4)
 4000 FORMAT (' GLVOLU : Volume ',A4,' for Level ',I3,
     *        ' does not exist in Volume ',A4)
 5000 FORMAT (' GLVOLU : at Level ',I3,' asked for #',I3,
     *        ' in divided Volume ',A4,' which has ',I3,' divisions.')
 6000 FORMAT (' GLVOLU : at Level ',I3,' user name ',A4,
     *        ' not equal to name ',A4,' of division.')
+SELF, IF=DEBUG.
 7000 FORMAT (' GLVOLU : Warning, ',A4,' not top of tree',
     *        ' you should reset NLEVEL to 0 before tracking !')
+SELF.
 8000 FORMAT (' GLVOLU : Volume ',A4,' Level 1 does not exist')
*                                                             END GLVOLU
  999 END
+DECK,  GMEDI2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

+SELF, IF=OLD.
      SUBROUTINE GMEDIA (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Called by :  GTREVE, GLTRAC, 'User'                          *
C.    *   Authors   : R.Brun, F.Bruyant, A.McPherson                   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+SELF, IF=OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=OLD.
C.
      DIMENSION  X(*)
      REAL       XC(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
      IF (NLEVEL.EQ.0) CALL GMEDIN
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
*            The information contained in INFROM has to be invalidated
*            because it has no meaning for the subsequent tracking. INFR
*            is a local variable used to optimise the search in the
*            geometry tree.
*
      INFROM = 0
*
* *** Check if point is in current volume
*
      INFR   = 0
      JVIN   = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*GRMAT(3
     +      ,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*GRMAT(6
     +      ,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*GRMAT(9
     +      ,NLEVEL)

      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
*
*       Do not set INFR whne going up the tree. GMEDIA can be called
*       by the user and it  should not assume  that the previous
*       position has something to do with the current search. INFR
*       is otherwise useful when searching in a 'MANY' volume
*       configuration. This statement is commented for the above reason.
*
*              INFR  =LINDEX(NLEVEL+1)
            ELSE
               INFR  =0
            ENDIF
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ENDIF
*
*  **   Point is in current volume
*
      IF(INFR  .GT.0) THEN
         JIN=LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
      NLMIN = NLEVEL
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            INFR   = 0
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT  = LQ(JVO-NIN-1)+1
         NCONT  = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               IDIV = LOCATF (Q(JSB+3), NSB, XC(IAX))
            ELSE
               CALL GFCOOR (XC, IAX, CX)
               IDIV = LOCATF (Q(JSB+3), NSB, CX)
            ENDIF
            IF (IDIV.LT.0) IDIV = -IDIV
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=OLD, IF=-USRJMP.
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=OLD, IF=USRJMP.
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF, IF=OLD.
            ELSEIF (INFR  .GT.0) THEN
               JNUP = LQ(LQ(JVO-INFR  )-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF (GONLY(NLEVEL).NE.0.) NLMANY = 0
                  INFR   = 0
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR  .GT.0) THEN
            JIN = LQ(JVO-INFR  )
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)

         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GMEDIA
  999 IF(JGSTAT.NE.0) CALL GFSTAT(2)
      END
+SELF.
+DECK,  GMEDIA, T=FORT.
* Revision 1.3  1998/02/09 16:48:33  japost
*   Simone's fix for MANY volumes in gmedia.
* Revision 1.2  1996/09/30 14:25:07  ravndal
* Windows NT related modifications
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

+SELF, IF=-OLD.
      SUBROUTINE GMEDIA (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Called by :  GTREVE, GLTRAC, 'User'                          *
C.    *   Authors   : R.Brun, F.Bruyant, A.McPherson                   *
C.    *               S.Giani.                                         *
C.    *                                                                *
C.    *   Modified by S.Giani (1993) to perform the search according   *
C.    *    to the new 'virtual divisions' algorithm and to build the   *
C.    *    stack of the 'possible overlapping volumes' in the case of  *
C.    *    MANY volumes. Any kind of boolean operation is now possible.*
C.    *    Divisions along arbitrary axis are now possible.            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SELF, IF=-OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=-OLD.
+CDE, GCVDMA.
+CDE, GCHVIR.
C.
      DIMENSION  X(*)
      REAL       XC(6)
      LOGICAL    BTEST
      CHARACTER*4 NAME
C.
C.    ------------------------------------------------------------------
*
      nvmany=0
      nfmany=0
      new2fl=0
*
      IF (NLEVEL.EQ.0) CALL GMEDIN
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
*            The information contained in INFROM has to be invalidated
*            because it has no meaning for the subsequent tracking. INFR
*            is a local variable used to optimise the search in the
*            geometry tree.
*
      INFROM = 0
*
* *** Check if point is in current volume
*
      INFR   = 0
      JVIN   = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*GRMAT(3
     +      ,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*GRMAT(6
     +      ,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*GRMAT(9
     +      ,NLEVEL)

      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
*
*       Do not set INFR whne going up the tree. GMEDIA can be called
*       by the user and it  should not assume  that the previous
*       position has something to do with the current search. INFR
*       is otherwise useful when searching in a 'MANY' volume
*       configuration. This statement is commented for the above reason.
*
*              INFR  =LINDEX(NLEVEL+1)
            ELSE
               INFR  =0
            ENDIF
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ENDIF
*
*  **   Point is in current volume
*
      IF(INFR  .GT.0) THEN
         JIN=LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
* To avoid starting from the protuding part of a MANY volume
      IF(GONLY(NLEVEL).EQ.0.) THEN
        NLEVEL = NLEVEL -1
        GO TO 100
      ENDIF
      NLMIN = NLEVEL
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            INFR   = 0
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT  = LQ(JVO-NIN-1)+1
         NCONT  = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  new2fl=0
                  IF (GONLY(NLEVEL).NE.0.) THEN
                    NLMANY = 0
                    nvmany = 0
                    nfmany = 0
                  ENDIF
                  INFR   = 0
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR  .GT.0) THEN
            JIN = LQ(JVO-INFR  )
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
            nfmany=nvmany+1
         ENDIF
         if(new2fl.eq.0)then
            nvmany=nvmany+1
            manyle(nvmany)=nlevel
            do 401 i = 1,nlevel
              manyna(nvmany,i)=names(i)
              manynu(nvmany,i)=number(i)
 401        continue
         endif
*
*   *   Go up the tree up to a volume with positioned contents
*
         new2fl=-1
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)

         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      if(nlmany.eq.0)then
        nvmany=0
        nfmany=0
      endif
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GMEDIA
  999 IF(JGSTAT.NE.0) CALL GFSTAT(2)
      END
+SELF.
+DECK,  GMEDIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GMEDIN
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Initializes common /GCVOLU/ and JGPAR structure              *
C.    *                                                                *
C.    *   Called by : GMEDIA                                           *
C.    *                                                                *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSTAK.
+CDE, GCVOLU.
C.    ------------------------------------------------------------------
*
* *** Initialize first level in /GCVOLU/ and in JGPAR structure
*
      NLEVEL      = 1
      LVOLUM(1)   = 1
      NAMES(1)    = IQ(JVOLUM+1)
      NUMBER(1)   = 1
      LINDEX(1)   = 1
      LINMX(1)    = 1
      GONLY(1)    = 1.
      JVO         = LQ(JVOLUM-1)
      NLEVMX      = IQ(LQ(JVOLUM)-1)
      NLDEV(1)    = NLEVMX
      IF (LQ(JVO).NE.0) NLDEV(1) = 1
*
      IF (JGPAR.EQ.0) CALL MZBOOK (IXCONS, JGPAR, JGPAR, 1,'GPAR',
     +                                     NLEVMX, 0, NLEVMX, 2, 0)
      IQ(JGPAR+1) = Q(JVO+5)
      LQ(JGPAR-1) = JVO +6
*
      DO 29 I = 1,3
         GTRAN(I, 1) = 0.
         DO 19 J = 1,3
            K = (I-1)*3 +J
            GRMAT(K, 1) = 0.
   19    CONTINUE
         K = I*4 -3
         GRMAT(K, 1) = 1.
   29 CONTINUE
      GRMAT(10,1) = 0.
*                                                             END GMEDIN
      END
+DECK,  GMEDIV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GMEDIV (JVO, IN, XC, IFL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Updates the common /GCVOLU/ and the structure JGPAR          *
C.    *     for contents defined by division.                          *
C.    *                                                                *
C.    *   For IFL nonzero, it also checks if the point XC is inside    *
C.    *     the content. It returns IN = 0, if the point is outside.   *
C.    *     Otherwise, it transforms XC in the local system.           *
C.    *                                                                *
C.    *   For IFL zero, IN is returned 0, if IN > NDIV.                *
C.    *                                                                *
C.    *   Input : JVO, IN, XC, IFL                                     *
C.    *   Output : IN, XC                                              *
C.    *                                                                *
C.    *   Called by : GDRAW, GMEDIA                                    *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCPOLY.
+CDE, GCVOLU.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION DPHIO, TPIDEG, ONE
+SELF.
      DIMENSION  XC(*)
      REAL       X0(3)
      INTEGER    IDTYP(3,12)
      PARAMETER (TPIDEG=360,ONE=1)
      SAVE IDTYP
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
C.
      JDIV  = LQ(JVO-1)
      ISH   = Q(JVO+2)
      IAXIS = Q(JDIV+1)
      IVOT  = Q(JDIV+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPAR = 0
      ELSE
*       (case with structure JVOLUM locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 20
         DO 10 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPAR+1).EQ.0) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
               IF (JPAR.EQ.0) GO TO 20
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV  = IQ(JPAR+1)
               ORIG  =  Q(JPAR+2)
               SDIV  =  Q(JPAR+3)
            ENDIF
   10    CONTINUE
         GO TO 30
      ENDIF
*      (normal case)
   20 NDIV  = Q(JDIV+3)
      ORIG  = Q(JDIV+4)
      SDIV  = Q(JDIV+5)
*
   30 IDT = IDTYP(IAXIS,ISH)
      IF (IFL.NE.0) THEN
         IF (IDT.EQ.1) THEN
*
*         Division along X, Y or Z axis
*
            XTT = XC(IAXIS)
            IF (ISH.EQ.10) THEN
               IF (IAXIS.NE.3) THEN
                  XTT = XTT - Q(LQ(JGPAR-NLEVEL)+IAXIS+4) * XC(3)
                  IF (IAXIS.EQ.1) THEN
                     YT  = XC(2) - Q(LQ(JGPAR-NLEVEL)+6) * XC(3)
                     XTT = XTT - Q(LQ(JGPAR-NLEVEL)+4) * YT
                  ENDIF
               ENDIF
            ENDIF
            IN = (XTT -ORIG)/SDIV +1
         ELSE IF (IDT.EQ.2) THEN
*
*          Division along R axis
*
            R = XC(1)**2 + XC(2)**2
            IF (ISH.EQ.9) R = R + XC(3)**2
            R = SQRT (R)
            IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
               IN = (R - ORIG) / SDIV + 1
            ELSE IF (ISH.EQ.7.OR.ISH.EQ.8) THEN
               IPAR = LQ(JGPAR-NLEVEL)
               DR   = 0.5 * (Q(IPAR+4) - Q(IPAR+2)) / Q(IPAR+1)
               RMN  = 0.5 * (Q(IPAR+4) + Q(IPAR+2)) + DR * XC(3)
               DR   = 0.5 * (Q(IPAR+5) - Q(IPAR+3)) / Q(IPAR+1)
               RMX  = 0.5 * (Q(IPAR+5) + Q(IPAR+3)) + DR * XC(3)
               STP  = (RMX - RMN) / NDIV
               IN   = (R - RMN) / STP + 1
            ELSE
               IPAR = LQ(JGPAR-NLEVEL)
               IF (ISH.EQ.12) THEN
                  IPT = IPAR + 1
               ELSE
                  IPT = IPAR + 2
               ENDIF
               IF (IZSEC.GT.0) THEN
                  IPT = IPT + 3 * IZSEC
               ELSE
                  NZ  = Q(IPT+2)
                  DO 40 IZ = 1, NZ-1
                     IF ((XC(3)-Q(IPT+3*IZ))*(XC(3)-Q(IPT+3*IZ+3))
     +               .LE.0.) THEN
                        IZSEC = IZ
                        IPT = IPT + 3 * IZSEC
                        GO TO 50
                     ENDIF
   40             CONTINUE
                  IN  = 0
                  GO TO 60
               ENDIF
   50          POR1 = (Q(IPT+3) - XC(3)) / (Q(IPT+3) - Q(IPT))
               POR2 = (XC(3) - Q(IPT)) / (Q(IPT+3) - Q(IPT))
               RMN  = Q(IPT+1) * POR1 + Q(IPT+4) * POR2
               RMX  = Q(IPT+2) * POR1 + Q(IPT+5) * POR2
               IF (ISH.EQ.11) THEN
                  NPDV = Q(IPAR+3)
                  DPH  = Q(IPAR+2) / NPDV
                  IF (IPSEC.LE.0) THEN
                     IF (XC(1).NE.0..OR.XC(2).NE.0.) THEN
                        PHI  = RADDEG * ATAN2 (XC(2), XC(1))
                     ELSE
                        PHI  = 0.0
                     ENDIF
                     PH0 = PHI-Q(IPAR+1)
                     SG = SIGN(1.0,PH0)
                     PH0 = MOD( ABS(PH0), 360.0 )
                     IF(SG.LE.0.0) PH0 = 360.0-PH0
                     IPSEC= PH0/DPH + 1
                  ENDIF
                  PH   = DEGRAD * (Q(IPAR+1) + (IPSEC - 0.5) * DPH)
                  R    = XC(1) * COS(PH) + XC(2) * SIN(PH)
               ENDIF
               STP = (RMX - RMN) / NDIV
               IN  = (R - RMN) / STP + 1
            ENDIF
         ELSE IF (IDT.EQ.3) THEN
*
*          Division along Phi axis
*
            IF (XC(1).NE.0..OR.XC(2).NE.0.) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.
            ENDIF
            DPHIO = PHI-ORIG
            SG = SIGN(ONE,DPHIO)
            DPHIO = MOD( ABS(DPHIO), TPIDEG)
            IF(SG.LE.0.0) DPHIO=TPIDEG-DPHIO
            IN = DPHIO/SDIV+1
         ELSE IF (IDT.EQ.4) THEN
*
*          Division along Theta axis
*
            IF (XC(3).NE.0.0) THEN
               RXY  = SQRT (XC(1)**2 + XC(2)**2)
               THET = RADDEG * ATAN (RXY/XC(3))
               IF (THET.LT.0.0)  THET = THET + 180.0
            ELSE
               THET = 90.0
            ENDIF
            IN   = (THET - ORIG) / SDIV + 1
         ENDIF
      ENDIF
*
   60 IF (IN.GT.NDIV) IN = 0
      IF (IN.LE.0) GO TO 999
*
      IF (JPAR.NE.0) THEN
         IF (IQ(JPAR-3).GT.1) THEN
            JPAR = LQ(JPAR-IN)
         ELSE
            JPAR = LQ(JPAR-1)
         ENDIF
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
      ELSE
         NPAR = Q(JVOT+5)
         JPAR = JVOT + 6
      ENDIF
*
*      Volume found at deeper level
*
      NL1    = NLEVEL
      NLEVEL = NLEVEL +1
      LVOLUM(NLEVEL) = IVOT
      NAMES(NLEVEL)  = IQ(JVOLUM+IVOT)
      NUMBER(NLEVEL) = IN
      LINDEX(NLEVEL) = IN
      LINMX(NLEVEL)  = NDIV
      GONLY(NLEVEL)  = GONLY(NL1)
      IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
         NLDEV(NLEVEL) = NLDEV(NL1)
      ELSE
         NLDEV(NLEVEL) = NLEVEL
      ENDIF
*
      IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         IF (IFL.NE.0) THEN
            XC(1) = XC(1) - X0(1)
            XC(2) = XC(2) - X0(2)
            XC(3) = XC(3) - X0(3)
         ENDIF
C*****  Code Expanded From Routine:  GTRMUL
C.
C.    ------------------------------------------------------------------
C.
         IF (GRMAT(10,NL1) .EQ. 0.0) THEN
            GTRAN(1,NLEVEL) = GTRAN(1,NL1) + X0(1)
            GTRAN(2,NLEVEL) = GTRAN(2,NL1) + X0(2)
            GTRAN(3,NLEVEL) = GTRAN(3,NL1) + X0(3)
            DO 70 I = 1, 10, 2
               GRMAT(I,NLEVEL) = GRMAT(I,NL1)
               GRMAT(I+1,NLEVEL) = GRMAT(I+1,NL1)
   70       CONTINUE
         ELSE
C
            DXTEM1 = X0(1)*GRMAT(1,NL1) + X0(2)*GRMAT(4,NL1) + X0(3)*
     +      GRMAT( 7,NL1)
            DXTEM2 = X0(1)*GRMAT(2,NL1) + X0(2)*GRMAT(5,NL1) + X0(3)*
     +      GRMAT( 8,NL1)
            DXTEM3 = X0(1)*GRMAT(3,NL1) + X0(2)*GRMAT(6,NL1) + X0(3)*
     +      GRMAT( 9,NL1)
            DO 80 I = 1, 10, 2
               GRMAT(I,NLEVEL) = GRMAT(I,NL1)
               GRMAT(I+1,NLEVEL) = GRMAT(I+1,NL1)
   80       CONTINUE
            GTRAN(1,NLEVEL) = GTRAN(1,NL1) + DXTEM1
            GTRAN(2,NLEVEL) = GTRAN(2,NL1) + DXTEM2
            GTRAN(3,NLEVEL) = GTRAN(3,NL1) + DXTEM3
         ENDIF
C*****  End of Code Expanded From Routine:  GTRMUL
*
      ELSE IF (IDT.EQ.3.OR.IDT.EQ.4) THEN
         IF (IDT.EQ.3) THEN
            PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
            CPHR = COS (PH0)
            SPHR = SIN (PH0)
         ELSE
            PH0  = 0.0
            CPHR = 1.0
            SPHR = 0.0
         ENDIF
         GTRAN(1,NLEVEL) = GTRAN(1,NL1)
         GRMAT(1,NLEVEL) = GRMAT(1,NL1)*CPHR + GRMAT(4,NL1)*SPHR
         GRMAT(4,NLEVEL) = GRMAT(4,NL1)*CPHR - GRMAT(1,NL1)*SPHR
         GRMAT(7,NLEVEL) = GRMAT(7,NL1)
         GTRAN(2,NLEVEL) = GTRAN(2,NL1)
         GRMAT(2,NLEVEL) = GRMAT(2,NL1)*CPHR + GRMAT(5,NL1)*SPHR
         GRMAT(5,NLEVEL) = GRMAT(5,NL1)*CPHR - GRMAT(2,NL1)*SPHR
         GRMAT(8,NLEVEL) = GRMAT(8,NL1)
         GTRAN(3,NLEVEL) = GTRAN(3,NL1)
         GRMAT(3,NLEVEL) = GRMAT(3,NL1)*CPHR + GRMAT(6,NL1)*SPHR
         GRMAT(6,NLEVEL) = GRMAT(6,NL1)*CPHR - GRMAT(3,NL1)*SPHR
         GRMAT(9,NLEVEL) = GRMAT(9,NL1)
         IF (IFL.NE.0) THEN
            XTT   = XC(1) * CPHR + XC(2) * SPHR
            XC(2) = XC(2) * CPHR - XC(1) * SPHR
            XC(1) = XTT
         ENDIF
         IF (PH0.EQ.0.0.AND.GRMAT(10,NL1).EQ.0.0) THEN
            GRMAT(10,NLEVEL) = 0.0
         ELSE
            GRMAT(10,NLEVEL) = 1.0
         ENDIF
         IF (ISH.EQ.11) IPSEC = 1
*
      ELSE
         GTRAN(1,NLEVEL) = GTRAN(1,NL1)
         GTRAN(2,NLEVEL) = GTRAN(2,NL1)
         GTRAN(3,NLEVEL) = GTRAN(3,NL1)
         DO 90 I = 1, 10, 2
            GRMAT(I,NLEVEL) = GRMAT(I,NL1)
            GRMAT(I+1,NLEVEL) = GRMAT(I+1,NL1)
   90    CONTINUE
      ENDIF
*
      IQ(JGPAR+NLEVEL) = NPAR
      LQ(JGPAR-NLEVEL) = JPAR
*                                                             END GMEDIV
  999 END
+DECK,  GMEPOS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GMEPOS (JVO, IN, XC, IFL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Updates the common /GCVOLU/ and the structure JGPAR          *
C.    *     for contents positioned.                                   *
C.    *                                                                *
C.    *   For IFL nonzero, it also checks if the point XC is inside    *
C.    *     the content. It returns IN = 0, if the point is outside.   *
C.    *     Otherwise, it transforms XC in the local system.           *
C.    *                                                                *
C.    *   Input : JVO, IN, XC, IFL                                     *
C.    *   Output : IN, XC                                              *
C.    *                                                                *
C.    *   Called by : GDRAW, GMEDIA                                    *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
      DIMENSION  XC(*)
      REAL       XT(3)
C.
C.    ------------------------------------------------------------------
C.
      JIN  = LQ(JVO-IN)
      IVOT = Q(JIN+2)
      JVOT = LQ(JVOLUM-IVOT)
      IF (NLEVEL.GE.NLDEV(NLEVEL)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 10 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 20
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
   10    CONTINUE
         JPAR = JPAR +5
         NPAR = IQ(JPAR)
         GO TO 30
      ENDIF
*      (normal case)
   20 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
*
   30 IROTT  = Q(JIN+4)
      IF (IFL.NE.0) THEN
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.EQ.0) IN = 0
      ENDIF
*
      IF (IN.GT.0) THEN
*
*       Volume found at deeper level
*
         NL1    = NLEVEL
         NLEVEL = NLEVEL +1
         LVOLUM(NLEVEL) = IVOT
         NAMES(NLEVEL)  = IQ(JVOLUM+IVOT)
         NUMBER(NLEVEL) = Q(JIN+3)
         LINDEX(NLEVEL) = IN
         LINMX(NLEVEL)  = Q(JVO+3)
         GONLY(NLEVEL)  = Q(JIN+8)
         IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
            NLDEV(NLEVEL) = NLDEV(NL1)
         ELSE
            NLDEV(NLEVEL) = NLEVEL
         ENDIF
         CALL GTRMUL (GTRAN(1,NL1), GRMAT(1,NL1), Q(JIN+5), IROTT,
     +                GTRAN(1,NLEVEL), GRMAT(1,NLEVEL) )
         IQ(JGPAR +NLEVEL) = NPAR
         LQ(JGPAR -NLEVEL) = JPAR
*
         IF (IFL.NE.0) THEN
            XC(1) = XT(1)
            XC(2) = XT(2)
            XC(3) = XT(3)
         ENDIF
      ENDIF
*                                                             END GMEPOS
      END
+DECK,  GMTOD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GMTOD(XM,XD,IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Computes coordinates XD (in DRS)                         *
C.    *       from known coordinates XM in MRS                         *
C.    *       The local reference system can be initialized by         *
C.    *         - the tracking routines and GMTOD used in GUSTEP       *
C.    *         - a call to GMEDIA(XM,NUMED)                           *
C.    *         - a call to GLVOLU(NLEVEL,NAMES,NUMBER,IER)            *
C.    *             (inverse routine is GDTOM)                         *
C.    *                                                                *
C.    *        If IFLAG=1  convert coordinates                         *
C.    *           IFLAG=2  convert direction cosinus                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun ,M Hansroul  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVOLU.
      DIMENSION XD(3),XM(3)
      EQUIVALENCE (N,NLEVEL)
C.
C.    ------------------------------------------------------------------
C.
      IF(IFLAG.EQ.1)THEN
         IF(GRMAT(10,N).NE.0.)THEN
            T1 = XM(1) - GTRAN(1,N)
            T2 = XM(2) - GTRAN(2,N)
            T3 = XM(3) - GTRAN(3,N)
            XD(1) = GRMAT(1,N)*T1+GRMAT(2,N)*T2+GRMAT(3,N)*T3
            XD(2) = GRMAT(4,N)*T1+GRMAT(5,N)*T2+GRMAT(6,N)*T3
            XD(3) = GRMAT(7,N)*T1+GRMAT(8,N)*T2+GRMAT(9,N)*T3
*
         ELSE
            XD(1) = XM(1) - GTRAN(1,N)
            XD(2) = XM(2) - GTRAN(2,N)
            XD(3) = XM(3) - GTRAN(3,N)
*
         ENDIF
*
      ELSE
         IF(GRMAT(10,N).NE.0.)THEN
            XD(1) = GRMAT(1,N)*XM(1)+GRMAT(2,N)*XM(2)+GRMAT(3,N)*XM(3)
            XD(2) = GRMAT(4,N)*XM(1)+GRMAT(5,N)*XM(2)+GRMAT(6,N)*XM(3)
            XD(3) = GRMAT(7,N)*XM(1)+GRMAT(8,N)*XM(2)+GRMAT(9,N)*XM(3)
*
         ELSE
            XD(1) = XM(1)
            XD(2) = XM(2)
            XD(3) = XM(3)
*
         ENDIF
*
      ENDIF
      END
+DECK,  GNBOX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GNBOX (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'BOX' VOLUME,   *
C.    *       FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)          *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Authors  R.Brun,  P. Weidhaas  *********               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6), PAR(6)
C.
C.    ------------------------------------------------------------------
C.
      SNXT = BIG
      S1   = BIG
      S2   = BIG
      S3   = BIG
      SAFX1= PAR(1)-X(1)
      SAFX2= PAR(1)+X(1)
      SAFY1= PAR(2)-X(2)
      SAFY2= PAR(2)+X(2)
      SAFZ1= PAR(3)-X(3)
      SAFZ2= PAR(3)+X(3)

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

        SAFE  = MIN(SAFX1,SAFX2, SAFY1,SAFY2, SAFZ1,SAFZ2)

        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------

      IF(X(4).GT.0.) S1 = SAFX1/X(4)
      IF(X(4).LT.0.) S1 =-SAFX2/X(4)
      IF(X(5).GT.0.) S2 = SAFY1/X(5)
      IF(X(5).LT.0.) S2 =-SAFY2/X(5)
      IF(X(6).GT.0.) S3 = SAFZ1/X(6)
      IF(X(6).LT.0.) S3 =-SAFZ2/X(6)

      SNXT  = MIN(S1,S2,S3)

  999 CONTINUE
      END
+DECK,  GNCONE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GNCONE(X,P,IACT,IFL,SNEXT,SNXT,SAFE)
C.    ******************************************************************
C.    *                                                                *
C.    *      Compute distance to intersection with boundary surface of *
C     *      volume CONE or CONS, from point X(1),X(2),X(3) inside     *
C     *      the volume along track with direction cosines X(4),X(5),  *
C     *      X(6)                                                      *
C.    *      P     (input)  : volume parameters                        *
C.    *      IACT  (input)  : action flag                              *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, compute SNXT only if SAFE.LT.SNEXT  *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *      IFL   (input)  : 1 for CONE, 2 for PHI segmented CONE     *
C.    *      SNEXT (input)  : see IACT = 1                             *
C.    *      SNXT  (output) : distance to volume boundary along track  *
C.    *      SAFE  (output) : not larger than scalar distance to       *
C.    *                       volume boundaray                         *
C.    *      Called by : GNEXT, GNOPCO, GTNEXT                         *
C.    *                                                                *
C.    *      Authors   : Michel Maire and Rolf Nierhaus    21-JUN-1990 *
C.    *                                                                *
C.    ******************************************************************
C.    *                                                                *
C.    * 'CONE'    is a conical tube. It has 5 parameters :             *
C.    *           the half length in z,                                *
C.    *           the inside and outside radii at the low z limit,     *
C.    *           and those at the high z limit.                       *
C.    * 'CONS'    is a phi segment of a  conical tube.  It has 7       *
C.    *           parameters, the same 5 as 'CONE' plus the phi limits.*
C.    *           The segment starts at the first limit and  includes  *
C.    *           increasing phi  value up  to the  second limit  or   *
C.    *           that plus 360 degrees.                               *
C.    *                                                                *
C.    ******************************************************************
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL SNEXT, SNXT, SAFE
      PARAMETER (F=0.01745329251994330D0)
+SELF, IF=SINGLE.
      PARAMETER (F=0.01745329251994330)
+SELF.
      REAL X(6),P(7)
*
*     this part has to be moved outside the routine
      RO1=0.5*(P(4)+P(2))
      TG1=0.5*(P(4)-P(2))/P(1)
      CR1=1./SQRT(1.+TG1*TG1)
      RO2=0.5*(P(5)+P(3))
      TG2=0.5*(P(5)-P(3))/P(1)
      CR2=1./SQRT(1.+TG2*TG2)
      IF (IFL.EQ.2) THEN
         P6=P(6)*F
         P7=P(7)*F
         IF (P7.LT.P6) P7=P7+F*360.
         C1=COS(P6)
         S1=SIN(P6)
         C2=COS(P7)
         S2=SIN(P7)
         FIO=0.5*(P7+P6)
         CFIO=COS(FIO)
         SFIO=SIN(FIO)
      END IF
*
      SNXT=1.E10
      R   =SQRT(X(1)**2+X(2)**2)
      RIN =TG1*X(3)+RO1
      ROUT=TG2*X(3)+RO2
*
*     Compute SAFE radius
      IF (IACT.LT.3) THEN
         SAF1=(R -RIN)*CR1
         SAF2=(ROUT-R)*CR2
         SAF3=P(1)-ABS(X(3))
         SAF4=1.E10
         IF (IFL.EQ.2) THEN
            IF ((X(2)*CFIO-X(1)*SFIO).LE.0.) THEN
               SAF4=ABS(X(1)*S1-X(2)*C1)
            ELSE
               SAF4=ABS(X(1)*S2-X(2)*C2)
            END IF
         END IF
         SAFE=MIN(SAF1,SAF2,SAF3,SAF4)
         IF (IACT.EQ.0) GO TO 999
         IF (IACT.EQ.1.AND.SNEXT.LE.SAFE) GO TO 999
      END IF
*
*     Intersection with z-plane
      IF (X(6).GT. 1.E-20) THEN
         SZ= (P(1)-X(3))/X(6)
      ELSEIF (X(6).LT.-1.E-20) THEN
         SZ=-(P(1)+X(3))/X(6)
      ELSE
         SZ= 1.E10
      END IF
*
*     Intersection with cones
*     Intersection point (x,y,z)
*     (x,y,z) is on track: x=X(1)+t*X(4)
*                          y=X(2)+t*X(5)
*                          z=X(3)+t*X(6)
*     (x,y,z) is on cone : x**2 + y**2 = (a*z+b)**2
*
*     (X(4)**2+X(5)**2-(a*x(6))**2)*t**2
*     +2.*(X(1)*X(4)+X(2)*X(5)-a*x(6)*(a*x(3)+b))*t
*     +X(1)**2+X(2)**2-(a*x(3)+b)**2=0
*
      T1=X(4)**2+X(5)**2
      T2=X(1)*X(4)+X(2)*X(5)
      T3=X(1)**2+X(2)**2
*
*     Intersection with the inner cone
      SR1=1.E10
      IF (RO1.GT.0.) THEN
         U=T1-(TG1*X(6))**2
         V=T2- TG1*X(6)*RIN
         W=T3- RIN*RIN
*        track not parallel to the cone ?
         IF (U.NE.0.) THEN
            B=V/U
            C=W/U
            D=B**2-C
            IF (D.GE.0.) THEN
               DS=SQRT(D)
               IF (DS.GE.ABS(B)) THEN
                  SR1= DS-B
               ELSEIF (B.LE.0.)  THEN
                  SR1=-DS-B
               END IF
            END IF
         ELSEIF (V.LT.0.) THEN
            SR1=-0.5*W/V
         END IF
      END IF
*
*     Intersection with the outer cone
      SR2=1.E10
      U=T1-(TG2*X(6))**2
      V=T2- TG2*X(6)*ROUT
      W=T3- ROUT*ROUT
*     track not parallel to the cone ?
      IF (U.NE.0.) THEN
         B=V/U
         C=W/U
         D=B**2-C
         IF (D.GE.0.) THEN
            DS=SQRT(D)
            IF (DS.GE.ABS(B)) THEN
               SR2= DS-B
            ELSEIF (B.LE.0.)  THEN
               SR2=-DS-B
            END IF
         END IF
      ELSEIF (V.GT.0.) THEN
         SR2=-0.5*W/V
      END IF
*
*     Intersection with phi-planes
*     x=r*cos(phi)=X(1)+t*X(4)
*     y=r*sin(phi)=X(2)+t*X(5)
*     z           =X(3)+t*X(6)
*     t=(X(2)*cos(phi)-X(1)*sin(phi))/(X(4)*sin(phi)-X(5)*cos(phi))
*
      SFI1=1.E10
      SFI2=1.E10
      IF (IFL.EQ.2) THEN
*        track not parallel to the phi1 plane ?
         UN=X(4)*S1-X(5)*C1
         IF (UN.NE.0.) THEN
            S=(X(2)*C1-X(1)*S1)/UN
            IF (S.GE.0.) THEN
               XI=X(1)+S*X(4)
               YI=X(2)+S*X(5)
               IF ((YI*CFIO-XI*SFIO).LE.0.) SFI1=S
            END IF
         END IF
*        track not parallel to the phi2 plane ?
         UN=X(4)*S2-X(5)*C2
         IF (UN.NE.0.) THEN
            S=(X(2)*C2-X(1)*S2)/UN
            IF (S.GE.0.) THEN
               XI=X(1)+S*X(4)
               YI=X(2)+S*X(5)
               IF ((YI*CFIO-XI*SFIO).GE.0.) SFI2=S
            END IF
         END IF
      END IF
*
      SNXT=MIN(SR1,SR2,SZ,SFI1,SFI2)
  999 END

+DECK,  GNCTUB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:51  cernlib
* Geant

      SUBROUTINE GNCTUB (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      COMPUTE DISTANCE UP TO INTERSECTION WITH 'CTUB'           *
C.    *      VOLUME FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)    *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GNPCON, GTNEXT                        *
C.    *         Authors A.McPherson    ********                        *
C.    *       MODIFICATION LOG.                                        *
C.    *       18-July-89 M.Guckes modifications due to GEANG 3.13      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      REAL X(6),PAR(11)
C
C-------------------------------------------------------------
C
      SNXT = BIG
      R2   = X(1)*X(1) + X(2)*X(2)
      R    = SQRT (R2)
      IF(PAR(5).GE.360.) THEN
         IFLAG = 1
      ELSE
         IFLAG = 2
      ENDIF
*
      SAFZ1  = (-PAR(3)-X(3) )*PAR(8)-X(1)*PAR(6)-X(2)*PAR(7)
      SAFZ2  = (PAR(3)-X(3) )*PAR(11)-X(1)*PAR(9)-X(2)*PAR(10)
      IF (PAR(1).NE.0.) THEN
         SAFR1  = R - PAR(1)
      ELSE
         SAFR1  = BIG
      ENDIF
      SAFR2  = PAR(2) - R
*
      IF (IACT .LT. 3) THEN
*
* *** Compute safety-distance 'SAFE' (P.Weidhaas)
*
         SAFSEG = BIG
         IF (IFLAG .EQ. 2) THEN
*
*     In addition to the radial distances (SAFR1 and SAFR2) and the
*     axial distances (SAFZ1 and SAFZ2) we compute here the distance
*     to the PHI-segment boundary that is closest to the point:
*
*     For each PHI-boundary we find the distance from the given
*     point to the outer (at RMAX) point of the segment boundary
*     (DISTS1 and DISTS2, resp.). If DISTS1 < DISTS2, we define
*     SAFSEG to be the distance to segment PHI1. Else we set
*     SAFSEG to be the distance to segment PHI2.
*
            PHI1 = PAR(4) * DEGRAD
            PHI2 = PAR(5) * DEGRAD
*
            COSPH1 = COS (PHI1)
            COSPH2 = COS (PHI2)
            SINPH1 = SIN (PHI1)
            SINPH2 = SIN (PHI2)
*
* ***   Get coordinates of outer endpoints (at ROUT) of both segments.
*
            XS1 = PAR(2) * COSPH1
            YS1 = PAR(2) * SINPH1
            XS2 = PAR(2) * COSPH2
            YS2 = PAR(2) * SINPH2
*
* ***   Get distances (squared) from the given point to each endpoint.
*
            DISTS1 = (X(1) - XS1)**2 + (X(2) - YS1)**2
            DISTS2 = (X(1) - XS2)**2 + (X(2) - YS2)**2
*
* ***   Get distance to that PHI-segment whose endpoint
* ***   is closest to the given point.
*
            IF (DISTS1 .LE. DISTS2) THEN
               SAFSEG = ABS(X(1) * SINPH1 - X(2) * COSPH1)
            ELSE
               SAFSEG = ABS(X(1) * SINPH2 - X(2) * COSPH2)
            ENDIF
         ENDIF
*
         SAFE = MIN (SAFZ1, SAFZ2, SAFR1, SAFR2, SAFSEG)
         IF (IACT .EQ. 0) GO TO 999
         IF (IACT .EQ. 1 .AND. SNEXT .LT. SAFE) GO TO 999
      ENDIF
*
* ***   Compute intersection with z-boundaries
*
      V1 = X(4)*PAR(6)+X(5)*PAR(7)+X(6)*PAR(8)
      SZ1 = SAFZ1/V1
      V2 = X(4)*PAR(9)+X(5)*PAR(10)+X(6)*PAR(11)
      SZ2 = SAFZ2/V2
      IF( SZ1 .GT. 0. ) THEN
         SNXT = SZ1
      ELSE
         SNXT = BIG
      ENDIF
      IF( SZ2 .GT. 0.0 .AND. SZ2 .LT. SNXT) SNXT = SZ2
      SZ=SNXT
*
      IF (ABS(X(6)).LT.1.)THEN
*
* ***      Compute z-intercept with inner cylinder.
*
         BA2=-1.
         IF(PAR(1).GT.0.)THEN
            RMIN2  = PAR(1)*PAR(1)
            ZP2    = 1./(1.-X(6)*X(6))
            BA     = (X(4)*X(1)+X(5)*X(2))*ZP2
            BA2    = BA*BA
            CA     = (R2-RMIN2)*ZP2
            DIS2   = BA2-CA
            IF (DIS2.GE.0.)THEN
               XSIN    = -BA-SQRT(DIS2)
               IF (XSIN.GE.0.)THEN
                  IF(XSIN.LT.SNXT)SNXT = XSIN
                  GO TO 10
               ENDIF
            ENDIF
         ENDIF
*
*  ***    Compute z-intercept with outer cylinder.
*
         RMAX2  = PAR(2)*PAR(2)
         XZ     = X(1) + X(4)*SZ
         YZ     = X(2) + X(5)*SZ
         IF (XZ*XZ+YZ*YZ.GT.RMAX2)THEN
            IF(BA2.LT.0.)THEN
               ZP2    = 1./(1.-X(6)*X(6))
               BA     = (X(4)*X(1)+X(5)*X(2))*ZP2
               BA2    = BA*BA
            ENDIF
            CA     = (R2-RMAX2)*ZP2
            DIS2   = BA2-CA
            IF (DIS2.GE.0.)THEN
               SRMAX = -BA+SQRT(DIS2)
               IF(SRMAX.LT.SNXT)SNXT=SRMAX
            ENDIF
         ENDIF
      ENDIF
*
   10 IF(IFLAG.EQ.2) THEN
*
*     =======>PHI segmented tube
*             We have checked the radius and Z.
*             now check PHI.
*
         DPSGN=X(1)*X(5)-X(2)*X(4)
*
*             Tells us which way its going.
*
         PHI2=PAR(5)
         IF(DPSGN.LT.0.0) PHI2=PAR(4)
         PH2=PHI2*DEGRAD
*
*             Have set up the limit.
*
         TSGN=SIN(PH2)
         TCSG=COS(PH2)
         DX45=X(4)*TSGN-X(5)*TCSG
         IF(DX45.EQ.0.)GO TO 999
         SN1=(X(2)*TCSG-X(1)*TSGN)/DX45
*
*             Distance until tangents are right.
*
         IF(SN1.LT.0.0) GO TO 999
         IF(ABS(TSGN).GT.1.E-6.AND.(X(2)+SN1*X(5))*TSGN .LT.0.)GO TO
     +   999
         IF(ABS(TCSG).GT.1.E-6.AND.(X(1)+SN1*X(4))*TCSG .LT.0.)GO TO
     +   999
*
*             Have checked that the distance is +VE and that the
*             SINE is the right sign.
*
         IF(SN1.LT.SNXT) SNXT=SN1
      END IF
*
  999 END
+DECK,  GNELTU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNELTU(X,PAR,IACT,SNEXT,SNXT,SAFE)
C
C     ****************************************************************
C     *                                                              *
C     *     Compute distance up to intersection with 'ELTU' volume,  *
C     *     from inside point X(1-3) along direction X(4-6).         *
C     *                                                              *
C     *     PAR    (input)  : volume parameters                      *
C     *     IACT   (input)  : action flag                            *
C     *       = 0   Compute SAFE only                                *
C     *       = 1   Compute SAFE, and SNXT only if SNEXT.gt.new SAFE *
C     *       = 2   Compute both SAFE and SNXT                       *
C     *       = 3   Compute SNXT only                                *
C     *     SNEXT  (input)  : see IACT = 1                           *
C     *     SNXT   (output) : distance to volume boundary            *
C     *     SAFE   (output) : shortest distance to any boundary      *
C     *                                                              *
C     *  ==>Called by : GNEXT,GTNEXT                                 *
C     *       Author  A.Solano                                       *
C     *                                                              *
C     ****************************************************************
C
+CDE, GCONSP.
C
      DIMENSION X(6),PAR(3)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION SAFZ1,SAFZ2,SAFR,A2,B2,X0,Y0,A,B,D1,D2
      DOUBLE PRECISION X1,X2,X3,Y1,Y2,Y3
      DOUBLE PRECISION SZ,XZ,YZ,U,V,W,DISCR,SQDISC,TAU1,TAU2
+SELF.
C
      SNXT = BIG
      SAFZ1 = PAR(3)-X(3)
      SAFZ2 = PAR(3)+X(3)
C
      A2 = PAR(1)*PAR(1)
      B2 = PAR(2)*PAR(2)
C
      IF(IACT.LT.3)THEN
C
C        -----------------------------------
C        |  Compute safety-distance 'SAFE' |
C        -----------------------------------
C
         X0 = ABS(X(1))
         Y0 = ABS(X(2))
C
         A=PAR(1)
         B=PAR(2)
         X1=X0
         Y1=SQRT((A-X0)*(A+X0))*B/A
         Y2=Y0
         X2=SQRT((B-Y0)*(B+Y0))*A/B
         D1=(X1-X0)**2+(Y1-Y0)**2
         D2=(X2-X0)**2+(Y2-Y0)**2
         DO 1 I=1,8
            IF (B.LT.A) THEN
               X3=.5*(X1+X2)
               Y3=SQRT((A-X3)*(A+X3))*B/A
            ELSE
               Y3=.5*(Y1+Y2)
               X3=SQRT((B-Y3)*(B+Y3))*A/B
            END IF
            IF (D1.LT.D2) THEN
               X2=X3
               Y2=Y3
               D2=(X2-X0)**2+(Y2-Y0)**2
            ELSE
               X1=X3
               Y1=Y3
               D1=(X1-X0)**2+(Y1-Y0)**2
            END IF
    1    CONTINUE
    2    SAFR=SQRT(D1)-1.E-3
*
         SAFE = MIN(SAFZ1,SAFZ2,SAFR)
         IF(IACT.EQ.0)GOTO 99
         IF(IACT.EQ.1.AND.SNEXT.LT.SAFE)GOTO 99
C
      ENDIF
C
C        -----------------------------------
C        |  Compute vector-distance 'SNXT' |
C        -----------------------------------
C
C ....  First check Z
C
      IF(X(6).GT.0.)THEN
         SNXT = SAFZ1/X(6)
      ELSEIF(X(6).LT.0.)THEN
         SNXT = -SAFZ2/X(6)
      ENDIF
C
C ....  Then,if necessary,find the intersection of
C       the given ray(described by array X) whit
C       the cylinder.
C       Ray equation : X'(1-3) = X(1-3) + TAU*X(4-6)
C       Cylinder equation : x**2/a**2 + y**2/b**2 = 1
C       To obtain TAU,solve the quadratic equation
C       Ut**2 + 2Vt + W = 0
C
      SZ = SNXT
      XZ = X(1)+X(4)*SZ
      YZ = X(2)+X(5)*SZ
      IF((XZ*XZ/A2+YZ*YZ/B2).LE.1)GOTO 99
C
      U = X(4)*X(4)*B2+X(5)*X(5)*A2
      V = X(1)*X(4)*B2+X(2)*X(5)*A2
      W = X(1)*X(1)*B2+X(2)*X(2)*A2-A2*B2
      DISCR = V*V-U*W
      IF(DISCR.LT.0.)GOTO 99
      IF(U.EQ.0.)GOTO 99
      SQDISC = SQRT(DISCR)
      TAU1 = (-V+SQDISC)/U
      TAU2 = (-V-SQDISC)/U
C
C ....  Set SNXT to the smallest positive TAU
C
      IF(TAU1.LT.0.)THEN
         IF(TAU2.LT.0.)GOTO 99
         SNXT = TAU2
      ELSE
         SNXT = TAU1
         IF(TAU2.GT.0.0.AND.TAU2.LT.TAU1)THEN
            SNXT = TAU2
         ENDIF
      ENDIF
C
   99 END
+DECK,  GNEX2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

+SELF, IF=OLD.
      SUBROUTINE GNEXT (X, SNEXT, SAFETY)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GNEXT (X, SNEXT, SAFETY)                               *
C.    *                                                                *
C.    *   Computes SNEXT and SAFETY                                    *
C.    *     SNEXT  (output) : distance to closest boundary             *
C.    *                      from point X(1-3) along X(4-6)            *
C.    *     SAFETY (output) : shortest distance to any boundary        *
C.    *                                                                *
C.    *   Called by : User                                             *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
+CDE, GCTMED.
+CDE, GCVOLU.
+SELF, IF=OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=OLD.
      REAL    X(6), X0(3), XC(6), XT(6)
      INTEGER IDTYP(3,12)
      LOGICAL BTEST
      SAVE IDTYP
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* *** Transform current point and direction into local reference system
*
      IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         DO 19 I = 1,3
            XC(I)   = X(I) -GTRAN(I,NLEVEL)
            XC(I+3) = X(I+3)
   19    CONTINUE
      ELSE
*       (later, code in line)
         CALL GTRNSF (X, GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), XC)
         CALL GROT (X(4), GRMAT(1,NLEVEL), XC(4))
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = BIG
      SAFETY = BIG
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      ISEARC = Q(JVO+1)
      IF (ISEARC.GE.-1) GO TO 120
*
*  ** Contents are ordered by (dynamic) GSORD, select neighbours
*
      JSB = LQ(LQ(JVO-NIN-1))
      IAX = Q(JSB+1)
      NSB = Q(JSB+2)
      IF (IAX.LE.3) THEN
         CX  = XC(IAX)
         INC = SIGN(1., XC(IAX+3))
      ELSE
         CALL GFCOOR (XC, IAX, CX)
         IF (IAX.LE.5) THEN
            DR = XC(1)*XC(4) +XC(2)*XC(5)
            IF (IAX.EQ.5) DR = DR +XC(3)*XC(6)
            INC = SIGN(1., DR)
         ELSE IF (IAX.EQ.6) THEN
            INC = SIGN(1., XC(1)*XC(5)-XC(2)*XC(4))
         ELSE
            INC = SIGN(1., XC(3)*(XC(1)*XC(4)+XC(2)*XC(5))
     +                    -XC(6)*(XC(1)*XC(1)+XC(2)*XC(2)))
         ENDIF
      ENDIF
      IDIV = LOCATF (Q(JSB+3), NSB, CX)
      IF (IDIV.LT.0) IDIV = -IDIV
      IF (IAX.NE.6) THEN
         IF (IDIV.EQ.0) THEN
            IF (INC.LT.0.AND.IAX.LE.3) THEN
               SAFETY = Q(JSB+3) -CX
               GO TO 300
            ENDIF
            IDIV = 1
         ELSE IF (IDIV.EQ.NSB) THEN
            IF (INC.GT.0.AND.IAX.NE.7) THEN
               SAFETY = CX -Q(JSB+2+NSB)
               GO TO 300
            ENDIF
            IDIV = NSB -1
         ELSE
            IF (IAX.NE.7) THEN
               IF (INC.GT.0) THEN
                  SAFETY = CX -Q(JSB+2+IDIV)
               ELSE
                  SAFETY = Q(JSB+3+IDIV) -CX
               ENDIF
            ELSE
               SAFETY = 0.
            ENDIF
         ENDIF
      ELSE IF (IAX.EQ.6) THEN
         IF (IDIV.EQ.0) IDIV = NSB
         SAFETY = 0.
      ENDIF
*
      IDIVL = 0
      IDIVB = 0
      JSC0  = LQ(JVO-NIN-2)
  110 NCONT = IQ(JSC0+IDIV)
*
*  ** Loop over (selected) contents
*
      IF (NCONT.EQ.0) THEN
         IF (IDIV.EQ.IDIVL) GO TO 400
         IDIV = IDIV +INC
*      (following statement for IAX=6, when division NSB is empty)
         IF (IDIV.GT.NSB) IDIV = 1
         GO TO 110
      ELSE
         ICONT = 1
         JSCV = LQ(JSC0-IDIV)
         GO TO 140
      ENDIF
*
  120 JNEAR = LQ(JVO-NIN-1)
      IF (ISEARC.GT.0) THEN
+SELF, IF=OLD, IF=-USRJMP.
         CALL GUNEAR (ISEARC, 2, XC, JNEAR)
+SELF, IF=OLD, IF=USRJMP.
         CALL JUMPT4(JUNEAR,ISEARC, 2, XC, JNEAR)
+SELF, IF=OLD.
         IF (IQ(JNEAR+1).EQ.0) GO TO 300
      ENDIF
      JNEAR = JNEAR +1
      NNEAR = IQ(JNEAR)
      IF (IQ(JNEAR+1).NE.0) THEN
         INEAR = 1
      ELSE
         INEAR = 2
      ENDIF
*
  130 IN = IQ(JNEAR+INEAR)
      GO TO 150
*
  140 IN = IQ(JSCV+ICONT)
*
  150 IF(IN.LE.0)GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (NLEVEL.GE.NLDEV(NLEVEL)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         GO TO 180
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
      ELSE
         JPAR = JVOT +6
      ENDIF
*
*   * Compute distance to boundary of current content
*
  180 IF (IROTT.EQ.0) THEN
         DO 189 I = 1,3
            XT(I)   = XC(I) -Q(JIN+4+I)
            XT(I+3) = XC(I+3)
  189    CONTINUE
      ELSE
*       (later, code in line)
         CALL GITRAN (XC, Q(JIN+5), IROTT, XT)
         CALL GRMTD (XC(4), IROTT, XT(4))
      ENDIF
*
      IACT = 2
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LT.SNEXT) THEN
         SNEXT = SNXT
         IF (ISEARC.EQ.-2) THEN
            IF (MOD(IQ(JSC0),2).NE.0) THEN
               IDIVB = IDIV
            ELSE
               DO 191 I = 1,3
                  X0(I) = XC(I) + SNXT*XC(I+3)
  191          CONTINUE
               IF (IAX.LE.3) THEN
                  IDIVB = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVB = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVB.LT.0) IDIVB = -IDIVB
               IF (IDIVB.EQ.0) THEN
                  IF (IAX.EQ.6) THEN
                     IDIVB = NSB
                  ELSE
                     IDIVB = 1
                  ENDIF
               ELSE IF (IDIVB.EQ.NSB) THEN
                  IF (IAX.NE.6) IDIVB = NSB - 1
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (ISEARC.EQ.-2) THEN
         IF (ICONT.EQ.NCONT) THEN
            IF (IDIVL.EQ.0) THEN
               IF (IDIVB.NE.0) THEN
                  IF (IDIV.EQ.IDIVB) GO TO 300
                  IF (.NOT.BTEST(IQ(JVO),2)) THEN
                     IDIVL = IDIVB
                     GO TO 193
                  ENDIF
               ENDIF
*
*   *         Compute distance to boundary of current volume
*
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LT.SNEXT)  SNEXT  = SNXT
*
*   *         Check wether other pseudo-divisions have to be scanned
*
               DO 192 I = 1,3
                  X0(I) = XC(I) +SNXT*XC(I+3)
  192          CONTINUE
               IF (IAX.LE.3) THEN
                  IDIVL = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVL = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVL.LT.0) IDIVL = -IDIVL
               IF (IDIVL.EQ.0) THEN
                  IF(IAX.EQ.6)THEN
                     IDIVL=NSB
                  ELSE
                     IDIVL=1
                  ENDIF
               ELSEIF (IDIVL.EQ.NSB)THEN
                  IF(IAX.NE.6)IDIVL=NSB-1
               ENDIF
            ELSE
               IF (IDIV.EQ.IDIVB)   GO TO 400
            ENDIF
  193       IF ((IDIV-IDIVL)*INC.GE.0) GO TO 400
            IDIV = IDIV +INC
            GO TO 110
         ELSE
            ICONT = ICONT +1
            GO TO 140
         ENDIF
      ELSE
         IF (INEAR.EQ.NNEAR) GO TO 300
         INEAR = INEAR +1
         GO TO 130
      ENDIF
*
* ***    Case of volume incompletely divided
*
  200 JDIV  = LQ(JVO-1)
      IAXIS = Q(JDIV+1)
      IVOT  = Q(JDIV+2)
      JVOT  = LQ(JVOLUM-IVOT)
      ISHT  = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
            PRINT *, ' GNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         PRINT *, ' GNEXT : Partially divided ',ISH,IAXIS
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         DO 231 I = 1, 3
            X0(I) = 0.0
  231    CONTINUE
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         DO 232 I = 1, 3
            XT(I)   = XC(I) - X0(I)
            XT(I+3) = XC(I+3)
  232    CONTINUE
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         DO 233 I = 1, 4, 3
            XT(I)   = XC(I)*CPHR + XC(I+1)*SPHR
            XT(I+1) = XC(I+1)*CPHR - XC(I)*SPHR
            XT(I+2) = XC(I+2)
  233    CONTINUE
      ELSE
         DO 234 I = 1, 6
            XT(I) = XC(I)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 2
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LT.SNEXT)  SNEXT  = SNXT
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*
* ***  Calculate SNEXT and SAFETY with respect to the Mother
* ***            SAFETY only for concave volumes if finite SNEXT
* ***            has been found with respect to one of its contents
*
  300 IACT = 2
      IF (SNEXT.LT.0.9*BIG) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LT.SNEXT)  SNEXT  = SNXT
*
  400 IF (GONLY(NLEVEL).EQ.0.) THEN
*
* ***   Case of a 'NOT ONLY' volume -> step search
*
         SAFETY = 0.
         EPSI2  = 0.5*EPSIL
         ST     = SNEXT -EPSI2
         IF (ST.LE.0) GO TO 999
         EPSI3  = 10.*EPSIL
         IF (ST.LE.EPSI3) THEN
            NN = 1
         ELSE
            NN = ST/EPSI3 +1
            ST = ST/NN
         ENDIF
*
         NBIN = 0
         SN   = 0.
  420    SN   = SN +ST
         DO 429 I = 1,3
            XT(I) = X(I) +SN*X(I+3)
  429    CONTINUE
*
         CALL GINVOL (XT, ISAME)
         IF (ISAME.EQ.0) THEN
            IF (ST.LT.EPSI2) GO TO 490
            SN   = SN -ST
            ST   = 0.5*ST
            NBIN = 1
            GO TO 420
         ENDIF
*
         IF (NBIN.NE.0) THEN
            IF (ST.LT.EPSI2) THEN
               SN = SN +EPSI2
               GO TO 490
            ELSE
               ST = 0.5*ST
               GO TO 420
            ENDIF
         ENDIF
         NN = NN -1
         IF (NN.GT.0) GO TO 420
         GO TO 999
*
  490    IF (SN.LT.SNEXT) SNEXT = SN
      ENDIF
*                                                              END GNEXT
  999 END

+SELF.
+DECK,  GNEXT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

+SELF, IF=-OLD.
      SUBROUTINE GNEXT (X, SNEXT, SAFETY)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GNEXT (X, SNEXT, SAFETY)                               *
C.    *                                                                *
C.    *   Computes SNEXT and SAFETY                                    *
C.    *     SNEXT  (output) : distance to closest boundary             *
C.    *                      from point X(1-3) along X(4-6)            *
C.    *     SAFETY (output) : shortest distance to any boundary        *
C.    *                                                                *
C.    *   Called by : User                                             *
C.    *   Author   : S.Giani (1993)                                    *
C.    *                                                                *
C.    *   This routine is now based on the new 'virtual divisions'     *
C.    *    algorithm to speed up the tracking.                         *
C.    *   The tracking for MANY volumes is not anymore based on a step *
C.    *    search: it is now based on a search through the list of     *
C.    *    'possible overlapping volumes' built by GTMEDI.             *
C.    *    Boolean operations and divisions along arbitrary axis are   *
C.    *     now supported.                                             *
C.    *    Important notice: in case of MANY volumes, it might happen  *
C.    *     that at the end of GNEXT the volume where X was found to   *
C.    *     be is not anymore the current volume in GCVOLU (being the  *
C.    *     tree ready for the volume where the particles is entering).*
C.    *     When this happens, the variable MYCOUN in the common block *
C.    *     PHYCOU is greater than one; the user can take the proper   *
C.    *     actions (before calling GINVOL, for example) like restoring*
C.    *     the old tree: this is possible because GMEDIA has saved    *
C.    *     the needed informations in MANYLE(NFMANY) (for nlevel), in *
C.    *     MANYNA(NFMANY,i) (for names(i)) and in MANYNU(NFMANY,i)    *
C.    *     (for number(i)); this is sufficient to restore the old tree*
C.    *     by calling GLVOLU.                                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
+CDE, GCTMED.
+CDE, GCVOLU.
+SELF, IF=-OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=-OLD.
+CDE, GCHVIR.
+CDE, GCVDMA.
      DIMENSION NUMTMP(15),NAMTMP(15)
      dimension iarrin(500),cxm(3),xxm(6)
      REAL    X(6), X0(6), XC(6), XT(6)
      INTEGER IDTYP(3,12)
      LOGICAL BTEST
      SAVE IDTYP
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* *** Transform current point and direction into local reference system
*
      mycoun=0
      myinfr=0
      newfl=0
      manyfl=0
      tsafet=big
      tsnext=big
 401  IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         DO 19 I = 1,3
            XC(I)   = X(I) -GTRAN(I,NLEVEL)
            XC(I+3) = X(I+3)
   19    CONTINUE
      ELSE
*       (later, code in line)
         CALL GTRNSF (X, GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), XC)
         CALL GROT (X(4), GRMAT(1,NLEVEL), XC(4))
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = BIG
      SAFETY = BIG
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      sneold=SNEXT
      nnn=0
      nflag=0
      mmm=0
      snxtot=0.
 111  if(nin.gt.1)then
        if(nnn.gt.0)goto 112
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.eq.4)then
         do 1 i=1,6
          xxm(i)=xc(i)
 1       continue
        endif
        divthi=(chmoth-clmoth)/ndivto
        if(iaxis.le.3)then
          cx=xc(iaxis)
          if(xc(iaxis+3).ge.0.)then
            inc=1
          else
            inc=-1
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.4)then
            dr= xc(1)*xc(4)+xc(2)*xc(5)
*            if(dr.eq.0.)print *,'dr.eq.0.'
            if(dr.ge.0.)then
              inc=1
            else
              inc=-1
            endif
          elseif(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
            dfi=xc(1)*xc(5)-xc(2)*xc(4)
            if(dfi.ge.0)then
              inc=1
            else
              inc=-1
            endif
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
 112    iofset=iq(jvdiv+ivdiv)
        jcont2=jvdiv+iofset+1
        ncont=iq(jcont2)
        if(ncont.eq.0)then
          idmi=iq(jcont2+1)
          idma=iq(jcont2+2)
          llflag=0
        elseif(ncont.eq.1)then
          idmi=iq(jcont2+2)
          idma=iq(jcont2+3)
          in=iq(jcont2+1)
        else
          idmi=iq(jcont2+ncont+1)
          idma=iq(jcont2+ncont+2)
          iii=1
          in=iq(jcont2+iii)
        endif
        if(nnn.eq.0)then
         cxold=cx
         if(inc.gt.0)then
          cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
          if(iaxis.ne.6)then
           safety=min(safety,(cxold-cmin))
          else
           safefi=min(90.,(cxold-cmin))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         else
          cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
          if(iaxis.ne.6)then
           safety=min(safety,(cmax-cxold))
          else
           safefi=min(90.,(cmax-cxold))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         endif
        endif
        if(ncont.eq.0)goto 181
      elseif(nin.eq.1)then
        in=1
      endif
*
  150 if(nin.gt.1.and.ncont.gt.1)then
        in=iq(jcont2+iii)
      endif
      if(nin.gt.0)then
        jin=lq(jvo-in)
        if(.NOT.BTEST(iq(jin),4))then
        else
          goto 171
        endif
      endif
      if(nin.gt.1)then
        llflag=0
        if(mmm.le.500)then
         do 151 ll=1,mmm
          if(iarrin(ll).eq.in)then
            llflag=1
            goto 171
          endif
 151     continue
        endif
        if(llflag.eq.0)then
          mmm=mmm+1
          if(mmm.le.500)then
           iarrin(mmm)=in
          endif
        endif
      endif
      IF(IN.LE.0)GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (NLEVEL.GE.NLDEV(NLEVEL)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         GO TO 179
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
      ELSE
         JPAR = JVOT +6
      ENDIF
 179  if((nin.eq.1).or.(nin.gt.1.and.llflag.eq.0))then
*
*   * Compute distance to boundary of current content
*
  180 IF (IROTT.EQ.0) THEN
         DO 189 I = 1,3
            XT(I)   = XC(I) -Q(JIN+4+I)
            XT(I+3) = XC(I+3)
  189    CONTINUE
      ELSE
*       (later, code in line)
         CALL GITRAN (XC, Q(JIN+5), IROTT, XT)
         CALL GRMTD (XC(4), IROTT, XT(4))
      ENDIF
*
      IACT = 2
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LT.SNEXT) THEN
         SNEXT = SNXT
      ENDIF
      endif
 171  if(nin.eq.1)then
        goto 300
      elseif(nin.ge.1.and.ncont.gt.1)then
           iii=iii+1
           if(iii.le.ncont)goto 150
      endif
*
*   *         Compute distance to boundary of current volume
*
 181  if(nnn.eq.0)then
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               safe=max(safe,0.)
               if(snxt.le.-prec)snxt=big
               snxt=max(snxt,0.)
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LT.SNEXT)  SNEXT  = SNXT
      endif
      if(iaxis.eq.4)then
       if(idma.eq.ndivto.and.inc.gt.0)goto 400
        cxm(1)=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
        if(idmi.eq.idma)then
          cxm(2)=cxm(1)+divthi
        else
          cxm(2)=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
        endif
        cxm(3)=20000.
        call gntube(xxm,cxm,3,1,SNEXT,snxnew,safe)
        snxnew=snxnew+.004
        snxtot=snxtot+snxnew
        if(snxtot.lt.SNEXT)then
          xxm(1)=xxm(1)+snxnew*xxm(4)
          xxm(2)=xxm(2)+snxnew*xxm(5)
          xxm(3)=xxm(3)+snxnew*xxm(6)
          call gfcoor(xxm,iaxis,cxnew)
          xevdiv=((cxnew-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xevdiv
          dr= xxm(1)*xxm(4)+xxm(2)*xxm(5)
*          if(dr.eq.0.)print *,'dr.eq.0.'
          if(dr.ge.0.)then
              inc=1
          else
              inc=-1
          endif
          if((xevdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
              ivdiv=1
          elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
          endif
          nnn=nnn+1
          goto 111
        else
          if(inc.gt.0)then
           cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
           safety=min(safety,(cmax-cxold))
          else
           cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
           safety=min(safety,(cxold-cmin))
          endif
          goto 400
        endif
      endif
          if(nnn.ne.0.and.SNEXT.eq.sneold)goto 199
               x0(1) = xc(1) + SNEXT*xc(4)
               x0(2) = xc(2) + SNEXT*xc(5)
               x0(3) = xc(3) + SNEXT*xc(6)
               x0(4) = xc(4)
               x0(5) = xc(5)
               x0(6) = xc(6)
          if(iaxis.le.3)then
            cx=x0(iaxis)
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          else
            call gfcoor(x0,iaxis,cx)
            if(iaxis.eq.6)then
             if((cx-clmoth).lt.-1.)then
              cx=cx+360.
             elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
             endif
             if(cx.gt.chmoth)then
              cx=chmoth
             elseif(cx.lt.clmoth)then
              cx=clmoth
             endif
            endif
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          endif
 199      if(ievdiv.ge.idmi.and.ievdiv.le.idma)then
            if(inc.gt.0)then
             cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
             if(iaxis.ne.6)then
              safety=min(safety,(cmax-cxold))
             else
              safefi=min(90.,(cmax-cxold))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            else
             cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
             if(iaxis.ne.6)then
              safety=min(safety,(cxold-cmin))
             else
              safefi=min(90.,(cxold-cmin))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            endif
            goto 400
          endif
          if(iaxis.eq.6.or.iaxis.le.3)then
           if(ievdiv.lt.idmi.and.inc.gt.0)then
            if(nnn.eq.0.and.iaxis.eq.6)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idmi=',idmi,' inc.gt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safety=min(safety,abs(cmax-cxold))
             elseif(iaxis.eq.6)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safefi=min(90.,(cmax-cxold))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           elseif(ievdiv.gt.idma.and.inc.lt.0)then
            if(nnn.eq.0.and.iaxis.eq.6)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idma=',idma,' inc.lt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safety=min(safety,abs(cxold-cmin))
             elseif(iaxis.eq.6)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safefi=min(90.,(cxold-cmin))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           endif
          endif
          nnn=nnn+1
          sneold=SNEXT
          if(inc.gt.0)then
            if(iaxis.eq.6)then
             if(idma.eq.ndivto.and.(chmoth-clmoth).eq.360.)then
               ivdiv=1
             else
               ivdiv=idma+1
             endif
            else
             ivdiv=idma+1
            endif
          else
            if(iaxis.eq.6)then
             if(idmi.eq.1.and.(chmoth-clmoth).eq.360.)then
               ivdiv=ndivto
             else
               ivdiv=idmi-1
             endif
            else
             ivdiv=idmi-1
            endif
          endif
          goto 111
*
* ***    Case of volume incompletely divided
*
  200 JDIV  = LQ(JVO-1)
      IAXIS = Q(JDIV+1)
      IVOT  = Q(JDIV+2)
      JVOT  = LQ(JVOLUM-IVOT)
      ISHT  = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
            PRINT *, ' GNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         PRINT *, ' GNEXT : Partially divided ',ISH,IAXIS
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         DO 231 I = 1, 3
            X0(I) = 0.0
  231    CONTINUE
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         DO 232 I = 1, 3
            XT(I)   = XC(I) - X0(I)
            XT(I+3) = XC(I+3)
  232    CONTINUE
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         DO 233 I = 1, 4, 3
            XT(I)   = XC(I)*CPHR + XC(I+1)*SPHR
            XT(I+1) = XC(I+1)*CPHR - XC(I)*SPHR
            XT(I+2) = XC(I+2)
  233    CONTINUE
      ELSE
         DO 234 I = 1, 6
            XT(I) = XC(I)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 2
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LT.SNEXT)  SNEXT  = SNXT
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*
* ***  Calculate SNEXT and SAFETY with respect to the Mother
* ***            SAFETY only for concave volumes if finite SNEXT
* ***            has been found with respect to one of its contents
*
  300 IACT = 2
      IF (SNEXT.LT.0.9*BIG) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      if(nin.eq.1.and.SNEXT.LT.0.9*BIG)then
        if(q(jin+8).eq.0.)iact=2
      endif
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LT.SNEXT)  SNEXT  = SNXT
*
 400  if(myinfr.gt.0)then
        jin=lq(jvo-myinfr)
        iq(jin)=ibclr(iq(jin),4)
        myinfr=0
      endif
      if(gonly(nlevel).eq.0..or.nvmany.ne.0) THEN
         if(safety.lt.tsafet)tsafet=safety
         if(snext.lt.tsnext)then
          mycoun=mycoun+1
          tsnext=snext
          call gscvol
         endif
         if(gonly(nlevel).eq.0.)then
 404       continue
           if(gonly(nlevel-1).eq.0..or.newfl.eq.0)then
             if(gonly(nlevel-1).ne.0.)newfl=1
             nlevel=nlevel-1
             jvo=lq(jvolum-lvolum(nlevel))
             nin=q(jvo+3)
             if(nin.lt.0)goto 404
             myinfr=lindex(nlevel+1)
             jin=lq(jvo-myinfr)
             iq(jin)=ibset(iq(jin),4)
             ignext=0
             goto 401
           endif
         endif
 403   continue
       if(manyfl.lt.nvmany)then
         manyfl=manyfl+1
         if(manyfl.eq.nfmany)goto 403
         levtmp=manyle(manyfl)
         do 402 i=1,levtmp
          namtmp(i)=manyna(manyfl,i)
          numtmp(i)=manynu(manyfl,i)
 402     continue
         call glvolu(levtmp,namtmp,numtmp,ier)
         if(ier.ne.0)print *,'Fatal error in GLVOLU'
         ignext=0
         goto 401
       endif
       if(tsafet.le.safety)safety=tsafet
       if(tsnext.le.snext)then
         snext=tsnext
         call gfcvol
       endif
      endif
*                                                              END GNEXT
  999 END

+SELF.
+DECK,  GNHYPE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNHYPE (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      COMPUTE DISTANCE UP TO INTERSECTION WITH  HYPErboloid     *
C.    *      VOLUME FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)    *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *                        inner radius                            *
C.    *                        outer radius                            *
C.    *                        half length in z                        *
C.    *                        straw stereo angle in degrees           *
C.    *                        r**2 = (z*tan(theta))**2 + a**2         *
C.    *                                                                *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Authors M.J. Corden,  A.Palounek                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6),PAR(4)

C-------------------------------------------------------------

      SNXT = BIG
      R2   = X(1)*X(1) + X(2)*X(2)
      TANTHS=(TAN(PAR(4)*DEGRAD))**2

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

      SAFZ1  = PAR(3) - X(3)
      SAFZ2  = PAR(3) + X(3)

      IF (IACT .LT. 3) THEN

C    tube version:
C      R    = SQRT (R2)
C      IF (PAR(1).NE.0.) THEN
C         SAFR1  = R - PAR(1)
C      ELSE
C         SAFR1  = BIG
C      ENDIF
C      SAFR2  = PAR(2) - R
C
C        SAFE  = MIN (SAFZ1, SAFZ2, SAFR1, SAFR2)
C
C    simple, safe choice for hyperboloid for now:
      SAFE=0.
C
        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF

C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------

C
C             Compute intersection with z-boundaries.
C
      IF(X(6).GT.0.)THEN
         SNXT=SAFZ1/X(6)
      ELSEIF(X(6).LT.0.)THEN
         SNXT=-SAFZ2/X(6)
      ENDIF
C
C     Compute intercepts with inner & outer curved surfaces:
C
      A = X(4)**2 + X(5)**2 - X(6)**2*TANTHS
      B = X(1)*X(4) + X(2)*X(5) - X(3)*X(6)*TANTHS

      DO 38 NCYL =1,2
        C = R2 - X(3)**2*TANTHS - PAR(NCYL)**2
        SURD = B**2 - A*C
        IF(SURD.GT.0.) THEN
          SURD=SQRT(SURD)
          DIST1=(-B+SURD)/A
          IF(DIST1.GT.0.) SNXT=MIN(SNXT,DIST1)
          DIST2=(-B-SURD)/A
          IF(DIST2.GT.0.) SNXT=MIN(SNXT,DIST2)
C       not necessary to compute intercept with outer surface
C       if there is a positive intercept with inner surface:
          IF(DIST1.GT.0. .OR. DIST2.GT.0.) GO TO 999
        ENDIF
  38  CONTINUE
C
 999  CONTINUE
      END
+DECK,  GNOBOX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOBOX (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'BOX' VOLUME,   *
C.    *        FROM OUTSIDE POINT X(1-3) ALONG DIRECTION X(4-6)        *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *       ==>Called by : GNEXT, GTNEXT                             *
C.    *       Author  A.McPherson, P.Weidhaas  ******                  *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6),PAR(3),SAF(3)
      EQUIVALENCE (SAF(1),SAF1),(SAF(2),SAF2),(SAF(3),SAF3)
C.
C.    ----------------------------------------------------------------
C.

      SNXT = BIG
      DO 5 I=1,3
        SAF(I)=ABS(X(I))-PAR(I)
   5  CONTINUE

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

        SAFE  = MAX (SAF1, SAF2, SAF3, 0.0)

        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF

C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------


      IF(X(1)*X(4).GE.0.0.AND.SAF1.GT.0.) GO TO 999
      IF(X(2)*X(5).GE.0.0.AND.SAF2.GT.0.) GO TO 999
      IF(X(3)*X(6).GE.0.0.AND.SAF3.GT.0.) GO TO 999
C
      SMAX1=BIG
      SMAX2=BIG
      SMAX3=BIG
      SMIN1=0.0
C
      IF(SAF1.LT.0.) GO TO 10
      IF(X(4).EQ.0.0) GO TO 999
      S4 = ABS(X(4))
      SMIN1=SAF1 / S4
      SMAX1=(PAR(1)+ABS(X(1))) / S4
      GO TO 20
C
   10 CONTINUE
      IF(X(4).NE.0.)THEN
         SMAX1=PAR(1)/ABS(X(4))-X(1)/X(4)
      ENDIF
   20 CONTINUE
C
      SMIN2=0.0
      IF(SAF2.LT.0.) GO TO 30
      IF(X(5).EQ.0.0) GO TO 999
      S5=ABS(X(5))
      SMIN2=SAF2/S5
      SMAX2=(PAR(2)+ABS(X(2)))/S5
      GO TO 40
C
   30 CONTINUE
      IF(X(5).NE.0.)THEN
         SMAX2=PAR(2)/ABS(X(5))-X(2)/X(5)
      ENDIF
   40 CONTINUE
C
      SMIN3=0.0
      IF(SAF3.LT.0.) GO TO 50
      IF(X(6).EQ.0.0) GO TO 999
      S6=ABS(X(6))
      SMIN3=SAF3/S6
      SMAX3=(PAR(3)+ABS(X(3)))/S6
      GO TO 60
C
   50 CONTINUE
      IF(X(6).NE.0.)THEN
         SMAX3=PAR(3)/ABS(X(6))-X(3)/X(6)
      ENDIF
   60 CONTINUE
C
      SMIN=MAX(SMIN1,SMIN2,SMIN3)
      SMAX=MIN(SMAX1,SMAX2,SMAX3)
      IF(SMAX.LT.SMIN) GO TO 999
C
      IF(SMIN.LE.0.)GO TO 999
      SNXT = SMIN

  999 CONTINUE
      END
+DECK,  GNOCON, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOCON(X,P,IACT,IFL,SNEXT,SNXT,SAFE)
C.    ******************************************************************
C.    *                                                                *
C.    *      Compute distance to intersection with boundary surface of *
C     *      volume CONE or CONS, from point X(1),X(2),X(3) outside    *
C     *      the volume along track with direction cosines X(4),X(5),  *
C     *      X(6)                                                      *
C.    *      P     (input)  : volume parameters                        *
C.    *      IACT  (input)  : action flag                              *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, compute SNXT only if SAFE.LT.SNEXT  *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *      IFL   (input)  : 1 for CONE, 2 for PHI segmented CONE     *
C.    *      SNEXT (input)  : see IACT = 1                             *
C.    *      SNXT  (output) : distance to volume boundary along track  *
C.    *      SAFE  (output) : not larger than scalar distance to       *
C.    *                       volume boundaray                         *
C.    *      Called by : GNEXT, GNOPCO, GTNEXT                         *
C.    *                                                                *
C.    *      Authors   : Michel Maire and Rolf Nierhaus   21-JUN-1990  *
C.    *                                                                *
C.    ******************************************************************
C.    *                                                                *
C.    * 'CONE'    is a conical tube. It has 5 parameters :             *
C.    *           the half length in z,                                *
C.    *           the inside and outside radii at the low z limit,     *
C.    *           and those at the high z limit.                       *
C.    * 'CONS'    is a phi segment of a  conical tube.  It has 7       *
C.    *           parameters, the same 5 as 'CONE' plus the phi limits.*
C.    *           The segment starts at the first limit and  includes  *
C.    *           increasing phi  value up  to the  second limit  or   *
C.    *           that plus 360 degrees.                               *
C.    *                                                                *
C.    ******************************************************************
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (F=0.01745329251994330D0)
+SELF, IF=SINGLE.
      PARAMETER (F=0.01745329251994330)
+SELF.
      REAL X(6),P(7),SNEXT,SNXT,SAFE
      PARAMETER (ONE=1,HALF=ONE/2,ZERO=0)
*
*     this part has to be moved outside the routine
      RO1=HALF*(P(4)+P(2))
      TG1=HALF*(P(4)-P(2))/P(1)
      CR1=ONE/SQRT(ONE+TG1*TG1)
      ZV1=1.E10
      IF (P(2).NE.P(4)) ZV1=-RO1/TG1
      RO2=HALF*(P(5)+P(3))
      TG2=HALF*(P(5)-P(3))/P(1)
      CR2=ONE/SQRT(ONE+TG2*TG2)
      ZV2=1.E10
      IF (P(3).NE.P(5)) ZV2=-RO2/TG2
      IF (IFL.EQ.2) THEN
         P6=P(6)*F
         P7=P(7)*F
         IF (P7.LT.P6) P7=P7+F*360
         C1=COS(P6)
         S1=SIN(P6)
         C2=COS(P7)
         S2=SIN(P7)
         FIO=HALF*(P7+P6)
         CFIO=COS(FIO)
         SFIO=SIN(FIO)
         DFI=HALF*(P7-P6)
         CDFI=COS(DFI)
*        SDFI=SIN(DFI)
      END IF
*
      SNXT=1.E10
      R   =SQRT(X(1)**2+X(2)**2)
      RIN =ABS(TG1*X(3)+RO1)
      ROUT=ABS(TG2*X(3)+RO2)
*
*     Compute SAFE radius
      IF (IACT.LT.3) THEN
         SAF1=(RIN -R)*CR1
         SAF2=(R-ROUT)*CR2
         SAF3=ABS(X(3))-P(1)
         SAF4=0.
         IF (IFL.EQ.2.AND.R.GT.0.) THEN
            CPSI=(X(1)*CFIO+X(2)*SFIO)/R
            IF (CPSI.LT.CDFI) THEN
               IF ((X(2)*CFIO-X(1)*SFIO).LE.0.) THEN
                  SAF4=ABS(X(1)*S1-X(2)*C1)
               ELSE
                  SAF4=ABS(X(1)*S2-X(2)*C2)
               END IF
            END IF
         END IF
         SAFE=MAX(SAF1,SAF2,SAF3,SAF4)
         IF (IACT.EQ.0) GO TO 999
         IF (IACT.EQ.1.AND.SNEXT.LE.SAFE) GO TO 999
      END IF
*
*     Intersection with z-plane
*     only points outside the z range need to be considered
      IF (ABS(X(3)).GE.P(1)) THEN
         IF (X(3)*X(6).LT.0.) THEN
            S=(ABS(X(3))-P(1))/ABS(X(6))
            XI=X(1)+S*X(4)
            YI=X(2)+S*X(5)
            RIQ=XI**2+YI**2
            IF (X(3).LE.0.) THEN
               R1Q=P(2)**2
               R2Q=P(3)**2
            ELSE
               R1Q=P(4)**2
               R2Q=P(5)**2
            END IF
            IF (R1Q.LE.RIQ.AND.RIQ.LE.R2Q) THEN
               IF (IFL.EQ.1.OR.RIQ.LE.0.)  GO TO 101
               CPSI=(XI*CFIO+YI*SFIO)/SQRT(RIQ)
               IF (CPSI.GE.CDFI) GO TO 101
            END IF
         END IF
      END IF
*
*     Intersection with cones
*     Intersection point (x,y,z)
*     (x,y,z) is on track: x=X(1)+t*X(4)
*                          y=X(2)+t*X(5)
*                          z=X(3)+t*X(6)
*     (x,y,z) is on cone : x**2 + y**2 = (a*z+b)**2
*
*     (X(4)**2+X(5)**2-(a*x(6))**2)*t**2
*     +2.*(X(1)*X(4)+X(2)*X(5)-a*x(6)*(a*x(3)+b))*t
*     +X(1)**2+X(2)**2-(a*x(3)+b)**2=0
*
      T1=X(4)**2+X(5)**2
      T2=X(1)*X(4)+X(2)*X(5)
      T3=X(1)**2+X(2)**2
*
*     Intersection with the outer cone
*     only points outside the outer cone need to be considered
      SR2=1.E10
      IF ((ZV2*X(3).GT.ZV2*ZV2).OR.(R.GT.ROUT)) THEN
         U=T1-(TG2*X(6))**2
         V=T2- TG2*X(6)*(TG2*X(3)+RO2)
         W=T3- ROUT*ROUT
*        track not parallel to the cone ?
         IF (U.NE.0.) THEN
            B=V/U
            C=W/U
            D=B**2-C
            IF (D.GE.0.) THEN
*              compute the smallest root first
               IR=-1
   11          S=-B+IR*SQRT(D)
               IF (S.GE.0.) THEN
                  ZI=X(3)+S*X(6)
                  IF (ABS(ZI).LE.P(1)) THEN
                     IF (IFL.EQ.1.OR.ZI.EQ.ZV2) THEN
                        SR2=S
                     ELSE
                        XI=X(1)+S*X(4)
                        YI=X(2)+S*X(5)
                        RI=TG2*ZI+RO2
                        CPSI=(XI*CFIO+YI*SFIO)/RI
                        IF (CPSI.GE.CDFI) SR2=S
                     END IF
                  END IF
               END IF
               IF (IR.EQ.-1) THEN
                  IF (SR2.EQ.S) GO TO 101
*                 smallest root not ok. Try the biggest one
                  IR=+1
                  GO TO 11
               END IF
            END IF
         ELSEIF (V.NE.0.) THEN
            S=-HALF*W/V
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(1)) THEN
                  IF (IFL.EQ.1.OR.ZI.EQ.ZV2)  GO TO 101
                  XI=X(1)+S*X(4)
                  YI=X(2)+S*X(5)
                  RI=TG2*ZI+RO2
                  CPSI=(XI*CFIO+YI*SFIO)/RI
                  IF (CPSI.GE.CDFI) GO TO 101
               END IF
            END IF
         END IF
      END IF
*
*     Intersection with the inner cone
      SR1=1.E10
      IF (RO1.GT.0.) THEN
         U=T1-(TG1*X(6))**2
         V=T2- TG1*X(6)*(TG1*X(3)+RO1)
         W=T3- RIN*RIN
*        track not parallel to the cone ?
         IF (U.NE.0.) THEN
            B=V/U
            C=W/U
            D=B**2-C
            IF (D.GE.0.) THEN
*              compute the smallest root first
               IR=-1
   21          S=-B+IR*SQRT(D)
               IF (S.GE.0.) THEN
                  ZI=X(3)+S*X(6)
                  IF (ABS(ZI).LE.P(1)) THEN
                     IF (IFL.EQ.1.OR.ZI.EQ.ZV1) THEN
                        SR1=S
                     ELSE
                        XI=X(1)+S*X(4)
                        YI=X(2)+S*X(5)
                        RI=TG1*ZI+RO1
                        CPSI=(XI*CFIO+YI*SFIO)/RI
                        IF (CPSI.GE.CDFI) SR1=S
                     END IF
                  END IF
               END IF
               IF (IR.EQ.-1.AND.SR1.GT.9.E9) THEN
*                 smallest root not ok. Try the biggest one
                  IR=+1
                  GO TO 21
               END IF
            END IF
         ELSEIF (V.NE.0.) THEN
            S=-HALF*W/V
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(1)) THEN
                  IF (IFL.EQ.1.OR.ZI.EQ.ZV1) THEN
                     SR1=S
                  ELSE
                     XI=X(1)+S*X(4)
                     YI=X(2)+S*X(5)
                     RI=TG1*ZI+RO1
                     CPSI=(XI*CFIO+YI*SFIO)/RI
                     IF (CPSI.GE.CDFI) SR1=S
                  END IF
               END IF
            END IF
         END IF
      END IF
*
      SNXT=MIN(SR1,SR2)
*
*     Intersection with phi-planes
*     x=r*cos(phi)=X(1)+t*X(4)
*     y=r*sin(phi)=X(2)+t*X(5)
*     z           =X(3)+t*X(6)
*     t=(X(2)*cos(phi)-X(1)*sin(phi))/(X(4)*sin(phi)-X(5)*cos(phi))
*
      IF (IFL.EQ.2) THEN
*        track not parallel to the phi1 plane ?
         UN=X(4)*S1-X(5)*C1
         IF (UN.NE.0.) THEN
            S=(X(2)*C1-X(1)*S1)/UN
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(1)) THEN
                  XI=X(1)+S*X(4)
                  YI=X(2)+S*X(5)
                  RIQ=XI**2+YI**2
                  R1Q=(TG1*ZI+RO1)**2
                  R2Q=(TG2*ZI+RO2)**2
                  IF (R1Q.LE.RIQ.AND.RIQ.LE.R2Q) THEN
                     IF ((YI*CFIO-XI*SFIO).LE.0.) THEN
                        IF (S.LT.SNXT) SNXT=S
                     END IF
                  END IF

              END IF
            END IF
         END IF
*        track not parallel to the phi2 plane ?
         UN=X(4)*S2-X(5)*C2
         IF(UN.NE.0.) THEN
            S=(X(2)*C2-X(1)*S2)/UN
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(1)) THEN
                  XI=X(1)+S*X(4)
                  YI=X(2)+S*X(5)
                  RIQ=XI**2+YI**2
                  R1Q=(TG1*ZI+RO1)**2
                  R2Q=(TG2*ZI+RO2)**2
                  IF (R1Q.LE.RIQ.AND.RIQ.LE.R2Q) THEN
                     IF ((YI*CFIO-XI*SFIO).GE.0.) THEN
                        IF (S.LT.SNXT) SNXT=S
                     END IF
                  END IF
               END IF
            END IF
         END IF
      END IF
      GO TO 999
*
  101 SNXT=S
  999 END
+DECK,  GNOCTU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOCTU(X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      COMPUTE DISTANCE UP TO INTERSECTION WITH 'CTUB'           *
C.    *      VOLUME, FROM OUTSIDE POINT X(1-3) ALONG DIRECTION X(4-6)  *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GNOPCO, GTNEXT                        *
C.    *         Author   A.McPherson   ********                        *
C.    *       MODIFICATION LOG.                                        *
C.    *       18-July-89 M.Guckes modifications due to GEANG 3.13      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6),PAR(11),SNP(2),CSP(2)
*
*     ------------------------------------------------------------------
*
      SNXT = BIG
*
* *** Make sure that (-pi).LT.PHI.GE.(+pi)
*
      PH1  = MOD(PAR(4)*DEGRAD,TWOPI)
      PH2  = MOD(PAR(5)*DEGRAD,TWOPI)
      DPHI = PH2 - PH1
      IF(DPHI.LT.TWOPI) THEN
         DPHI = PH2 - PH1
         SNP(1) = SIN(PH1)
         CSP(1) = COS(PH1)
         SNP(2) = SIN(PH2)
         CSP(2) = COS(PH2)
      ELSE
         PH1  = 0.
         PH2  = TWOPI
         DPHI = TWOPI
         SNP(1) = 0.
         CSP(1) = 1.
         SNP(2) = 0.
         CSP(2) = 1.
      ENDIF
C
*
* *** Check that current point is outside the CTUB.  compute SAFE
*
      R02=X(1)*X(1)+X(2)*X(2)
      R=SQRT(R02)
      SAF1=PAR(1)-R
      SAF2=R-PAR(2)
      SAF3 = ( X(3)+PAR(3) )*PAR(8)+X(1)*PAR(6)+X(2)*PAR(7)
      SAF4 = ( X(3)-PAR(3) )*PAR(11)+X(1)*PAR(9)+X(2)*PAR(10)
*
      IF(IACT.EQ.3) GO TO 20
*
*     Phi segment (P. Weidhaas)
*       We compute here the distance (SAF5)
*        to the PHI-segment boundary that is closest to the point:
*
*        SAF5 is only calculated if PHI lies outside the interval
*        [PH1, PH2]. Here PHI is the angle to the given point
*        (thus we only consider SAF5 if the point is outside the
*        PHI-segment : FIOUT > 0.
*        Algorithm to find SAF5 (same as in routine "GNTUBE"):
*        For each PHI-boundary we find the distance from the given
*        point to the outer (at RMAX) point of the segment boundary
*        (DSP1 and DSP2, resp.). If DSP1 < DSP2, we define
*        SAF5 to be the distance to segment PHI1; else we set
*        SAF5 to be the distance to segment PHI2.
      SAF5=0.
      IF(R.GT.0.) THEN
         PHI    = ATAN2(X(2),X(1))
         FIOUT  = DPHI*(PHI-PH1)*(PHI-PH2)
         IF(FIOUT.LE.0.) GO TO 16
         DSP1 = (X(1)-PAR(2)*CSP(1))**2 + (X(2)-PAR(2)*SNP(1))**2
         DSP2 = (X(1)-PAR(2)*CSP(2))**2 + (X(2)-PAR(2)*SNP(2))**2
         IF(DSP1.LE.DSP2) THEN
            SAF5 = ABS(X(1)*SNP(1) - X(2)*CSP(1))
         ELSE
            SAF5 = ABS(X(1)*SNP(2) - X(2)*CSP(2))
         ENDIF
      ENDIF
   16 CONTINUE
*
*     Compute SAFE
      SAFE = 0.
      IF(SAF1.GT.SAFE) SAFE = SAF1
      IF(SAF2.GT.SAFE) SAFE = SAF2
      IF(SAF3.GT.SAFE) SAFE = SAF3
      IF(SAF4.GT.SAFE) SAFE = SAF4
      IF(SAF5.GT.SAFE) SAFE = SAF5
*
*     Point inside the volume ?
      IF(SAFE.EQ.0.) THEN
         SNXT = -10.
         GO TO 999
      ENDIF
*
      IF(IACT.EQ.0)                   GO TO 999
      IF(IACT.EQ.1.AND.SAFE.GT.SNEXT) GO TO 999
*
   20 CONTINUE
*
* *** Compute SNXT
*
      SMAX=BIG
      V1 = X(4)*PAR(6)+X(5)*PAR(7)+X(6)*PAR(8)
      V2 = X(4)*PAR(9)+X(5)*PAR(10)+X(6)*PAR(11)
      IF( V1 .GE. 0.0 .AND. SAF3 .GE. 0.0 ) GO TO 999
      IF( V2 .GE. 0.0 .AND. SAF4 .GE. 0.0 ) GO TO 999
C
      IF( SAF3 .GT. 0.0 .AND. SAF4 .LE. 0.0 ) THEN
        SMIN = -SAF3/V1
        IF( V2 .GT. 0 ) THEN
          SMAX = -SAF4/V2
        ELSE
          SMAX = BIG
        ENDIF
      ELSEIF( SAF4 .GT. 0.0 .AND. SAF3 .LE. 0.0 ) THEN
        SMIN = -SAF4/V2
        IF( V1 .GT. 0 ) THEN
          SMAX = -SAF3/V1
        ELSE
          SMAX = BIG
        ENDIF
      ELSEIF( SAF3 .LE. 0.0 .AND. SAF4 .LE. 0.0 ) THEN
        SMIN = 0.0
        SMAX = BIG
        IF( V1 .GT. 0.0 ) SMAX = -SAF3/V1
        IF( V2 .GT. 0.0 .AND. SMAX .GT. -SAF4/V2 ) SMAX = -SAF4/V2
      ENDIF
*
      SMIN1=SMIN
      SMAX1=-1.0
      SMIN2=SMIN
      SMAX2=SMAX
C
      DXY2=(1+X(6))*(1-X(6))
      IF(DXY2.LT.1.0E-10.AND.(R.LT.PAR(1)
     +   .OR.R.GT.PAR(2)))GO TO 999
      IF(DXY2.EQ.0.) GO TO 30
C
      BA=(X(1)*X(4)+X(2)*X(5))/DXY2
      IF(R.GE.PAR(2).AND.BA.GE.0.0) GO TO 999
C
      CA=(R02-PAR(2)*PAR(2))/DXY2
      DISC=BA*BA-CA
      IF(DISC.LE.0.0) GO TO 999
C
      RDISC=SQRT(DISC)
      SMAR=-BA+RDISC
      IF(SMAR.LT.SMAX) SMAX=SMAR
      SMIR=-BA-RDISC
      IF(SMIR.GT.SMIN) SMIN=SMIR
      IF(SMAX.LE.SMIN) GO TO 999
C
      CA=(R02-PAR(1)*PAR(1))/DXY2
      DISC=BA*BA-CA
C
      SMIN1=SMIN
      SMAX1=-1.0
      SMIN2=SMIN
      SMAX2=SMAX
C
      IF(DISC.LE.0.0) GO TO 30
      RDISC=SQRT(DISC)
      SMI2=-BA+RDISC
      IF(SMI2.GT.SMIN2)SMIN2=SMI2
      SMAX1=-BA-RDISC
      IF(SMAX.LT.SMAX1) SMAX1=SMAX
C
   30 CONTINUE
C
      IF( PAR(4) .EQ. 0.0 .AND. PAR(5) .EQ. 360.0 ) GO TO 120
C
C                   Now do the phi stuff.
C
      DPSGN=X(1)*X(5)-X(2)*X(4)
      ISMIN=0
      ISMAX=0
C
      TSGN=SNP(1)
      TCSG=CSP(1)
      DEN=X(4)*TSGN-X(5)*TCSG
      IF(DEN.EQ.0.0) GO TO 40
      SNL=(X(2)*TCSG-X(1)*TSGN)/DEN
      IF(ABS(TSGN).GT.1.E-6.AND.(X(2)+SNL*X(5))*TSGN.LT.0.) GO TO 40
      IF(ABS(TCSG).GT.1.E-6.AND.(X(1)+SNL*X(4))*TCSG.LT.0.) GO TO 40
C
      ISMIN=1
      SMIN=SNL
      IF(DPSGN.GT.0.0) GO TO 40
      ISMIN=0
      ISMAX=1
      SMAX=SNL
C
   40 CONTINUE
C
      TSGN=SNP(2)
      TCSG=CSP(2)
      DEN=X(4)*TSGN-X(5)*TCSG
      IF(DEN.EQ.0.0) GO TO 60
      SNH=(X(2)*TCSG-X(1)*TSGN)/DEN
      IF(ABS(TSGN).GT.1.E-6.AND.(X(2)+SNH*X(5))*TSGN.LT.0.) GO TO 60
      IF(ABS(TCSG).GT.1.E-6.AND.(X(1)+SNH*X(4))*TCSG.LT.0.) GO TO 60
      IF(DPSGN.LT.0.0) GO TO 50
      ISMAX=1
      SMAX=SNH
      GO TO 60
C
   50 CONTINUE
      ISMIN=1
      SMIN=SNH
C
   60 CONTINUE
C
      IF(ISMIN.EQ.0.OR.ISMAX.EQ.0) GO TO 90
      IF(SMAX.LT.0.0.AND.SMAX.GT.SMIN) GO TO 999
      IF(SMIN.LT.0.0) SMIN=0.0
      IF(SMAX.LT.0.0) GO TO 110
      IF(SMAX.GT.SMIN) GO TO 70
C
C                         SMAX +VE and less than SMIN - 2 allowed
C                         regions.
C
      IF(SMAX.GT.SMIN1.AND.SMAX1.GT.SMIN1) GO TO 130
      IF(SMIN.GT.SMIN1) SMIN1=SMIN
      IF(SMAX1.GT.SMIN1) GO TO 130
      IF(SMAX.GT.SMIN2) GO TO 140
      IF(SMIN.GT.SMAX2) GO TO 999
      IF(SMIN.GT.SMIN2) SMIN2=SMIN
      GO TO 140
C
   70 CONTINUE
      IF(SMIN.GT.SMIN1) SMIN1=SMIN
      IF(SMAX.LT.SMAX1) SMAX1=SMAX
      IF(SMAX1.LT.SMIN1) GO TO 80
      GO TO 130
C
   80 CONTINUE
      IF(SMIN.GT.SMIN2) SMIN2=SMIN
      IF(SMAX.LT.SMAX2) SMAX2=SMAX
      IF(SMAX2.LT.SMIN2) GO TO 999
      GO TO 140
C
   90 CONTINUE
      IF(ISMIN.EQ.1) GO TO 110
      IF(ISMAX.EQ.0) GO TO 100
      IF(SMAX.LT.SMAX1) SMAX1=SMAX
      IF(SMAX.LT.SMAX2) SMAX2=SMAX
      GO TO 120
C
  100 CONTINUE
      DPH=PAR(5)-PAR(4)
      IF(DPH.LT.180.0.AND.DPH.GT.0.0) GO TO 999
      IF(DPH.LT.-180.0) GO TO 999
      GO TO 120
C
  110 CONTINUE
      IF(SMIN.GT.SMIN1) SMIN1=SMIN
      IF(SMAX1.GT.SMIN1) GO TO 130
      IF(SMIN.GT.SMIN2) SMIN2=SMIN
      IF(SMAX2.LT.SMIN2) GO TO 999
      GO TO 140
C
  120 CONTINUE
      IF(SMAX1.GT.SMIN1) GO TO 130
      IF(SMAX2.GT.SMIN2) GO TO 140
      GO TO 999
C
  130 CONTINUE
      IF(SMIN1.LE.0.)GO TO 999
      IF(SNXT.GT.SMIN1) SNXT=SMIN1
      GO TO 999
C
  140 CONTINUE
      IF(SMIN2.LE.0.)GO TO 999
      IF(SNXT.GT.SMIN2) SNXT=SMIN2
C
  999 CONTINUE
      END
+DECK,  GNOELT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOELT(X,PAR,IACT,SNEXT,SNXT,SAFE)
C
C     ****************************************************************
C     *                                                              *
C     *     Compute distance up to intersection with 'ELTU' volume,  *
C     *     from outside point X(1-3) along direction X(4-6).        *
C     *                                                              *
C     *     PAR    (input)  : volume parameters                      *
C     *     IACT   (input)  : action flag                            *
C     *       = 0   Compute SAFE only                                *
C     *       = 1   Compute SAFE, and SNXT only if SNEXT.gt.new SAFE *
C     *       = 2   Compute both SAFE and SNXT                       *
C     *       = 3   Compute SNXT only                                *
C     *     SNEXT  (input)  : see IACT = 1                           *
C     *     SNXT   (output) : distance to volume boundary            *
C     *     SAFE   (output) : shortest distance to any boundary      *
C     *                                                              *
C     *  ==>Called by : GNEXT,GTNEXT                                 *
C     *       Author  A.Solano                                       *
C     *                                                              *
C     ****************************************************************
C
+CDE, GCONSP.
C
      DIMENSION X(6),PAR(3),TAU(2)
C
+SELF, IF=-SINGLE.
      DOUBLE PRECISION SAFZ,A2,B2,X0,Y0,PHI1,PHI2,PHI3,X3,Y3
      DOUBLE PRECISION DXY2,U,V,W,DISCR,SQDISC,TAU,TAUZ,ZI,XZ,YZ
+SELF.
      SNXT = BIG
      SAFZ = ABS(X(3))-PAR(3)
      A2 = PAR(1)*PAR(1)
      B2 = PAR(2)*PAR(2)
C
      IF(IACT.EQ.3)GOTO 40
C
C      -----------------------------------
C      |  Compute safety-distance 'SAFE' |
C      -----------------------------------
C
C ....  First check Z
      X0 = ABS(X(1))
      Y0 = ABS(X(2))
C
      SAFE=0.
      IF(X0*X0/A2+Y0*Y0/B2.LT.1.) GO TO 30
      PHI1=0.
      PHI2=PIBY2
      DO 10    I=1,10
         PHI3=(PHI1+PHI2)*0.5
         X3=PAR(1)*COS(PHI3)
         Y3=PAR(2)*SIN(PHI3)
         D=Y3*A2*(X0-X3)-X3*B2*(Y0-Y3)
*
*        D is the (signed) distance from the point (X0,Y0)
*        to the normal to the ellipse at the point (X3,Y3).
*
         IF (D.LT.0.) THEN
            PHI1=PHI3
         ELSE
            PHI2=PHI3
         END IF
   10 CONTINUE
   20 SAFE=SQRT((X0-X3)**2+(Y0-Y3)**2)-.01
   30 IF(SAFZ.GT.0.)THEN
*
* ....   Combine the radial distance whit the Z-distance
*
         SAFE = SQRT(SAFE**2+SAFZ**2)
      ENDIF
      IF(IACT.EQ.0)GOTO 999
      IF(IACT.EQ.1.AND.SNEXT.LT.SAFE)GOTO 999
   40 CONTINUE
C
C      ---------------------------------------
C      |  Compute the vector-distance 'SNXT' |
C      ---------------------------------------
C
      IF(SAFZ.GT.0.0.AND.X(3)*X(6).GE.0.0)GOTO 999
C
      DXY2 = (1-X(6))*(1+X(6))
      IF(DXY2.LE.0.)GOTO 60
C
C ....  Find the intersection of the given ray
C       (described by array X) whit the cylider.
C       Ray equation : X'(1-3) = X(1-3) + TAU*X(4-6)
C       Cylinder equation : x**2/a**2 + y**2/b**2 = 1
C       To obtain TAU,solve the quadratic equation
C       Ut**2 + 2Vt + W = 0
C
      U = X(4)*X(4)*B2+X(5)*X(5)*A2
      V = X(1)*X(4)*B2+X(2)*X(5)*A2
      W = X(1)*X(1)*B2+X(2)*X(2)*A2-A2*B2
      DISCR = V*V-U*W
      IF(DISCR.LT.0.)GOTO 999
      IF(U.EQ.0.)GOTO 999
      SQDISC = SQRT(DISCR)
      TAU(1) = (-V+SQDISC)/U
      TAU(2) = (-V-SQDISC)/U
C
      DO 50 I=1,2
         IF(TAU(I).GE.0.)THEN
            ZI = X(3)+TAU(I)*X(6)
            IF((ABS(ZI)-PAR(3)).LT.1.E-6)THEN
C
C ....  Set SNXT to the smallest positive TAU,only if
C       the intersection point is inside the Z limits
C
               SNXT = MIN(SNXT,REAL(TAU(I)))
            ENDIF
         ENDIF
   50 CONTINUE
   60 CONTINUE
C
      IF(SAFZ.GT.0.)THEN
C
C ....  Check intersection whit Z planes
C
         IF(X(3).GT.0.) ZI = PAR(3)
         IF(X(3).LT.0.) ZI = -PAR(3)
C
         TAUZ = (ZI-X(3))/X(6)
         XZ = X(1)+X(4)*TAUZ
         YZ = X(2)+X(5)*TAUZ
         IF((XZ*XZ/A2+YZ*YZ/B2).LE.1.) SNXT = TAUZ
      ENDIF
C
  999 END
+DECK,  GNOHYP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOHYP (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      COMPUTE DISTANCE UP TO INTERSECTION WITH HYPErboloid      *
C.    *      VOLUME, FROM OUTSIDE POINT X(1-3) ALONG DIRECTION X(4-6)  *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *                        inner radius                            *
C.    *                        outer radius                            *
C.    *                        half length in z                        *
C.    *                        straw stereo angle in degrees           *
C.    *                        r**2 = (z*tan(theta))**2 + a**2         *
C.    *                                                                *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Authors  M.J.Corden, A.Palounek                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6),PAR(4),ENDR(2)
*
*     ------------------------------------------------------------------
*
      SNXT = BIG
      TANTHS= (TAN(PAR(4)*DEGRAD))**2
      R2 = X(1)*X(1)+X(2)*X(2)
      ENDR(1)=SQRT(PAR(1)**2+PAR(3)**2*TANTHS)
      ENDR(2)=SQRT(PAR(2)**2+PAR(3)**2*TANTHS)
      SAF3=ABS(X(3))-PAR(3)
*
      IF(IACT.EQ.3) GO TO 10
*
*     compute SAFE from escribed cylinders
*
      R  = SQRT(R2)
      SAF1=PAR(1)-R
      SAF2=R-ENDR(2)
      SAFE = MAX(0.,SAF1,SAF2,SAF3)
*
      IF(IACT.EQ.0) GO TO 999
      IF(IACT.EQ.1.AND.SAFE.GT.SNEXT) GO TO 999
*
   10 CONTINUE
*
* *** Compute SNXT
*
      IF((SAF3.GT.0.).AND.(X(3)*X(6).GE.0.)) GO TO 999
C
C       Compute intercept with inner & outer surfaces.
C
      A = X(4)**2 + X(5)**2 - X(6)**2*TANTHS
      B = X(1)*X(4) + X(2)*X(5) - X(3)*X(6)*TANTHS
C
      DO 30 NCYL =1,2
         C = R2 - X(3)**2*TANTHS - PAR(NCYL)**2
         SURD = B**2 - A*C
         IF(SURD.LE.0.0) GO TO 30
         SURD=SQRT(SURD)
*
         DO 20 IR=-1,+1,2
            S=(-B+IR*SURD)/A
            IF((S.LT.0.).OR.(S.GT.SNXT)) GO TO 20
*       Intersection point
            ZI = X(3) + S*X(6)
*       Check Z limits
            IF(ABS(ZI).GT.PAR(3)) GO TO 20
*       Intersection with hyperboloid ok
            SNXT = S
   20    CONTINUE
   30 CONTINUE
*
* *** Intersection with Z end planes
*
      IF(SAF3.LE.0.) GO TO 999
      S    = SAF3/ABS(X(6))
*     Intersection point
      XI  = X(1) + S*X(4)
      YI  = X(2) + S*X(5)
*     Check R limits
      RI  = SQRT(XI*XI + YI*YI)
      IF(RI.LT.ENDR(1).OR.RI.GT.ENDR(2)) GO TO 999
*     Intersection with Z end plane ok
      SNXT  = S
*
  999 END
+DECK,  GNOPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOPAR (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *      COMPUTE DISTANCE UP TO INTERSECTION WITH 'PARA' VOLUME,   *
C.    *       FROM OUTSIDE POINT X(1-3) ALONG DISTANCE X(4-6)          *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6), PAR(6)
C.
C.    -------------------------------------------
C.
      SNXT=BIG
      DN31=-PAR(3)-X(3)
      DN32=PAR(3)-X(3)
      YT=X(2)-PAR(6)*X(3)
      DN21=-PAR(2)-YT
      DN22=PAR(2)-YT
      CTY=1.0/SQRT(1.0+PAR(6)**2)
C
      XT=X(1)-PAR(5)*X(3)-PAR(4)*YT
      DN11=-PAR(1)-XT
      DN12=PAR(1)-XT
      CTX=1.0/SQRT(1.0+PAR(4)**2+PAR(5)**2)
C
      SN3=DN31
      IF(SN3.LT.0.0) SN3=-DN32
      SN2=DN21*CTY
      IF(SN2.LT.0.0) SN2=-DN22*CTY
      SN1=DN11*CTX
      IF(SN1.LT.0.0) SN1=-DN12*CTX

      IF (IACT .LT. 3) THEN


C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (McPherson)   |
C       -------------------------------------------------

        SAFE=MAX(SN1,SN2,SN3)
C
C      IF(SAFETY.LT.0.0) GO TO 900
C

        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------


      IF(X(6).NE.0.0) GO TO 5
      IF(DN32*DN31.GT.0.0) GO TO 999
      DN31=0.0
      DN32=BIG
      GO TO 10
    5 CONTINUE
C
      DN31=DN31/X(6)
      DN32=DN32/X(6)
      IF(X(6).GT.0.0) GO TO 10
C
      DNS=DN31
      DN31=DN32
      DN32=DNS
C
   10 CONTINUE
C
      IF(DN32.LE.0.0) GO TO 999
C
      DY=X(5)-PAR(6)*X(6)
C
      IF(DY.NE.0.0) GO TO 15
      IF(DN21*DN22.GT.0.0) GO TO 999
      DN21=0.0
      DN22=BIG
      GO TO 20
   15 CONTINUE
      DN21=DN21/DY
      DN22=DN22/DY
      IF(DY.GT.0.0) GO TO 20
C
      DNS=DN21
      DN21=DN22
      DN22=DNS
C
   20 CONTINUE
C
      IF(DN22.LE.0.0) GO TO 999
C
      DX=X(4)-PAR(5)*X(6)-PAR(4)*DY
      IF(DX.NE.0.0) GO TO 25
      IF(DN11*DN12.GT.0.0) GO TO 999
      DN11=0.0
      DN12=BIG
      GO TO 30
   25 CONTINUE
      DN11=DN11/DX
      DN12=DN12/DX
      IF(DX.GT.0.0) GO TO 30
C
      DNS=DN11
      DN11=DN12
      DN12=DNS
C
   30 CONTINUE
C
      IF(DN12.LE.0.0) GO TO 999
C
      SMIN=MAX(DN11,DN21,DN31)
      SMAX=MIN(DN12,DN22,DN32)
C
      IF(SMAX.LE.SMIN) GO TO 999
C
      IF(SMIN.LE.0.)GO TO 999
      SNXT = SMIN
C
  999 CONTINUE
      END
+DECK,  GNOPCO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOPCO (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'PCON' VOLUME,  *
C.    *       FROM OUTSIDE POINT X(1-3) ALONG DIRECTION X(4-6)         *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson,  P.Weidhaas  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6), PAR(9), PT(7), XT(6)

      EQUIVALENCE (PT(1),PT1), (PT(2),PT2), (PT(3),PT3), (PT(4),PT4)
      EQUIVALENCE (PT(5),PT5), (PT(6),PT6), (PT(7),PT7)
C.
C.   --------------------------------------------------------
C.

      SNXT = BIG
      SAFE = BIG
      R2 = X(1)*X(1) + X(2)*X(2)
      R  = SQRT (R2)
      NZ  = PAR(3)
      NSEC= NZ - 1
      PT6=PAR(1)
      PT7=PAR(1)+PAR(2)

      IFLAG = 2
      IF(PAR(2).EQ.360.0) IFLAG = 1

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------


        SAFEZ  = 0.0
C
C......  Obtain axial distance "SAFEZ".
C
        ZMIN   = PAR(4)
        ZMAX   = PAR(3*NZ+1)

        IF (X(3) .LT. ZMIN) THEN
          SAFEZ  = ZMIN - X(3)
        ELSEIF (X(3) .GT. ZMAX) THEN
          SAFEZ  = X(3) - ZMAX
        ENDIF


C----------------------------------------------------
C......  Prepare parameters for PHI-segmented cone:
C----------------------------------------------------

      IF (IFLAG .EQ. 2) THEN

        PHI1 = MOD (PT6+360.0 , 360.0)
        PHI2 = MOD (PT7+360.0 , 360.0)
        IF ( X(1).NE.0.0 .OR. X(2).NE.0.0 ) THEN
           PHI = ATAN2( X(2), X(1) ) * RADDEG
        ELSE
           PHI = 0.0
        ENDIF
        PHI  = MOD (PHI+360.0 , 360.0)

        SINPH1 = SIN(PHI1*DEGRAD)
        COSPH1 = COS(PHI1*DEGRAD)
        SINPH2 = SIN(PHI2*DEGRAD)
        COSPH2 = COS(PHI2*DEGRAD)


C......  Set flag "IOPENP" if point (X(1),X(2),X(3)) lies in the
C......  PHI-opening.

        IOPENP = 0
        IF (PHI2 .GT. PHI1) THEN
          IF (PHI.GT.PHI2 .OR. PHI.LT.PHI1) IOPENP = 1
        ELSE
          IF (PHI.GT.PHI2 .AND. PHI.LT.PHI1) IOPENP = 1
        ENDIF
      ENDIF



C------------------   Start of loop over Z-sections  --------------

        IPZ2=4

        DO 150 IS=1,NSEC

        IPZ1=IPZ2
        IPZ2=IPZ1+3

        SAFSEG = 0.0
        SAFER  = 0.0

        XT3=X(3) - 0.5 * (PAR(IPZ1)+PAR(IPZ2))
        DZ   = 0.5 * (PAR(IPZ2)-PAR(IPZ1))

        PT2  = PAR(IPZ1+1)
        PT3  = PAR(IPZ1+2)
        PT4  = PAR(IPZ2+1)
        PT5  = PAR(IPZ2+2)
C**** check DZ=0 segments
        IF (DZ.LE.0.) THEN
           IF ((R-PT2)*(R-PT4).LE.0. .OR. (R-PT3)*(R-PT5).LE.0.) THEN
              SAFER = ABS(XT3)
           ELSE
              GO TO 150
           ENDIF
           GO TO 100
        ENDIF

        IF (PT2 .NE. PT4) GO TO 50
        IF (PT3 .NE. PT5) GO TO 50

C**********************************************************
C
C......  The segment is a tube;  invoke the algorithm
C......  from "GNOTUB" inline to get "SAFER" and "SAFSEG".
C
C**********************************************************

        IF (R .LT. PT2) SAFER = PT2 - R
        IF (R .GT. PT3) SAFER = R - PT3

        IF (IFLAG .EQ. 2)  THEN

C********************************************************************
C......  Handle the case in which we have a PHI-segment of a tube.
C......  In addition to the radial distance (SAFER) and the
C......  axial distance (SAFEZ) we compute here the distance (SAFSEG)
C......  to the PHI-segment boundary that is closest to the point:
C
C......  SAFSEG is only calculated if PHI lies outside the interval
C......  [PHI1, PHI2]. Here PHI is the angle to the given point
C......  (thus we only consider SAFSEG if the point is outside the
C......  PHI-segment).
C
C......  Algorithm to find SAFSEG (same as in routine "GNTUBE"):
C
C......  For each PHI-boundary we find the distance from the given
C......  point to the outer (at RMAX) point of the segment boundary
C......  (DISTS1 and DISTS2, resp.). If DISTS1 < DISTS2, we define
C......  SAFSEG to be the distance to segment PHI1; else we set
C......  SAFSEG to be the distance to segment PHI2.
C********************************************************************


C......  Next eliminate those points whose angle PHI places them
C......  inside the given PHI-segment (IOPENP = 0).

          IF (IOPENP .EQ. 0) GO TO 100


C......  Get coordinates of outer endpoints (at RMAX) of both PHI-segments.

          XS1  = PT3 * COSPH1
          YS1  = PT3 * SINPH1
          XS2  = PT3 * COSPH2
          YS2  = PT3 * SINPH2

C......  Get distances (squared) from the given point to each endpoint.

          DISTS1 = (X(1) - XS1)**2  +  (X(2) - YS1)**2
          DISTS2 = (X(1) - XS2)**2  +  (X(2) - YS2)**2

C......  Get distance to that PHI-segment whose endpoint
C......  is closest to the given point.

          IF (DISTS1 .LE. DISTS2) THEN
            SAFSEG = ABS(X(1) * SINPH1 - X(2) * COSPH1)
          ELSE
            SAFSEG = ABS(X(1) * SINPH2 - X(2) * COSPH2)
          ENDIF

        ENDIF

        GO TO 100


   50   CONTINUE

C*********************************************************
C
C......  The segment is a cone; invoke the algorithm
C......  from "GNOCON" inline to get "SAFER" and "SAFSEG".
C
C*********************************************************

        ZLENI = 0.5 / DZ

        FACT1  = (PT4 - PT2) * ZLENI
        FACT2  = (PT5 - PT3) * ZLENI
        RIN   = PT2 + FACT1 * (DZ + XT3)
        ROUT  = PT3 + FACT2 * (DZ + XT3)

        IF (R .LT. RIN) THEN
          SAFER = (RIN - R) / SQRT(1.0 + FACT1 * FACT1)
        ELSE
          IF (R .GT. ROUT) THEN
            SAFER = (R - ROUT) / SQRT(1.0 + FACT2 * FACT2)
          ENDIF
        ENDIF


        IF (IFLAG .EQ. 2)  THEN

C********************************************************************
C......  Handle the case in which we have a PHI-segment of a cone.
C......  In addition to the radial distance (SAFER) and the
C......  axial distance (SAFEZ) we compute here the distance (SAFSEG)
C......  to the PHI-segment boundary that is closest to the point:
C
C......  SAFSEG is only calculated if PHI lies outside the interval
C......  [PHI1, PHI2]. Here PHI is the angle to the given point
C......  (thus we only consider SAFSEG if the point is outside the
C......  PHI-segment).
C
C......  Algorithm to find SAFSEG (same as in routine "GNTUBE"):
C
C......  For each PHI-boundary we find the distance from the given
C......  point to the outer (at ROUT) point of the segment boundary
C......  (DISTS1 and DISTS2, resp.). If DISTS1 < DISTS2, we define
C......  SAFSEG to be the distance to segment PHI1; else we set
C......  SAFSEG to be the distance to segment PHI2.
C********************************************************************


C......  Next eliminate those points whose angle PHI places them
C......  inside the given PHI-segment (IOPENP = 0).

           IF (IOPENP .EQ. 0) GO TO 100

C......  Get coordinates of outer endpoints (at ROUT) of both PHI-segments.

          IF (XT3 .LT. -DZ) THEN
            ROUT = PT3
          ELSEIF (XT3 .GT. DZ) THEN
            ROUT = PT5
          ENDIF

          XS1  = ROUT * COSPH1
          YS1  = ROUT * SINPH1
          XS2  = ROUT * COSPH2
          YS2  = ROUT * SINPH2

C......  Get distances (squared) from the given point to each endpoint.

          DISTS1 = (X(1) - XS1)**2  +  (X(2) - YS1)**2
          DISTS2 = (X(1) - XS2)**2  +  (X(2) - YS2)**2

C......  Obtain distance to that PHI-segment whose endpoint
C......  is closest to the given point.

          IF (DISTS1 .LE. DISTS2) THEN
            SAFSEG = ABS(X(1) * SINPH1 - X(2) * COSPH1)
          ELSE
            SAFSEG = ABS(X(1) * SINPH2 - X(2) * COSPH2)
          ENDIF

        ENDIF


  100   CONTINUE
        TSAFE  = MAX (SAFEZ, SAFER, SAFSEG)

        IF (TSAFE .GT. 0.0) THEN
          IF (TSAFE .LT. SAFE) SAFE  = TSAFE
        ENDIF

        IF (TSAFE .EQ. 0.0) THEN
          IF (X(3) .LT. PAR(IPZ1)) GO TO 200
        ENDIF
  150   CONTINUE

  200   CONTINUE
        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------

      TSNXT = BIG

      DO 210 I=1, 6
        XT(I) = X(I)
  210 CONTINUE

      IPZ2 = 4

      DO 300  IS=1, NSEC
        IPZ1  = IPZ2
        IPZ2  = IPZ1 + 3

        XT(3) = X(3) - 0.5 * (PAR(IPZ1) + PAR(IPZ2))

        PT1 = 0.5 * (PAR(IPZ2) - PAR(IPZ1))
        IF (PT1 .LE. 0.0) GO TO 300

        IF (PAR(IPZ1+1) .NE. PAR(IPZ2+1)) GO TO 250
        IF (PAR(IPZ1+2) .NE. PAR(IPZ2+2)) GO TO 250

C
C......  This Z-section is a tube.
C
        PT3 = PT1
        PT1 = PAR(IPZ1+1)
        PT2 = PAR(IPZ1+2)
        PT4 = PT6
        PT5 = PT7

        CALL GNOTUB (XT, PT, 3, IFLAG, SNEXT, TSNXT, TSAFE)
        GO TO 280


  250   CONTINUE
C
C......   This Z-section is a cone.
C
        PT2 = PAR(IPZ1+1)
        PT3 = PAR(IPZ1+2)
        PT4 = PAR(IPZ2+1)
        PT5 = PAR(IPZ2+2)

        CALL GNOCON (XT, PT, 3, IFLAG, SNEXT, TSNXT, TSAFE)

  280 CONTINUE
      IF (TSNXT .LT. SNXT)  SNXT = TSNXT
  300 CONTINUE

  999 CONTINUE
      END
+DECK,  GNOPG1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:52  cernlib
* Geant

      SUBROUTINE GNOPG1(X,P,SNXT)
*********************************************************************
***** GNOPG1 ********************************************************
*
*     GNOPG1 ... 20-DEC-1988
*     Version 1.1
*     Rolf Nierhaus
*
*********************************************************************
*
*     Copyright   CERN,   Geneva  1988  -  Copyright  and  any  other
*     appropriate legal protection of  these  computer  programs  and
*     associated  documentation  reserved  in  all  countries  of the
*     world.
*
*********************************************************************
*
*          Subroutine  GNOPG1 is called by GNOPGO for the computation
*     of SNXT, the distance from a point P  along  a  track  T  to  a
*     boundary  surface  of a Geant volume V of shape PGON. The point
*     P is outside the volume V. If the track T has  no  intersection
*     with the volume V, the vector distance SNXT is set to 1.E10.
*
*          V  is  generally  a composite volume consisting of several
*     sections. The sections have  boundary  surfaces  orthogonal  to
*     the   Z-axis.   Each  section  consists  generally  of  several
*     sectors. Each sector is an  "elementary"  convex  volume.  This
*     package  assumes it is either a hexahedron or a pentahedron. If
*     it is a pentahedron, it has 6 vertices, of  which  two  are  on
*     the  Z-axis.  All  sectors  of  the same section are congruent.
*     Each section has the same number of sectors.
*
*          GNOPG1 calls GNOPG2 for each section, GNOPG2  call  GNOPG3
*     for  each  sector.  GNOPG4  is  called  to  store  the  surface
*     parameters of  a  sector  in  the  common  block  GCQ1.  GNOPG6
*     computes  the  vector  distance  to  a  convex  volume.  GNOPG7
*     computes the  vector  distance  to  a  plane  surface.  Logical
*     function  GNOPG8  determines  if  a  point  is  inside a convex
*     volume, and logical function GNOPG9 determines if  a  point  is
*     inside a region delimited by a plane surface.
*
*          We  describe each surface by 6 parameters: the first three
*     are   the   coordinates   of   a   point   on    the    surface
*     XS(I),YS(I),ZS(I),  the  other  three are the components of the
*     normal vector of the surface XN(I),YN(I),ZN(I). I is the  index
*     of  the surface. We consider only one sector at a time, and the
*     number of boundary  surfaces  is  never  larger  then  6.  Each
*     surface  divides  the  space  into  two  regions:  the positive
*     region and the negative region. We choose the direction of  the
*     normal  vectors  of the boundary surfaces such that the bounded
*     volume is within the positive region of each surface, that  is,
*     the normal vector is pointing to the inside of the volume.
*
*          Logical   function   GNOPG9  returns  TRUE  if  the  point
*     (XP,YP,ZP) is within the positive region of  the  surface  with
*     index   I.   This   is  the  case  if  the  scalar  product  of
*     (XP-XS,YP-YS,ZP-ZS) and (XN,YN,ZN) is positive (or zero).
*
*          GNOPG8 is true if  the  point  (XP,YP,ZP)  is  within  the
*     positive region of all bounding surfaces.
*
*          To  find  the  distance  from  a  point (XP,YP,ZP) along a
*     track  with  direction  cosines   (XD,YD,ZD)   to   a   surface
*     (XS,YS,ZS)(XN,YN,ZN),  we  compute  first the scalar product of
*     the  vector  (XS-XP,YS-YP,ZS-ZP)   with   the   normal   vector
*     (XN,YN,ZN),  then  the scalar product of the vectors (XD,YD,ZD)
*     and (XN,YN,ZN).  The  first  scalar  product  is  the  shortest
*     distance  from  the  point  to  the  plane,  the  second scalar
*     product is the cosine of the angle between the  track  and  the
*     plane  normal.  The  quotient  is  the vector distance. If this
*     vector distance is  positive  (or  zero)  we  set  the  logical
*     variable  FLAG  TRUE.  GNOPG7  is  called with three parameters
*     I,FLAG and DIST. I is the index of the  surface,  and  DIST  is
*     the vector distance if FLAG is TRUE.
*
*          To  find the vector distance from a point to an elementary
*     volume, all bounding surfaces of the volume are considered.  If
*     the  point  is  in  the positive region of a surface, the track
*     could possibly exit through the surface, but  it  cannot  enter
*     through  it.  For  those surfaces which have the point in their
*     negative region, we  determine  if  the  track  intersects  the
*     surface,  and  what  is the distance to the intersection point.
*     Only the largest of these distances  is  a  candidate  for  the
*     distance  from  the point to the volume. It is however possible
*     that the track misses the elementary volume entirely.  This  we
*     find  out  by applying the function GNOPG8 (Inside volume test)
*     to the coordinates of the intersection point. GNOPG6 is  called
*     with  two parameters: a logical variable FLAG, which is TRUE if
*     the track  intersects  the  volume,  and  DIST,  which  is  the
*     distance if FLAG is TRUE.
*
*          The  coordinates of  the point P and the direction cosines
*     of the  track  T  are  stored  in  the  common  block  GCQ2  by
*     subroutine  GNOPG1. The parameter array P in the call to GNOPG1
*     contains in its first two members the lower  phi-limit  of  the
*     PGON  and  the range in phi. Both angles are in degrees. GNOPG1
*     convertes from degrees to radians and stores the phi-limits  of
*     the  first  sector  of  each  section  in the common block GCQ3
*     together with the number of sectors per section. The number  of
*     sectors  per  section  is  contained in the third member of the
*     parameter array P. The other members of P  have  the  following
*     meaning:  From  P(5)  onwards,  there are groups of three. Each
*     group describes a section boundary. The  first  member  is  the
*     Z-coordinate  of the boundary. The second and the third are the
*     distances from the Z-axis to the inner and outer edges at  that
*     boundary.  If  there is no inner edge, the sector is limited by
*     the Z-axis. In this case the second members of  the  group  are
*     zero.  Groups may be shared by adjacent sections. Otherwise the
*     Z-coordinates of two consecutive  groups  are  the  same.  P(4)
*     contains the number of groups.
*
*          GNOPG1  calls  GNOPG2  with  8 parameters. The first 6 are
*     input parameters, the first  3  refer  to  the  "left"  section
*     boundary,  the next 3 to the "right" section boundary. The last
*     two parameters are output. Logical variable  FLAG  is  TRUE  if
*     the  track  intersects  the  section.  In this case DIST is the
*     distance.
*
*          GNOPG2 calls GNOPG3 with four parameters. The first 2  are
*     input  parameters,  namely  the  phi-limits  of the sector. The
*     last two parameters again are  output:  FLAG  is  TRUE  if  the
*     track   intersects  the  sector.  In  this  case  DIST  is  the
*     distance. The other variables required by GNOPG3 are  the  same
*     for  all  sectors  of the same section and are stored by GNOPG2
*     in the common block GCQ4. GNOPG2  also  stores  in  the  common
*     block GCQ5 the number of boundary surfaces of each sector.
*
*          The  surfaces  orthogonal  to  the Z-axis are the same for
*     all sectors of a section. The surface parameters of  these  two
*     sections  are  stored  by  calls  to  GNOPG4  from  GNOPG2. The
*     surface parameters of the other  three  or  four  surfaces  are
*     stored from GNOPG3.
*
*          GNOPG3  sets  FLAG  TRUE,  if  the  track T intersects the
*     corresponding sector. GNOPG2 finds  the  shortest  distance  to
*     all  intersected  sectors,  and  set  FLAG TRUE, if the track T
*     intersects  the  corresponding  section.   GNOPG1   finds   the
*     shortest  distance  to  all intersected sections. If no section
*     intersects, the track FLAG is set FALSE, and 1.E10 is  returned
*     as SNXT.
*
***** Subroutine GNOPG1 *************************** 04-DEC-1988 *****
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (F=0.01745329251994330D0)
+SELF, IF=SINGLE.
      PARAMETER (F=0.01745329251994330)
+SELF.
      REAL X(6),P(49),SNXT
      LOGICAL FLAG,FLAG1
      DIMENSION XS(6), YS(6), ZS(6), XN(6), YN(6), ZN(6)
      LOGICAL FLAG1X, GNOP1X, GNOP2X, GNOP4X
      PARAMETER (ONE=1,HALF=ONE/2)
      XP=X(1)
      YP=X(2)
      ZP=X(3)
      XD=X(4)
      YD=X(5)
      ZD=X(6)
      NT=P(3)+.5
      P1=F*P(1)
      P2=F*P(2)/NT
      INDEX=5
      MINDEX=3.*P(4)+1.5
      FLAG=.FALSE.
      DIST=1.E10
   10 Z1=P(INDEX)
      D1N=P(INDEX+1)
      D1X=P(INDEX+2)
      Z2=P(INDEX+3)
      D2N=P(INDEX+4)
      D2X=P(INDEX+5)
C*****  Code Expanded From Routine:  GNOPG2
C*****  Code Expanded From Routine:  GNOPG4
      XS(1) = 0.
      YS(1) = 0.
      ZS(1) = Z1
      XN(1) = 0.
      YN(1) = 0.
      ZN(1) = 1.
C*****  End of Code Expanded From Routine:  GNOPG4
C*****  Code Expanded From Routine:  GNOPG4
      XS(2) = 0.
      YS(2) = 0.
      ZS(2) = Z2
      XN(2) = 0.
      YN(2) = 0.
      ZN(2) = -1.
C*****  End of Code Expanded From Routine:  GNOPG4
      P3 = P1
      P4 = P1 + P2
      Z3 = HALF*(Z1 + Z2)
      D3X = HALF*(D1X + D2X)
      TH1 = ATAN((D2X - D1X)/(Z2 - Z1))
      COSTH1 = COS(TH1)
      SINTH1 = SIN(TH1)
      D3N = HALF*(D1N + D2N)
      ISMAX = 5
      IF (D3N .NE. 0.) THEN
         ISMAX = 6
         TH2 = ATAN((D2N - D1N)/(Z2 - Z1))
         COSTH2 = COS(TH2)
         SINTH2 = SIN(TH2)
      ENDIF
      FLAG1 = .FALSE.
      DIST1 = 1.E10
      DO 60  I = 1, NT
C*****  Code Expanded From Routine:  GNOPG3
C*****  Code Expanded From Routine:  GNOPG4
         XS(3) = 0.
         YS(3) = 0.
         ZS(3) = Z3
         XN(3) = -SIN(P3)
         YN(3) = COS(P3)
         ZN(3) = 0.
C*****  End of Code Expanded From Routine:  GNOPG4
C*****  Code Expanded From Routine:  GNOPG4
         XS(4) = 0.
         YS(4) = 0.
         ZS(4) = Z3
         XN(4) = SIN(P4)
         YN(4) = -COS(P4)
         ZN(4) = 0.
C*****  End of Code Expanded From Routine:  GNOPG4
         P1X = HALF*(P3 + P4)
         COSP = COS(P1X)
         SINP = SIN(P1X)
C*****  Code Expanded From Routine:  GNOPG4
         XS(5) = D3X*COSP
         YS(5) = D3X*SINP
         ZS(5) = Z3
         XN(5) = -COSP*COSTH1
         YN(5) = -SINP*COSTH1
         ZN(5) = SINTH1
C*****  End of Code Expanded From Routine:  GNOPG4
         IF (D3N .NE. 0.) THEN
C*****  Code Expanded From Routine:  GNOPG4
            XS(6) = D3N*COSP
            YS(6) = D3N*SINP
            ZS(6) = Z3
            XN(6) = COSP*COSTH2
            YN(6) = SINP*COSTH2
            ZN(6) = -SINTH2
C*****  End of Code Expanded From Routine:  GNOPG4
         ENDIF
C*****  Code Expanded From Routine:  GNOPG6
         FLAG1X = .FALSE.
         DIST2X = 0.
         DO 20  IS = 1, ISMAX
C*****  Code Expanded From Routine:  GNOPG9
*     TRUE if (XP,YP,ZP) in positive region of surface I
            GNOP1X = 0. .LE. (XP-XS(IS))*XN(IS)+(YP-YS(IS))*YN(IS)+(ZP-
     +         ZS(IS))*ZN(IS)
C*****  End of Code Expanded From Routine:  GNOPG9
C*****  Code Expanded From Routine:  GNOPG7
            IF (.NOT.GNOP1X) THEN
               SPPMSN = (XP - XS(IS))*XN(IS) + (YP - YS(IS))*YN(IS) + (
     +            ZP - ZS(IS))*ZN(IS)
               SPDN = XD*XN(IS) + YD*YN(IS) + ZD*ZN(IS)
               IF (SPDN .EQ. 0.) THEN
                  DIST1X = -.000001
               ELSE
                  DIST1X = -SPPMSN/SPDN
               ENDIF
C*****  End of Code Expanded From Routine:  GNOPG7
               IF ((-1.E-5) .LE. DIST1X) THEN
                  FLAG1X = .TRUE.
                  DIST2X = MAX(DIST1X,DIST2X)
               ENDIF
            ENDIF
   20    CONTINUE
         IF (.NOT.FLAG1X) GO TO 50
         T = DIST2X + .001
         XQ = XP + T*XD
         YQ = YP + T*YD
         ZQ = ZP + T*ZD
C*****  Code Expanded From Routine:  GNOPG8
*     TRUE if (XP,YP,ZP) in volume
         GNOP2X = .FALSE.
         DO 30  IS1X = 1, ISMAX
C*****  Code Expanded From Routine:  GNOPG9
*     TRUE if (XP,YP,ZP) in positive region of surface I
            GNOP4X = 0. .LE. (XQ-XS(IS1X))*XN(IS1X)+(YQ-YS(IS1X))*YN(
     +         IS1X)+(ZQ-ZS(IS1X))*ZN(IS1X)
            IF (.NOT.GNOP4X) GO TO 40
C*****  End of Code Expanded From Routine:  GNOPG9
   30    CONTINUE
         GNOP2X = .TRUE.
   40    CONTINUE
         FLAG1X = GNOP2X
C*****  End of Code Expanded From Routine:  GNOPG8
   50    CONTINUE
C*****  End of Code Expanded From Routine:  GNOPG3
         IF (FLAG1X) THEN
            FLAG1 = .TRUE.
            DIST1 = MIN(DIST2X,DIST1)
         ENDIF
         P3 = P4
         P4 = P4 + P2
   60 CONTINUE
C*****  End of Code Expanded From Routine:  GNOPG2
      IF (FLAG1) THEN
         FLAG=.TRUE.
         IF (DIST1.LT.DIST) DIST=DIST1
      END IF
      INDEX=INDEX+3
      IF (MINDEX.LT.INDEX) THEN
         IF(FLAG) THEN
            SNXT=DIST
         ELSE
            SNXT=1.E10
         ENDIF
      ELSE
         IF (P(INDEX+3).EQ.Z2) INDEX=INDEX+3
         GO TO 10
      ENDIF
      END
+DECK,  GNOPGO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOPGO (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'PGON' VOLUME,  *
C.    *       FROM OUTSIDE POINT X(1-3) ALONG DIRECTION X(4-6)         *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *                       from point X(1-3) along direction X(4-6) *
C.    *       SAFE  (output) : shortest distance from point X(1-3) to  *
C.    *                       any boundary (possibly overestimated)    *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Authors   R.Nierhaus, F.Bruyant   *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      REAL X(*),PAR(*)
C
C.    ------------------------------------------------------------------
*
      SNXT = BIG
      IF (IACT.LT.3) THEN
*
* ***   Compute SAFE
*
         R2 = X(1)**2 +X(2)**2
         R  = SQRT(R2)
         DPHI2  = 0.5*PAR(2)*DEGRAD/PAR(3)
         CDPHI2 = COS(DPHI2)
         NZ = PAR(4)
*
         IF (X(3).LT.PAR(5)) THEN
            SAFEZ = PAR(5) -X(3)
         ELSE IF (X(3).GT.PAR(3*NZ+2)) THEN
            SAFEZ = X(3) -PAR(3*NZ+2)
         ELSE
            SAFEZ = BIG
         ENDIF
*
         RMIN = BIG
         RMAX = 0.
         DO 10 I = 6,3*NZ+3,3
            IF (PAR(I).LT.RMIN) RMIN = PAR(I)
            IF (PAR(I+1).GT.RMAX) RMAX = PAR(I+1)
   10    CONTINUE
         RMAX = RMAX/CDPHI2
*
*  **   Treat outside Z-limits first
*
         IF (SAFEZ.LT.0.9*BIG) THEN
            IF (R.LT.RMIN) THEN
               SAFE = MAX(SAFEZ,RMIN-R)
            ELSE IF (R.GT.RMAX) THEN
               SAFE = MAX(SAFEZ,R-RMAX)
            ELSE
               SAFE = SAFEZ
            ENDIF
            GO TO 50
         ELSE
*
*  **   Now one is inside the Z-limits
*
            DO 20 I = 8,3*NZ+2,3
              IF (X(3).GT.PAR(I)) GO TO 20
              IF (PAR(I+1).EQ.PAR(I-2)) THEN
                 IF (R.LT.PAR(I+1)) THEN
                    SAFE = PAR(I+1) -R
                    IF (NZ.EQ.2) GO TO 50
                    XT3  = X(3) -0.5*(PAR(I)+PAR(I-3))
                    DZ   = 0.5*(PAR(I)-PAR(I-3))
                    GO TO 18
                 ENDIF
              ELSE IF (PAR(I+2).EQ.PAR(I-1)) THEN
                 IF (R.GT.PAR(I+2)) THEN
                    SAFE = R -PAR(I+2)
                    IF (NZ.EQ.2) GO TO 50
                    XT3  = X(3) -0.5*(PAR(I)+PAR(I-3))
                    DZ   = 0.5*(PAR(I)-PAR(I-3))
                    GO TO 18
                 ENDIF
              ENDIF
*
              XT3  = X(3) -0.5*(PAR(I)+PAR(I-3))
              DZ   = 0.5*(PAR(I)-PAR(I-3))
              FACT = 0.5*(PAR(I+1)-PAR(I-2))/DZ
              RAD1 = PAR(I-2) +FACT*(DZ+XT3)
              IF (R.LT.RAD1) THEN
                 SAFE = (RAD1-R)/SQRT(1.+FACT**2)
              ELSE
                 FACT = 0.5*(PAR(I+2)-PAR(I-1))/DZ
                 RAD2 = PAR(I-1) +FACT*(DZ+XT3)
                 RAD2=RAD2/CDPHI2
                 IF (R.GT.RAD2) THEN
                    SAFE = (R-RAD2)/SQRT(1.+FACT**2)
                 ELSE
                    SAFE = 0.
                 ENDIF
              ENDIF
              IF (NZ.EQ.2) GO TO 19
*
   18         SAFEZ = DZ-ABS(XT3)
              SAFE  = MIN(SAFEZ,SAFE)
*
   19         IF (R.LT.RMIN) THEN
                 SAFE = MAX(RMIN-R,SAFE)
              ELSE IF (R.GT.RMAX) THEN
                 SAFE = MAX(R-RMAX,SAFE)
              ENDIF
              GO TO 50
   20       CONTINUE
         ENDIF
*
*  **   Case of a Phi segmented polygon
*               (not coded yet)
   50    CONTINUE
*
         IF (IACT .EQ. 0) GO TO 999
         IF (IACT .EQ. 1) THEN
            IF (SNEXT .LT. SAFE) GO TO 999
         ENDIF
      ENDIF
*
      CALL GNOPG1 (X, PAR, SNXT)
*
  999 END
+DECK,  GNOSPH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOSPH (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'SPHE' VOLUME,  *
C.    *       FROM OUTSIDE POINT X(1-3) ALONG DIRECTION X(4-6)SPHERE   *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson,  P.Weidhaas  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+SELF.
+CDE, GCONSP.
      REAL X(6),PAR(6),SNEXT,SNXT,SAFE
      DIMENSION IS(4),SS(4)
C.
C.    ----------------------------------------------------------------
C.

      SNXT = BIG
      R2  = X(1)*X(1) + X(2)*X(2) + X(3)*X(3)
      R   = SQRT (R2)

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

        RIN  = PAR(1)
        ROUT = PAR(2)
        IF (R .LT. RIN) THEN
          SAFE  = RIN - R
        ELSEIF (R .GT. ROUT) THEN
          SAFE  = R - ROUT
        ENDIF


        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------


      BA=X(1)*X(4)+X(2)*X(5)+X(3)*X(6)
      IF(R2.GE.PAR(2)*PAR(2).AND.BA.GE.0.0) GO TO 999
C
      CA=R2-PAR(2)*PAR(2)
      DISC=BA*BA-CA
      IF(DISC.LE.0.0) GO TO 999
C
      RDISC=SQRT(DISC)
      SMAX=-BA+RDISC
      SMIN=-BA-RDISC
C
C                   NOW DO RMIN
C
      CA=R2-PAR(1)*PAR(1)
      DISC=BA*BA-CA
C
      SMIN1=SMIN
      SMAX1=-1.0
      SMIN2=SMIN
      SMAX2=SMAX
C
      IF(DISC.LE.0.0) GO TO 30
      RDISC=SQRT(DISC)
      SMIN2=-BA+RDISC
      SMAX1=-BA-RDISC
C
   30 CONTINUE
C
C                   NOW DO THE PHI STUFF.
C
      IP2=0
      SMNP1=0.0
      SMXP1=SMAX2
C
      IF(PAR(6)-PAR(5).GE.360.0) GO TO  110
C
      DPSGN=X(1)*X(5)-X(2)*X(4)
      PHL=PAR(5)/RADDEG
      PHH=PAR(6)/RADDEG
      ISMIN=0
      ISMAX=0
C
      TSGN=SIN(PHL)
      TCSG=COS(PHL)
      DEN=X(4)*TSGN-X(5)*TCSG
      IF(DEN.EQ.0.0) GO TO 40
      SNL=(X(2)*TCSG-X(1)*TSGN)/DEN
      IF(ABS(TSGN).GT.1.E-6.AND.(X(2)+SNL*X(5))*TSGN.LT.0.) GO TO 40
      IF(ABS(TCSG).GT.1.E-6.AND.(X(1)+SNL*X(4))*TCSG.LT.0.) GO TO 40
C
      ISMIN=1
      SMIN=SNL
      IF(DPSGN.GT.0.0) GO TO 40
      ISMIN=0
      ISMAX=1
      SMAX=SNL
C
   40 CONTINUE
C
      TSGN=SIN(PHH)
      TCSG=COS(PHH)
      DEN=X(4)*TSGN-X(5)*TCSG
      IF(DEN.EQ.0.0) GO TO 60
      SNH=(X(2)*TCSG-X(1)*TSGN)/DEN
      IF(ABS(TSGN).GT.1.E-6.AND.(X(2)+SNH*X(5))*TSGN.LT.0.) GO TO 60
      IF(ABS(TCSG).GT.1.E-6.AND.(X(1)+SNH*X(4))*TCSG.LT.0.) GO TO 60
      IF(DPSGN.LT.0.0) GO TO 50
      ISMAX=1
      SMAX=SNH
      GO TO 60
C
   50 CONTINUE
      ISMIN=1
      SMIN=SNH
C
   60 CONTINUE
C
      IF(ISMIN.EQ.0.OR.ISMAX.EQ.0) GO TO 80
      IF(SMAX.LT.0.0.AND.SMAX.GT.SMIN) GO TO 999
      IF(SMIN.LT.0.0) SMIN=0.0
      IF(SMAX.LT.0.0) GO TO  100
      IF(SMAX.GT.SMIN) GO TO 70
C
C                         SMAX +VE AND LESS THAN SMIN - 2 ALLOWED
C                         REGIONS.
C
      IP2=1
      SMXP1=SMAX
      SMNP2=SMIN
      SMXP2=SMAX2
      GO TO  110
C
   70 CONTINUE
C
C                         SMIN +VE AND SMAX GT SMIN: NORMAL SINGLE
C                         REGION
C
      SMNP1=SMIN
      SMXP1=SMAX
      GO TO  110
C
   80 CONTINUE
      IF(ISMIN.EQ.1) GO TO  100
      IF(ISMAX.EQ.0) GO TO  90
C
C                    SMAX BUT NO SMIN
C
      SMXP1=SMAX
      GO TO  110
C
   90 CONTINUE
C
C                   NO SMIN OR SMAX: ALWAYS IN OR ALWAYS OUT.
C
      DPH=PAR(5)-PAR(4)
      IF(DPH.LT.180.0.AND.DPH.GT.0.0) GO TO 999
      IF(DPH.LT.-180.0) GO TO 999
      GO TO  110
C
  100 CONTINUE
C
C                  SMIN BUT NO SMAX.
C
      SMNP1=SMIN
C
  110 CONTINUE
C
C                  NOW DO THETA.
C
      IT2=0
      SMNT1=0.0
      SMXT1=SMAX2
      IF(PAR(4)-PAR(3).GE.180.0) GO TO 360
C
      TH=PAR(3)
      IT=1
      ITLN=0
      ITLX=0
      ITHN=0
      ITHX=0
C
  120 CONTINUE
C
      IF(TH.NE.90.0) GO TO 130
      IF(X(6).EQ.0.0) GO TO 220
C
      ST=-X(3)/X(6)
      STST=-X(6)
      GO TO 180
C
  130 CONTINUE
C
      TT=TAN(TH/RADDEG)
      TT2=TT*TT
C
      A=X(4)*X(4)+X(5)*X(5)-TT2*X(6)*X(6)
      B=X(1)*X(4)+X(2)*X(5)-TT2*X(3)*X(6)
      C=X(1)*X(1)+X(2)*X(2)-TT2*X(3)*X(3)
C
      IF(A.NE.0.0) GO TO 140
      IF(B.EQ.0.0) GO TO 220
C
      ST=-C*0.5/B
C
      Z=X(3)+ST*X(6)
      IF(Z*TT.LT.0.0) GO TO 220
C
      STST=(B+ST*A)/Z
      ITRY=2
C
      GO TO 180
  140 CONTINUE
C
      BA=B/A
      CA=C/A
      DISC=BA*BA-CA
      IF(DISC.LT.0.0) GO TO 220
C
      RDISC=0.0
      IF(DISC.GT.0.0) RDISC=SQRT(DISC)
      ITRY=1
      ST=-BA-RDISC
C
  150 CONTINUE
C
      IF(ST.LT.0.0) GO TO 160
      Z=X(3)+ST*X(6)
      IF(Z.EQ.0.0.AND.ABS(A).LT.0.0) GO TO 170
      IF(RDISC.EQ.0.0) GO TO 160
      IF(Z*TT.LT.0.0) GO TO 160
C
      STST=(B+ST*A)/Z
      GO TO 180
C
  160 CONTINUE
C
      IF(ITRY.EQ.2) GO TO 220
      ST=-BA+RDISC
      ITRY=2
      GO TO 150
C
  170 CONTINUE
      STST=-X(6)
  180 CONTINUE
C
      IF(IT.NE.1) GO TO 200
      IF(STST.GT.0.0) GO TO 190
      ITLX=1
      SMXTL=ST
      GO TO 160
C
  190 CONTINUE
      ITLN=1
      SMNTL=ST
      GO TO 160
C
  200 CONTINUE
      IF(STST.GT.0.0) GO TO 210
      ITHN=1
      SMNTH=ST
      GO TO 160
C
  210 CONTINUE
      ITHX=1
      SMXTH=ST
      GO TO 160
C
  220 CONTINUE
      IF(IT.EQ.2) GO TO 230
      IT=2
      TH=PAR(4)
      GO TO 120
C
  230 CONTINUE
C
C              ORDER THE VARIOUS BOUNDARIES.
C
      ICOUNT=0
      IF(ITLN.EQ.0.OR.SMNTL.LE.0.0) GO TO 240
      IS(1)=1
      SS(1)=SMNTL
      ICOUNT=1
C
  240 CONTINUE
      IF(ITLX.EQ.0.OR.SMXTL.LE.0.0) GO TO 260
      IPL=ICOUNT+1
      IF(ICOUNT.EQ.0.OR.SMXTL.GT.SS(1)) GO TO 250
      IS(2)=IS(1)
      SS(2)=SS(1)
      IPL=1
  250 CONTINUE
      ICOUNT=ICOUNT+1
      IS(IPL)=2
      SS(IPL)=SMXTL
C
  260 CONTINUE
      IST=3
      IF(ITHN.EQ.0.OR.SMNTH.LE.0.0) GO TO 320
      STEST=SMNTH
C
  270 CONTINUE
      IPL=ICOUNT+1
      IF(ICOUNT.EQ.0) GO TO 310
      DO 280 IC=1,ICOUNT
      IC1=ICOUNT-IC+1
      IF(STEST.GT.SS(IC1)) GO TO 290
      IPL=IPL-1
  280 CONTINUE
C
  290 CONTINUE
      IF(IPL.EQ.ICOUNT+1) GO TO 310
      IM=ICOUNT+1-IPL
      DO 300 I=1,IM
      I1=ICOUNT-I+1
      I2=I1+1
      IS(I2)=IS(I1)
      SS(I2)=SS(I1)
  300 CONTINUE
C
  310 CONTINUE
      ICOUNT=ICOUNT+1
      IS(IPL)=IST
      SS(IPL)=STEST
C
  320 CONTINUE
      IF(IST.EQ.4) GO TO 330
      IF(ITHX.EQ.0.OR.SMXTH.LE.0.0) GO TO 330
      IST=4
      STEST=SMXTH
      GO TO 270
C
  330 CONTINUE
C
C               CHECK WHETHER 1ST IS MAX OR MIN.
C
      IF(ICOUNT.EQ.0) GO TO 350
      IF(IS(1).EQ.2.OR.IS(1).EQ.4) GO TO 340
C
C               START WITH MIN.
C
      SMNT1=SS(1)
      IF(ICOUNT.GE.2) SMXT1=SS(2)
      IF(ICOUNT.LE.2) GO TO 360
      IT2=1
      SMNT2=SS(3)
      SMXT2=SMAX2
      IF(ICOUNT.GE.4) SMXT2=SS(4)
      GO TO 360
C
  340 CONTINUE
C
C              START WITH MAX SO 1ST MIN IS 0.0
C
      SMNT1=0.0
      SMXT1=SS(1)
      IF(ICOUNT.LE.1) GO TO 360
      IT2=1
      SMNT2=SS(2)
      SMXT2=SMAX2
      IF(ICOUNT.GE.3) SMXT2=SS(3)
      GO TO 360
C
  350 CONTINUE
C
C              NO INTERSECTIONS ALWAYS IN OR ALWAYS OUT.
C
      R=X(1)*X(1)+X(2)*X(2)
      IF(R.GT.0.0) R=SQRT(R)
      TH=90.0
      IF(X(3).NE.0.0) TH=ATAN(R/X(3))*RADDEG
      IF(TH.LT.0.0) TH=180.0+TH
      IF(TH.LT.PAR(3).OR.TH.GT.PAR(4)) GO TO 999
C
  360 CONTINUE
C
C              NOW FIND SMALLEST S ALOWED BY ALL.
C
      IF(SMAX1.LE.SMIN1) GO TO 370
      SMAXR=SMAX1
      SMINR=SMIN1
      IRT=1
      GO TO 380
C
  370 CONTINUE
      SMAXR=SMAX2
      SMINR=SMIN2
      IRT=2
C
  380 CONTINUE
      IF(SMNP1.GT.SMAXR) GO TO 430
      IF(SMXP1.LT.SMINR) GO TO 390
      SMIN=SMINR
      SMAX=SMAXR
      IF(SMNP1.GT.SMIN) SMIN=SMNP1
      IF(SMXP1.LT.SMAX) SMAX=SMXP1
      IPT=1
      GO TO 400
C
  390 CONTINUE
      IF(IP2.EQ.0) GO TO 430
      IF(SMNP2.GT.SMAXR) GO TO 430
      IF(SMXP2.LT.SMINR) GO TO 430
      SMIN=SMINR
      SMAX=SMAXR
      IF(SMNP2.GT.SMIN) SMIN=SMNP2
      IF(SMXP2.LT.SMAX) SMAX=SMXP2
      IPT=2
C
  400 CONTINUE
C
      IF(SMNT1.GT.SMAX) GO TO 420
      IF(SMXT1.LT.SMIN) GO TO 410
      IF(SMNT1.GT.SMIN) SMIN=SMNT1
      GO TO 440
C
  410 CONTINUE
      IF(IT2.EQ.0) GO TO 420
      IF(SMNT2.GT.SMAX) GO TO 420
      IF(SMXT2.LT.SMIN) GO TO 420
      IF(SMNT2.GT.SMIN) SMIN=SMNT2
      GO TO 440
C
  420 CONTINUE
      IF(IPT.EQ.1) GO TO 390
  430 CONTINUE
      IF(IRT.EQ.1) GO TO 370
      GO TO 999
C
  440 CONTINUE
      IF(SMIN.LE.0.)GO TO 999
      SNXT = SMIN

  999 CONTINUE
      END
+DECK,  GNOTR1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOTR1(P)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routine to extend  the  user supplied parameters P  to      *
C.    *    internal parameters   for the  trapezoidal shape TRAP       *
C.    *                                                                *
C.    *         Called by : GSPOSP, GSVOLU , GGDPAR                    *
C.    *         Author  R.Nierhaus  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
*     GNOTR1  computes the coordinates for the 8 vertices
*     X(8), Y(8) and Z(8).
*     Then GNOTR2 is called for each of the six boundary surfaces.
*
      DIMENSION P(35),X(8),Y(8),Z(8)
*
      HZ  =P(1)
      SX  =P(2)
      SY  =P(3)
      HY1 =P(4)
      HX11=P(5)
      HX12=P(6)
      SX1 =P(7)
      HY2 =P(8)
      HX21=P(9)
      HX22=P(10)
      SX2 =P(11)
      IF (HY1.LT.1.E-6) HY1=1.E-6
      IF (HX11.LT.1.E-6) HX11=1.E-6
      IF (HX12.LT.1.E-6) HX12=1.E-6
      IF (HY2.LT.1.E-6) HY2=1.E-6
      IF (HX21.LT.1.E-6) HX21=1.E-6
      IF (HX22.LT.1.E-6) HX22=1.E-6
      X(1)=-HZ*SX-HY1*SX1-HX11
      X(2)=-HZ*SX-HY1*SX1+HX11
      X(3)=-HZ*SX+HY1*SX1-HX12
      X(4)=-HZ*SX+HY1*SX1+HX12
      X(5)=+HZ*SX-HY2*SX2-HX21
      X(6)=+HZ*SX-HY2*SX2+HX21
      X(7)=+HZ*SX+HY2*SX2-HX22
      X(8)=+HZ*SX+HY2*SX2+HX22
      Y(1)=-HZ*SY-HY1
      Y(2)=-HZ*SY-HY1
      Y(3)=-HZ*SY+HY1
      Y(4)=-HZ*SY+HY1
      Y(5)=+HZ*SY-HY2
      Y(6)=+HZ*SY-HY2
      Y(7)=+HZ*SY+HY2
      Y(8)=+HZ*SY+HY2
      Z(1)=-HZ
      Z(2)=-HZ
      Z(3)=-HZ
      Z(4)=-HZ
      Z(5)=+HZ
      Z(6)=+HZ
      Z(7)=+HZ
      Z(8)=+HZ
      CALL GNOTR2(X,Y,Z,1,2,4,3,P(12))
      CALL GNOTR2(X,Y,Z,5,7,8,6,P(16))
      CALL GNOTR2(X,Y,Z,1,5,6,2,P(20))
      CALL GNOTR2(X,Y,Z,3,4,8,7,P(24))
      CALL GNOTR2(X,Y,Z,1,3,7,5,P(28))
      CALL GNOTR2(X,Y,Z,2,6,8,4,P(32))
*
      END
+DECK,  GNOTR2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOTR2(X,Y,Z,N1,N2,N3,N4,ABCD)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     GNOTR2 computes the coefficients of the implicit           *
C.    *     normalized plane equation.                                 *
C.    *     These are called ABCD(1),ABCD(2),ABCD(3) and ABCD(4) in    *
C.    *     GNOTR2. They are stored in the parameter array             *
C.    *     respectively in P(12),P(13),P(14),P(15) for the first      *
C.    *     surface, P(16),P(17),P(18),P(19) for the second surface    *
C.    *     and so on. The face is formed by the half-edges            *
C.    *     N1-N2,N2-N3,N3-N4,N4-N1, where N1,N2,N3,N4 are the         *
C.    *     indices of the corresponding vertices.                     *
C.    *         Called by : GNOTR1                                     *
C.    *         Author  R.Nierhaus  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(8),Y(8),Z(8),ABCD(4)
*
      CALL GNOTR9(X,Y,Z,N1,N2,N3,N4)
*
      A=((Y(N2)-Y(N1))*(Z(N1)+Z(N2))+(Y(N3)-Y(N2))*(Z(N2)+Z(N3))
     +  +(Y(N4)-Y(N3))*(Z(N3)+Z(N4))+(Y(N1)-Y(N4))*(Z(N4)+Z(N1)))
      B=((Z(N2)-Z(N1))*(X(N1)+X(N2))+(Z(N3)-Z(N2))*(X(N2)+X(N3))
     +  +(Z(N4)-Z(N3))*(X(N3)+X(N4))+(Z(N1)-Z(N4))*(X(N4)+X(N1)))
      C=((X(N2)-X(N1))*(Y(N1)+Y(N2))+(X(N3)-X(N2))*(Y(N2)+Y(N3))
     +  +(X(N4)-X(N3))*(Y(N3)+Y(N4))+(X(N1)-X(N4))*(Y(N4)+Y(N1)))
      S=SQRT(A**2+B**2+C**2)
      ABCD(1)=A/S
      ABCD(2)=B/S
      ABCD(3)=C/S
      ABCD(4)=-(ABCD(1)*X(N1)+ABCD(2)*Y(N1)+ABCD(3)*Z(N1))
*
      END
+DECK,  GNOTR9, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOTR9(X,Y,Z,N1,N2,N3,N4)
C.    ******************************************************************
C.    *                                                                *
C.    *     GNOTR9 checks coplanarity of the face described by the     *
C.    *     indices N1,N2,N3,N4 into the vertex array X,Y,Z.           *
C.    *     This check is perfomed since shape TRAP is described by    *
C.    *     11 values in the parameter array of which only 9 are       *
C.    *     independant.
C.    *         Called by : GNOTR2
C.    *         Author  R.Nierhaus  *********                          *
C.    *                                                                *
C.    ******************************************************************
*
+CDE, GCUNIT.
*
      DIMENSION X(8),Y(8),Z(8)
*
      A=-((Y(N2)-Y(N1))*(Z(N3)-Z(N1))-(Y(N3)-Y(N1))*(Z(N2)-Z(N1)))
      B=-((Z(N2)-Z(N1))*(X(N3)-X(N1))-(Z(N3)-Z(N1))*(X(N2)-X(N1)))
      C=-((X(N2)-X(N1))*(Y(N3)-Y(N1))-(X(N3)-X(N1))*(Y(N2)-Y(N1)))
      V=(X(N4)-X(N1))*A+(Y(N4)-Y(N1))*B+(Z(N4)-Z(N1))*C
      IF (ABS(V)/SQRT(A**2+B**2+C**2).GT.1.E-3) THEN
         WRITE(CHMAIL,1001)
         CALL GMAIL(0,0)
 1001    FORMAT (' GNOTR9 ...TRAP shape :  surface not coplanar')
      END IF
*
      END

+DECK,  GNOTRA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOTRA (X, PAR, IACT, IFLAG, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      COMPUTE DISTANCE UP TO INTERSECTION WITH 'TRD1' OR 'TRD2' *
C.    *       VOLUME, FROM OUTSIDE POINT X(1-3) ALONG DIRECTION X(4-6) *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       IFLAG (input)  : = 1 for TRD1, 2 for TRD2                *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson,  P.Weidhaas  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6),PAR(5)
C.
C.    ----------------------------------------------------------------
C.

      SNXT = BIG
      IF (IFLAG .EQ. 1) THEN
        FACTX  = (PAR(2) - PAR(1)) / (2.0*PAR(4))
      ELSEIF (IFLAG .EQ. 2) THEN
        FACTX  = (PAR(2) - PAR(1)) / (2.0*PAR(5))
        FACTY  = (PAR(4) - PAR(3)) / (2.0*PAR(5))
      ENDIF

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

        IF (IFLAG .EQ. 1) THEN
C*******************************************************
C
C......  Shape "TRD1":   only x varies with z.
C
C*******************************************************

          SAF2  = MAX (ABS(X(2)) - PAR(3),  0.0)
          SAF3  = MAX (ABS(X(3)) - PAR(4),  0.0)
C
C......  Distance along x-direction to slanted wall.
C
          DISTX = PAR(1) + FACTX * (PAR(4) + X(3))
          IF (ABS(X(1)) .GT. DISTX) THEN
            SAF1  = (ABS(X(1)) - DISTX) / SQRT(1.0 + FACTX*FACTX)
          ELSE
            SAF1  = 0.0
          ENDIF


        ELSE
C*******************************************************
C
C......  Shape "TRD2":  both x and y vary with z.
C
C*******************************************************

          SAF3  = MAX (ABS(X(3)) - PAR(5),  0.0)

C
C......  Distance along x-direction to slanted wall.
C
          DISTX = PAR(1) + FACTX * (PAR(5) + X(3))
          IF (ABS(X(1)) .GT. DISTX) THEN
            SAF1  = (ABS(X(1)) - DISTX) / SQRT(1.0 + FACTX*FACTX)
          ELSE
            SAF1  = 0.0
          ENDIF
C
C......  Distance along y-direction to slanted wall.
C
          DISTY = PAR(3) + FACTY * (PAR(5) + X(3))
          IF (ABS(X(2)) .GT. DISTY) THEN
            SAF2  = (ABS(X(2)) - DISTY) / SQRT(1.0 + FACTY*FACTY)
          ELSE
            SAF2  = 0.0
          ENDIF

        ENDIF

        SAFE  = MAX (SAF1, SAF2, SAF3)

        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------


C
C                 Only x varies with z.
C
      IF(IFLAG.NE.1) GO TO 50
      S3=PAR(4)
      FACTX = (PAR(2) - PAR(1)) / (2.0*S3)
      S1  = 0.5 * (PAR(1) + PAR(2))  +  FACTX * X(3)
      DS11=X(4) - FACTX * X(6)
      DS12=X(4) + FACTX * X(6)
      S2=PAR(3)
      DS21=X(5)
      DS22=X(5)
      GO TO 60
C
C            Both x and y widths vary with z.
C
   50 CONTINUE
      S3=PAR(5)
      FACTX = (PAR(2) - PAR(1)) / (2.0*S3)
      FACTY = (PAR(4) - PAR(3)) / (2.0*S3)
      S1 = 0.5 * (PAR(1) + PAR(2))  +  FACTX * X(3)
      DS11=X(4) - FACTX * X(6)
      DS12=X(4) + FACTX * X(6)
      S2 = 0.5 * (PAR(3) + PAR(4))  +  FACTY * X(3)
      DS21=X(5) - FACTY * X(6)
      DS22=X(5) + FACTY * X(6)

C
C            FIRST DO THE Z COORDINATE.
C
   60 SMAX=9.0E+10
      SMIN=0.0
      IF(X(6).EQ.0.0.AND.S3.LT.ABS(X(3))) GO TO 999
      IF(X(6).EQ.0.0) GO TO 70
      SMIN=(S3-X(3))/X(6)
      SMAX=(-S3-X(3))/X(6)
      IF(SMAX.GT.SMIN) GO TO 70
      SN=SMAX
      SMAX=SMIN
      SMIN=SN
C
   70 IF(SMIN.LT.0.0) SMIN=0.0
      IF(SMAX.LT.SMIN) GO TO 999
C
C             NOW DO X COORDINATE.
C
      SS1=S1-X(1)
      SS2=-S1-X(1)
      SN1=-1.0
      SN2=SMAX
*
      IF(SS1.LT.0.0) SN1=SMAX
      IF(SS2.GT.0.0) SN2=-1.0
*
      IF(DS11.NE.0.0) SN1=SS1/DS11
      IF(DS12.NE.0.0) SN2=SS2/DS12
      IF(DS12*DS11.EQ.0.0) GO TO 90
      IF(DS12.LT.0.0.AND.DS11.LT.0.0) GO TO 110
      ST=SN2
      SN2=SN1
      SN1=ST
      IF(DS12.GT.0.0.AND.DS11.GT.0.0) GO TO 110
      IF(DS12.LT.0.0) GO TO 80
      IF(SN2.GT.SN1) SN1=SN2
      SN2=SMAX
      GO TO 110
C
   80 CONTINUE
C
      IF(SN2.GT.SN1) SN2=SN1
      SN1=0.0
      GO TO 110
C
   90 CONTINUE
C
      IF(DS12.EQ.0.0.AND.SS2.GT.0.0) GO TO 999
      IF(DS12.EQ.0.0.AND.DS11.LT.0.0) GO TO 110
      IF(DS11.EQ.0.0.AND.SS1.LT.0.0) GO TO 999
      IF(DS11.EQ.0.0.AND.DS12.LE.0.0) GO TO 110
      IF(DS11.EQ.0.0) GO TO 100
      SN2=SN1
      SN1=0.0
      GO TO 110
C
  100 CONTINUE
      SN1=SN2
      SN2=SMAX
C
  110 CONTINUE
C
      IF(SN1.GT.SMIN) SMIN=SN1
      IF(SN2.LT.SMAX) SMAX=SN2
      IF(SMAX.LE.SMIN) GO TO 999
C
C             NOW DO Y COORDINATE.
C
      SS1=S2-X(2)
      SS2=-S2-X(2)
      SN1=-1.0
      SN2=SMAX
*
      IF(SS1.LT.0.0) SN1=SMAX
      IF(SS2.GT.0.0) SN2=-1.0
*
      IF(DS21.NE.0.0) SN1=SS1/DS21
      IF(DS22.NE.0.0) SN2=SS2/DS22
      IF(DS22*DS21.EQ.0.0) GO TO 130
      IF(DS22.LT.0.0.AND.DS21.LT.0.0) GO TO 150
      ST=SN2
      SN2=SN1
      SN1=ST
      IF(DS22.GT.0.0.AND.DS21.GT.0.0) GO TO 150
      IF(DS22.LT.0.0) GO TO 120
      IF(SN2.GT.SN1) SN1=SN2
      SN2=SMAX
      GO TO 150
C
  120 CONTINUE
C
      IF(SN2.GT.SN1) SN2=SN1
      SN1=0.0
      GO TO 150
C
  130 CONTINUE
C
      IF(DS22.EQ.0.0.AND.SS2.GT.0.0) GO TO 999
      IF(DS22.EQ.0.0.AND.DS21.LT.0.0) GO TO 150
      IF(DS21.EQ.0.0.AND.SS1.LT.0.0) GO TO 999
      IF(DS21.EQ.0.0.AND.DS22.LE.0.0) GO TO 150
      IF(DS21.EQ.0.0) GO TO 140
      SN2=SN1
      SN1=0.0
      GO TO 150
C
  140 CONTINUE
      SN1=SN2
      SN2=SMAX
C
  150 CONTINUE
C
      IF(SN1.GT.SMIN) SMIN=SN1
      IF(SN2.LT.SMAX) SMAX=SN2
C
      IF(SMAX.LE.SMIN) GO TO 999
      IF(SMIN.LE.0.)GO TO 999
      SNXT = SMIN

 999  CONTINUE
      END
+DECK,  GNOTRP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOTRP(X,P,IACT,SNEXT,SNXT,SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Compute distance up to intersection with 'TRAP' volume.    *
C.    *     from outside point X(1-3) along direction X(4-6)           *
C.    *                                                                *
C.    *     P    (input) : volume parameters                           *
C.    *     IACT (input) : action flag                                 *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT.GT.SAFE      *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *     SNEXT (input)    : see IACT = 1                            *
C.    *     SNXT  (output)   : distance to volume boundary             *
C.    *     SAFE  (output)   : shortest distance to any boundary       *
C.    *                                                                *
C.    *     Scalar Distance to Volume.                                 *
C.    *     The scalar distance from a point to a hexahedron can be    *
C.    *     the distance from the point to a surface,                  *
C.    *     the distance from the point to an edge or                  *
C.    *     the distance from the point to a vertex.                   *
C.    *     Here we compute only the distances to the planes of the    *
C.    *     six surfaces and take the maximum.                         *
C.    *     Since the distances to edges or vertices can only be       *
C.    *     larger, this is a first approximation to                   *
C.    *     SAFETY, that is a value which is not larger than the       *
C.    *     distance from the point to the volume.                     *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  R.Nierhaus  *********                          *
C.    *                                                                *
C.    ******************************************************************
*
+CDE, GCONSP.
*
      DIMENSION X(6),P(35)
*
      SAFE=-BIG
      SNXT=BIG
      DO 1 I=12,32,4
         T1=P(I)*X(1)+P(I+1)*X(2)+P(I+2)*X(3)+P(I+3)
         IF (SAFE.LT.T1) SAFE=T1
    1 CONTINUE
      IF (IACT.EQ.0.OR.(IACT.EQ.1.AND.SNEXT.LE.SAFE)) RETURN
*
*     Vector Distance to Volume.
*     Volume is hexahedron.
*     (X(1),X(2),X(3)) is outside.
*     P(1),P(2) ... P(11) are the standard Geant execution time
*     parameters for a shape 4 (TRAP) volume.
*     P(12) ... P(35) contain boundary surface data.
*     P(12),P(13),P(14),P(15) are the coefficients of the normalized
*     implicit plane equation for the first boundary surface.
*     P(16),P(17),P(18),P(19) for the second boundary surface.
*     P(32),P(33),P(34),P(35) for the last (sixth) boundary surface.
*     The first three coefficients are the components of a unit
*     vector pointing away from the volume.
*     T1 is the signed orthogonal distance of the point
*     (X(1),X(2),X(3)) and a boundary plane.
*     If this distance is negative, the track cannot enter the
*     volume through the corresponding face.
*     T2 is the cosine of the angle between the plane normal and the
*     track directions (X(4),X(5),X(6)).
*     T3 is the vector distance to the corresponding surface.
*
      SNXT1=-BIG
      DO 2 I=12,32,4
         T1=P(I)*X(1)+P(I+1)*X(2)+P(I+2)*X(3)+P(I+3)
         IF (0.LT.T1) THEN
            T2=P(I)*X(4)+P(I+1)*X(5)+P(I+2)*X(6)
            T3=-.0000001
            IF (T2.NE.0.) T3=-T1/T2
            IF (0..LE.T3) THEN
               IF (SNXT1.LT.T3) SNXT1=T3
            END IF
         END IF
    2 CONTINUE
      IF (SNXT1.EQ.-BIG) RETURN
*
      T=1.00001*SNXT1+.00001
*
*     (XQ,YQ,ZQ) is the intersection point of the track with
*     a boundary surface plane.
*     P(I)*XQ+P(I+1)*YQ+P(I+2)*ZQ+P(I+3) is the signed distance of
*     the intersection point with a boundary surface plane.
*     If this distance is positive for any of the six surfaces,
*     the intersection is not with the volume.
*     A small correction is applied which moves the point slightly
*     to the interior of the volume to protect against rounding
*     errors.
*
      XQ=X(1)+T*X(4)
      YQ=X(2)+T*X(5)
      ZQ=X(3)+T*X(6)
      DO 3 I=12,32,4
         IF (0.LT.P(I)*XQ+P(I+1)*YQ+P(I+2)*ZQ+P(I+3)) RETURN
    3 CONTINUE
      SNXT=SNXT1
*
      END
+DECK,  GNOTUB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNOTUB(X,P,IACT,IFL,SNEXT,SNXT,SAFE)
C.    ******************************************************************
C.    *                                                                *
C.    *      Compute distance to intersection with boundary surface of *
C     *      volume TUBE or TUBS, from point X(1),X(2),X(3) outside    *
C     *      the volume along track with direction cosines X(4),X(5),  *
C     *      X(6)                                                      *
C.    *      P     (input)  : volume parameters                        *
C.    *      IACT  (input)  : action flag                              *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, compute SNXT only if SAFE.LT.SNEXT  *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *      IFL   (input)  : 1 for TUBE, 2 for PHI segmented TUBE     *
C.    *      SNEXT (input)  : see IACT = 1                             *
C.    *      SNXT  (output) : distance to volume boundary along track  *
C.    *      SAFE  (output) : not larger than scalar distance to       *
C.    *                       volume boundaray                         *
C.    *      Called by : GNEXT, GNOPCO, GTNEXT                         *
C.    *                                                                *
C.    *      Authors   : Michel Maire and Rolf Nierhaus   21-JUN-1990  *
C.    *                                                                *
C.    ******************************************************************
C.    *                                                                *
C.    * 'TUBE'    is a tube. It has 3 parameters, the inside radius,   *
C.    *           the outside radius and the half length in z.         *
C.    * 'TUBS'    is a phi segment of a  tube.  It has 5 parameters,   *
C.    *           the same  3 as  'TUBE' plus  the phi  limits.  The   *
C.    *           segment  starts at  the first  limit and  includes   *
C.    *           increasing phi  value up  to the  second limit  or   *
C.    *           that plus 360 degrees.                               *
C.    *                                                                *
C.    ******************************************************************
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+SELF.
+CDE, GCONSP.
      REAL X(6),P(5),SNEXT,SNXT,SAFE
*
*     this part has to be moved outside the routine
      IF (IFL.EQ.2) THEN
         P4=P(4)*DEGRAD
         P5=P(5)*DEGRAD
         IF (P5.LT.P4) P5=P5+TWOPI
         C1=COS(P4)
         S1=SIN(P4)
         C2=COS(P5)
         S2=SIN(P5)
         FIO=0.5*(P5+P4)
         CFIO=COS(FIO)
         SFIO=SIN(FIO)
         DFI=0.5*(P5-P4)
         CDFI=COS(DFI)
*        SDFI=SIN(DFI)
      END IF
*
      SNXT=1.E10
      R=SQRT(X(1)**2+X(2)**2)
*
*     Compute SAFE radius
      IF (IACT.LT.3) THEN
         SAF1=P(1)-R
         SAF2=R-P(2)
         SAF3=ABS(X(3))-P(3)
         SAF4=0.
         IF (IFL.EQ.2.AND.R.GT.0.) THEN
            CPSI=(X(1)*CFIO+X(2)*SFIO)/R
            IF (CPSI.LT.CDFI) THEN
               IF ((X(2)*CFIO-X(1)*SFIO).LE.0.) THEN
                  SAF4=ABS(X(1)*S1-X(2)*C1)
               ELSE
                  SAF4=ABS(X(1)*S2-X(2)*C2)
               END IF
            END IF
         ENDIF
         SAFE=MAX(SAF1,SAF2,SAF3,SAF4)
         IF (IACT.EQ.0) GO TO 999
         IF (IACT.EQ.1.AND.SNEXT.LE.SAFE) GO TO 999
      END IF
*
*     Intersection with z-plane
*     only points outside the z range need to be considered
      IF (ABS(X(3)).GE.P(3)) THEN
         IF (X(3)*X(6).LT.0.) THEN
            S=(ABS(X(3))-P(3))/ABS(X(6))
            XI=X(1)+S*X(4)
            YI=X(2)+S*X(5)
            R2=XI**2+YI**2
            IF (P(1)**2.LE.R2.AND.R2.LE.P(2)**2) THEN
               IF (IFL.EQ.1) GO TO 101
               IF (R2.EQ.0.) GO TO 101
               CPSI=(XI*CFIO+YI*SFIO)/SQRT(R2)
               IF (CPSI.GE.CDFI) GO TO 101
            END IF
         END IF
      END IF
*
*     Intersection with cylinders
*     Intersection point (x,y,z)
*     (x,y,z) is on track :    x=X(1)+t*X(4)
*                              y=X(2)+t*X(5)
*                              z=X(3)+t*X(6)
*     (x,y,z) is on cylinder : x**2 + y**2 = R**2
*
*     (X(4)**2+X(5)**2)*t**2
*     +2.*(X(1)*X(4)+X(2)*X(5))*t
*     +X(1)**2+X(2)**2-R**2=0
*
      T1=X(4)**2+X(5)**2
      T2=(X(1)*X(4)+X(2)*X(5))
      T3=X(1)**2+X(2)**2
*     track parallel to the z axis ?
***** 21-JUN-1990
*     IF (T1.EQ.0.) GO TO 999
      IF (ABS(T1).LT.1.E-32) GO TO 999
      B =T2/T1
*
*     Intersection with outer cylinder
*     only points outside the outer cylinder need to be considered
      IF (R.GE.P(2)) THEN
         C=(T3-P(2)**2)/T1
         D=B**2-C
         IF (D.GE.0.) THEN
            S=-B-SQRT(D)
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(3)) THEN
                  IF (IFL.EQ.1) GO TO 101
                  XI=X(1)+S*X(4)
                  YI=X(2)+S*X(5)
                  CPSI=(XI*CFIO+YI*SFIO)/P(2)
                  IF (CPSI.GE.CDFI) GO TO 101
               END IF
            END IF
         END IF
      END IF
*     Intersection with inner cylinder
      IF (P(1).GT.0.) THEN
         C=(T3-P(1)**2)/T1
         D=B**2-C
         IF (D.GE.0.) THEN
            S=-B+SQRT(D)
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(3)) THEN
                  IF (IFL.EQ.1) GO TO 101
                  XI=X(1)+S*X(4)
                  YI=X(2)+S*X(5)
                  CPSI=(XI*CFIO+YI*SFIO)/P(1)
                  IF (CPSI.GE.CDFI) SNXT=S
               END IF
            END IF
         END IF
      END IF
*
*     Intersection with phi-planes
*     x=r*cos(phi)=X(1)+t*X(4)
*     y=r*sin(phi)=X(2)+t*X(5)
*     z           =X(3)+t*X(6)
*     t=(X(2)*cos(phi)-X(1)*sin(phi))/(X(4)*sin(phi)-X(5)*cos(phi))
      IF (IFL.EQ.2) THEN
*        track not parallel to the phi1 plane ?
         UN=X(4)*S1-X(5)*C1
         IF (UN.NE.0.) THEN
            S=(X(2)*C1-X(1)*S1)/UN
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(3)) THEN
                  XI=X(1)+S*X(4)
                  YI=X(2)+S*X(5)
                  R2=XI**2+YI**2
                  IF (P(1)**2.LE.R2.AND.R2.LE.P(2)**2) THEN
                     IF ((YI*CFIO-XI*SFIO).LE.0.) THEN
                        IF (S.LT.SNXT) SNXT=S
                     END IF
                  END IF
               END IF
            END IF
         END IF
*        track not parallel to the phi2 plane ?
         UN=X(4)*S2-X(5)*C2
         IF (UN.NE.0.) THEN
            S=(X(2)*C2-X(1)*S2)/UN
            IF (S.GE.0.) THEN
               ZI=X(3)+S*X(6)
               IF (ABS(ZI).LE.P(3)) THEN
                  XI=X(1)+S*X(4)
                  YI=X(2)+S*X(5)
                  R2=XI**2+YI**2
                  IF (P(1)**2.LE.R2.AND.R2.LE.P(2)**2) THEN
                     IF ((YI*CFIO-XI*SFIO).GE.0.) THEN
                        IF (S.LT.SNXT) SNXT=S
                     END IF
                  END IF
               END IF
            END IF
         END IF
      END IF
      GO TO 999
*
  101 SNXT=S
  999 END

+DECK,  GNPARA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNPARA (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'PARA' VOLUME,  *
C.    *       FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)          *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6), PAR(6)
C.
C.    ---------------------------------------------------
C.
      SNXT = BIG
      DN31=PAR(3)-X(3)
      DN32=-PAR(3)-X(3)
C
      YT=X(2)-PAR(6)*X(3)
      DN21=PAR(2)-YT
      DN22=-PAR(2)-YT
      CTY=1.0/SQRT(1.0+PAR(6)**2)
C
      XT=X(1)-PAR(5)*X(3)-PAR(4)*YT
      DN11=PAR(1)-XT
      DN12=-PAR(1)-XT
      CTX=1.0/SQRT(1.0+PAR(4)**2+PAR(5)**2)

      IF (IACT .LT. 3) THEN


C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (McPherson)   |
C       -------------------------------------------------


        SAFE=MIN(DN11*CTX,-DN12*CTX,DN21*CTY,-DN22*CTY,DN31,-DN32)
C
        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF

C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------


      SN3=BIG
      SN2=BIG
      SN1=BIG
C
      IF(X(6).NE.0.0) SN3=DN31/X(6)
      IF(SN3.LT.0.0) SN3=DN32/X(6)
C
      DY=X(5)-PAR(6)*X(6)
      IF(DY.NE.0.0) SN2=DN21/DY
      IF(SN2.LT.0.0) SN2=DN22/DY
C
      DX=X(4)-PAR(5)*X(6)-PAR(4)*DY
      IF(DX.NE.0.0) SN1=DN11/DX
      IF(SN1.LT.0.0) SN1=DN12/DX
C
      SNXT=MIN(SN1,SN2,SN3)
C
  999 CONTINUE
      END
+DECK,  GNPCON, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

      SUBROUTINE GNPCON (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'PCON' VOLUME,  *
C.    *       FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)          *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson,  P.Weidhaas  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6), PAR(9),  XT(6), PT(7)

      EQUIVALENCE (PT(1), DZ),  (PT(2), PT2), (PT(3), PT3)
      EQUIVALENCE (PT(4), PT4), (PT(5), PT5), (PT(6), PT6)
      EQUIVALENCE (PT(7), PT7)

      EQUIVALENCE (XT(3), XT3)
C.
C.   ---------------------------------------------------
C.

      SNXT = BIG
      R2  = X(1)*X(1) + X(2)*X(2)
      R   = SQRT (R2)

      NZ  = PAR(3)
      ZMIN  = PAR(4)
      ZMAX  = PAR(3*NZ+1)
      SAFZ1 = X(3) - ZMIN
      SAFZ2 = ZMAX - X(3)
      SAFEZ = MIN (SAFZ1, SAFZ2)

C
C......  First determine in which z-segment the particle is located.
C
      DO 10 JPH=7, 3*(NZ-1)+1,  3
        IF (X(3) .LE. PAR(JPH)) THEN
           IPH=JPH
           GO TO 20
        ENDIF
   10 CONTINUE
      IPH=3*NZ+1

   20 CONTINUE
C
C......  The particle is in the segment bounded by z-planes at
C......  Z1=PAR(IPL) and Z2=PAR(IPH), i.e.,  Z1 < X(3) < Z2.
C
C......  Set parameters for this segment and translate z-coordinate
C......  of point relative to center of this segment.This is done in
C......  preparation of invoking the algorithms used in "GNTUBE" and
C......  "GNCONE" (which for reasons of efficiency and clarity are
C......  implemented inline).
C
      IPL  = IPH - 3
      DZ    = 0.5 * (PAR(IPH) - PAR(IPL))
      PT2 = PAR(IPL+1)
      PT3 = PAR(IPL+2)
      PT4 = PAR(IPH+1)
      PT5 = PAR(IPH+2)
      PT6 = PAR(1)
      PT7 = PAR(1) + PAR(2)
      IF (PT7 .GT. 360.0)  PT7  = PT7 - 360.0

      XT3 = X(3) - 0.5 * (PAR(IPL) + PAR(IPH))

      XT(1)  = X(1)
      XT(2)  = X(2)
      XT(4)  = X(4)
      XT(5)  = X(5)
      XT(6)  = X(6)

      IND = 2
      IF (PAR(2) .EQ. 360.0)  IND = 1

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------
        SAFZ1   = DZ - ABS(XT3)
        SAFEZ   = MIN (SAFEZ,SAFZ1)
        SAFSEG  = BIG
C
C......  Determine whether the segment is a tube or a cone.
C

        IF (PT2 .NE. PT4) GO TO 50
        IF (PT3 .NE. PT5) GO TO 50

C*********************************************************
C
C......  The segment is a tube: invoke the algorithm
C......  from routine "GNTUBE" inline to get "SAFER".
C
C*********************************************************

        SAFR1  = R - PT2
        SAFR2  = PT3 - R
        SAFER  = MIN (SAFR1, SAFR2)

        IF (IND .EQ. 2) GO TO 70

        GO TO 100


   50   CONTINUE

C*********************************************************
C
C......  The segment is a cone: invoke the algorithm
C......  from routine "GNCONE" inline to get "SAFER".
C
C*********************************************************

        SAFZ2  = DZ + XT3
        ZLENI  = 0.5 / DZ

C......  Compute radial distance to inner wall.

        FACT  = (PT4 - PT2) * ZLENI
        R1  = PT2 + FACT * SAFZ2
        SAFR1 = (R - R1) / SQRT(1.0 + FACT*FACT)

C......  Compute radial distance to outer wall.

        FACT  = (PT5 - PT3) * ZLENI
        R2  = PT3 + FACT * SAFZ2
        SAFR2 = (R2 - R) / SQRT(1.0 + FACT*FACT)
        SAFER = MIN (SAFR1, SAFR2)

        IF (IND .EQ. 1) GO TO 100

   70   CONTINUE

C********************************************************************
C......  Here we handle the case of a PHI-segment of a tube or cone.
C......  In addition to the radial distances (SAFR1, SAFR2) and the
C......  axial distances (SAFZ1, SAFZ2) we compute here the distance
C......  to the PHI-segment boundary that is closest to the point.
C
C......  For each PHI-boundary we find the distance from the given
C......  point to the outer (at R2) point of the segment boundary
C......  (DISTS1 and DISTS2, resp.). If DISTS1 < DISTS2, we define
C......  "SAFSEG" to be the distance to segment PHI1, else we set
C......  "SAFSEG" to be the distance to segment PHI2.
C*********************************************************************

          PHI1  = PT6 * DEGRAD
          PHI2  = PT7 * DEGRAD
          IF (PHI2 .LT. PHI1)  PHI2 = PHI2 + TWOPI

          COSPH1  = COS (PHI1)
          COSPH2  = COS (PHI2)
          SINPH1  = SIN (PHI1)
          SINPH2  = SIN (PHI2)

C......  Get coordinates of outer endpoints (at R2) of both PHI-segments.

          XS1  = R2 * COSPH1
          YS1  = R2 * SINPH1
          XS2  = R2 * COSPH2
          YS2  = R2 * SINPH2

C......  Get distances (squared) from given point to each endpoint.

          DISTS1 = (X(1) - XS1)**2  +  (X(2) - YS1)**2
          DISTS2 = (X(1) - XS2)**2  +  (X(2) - YS2)**2

C......  Get distance to that PHI-segment whose endpoint
C......  is closest to the given point.

          IF (DISTS1 .LE. DISTS2) THEN
            SAFSEG = ABS(X(1) * SINPH1 - X(2) * COSPH1)
          ELSE
            SAFSEG = ABS(X(1) * SINPH2 - X(2) * COSPH2)
          ENDIF


  100   CONTINUE

        SAFE  = MIN (SAFEZ, SAFER, SAFSEG)

        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------
*
*     Avoid rounding effects induced by translation ********************
*
      IF (ABS(XT(3)).GE.DZ) XT(3) = (1.-0.000001)*XT(3)
*
      IF (PT2 .NE. PT4) GO TO 200
      IF (PT3 .NE. PT5) GO TO 200

      DELZ  = DZ
      PT(1) = PT2
      PT(2) = PT3
      PT(3) = DELZ
      PT(4) = PT6
      PT(5) = PT7

      CALL GNTUBE (XT, PT, 3, IND, SNEXT, SNXT, TSAFE)
      GO TO 999

  200 CONTINUE
      CALL GNCONE (XT, PT, 3, IND, SNEXT, SNXT, TSAFE)

  999 CONTINUE
      END

+DECK,  GNPGO1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:53  cernlib
* Geant

*********************************************************************
***** GNPGO1 ********************************************************
*     GNPGO1 ... 15-AUG-1991
*     Version 1.1
*     Rolf Nierhaus
*********************************************************************
*     Copyright   CERN,   Geneva  1991  -  Copyright  and  any  other
*     appropriate legal protection of  these  computer  programs  and
*     associated  documentation  reserved  in  all  countries  of the
*     world.
*********************************************************************
*          Subroutine  GNPGO1 is called by GNPGON for the computation
*     of SNXT, the distance from a point P  along  a  track  T  to  a
*     boundary  surface  of a Geant volume V of shape PGON. The point
*     P is inside the volume V.
*          V  is  generally  a composite volume consisting of several
*     sections. The sections have  boundary  surfaces  orthogonal  to
*     the   Z-axis.   Each  section  consists  generally  of  several
*     sectors. Each sector is an  "elementary"  convex  volume.  This
*     package  assumes it is either a hexahedron or a pentahedron. If
*     it is a pentahedron, it has 6 vertices, of  which  two  are  on
*     the  Z-axis.  All  sectors  of  the same section are congruent.
*     Each section has the same number of sectors.
*          We  describe each surface by 6 parameters: the first three
*     are   the   coordinates   of   a   point   on    the    surface
*     XS(I),YS(I),ZS(I),  the  other  three are the components of the
*     normal vector of the surface XN(I),YN(I),ZN(I). I is the  index
*     of  the surface. We consider only one sector at a time, and the
*     number of boundary  surfaces  is  never  larger  then  6.  Each
*     surface  divides  the  space  into  two  regions:  the positive
*     region and the negative region. We choose the direction of  the
*     normal  vectors  of the boundary surfaces such that the bounded
*     volume is within the positive region of each surface, that  is,
*     the normal vector is pointing to the inside of the volume.
***** Subroutine GNPGO1 *************************** 15-AUG-1991 *****
      SUBROUTINE GNPGO1(X,P,SNXT)
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+SELF.
      REAL X(6),P(49),SNXT
+SELF, IF=SINGLE.
      PARAMETER (F=0.01745329251994330,TPI=6.283185307179586)
+SELF, IF=-SINGLE.
      PARAMETER (F=0.01745329251994330D0,TPI=6.283185307179586D0)
+SELF.
      PARAMETER (ONE=1,HALF=ONE/2,ZERO=0.)
      DIMENSION XS(6), YS(6), ZS(6), XN(6), YN(6), ZN(6)
      LOGICAL FLAG, FLG
      XP=X(1)
      YP=X(2)
      ZP=X(3)
      XD=X(4)
      YD=X(5)
      ZD=X(6)
      IMAX=P(4)-.5
*     IMAX   ->   number of Z-sections
      JMAX=P(3)+.5
*     JMAX   ->   number of Phi-sectors
      SNXT=0.
   10 CONTINUE
*     Find current elementary volume
      IF (ZP.LE.P(5)) RETURN
*     Current point (XP,YP,ZP) is below first section.
      DO 20 II=1,IMAX
         IF (ZP.LT.P(5+3*II)) THEN
            I=II
            GO TO 30
         ENDIF
   20 CONTINUE
      RETURN
*     Current point (XP,YP,ZP) is above last section.
   30 CONTINUE
      IF (XP.EQ.0..AND.YP.EQ.0.) XP=1.E-20
      PHI=ATAN2(YP,XP)
      IF (PHI.LT.0.) PHI=PHI+TPI
      P1=F*P(1)
      PHI1=PHI-P1
      IF (PHI1.LT.0.) PHI1=PHI1+TPI
      IF (PHI1.GE.TPI) PHI1=PHI1-TPI
      IF (JMAX.EQ.1) THEN
          IF (ABS(PHI1-TPI).LT.1D-7) PHI1=0.
      ENDIF
      J=PHI1*P(3)/(F*P(2))+ONE
      IF (P(2).EQ.360.) THEN
         IF (J.LT.1) THEN
            J=J+JMAX
         ELSEIF (JMAX.LT.J) THEN
            J=J-JMAX
         END IF
      END IF
      IF (JMAX.LT.J.OR.J.LT.1) RETURN
*     Current point is outside Phi-range.
C*****  Code Expanded From Routine:  GNPGO2
*     GNPGO2 finds the vector distance to the boundary surface
*     of the current elementary volume.
*     I is Z-section, J is Phi-sector.
*     GNPGO2 calls GNPGO4 five or six times for the storage of
*     the surface coefficients of its boundary surfaces.
*
      INDEX = 2 + 3*I
      Z1 = P(INDEX)
      D1N = P(INDEX+1)
      D1X = P(INDEX+2)
      Z2 = P(INDEX+3)
      D2N = P(INDEX+4)
      D2X = P(INDEX+5)
      ZM = HALF*(Z1 + Z2)
      P11X = F*(P(1)+(J-1)*P(2)/JMAX)
      P2 = F*(P(1)+J*P(2)/JMAX)
      PP = HALF*(P11X + P2)
      COSP = COS(PP)
      SINP = SIN(PP)
      DMX = HALF*(D1X + D2X)
      DMN = HALF*(D1N + D2N)
      THX = ATAN((D2X - D1X)/(Z2 - Z1))
      COSTHX = COS(THX)
      SINTHX = SIN(THX)
      XNN = -COSP*COSTHX
      YNN = -SINP*COSTHX
C*****  Code Expanded From Routine:  GNPGO4
*     Store surface coefficients
      XS(5) = DMX*COSP
      YS(5) = DMX*SINP
      ZS(5) = ZM
      XN(5) = XNN
      YN(5) = YNN
      ZN(5) = SINTHX
C*****  End of Code Expanded From Routine:  GNPGO4
C*****  Code Expanded From Routine:  GNPGO9
*          Logical   function   GNPGO9  returns  TRUE  if  the  point
*     (XP,YP,ZP) is within the positive region of  the  surface  with
*     index   I.   This   is  the  case  if  the  scalar  product  of
*     (XP-XS,YP-YS,ZP-ZS) and (XN,YN,ZN) is positive (or zero).
      RESULT=(XP-XS(5))*XN(5)+(YP-YS(5))*YN(5)+(ZP-ZS(5))*ZN(5)
      FLG = 0. .LE. RESULT
      IF (.NOT.FLG) GO TO 50
      ISMAX = 5
      IF (DMN .NE. 0.) THEN
         ISMAX = 6
         THN = ATAN((D2N - D1N)/(Z2 - Z1))
         COSTHN = COS(THN)
         SINTHN = SIN(THN)
         XNN = COSP*COSTHN
         YNN = SINP*COSTHN
C*****  Code Expanded From Routine:  GNPGO4
         XS(6) = DMN*COSP
         YS(6) = DMN*SINP
         ZS(6) = ZM
         XN(6) = XNN
         YN(6) = YNN
         ZN(6) = -SINTHN
C*****  End of Code Expanded From Routine:  GNPGO4
C*****  Code Expanded From Routine:  GNPGO9
         RESULT=(XP-XS(6))*XN(6)+(YP-YS(6))*YN(6)+(ZP-ZS(6))*ZN(6)
         FLG = 0. .LE. RESULT
         IF (.NOT.FLG) GO TO 50
      ENDIF
C*****  Code Expanded From Routine:  GNPGO4
      XS(1) = ZERO
      YS(1) = ZERO
      ZS(1) = Z1
      XN(1) = ZERO
      YN(1) = ZERO
      ZN(1) = ONE
C*****  End of Code Expanded From Routine:  GNPGO4
C*****  Code Expanded From Routine:  GNPGO4
      XS(2) = ZERO
      YS(2) = ZERO
      ZS(2) = Z2
      XN(2) = ZERO
      YN(2) = ZERO
      ZN(2) = -ONE
C*****  End of Code Expanded From Routine:  GNPGO4
C*****  Code Expanded From Routine:  GNPGO4
      XS(3) = ZERO
      YS(3) = ZERO
      ZS(3) = ZM
      XN(3) = -SIN(P11X)
      YN(3) = COS(P11X)
      ZN(3) = ZERO
C*****  End of Code Expanded From Routine:  GNPGO4
C*****  Code Expanded From Routine:  GNPGO4
      XS(4) = ZERO
      YS(4) = ZERO
      ZS(4) = ZM
      XN(4) = SIN(P2)
      YN(4) = -COS(P2)
      ZN(4) = ZERO
C*****  End of Code Expanded From Routine:  GNPGO4
C*****  Code Expanded From Routine:  GNPGO5
*     Vector distance to volume boundary
      SNXT1 = 1.E10
      DO 40  IS = 1, ISMAX
C*****  Code Expanded From Routine:  GNPGO7
*          To  find  the  distance  from  a  point (XP,YP,ZP) along a
*     track  with  direction  cosines   (XD,YD,ZD)   to   a   surface
*     (XS,YS,ZS)(XN,YN,ZN),  we  compute  first the scalar product of
*     the  vector  (XS-XP,YS-YP,ZS-ZP)   with   the   normal   vector
*     (XN,YN,ZN),  then  the scalar product of the vectors (XD,YD,ZD)
*     and (XN,YN,ZN).  The  first  scalar  product  is  the  shortest
*     distance  from  the  point  to  the  plane,  the  second scalar
*     product is the cosine of the angle between the  track  and  the
*     plane  normal.  The  quotient  is  the vector distance. If this
*     vector distance is  positive  (or  zero)  we  set  the  logical
*     variable  FLAG  TRUE.  GNPGO7  is  called with three parameters
*     I,FLAG and DIST. I is the index of the  surface,  and  DIST  is
*     the vector distance if FLAG is TRUE.
         SPPMSN = (XP - XS(IS))*XN(IS) + (YP - YS(IS))*YN(IS) + (ZP -
     +   ZS (IS))*ZN(IS)
         SPDN = XD*XN(IS) + YD*YN(IS) + ZD*ZN(IS)
         IF (SPDN .EQ. 0.) THEN
            DIST1 = 0.
         ELSE
            DIST1 = -(SPPMSN + .0001)/SPDN
         ENDIF
         FLAG = 0. .LT. DIST1
C*****  End of Code Expanded From Routine:  GNPGO7
         IF (FLAG) SNXT1 = MIN(DIST1,SNXT1)
   40 CONTINUE
   50 CONTINUE
C*****  End of Code Expanded From Routine:  GNPGO2
      IF (FLG) THEN
         SNXT=SNXT+SNXT1
         XP=XP+SNXT1*XD
         YP=YP+SNXT1*YD
         ZP=ZP+SNXT1*ZD
*     The current point (XP,YP,ZP) is propagated along the track
*     to the boundary of the current elementary volume.
         GO TO 10
      ENDIF
      END
+DECK,  GNPGON, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GNPGON (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'PGON' VOLUME,  *
C.    *       FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)          *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson,  P.Weidhaas  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.

      DIMENSION X(6), PAR(50), TPAR(50)

C-----------------------------------------------------------------

      SNXT = BIG
      SAFSEG = BIG
      R2 = X(1)*X(1) + X(2)*X(2)
      R  = SQRT (R2)

      PDIV  = PAR(2) / PAR(3)
      DELPHI  = PDIV * DEGRAD
      DPHI2 = 0.5 * DELPHI
      CSDPH2 = COS (DPHI2)

      TPAR(1)  = PAR(1)
      TPAR(2)  = PAR(2)
      TPAR(3)  = PAR(3)
      TPAR(4)  = PAR(4)
      NZ  = PAR(4)

      DO 5 I=1, NZ
        I3  = 3*(I-1)
        TPAR(5+I3) = PAR(5+I3)
        TPAR(6+I3) = PAR(6+I3) / CSDPH2
        TPAR(7+I3) = PAR(7+I3)
    5 CONTINUE

C**************************************************************************
C
C......  Here we start the logic from "GNPCON" (which for reasons of
C......  efficiency and clarity has been implemented inline).
C
C**************************************************************************

      ZMIN  = TPAR(5)
      ZMAX  = TPAR(3*NZ+2)
      SAFZ1 = X(3) - ZMIN
      SAFZ2 = ZMAX - X(3)
      SAFEZ = MIN (SAFZ1, SAFZ2)

C
C......  First determine in which segment the particle is located.
C
      DO 10 JPH=8, 3*NZ-1,  3
        IF (X(3) .LT. TPAR(JPH)) THEN
           IPH=JPH
           GO TO 20
        ENDIF
   10 CONTINUE
      IPH = 3*NZ+2

   20 CONTINUE
C
C......  The particle is in the segment bounded by z-planes at
C......  Z1=PAR(IPL) and Z2=PAR(IPH), i.e.,  Z1 < X(3) < Z2.
C
C......  Set parameters for this segment and translate z-coordinate
C......  of point relative to center of this segment. this is done in
C......  preparation of invoking the algorithms used in "GNTUBE" and
C......  "GNCONE" (which for reasons of efficiency and clarity are
C......  implemented inline).
C
      IPL  = IPH - 3
      DZ    = 0.5 * (TPAR(IPH) - TPAR(IPL))
      PT2 = TPAR(IPL+1)
      PT3 = TPAR(IPL+2)
      PT4 = TPAR(IPH+1)
      PT5 = TPAR(IPH+2)
      PT6 = TPAR(1)
      PT7 = TPAR(1) + TPAR(2)
      IF (PT7 .GT. 360.0)  PT7  = PT7 - 360.0

      XT3 = X(3) - 0.5 * (TPAR(IPL) + TPAR(IPH))

      SAFZ2  = DZ + XT3
      ZLENI  = 0.5 / DZ

      PHI1  = PT6 * DEGRAD
      PHI2  = PT7 * DEGRAD
      IF (PHI2.LE.PHI1) PHI2=PHI2+TWOPI

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

        IFLAG = 2
        IF (TPAR(2) .EQ. 360.0)  IFLAG = 1
        SAFZ1 = DZ - ABS(XT3)
        SAFEZ = MIN (SAFEZ,SAFZ1)
C
C......  Next determine whether the segment is a tube or a cone.
C
        IF (PT2 .NE. PT4) GO TO 50
        IF (PT3 .NE. PT5) GO TO 50

C*********************************************************
C
C......  The segment is a tube; invoke the algorithm
C......  from routine "GNTUBE" inline to get "SAFER".
C
C*********************************************************

        SAFR1  = BIG
        IF(PT2.GT.0.) SAFR1  = R - PT2
        SAFR2  = PT3 - R
        SAFER  = MIN (SAFR1, SAFR2)

        IF (IFLAG .EQ. 2) GO TO 70

        GO TO 100


   50   CONTINUE

C*********************************************************
C
C......  The segment is a cone; invoke the algorithm
C......  from routine "GNCONE" inline to get "SAFER".
C
C*********************************************************


C......  Compute radial distance to inner wall.

        IF(PT2+PT4.GT.0.) THEN
        FACT  = (PT4 - PT2) * ZLENI
        RAD1  = PT2 + FACT * SAFZ2
        SAFR1 = (R - RAD1) / SQRT(1.0 + FACT*FACT)
        ELSE
        SAFR1 = BIG
        ENDIF

C......  Compute radial distance to outer wall.

        FACT  = (PT5 - PT3) * ZLENI
        RAD2  = PT3 + FACT * SAFZ2
        SAFR2 = (RAD2 - R) / SQRT(1.0 + FACT*FACT)

        SAFER  = MIN (SAFR1, SAFR2)

        IF (IFLAG .EQ. 1) GO TO 100

   70   CONTINUE

C********************************************************************
C......  Here we handle the case of a phi-segment of a tube or cone.
C......  in addition to the radial distances (SAFR1, SAFR2) and the
C......  axial distances (SAFZ1, SAFZ2) we compute here the distance
C......  to the phi-segment boundary that is closest to the point:
C
C......  For each phi-boundary we find the distance from the given
C......  point to the outer (at R2) point of the segment boundary
C......  (DISTS1 and DISTS2, resp.). If DISTS1 < DISTS2, we define
C......  "SAFSEG" to be the distance to segment PHI1, else we set
C......  "SAFSEG" to be the distance to segment PHI2.
C*********************************************************************


          COSPH1  = COS (PHI1)
          SINPH1  = SIN (PHI1)
          COSPH2  = COS (PHI2)
          SINPH2  = SIN (PHI2)

C......  Get coordinates of outer endpoints (at R2) of both phi-segments.

          XS1  = R * COSPH1
          YS1  = R * SINPH1
          XS2  = R * COSPH2
          YS2  = R * SINPH2

C......  Get distances (squared) from given point to each endpoint.

          DISTS1 = (X(1) - XS1)**2  +  (X(2) - YS1)**2
          DISTS2 = (X(1) - XS2)**2  +  (X(2) - YS2)**2

C......  Get distance to that phi-segment whose endpoint
C......  is closest to the given point.

          IF (DISTS1 .LE. DISTS2) THEN
            SAFSEG = ABS(SINPH1 * X(1) - COSPH1 * X(2))
          ELSE
            SAFSEG = ABS(SINPH2 * X(1) - COSPH2 * X(2))
          ENDIF

  100   CONTINUE


        IF (SAFER .LE. 0.0)  THEN

C---------------------------------------------------------------------------
C
C......  Here we handle the case in which  SAFER < 0, i.e., the point is
C......  inside the polygon but outside the inscribed polycone. We must
C......  do an accurate calculation of "SAFER".
C
C---------------------------------------------------------------------------

          FACT = SAFZ2 * ZLENI
          RAD1 = PT2 + FACT * (PT4 - PT2)
          RAD2 = PT3 + FACT * (PT5 - PT3)
          RR1 = RAD1 * RAD1
          RR2 = RAD2 * RAD2

          IF(X(1).EQ.0.)THEN
             PHI   = ATAN2(X(2), 1.E-8)
          ELSE
             PHI   = ATAN2(X(2), X(1))
          ENDIF
          IF (PHI .LT. PHI1)  PHI = PHI + TWOPI

          DIST=0.
          IF (PHI .GE. PHI1  .AND.  PHI .LE. PHI2)  THEN
            PHIREL = PHI - PHI1
            NSECTR = INT(PHIREL / DELPHI) + 1
            PHICTR  = PHI1 + (2.0*NSECTR - 1.0) * DPHI2
            COSPHC = COS (PHICTR)
            SINPHC = SIN (PHICTR)


            IF (R2 .GE. RR2) THEN
              SR2 = RAD2
              DIST = ABS (COSPHC * X(1) + SINPHC * X(2) - SR2)
              FACTC  = (PT5 - PT3) * ZLENI
            ELSEIF (R2 .LE. RR1) THEN
              RIN  = RAD1 * CSDPH2
              SRIN = RIN
              DIST = ABS (COSPHC * X(1) + SINPHC * X(2) - SRIN)
              FACTC = (PT4 - PT2) * ZLENI
            ENDIF

          ENDIF

          SAFER  = DIST / SQRT(1.0 + FACTC*FACTC)

        ENDIF

        SAFE  = MIN (SAFEZ, SAFER, SAFSEG)


        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (Nierhaus)  |
C     ------------------------------------------------


      CALL GNPGO1(X,PAR,SNXT)
C
  999 CONTINUE
      END

+DECK,  GNSPHR, T=FORT.
* Revision 1.3  1996/03/28 08:50:23  cernlib
* In the call to function MAX  use NULL istead of 0. to get the proper
* type of argument.
* Revision 1.2  1996/02/27 10:12:06  ravndal
* Precision problem (neg. Sqrt) solved
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GNSPHR (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'SPHE' VOLUME,  *
C.    *       FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)          *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson,  P.Weidhaas  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+SELF.
+CDE, GCONSP.
      REAL X(6), PAR(6), SNXT, SNEXT, SAFE
      PARAMETER (ZERO=0,ONE=1,SMALL=ONE/BIG)

C---------------------------------------------------------------

      SNXT = BIG
      R2   = X(1)*X(1) + X(2)*X(2) + X(3)*X(3)
      R    = SQRT (R2)
      RIN  = PAR(1)
      ROUT = PAR(2)
      SAF1 = R - RIN
      SAF2 = ROUT - R

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

         SAFE = MIN (SAF1, SAF2)
         IF( RIN .EQ. 0.0 ) THEN
            SAFE = ROUT-R
            SAF3 = SAFE
            SAF4 = SAFE
         ELSE
            SAF3 = R
            SAF4 = R
         ENDIF
         IF( R .GT. 1.E-5) THEN
            IF( PAR(4)-PAR(3).GE.180.) THEN
               SAF3 = BIG
            ELSE
               TH = ACOS(X(3)/SNGL(R))*RADDEG
               IF (TH.LT.0) TH = 180.+TH
               DTH1 = TH-PAR(3)
               DTH2 = PAR(4)-TH
               DTH = MIN(DTH1,DTH2)
               SAF3 = R*SIN(DTH*DEGRAD)
            ENDIF
            RXY2 = X(1)*X(1)+X(2)*X(2)
            IF( RXY2 .GT. 1.E-12.AND. PAR(6)-PAR(5) .LT. 360) THEN
               RXY = SQRT(RXY2)
               PHI=ATAN2(X(2),X(1))*RADDEG
               DPH = PHI-PAR(5)
               SG = SIGN(ONE,DPH)
               DPH = MOD( ABS(DPH), ONE*360 )
               IF(SG.LE.0.) DPH = 360.-DPH
               DPHT = PAR(6)-PAR(5)
               IF(DPHT .LT. 0.) DPHT = DPHT+360.
               DDPH = MIN(DPH,DPHT-DPH)
               IF( DDPH .GT. 90.) THEN
                  SAF4 = BIG
               ELSE
                  SAF4 = RXY*SIN(DDPH*DEGRAD)
               ENDIF
            ENDIF
         ENDIF
         SAFE = MIN(ONE*SAFE,SAF3,SAF4)

         IF (IACT .EQ. 0) GO TO 999
         IF (IACT .EQ. 1) THEN
            IF (SNEXT .LT. SAFE) GO TO 999
         ENDIF
      ENDIF

C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------

      IF(R.LT.1.0E-5) GO TO 70

      C1=(X(1)*X(4)+X(2)*X(5)+X(3)*X(6)) / R
      RTMP = PAR(2)
      SGN=ONE
      AC=R*R * (ONE-C1*C1)
      IF(AC.GT.PAR(1)**2.OR.C1.GT.0.0) GO TO 10
      SGN=-ONE
      RTMP = PAR(1)
   10 CONTINUE
      RTMPAC=MAX(RTMP*RTMP-AC,ZERO)
      SNXT=SQRT(RTMPAC)*SGN-R*C1
      DPSGN=X(1)*X(5)-X(2)*X(4)
      PHI2=PAR(6)
      IF(DPSGN.LT.0.0) PHI2=PAR(5)
C
      TSGN=SIN(PHI2*DEGRAD)
      TCSG=COS(PHI2*DEGRAD)
      DEN=X(4)*TSGN-X(5)*TCSG
      IF(DEN.EQ.0.0) GO TO 20
      SP=(X(2)*TCSG-X(1)*TSGN)/DEN
      IF(SP.LT.0.0) GO TO 20
      IF(ABS(TSGN).GT.1.E-6.AND.(X(2)+SP*X(5))*TSGN
     +       .LT.0.)GO TO 20
      IF(ABS(TCSG).GT.1.E-6.AND.(X(1)+SP*X(4))*TCSG
     +       .LT.0.)GO TO 20
C
      IF(SP.LT.SNXT) SNXT=SP
C
   20 CONTINUE
C
      TH2=PAR(4)
      IBOUN=0
   30 CONTINUE
      IBOUN=IBOUN+1
C
      STH=SIN(TH2*DEGRAD)
      CTH=COS(TH2*DEGRAD)
      STH2=STH*STH
      CTH2=CTH*CTH
      AA=STH2*X(6)**2-CTH2*(X(4)**2+X(5)**2)
      BB=STH2*X(6)*X(3)-CTH2*(X(4)*X(1)+
     +X(5)*X(2))
      CC=STH2*X(3)**2-CTH2*(X(1)**2+X(2)**2)
      SQ=BB*BB-AA*CC
      IF(SQ.LT.0.0) GO TO 60
      ST=BIG
      IF(ABS(BB).GE.SMALL) ST=-CC*0.5/BB
      ITRY=1
      IF(AA.EQ.0.0) GO TO 45
      T2=SQRT(SQ)/AA
      ITRY=0
      T1=-BB/AA
   40 CONTINUE
      ST=T1+T2
   45 CONTINUE
      IF((X(3)+ST*X(6))*CTH.LT.0.0) GO TO 50
      IF(ST.GT.0.0.AND.ST.LT.SNXT) SNXT=ST
   50 CONTINUE
      IF(ITRY.NE.0) GO TO 60
      ITRY=1
      T2=-T2
      GO TO 40
   60 CONTINUE
      IF(IBOUN.NE.1) GO TO 999
      TH2=PAR(3)
      GO TO 30
C
   70 CONTINUE
C              THIS BIT FOR X,Y,Z=0,0,0
C
      SNXT=PAR(2)
C              WE HAVE IGNORED THETA AND PHI BUT USERS SHOULDN'T
C              USE THETA PHI SEGMENTATION AT R=0 ANYWAY.
C
  999 CONTINUE
      END
+DECK,  GNTRAP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GNTRAP (X, PAR, IACT, IFLAG, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      COMPUTE DISTANCE UP TO INTERSECTION WITH 'TRD1' OR 'TRD2' *
C.    *      VOLUME, FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)   *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       IFLAG (input)  : 1 for TRD1, 2 for TRD2                  *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson,  P.Weidhaas  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6),PAR(5)
C.
C.    ------------------------------------------------------------------
C.
      SNXT = BIG
      IF (IFLAG .EQ. 1) THEN
        FACTX  = (PAR(2) - PAR(1)) / (2.0 * PAR(4))
      ELSEIF (IFLAG .EQ. 2) THEN
        FACTX  = (PAR(2) - PAR(1)) / (2.0 * PAR(5))
        FACTY  = (PAR(4) - PAR(3)) / (2.0 * PAR(5))
      ENDIF

      IF (IACT .LT. 3) THEN

C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE' (P.Weidhaas)  |
C       -------------------------------------------------

        IF (IFLAG .EQ. 1) THEN
C*******************************************************
C
C......  Shape "TRD1":   only x varies with z.
C
C*******************************************************

          SAF2  = PAR(3) - ABS(X(2))
          SAF3  = PAR(4) - ABS(X(3))
C
C......  Distance alng x-direction to slanted wall.
C
          DISTX = PAR(1) + FACTX * (PAR(4) + X(3)) - ABS(X(1))
          SAF1  = DISTX / SQRT (1.0 + FACTX*FACTX)
        ELSE
C*******************************************************
C
C......  Shape "TRD2":   both x and y vary with z.
C
C*******************************************************
          SAF3  = PAR(5) - ABS(X(3))
C
C......  Distance along x-direction to slanted wall.
C
          DISTX = PAR(1) + FACTX * (PAR(5) + X(3)) - ABS(X(1))
          SAF1  = DISTX / SQRT (1.0 + FACTX*FACTX)
C
C......  Distance along y-direction to slanted wall.
C
          DISTY = PAR(3) + FACTY * (PAR(5) + X(3)) - ABS(X(2))
          SAF2  = DISTY / SQRT (1.0 + FACTY*FACTY)
        ENDIF

        SAFE  = MIN (SAF1, SAF2, SAF3)

        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------


      IF(IFLAG.NE.1) GO TO 20
C
C              Only x-thickness varies with z.
C
C
C              First check z.
C
      ZEND=PAR(4)
      IF(X(6).LT.0.0) ZEND=-ZEND
      IF(X(6).EQ.0.)GO TO 5
      SNXT=(ZEND-X(3))/X(6)
C
C              Now do Y.
C
   5  YEND=PAR(3)
      IF(X(5).LT.0.0) YEND=-YEND
      IF(X(5).EQ.0.)GO TO 7
      SN=(YEND-X(2))/X(5)
      IF(SN.LT.SNXT) SNXT=SN
C
C              Now do X.
C
   7  DXM=0.5*(PAR(1)+PAR(2))
      ANUM=DXM+FACTX*X(3)-X(1)
      DENO=X(4)-FACTX*X(6)
C
      IF(DENO.EQ.0.0) GO TO 10
      QUOT = ANUM/DENO
      IF(QUOT.LE.0.0.OR.QUOT.GT.SNXT) GO TO 10
      SNXT=QUOT
      GO TO 999
C
   10 CONTINUE
C
      ANUM=-FACTX*X(3)-X(1)-DXM
      DENO=FACTX*X(6)+X(4)
C
      IF(DENO.EQ.0.0) GO TO 999
      QUOT = ANUM/DENO
      IF(QUOT.GT.0.0.AND.QUOT.LT.SNXT) SNXT=QUOT
C
      GO TO 999
   20 CONTINUE
C
C              x- and y-thicknesses vary with z.
C
C
C              First check z
C
      ZEND=PAR(5)
      IF(X(6).LT.0.0) ZEND=-ZEND
      IF(X(6).EQ.0.)GO TO 25
      SNXT=(ZEND-X(3))/X(6)
C
C              Now do x.
C
  25  DXM=0.5*(PAR(1)+PAR(2))
      ANUM=DXM+FACTX*X(3)-X(1)
      DENO=X(4)-FACTX*X(6)
C
      IF(DENO.EQ.0.0) GO TO 40
      QUOT = ANUM/DENO
      IF(QUOT.LE.0.0.OR.QUOT.GT.SNXT) GO TO 40
      SNXT=QUOT
      GO TO 60
C
   40 CONTINUE
C
      ANUM=-FACTX*X(3)-X(1)-DXM
      DENO=FACTX*X(6)+X(4)
C
      IF(DENO.EQ.0.0) GO TO 60
      QUOT = ANUM/DENO
      IF(QUOT.GT.0.0.AND.QUOT.LT.SNXT) SNXT=QUOT
C
   60 CONTINUE
C
C             Now do y.
C
      DYM=0.5*(PAR(3)+PAR(4))
      ANUM=DYM+FACTY*X(3)-X(2)
      DENO=X(5)-FACTY*X(6)
C
      IF(DENO.EQ.0.0) GO TO 80
      QUOT = ANUM/DENO
      IF(QUOT.LE.0.0.OR.QUOT.GT.SNXT) GO TO 80
      SNXT=QUOT
      GO TO 999
C
   80 CONTINUE
C
      ANUM=-FACTY*X(3)-X(2)-DYM
      DENO=FACTY*X(6)+X(5)
C
      IF(DENO.EQ.0.0) GO TO 999
      QUOT = ANUM/DENO
      IF(QUOT.GT.0.0.AND.QUOT.LT.SNXT) SNXT=QUOT
C
  999 CONTINUE
      END
+DECK,  GNTRP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GNTRP (X, PAR, IACT, SNEXT, SNXT, SAFE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       COMPUTE DISTANCE UP TO INTERSECTION WITH 'TRAP' VOLUME,  *
C.    *       FROM INSIDE POINT X(1-3) ALONG DIRECTION X(4-6)          *
C.    *                                                                *
C.    *       PAR   (input)  : volume parameters                       *
C.    *       IACT  (input)  : action flag                             *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, and SNXT only if SNEXT .GT.new SAFE *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *       SNEXT (input)  : see IACT = 1                            *
C.    *       SNXT  (output) : distance to volume boundary             *
C.    *       SAFE  (output) : shortest distance to any boundary       *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION X(6), PAR(11)
+SELF, IF=SINGLE.
      DIMENSION XT(6), P(11)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION XT(6), P(11)
      DOUBLE PRECISION A,B,C,DSN,TOP1,TOP2,BOT1,BOT2
      DOUBLE PRECISION DX1,DX2,X1,X2,X3,DCX1,DCX2,DX,DY
      DOUBLE PRECISION SP1,SP2,DCX,DCY,TANG1,TANG2,A1,B1,A2,B2
      DOUBLE PRECISION XL1,XL2,XL3,XL4,CY,SY,SX,CX,C1,C2
      DOUBLE PRECISION TX,H0,DHDZ,CH
      DOUBLE PRECISION CHTAN,SHTAN
      DOUBLE PRECISION SN1,SN2,SN3,SN4,SN5,SN6,SN7,SN8,P15
+SELF.
C.
C.               --------------------------------------
C.
      SNXT = BIG
      SAFE = 0.0
      DO 1 I=1,6
   1  XT(I)=X(I)
      DO 2 I=1,11
   2  P(I)=PAR(I)

      P15=0.5/P(1)
      DHDZ=(P(4)-P(8))*P15

      IF (IACT .LT. 3) THEN


C       -------------------------------------------------
C       |  Compute safety-distance 'SAFE'  (McPherson)  |
C       -------------------------------------------------


C            CALCULATE RECTANGLE ON FACE AT Z=-DZ.

        DX1=P(4)*P(7)
        X1=-DX1-P(5)
        X2=DX1-P(6)
        IF(X2.GT.X1) X1=X2
        X2=-DX1+P(5)
        X3=DX1+P(6)
        IF(X3.LT.X2) X2=X3
        DCX1=(X1+X2)*0.5
        DX1=(X2-X1)*0.5
C
C            CALCULATE RECTANGLE ON FACE AT Z=DZ.
C
        DX2=P(8)*P(11)
        X1=-DX2-P(9)
        X2=DX2-P(10)
        IF(X2.GT.X1) X1=X2
        X2=-DX2+P(9)
        X3=DX2+P(10)
        IF(X3.LT.X2) X2=X3
        DCX2=(X1+X2)*0.5
        DX2=(X2-X1)*0.5

C
        TX=P(2)+(DCX2-DCX1)*P15
C
C            CALCULATE LOCAL RECTANGLE.
C
        SP1=(P(1)-XT(3))*P15
        SP2=(P(1)+XT(3))*P15
C
        DY=P(4)*SP1+P(8)*SP2
        DX=DX1*SP1+DX2*SP2
        DCX=(DCX1+DCX2)*0.5+TX*XT(3)
        DCY=P(3)*XT(3)
C
C            CHECK POINT IS INSIDE RECTANGLE.
C
        IF(ABS(XT(1)-DCX).GT.DX) GO TO 10
C
C            CALCULATE ANGLE OF YZ PLANES.
C
        TANG1=TX+(DX1-DX2)*P15
        TANG2=TX-(DX1-DX2)*P15
C
C            CALCULATE SAFETY FROM YZ PLANES.
C
        SAF1=(XT(1)-DCX+DX)/SQRT(1.0+TANG1*TANG1)
        SAF2=(DX-XT(1)+DCX)/SQRT(1.0+TANG2*TANG2)
C
C            CALCULATE ANGLE OF XZ PLANES.
C
        TANG1=P(3)+DHDZ
        TANG2=P(3)-DHDZ
C
C            CALCULATE SAFETY FROM XZ PLANES.
C
        SAF3=(XT(2)-DCY+DY)/SQRT(1.0+TANG1*TANG1)
        SAF4=(DY-XT(2)+DCY)/SQRT(1.0+TANG2*TANG2)
C
C            CALCULATE SAFETY FROM XY PLANES.
C
        SAF5=P(1)-ABS(XT(3))
C
C            OVERALL SAFETY.
C
        SAFE = MIN(SAF1,SAF2,SAF3,SAF4,SAF5)


        IF (IACT .EQ. 0) GO TO 999
        IF (IACT .EQ. 1) THEN
          IF (SNEXT .LT. SAFE) GO TO 999
        ENDIF
      ENDIF


   10 CONTINUE

C     ------------------------------------------------
C     |  Compute vector-distance 'SNXT' (McPherson)  |
C     ------------------------------------------------



C           FIRST FIND S TO Z LIMITS.

      SN1=BIG
      SN2=BIG
      SN3=BIG
      SN4=BIG
C
      IF(XT(6).EQ.0.0) GOTO 15
      SN1=(P(1)-XT(3))/XT(6)
      SN2=-(P(1)+XT(3))/XT(6)
      IF(SN1.GE.0.) GOTO 15
      SNX=SN1
      SN1=SN2
      SN2=SNX
15    CONTINUE
C
C           NOW Y LIMITS.
C
      H0=(P(4)+P(8))*0.5
C
      TOP1=H0-DHDZ*XT(3)
      TOP2=XT(2)-XT(3)*P(3)
      BOT1=XT(5)-XT(6)*P(3)
      BOT2=DHDZ*XT(6)
C
      IF(BOT1+BOT2.NE.0.0) SN3=(TOP1-TOP2)/(BOT1+BOT2)
      IF(BOT2-BOT1.NE.0.0) SN4=(TOP1+TOP2)/(BOT2-BOT1)
C
C           NOW X LIMTS.
C
      XL1=(P(5)+P(6)+P(9)+P(10))*0.25
      XL2=(P(5)-P(6)+P(9)-P(10))*0.25
      XL3=(P(5)+P(6)-P(9)-P(10))*0.25
      XL4=(P(5)-P(6)-P(9)+P(10))*0.25
C
      CY=XT(2)-XT(3)*P(3)
      SY=XT(5)-XT(6)*P(3)
      CH=H0-DHDZ*XT(3)
C
      A1=XL4*XT(6)*SY+XL3*XT(6)*XT(6)*DHDZ
      B1=XL4*(XT(6)*CY+XT(3)*SY)-XL3*XT(6)*(CH-XT(3)*DHDZ)-XL2*P(1)*SY-
     +XL1*XT(6)*DHDZ*P(1)
      C1=XL4*CY*XT(3)-XL3*XT(3)*CH-XL2*CY*P(1)+XL1*CH*P(1)
C
      CHTAN=(P(7)*P(4)+P(11)*P(8))*0.5
      SHTAN=-(P(7)*P(4)-P(11)*P(8))*P15
      CHTAN=CHTAN+SHTAN*XT(3)
      SHTAN=SHTAN*XT(6)
      CX=XT(1)-XT(3)*P(2)
      SX=XT(4)-XT(6)*P(2)
C
      A2=-P(1)*(DHDZ*XT(6)*SX+SY*SHTAN)
      B2=P(1)*(CH*SX-DHDZ*XT(6)*CX-CY*SHTAN-SY*CHTAN)
      C2=P(1)*(CH*CX-CY*CHTAN)
C
      ISN56=0
      A=A1+A2
      B=B1+B2
      C=C1+C2
      IF(B*B-A*C*4.0.LT.0.0) GO TO 20
      IF(ABS(A).LT.1.0E-7) GO TO 19
      DSN=SQRT(B*B-A*C*4.0)
      SN5=(-B+DSN)*0.5/A
      SN6=(-B-DSN)*0.5/A
      ISN56=1
      GO TO 20
   19 CONTINUE
      IF(ABS(B).LT.1.0E-5) GO TO 20
      ISN56=1
      SN5=-C/B
      SN6=-C/B
   20 CONTINUE
C
      ISN78=0
      A=A1-A2
      B=B1-B2
      C=C1-C2
      IF(B*B-A*C*4.0.LT.0.0) GO TO 30
      DSN=SQRT(B*B-A*C*4.0)
      IF(ABS(A).LT.1.0E-7) GO TO 25
      SN7=(-B+DSN)*0.5/A
      SN8=(-B-DSN)*0.5/A
      ISN78=1
      GO TO 30
   25 CONTINUE
      IF(ABS(B).LT.1.0E-5) GO TO 30
      ISN78=1
      SN7=-C/B
      SN8=-C/B
   30 CONTINUE
C
      IF(SN2.GT.0.0.AND.SN2.LT.SN1) SN1=SN2
      IF(SN3.GT.0.0.AND.SN3.LT.SN1) SN1=SN3
      IF(SN4.GT.0.0.AND.SN4.LT.SN1) SN1=SN4
      IF(ISN56.EQ.0) GO TO 40
      IF(SN5.GT.0.0.AND.SN5.LT.SN1) SN1=SN5
      IF(SN6.GT.0.0.AND.SN6.LT.SN1) SN1=SN6
   40 CONTINUE
      IF(ISN78.EQ.0) GO TO 50
      IF(SN7.GT.0.0.AND.SN7.LT.SN1) SN1=SN7
      IF(SN8.GT.0.0.AND.SN8.LT.SN1) SN1=SN8
   50 CONTINUE
C
      SNXT=SN1
C
  999 CONTINUE
      END
+DECK,  GNTUBE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GNTUBE(X,P,IACT,IFL,SNEXT,SNXT,SAFE)
C.    ******************************************************************
C.    *                                                                *
C.    *      Compute distance to intersection with boundary surface of *
C     *      volume TUBE or TUBS, from point X(1),X(2),X(3)  INSIDE    *
C     *      the volume along track with direction cosines X(4),X(5),  *
C     *      X(6)                                                      *
C.    *      P     (input)  : volume parameters                        *
C.    *      IACT  (input)  : action flag                              *
C.    *         = 0  Compute SAFE only                                 *
C.    *         = 1  Compute SAFE, compute SNXT only if SAFE.LT.SNEXT  *
C.    *         = 2  Compute both SAFE and SNXT                        *
C.    *         = 3  Compute SNXT only                                 *
C.    *      IFL   (input)  : 1 for TUBE, 2 for PHI segmented TUBE     *
C.    *      SNEXT (input)  : see IACT = 1                             *
C.    *      SNXT  (output) : distance to volume boundary along track  *
C.    *      SAFE  (output) : not larger than scalar distance to       *
C.    *                       volume boundaray                         *
C.    *      Called by : GNEXT, GNPCON, GTNEXT                         *
C.    *                                                                *
C.    *      Authors   : Michel Maire and Rolf Nierhaus    21-JUN-1990 *
C.    *                                                                *
C.    ******************************************************************
C.    *                                                                *
C.    * 'TUBE'    is a tube. It has 3 parameters, the inside radius,   *
C.    *           the outside radius and the half length in z.         *
C.    * 'TUBS'    is a phi segment of a  tube.  It has 5 parameters,   *
C.    *           the same  3 as  'TUBE' plus  the phi  limits.  The   *
C.    *           segment  starts at  the first  limit and  includes   *
C.    *           increasing phi  value up  to the  second limit  or   *
C.    *           that plus 360 degrees.                               *
C.    *                                                                *
C.    ******************************************************************
+CDE, GCONSP.
      DIMENSION X(6),P(5)
*
*     this part has to be moved outside the routine
      IF (IFL.EQ.2) THEN
         P4=P(4)*DEGRAD
         P5=P(5)*DEGRAD
         IF (P5.LT.P4) P5=P5+TWOPI
         C1=COS(P4)
         S1=SIN(P4)
         C2=COS(P5)
         S2=SIN(P5)
         FIO=0.5*(P5+P4)
         CFIO=COS(FIO)
         SFIO=SIN(FIO)
      END IF
*
      SNXT=1.E10
      R=SQRT(X(1)**2+X(2)**2)
*
*     Compute SAFE radius
      IF (IACT.LT.3) THEN
         SAF1=R-P(1)
         SAF2=P(2)-R
         SAF3=P(3)-ABS(X(3))
         SAF4=1.E10
         IF (IFL.EQ.2) THEN
            IF ((X(2)*CFIO-X(1)*SFIO).LE.0.) THEN
               SAF4=ABS(X(1)*S1-X(2)*C1)
            ELSE
               SAF4=ABS(X(1)*S2-X(2)*C2)
            END IF
         ENDIF
         SAFE=MIN(SAF1,SAF2,SAF3,SAF4)
         IF (IACT.EQ.0) GO TO 999
         IF (IACT.EQ.1.AND.SNEXT.LE.SAFE) GO TO 999
      END IF
*
*     Intersection with z-plane
      IF (X(6).GT.1.E-20) THEN
         SZ= (P(3)-X(3))/X(6)
      ELSEIF (X(6).LT.-1.E-20) THEN
         SZ=-(P(3)+X(3))/X(6)
      ELSE
         SZ=1.E10
      END IF
*
*     Intersection with cylinders
*     Intersection point (x,y,z)
*     (x,y,z) is on track :    x=X(1)+t*X(4)
*                              y=X(2)+t*X(5)
*                              z=X(3)+t*X(6)
*     (x,y,z) is on cylinder : x**2 + y**2 = R**2
*
*     (X(4)**2+X(5)**2)*t**2
*     +2.*(X(1)*X(4)+X(2)*X(5))*t
*     +X(1)**2+X(2)**2-R**2=0
*
      T1=X(4)**2+X(5)**2
      T2=(X(1)*X(4)+X(2)*X(5))
      T3=X(1)**2+X(2)**2
      IF (T1.LE.0.) THEN
*        track parallel to the z-axis
         SNXT=SZ
         GO TO 999
      ENDIF
      B=T2/T1
*
*     Intersection with inner cylinder
      IF (P(1).GT.0.) THEN
         C=(T3-P(1)**2)/T1
         D=B**2-C
         IF (D.GE.0.) THEN
            SR=-B-SQRT(D)
            IF (SR.GE.0.) GO TO 101
         END IF
      END IF
*     Intersection with outer cylinder
         C=(T3-P(2)**2)/T1
         D=MAX(B**2-C,0.)
         SR=-B+SQRT(D)
*
*     Intersection with phi-planes
*     x=r*cos(phi)=X(1)+t*X(4)
*     y=r*sin(phi)=X(2)+t*X(5)
*     z           =X(3)+t*X(6)
*     t=(X(2)*cos(phi)-X(1)*sin(phi))/(X(4)*sin(phi)-X(5)*cos(phi))
  101 SFI1=1.E10
      SFI2=1.E10
      IF (IFL.EQ.2) THEN
*        track not parallel to the phi1 plane ?
         UN=X(4)*S1-X(5)*C1
         IF (UN.NE.0.) THEN
            S=(X(2)*C1-X(1)*S1)/UN
            IF (S.GE.0.) THEN
               XI=X(1)+S*X(4)
               YI=X(2)+S*X(5)
               IF ((YI*CFIO-XI*SFIO).LE.0.) SFI1=S
            END IF
         END IF
*        track not parallel to the phi2 plane ?
         UN=X(4)*S2-X(5)*C2
         IF (UN.NE.0.) THEN
            S=(X(2)*C2-X(1)*S2)/UN
            IF (S.GE.0.) THEN
               XI=X(1)+S*X(4)
               YI=X(2)+S*X(5)
               IF ((YI*CFIO-XI*SFIO).GE.0.) SFI2=S
            END IF
         END IF
      END IF
*
      SNXT=MIN(SZ,SR,SFI1,SFI2)
  999 END
+DECK,  GPROTM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GPROTM(NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print rotation matrices structure JROTM       *
C.    *       NUMB     Rotation matrix number                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      IF (JROTM.LE.0)  GO TO 99
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,1000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = IQ(JROTM-2)
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
C
      IF(NUMB.GE.0) THEN
         WRITE (CHMAIL,1001)
         CALL GMAIL(0,1)
      ENDIF
C
      DO 30 I=N1,N2
      JR = LQ(JROTM-I)
      IF (JR.LE.0)   GO TO 30
C
      IFLAG = Q(JR+10)
      WRITE (CHMAIL,1002) I,(Q(JR+J),J = 1,9),IFLAG,(Q(JR+J),J = 11,16)
      CALL GMAIL(0,0)
   30 CONTINUE
C
 1000 FORMAT ('0',51('='),1X,'ROTATION MATRICES',2X,50('='))
 1001 FORMAT ('0','MATRIX',1X,'<',17('-'),' ROTATION MATRIX',1X,17('-')
     +,'>',' FLAG','  THET1','   PHI1','  THET2','   PHI2','  THET3'
     +,'   PHI3')
 1002 FORMAT (' ',I6,9F6.3,I5,6F7.2)
   99 RETURN
      END
+DECK,  GPROTX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GPROTX(NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print rotation matrices structure JROTM       *
C.    *       NUMB     Rotation matrix number                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *         Author  R.Brun  S.Giani *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      CHARACTER*32 CHLINE,CHSTRI(50)
C.
C.    ------------------------------------------------------------------
C.
      IF (JROTM.LE.0) GO TO 999
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = IQ(JROTM-2)
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
C
*      IF(NUMB.GE.0) THEN
*         WRITE (CHMAIL,1001)
*         CALL GMAIL(0,1)
*      ENDIF
C
      DO 10 I=N1,N2
         JR = LQ(JROTM-I)
         IF (JR.LE.0) GO TO 10
C
         IFLAG = Q(JR+10)
         CHLINE='Matrix Number='
         ILEN=LENOCC(CHLINE)+1
         CALL IZITOC(I,CHLINE(ILEN:))
         CHSTRI(1)=CHLINE
         CHLINE='RM(1,1)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+1),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+1)
         CHSTRI(2)=CHLINE
         CHLINE='RM(2,1)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+2),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+2)
         CHSTRI(3)=CHLINE
         CHLINE='RM(3,1)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+3),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+3)
         CHSTRI(4)=CHLINE
         CHLINE='RM(1,2)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+4),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+4)
         CHSTRI(5)=CHLINE
         CHLINE='RM(2,2)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+5),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+5)
         CHSTRI(6)=CHLINE
         CHLINE='RM(3,2)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+6),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+6)
         CHSTRI(7)=CHLINE
         CHLINE='RM(1,3)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+7),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+7)
         CHSTRI(8)=CHLINE
         CHLINE='RM(2,3)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+8),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+8)
         CHSTRI(9)=CHLINE
         CHLINE='RM(3,3)='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JR+9),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10200)Q(JR+9)
         CHSTRI(10)=CHLINE
         CHLINE='Iflag='
         ILEN=LENOCC(CHLINE)+1
         CALL IZITOC(IFLAG,CHLINE(ILEN:))
         CHSTRI(11)=CHLINE
         CHLINE='Theta1='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JR+11),CHLINE(ILEN:))
         CHSTRI(12)=CHLINE
         CHLINE='Phi1='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JR+12),CHLINE(ILEN:))
         CHSTRI(13)=CHLINE
         CHLINE='Theta2='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JR+13),CHLINE(ILEN:))
         CHSTRI(14)=CHLINE
         CHLINE='Phi2='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JR+14),CHLINE(ILEN:))
         CHSTRI(15)=CHLINE
         CHLINE='Theta3='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JR+15),CHLINE(ILEN:))
         CHSTRI(16)=CHLINE
         CHLINE='Phi3='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JR+16),CHLINE(ILEN:))
         CHSTRI(17)=CHLINE
         CALL IGMESS(17,CHSTRI,'PRINT','P')
*      WRITE (CHMAIL,1002) I,(Q(JR+J),J = 1,9),IFLAG,(Q(JR+J),J = 11,16)
*      CALL GMAIL(0,0)
   10 CONTINUE
C
10000 FORMAT ('0',51('='),1X,'ROTATION MATRICES',2X,50('='))
10100 FORMAT ('0','MATRIX',1X,'<',17('-'),' ROTATION MATRIX',1X,17('-')
     +,'>',' FLAG','  THET1','   PHI1','  THET2','   PHI2','  THET3'
     +,'   PHI3')
* 1002 FORMAT (' ',I6,9F6.3,I5,6F7.2)
10200 FORMAT (E12.5)
  999 END
+DECK,  GPSTAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GPSTAT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Print volume statistics                                  *
C.    *                                                                *
C.    *    ==>Called by : GLAST                                        *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
C.
C.      ---------------------------------------------------------------
C.
      IF(JGSTAT.LE.0)GO TO 999
      IF(NVOLUM.LE.0)GO TO 999
      WRITE(CHMAIL,10000)
      CALL GMAIL(3,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10200)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10300)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10400)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
C
      DO 10 I=1,NVOLUM
         JG=LQ(JGSTAT-I)
         IF(JG.GT.0) THEN
            WRITE(CHMAIL,10500)IQ(JVOLUM+I),(IQ(JG+J),J=1,9)
            CALL GMAIL(0,0)
         ENDIF
   10 CONTINUE
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,2)
C
10000 FORMAT(1X,122('*'))
10100 FORMAT (' *',120X,'*')
10200 FORMAT (' *',43X,
     +'V O L U M E    S T A T I S T I C S',43X,'*')
10300 FORMAT (      ' *',3X,'VOLUME','   *',
     +3X,'      GINVOL      ',2X,'*',
     +3X,'      GMEDIA      ',2X,'*',
     +3X,'      GTNEXT      ',2X,'*',
     +3X,'      GTMEDI      ',2X,'*',
     +2X,'NSTEPS',3X,'*')
10400 FORMAT (      ' *',3X,' NAME ','   *',
     +3X,'TOTAL ','  *   ','NLEVEL',2X,'*',
     +3X,'TOTAL ','  *   ','NLEVEL',2X,'*',
     +3X,'TOTAL ','  *   ','NLEVEL',2X,'*',
     +3X,'TOTAL ','  *   ','NLEVEL',2X,'*',
     +2X,'NLEVEL',3X,'*')
10500 FORMAT(1X,'*',4X,A4,4X,9('*',I10,1X),'*')
  999 END
+DECK,  GPVOLU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GPVOLU(NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print VOLUMES data structures JVOLUM          *
C.    *       NUMB     Volume number                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      COMMON/FMOTH/INGLOB,IVOMGL
      CHARACTER*4 ISHAP(30),NAME,MOTHER
      DIMENSION PAR(50),ATT(20)
      SAVE ISHAP
      DATA ISHAP/'BOX ','TRD1','TRD2','TRAP','TUBE','TUBS','CONE',
     +           'CONS','SPHE','PARA','PGON','PCON','ELTU','HYPE',
     +13*'    ', 'GTRA','CTUB','    '/
C.
C.    ------------------------------------------------------------------
      IF (JVOLUM.LE.0) GO TO 99
      IF (NUMB  .GT.0) GO TO 10
C
      WRITE (CHMAIL,1000)
      CALL GMAIL(0,0)
      WRITE (CHMAIL,1001)
      CALL GMAIL(0,1)
C
      N1     = 1
      N2     = NVOLUM
      GO TO 20
C
   10 WRITE (CHMAIL,1001)
      CALL GMAIL(0,1)
C
      N1     = NUMB
      N2     = NUMB
C
   20 DO 30 I=N1,N2
      JVO = LQ(JVOLUM-I)
      NIN=Q(JVO+3)
      IF (JVO.LE.0)   GO TO 30
C
      CALL UHTOC(IQ(JVOLUM+I),4,NAME,4)
      CALL GFMOTH(NAME,MOTHER,KONLY)
      JVOMOT=LQ(JVOLUM-IVOMGL)
      MNIN=Q(JVOMOT+3)
      IF(MNIN.LE.0)THEN
        NMBR=1
      ELSE
        JIN = LQ(JVOMOT-INGLOB)
        NMBR=Q(JIN+3)
      ENDIF

      IS   = Q(JVO+2)
      NMED = Q(JVO+4)
C
      CALL GFPARA(NAME,NMBR,1,NPAR,NATT,PAR,ATT)
      IEND10=10
      IF(NPAR.LT.IEND10)IEND10=NPAR
      WRITE(CHMAIL,1002)I,NAME,NMED,ISHAP(IS),NPAR,(PAR(J),J=1,IEND10)
      CALL GMAIL(0,0)
      DO 25 I10=11,NPAR,10
        IEND10=I10+9
        IF (NPAR.LT.IEND10) IEND10=NPAR
        WRITE (CHMAIL,1003) (PAR(J),J = I10,IEND10)
        CALL GMAIL(0,0)
   25 CONTINUE
   30 CONTINUE
C
 1000 FORMAT ('0',51('='),5X,' VOLUMES ',6X,50('='))
 1001 FORMAT ('0','VOLUME NAME  NUMED SHAPE NPAR  PARAMETERS')
 1002 FORMAT (' ',I6,1X,A4,2X,I3,3X,A4,I5,2X,10E10.3)
 1003 FORMAT (31X,10E10.3)
  99  END
+DECK,  GPVOLX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GPVOLX(NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print VOLUMES data structures JVOLUM          *
C.    *       NUMB     Volume number                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *         Author  R.Brun S.Giani ****                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      COMMON/FMOTH/INGLOB,IVOMGL
      CHARACTER*32 CHLINE,CHSTRI(50)
      CHARACTER*4 ISHAP(30),NAME,MOTHER
      DIMENSION PAR(50),ATT(20)
      SAVE ISHAP
      DATA ISHAP/'BOX ','TRD1','TRD2','TRAP','TUBE','TUBS','CONE',
     +           'CONS','SPHE','PARA','PGON','PCON','ELTU','HYPE',
     +13*'    ', 'GTRA','CTUB','    '/
C.
C.    ------------------------------------------------------------------
      IF (JVOLUM.LE.0) GO TO 999
      IF (NUMB  .GT.0) GO TO 10
C
      WRITE (CHMAIL,10000)
      CALL GMAIL(0,0)
      WRITE (CHMAIL,10100)
      CALL GMAIL(0,1)
C
      N1     = 1
      N2     = NVOLUM
      GO TO 20
C
*   10 WRITE (CHMAIL,1001)
*      CALL GMAIL(0,1)
   10 CONTINUE
C
      N1     = NUMB
      N2     = NUMB
C
   20 DO 40 I=N1,N2
         JVO = LQ(JVOLUM-I)
         IF (JVO.LE.0) GO TO 40
C
         CALL UHTOC(IQ(JVOLUM+I),4,NAME,4)
      CALL GFMOTH(NAME,MOTHER,KONLY)
      JVOMOT=LQ(JVOLUM-IVOMGL)
      MNIN=Q(JVOMOT+3)
      IF(MNIN.LE.0)THEN
        NMBR=1
      ELSE
        JIN = LQ(JVOMOT-INGLOB)
        NMBR=Q(JIN+3)
      ENDIF
         IS = Q(JVO+2)
         NMED = Q(JVO+4)
C
         CALL GFPARA(NAME,1,1,NPAR,NATT,PAR,ATT)
*      IEND10=10
*      IF(NPAR.LT.IEND10)IEND10=NPAR
*      WRITE(CHMAIL,1002)I,NAME,NMED,ISHAP(IS),NPAR,(PAR(J),J=1,IEND10)
*      CALL GMAIL(0,0)
         CHLINE='Volume Number='
         ILEN=LENOCC(CHLINE)+1
         CALL IZITOC(I,CHLINE(ILEN:))
         CHSTRI(1)=CHLINE
         CHLINE='Name='
         ILEN=LENOCC(CHLINE)+1
         CHLINE(ILEN:)=NAME
         CHSTRI(2)=CHLINE
         CHLINE='Nmed='
         ILEN=LENOCC(CHLINE)+1
         CALL IZITOC(NMED,CHLINE(ILEN:))
         CHSTRI(3)=CHLINE
         CHLINE='Shape='
         ILEN=LENOCC(CHLINE)+1
         CHLINE(ILEN:)=ISHAP(IS)
         CHSTRI(4)=CHLINE
         CHLINE='Npar='
         ILEN=LENOCC(CHLINE)+1
         CALL IZITOC(NPAR,CHLINE(ILEN:))
         CHSTRI(5)=CHLINE
         DO 30 JJ=1,NPAR
            CHLINE='Par('
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(JJ,CHLINE(ILEN:))
            ILEN=LENOCC(CHLINE)+1
            CHLINE(ILEN:)=')='
            ILEN=LENOCC(CHLINE)+1
*       CALL IZRTOC(PAR(JJ),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10300)PAR(JJ)
            CHSTRI(5+JJ)=CHLINE
   30    CONTINUE
         NLINE=5+NPAR
         CALL IGMESS(NLINE,CHSTRI,'PRINT','P')

*      DO 25 I10=11,NPAR,10
*        IEND10=I10+9
*        IF (NPAR.LT.IEND10) IEND10=NPAR
*        WRITE (CHMAIL,1003) (PAR(J),J = I10,IEND10)
*        CALL GMAIL(0,0)
*   25 CONTINUE
   40 CONTINUE
C
10000 FORMAT ('0',51('='),5X,' VOLUMES ',6X,50('='))
10100 FORMAT ('0','VOLUME NAME  NUMED SHAPE NPAR  PARAMETERS')
10200 FORMAT (' ',I6,1X,A4,2X,I3,3X,A4,I5,2X,10E10.3)
10300 FORMAT (E12.5)
  999 END
+DECK,  GRMTD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GRMTD(XMAS,IROT,XNEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE ROTATES A POINT IN XMAS FROM THE MASTER SYSTEM      *
C.    *    TO A NEW SYSTEM USING MATRIX # IROT.                        *
C.    *    RESULT IS RETURNED IN VECTOR XNEW.                          *
C.    *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      DIMENSION XMAS(3),XNEW(3)
C.
C.    ------------------------------------------------------------------
C.
      IF (IROT.GT.0) THEN
         JR = LQ(JROTM- IROT)
         XNEW(1) = XMAS(1)*Q(JR+1) + XMAS(2)*Q(JR+2) + XMAS(3)*Q(JR+3)
         XNEW(2) = XMAS(1)*Q(JR+4) + XMAS(2)*Q(JR+5) + XMAS(3)*Q(JR+6)
         XNEW(3) = XMAS(1)*Q(JR+7) + XMAS(2)*Q(JR+8) + XMAS(3)*Q(JR+9)
*
      ELSE
         XNEW(1) = XMAS(1)
         XNEW(2) = XMAS(2)
         XNEW(3) = XMAS(3)
*
      ENDIF
      END
+DECK,  GRMUL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GRMUL(RMAT,IROT,RMATN)
C.
C.    ******************************************************************
C.    *                                                                *
C     *      ROUTINE MULTIPLIES ROTATION MATRIX RMAT BY THE            *
C     *       IROT TH MATRIX IN THE GEANT ROTATION MATRIX BANK         *
C     *     TO PRODUCE THE MATRIX RMATN SUCH THAT RMATN IS             *
C     *       THE RESULT OF FIRST RMAT THEN IROT.                      *
C     *                                                                *
C.    *    ==>Called by : GTRMUL                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      DIMENSION RMAT(10),RMATN(10)
C.
C.    ------------------------------------------------------------------
C.
      IF(IROT.EQ.0) THEN
         DO 10 I=1,10
            RMATN(I)=RMAT(I)
   10    CONTINUE
      ELSE
         JR=LQ(JROTM-IROT)
         RMATN(10)=1.
         IF(RMAT(10).EQ.0.0) THEN
            DO 20 I=1,9
               RMATN(I)=Q(JR+I)
   20       CONTINUE
         ELSE
C
            DO 30 KO=1,9
               RMATN(KO)=0.0
C
               KO1=(KO-1)/3+1
               KO2=KO-(KO1-1)*3
C
               DO 30 IN=1,3
                  KI1=KO2+(IN-1)*3
                  KI2=IN+(KO1-1)*3
                  RMATN(KO)=RMATN(KO)+RMAT(KI1)*Q(JR+KI2)
   30       CONTINUE
         ENDIF
      ENDIF
      END
+DECK,  GROT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:54  cernlib
* Geant

      SUBROUTINE GROT(X,RMAT,XNEW)
C.
C.    ******************************************************************
C.    *                                                                *
C     *            ROUTINE TO ROTATE POINT X BY MATRIX RMAT TO         *
C     *            FORM POINT XNEW.                                    *
C     *                                                                *
C.    *    ==>Called by : GNEXT, GTNEXT                                *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),XNEW(3),RMAT(10)
C
      IF(RMAT(10).NE.0.0) THEN
         XNEW(1) = X(1)*RMAT(1) + X(2)*RMAT(2) + X(3)*RMAT(3)
         XNEW(2) = X(1)*RMAT(4) + X(2)*RMAT(5) + X(3)*RMAT(6)
         XNEW(3) = X(1)*RMAT(7) + X(2)*RMAT(8) + X(3)*RMAT(9)
*
      ELSE
         XNEW(1) = X(1)
         XNEW(2) = X(2)
         XNEW(3) = X(3)
*
      ENDIF
      END
+DECK,  GRPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GRPAR(SHAP,NP,P,NDIV,STEP,C0,IN,GP,NSP,SP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       ROUTINE TO COMPUTE RMIN AND RMAX FOR THE IN TH DIVISION  *
C.    *       OF NDIV DIVISIONS STARTING AT C0 WITH STEP OF STEP       *
C.    *       (FOR ISHAPE 5 & 6) AND TO INSERT THEM INTO THE SHAPE     *
C.    *       PARAMETER LIST FROM P OUTPUTING THE RESULT AS THE        *
C.    *       LIST SP.                                                 *
C.    *                                                                *
C.    *    ==>Called by : not used                                     *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
      DIMENSION P(3),SP(5),GP(5)
C.
C.    ------------------------------------------------------------------
C.
      ISH=SHAP
      IF(ISH.NE.5)GO TO 5
      NSP=3
      SP(3)=P(3)
      SP(2)=C0+STEP*IN
      SP(1)=SP(2)-STEP
      GO TO 99
C
   5  IF(ISH.LT.5.OR.ISH.GT.12) GO TO 90
      IF(ISH.EQ.10) GO TO 90
C
      NSP=NP
      DO 10 I=1,NP
  10  SP(I)=P(I)
C
      IF(ISH.GT.6.AND.ISH.NE.9) GO TO 20
      SP(2)=C0+STEP*IN
      SP(1)=SP(2)-STEP
      GO TO 99
C
   20 CONTINUE
C
      IF(ISH.GT.9) GO TO 30
C
      DR=(GP(3)-GP(2))/NDIV
      SP(3)=GP(2)+DR*IN
      SP(2)=SP(3)-DR
      DR=(GP(5)-GP(4))/NDIV
      SP(5)=GP(4)+DR*IN
      SP(4)=SP(5)-DR
      GO TO 99
C
   30 CONTINUE
C
C               POLYGONS AND POLYCONES.
C
      IPNZ=3
      IF(ISH.EQ.11) IPNZ=4
      NZ=GP(IPNZ)
C
      DO 40 IZ=1,NZ
C
      IPZ=IPNZ+IZ*3-2
      OR=GP(IPZ+1)
      ST=(GP(IPZ+2)-OR)/NDIV
      SP(IPZ+2)=OR+ST*IN
      SP(IPZ+1)=SP(IPZ+2)-ST
C
   40 CONTINUE
C
      GO TO 99
C
  90  CONTINUE
      WRITE(CHMAIL,1000) ISH
      CALL GMAIL(0,0)
C
 1000 FORMAT(' SHAPE #',I5,' AS A DIVISION IN R NOT YET IMPLEMENTED')
  99  RETURN
      END
+DECK,  GSAGTR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSAGTR(X,P,SAFETY,INSIDE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *              SUBROUTINE GSAGTR(X,P,SAFETY,INSIDE)              *
C.    *    Routine to cumpute the 'Safe' distance to nearest boundary  *
C.    *    of the general twisted trapezoid. Point is given in X(1-3), *
C.    *    parameters of trapezoid are in P, if INSIDE = 1 point is    *
C.    *    inside shape if 0 outside. 'SAFE' distance is returned in   *
C.    *    SAFETY.                                                     *
C.    *    I have not yet been able to come up with an exact           *
C.    *    computation of this. From the outside I use an exscribed    *
C.    *    cylinder with its axis as the line joining the centres of   *
C.    *    the trapezia at the ends. As far as I can see there is no   *
C.    *    straight forward way of finding a reliable conservative     *
C.    *    estimate from the inside; so I set SAFETY to 0.0 for all    *
C.    *    points inside the shape. The radius of the exscribed        *
C.    *    cylinder is given by the longest of the eight distances     *
C.    *    from the centre of the trapezium to each corner on each of  *
C.    *    the end faces.                                              *
C.    *        Called by : GSNGTR                                      *
C.    *            A.C.McPherson.      23rd April 1985.                *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),P(30)
C
      SAFETY=0.0
C
C                  Check if point is inside.
C
      IF(INSIDE.EQ.1) GO TO 999
C
C                  Compute radius of cylinder.
C
      RCYL=0.0
      DO 10 I=1,4
         I0=I*4+11
         RC2=(P(I0)+(P(I0+2)-P(13))*P(1))**2+
     +   (P(I0+1)+(P(I0+3)-P(14))*P(1))**2
         IF(RC2.GT.RCYL) RCYL=RC2
         RC2=(P(I0)-(P(I0+2)-P(13))*P(1))**2+
     +   (P(I0+1)-(P(I0+3)-P(14))*P(1))**2
         IF(RC2.GT.RCYL) RCYL=RC2
   10 CONTINUE
      IF(RC2.GT.0.0) RCYL=SQRT(RC2)
C
C                 The direction cosines of the axis of the cylinder
C                 are computed and the distance from the point to the
C                 axis is calculated from the cross product of these
C                 direction cosines with the vector from the origin to
C                 the point. The cross product of this cross product
C                 with the direction cosines gives the vector from the
C                 axis to the point. Subtracting this times the ratio
C                 (D-RCYL)/D where D is the distance of the point from
C                 the axis and RCYL is the radius of the cylinder gives
C                 the point on the cylinder nearest to the point. If
C                 this is outside the z range of the shape then the
C                 distance along the cylinder surface to the z limit is
C                 added in quadrature.
C
      IF(ABS(X(3)).GT.P(1)) SAFETY=ABS(X(3)-P(1))
      TTH2=P(13)**2+P(14)**2
      CTH2=1.0/(1.0+TTH2)
      DIR3=SQRT(CTH2)
      DIR1=P(13)*DIR3
      DIR2=P(14)*DIR3
      DX=DIR2*X(3)-DIR3*X(2)
      DY=DIR3*X(1)-DIR1*X(3)
      DZ=DIR1*X(2)-DIR2*X(1)
      D2=DX*DX+DY*DY+DZ*DZ
      IF(D2.LT.RCYL*RCYL) GO TO 999
C
C            Only Z component of vector is needed.
C
      DDZ=DX*DIR2-DY*DIR1
      D=SQRT(D2)
      Z=X(3)-DDZ*(D-RCYL)/D
      SAFETY=D-RCYL
      IF(ABS(Z).LT.P(1)) GO TO 999
      SAFETY=SQRT(SAFETY*SAFETY+(ABS(Z)-P(1))**2/CTH2)
  999 CONTINUE
      RETURN
      END
+DECK,  GSAPHI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSAPHI(V,PHIL,PHIH,SAF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *    Subroutine GSAPHI computes the 'safety radius' from the     *
C.    *    point V to phi limits PHIL and PHIH. The safety radius is   *
C.    *    returned in SAF.                                            *
C.    *       A.C.McPherson   5th Sept. 1984.                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
C
      DIMENSION V(3)
C
      R=V(1)**2+V(2)**2
      IF(R.GT.0.0) R=SQRT(R)
C
      PHL=PHIL*DEGRAD
      PHH=PHIH*DEGRAD
C
C              Check for case of complete 360 degree region.
C
      SAF=BIG
      DPHI=PHIH-PHIL
      IF(DPHI.LE.0.0) DPHI=DPHI+360.0
      IF(DPHI.GE.360.0) GO TO 10
C
      SAF=R
      SL=SIN(PHL)
      CL=COS(PHH)
      IF(SL*V(2)+CL*V(1).GT.0.0) SAF=ABS(SL*V(1)-CL*V(2))
C
      SAF2=R
      SH=SIN(PHH)
      CH=COS(PHH)
      IF(SH*V(2)+CH*V(1).GT.0.0) SAF2=ABS(SH*V(1)-CH*V(2))
C
      IF(SAF2.LT.SAF) SAF=SAF2
C
   10 CONTINUE
      RETURN
      END
+DECK,  GSATT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSATT(NAME,IAT,IVAL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        Set attribute IAT to the value IVAL                     *
C.    *        for the volume NAME                                     *
C.    *                                                                *
C.    *    1:  'WORK'   0=volume inactive   1=active volume            *
C.    *    2:  'SEEN'   0=unseen 1=seen -1,-2=tree unseen -3=tree opt. *
C.    *    3:  'LSTY'   line style 1,2,3,...                           *
C.    *    4:  'LWID'   line width 1,2,3,...                           *
C.    *    5:  'COLO'   color code 1,2,3,...                           *
C.    *    6:  'FILL'   fill area  0,1,2,...                           *
C.    *    7:  'SET '   set number associated to this volume           *
C.    *    8:  'DET '   detector number associated to this volume      *
C.    *    9:  'DTYP'   detector type (1,2)                            *
C.    *   10:  'NODE'   <>0=a node is created for 3D (PIONS,GMR,etc.)  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDPRTR,GDSPEC,GDTREE,GSDET, *
C.    *                   GSDETV,GSDVN,GSDVN2,GSDVT,GSDVT2,GSVOLU      *
C.    *         Author  R.Brun  S.Giani *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
      COMMON/DEFPAR/IATDEF,IVADEF
*
      CHARACTER*4 KATT(10),NAME,IAT,IATDEF
      DIMENSION LATT(10)
      SAVE KATT,IFIRST,LATT
      DATA KATT/'WORK','SEEN','LSTY','LWID','COLO','FILL','SET ',
     +'DET ','DTYP','NODE'/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
C              CHECK IF OPTION EXISTS
*
      IF(IAT.EQ.'DEFA')IAT=IATDEF
      IF(IVAL.EQ.10000)IVAL=IVADEF
C
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KATT,LATT,4,40)
      ENDIF
C
      IPN=5
      IPS=7
C
C              CHECK IF OPTION EXISTS
C
      CALL GLOOK(IAT,LATT,10,IOP)
      IF(IOP.GT.0)GO TO 10
      WRITE(CHMAIL,10100)IAT
      CALL GMAIL(0,0)
      GO TO 999
C              CHECK IF VOLUME EXISTS
C
   10 IF(JVOLUM.GT.0)GO TO 20
      WRITE(CHMAIL,10000)NAME
      CALL GMAIL(0,0)
      GO TO 999
C
   20 IF(NAME(1:1).EQ.'*')GO TO 40
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVOLU)
      IF(IVOLU.GT.0)GO TO 30
      WRITE(CHMAIL,10000)NAME
      CALL GMAIL(0,0)
      GO TO 999
C
   30 JVO=LQ(JVOLUM-IVOLU)
      NPAR=Q(JVO+IPN)
      Q(JVO+NPAR+IPS-1+IOP)=IVAL
      GO TO 999
C
C             SET OPTION VALUE FOR ALL DEFINED VOLUMES
C
   40 CONTINUE
      DO 50 I=1,NVOLUM
         JVO=LQ(JVOLUM-I)
         NPAR=Q(JVO+IPN)
         Q(JVO+NPAR+IPS-1+IOP)=IVAL
   50 CONTINUE
C
10000 FORMAT(' GSATT VOLUME ',A4,' DOES NOT EXIST ')
10100 FORMAT(' GSATT OPTION ',A4,' NOT IMPLEMENTED ')
  999 END
+DECK,  GSCHK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSCHK(NAME,KSHAPE,NPAR,ISHAPE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *           CHECK SHAPE PARAMETERS                               *
C.    *           RETURN SHAPE NUMBER CORRESPONDING TO 'KSHAPE'        *
C.    *                                                                *
C.    *    ==>Called by : GSVOLU                                       *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
      CHARACTER*4 NAME,KSHAP(30)
      CHARACTER*4    KSHAPE
      DIMENSION NPARS(30)
      SAVE KSHAP,NPARS
      DATA KSHAP/'BOX ','TRD1','TRD2','TRAP','TUBE','TUBS','CONE',
     +           'CONS','SPHE','PARA','PGON','PCON','ELTU','HYPE',
     + 13*'    ','GTRA','CTUB','    '/
      DATA NPARS/3,4,5,11,3,5,5,7,6,6,10,9,3,4,13*0,12,11,0/
C.
C.    ------------------------------------------------------------------
C.
      ISHAPE = 0
      DO 10 JSH=1, 30
         IF(KSHAPE.EQ.KSHAP(JSH)) THEN
            ISHAPE=JSH
            GOTO 20
         ENDIF
   10 CONTINUE
C
      WRITE(CHMAIL,10000)KSHAPE,NAME
      CALL GMAIL(1,0)
      GO TO 999
C
C              CHECK PARAMETERS
C
   20 IF(NPAR.LT.NPARS(ISHAPE).AND.NPAR.NE.0) THEN
C
         WRITE(CHMAIL,10100)KSHAPE,NAME,NPAR
         CALL GMAIL(1,0)
         ISHAPE=-1
         GO TO 999
      ENDIF
C
10000 FORMAT(' ***** SHAPE TYPE ',A4,' VOLUME ',A4,
     +       ' NOT VALID *****')
10100 FORMAT(' ***** SHAPE ',A4,' VOLUME ',A4,
     +       ' INCONSISTENT NUMBER OF PARAMETERS ',I5,'*****')
  999 END
+DECK,  GSCVOL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSCVOL
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO STORE THE RELEVANT CONTENTS OF THE COMMON BLOCK  *
C.    *    /GCVOLU/ IN THE COMMON /GCVOL2/                             *
C.    *    THE COMMON BLOCK CAN BE RELOADED FROM ARRAY BY THE ROUTINE  *
C.    *    GFCVOL.                                                     *
C.    *                                                                *
C.    *    ==>Called by : GDRAW,GDRVOL,GINVOL,GMEDIA,GTMEDI            *
C.    *         Authors : R.Brun, F.Bruyant  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCVOL2.
C.
C.          ----------------------------------------
C.
      NLEVE2 = NLEVEL
      IF (NLEVE2.LE.0) GO TO 99
*
      NLEVMX=IQ(LQ(JVOLUM)-1)
      IF (JGPAR2.EQ.0) THEN
         CALL MZBOOK (IXCONS, JGPAR2, JGPAR2, 1,'GPA2',
     +                                NLEVMX+1, 0, NLEVMX+1, 2, 0)
      ENDIF
*
      INFRO2 = INFROM
      IF(NLEVEL+1.GT.IQ(JGPAR2-1)) THEN
         CALL MZPUSH(IXCONS,JGPAR2,NLEVEL+1-IQ(JGPAR2-1),
     +                             NLEVEL+1-IQ(JGPAR2-1),' ')
      ENDIF
      DO 40 I = 1,NLEVEL
*
         NAMES2(I) = NAMES(I)
         NUMB2(I)  = NUMBER(I)
         LVOL2(I)  = LVOLUM(I)
         LIND2(I)  = LINDEX(I)
         GONLY2(I) = GONLY(I)
         NLDEV2(I) = NLDEV(I)
         LINMX2(I) = LINMX(I)
*
         DO 10 J = 1,3
            GTRAN2(J,I) = GTRAN(J,I)
   10    CONTINUE
*
         DO 20 J = 1,10
            GRMAT2(J,I) = GRMAT(J,I)
   20    CONTINUE
*
         IQ(JGPAR2+I) = IQ(JGPAR+I)
         LQ(JGPAR2-I) = LQ(JGPAR-I)
*
   40 CONTINUE
*                                                             END GSCVOL
   99 END
+DECK,  GSDVN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSDVN(KNAME,MOTHER,NDIV,IAXIS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine divides MOTHER into NDIV divisions called NAME   *
C.    *       along axis number IAXIS.                                 *
C.    *          JVO=Pointer to MOTHER volume                          *
C.    *          JDIV=LQ(JVO-1)                                        *
C.    *                                                                *
C.    *            Q(JDIV+1)=IAXIS                                     *
C.    *            Q(JDIV+2)=Volume number.                            *
C.    *            Q(JDIV+3)=NDIV                                      *
C.    *            Q(JDIV+4)=Lowest coord of slices.                   *
C.    *            Q(JDIV+5)=Step size in coordinates.                 *
C.    *                                                                *
C.    *    ==>Called by :  <USER>, GEDITV                              *
C.    *         Authors R.Brun,   A.McPherson  *********               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCSHNO.
      CHARACTER*4 KNAME,MOTHER
      DIMENSION PAR(50),PARM(50),ATT(20)
      SAVE ATT
      DATA ATT /1.,1.,1.,1.,1.,15*0./
C.
C.    ------------------------------------------------------------------
C.
C              Check if volume master bank exists.
C
      CALL UCTOH(KNAME,NAME,4,4)
      IF(JVOLUM.GT.0)GO TO 10
      WRITE(CHMAIL,1000)
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if MOTHER volume exists.
C
  10  CALL GLOOK(MOTHER,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.GT.0)GO TO 20
      WRITE(CHMAIL,1100)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if NAME volume exists.
C
  20  CALL GLOOK(KNAME,IQ(JVOLUM+1),NVOLUM,IN)
      IF(IN.LE.0)GO TO 50
      WRITE(CHMAIL,2000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if MOTHER is not divided.
C
  50  JVO=LQ(JVOLUM-IVO)
      NIN=Q(JVO+3)
      IF(NIN.EQ.0)GO TO 60
      WRITE(CHMAIL,4000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check validity of axis value.
C
  60  IF(IAXIS.GT.0.AND.IAXIS.LT.4)GO TO 70
      WRITE(CHMAIL,5000)IAXIS
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check validity of NDIV
C
  70  IF(NDIV.GT.0)GO TO 80
      WRITE(CHMAIL,6000)NDIV
      CALL GMAIL(0,0)
      GO TO 99
C
C               Create bank to store division parameters.
C
  80  CALL MZBOOK(IXCONS,JDIV,JVO,-1,'VODI',0,0,6,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JDIV-5)=IVO
C
C               Now store parameters into bank area.
C
  90  Q(JDIV+1)=IAXIS
      Q(JDIV+2)=NVOLUM+1
      Q(JDIV+3)=NDIV
      Q(JVO+3)=-1
      IVOM= IVO
      NWM = IQ(JVO-1)
      NW  = NWM
      ISH = Q(JVO+2)
C
C               Bit to allow division of objects defined
C               by GSPOSP.
C
      C0=0.0
      STEP=0.0
      NPAR=Q(JVO+5)
      NATT=Q(JVO+6)
      CALL UCOPY(Q(JVO+NPAR+7),ATT,NATT)
      IF(NPAR.LE.0) GO TO 230
C
      CALL GFIPAR(JVO,0,0,NPAR,NATT,PAR,ATT)
      CALL UCOPY(PAR,PARM,NPAR)
C
C              Find and store start and step.
C
      IF(ISH.NE.1) GO TO 100
C
C               Box.
C
      STEP=-1.0
      PAR(IAXIS)=-1.0
      IF(PARM(IAXIS).LT.0.0) GO TO 230
      C0  =-PARM(IAXIS)
      STEP=PARM(IAXIS)*2.0/NDIV
      PAR(IAXIS)=STEP/2.
      GO TO 230
C
  100 CONTINUE
      IF(ISH.NE.2) GO TO 110
C
C              Trapezoid with only X thickness varying with Z.
C
      IF(IAXIS.EQ.1) GO TO 900
      PAR(1)=-1.
      PAR(2)=-1.
      STEP=-1.0
      PAR(IAXIS+1)=-1.0
      IF(PARM(IAXIS+1).LT.0.0) GO TO 230
      C0  =-PARM(IAXIS+1)
      STEP=PARM(IAXIS+1)*2.0/NDIV
      PAR(IAXIS+1)=STEP/2.
      GO TO 230
C
  110 CONTINUE
      IF(ISH.NE.3) GO TO 120
C
C              Trapezoid with both X and Y thicknesses varying with
C              Z
C
      IF(IAXIS.NE.3) GO TO 900
      PAR(1)=-1.
      PAR(2)=-1.
      PAR(3)=-1.
      PAR(4)=-1.
      STEP=-1.0
      PAR(5)=-1.0
      IF(PARM(5).LT.0.0) GO TO 230
      C0  =-PARM(5)
      STEP=PARM(5)*2.0/NDIV
      PAR(5)=STEP/2.
      GO TO 230
C
  120 CONTINUE
      IF(ISH.NE.4) GO TO 125
      IF(IAXIS.NE.3) GO TO 126
      PAR(1)=-1.
      PAR(4)=-1.
      PAR(5)=-1.
      PAR(6)=-1.
      PAR(8)=-1.
      PAR(9)=-1.
      PAR(10)=-1.
      STEP=-1.0
      IF(PARM(1).LT.0.0) GO TO 230
      C0=-PARM(1)
      STEP=PARM(1)*2.0/NDIV
      PAR(1)=STEP*0.5
C
      GO TO 230
C
  126 IF(IAXIS.NE.2) GO TO 900
      IF(MOD(PARM(3),180.).EQ.0.) GO TO 127
      WRITE(CHMAIL,10100)
10100 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when PHI=0,180')
      CALL GMAIL(0,0)
      GOTO 99
  127 IF(PARM(4).EQ.PARM(8))  GO TO 128
      WRITE(CHMAIL,10200)
10200 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when H1=H2')
      CALL GMAIL(0,0)
      GOTO 99
  128 CONTINUE
      STEP = -1.
      IF(PARM(4).LT.0.0) GO TO 230
      C0=-PARM(4)
      STEPH = PARM(4)/NDIV
      PAR(4) = STEPH
      PAR(5) = -1.
      PAR(6) = -1.
      PAR(8) = STEPH
      PAR(9) = -1.
      PAR(10) = -1.
      STEP = 2.*STEPH
C
      GO TO 230
C
  125 CONTINUE
      IF(ISH.NE.5.AND.ISH.NE.6.AND.ISH.NE.NSCTUB) GO TO 160
C
C              Tube, tube segment or cut tube.
C
      IF(IAXIS.NE.3) GO TO 130
      STEP=-1.0
      PAR(3)=-1.0
      IF(PARM(3).LT.0.0) GO TO 230
      C0  =-PARM(3)
      STEP=PARM(3)*2.0/NDIV
      PAR(3)=STEP/2.
      GO TO 230
C
  130 CONTINUE
      IF(IAXIS.NE.1) GO TO 140
      PAR(1)=-1.
      PAR(2)=-1.
      STEP=-1.0
      IF(PARM(1).LT.0.0) GO TO 230
      C0  =PARM(1)
      IF(PARM(2).LT.0.0) GO TO 230
      STEP=(PARM(2)-PARM(1))/NDIV
      GO TO 230
C
  140 CONTINUE
      IF(ISH.EQ.6) GO TO 150
      NW=NW+2
      ISH=6
      C0  =0.0
      STEP=360.0/NDIV
      NPAR=5
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 230
C
  150 CONTINUE
      DP=PAR(5)-PAR(4)
      IF(DP.LT.0.0) DP=DP+360.0
      C0  =PAR(4)
      STEP=DP/NDIV
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 230
C
  160 CONTINUE
C
      IF(ISH.NE.7.AND.ISH.NE.8) GO TO 190
      IF(IAXIS.EQ.1) GO TO 165
      IF(IAXIS.NE.3) GO TO 170
C
      STEP=-1.0
      PAR(1)=-1.0
      IF(PARM(1).LT.0.0) GO TO 165
      C0=-PARM(1)
      STEP=PARM(1)*2.0/NDIV
      PAR(1)=STEP*0.5
C
  165 CONTINUE
C
      PAR(2)=-1.0
      PAR(3)=-1.0
      PAR(4)=-1.0
      PAR(5)=-1.0
      GO TO 230
C
  170 CONTINUE
      IF(IAXIS.EQ.1) GO TO 230
C
      IF(ISH.EQ.8) GO TO 180
      NW=NW+2
      ISH=8
      C0  =0.0
      STEP=360.0/NDIV
      NPAR=7
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 230
C
  180 CONTINUE
      DP=PAR(7)-PAR(6)
      IF(DP.LT.0.0) DP=DP+360.0
      C0  =PAR(6)
      STEP=DP/NDIV
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 230
C
  190 CONTINUE
      IF(ISH.NE.9) GO TO 200
      IF(IAXIS.NE.1) GO TO 195
      PAR(1)=-1.0
      PAR(2)=-1.0
      C0    = PARM(1)
      STEP = (PARM(2)-PARM(1))/NDIV
  195 CONTINUE
      IF(IAXIS.NE.2) GO TO 196
      WRITE(CHMAIL,8102)
      CALL GMAIL(0,0)
      GOTO 99
C
  196 CONTINUE
      IF(IAXIS.NE.3) GO TO 230
      C0=PAR(5)
      DP=PAR(6)-PAR(5)
      IF(DP.LE.0.0) DP=DP+360.0
      STEP=DP/NDIV
      PAR(3)=-1.
      PAR(4)=-1.
      PAR(5)=-0.5*STEP
      PAR(6)=0.5*STEP
      GO TO 230
C
  200 CONTINUE
C
      IF(ISH.NE.10) GO TO 210
C
C              Parallelipiped.
C
      C0  =-PAR(IAXIS)
      STEP=-2.0*C0/NDIV
      PAR(IAXIS)=STEP/2.
      GO TO 230
C
  210 CONTINUE
      IF(ISH.GT.12) GO TO 900
      IF(IAXIS.EQ.1) GO TO 230
      IF(IAXIS.EQ.2) GO TO 220
C
      IPNZ=4
      IF(ISH.EQ.12) IPNZ=3
      IF(PAR(IPNZ).NE.2) GO TO 910
C
      ZH=PAR(IPNZ+4)
      ZL=PAR(IPNZ+1)
      STEP=(ZH-ZL)/NDIV
      C0=ZL
      PAR(IPNZ+4)=STEP*0.5
      PAR(IPNZ+1)=-PAR(IPNZ+4)
      PAR(IPNZ+2)=-1.
      PAR(IPNZ+3)=-1.
      PAR(IPNZ+5)=-1.
      PAR(IPNZ+6)=-1.
C
      GO TO 230
  220 CONTINUE
C
      NDV=NDIV
      IF(ISH.EQ.11) NDV=PAR(3)
      Q(JDIV+3)=NDV
      C0=PAR(1)
      STEP=PAR(2)/NDV
      PAR(1)=-STEP*0.5
      PAR(2)=STEP
      IF(ISH.EQ.11)PAR(3)=1.
C
  230 CONTINUE
C
C                Now create the volume for division.
C
      Q(JDIV+4)=C0
      Q(JDIV+5)=STEP
      NVOLUM=NVOLUM+1
      NVOL  =IQ(JVOLUM-2)
      IF(NVOLUM.GT.NVOL)CALL MZPUSH(IXCONS,JVOLUM,50,50,'I')
      CALL MZBOOK(IXCONS,JVO,JVOLUM,-NVOLUM,'VOL1',50,50,NW,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JVOLUM+NVOLUM)=NAME
C
C              Copy parameters in data area.
C
      JVOM=LQ(JVOLUM-IVOM)
      CALL UCOPY(Q(JVOM+1),Q(JVO+1),NWM)
      IF(NPAR.GT.0) CALL GSIPAR(JVO,0,NPAR,NATT,PAR,ATT)
      Q(JVO+2)=ISH
      Q(JVO+3)=0.
      GO TO 99
C
  900 CONTINUE
C
C        Divide action not supported.
C
      WRITE(CHMAIL,8000)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,8001) ISH,IAXIS
      CALL GMAIL(0,0)
C
      GO TO 99
C
  910 CONTINUE
C
C          Trying to divide multi Z sector shape along Z.
C
      WRITE(CHMAIL,8100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,8101) ISH,IAXIS,IPNZ,INT(PAR(IPNZ))
      CALL GMAIL(0,0)
C
      GO TO 99
C
C              Not enough space.
C
  95  WRITE(CHMAIL,7000)NAME,MOTHER
      CALL GMAIL(0,0)
C
  99  CONTINUE
 1000 FORMAT(' ***** GSDVN CALLED AND NO VOLUMES DEFINED *****')
 1100 FORMAT(' ***** GSDVN MOTHER VOLUME ',A4,' DOES NOT EXIST *****')
 2000 FORMAT(' ***** GSDVN VOLUME ',A4,' ALREADY EXISTS *****')
 3000 FORMAT(' ***** GSDVN ROTATION MATRIX',I5,' DOES NOT EXISTS *****')
 4000 FORMAT(' ***** GSDVN MOTHER ',A4,' ALREADY DIVIDED *****')
 5000 FORMAT(' ***** GSDVN BAD AXIS VALUE ',I5,' *****')
 6000 FORMAT(' ***** GSDVN BAD NUMBER OF DIVISIONS ',I5,' *****')
 7000 FORMAT(' ***** GSDVN NOT ENOUGH SPACE TO STORE DIVISIONS ',
     +       ' IN ',A4,' *****')
 8000 FORMAT(' DIVIDE ACTION REQUESTED NOT SUPPORTED AT PRESENT.')
 8001 FORMAT(' ISH =',I5,' IAXIS =',I5)
 8100 FORMAT(' ATTEMPT TO DIVIDE MULTI Z SECTOR SHAPE ALONG Z.')
 8101 FORMAT(' ISH =',I5,' IAXIS =',I5,' NZ (THE',I3,'TH PAR) IS',I5)
 8102 FORMAT(' DIVISION OF A SPHERE ALONG AXIS 2 NOT SUPPORTED')
      END
+DECK,  GSDVN2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSDVN2(KNAME,MOTHER,NDIV,IAXIS,C0I,NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       DIVIDES MOTHER INTO NDIV DIVISIONS CALLED NAME           *
C.    *       ALONG AXIS IAXIS STARTING AT COORDINATE VALUE C0.        *
C.    *       THE NEW VOLUME CREATED WILL BE MEDIUM NUMBER NUMED.      *
C.    *                                                                *
C.    *          JVO=POINTER TO MOTHER VOLUME                          *
C.    *          JDIV=LQ(JVO-1)                                        *
C.    *                                                                *
C.    *            Q(JDIV+1)=IAXIS                                     *
C.    *            Q(JDIV+2)=VOLUME NUMBER                             *
C.    *            Q(JDIV+3)=NDIV                                      *
C.    *            Q(JDIV+4)=C0                                        *
C.    *            Q(JDIV+5)=STEP SIZE IN COORDINATES.                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GSDVX                                *
C.    *         Authors F.Bruyant,   A.McPherson  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCSHNO.
      CHARACTER*4 KNAME,MOTHER
      DIMENSION PAR(50),ATT(20)
      SAVE ATT
      DATA ATT /1.,1.,1.,1.,1.,15*0./
C.
C.    ------------------------------------------------------------------
C.
C              CHECK IF VOLUME MASTER BANK EXISTS
C
      CALL UCTOH(KNAME,NAME,4,4)
      IF(JVOLUM.GT.0)GO TO 10
      WRITE(CHMAIL,1000)
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF MOTHER VOLUME EXISTS
C
  10  CALL GLOOK(MOTHER,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.GT.0)GO TO 20
      WRITE(CHMAIL,2000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF NAME VOLUME EXISTS
C
  20  CALL GLOOK(KNAME,IQ(JVOLUM+1),NVOLUM,IN)
      IF(IN.LE.0)GO TO 50
      WRITE(CHMAIL,2000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF MOTHER IS NOT DIVIDED
C
  50  JVO=LQ(JVOLUM-IVO)
      NIN=Q(JVO+3)
      IF(NIN.EQ.0)GO TO 60
      WRITE(CHMAIL,4000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK VALIDITY OF AXIS VALUE
C
  60  IF(IAXIS.GT.0.AND.IAXIS.LT.4)GO TO 70
      WRITE(CHMAIL,5000)IAXIS
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK VALIDITY OF NDIV
C
  70  IF(NDIV.GT.0)GO TO 80
      WRITE(CHMAIL,6000)NDIV
      CALL GMAIL(0,0)
      GO TO 99
C
C               CREATE BANK TO STORE DIVISION PARAMETERS
C
  80  CALL MZBOOK(IXCONS,JDIV,JVO,-1,'VODI',0,0,6,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JDIV-5)=IVO
C
C               NOW STORE PARAMETERS INTO BANK AREA
C
  90  Q(JDIV+1)=IAXIS
      Q(JDIV+2)=NVOLUM+1
      Q(JDIV+3)=NDIV
      Q(JVO+3)=-1
      IVOM= IVO
      NWM = IQ(JVO-1)
      NW  = NWM
      CALL GFIPAR(JVO,0,0,NPAR,NATT,PAR,ATT)
C
C              CHECK START AND FIND AND STORE STEP.
C
      ISH=Q(JVO+2)
      C0 = C0I
      IF(ISH.NE.1) GO TO 100
C
C               BOX
C
      IF(PAR(IAXIS).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(IAXIS)) GO TO 910
      STEP=(PAR(IAXIS)-C0)/NDIV
      PAR(IAXIS)=STEP/2.
      GO TO 210
C
  100 CONTINUE
      IF(ISH.NE.2) GO TO 110
C
C              TRAPEZOID WITH ONLY X THICKNESS VARYING WITH Z.
C
      IF(IAXIS.EQ.1) GO TO 900
      IF(PAR(IAXIS+1).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(IAXIS+1)) GO TO 910
      STEP=(PAR(IAXIS+1)-C0)/NDIV
      PAR(1)=-1.
      PAR(2)=-1.
      PAR(IAXIS+1)=STEP/2.
      GO TO 210
C
  110 CONTINUE
      IF(ISH.NE.3) GO TO 120
C
C              TRAPEZOID WITH BOTH X AND Y THICKNESSES VARYING WITH
C              Z
C
      IF(IAXIS.NE.3) GO TO 900
      IF(PAR(5).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(5)) GO TO 910
      STEP=(PAR(5)-C0)/NDIV
      PAR(1)=-1.
      PAR(2)=-1.
      PAR(3)=-1.
      PAR(4)=-1.
      PAR(5)=STEP/2.
      GO TO 210
C
  120 CONTINUE
      IF(ISH.NE.4) GO TO 125
      IF(IAXIS.NE.3) GO TO 126
      IF(PAR(1).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(1)) GO TO 910
      STEP=(PAR(1)-C0)/NDIV
      PAR(1)=STEP*0.5
      PAR(4)=-1.0
      PAR(5)=-1.0
      PAR(6)=-1.0
      PAR(8)=-1.0
      PAR(9)=-1.0
      PAR(10)=-1.0
      GO TO 210
C
  126 IF(IAXIS.NE.2) GO TO 900
      IF(MOD(PAR(3),180.).EQ.0.) GO TO 127
      WRITE(CHMAIL,10100)
10100 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when PHI=0,180')
      CALL GMAIL(0,0)
      GOTO 99
  127 IF(PAR(4).EQ.PAR(8))  GO TO 128
      WRITE(CHMAIL,10200)
10200 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when H1=H2')
      CALL GMAIL(0,0)
      GOTO 99
  128 CONTINUE
      IF(PAR(4).LE.0.) GO TO 920
      IF(ABS(C0).GT.PAR(4)) GO TO 910
      STEP = (PAR(4)-C0)/NDIV
      PAR(4) = 0.5*STEP
      PAR(5) = -1.
      PAR(6) = -1.
      PAR(8) = 0.5*STEP
      PAR(9) = -1.
      PAR(10) = -1.
C
      GO TO 210
C
  125 CONTINUE
      IF(ISH.NE.5.AND.ISH.NE.6.AND.ISH.NE.NSCTUB) GO TO 160
C
C              Tube, tube segment or cut tube.
C
      IF(IAXIS.NE.3) GO TO 130
      IF(PAR(3).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(3)) GO TO 910
      STEP=(PAR(3)-C0)/NDIV
      PAR(3)=STEP/2.
      GO TO 210
C
  130 CONTINUE
      IF(IAXIS.NE.1) GO TO 140
      IF(PAR(1).LE.0.0.OR.PAR(2).LE.0.0) GO TO 920
      IF(C0.LT.PAR(1).OR.C0.GT.PAR(2)) GO TO 910
      STEP=(PAR(2)-C0)/NDIV
      PAR(1)=-1.
      PAR(2)=-1.
      GO TO 210
C
  140 CONTINUE
      IF(ISH.EQ.6) GO TO 150
      NW=NW+2
      ISH=6
      STEP=360.0/NDIV
      NPAR=5
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 210
C
  150 CONTINUE
      DP=PAR(5)-PAR(4)
      DC0P = C0-PAR(4)
      SG = SIGN(1.0,DC0P)
      DC0P = MOD( ABS(DC0P), 360.0)
      IF(SG.LE.0.0) DC0P = 360.0-DC0P
      C0 = PAR(4)+DC0P
      IF(C0-PAR(4).LT.0.0) C0=C0+360.0
      IF(C0-PAR(4).GT.DP) GO TO 910
      DP=PAR(5)-C0
      IF(DP.LT.0.0) DP=DP+360
      STEP=DP/NDIV
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 210
C
  160 CONTINUE
C
      IF(ISH.NE.7.AND.ISH.NE.8) GO TO 190
      IF(IAXIS.EQ.1) GO TO 165
      IF(IAXIS.NE.3) GO TO 170
C
      IF(PAR(1).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(1)) GO TO 910
      STEP=(PAR(1)-C0)/NDIV
      PAR(1)=STEP*0.5
C
  165 CONTINUE
C
      PAR(2)=-1.0
      PAR(3)=-1.0
      PAR(4)=-1.0
      PAR(5)=-1.0
      GO TO 210
C
  170 CONTINUE
      IF(IAXIS.EQ.1) GO TO 210
C
      IF(ISH.EQ.8) GO TO 180
      NW=NW+2
      ISH=8
      STEP=360.0/NDIV
      NPAR=7
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 210
C
  180 CONTINUE
      DP=PAR(7)-PAR(6)
      DC0P = C0-PAR(6)
      SG = SIGN(1.0,DC0P)
      DC0P = MOD( ABS(DC0P), 360.0)
      IF(SG.LE.0.0) DC0P = 360.0-DC0P
      C0 = PAR(6)+DC0P
      IF(C0-PAR(6).LT.0.0) C0=C0+360.0
      IF(C0-PAR(6).GT.DP) GO TO 910
      DP=PAR(7)-C0
      IF(DP.LT.0.0) DP=DP+360.0
      STEP=DP/NDIV
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 210
C
  190 CONTINUE
      IF(ISH.NE.9) GO TO 200
      IF(IAXIS.NE.1) GO TO 195
      PAR(1)=-1.0
      PAR(2)=-1.0
      IF(C0.LT.PAR(1).OR.C0.GT.PAR(2)) THEN
         GOTO 910
      ENDIF
      STEP = (PAR(2)-C0)/NDIV
      GOTO 210
  195 CONTINUE
      IF(IAXIS.NE.2) GO TO 196
      WRITE(CHMAIL,8102)
      CALL GMAIL(0,0)
      GOTO 99
C
  196 CONTINUE
      IF(IAXIS.NE.3) GO TO 210
      ANGMIN = MOD(PAR(5),360.)
      IF(ANGMIN.LT.0.) ANGMIN=ANGMIN+360.
      ANGMAX = MOD(PAR(6),360.)
      IF(ANGMAX.LE.ANGMIN) ANGMAX=ANGMAX+360.
      C0 = MOD(C0,360.)
      IF(C0.LT.0.0) C0=C0+360.0
      IF(C0.GT.ANGMAX.OR.C0.LT.ANGMIN) GO TO 910
      STEP=(ANGMAX-C0)/NDIV
      PAR(3)=-1.
      PAR(4)=-1.
      PAR(5)=-0.5*STEP
      PAR(6)=0.5*STEP
      GO TO 210
C
  200 CONTINUE
C
      GO TO 900
C
C                NOW CREATE THE VOLUME FOR DIVISION
C
 210  Q(JDIV+4)=C0
      Q(JDIV+5)=STEP
      NVOLUM=NVOLUM+1
      NVOL  =IQ(JVOLUM-2)
      IF(NVOLUM.GT.NVOL)CALL MZPUSH(IXCONS,JVOLUM,50,50,'I')
      CALL MZBOOK(IXCONS,JVO,JVOLUM,-NVOLUM,'VOL1',50,50,NW,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JVOLUM+NVOLUM)=NAME
C
C              COPY PARAMETERS IN DATA AREA
C
      JVOM=LQ(JVOLUM-IVOM)
      CALL UCOPY(Q(JVOM+1),Q(JVO+1),NWM)
      CALL GSIPAR(JVO,0,NPAR,NATT,PAR,ATT)
      Q(JVO+2)=ISH
      Q(JVO+3)=0.
      Q(JVO+4)=NUMED
      GO TO 99
C
  900 CONTINUE
C
C        DIVIDE ACTION NOT SUPPORTED.
C
      WRITE(CHMAIL,8000)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,8001) ISH,IAXIS
      CALL GMAIL(0,0)
C
      GO TO 99
C
  910 CONTINUE
C
C              C0 START OF DIVISION OUT OF OBJECT.
C
      WRITE(CHMAIL,9000) C0
      CALL GMAIL(0,0)
C
      GO TO 99
  920 CONTINUE
C
C              +VE DEFINITE PARAMETER IN DIMENSION OF C0 SET -VE OR 0.
C
      WRITE(CHMAIL,9010)
      CALL GMAIL(0,0)
C
      GO TO 99
C
C              NOT ENOUGH SPACE
C
  95  WRITE(CHMAIL,7000)NAME,MOTHER
      CALL GMAIL(0,0)
C
  99  CONTINUE
 1000 FORMAT(' ***** GSDVN2 CALLED AND NO VOLUMES DEFINED *****')
 2000 FORMAT(' ***** GSDVN2 VOLUME ',A4,' ALREADY EXISTS *****')
 3000 FORMAT(' ***** GSDVN2 ROTATION MATRIX',I5,' DOES NOT EXIST *****')
 4000 FORMAT(' ***** GSDVN2 MOTHER ',A4,' ALREADY DIVIDED *****')
 5000 FORMAT(' ***** GSDVN2 BAD AXIS VALUE ',I5,' *****')
 6000 FORMAT(' ***** GSDVN2 BAD NUMBER OF DIVISIONS ',I5,' *****')
 7000 FORMAT(' ***** GSDVN2 NOT ENOUGH SPACE TO STORE DIVISIONS ',
     +       ' IN ',A4,' *****')
 8000 FORMAT(' DIVIDE ACTION WITH C0 REQUESTED NOT SUPPORTED',
     +' AT PRESENT.')
 8001 FORMAT(' ISH =',I5,' IAXIS =',I5)
 8102 FORMAT(' DIVISION OF A SPHERE ALONG AXIS 2 NOT SUPPORTED')
 9000 FORMAT(' ***** GSDVN2 C0',E15.5,' OUT OF OBJECT *****')
 9010 FORMAT(' ***** GSDVN2 C0 WITH -VE DIMENSION IN MOTHER *****')
      END
+DECK,  GSDVS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSDVS(CHNAME,CHMOTH,STEP,IAXIS,NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    To be replaced in the future by GSDVT                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
      CHARACTER*4 CHNAME,CHMOTH
      WRITE(CHMAIL,
     +'('' *** GSDVS: Obsolete Routine -- Call GSDVT instead'')')
      CALL GMAIL(1,0)
      WRITE(CHMAIL,
     +'(''            This code will be removed from next version'')')
      CALL GMAIL(0,1)
      CALL GSDVT(CHNAME,CHMOTH,STEP,IAXIS,NUMED,0)
      END
+DECK,  GSDVS2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSDVS2(CHNAME,CHMOTH,STEP,IAXIS,C0,NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    To be replaced in the future by GSDVT2                      *
C.    *                                                                *
C.    ******************************************************************
+CDE, GCUNIT.
C.
      CHARACTER*4 CHNAME,CHMOTH
      WRITE(CHMAIL,
     +'('' *** GSDVS2: Obsolete Routine -- Call GSDVT2 instead'')')
      CALL GMAIL(1,0)
      WRITE(CHMAIL,
     +'(''            This code will be removed from next version'')')
      CALL GMAIL(0,1)
      CALL GSDVT2(CHNAME,CHMOTH,STEP,IAXIS,C0,NUMED,0)
      END
+DECK,  GSDVT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:55  cernlib
* Geant

      SUBROUTINE GSDVT (KNAME,MOTHER,STEP,IAXIS,NUMED,NDVMX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Divides MOTHER into divisions called NAME along          *
C.    *       axis IAXIS in steps of STEP. If not exactly divisible    *
C.    *       will make as many as possible and will centre them       *
C.    *       with respect to the mother. Divisions will have medium   *
C.    *       number NUMED. If NUMED is 0, NUMED of MOTHER is taken.   *
C.    *       NDVMX is the expected maximum number of divisions        *
C.    *          (If 0, no protection tests are performed)             *
C.    *                                                                *
C.    *          JVO=Pointer to MOTHER volume                          *
C.    *          JDIV=LQ(JVO-1)                                        *
C.    *                                                                *
C.    *            Q(JDIV+1)=IAXIS                                     *
C.    *            Q(JDIV+2)=Volume number.                            *
C.    *            Q(JDIV+3)=Number of divisions.                      *
C.    *            Q(JDIV+4)=Lowest coord of slices.                   *
C.    *            Q(JDIV+5)=STEP                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GSDVS                                *
C.    *         Authors F.Bruyant, M.Maire,  A.McPherson  *********    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCSHNO.
      CHARACTER*4 KNAME,MOTHER
      DIMENSION PAR(50),ATT(20)
      SAVE ATT
      DATA ATT/1.,1.,1.,1.,1.,15*0./
C.
C.    ------------------------------------------------------------------
C.
C              Check if volume master bank exists.
C
      CALL UCTOH(KNAME,NAME,4,4)
      IF(JVOLUM.GT.0)GO TO 10
      WRITE(CHMAIL,1000)
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if MOTHER volume exists.
C
  10  CALL GLOOK(MOTHER,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.GT.0)GO TO 20
      WRITE(CHMAIL,2000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if NAME volume exists.
C
  20  CALL GLOOK(KNAME,IQ(JVOLUM+1),NVOLUM,IN)
      IF(IN.LE.0)GO TO 50
      WRITE(CHMAIL,2000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if MOTHER is not divided.
C
  50  JVO=LQ(JVOLUM-IVO)
      NIN=Q(JVO+3)
      IF(NIN.EQ.0)GO TO 60
      WRITE(CHMAIL,4000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check validity of axis value.
C
  60  IF(IAXIS.GT.0.AND.IAXIS.LT.4)GO TO 70
      WRITE(CHMAIL,5000)IAXIS
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check validity of STEP
C
  70  IF(STEP.GT.0.0) GO TO 80
      WRITE(CHMAIL,6000)STEP
      CALL GMAIL(0,0)
      GO TO 99
C
C               Create bank to store division parameters.
C
  80  CALL MZBOOK(IXCONS,JDIV,JVO,-1,'VODI',0,0,6,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JDIV-5)=IVO
C
C               Now store parameters into bank area.
C
  90  Q(JDIV+1)=IAXIS
      Q(JDIV+2)=NVOLUM+1
      Q(JVO+3)=-1
      IVOM= IVO
      NWM = IQ(JVO-1)
      NW  = NWM
      ISH = Q(JVO+2)
C
C               Bit to allow division of objects defined
C               by GSPOSP.
C
      C0=0.0
      NDIV=0
      NPAR=Q(JVO+5)
      NATT=Q(JVO+6)
      CALL UCOPY(Q(JVO+NPAR+7),ATT,NATT)
C
      IF(NPAR.LE.0) GO TO 210
C
      CALL GFIPAR(JVO,0,0,NPAR,NATT,PAR,ATT)
C
C              Check STEP and find and store start and NDIV.
C
      IF(ISH.NE.1) GO TO 100
C
C               Box.
C
      IF(PAR(IAXIS).LT.0.0) GO TO 210
      NDIV=(PAR(IAXIS)*2.0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(IAXIS)=STEP/2.0
      C0=-STEP*NDIV/2.0
      GO TO 210
C
  100 CONTINUE
      IF(ISH.NE.2) GO TO 110
C
C              Trapezoid with only X thickness varying with Z.
C
      IF(IAXIS.EQ.1) GO TO 900
      PAR(1)=-1.
      PAR(2)=-1.
      IF(PAR(IAXIS+1).LT.0.0) GO TO 210
      NDIV=(PAR(IAXIS+1)*2.0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(IAXIS+1)=STEP/2.0
      C0=-STEP*NDIV/2.0
      GO TO 210
C
  110 CONTINUE
      IF(ISH.NE.3) GO TO 120
C
C              Trapezoid with both X and Y thicknesses varying with
C              Z.
C
      IF(IAXIS.NE.3) GO TO 900
      PAR(1)=-1.
      PAR(2)=-1.
      PAR(3)=-1.
      PAR(4)=-1.
      IF(PAR(5).LT.0.0) GO TO 210
      NDIV=(PAR(5)*2.0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(5)=STEP/2.0
      C0=-STEP*NDIV/2.0
      GO TO 210
C
  120 CONTINUE
      IF(ISH.NE.4) GO TO 125
      IF(IAXIS.NE.3) GO TO 126
      PAR(4)=-1.0
      PAR(5)=-1.0
      PAR(6)=-1.0
      PAR(8)=-1.0
      PAR(9)=-1.0
      PAR(10)=-1.0
      IF(PAR(1).LT.0.0) GO TO 210
      NDIV=(PAR(1)*2.0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(1)=STEP*0.5
      C0=-STEP*NDIV*0.5
      GO TO 210
C
  126 IF(IAXIS.NE.2) GO TO 900
      IF(MOD(PAR(3),180.).EQ.0.) GO TO 127
      WRITE(CHMAIL,10100)
10100 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when PHI=0,180')
      CALL GMAIL(0,0)
      GOTO 99
  127 IF(PAR(4).EQ.PAR(8))  GO TO 128
      WRITE(CHMAIL,10200)
10200 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when H1=H2')
      CALL GMAIL(0,0)
      GOTO 99
  128 CONTINUE
      PAR(5) = -1.
      PAR(6) = -1.
      PAR(9) = -1.
      PAR(10) = -1.
      IF(PAR(4).LT.0.0) GO TO 210
      NDIV = (2.*PAR(4)+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(4) = 0.5*STEP
      PAR(8) = 0.5*STEP
      C0=-STEP*NDIV*0.5
      GO TO 210
C
  125 CONTINUE
      IF(ISH.NE.5.AND.ISH.NE.6.AND.ISH.NE.NSCTUB) GO TO 160
C
C              Tube, tube segment or cut tube.
C
      IF(IAXIS.NE.3) GO TO 130
      IF(PAR(3).LT.0.0) GO TO 210
      NDIV=(PAR(3)*2.0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(3)=STEP/2.0
      C0=-STEP*NDIV/2.0
      GO TO 210
C
  130 CONTINUE
      IF(IAXIS.NE.1) GO TO 140
      PAR(1)=-1.
      PAR(2)=-1.
      IF(PAR(1).LT.0.0) GO TO 210
      IF(PAR(2).LT.0.0) GO TO 210
      NDIV=(PAR(2)-PAR(1)+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      C0=(PAR(2)+PAR(1)-STEP*NDIV)/2.0
      GO TO 210
C
  140 CONTINUE
      IF(ISH.EQ.6) GO TO 150
      NW=NW+2
      ISH=6
      NDIV=360.001/STEP
      IF (NDIV.LE.0) GO TO 910
      C0=0.0
      NPAR=5
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 210
C
  150 CONTINUE
      DP=PAR(5)-PAR(4)
      IF(DP.LT.0.0) DP=DP+360.0
      NDIV=(DP+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      C0=PAR(4)+(DP-STEP*NDIV)/2.0
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 210
C
  160 CONTINUE
C
      IF(ISH.NE.7.AND.ISH.NE.8) GO TO 190
      IF(IAXIS.EQ.1) GO TO 165
      IF(IAXIS.NE.3) GO TO 170
C
      IF(PAR(1).LT.0.0) GO TO 165
      NDIV=(PAR(1)*2.0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(1)=STEP/2.0
      C0=-STEP*NDIV/2.0
      PAR(1)=STEP*0.5
C
  165 CONTINUE
C
      PAR(2)=-1.0
      PAR(3)=-1.0
      PAR(4)=-1.0
      PAR(5)=-1.0
      GO TO 210
C
  170 CONTINUE
      IF(IAXIS.EQ.1) GO TO 210
C
      IF(ISH.EQ.8) GO TO 180
      NW=NW+2
      ISH=8
      C0  =0.0
      NDIV=360.001/STEP
      IF (NDIV.LE.0) GO TO 910
      NPAR=7
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 210
C
  180 CONTINUE
      DP=PAR(7)-PAR(6)
      IF(DP.LT.0.0) DP=DP+360.0
      NDIV=(DP+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      C0=PAR(6)+(DP-STEP*NDIV)/2.0
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 210
C
  190 CONTINUE
      IF(ISH.NE.9) GO TO 200
      IF(IAXIS.NE.1) GO TO 195
      PAR(1)=-1.0
      PAR(2)=-1.0
  195 CONTINUE
C
      IF(IAXIS.NE.3) GO TO 210
      DP=PAR(6)-PAR(5)
      IF(DP.LT.0.0) DP=DP+360.0
      NDIV=(DP+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      C0=PAR(5)+(DP-STEP*NDIV)/2.0
      PAR(3)=-1.
      PAR(4)=-1.
      PAR(5)=-0.5*STEP
      PAR(6)=0.5*STEP
      GO TO 210
C
  200 CONTINUE
C
      IF(ISH.NE.10) GO TO 900
C
C              Parallelipiped.
C
      C0  =-PAR(IAXIS)
      NDIV=(-C0*2.0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      C0=-STEP*NDIV/2.0
      PAR(IAXIS)=STEP/2.
C
      GO TO 210
C
C
C                Now create the volume for division.
C
 210  IF (NDVMX.NE.0) THEN
        IF (NDIV.EQ.0) NDIV=-NDVMX
        IF (NDIV.GT.NDVMX)  THEN
          WRITE (CHMAIL, 1210)
          CALL GMAIL(0,0)
 1210     FORMAT (' ***** GSDVT  MORE CELLS THAN EXPECTED MAXIMUM')
        ENDIF
      ENDIF
      Q(JDIV+4)=C0
      Q(JDIV+5)=STEP
      Q(JDIV+3)=NDIV
      NVOLUM=NVOLUM+1
      NVOL  =IQ(JVOLUM-2)
      IF(NVOLUM.GT.NVOL)CALL MZPUSH(IXCONS,JVOLUM,50,50,'I')
      CALL MZBOOK(IXCONS,JVO,JVOLUM,-NVOLUM,'VOL1',50,50,NW,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JVOLUM+NVOLUM)=NAME
C
C              Copy parameters in data area.
C
      JVOM=LQ(JVOLUM-IVOM)
      CALL UCOPY(Q(JVOM+1),Q(JVO+1),NWM)
      IF(NPAR.GT.0) CALL GSIPAR(JVO,0,NPAR,NATT,PAR,ATT)
      Q(JVO+2)=ISH
      Q(JVO+3)=0.
      IF (NUMED.GT.0) Q(JVO+4)=NUMED
      GO TO 99
C
  900 CONTINUE
C
C        Divide action not supported.
C
      WRITE(CHMAIL,8000)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,8001) ISH,IAXIS
      CALL GMAIL(0,0)
C
      GO TO 99
C
  910 CONTINUE
C
C           Step size too big.
C
      WRITE(CHMAIL,9000) STEP
      CALL GMAIL(0,0)
C
C              Not enough space.
C
  95  WRITE(CHMAIL,7000)NAME,MOTHER
      CALL GMAIL(0,0)
C
  99  CONTINUE
 1000 FORMAT(' ***** GSDVT  CALLED AND NO VOLUMES DEFINED *****')
 2000 FORMAT(' ***** GSDVT  VOLUME ',A4,' ALREADY EXISTS *****')
 3000 FORMAT(' ***** GSDVT  ROTATION MATRIX',I5,' DOES NOT EXIST *****')
 4000 FORMAT(' ***** GSDVT  MOTHER ',A4,' ALREADY DIVIDED *****')
 5000 FORMAT(' ***** GSDVT  BAD AXIS VALUE ',I5,' *****')
 6000 FORMAT(' ***** GSDVT  BAD STEP SIZE ',E15.5,' *****')
 7000 FORMAT(' ***** GSDVT  NOT ENOUGH SPACE TO STORE DIVISIONS ',
     +       ' IN ',A4,' *****')
 8000 FORMAT(' DIVIDE ACTION BY STEP REQUESTED NOT SUPPORTED ',
     +'AT PRESENT.')
 8001 FORMAT(' ISH =',I5,' IAXIS =',I5)
 9000 FORMAT(' ***** GSDVT  STEP SIZE',E15.5,' TOO BIG *****')
      END
+DECK,  GSDVT2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSDVT2(KNAME,MOTHER,STEP,IAXIS,C0,NUMED,NDVMX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Divides MOTHER into divisions called NAME along          *
C.    *        axis IAXIS starting at coordinate value C0 with step    *
C.    *        size STEP.                                              *
C.    *       The new volume created will have medium number NUMED.    *
C.    *       If NUMED is 0, NUMED of mother is taken.                 *
C.    *       NDVMX is the expected maximum number of divisions        *
C.    *         (If 0, no protection tests are performed)              *
C.    *                                                                *
C.    *          JVO=Pointer to MOTHER volume                          *
C.    *          JDIV=LQ(JVO-1)                                        *
C.    *                                                                *
C.    *            Q(JDIV+1)=IAXIS                                     *
C.    *            Q(JDIV+2)=Volume number                             *
C.    *            Q(JDIV+3)=Number of divisions.                      *
C.    *            Q(JDIV+4)=C0                                        *
C.    *            Q(JDIV+5)=STEP                                      *
C.    *                                                                *
C.    *    ==>Called by : ,USER., GSDVS2, GSDVX                        *
C.    *         Authors F.Bruyant, M.Maire,  A.McPherson  *********    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCSHNO.
      CHARACTER*4 KNAME,MOTHER
      DIMENSION PAR(50),ATT(20)
      SAVE ATT
      DATA ATT /1.,1.,1.,1.,1.,15*0./
C.
C.    ------------------------------------------------------------------
C.
C              CHECK IF VOLUME MASTER BANK EXISTS
C
      CALL UCTOH(KNAME,NAME,4,4)
      IF(JVOLUM.GT.0)GO TO 10
      WRITE(CHMAIL,1000)
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF MOTHER VOLUME EXISTS
C
  10  CALL GLOOK(MOTHER,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.GT.0)GO TO 20
      WRITE(CHMAIL,2000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF NAME VOLUME EXISTS
C
  20  CALL GLOOK(KNAME,IQ(JVOLUM+1),NVOLUM,IN)
      IF(IN.LE.0)GO TO 50
      WRITE(CHMAIL,2000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF MOTHER IS NOT DIVIDED
C
  50  JVO=LQ(JVOLUM-IVO)
      NIN=Q(JVO+3)
      IF(NIN.EQ.0)GO TO 60
      WRITE(CHMAIL,4000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK VALIDITY OF AXIS VALUE
C
  60  IF(IAXIS.GT.0.AND.IAXIS.LT.4)GO TO 70
      WRITE(CHMAIL,5000)IAXIS
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK VALIDITY OF STEP
C
  70  IF(STEP.GT.0.0)GO TO 80
      WRITE(CHMAIL,6000)STEP
      CALL GMAIL(0,0)
      GO TO 99
C
C               CREATE BANK TO STORE DIVISION PARAMETERS
C
  80  CALL MZBOOK(IXCONS,JDIV,JVO,-1,'VODI',0,0,6,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JDIV-5)=IVO
C
C               NOW STORE PARAMETERS INTO BANK AREA
C
  90  Q(JDIV+1)=IAXIS
      Q(JDIV+2)=NVOLUM+1
      Q(JVO+3)=-1
      IVOM= IVO
      NWM = IQ(JVO-1)
      NW  = NWM
      CALL GFIPAR(JVO,0,0,NPAR,NATT,PAR,ATT)
C
C              CHECK START AND STEP AND FIND AND STORE NDIV.
C
      ISH=Q(JVO+2)
      IF(ISH.NE.1) GO TO 100
C
C               BOX
C
      IF(PAR(IAXIS).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(IAXIS)) GO TO 910
      NDIV=(PAR(IAXIS)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(IAXIS)=STEP/2.
      GO TO 210
C
  100 CONTINUE
      IF(ISH.NE.2) GO TO 110
C
C              TRAPEZOID WITH ONLY X THICKNESS VARYING WITH Z.
C
      IF(IAXIS.EQ.1) GO TO 900
      IF(PAR(IAXIS+1).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(IAXIS+1)) GO TO 910
      NDIV=(PAR(IAXIS+1)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(1)=-1.
      PAR(2)=-1.
      PAR(IAXIS+1)=STEP/2.
      GO TO 210
C
  110 CONTINUE
      IF(ISH.NE.3) GO TO 120
C
C              TRAPEZOID WITH BOTH X AND Y THICKNESSES VARYING WITH
C              Z
C
      IF(IAXIS.NE.3) GO TO 900
      IF(PAR(5).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(5)) GO TO 910
      NDIV=(PAR(5)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(1)=-1.
      PAR(2)=-1.
      PAR(3)=-1.
      PAR(4)=-1.
      PAR(5)=STEP/2.
      GO TO 210
C
  120 CONTINUE
      IF(ISH.NE.4) GO TO 125
      IF(IAXIS.NE.3) GO TO 126
      IF(PAR(1).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(1)) GO TO 910
      NDIV=(PAR(1)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(1)=STEP*0.5
      PAR(4)=-1.0
      PAR(5)=-1.0
      PAR(6)=-1.0
      PAR(8)=-1.0
      PAR(9)=-1.0
      PAR(10)=-1.0
      GO TO 210
C
  126 IF(IAXIS.NE.2) GO TO 900
      IF(MOD(PAR(3),180.).EQ.0.) GO TO 127
      WRITE(CHMAIL,10100)
10100 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when PHI=0,180')
      CALL GMAIL(0,0)
      GOTO 99
  127 IF(PAR(4).EQ.PAR(8))  GO TO 128
      WRITE(CHMAIL,10200)
10200 FORMAT(' Division of TRAP ',A4,
     +    ' along Y only possible when H1=H2')
      CALL GMAIL(0,0)
      GOTO 99
  128 CONTINUE
      IF(PAR(4).LT.0.0) GO TO 920
      IF(ABS(C0).GE.PAR(4)) GO TO 910
      NDIV = (PAR(4)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(4) = 0.5*STEP
      PAR(5) = -1.
      PAR(6) = -1.
      PAR(8) = 0.5*STEP
      PAR(9) = -1.
      PAR(10) = -1.
C
      GO TO 210
C
  125 CONTINUE
      IF(ISH.NE.5.AND.ISH.NE.6.AND.ISH.NE.NSCTUB) GO TO 160
C
C              Tube, tube segment or cut tube.
C
      IF(IAXIS.NE.3) GO TO 130
      IF(PAR(3).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(3)) GO TO 910
      NDIV=(PAR(3)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(3)=STEP/2.
      GO TO 210
C
  130 CONTINUE
      IF(IAXIS.NE.1) GO TO 140
      IF(PAR(1).LE.0.0.OR.PAR(2).LE.0.0) GO TO 920
      IF(C0.LT.PAR(1)) GO TO 910
      NDIV=(PAR(2)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(1)=-1.
      PAR(2)=-1.
      GO TO 210
C
  140 CONTINUE
      IF(ISH.EQ.6) GO TO 150
      NW=NW+2
      ISH=6
      NDIV=360.001/STEP
      IF (NDIV.LE.0) GO TO 910
      NPAR=5
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 210
C
  150 CONTINUE
      DP=PAR(5)-PAR(4)
      DC0P = C0-PAR(4)
      SG = SIGN(1.0,DC0P)
      DC0P = MOD( ABS(DC0P), 360.0)
      IF(SG.LE.0.0) DC0P = 360.0-DC0P
      C0 = PAR(4)+DC0P
      IF(C0-PAR(4).LT.0.0) C0=C0+360.0
      IF(C0-PAR(4).GT.DP) GO TO 910
      DP=PAR(5)-C0
      IF(DP.LT.0.0) DP=DP+360
      NDIV=(DP+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(4)=-STEP/2.
      PAR(5)=STEP/2.
      GO TO 210
C
  160 CONTINUE
C
      IF(ISH.NE.7.AND.ISH.NE.8) GO TO 190
      IF(IAXIS.EQ.1) GO TO 165
      IF(IAXIS.NE.3) GO TO 170
C
      IF(PAR(1).LE.0.0) GO TO 920
      IF(ABS(C0).GT.PAR(1)) GO TO 910
      NDIV=(PAR(1)-C0+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(1)=STEP*0.5
C
  165 CONTINUE
C
      PAR(2)=-1.0
      PAR(3)=-1.0
      PAR(4)=-1.0
      PAR(5)=-1.0
      GO TO 210
C
  170 CONTINUE
      IF(IAXIS.EQ.1) GO TO 210
C
      IF(ISH.EQ.8) GO TO 180
      NW=NW+2
      ISH=8
      NDIV=360.001/STEP
      IF (NDIV.LE.0) GO TO 910
      NPAR=7
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 210
C
  180 CONTINUE
      DP=PAR(7)-PAR(6)
      DC0P = C0-PAR(6)
      SG = SIGN(1.0,DC0P)
      DC0P = MOD( ABS(DC0P), 360.0)
      IF(SG.LE.0.0) DC0P = 360.0-DC0P
      C0 = PAR(6)+DC0P
      IF(C0-PAR(6).LT.0.0) C0=C0+360.0
      IF(C0-PAR(6).GT.DP) GO TO 910
      DP=PAR(7)-C0
      IF(DP.LT.0.0) DP=DP+360.0
      NDIV=(DP+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(6)=-STEP/2.
      PAR(7)=STEP/2.
      GO TO 210
C
  190 CONTINUE
      IF(ISH.NE.9) GO TO 200
      IF(IAXIS.NE.1) GO TO 195
      PAR(1)=-1.0
      PAR(2)=-1.0
  195 CONTINUE
C
      IF(IAXIS.NE.3) GO TO 210
      DP=PAR(6)-PAR(5)
      DC0P = C0-PAR(4)
      SG = SIGN(1.0,DC0P)
      DC0P = MOD( ABS(DC0P), 360.0)
      IF(SG.LE.0.0) DC0P = 360.0-DC0P
      C0 = PAR(4)+DC0P
      IF(C0.LT.PAR(5)) C0=C0+360.0
      IF(C0-PAR(5).GT.DP) GO TO 910
      DP=PAR(6)-C0
      IF(DP.LT.0.0) DP=DP+360
      NDIV=(DP+0.001)/STEP
      IF (NDIV.LE.0) GO TO 910
      PAR(3)=-1.
      PAR(4)=-1.
      PAR(5)=-0.5*STEP
      PAR(6)=0.5*STEP
      GO TO 210
C
  200 CONTINUE
C
      GO TO 900
C
C                NOW CREATE THE VOLUME FOR DIVISION
C
 210  IF (NDVMX.GT.0) THEN
         IF (NDIV.GT.NDVMX) THEN
            WRITE (CHMAIL, 1210) NDIV,NDVMX
            CALL GMAIL(0,0)
 1210    FORMAT (' GSDVT2 : NDIV gt NDVMX', 2I8,'  truncated')
            NDIV = NDVMX
        ENDIF
      ELSE IF (NDVMX.LT.0) THEN
*       Case when called by GSDVX
         IF (NDIV.GT.-NDVMX) NDIV = -NDVMX
      ENDIF
      Q(JDIV+4)=C0
      Q(JDIV+5)=STEP
      Q(JDIV+3)=NDIV
      NVOLUM=NVOLUM+1
      NVOL  =IQ(JVOLUM-2)
      IF(NVOLUM.GT.NVOL)CALL MZPUSH(IXCONS,JVOLUM,50,50,'I')
      CALL MZBOOK(IXCONS,JVO,JVOLUM,-NVOLUM,'VOL1',50,50,NW,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JVOLUM+NVOLUM)=NAME
C
C              COPY PARAMETERS IN DATA AREA
C
      JVOM=LQ(JVOLUM-IVOM)
      CALL UCOPY(Q(JVOM+1),Q(JVO+1),NWM)
      CALL GSIPAR(JVO,0,NPAR,NATT,PAR,ATT)
      Q(JVO+2)=ISH
      Q(JVO+3)=0.
      IF (NUMED.GT.0) Q(JVO+4)=NUMED
      GO TO 99
C
  900 CONTINUE
C
C        DIVIDE ACTION NOT SUPPORTED.
C
      WRITE(CHMAIL,8000)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,8001) ISH,IAXIS
      CALL GMAIL(0,0)
C
      GO TO 99
C
  910 CONTINUE
C
C              C0 START OF DIVISION OUT OF OBJECT OR STEP SIZE TOO BIG.
C
      WRITE(CHMAIL,9000) C0,STEP
      CALL GMAIL(0,0)
C
      GO TO 99
  920 CONTINUE
C
C              +VE DEFINITE PARAMETER IN DIMENSION OF C0 SET -VE OR 0.
C
      WRITE(CHMAIL,9010)
      CALL GMAIL(0,0)
C
      GO TO 99
C
C              NOT ENOUGH SPACE
C
  95  WRITE(CHMAIL,7000)NAME,MOTHER
      CALL GMAIL(0,0)
C
  99  CONTINUE
 1000 FORMAT(' ***** GSDVT2 CALLED AND NO VOLUMES DEFINED *****')
 2000 FORMAT(' ***** GSDVT2 VOLUME ',A4,' ALREADY EXISTS *****')
 3000 FORMAT(' ***** GSDVT2 ROTATION MATRIX',I5,' DOES NOT EXIST *****')
 4000 FORMAT(' ***** GSDVT2 MOTHER ',A4,' ALREADY DIVIDED *****')
 5000 FORMAT(' ***** GSDVT2 BAD AXIS VALUE ',I5,' *****')
 6000 FORMAT(' ***** GSDVT2 BAD STEP SIZE ',E15.5,' *****')
 7000 FORMAT(' ***** GSDVT2 NOT ENOUGH SPACE TO STORE DIVISIONS ',
     +       ' IN ',A4,' *****')
 8000 FORMAT(' DIVIDE ACTION WITH C0 REQUESTED NOT SUPPORTED',
     +' AT PRESENT.')
 8001 FORMAT(' ISH =',I5,' IAXIS =',I5)
 9000 FORMAT(' ***** GSDVT2 C0',E15.5,' OUT OF OBJECT',
     +' OR STEP',E15.5,' TOO BIG *****')
 9010 FORMAT(' ATTEMPT TO SPECIFY C0 WHEN APPROPRIATE DIMENSION',
     +' OF THE MOTHER IS DEFINED -VE (TO BE SELECTED AT RUN TIME)')
      END
+DECK,  GSDVX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSDVX (NAME,MOTHER,NDIV,IAXIS,STEP,C0,NUMED
     +                  ,NDVMX)
C.
C.    *******************************************************
C.    *                                                     *
C.    * DIVIDES MOTHER INTO 'NDIV' DIVISIONS OF SIZE 'STEP' *
C.    * ALONG AXIS 'IAXIS' STARTING AT COORDINATE 'C0'.     *
C.    *  NDIV OR STEP CAN BE SET NEGATIVE OR ZERO, IN WHICH *
C.    * CASE THEY ARE RECOMPUTED FROM THE MOTHER'S SIZE.    *
C.    *                                                     *
C.    *    ==>Called by : 'USER'                            *
C.    *    Authors   F.Bruyant, B.Stoer  ********           *
C.    *                                                     *
C.    *******************************************************
C.
+CDE, GCFLAG.
+CDE, GCUNIT.
      CHARACTER*4 NAME,MOTHER
C.    -------------------------------------------------------
*
      IF (NDIV.GT.0) THEN
         IF (STEP.GT.0.) THEN
            CALL GSDVT2 (NAME, MOTHER, STEP, IAXIS, C0, NUMED, -NDIV)
         ELSE
            CALL GSDVN2 (NAME, MOTHER, NDIV, IAXIS, C0, NUMED)
         ENDIF
      ELSE
         IF (STEP.GT.0.) THEN
            CALL GSDVT2 (NAME, MOTHER, STEP, IAXIS, C0, NUMED, NDVMX)
         ELSE
            WRITE (CHMAIL, 1001)
            CALL GMAIL (0, 0)
            IEORUN = 1
         ENDIF
      ENDIF
*
 1001 FORMAT (' GSDVX : Call with NDIV and STEP .le. 0')
      END
+DECK,  GSIPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSIPAR(JVO,JIN,NPAR,NATT,PAR,ATT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO SET INTERNAL PARAMETERS AND ATTRIBUTES.          *
C.    *                                                                *
C.    *    ==>Called by : GSDVN,GSDVN2,GSDVT,GSDVT2,GSVOLU             *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION PAR(50),ATT(20)
C.
C.              --------------------------------------------
C.
      IF(NPAR.LT.0.OR.NPAR.GT.50) GO TO 900
      IF(NATT.LE.0.OR.NATT.GT.20) GO TO 900
C
      IF(JVO.LE.0) GO TO 910
      IF(JIN.GT.0) GO TO 10
C
      Q(JVO+5)=NPAR
      Q(JVO+6)=NATT
      JPAR=JVO+7
      JATT=JVO+7+NPAR
C
      GO TO 20
   10 CONTINUE
C
      JPAR=JIN+9
      Q(JPAR)=NPAR
      Q(JVO+5)=0
      Q(JVO+6)=NATT
      JPAR=JPAR+1
      JATT=JVO+7
C
   20 CONTINUE
C
      CALL UCOPY(PAR,Q(JPAR),NPAR)
      CALL UCOPY(ATT,Q(JATT),NATT)
C
      GO TO 999
  900 CONTINUE
C
      WRITE(CHMAIL,1000) NPAR,NATT
      CALL GMAIL(0,0)
 1000 FORMAT(' **** ERROR IN GSIPAR - NPAR =',I12,' OR NATT =',I12,
     +' OUT OF RANGE ****')
C
      GO TO 999
  910 CONTINUE
C
      WRITE(CHMAIL,1010) JVO
      CALL GMAIL(0,0)
 1010 FORMAT(' **** ERROR IN GSIPAR - JVO =',I12,
     +' LE 0. ****')
C
  999 END
+DECK,  GSNEAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSNEAR (CHMOTH,IN,NLIST,LIST)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Gives an ordered LIST of NLIST daughter volumes to search  *
C.    *     for when leaving the INth daughter of the volume CHMOTH    *
C.    *     (LIST(1) = 0 means back in mother at exit of INth content) *
C.    *                                                                *
C.    *     If IN = -1, the mother is regarded to have no contents     *
C.    *         contiguous to its boundaries (LIST and NLIST unused)   *
C.    *        (Bit 4 set in CHMOTH volume bank for action in GGCLOS)  *
C.    *                                                                *
C.    *     Default facility :                                         *
C.    *         If IN = 0, for each content in turn, GSNEAR builds a   *
C.    *         LIST  limited to 1 element LIST(1)=0                   *
C.    *                                                                *
C.    *     Called by : 'USER'                                         *
C.    *     Author    : F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER*4 CHMOTH
      DIMENSION LIST(*)
C.    ------------------------------------------------------------------
*
      IVO = 0
      IF (JVOLUM.GT.0) CALL GLOOK (CHMOTH, IQ(JVOLUM+1), NVOLUM, IVO)
      IF (IVO.EQ.0) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
* *** Check that volume CHMOTH has contents positioned by GSPOS or
*      GSPOSP, and not ordered by User
*
      JVO    = LQ(JVOLUM-IVO)
      ISEARC = Q(JVO+1)
      NIN    = Q(JVO+3)
      IF (NIN.LE.0.OR.ISEARC.GT.0) THEN
         WRITE (CHMAIL, 1002)
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      IF (IN.GT.0) THEN
*
* ***    Lift a JNEAR bank for current content
*
         JIN = LQ(JVO-IN)
         CALL MZBOOK (IXCONS, JNEAR,JIN,-1,'VONE', 0,0,NLIST+1, 2,0)
         IQ(JNEAR-5) = 100*IVO +IN
         IQ(JNEAR+1) = NLIST
         DO 19 I = 1,NLIST
            IQ(JNEAR+I+1) = LIST(I)
   19    CONTINUE
*
      ELSE IF (IN.EQ.0) THEN
*
* ***    Default option for all contents
*
         DO 49 I = 1,NIN
            JIN = LQ(JVO-I)
            CALL MZBOOK (IXCONS, JNEAR,JIN,-1,'VONE',0,0,2, 2,0)
            IQ(JNEAR-5) = 100*IVO+I
            JVO = LQ(JVOLUM-IVO)
            IQ(JNEAR+1)  = 1
   49    CONTINUE
*
      ELSE
*
         IQ(JVO) = IBSET(IQ(JVO),3)
*
      ENDIF
*
 1001 FORMAT (' GSNEAR : Volume',A4,' does not exist  *****')
 1002 FORMAT (' GSNEAR : Volume',A4,' not a candidate for GSNEAR *****')
*                                                             END GSNEAR
  999 END
+DECK,  GSNEXT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSNEXT (MOTHER,IN,NLIST,LIST)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Gives an ordered LIST of NLIST daughter volumes to search  *
C.    *     for when leaving the INth daughter of the volume MOTHER    *
C.    *                                                                *
C.    *     Default facility :                                         *
C.    *         If IN = 0, for each content in turn, GSNEXT builds a   *
C.    *         LIST  limited to next (if any), previous (if any) and  *
C.    *         current content                                        *
C.    *                                                                *
C.    *     Called by : 'USER'                                         *
C.    *     Author    : F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER*4 MOTHER
      DIMENSION LIST(*)
C.    ------------------------------------------------------------------
*
      IVO = 0
      IF (JVOLUM.GT.0) CALL GLOOK (MOTHER, IQ(JVOLUM+1), NVOLUM, IVO)
      IF (IVO.EQ.0) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
* *** Check that volume MOTHER has contents positioned by GSPOS or
*      GSPOSP, and not ordered by User
*
      JVO    = LQ(JVOLUM-IVO)
      ISEARC = Q(JVO+1)
      NIN    = Q(JVO+3)
      IF (NIN.LE.0.OR.ISEARC.GT.0) THEN
         WRITE (CHMAIL, 1002)
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      IF (IN.GT.0) THEN
*
* ***    Lift a JNEAR bank for current content
*
         JIN = LQ(JVO-IN)
         CALL MZBOOK (IXCONS, JNEAR,JIN,-1,'VONE', 0,0,NLIST+1, 2,0)
         IQ(JNEAR-5) = 100*IVO +IN
         NVOLST = 0
         DO 19 I = 1,NLIST
            IF(LIST(I).GT.NIN.OR.LIST(I).LT.0) THEN
               WRITE(CHMAIL,1003) IQ(JVOLUM+IVO),I,LIST(I),NIN
               CALL GMAIL(0,0)
            ELSE
               DO 20 J=1, NVOLST
                  IF(IQ(JNEAR+1+J).EQ.LIST(I)) THEN
                     WRITE(CHMAIL,1004) IQ(JVOLUM+IVO), LIST(I)
                     CALL GMAIL(0,0)
                     GOTO 19
                  ENDIF
   20          CONTINUE
               NVOLST = NVOLST+1
               IQ(JNEAR+NVOLST+1) = LIST(I)
            ENDIF
   19    CONTINUE
         IQ(JNEAR+1) = NVOLST
         IF(NVOLST.LT.NLIST) THEN
             CALL MZPUSH (IXCONS, JNEAR, 0, NVOLST-NLIST, 'R')
         ENDIF
*
      ELSE IF (IN.EQ.0) THEN
*
* ***    Default option for all contents
*
         DO 49 I = 1,NIN
            JIN = LQ(JVO-I)
            IF (LQ(JIN-1).NE.0) GO TO 49
            N = 3
            IF (I.EQ.1.OR.I.EQ.NIN) N = 2
            CALL MZBOOK (IXCONS, JNEAR,JIN,-1,'VONE',0,0,N+1, 2,0)
            IQ(JNEAR-5) = 100*IVO+I
            JVO = LQ(JVOLUM-IVO)
            IQ(JNEAR+1)  = N
            IQ(JNEAR+N+1) = I
            IF (I.NE.1) GO TO 41
            IQ(JNEAR+N) = I +1
            GO TO 49
   41       IF (I.NE.NIN) GO TO 42
            IQ(JNEAR+N) = I -1
            GO TO 49
   42       IQ(JNEAR+N)   = I +1
            IQ(JNEAR+N-1) = I -1
   49    CONTINUE
*
      ENDIF
*
 1001 FORMAT (' GSNEXT : Volume',A4,' does not exist  *****')
 1002 FORMAT (' GSNEXT : Volume',A4,' not a candidate for GSNEXT *****')
 1003 FORMAT (' GSNEXT : Volume ',A4,': LIST(',I3,')=',I3,
     +        ' NIN=',I3,' value ignored')
 1004 FORMAT (' GSNEXT : Volume',A4,': repetition of content ',
     +        I3,' ignored')
*                                                             END GSNEXT
  999 END
+DECK,  GSNGTR, T=FORT.
* Revision 1.2  1996/02/27 09:54:45  ravndal
* Double precision for some locals, thanks to G.Poulard
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSNGTR(X,P,IACT,SNEXT,SNXT,SAFE,INSIDE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *    Routine to determine the shortest distance from the point   *
C.    *    X(1-3) to the boundary of the shape of type GTRA defined    *
C.    *    by the parameters P along the vector X(4-6). If INSIDE is   *
C.    *    1 then the point is inside the shape and the distance is    *
C.    *    returned as SNEXT. If INSIDE is 0 then the point is         *
C.    *    outside the shape and if the line hits the shape then       *
C.    *    if the new distance is less than the                        *
C.    *    old value of SNEXT the new distance is returned as SNEXT.   *
C.    *                                                                *
C.    *          Called by : GNEXT, GTNEXT                             *
C.    *          A.C.McPherson   22nd April 1985.                      *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCUNIT.
C
+SELF, IF=-SINGLE.
      DOUBLE PRECISION X0,Y0,DXDZ,DYDZ,A,B,C,DISC,X1,X2,X3,SN,CP,SMALL
+SELF.
      PARAMETER (SMALL=1E-10)
C
      DIMENSION X(6),P(30),SN(2,5),IOUT(5),X0(4),Y0(4),DXDZ(4),DYDZ(4)
C.
C.                ---------------------------------------------
C.
C
C               Compute Safety distance
C
      DOUBLE PRECISION SL,SL1,SM,SM1
      IF(IACT.LT.3) CALL GSAGTR(X,P,SAFE,INSIDE)
      SNXT=BIG
      IF (IACT .EQ. 0) GO TO 999
      IF (IACT .EQ. 1) THEN
        IF (SNEXT .LT. SAFE) GO TO 999
      ENDIF
C
C               First compute the distance along the line to the
C               boundaries.
C
C               The distance to the planes defined by z=+/-P(1).
C
      IF(X(6).EQ.0.0) THEN
          SN(1,1)=BIG
          SN(2,1)=BIG
          GOTO 10
      ENDIF
      SN(1,1)=(-P(1)-X(3))/X(6)
      SN(2,1)=(P(1)-X(3))/X(6)
      IF(X(6).GT.0.0) GO TO 10
      ST=SN(2,1)
      SN(2,1)=SN(1,1)
      SN(1,1)=ST
   10 CONTINUE
C
C               The distance to the remaining four surfaces.
C
      DO 20 I=1,4
      X0(I)=P(I*4+11)
      Y0(I)=P(I*4+12)
      DXDZ(I)=P(I*4+13)
      DYDZ(I)=P(I*4+14)
   20 CONTINUE
C
      DO 65 I=1,4
      J=I+1
      IF(J.EQ.5) J=1
C
      A=(X(4)-DXDZ(I)*X(6))*(DYDZ(J)-DYDZ(I))*X(6) -
     +(X(5)-DYDZ(I)*X(6))*(DXDZ(J)-DXDZ(I))*X(6)
C
      B=(X(4)-DXDZ(I)*X(6))*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X(3)) +
     +(X(1)-X0(I)-DXDZ(I)*X(3))*(DYDZ(J)-DYDZ(I))*X(6) -
     +(X(5)-DYDZ(I)*X(6))*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X(3)) -
     +(X(2)-Y0(I)-DYDZ(I)*X(3))*(DXDZ(J)-DXDZ(I))*X(6)
C
      C=(X(1)-X0(I)-DXDZ(I)*X(3))*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X(3))
     + - (X(2)-Y0(I)-DYDZ(I)*X(3))*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X(3))
C
      IOUT(I+1)=0
      IF(C.GT.0.0) IOUT(I+1)=1
C
C             The solutions are in the normal form:
C             s = (-B+/-SQRT(B*B-4.0*A*C))*0.5/A
C
      SN(1,I+1)=BIG
      SN(2,I+1)=BIG
      IF(ABS(A).GT.1.0E-10) GO TO 30
C
C             A = 0 only one solution.
C
      IF(ABS(B).LT.1.0E-10) GO TO 60
C
      SN(1,I+1)=-C/B
      GO TO 60
C
   30 CONTINUE
      IF(ABS(C).GT.1.0E-10) GO TO 40
      SN(1,I+1)=0.0
      SN(2,I+1)=0.0
      IF(ABS(B).LT.1.0E-10) GO TO 60
      SN(1,I+1)=-C/B
      IF(C.EQ.0.0) SN(1,I+1)=SIGN(SMALL,B)
      SN(2,I+1)=-B/A
      GO TO 50
C
   40 CONTINUE
      DISC=B*B-A*C*4.0
      IF(DISC.LT.0.0) GO TO 60
      IF(DISC.GT.0.0) DISC=SQRT(DISC)
      SN(1,I+1)=(-B-DISC)*0.5/A
      SN(2,I+1)=(-B+DISC)*0.5/A
C
   50 CONTINUE
      IF(SN(2,I+1).GT.SN(1,I+1)) GO TO 60
      ST=SN(2,I+1)
      SN(2,I+1)=SN(1,I+1)
      SN(1,I+1)=ST
C
   60 CONTINUE
C
      DO 65 K=1,2
      IF(ABS(SN(K,I+1)).GT.1.0E+05.OR.ABS(SN(K,I+1)).LT.1.0E-05)
     +GO TO 65
C
      X1=X(1)+SN(K,I+1)*X(4)
      X2=X(2)+SN(K,I+1)*X(5)
      X3=X(3)+SN(K,I+1)*X(6)
      CP=(X1-X0(I)-DXDZ(I)*X3)*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X3)
     + - (X2-Y0(I)-DYDZ(I)*X3)*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X3)
      CP=CP/SQRT((X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X3)**2+
     +   (Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X3)**2)
C
      IF(ABS(CP).LT.0.0001) GO TO 65
      IF(ABS(CP/SN(K,I+1)).LT.1.0E-06) GO TO 65
      WRITE(CHMAIL,1020) I,K,SN(K,I+1)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1021) X
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1022) X1,X2,X3,CP
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1023) A,B,C,DISC
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1024) INSIDE
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1025) X0
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1026) Y0
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1027) DXDZ
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1028) DYDZ
      CALL GMAIL(0,0)
 1020 FORMAT('0 GSNGTR ERROR - I,K =',2I2,' SN =',E13.5)
 1021 FORMAT(' X =',6F15.6)
 1022 FORMAT(' X1,X2,X3 =',3F15.6,' CP =',E15.6)
 1023 FORMAT(' A =',E15.6,' B =',E15.6,' C =',E15.6,' DISC =',E15.6)
 1024 FORMAT(' INSIDE =',I3)
 1025 FORMAT('   X0 =',4E15.6)
 1026 FORMAT('   Y0 =',4E15.6)
 1027 FORMAT(' DXDZ =',4E15.6)
 1028 FORMAT(' DYDZ =',4E15.6)
C
   65 CONTINUE
C
C
C             Have computed the two distances for the z planes and
C             the four surfaces. Combine them accordingly as to
C             whether the point is inside or outside the shape.
C
      IF(INSIDE.EQ.0) GO TO 80
C
C             Point is inside shape.
C
      DO 70 I=1,5
      DO 70 J=1,2
      IF(SN(J,I).GT.0.0.AND.SN(J,I).LT.SNXT) SNXT=SN(J,I)
   70 CONTINUE
      GO TO 999
C
   80 CONTINUE
C
C             Point is outside shape.
C
      IOUT(1)=0
      IF(ABS(X(3)).GT.P(1)) IOUT(1)=1
C
C             For each of five sets of SN and IOUT, IOUT(I) equal to 1
C             indicates that the point is outside the shape by the Ith
C             test, SN(1,I) is the distance to the first change in the
C             test and SN(2,I) is the distance to the second change.
C             The remaining logic just attempts to find a distance when
C             the line is inside by all five tests, bearing in mind that
C             for some tests the line can start inside, leave and return
C             inside.
C
      SL=-1.0
      SM=BIG
      SM1=BIG
      DO 100 I=1,5
      IF(IOUT(I).EQ.0) GO TO 90
      IF(SN(2,I).LT.0.0) GO TO 999
      IF(SN(1,I).LT.0.0.AND.SN(2,I).GT.SL) SL=SN(2,I)
      IF(SN(1,I).GT.SL) SL=SN(1,I)
      IF(SN(1,I).GE.0.0.AND.SN(2,I).LT.SM) SM=SN(2,I)
      GO TO 100
   90 CONTINUE
      IF(SN(1,I).LT.0.0.AND.SN(2,I).GE.0.0.AND.SN(2,I).LT.SM) SM=SN(2,I)
      IF(SN(1,I).LT.0.0.OR.SN(1,I).GT.SM1) GO TO 100
      IF(SN(1,I).GE.SN(2,I)) GO TO 100
      SM1=SN(1,I)
      SL1=SN(2,I)
  100 CONTINUE
C
C             SL is the largest of the five distances to the first
C             time the line is inside. SM is the smallest to the
C             last time the point is inside. SM1 is the smallest
C             distance to when the line is temporarily outside
C             one of the tests.
C
      IF(SM.LE.SL) GO TO 999
      IF(SM1.GT.SL) GO TO 130
C
  110 CONTINUE
C
C             In this loop SL is updated by the return after SM1
C             if SM1 is less than SL.
C
      SL=SL1
      IF(SM.LE.SL) GO TO 999
      SM1=SM
C
      DO 120 I=1,5
      IF(IOUT(I).EQ.1) GO TO 120
      IF(SN(2,I).LE.SL.OR.SN(1,I).GT.SM1) GO TO 120
      IF(SN(1,I).GE.SN(2,I)) GO TO 120
      SM1=SN(1,I)
      SL1=SN(2,I)
  120 CONTINUE
C
      IF(SM1.GT.SL) GO TO 130
C
      GO TO 110
  130 CONTINUE
C
      IF(SL.LT.SNXT) SNXT=SL
C
  999 CONTINUE
      END
+DECK,  GSORD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSORD (CHNAME, IAX)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    Flags volume CHNAME whose contents will have to be ordered   *
C.    *    along axis IAX, by setting the search flag to -IAX         *
C.    *           IAX = 1    X axis                                   *
C.    *           IAX = 2    Y axis                                   *
C.    *           IAX = 3    Z axis                                   *
C.    *           IAX = 4    Rxy (static ordering only  -> GTMEDI)    *
C.    *           IAX = 14   Rxy (also dynamic ordering -> GTNEXT)    *
C.    *           IAX = 5    Rxyz (static ordering only -> GTMEDI)    *
C.    *           IAX = 15   Rxyz (also dynamic ordering -> GTNEXT)   *
C.    *           IAX = 6    PHI   (PHI=0 => X axis)                  *
C.    *           IAX = 7    THETA (THETA=0 => Z axis)                *
C.    *                                                               *
C.    *    Called by : <USER>                                         *
C.    *    Authors   : R.Brun, F.Bruyant, A.McPherson  *********      *
C.    *                                                               *
C.    *****************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
      CHARACTER*4 CHNAME
C.
C.    ------------------------------------------------------------------
*
      IVO = 0
      IF (JVOLUM.GE.0) CALL GLOOK (CHNAME, IQ(JVOLUM+1), NVOLUM, IVO)
      IF (IVO.EQ.0) THEN
         WRITE (CHMAIL, 1001) CHNAME
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      IF ((IAX.LE.0.OR.IAX.GT.7).AND.IAX.NE.14.AND.IAX.NE.15) THEN
         WRITE (CHMAIL, 1002) CHNAME, IAX
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      JVO = LQ(JVOLUM-IVO)
      NIN = Q(JVO+3)
      IF (NIN.LE.0.OR.NIN.GT.500) THEN
         WRITE (CHMAIL,1003) CHNAME, NIN
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
* *** Set search flag
*
      Q(JVO+1) = -IAX
*
 1001 FORMAT (' GSORD : Volume ',A4,' does not exist  *****')
 1002 FORMAT (' GSORD : Volume ',A4,', axis',I3,' not allowed  *****')
 1003 FORMAT (' GSORD : Volume ',A4,' not accepted, NIN=',I5,'  *****')
*                                                              END GSORD
  999 END
+DECK,  GSPOS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSPOS(CHNAME,NR,CHMOTH,X,Y,Z,IROT,CHONLY)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      PLACE A COPY OF VOLUME 'CHNAME' WITH USER NUMBER 'NUMBER'   *
C.    *      INSIDE 'CHMOTH'                                           *
C.    *                                                                *
C.    *          JVO=POINTER TO CHMOTH VOLUME                          *
C.    *          JIN=POINTER TO THE COPY 'CHNAME','NUMBER'               *
C.    *          JIN=LQ(JVO-IN)                                        *
C.    *                                                                *
C.    *             Q(JIN+1)=NENTRY                                    *
C.    *             Q(JIN+2)=VOLUME NUMBER                             *
C.    *             Q(JIN+3)=USER NUMBER                               *
C.    *             Q(JIN+4)=IROT                                      *
C.    *             Q(JIN+5)=X                                         *
C.    *             Q(JIN+6)=Y                                         *
C.    *             Q(JIN+7)=Z                                         *
C.    *             Q(JIN+8)=ONLY                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *         Authors R.Brun,  A.McPherson  *********                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER*4 CHNAME,CHMOTH,CHONLY
C.
C.    ------------------------------------------------------------------
C.
C              CHECK IF VOLUME MASTER BANK EXISTS
C
      IF(JVOLUM.GT.0)GO TO 10
      WRITE(CHMAIL,1000)
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF CHMOTH VOLUME EXISTS
C
  10  CALL GLOOK(CHMOTH,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.GT.0)GO TO 20
      WRITE(CHMAIL,2000)CHMOTH
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF CHNAME VOLUME EXISTS
C
  20  CALL GLOOK(CHNAME,IQ(JVOLUM+1),NVOLUM,IN)
      IF(IN.GT.0)GO TO 30
      WRITE(CHMAIL,2000)CHNAME
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF ROTATION MATRIX EXISTS
C
  30  IF(IROT.LE.0)GO TO 50
      IF(JROTM.GT.0)GO TO 40
      WRITE(CHMAIL,3000)IROT
      CALL GMAIL(0,0)
      GO TO 99
  40  IF(LQ(JROTM-IROT).GT.0)GO TO 50
      WRITE(CHMAIL,3000)IROT
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF MOTHER IS NOT DIVIDED
C
  50  JVO=LQ(JVOLUM-IVO)
      ICOPY=1
      NIN=Q(JVO+3)
      IF(NIN.GE.0)GO TO 60
      WRITE(CHMAIL,4000)CHMOTH
      CALL GMAIL(0,0)
      GO TO 99
C
C              CHECK IF ('NAME',NUMBER') EXISTS
C
  60  IF(NIN.EQ.0)GO TO 80
      DO 70 I=1,NIN
      JIN=LQ(JVO-I)
      IF(Q(JIN+2).NE.IN)GO TO 70
      IF(Q(JIN+3).NE.NR)GO TO 70
      WRITE(CHMAIL,5000)CHNAME,NR
      CALL GMAIL(0,0)
      GO TO 90
  70  CONTINUE
      ICOPY=NIN+1
C
C               CREATE BANK FOR THAT COPY
C
  80  NINL=IQ(JVO-2)
      IF(ICOPY.GT.NINL)CALL MZPUSH(IXCONS,JVO,50,0,'I')
      CALL MZBOOK(IXCONS,JIN,JVO,-ICOPY,'VOPO',1,1,8,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JIN-5)=100*IVO+ICOPY
      Q(JVO+3)=Q(JVO+3)+1
C
C               NOW STORE PARAMETERS INTO BANK AREA
C
  90  Q(JIN+2)=IN
      Q(JIN+3)=NR
      Q(JIN+4)=IROT
      Q(JIN+5)=X
      Q(JIN+6)=Y
      Q(JIN+7)=Z
      IF(CHONLY.EQ.'ONLY')Q(JIN+8)=1.
      GO TO 99
C
C              NOT ENOUGH SPACE
C
  95  WRITE(CHMAIL,6000)CHNAME,NR,CHMOTH
      CALL GMAIL(0,0)
C
 1000 FORMAT(' ***** GSPOS called and no volumes defined')
 2000 FORMAT(' ***** GSPOS volume ',A4,' does not exist')
 3000 FORMAT(' ***** GSPOS rotation matrix',I5,' does not exist')
 4000 FORMAT(' ***** GSPOS mother ',A4,' already divided')
 5000 FORMAT(' ***** GSPOS copy ',A4,' number ',I5,
     +       ' already created in ',A4,' *****')
 6000 FORMAT(' ***** GSPOS not enough space to store copy ',A4,
     +       ' number ',I5,' in ',A4,' *****')
  99  END
+DECK,  GSPOSP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSPOSP(NAME,NR,MOTHER,X,Y,Z,IROT,KONLY,UPAR,NP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Place a copy of generic volume 'NAME' with user number    *
C.    *      'NR' inside 'MOTHER', with its parameters UPAR(1..NP)     *
C.    *                                                                *
C.    *          JVO=pointer to mother volume                          *
C.    *          JIN=pointer to the copy 'NAME','NR'                   *
C.    *          JIN=LQ(JVO-IN)                                        *
C.    *                                                                *
C.    *             Q(JIN+1)=NENTRY                                    *
C.    *             Q(JIN+2)=VOLUME NUMBER                             *
C.    *             Q(JIN+3)=USER NUMBER                               *
C.    *             Q(JIN+4)=IROT                                      *
C.    *             Q(JIN+5)=X                                         *
C.    *             Q(JIN+6)=Y                                         *
C.    *             Q(JIN+7)=Z                                         *
C.    *             Q(JIN+8)=ONLY                                      *
C.    *             Q(JIN+9)=NPAR                                      *
C.    *             Q(JIN+10 ..)=PAR ..                                *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *         Authors R.Brun, F.Bruyant,  A.McPherson  *********     *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCNUM.
+CDE, GCONSP.
      CHARACTER*4 NAME,MOTHER,KONLY
      DIMENSION UPAR(*),PAR(50)
C.
C.    ------------------------------------------------------------------
C.
C              Check if volume master bank exists
C
      IF(JVOLUM.GT.0)GO TO 10
      WRITE(CHMAIL,1000)
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if mother volume exists
C
  10  CALL GLOOK(MOTHER,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.GT.0)GO TO 20
      WRITE(CHMAIL,2000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if NAME volume exists
C
  20  CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IN)
      IF(IN.GT.0)GO TO 30
      WRITE(CHMAIL,2000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if rotation matrix exists
C
  30  IF(IROT.LE.0)GO TO 50
      IF(JROTM.GT.0)GO TO 40
      WRITE(CHMAIL,3000)IROT
      CALL GMAIL(0,0)
      GO TO 99
  40  IF(LQ(JROTM-IROT).GT.0)GO TO 50
      WRITE(CHMAIL,3000)IROT
      CALL GMAIL(0,0)
      GO TO 99
C
C              Check if mother is not divided
C
  50  JIN=LQ(JVOLUM-IN)
      ISH=Q(JIN+2)
      JVO=LQ(JVOLUM-IVO)
      ICOPY=1
      NIN=Q(JVO+3)
      IF(NIN.GE.0)GO TO 60
      WRITE(CHMAIL,4000)MOTHER
      CALL GMAIL(0,0)
      GO TO 99
*
* *** Copy user parameters into local array PAR
  60  NPAR=NP
      IF (ISH.EQ. 4) NPAR=35
      IF (ISH.EQ.28) NPAR=30
      CALL UCOPY(UPAR,PAR,NP)
*
* *** Check if ('NAME',NUMBER') exists
      IF(NIN.EQ.0)GO TO 80
      DO 70 I=1,NIN
      JIN=LQ(JVO-I)
      IF(Q(JIN+2).NE.IN)GO TO 70
      IF(Q(JIN+3).NE.NR)GO TO 70
      WRITE(CHMAIL,5000)NAME,NR
      CALL GMAIL(0,0)
      GO TO 90
  70  CONTINUE
      ICOPY=NIN+1
*
* *** Create bank for that copy
  80  NINL=IQ(JVO-2)
      IF(ICOPY.GT.NINL)CALL MZPUSH(IXCONS,JVO,50,0,'I')
      CALL MZBOOK(IXCONS,JIN,JVO,-ICOPY,'VOPP',1,1,NPAR+9,3,0)
      IF(IEOTRI.NE.0)GO TO 95
      IQ(JIN-5)=100*IVO+ICOPY
      Q(JVO+3)=Q(JVO+3)+1
*
* *** Now store parameters into bank area
  90  Q(JIN+2)=IN
      Q(JIN+3)=NR
      Q(JIN+4)=IROT
      Q(JIN+5)=X
      Q(JIN+6)=Y
      Q(JIN+7)=Z
      IF(KONLY.EQ.'ONLY')Q(JIN+8)=1.
      Q(JIN+9) = NPAR
*
      IF (ISH.EQ.4) THEN
*        Trapezoid
         TTH= TAN(PAR(2)*DEGRAD)
         PHI    = PAR(3)*DEGRAD
         PAR(2) = TTH*COS(PHI)
         PAR(3) = TTH*SIN(PHI)
         PAR(7) = TAN(PAR(7) *DEGRAD)
         PAR(11)= TAN(PAR(11)*DEGRAD)
         CALL GNOTR1 (PAR)
      ELSE IF (ISH.EQ.10) THEN
*        Parallelepiped.
         PAR(4)=TAN(PAR(4)*DEGRAD)
         TTH=TAN(PAR(5)*DEGRAD)
         PH=PAR(6)*DEGRAD
         PAR(5)=TTH*COS(PH)
         PAR(6)=TTH*SIN(PH)
      ELSE IF (ISH.EQ.28) THEN
*        General twisted trapezoid.
         CALL GTRAIN(UPAR,PAR)
      ENDIF
*
      CALL UCOPY(PAR,Q(JIN+10),NPAR)
      GO TO 99
*
*     Not enough space
  95  WRITE(CHMAIL,6000)NAME,NR,MOTHER
      CALL GMAIL(0,0)
C
 1000 FORMAT(' ***** GSPOSP CALLED AND NO VOLUMES DEFINED *****')
 2000 FORMAT(' ***** GSPOSP VOLUME ',A4,' DOES NOT EXISTS *****')
 3000 FORMAT(' ***** GSPOSP ROTATION MATRIX',I5,' DOES NOT EXIST *****')
 4000 FORMAT(' ***** GSPOSP MOTHER ',A4,' ALREADY DIVIDED *****')
 5000 FORMAT(' ***** GSPOSP COPY ',A4,' NUMBER ',I5,
     +       ' ALREADY CREATED IN ',A4,' *****')
 6000 FORMAT(' ***** GSPOSP NOT ENOUGH SPACE TO STORE COPY ',A4,
     +       ' NUMBER ',I5,' IN ',A4,' *****')
  99  RETURN
      END
+DECK,  GSROTM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSROTM(NMAT,THETA1,PHI1,THETA2,PHI2,THETA3,PHI3)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       STORE ROTATION MATRICES                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCONSP.
+CDE, GCNUM.
      DIMENSION ANGLES(6),IP(3)
      SAVE SINMIN
+SELF, IF=SINGLE.
      DIMENSION ROTMAT(9)
      PARAMETER (ONE=1.0,ZERO=0.0)
      DATA SINMIN/1.00E-5/
+SELF, IF=-SINGLE.
      DOUBLE PRECISION ROTMAT(9),ONE,ZERO
      DOUBLE PRECISION PROD1,PROD2,PROD3,HMOD,SINMIN
      PARAMETER (ONE=1.D0,ZERO=0.D0)
      DATA SINMIN/1.00D-5/
+SELF.
C.
C.    ------------------------------------------------------------------
C.
      IF(NMAT.LE.0)GO TO 999
      IF(JROTM.LE.0)CALL MZBOOK(IXCONS,JROTM,JROTM,1,'ROTM',NROTM,NROTM,
     +0,3,0)
      IF(NMAT.GT.IQ(JROTM-2)) THEN
         NPUSH=NMAT-IQ(JROTM-2)+50
         CALL MZPUSH(IXCONS,JROTM,NPUSH,0,'I')
         NROTM=IQ(JROTM-2)
         JR1=0
      ELSE
         JR1=LQ(JROTM-NMAT)
         IF(JR1.GT.0)THEN
            WRITE(CHMAIL,1000)
            CALL GMAIL(1,0)
            CALL GPROTM(NMAT)
            CALL MZDROP(IXCONS,LQ(JROTM-NMAT),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JR,JROTM,-NMAT,'ROTM',0,0,16,3,0)
C
      Q(JR + 11) = THETA1
      Q(JR + 12) = PHI1
      Q(JR + 13) = THETA2
      Q(JR + 14) = PHI2
      Q(JR + 15) = THETA3
      Q(JR + 16) = PHI3
C
      DO  10 N = 1,3
        THERAD = Q(JR+ 9+2*N)*DEGRAD
        PHIRAD = Q(JR+10+2*N)*DEGRAD
        SINTHE = SIN(THERAD)
        Q(JR+3*N-2) = SINTHE * COS(PHIRAD)
        Q(JR+3*N-1) = SINTHE * SIN(PHIRAD)
        Q(JR+3*N  ) = COS(THERAD)
        CALL VUNIT (Q(JR+3*N-2),Q(JR+3*N-2),3)
  10  CONTINUE
C.
C.---       Test orthonormality
      DO 20 J=1,9
        ROTMAT(J)=Q(JR+J)
  20  CONTINUE
      PROD2=ZERO
C.
C.               X - Y
      PROD1=
     +ROTMAT(1)*ROTMAT(4)+ROTMAT(2)*ROTMAT(5)+ROTMAT(3)*ROTMAT(6)
      IF(ABS(PROD1).GT.SINMIN) GO TO 30
C.
C.               X - Z
      PROD2=
     +ROTMAT(1)*ROTMAT(7)+ROTMAT(2)*ROTMAT(8)+ROTMAT(3)*ROTMAT(9)
      IF(ABS(PROD2).GT.SINMIN) GO TO 30
C.
C.               Y - Z
      PROD3=
     +ROTMAT(7)*ROTMAT(4)+ROTMAT(8)*ROTMAT(5)+ROTMAT(9)*ROTMAT(6)
      IF(ABS(PROD3).LE.SINMIN) GO TO 110
  30  CONTINUE
C.
C.---       Orthonormalization needed
C.
C.          Assume X correct
      HMOD=ZERO
      DO 40 J=4,6
        ROTMAT(J)=ROTMAT(J)-ROTMAT(J-3)*PROD1
        HMOD=HMOD+ROTMAT(J)*ROTMAT(J)
  40  CONTINUE
      HMOD=ONE/SQRT(HMOD)
      DO 50 J=4,6
        ROTMAT(J)=ROTMAT(J)*HMOD
  50  CONTINUE
C.
C.          Y done, do Z
C.
*      IF(PROD2.EQ.ZERO) THEN
*        PROD2=
*     +  ROTMAT(1)*ROTMAT(7)+ROTMAT(2)*ROTMAT(8)+ROTMAT(3)*ROTMAT(9)
*      ENDIF
*      PROD3=
*     +ROTMAT(4)*ROTMAT(7)+ROTMAT(5)*ROTMAT(8)+ROTMAT(6)*ROTMAT(9)
*      HMOD = ZERO
*      DO 60 J=1,3
*        ROTMAT(J+6)=ROTMAT(J+6)-ROTMAT(J+3)*PROD3-ROTMAT(J)*PROD2
*        HMOD = HMOD+ROTMAT(J)*ROTMAT(J)
*  60  CONTINUE
* == AV ==
      ROTMAT(7) = ROTMAT(2)*ROTMAT(6) - ROTMAT(3)*ROTMAT(5)
      ROTMAT(8) = ROTMAT(3)*ROTMAT(4) - ROTMAT(1)*ROTMAT(6)
      ROTMAT(9) = ROTMAT(1)*ROTMAT(5) - ROTMAT(2)*ROTMAT(4)
      HMOD = ZERO + ROTMAT(7)*ROTMAT(7) + ROTMAT(8)*ROTMAT(8)
     &            + ROTMAT(9)*ROTMAT(9)
* == AV ==
      HMOD = ONE/SQRT(HMOD)
      DO 70 J=7,9
        ROTMAT(J) = ROTMAT(J)*HMOD
  70  CONTINUE
C.
C.          Put back the matrix in place
      DO 80 J=1,9
        Q(JR+J)=ROTMAT(J)
  80  CONTINUE
C.
C.          Now recompute the angles
      DO 90 J=1,3
        ANGLES(J*2-1) = ACOS(MAX(-ONE,MIN(ONE,ROTMAT(J*3))))*RADDEG
        ANGLES(J*2)   = ZERO
        IF(ROTMAT(J*3-1).NE.ZERO) THEN
          ANGLES(J*2) = ATAN2(ROTMAT(J*3-1),ROTMAT(J*3-2))*RADDEG
          IF(ANGLES(2*J).LT.0.0) ANGLES(2*J) = ANGLES(2*J)+360.0
        ENDIF
  90  CONTINUE
      WRITE(CHMAIL,2000) NMAT
      CALL GMAIL(1,2)
      WRITE(CHMAIL,2001) (Q(JR+10+J),J=1,6)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,2002) ANGLES
      CALL GMAIL(0,1)
C.
C.          Put back the angles in place
      DO 100 J=1,6
        Q(JR+10+J) = ANGLES(J)
 100  CONTINUE
C.
C.---       Orthonormalization ended
 110  CONTINUE
C
      DO 130 J = 1,3
        IP(J)  = 3
        JJR=JR+J*3-3
C
        DO 120 I = 1,3
          IF(ABS(Q(JJR+I)).LT.0.99999) GO TO 120
C
          IP(J)  = I + 3
          IF(Q(JJR+I).GE.0.) GO TO 130
C
          IP(J)  = 3 - I
          GO TO 130
C
 120    CONTINUE
 130  CONTINUE
C
      Q(JR + 10) = IP(1) + 10* IP(2) + 100* IP(3)
C
      IF(JR1.GT.0) THEN
         CALL GPROTM(-NMAT)
      ENDIF
C
1000  FORMAT(' *** GSROTM ***: Warning, rotation matrix redefinition:')
2000  FORMAT(' *** GSROTM ***: ',
     +       'Parameters of matrix no. ',I4,' changed:')
2001  FORMAT(' Old values: ',6(F14.7,3X))
2002  FORMAT(' New values: ',6(F14.7,3X))
 999  RETURN
      END
+DECK,  GSUNEA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSUNEA(CHNAME,ISEARC)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    ROUTINE TO SPECIFY USER ORDERING FOR THE CONTENTS          *
C.    *    OF A GIVEN VOLUME, BY SETTING THE SEARCH FLAG >0           *
C.    *                                                               *
C.    *    ==>Called by : USER                                        *
C.    *         Author  R.Brun, F.Bruyant  *********                  *
C.    *                                                               *
C.    *****************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER*4 CHNAME
C.
C.             -----------------------------------------
C.
C            Check JVOLUM
*
      IF(JVOLUM.LE.0) THEN
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
*
      ELSE
*
*           find volume CHNAME.
         CALL GLOOK(CHNAME,IQ(JVOLUM+1),NVOLUM,IVO)
         IF(IVO.LE.0) THEN
            WRITE(CHMAIL,10100) CHNAME
            CALL GMAIL(0,0)
*
         ELSE
*
*          Set new value of ISEARC.
            IF (ISEARC.LE.0) THEN
               WRITE (CHMAIL, 10200) ISEARC
               CALL GMAIL (0, 0)
            ELSE
               JVO=LQ(JVOLUM-IVO)
               Q(JVO+1)=ISEARC
            ENDIF
         ENDIF
      ENDIF
*
10000 FORMAT(' ***** GSUNEA - No volumes defined')
10100 FORMAT(' ***** GSUNEA - Volume ',A4,' does not exist')
10200 FORMAT(' ***** GSUNEA - ISEARC = ',I10,' should be positive')
      END
+DECK,  GSVOLU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GSVOLU(KNAME,JSHAPE,NMED,UPAR,NP,IVOLU)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        CREATES A NEW VOLUME                                    *
C.    *                                                                *
C.    *          JVO=LQ(JVOLUM-IVOLU)                                  *
C.    *                                                                *
C.    *            Q(JVO+1)=ISEARC (SET TO 0 BY DEFAULT)               *
C.    *            Q(JVO+2)=ISHAPE                                     *
C.    *            Q(JVO+3)=NIN                                        *
C.    *            Q(JVO+4)=NMED                                       *
C.    *            Q(JVO+5)=NPAR                                       *
C.    *            Q(JVO+6)=NATT                                       *
C.    *            Q(JVO+7)=PAR.....                                   *
C.    *            Q(JVO+7+NPAR)=ATT.....                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *         Author  R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCNUM.
+CDE, GCDRAW.
+CDE, GCUNIT.
      CHARACTER*4 KNAME,JSHAPE
      DIMENSION UPAR(50),PAR(50),ATT(20)
      SAVE ATT,NATT
      DATA ATT/1.,1.,1.,1.,1.,15*0./
      DATA NATT/10/
C.
C.    ------------------------------------------------------------------
C.
C
C              Copy user parameters into local array PAR
C
      NPAR=NP
      IF (NP.GT.0) THEN
         IF(JSHAPE.EQ.'TRAP') NPAR=35
         IF(JSHAPE.EQ.'GTRA') NPAR=30
         CALL UCOPY(UPAR,PAR,NP)
      ENDIF
C
      IVOLU=0
C
C              CHECK SHAPE VALIDITY
C
      CALL GSCHK ( KNAME, JSHAPE, NPAR, ISHAPE )
C
      IF(ISHAPE.LE.0)GO TO 99
      IF(JVOLUM.GT.0)GO TO 10
C
C              CREATE THE MOTHER MEDIA BANK
C
      CALL MZBOOK(IXCONS,JVOLUM,JVOLUM,1,'VOLU',400,400,400,5,0)
      IVO=1
      NVOLUM=1
      GO TO 30
C
C              CHECK IF SUCH A VOLUME ALREADY DEFINED
C
  10  NVOL=IQ(JVOLUM-2)
      CALL GLOOK(KNAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.LE.0)GO TO 20
      IF(LQ(JVOLUM-IVO).GT.0) THEN
         WRITE(CHMAIL,10010) KNAME, IVO
10010 FORMAT(' **** GSVOLU: Redefinition of volume ',
     +       A4,' IVO = ',I6)
         CALL GMAIL(0,0)
         CALL MZDROP(IXCONS,LQ(JVOLUM-IVO),' ')
      ENDIF
      GO TO 30
C
  20  NVOLUM=NVOLUM+1
      IF(NVOLUM.GT.NVOL)CALL MZPUSH(IXCONS,JVOLUM,50,50,'I')
      IVO=NVOLUM
C
C              NOW CREATE THE VOLUME BANK
C
  30  CALL MZBOOK(IXCONS,JVO,JVOLUM,-IVO,'VOL1',50,50,9+NPAR+NATT,3,0)
      CALL UCTOH(KNAME,IQ(JVOLUM+IVO),4,4)
C
C              COPY PARAMETERS IN DATA AREA
C
      IVOLU=IVO
      Q(JVO+2)=ISHAPE
      Q(JVO+4)=NMED
      IF(NPAR.LE.0)GO TO 99
*
      IF (ISHAPE.EQ.4) THEN
*        Trapezoid
         TTH= TAN(PAR(2)*DEGRAD)
         PHI    = PAR(3)*DEGRAD
         PAR(2) = TTH*COS(PHI)
         PAR(3) = TTH*SIN(PHI)
         PAR(7) = TAN(PAR(7) *DEGRAD)
         PAR(11)= TAN(PAR(11)*DEGRAD)
         CALL GNOTR1 (PAR)
      ELSE IF (ISHAPE.EQ.10) THEN
*        Parallelepiped change angles to tangents.
         PAR(4)=TAN(PAR(4)*DEGRAD)
         TTH=TAN(PAR(5)*DEGRAD)
         PH=PAR(6)*DEGRAD
         PAR(5)=TTH*COS(PH)
         PAR(6)=TTH*SIN(PH)
      ELSE IF (ISHAPE.EQ.28) THEN
*        General twisted trapezoid.
         CALL GTRAIN(UPAR,PAR)
      ENDIF
*
  99  CONTINUE
*
      CALL GSIPAR(JVO,0,NPAR,NATT,PAR,ATT)
*
      END
+DECK,  GTRAIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GTRAIN(PARU,P)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *              SUBROUTINE GTRAIN(PARU,P)                         *
C.    *    Routine to convert from user supplied parameters PARU to    *
C.    *    internal parameters P for the twisted trapezoidal shape     *
C.    *    GTRA.                                                       *
C.    *          Called by : GSPOSP, GSVOLU                            *
C.    *          A.C.McPherson    22nd April 1985.                     *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION PARU(12),P(30),CORN(3,8)
C.
C.                   -------------------------------------
C.
C                First copy the 12 user parameters into the internal
C                parameter array.
C
      DO 10 I=1,12
      P(I)=PARU(I)
   10 CONTINUE
C
C                Now some trignometrical quantities including the first
C                two extra parameters.
C
      P(13) = TAN(P(2)*DEGRAD)*COS(P(3)*DEGRAD)
      P(14) = TAN(P(2)*DEGRAD)*SIN(P(3)*DEGRAD)
      STWIS = SIN(P(4)*DEGRAD)
      CTWIS = COS(P(4)*DEGRAD)
      DXDY1 = TAN(P(8)*DEGRAD)
      DXDY2 = TAN(P(12)*DEGRAD)
C
C                Next the edges outside the constant z faces (derived
C                from the eight corner points).
C
      P(15) = (CTWIS*(P(5)*DXDY1+P(7)+P(9)*DXDY2+P(11)) +
     +STWIS*(P(5)-P(9)))*0.5
      P(16) = (CTWIS*(P(5)+P(9)) -
     +STWIS*(P(5)*DXDY1+P(7)-P(9)*DXDY2-P(11)))*0.5
      P(17) = P(13) - (CTWIS*(P(5)*DXDY1+P(7)-P(9)*DXDY2-P(11)) +
     +STWIS*(P(5)+P(9)))*0.5/P(1)
      P(18) = P(14) - (CTWIS*(P(5)-P(9)) -
     +STWIS*(P(5)*DXDY1+P(7)+P(9)*DXDY2+P(11)))*0.5/P(1)
C
      P(19) = (CTWIS*(P(5)*DXDY1-P(7)+P(9)*DXDY2-P(11)) +
     +STWIS*(P(5)-P(9)))*0.5
      P(20) = (CTWIS*(P(5)+P(9)) -
     +STWIS*(P(5)*DXDY1-P(7)-P(9)*DXDY2+P(11)))*0.5
      P(21) = P(13) - (CTWIS*(P(5)*DXDY1-P(7)-P(9)*DXDY2+P(11)) +
     +STWIS*(P(5)+P(9)))*0.5/P(1)
      P(22) = P(14) - (CTWIS*(P(5)-P(9)) -
     +STWIS*(P(5)*DXDY1-P(7)+P(9)*DXDY2-P(11)))*0.5/P(1)
C
      P(23) = -(CTWIS*(P(5)*DXDY1+P(6)+P(9)*DXDY2+P(10)) +
     +STWIS*(P(5)-P(9)))*0.5
      P(24) = -(CTWIS*(P(5)+P(9)) -
     +STWIS*(P(5)*DXDY1+P(6)-P(9)*DXDY2-P(10)))*0.5
      P(25) = P(13) + (CTWIS*(P(5)*DXDY1+P(6)-P(9)*DXDY2-P(10)) +
     +STWIS*(P(5)+P(9)))*0.5/P(1)
      P(26) = P(14) + (CTWIS*(P(5)-P(9)) -
     +STWIS*(P(5)*DXDY1+P(6)+P(9)*DXDY2+P(10)))*0.5/P(1)
C
      P(27) = -(CTWIS*(P(5)*DXDY1-P(6)+P(9)*DXDY2-P(10)) +
     +STWIS*(P(5)-P(9)))*0.5
      P(28) = -(CTWIS*(P(5)+P(9)) -
     +STWIS*(P(5)*DXDY1-P(6)-P(9)*DXDY2+P(10)))*0.5
      P(29) = P(13) + (CTWIS*(P(5)*DXDY1-P(6)-P(9)*DXDY2+P(10)) +
     +STWIS*(P(5)+P(9)))*0.5/P(1)
      P(30) = P(14) + (CTWIS*(P(5)-P(9)) -
     +STWIS*(P(5)*DXDY1-P(6)+P(9)*DXDY2-P(10)))*0.5/P(1)
C
C               All done.
C
      DO 970 IL=1,4
      I0=IL*4+11
      CORN(3,IL)=-P(1)
      CORN(1,IL)=P(I0)+P(I0+2)*CORN(3,IL)
      CORN(2,IL)=P(I0+1)+P(I0+3)*CORN(3,IL)
      CORN(3,IL+4)=P(1)
      CORN(1,IL+4)=P(I0)+P(I0+2)*CORN(3,IL+4)
      CORN(2,IL+4)=P(I0+1)+P(I0+3)*CORN(3,IL+4)
  970 CONTINUE
C
+SELF, IF=DEBUG.
C      WRITE(CHMAIL,1000) P,CORN
C      CALL GMAIL(0,0)
C 1000 FORMAT(' P =',10F10.4,/,4X,10F10.4,/,4X,10F10.4,/,' CORN =',
C     +3F10.4,7X,3F10.4,3(/,7X,3F10.4,7X,3F10.4))
+SELF.
C
      RETURN
      END
+DECK,  GTRMUL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GTRMUL(DX1,RMAT1,DX2,IROT,DXNEW,RMATN)
C.
C.    ******************************************************************
C     *                                                                *
C     *       ROUTINE TO FORM THE TRANSFORMATION RESULTING FROM        *
C     *       THE APPLICATION OF FIRST THE TRANSFORMATION GIVEN        *
C     *       BY THE POINT DX1 AND THE MATRIX RMAT1 FOLLOWED BY        *
C     *       THE APPLICATION OF THE TRANSFORMATION GIVEN BY THE       *
C     *       POINT DX2 AND THE MATRIX IN THE GEANT ROTATION           *
C     *        MATRIX BANKS WITH INDEX NUMBER IROT. THE RESULTING      *
C     *       TRANSFORMATION IS STORED AS THE POINT DXNEW AND          *
C     *       MATRIX RMATN.                                            *
C.    *                                                                *
C.    *    ==>Called by : GFTRAC,GINVOL,GLVOLU,GMEDIV,GMEPOS,GSTRAC,   *
C.    *                   GTMEDI                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      DIMENSION DX1(3),RMAT1(10),DX2(3),DXNEW(3),RMATN(10)
C.
C.    ------------------------------------------------------------------
C.
      IF(RMAT1(10).EQ.0.0)THEN
         DXNEW(1) = DX1(1) + DX2(1)
         DXNEW(2) = DX1(2) + DX2(2)
         DXNEW(3) = DX1(3) + DX2(3)
         IF(IROT.EQ.0)THEN
            DO 20 I = 1, 10, 2
               RMATN(I) = RMAT1(I)
               RMATN(I+1) = RMAT1(I+1)
   20       CONTINUE
         ELSE
            JR=LQ(JROTM-IROT)
            DO 30 I = 1, 9
               RMATN(I) = Q(JR+I)
   30       CONTINUE
            RMATN(10)=1.
         ENDIF
      ELSE
C
         DXTEM1 = DX2(1)*RMAT1(1) + DX2(2)*RMAT1(4) + DX2(3)*RMAT1(7)
         DXTEM2 = DX2(1)*RMAT1(2) + DX2(2)*RMAT1(5) + DX2(3)*RMAT1(8)
         DXTEM3 = DX2(1)*RMAT1(3) + DX2(2)*RMAT1(6) + DX2(3)*RMAT1(9)
C
         IF(IROT.EQ.0)THEN
            DO 50 I = 1, 10, 2
               RMATN(I) = RMAT1(I)
               RMATN(I+1) = RMAT1(I+1)
   50       CONTINUE
         ELSE
            CALL GRMUL(RMAT1,IROT,RMATN)
         ENDIF
         DXNEW(1) = DX1(1) + DXTEM1
         DXNEW(2) = DX1(2) + DXTEM2
         DXNEW(3) = DX1(3) + DXTEM3
      ENDIF
      END
+DECK,  GTRNSF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GTRNSF(X,DX,RMAT,XNEW)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       ROUTINE TO APPLY THE TRANSFORMATION GIVEN BY             *
C     *       THE POINT DX AND THE ROTATION MATRIX RMAT TO THE         *
C     *       POINT X, PLACING THE RESULT IN THE POINT XNEW.           *
C.    *                                                                *
C.    *    ==>Called by : GDFR3D, GFTRAC, GINVOL,GMEDIA, GNEXT, GSTRAC,*
C.    *                   GTMEDI, GTNEXT                               *
C.    *         Author  A.McPherson  *********                         *
C     *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),DX(3),RMAT(10),XNEW(3)
C
      IF(RMAT(10).EQ.0.)THEN
         XNEW(1) = X(1) - DX(1)
         XNEW(2) = X(2) - DX(2)
         XNEW(3) = X(3) - DX(3)
*
      ELSE
         XL1 = X(1) - DX(1)
         XL2 = X(2) - DX(2)
         XL3 = X(3) - DX(3)
         XNEW(1) = XL1*RMAT(1) + XL2*RMAT(2) + XL3*RMAT(3)
         XNEW(2) = XL1*RMAT(4) + XL2*RMAT(5) + XL3*RMAT(6)
         XNEW(3) = XL1*RMAT(7) + XL2*RMAT(8) + XL3*RMAT(9)

      ENDIF
      END
+DECK,  GVDCAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GVDCAR(IAXIS,ISH,IROT,PARS,CL,CH,IERR)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    ROUTINE TO FIND THE LIMITS ALONG AXIS IAXIS IN CARTESIAN   *
C.    *    COORDINATES FOR VOLUME OF SHAPE ISH ROTATED BY THE         *
C.    *    ROTATION MATRIX IROT. THE SHAPE HAS NPAR PARAMETERS IN     *
C.    *    THE ARRAY PARS. THE LOWER LIMIT IS RETURNED IN CL, THE     *
C.    *    HIGHER IN CH. IF THE CALCULATION CANNOT BE MADE IERR IS    *
C.    *    SET TO 1 OTHERWISE IT IS SET TO 0.                         *
C.    *                                                               *
C.    *    ==>Called by : GVDLIM                                      *
C.    *         Author  S.Giani  ********                             *
C.    *                                                               *
C.    *****************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION PARS(50),X(3),XT(3)
C.
C.          ---------------------------------------------------
C.
      IERR=1
      IF (ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C           CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
C
      IERR=0
      CL=0
      CH=0
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          UPDATE LIMITS IF NECESSARY.
C
      IF(XT(IAXIS).LT.CL) CL=XT(IAXIS)
      IF(XT(IAXIS).GT.CH) CH=XT(IAXIS)
C
   30 CONTINUE
C
      GO TO 999
C
   40 CONTINUE
      IF(ISH.EQ.9) GO TO 90
C
C              TUBES , CONES, POLYGONS, POLYCONES.
C              AND CUT TUBES.
C
      MYFLAG=0
      IF((ISH.EQ.11.OR.ISH.EQ.12).AND.(IAXIS.LT.3))THEN
        MYFLAG=1
      ENDIF
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          XT IS Z AXIS ROTATED.
C
      IF(MYFLAG.EQ.0)THEN
       IF(ABS(XT(IAXIS)).LT.0.99) GO TO 50
      ELSE
       IF(ABS(XT(3)).LT.0.99) GO TO 50
      ENDIF
      IF(ISH.EQ.11)GO TO 45
      IF(ISH.EQ.12)GO TO 46
C
C           PARALLEL.
C
      IP=3
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14) IP=1
      CL=-PARS(IP)
      CH=PARS(IP)
      IERR=0
C
      GO TO 999
  45  IF(MYFLAG.EQ.0)THEN
       NZLAST=PARS(4)
       IZLAST=2+3*NZLAST
       CL=PARS(5)
       GO TO 49
      ELSEIF(MYFLAG.EQ.1)THEN
       NZLAST=PARS(4)
       IZLAST=2+3*NZLAST
       TMPRAD=0.
       DO 145 I=7,IZLAST+2,3
         IF(PARS(I).GT.TMPRAD)TMPRAD=PARS(I)
 145   CONTINUE
       PHIMIN=PARS(1)
       PHIMAX=PHIMIN+PARS(2)
       AANG=ABS(PHIMAX-PHIMIN)
       NANG=PARS(3)
       AATMAX=NANG*360./AANG
       LATMAX=AATMAX
       ALA=AATMAX-LATMAX
       IF(ALA.GT..5)LATMAX=LATMAX+1
       AFINV=1./COS(PI/LATMAX)
       FINV=ABS(AFINV)
       R=TMPRAD*FINV
       CL=-R
       CH= R
       IERR=0
       GOTO 999
      ENDIF
C
  46  IF(MYFLAG.EQ.0)THEN
       NZLAST=PARS(3)
       IZLAST=1+3*NZLAST
       CL=PARS(4)
      ELSEIF(MYFLAG.EQ.1)THEN
       NZLAST=PARS(3)
       IZLAST=1+3*NZLAST
       TMPRAD=0.
       DO 146 I=6,IZLAST+2,3
         IF(PARS(I).GT.TMPRAD)TMPRAD=PARS(I)
 146   CONTINUE
       CL=-TMPRAD
       CH= TMPRAD
       IERR=0
       GOTO 999
      ENDIF
C
  49  CH=PARS(IZLAST)
      IF ( ABS(XT(IAXIS)-X(IAXIS)) .GT.1.) THEN
         TEMP = CL
         CL = -CH
         CH = -TEMP
      ENDIF
      IERR=0
      GO TO 999
C
   50 CONTINUE
**
      IF(ISH.EQ.13) THEN
         CL=-PARS(IAXIS)
         CH=PARS(IAXIS)
         IERR=0
         GOTO 999
      ENDIF
**
      IF(ISH.EQ.14) THEN
C     for hyperboloid, use escribed cylinder
         CH = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
         CL = -CH
         IERR=0
         GOTO 999
      ENDIF
**
      IF(ISH.GT.10.AND.ISH.NE.NSCTUB)GO TO 999
      IF(ABS(XT(IAXIS)).GT.0.01) GO TO 70
C
C         Z AXIS PERPENDICULAR TO IAXIS. ASSUME COMPLETE TUBE OR
C         CONE (I.E. IGNORE PHI SEGMENTATION).
C
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB) GO TO 60
C
      CL=-PARS(2)
      CH=PARS(2)
      IERR=0
      IF(ISH.EQ.6)THEN
        RMIN=PARS(1)
        RMAX=PARS(2)
        IF(IROT.NE.0)THEN
         IF(Q(JROT+15).EQ.0.)THEN
           PHI1=(PARS(4)+Q(JROT+12))*DEGRAD
           PHI2=(PARS(5)+Q(JROT+12))*DEGRAD
         ELSEIF(Q(JROT+15).EQ.180.)THEN
           PHI1=(PARS(4)+Q(JROT+12)-(PARS(5)-PARS(4)))*DEGRAD
           PHI2=(PARS(5)+Q(JROT+12)-(PARS(5)-PARS(4)))*DEGRAD
         ELSE
           GOTO 999
         ENDIF
        ELSE
         PHI1=PARS(4)*DEGRAD
         PHI2=PARS(5)*DEGRAD
        ENDIF
        IF(IAXIS.EQ.1)THEN
         IF(PHI1.GE.0..AND.PHI2.LE.PI)THEN
          XMIN1=RMIN*COS(PHI2)
          XMIN2=RMAX*COS(PHI2)
          CL=MIN(XMIN1,XMIN2)
          XMAX1=RMIN*COS(PHI1)
          XMAX2=RMAX*COS(PHI1)
          CH=MAX(XMAX1,XMAX2)
         ELSEIF(PHI1.GE.PI.AND.PHI2.LE.TWOPI.OR.
     +          PHI1.GE.-PI.AND.PHI2.LE.0.)THEN
          XMIN1=RMIN*COS(PHI1)
          XMIN2=RMAX*COS(PHI1)
          CL=MIN(XMIN1,XMIN2)
          XMAX1=RMIN*COS(PHI2)
          XMAX2=RMAX*COS(PHI2)
          CH=MAX(XMAX1,XMAX2)
         ELSEIF(PHI1.LT.0..AND.PHI2.GT.0..AND.
     +         (PHI2-PHI1).LE.PI)THEN
          XMIN1=RMIN*COS(PHI2)
          XMIN2=RMIN*COS(PHI1)
          CL1=MIN(XMIN1,XMIN2)
          XMIN3=RMAX*COS(PHI2)
          XMIN4=RMAX*COS(PHI1)
          CL2=MIN(XMIN3,XMIN4)
          CL=MIN(CL1,CL2)
          CH=RMAX
         ELSEIF(PHI1.LT.PI.AND.PHI2.GT.PI.AND.
     +         (PHI2-PHI1).LE.PI)THEN
          CL=-RMAX
          XMAX1=RMIN*COS(PHI2)
          XMAX2=RMIN*COS(PHI1)
          CH1=MAX(XMAX1,XMAX2)
          XMAX3=RMAX*COS(PHI2)
          XMAX4=RMAX*COS(PHI1)
          CH2=MAX(XMAX3,XMAX4)
          CH=MAX(CH1,CH2)
         ENDIF
        ELSEIF(IAXIS.EQ.2)THEN
         IF(PHI1.GE.(-PI*.5).AND.PHI2.LE.(PI*.5))THEN
          YMIN1=RMIN*SIN(PHI1)
          YMIN2=RMAX*SIN(PHI1)
          CL=MIN(YMIN1,YMIN2)
          YMAX1=RMIN*SIN(PHI2)
          YMAX2=RMAX*SIN(PHI2)
          CH=MAX(YMAX1,YMAX2)
         ELSEIF(PHI1.GE.(PI*.5).AND.PHI2.LE.(PI*3*.5))THEN
          YMIN1=RMIN*SIN(PHI2)
          YMIN2=RMAX*SIN(PHI2)
          CL=MIN(YMIN1,YMIN2)
          YMAX1=RMIN*SIN(PHI1)
          YMAX2=RMAX*SIN(PHI1)
          CH=MAX(YMAX1,YMAX2)
         ELSEIF(PHI1.LT.(PI*.5).AND.PHI2.GT.(PI*.5).AND.
     +         (PHI2-PHI1).LE.PI)THEN
          YMIN1=RMIN*SIN(PHI2)
          YMIN2=RMIN*SIN(PHI1)
          CL1=MIN(YMIN1,YMIN2)
          YMIN3=RMAX*SIN(PHI2)
          YMIN4=RMAX*SIN(PHI1)
          CL2=MIN(YMIN3,YMIN4)
          CL=MIN(CL1,CL2)
          CH=RMAX
         ELSEIF(((PHI1.LT.(PI*3*.5).AND.PHI2.GT.(PI*3*.5)).OR.
     +          (PHI1.LT.-(PI*.5).AND.PHI2.GT.-(PI*.5)))
     +          .AND.(PHI2-PHI1).LE.PI)THEN
          CL=-RMAX
          YMAX1=RMIN*SIN(PHI2)
          YMAX2=RMIN*SIN(PHI1)
          CH1=MAX(YMAX1,YMAX2)
          YMAX3=RMAX*SIN(PHI2)
          YMAX4=RMAX*SIN(PHI1)
          CH2=MAX(YMAX3,YMAX4)
          CH=MAX(CH1,CH2)
         ENDIF
        ENDIF
      ENDIF
C
      GO TO 999
C
   60 CONTINUE
C
      RM=PARS(3)
      IF(PARS(5).GT.PARS(3)) RM=PARS(5)
C
      CL=-RM
      CH=RM
      IERR=0
C
      GO TO 999
C
   70 CONTINUE
C
C           ARBITRARY ROTATION.
C
      DZ=PARS(3)
      RM=PARS(2)
      IF(ISH.EQ.13) THEN
**
**       approxime to a cylinder whit radius
**       equal to the ellipse major axis
**
         IF(PARS(1).GT.RM) RM=PARS(1)
         GOTO 80
      ENDIF
**
      IF(ISH.EQ.14) THEN
        RM = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 80
      ENDIF
*
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RM*S1
      ENDIF
      IF(ISH.LE.6) GO TO 80
C
      DZ=PARS(1)
      RM=PARS(3)
      IF(PARS(5).GT.RM) RM=PARS(5)
C
   80 CONTINUE
C
      COST=ABS(XT(IAXIS))
      SINT=(1+COST)*(1-COST)
      IF(SINT.GT.0.0) SINT=SQRT(SINT)
C
      CH=COST*DZ+SINT*RM
      CL=-CH
      IERR=0
C
      GO TO 999
   90 CONTINUE
C
C           SPHERE - ASSUME COMPLETE SPHERE, TAKE OUTER RADIUS.
C
      IERR=0
      CL=-PARS(2)
      CH=PARS(2)
C
  999 CONTINUE
      END
+DECK,  GVDLIM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      SUBROUTINE GVDLIM(JVO,IN,IAXIS,CLOW,CHIGH,IERR)
C.
C.    **********************************************************
C.    *                                                        *
C.    *    ROUTINE TO FIND THE COORDINATE LIMITS ALONG AXIS    *
C.    *    IAXIS FOR THE INTH CONTENT OF THE VOLUME POINTED    *
C.    *    TO BY JVO. THE LIMITS ARE RETURNED AS CLOW AND      *
C.    *    CHIGH.IF THEY CANNOT BE FOUND THEN IERR IS SET TO 1.*
C.    *                                                        *
C.    *    ==>Called by : GGCLOS                               *
C.    *         Author  S.Giani  *********                     *
C.    *                                                        *
C.    **********************************************************
C.
+CDE, GCBANK.
      DIMENSION PAR(50),ATT(20)
C.
C.         -----------------------------------------
C.
      JIN=LQ(JVO-IN)
      IROT=Q(JIN+4)
      IVOT=Q(JIN+2)
      JVOT=LQ(JVOLUM-IVOT)
      ISH=Q(JVOT+2)
C
      CALL GFIPAR(JVOT,JIN,IN,NPAR,NATT,PAR,ATT)
C
C              X,Y OR Z COORDINATES.
C
      IF(IAXIS.GT.3) GO TO 20
C
      CALL GVDCAR(IAXIS,ISH,IROT,PAR,CL,CH,IERR)
      IF(IERR.NE.0) GO TO 999
C
      CLOW=CL+Q(JIN+IAXIS+4)
      CHIGH=CH+Q(JIN+IAXIS+4)
C
      GO TO 999
C
   20 CONTINUE
      IF(IAXIS.GT.5) GO TO 30
C
C          R COORDINATES.
C
      CALL GVDRAD(IAXIS,ISH,IROT,Q(JIN+5),PAR,CLOW, CHIGH,IERR)

C
      GO TO 999
C
   30 CONTINUE
C
C          PHI OR THETA COORDINATES.
C
      IF(IAXIS.EQ.6) CALL GVDPHI(ISH,IROT,Q(JIN+5), PAR,CLOW,CHIGH,
     +IERR)
C
      IF(IAXIS.EQ.7) CALL GVDTHE(ISH,IROT,Q(JIN+5), PAR,CLOW,CHIGH,
     +IERR)
C
  999 CONTINUE
      END
+DECK,  GVDPHI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      SUBROUTINE GVDPHI(ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    **********************************************************
C.    *                                                        *
C.    *    ROUTINE TO FIND THE PHI LIMITS OF THE OBJECT SHAPE  *
C.    *    ISH ROTATED BY MATRIX IROT AND DISPLACED BY VECTOR  *
C.    *    DX. IT HAS NPAR PARAMTERS IN THE ARRAY PARS. THE    *
C.    *    LOWER LIMIT IS RETURNED IN CL AND THE HIGHER IN CH. *
C.    *    NOTE THE OBJECT IS CONTAINED IN THE RANGE OF        *
C.    *    INCREASING PHI FROM CL TO CH THOUGH CL AND CH ARE   *
C.    *    FORCED TO LIE IN THE RANGE 0.0 TO 360.0 SO THAT THE *
C.    *    VALUE OF CL CAN BE HIGHER THAN THAT OF CH.          *
C.    *                                                        *
C.    *    ==>Called by : GVDLIM modified                      *
C.    *         Author  S.Giani  *********                     *
C.    *                                                        *
C.    **********************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION DX(3),PARS(50),X(3),XT(3)
C.
C.          -------------------------------------------
C.
      IERR=1
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C
C           CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
      IERR=0
      CL=0.0
      CH=360.0
C
C           IF IN DOUBT SET IT TO FULL RANGE.
C
      IF(DXS.LE.0.0) GO TO 999
C
      PHC=90.
      IF(DX(1).NE.0.)PHC=ATAN2(DX(2),DX(1))*RADDEG
      IF(DX(1).EQ.0..AND.DX(2).LT.0.)PHC=-90.
      IF(PHC.LT.0.0) PHC=PHC+360
      PL=0.0
      PH=0.0
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
      XPT=DXS+(DX(1)*XT(1)+DX(2)*XT(2))/DXS
      YPT=(DX(1)*XT(2)-DX(2)*XT(1))/DXS
C
      IF(YPT.EQ.0.0.AND.XPT.EQ.0.0) GO TO 999
      P=ATAN2(YPT,XPT)
      IF(P.GT.PI) P=P-PI*2.0
      IF(P.LT.PL) PL=P
      IF(P.GT.PH) PH=P
C
C
   30 CONTINUE
C
C
      IF(PH-PL.GT.PI) GO TO 999
      CL=PHC+PL*RADDEG
      CH=PHC+PH*RADDEG
C
***      SG = SIGN(1.0,CL)
***      CL = MOD( ABS(CL),360.0 )
***      IF(SG.LE.0.0) CL=360.-CL
***      SG=SIGN(1.0,CH)
***      CH = MOD( ABS(CH),360.0 )
***      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   40 CONTINUE
      MYFLAG=0
      IF(ISH.EQ.11)THEN
       NZLAST=PARS(4)
       IZLAST=2+3*NZLAST
       CLZ=PARS(5)
       CHZ=PARS(IZLAST)
       DZ2=ABS(CHZ-CLZ)
       DZ=DZ2*.5
       TMPRAD=0.
       TMPMIN=100000.
       DO 145 I=7,IZLAST+2,3
         IF(PARS(I).GT.TMPRAD)TMPRAD=PARS(I)
         IF(PARS(I-1).LT.TMPMIN)TMPMIN=PARS(I-1)
 145   CONTINUE
       RLOW=TMPMIN
       PHIMIN=PARS(1)
       PHIMAX=PHIMIN+PARS(2)
       AANG=ABS(PHIMAX-PHIMIN)
       NANG=PARS(3)
       AATMAX=NANG*360./AANG
       LATMAX=AATMAX
       ALA=AATMAX-LATMAX
       IF(ALA.GT..5)LATMAX=LATMAX+1
       AFINV=1./COS(PI/LATMAX)
       FINV=ABS(AFINV)
       RM=TMPRAD*FINV
       IF(PARS(2).EQ.360)THEN
        MYFLAG=5
       ELSE
        PHIMIN=PARS(1)*DEGRAD
        PHIMAX=(PARS(1)+PARS(2))*DEGRAD
        MYFLAG=6
       ENDIF
      ELSEIF(ISH.EQ.12)THEN
       NZLAST=PARS(3)
       IZLAST=1+3*NZLAST
       CLZ=PARS(4)
       CHZ=PARS(IZLAST)
       DZ2=ABS(CHZ-CLZ)
       DZ=DZ2*.5
       TMPRAD=0.
       TMPMIN=100000.
       DO 146 I=6,IZLAST+2,3
         IF(PARS(I).GT.TMPRAD)TMPRAD=PARS(I)
         IF(PARS(I-1).LT.TMPMIN)TMPMIN=PARS(I-1)
 146   CONTINUE
       RM=TMPRAD
       RLOW=TMPMIN
       IF(PARS(2).EQ.360)THEN
        MYFLAG=5
       ELSE
        PHIMIN=PARS(1)*DEGRAD
        PHIMAX=(PARS(1)+PARS(2))*DEGRAD
        MYFLAG=6
       ENDIF
      ELSEIF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14)THEN
        GO TO 80
      ENDIF
C
C             TUBES AND CONES.
C
      IERR=0
      CL=0.0
      CH=360.0
C
C             WHEN IN DOUBT SET TO FULL RANGE.
C
      IF(MYFLAG.EQ.0)RM=PARS(2)
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB.OR.MYFLAG.NE.0) GO TO 50
**
      IF(ISH.EQ.13) THEN
**
**       approxime to a cylinder whit radius
**       equal to the ellipse major axis
**
         IF(PARS(1).GT.RM) RM=PARS(1)
         GOTO 50
      ENDIF
      IF(ISH.EQ.14) THEN
        RM = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 50
      ENDIF
      RM=PARS(3)
      IF(PARS(5).GT.RM) RM=PARS(5)
C
   50 CONTINUE
C
      IF(DXS.GT.RM) GO TO 70
      IF(ISH.EQ.5.OR.ISH.EQ.7.OR.ISH.EQ.14.OR.MYFLAG.EQ.5) GO TO 999
      IF(ISH.EQ.13) GOTO 999
*                 Here we treat the CONS and TUBS
*                 This is the simple case, no rotation
*                 Compute the position of the limits on
*                 the X-Y plane.
      IF(MYFLAG.EQ.0.AND.ISH.LE.6)THEN
       PHIMIN=PARS(4)*DEGRAD
       PHIMAX=PARS(5)*DEGRAD
       RLOW=PARS(1)
      ELSEIF(MYFLAG.EQ.0.AND.ISH.EQ.8)THEN
        PHIMIN=PARS(6)*DEGRAD
        PHIMAX=PARS(7)*DEGRAD
        RLOW=MIN(PARS(2),PARS(4))
      ENDIF
      CL=PHIMIN*RADDEG
      CH=PHIMAX*RADDEG
      IF(DXS.NE.0.)THEN
       DDX1 = DX(1)+RM*COS(PHIMIN)
       DDY1 = DX(2)+RM*SIN(PHIMIN)
       DDX2 = DX(1)+RM*COS(PHIMAX)
       DDY2 = DX(2)+RM*SIN(PHIMAX)
       CLA = ATAN2(DDY1,DDX1)*RADDEG
       CHA = ATAN2(DDY2,DDX2)*RADDEG
       DDX1 = DX(1)+RLOW*COS(PHIMIN)
       DDY1 = DX(2)+RLOW*SIN(PHIMIN)
       DDX2 = DX(1)+RLOW*COS(PHIMAX)
       DDY2 = DX(2)+RLOW*SIN(PHIMAX)
       CLB = ATAN2(DDY1,DDX1)*RADDEG
       CHB = ATAN2(DDY2,DDX2)*RADDEG
       CL=MIN(CLA,CLB,CHA,CHB)
       CH=MAX(CLA,CLB,CHA,CHB)
       IF((CH-CL).GT.(PHIMAX-PHIMIN)*RADDEG)THEN
         IF(ISH.EQ.6.OR.ISH.EQ.8.OR.MYFLAG.EQ.6)THEN
           IF(DXS.GT.RLOW)THEN
              CL=0.
              CH=360.
           ENDIF
         ELSE
           CL=0.
           CH=360.
         ENDIF
       ENDIF
      ENDIF
C
   60 CONTINUE
C
      IF(IROT.EQ.0) GO TO 65
      IF(CL.EQ.0..AND.CH.EQ.360.)GOTO 65
      JROT=LQ(JROTM-IROT)
      IF(Q(JROT+15).NE.0.0.AND.Q(JROT+15).NE.180.0)THEN
        CL=0.
        CH=360.
        GO TO 999
      ENDIF
C
      PHX=Q(JROT+12)
      PHY=Q(JROT+14)
      IF(PHY.LT.PHX) PHY=PHY+360.0
      ISPH=1
      IF(PHY-PHX.GT.180.0) ISPH=-1
      IF(DXS.NE.0.)THEN
       PHI1 = ISPH*PHIMIN+PHX*DEGRAD
       PHI2 = ISPH*PHIMAX+PHX*DEGRAD
       DDX1 = DX(1)+RM*COS(PHI1)
       DDY1 = DX(2)+RM*SIN(PHI1)
       DDX2 = DX(1)+RM*COS(PHI2)
       DDY2 = DX(2)+RM*SIN(PHI2)
       CLA = ATAN2(DDY1,DDX1)*RADDEG
       CHA = ATAN2(DDY2,DDX2)*RADDEG
       DDX1 = DX(1)+RLOW*COS(PHI1)
       DDY1 = DX(2)+RLOW*SIN(PHI1)
       DDX2 = DX(1)+RLOW*COS(PHI2)
       DDY2 = DX(2)+RLOW*SIN(PHI2)
       CLB = ATAN2(DDY1,DDX1)*RADDEG
       CHB = ATAN2(DDY2,DDX2)*RADDEG
       CL=MIN(CLA,CLB,CHA,CHB)
       CH=MAX(CLA,CLB,CHA,CHB)
      ELSE
       CL=ISPH*CL+PHX
       CH=ISPH*CH+PHX
      ENDIF
      IF(ISPH.EQ.1) GO TO 65
      CHT=CH
      CH=CL
      CL=CHT
C
   65 CONTINUE
C
***      SG=SIGN(1.0,CL)
***      CL = MOD( ABS(CL),360.0 )
***      IF(SG.LE.0.0) CL=360.-CL
***      SG=SIGN(1.0,CH)
***      CH = MOD( ABS(CH),360.0 )
***      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   70 CONTINUE
C
C            DISPLACEMENT GREATER THAN MAXIMUM RADIUS SO
C            ASSUME COMPLETE TUBE TO GENERATE 'WORST CASE'.
C
      IF(MYFLAG.EQ.0)DZ=PARS(3)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RM*S1
      ELSEIF(ISH.GT.6.AND.ISH.NE.13.AND.ISH.NE.14.AND.MYFLAG.EQ.0)THEN
        DZ=PARS(1)
      ENDIF
C
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
C
C                    LOCAL Z AXIS.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
      COST=ABS(DX(1)*XT(1)+DX(2)*XT(2))
      COS2=ABS(DX(1)*XT(2)-DX(2)*XT(1))
      SINT=(DXS+COST)*(DXS-COST)
      SIN2=(DXS+COS2)*(DXS-COS2)
      IF(SINT.GT.0.0) SINT=SQRT(SINT)
      IF(SIN2.GT.0.0) SIN2=SQRT(SIN2)
C
      XPT=DXS-(COST*DZ+SINT*RM)/DXS
C
      IF(XPT.LE.0.0) GO TO 999
      YPT=(SIN2*RM+COS2*DZ)/DXS
      DP=ATAN(YPT/XPT)
C
      P0=ATAN2(DX(2),DX(1))
      CL=(P0-DP)*RADDEG
      CH=(P0+DP)*RADDEG
C
***      SG=SIGN(1.0,CL)
***      CL = MOD( ABS(CL),360.0 )
***      IF(SG.LE.0.0) CL=360.-CL
***      SG=SIGN(1.0,CH)
***      CH = MOD( ABS(CH),360.0 )
***      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   80 CONTINUE
      IF(ISH.GT.9.AND.MYFLAG.EQ.0) GO TO 999
C
C               SPHERE.
C
      IERR=0
      CL=0.0
      CH=360.0
C
      IF(IROT.NE.0.OR.DXS.GT.0.0) GO TO 90
C
C          UNROTATED AND CENTERED.
C
      CL=PARS(5)
      CH=PARS(6)
C
***      SG=SIGN(1.0,CL)
***      CL = MOD( ABS(CL),360.0 )
***      IF(SG.LE.0.0) CL=360.-CL
***      SG=SIGN(1.0,CH)
***      CH = MOD( ABS(CH),360.0 )
***      IF(SG.LE.0.0) CH=360.-CH
C
      GO TO 999
C
   90 CONTINUE
C
C            ROTATED OR NOT CENTERED.
C
      IF(DXS.LT.PARS(2)) GO TO 999
      P0=ATAN2(DX(2),DX(1))
      DP=ASIN(PARS(2)/DXS)
      CL=(P0-DP)*RADDEG
      CH=(P0+DP)*RADDEG
C
***      SG=SIGN(1.0,CL)
***      CL = MOD( ABS(CL),360.0 )
***      IF(SG.LE.0.0) CL=360.-CL
***      SG=SIGN(1.0,CH)
***      CH = MOD( ABS(CH),360.0 )
***      IF(SG.LE.0.0) CH=360.-CH
C
  999 CONTINUE
      END
+DECK,  GVDRAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:56  cernlib
* Geant

      SUBROUTINE GVDRAD(IAXIS,ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO COMPUTE THE LIMITS IN R FOR THE SHAPE ISH        *
C.    *    DISPLACED BY THE VECTOR DX AND ROTATED BY THE MATRIX IROT.  *
C.    *    IF IAXIS = 4 THE R IS THE XY PLANE R, IF IAXIS = 5 IT IS    *
C.    *    THE 3 DINEMSIONAL SPACE R. THE SHAPE HAS NPAR PARAMETERS    *
C.    *    IN THE ARRAY PARS. THE LOWER LIMIT IS RETURNED IN CL AND    *
C.    *    THE HIGHER IN CH. IF THE CALCULATION CANNOT BE PERFORMED    *
C.    *    IERR IS SET TO 1 OTHERWISE IT IS SET TO 0.                  *
C.    *                                                                *
C.    *    ==>Called by : GVDLIM                                       *
C.    *         Author  S.Giani  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION DX(3),PARS(50),X(3),XT(3)
C.
C.           --------------------------------------------------
C.
      IERR=1
C
C            FIRST CALCULATE THE LENGTH OF THE DISPLACEMENT OF THE
C            ORIGIN.
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(IAXIS.EQ.5) DXS=DXS+DX(3)*DX(3)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C          CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
      CH=0.0
      CL=DXS
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          NOW COMPUTE RMIN = PROJECTED R ON DX AND RMAX = R
C          AND UPDATE LIMITS IF NECESSARY.
C
      R2=(XT(1)+DX(1))**2+(XT(2)+DX(2))**2
      IF(IAXIS.EQ.5) R2=R2+(XT(3)+DX(3))**2
      R=SQRT(R2)
      IF(R.GT.CH) CH=R
C
      IF(CL.LE.0.0) GO TO 30
C
      XPT=DX(1)*XT(1)+DX(2)*XT(2)
      IF(IAXIS.EQ.5) XPT=XPT+DX(3)*XT(3)
      IF(DXS.LE.1.0E-05) GO TO 30
      RMN=DXS+XPT/DXS
      IF(RMN.LT.CL) CL=RMN
C
   30 CONTINUE
C
      IF(CL.LE.0.0) CL=0.0
C
      IERR=0
      GO TO 999
C
   40 CONTINUE
C
C          POLYGONES AND POLYCONES
C
      IF(ISH.EQ.11.AND.IAXIS.EQ.4)THEN
       NZLAST=PARS(4)
       IZLAST=2+3*NZLAST
       CLZ=PARS(5)
       CHZ=PARS(IZLAST)
       DZ2=ABS(CHZ-CLZ)
       DZ=DZ2*.5
       TMPRAD=0.
       TMPMIN=100000.
       DO 145 I=7,IZLAST+2,3
         IF(PARS(I).GT.TMPRAD)TMPRAD=PARS(I)
         IF(PARS(I-1).LT.TMPMIN)TMPMIN=PARS(I-1)
 145   CONTINUE
       RMN=TMPMIN
       PHIMIN=PARS(1)
       PHIMAX=PHIMIN+PARS(2)
       AANG=ABS(PHIMAX-PHIMIN)
       NANG=PARS(3)
       AATMAX=NANG*360./AANG
       LATMAX=AATMAX
       ALA=AATMAX-LATMAX
       IF(ALA.GT..5)LATMAX=LATMAX+1
       AFINV=1./COS(PI/LATMAX)
       FINV=ABS(AFINV)
       R=TMPRAD*FINV
       GOTO 50
      ELSEIF(ISH.EQ.12.AND.IAXIS.EQ.4)THEN
       NZLAST=PARS(3)
       IZLAST=1+3*NZLAST
       CLZ=PARS(4)
       CHZ=PARS(IZLAST)
       DZ2=ABS(CHZ-CLZ)
       DZ=DZ2*.5
       TMPRAD=0.
       TMPMIN=100000.
       DO 146 I=6,IZLAST+2,3
         IF(PARS(I).GT.TMPRAD)TMPRAD=PARS(I)
         IF(PARS(I-1).LT.TMPMIN)TMPMIN=PARS(I-1)
 146   CONTINUE
       RMN=TMPMIN
       R=TMPRAD
       GOTO 50
      ENDIF
      IF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14)GO TO 80
C
C             TUBES AND CONES
C
      IP3=3
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14) IP3=1
      DZ=PARS(IP3)
      R=PARS(2)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+R*S1
      ENDIF
**
      IF(ISH.EQ.13) THEN
**
**       APPROXIME TO A CYLINDER WHIT RADIUS
**       EQUAL TO THE ELLIPSE MAJOR AXIS
**
         RMN=0.0
         IF(PARS(1).GT.R) R=PARS(1)
         GOTO 50
      ENDIF
      RMN=PARS(1)
*
      IF(ISH.EQ.14) THEN
        R = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 50
      ENDIF
C
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 50
C
      R=PARS(3)
      IF(PARS(5).GT.R) R=PARS(5)
      RMN=PARS(2)
      IF(PARS(4).LT.RMN) RMN=PARS(4)
C
   50 CONTINUE
C
C          ROTATE THE LOCAL Z AXIS.
C
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          COMPUTE RMIN AND RMAX ASSUMING COMPLETE TUBE HALF
C          LENGTH DZ AND RADIUS R.
C
      ST2=1.0
      IF(IAXIS.EQ.4) ST2=(1+XT(3))*(1-XT(3))
      DR=SQRT(DZ*DZ*ST2+R*R)
      CL=DXS-DR
      IF(CL.LT.0.0) CL=0.0
      CH=DXS+DR
      IF(ABS(XT(3)).EQ.1.0.AND.DXS.LT.1.0E-05) CL=RMN
      IERR=0
C
      GO TO 999
C
   80 CONTINUE
      IF(ISH.GT.9) GO TO 999
C
C           SPHERE.
C
      CL=DXS-PARS(2)
      IF(CL.LT.0.0) CL=0.0
      CH=DXS+PARS(2)
      IF(IAXIS.EQ.5.AND.DXS.LT.1.0E-05) CL=PARS(1)
      IERR=0
C
  999 CONTINUE
      END
+DECK,  GVDTHE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      SUBROUTINE GVDTHE(ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO COMPUTE THE THETA LIMITS FOR VOLUME OF SHAPE     *
C.    *    ISH ROTATED BY MATRIX IROT AND DISPLACED BY VECTOR DX.      *
C.    *    THE VOLUME HAS NPAR PARAMETERS IN THE ARRAY PARS. THE LOWER *
C.    *    LIMIT IS RETURNED IN CL THE HIGHER IN CH. IF THE            *
C.    *    CALCULATION CANNOT BE MADE IERR IS SET TO 1 OTHERWISE IT    *
C.    *    IS SET TO 0.                                                *
C.    *                                                                *
C.    *    ==>Called by : GVDLIM                                       *
C.    *         Author  S.Giani  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCSHNO.
      DIMENSION DX(3),PARS(50),X(3),XT(3),X1(3),X2(3),XT1(3),XT2(3)
C.
C.          ----------------------------------------------
C.
      IERR=1
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 130
C
C            CUBES, TRAPEZOIDS AND PARALLELEPIPEDS.
C
      IERR=0
      CL=0.0
      CH=180.0
C
      IF(DXS.LE.0.0) GO TO 999
C
      TH=90.
      IF(ABS(DX(3)).LT.1.0E-06)GO TO 5
      TH=ATAN(DXS/DX(3))*RADDEG
      IF(TH.LT.0.0) TH=TH+180.0
   5  TL=TH
C
      DO 50 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
         goto 999
C            General twisted trapezoid.
C
*         IL=(IP+1)/2
*         I0=IL*4+11
*         IS=(IP-IL*2)*2+1
*         X(3)=PARS(1)*IS
*         X(1)=PARS(I0)+PARS(I0+2)*X(3)
*         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
*         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
      Z=DX(3)+XT(3)
      R=(DX(1)+XT(1))**2+(DX(2)+XT(2))**2
      RT=R+(DX(3)+XT(3))**2
      IF(RT.LT.1.0E-10) GO TO 999
C
      IF(R.GT.0.0) GO TO 30
      IF(Z.GT.0.0) T=0.0
      IF(Z.LT.0.0) T=180.0
      GO TO 40
C
   30 CONTINUE
      T=90.0
      IF(ABS(Z).LT.1.0E-6) GO TO 40
C
      R=SQRT(R)
      T=ATAN(R/Z)*RADDEG
      IF(T.EQ.0.0.AND.Z.LT.0.0) T=180.0
      IF(T.LT.0.0) T=T+180.0
C
   40 CONTINUE
      IF(T.GT.TH) TH=T
      IF(T.LT.TL) TL=T
C
   50 CONTINUE
C
C           THETA LIMITS SET FROM THE POINTS NOW DO THE EDGES.
C
      DO 120 IL=1,12
C
C           FIND THE END POINT NUMBERS FOR EACH EDGE.
C
      IF(IL.GT.4) GO TO 60
      IPP1=1
      IF(IL.GT.2) IPP1=4
      IPP2=2
      IF(MOD(IL,2).EQ.1) IPP2=3
C
      GO TO 80
   60 CONTINUE
      IF(IL.LT.9) GO TO 70
C
      IPP1=5
      IF(IL.GT.10) IPP1=8
      IPP2=6
      IF(MOD(IL,2).EQ.1) IPP2=7
C
      GO TO 80
   70 CONTINUE
C
      IPP1=IL-4
      IPP2=IL
C
   80 CONTINUE
C
C           NOW GET THE POINTS AND ROTATE THEM.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         ILL=IPP1
         IF(IPP1.EQ.3) ILL=4
         IF(IPP1.EQ.4) ILL=3
         I0=ILL*4+11
         X1(3)=PARS(1)
         IF(IPP1.LT.5) X1(3)=-X1(3)
         X1(1)=PARS(I0)+PARS(I0+2)*X1(3)
         X1(2)=PARS(I0+1)+PARS(I0+3)*X1(3)
         ILL=IPP2
         IF(IPP2.EQ.3) ILL=4
         IF(IPP2.EQ.4) ILL=3
         I0=ILL*4+11
         X2(3)=PARS(1)
         IF(IPP2.LT.5) X2(3)=-X2(3)
         X2(1)=PARS(I0)+PARS(I0+2)*X2(3)
         X2(2)=PARS(I0+1)+PARS(I0+3)*X2(3)
C
         GO TO 100
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X1(3)=PARS(IP3)
      IF(IPP1.LE.4) X1(3)=-X1(3)
      IP2=3
      IF(ISH.GT.2.AND.X1(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X1(3).GT.0.0) IP2=8
      X1(2)=PARS(IP2)
      IF(MOD(IPP1+3,4).LT.2) X1(2)=-X1(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X1(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X1(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X1(2).GT.0.0) IP1=IP1+1
      X1(1)=PARS(IP1)
      IF(MOD(IPP1,2).EQ.1) X1(1)=-X1(1)
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X2(3)=PARS(IP3)
      IF(IPP2.LE.4) X2(3)=-X2(3)
      IP2=3
      IF(ISH.GT.2.AND.X2(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X2(3).GT.0.0) IP2=8
      X2(2)=PARS(IP2)
      IF(MOD(IPP2+3,4).LT.2) X2(2)=-X2(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X2(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X2(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X2(2).GT.0.0) IP1=IP1+1
      X2(1)=PARS(IP1)
      IF(MOD(IPP2,2).EQ.1) X2(1)=-X2(1)
C
      IF(ISH.NE.10) GO TO 90
      X1(1)=X1(1)+X1(2)*PARS(4)+X1(3)*PARS(5)
      X1(2)=X1(2)+X1(3)*PARS(6)
      X2(1)=X2(1)+X2(2)*PARS(4)+X2(3)*PARS(5)
      X2(2)=X2(2)+X2(3)*PARS(6)
   90 CONTINUE
C
      IF(ISH.NE.4) GO TO 100
      IP4=7
      IF(X1(3).GT.0.0) IP4=11
      X1(1)=X1(1)+X1(2)*PARS(IP4)+X1(3)*PARS(2)
      X1(2)=X1(2)+X1(3)*PARS(3)
      IP4=7
      IF(X2(3).GT.0.0) IP4=11
      X2(1)=X2(1)+X2(2)*PARS(IP4)+X2(3)*PARS(2)
      X2(2)=X2(2)+X2(3)*PARS(3)
  100 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT1(1)=X1(1)
      XT1(2)=X1(2)
      XT1(3)=X1(3)
      IF(IROT.NE.0) CALL GINROT(X1,Q(JROT+1),XT1)
      XT2(1)=X2(1)
      XT2(2)=X2(2)
      XT2(3)=X2(3)
      IF(IROT.NE.0) CALL GINROT(X2,Q(JROT+1),XT2)
C
C           NOW WE HAVE THE END POINTS IN THE MASTER SYSTEM.
C           FIND THE TANGENT POINT TO THE SET OF CONES OF CONSTANT
C           THETA.
C
      DS=(XT2(1)-XT1(1))**2+(XT2(2)-XT1(2))**2+(XT2(3)-XT1(3))**2
      IF(DS.LE.0.0) GO TO 120
C
      DS=SQRT(DS)
C
      X0=(XT2(1)+XT1(1))/2.0+DX(1)
      Y0=(XT2(2)+XT1(2))/2.0+DX(2)
      Z0=(XT2(3)+XT1(3))/2.0+DX(3)
      ALX=(XT2(1)-XT1(1))/DS
      ALY=(XT2(2)-XT1(2))/DS
      ALZ=(XT2(3)-XT1(3))/DS
C
      T=90.0
      IF(Z0.EQ.0.0.AND.ALZ.EQ.0.0) GO TO 110
C
      IF(ALX.EQ.0.0.AND.ALY.EQ.0.0) GO TO 120
C             THIS CHECKS WHETHER THE LINE IS PARALLEL TO THE
C             Z AXIS IN WHICH CASE THERE IS NO TANGENT AND
C             THE END POINTS DETERMINE THE THETA RANGE.
C
      SNUM=(X0*Z0*ALX+Y0*Z0*ALY+X0*X0*ALZ+Y0*Y0*ALZ)
      SDEN=(Z0*ALX*ALX-X0*ALX*ALZ+Z0*ALY*ALY-Y0*ALY*ALZ)
C
      IF(ABS(SNUM).GT.0.5*DS*ABS(SDEN)) GO TO 120
C
C           TANGENT EXIST BETWEEN THE TWO ENDS.
C
      S = SNUM/SDEN
      X0=X0+S*ALX
      Y0=Y0+S*ALY
      Z0=Z0+S*ALZ
C
      R=X0*X0+Y0*Y0
      RT=R+Z0*Z0
C
      IF(RT.LT.1.0E-10) GO TO 999
C
      IF(R.GT.0.0) R=SQRT(R)
      T=90.0
      IF(ABS(Z0).LT.1.0E-06) GO TO 110
C
      T=ATAN(R/Z0)*RADDEG
      IF(T.EQ.0.0.AND.Z0.LT.0.0) T=180.0
      IF(T.LT.0.0) T=T+180.0
C
  110 CONTINUE
C
      IF(T.LT.TL) TL=T
      IF(T.GT.TH) TH=T
C
C        CHECK FOR THE POSSIBILITY OF STRADDLING T=0.0 &/OR 180.0.
C
      C=X0*DX(1)+Y0*DX(2)
      IF(C.GT.0.0) GO TO 120
C
C          CHECK IF SAME SIGN OF Z.
C
      IF(Z0*DX(3).LT.0.0) GO TO 999
C
      T=0.0
      IF(Z0.LT.0.0) T=180.0
      IF(T.LT.TL) TL=T
      IF(T.GT.TH) TH=T
C
  120 CONTINUE
C
C            DONE SET THE LIMITS.
C
      CL=TL
      CH=TH
C
      GO TO 999
C
  130 CONTINUE
C
C          TUBES, CONES ETC.
C
      IF(IROT.NE.0.OR.DXS.GT.1.0E-05) GO TO 180
C
C          UNROTATED AND CENTERED.
C
      IF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13
     +           .AND.ISH.NE.14)GO TO 170
C
C               TUBES AND CONES.
C
      IERR=0
      DZ=PARS(3)
      RMN=PARS(1)
      RMX=PARS(2)
      IF(ISH.EQ.13) THEN
**
**         approxime to a cylinder whit radius
**         equal to the ellipse major axis
**
        RMN=0.0
        IF(PARS(1).GT.RMX) RMX=PARS(1)
        GOTO 140
      ENDIF
      IF(ISH.EQ.14) THEN
C   not really sure of the function of these... keep RMN=PARS(1)
        RMX = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 140
      ENDIF
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RMX*S1
      ENDIF
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 140
      DZ=PARS(1)
      RMN=PARS(2)
      RMX=PARS(3)
      IF(PARS(4).LT.RMN) RMN=PARS(4)
      IF(PARS(5).GT.RMX) RMX=PARS(5)
  140 CONTINUE
C
      IF(DZ.GT.ABS(DX(3))) GO TO 160
C
C          ALL FORWARD OR ALL BACK.
C
      DSH=DX(3)-DZ
      DLN=DX(3)+DZ
      IF(DX(3).GT.0.0) GO TO 150
      DSS=DSH
      DSH=DLN
      DLN=DSS
  150 CONTINUE
C
      CL=90.0
      CH=90.0
      IF(DLN.NE.0.0) CL=ATAN(RMN/DLN)*RADDEG
      IF(DSH.NE.0.0) CH=ATAN(RMX/DSH)*RADDEG
      IF(DX(3).GT.0.0) GO TO 999
      CS=CL
      CL=CH
      CH=CS
      IF(CH.EQ.0.0) CH=180.0
      IF(CL.LT.0.0) CL=CL+180.0
      IF(CH.LT.0.0) CH=CH+180.0
C
      GO TO 999
C
  160 CONTINUE
C
      CL=90.0
      CH=90.0
      IF(DZ+DX(3).NE.0.0) CL=ATAN(RMN/(DZ+DX(3)))*RADDEG
      IF(-DZ+DX(3).NE.0.0) CH=ATAN(RMN/(-DZ+DX(3)))*RADDEG
      IF(CH.LE.0.0) CH=CH+180.0
C
      GO TO 999
C
  170 CONTINUE
      IF(ISH.GT.9) GO TO 999
C
C           SPHERE.
C
      IERR=0
      CL=PARS(3)
      CH=PARS(4)
C
      GO TO 999
  180 CONTINUE
C
      IF(ISH.EQ.11.OR.ISH.EQ.12) GOTO 999
**
      RM=PARS(2)
      IF(ISH.EQ.9) GO TO 200
C
      DZ=PARS(3)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+RM*S1
      ENDIF
**
      IF(ISH.EQ.13) THEN
        IF(PARS(1).GT.RM) RM=PARS(1)
        GOTO 190
      ENDIF
**
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 190
C
      DZ=PARS(1)
      RM=PARS(3)
      IF(PARS(5).GT.RM) RM=PARS(5)
C
  190 CONTINUE
C
      RM=SQRT(RM**2+DZ**2)
C
  200 CONTINUE
C
      CL=0.0
      CH=180.0
      IERR=0
      RC=DXS**2+DX(3)**2
      IF(RC.GT.0.0) RC=SQRT(RC)
      IF(RM.GE.RC) GO TO 999
C
      TC=90.0
      IF(ABS(DX(3)).GT.0.0) TC=ATAN(DXS/DX(3))*RADDEG
      IF(TC.LT.0.0) TC=TC+180.0
C
      DT=ASIN(RM/RC)*RADDEG
      CL=TC-DT
      CH=TC+DT
      IF(CL.LT.0.0) CL=0.0
      IF(CH.GT.180.0) CH=180.0
C
  999 CONTINUE
      END
+DECK,  GVGRAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      SUBROUTINE GVGRAD (XYZ, C, NC, GRA)
************************************************************************
*                                                                      *
* GVGRAD calculates the gradient vector of a surface         VP 880314 *
*                                                                      *
* Input  : XYZ     coordinates of the point                            *
*          C(1)       number of non constant coefficients of the       *
*                        surface                                       *
*          C(2),C(3),... non constant coefficients of the surface      *
*          NC      total number of coefficients of the surface         *
*                                                                      *
* Output : GRA     gradient vector of the surface                      *
*                                                                      *
************************************************************************
      REAL           XYZ(3) , C(*), GRA(3)
*-----------------------------------------------------------------------
*
*     case with simplified surface X=C0, Y=C0, Z=C0, X*2+Y*2=C0
*     (happens only when initialisation is done)
*
      IF (NC.EQ.2)              THEN
        IAX = C(2)
        IF (IAX.LE.3)           THEN
          GRA(1) = 0
          GRA(2) = 0
          GRA(3) = 0
          GRA(IAX) = 1
        ELSE
          GRA(1)   = 2.*XYZ(1)
          GRA(2)   = 2.*XYZ(2)
          GRA(3)   = 0.
        ENDIF
        GO TO 999
      ENDIF
*
*     case with surfaces with 4, 7 or 10 coefficients (normal case)
*
      GRA(1) = C(2)
      GRA(2) = C(3)
      GRA(3) = C(4)
      IF (NC.EQ.4)              GO TO 999
*
*     case with surfaces with 7 or 10 coefficients
*
      DO 100 I = 1,3
  100   GRA(I) = GRA(I) + 2.*C(I+4)*XYZ(I)
      IF (NC.NE.10)             GO TO 999
*
*     case with surfaces with 10 coefficients
*
      GRA(1)   = GRA(1) + C(8)*XYZ(2)+C(10)*XYZ(3)
      GRA(2)   = GRA(2) + C(8)*XYZ(1)+C( 9)*XYZ(3)
      GRA(3)   = GRA(3) + C(9)*XYZ(2)+C(10)*XYZ(1)

  999 RETURN
      END
+DECK,  GVLONG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      SUBROUTINE GVLONG (DIR, C, NC, TAU, NTAU)
************************************************************************
*                                                                      *
* GVLONG calculates the distance to the surface along a      VP 920125 *
*        given DIRection                                               *
*                                                                      *
*        SHOULD BE called ONLY AFTER call GVSAFE.                      *
*        due to some results of GVSAFE are used.                       *
*        Just by this reason starting XYZ point                        *
*        is omitted                                                    *
*        =======================================                       *
*                                                                      *
* Input  : DIR -   direction                                           *
*          C   -   coeffs of surface (C(1) not used)                   *
*          NC  -   number of coefs                                     *
*                                                                      *
* Output : TAU -   TAU(1:2) distances to surface in increasing order   *
*                  in the units of the length of DIR                   *
*          NTAU -  number of distances (solutions)  (0,1,2)            *
*                                                                      *
************************************************************************
      COMMON /SLATE/ SLATE (40)
      INTEGER        ISLATE(40)
      EQUIVALENCE    (SLATE,ISLATE)
      REAL           C(*), DIR(3), TAU(2), CBA(3)
      LOGICAL        XLINE
*-----------------------------------------------------------------------
*
*     SLATE(10) is the value of S(X) = equation of the surface with
*     the point coordinates
*     SLATE(11),SLATE(12),SLATE(13) is the gradient to the surface
*
      NTAU = 0
      CBA(1) = SLATE(10)
      CBA(2) = SLATE(11)*DIR(1)+SLATE(12)*DIR(2)+SLATE(13)*DIR(3)
*
      CBA(3) = 0.
      XLINE  = .TRUE.
*
**              in case of a plane
      IF (NC.EQ.4)              GO TO 200
*
*     in case it is a simplified surface X=-C0,Y=-C0,Z=-C0, or X*2+Y*2=-C0
*
      IF (NC.EQ.2)              THEN
        IAX  = C(2)
        IF (IAX.NE.4)           GO TO 200
        CBA(3) = DIR(1)**2+DIR(2)**2
      ELSE
*
**              in case it is a surface with 7 or 10 coefficients
        CBA(3) = DIR(1)**2*C(5)+DIR(2)**2*C(6)+DIR(3)**2*C(7)
*
**              in case it is a surface with 10 coefficients
        IF (NC.EQ.10)           THEN
          CBA(3) = CBA(3) + C(08)*DIR(1)*DIR(2)
          CBA(3) = CBA(3) + C(09)*DIR(2)*DIR(3)
          CBA(3) = CBA(3) + C(10)*DIR(3)*DIR(1)
        ENDIF
      ENDIF
      XLINE = .FALSE.
*
  200 IF (XLINE)                THEN
*
*     in case it is a plane (4 coefficients) or a simplified surface
*
        IF (1.E+6*ABS(CBA(2)).LE.ABS(CBA(1)))   GO TO 999
        NTAU = 1
        TAU(1) = - CBA(1)/CBA(2)
      ELSE
*
**              in case it is a surface with 7 or 10 coefficients
        CALL GVPSQR (CBA, TAU, NTAU)
      ENDIF
*
  999 NTAU = MAX(0,NTAU)
      RETURN
      END
+DECK,  GVPSQR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      SUBROUTINE GVPSQR (CBA, SOL, NSOL)
************************************************************************
*                                                                      *
*     SUBROUTINE GVPSQR (CBA,SOL,NSOL)             870924  VP          *
*                                                                      *
*       SOLVE  QUADRATIC  EQUATION                                     *
*                                                                      *
*   ARGUMENTS:                                                         *
*       CBA     Array of coeff's A0 + A1*x + A2*x**2                   *
*       SOL     Solutions                                              *
*       NSOL    Number of solutions :                                  *
*               if zero - SOL(1)= extremum                             *
*               if -ve  - No solution at all                           *
*                                                                      *
************************************************************************

      PARAMETER      (ZERO2=1.E-12)
      REAL           CBA(3), SOL(2), SWAP
*-----------------------------------------------------------------------

      A = CBA(3)
      B = CBA(2)*.5
      C = CBA(1)
      IF (B.LT.0.)              THEN
        A = -A
        B = -B
        C = -C
      ENDIF

      AMX = MAX (ABS(A),ABS(B),ABS(C))
      IF (AMX.LE.0.)            GO TO 100
      A   = A/AMX
      B   = B/AMX
      C   = C/AMX

      DIS = B**2 - A*C
      NSOL = 1
      IF (ABS(DIS) .LE. ZERO2)  DIS = 0.
      IF (DIS.LT.0.)            THEN
        NSOL = 0
        DIS  = 0.
      ENDIF

      IF (DIS.GT.0.)            DIS = SQRT(DIS)
      BDIS = B + DIS
      IF (ABS(C).GT.1.E+10*BDIS)        GO TO 100
      SOL(1) = 0.
      IF (ABS(BDIS).LE.0.)      GO TO 999
      SOL(1) = (-C/BDIS)
      IF (DIS.LE.0.)            GO TO 999
      IF (BDIS.GE.1.E+10*ABS(A))        GO TO 999
      NSOL   = 2
      SOL(2) = (-BDIS/A)
      IF (SOL(1).GT.SOL(2))     THEN
        SWAP = SOL(1)
        SOL(1) = SOL(2)
        SOL(2) = SWAP
      ENDIF
      GO TO 999

*
**      No solutions
  100 NSOL = -1

  999 RETURN
      END
+DECK,  GVSAFE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      FUNCTION GVSAFE (XYZ, C1, C, NC)
************************************************************************
*                                                                      *
* GVSAFE Calculates the distance from a point                YB 870511 *
*        to a surface, and the gradient in this point.                 *
*        This is an approximation of the distance, which is smaller    *
*        than the real distance.                                       *
*                                                                      *
* Input : XYZ     point coordinates                                    *
*         C1      constant coefficient from the surface                *
*         C(1)    number of non constant coefficients from             *
*                       the surface                                    *
*         C(2),C(3),... non constant coefficients from the surface     *
*         NC      total number of coefficients from the surface        *
*                                                                      *
* Extra OUTPUT: COMMON/SLATE/ISLATE(2)  ISLATE(2)=ISIGN (from GVSIGN)  *
*               SLATE(10)    - value of S(X)                           *
*               SLATE(11:13) - gradient                                *
*               SLATE(14)    - normalisation factor for distance       *
*               SLATE(15)    - normalisation factor for gradient       *
*                                                                      *
************************************************************************
      COMMON /SLATE/ SLATE (40)
      INTEGER        ISLATE(40)
      EQUIVALENCE    (SLATE,ISLATE)
      EQUIVALENCE    (JDUMM,SLATE(2))
      REAL           XYZ(3) , C(*)
      INTEGER        GVSIGN
*-----------------------------------------------------------------------
      SLATE(14) = 1.
      SLATE(15) = 1.
      IF (NC.NE.2)              GO TO 200
*
*     case with simplified surface X=C0, Y=C0, Z=C0, X*2+Y*2=C0
*     (happens only when initialisation is done)
*
      IAX = C(2)
      SLATE(11) = 0.
      SLATE(12) = 0.
      SLATE(13) = 0.
      IF (IAX.LE.3)             THEN
        SLATE(10) = C1 + XYZ(IAX)
        SLATE(IAX+10) = 1.
        CC = SLATE(10)
      ELSE
        RXY2 = XYZ(1)**2 + XYZ(2)**2
        RXY = SQRT(RXY2)
        SLATE(10) = (RXY2 - C1**2)
        SLATE(11) = 2.*XYZ(1)
        SLATE(12) = 2.*XYZ(2)
        SLATE(15) = 2.*RXY
        SLATE(14) = (RXY-C1)
        CC = SLATE(10)/SLATE(14)
      ENDIF
      IF (SLATE(10))            101,102,103
  101 ISLATE(2) = -1
      GO TO 999
  102 ISLATE(2) = 0
      GO TO 999
  103 ISLATE(2) = +1
      GO TO 999
*
*     case with surfaces with 4, 7 or 10 coefficients (normal case)
*
  200 JDUMM = GVSIGN (XYZ, C1, C, NC)
      CC    = SLATE(1)
      SLATE(10) = SLATE(1)
      SLATE(11) = C(2)
      SLATE(12) = C(3)
      SLATE(13) = C(4)
      IF (NC .EQ. 4)            GO TO 999
      IF (NC .EQ. 7)            THEN
        AA = 1.
      ELSE
CCC     AA = C(5)**2+C(6)**2+C(7)**2CCC        AA = C(5)**2+C(6)**2+C(7)**2
CCC  ++ 0.5*(C(8)**2+C(9)**2+C(10)**2)
CCC        AA = SQRT(AA)
        AA = 2.0
      ENDIF
      CALL GVGRAD (XYZ, C, NC, SLATE(11))
      TT2  = SLATE(11)**2 + SLATE(12)**2 + SLATE(13)**2
      SLATE(14) = (TT2+4.*AA*ABS(CC))
      IF (SLATE(14)-TT2.LE.0.1*TT2)     THEN
        SLATE(15) = SQRT(SLATE(14))
        SLATE(14) = SLATE(15)
      ELSE
        SLATE(15) = SQRT(TT2)
        SLATE(14) = 0.5*(SLATE(15) + SQRT(SLATE(14)))
      ENDIF
      IF (ABS(SLATE(14)).LE.0.) SLATE(14) = 1.E-10
      CC = CC / SLATE(14)

  999 GVSAFE = CC

      END
+DECK,  GVSIGN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:57  cernlib
* Geant

      INTEGER FUNCTION GVSIGN (XYZ, C0, C, NC)
************************************************************************
*                                                                      *
* Calculate the sign of the given point in relation          YB 870424 *
* to the  surface                                            VP 880312 *
*                                                                      *
* Input :       XYZ -  point to be tested                              *
*               C0  -  first coefficient of surface                    *
*               C   -  coefficients of surface in the standart form    *
*                      ,the first one is taken from C1                 *
*               NC  -  number of coefficients (4,7, 10)                *
*                                                                      *
* Output :     -1, 0, +1  depending on side                            *
*                                                                      *
************************************************************************
      COMMON /SLATE/ SLATE (40)
      INTEGER        ISLATE(40)
      EQUIVALENCE    (SLATE,ISLATE)
      REAL           XYZ(3), C(0:9)
      EQUIVALENCE    (TMP,SLATE(1))
*-----------------------------------------------------------------------

+SELF, IF=GVCONT.
      NSIGN = NSIGN + 1
+SELF.
*
      GO TO (10013,10002,10013,10004,10013
     +,      10013,10007,10013,10013,10010),NC
10013 CALL ZFATAM('GVSIGN. WRONG length')
*
*               special simple case
10002 IAX   = C(1)
      IF (IAX.LE.3)             THEN
*               X,Y,Z boundary
        TMP = C0 + XYZ(IAX)
      ELSE
*               Rxy boundary
        TMP = -C0**2 + XYZ(1)**2 + XYZ(2)**2
      ENDIF
      GO TO 10090
*               plane boundary
10004 TMP   = C0+C(1)*XYZ(1)+C(2)*XYZ(2)+C(3)*XYZ(3)
      GO TO 10090

*               2nd order boundary, short case
10007 TMP   = C0
     ++XYZ(1)*(C(1)+C(4)*XYZ(1))
     ++XYZ(2)*(C(2)+C(5)*XYZ(2))
     ++XYZ(3)*(C(3)+C(6)*XYZ(3))
      GO TO 10090
*               2nd order boundary, general case
10010 TMP   = C0
     ++XYZ(1)*(C(1)+C(4)*XYZ(1)+C(7)*XYZ(2))
     ++XYZ(2)*(C(2)+C(5)*XYZ(2)+C(8)*XYZ(3))
     ++XYZ(3)*(C(3)+C(6)*XYZ(3)+C(9)*XYZ(1))
*
10090 IS    = -1
      IF (TMP.GE.0.)            IS = 1
*
  999 GVSIGN = IS
      RETURN
      END
+PATCH, GEOCAD.
+DECK,  GBOSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GBOSET(PAR)
C-   Created  12-JUN-1991   Nils Joar Hoimyr, Jouko Vuoskoski
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C- Takes the GEANT shape BOX, converts it to a SET box, with
C- the right position and writes the shape to the current SET file.
C -
C----------------------------------------------------------------------
C
+CDE, GCSETF.

C
      REAL      PAR
      DIMENSION PAR(50)
C
      REAL X,Y,Z,DX,DY,DZ
C
C
C----------------------------------------------------------------------
C
C             BOX
C
      DX=PAR(1)
      DY=PAR(2)
      DZ=PAR(3)
      X=2*DX
      Y=2*DY
      Z=2*DZ
C *WRITE SET @50,N1,:5,2#60,X,Y,Z
C *WRITE SET @302,N2,#317,-DX,-DY,-DZ
C *WRITE SET @100,N3,:5,2,:9,'Name'#101,!N1,!N2
C
C-------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1, X, Y, Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,-DX,-DY,-DZ
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10200)N1,N1-2,N1-1
      CALL GJWRIT
C
10000   FORMAT('@50,',I10,',:5,2#60,',G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@302,',I10,'#317,',G14.7,',',G14.7,',',G14.7)
10200   FORMAT('@100,',I10,',:5,2#101,!',I10,',!',I10)
C
C
C
      END
+DECK,  GCKMAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GCKMAT (ITMED,NATMED)
*
*
*    This routine check the material table coming from a Cadd system.
*    It may help to take default/savety actions.
*
*
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
*
      CHARACTER*20  NAME,NATMED
*
* *** check tracking media number
      JTM = LQ(JTMED - ITMED)
      IF (ITMED.GT.NTMED.OR.JTM.LE.0) THEN
         WRITE (CHMAIL,10200) ITMED
         CALL GMAIL (0,0)
         IMATE = 1
         CALL GSTMED (ITMED,NATMED,IMATE, 0, 0, 1., 10.,
     +                100., 0.2, 0.005, 0.001, 0, 0)
      ELSE
         CALL UHTOC (IQ(JTM+1),4,NAME,20)
         IF (NATMED.NE.NAME) THEN
            WRITE (CHMAIL,10300) ITMED
            CALL GMAIL (0,0)
         ENDIF
      ENDIF
*
10000 FORMAT(' *** GCKMAT *** Warning, material number :', I3,
     +       ' does not exist; force by default IMATE = 1' )
*
10100 FORMAT(' *** GCKMAT *** Warning, material number :', I3,
     +      ' maybe not egal to the Geant definition. KEEP the old one')
*
10200 FORMAT(' *** GCKMAT *** Warning, tracking media  :', I3,
     +    ' does not exist; It will be created with default parameters')
*
10300 FORMAT(' *** GCKMAT *** Warning, tracking media  :', I3,
     +      ' maybe not egal to the Geant definition. KEEP the old one')
*
      END
+DECK,  GCKPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GCKPAR (ISH,NPAR,PAR)
*
+CDE, GCONSP.
*
      DIMENSION PAR(50)
*
      IF (ISH.EQ.4) THEN
* ***    trap
         NPAR = 11
         PH = 0.
         IF (PAR(2).NE.0.) PH = ATAN2(PAR(3),PAR(2))*RADDEG
         TT = SQRT(PAR(2)**2+PAR(3)**2)
         PAR(2) = ATAN(TT)*RADDEG
         IF (PH.LT.0.0) PH = PH + 360.0
         PAR(3) = PH
         PAR(7) = ATAN(PAR(7))*RADDEG
         IF (PAR(7).GT.90.0) PAR(7) = PAR(7)-180.0
         PAR(11)= ATAN(PAR(11))*RADDEG
         IF (PAR(11).GT.90.0) PAR(11) = PAR(11)-180.0
*
      ELSE IF (ISH.EQ.10) THEN
* ***    para
         PH = 0.
         IF (PAR(5).NE.0.) PH = ATAN2(PAR(6),PAR(5))*RADDEG
         TT = SQRT(PAR(5)**2+PAR(6)**2)
         PAR(4) = ATAN(PAR(4))*RADDEG
         IF (PAR(4).GT.90.0) PAR(4) = PAR(4)-180.0
         PAR(5) = ATAN(TT)*RADDEG
         IF (PH.LT.0.0) PH = PH + 360.0
         PAR(6) = PH
*
      ELSE IF (ISH.EQ.28) THEN
* ***    gtra
         NPAR = 12
      ENDIF
*
      END
+DECK,  GCOSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GCOSET(PAR,ISHAPE)
C-
C-   Created  12-JUN-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992    Jouko Vuoskoski
C-
C-   Describes a contour face of a CONE(Segment) from the GEANT
C-   CONE/CONS shape parameters.  This face is rotated around the
C-   Z-axis to generated the solid shape in SET.
C----------------------------------------------------------C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
C
C---------------------------------------------------------
      RMIN1=PAR(2)
      RMAX1=PAR(3)
      RMIN2=PAR(4)
      RMAX2=PAR(5)
      Z2=PAR(1)
      Z1=-Z2
      IF (ISHAPE.EQ.7) THEN
         PHIMIN=0.0
         PHIMAX=360.0
      ELSEIF (ISHAPE.EQ.8) THEN
         PHIMIN=PAR(6)
         PHIMAX=PAR(7)
      ENDIF
C       SET CONVERSION
      P1X= RMIN1
      P1Y= 0
      P1Z= Z1
      P2X= RMIN2
      P2Y= 0
      P2Z= Z2
      P3X= RMAX2
      P3Y= 0
      P3Z= Z2
      P4X= RMAX1
      P4Y= 0
      P4Z= Z1
C *WRITE SET@103,F1#3,3,2,P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
C *WRITE SET @100,N..#144,!F1,PHIMIN,PHIMAX.
C----------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,P1X,P1Y,P1Z,P2X,P2Y,P2Z, P3X,P3Y,P3Z,P4X,
     +P4Y,P4Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,N1-1,PHIMIN,PHIMAX
      CALL GJWRIT
C
10000   FORMAT('@103,',I10,',:5,2#3,3,2,',G14.7,',',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@100,',I10,',:5,2#144,!',I10,',',G14.7,',',G14.7)
C
C
      END
+DECK,  GCSETC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant

*           Definitions of common blocks for GEANT-SET interface
*           These varables are only related to SET file output
+DECK,  GCTSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GCTSET(PAR)
C-
C-   Created  26-JUL-1991   Nils Joar Hoimyr
C-   Modified by J. Vuoskoski 21.02.1992
C-
C-   Describes a contour face of a tube segment from the GEANT
C-   CTUB shape parameters.  This face is rotated around the
C-   Z-axis to generated a solid tube segment in SET.  To cut the
C-   tube, the cutting planes are calculated from the shape parameters,
C-   and then 2 half-spaces are generated and subtracted from the tube
C-   in a boolean CUT operation.
C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
C
      REAL  Z,DX,DY,DZ,RMIN,RMAX,PHIMIN,PHIMAX
      REAL  LXL,LYL,LZL,LXH,LYH,LZH
C
C----------------------------------------------------------
C
      RMIN=PAR(1)
      RMAX=PAR(2)
      DX=0.0
      DY=0.0
      DZ=PAR(3)
      PHIMIN=PAR(4)
      PHIMAX=PAR(5)
      LXL= PAR(6)
      LYL= PAR(7)
      LZL= PAR(8)
      LXH= PAR(9)
      LYH= PAR(10)
      LZH= PAR(11)
      IF (RMAX .LE. 0.0) THEN
         WRITE (*,*) 'IMPOSSIBLE RADIUS VALUE'
         N1=N1-1
         GOTO 10
      ENDIF
C
C       SET CONVERSION
      Z= 2*DZ
C
C   Starts with a normal TUBS element
C *WRITE SET @50,N1,:5,2#32,RMAX,Z,PHIMIN,PHIMAX,RMIN
C *WRITE SET @302,N2,:5,2#317,0,0,-DZ
C *WRITE SET @100,N3,:5,2,:9,'MATNAM'#101,!N1,!N2
C
C------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,RMAX,Z,PHIMIN,PHIMAX,RMIN
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,-DX,-DY,-DZ
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10200)N1,N1-2,N1-1
      CALL GJWRIT
C
C     Tube cutting:
C
C     Create cutting planes, and semi-spaces which are used to
C     cut the tube section
C     SET blocks @30..#30 plane normals given by LXL, etc
C
      N1=N1+1
      WRITE(BLKSTR,10300)N1,LXL,LYL,LZL,-DZ
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10400)N1,N1-1
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10300)N1,LXH,LYH,LZH,DZ
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10400)N1,N1-1
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10500)N1,N1-5,N1-1,N1-3
      CALL GJWRIT
C
10000   FORMAT('@50,',I10,',:5,2#32,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@302,',I10,'#317,',G14.7,',',G14.7,',',G14.7)
10200   FORMAT('@100,',I10,',:5,2#101,!',I10,',!',I10)
10300   FORMAT('@30,',I10,',:5,2#30,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7)
10400   FORMAT('@100,',I10,',:5,2#139,!',I10,',1,1')
10500   FORMAT('@100,',I10,',:5,2#100,3,!',I10,',!',I10,',!',I10)
C
   10 RETURN
      END
+DECK,  GDEXCA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GDEXCA(NAME,NBINS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Based on GDRAW, calculates parameters of each volume        *
C.    *    Areas marked JV + NH                                        *
C.    *                                                                *
C.    *    Called by GTXSET                                            *
C.    *                                                                *
C.    *       Authors : R.Brun, A.McPherson, P.Zanarini,   *********   *
C.    *                 J.Salt, S.Giani , J. Vuoskoski,  N. Hoimyr     *
C.    ******************************************************************
C.
C JV
+CDE, GCSETF.
C
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCONST.
+CDE, GCNUM.
+CDE, GCDLIN.
+CDE, GCMUTR.
*JS
+CDE, GCGOBJ.
C+SEQ,CGHPAR.
+CDE, GCHILN.
+CDE, GCSPEE.
*JS
*
*
C   this by jv
      DIMENSION PARMJV(9), POSJV(3)
C         if volume is divided jdvinf(level) is 1
      DIMENSION JDVINF(0:15)
      CHARACTER*4 JVVOLU,JVVOLD, NAME,NAMEE2
      CHARACTER*10 VOLNAM
      DIMENSION X(3),ATT(10)
      DIMENSION LVOLS(15),LINDX(15),LNAMES(15)
      DIMENSION GPAR(50,15)
*     INTEGER START, OLDOLD, PASS
C
      IF(JCADNT.EQ.0) THEN
         CALL MZBOOK(IXSTOR,JCADNT,JCADNT,1,'CADI',1,1,0,2,-1)
         CALL MZBOOK(IXSTOR,JBUF1,
     +               JCADNT,-1,'CAD1',0,0,NVOLUM,2,-1)
      ENDIF
      DO 10 JV=1,NVOLUM
         IQ(JBUF1+JV)=0
   10 CONTINUE
      JDVINF(0)=0
      JLEVEL=0
      MYSEEN=1
      JVVOLU='----'
C
C            Set IOBJ to VOLUME
C
      IOBJ=1
C
C             Save /GCVOLU/ if necessary
C
      IFCVOL=0
      IF (NLEVEL.NE.0) THEN
         CALL GSCVOL
         IFCVOL=1
      ENDIF
      IF (NLEVEL.LT.0) NLEVEL=IABS(NLEVEL)
C
C             Start of general code
C
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.LE.0)GO TO 210
C
C             Theta, phi and psi angles are normalized in [0-360[ range
C
*
      JVO=LQ(JVOLUM-IVO)
C
C             Initialize JIN to switch correctly CALL GFPARA/GFIPAR
C
      JIN=0
C
      LEVSEE=1000
C
      IF (IDRNUM.NE.0) GO TO 30
C
C             Initialize for new geometry structure
C
      IF (JGPAR.EQ.0) CALL GMEDIN
      CALL GLMOTH(NAME,1,NLEV,LVOLS,LINDX)
      DO 20 J=1, NLEV
         LNAMES(J)=IQ(JVOLUM+LVOLS(J))
   20 CONTINUE
      NLEV=NLEV+1
      CALL UCTOH(NAME,LNAMES(NLEV),4,4)
      LINDX(NLEV)=1
      CALL GLVOLU(NLEV, LNAMES, LINDX, IER)
C
      NLVTOP=NLEVEL
C
   30 CONTINUE
C
      NLMIN=NLEVEL
      NLMAX=NLEVEL
C
      IF (IDRNUM.NE.0) GO TO 70
C
      CALL GFPARA(NAME,1,1,NPAR,NATT,GPAR(1,NLEVEL),ATT)
C
      IF (NPAR.LE.0) GO TO 220
C
      DO 60  LLL=1,NLEVEL
         DO 50 I=1,3
            GTRAN(I,LLL)=0.0
            X(I)=0.0
            DO 40 J=1,3
               K=(I-1)*3+J
               GRMAT(K,LLL)=0.0
   40       CONTINUE
            K=I*4-3
            GRMAT(K,LLL)=1.0
   50    CONTINUE
         GRMAT(10,LLL)=0.0
   60 CONTINUE
C
C             Ready for general case code
C
   70 CONTINUE
*SG
*    Taking volume name and shape from Zebra Structure
*
      IVOLNA=IQ(JVOLUM+IVO)
      ISHAPE=Q(JVO+2)
*SG
C
      IF (IDRNUM.NE.0) GO TO 80
C
      IF (NLEVEL.EQ.NLVTOP) GO TO 90
C
   80 CONTINUE
C
      IF (IDRNUM.NE.0.AND.JIN.EQ.0) THEN
         CALL UHTOC(NAMES(NLEVEL),4,NAMEE2,4)
         CALL GFPARA(NAMEE2,NUMBER(NLEVEL),1,NPAR,
     +            NATT,GPAR(1,NLEVEL),ATT)
      ELSE
         NPAR=Q(JVO+5)
         NATT=Q(JVO+6)
         JATT=JVO+7+NPAR
         CALL UCOPY(Q(JATT),ATT,NATT)
      ENDIF
C
   90 CONTINUE
C
      WORK=ATT(1)
      SEEN=ATT(2)

*
      LINSTY=ATT(3)
      LINWID=ATT(4)
      LINCOL=ATT(5)
      LINFIL=ATT(6)
      CALL MVBITS(LINCOL,0,4,LINATT,7)
      CALL MVBITS(LINWID,0,3,LINATT,11)
      CALL MVBITS(LINSTY,0,3,LINATT,14)
      CALL MVBITS(LINFIL,0,3,LINATT,17)
*
***SG
*
*    New logic scanning the geometrical tree:
*    A volume can set bounds OR be compared with bounds;
*    this can happen only IF a relationship mother-daughters exists.
*
*    Optimization for Hidden Volume Removal:
*    POS and DIV cases are considered at the same time.
*
*     IF(START.EQ.1)THEN
*
*        IF(NLEVEL.GT.OLDOLD)THEN
*           IF(PASS.NE.0)THEN
*              S1=0
*              S2=0
*              S3=0
*              SS1=0
*              SS2=0
*              SS3=0
*              SRAGMX=0
*              SRAGMN=0
*              PASS=0
*              IF(SEEN.EQ.0.OR.SEEN.EQ.-1)PASS=1
*              OLDOLD=NLEVEL
*           ENDIF
*
*        ELSE IF(NLEVEL.LE.OLDOLD)THEN
*           S1=0
*           S2=0
*           S3=0
*           SS1=0
*           SS2=0
*           SS3=0
*           SRAGMX=0
*           SRAGMN=0
*           PASS=0
*           IF(SEEN.EQ.0.OR.SEEN.EQ.-1)PASS=1
*           OLDOLD=NLEVEL
*        ENDIF
*     ENDIF
*
*     IF(OLDOLD.EQ.0.AND.(SEEN.EQ.1.OR.SEEN.EQ.-2))THEN
*        START=1
*        PASS=0
*        OLDOLD=NLEVEL
*     ENDIF
C
C             WORK attribute enabled ?
C
      IF(WORK.LE.0.)GO TO 200
C
C             SEEN attribute processing
C
      IF (SEEN.LT.50.) GO TO 100
      ISEENL=SEEN/10.+0.5
      SEEN=ISEENL-10
  100 CONTINUE
C
      IF(NLEVEL.LE.LEVSEE)LEVSEE=1000
      IF(SEEN.EQ.-1.)GO TO 200
      IF (NLEVEL.GT.LEVSEE) GO TO 200
      IF(SEEN.EQ.0.)GO TO 150
      IF (SEEN.EQ.-2.) LEVSEE=NLEVEL
C
*              Standard Mode: Output to SET
*
C-----------------------JV----Mod NH---------------------------
C        Get positioning variables
C
      IF(NLEVEL.LT.JLEVEL)THEN
         CALL GSATT(JVVOLU,'SEEN',MYSEEN)
         Q(JBUF1+MYIVO)=0
      ENDIF
      JVO=LQ(JVOLUM-IVO)
      NIN=Q(JVO+3)
      IF(NIN.LT.0) THEN
         JDVINF(NLEVEL)=1
      ELSE
         JDVINF(NLEVEL)=0
      ENDIF
C
C            if division
      IF (JDVINF(NLEVEL-1).EQ.1) THEN
C
         IF (IQ(JBUF1+IVO).LT.NBINS) THEN
            DO 110 JV=1, 9
               PARMJV(JV)=GRMAT(JV,NLEVEL)
  110       CONTINUE
C
            DO 120 JV=1, 3
               POSJV(JV)=GTRAN(JV,NLEVEL)
  120       CONTINUE
C
C        Appends new name VOLNAM to each volume, with index.
C
            IQ(JBUF1+IVO)=IQ(JBUF1+IVO)+1
            WRITE(VOLNAM(1:5),10200)IVOLNA
            WRITE(VOLNAM(6:10),'(I4.0)')IQ(JBUF1+IVO)
C
C        Call SHAPE to SET routines
C
C        Updates SET block sequence number:
            N1=N1+1
            CALL GETSHP(ISHAPE,GPAR(1,NLEVEL))
C
C        Position the volumes
C
            N1=N1+1
            CALL GPOSI(PARMJV,POSJV,VOLNAM,LINCOL)
C
         ELSE
            JVVOLD=JVVOLU
            CALL UHTOC(IVOLNA,4,JVVOLU,4)
            IF(JVVOLD.NE.JVVOLU)MYSEEN=ATT(2)
            CALL GSATT(JVVOLU,'SEEN',-1)
            JLEVEL=NLEVEL
            MYIVO=IVO
            GOTO 200
         ENDIF
C
C       normal volumes
      ELSE
         DO 130 JV=1, 9
            PARMJV(JV)=GRMAT(JV,NLEVEL)
  130    CONTINUE
C
         DO 140 JV=1, 3
            POSJV(JV)=GTRAN(JV,NLEVEL)
  140    CONTINUE
C
C        Appends new name VOLNAM to each volume, with index.
C
         IQ(JBUF1+IVO)=IQ(JBUF1+IVO)+1
         WRITE(VOLNAM(1:5),10200)IVOLNA
         WRITE(VOLNAM(6:10),'(I4.0)')IQ(JBUF1+IVO)
C
C        Call SHAPE to SET routines
C
C        Updates SET block sequence number:
         N1=N1+1
         CALL GETSHP(ISHAPE,GPAR(1,NLEVEL))
C
C        Position the volumes
C
         N1=N1+1
         CALL GPOSI(PARMJV,POSJV,VOLNAM,LINCOL)
      ENDIF
C------------------------------------------------------------------------
C         Output of material list
C
      IF (IQ(JBUF1+IVO).EQ.1) THEN
         NTRMED=Q(JVO+4)
         CALL GPTSET (IVOLNA, NTRMED)
      ENDIF
C------------------------------END JV------------------------------------
C
*JS
*
*     Logic has been modified  >>>>>
*
*
*JS
      IF(SEEN.EQ.-2.)GO TO 200
C
  150 CONTINUE
C
***   IF (IDRNUM.NE.0) GO TO 999
C
C             Skip User shapes (not yet implemented)
C
**      ISEARC=Q(JVO+1)
C
C             Now go down the tree
C
      NIN=Q(JVO+3)
      IF(NIN.EQ.0) GO TO 200
      IF(NIN.LT.0) GO TO 170
C
C             Contents placed by GSPOS
C
      IN=0
      IF(NLMAX.GT.NLEVEL) IN=LINDEX(NLEVEL+1)
      IN=IN+1
      IF(IN.GT.NIN.AND.NLEVEL.EQ.NLMIN) GO TO 230
*
      IF(IN.GT.NIN) GO TO 190
*
      CALL GMEPOS(JVO,IN,X,0)
*
      NPAR=IQ(JGPAR+NLEVEL)
      DO 160 I=1,NPAR
         GPAR(I,NLEVEL)=Q(LQ(JGPAR-NLEVEL)+I)
  160 CONTINUE
*
      IVO=LVOLUM(NLEVEL)
      JVO=LQ(JVOLUM-IVO)
      NLMAX=NLEVEL
      GO TO 70
C
  170 CONTINUE
C
C             Contents by division
C
      IN=0
      IF(NLMAX.GT.NLEVEL) IN=LINDEX(NLEVEL+1)
      IN=IN+1
      CALL GMEDIV(JVO,IN,X,0)
*
      IF (IN.EQ.0) GO TO 190
*
      NPAR=IQ(JGPAR+NLEVEL)
      DO 180 I=1,NPAR
         GPAR(I,NLEVEL)=Q(LQ(JGPAR-NLEVEL)+I)
  180 CONTINUE
*
      IF (IN.EQ.0) GO TO 190
*
      IVO=LVOLUM(NLEVEL)
      JVO=LQ(JVOLUM-IVO)
      NLMAX=NLEVEL
      GO TO 70
C
  190 CONTINUE
      NLMAX=NLEVEL
  200 CONTINUE
      NLEVEL=NLEVEL-1
      IF(NLEVEL.LT.NLMIN) GO TO 230
      IVO=LVOLUM(NLEVEL)
      JVO=LQ(JVOLUM-IVO)
      GO TO 150
C
  210 WRITE(CHMAIL,10000)NAME
      CALL GMAIL(0,0)
      GO TO 230
C
  220 CONTINUE
C
C             TOP OF THE TREE HAS PARAMETERS SET BY GSPOSP.
C             BUT GDRAW DOES NOT HAVE ACCESS TO THE IN BANK
C             WHICH PLACED IT IN ITS MOTHER.
C
      WRITE(CHMAIL,10100) NAME
      CALL GMAIL(0,0)
C
  230 CONTINUE
*
***SG
*
*JS
      IF(KCGST.EQ.-9)THEN
         KSHIFT=0
         IF(JCG.NE.0)CALL MZDROP(IXSTOR,JCG,' ')
         IF(JCGOBJ.NE.0)CALL MZDROP(IXSTOR,JCGOBJ,' ')
         CALL GDCGRS
         IF(JCGCOL.NE.0)CALL MZDROP(IXSTOR,JCGCOL,' ')
         LARECG(1)=0
         CALL MZGARB(IXSTOR+1,0)
         NCLAS2=0
         NCLAS3=0
      ENDIF
      ICUT=0
      IF (IFCVOL.EQ.1) THEN
         CALL GFCVOL
      ELSE
         NLEVEL=0
      ENDIF
C
C             Restore permanent value of color and return
C
      CALL GDCOL(0)
      IOBJ=0
C
10000 FORMAT(' *** GDEXCA *** : Volume ',A4,' does not exist')
10100 FORMAT(' *** GDEXCA *** : Top of tree ',A4,' parameters defined',
     +       '  by GSPOSP - info not available to GDEXCA.')
10200 FORMAT(A4,'_')
      END
+DECK,  GELSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GELSET(PAR)
C-
C-   Created  26-JUL-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C-   Writes out the elliptical section of a tube in SET, and generates
C-   an extruded solid from the elliptical section (face).
C-
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL DX1,DY,Z,DZ,A,B
C
C------------------------------------------------------
C  Converts GEANT shape ELTU into SET format
C
      A=PAR(1)
      B=PAR(2)
      DZ=PAR(3)
C       SET conversion
      Z= 2*DZ
      DX1=0.0
      DY=0.0
C *WRITE SET @103,N1..#11,A,B,0.0,360.0,0,0,0,0
C *WRITE SET @100,N2,:5,2#143,!N!,0.0,0.0,1.0
C *WRITE SET @302,N3,:5,2#317,0,0,-DZ
C *WRITE SET @100,N4,:5,2,:9,'MATNAM'#101,!N1,!N2
C
C------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,A,B
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,N1-1,Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10200)N1,-DX1,-DY,-DZ
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10300)N1,N1-2,N1-1
      CALL GJWRIT
10000   FORMAT('@103,',I10,',:5,2#11,:14,1,',G14.7,',',G14.7,',
     +     0.0,360.0,0.0,0.0,0.0,0.0')
10100   FORMAT('@100,',I10,',:5,2#143,!',I10,',0.,0.,',G14.7)
10200   FORMAT('@302,',I10,'#317,',G14.7,',',G14.7,',',G14.7)
10300   FORMAT('@100,',I10,',:5,2#101,!',I10,',!',I10)
C
   10 RETURN
      END
+DECK,  GENSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GENSET
*
*      This subroutine closes a SET file, and writes out the
*      end-data assembly and end-SET file blocks.
*      Author :    Nils Hoimyr
*
+CDE, GCSETF.

*
      WRITE (BLKSTR,10000) N1+1,N1+3
      CALL GJWRIT
* *** the last line
      WRITE (NUNIT1,'(A80)') JVSTR
*
      CLOSE (UNIT = NUNIT2)
      CLOSE (UNIT = NUNIT1)
*
10000 FORMAT('@9998,',I10,'@9999,',I10)
*
      END
+DECK,  GETSHP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GETSHP(ISHAPE,PAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Converts GEANT SHAPES to SET. Calls  Subroutines for     *
C.    *       shape definition in SET are called
C.    *                                                                *
C.    *                                                                *
C.    *                                                                *
C.    * SHAPE     SHAPE    SHAPE                                       *
C.    * NUMBER    TYPE     PARAMETERS                                  *
C.    * -------------------------------------------------------------- *
C.    *                                                                *
C.    *   1       BOX      DX,DY,DZ                                    *
C.    *   2       TRD1     DX1,DX2,DY,DZ                               *
C.    *   3       TRD2     DX1,DX2,DY1,DY2,DZ                          *
C.    *   4       TRAP     DZ,TX,TY,H1,BL1,TL1,TTH1,H2,BL2,TL2,TTH2    *
C.    *                                                                *
C.    *   5       TUBE     RMIN,RMAX,DZ                                *
C.    *   6       TUBS     RMIN,RMAX,DZ,PHIMIN,PHIMAX                  *
C.    *   7       CONE     DZ,RMIN1,RMAX1,RMIN2,RMAX2                  *
C.    *   8       CONS     DZ,RMIN1,RMAX1,RMIN2,RMAX2,PHIMIN,PHIMAX    *
C.    *                                                                *
C.    *   9       SPHE     RMIN,RMAX,THEMIN,THEMAX,PHIMIN,PHIMAX       *
C.    *                                                                *
C.    *  10       PARA     DX,DY,DZ,TXY,TXZ,TYZ                        *
C.    *  11       PGON     PHIMIN,DPHI,NDIV,NZ,Z(1),RMIN(1),RMAX(1),...*
C.    *  12       PCON     PHIMIN,DPHI,NZ,Z(1),RMIN(1),RMAX(1),Z(2),...*
C.    *  13       ELTU     A,B,DZ                                      *
C.    *  14       HYPE     RMIN,RMAX,DZ,PHI
C.    *  NSGTRA   GTRA     DZ,TH,PHI,TWIST,Y1,XL1,XH1,TH1,Y2,XL2,XH2,..*
C.    *  NSCTUB   CTUB     RMIN,RMAX,DZ,PHIMIN,PHIMAX,LXL,LYL,LZL,LXH,.*
C.    *                                                                *
C.    *    ==>Called by : GDEXCA
C.    *                                                                *
C.    *       Authors : NJ Hoimyr, J Vuoskoski     *********           *
C.    ******************************************************************
C. -------------------------------------------------------
+CDE, GCSETF.


      DIMENSION PAR(50)
C
C----------------------------------------------------------
C     IF SHAPE THEN LOOP FOR SET OUTPUT
C
      IF (ISHAPE.EQ.1) THEN
C
C       BOX
         CALL GBOSET(PAR)
C
      ELSEIF (ISHAPE.EQ.2) THEN
C
C       TRD1
         CALL GTRDSE(PAR,ISHAPE)
C
      ELSEIF (ISHAPE.EQ.3) THEN
C
C       TRD2
         CALL GTRDSE(PAR,ISHAPE)
C
      ELSEIF (ISHAPE.EQ.4) THEN
C       TRAP
         CALL GTRASE(PAR)
C
      ELSEIF (ISHAPE.EQ.5) THEN
C
C             TUBE
         CALL GTUSET(PAR,ISHAPE)
C
      ELSEIF (ISHAPE.EQ.6) THEN
C
C             TUBS
         CALL GTUSET(PAR,ISHAPE)
C
      ELSEIF (ISHAPE.EQ.7) THEN
C
C             CONE
         CALL GCOSET(PAR,ISHAPE)
C
      ELSEIF (ISHAPE.EQ.8) THEN
C
C             CONS
         CALL GCOSET(PAR,ISHAPE)
C
      ELSEIF (ISHAPE.EQ.9) THEN
C
C             SPHE
         CALL GSPSET(PAR)
C
      ELSEIF (ISHAPE.EQ.10) THEN
C
C             PARA
         CALL GPASET(PAR)
C
      ELSEIF (ISHAPE.EQ.11) THEN
C
C             PGON
         CALL GPGSET(PAR)
C
      ELSEIF (ISHAPE.EQ.12) THEN
C
C             PCON
         CALL GPCSET(PAR)
C
      ELSEIF (ISHAPE.EQ.13) THEN
C
C             ELTU
         CALL GELSET(PAR)
C
C      ELSEIF (ISHAPE.EQ.14) THEN
C     not ready yet
C
C             HYPE
C        CALL HYPSET(PAR)
C

      ELSEIF (ISHAPE.EQ.28) THEN
C
C             GTRA
         CALL GTRSET(PAR)
C
      ELSEIF (ISHAPE.EQ.29) THEN
C
C             CTUB
         CALL GCTSET(PAR)
      ELSE
C
C   New shapes could be included
C
      END IF
C
      RETURN
      END
+DECK,  GJWRIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GJWRIT
C
C    Writes 80 characters in a line and skips spaces
C
C    CALLED BY ALL SHAPE ROUTINES in CADINT
C
C    BLKSTR = The character string to be written
C    NPLACE = The place of the current character in the line
C
C---------------------------------------------------------------------
C
+CDE, GCSETF.

C
C---------------------------------------------------------------------
C
C
      J=NPLACE
C
      LBLK=LEN(BLKSTR)
      DO 10  I=1, LBLK
         IF (BLKSTR(I:I) .NE. ' ') THEN
            WRITE(JVSTR(J:J),'(A1)')BLKSTR(I:I)
            IF (J .EQ. 80) THEN
               WRITE(NUNIT1,'(A80)')JVSTR
               JVSTR=' '
               J=0
            END IF
            J=J+1
         END IF
   10 CONTINUE
C
      NPLACE=J
C
      BLKSTR=' '
C
      END
+DECK,  GPASET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GPASET(PAR)
C-
C-   Created  12-JUN-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C-  Calculates the coordinates of the corner points of a GEANT PARA  shape
C-  from the shape parameters.   The end faces are generated by drawing
C-  connected polylines between the corner points at each Z-end of the shape.
C-  A ruled solid is then defined between the 2 faces, and written out in SET.
C---------------------------------------------------------
C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
      REAL P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z

C
C----------------------------------------------------------------------
C
      DX=PAR(1)
      DY=PAR(2)
      DZ=PAR(3)
      TXY=PAR(4)
      TXZ=PAR(5)
      TYZ=PAR(6)
C       Calculation of corner points (verify PHI/THETA coordinates,
C       I.e. TXZ AND TYZ should possibly change place)
C
C       FACE 1:
      P1X= -DX*COS(TYZ)-DY*SIN(TXY)
      P1Y= -DY*COS(TXY)
      P1Z= -DZ*COS(TXZ)-DY*SIN(TXY)
C
      P2X= DX*COS(TYZ)-DY*SIN(TXY)
      P2Y= -DY*COS(TXY)
      P2Z= -DZ*COS(TXZ)-DY*SIN(TXY)
C
      P3X= DX*COS(TYZ)-DY*SIN(TXY)
      P3Y= DY*COS(TXY)
      P3Z= -DZ*COS(TXZ)+DY*SIN(TXY)
C
      P4X= DX*COS(TYZ)-DY*SIN(TXY)
      P4Y= DY*COS(TXY)
      P4Z= -DZ*COS(TXZ)+DY*SIN(TXY)
C
C      FACE 2:
C
      P5X= -DX*COS(TYZ)+DY*SIN(TXY)
      P5Y= -DY*COS(TXY)
      P5Z= DZ*COS(TXZ)-DY*SIN(TXY)
C
      P6X= DX*COS(TYZ)+DY*SIN(TXY)
      P6Y= -DY*COS(TXY)
      P6Z= DZ*COS(TXZ)-DY*SIN(TXY)
C
      P7X= DX*COS(TYZ)+DY*SIN(TXY)
      P7Y= DY*COS(TXY)
      P7Z= DZ*COS(TXZ)+DY*SIN(TXY)
C
      P8X= -DX*COS(TYZ)+DY*SIN(TXY)
      P8Y= DY*COS(TXY)
      P8Z= DZ*COS(TXZ)+DY*SIN(TXY)
C
C       DESCRIBED BY 2 FACES represented by polylines
C       connected by the corners of the shape.
C *WRITE SET@103,F1#3,3,2,P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
C *WRITE SET@103,F2#3,3,2,P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z
C *WRITE SET @100,N#145,!F1,!F2
C
C----------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,P1X,P1Y,P1Z,P2X,P2Y,P2Z, P3X,P3Y,P3Z,P4X,
     +P4Y,P4Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10000)N1,P5X,P5Y,P5Z,P6X,P6Y,P6Z, P7X,P7Y,P7Z,P8X,
     +P8Y,P8Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,N1-2,N1-1
      CALL GJWRIT
C
10000   FORMAT('@103,',I10,',:5,2#3,3,2,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@100,',I10,',:5,2#145,!',I10,',!',I10)
C
      END
+DECK,  GPCSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GPCSET(PAR)
C-
C-   Created  26-JUN-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-   Modified  02.04.92  NJH
C-
C---------------------------------------------------------
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL PHIMIN,PHIMAX,PX,PY,PZ,RMIN,RMAX
C-
C-   Describes a contour face of a PCON shape calculated from the GEANT
C-   PCON shape parameters.  This face is rotated around the
C-   Z-axis to generated the solid shape in SET.
C---------------------------------------------------------
C
      PHIMIN=(PAR(1)-90.0)
      PHIMAX=(PHIMIN+PAR(2))
      NZ=PAR(3)
C        Solid of revolution described by rotation of a face
C        Face defined in the yz-plane (x=0)
C       WRITE SET@103,F1#3,3,2,P1X,P1Y,P1Z,P2X.........
C---------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1
      CALL GJWRIT
C---------------------------------------------------------
      N2= 1
      PX= 0.0
C
      PY= PAR(5)
      PZ= PAR(4)
C---------------------------------------------------------
C
      WRITE(BLKSTR,10100)PX,PY,PZ
      CALL GJWRIT
C---------------------------------------------------------
C
      DO 10  K=1,NZ
         N2=N2+3
         PY= PAR(N2+2)
         PZ= PAR(N2)
         RMIN= PAR(N2+1)
         RMAX=PAR(N2+2)
         IF (RMIN .GE. RMAX) GOTO 10
C
C---------------------------------------------------------
C
         WRITE(BLKSTR,10100)PX,PY,PZ
         CALL GJWRIT
C---------------------------------------------------------
C
   10 CONTINUE
C
      DO 20  L=2,NZ
         PY= PAR(N2+1)
         PZ= PAR(N2)
C
C---------------------------------------------------------
C
         WRITE(BLKSTR,10100)PX,PY,PZ
         CALL GJWRIT
C---------------------------------------------------------
         N2=N2-3
   20 CONTINUE
C     WRITE SET @100,N..#144,!F1,PHIMIN,PHIMAX.
C
      N1=N1+1
      WRITE(BLKSTR,10200)N1,N1-1,PHIMIN,PHIMAX
      CALL GJWRIT
C
10000   FORMAT('@103,',I10,',:5,2#3,3,2')
10100   FORMAT(',',G14.7,',',G14.7,',',G14.7)
10200   FORMAT('@100,',I10,',:5,2#144,!',I10,',',G14.7,',',G14.7)
C
      END
+DECK,  GPGSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GPGSET(PAR)
C-
C-   Created  26-JUN-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C---------------------------------------------------------
C- Calculates the sectional face of 1 cell of the PGON shape.   This face is
C- copied and rotated around the Z-axis to make "the other side" of the first
C- cell.  A ruled solid is generated between the 2 faces, to created the cell.
C- The rest of the cells are created by copying and rotation of the first cell.
C- The final result is obtained with a Boolean fusion of the cells.  (The whole
C-  creation history is written to the SET file.)
C----------------------------------------------------------
C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL PX,PY,PZ,PHIC,PHI1,RMIN,RMAX
      REAL R1,R2,R3,R4,R5,R6,R7,R8,R9
C
C----------------------------------------------------------------------
C
C        Calculates range of each cell
C
      PHI1= (PAR(1)+180)/180*3.14159265359
      NZ= PAR(4)
      NPDV= PAR(3)
      PHIC= (PAR(2)/PAR(3))/180*3.14159265359
C      Rotation around the Z-axis.  Coeffisients of rotation:
      R1= COS(PHI1)
      R2= -SIN(PHI1)
      R3= 0.0
      R4= SIN(PHI1)
      R5= COS(PHI1)
      R6= 0.0
      R7= 0.0
      R8= 0.0
      R9= 1.0
C      Face defined in the yz-plane (x=0)
C----------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1
      CALL GJWRIT
C---------------------------------------------------------
C   1. Definition point for the face:
C
      N3= 2
      PX= 0.0
C
      PY= PAR(6)
      PZ= PAR(5)
C---------------------------------------------------------
C
      WRITE(BLKSTR,10100)PX,PY,PZ
      CALL GJWRIT
C---------------------------------------------------------
C  Loops over the other definition points:
C
      DO 10  K=1,NZ
         N3=N3+3
         PY= PAR(N3+2)
         PZ= PAR(N3)
         RMIN= PAR(N3+1)
         RMAX= PAR(N3+2)
         IF (RMIN .GE. RMAX) GOTO 10
C
C
C---------------------------------------------------------
         WRITE(BLKSTR,10100)PX,PY,PZ
         CALL GJWRIT
C---------------------------------------------------------
C
   10 CONTINUE
C
      DO 20  L=2,NZ
         PY= PAR(N3+1)
         PZ= PAR(N3)
C
C---------------------------------------------------------
         WRITE(BLKSTR,10100)PX,PY,PZ
         CALL GJWRIT
C----------------------------------------------------------
         N3=N3-3
   20 CONTINUE
C
C      Geometric Transformation
C*       WRITE SET @302,N1..#301,R1,R2,R3,R4,R5,R6,R7,R8,R9
C
      N1=N1+1
      NG= N1
      WRITE(BLKSTR,10200)N1,R1,R2,R3,R4,R5,R6,R7,R8,R9
      CALL GJWRIT
C-------------------------------------------------
C---First FACE:
C*       WRITE SET @113,F2..#101,!F1,N1
C------------------------------------------------
C
      N1=N1+1
      WRITE(BLKSTR,10300)N1,N1-2,N1-1
      CALL GJWRIT
C---------------------------------------------------------
C      Next step is to obtain the right position of the second face to
C      create a cell:
C      Rotation around the Z-axis.  Coeffisients of rotation:
      R1= COS(PHIC)
      R2= -SIN(PHIC)
      R3= 0.0
      R4= SIN(PHIC)
      R5= COS(PHIC)
      R6= 0.0
      R7= 0.0
      R8= 0.0
      R9= 1.0
C
C      Geometric Transformation
C*       WRITE SET @302,N1..#301,R1,R2,R3,R4,R5,R6,R7,R8,R9
C
C------------------------------------------------------------
      N1=N1+1
      NG= N1
      WRITE(BLKSTR,10200)N1,R1,R2,R3,R4,R5,R6,R7,R8,R9
      CALL GJWRIT
C--------------------------------------------------------------
C      Second Face:
C
C      The first cell of the PGON is defined as a ruled solid between two
C      faces.  The second face is defined as a copy of the first face that is
C      rotated PHIC degrees around the Z-axis.
C
C*       WRITE SET @113,F2..#101,!F1,N1
C------------------------------------------------
C
      N1=N1+1
      WRITE(BLKSTR,10300)N1,N1-2,N1-1
      CALL GJWRIT
C
C-------------------------------------------------
C*       WRITE SET @100,N2..#145,!F1,!F2
C------------------------------------------------
C
      N1=N1+1
      WRITE(BLKSTR,10400)N1,N1-3,N1-1
      CALL GJWRIT
C
C--------------------------------------------------------------
C  The rest of the cells are defined as rotated copies of the first cell:
      N2=N1
      DO 30  K=2, NPDV
C*       WRITE SET @100,N3..#101,!N1-1,!NG
C
C------------------------------------------------
C
         N1=N1+1
         WRITE(BLKSTR,10500)N1,N1-1,NG
         CALL GJWRIT
C
   30 CONTINUE
C------------------------------------------------------------
C      The final shape is a Boolean union of the cells
C*       WRITE SET @100,N4..#100,2,!N1-NPDV....!N1-1
C------------------------------------------------
C
      N1=N1+1
      WRITE(BLKSTR,10700)N1
      CALL GJWRIT
C------------------------------------------------
      DO 40  K=N2, N1-1
C
         WRITE(BLKSTR,10600)K
         CALL GJWRIT
C
   40 CONTINUE
C
10000   FORMAT('@103,',I10,',:5,2#3,3,2')
10100   FORMAT(',',G14.7,',',G14.7,',',G14.7)
10200   FORMAT('@302,',I10,',:5,2#301,',G14.7,',',G14.7,',',G14.7
     +  ,',',G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7)
10300   FORMAT('@113,',I10,',:5,2#101,!',I10,',!',I10)
10400   FORMAT('@100,',I10,',:5,2#145,!',I10,',!',I10)
10500   FORMAT('@100,',I10,',:5,2#101,!',I10,',!',I10)
10600   FORMAT(',!',I10)
10700   FORMAT('@100,',I10,',:5,2#100,2')
C
      END
+DECK,  GPOSI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GPOSI(PARMAT,POSIT,VOLNAM,COLO)
C-   Created  12-JUN-1991   Nils Joar Hoimyr, Jouko Vuoskoski
C
C    Modyfied 10.11.92 Nils Hoimyr. Added colour output to CAD.
C----------------------------------------------------------------------
C
+CDE, GCSETF.

C
C
      DIMENSION PARMAT(9)
      DIMENSION POSIT(3)
      CHARACTER*10 VOLNAM
      INTEGER COLOUR,COL,COLO
C
C
C    Map GEANT colour to SET colour: (Use SET standard colour table)
C                                     Approx LightBlue with blue
C
      IF (ABS(COLO).GE.10) THEN
         COL= ABS(COLO/10)
      ELSE
         COL= ABS(COLO)
      ENDIF
      IF (COL.EQ.1) COLOUR=8
      IF (COL.EQ.2) COLOUR=7
      IF (COL.EQ.3) COLOUR=4
      IF (COL.EQ.4) COLOUR=3
      IF (COL.EQ.5) COLOUR=5
      IF (COL.EQ.6) COLOUR=2
      IF (COL.EQ.7) COLOUR=3
C----------------------------------------------------------------------
C   Positioning of the volume in SET:
C
C *WRITE SET @302,N1,#301,1,0,0,0,1,0,0,0,1,XPOSIT,YPOSIT,XPOSIT
C *WRITE SET @100,N2,:57,'Colour',:9,'Name'#101,!N1(of the shape),!N1
C
C-------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,(PARMAT(JV),JV=1,9),(POSIT(JV),JV=1,3)
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,COLOUR,VOLNAM,N1-2,N1-1
      CALL GJWRIT
C
10000   FORMAT('@302,',I10,'#301,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7)
C10010   FORMAT('@302,',I10,'#317,',G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@100,',I10,',:57,',I10,',:9,'''
     +  ,A,'''#101,!',I10,',!',I10)
C10020   FORMAT('@100,',I10,',:5,2#101,!',I10,',!',I10)
C
      END
+DECK,  GPTSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:46  cernlib
* Geant

      SUBROUTINE GPTSET (IVOLNA, NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print tracking media data structure JTMED     *
C.    *       NUMB     medium number                                   *
C.    *                                                                *
C.    *    ==>Called by : GDEXCA    PRINTS the media of the volumes    *
C.    *       exported to SET in the material file .mat.               *
C.    *       Author: Nils Hoimyr                                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSETF.
*
      CHARACTER CHVOLN*4, CHNATM*20, CHNAMA*20
*
      IF (JTMED.LE.0) RETURN
      JTM = LQ(JTMED-NUMB)
      IF (JTM.NE.0) THEN
         CALL UHTOC(IVOLNA,4,CHVOLN,4)
         CALL UHTOC(IQ(JTM+1),4,CHNATM,20)
         IMAT = Q(JTM+6)
         JMA = LQ(JMATE-IMAT)
         CALL UHTOC(IQ(JMA+1),4,CHNAMA,20)
         DENS = Q(JMA+8)
         WRITE (NUNIT2,10000) CHVOLN,NUMB,CHNATM,IMAT,CHNAMA,DENS
      ENDIF
*
10000 FORMAT(1X,A4,6X,I6,1X,A20,I4,1X,A20,E15.8)
      END

+DECK,  GREUCL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GREUCL (LUN,FILNAM)
*
*
*     ******************************************************************
*     *                                                                *
*     *  Read in the geometry of the detector in EUCLID file format    *
*     *                                                                *
*     *                                                                *
*     *       Author : M. Maire                                        *
*     *                                                                *
*     ******************************************************************
*
      CHARACTER*(*) FILNAM
      CHARACTER*80  FILEXT
      CHARACTER    KEY*4, CARD*76
      CHARACTER*20 NATMED, NAMATE
      CHARACTER*4  NAME, MOTHER, SHAPE, KONLY
      REAL PAR(50)
*
+CDE, GCNUM.
+CDE, GCUNIT.
*
      IT2=LNBLNK(FILNAM)
+SELF, IF=-IBM.
      FILEXT=FILNAM
+SELF, IF=IBM.
      IT1=INDEX(FILNAM,'.')
      IF (IT1.GT.0) THEN
         FILEXT='/'//FILNAM(1:IT1-1)//' '//FILNAM(IT1+1:IT2)//' A1'
         CALL CLTOU(FILEXT)
      ELSE
         WRITE (CHMAIL,10000) FILNAM
         CALL GMAIL (0,0)
         RETURN
      ENDIF
+SELF.
*
      OPEN (UNIT=LUN,FILE=FILEXT,STATUS='UNKNOWN',FORM='FORMATTED')
*
   10 READ (LUN,'(A4,A76)',END=20,ERR=20) KEY,CARD
*
      IF (KEY.EQ.'TMED') THEN
         READ (CARD,*)    ITMED, NATMED
         CALL GCKMAT (ITMED, NATMED)
*
      ELSE IF (KEY.EQ.'ROTM') THEN
         READ (CARD,*) IROT, TETA1, PHI1, TETA2, PHI2, TETA3, PHI3
         CALL GSROTM ( IROT, TETA1, PHI1, TETA2, PHI2, TETA3, PHI3 )
*
      ELSE IF (KEY.EQ.'VOLU') THEN
         READ (CARD,*) NAME, SHAPE, NUMED, NPAR
         IF (NPAR.GT.0) READ (LUN, *) (PAR(I),I=1,NPAR)
         CALL GSVOLU ( NAME, SHAPE, NUMED, PAR, NPAR, IVOLU)
*
      ELSE IF (KEY.EQ.'DIVN') THEN
         READ (CARD,*) NAME, MOTHER, NDIV, IAXE
         CALL GSDVN  ( NAME, MOTHER, NDIV, IAXE )
*
      ELSE IF (KEY.EQ.'DVN2') THEN
         READ (CARD,*) NAME, MOTHER, NDIV, IAXE, ORIG, NUMED
         CALL GSDVN2 ( NAME, MOTHER, NDIV, IAXE, ORIG, NUMED )
*
      ELSE IF (KEY.EQ.'DIVT') THEN
         READ (CARD,*) NAME, MOTHER, STEP, IAXE, NUMED, NDVMX
         CALL GSDVT  ( NAME, MOTHER, STEP, IAXE, NUMED, NDVMX )
*
      ELSE IF (KEY.EQ.'DVT2') THEN
         READ (CARD,*) NAME, MOTHER, STEP, IAXE, ORIG, NUMED, NDVMX
         CALL GSDVT2 ( NAME, MOTHER, STEP, IAXE, ORIG, NUMED, NDVMX )
*
      ELSE IF (KEY.EQ.'POSI') THEN
         READ (CARD,*) NAME, NR, MOTHER, XO, YO, ZO, IROT, KONLY
         CALL GSPOS  ( NAME, NR, MOTHER, XO, YO, ZO, IROT, KONLY )
*
      ELSE IF (KEY.EQ.'POSP') THEN
         READ (CARD,*) NAME, NR, MOTHER, XO, YO, ZO, IROT, KONLY, NPAR
         IF (NPAR.GT.0) READ (LUN, *) (PAR(I),I=1,NPAR)
         CALL GSPOSP ( NAME, NR, MOTHER, XO,YO,ZO,IROT,KONLY,PAR,NPAR)
      ENDIF
*
      IF (KEY.NE.'END') GO TO 10
      CLOSE (LUN)
*
      WRITE (CHMAIL,10100) FILNAM(1:IT2)
      CALL GMAIL (1,1)
*
      GOTO 999
*
   20 CONTINUE
      WRITE (CHMAIL,10200)
      CALL GMAIL (1,1)
      CLOSE (LUN)
*
10000 FORMAT (' *** GREUCL *** ',A,' is not a valib IBM name')
10100 FORMAT (' *** GREUCL *** file: ',A,' is now read in')
10200 FORMAT (' *** GREUCL *** reading error or premature end of file')
*
  999 END
+DECK,  GSPSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GSPSET(PAR)
C-
C-   Created  12-JUN-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C-  Takes a GEANT SPHE shape, and wites it out as a primitive solid
C-  sphere in SET.
C----------------------------------------------------------------------

+CDE, GCSETF.

C
      DIMENSION PAR(50)
C
      REAL RMIN, RMAX
C
C Segments not yet ready:
C    REAL ALPH1, ALPH2, THET1, THET2
C
C----------------------------------------------------------------------
C
      RMIN= PAR(1)
      RMAX= PAR(2)
C
C        IF segment of a sphere  THEN (Currently not implemented)
C      *WRITE SET @50,N..#34,RMAX,ALPH1,ALPH2,THET1,THET2,RMIN
C        ELSE
C      *WRITE SET @50,N..#34,RMAX,,,,,RMIN
C----------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,RMAX,RMIN
      CALL GJWRIT
C
10000   FORMAT('@50,',I10,',:5,2#34,',G14.7,',,,,,',G14.7)
C
      END
+DECK,  GSTMAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GSTMAT(FNAME)
*
* *** Opens a material list file for CADD output
*
+CDE, GCSETF.
*
* *** name of the SET-file:
      CHARACTER*24    FNAME
* *** name of the MAT-file:
      CHARACTER*80    FNAMEM
*
* *** Append filename FNAME to FNAMEM with extension .mat:
      IF(INDEX(FNAME,'.').EQ.0) THEN
         IT=LNBLNK(FNAME)
      ELSE
         IT=INDEX(FNAME,'.')-1
      ENDIF
+SELF, IF=-IBM.
      FNAMEM=FNAME(1:IT)//'.mat'
+SELF, IF=IBM.
      FNAMEM='/'//FNAME(1:MIN(IT,8))//' MAT A1'
      CALL CLTOU(FNAMEM)
+SELF.
*
* *** Open material file:
      OPEN  (UNIT=NUNIT2, FILE=FNAMEM, STATUS='UNKNOWN', ERR=10 )
*
      WRITE (NUNIT2,*)'GEANT-SET MATERIAL LISTING FILE'
      WRITE (NUNIT2,*)'--------------------------------'
      WRITE (NUNIT2,*)
      WRITE (NUNIT2,*)'Materials in the geometry described in'
      WRITE (NUNIT2,*)'the .SET file:  ',FNAME
      WRITE (NUNIT2,*)
      WRITE (NUNIT2,10000)
      WRITE (NUNIT2,*)
      RETURN
*
   10 WRITE(*,*)'Error opening the .mat file for materials'
      WRITE(*,*)'Check use of logical units.'
*
10000 FORMAT('Volume name    ','Tracking media ',9X
     + ,'Material  ',14X,'Density  ')
*
      END
+DECK,  GSTSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GSTSET(FNAME,ANAME,INST,SITE,DEPT,RESP)
*
*
*      This subroutine starts a SET file.
*
*      It writes the beginning of the file, with a relevant header
*      A SET data assembly is intialized after the header.
*
+CDE, GCSETF.
+CDE, GCUNIT.

*
* *** name of the SET-file:
      CHARACTER*24    FNAME
      CHARACTER*80    FNAMES
* *** name of the data assembly:
      CHARACTER*4    ANAME
      CHARACTER*8     DATE,TIME
      CHARACTER*24    INST,SITE,DEPT,RESP
*
* *** File name and other general input to be read in by the user **
      IF(INDEX(FNAME,'.').EQ.0) THEN
         IT=LNBLNK(FNAME)
      ELSE
         IT=INDEX(FNAME,'.')-1
      ENDIF
+SELF, IF=-IBM.
      FNAMES=FNAME(1:IT)//'.set'
+SELF, IF=IBM.
      FNAMES='/'//FNAME(1:MIN(IT,8))//' SET A1'
      CALL CLTOU(FNAMES)
+SELF.
*
      OPEN (UNIT=NUNIT1, FILE=FNAMES, STATUS='UNKNOWN', ERR=10 )
*
* *** library call for date and time:
      CALL DATIMH (DATE,TIME)
*
      NPLACE = 1
      BLKSTR = ' '
      JVSTR  = ' '
      WRITE (BLKSTR,10000) INST,SITE,DEPT,RESP
      CALL GJWRIT
*   the last line:
      WRITE (NUNIT1,'(A80)') JVSTR
      JVSTR  = ' '
*
      WRITE (NUNIT1,10100) DATE(7:8),DATE(4:5),DATE(1:2),
     +                     TIME(1:2),TIME(4:5),TIME(7:8)
*
      NPLACE = 1
      BLKSTR = ' '
      WRITE (BLKSTR,10200) ANAME
      CALL GJWRIT
*   the last line:
      WRITE(NUNIT1,'(A80)')JVSTR
      JVSTR = ' '
*
      WRITE (NUNIT1,'(A)') ',1,0.01,0,-300.,300.,-300.,300.,-300.,300.'
      WRITE (NUNIT1,'(A)') '#9920,:12,0.005,:14,0,:15,0'
      WRITE (NUNIT1,'(A)') '@301,2#301,1.,0.,0.,0.,1.
     + ,0.,0.,0.,1.,0.,0.,0.'
*
      RETURN
*
   10 WRITE(CHMAIL,'('' Error opening the .SET file. '')')
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'(''Check your directory and unit number in use'')')
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' CADINT cannot proceed. Program terminated '')')
      CALL GMAIL(0,0)
      STOP
*
10000 FORMAT('@9900#9900,''Z68-300.89.06'',''2.0'',''
     +CADINT'',''1.20'',''',A,''',''',A,''',''',A,
     +''',''',A,'''')
10100 FORMAT('#9901,19',A2,',',A2,',',A2,',',A2,',',A2,',',A2)
10200 FORMAT('@9901,1,''',A4,'''#9905,3,1.')
*
      END
+DECK,  GTRASE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GTRASE(PAR)
C-
C-   Created  12-JUN-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C-  Calculates the coordinates of the corner points of a GEANT TRAP  shape
C-  from the shape parameters.   The end faces are generated by drawing
C-  connected polylines between the corner points at each Z-end of the shape.
C-  A ruled solid is then defined between the 2 faces, and written out in SET.
C---------------------------------------------------------
C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
C
      REAL P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
      REAL P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z
C
C----------------------------------------------------------------------
C
C             TRAP
C

      DZ=PAR(1)
      TX=PAR(2)
      TY=PAR(3)
      H1=PAR(4)
      BL1=PAR(5)
      TL1=PAR(6)
      H2=PAR(8)
      BL2=PAR(9)
      TL2=PAR(10)
C       Parameter conv for faces..
C       FACE parameters:
C       FACE 1:
      P1X= -BL1-DZ*SIN(TX)
      P1Y= -H1-DZ*SIN(TY)
      P1Z= -DZ
C
      P2X= BL1-DZ*SIN(TX)
      P2Y= -H1-DZ*SIN(TY)
      P2Z= -DZ
C
      P3X= TL1-DZ*SIN(TX)
      P3Y= H1-DZ*SIN(TY)
      P3Z= -DZ
C
      P4X= -TL1-DZ*SIN(TX)
      P4Y= H1-DZ*SIN(TY)
      P4Z= -DZ
C       Next FACE:
      P5X= -BL2+DZ*SIN(TX)
      P5Y= -H2+DZ*SIN(TY)
      P5Z= DZ
C
      P6X= BL2+DZ*SIN(TX)
      P6Y= -H2+DZ*SIN(TY)
      P6Z= DZ
C
      P7X= TL2+DZ*SIN(TX)
      P7Y= H2+DZ*SIN(TY)
      P7Z= DZ
C
      P8X= -TL2+DZ*SIN(TX)
      P8Y= H2+DZ*SIN(TY)
      P8Z= DZ
C       DESCRIBED BY 2 FACES represented by polylines
C       connected by the 4 corners of the shape.
C *WRITE SET@103,F1#3,3,2,P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
C *WRITE SET@103,F2#3,3,2,P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z
C
C *WRITE SET @100,N#145,!F1,!F2,
C-------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,P1X,P1Y,P1Z,P2X,P2Y,P2Z, P3X,P3Y,P3Z,P4X,
     +P4Y,P4Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10000)N1,P5X,P5Y,P5Z,P6X,P6Y,P6Z, P7X,P7Y,P7Z,P8X,
     +P8Y,P8Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,N1-2,N1-1
      CALL GJWRIT
C
10000   FORMAT('@103,',I10,',:5,2#3,3,2,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@100,',I10,',:5,2#145,!',I10,',!',I10)
C
      END
+DECK,  GTRDSE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GTRDSE(PAR,ISHAPE)
C-
C----------------------------------------------------------
C-  Calculates the coordinates of the corner points of a GEANT  shape
C-  from the shape parameters.   The end faces are generated by drawing
C-  connected polylines between the corner points at each Z-end of the shape.
C-  A ruled solid is then defined between the 2 faces, and written out in SET.
C----------------------------------------------------------
C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
      REAL P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z
C
C
C----------------------------------------------------------------------
C             TRD1&2
C

      DX1=PAR(1)
      DX2=PAR(2)
      DY1=PAR(3)
      IF (ISHAPE .EQ. 2) THEN
         DY2=DY1
         DZ= PAR(4)
      ELSE
         DY2=PAR(4)
         DZ=PAR(5)
      ENDIF
C       FACE parameters:
C       FACE 1:
      P1X= -DX1
      P1Y= -DY1
      P1Z= -DZ
C
      P2X= DX1
      P2Y= -DY1
      P2Z= -DZ
C
      P3X= DX1
      P3Y= DY1
      P3Z= -DZ
C
      P4X= -DX1
      P4Y= DY1
      P4Z= -DZ
C       Next FACE:
      P5X= -DX2
      P5Y= -DY2
      P5Z= DZ
C
      P6X= DX2
      P6Y= -DY2
      P6Z= DZ
C
      P7X= DX2
      P7Y= DY2
      P7Z= DZ
C
      P8X= -DX2
      P8Y= DY2
      P8Z= DZ
C       DESCRIBED BY 2 FACES represented by polylines
C       connected by the 4 corners of the shape.
C *WRITE SET@103,F1,:5,2#3,3,2,P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
C *WRITE SET@103,F2,:5,2#3,3,2,P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z
C *WRITE SET @100,N,:5,2,:9,'MATNAM'#145,!F1,!F2,
C-------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,P1X,P1Y,P1Z,P2X,P2Y,P2Z, P3X,P3Y,P3Z,P4X,
     +P4Y,P4Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10000)N1,P5X,P5Y,P5Z,P6X,P6Y,P6Z, P7X,P7Y,P7Z,P8X,
     +P8Y,P8Z
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,N1-2,N1-1
      CALL GJWRIT
C
10000   FORMAT('@103,',I10,',:5,2#3,3,2,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@100,',I10,',:5,2#145,!',I10,',!',I10)
C
      END
+DECK,  GTRSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE  GTRSET(PAR)
C-
C-   Created  26-JUL-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C-  Calculates the coordinates of the corner points of a GEANT GTRA  shape
C-  from the shape parameters.   The end faces are generated by drawing
C-  connected polylines between the corner points at each Z-end of the shape.
C-  A ruled solid is then defined between the 2 faces, and written out in SET.
C----------------------------------------------------------------------
C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
      REAL P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z
C
C----------------------------------------------------------------------
C
C  GTRA as TRAP except that the faces are rotated aroud the Z-axis
C
C             TRAP
C

      DZ=PAR(1)
      TX= (PAR(2)*3.14159265359)/180.
      TY= (PAR(3)*3.14159265359)/180.
      TWIST=(PAR(4)*3.14159265359)/180.
      H1=PAR(5)
      BL1=PAR(6)
      TL1=PAR(7)
      H2=PAR(9)
      BL2=PAR(10)
      TL2=PAR(11)
C       Parameter conv for faces..
C       FACE parameters:
C       FACE 1:
      P1X= -BL1-DZ*SIN(TX)
      P1Y= -H1-DZ*SIN(TY)
      P1Z= -DZ
C
      P2X= BL1-DZ*SIN(TX)
      P2Y= -H1-DZ*SIN(TY)
      P2Z= -DZ
C
      P3X= TL1-DZ*SIN(TX)
      P3Y= H1-DZ*SIN(TY)
      P3Z= -DZ
C
      P4X= -TL1-DZ*SIN(TX)
      P4Y= H1-DZ*SIN(TY)
      P4Z= -DZ
C       Next FACE:
      P5X= -BL2+DZ*SIN(TX)
      P5Y= -H2+DZ*SIN(TY)
      P5Z= DZ
C
      P6X= BL2+DZ*SIN(TX)
      P6Y= -H2+DZ*SIN(TY)
      P6Z= DZ
C
      P7X= TL2+DZ*SIN(TX)
      P7Y= H2+DZ*SIN(TY)
      P7Z= DZ
C
      P8X= -TL2+DZ*SIN(TX)
      P8Y= H2+DZ*SIN(TY)
      P8Z= DZ
C       DESCRIBED BY 2 FACES represented by polylines
C       connected by the 4 corners of the shape.
C *WRITE SET@103,F1#3,3,2,P1X,P1Y,P1Z,P2X,P2Y,P2Z,P3X,P3Y,P3Z,P4X,P4Y,P4Z
C      Geometric Transformation
C*WRITE SET @302,N1..#301,R1,R2,R3,R4,R5,R6,R7,R8,R9
C *WRITE SET@113,
C *WRITE SET@103,F2#3,3,2,P5X,P5Y,P5Z,P6X,P6Y,P6Z,P7X,P7Y,P7Z,P8X,P8Y,P8Z
C
C *WRITE SET @100,N#145,!F1,!F2,
C-------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,P1X,P1Y,P1Z,P2X,P2Y,P2Z, P3X,P3Y,P3Z,P4X,
     +P4Y,P4Z
      CALL GJWRIT
C     Rotation of face:
C
C      Rotation around the Z-axis.  Coeffisients of rotation:
      R1= COS(-TWIST)
      R2= -SIN(-TWIST)
      R3= 0.0
      R4= SIN(-TWIST)
      R5= COS(-TWIST)
      R6= 0.0
      R7= 0.0
      R8= 0.0
      R9= 1.0
C
C Twist applied, results in constructed faces.
      N1=N1+1
      WRITE(BLKSTR,10100)N1,R1,R2,R3,R4,R5,R6,R7,R8,R9
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10200)N1,N1-2,N1-1
      CALL GJWRIT
C     Second face:
      N1=N1+1
      WRITE(BLKSTR,10000)N1,P5X,P5Y,P5Z,P6X,P6Y,P6Z, P7X,P7Y,P7Z,P8X,
     +P8Y,P8Z
      CALL GJWRIT
C     Rotation of faces:
C
C      Rotation around the Z-axis.  Coeffisients of rotation:
      R1= COS(TWIST)
      R2= -SIN(TWIST)
      R3= 0.0
      R4= SIN(TWIST)
      R5= COS(TWIST)
      R6= 0.0
      R7= 0.0
      R8= 0.0
      R9= 1.0
C
C Twist applied, results in constructed faces.
      N1=N1+1
      WRITE(BLKSTR,10100)N1,R1,R2,R3,R4,R5,R6,R7,R8,R9
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10200)N1,N1-2,N1-1
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10300)N1,N1-4,N1-1
      CALL GJWRIT
C
10000   FORMAT('@103,',I10,',:5,2#3,3,2,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@302,',I10,'#301,',G14.7,',',G14.7,',',G14.7
     +  ,',',G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7,',',G14.7)
10200   FORMAT('@113,',I10,',:5,2#101,!',I10,',!',I10)
10300   FORMAT('@100,',I10,',:5,2#145,!',I10,',!',I10)
C
C
   10 RETURN
      END
+DECK,  GTUSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GTUSET(PAR,ISHAPE)
C-
C-   Created  12-JUN-1991   Nils Joar Hoimyr
C-   Modified 21.02.1992  Jouko Vuoskoski
C-
C   Converts GEANT shapes TUBE&TUBS to SET
C-
C-   Describes a contour face of a TUBE(Segment) from the GEANT
C-   TUBE/TUBS shape parameters.  This face is rotated around the
C-   Z-axis to generated the solid shape in SET.
C
C---------------------------------------------------------------------
C
+CDE, GCSETF.

C
      DIMENSION PAR(50)
      REAL DX1,DZ,RMIN,RMAX,PHIMIN,PHIMAX,Z2
C
C----------------------------------------------------------------------
C
      RMIN=PAR(1)
      RMAX=PAR(2)
      Z2=PAR(3)
      IF (ISHAPE.EQ.5) THEN
         PHIMIN=0.0
         PHIMAX=360.0
      ELSEIF (ISHAPE.EQ.6) THEN
         PHIMIN=PAR(4)
         PHIMAX=PAR(5)
      ENDIF
C       SET CONVERSION
      Z= 2*Z2
      DX1=0.0
      DY=0.0
      DZ=Z2
      IF (RMAX .LE. 0.0) THEN
         WRITE (*,*) 'IMPOSSIBLE RADIUS VALUE'
         N1=N1-1
         GOTO 10
      ENDIF
C *WRITE SET @50,N1,:5,2#32,RMAX,Z,PHIMIN,PHIMAX,RMIN
C *WRITE SET @302,N2,:5,2#317,0,0,-Z2
C *WRITE SET @100,N3,:5,2,:9,'MATNAM'#101,!N1,!N2
C-------------------------------------------------------------------
C
      WRITE(BLKSTR,10000)N1,RMAX,Z,PHIMIN,PHIMAX,RMIN
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10100)N1,-DX1,-DY,-DZ
      CALL GJWRIT
      N1=N1+1
      WRITE(BLKSTR,10200)N1,N1-2,N1-1
      CALL GJWRIT
C
10000   FORMAT('@50,',I10,',:5,2#32,',G14.7,',',G14.7,','
     +  ,G14.7,',',G14.7,',',G14.7)
10100   FORMAT('@302,',I10,'#317,',G14.7,',',G14.7,',',G14.7)
10200   FORMAT('@100,',I10,',:5,2#101,!',I10,',!',I10)
C
   10 RETURN
      END
+DECK,  GTXSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GTXSET(FNAME,ANAME,NBINS,LUNIT,LUNIT2,
     +INST,SITE,DEPT,RESP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Writes out a description of the detector in SET file format.  *
C.    *  This is the main routine in the GEANT-SET interface           *
C.    *                                                                *
C.    *                    CADINT 1.20                                 *
C.    *                    ***********                                 *
C.    *    In this version VISIBLE VOLUMES are written out in a        *
C.    *    flat assembly.                                              *
C.    *    For questions, contact the authors.                         *
C.    *                                                                *
C.    *       Authors : NJ Hoimyr, J Vuoskoski     *********           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSETF.

+CDE, GCDLIN.
+CDE, GCNUM.
+CDE, GCUNIT.
*
      CHARACTER*24    INST,SITE,DEPT,RESP
      CHARACTER*24    FNAME
      CHARACTER*4     ANAME,NAME
      INTEGER         LUNIT,LUNIT2,NBINS
*     ------------------------------------------------------------
*
      WRITE(CHMAIL,'('' Starting to write SET file...'')')
      CALL GMAIL(1,0)
*
*     local zebra links
      CALL MZLINT(IXSTOR,'/GCDLIN/',NCWORD,JCDFRS,JCDLST)
*
*     number of volumes:
      NVOL=0
*     counter for SET blocks:
      N1=2
*     Assign logical unit for .set file:
      NUNIT1=LUNIT
*     Assign logical unit for .mat file:
      NUNIT2=LUNIT2
*
* *** I n i t i a l i z e  S E T f i l e
*
*     Starting blocks:
      CALL GSTSET(FNAME,ANAME,INST,SITE,DEPT,RESP)
      NPLACE=1
*
*     Starts material listing file:
      CALL GSTMAT(FNAME)
*
*     c a l q.  n u m. o f  v o l u m e s
   10 IF (LQ(JVOLUM-NVOL-1).EQ.0.OR.IQ(JVOLUM-2).EQ.NVOL) GOTO 20
      NVOL=NVOL+1
      GOTO 10
   20 CONTINUE
*
*     Is NAME an existing volume ?
      NAME = ANAME
      CALL GLOOK (NAME,IQ(JVOLUM+1),NVOLUM,IVO)
*
* *** Uses information given by the drawing package **
*
      CALL GDEXCA (NAME,NBINS)
*
* *** e n d  o f  S E T  f i l e
*
* *** write the tree
*
      CALL GWRTRE (NAME, NVOL)
      CALL GENSET
*
      WRITE(CHMAIL,'('' '')')
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' The selected geometry is now converted '')')
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' into the SET file format and the file '')')
      CALL GMAIL(0,0)
      WRITE(CHMAIL,'('' is in your current working directory '')')
      CALL GMAIL(0,0)
*
      IF(JCADNT.NE.0) THEN
         CALL MZDROP(IXSTOR, JCADNT, ' ')
      ENDIF
      NCWORD(1) = 0
*
      END
+DECK,  GWEUCL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GWEUCL (LUN,FILNAM,TOPVOL,NUMBER,NLEVEL)
*
*
*     ******************************************************************
*     *                                                                *
*     *  Write out the geometry of the detector in EUCLID file format  *
*     *                                                                *
*     *       filnam : will be with the extension .euclid              *
*     *       topvol : volume name of the starting node                *
*     *       number : copy number of topvol (relevant for gsposp)     *
*     *       nlevel : number of  levels in the tree structure         *
*     *                to be written out, starting from topvol         *
*     *                                                                *
*     *       Author : M. Maire                                        *
*     *                                                                *
*     ******************************************************************
*
*
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
*
      CHARACTER*(*) FILNAM
      CHARACTER*80  FILEXT
      CHARACTER    CARD*80
      CHARACTER*4  TOPVOL
      CHARACTER*20 NATMED, NAMATE
      CHARACTER*4  NAME, MOTHER, SHAPE(16), KONLY
*
      DIMENSION PAR(50), ATT(20)
*
      DATA SHAPE/'BOX ','TRD1','TRD2','TRAP','TUBE','TUBS','CONE',
     +           'CONS','SPHE','PARA','PGON','PCON','ELTU','HYPE',
     +           'GTRA','CTUB'/
*
*
* *** The output filnam name will be with extension '.euclid'
      IF(INDEX(FILNAM,'.').EQ.0) THEN
         IT=LNBLNK(FILNAM)
      ELSE
         IT=INDEX(FILNAM,'.')-1
      ENDIF
+SELF, IF=-IBM.
      FILEXT=FILNAM(1:IT)//'.euclid'
+SELF, IF=IBM.
      FILEXT='/'//FILNAM(1:MIN(IT,8))//' EUCLID A1'
      CALL CLTOU(FILEXT)
+SELF.
*
      OPEN (UNIT=LUN,FILE=FILEXT,STATUS='UNKNOWN',FORM='FORMATTED')
*
* *** Initialisation of the working space
      IADVOL = NVOLUM
      IADTMD = IADVOL + NVOLUM
      IADROT = IADTMD + NTMED
      IF(JROTM.GT.0) THEN
         NROTM  = IQ(JROTM-2)
      ELSE
         NROTM = 0
      ENDIF
      NWTOT  = IADROT + NROTM
      CALL GWORK (NWTOT)
      CALL VZERO (IWS(1),NWTOT)
      MLEVEL = NLEVEL
      IF (NLEVEL.LE.0) MLEVEL = 20
*
* *** find the top volume and put it in the stak
      NUMBR = NUMBER
      IF (NUMBER.LE.0) NUMBR = 1
      CALL GFPARA (TOPVOL,NUMBR,1,NPAR,NATT,PAR,ATT)
      IF (NPAR.LE.0) THEN
         WRITE (CHMAIL,11100) TOPVOL,NUMBR
         CALL GMAIL (0,0)
         RETURN
      ENDIF
*
*     authorized shape ?
      CALL GLOOK (TOPVOL,IQ(JVOLUM+1),NVOLUM,IVO)
      JVO = LQ(JVOLUM - IVO)
      ISH =  Q(JVO + 2)
      IF (ISH.GT.12) THEN
         WRITE (CHMAIL,11100) TOPVOL,NUMBR
         CALL GMAIL (0,0)
         RETURN
      ENDIF
*
      LEVEL  = 1
      NVSTAK = 1
      IWS(NVSTAK)     = IVO
      IWS(IADVOL+IVO) = LEVEL
      IVSTAK = 0
*
* *** Flag all volumes and fill the stak
*
   10 CONTINUE
*
*     pick the next volume in stak
      IVSTAK = IVSTAK + 1
      IVO   = ABS(IWS(IVSTAK))
      JVO   = LQ(JVOLUM - IVO)
*
*     flag the tracking medium
      NUMED =  Q(JVO + 4)
      IWS(IADTMD + NUMED) = 1
*
*     get the daughters ...
      LEVEL = IWS(IADVOL+IVO)
      IF (LEVEL.LT.MLEVEL) THEN
         LEVEL = LEVEL + 1
         NIN = Q(JVO + 3)
*
*        from division ...
         IF (NIN.LT.0) THEN
            JDIV = LQ(JVO  - 1)
            IVIN =  Q(JDIV + 2)
            NVSTAK = NVSTAK + 1
            IWS(NVSTAK)      = -IVIN
            IWS(IADVOL+IVIN) =  LEVEL
*
*        from position ...
         ELSE IF (NIN.GT.0) THEN
            DO 20 IN=1,NIN
               JIN  = LQ(JVO - IN)
               IVIN =  Q(JIN + 2 )
               JVIN = LQ(JVOLUM - IVIN)
               ISH  =  Q(JVIN + 2)
*              authorized shape ?
               IF (ISH.LE.12) THEN
*                 not yet flagged ?
                  IF (IWS(IADVOL+IVIN).EQ.0) THEN
                     NVSTAK = NVSTAK + 1
                     IWS(NVSTAK)      = IVIN
                     IWS(IADVOL+IVIN) = LEVEL
                  ENDIF
*                 flag the rotation matrix
                  IROT =  Q(JIN + 4 )
                  IF (IROT.GT.0) IWS(IADROT+IROT) = 1
               ENDIF
   20       CONTINUE
         ENDIF
      ENDIF
*
*     next volume in stak ?
      IF (IVSTAK.LT.NVSTAK) GO TO 10
*
* *** Write down the tracking medium definition
*
      CARD = '!       Tracking medium'
      WRITE (LUN,10000) CARD
*
      DO 30 ITM = 1,NTMED
         IF (IWS(IADTMD+ITM).GT.0) THEN
            JTM  = LQ(JTMED-ITM)
            CALL UHTOC (IQ(JTM+1),4,NATMED,20)
            IMAT =  Q(JTM+6)
            JMA  = LQ(JMATE-IMAT)
            IF(JMA.LE.0) THEN
               NAMATE = ' '
               WRITE(CHMAIL,11300) ITM, NATMED(1:LNBLNK(NATMED))
               CALL GMAIL(1,1)
            ELSE
               CALL UHTOC (IQ(JMA+1),4,NAMATE,20)
            ENDIF
            CARD = ' '
            WRITE (CARD,10100) ITM,NATMED,IMAT,NAMATE
            WRITE (LUN,'(A)') CARD
         ENDIF
   30 CONTINUE
*
* *** Write down the rotation matrix
*
      CARD = '!       Reperes'
      WRITE (LUN,10000) CARD
*
      DO 40 IRM = 1,NROTM
         IF (IWS(IADROT+IRM).GT.0) THEN
            JRM  = LQ(JROTM-IRM)
            CARD = ' '
            WRITE (CARD,10200) IRM,(Q(JRM+K),K=11,16)
            WRITE (LUN,'(A)') CARD
         ENDIF
   40 CONTINUE
*
* *** Write down the volume definition
*
      CARD = '!       Volumes'
      WRITE (LUN,10000) CARD
*
      DO 50 IVSTAK = 1,NVSTAK
         IVO = IWS(IVSTAK)
         IF (IVO.GT.0) THEN
            CALL UHTOC (IQ(JVOLUM+IVO),4,NAME,4)
            JVO  = LQ(JVOLUM-IVO)
            ISH   = Q(JVO+2)
            NMED  = Q(JVO+4)
            IF (IVSTAK.GT.1) NPAR  = Q(JVO+5)
            CARD = ' '
            IF (NPAR.GT.0) THEN
               IF (IVSTAK.GT.1) CALL UCOPY (Q(JVO+7),PAR(1),NPAR)
               CALL GCKPAR (ISH,NPAR,PAR)
               WRITE (CARD,10300) NAME,SHAPE(ISH),NMED,NPAR
               WRITE (LUN,'(A)') CARD
               WRITE (LUN,10400) (PAR(K),K=1,NPAR)
            ELSE
               WRITE (CARD,10300) NAME,SHAPE(ISH),NMED,NPAR
               WRITE (LUN,'(A)') CARD
            ENDIF
         ENDIF
   50 CONTINUE
*
* *** Write down the division of volumes
*
      CARD = '!       Divisions'
      WRITE (LUN,10000) CARD
*
      DO 60 IVSTAK = 1,NVSTAK
         IVO = ABS(IWS(IVSTAK))
         JVO  = LQ(JVOLUM-IVO)
         ISH  =  Q(JVO+2)
         NIN  =  Q(JVO+3)
*        this volume is divided ...
         IF (NIN.LT.0) THEN
            JDIV = LQ(JVO-1)
            IAXE =  Q(JDIV+1)
            IVIN =  Q(JDIV+2)
            NDIV =  Q(JDIV+3)
            C0   =  Q(JDIV+4)
            STEP =  Q(JDIV+5)
            JVIN = LQ(JVOLUM-IVIN)
            NMED =  Q(JVIN+4)
            CALL UHTOC (IQ(JVOLUM+IVO ),4,MOTHER,4)
            CALL UHTOC (IQ(JVOLUM+IVIN),4,NAME  ,4)
            CARD = ' '
            IF ((STEP.LE.0.).OR.(ISH.GE.11)) THEN
*              volume with negative parameter or gsposp or PGON ...
               WRITE (CARD,10500) NAME,MOTHER,NDIV,IAXE
            ELSEIF ((NDIV.LE.0).OR.(ISH.EQ.10)) THEN
*              volume with negative parameter or gsposp or PARA ...
               NDVMX = ABS(NDIV)
               WRITE (CARD,10600) NAME,MOTHER,STEP,IAXE,NMED,NDVMX
            ELSE
*              normal volume : all kind of division are equivalent
               WRITE (CARD,10700) NAME,MOTHER,STEP,IAXE,C0,NMED,NDIV
            ENDIF
            WRITE (LUN,'(A)') CARD
         ENDIF
   60 CONTINUE
*
* *** Write down the the positionnement of volumes
*
      card = '!       Positionnements'
      WRITE (LUN,10000) CARD
*
      DO 80 IVSTAK = 1,NVSTAK
         IVO = ABS(IWS(IVSTAK))
         CALL UHTOC (IQ(JVOLUM+IVO ),4,MOTHER,4)
         JVO  = LQ(JVOLUM-IVO)
         NIN  =  Q(JVO+3)
*        this volume has daughters ...
         IF (NIN.GT.0) THEN
            DO 70 IN=1,NIN
               JIN  = LQ(JVO-IN)
               IVIN =  Q(JIN +2)
               NUMB =  Q(JIN +3)
               IROT =  Q(JIN +4)
               X    =  Q(JIN +5)
               Y    =  Q(JIN +6)
               Z    =  Q(JIN +7)
               KONLY = 'ONLY'
               IF (Q(JIN+8).NE.1.) KONLY = 'MANY'
               CALL UHTOC (IQ(JVOLUM+IVIN),4,NAME  ,4)
               JVIN = LQ(JVOLUM-IVIN)
               ISH  =  Q(JVIN+2)
               CARD = ' '
*              gspos or gsposp ?
               NDATA = IQ(JIN-1)
               IF (NDATA.EQ.8) THEN
                  WRITE (CARD,10800) NAME,NUMB,MOTHER,X,Y,Z,IROT,KONLY
                  WRITE (LUN,'(A)') CARD
               ELSE
                  NPAR =  Q(JIN+9)
                  CALL UCOPY (Q(JIN+10),PAR(1),NPAR)
                  CALL GCKPAR (ISH,NPAR,PAR)
                  WRITE (CARD,10900) NAME,NUMB,MOTHER,X,Y,Z,IROT,KONLY,
     +            NPAR
                  WRITE (LUN,'(A)') CARD
                  WRITE (LUN,10400) (PAR(K),K=1,NPAR)
               ENDIF
   70       CONTINUE
         ENDIF
   80 CONTINUE
*
      WRITE (LUN,11000)
      CLOSE (LUN)
*
      WRITE (CHMAIL,11200) FILEXT(1:IT+9)
      CALL GMAIL (1,1)
*
10000 FORMAT (1H!,/,A,/,1H!)
*
10100 FORMAT ('TMED',2(1X,I3,1X,1H',A20,1H'))
10200 FORMAT ('ROTM',1X,I3,6(1X,F8.3))
10300 FORMAT ('VOLU',2(1X,1H',A4,1H'),2(1X,I3))
10400 FORMAT (      (5X,6(1X,F11.5)))
10500 FORMAT ('DIVN',2(1X,1H',A4,1H'),2(1X,I3))
10600 FORMAT ('DIVT',2(1X,1H',A4,1H'),1X,F11.5,3(1X,I3))
10700 FORMAT ('DVT2',2(1X,1H',A4,1H'),1X,F11.5,1X,I3,1X,F11.5,2(1X,I3))
10800 FORMAT ('POSI',1X,1H',A4,1H',1X,I3,1X,1H',A4,1H',3(1X,F11.5),1X,I3
     &              ,1X,1H',A4,1H')
10900 FORMAT ('POSP',1X,1H',A4,1H',1X,I3,1X,1H',A4,1H',3(1X,F11.5),1X,I3
     &              ,1X,1H',A4,1H',1X,I3)
11000 FORMAT ('END')
*
11100 FORMAT (' *** GWEUCL *** top volume : ',A4,' number :',I3,
     &        ' can not be a valid root')
11200 FORMAT (' *** GWEUCL *** file: ',A,' is now written out')
11300 FORMAT (' *** GWEUCL *** material not defined for tracking ',
     +        'medium ',I5,' ',A)
*
      END
+DECK,  GWRTRE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:47  cernlib
* Geant

      SUBROUTINE GWRTRE (VLNAME, NVOL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write out the GEANT tree in the .mat file
C.    *       starting from the given volume                           *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GTXSET
C.    *
C.    *       Author: Jouko Vuoskoski                                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCDLIN.
+CDE, GCSETF.
C
      CHARACTER*4 VLNAME,VOLUNA
      CHARACTER*80   HELPST
C
C    this has to be changed:
      IF(JCADNT.EQ.0) THEN
         CALL MZBOOK(IXSTOR,JCADNT,JCADNT,1,'CADI',1,1,0,2,-1)
         CALL MZBOOK(IXSTOR,JBUF1,
     +               JCADNT,-1,'CAD1',0,0,NVOLUM,2,-1)
      ENDIF
      DO 10 JV=1,NVOLUM
         IQ(JBUF1+JV)=0
   10 CONTINUE
C
C     Load IVO numbers of this particular part of the tree
C     First the volume where to be started
C
      DO 20 IVO=1, NVOL
         JVVOLU=IQ(JVOLUM+IVO)
         CALL UHTOC(JVVOLU,4,VOLUNA,4)
         IF(VOLUNA.EQ.VLNAME) THEN
            IQ(JBUF1+1)=IVO
         ENDIF
   20 CONTINUE
C
C      Then all the others
C
      JV=1
      DO 70 NH1=1, 15
         DO 60 NH2=1, JV
            JVO=LQ(JVOLUM-IQ(JBUF1+NH2))
            NIN=Q(JVO+3)
            IF(NIN.GT.0) THEN
               DO 40 IIN=1, NIN
                  JIN=LQ(JVO-IIN)
                  JVFLAG=0
                  DO 30 NH3=1, JV
                     IF(Q(JIN+2).EQ.IQ(JBUF1+NH3)) JVFLAG=1
   30             CONTINUE
                  IF(JVFLAG.EQ.0) THEN
                     JV=JV+1
                     IQ(JBUF1+JV)=Q(JIN+2)
                  ENDIF
   40          CONTINUE
            ELSEIF(NIN.LT.0) THEN
               JDIV=LQ(JVO-1)
               JVFLAG=0
               DO 50 NH3=1, JV
                  IF(Q(JDIV+2).EQ.IQ(JBUF1+NH3)) JVFLAG=1
   50          CONTINUE
               IF(JVFLAG.EQ.0) THEN
                  JV=JV+1
                  IQ(JBUF1+JV)=Q(JDIV+2)
               ENDIF
            ENDIF
   60    CONTINUE
   70 CONTINUE
C
C
C     write out the volumes into the .mat file
C
      WRITE (NUNIT2,*)
      WRITE (NUNIT2,*)
      WRITE (NUNIT2,*)'GEANT TREE'
      WRITE (NUNIT2,*)'----------'
      WRITE (NUNIT2,*)
      WRITE (NUNIT2,*)'The GEANT tree starting from the given volume'
      WRITE (NUNIT2,*)
C
      DO 90 NH1=1, JV
         JVO=LQ(JVOLUM-IQ(JBUF1+NH1))
         NIN=Q(JVO+3)
         IF(NIN.GT.0) THEN
            I1=10
            I2=16
            WRITE (HELPST,'(A80)')' '
            WRITE (HELPST(1:4),10000)IQ(JVOLUM+IQ(JBUF1+NH1))
            WRITE (HELPST(6:10),10100)NIN
            DO 80 IIN=1, NIN
               JIN=LQ(JVO-IIN)
               IVO=Q(JIN+2)
               WRITE (HELPST(I1:I2),10200)IQ(JVOLUM+IVO)
               I1=I1+6
               I2=I2+6
               IF (I2.GE.73) THEN
                  WRITE(NUNIT2,'(A80)')HELPST
                  I1=10
                  I2=16
                  WRITE (HELPST,'(A80)')' '
               ENDIF
   80       CONTINUE
            WRITE(NUNIT2,'(A80)')HELPST
C
         ELSEIF(NIN.LT.0) THEN
            JDIV=LQ(JVO-1)
            IVO=Q(JDIV+2)
            NUMDIV=Q(JDIV+3)
            WRITE(NUNIT2,10300)IQ(JVOLUM+IQ(JBUF1+NH1)),-NUMDIV,
     +      Q(JDIV+ 4),Q(JDIV+5),IQ(JVOLUM+IVO)

         ENDIF
   90 CONTINUE
C
      WRITE (NUNIT2,*)
      WRITE (NUNIT2,*)
      WRITE (NUNIT2,*)'  ------ end of file -------'
C
10000 FORMAT(A4)
10100 FORMAT(I4)
10200 FORMAT(2X,A4)
10300 FORMAT(A4,1X,I4,2X,E15.8,2X,E15.8,2X,A4)
C
      END
+DECK,  HISTORY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant

* *** Version 1.21 (23-04-93)
*   8-04-92 : define Patchy title
*   7-04-92 : mods in GPTSET
*           : mods in START,STAMAT for file definition on ibm
*  16-04-92 : Cosmetic mods in START
*  27-04-92 : Aname bug on IBM corrected, mod of .mat output
*  10-11-92 : Added transfer of colour attribut to SET output
*  04-03-93 : Added routine GWRTRE to write the tree information into
*             the material file
*  04-03-93 : Added an option to choose the number of instances
*  14-04-93 : Mods in the output of tree information
*  14-04-93 : Mods in the "number of instances" option so that it affects
*             only to divisions
*  23-04-93 : Names changes to GEANT name convention scheme.  Some
*             cleaning done to GDEXCA (Earlier SETDRS)
+DECK,  README, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant

*        INFORMATION ABOUT THE GEANT-SET-INTERFACE (CADINT 1.20)
C    The interface is available in the CMZ patch CADINT. (CAR file CADINT.car)
C    An updated GXINT as well as command file CDF are also required.
C
C    You must recompile gxint and cdf, then you copy the interface code to your
C    directory in CMZ (YTOC cadint.car.)
C
C    You have to specify the name of the volume where you want to
C    start your conversion and the number of division instances to be written
C    into the SET file. This is useful in a case of many divisions.
C
C    Selection of volumes to export into SET is done with the visibility
C    attribute command (SATT volume SEEN x). Volume names will
C    be written into SET with an index to distinguish different instances
C    of a volume. In a case of many divisions, the indexing of slices will be
C    reset in each division.
C
C    The colors of the volumes will be transformed inte SET file as well.
C
C    When you export GEANT geometry to a CAD system,
C    be a bit careful not to have
C    too many volumes, because this will fill up the CAD system.  (Divided
C    volumes which  contains 100's of equal daughters are
C    therefore better to be SATT volume SEEN -2, or you can define the number
C    of division instances).
C
C    A good strategy is to make several SET files,
C    one for each sub part of the detector.
C    Material information is currently written into .mat file as well as
C    the tree information.
C
C    Remember that you must specify the drawing parameters again if you
C    want to draw your detector after you have used the interface command.
C
C    Contact Nils Hoimyr/CN/CE or Jouko Vuoskoski/CN/AS if you have any
C    questions regarding the interface.


+PATCH, GDRAW.
+DECK,  GCHNWK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:18  cernlib
* Geant

      SUBROUTINE GCHNWK
*
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCSPEE.
*
      SAVE FIRST
      LOGICAL FIRST
      DATA FIRST/.TRUE./
*
      IF(FIRST)THEN
         FIRST=.FALSE.
         CALL IOPWK(2,1,9)
      ENDIF
      CALL IDAWK(1)
      CALL IACWK(2)
*
 999  END
+DECK,  GD16V, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:19  cernlib
* Geant

+SELF, IF=CG.
      SUBROUTINE GD16V(IWOFFS,SHADE)
************************************************************************
*                                                                      *
*     Name: GD16V                                                      *
*     Author: S.Giani                            Date:    18.07.91     *
*                                                Revised: 1992         *
*                                                                      *
*     Function: Vizualisation of WIRE-object                           *
*               Search and construction of faces' visible portions     *
*               Surface filling for WIRE-object                        *
*               Two scan line algorithms                               *
*               Surface shading                                        *
*                                                                      *
*     References: CGVHED                                               *
*                                                                      *
*     Input: Q(JCG+IWOFFS+*) - WIRE-object                             *
*               Q(JCG+*) - HIDE-structure                              *
*                                                                      *
*     Output: none                                                     *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, CGGPAR.
+CDE, CGHPAR.
+CDE, CGDELT.
+CDE, CGCTRA.
+CDE, CGCEDG.
+CDE, GCDRAW.
+CDE, GCFLAG.
+CDE, GCSPEE.
+CDE, GCONST.
+CDE, GCHILN.
*
      INTEGER SHADE(*)
      REAL P1(3),P2(3),AX(2),AY(2)
*SG
      DIMENSION ISCFAC(500),SCXYZ(3,500),COSDIR(4)
      DIMENSION CX(500),CY(500),CZ(500)
      DIMENSION TESTX(2),TESTY(2)
      DIMENSION VVX(500),VVY(500)
*
      DIMENSION AROT(4,4),ZROT(4,4),CXROT(500),CYROT(500),CZROT(500)
      DIMENSION PXINT(50),PZINT(50),XPINT(50),YPINT(50),ZPINT(50),RRR(4)
*SG
      LLEP=ABS(LEP)
*****                                 CALL IGSET('SYNC',1.)
      IF (Q(JCG+IWOFFS+KCGSIZ) .LE. 0.)   THEN
         WRITE(CHMAIL,10000)
         GOTO 400
      ENDIF
      IF (Q(JCG+KHSIZE) .LE. LHHEAD)  THEN
         WRITE(CHMAIL,10100)
         GOTO 400
      ENDIF
*SG
      LINBUF=0
      DO 10  IJ=1,2
         TESTX(IJ)=20.
         TESTY(IJ)=20.
   10 CONTINUE
      LINFIL=IBITS(LINATT,13,3)
      IF(LINFIL.NE.0)CALL GDRAWV(TESTX,TESTY,-1)
      IJKLMN=0
      IACTUN=0
      LPARZ=0
      LFULL=0
      IN=0
      KKK=0
      LMN=0
      NSI=0
      IGEN=0
*SG
      NT = Q(JCG+KHNT)
      IF (NT.LE.0 .OR. NT.GT.NTMAX) GOTO 400
      NEDGE  = Q(JCG+IWOFFS+KCGNF)
*      IF(NEDGE.EQ.0)GOTO 49
      JXYZ1   = Q(JCG+KHJXYZ)
      JFA    = Q(JCG+KHJFA)
      JPFA   = Q(JCG+KHJPFA)
      JDFA   = Q(JCG+KHJDFA)
      JTRE   = Q(JCG+KHJTRE)
      JSTA   = Q(JCG+KHJSTA)
      JALE   = Q(JCG+KHJALE)
      JARI   = Q(JCG+KHJARI)
      NFACE  = Q(JCG+KHNFAC)
      DO 230 NE=1,NEDGE
         IF(LINFIL.NE.0)THEN
            IF(LLEP.NE.1)THEN
               DO 180 MMM=2,SHADE(1)
                  IF(NE.EQ.(SHADE(MMM)+1).AND.NE.NE.1)THEN
***                     IF((LFULL+LPARZ).EQ.0)GOTO 260
                     CALL CGFAC2(CX,CY,CZ,LMN)
                     ISCFAC(1)=LMN*.5
                     DO 20  I=2,LMN+1
                        ISCFAC(I)=I-1
                        SCXYZ(1,I-1)=CX(I-1)
                        SCXYZ(2,I-1)=CY(I-1)
                        SCXYZ(3,I-1)=CZ(I-1)
   20                CONTINUE
                     CALL CGHPLA(ISCFAC,SCXYZ,COSDIR)
                     XCOSX=(SIN(GTHETA*DEGRAD))*(COS(GPHI*DEGRAD))
                     YCOSY=(SIN(GTHETA*DEGRAD))*(SIN(GPHI*DEGRAD))
                     ZCOSZ=COS(GTHETA*DEGRAD)
                     PROSCA=(COSDIR(1)*XCOSX)+(COSDIR(2)*YCOSY)+
     +               (COSDIR(3)*ZCOSZ)
                     PROSCB=(2.*(PROSCA**2))-1.
                     APROSC=PROSCB
*            IF(APROSC.LT.-1.)PRINT *,'GT1'
                     IF(LFULL.EQ.(IJKLMN/2).AND.
     +       (LINFIL.EQ.2.OR.LINFIL.EQ.3))THEN
                        CALL CGFACO(VVX,VVY,IJKLMN,LFULL,APROSC)
                     ELSE
                        IF(ISWIT(10).EQ.100)THEN
                           PNX=COSDIR(1)
                           PNY=COSDIR(2)
                           PNZ=COSDIR(3)
                           APNZ=ABS(1.-PNZ)
                           IF(APNZ.LT..0001)THEN
                              AROT(1,1)=1.
                              AROT(1,2)=0.
                              AROT(1,3)=0.
                              AROT(2,1)=0.
                              AROT(2,2)=1.
                           ELSE
                              AROT(1,1)=PNX*PNZ/SQRT(PNX**2+PNY**2)
                              AROT(1,2)=PNY*PNZ/SQRT(PNX**2+PNY**2)
                              AROT(1,3)=-SQRT(PNX**2+PNY**2)
                              AROT(2,1)=-PNY/SQRT(PNX**2+PNY**2)
                              AROT(2,2)=PNX/SQRT(PNX**2+PNY**2)
                           ENDIF
                           AROT(2,3)=0.
                           AROT(3,1)=PNX
                           AROT(3,2)=PNY
                           AROT(3,3)=PNZ
                        ELSE
                           DO 40  IHH=1,3
                              DO 30  JHH=1,4
                                 AROT(IHH,JHH)=TSCRN(JHH,IHH,NT)
   30                         CONTINUE
   40                      CONTINUE
                           AROT(4,1)=0.
                           AROT(4,2)=0.
                           AROT(4,3)=0.
                           AROT(4,4)=1.
                        ENDIF
                        IF(ISWIT(10).EQ.100)THEN
                           ZROT(1,1)=AROT(1,1)
                           ZROT(2,1)=AROT(1,2)
                           ZROT(3,1)=AROT(1,3)
                           ZROT(1,2)=AROT(2,1)
                           ZROT(2,2)=AROT(2,2)
                           ZROT(3,2)=AROT(2,3)
                           ZROT(1,3)=AROT(3,1)
                           ZROT(2,3)=AROT(3,2)
                           ZROT(3,3)=AROT(3,3)
                        ELSE
                           DO 60  IHH=1,4
                              DO 50  JHH=1,4
                                 ZROT(IHH,JHH)=AROT(IHH,JHH)
   50                         CONTINUE
   60                      CONTINUE
                           CALL RINV(4,ZROT,4,RRR,IFAIL)
                        ENDIF
                        YROTMI=100000.
                        YROTMA=-100000.
                        DO 70 M=1,LMN
                           IF(ISWIT(10).EQ.100)THEN
                              CXROT(M)=AROT(1,1)*CX(M)+ AROT(1,2)*CY(M)
     +                        +AROT(1,3)*CZ(M)
                              CYROT(M)=AROT(2,1)*CX(M)+ AROT(2,2)*CY(M)
     +                        +AROT(2,3)*CZ(M)
                              CZROT(M)=AROT(3,1)*CX(M)+ AROT(3,2)*CY(M)
     +                        +AROT(3,3)*CZ(M)
                           ELSE
                              CXROT(M)=AROT(1,4)+AROT(1,1)*CX(M)+
     +                        AROT(1,2)*CY(M)+AROT(1,3)*CZ(M)
                              CYROT(M)=AROT(2,4)+AROT(2,1)*CX(M)+
     +                        AROT(2,2)*CY(M)+AROT(2,3)*CZ(M)
                              CZROT(M)=AROT(3,4)+AROT(3,1)*CX(M)+
     +                        AROT(3,2)*CY(M)+AROT(3,3)*CZ(M)
                           ENDIF
                           IF(CYROT(M).LT.YROTMI)YROTMI=CYROT(M)
                           IF(CYROT(M).GT.YROTMA)YROTMA=CYROT(M)
   70                   CONTINUE
                        IF(LINFIL.EQ.1)THEN
                           RINULI=.01
                        ELSEIF(LINFIL.EQ.2)THEN
                           RINULI=.1
                        ELSEIF(LINFIL.EQ.3)THEN
                           RINULI=.05
                        ELSEIF(LINFIL.EQ.4)THEN
                           RINULI=.05
                        ELSEIF(LINFIL.EQ.5)THEN
                           RINULI=.02
                        ELSEIF(LINFIL.EQ.6)THEN
                           RINULI=.01
                        ELSEIF(LINFIL.EQ.7)THEN
                           RINULI=.005
                        ENDIF
                        NYROTM=(YROTMA-YROTMI)/RINULI
                        YROTST=YROTMI
                        DO 170 MM=1,NYROTM-1
                           YROTST=YROTST+RINULI
                           JFK=0
                           DO 80 MMI=1,LMN-1,2
                              IF(CXROT(MMI).EQ.CXROT(MMI+1))THEN
                                 IF(MIN(CYROT(MMI),CYROT(MMI+1)).LT.
     +                           YROTST.AND.MAX(CYROT(MMI),CYROT(MMI+1)
     +                           ) .GT.YROTST)THEN
                                    JFK=JFK+1
                                    PXINT(JFK)=CXROT(MMI)
                                    IF(CZROT(MMI).EQ.CZROT(MMI+1))THEN
                                    PZINT(JFK)=CZROT(MMI)
                                 ELSEIF(CYROT(MMI).NE.CYROT(MMI+1))
     +                           THEN
                                    AAAZ=(CYROT(MMI)-CYROT(MMI+1))/
     +                              (CZROT(MMI)-CZROT(MMI+1))
                                    BBBZ=(CZROT(MMI)*CYROT(MMI+1)-
     +                              CYROT(MMI)*CZROT(MMI+1))/ (CZROT(MM
     +                              I)-CZROT(MMI+1))
                                    PZINT(JFK)=(YROTST-BBBZ)/AAAZ
                                    ENDIF
                                 ENDIF
                              ELSEIF(CYROT(MMI).NE.CYROT(MMI+1))THEN
                                 IF(MIN(CYROT(MMI),CYROT(MMI+1)).LT.
     +                           YROTST.AND.MAX(CYROT(MMI),CYROT(MMI+1)
     +                           ) .GT.YROTST)THEN
                                    AAA=(CYROT(MMI)-CYROT(MMI+1))/
     +                              (CXROT(MMI)-CXROT(MMI+1))
                                    BBB=(CXROT(MMI)*CYROT(MMI+1)-
     +                              CYROT(MMI)*CXROT(MMI+1))/ (CXROT(MM
     +                              I)-CXROT(MMI+1))
                                    JFK=JFK+1
                                    PXINT(JFK)=(YROTST-BBB)/AAA
                                    IF(CZROT(MMI).EQ.CZROT(MMI+1))THEN
                                    PZINT(JFK)=CZROT(MMI)
                                 ELSEIF(CYROT(MMI).NE.CYROT(MMI+1))
     +                           THEN
                                    AAAZ=(CYROT(MMI)-CYROT(MMI+1))/
     +                              (CZROT(MMI)-CZROT(MMI+1))
                                    BBBZ=(CZROT(MMI)*CYROT(MMI+1)-
     +                              CYROT(MMI)*CZROT(MMI+1))/ (CZROT(MM
     +                              I)-CZROT(MMI+1))
                                    PZINT(JFK)=(YROTST-BBBZ)/AAAZ
                                    ENDIF
                                 ENDIF
                              ENDIF
   80                      CONTINUE
                           DO 100 JM=1,JFK-1
                              DO 90 KM=JM+1,JFK
                                 IF(PXINT(JM).LT.PXINT(KM))THEN
                                    TMPM=PXINT(JM)
                                    TMPZ=PZINT(JM)
                                    PXINT(JM)=PXINT(KM)
                                    PZINT(JM)=PZINT(KM)
                                    PXINT(KM)=TMPM
                                    PZINT(KM)=TMPZ
                                 ENDIF
   90                         CONTINUE
  100                      CONTINUE
                           RJFK=JFK*.5
                           IRJFK=RJFK
*                          IF((RJFK-IRJFK).GT..1)PRINT *,'Odd !'
                           DO 110 MR=1,JFK
                              IF(ISWIT(10).EQ.100)THEN
                                 XPINT(MR)=ZROT(1,1)*PXINT(MR)+ ZROT(1,
     +                           2)*YROTST+ZROT(1,3)*CZROT(1)
                                 YPINT(MR)=ZROT(2,1)*PXINT(MR)+ ZROT(2,
     +                           2)*YROTST+ZROT(2,3)*CZROT(1)
                                 ZPINT(MR)=ZROT(3,1)*PXINT(MR)+ ZROT(3,
     +                           2)*YROTST+ZROT(3,3)*CZROT(1)
                              ELSE
                                 XPINT(MR)=ZROT(1,4)+ZROT(1,1)*
     +                           PXINT(MR)+ ZROT(1,2)*YROTST+ZROT(1,3)*
     +                           PZINT(MR)
                                 YPINT(MR)=ZROT(2,4)+ZROT(2,1)*
     +                           PXINT(MR)+ ZROT(2,2)*YROTST+ZROT(2,3)*
     +                           PZINT(MR)
                                 ZPINT(MR)=ZROT(3,4)+ZROT(3,1)*
     +                           PXINT(MR)+ ZROT(3,2)*YROTST+ZROT(3,3)*
     +                           PZINT(MR)
                              ENDIF
  110                      CONTINUE
                           IF(LINFIL.GT.1)THEN
                              LINCOL=IBITS(LINATT,16,8)
                              CALL GDSHAD(LINCOL,APROSC)
                           ENDIF
                           DO 160 MZ=1,JFK,2
                              P1(1)=XPINT(MZ)
                              P1(2)=YPINT(MZ)
                              P1(3)=ZPINT(MZ)
                              P2(1)=XPINT(MZ+1)
                              P2(2)=YPINT(MZ+1)
                              P2(3)=ZPINT(MZ+1)
                              CALL CGVEDG(NT,P1,P2,IVIS)
                              IF (IVIS .LT. 0) GOTO 150
                              IF (NFACE .EQ. 0) GOTO 140
                              CALL CGVHED( Q(JCG+JXYZ1),IQ(JCG+JFA),
     +                        IQ(JCG+JPFA), Q(JCG+ JDFA),IQ(JCG+JTRE),
     +                        IQ(JCG+JSTA), Q(JCG+JALE),Q(JCG+JARI))
*           D R A W   E D G E
                              IF (NPART) 150,140,120
  120                         DO 130 I=1,NPART+1
                                 IF (I .EQ. 1) T1 = 0.
                                 IF (I .NE. 1) T1 = TEND(I-1)
                                 IF (I .NE. NPART+1) T2 = TSTRT(I)
                                 IF (I .EQ. NPART+1) T2 = 1.
                                 IF (T2-T1 .LT. TDEL) GOTO 130
                                 AX(1) = XA + T1*XDELT
                                 AY(1) = YA + T1*YDELT
                                 AX(2) = XA + T2*XDELT
                                 AY(2) = YA + T2*YDELT
                                 IF(LINFIL.GT.1.AND.IDVIEW.NE.0)THEN
                                    LLLINA=LINATT
                                    CALL MVBITS(LINCOL,0,8,LINATT,16)
                                    CALL GDRAWV(AX,AY,2)
                                    LINATT=LLLINA
                                 ELSE
                                    CALL GDRAWV(AX,AY,2)
                                 ENDIF
  130                         CONTINUE
                              GOTO 150
*           L I N E   I S   F U L L Y   V I S I B L E
  140                         CONTINUE
                              AX(1) = AA(1)
                              AY(1) = AA(2)
                              AX(2) = BB(1)
                              AY(2) = BB(2)
                              IF(LINFIL.GT.1.AND.IDVIEW.NE.0)THEN
                                 LLLINA=LINATT
                                 CALL MVBITS(LINCOL,0,8,LINATT,16)
                                 CALL GDRAWV(AX,AY,2)
                                 LINATT=LLLINA
                              ELSE
                                 CALL GDRAWV(AX,AY,2)
                              ENDIF
  150                         CONTINUE
  160                      CONTINUE
  170                   CONTINUE
                     ENDIF
*  Resetting counters for next face
                     IJKLMN=0
                     LPARZ=0
                     LFULL=0
                     IN=0
                     KKK=0
                     LMN=0
                     NSI=0
                     IGEN=0
                     GOTO 190
                  ENDIF
  180          CONTINUE
            ENDIF
         ENDIF
  190    CONTINUE
         J = LCGHEA + (NE-1)*LCGEDG
*         IEA = Q(JCG+IWOFFS+J+KCGAE)
         P1(1) = Q(JCG+IWOFFS+J+KCGX1)
         P1(2) = Q(JCG+IWOFFS+J+KCGY1)
         P1(3) = Q(JCG+IWOFFS+J+KCGZ1)
         P2(1) = Q(JCG+IWOFFS+J+KCGX2)
         P2(2) = Q(JCG+IWOFFS+J+KCGY2)
         P2(3) = Q(JCG+IWOFFS+J+KCGZ2)
         IF(LINFIL.NE.0)THEN
            LMN=LMN+1
*          IF(LMN.GE.500)THEN
*            PRINT *,LMN,'=LMN'
*          ENDIF
            CX(LMN)=P1(1)
            CY(LMN)=P1(2)
            CZ(LMN)=P1(3)
            LMN=LMN+1
*          IF(LMN.GE.500)THEN
*            PRINT *,LMN,'=LMN'
*          ENDIF
            CX(LMN)=P2(1)
            CY(LMN)=P2(2)
            CZ(LMN)=P2(3)
         ENDIF
         CALL CGVEDG(NT,P1,P2,IVIS)
         IF(LINFIL.NE.0)THEN
            IJKLMN=IJKLMN+1
*              IF(IJKLMN.GE.500)THEN
*                PRINT *,IJKLMN,'=IJKLMN'
*              ENDIF
            VVX(IJKLMN)=AA(1)
            VVY(IJKLMN)=AA(2)
            IJKLMN=IJKLMN+1
*              IF(IJKLMN.GE.500)THEN
*                PRINT *,IJKLMN,'=IJKLMN'
*              ENDIF
            VVX(IJKLMN)=BB(1)
            VVY(IJKLMN)=BB(2)
         ENDIF
         IF (IVIS .LT. 0) GOTO 230
         IF (NFACE .EQ. 0) GOTO 220
         CALL CGVHED( Q(JCG+JXYZ1),IQ(JCG+JFA),IQ(JCG+JPFA), Q(JCG+
     +   JDFA),IQ(JCG+JTRE),IQ(JCG+JSTA), Q(JCG+JALE),Q(JCG+JARI))
*           D R A W   E D G E
         IF (NPART) 230,220,200
  200    DO 210 I=1,NPART+1
            IF (I .EQ. 1) T1 = 0.
            IF (I .NE. 1) T1 = TEND(I-1)
            IF (I .NE. NPART+1) T2 = TSTRT(I)
            IF (I .EQ. NPART+1) T2 = 1.
            IF (T2-T1 .LT. TDEL) GOTO 210
            AX(1) = XA + T1*XDELT
            AY(1) = YA + T1*YDELT
            AX(2) = XA + T2*XDELT
            AY(2) = YA + T2*YDELT
            IF(LINFIL.NE.0)THEN
               LTY=IBITS(LINATT,10,3)
               CALL MVBITS(6,0,3,LINATT,10)
***               IOLEP=LEP
***               LEP=11
               CALL GDRAWV(AX,AY,2)
***               LEP=IOLEP
               CALL MVBITS(LTY,0,3,LINATT,10)
            ELSE
               CALL GDRAWV(AX,AY,2)
            ENDIF
  210    CONTINUE
         LPARZ=LPARZ+1
         GOTO 230
*           L I N E   I S   F U L L Y   V I S I B L E
  220    CONTINUE
         AX(1) = AA(1)
         AY(1) = AA(2)
         AX(2) = BB(1)
         AY(2) = BB(2)
         IF(LINFIL.NE.0)THEN
            LTY=IBITS(LINATT,10,3)
            CALL MVBITS(6,0,3,LINATT,10)
***            IOLEP=LEP
***            LEP=11
            CALL GDRAWV(AX,AY,2)
***            LEP=IOLEP
            CALL MVBITS(LTY,0,3,LINATT,10)
         ELSE
            CALL GDRAWV(AX,AY,2)
         ENDIF
         LFULL=LFULL+1
  230 CONTINUE
*SG
      IF(LINFIL.NE.0)THEN
***         IF((LFULL+LPARZ).EQ.0)GOTO 555
         CALL CGFAC2(CX,CY,CZ,LMN)
         ISCFAC(1)=LMN*.5
         DO 240  I=2,LMN+1
            ISCFAC(I)=I-1
            SCXYZ(1,I-1)=CX(I-1)
            SCXYZ(2,I-1)=CY(I-1)
            SCXYZ(3,I-1)=CZ(I-1)
  240    CONTINUE
         CALL CGHPLA(ISCFAC,SCXYZ,COSDIR)
         XCOSX=(SIN(GTHETA*DEGRAD))*(COS(GPHI*DEGRAD))
         YCOSY=(SIN(GTHETA*DEGRAD))*(SIN(GPHI*DEGRAD))
         ZCOSZ=COS(GTHETA*DEGRAD)
         PROSCA=(COSDIR(1)*XCOSX)+(COSDIR(2)*YCOSY)+ (COSDIR(3)*ZCOSZ)
         PROSCB=(2.*(PROSCA**2))-1.
         APROSC=PROSCB
*             IF(APROSC.GT.1)PRINT *,'GT1'
         IF(LFULL.EQ.IJKLMN/2.AND.
     +       (LINFIL.EQ.2.OR.LINFIL.EQ.3))THEN
            CALL CGFACO(VVX,VVY,IJKLMN,LFULL,APROSC)
         ELSE
            IF(ISWIT(10).EQ.100)THEN
               PNX=COSDIR(1)
               PNY=COSDIR(2)
               PNZ=COSDIR(3)
               APNZ=ABS(1.-PNZ)
               IF(APNZ.LT..0001)THEN
                  AROT(1,1)=1.
                  AROT(1,2)=0.
                  AROT(1,3)=0.
                  AROT(2,1)=0.
                  AROT(2,2)=1.
               ELSE
                  AROT(1,1)=PNX*PNZ/SQRT(PNX**2+PNY**2)
                  AROT(1,2)=PNY*PNZ/SQRT(PNX**2+PNY**2)
                  AROT(1,3)=-SQRT(PNX**2+PNY**2)
                  AROT(2,1)=-PNY/SQRT(PNX**2+PNY**2)
                  AROT(2,2)=PNX/SQRT(PNX**2+PNY**2)
               ENDIF
               AROT(2,3)=0.
               AROT(3,1)=PNX
               AROT(3,2)=PNY
               AROT(3,3)=PNZ
            ELSE
               DO 260 IHH=1,3
                  DO 250 JHH=1,4
                     AROT(IHH,JHH)=TSCRN(JHH,IHH,NT)
  250             CONTINUE
  260          CONTINUE
               AROT(4,1)=0.
               AROT(4,2)=0.
               AROT(4,3)=0.
               AROT(4,4)=1.
            ENDIF
            IF(ISWIT(10).EQ.100)THEN
               ZROT(1,1)=AROT(1,1)
               ZROT(2,1)=AROT(1,2)
               ZROT(3,1)=AROT(1,3)
               ZROT(1,2)=AROT(2,1)
               ZROT(2,2)=AROT(2,2)
               ZROT(3,2)=AROT(2,3)
               ZROT(1,3)=AROT(3,1)
               ZROT(2,3)=AROT(3,2)
               ZROT(3,3)=AROT(3,3)
            ELSE
               DO 280 IHH=1,4
                  DO 270 JHH=1,4
                     ZROT(IHH,JHH)=AROT(IHH,JHH)
  270             CONTINUE
  280          CONTINUE
               CALL RINV(4,ZROT,4,RRR,IFAIL)
            ENDIF
            YROTMI=100000.
            YROTMA=-100000.
            DO 290 M=1,LMN
               IF(ISWIT(10).EQ.100)THEN
                  CXROT(M)=AROT(1,1)*CX(M)+ AROT(1,2)*CY(M)+AROT(1,3)*
     +            CZ(M)
                  CYROT(M)=AROT(2,1)*CX(M)+ AROT(2,2)*CY(M)+AROT(2,3)*
     +            CZ(M)
                  CZROT(M)=AROT(3,1)*CX(M)+ AROT(3,2)*CY(M)+AROT(3,3)*
     +            CZ(M)
               ELSE
                  CXROT(M)=AROT(1,4)+AROT(1,1)*CX(M)+ AROT(1,2)*CY(M)+
     +            AROT(1,3)*CZ(M)
                  CYROT(M)=AROT(2,4)+AROT(2,1)*CX(M)+ AROT(2,2)*CY(M)+
     +            AROT(2,3)*CZ(M)
                  CZROT(M)=AROT(3,4)+AROT(3,1)*CX(M)+ AROT(3,2)*CY(M)+
     +            AROT(3,3)*CZ(M)
               ENDIF
               IF(CYROT(M).LT.YROTMI)YROTMI=CYROT(M)
               IF(CYROT(M).GT.YROTMA)YROTMA=CYROT(M)
  290       CONTINUE
            IF(LINFIL.EQ.1)THEN
               RINULI=.01
            ELSEIF(LINFIL.EQ.2)THEN
               RINULI=.1
            ELSEIF(LINFIL.EQ.3)THEN
               RINULI=.05
            ELSEIF(LINFIL.EQ.4)THEN
               RINULI=.05
            ELSEIF(LINFIL.EQ.5)THEN
               RINULI=.02
            ELSEIF(LINFIL.EQ.6)THEN
               RINULI=.01
            ELSEIF(LINFIL.EQ.7)THEN
               RINULI=.005
            ENDIF
            NYROTM=(YROTMA-YROTMI)/RINULI
            YROTST=YROTMI
            DO 390 MM=1,NYROTM-1
               YROTST=YROTST+RINULI
               JFK=0
               DO 300 MMI=1,LMN-1,2
                  IF(CXROT(MMI).EQ.CXROT(MMI+1))THEN
                     IF(MIN(CYROT(MMI),CYROT(MMI+1)).LT. YROTST.AND.MAX
     +               (CYROT(MMI),CYROT(MMI+1)) .GT.YROTST)THEN
                        JFK=JFK+1
                        PXINT(JFK)=CXROT(MMI)
                        IF(CZROT(MMI).EQ.CZROT(MMI+1))THEN
                           PZINT(JFK)=CZROT(MMI)
                        ELSEIF(CYROT(MMI).NE.CYROT(MMI+1))THEN
                           AAAZ=(CYROT(MMI)-CYROT(MMI+1))/ (CZROT(MMI)-
     +                     CZROT(MMI+1))
                           BBBZ=(CZROT(MMI)*CYROT(MMI+1)- CYROT(MMI)*
     +                     CZROT(MMI+1))/ (CZROT(MMI)-CZROT(MMI+1))
                           PZINT(JFK)=(YROTST-BBBZ)/AAAZ
                        ENDIF
                     ENDIF
                  ELSEIF(CYROT(MMI).NE.CYROT(MMI+1))THEN
                     IF(MIN(CYROT(MMI),CYROT(MMI+1)).LT. YROTST.AND.MAX
     +               (CYROT(MMI),CYROT(MMI+1)) .GT.YROTST)THEN
                        AAA=(CYROT(MMI)-CYROT(MMI+1))/ (CXROT(MMI)-
     +                  CXROT(MMI+1))
                        BBB=(CXROT(MMI)*CYROT(MMI+1)- CYROT(MMI)*
     +                  CXROT(MMI+1))/ (CXROT(MMI)-CXROT(MMI+1))
                        JFK=JFK+1
                        PXINT(JFK)=(YROTST-BBB)/AAA
                        IF(CZROT(MMI).EQ.CZROT(MMI+1))THEN
                           PZINT(JFK)=CZROT(MMI)
                        ELSEIF(CYROT(MMI).NE.CYROT(MMI+1))THEN
                           AAAZ=(CYROT(MMI)-CYROT(MMI+1))/ (CZROT(MMI)-
     +                     CZROT(MMI+1))
                           BBBZ=(CZROT(MMI)*CYROT(MMI+1)- CYROT(MMI)*
     +                     CZROT(MMI+1))/ (CZROT(MMI)-CZROT(MMI+1))
                           PZINT(JFK)=(YROTST-BBBZ)/AAAZ
                        ENDIF
                     ENDIF
                  ENDIF
  300          CONTINUE
               DO 320 JM=1,JFK-1
                  DO 310 KM=JM+1,JFK
                     IF(PXINT(JM).LT.PXINT(KM))THEN
                        TMPM=PXINT(JM)
                        TMPZ=PZINT(JM)
                        PXINT(JM)=PXINT(KM)
                        PZINT(JM)=PZINT(KM)
                        PXINT(KM)=TMPM
                        PZINT(KM)=TMPZ
                     ENDIF
  310             CONTINUE
  320          CONTINUE
               RJFK=JFK*.5
               IRJFK=RJFK
*              IF((RJFK-IRJFK).GT..1)PRINT *,'Odd !'
               DO 330 MR=1,JFK
                  IF(ISWIT(10).EQ.100)THEN
                     XPINT(MR)=ZROT(1,1)*PXINT(MR)+ ZROT(1,2)*YROTST+
     +               ZROT(1,3)*CZROT(1)
                     YPINT(MR)=ZROT(2,1)*PXINT(MR)+ ZROT(2,2)*YROTST+
     +               ZROT(2,3)*CZROT(1)
                     ZPINT(MR)=ZROT(3,1)*PXINT(MR)+ ZROT(3,2)*YROTST+
     +               ZROT(3,3)*CZROT(1)
                  ELSE
                     XPINT(MR)=ZROT(1,4)+ZROT(1,1)*PXINT(MR)+ ZROT(1,2)
     +               *YROTST+ZROT(1,3)*PZINT(MR)
                     YPINT(MR)=ZROT(2,4)+ZROT(2,1)*PXINT(MR)+ ZROT(2,2)
     +               *YROTST+ZROT(2,3)*PZINT(MR)
                     ZPINT(MR)=ZROT(3,4)+ZROT(3,1)*PXINT(MR)+ ZROT(3,2)
     +               *YROTST+ZROT(3,3)*PZINT(MR)
                  ENDIF
  330          CONTINUE
               IF(LINFIL.GT.1)THEN
                  LINCOL=IBITS(LINATT,16,8)
                  CALL GDSHAD(LINCOL,APROSC)
               ENDIF
               DO 380 MZ=1,JFK,2
                  P1(1)=XPINT(MZ)
                  P1(2)=YPINT(MZ)
                  P1(3)=ZPINT(MZ)
                  P2(1)=XPINT(MZ+1)
                  P2(2)=YPINT(MZ+1)
                  P2(3)=ZPINT(MZ+1)
                  CALL CGVEDG(NT,P1,P2,IVIS)
                  IF (IVIS .LT. 0) GOTO 370
                  IF (NFACE .EQ. 0) GOTO 360
                  CALL CGVHED( Q(JCG+JXYZ1),IQ(JCG+JFA),IQ(JCG+JPFA),
     +            Q(JCG+ JDFA),IQ(JCG+JTRE),IQ(JCG+JSTA), Q(JCG+JALE),
     +            Q(JCG+JARI))
*           D R A W   E D G E
                  IF (NPART) 370 ,360 ,340
  340             DO 350  I=1,NPART+1
                     IF (I .EQ. 1) T1 = 0.
                     IF (I .NE. 1) T1 = TEND(I-1)
                     IF (I .NE. NPART+1) T2 = TSTRT(I)
                     IF (I .EQ. NPART+1) T2 = 1.
                     IF (T2-T1 .LT. TDEL) GOTO 350
                     AX(1) = XA + T1*XDELT
                     AY(1) = YA + T1*YDELT
                     AX(2) = XA + T2*XDELT
                     AY(2) = YA + T2*YDELT
                     IF(LINFIL.GT.1.AND.IDVIEW.NE.0)THEN
                        LLLINA=LINATT
                        CALL MVBITS(LINCOL,0,8,LINATT,16)
                        CALL GDRAWV(AX,AY,2)
                        LINATT=LLLINA
                     ELSE
                        CALL GDRAWV(AX,AY,2)
                     ENDIF
  350             CONTINUE
                  GOTO 370
*           L I N E   I S   F U L L Y   V I S I B L E
  360             CONTINUE
                  AX(1) = AA(1)
                  AY(1) = AA(2)
                  AX(2) = BB(1)
                  AY(2) = BB(2)
                  IF(LINFIL.GT.1.AND.IDVIEW.NE.0)THEN
                     LLLINA=LINATT
                     CALL MVBITS(LINCOL,0,8,LINATT,16)
                     CALL GDRAWV(AX,AY,2)
                     LINATT=LLLINA
                  ELSE
                     CALL GDRAWV(AX,AY,2)
                  ENDIF
  370             CONTINUE
  380          CONTINUE
  390       CONTINUE
         ENDIF
      ENDIF
***      IOLEP=LEP
***      LEP=11
      IF(LINFIL.NE.0)THEN
         LTY=IBITS(LINATT,10,3)
         CALL MVBITS(6,0,3,LINATT,10)
         CALL GDRAWV(TESTX,TESTY,0)
         CALL MVBITS(LTY,0,3,LINATT,10)
***      LEP=IOLEP
      ENDIF
*SG
  400 RETURN
*
10000    FORMAT('  First word of WIRE less or equal 0 ')
10100    FORMAT(' N. of words of Hidden Structure less or equal 18 ')
*
      END
+SELF.
+DECK,  GD3D3D, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:19  cernlib
* Geant

      SUBROUTINE GD3D3D(XIN,NPOINT,XOUT,INV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to transform the 3D points given by array XIN    *
C.    *       into the 3D points in XOUT:                              *
C.    *       if INV=0 the Z-axis for XOUT is the line of sight for XIN*
C.    *       if INV=1 the Z-axis for XIN is the line of sight for XOUT*
C.    *                                                                *
C.    *    ==>Called by : <USER>, GDCUT                                *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVOLU.
+CDE, GCDRAW.
      DIMENSION XC(3),XOUT(3,1),VL(3),VM(3),VN(3),XIN(3,1)
      SAVE VL,VM,VN
C.
C.    ------------------------------------------------------------------
C.
      IF(NPOINT.EQ.0)GO TO 999
      N=NPOINT
      IF(NPOINT.LT.0)N=-NPOINT
      IF(NGVIEW.NE.0) GO TO 40
C
C             First call compute the rotation matrix
C
      PH     = ABS(MOD(GPHI,360.))
      THET   = ABS(MOD(GTHETA,360.))
      IF(THET.LE.180.)GO TO 10
      PH     = PH + 180.
      THET   = 360. - THET
C
   10 ST     = SIN(THET * 0.017453)
      CT     = COS(THET * 0.017453)
      SP     = SIN(PH * 0.017453)
      CP     = COS(PH * 0.017453)
C
C             VN is new nu axis
C
      VN(1)  = ST * CP
      VN(2)  = ST * SP
      VN(3)  = CT
C
      IF(ABS(VN(2)).GT.0.99999)GO TO 20
C
      VM(1)  = 0.
      VM(2)  = 1.
      VM(3)  = 0.
C
C             Define new lambda axis
C
      CALL CROSS(VM,VN,VL)
      CALL VUNIT(VL,VL,3)
C
C             Define new mu axis
C
      CALL CROSS(VN,VL,VM)
      GO TO 30
C
C             Special case when observer line of sight is along mu:
C             in this case one chooses arbitrarily the vertical axis of
C             plane of projection as the lambda axis and the horizontal
C             as the nu axis
C
   20 VL(1)  = 0.
      VL(2)  = 0.
      VL(3)  = 1.
      VM(1)  = 1.
      VM(2)  = 0.
      VM(3)  = 0.
   30 CONTINUE
C
      NGVIEW=1
C
   40 CONTINUE
C
C             Begin of a normal call (i.e. with NGVIEW=1)
C
      DO 70  I=1,N
C
C             Loop over the points
C
         IF (NPOINT.LT.0) THEN
C
C             NPOINT < 0 : XIN is in general reference system
C
            IF (INV.EQ.1) THEN
               XC(1)=VL(1)*XIN(1,I)+VM(1)*XIN(2,I)+VN(1)*XIN(3,I)
               XC(2)=VL(2)*XIN(1,I)+VM(2)*XIN(2,I)+VN(2)*XIN(3,I)
               XC(3)=VL(3)*XIN(1,I)+VM(3)*XIN(2,I)+VN(3)*XIN(3,I)
            ELSE
               XC(1)=XIN(1,I)*VL(1)+XIN(2,I)*VL(2)+XIN(3,I)*VL(3)
               XC(2)=XIN(1,I)*VM(1)+XIN(2,I)*VM(2)+XIN(3,I)*VM(3)
               XC(3)=XIN(1,I)*VN(1)+XIN(2,I)*VN(2)+XIN(3,I)*VN(3)
            ENDIF
C
            DO 50  J=1,3
               XOUT(J,I)=XC(J)
   50       CONTINUE
C
         ELSE
C
C             NPOINT > 0 : XIN is in volume reference system
C
            CALL GINROT(XIN(1,I),GRMAT(1,NLEVEL),XC)
            DO 60  J=1,3
               XOUT(J,I)=XC(J)+GTRAN(J,NLEVEL)
   60       CONTINUE
C
         ENDIF
C
   70 CONTINUE
C
  999 RETURN
      END
+DECK,  GDAHIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:19  cernlib
* Geant

      SUBROUTINE GDAHIT (X,Y,Z,ISYMB,SIZSYM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw an HIT point at (X,Y,Z)                             *
C.    *                                                                *
C.    *       The hit belongs to track -ITR3D (in common GCDRAW)       *
C.    *       if GDAHIT is called from GDHITS or GDCHIT, otherwise     *
C.    *       it belongs to track ITRA (in common GCKINE)              *
C.    *       if GDAHIT is called directly from user hit routines.     *
C.    *                                                                *
C.    *       The following characters may be chosen :                 *
C.    *          ISYMB = -1   hardware character    (fast),            *
C.    *                =  0   crosses X by TVDRAW   (default),         *
C.    *                       (size = SIZSYM in cm, default = 0.1),    *
C.    *                = 840  characters by HPLSOF                     *
C.    *                   .   according to the table p. 25             *
C.    *                   .   of the HPLOT manual                      *
C.    *                  853  (size = SIZSYM in cm)                    *
C.    *             (844,854  white, black asterisk * in addition).    *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GDCHIT, GDHITS                       *
C.    *       Authors : R.Brun, P.Zanarini   **********                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCKINE.
      CHARACTER*4 LSYMB(10),CHTEXT
      DIMENSION        HITS(3),UU(2),VV(2),JSYMB(10)
      SAVE JSYMB,LSYMB,IFIRST,IOFF
      DATA             JSYMB/  840 ,  841 ,  842 ,  843 ,  844
     +,                        850 ,  851 ,  852 ,  853 ,  854 /
      DATA             LSYMB/'"<0$','"<1$','"<2$','"<3$','"<4$'
     +,                      '">0$','">1$','">2$','">3$','">4$'/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF (IFIRST.EQ.0) THEN
         IFIRST=1
         CALL UCTOH('OFF ',IOFF,4,4)
      ENDIF
C
C            Set IOBJ to HIT
C
      IOBJ=3
C
      HITS(1)= X
      HITS(2)= Y
      HITS(3)= Z
C
C            Find mode of drawing
C
      KSYMB      = ISYMB
      IF (ISYMB.NE.-1)   KSYMB=IUCOMP(ISYMB,JSYMB(1),10)
      IF (KSYMB.GT. 0)   CALL UCTOH(LSYMB(KSYMB),MSYMB,4,4)
      SSYMB=SIZSYM
      IF (SSYMB.EQ.0.)   SSYMB=0.1
C
C            If THRZ option is set on (R-Z projection) and
C            the cut is lateral (vertical or horizontal) then :
C            if ITR3D is not set by GDHITS or GDCHIT
C            then use -ITRA from common /GCKINE/
C            else do not modify ITR3D already set
C
      IF (ITHRZ.NE.IOFF) THEN
         IF (ICUT.EQ.1.OR.ICUT.EQ.2) THEN
            IF (ITR3D.EQ.0) ITR3D=-ITRA
         ENDIF
      ELSE
         ITR3D=0
      ENDIF
C
C            Draw the hit
C
      CALL GDFR3D(HITS,1,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .NE. 0 ) GO TO 999
CM
C
      IF (KSYMB.LT.0) THEN
C
C            ' ' for hardware points, or 'x' for hardware crosses
C
         CALL IPM(1,U,V)
C
      ELSE IF (KSYMB.GT.0) THEN
C
C            soft-characters 840...854 (see above)
C
         V=V-SSYMB*0.5
         CALL UHTOC(MSYMB,4,CHTEXT,4)
         CALL GDRAWT(U,V,CHTEXT,SSYMB,0.,1,0)
C
      ELSE
C
C            default crosses of size SSYMB cm
C
         DP = 0.5 * SSYMB
         UU(1) = U-DP
         UU(2) = U+DP
         VV(1) = V+DP
         VV(2) = V-DP
         CALL GDRAWV(UU,VV,2)
         UU(1) = U+DP
         UU(2) = U-DP
         VV(1) = V+DP
         VV(2) = V-DP
         CALL GDRAWV(UU,VV,2)
C
      ENDIF
C
  999 RETURN
      END
+DECK,  GDARC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:19  cernlib
* Geant

      SUBROUTINE GDARC(R,Z0,PHI1,PHI2)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw an arc, from PHI1 to PHI2,                          *
C.    *       of the circle of radius R centered on Z-axis,            *
C.    *       at a distance of Z0 from the origin,                     *
C.    *       on a plane parallel to X-Y plane                         *
C.    *                                                                *
C.    *    ==>Called by : GDRAWS                                       *
C.    *       Authors : A.McPherson, P.Zanarini   *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCDRAW.
      DIMENSION X(3,45),U(45),V(45)
C.
C.    ------------------------------------------------------------------
C.
      PHIMIN=PHI1
      PHIMAX=PHI2
C
      NP=1
      PH=PHIMIN*DEGRAD
      X(1,1)=R*COS(PH)
      X(2,1)=R*SIN(PH)
      X(3,1)=Z0
C
      IF(ABS(PHIMAX-PHIMIN).LE.9.) GO TO 20
C
      I1=PHIMIN/9.0+2
      I2=PHIMAX/9.0+1
      NAS=I2-I1+1
      IF(NAS.LE.0) NAS=NAS+40
      IC=I1
C
      DO 10 IAS=1,NAS
         IF(IC.GT.40) IC=IC-40
         NP=NP+1
         ICC=IC
         IF (ICC.LE.0) ICC=40+ICC
         X(1,NP)=R*GCOS(ICC)
         X(2,NP)=R*GSIN(ICC)
         X(3,NP)=Z0
         IC=IC+1
   10 CONTINUE
C
   20 CONTINUE
C
      PH=PHIMAX*DEGRAD
      NP=NP+1
      X(1,NP)=R*COS(PH)
      X(2,NP)=R*SIN(PH)
      X(3,NP)=Z0
C
      CALL GDFR3D(X,NP,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .EQ. 0 ) CALL GDRAWV(U,V,NP)
CM
      END
+DECK,  GDARR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDARR(X1,Y1,X2,Y2,SIZE,ITEXT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a segment from (X1,Y1) to (X2,Y2)                   *
C.    *       and an arrow (of size SIZE) at the ending point (X2,Y2)  *
C.    *       together with the one-character text ITEXT               *
C.    *                                                                *
C.    *    ==>Called by : GDAXIS                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION U(3),V(3)
      CHARACTER*(*) ITEXT
      SAVE TGAR
      DATA TGAR/0.6/
C.
C.    ------------------------------------------------------------------
C.
      U(1)=X1
      U(2)=X2
      V(1)=Y1
      V(2)=Y2
      XL=SQRT((X2-X1)**2+(Y2-Y1)**2)
C
C             If axis size is too small, then return without drawing it
C
      IF (XL.LE.0.1) GO TO 999
C
C             Draw the segment
C
      CALL GDRAWV(U,V,2)
C
      FSIN=(Y2-Y1)/XL
      FCOS=(X2-X1)/XL
      U(1)=X1+(XL-SIZE)*FCOS-SIZE*TGAR*FSIN
      U(3)=X1+(XL-SIZE)*FCOS+SIZE*TGAR*FSIN
      V(1)=Y1+(XL-SIZE)*FSIN+SIZE*TGAR*FCOS
      V(3)=Y1+(XL-SIZE)*FSIN-SIZE*TGAR*FCOS
      U(2)=X2
      V(2)=Y2
C
C             Draw the arrow
C
      CALL GDRAWV(U,V,3)
C
      X0=X1+(XL+2*SIZE)*FCOS
      Y0=Y1+(XL+2*SIZE)*FSIN
      ANGLE=0.0
      LWIDTH=1
      IOPT=0
C
C             Draw the text
C
      CALL GDRAWT(X0,Y0,ITEXT,SIZE,ANGLE,LWIDTH,IOPT)
C
  999 RETURN
      END
+DECK,  GDAXIS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDAXIS(X0,Y0,Z0,AXSIZ)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the axis system at a given                          *
C.    *       point (X0,Y0,Z0) with axis of length AXSIZ;              *
C.    *       by this way the user can easily realize                  *
C.    *       wich view is in effect in the picture                    *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC                      *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3,4),U(4),V(4),XL(3)
C
C.
C.    ------------------------------------------------------------------
C.
      DO 10 I=1,4
         X(1,I)=X0
         X(2,I)=Y0
         X(3,I)=Z0
   10 CONTINUE
C
      X(1,2)=X0+AXSIZ
      X(2,3)=Y0+AXSIZ
      X(3,4)=Z0+AXSIZ
      CALL GDFR3D(X,4,U,V)
C
      DO 20 I=1,3
         XL(I)=SQRT((U(I+1)-U(1))**2+(V(I+1)-V(1))**2)
   20 CONTINUE
C
      XLMAX=MAX(XL(1),XL(2))
      XLMAX=MAX(XLMAX,XL(3))
      ARSIZ=XLMAX/7.0
C
      CALL GDARR(U(1),V(1),U(2),V(2),ARSIZ,'<X')
      CALL GDARR(U(1),V(1),U(3),V(3),ARSIZ,'<Y')
      CALL GDARR(U(1),V(1),U(4),V(4),ARSIZ,'<Z')
C
      END
+DECK,  GDBOMB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDBOMB(ICPOIN,ISHAPE)
*
********************************************************************************
*
*  This subroutine allows exploded view of detectors !
*
*  GBOOM > 0 => EXPLOSION
*
*  GBOOM = 0 => RESET
*
*  GBOOM < 0 => IMPLOSION
*
********************************************************************************
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCVOLU.
+CDE, GCGOBJ.
*SG
+CDE, GCMUTR.
+CDE, GCDRAW.
+CDE, GCHILN.
+CDE, GCSPEE.
      DIMENSION RRMIN(3),RRMAX(3)
      SAVE SEXP1, SEXP2, SEXP3
C.    ------------------------------------------------------------------
*
*
      IF(GBOOM.NE.0)THEN
         IF(ISUBLI.EQ.1) THEN
            CALL CGSHIF(SEXP1,SEXP2,SEXP3,Q(ICPOIN))
            ITSTCU=1
         ELSE
            CALL CGMNMX(Q(ICPOIN),RRMIN,RRMAX)
            EXP1=(RRMAX(1)+RRMIN(1))*.5
            EXP2=(RRMAX(2)+RRMIN(2))*.5
            EXP3=(RRMAX(3)+RRMIN(3))*.5
            AEXP1=ABS(EXP1)
            AEXP2=ABS(EXP2)
            AEXP3=ABS(EXP3)
            AA1=MAX(ABS(RRMAX(1)),ABS(RRMIN(1)))
            AA2=MAX(ABS(RRMAX(2)),ABS(RRMIN(2)))
            AA3=MAX(ABS(RRMAX(3)),ABS(RRMIN(3)))
            IF((AEXP1/AA1).LE.0.05.AND.(AEXP2/AA2).LE.0.05.AND.
     +                 (AEXP3/AA3).LE.0.05)THEN
               ITSTCU=0
               IF(IPORLI.EQ.1)LPASS=1
            ELSE
               ITSTCU=1
               IF(ISHAPE.EQ.11.OR.ISHAPE.EQ.12)LPASS=1
               SEXP1=GBOOM*EXP1
               SEXP2=GBOOM*EXP2
               SEXP3=GBOOM*EXP3
               CALL CGSHIF(SEXP1,SEXP2,SEXP3,Q(ICPOIN))
            ENDIF
         ENDIF
      ENDIF
*
 999  END

+DECK,  GDCGCL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDCGCL(ISHAPE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This Subroutine allows the clipping of a CG object       *
C.    *       built with the Hidden Line Removal by means of any       *
C.    *       kind of shape (moreover it's possible to clip the        *
C.    *       same object more than once and by different shapes)      *
C.    *       defined by 'MCVOL' Command.                              *
C.    *                                                                *
C.    *    ==>Called by :  GDCGHI                                      *
C.    *                                                                *
C.    *       Authors :  J.Salt ; S.Giani     *********                *
C.    *                                                                *
C.    ******************************************************************
C
+CDE, GCBANK.
+CDE, GCGOBJ.
+CDE, GCHILN.
+CDE, GCSPEE.
+CDE, GCMUTR.
*
      DIMENSION VMIN(3),VMAX(3)
*
*
*     Volume substraction. The algorithm is the following :
*
*     Check if the Clipping volume is inside Volume 'I' (First Check)
*
*      a) If Yes , Volume 'I' is Seen (IVFUN=1)
*      b) If Not , Check the following 3 cases (Second Check):
*
*          1) C. Vol. intersects volume 'I', but the volume does not include it
*              (IVFUN=2).
*          2) Volume 'I' is inside C. Vol., Then Volume is Unseen (IVFUN=0)
*          3) Volume 'I' is outside C. Vol., Then Volume is Seen (IVFUN=1)
*
*SG
      IA=JCGOBJ+1
      IB=JCGOBJ+8000
*SG
      CALL CGMNMX(Q(IA),VMIN,VMAX)
*
*      First Check
*
***SG
*
      IF(NAIN.EQ.1)THEN
        ISUB=JCGOBJ+20000
        IF(ISHAPE.EQ.29.OR.ISHAPE.EQ.99)THEN
          CALL CGCOPY(Q(IB),8000,Q(ISUB))
        ELSE
          CALL CGCOPY(Q(IA),8000,Q(ISUB))
        ENDIF
        RETURN
      ENDIF
*
*      Do it for all the volumes cutting 'I'
*
      DO 11 IJ=1,JJJ
      DO 10 K=1,3
         IF(VMIN(K).LE.BMIN(K+3*IJ-3).AND.BMIN(K+3*IJ-3).LE.VMAX(K).AND.
     +VMIN(K).LE.BMAX(K+3*IJ-3).AND.BMAX(K+3*IJ-3).LE.VMAX(K))THEN
***SG
            GOTO 10
         ELSE
            GOTO 20
         ENDIF
   10 CONTINUE
      IVFUN=1
      GOTO 50
*
*      C. Vol. is not inside 'I'  Volume. Second Check:
***SG
*
   20 IKON=0
      IDISJ=0
      DO 30 J=1,3
******         IDISJ=0
*      Do it for all the volumes cutting 'I'
*
         IF(BMIN(J+3*IJ-3).LE.VMIN(J).AND.VMIN(J).LE.BMAX(J+3*IJ-3))THEN
            IKON=IKON+1
         ELSE
            IDISJ=IDISJ+1
         ENDIF
         IF(BMIN(J+3*IJ-3).LE.VMAX(J).AND.VMAX(J).LE.BMAX(J+3*IJ-3))THEN
***SG
            IKON=IKON+1
         ELSE
            IDISJ=IDISJ+1
         ENDIF
         IF(IDISJ.EQ.6)GOTO 40
   30 CONTINUE
   40 IF(IDISJ.EQ.6)THEN
         IVFUN=1
      ELSE
         IF(IKON.EQ.6)THEN
          IF(ICUBE.EQ.JJJ)THEN
**            IVFUN=0
             IVFUN=2
          ELSE
            IVFUN=2
          ENDIF
         ELSE
            IVFUN=2
         ENDIF
      ENDIF
   50 CONTINUE
**      IF(IVFUN.EQ.0)GOTO 11
*
*****SG
*
*    Multiple clipping: you can clip, as a sequence, the same
*    volume by two different shapes
*
      IF(JJJ.EQ.2)THEN
        ISUB1=JCGOBJ+12000
        ISUB =JCGOBJ+20000
        IF(IJ.EQ.1)THEN
         IF(ISHAPE.EQ.29.OR.ISHAPE.EQ.99)THEN
           IF(IVFUN.EQ.2) CALL CGSUB(Q(IB),Q(ICLIP1),8000,Q(ISUB1))
           IF(IVFUN.EQ.1) CALL CGCOPY(Q(IB),8000,Q(ISUB1))
         ELSE
           IF(IVFUN.EQ.2) CALL CGSUB(Q(IA),Q(ICLIP1),8000,Q(ISUB1))
           IF(IVFUN.EQ.1) CALL CGCOPY(Q(IA),8000,Q(ISUB1))
         ENDIF
        ENDIF
        IF(IJ.EQ.2)THEN
          IF(IVFUN.EQ.2) CALL CGSUB(Q(ISUB1),Q(ICLIP2),8000,Q(ISUB))
          IF(IVFUN.EQ.1) CALL CGCOPY(Q(ISUB1),8000,Q(ISUB))
        ENDIF
      ELSE
        ISUB=JCGOBJ+20000
        IF(ISHAPE.EQ.29.OR.ISHAPE.EQ.99)THEN
          IF(IVFUN.EQ.2) CALL CGSUB(Q(IB),Q(ICLIP1),8000,Q(ISUB))
          IF(IVFUN.EQ.1) CALL CGCOPY(Q(IB),8000,Q(ISUB))
        ELSE
          IF(IVFUN.EQ.2) CALL CGSUB(Q(IA),Q(ICLIP1),8000,Q(ISUB))
          IF(IVFUN.EQ.1) CALL CGCOPY(Q(IA),8000,Q(ISUB))
        ENDIF
      ENDIF
   11 CONTINUE
*
*****SG
*
      END
+DECK,  GDCGEM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDCGEM(VRPX,VRPY,VRPZ,VUPX,VUPY,VUPZ,VPNX, VPNY,VPNZ,
     +IERR,AMTR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *  This subroutine evaluates the Viewing Matrix with the same    *
C.    *  algorithm and with the same input parameters as subroutine    *
C.    *  GEVVM of GKS3D.                                               *
C.    *                                                                *
C.    *  Input Parameters:                                             *
C.    *                                                                *
c.    *       VRPX,VRPY,VRPZ,VUPX,VUPY,VUPZ,VPNX, VPNY,VPNZ            *
C.    *                                                                *
C.    *  Output Parameters:                                            *
C.    *                                                                *
C.    *       IERR,AMTR(4,4)                                           *
C.    *                                                                *
C.    *                                                                *
C.    *       Called by :  GDCGVW                                      *
C.    *                                                                *
C.    *       Author : J.Salt     *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
*
      DIMENSION VRPT(3),VUPT(3),VPNT(3)
      DIMENSION AMTR(4,4)
*
      IERR=0
      VRPT(1)=VRPX
      VRPT(2)=VRPY
      VRPT(3)=VRPZ
      VUPT(1)=VUPX
      VUPT(2)=VUPY
      VUPT(3)=VUPZ
      VPNT(1)=VPNX
      VPNT(2)=VPNY
      VPNT(3)=VPNZ
*
      VLEN=SQRT(VPNT(1)**2+VPNT(2)**2+VPNT(3)**2)
      AMTR(3,1)=VPNT(1)/VLEN
      AMTR(3,2)=VPNT(2)/VLEN
      AMTR(3,3)=VPNT(3)/VLEN
*
*    First Row (U-axis)  := Unit Vector Perpendicular to VUP and VPN
*
      UX=VUPT(2)*VPNT(3)-VUPT(3)*VPNT(2)
      UY=VUPT(3)*VPNT(1)-VUPT(1)*VPNT(3)
      UZ=VUPT(1)*VPNT(2)-VUPT(2)*VPNT(1)
      ULEN=SQRT(UX**2+UY**2+UZ**2)
*
*     LENGTH=0. <=> VUP and VPN are collinear
*
      IF(ULEN.EQ.0)THEN
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
      ELSE
         AMTR(1,1)=UX/ULEN
         AMTR(1,2)=UY/ULEN
         AMTR(1,3)=UZ/ULEN
      ENDIF
*
*       2ND ROW(V-AXIS)  := UNIT VECTOR PERPENDICULAR TO U- AND N-AXIS
*
      AMTR(2,1)=AMTR(3,2)*AMTR(1,3)-AMTR(1,2)*AMTR(3,3)
      AMTR(2,2)=AMTR(3,3)*AMTR(1,1)-AMTR(1,3)*AMTR(3,1)
      AMTR(2,3)=AMTR(3,1)*AMTR(1,2)-AMTR(1,1)*AMTR(3,2)
*
*      4TH COLUMN : = TRANSLATION FACTORS
*
      AMTR(1,4)=-(VRPT(1)*AMTR(1,1)+VRPT(2)*AMTR(1,2)+ VRPT(3)*
     +AMTR(1,3))
      AMTR(2,4)=-(VRPT(1)*AMTR(2,1)+VRPT(2)*AMTR(2,2)+ VRPT(3)*
     +AMTR(2,3))
      AMTR(3,4)=-(VRPT(1)*AMTR(3,1)+VRPT(2)*AMTR(3,2)+ VRPT(3)*
     +AMTR(3,3))
*
*      4TH ROW
*
      AMTR(4,1)=0.
      AMTR(4,2)=0.
      AMTR(4,3)=0.
      AMTR(4,4)=0.
*
10000 FORMAT(' **** VUP and VPN are collinear  ****')
*
      END
+DECK,  GDCGER, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDCGER(CGERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    This subroutine returns Error Message in the CG-Object      *
C.    *    according to the value of CGERR.                            *
C.    *                                                                *
C.    *    Input Parameter:                                            *
C.    *                                                                *
C.    *        CGERR:  First word of the CG array                      *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by :   GDCGCL,GDCGOB                              *
C.    *                                                                *
C.    *       Author : J. Salt   **********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
+CDE, GCGOBJ.
*
      IF(CGERR.LT.-0.0001)THEN
         KCGST=-2
         WRITE(CHMAIL,10000)
      ELSE
         KCGST=-3
         WRITE(CHMAIL,10100)
      ENDIF
      CALL GMAIL(0,0)
*
10000 FORMAT(' Error in CG, Lack of Memory  ')
10100 FORMAT(' Error in CG, Wrong Shape Parameters  ')
*
      END

+DECK,  GDCGHI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDCGHI(IMOD,NOBJ,NWWS,LSTEP,ISG,NTVOL,ISHAPE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This routine allows :                                    *
C.    *                                                                *
C.    *          - Slicing by a plane if some cut has been set,        *
C.    *          - Clipping by any kind of volume if one or more       *
C.    *            clipping volumes have been defined                  *
C.    *          - to Insert the CG Objects into the Hidden Structure  *
C.    *          - to convert the CG Objects in Wire Objects           *
C.    *                                                                *
C.    *       Input Parameters:                                        *
C.    *                                                                *
C.    *          IMOD:  Number for indicating the task to be perfor-   *
C.    *                 med.  See GDCGOB subroutine                    *
C.    *          NOBJ:  Counter for CG objects                         *
C.    *          NWWS:  Size of Wire Structure                         *
C.    *          LSTEP:  N. of bodies forming each CG volume           *
C.    *          ISG  :  i-th body forming a Pcon or Pgon              *
C.    *          NTVOL: N. of bodies forming each Pcon or Pgon         *
C.    *          ISHAPE:Shape of CG object                             *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GDCGOB                                       *
C.    *                                                                *
C.    *       Authors :  J.Salt, S.Giani                               *
C.    ******************************************************************
C.
*
+CDE, GCBANK.
+CDE, GCGOBJ.
+CDE, GCUNIT.
+CDE, GCHILN.
+CDE, GCSPEE.
+CDE, GCMUTR.
      SAVE NFIRST, NSHA, IOLDNS
      DATA NFIRST/1/
      DATA NSHA/0/
      DATA IOLDNS/0/
*
*   Slicing or clipping Actions
*
      LLEP=ABS(LEP)
      IVFUN=1
      LENGHT=4000
      ICPOIN=JCGOBJ+1
      IZPOIN=JCGOBJ+20000
      IF(ISHAPE.EQ.11.OR.ISHAPE.EQ.12)ICGP=ICGP+1
*
      IF(IMOD.EQ.3)THEN
         IST=2
      ELSE IF(IMOD.EQ.4)THEN
         IST=3
         CALL CGSLIC(Q(ICPOIN),ABCD,LENGHT,Q(IZPOIN))
**SG
      ELSE IF(IMOD.EQ.5)THEN
         IST=3
*  Clip object
         CALL GDCGCL(ISHAPE)
**SG
      ELSE
         WRITE(CHMAIL,10000)IMOD
         CALL GMAIL(0,0)
      ENDIF
*
**      IF(IVFUN.EQ.0)GOTO 999
*
***SG
*      Inserting CG object in the Hidden Structure
*
      IHPOIN=JCG+1
      ICPOIN=JCGOBJ+1
      ISPOIN=JCGOBJ+8000
      IZPOIN=JCGOBJ+20000
      IF(ISHAPE.EQ.29.OR.ISHAPE.EQ.99)ICPOIN=ISPOIN
      IF(IMOD.EQ.4.OR.IMOD.EQ.5)ICPOIN=IZPOIN
*
*   Evaluate size of Hide Structure after all volumes
*   If it's too big, go back to GDRAW
*   If it's ok, build the Wire Structure
*
      CALL CGHINS(Q(ICPOIN),Q(IHPOIN),ISHAPE)
      IF(KCGST.EQ.-8)THEN
         IF(NFIRST.EQ.1)THEN
           NFIRST=0
           WRITE(CHMAIL,10002)
           CALL GMAIL(0,0)
         ENDIF
         NNN=NOBJ+1
         IF(ISHAPE.EQ.11.OR.ISHAPE.EQ.12)THEN
           IF(ISG.EQ.NTVOL)NNN=NNN+LSTEP-1
         ENDIF
         IF(NNN.EQ.NCLAS2)THEN
           KCGST=-9
           NFIRST=1
         ENDIF
         GOTO 999
      ENDIF
*
*      Building Up the Wiring structure.
*
      ILCG=ILCG+1
      IST=ILCG
      IF(IST.GE.IQ(JCOUNT-1))THEN
        WRITE(CHMAIL,10001)
        CALL GMAIL(0,0)
        GOTO 999
      ENDIF
      IF(LLEP.NE.1)THEN
       IQ(IMCOUN+IST)=IQ(IMCOUN+IST-1)+NSHA
      ENDIF
      IQ(JCOUNT+IST)=IQ(JCOUNT+IST-1)+NTCUR
      IF(IFCG.EQ.4.AND.ILCG.EQ.4)THEN
        IQ(JCOUNT+4)=IQ(JCOUNT+4)-8000+1
        IF(LLEP.NE.1)THEN
         IQ(IMCOUN+4)=IQ(IMCOUN+4)-8000+1
        ENDIF
      ENDIF
      IF(IFCG.EQ.3.AND.ILCG.EQ.3)THEN
        IQ(JCOUNT+3)=IQ(JCOUNT+3)-4000+1
        IF(LLEP.NE.1)THEN
         IQ(IMCOUN+3)=IQ(IMCOUN+3)-4000+1
        ENDIF
      ENDIF
      IF(LLEP.NE.1)THEN
       MMPOIN=IMPOIN+IQ(IMCOUN+IST)
      ENDIF
      IWPOIN=JCG+IQ(JCOUNT+IST)
      ICPOIN=JCGOBJ+1
      IF(ISHAPE.EQ.29.OR.ISHAPE.EQ.99) ICPOIN=JCGOBJ+8000
      IF(IMOD.EQ.4.OR.IMOD.EQ.5) ICPOIN=JCGOBJ+20000
*
*    Evaluate size of Wire structure after all volumes
*    If it's too big, go back to GDRAW
*    If it's ok, go on.
*
      IF(LLEP.NE.1)THEN
      CALL CGWIRE(Q(ICPOIN),NTRCG,-1,NWWS,Q(IWPOIN),ISHAPE,IQ(MMPOIN))
      ELSE
      CALL CGWIRE(Q(ICPOIN),NTRCG,-1,NWWS,Q(IWPOIN),ISHAPE,0)
      ENDIF
      IF(KCGST.EQ.-8)THEN
         IF(NFIRST.EQ.1)THEN
           NFIRST=0
           WRITE(CHMAIL,10002)
           CALL GMAIL(0,0)
         ENDIF
        NNN=NOBJ+1
        IF(ISHAPE.EQ.11.OR.ISHAPE.EQ.12)THEN
           IF(ISG.EQ.NTVOL)NNN=NNN+LSTEP-1
        ENDIF
        IF(NNN.EQ.NCLAS2)THEN
          KCGST=-10
          NFIRST=1
        ENDIF
        NTCUR=0
        GOTO 999
      ENDIF
      ITSTCU=Q(IWPOIN)
      IF(LLEP.NE.1)NSHACU=IQ(MMPOIN)
      IF(ITSTCU.NE.0)THEN
       IOLDCU=ITSTCU
       IF(LLEP.NE.1)IOLDNS=NSHACU
      ENDIF
      NTCUR=Q(IWPOIN)
      IF(LLEP.NE.1)NSHA=IQ(MMPOIN)
      NFILT=NFILT+NTCUR
      IF(LLEP.NE.1)NTNEX=NTNEX+NSHA
      IF(NTCUR.EQ.0)THEN
        NTCUR=IOLDCU
        IF(LLEP.NE.1)NSHA=IOLDNS
        IF(IFCG.EQ.4.AND.ILCG.EQ.4)THEN
          IQ(JCOUNT+4)=IQ(JCOUNT+4)-8000+1
          IF(LLEP.NE.1)THEN
           IQ(IMCOUN+4)=IQ(IMCOUN+4)-8000+1
          ENDIF
        ENDIF
        IF(IFCG.EQ.3.AND.ILCG.EQ.3)THEN
          IQ(JCOUNT+3)=IQ(JCOUNT+3)-4000+1
          IF(LLEP.NE.1)THEN
           IQ(IMCOUN+3)=IQ(IMCOUN+3)-4000+1
          ENDIF
        ENDIF
        ILCG=ILCG-1
        ICGP=ICGP-1
      ENDIF
***SG
10000    FORMAT('  IMOD  = ',I5,' is not defined  ')
10001    FORMAT(' *** GDCGHI *** : Please, increase size of',
     +          ' the Zebra store; the drawing',
     +          ' will not be completed.')
10002    FORMAT(' *** GDCGHI *** : The memory size is not enough;',
     +          ' the program is going on evaluating the number of',
     +          ' words missing.')
*
  999 END
+DECK,  GDCGOB, T=FORT.
* Revision 1.2  1996/02/27 10:02:05  ravndal
* Drawing of PCON's optimized for 'HIDE ON'
* Revision 1.1.1.1  1995/10/24 10:20:20  cernlib
* Geant

      SUBROUTINE GDCGOB(ITASK,ISHAPE,PAR,NOBJ,NWWS,IVOLNA,
     +LSTEP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Make the CG-Object with shape ISHAPE of parameters PAR   *
C.    *       with the same logic as GDRAWS. 1992                      *
C.    *                                                                *
C.    *     Input Parameters :                                         *
C.    *                                                                *
C.    *     ITASK:   Number for indicating the task to be performed    *
C.    *                                                                *
C.    *                                                                *
C.    *           = 0      Counting task                               *
C.    *           = 1      Slicing + Counting                          *
C.    *           = 2      Clipping + Counting                         *
C.    *           = 3      Insert into the H.S. + Convert to Wire      *
C.    *           = 4      Slicing + Insert into the H.S. + Convert    *
C.    *                    to Wire                                     *
C.    *           = 5      Clipping + Insert into the H.S. + Convert   *
C.    *                    to Wire                                     *
C.    *                                                                *
C.    * SHAPE     SHAPE    SHAPE                                       *
C.    * NUMBER    TYPE     PARAMETERS                                  *
C.    * -------------------------------------------------------------- *
C.    *                                                                *
C.    *   1       BOX      DX,DY,DZ                                    *
C.    *   2       TRD1     DX1,DX2,DY,DZ                               *
C.    *   3       TRD2     DX1,DX2,DY1,DY2,DZ                          *
C.    *   4       TRAP     DZ,TX,TY,H1,BL1,TL1,TTH1,H2,BL2,TL2,TTH2    *
C.    *                                                                *
C.    *   5       TUBE     RMIN,RMAX,DZ                                *
C.    *   6       TUBS     RMIN,RMAX,DZ,PHIMIN,PHIMAX                  *
C.    *   7       CONE     DZ,RMIN1,RMAX1,RMIN2,RMAX2                  *
C.    *   8       CONS     DZ,RMIN1,RMAX1,RMIN2,RMAX2,PHIMIN,PHIMAX    *
C.    *                                                                *
C.    *   9       SPHE     RMIN,RMAX,THEMIN,THEMAX,PHIMIN,PHIMAX       *
C.    *                                                                *
C.    *  10       PARA     DX,DY,DZ,TXY,TXZ,TYZ                        *
C.    *  11       PGON     PHIMIN,DPHI,NDIV,NZ,Z(1),RMIN(1),RMAX(1),...*
C.    *  12       PCON     PHIMIN,DPHI,NZ,Z(1),RMIN(1),RMAX(1),Z(2),...*
C.    *                                                                *
C.    * NOBJ = Counter of cg objects                                   *
C.    * NWWS = Size of Wire structure                                  *
C.    * IVOLNA = Name of volume                                        *
C.    * LSTEP = Number of CG objects forming each volume                *
C.    *                                                                *
C.    *    ==>Called by : GDRAW                                        *
C.    *       Author : P.Zanarini, J.Salt, S.Giani *********           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCVOLU.
+CDE, GCGOBJ.
+CDE, GCMUTR.
+CDE, GCDRAW.
+CDE, GCHILN.
+CDE, GCSPEE.
+CDE, GCONSP.
      SAVE NWPROD
      COMMON /QUEST/IQUEST(100)
      DIMENSION PAR(50),P(3,8)
*SG
      DIMENSION RRMIN(3),RRMAX(3)
      DIMENSION SLI1(4),SLI2(4),SPI1(4),SPI2(4)
*SG
      DIMENSION XZ(2,4),ZR(18),RMIR(18),RMAR(18),AMIRMA(18),AMARMA(18)
      DIMENSION T(4,3)
C.    ------------------------------------------------------------------
C.
**SG
      CALL UCTOH('PERS',IPERS,4,4)
      T(4,1)=0.
      T(4,2)=0.
      T(4,3)=0.
      LINSTY=IBITS(LINATT,10,3)
      IF(LINSTY.EQ.7)THEN
         APPROS=30.
      ELSE
         APPROS=15.
      ENDIF
      IF(ISUBLI.LT.IOLDSU)THEN
         PORGX=0
         PORGY=0
         PORGZ=0
         DO 10  J=1,15
            POX(J)=0
            POY(J)=0
            POZ(J)=0
   10    CONTINUE
      ENDIF
      IOLDSU=ISUBLI
*
*       LHC flag 'ON' (default)
*
*      CALL UCTOH('ON  ',LHIF,4,4)
*      IF(LEP.EQ.LHIF)THEN
*         VITE=1
*      ELSE
*         VITE=0
*      ENDIF
*
* Flag for GDCGHI resetted for each CG object
      ISG=0
      ICGP=0
      LINFIL=IBITS(LINATT,13,3)
**SG
      IVCLOS=0
      IVFUN=1
      IWORK=ITASK
      CALL UCTOH('ON  ',IFLH,4,4)
*JS
      IF (ISHAPE.EQ.1) THEN
C
C             BOX
C
         DX1=PAR(1)
         DY1=PAR(2)
         DX2=DX1
         DY2=DY1
         DZ=PAR(3)
         GO TO 20
C
      ELSEIF (ISHAPE.EQ.2) THEN
C
C             TRD1
C
         DX1=PAR(1)
         DX2=PAR(2)
         DY1=PAR(3)
         DY2=DY1
         DZ=PAR(4)
         GO TO 20
C
      ELSEIF (ISHAPE.EQ.3) THEN
C
C             TRD2
C
         DX1=PAR(1)
         DX2=PAR(2)
         DY1=PAR(3)
         DY2=PAR(4)
         DZ=PAR(5)
         GO TO 20
C
      ELSEIF (ISHAPE.EQ.4) THEN
C
C             TRAP
C
         DZ=PAR(1)
         TX=PAR(2)
         TY=PAR(3)
         H1=PAR(4)
         BL1=PAR(5)
         TL1=PAR(6)
         TTH1=PAR(7)
         H2=PAR(8)
         BL2=PAR(9)
         TL2=PAR(10)
         TTH2=PAR(11)
         GO TO 30
C
      ELSEIF (ISHAPE.EQ.5) THEN
C
C             TUBE
C
         AFINV=1./COS(PI/APPROS)
         FINV=ABS(AFINV)
         RMIN1=PAR(1)*FINV
         RMAX1=PAR(2)*FINV
         RMIN2=RMIN1
         RMAX2=RMAX1
         Z2=PAR(3)
*         Z1=-Z2
         PHIMIN=0.
         PHIMAX=360.
         IF((LINFIL.EQ.2.OR.LINFIL.EQ.3)
     +   .AND.RMIN1.NE.0)PHIMIN=5.
*SG
         ANG1=PHIMIN
         ANG2=PHIMAX
         AANG=ABS(ANG2-ANG1)
         AZLAT=AANG*APPROS
         ZLAT=AZLAT/360
         NANG=ZLAT
         IF(NANG.EQ.0)NANG=1
         AZ=ZLAT-NANG
         IF(AZ.GT..5)NANG=NANG+1
*SG
         GO TO 70
C
      ELSEIF (ISHAPE.EQ.6.OR.ISHAPE.EQ.29) THEN
C
C             TUBS
C
         AFINV=1./COS(PI/APPROS)
         FINV=ABS(AFINV)
         RMIN1=PAR(1)*FINV
         RMAX1=PAR(2)*FINV
         RMIN2=RMIN1
         RMAX2=RMAX1
         AZ2=PAR(3)
         Z2=ABS(AZ2)
*         Z1=-Z2
         PHIMIN=PAR(4)
         PHIMAX=PAR(5)
**SG
         ANG1=PHIMIN
         ANG2=PHIMAX
         AANG=ABS(ANG2-ANG1)
         AZLAT=AANG*APPROS
         ZLAT=AZLAT/360
         NANG=ZLAT
         IF(NANG.EQ.0)NANG=1
         AZ=ZLAT-NANG
         IF(AZ.GT..5)NANG=NANG+1
         IF(ISHAPE.EQ.29)NANG=APPROS
**SG
         GO TO 70
C
      ELSEIF (ISHAPE.EQ.7) THEN
C
C             CONE
C
         AFINV=1./COS(PI/APPROS)
         FINV=ABS(AFINV)
         RMIN1=PAR(2)*FINV
         RMAX1=PAR(3)*FINV
         RMIN2=PAR(4)*FINV
         RMAX2=PAR(5)*FINV
         Z2=PAR(1)
*         Z1=-Z2
         PHIMIN=0.
         PHIMAX=360.
         IF((LINFIL.EQ.2.OR.LINFIL.EQ.3).AND.RMIN2.NE.0)PHIMIN=5.
*SG
         ANG1=PHIMIN
         ANG2=PHIMAX
         AANG=ABS(ANG2-ANG1)
         AZLAT=AANG*APPROS
         ZLAT=AZLAT/360
         NANG=ZLAT
         IF(NANG.EQ.0)NANG=1
         AZ=ZLAT-NANG
         IF(AZ.GT..5)NANG=NANG+1
*SG
         GO TO 70
C
      ELSEIF (ISHAPE.EQ.8) THEN
C
C             CONS
C
         AFINV=1./COS(PI/APPROS)
         FINV=ABS(AFINV)
         RMIN1=PAR(2)*FINV
         RMAX1=PAR(3)*FINV
         RMIN2=PAR(4)*FINV
         RMAX2=PAR(5)*FINV
         Z2=PAR(1)
*         Z1=-Z2
         PHIMIN=PAR(6)
         PHIMAX=PAR(7)
**SG
         ANG1=PHIMIN
         ANG2=PHIMAX+.1
         AANG=ABS(ANG2-ANG1)
         AZLAT=AANG*APPROS
         ZLAT=AZLAT/360
         NANG=ZLAT
         IF(NANG.EQ.0)NANG=1
         AZ=ZLAT-NANG
         IF(AZ.GT..5)NANG=NANG+1
**SG
         GO TO 70
C
      ELSEIF (ISHAPE.EQ.9) THEN
C
C             SPHE
C
*         RMIN=PAR(1)
         RMAX=PAR(2)
         GO TO 120
C
      ELSEIF (ISHAPE.EQ.10) THEN
C
C             PARA
C
         DX=PAR(1)
         DY=PAR(2)
         DZ=PAR(3)
         TXY=PAR(4)
         TXZ=PAR(5)
         TYZ=PAR(6)
C
         TX=TXZ
         TY=TYZ
         H1=DY
         BL1=DX
         TL1=DX
         TTH1=TXY
         H2=DY
         BL2=DX
         TL2=DX
         TTH2=TXY
         GO TO 30
C
      ELSEIF (ISHAPE.EQ.11) THEN
C
C             PGON
C
         PHIMIN=PAR(1)
         IF((LINFIL.EQ.2.OR.LINFIL.EQ.3).AND.PAR(2).GT.359.)PAR(2)=359.
         PHIMAX=PHIMIN+PAR(2)
         NDIVAN=PAR(3)
         NZ=PAR(4)
C
C             Z(1)=PAR(5) - RMIN(1)=PAR(6) - RMAX(1)=PAR(7) - Z(2)=PAR(8
C
         GO TO 150
C
      ELSEIF (ISHAPE.EQ.12) THEN
C
C             PCON
C
         PHIMIN=PAR(1)
         IF((LINFIL.EQ.2.OR.LINFIL.EQ.3).AND.PAR(2).GT.359.)PAR(2)=359.
         PHIMAX=PHIMIN+PAR(2)
         NZ=PAR(3)
C
C             Z(1)=PAR(4) - RMIN(1)=PAR(5) - RMAX(1)=PAR(6) - Z(2)=PAR(7
C
         GO TO 230
      ELSE
         GO TO 999
      ENDIF
C
*      GO TO 150
C
   20 CONTINUE
C
C             Rectilinear shapes: BOX,TRD1,TRD2
C
      X1=0.
      Y1=0.
      X2=0.
      Y2=0.
      IF(DZ.LT.0.001)DZ=0.001
      Z1=-DZ
      Z2=DZ
C
C             Calculate the 8 vertex for rectilinear shapes
C
      IF(DX1.EQ.0.)DX1=0.0001
      IF(DY1.EQ.0.)DY1=0.0001
      IF(DX2.EQ.0.)DX2=0.0001
      IF(DY2.EQ.0.)DY2=0.0001
      P(1,1)=X1+DX1
      P(2,1)=Y1+DY1
      P(3,1)=Z1
      P(1,2)=X1-DX1
      P(2,2)=Y1+DY1
      P(3,2)=Z1
      P(1,3)=X1-DX1
      P(2,3)=Y1-DY1
      P(3,3)=Z1
      P(1,4)=X1+DX1
      P(2,4)=Y1-DY1
      P(3,4)=Z1
      P(1,5)=X2+DX2
      P(2,5)=Y2+DY2
      P(3,5)=Z2
      P(1,6)=X2-DX2
      P(2,6)=Y2+DY2
      P(3,6)=Z2
      P(1,7)=X2-DX2
      P(2,7)=Y2-DY2
      P(3,7)=Z2
      P(1,8)=X2+DX2
      P(2,8)=Y2-DY2
      P(3,8)=Z2
*
      GOTO 40
C
   30 CONTINUE
C
C             TRAP,PARA
C
C             Calculate the 8 vertex
C
      P(1,1)=-DZ*TX+TTH1*H1+TL1
      P(2,1)=+H1-DZ*TY
      P(3,1)=-DZ
      P(1,2)=-DZ*TX+TTH1*H1-TL1
      P(2,2)=+H1-DZ*TY
      P(3,2)=-DZ
      P(1,3)=-DZ*TX-TTH1*H1-BL1
      P(2,3)=-H1-DZ*TY
      P(3,3)=-DZ
      P(1,4)=-DZ*TX-TTH1*H1+BL1
      P(2,4)=-H1-DZ*TY
      P(3,4)=-DZ
      P(1,5)=+DZ*TX+TTH2*H2+TL2
      P(2,5)=+H2+DZ*TY
      P(3,5)=+DZ
      P(1,6)=+DZ*TX+TTH2*H2-TL2
      P(2,6)=+H2+DZ*TY
      P(3,6)=+DZ
      P(1,7)=+DZ*TX-TTH2*H2-BL2
      P(2,7)=-H2+DZ*TY
      P(3,7)=+DZ
      P(1,8)=+DZ*TX-TTH2*H2+BL2
      P(2,8)=-H2+DZ*TY
      P(3,8)=+DZ
C
   40 CONTINUE
C
C       BOX,TRD1,TRD2,TRAP,PARA --->>  call CGBOX
C
      IVCLOS=1
*SG
*  Size evaluation
*
      IF(IWORK.LE.2.AND.IVFUN.NE.0)THEN
*  NWB = n. words for each box
         NCGVOL=NCGVOL+NWB
         GOTO 999
      ENDIF
      ICPOIN=JCGOBJ+1
*   Creating object
*SG
      RMIN1=0
      RMIN2=0
      RMAX1=0
      RMAX2=0
      CALL CGBOX(P,4,4,300,Q(ICPOIN))
      DO 50  J=1,3
         T(J,1)=GRMAT(3*J-2,NLEVEL)
         T(J,2)=GRMAT(3*J-1,NLEVEL)
         T(J,3)=GRMAT(3*J,NLEVEL)
   50 CONTINUE
      CALL CGRIFL(T,Q(ICPOIN))
      CGERR=Q(ICPOIN)
      IF(CGERR.LE.0)THEN
         CALL GDCGER(CGERR)
         IF(KCGST.EQ.-2) GOTO 999
         IF(KCGST.EQ.-3) THEN
            KCGST=0
            WRITE(CHMAIL,10000)ISHAPE,NAMES(NLEVEL)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
      ENDIF
      CALL CGCEV(1,Q(ICPOIN))
      DO 60  J=1,3
         T(J,1)=GRMAT(3*J-2,NLEVEL)
         T(J,2)=GRMAT(3*J-1,NLEVEL)
         T(J,3)=GRMAT(3*J,NLEVEL)
   60 CONTINUE
      CALL CGAFFI(T,Q(ICPOIN))
      XV=GTRAN(1,NLEVEL)
      YV=GTRAN(2,NLEVEL)
      ZV=GTRAN(3,NLEVEL)
      CALL CGSHIF(XV,YV,ZV,Q(ICPOIN))
***SG
*    Shifting object
      IF(KSHIFT.GT.0)THEN
         CALL GDSHIF(IVOLNA,ICPOIN)
      ENDIF
*
      IF(GBOOM.NE.0)THEN
         CALL GDBOMB(ICPOIN,ISHAPE)
         IF(ITSTCU.EQ.0)GOTO 999
      ENDIF
*
*
*
*   Hidden Volume Removal:
*   Computing volumes visibility and skipping
*   the unvisible ones; a great increase in speed
*   and a great reduction in n. of words used can be
*   obtained in this way.
*
      CALL CGMNMX(Q(ICPOIN),RRMIN,RRMAX)
      IF(ISUBLI.EQ.1)THEN
         AA1=RRMIN(1)-S1
         AA2=RRMIN(2)-S2
         AA3=RRMIN(3)-S3
         BB1=RRMAX(1)-SS1
         BB2=RRMAX(2)-SS2
         BB3=RRMAX(3)-SS3
         IF(AA1.GT.0.001.AND.AA2.GT.0.001.AND.AA3.GT.0.001.AND. BB1.LT.
     +   0.001.AND.BB2.LT.0.001.AND.BB3.LT.0.001)THEN
            IF(ISCOP.NE.1)THEN
               IF(IWORK.EQ.0.OR.IWORK.EQ.3)THEN
                  ITSTCU=0
                  NCGVOL=NCGVOL-NWB
                  GOTO 999
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      IF(IPORLI.EQ.1)THEN
         S1=RRMIN(1)
         S2=RRMIN(2)
         S3=RRMIN(3)
         SS1=RRMAX(1)
         SS2=RRMAX(2)
         SS3=RRMAX(3)
         SRAGMX=0
         SRAGMN=0
         RAINT1=0
         RAINT2=0
      ENDIF
*   Create clipping objects
      IF(ICUT.NE.0.OR.IHOLE.NE.0)CALL GDCGSL(IVOLNA,ISHAPE)
*   Perspective view
      IF (IPRJ.EQ.IPERS) THEN
         CALL CGPERS(Q(ICPOIN))
      ENDIF
*   Inserting volumes in Hide + Wire Structures
      CALL GDCGHI(IWORK,NOBJ,NWWS,LSTEP,ISG,NTVOL,ISHAPE)
      GOTO 999
***SG
C
   70 CONTINUE
C
C     TUBE,CONE,TUBS,CONS  -----> call CGZREV
C
*
*     Checking Shape Parameters
*
      IF(RMIN1.GT.RMAX1) THEN
         WRITE(CHMAIL,10100)ISHAPE,NAMES(NLEVEL)
         CALL GMAIL(0,0)
      ENDIF
      IF(RMIN2.GT.RMAX2) THEN
         WRITE(CHMAIL,10200)ISHAPE,NAMES(NLEVEL)
         CALL GMAIL(0,0)
      ENDIF
      IF(PHIMIN.GT.PHIMAX)THEN
         WRITE(CHMAIL,10300)ISHAPE,NAMES(NLEVEL)
         CALL GMAIL(0,0)
      ENDIF
*
*
*   Checking if all Inner Radii are  0. ==> 'Closed' Volume
*
      IF(RMIN1.LE.0.00001.AND.RMIN2.LE.0.00001)IVCLOS=1
*SG
*   Size evaluation
      IF(IWORK.LE.2.AND.IVFUN.NE.0)THEN
*   NWPROD = n. words for each body of revolution
         NWPROD=NWREV*(NANG+1)
         NCGVOL=NCGVOL+NWPROD
         GOTO 999
      ENDIF
*  Creating object
      ICPOIN=JCGOBJ+1
*SG
      IF(ISHAPE.EQ.29)THEN
         SAL=PAR(8)
         IF(PAR(11).GT.SAL)SAL=PAR(11)
         PAR3=MAX(PAR(3),0.)
         Z2=PAR3+1.001*RMAX1*SQRT((1-SAL*SAL)/(SAL*SAL))
      ENDIF
      XZ(1,1)=RMIN1
      XZ(2,1)=-Z2
      XZ(1,2)=RMAX1
      XZ(2,2)=-Z2
      XZ(1,3)=RMAX2
      XZ(2,3)=Z2
      XZ(1,4)=RMIN2
      XZ(2,4)=Z2
      CALL CGZREV(XZ,ANG1,ANG2,NANG,4000,Q(ICPOIN))
      DO 80  J=1,3
         T(J,1)=GRMAT(3*J-2,NLEVEL)
         T(J,2)=GRMAT(3*J-1,NLEVEL)
         T(J,3)=GRMAT(3*J,NLEVEL)
   80 CONTINUE
      CALL CGRIFL(T,Q(ICPOIN))
      CGERR=Q(ICPOIN)
      IF(CGERR.LE.0)THEN
         CALL GDCGER(CGERR)
         IF(KCGST.EQ.-2) GOTO 999
         IF(KCGST.EQ.-3) THEN
            KCGST=0
            WRITE(CHMAIL,10000)ISHAPE,NAMES(NLEVEL)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
      ENDIF
      CALL CGCEV(1,Q(ICPOIN))
      IF(ISHAPE.EQ.29)THEN
         SLI1(1)=-PAR(6)
         SLI1(2)=-PAR(7)
         SLI1(3)=-PAR(8)
         SLI1(4)=-PAR(3)*PAR(8)
         SLI2(1)=-PAR(9)
         SLI2(2)=-PAR(10)
         SLI2(3)=-PAR(11)
         SLI2(4)=+PAR(3)*PAR(11)
         ISL1=JCGOBJ+4000
         CALL CGSLIC(Q(ICPOIN),SLI1,4000,Q(ISL1))
         ISL2=JCGOBJ+8000
         CALL CGSLIC(Q(ISL1),SLI2,4000,Q(ISL2))
         ICPOIN=ISL2
         CALL CGCEV(1,Q(ICPOIN))
      ENDIF
      DO 90  J=1,3
         T(J,1)=GRMAT(3*J-2,NLEVEL)
         T(J,2)=GRMAT(3*J-1,NLEVEL)
         T(J,3)=GRMAT(3*J,NLEVEL)
   90 CONTINUE
      CALL CGAFFI(T,Q(ICPOIN))
      XV=GTRAN(1,NLEVEL)
      YV=GTRAN(2,NLEVEL)
      ZV=GTRAN(3,NLEVEL)
      CALL CGSHIF(XV,YV,ZV,Q(ICPOIN))
***SG
*    Shifting object
      IF(KSHIFT.GT.0)THEN
         CALL GDSHIF(IVOLNA,ICPOIN)
      ENDIF
*
      IF(GBOOM.NE.0)THEN
         CALL GDBOMB(ICPOIN,ISHAPE)
         IF(ITSTCU.EQ.0)GOTO 999
      ENDIF
*
*
*   Hidden Volume Removal:
*   Computing closed volumes visibility and skipping
*   the unvisible ones; a great increase in speed
*   and a great reduction in n. of words used are obtained
*   in this way.
*
      CALL CGMNMX(Q(ICPOIN),RRMIN,RRMAX)
      IF(ISUBLI.EQ.1)THEN
         AA1=RRMIN(1)-S1
         AA2=RRMIN(2)-S2
         AA3=RRMIN(3)-S3
         BB1=RRMAX(1)-SS1
         BB2=RRMAX(2)-SS2
         BB3=RRMAX(3)-SS3
         IF(AA1.GT.0.001.AND.AA2.GT.0.001.AND.AA3.GT.0.001.AND. BB1.LT.
     +   -0.001.AND.BB2.LT.-0.001.AND.BB3.LT.-0.001)THEN
            IF(ISHAPE.EQ.7.OR.ISHAPE.EQ.8)THEN
               IF((RMAX2.LT.SRAGMX.AND.RMAX1.LT.SRAGMN).OR. (SRAGMX.EQ.
     +         0))THEN
                  IF((RMIN2.GT.RAINT2.AND.RMIN1.GT.RAINT1).OR. (RAINT2.
     +            EQ.0))THEN
                     IF(IWORK.EQ.0.OR.IWORK.EQ.3)THEN
                        ITSTCU=0
                        NCGVOL=NCGVOL-NWPROD
                        GOTO 999
                     ENDIF
                  ENDIF
               ENDIF
            ELSEIF(SRAGMX.NE.0.)THEN
               DO 100 ITER=1,IPORNT
                  IF(RMAX1.EQ.PORMAR(ITER))GOTO 110
                  IF(RMIN1.EQ.PORMIR(ITER))THEN
                     IF(PORMIR(ITER).NE.0.)GOTO 110
                  ENDIF
  100          CONTINUE
            ENDIF
            IF(IWORK.EQ.0.OR.IWORK.EQ.3)THEN
               ITSTCU=0
               NCGVOL=NCGVOL-NWPROD
               GOTO 999
            ENDIF
         ENDIF
      ENDIF
      IF(IPORLI.EQ.1)THEN
         S1=RRMIN(1)
         S2=RRMIN(2)
         S3=RRMIN(3)
         SS1=RRMAX(1)
         SS2=RRMAX(2)
         SS3=RRMAX(3)
         SRAGMX=RMAX2
         SRAGMN=RMAX1
         RAINT1=RMIN1
         RAINT2=RMIN2
         IPORNT=1
         PORMAR(1)=RMAX2
         PORMIR(1)=RMIN1
      ENDIF
  110 CONTINUE
*   Create clipping objects
      IF(ICUT.NE.0.OR.IHOLE.NE.0)CALL GDCGSL(IVOLNA,ISHAPE)
*   Perspective view
      IF (IPRJ.EQ.IPERS) THEN
         CALL CGPERS(Q(ICPOIN))
      ENDIF
*   Inserting objects in Hide + Wire structures
      CALL GDCGHI(IWORK,NOBJ,NWWS,LSTEP,ISG,NTVOL,ISHAPE)
      GOTO 999
***SG
C
  120 CONTINUE
C
C     SPHE  -----> call CGSPHE
C
      IVCLOS=1
*SG
*   Size evaluation
      IF(IWORK.LE.2.AND.IVFUN.NE.0)THEN
*  NWS = n. words for each sphere
         NCGVOL=NCGVOL+NWS
         GOTO 999
      ENDIF
*
      R=RMAX
      RMAX2=R
      RMAX1=0
      RMIN1=0
      RMIN2=0
      NLAT=11
      NLON=11
      NWOR=4000
      IF(IWORK.EQ.3.AND.(PAR(3).EQ.0.AND.(PAR(4).EQ.0.OR.
     +PAR(4).EQ.180)))THEN
         NLAT=29
         NLON=29
         NWOR=30000
      ENDIF
      ICPOIN=JCGOBJ+1
*  Creating object
      CALL CGSPHE(R,NLAT,NLON,NWOR,Q(ICPOIN))
      DO 130 J=1,3
         T(J,1)=GRMAT(3*J-2,NLEVEL)
         T(J,2)=GRMAT(3*J-1,NLEVEL)
         T(J,3)=GRMAT(3*J,NLEVEL)
  130 CONTINUE
      CALL CGRIFL(T,Q(ICPOIN))
*SG
      CGERR=Q(ICPOIN)
      IF(CGERR.LE.0)THEN
         CALL GDCGER(CGERR)
         IF(KCGST.EQ.-2) GOTO 999
         IF(KCGST.EQ.-3) THEN
            KCGST=0
            WRITE(CHMAIL,10000)ISHAPE,NAMES(NLEVEL)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
      ENDIF
      CALL CGCEV(1,Q(ICPOIN))
      IF(PAR(3).NE.0.OR.(PAR(4).NE.0.AND.PAR(4).NE.180))THEN
         ISHAPE=99
         SPI1(1)=-COS((90-PAR(3))*DEGRAD)
         SPI1(2)=0
         SPI1(3)=-COS(PAR(3)*DEGRAD)
         SPI1(4)=0
         SPI2(1)=-COS((90-PAR(4))*DEGRAD)
         SPI2(2)=0
         SPI2(3)=-COS(PAR(4)*DEGRAD)
         SPI2(4)=0
         ISP1=JCGOBJ+4000
         CALL CGSLIC(Q(ICPOIN),SPI1,4000,Q(ISP1))
         ISP2=JCGOBJ+8000
         CALL CGSLIC(Q(ISP1),SPI2,4000,Q(ISP2))
         ICPOIN=ISP2
         CALL CGCEV(1,Q(ICPOIN))
      ENDIF
      DO 140 J=1,3
         T(J,1)=GRMAT(3*J-2,NLEVEL)
         T(J,2)=GRMAT(3*J-1,NLEVEL)
         T(J,3)=GRMAT(3*J,NLEVEL)
  140 CONTINUE
      CALL CGAFFI(T,Q(ICPOIN))
      XV=GTRAN(1,NLEVEL)
      YV=GTRAN(2,NLEVEL)
      ZV=GTRAN(3,NLEVEL)
      CALL CGSHIF(XV,YV,ZV,Q(ICPOIN))
***SG
*    Shifting object
      IF(KSHIFT.GT.0)THEN
         CALL GDSHIF(IVOLNA,ICPOIN)
      ENDIF
*
      IF(GBOOM.NE.0)THEN
         CALL GDBOMB(ICPOIN,ISHAPE)
         IF(ITSTCU.EQ.0)GOTO 999
      ENDIF
*
*
*   Hidden Volume Removal:
*   Computing closed volumes visibility and skipping
*   the unvisible ones; a great increase in speed
*   and a great reduction in n. of words used are obtained
*   in this way.
*
      CALL CGMNMX(Q(ICPOIN),RRMIN,RRMAX)
      IF(ISUBLI.EQ.1)THEN
         AA1=RRMIN(1)-S1
         AA2=RRMIN(2)-S2
         AA3=RRMIN(3)-S3
         BB1=RRMAX(1)-SS1
         BB2=RRMAX(2)-SS2
         BB3=RRMAX(3)-SS3
         IF(AA1.GT.0.001.AND.AA2.GT.0.001.AND.AA3.GT.0.001.AND. BB1.LT.
     +   -0.001.AND.BB2.LT.-0.001.AND.BB3.LT.-0.001)THEN
            IF(ISHAPE.NE.99)THEN
               IF(IWORK.EQ.0.OR.IWORK.EQ.3)THEN
                  ITSTCU=0
                  NCGVOL=NCGVOL-NWS
                  GOTO 999
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      IF(IPORLI.EQ.1)THEN
         S1=RRMIN(1)
         S2=RRMIN(2)
         S3=RRMIN(3)
         SS1=RRMAX(1)
         SS2=RRMAX(2)
         SS3=RRMAX(3)
         SRAGMX=R
         SRAGMN=0.
         RAINT1=0.
         RAINT2=0.
         IPORNT=1
         PORMAR(1)=R
         PORMIR(1)=0.
      ENDIF
*   Create clipping objects
      IF(ICUT.NE.0.OR.IHOLE.NE.0)CALL GDCGSL(IVOLNA,ISHAPE)
*   Perspective view
      IF (IPRJ.EQ.IPERS) THEN
         CALL CGPERS(Q(ICPOIN))
      ENDIF
*   Inserting objects in Hide + Wire structures
      CALL GDCGHI(IWORK,NOBJ,NWWS,LSTEP,ISG,NTVOL,ISHAPE)
      GOTO 999
***SG
*
  150 CONTINUE
C
C         PGON   ---->  call CGZREV
C
      NTVOL=NZ-1
      ANG1=PHIMIN
      ANG2=PHIMAX
**SG
      AANG=ABS(ANG2-ANG1)
      AZLAT=AANG*APPROS
      ZLAT=AZLAT/360
      NANG=ZLAT
      IF(NANG.EQ.0)NANG=1
      AZ=ZLAT-NANG
      IF(AZ.GT..5)NANG=NANG+1
      IF(NDIVAN.LT.NANG)THEN
         NANG=NDIVAN
*         WRITE(CHMAIL,10400)NANG,NAMES(NLEVEL)
*         CALL GMAIL(0,0)
      ENDIF
      AATMAX=NANG*360./AANG
      LATMAX=AATMAX
      ALA=AATMAX-LATMAX
      IF(ALA.GT..5)LATMAX=LATMAX+1
**SG
      AFINV=1./COS(PI/LATMAX)
      FINV=ABS(AFINV)
      JSURZ=1
      ZR(1)=PAR(5)
      RMIR(1)=PAR(6)*FINV
      RMAR(1)=PAR(7)*FINV
*SG
      RMAR(1)=RMAR(1)+.001
*SG
      DO 160 I=1,NTVOL
*         ZA=PAR(5+3*(I-1))
         ZB=PAR(5+3*I)
**SG
         ZB=ZB+.001
*********         DIFZ=ABS(ZB-ZA)
*********         IF(DIFZ.LT.0.001)GOTO 220
**SG
         JSURZ=JSURZ+1
         ZR(JSURZ)=ZB
         RMIR(JSURZ)=PAR(6+3*I)*FINV
         RMAR(JSURZ)=PAR(7+3*I)*FINV
**SG
         RMAR(JSURZ)=RMAR(JSURZ)+.001
*
  160 CONTINUE
*
*   Checking if all Inner Radii are  0. ==> 'Closed' Volume
*
*      NRAD=NTVOL+1
*      DO 230 I=1,NRAD
*         IF(RMIR(I).GT.0.00001)GOTO 240
*  230 CONTINUE
*      IVCLOS=1
*  240 CONTINUE
*
*   Size evaluation
      IF(IWORK.LE.2.AND.IVFUN.NE.0)THEN
         NCGVOL=NCGVOL+NWREV*(NANG+1)*NTVOL
         GOTO 999
      ENDIF
      IF(IPORLI.EQ.1)THEN
         SRAGMN=10000.
         RAINT1=10000.
      ENDIF
*
      DO 220  IVOL=1,NTVOL
         ISG=ISG+1
         IVCLOS=1
         IF((RMIR(IVOL).GT.0.00001).OR.(RMIR(IVOL+1).GT.
     +   0.00001))IVCLOS=0
         XZ(1,1)=RMIR(IVOL)
         XZ(2,1)=ZR(IVOL)
         XZ(1,2)=RMAR(IVOL)
         XZ(2,2)=ZR(IVOL)
         XZ(1,3)=RMAR(IVOL+1)
         XZ(2,3)=ZR(IVOL+1)
         XZ(1,4)=RMIR(IVOL+1)
         XZ(2,4)=ZR(IVOL+1)
         ZR(IVOL+1)=ZR(IVOL+1)+.001
         ICPOIN=JCGOBJ+1
*   Creating object
**SG
         CALL CGZREV(XZ,ANG1,ANG2,NANG,4000,Q(ICPOIN))
         DO 170 J=1,3
            T(J,1)=GRMAT(3*J-2,NLEVEL)
            T(J,2)=GRMAT(3*J-1,NLEVEL)
            T(J,3)=GRMAT(3*J,NLEVEL)
  170    CONTINUE
         CALL CGRIFL(T,Q(ICPOIN))
         CGERR=Q(ICPOIN)
         IF(CGERR.LE.0)THEN
            CALL GDCGER(CGERR)
            IF(KCGST.EQ.-2) GOTO 999
            IF(KCGST.EQ.-3) THEN
               KCGST=0
               WRITE(CHMAIL,10000)ISHAPE,NAMES(NLEVEL)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,10400)(PAR(I),I=1,4)
               CALL GMAIL(0,0)
               DO 180 J=1,NZ
                  ZPR=PAR(5+(J-1)*3)
                  RMIPR=PAR(6+(J-1)*3)
                  RMAPR=PAR(7+(J-1)*3)
                  WRITE(CHMAIL,10600)J,ZPR,RMIPR,RMAPR
                  CALL GMAIL(0,0)
  180          CONTINUE
               GOTO 999
            ENDIF
         ENDIF
         CALL CGCEV(1,Q(ICPOIN))
         DO 190  J=1,3
            T(J,1)=GRMAT(3*J-2,NLEVEL)
            T(J,2)=GRMAT(3*J-1,NLEVEL)
            T(J,3)=GRMAT(3*J,NLEVEL)
  190    CONTINUE
         CALL CGAFFI(T,Q(ICPOIN))
         XV=GTRAN(1,NLEVEL)
         YV=GTRAN(2,NLEVEL)
         ZV=GTRAN(3,NLEVEL)
         CALL CGSHIF(XV,YV,ZV,Q(ICPOIN))
***SG
*    Shifting object
         IF(KSHIFT.GT.0)THEN
            CALL GDSHIF(IVOLNA,ICPOIN)
         ENDIF
*
         IF(GBOOM.NE.0)THEN
            CALL GDBOMB(ICPOIN,ISHAPE)
            IF(ITSTCU.EQ.0)GOTO 220
         ENDIF
*
*
*   Hidden Volume Removal:
*   Computing closed volumes visibility and skipping
*   the unvisible ones; a great increase in speed
*   and a great reduction in n. of words used are obtained
*   in this way.
*
         CALL CGMNMX(Q(ICPOIN),RRMIN,RRMAX)
         IF(ISUBLI.EQ.1)THEN
            AA1=RRMIN(1)-S1
            AA2=RRMIN(2)-S2
            AA3=RRMIN(3)-S3
            BB1=RRMAX(1)-SS1
            BB2=RRMAX(2)-SS2
            BB3=RRMAX(3)-SS3
            IF(AA1.GT.0.001.AND.AA2.GT.0.001.AND.AA3.GT.0.001.AND.
     +      BB1.LT.-0.001.AND.BB2.LT.-0.001.AND.BB3.LT.-0.001)THEN
               AMARMA(IVOL) =MIN(RMAR(IVOL),RMAR(IVOL+1))
               AMARMA(IVOL+1)=MAX(RMAR(IVOL),RMAR(IVOL+1))
               AMIRMA(IVOL) =MIN(RMIR(IVOL),RMIR(IVOL+1))
               AMIRMA(IVOL+1)=MAX(RMIR(IVOL),RMIR(IVOL+1))
               RMAX1=AMARMA(IVOL)
               RMAX2=AMARMA(IVOL+1)
               RMIN1=AMIRMA(IVOL)
               RMIN2=AMIRMA(IVOL+1)
               IF(SRAGMX.NE.0.)THEN
                  DO 200 ITER=1,IPORNT
                     IF(RMAX1.EQ.PORMAR(ITER).OR.RMAX2.EQ.PORMAR(ITER))
     +               GOTO 210
                     IF(RMIN1.EQ.PORMIR(ITER).OR.RMIN2.EQ.PORMIR(ITER))
     +               THEN
                        IF(PORMIR(ITER).NE.0.)GOTO 210
                     ENDIF
  200             CONTINUE
               ENDIF
               IF(ISCOP.EQ.1)THEN
                  IF((AMARMA(IVOL+1).GE.SRAGMX.OR.AMARMA(IVOL) .GT.SRAG
     +            MN))GOTO 210
                  IF((AMIRMA(IVOL+1).LE.RAINT2.OR.AMIRMA(IVOL)
     +            .LE.RAINT1).AND.(RAINT2.NE.0))GOTO 210
               ENDIF
               IF(IWORK.EQ.0.OR.IWORK.EQ.3)THEN
                  ITSTCU=0
                  NCGVOL=NCGVOL-NWPROD
                  GOTO 220
               ENDIF
            ENDIF
         ENDIF
         IF(IPORLI.EQ.1)THEN
            IF(RRMIN(1).LT.S1)S1=RRMIN(1)
            IF(RRMIN(2).LT.S2)S2=RRMIN(2)
            IF(RRMIN(3).LT.S3)S3=RRMIN(3)
            IF(RRMAX(1).GT.SS1)SS1=RRMAX(1)
            IF(RRMAX(2).GT.SS2)SS2=RRMAX(2)
            IF(RRMAX(3).GT.SS3)SS3=RRMAX(3)
            IF(RMAR(IVOL).GT.SRAGMX)SRAGMX=RMAR(IVOL)
            IF(RMAR(IVOL).LT.SRAGMN)SRAGMN=RMAR(IVOL)
            IF(RMAR(IVOL+1).GT.SRAGMX)SRAGMX=RMAR(IVOL+1)
            IF(RMAR(IVOL+1).LT.SRAGMN)SRAGMN=RMAR(IVOL+1)
            IF(RMIR(IVOL).GT.RAINT2)RAINT2=RMIR(IVOL)
            IF(RMIR(IVOL).LT.RAINT1)RAINT1=RMIR(IVOL)
            IF(RMIR(IVOL+1).GT.RAINT2)RAINT2=RMIR(IVOL+1)
            IF(RMIR(IVOL+1).LT.RAINT1)RAINT1=RMIR(IVOL+1)
            PORMAR(IVOL)=RMAR(IVOL)
            PORMIR(IVOL)=RMIR(IVOL)
            IPORNT =NTVOL
         ENDIF
  210    CONTINUE
*   Create clipping objects
         IF(ICUT.NE.0.OR.IHOLE.NE.0)CALL GDCGSL(IVOLNA,ISHAPE)
*   Perspective view
         IF (IPRJ.EQ.IPERS) THEN
            CALL CGPERS(Q(ICPOIN))
         ENDIF
*   Inserting objects in Hide + Wire structures
         CALL GDCGHI(IWORK,NOBJ,NWWS,LSTEP,ISG,NTVOL,ISHAPE)
***SG
  220 CONTINUE
      GOTO 999
*
  230 CONTINUE
C
C         PCON    ---->  call CGZREV
C
      NTVOL=NZ-1
      ANG1=PHIMIN
      ANG2=PHIMAX
**SG
      AANG=ABS(ANG2-ANG1)
      AZLAT=AANG*APPROS
      ZLAT=AZLAT/360
      NANG=ZLAT
      IF(NANG.EQ.0)NANG=1
      AZ=ZLAT-NANG
      IF(AZ.GT..5)NANG=NANG+1
**SG
      AFINV=1./COS(PI/APPROS)
      FINV=ABS(AFINV)
      JSURZ=1
      ZR(1)=PAR(4)
      RMIR(1)=PAR(5)*FINV
      RMAR(1)=PAR(6)*FINV
*SG
      RMAR(1)=RMAR(1)+.1
*SG
      DO 240 I=1,NTVOL
*         ZA=PAR(4+3*(I-1))
         ZB=PAR(4+3*I)
**SG
         ZB=ZB+.001
********         DIFZ=ABS(ZB-ZA)
********         IF(DIFZ.LT.0.001)GOTO 290
**SG
         JSURZ=JSURZ+1
         ZR(JSURZ)=ZB
         RMIR(JSURZ)=PAR(5+3*I)*FINV
         RMAR(JSURZ)=PAR(6+3*I)*FINV
**SG
         RMAR(JSURZ)=RMAR(JSURZ)+.1
*
  240 CONTINUE
*
*   Checking if all Inner Radii are  0. ==> 'Closed' Volume
*
*      NRAD=NTVOL+1
*      DO 300 I=1,NRAD
*         IF(RMIR(I).GT.0.00001)GOTO 310
*  300 CONTINUE
*      IVCLOS=1
*  310 CONTINUE
*
*
*   Size evaluation
      IF(IWORK.LE.2.AND.IVFUN.NE.0)THEN
         NCGVOL=NCGVOL+NWREV*(NANG+1)*NTVOL
         GOTO 999
      ENDIF
      IF(IPORLI.EQ.1)THEN
         SRAGMN=10000.
         RAINT1=10000.
      ENDIF
*
      DO 300 IVOL=1,NTVOL
         ISG=ISG+1
         IVCLOS=1
         IF((RMIR(IVOL).GT.0.00001).OR.(RMIR(IVOL+1).GT.
     +   0.00001))IVCLOS=0
         XZ(1,1)=RMIR(IVOL)
         XZ(2,1)=ZR(IVOL)
         XZ(1,2)=RMAR(IVOL)
         XZ(2,2)=ZR(IVOL)
         XZ(1,3)=RMAR(IVOL+1)
         XZ(2,3)=ZR(IVOL+1)
         XZ(1,4)=RMIR(IVOL+1)
         XZ(2,4)=ZR(IVOL+1)
         ZR(IVOL+1)=ZR(IVOL+1)+.1
         ICPOIN=JCGOBJ+1
*  Creating object
**SG
         CALL CGZREV(XZ,ANG1,ANG2,NANG,4000,Q(ICPOIN))
         DO 250 J=1,3
            T(J,1)=GRMAT(3*J-2,NLEVEL)
            T(J,2)=GRMAT(3*J-1,NLEVEL)
            T(J,3)=GRMAT(3*J,NLEVEL)
  250    CONTINUE
         CALL CGRIFL(T,Q(ICPOIN))
         CALL CGCEV(-1,Q(ICPOIN))
         CGERR=Q(ICPOIN)
         IF(CGERR.LE.0)THEN
            CALL GDCGER(CGERR)
            IF(KCGST.EQ.-2) GOTO 999
            IF(KCGST.EQ.-3) THEN
               KCGST=0
               WRITE(CHMAIL,10000)ISHAPE,NAMES(NLEVEL)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,10500)(PAR(I),I=1,3)
               CALL GMAIL(0,0)
               DO 260 J=1,NZ
                  ZPR=PAR(4+(J-1)*3)
                  RMIPR=PAR(5+(J-1)*3)
                  RMAPR=PAR(6+(J-1)*3)
                  WRITE(CHMAIL,10600)J,ZPR,RMIPR,RMAPR
                  CALL GMAIL(0,0)
  260          CONTINUE
               GOTO 999
            ENDIF
         ENDIF
         CALL CGCEV(1,Q(ICPOIN))
         DO 270 J=1,3
            T(1,J)=GRMAT(3*J-2,NLEVEL)
            T(2,J)=GRMAT(3*J-1,NLEVEL)
            T(3,J)=GRMAT(3*J,NLEVEL)
            T(4,J)=0.
  270    CONTINUE
         CALL CGAFFI(T,Q(ICPOIN))
         XV=GTRAN(1,NLEVEL)
         YV=GTRAN(2,NLEVEL)
         ZV=GTRAN(3,NLEVEL)
         CALL CGSHIF(XV,YV,ZV,Q(ICPOIN))
*
***SG
*    Shifting object
         IF(KSHIFT.GT.0)THEN
            CALL GDSHIF(IVOLNA,ICPOIN)
         ENDIF
*
         IF(GBOOM.NE.0)THEN
            CALL GDBOMB(ICPOIN,ISHAPE)
            IF(ITSTCU.EQ.0)GOTO 300
         ENDIF
*
*
*   Hidden Volume Removal:
*   Computing closed volumes visibility and skipping
*   the unvisible ones; a great increase in speed
*   and a great reduction in n. of words used are obtained
*   in this way.
*
         CALL CGMNMX(Q(ICPOIN),RRMIN,RRMAX)
         IF(ISUBLI.EQ.1)THEN
            AA1=RRMIN(1)-S1
            AA2=RRMIN(2)-S2
            AA3=RRMIN(3)-S3
            BB1=RRMAX(1)-SS1
            BB2=RRMAX(2)-SS2
            BB3=RRMAX(3)-SS3
            IF(AA1.GT.0.001.AND.AA2.GT.0.001.AND.AA3.GT.0.001.AND.
     +      BB1.LT.-0.001.AND.BB2.LT.-0.001.AND.BB3.LT.-0.001)THEN
               AMARMA(IVOL) =MIN(RMAR(IVOL),RMAR(IVOL+1))
               AMARMA(IVOL+1)=MAX(RMAR(IVOL),RMAR(IVOL+1))
               AMIRMA(IVOL) =MIN(RMIR(IVOL),RMIR(IVOL+1))
               AMIRMA(IVOL+1)=MAX(RMIR(IVOL),RMIR(IVOL+1))
               RMAX1=AMARMA(IVOL)
               RMAX2=AMARMA(IVOL+1)
               RMIN1=AMIRMA(IVOL)
               RMIN2=AMIRMA(IVOL+1)
               IF(SRAGMX.NE.0.)THEN
                  DO 280 ITER=1,IPORNT
                     IF(RMAX1.EQ.PORMAR(ITER).OR.RMAX2.EQ.PORMAR(ITER))
     +               GOTO 290
                     IF(RMIN1.EQ.PORMIR(ITER).OR.RMIN2.EQ.PORMIR(ITER))
     +               THEN
                        IF(PORMIR(ITER).NE.0)GOTO 290
                     ENDIF
  280             CONTINUE
               ENDIF
               IF(ISCOP.EQ.1)THEN
                  IF((AMARMA(IVOL+1).GE.SRAGMX.OR.AMARMA(IVOL) .GE.SRAG
     +            MN))GOTO 290
                  IF((AMIRMA(IVOL+1).LE.RAINT2.AND.AMIRMA(IVOL)
     +            .LE.RAINT1).AND.(RAINT2.NE.0))GOTO 290
               ENDIF
               IF(IWORK.EQ.0.OR.IWORK.EQ.3)THEN
                  NCGVOL=NCGVOL-NWPROD
                  ITSTCU=0
                  GOTO 300
               ENDIF
            ENDIF
         ENDIF
         IF(IPORLI.EQ.1)THEN
            IF(RRMIN(1).LT.S1)S1=RRMIN(1)
            IF(RRMIN(2).LT.S2)S2=RRMIN(2)
            IF(RRMIN(3).LT.S3)S3=RRMIN(3)
            IF(RRMAX(1).GT.SS1)SS1=RRMAX(1)
            IF(RRMAX(2).GT.SS2)SS2=RRMAX(2)
            IF(RRMAX(3).GT.SS3)SS3=RRMAX(3)
            IF(RMAR(IVOL).GT.SRAGMX)SRAGMX=RMAR(IVOL)
            IF(RMAR(IVOL).LT.SRAGMN)SRAGMN=RMAR(IVOL)
            IF(RMAR(IVOL+1).GT.SRAGMX)SRAGMX=RMAR(IVOL+1)
            IF(RMAR(IVOL+1).LT.SRAGMN)SRAGMN=RMAR(IVOL+1)
            IF(RMIR(IVOL).GT.RAINT2)RAINT2=RMIR(IVOL)
            IF(RMIR(IVOL).LT.RAINT1)RAINT1=RMIR(IVOL)
            IF(RMIR(IVOL+1).GT.RAINT2)RAINT2=RMIR(IVOL+1)
            IF(RMIR(IVOL+1).LT.RAINT1)RAINT1=RMIR(IVOL+1)
            PORMAR(IVOL)=RMAR(IVOL)
            PORMIR(IVOL)=RMIR(IVOL)
            IPORNT =NTVOL
         ENDIF
  290    CONTINUE
*   Create clipping objects
         IF(ICUT.NE.0.OR.IHOLE.NE.0)CALL GDCGSL(IVOLNA,ISHAPE)
*   Perspective view
         IF (IPRJ.EQ.IPERS) THEN
            CALL CGPERS(Q(ICPOIN))
         ENDIF
*   Inserting object in Hide + Wire structures
         CALL GDCGHI(IWORK,NOBJ,NWWS,LSTEP,ISG,NTVOL,ISHAPE)
  300 CONTINUE
      GOTO 999
*
***SG
*
10000   FORMAT(' Check Parameters of Shape ',I3,' in volume ',A4)
10100   FORMAT(' Warning >>> RMIN1 greater than RMAX1 for shape '
     +  ,I3,' in volume ',A4)
10200   FORMAT(' Warning >>> RMIN2 greater than RMAX2 for shape '
     +  ,I3,' in volume ',A4)
10300   FORMAT(' Warning >>> PHIMIN greater than PHIMAX for shape'
     +  ,I3,' in volume ',A4)
*10400   FORMAT(' PGON with NPDV = ',I5,' in volume ',A4,' NPDV very
*     +  large . It must be < 30 . Volume will not be drawn. ')
10400   FORMAT(' PHI1 = ',F8.3,' DPHI = ',F8.3,' NPDV = ',F8.1
     +  ,' NZ   = ',F8.1)
10500   FORMAT(' PHI1 = ',F8.3,' DPHI = ',F8.3,' NZ  = ',F8.1)
10600   FORMAT(' J = ',I5,' Z = ',F8.3,' RMIN = ',F8.3
     +  ,' RMAX = ',F8.3)
*10800   FORMAT(' Please, increase size of Zebra store by ',I10,
*     +         ' words')
*
***SG
  999 END
+DECK,  GDCGPR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:21  cernlib
* Geant

      SUBROUTINE GDCGPR
C.    ******************************************************************
C.    *                                                                *
C.    *    The aim of this subroutine is:                              *
C.    *                                                                *
C.    *    - To control the number of structures used                  *
C.    *    - To test if the maximum size of memory is achieved         *
C.    *                                                                *
C.    *    - To increase the size of the CG-Bank if there              *
C.    *    is not enough space for new CG structures.                  *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GDCGCL,GDCGHI,GDCGOB                         *
C.    *                                                                *
C.    *       Author : J. Salt   **********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCGOBJ.
+CDE, GCHILN.
*
      INCND=2500
*
*  Control on the Maximum Number of CG Structures
*
      IF(IST.GT.IQ(JCOUNT-1))THEN
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
         KCGST=-1
         RETURN
      ENDIF
*
*   Control the Size of the IXCG
*   Bank Extension. Garbage Collection
*
      NSUM=NFILT+NTNEX
      NWFIL=IQ(JCG-1)
      IF(NSUM.GT.NWFIL)THEN
         NRES=NSUM-IQ(JCG-1)
         IF(NRES.GT.INCND)INCND=NRES
**
         IXCG=IXSTOR+1
         CALL MZPUSH(IXCG,JCG,0,INCND,' ')
      ENDIF
      IXCG=IXSTOR+1
      CALL MZGARB(IXCG,0)
*
10000 FORMAT('  Maximum Number of Structures exceeded')
*
      END

+DECK,  GDCGRS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:21  cernlib
* Geant

      SUBROUTINE GDCGRS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Reset the pointers and counters for the Zebra Bank         *
C.    *     of CG, HS and Wire Objects.                                *
C.    *                                                                *
C.    *    ==>Called by : GDRAW,GDCGHI                                 *
C.    *                                                                *
C.    *                                                                *
C.    *       Author : J. Salt ; S. Giani  **********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCGOBJ.
*
      IST=2
*      DO 10 I=1,NST
*         LPST(I)=0
* 10   CONTINUE
*      LPST(1)=1
*      LPST(2)=4000
*      LPST(3)=8000
      IFCG=3
      ILCG=2
*SG
*      NTCUR=0
*      NFILT=0
*      NTNEX=0
*SG
      KCGST=0
      NCGVOL=0
      IVCLOS=0
      IVFUN=1
      NCLAS1=0
*SG
*      NCLAS2=0
*      NCLAS3=0
*SG
      END

+DECK,  GDCGSL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:21  cernlib
* Geant

      SUBROUTINE GDCGSL(IVOLNA,ISHAPE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This routine allows computes the coefficients of the     *
C.    *       cut plane and the limits and array of the clipping       *
C.    *       volumes (boxes, cones, tubes, spheres).                  *
C.    *                                                                *
C.    *    ==>Called by : GDRAW                                        *
C.    *                                                                *
C.    *       Authors :  J.Salt ; S.Giani                              *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCONSP.
+CDE, GCGOBJ.
*
*
*****SG
*
+CDE, GCSPEE.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCVOLU.
+CDE, GCHILN.
+CDE, GCMUTR.
+CDE, PAWC.
*
      DIMENSION TMIN(3),TMAX(3),XZ(2,4)
      CHARACTER*4 NACA
*
      CALL UCTOH('PERS',IPERS,4,4)
      IF(IHOLE.NE.0)THEN
*
*   Clipping Volumes Creation
*
*   Look for volume to be clipped
*
         NAIN=0
         JJJ=0
         ICUBE=0
         CALL UHTOC(IVOLNA,4,NACA,4)
         DO 30  III=1,MULTRA
            INV=0
            IWILDC=INDEX(GNNVV(III),'*')
            IF(IWILDC.EQ.0) THEN
               CALL UCTOH(GNNVV(III),INV,4,4)
            ELSEIF(IWILDC.EQ.1.AND.JJJ.LT.2) THEN
               INV=IVOLNA
            ELSEIF(GNNVV(III)(1:IWILDC-1).EQ.
     +                NACA(1:IWILDC-1)) THEN
               INV=IVOLNA
            ENDIF
            IF(INV.EQ.IVOLNA)THEN
*
*   If you find it, compute number of times it's to be clipped
*   and set parameters of relative clipping shapes
*
               JJJ=JJJ+1
               IF(JJJ.EQ.3)THEN
                  WRITE(CHMAIL,10100)
                  CALL GMAIL(0,0)
                  GOTO 60
               ENDIF
               IF(GNASH(III).EQ.'BOX ')THEN
                  DBX=GXMAX(III)-GXMIN(III)
                  DBY=GYMAX(III)-GYMIN(III)
                  DBZ=GZMAX(III)-GZMIN(III)
*
                  IF(JJJ.EQ.2)THEN
                     ICUBE=ICUBE+1
                     CALL CGBRIK(DBX,DBY,DBZ,300,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     CALL CGSHIF(GXMIN(III),GYMIN(III),GZMIN(III),
     +               Q(ICLIP2))
                     CALL CGMNMX(Q(ICLIP2),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP2))
                     ENDIF
                  ELSE
                     ICUBE=ICUBE+1
                     CALL CGBRIK(DBX,DBY,DBZ,300,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     CALL CGSHIF(GXMIN(III),GYMIN(III),GZMIN(III),
     +               Q(ICLIP1))
                     CALL CGMNMX(Q(ICLIP1),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP1))
                     ENDIF
                  ENDIF
               ELSE IF (GNASH(III).EQ.'TUBE') THEN
                  RMIN1=0
                  RMAX1=GXMIN(III)
                  Z2=GXMAX(III)
                  RMIN2=RMIN1
                  RMAX2=RMAX1
                  XZ(1,1)=RMIN1
                  XZ(2,1)=-Z2
                  XZ(1,2)=RMAX1
                  XZ(2,2)=-Z2
                  XZ(1,3)=RMAX2
                  XZ(2,3)=Z2
                  XZ(1,4)=RMIN2
                  XZ(2,4)=Z2
                  ANG1=0.
                  ANG2=360.
                  NANG=30
*
                  IF(JJJ.EQ.2)THEN
                     CALL CGZREV(XZ,ANG1,ANG2,NANG,16000,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     S1=GYMIN(III)
                     S2=GYMAX(III)
                     S3=GZMIN(III)
                     CALL CGSHIF(S1,S2,S3,Q(ICLIP2))
                     CALL CGMNMX(Q(ICLIP2),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP2))
                     ENDIF
                  ELSE
                     CALL CGZREV(XZ,ANG1,ANG2,NANG,16000,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     S1=GYMIN(III)
                     S2=GYMAX(III)
                     S3=GZMIN(III)
                     CALL CGSHIF(S1,S2,S3,Q(ICLIP1))
                     CALL CGMNMX(Q(ICLIP1),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP1))
                     ENDIF
                  ENDIF
               ELSE IF (GNASH(III).EQ.'SPHE') THEN
                  R=GXMIN(III)
                  NLAT=15
                  NLON=15
*
                  IF(JJJ.EQ.2)THEN
                     CALL CGSPHE(R,NLAT,NLON,16000,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     S1=GXMAX(III)
                     S2=GYMIN(III)
                     S3=GYMAX(III)
                     CALL CGSHIF(S1,S2,S3,Q(ICLIP2))
                     CALL CGMNMX(Q(ICLIP2),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP2))
                     ENDIF
                  ELSE
                     CALL CGSPHE(R,NLAT,NLON,16000,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     S1=GXMAX(III)
                     S2=GYMIN(III)
                     S3=GYMAX(III)
                     CALL CGSHIF(S1,S2,S3,Q(ICLIP1))
                     CALL CGMNMX(Q(ICLIP1),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP1))
                     ENDIF
                  ENDIF
               ELSE IF (GNASH(III).EQ.'CONE') THEN
                  RMIN1=0.
                  RMAX1=GXMIN(III)
                  RMIN2=0.
                  RMAX2=GXMAX(III)
                  Z2=GYMIN(III)
                  XZ(1,1)=RMIN1
                  XZ(2,1)=-Z2
                  XZ(1,2)=RMAX1
                  XZ(2,2)=-Z2
                  XZ(1,3)=RMAX2
                  XZ(2,3)=Z2
                  XZ(1,4)=RMIN2
                  XZ(2,4)=Z2
                  ANG1=0.
                  ANG2=360.
                  NANG=30
                  IF(JJJ.EQ.2)THEN
                     CALL CGZREV(XZ,ANG1,ANG2,NANG,16000,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     CALL CGCEV(-1,Q(ICLIP2))
                     S1=GYMAX(III)
                     S2=GZMIN(III)
                     S3=GZMAX(III)
                     CALL CGSHIF(S1,S2,S3,Q(ICLIP2))
                     CALL CGMNMX(Q(ICLIP2),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP2))
                     ENDIF
                  ELSE
                     CALL CGZREV(XZ,ANG1,ANG2,NANG,16000,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     CALL CGCEV(-1,Q(ICLIP1))
                     S1=GYMAX(III)
                     S2=GZMIN(III)
                     S3=GZMAX(III)
                     CALL CGSHIF(S1,S2,S3,Q(ICLIP1))
                     CALL CGMNMX(Q(ICLIP1),TMIN,TMAX)
*   Perspective view
                     IF (IPRJ.EQ.IPERS) THEN
                        CALL CGPERS(Q(ICLIP1))
                     ENDIF
                  ENDIF
               ENDIF
*          IF(CGERR.LE.0)THEN
*             CALL GDCGER(CGERR)
*             IF(KCGST.EQ.-2)GO TO 999
*             IF(KCGST.EQ.-3)THEN
*                WRITE(CHMAIL,10100)
*                CALL GMAIL(0,0)
*                GO TO 999
*             ENDIF
*          ENDIF
*
*    Compute scope for each clipping volume
*
               DO 10 K=1,3
                  KKK=K+3*JJJ-3
                  BMIN(KKK)=TMIN(K)
                  BMAX(KKK)=TMAX(K)
   10          CONTINUE
               IF(IPORLI.EQ.1)THEN
                  DO 20 KJ=1,3
                     KKKJ=KJ+3*JJJ-3
                     CLIPMI(KKKJ)=TMIN(KJ)
                     CLIPMA(KKKJ)=TMAX(KJ)
   20             CONTINUE
               ENDIF
            ENDIF
   30    CONTINUE
*
*    If volume is not to be clipped
*
         IF(JJJ.EQ.0)THEN
            IF(IPORLI.EQ.1)THEN
               DO 40 KJ=1,6
                  CLIPMI(KJ)=-10000
                  CLIPMA(KJ)=-9999
   40          CONTINUE
               JPORJJ=1
            ENDIF
            NAIN=1
            GOTO 60
         ELSE
            IF(IPORLI.EQ.1)THEN
               JPORJJ=JJJ
            ENDIF
            NAIN=2
            ISA=0
            DO 50  J=1,6
               IF(BMIN(J).EQ.CLIPMI(J).AND.BMAX(J).EQ.CLIPMA(J))THEN
                  ISA=ISA+1
               ENDIF
   50       CONTINUE
            IF(ISA.EQ.6)NAIN=3
         ENDIF
*
*
*****SG
*
*
      ELSE
*
*   Slicing with a plane
*
         IF(ICUT.EQ.0) GO TO 999
         IF(ICUT.EQ.1)THEN
            CTHETA=90.
            CPHI=180.
         ELSE IF(ICUT.EQ.2)THEN
            CTHETA=90.
            CPHI=270.
         ELSE IF(ICUT.EQ.3)THEN
            CTHETA=180.
            CPHI=0.
         ELSE
            WRITE(CHMAIL,10000)
            CALL GMAIL(0,0)
            GO TO 999
         ENDIF
         ATH=DEGRAD*CTHETA
         APH=DEGRAD*CPHI
         ABCD(1)=SIN(ATH)*COS(APH)
         ABCD(2)=SIN(ATH)*SIN(APH)
         ABCD(3)=COS(ATH)
         ABCD(4)=DCUT
      ENDIF
   60 CONTINUE
*
10000 FORMAT(' CUT Index not implemented')
*10100 FORMAT(' Check Clipping Box Parameters ')
10100 FORMAT(' Please, reset CVOL mode. ')
*
  999 END
+DECK,  GDCGVW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:21  cernlib
* Geant

      SUBROUTINE GDCGVW (VPAR,VMA)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Subroutine evaluates the Viewing Matrix from Viewing Angles   *
C.    *                                                                *
C.    *  Input Parameters:                                             *
C.    *                                                                *
C.    *     VPAR(3) : Viewing Angles (VPAR(1)=THETA, VPAR(2)=PHI,      *
C.    *               VPAR(3)=PSI)                                     *
C.    *                                                                *
C.    *  Output Parameters:                                            *
C.    *                                                                *
C.    *     VMA(4,3): Viewing Matrix                                   *
C.    *                                                                *
C.    *    ==>Called by :   GDINIT,GDRAW                               *
C.    *                                                                *
C.    *       Author : J.Salt     *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCONSP.
*
      DIMENSION  VPAR(3),AMTR(4,4),VMA(4,3)
      DIMENSION  VL(3),VM(3),VN(3)
      COMMON/PROSP/SVN(3)
*.______________________________________
*
*      CALL ISCLIP(1)
      IERR=0
      DO 20 KK=1,4
         DO 10 JJ=1,4
            AMTR(KK,JJ)=0.
   10    CONTINUE
   20 CONTINUE
*
*         Normalise theta, phi and psi angles to [0-360] range
*
      THETA = MOD(ABS(VPAR(1)),180.)
      PHI = MOD(ABS(VPAR(2)),360.)
      PSI = MOD(ABS(VPAR(3)),360.)
*
*         Ensure theta is in the range [0-180]
*
      IF (THETA.GT.180.) THEN
         PHI = PHI + 180.
         THETA = 360. - THETA
      ENDIF
      SINPSI = SIN(PSI * DEGRAD)
      COSPSI = COS(PSI * DEGRAD)
      ST = SIN(THETA * DEGRAD)
      CT = COS(THETA * DEGRAD)
      SP = SIN(PHI * DEGRAD)
      CP = COS(PHI * DEGRAD)
*
*         VN is new nu axis
*
      VN(1) = ST * CP
      SVN(1)=VN(1)
      VN(2) = ST * SP
      SVN(2)=VN(2)
      VN(3) = CT
      SVN(3)=VN(3)
*
      IF (ABS(VN(2)).LT.0.99999) THEN
*
*         Y-axis is default mu axis (view up vector)
*
         VM(1) = 0.
         VM(2) = 1.
         VM(3) = 0.
*
*           Define new lambda axis
*
         VL(1)=VM(2)*VN(3)-VM(3)*VN(2)
         VL(2)=VM(3)*VN(1)-VM(1)*VN(3)
         VL(3)=VM(1)*VN(2)-VM(2)*VN(1)
         VAVL=SQRT(VL(1)**2+VL(2)**2+VL(3)**2)
         VL(1)=VL(1)/VAVL
         VL(2)=VL(2)/VAVL
         VL(3)=VL(3)/VAVL
*
*           Define new mu axis
*
         VM(1)=VN(2)*VL(3)-VN(3)*VL(2)
         VM(2)=VN(3)*VL(1)-VN(1)*VL(3)
         VM(3)=VN(1)*VL(2)-VN(2)*VL(1)
*
      ELSE
*
*           Special case when observer line of sight is along mu:
*           in this case one chooses arbitrarily the vertical axis of the
*           plane of projection as the lambda axis and the horizontal axis
*           as the nu axis
*
         VL(1) = 0.
         VL(2) = 0.
         VL(3) = 1.
         VM(1) = 1.
         VM(2) = 0.
         VM(3) = 0.
      ENDIF
*
*         Get the view up vector by rotating the mu axis
*         PSI degrees in the view plane (= mu-nu plane)
*
      VUPX = COSPSI * VM(1) + SINPSI * VL(1)
      VUPY = COSPSI * VM(2) + SINPSI * VL(2)
      VUPZ = COSPSI * VM(3) + SINPSI * VL(3)
*
*      Values for View Reference Point in NDC (CSw =1)
*
      VRPX = 0.5
      VRPY = 0.5
      VRPZ = 0.5
      VPNX = VN(1)
      VPNY = VN(2)
      VPNZ = VN(3)
*
*           Evaluate view matrix
*
      CALL GDCGEM(VRPX,VRPY,VRPZ,VUPX,VUPY, VUPZ,VPNX, VPNY,VPNZ,IERR,
     +AMTR)
*
      IF (IERR.NE.0)RETURN
*
      VMA(1,1)=AMTR(1,1)*GSCU
      VMA(2,1)=AMTR(1,2)*GSCU
      VMA(3,1)=AMTR(1,3)*GSCU
      VMA(4,1)=GU0
*
      VMA(1,2)=AMTR(2,1)*GSCV
      VMA(2,2)=AMTR(2,2)*GSCV
      VMA(3,2)=AMTR(2,3)*GSCV
      VMA(4,2)=GV0
*
      DO 30  K=1,4
         VMA(K,3)=AMTR(3,K)
   30 CONTINUE
*
      END
+DECK,  GDCGWV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:21  cernlib
* Geant

+SELF, IF=CG.
      SUBROUTINE GDCGWV(IWOFFS)
************************************************************************
*                                                                      *
*     Name: GDCGWV    extracted from CG routine CGVWIR                 *
*     Author: E. Chernyaev                       Date:    09.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Vizualisation of WIRE-object                           *
*                                                                      *
*     References: CGVHED                                               *
*                                                                      *
*     Input: Q(JCG+IWOFFS+*) - WIRE-object                             *
*               Q(JCG+*) - HIDE-structure                              *
*                                                                      *
*     Output: none                                                     *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, CGGPAR.
+CDE, CGHPAR.
+CDE, CGCTRA.
+CDE, CGCEDG.
+CDE, GCDRAW.
*
       REAL P1(3),P2(3),AX(2),AY(2)
*      SAVE FIRST,JPOLD
*      LOGICAL FIRST
*      DATA FIRST/.TRUE./
*SG
*      DIMENSION TESTX(2),TESTY(2)
*SG
*      IF(FIRST) THEN
*         JPOLD=LQ(LQ(JDRAW-3)-5)
*         FIRST=.FALSE.
*      ENDIF
      IF (Q(JCG+IWOFFS+KCGSIZ) .LE. 0.)   THEN
         WRITE(CHMAIL,10000)
         GOTO 50
      ENDIF
      IF (Q(JCG+KHSIZE) .LE. LHHEAD)  THEN
         WRITE(CHMAIL,10100)
         GOTO 50
      ENDIF
*SG
*  Icolar is equal to 1 even if hide is off, but linbuf can be = 2 only
*  if fill area option is switched on AND hide is on.
*
*      LINBUF=0
*      DO 111 IJ=1,2
*        TESTX(IJ)=0
*        TESTY(IJ)=0
* 111  CONTINUE
*      LINFIL=IBITS(LINATT,17,3)
*      IF(LINFIL.GT.0)THEN
*        CALL GDRAWV(TESTX,TESTY,-1)
*      ENDIF
*SG
      NT = Q(JCG+KHNT)
      IF (NT.LE.0 .OR. NT.GT.NTMAX)     GOTO 50
      NEDGE  = Q(JCG+IWOFFS+KCGNF)
*      IF(NEDGE.EQ.0)GOTO 49
      JXYZ1   = Q(JCG+KHJXYZ)
      JFA    = Q(JCG+KHJFA)
      JPFA   = Q(JCG+KHJPFA)
      JDFA   = Q(JCG+KHJDFA)
      JTRE   = Q(JCG+KHJTRE)
      JSTA   = Q(JCG+KHJSTA)
      JALE   = Q(JCG+KHJALE)
      JARI   = Q(JCG+KHJARI)
      NFACE  = Q(JCG+KHNFAC)
      DO 40  NE=1,NEDGE
         J = LCGHEA + (NE-1)*LCGEDG
*         IEA = Q(JCG+IWOFFS+J+KCGAE)
         P1(1) = Q(JCG+IWOFFS+J+KCGX1)
         P1(2) = Q(JCG+IWOFFS+J+KCGY1)
         P1(3) = Q(JCG+IWOFFS+J+KCGZ1)
         P2(1) = Q(JCG+IWOFFS+J+KCGX2)
         P2(2) = Q(JCG+IWOFFS+J+KCGY2)
         P2(3) = Q(JCG+IWOFFS+J+KCGZ2)
         CALL CGVEDG(NT,P1,P2,IVIS)
         IF (IVIS .LT. 0) GOTO 40
         IF (NFACE .EQ. 0) GOTO 30
         CALL CGVHED( Q(JCG+JXYZ1),Q(JCG+JFA),Q(JCG+JPFA),
     +   Q(JCG+JDFA),Q(JCG+JTRE),Q(JCG+JSTA),
     +   Q(JCG+JALE),Q(JCG+JARI))
*           D R A W   E D G E
         IF (NPART) 40 ,30 ,10
   10    DO 20  I=1,NPART+1
            IF (I .EQ. 1) T1 = 0.
            IF (I .NE. 1) T1 = TEND(I-1)
            IF (I .NE. NPART+1) T2 = TSTRT(I)
            IF (I .EQ. NPART+1) T2 = 1.
            IF (T2-T1 .LT. TDEL) GOTO 20
            AX(1) = XA + T1*XDELT
            AY(1) = YA + T1*YDELT
            AX(2) = XA + T2*XDELT
            AY(2) = YA + T2*YDELT
*            JPNOW=LQ(LQ(JDRAW-3)-5)
*            IF(JPNOW.NE.JPOLD) THEN
*               PRINT*,'JPOLD, JPNEW before 1st GDRAWV ',JPOLD,JPNEW
*               Q(JCG+100000000)=1.
*            ENDIF
            CALL GDRAWV(AX,AY,2)
*            IF(JPNOW.NE.JPOLD) THEN
*               PRINT*,'JPOLD, JPNEW after 1st GDRAWV ',JPOLD,JPNEW
*               Q(JCG+100000000)=1.
*            ENDIF
   20    CONTINUE
         GOTO 40
*           L I N E   I S   F U L L Y   V I S I B L E
   30    CONTINUE
         AX(1) = AA(1)
         AY(1) = AA(2)
         AX(2) = BB(1)
         AY(2) = BB(2)
*            IF(JPNOW.NE.JPOLD) THEN
*               PRINT*,'JPOLD, JPNEW before 2nd GDRAWV ',JPOLD,JPNEW
*               Q(JCG+100000000)=1.
*            ENDIF
         CALL GDRAWV(AX,AY,2)
*            IF(JPNOW.NE.JPOLD) THEN
*               PRINT*,'JPOLD, JPNEW after 2nd GDRAWV ',JPOLD,JPNEW
*               Q(JCG+100000000)=1.
*            ENDIF
   40 CONTINUE
*SG
*      IF(LINFIL.EQ.1)CALL GDRAWV(TESTX,TESTY,0)
*   49 CONTINUE
*SG
   50 RETURN
*
10000    FORMAT('  First word of WIRE less or equal 0 ')
10100    FORMAT(' N. of words of Hidden Structure less or equal 18 ')
*
      END
+SELF.
+DECK,  GDCHIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:21  cernlib
* Geant

      SUBROUTINE GDCHIT (IUSET,IUDET,ITRS,ISYMB,SIZMAX,KDHIT,
     +                   HITMIN,HITMAX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw Calorimetry Hits of track ITRS in detector IUDET    *
C.    *       of set IUSET, in case that the spatial coordinates       *
C.    *       of the HITS had been stored as the first three words     *
C.    *       in the argument vector of GSAHIT.                        *
C.    *                                                                *
C.    *       The following characters may be chosen :                 *
C.    *          ISYMB = -1   hardware character    (fast),            *
C.    *                =  0   crosses X by TVDRAW   (default),         *
C.    *                       (size = SSYMB in cm, default = 0.1),     *
C.    *                = 840  characters by HPLSOF                     *
C.    *                   .   according to the table p. 25             *
C.    *                   .   of the HPLOT manual                      *
C.    *                  853  (size = SSYMB in cm)                     *
C.    *             (844,854  white, black asterisk * in addition).    *
C.    *                                                                *
C.    *       SIZMAX is the maximum character size                     *
C.    *                                                                *
C.    *       KDHIT is the hit number selected : the character size    *
C.    *       is a function of HITS(KDHIT) and HITMIN and HITMAX are   *
C.    *       its limits                                               *
C.    *                                                                *
C.    *                                                                *
C.    *       JH =LQ(JHITS-ISET)                                       *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)=pointer to the LAST USED word in JHD         *
C.    *         Each hit was packed into JHD in the following format:  *
C.    *        --Track number ITRA not packed;                         *
C.    *        --Volume numbers packed;                                *
C.    *        --Hits transformed and packed.                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Authors : R.Brun, P.Zanarini   *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
      DIMENSION HITS(3,10),ASIZE(10)
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('OFF ',IOFF,4,4)
C
C            Set IOBJ to HIT
C
      IOBJ=3
C
      IF (JHITS.LE.0)           GOTO 140
      NSET = IQ(JSET-1)
      NS1        = 1
      NS2        = NSET
      IF (IUSET(1:1).EQ.'*')   GOTO  10
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET .LE.0)           GOTO 140
      NS1        = ISET
      NS2        = ISET
   10 CONTINUE
C
C            loop on all selected sets
C
      DO 130   ISET=NS1,NS2
      JS = LQ(JSET-ISET)
      JH = LQ(JHITS-ISET)
      IF(JS.LE.0)GO TO 130
      IF(JH.LE.0)GO TO 130
      NDET = IQ(JS-1)
      ND1        = 1
      ND2        = NDET
      IF (IUDET(1:1).EQ.'*')   GOTO  20
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF (IDET .EQ.0)   GOTO 130
      ND1        = IDET
      ND2        = IDET
   20 CONTINUE
C
C            loop on selected detectors for this set
C
      DO 120   IDET=ND1,ND2
      JD = LQ(JS-IDET)
      JHD = LQ(JH-IDET)
      IF (JHD  .LE.0)   GOTO 120
      JDH = LQ(JD-1)
      ILAST = IQ(JH+IDET)
      IF (ILAST.EQ.0)   GOTO 120
      NV = IQ(JD+2)
      NH = IQ(JD+4)
      NW = IQ(JD+1) + IQ(JD+3) + 1
C
C            Now loop on all hits to get their space coordinates
C
      MH         = 0
      DO 110   I=1,ILAST,NW
      ITRA = IQ(JHD+I)
C
C            Is this the right track ?
C
      IF (ITRS.NE.0 .AND. ITRS.NE.ITRA) GOTO 110
C
C            Is THRZ option set on (R-Z projection)
C            and the cut lateral (vertical or horizontal) ?
C
      IF (ITHRZ.NE.IOFF) THEN
        IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-ITRA
      ELSE
        ITR3D=0
      ENDIF
C
C            Skip words with volume numbers
C
      NK         = 1
      K          = 1
      IF (NV.LE.0)      GOTO  40
      DO 30   IV=1,NV
      NB = IQ(JD+2*IV+10)
      IF (NB.EQ.0)  NB=32
      K          = NB + K
      IF (K.LE.33)      GOTO  30
      NK         = NK + 1
      K          = NB + 1
   30 CONTINUE
      NK         = NK + 1
C
C            Get unpacked (first three !) HITS.
C            Hits origin is shifted. Division by scale factor.
C
   40 CONTINUE
      IF (NH.LE.2)      GOTO 110
      MH         = MH + 1
C
      IF (KDHIT.GT.3.AND.KDHIT.LE.10) THEN
        KDH=KDHIT
      ELSE
        KDH=3
        HITKH=0.
      ENDIF
C
      K=1
      DO 80   IH=1,KDH
      NB = IQ(JDH+4*IH-2)
      IF (NB.GT.0)      GOTO  50
      IF (K.GT.1) THEN
        NK=NK+1
      ENDIF
      KHIT = IQ(JHD+I+NK)
      K          = 1
      NK         = NK + 1
      GOTO  70
   50 IF (K+NB.LE.33)   GOTO  60
      K          = 1
      NK         = NK + 1
   60 KHIT = IBITS(IQ(JHD+I+NK),K-1,NB)
      K          = K + NB
   70 CONTINUE
      IF (IH.LE.3) THEN
        HITS(IH,MH)= FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
      ELSE
        HITKH=FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
      ENDIF
   80 CONTINUE
C
C             Compute symbol size
C
      IF (HITMAX.LE.0) THEN
        SSYMB=SIZMAX
      ELSE
        SSYMB=SIZMAX*(HITKH-HITMIN)/HITMAX
        IF (SSYMB.GT.SIZMAX) SSYMB=SIZMAX
C
C             HPLSOF accepts a minimum SIZE of 0.001,
C             otherwise set SIZE=0.25 : protect here this case
C
        IF (SSYMB.LT.0.0011) SSYMB=0.0011
      ENDIF
      ASIZE(MH)=SSYMB
C
C            Draw the hits (usually 10 at a time);
C            flush HITS vector if
C             --loop on this detector volume is to finish,
C             --loop on current track is to finish,
C             --HITS vector is full.
C
      IF ((ILAST-I).LT.NW)   GOTO 90
      ITRN = IQ(JHD+I+NW)
      IF (ITRA.NE.ITRN)      GOTO 90
      IF (MH  .NE.  10)      GOTO 110
C
   90 CONTINUE
C
      DO 100 II=1,MH
        CALL GDAHIT(HITS(1,II),HITS(2,II),HITS(3,II),ISYMB,ASIZE(II))
  100 CONTINUE
      MH=0
C
  110 CONTINUE
  120 CONTINUE
  130 CONTINUE
  140 CONTINUE
C
C             Reset ITR3D to 'standard projection'
C
      ITR3D=0
      IOBJ=0
C
      END
+DECK,  GDCIRC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCIRC(R,Z0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a circle of radius R centered on Z-axis,            *
C.    *       at a distance of Z0 from the origin,                     *
C.    *       on a plane parallel to X-Y plane                         *
C.    *                                                                *
C.    *    ==>Called by : GDRAWS                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION X(3,41),U(41),V(41)
C.
C.    ------------------------------------------------------------------
C.
      IF (R.LT.0.0001) GO TO 999
C
      DO 10 I=1,40
         X(1,I)=R*GCOS(I)
         X(2,I)=R*GSIN(I)
         X(3,I)=Z0
   10 CONTINUE
C
      CALL GDFR3D(X,40,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .NE. 0 ) GO TO 999
CM
      U(41)=U(1)
      V(41)=V(1)
      CALL GDRAWV(U,V,41)
C
  999 RETURN
      END
+DECK,  GDCIRR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCIRR(R,THROT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a circle of radius R, centered on the origin,       *
C.    *       on a plane whose normal is parallel to X-Y plane         *
C.    *       with an angle THROT with X-axis                          *
C.    *                                                                *
C.    *    ==>Called by : GDRAWS                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCONSP.
      DIMENSION X(3,41),U(41),V(41)
C.
C.    ------------------------------------------------------------------
C.
      IF (R.LT.0.0001) GO TO 999
C
      GTHROT=THROT*DEGRAD
      STHROT=SIN(GTHROT)
      CTHROT=COS(GTHROT)
C
      DO 10 I=1,40
         X(1,I)=R*GCOS(I)*CTHROT
         X(2,I)=R*GSIN(I)
         X(3,I)=R*GCOS(I)*STHROT
   10 CONTINUE
C
      CALL GDFR3D(X,40,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .NE. 0 ) GO TO 999
CM
      U(41)=U(1)
      V(41)=V(1)
      CALL GDRAWV(U,V,41)
C
  999 RETURN
      END
+DECK,  GDCIRY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCIRY(R,Y0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a circle of radius R centered on Y-axis,            *
C.    *       at a distance of Y0 from the origin,                     *
C.    *       on a plane parallel to X-Z plane                         *
C.    *                                                                *
C.    *    ==>Called by : GDRAWS                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION X(3,41),U(41),V(41)
C.
C.    ------------------------------------------------------------------
C.
      IF (R.LT.0.0001) GO TO 999
C
      DO 10 I=1,40
         X(1,I)=R*GCOS(I)
         X(2,I)=Y0
         X(3,I)=R*GSIN(I)
   10 CONTINUE
C
      CALL GDFR3D(X,40,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .NE. 0 ) GO TO 999
CM
      U(41)=U(1)
      V(41)=V(1)
      CALL GDRAWV(U,V,41)
C
  999 RETURN
      END
+DECK,  GDCLOS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Close last view bank opened and reset IVIEW to 0,        *
C.    *       meaning screen; a release of unused space in             *
C.    *       view banks is also done by negative pushing              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
C             If current view is screen don't do anything
C
      IF (IDVIEW.EQ.0) GO TO 999
C
C             Close view number IDVIEW
C
      JV=LQ(JDRAW-IDVIEW)
C
C             Store parameters for that view, i.e. logical (I..)
C             and phisical (MAX..) length of view banks
C
      Q(JV+1)=IGU
C---  Q(JV+2)=MAXGU
      Q(JV+4)=IGS
C---  Q(JV+5)=MAXGS
      Q(JV+7)=ITU
C---  Q(JV+8)=MAXTU
      Q(JV+10)=ITS
C---  Q(JV+11)=MAXTS
C
      Q(JV+22)=ICUT
C
C             Release unused space
C
      ND1=MAXGU-IGU
      ND2=ND1
      ND3=MAXTU-ITU
      ND4=MAXGS-IGS
      ND5=ND4
      ND6=MAXTS-ITS
      JV = LQ(JV-1)
      CALL MZPUSH(IXCONS,JV,0,-ND1,'I')
      JV = LQ(JDRAW-IDVIEW)
      JV = LQ(JV-2)
      CALL MZPUSH(IXCONS,JV,0,-ND2,'I')
      JV = LQ(JDRAW-IDVIEW)
      JV = LQ(JV-3)
      CALL MZPUSH(IXCONS,JV,0,-ND3,'I')
      JV = LQ(JDRAW-IDVIEW)
      JV = LQ(JV-4)
      CALL MZPUSH(IXCONS,JV,0,-ND4,'I')
      JV = LQ(JDRAW-IDVIEW)
      JV = LQ(JV-5)
      CALL MZPUSH(IXCONS,JV,0,-ND5,'I')
      JV = LQ(JDRAW-IDVIEW)
      JV = LQ(JV-6)
      CALL MZPUSH(IXCONS,JV,0,-ND6,'I')
C
C             Reset view number to 0 (screen)
C
      IDVIEW=0
C
  999 RETURN
      END
+DECK,  GDCOL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCOL(ICOL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Set line color to ICOL                                   *
C.    *                                                                *
C.    *       if ICOL > 0 set color temporarily                        *
C.    *       if ICOL < 0 set color permanently                        *
C.    *       if ICOL = 0 restore permanent color value                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDHEAD, GDRAW, GDSPEC,GDXYZ *
C.    *       Author : P.Zanarini ; S.Giani  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      KCOL=MOD(IABS(ICOL),16)
      IF (ICOL.EQ.0) THEN
         CALL MVBITS(LINATP,16,4,LINATT,16)
         CALL MVBITS(LINATP,16,4,ITXATT,3)
      ELSE IF (ICOL.GT.0) THEN
         CALL MVBITS(KCOL,0,4,LINATT,16)
         CALL MVBITS(KCOL,0,4,ITXATT,3)
      ELSE
         CALL MVBITS(KCOL,0,4,LINATT,16)
         CALL MVBITS(KCOL,0,4,LINATP,16)
         CALL MVBITS(KCOL,0,4,ITXATT,3)
      ENDIF
      END
+DECK,  GDCOL1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCOL1(ICOL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Change the line color to ICOL                            *
C.    *                                                                *
C.    *       The color table is :                                     *
C.    *                                                                *
C.    *       1 = White (Black is suggested for paper outputs)         *
C.    *       2 = Red                                                  *
C.    *       3 = Green                                                *
C.    *       4 = Blue                                                 *
C.    *                                                                *
C.    *       5 = Yellow                                               *
C.    *       6 = Cyan                                                 *
C.    *       7 = Magenta                                              *
C.    *       8 = Orange                                               *
C.    *                                                                *
C.    *    ==>Called by : GDRAWP, GDRAWT                               *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
C
      SAVE IOLD
      DATA IOLD/-1/
C.
C.    ------------------------------------------------------------------
C.
      LCOL=MOD(IABS(ICOL),16)
      KCOL=LOOKTB(LCOL)
C
      IF (KCOL.NE.IOLD) THEN
         IOLD=KCOL
         CALL ISPLCI(KCOL)
         CALL ISTXCI(KCOL)
         CALL ISPMCI(KCOL)
         CALL ISFACI(KCOL)
      ENDIF
      END
+DECK,  GDCOTA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

+SELF, IF=CG.
      SUBROUTINE GDCOTA
*
**********************************************************************
*                                                                    *
* RAY-TRACING                                                        *
* Function: Create colour's code table for ray-tracing and CG        *
*                                                                    *
* Author: S. Giani                                                   *
*                                                                    *
**********************************************************************
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCFLAG.
*
      PARAMETER (NLSHAD=25,HINCRM=0.5/NLSHAD)
* red
      ID=16
      SL=0.2
      DO 10 I=1,NLSHAD
         ID=ID+1
         SL=SL+HINCRM
         CALL IGHTOR(0.,SL,.9,R,G,B)
         CALL ISCR(1,ID,R,G,B)
   10 CONTINUE
* yellow
      ID=41
      SL=0.2
      DO 20 I=1,NLSHAD
         ID=ID+1
         SL=SL+HINCRM
         CALL IGHTOR(60.,SL,.9,R,G,B)
         CALL ISCR(1,ID,R,G,B)
   20 CONTINUE
* green
      ID=66
      SL=0.2
      DO 30 I=1,NLSHAD
         ID=ID+1
         SL=SL+HINCRM
         CALL IGHTOR(120.,SL,.9,R,G,B)
         CALL ISCR(1,ID,R,G,B)
   30 CONTINUE
* light blue
      ID=91
      SL=0.2
      DO 40 I=1,NLSHAD
         ID=ID+1
         SL=SL+HINCRM
         CALL IGHTOR(180.,SL,.9,R,G,B)
         CALL ISCR(1,ID,R,G,B)
   40 CONTINUE
* blue
      ID=116
      SL=0.2
      DO 50 I=1,NLSHAD
         ID=ID+1
         SL=SL+HINCRM
         CALL IGHTOR(240.,SL,.9,R,G,B)
         CALL ISCR(1,ID,R,G,B)
   50 CONTINUE
* violet
      ID=141
      SL=0.2
      DO 60 I=1,NLSHAD
         ID=ID+1
         SL=SL+HINCRM
         CALL IGHTOR(300.,SL,.9,R,G,B)
         CALL ISCR(1,ID,R,G,B)
   60 CONTINUE
*
  999 END
+SELF.
+DECK,  GDCURS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCURS(U0,V0,MCHAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       When this routine is called in interactive               *
C.    *       version of GEANT3 and with PIGS or GKS option set,       *
C.    *       it draws on screen the present position of the cursor,   *
C.    *       then moving UP-DOWN and LEFT-RIGHT arrows (or similars)  *
C.    *       the user goes on the screen point he wants be selected   *
C.    *       and press a key (but not <CR>) to hold that point.       *
C.    *       If the user types <CR>, it has to press a key again.     *
C.    *       The routine returns then in U0,V0 the user coordinates   *
C.    *       of the graphics cursor, and in MCHAR the ascii value     *
C.    *       of the key pressed.                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDTREE                      *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C
C.    ------------------------------------------------------------------
C.
*
* Request the locator position
*
      CALL IRQLC(1,1,ISTAT,ITNR,U0,V0)
      MCHAR=ISTAT
      END
+DECK,  GDCUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCUT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the 4 lines obtained by the intersection            *
C.    *       of the cut plane (at point DCUT along axis ICUT) and     *
C.    *       the NSURF surfaces stored in vector SURF.                *
C.    *       DCUT, ICUT, NSURF, SURF are in common block GCDRAW.      *
C.    *                                                                *
C.    *    ==>Called by : GDRWSC, GDSSUR                               *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
      DIMENSION SURF(2)
      EQUIVALENCE (WS(1),SURF(1))
      DIMENSION P(3,2),U(2),V(2),XI(2),YI(2),ZI(2),PL(3),PR(3)
      EQUIVALENCE (PL(1),XL),(PL(2),YL),(PL(3),ZL)
      EQUIVALENCE (PR(1),XR),(PR(2),YR),(PR(3),ZR)
C
      SAVE EPS,ICUT3
      DATA EPS/0.00001/
C.
C.    ------------------------------------------------------------------
C.
C     Let be L(XL,YL,ZL) and R(XR,YR,ZR) the extreme points of a line,
C     I(XI,YI,ZI) the intersection point between the line and
C     the cut-plane (for example Z=C, i.e. the plane normal to Z axis).
C     Then we have:
C
C
C                       (XR-XL)               (XR-XL)
C     XI = XL + (ZI-ZL) ------- = XL + (C-ZL) -------
C                       (ZR-ZL)               (ZR-ZL)
C
C
C                       (YR-YL)               (YR-YL)
C     YI = YL + (XI-XL) ------- = YL + (C-XL) -------
C                       (XR-XL)               (XR-XL)
C
C
C     ZI = C
C
C
C     Then we have two cases:
C
C     1.   ZL <= ZI <= ZR
C          i.e. the cut-plane intersects the line at I(XI,YI,ZI) :
C          a line is drawn between that point and next one
C
C     2.   ZL = ZR
C          i.e. the line is parallel to (or into) the cut-plane :
C          any line is drawn
C
C
      IF (NSURF.EQ.0) GO TO 80
C
      IF (ICUT.EQ.0) THEN
         ICUT3=3
         ICUT=3
      ELSE
         ICUT3=0
      ENDIF
C
      IF (ICUT.LT.1.OR.ICUT.GT.3) GO TO 80
C
      DO 70  I=1,NSURF
C
         ISTART=12*(I-1)+1
         J=0
C
         DO 40 L=1,4
C
            IL=ISTART+(L-1)*3
            IR=IL+3
            IF (L.EQ.4) IR=ISTART
            XL=SURF(IL)
            YL=SURF(IL+1)
            ZL=SURF(IL+2)
            XR=SURF(IR)
            YR=SURF(IR+1)
            ZR=SURF(IR+2)
C
            IF (ICUT3.GT.0) THEN
C
C             Transform PL and PR to have Z-axis = line of sight CTHETA,
C
               SAVTHE=GTHETA
               SAVPHI=GPHI
               GTHETA=CTHETA
               GPHI=CPHI
               NGVIEW=0
               CALL GD3D3D(PL,-1,PL,0)
               CALL GD3D3D(PR,-1,PR,0)
               GTHETA=SAVTHE
               GPHI=SAVPHI
               NGVIEW=0
C
            ENDIF
C
C             Is the line parallel to the cut-plane ?
C
            IF ((PL(ICUT).GE.PR(ICUT)-EPS).AND.(PL(ICUT).LE.PR(ICUT)+
     +      EPS)) GO TO 40
C
C             No, it isn't
C
            AMX=MAX(PL(ICUT),PR(ICUT))
            AMN=MIN(PL(ICUT),PR(ICUT))
            IF ((DCUT.LT.AMN).OR.(DCUT.GT.AMX)) GO TO 40
C
            J=J+1
C
            IF (ICUT.NE.3) GO TO 10
            XI(J)=XL+(DCUT-ZL)*(XR-XL)/(ZR-ZL)
            YI(J)=YL+(DCUT-ZL)*(YR-YL)/(ZR-ZL)
            ZI(J)=DCUT
            GO TO 30
C
   10       IF (ICUT.NE.1) GO TO 20
            XI(J)=DCUT
            YI(J)=YL+(DCUT-XL)*(YR-YL)/(XR-XL)
            ZI(J)=ZL+(DCUT-XL)*(ZR-ZL)/(XR-XL)
            GO TO 30
C
   20       CONTINUE
            XI(J)=XL+(DCUT-YL)*(XR-XL)/(YR-YL)
            YI(J)=DCUT
            ZI(J)=ZL+(DCUT-YL)*(ZR-ZL)/(YR-YL)
C
   30       IF (J.EQ.2) GO TO 50
C
   40    CONTINUE
C
         IF (J.LT.2) GO TO 70
C
   50    CONTINUE
         DO 60 IND=1,2
            P(1,IND)=XI(IND)
            P(2,IND)=YI(IND)
            P(3,IND)=ZI(IND)
   60    CONTINUE
C
         IF (ICUT3.GT.0) THEN
C
C             Transform back P
C
            SAVTHE=GTHETA
            SAVPHI=GPHI
            GTHETA=CTHETA
            GPHI=CPHI
            NGVIEW=0
            CALL GD3D3D(P(1,1),-2,P(1,1),1)
            GTHETA=SAVTHE
            GPHI=SAVPHI
            NGVIEW=0
C
         ENDIF
C
C             Points are now in general reference system
C
         CALL GDFR3D(P,-2,U,V)
C
CM             Short circuit in case of GMR
C
         IF ( IGMR .EQ. 0 ) CALL GDRAWV(U,V,2)
CM
   70 CONTINUE
C
   80 CONTINUE
C
      IF (ICUT3.GT.0) THEN
         ICUT3=0
         ICUT=0
      ENDIF
C
      NSURF=0
      ISURF=1
C
      END
+DECK,  GDCXYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDCXYZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Online display of the track trajectory                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors : R.Brun, P.Zanarini, S.Giani  ****              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCKINE.
+CDE, GCSTAK.
+CDE, GCTRAK.
      PARAMETER (NTRTYP=8)
      DIMENSION UU(2),VV(2)
      DIMENSION MODE(NTRTYP),KCOLO(NTRTYP),VOLD(3)
      SAVE MODE,KCOLO,IFIRST,IOFF,ILINE,UU,VV
      DATA MODE /3, 1, 4, 1, 2, 1, 1, 1/
      DATA KCOLO/4, 2, 1, 2, 3, 1, 6, 6/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
*      IF(SLENG.GT.0..AND.STEP.LT.0.1)RETURN
      IF(IFIRST.EQ.0)THEN
         CALL UCTOH('OFF ',IOFF,4,4)
         CALL UCTOH('LINE',ILINE,4,4)
         IFIRST=1
      ENDIF
C
C             Set IOBJ to TRACK
C
      IOBJ=2
C
C             Is THRZ option set on (R-Z projection)
C             and the cut lateral (vertical or horizontal) ?
C
      IF (ITHRZ.NE.IOFF) THEN
         IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-ITRA
      ELSE
         ITR3D=0
      ENDIF
      ICOL=KCOLO(ITRTYP)
      KCOL=LOOKTB(ICOL)
C
      IF(NJTMAX.EQ.0)THEN
*
*            Normal sequential tracking
         IF(SLENG.LE.0.)THEN
            CALL GDFR3D(VECT,1,UU(1),VV(1))
            IF (ITRKOP.NE.ILINE) THEN
               CALL IGPID(1,'Kine',ITRA,' ')
               CALL IPM(1,UU,VV)
            ENDIF
         ELSE
            CALL GDFR3D(VECT,1,UU(2),VV(2))
            IF (ITRKOP.EQ.ILINE) THEN
               CALL ISPLCI(KCOL)
               CALL ISLN(MODE(ITRTYP))
               CALL IGPID(1,'Kine',ITRA,' ')
               CALL IPL(2,UU,VV)
            ELSE
               CALL IGPID(1,'Kine',ITRA,' ')
               CALL IPM(1,UU(2),VV(2))
            ENDIF
            UU(1)=UU(2)
            VV(1)=VV(2)
         ENDIF
      ELSE
*
*            Parallel tracking
         CALL GDFR3D(VECT,1,UU(2),VV(2))
         IF (ITRKOP.NE.ILINE) THEN
            CALL IGPID(1,'Kine',ITRA,' ')
            CALL IPM(1,UU(2),VV(2))
         ELSE
            CALL ISPLCI(KCOL)
            CALL ISLN(MODE(ITRTYP))
            VOLD(1)=VECT(1)-STEP*VECT(4)
            VOLD(2)=VECT(2)-STEP*VECT(5)
            VOLD(3)=VECT(3)-STEP*VECT(6)
            CALL GDFR3D(VOLD,1,UU(1),VV(1))
            CALL IGPID(1,'Kine',ITRA,' ')
            CALL IPL(2,UU,VV)
            IF (MODE(ITRTYP).NE.1) CALL ISLN(1)
         ENDIF
      ENDIF
C
C             Reset ITR3D to 'standard projection'
C
      ITR3D=0
      IOBJ=0
C
      END
+DECK,  GDELET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:22  cernlib
* Geant

      SUBROUTINE GDELET(IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Delete view number IVIEW from view banks                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDTR0, GDTR99               *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      IF (IVIEW.GE.1.AND.IVIEW.LE.NKVIEW) THEN
         IF (LQ(JDRAW-IVIEW).NE.0) THEN
            IF (Q(JDRAW+IVIEW).NE.3.) THEN
               Q(JDRAW+IVIEW)=1.
               CALL MZDROP(IXCONS,LQ(JDRAW-IVIEW),' ')
*
*             Reset view number to 0 (screen)
               IF (IDVIEW.EQ.IVIEW) IDVIEW = 0
*
            ELSE
               WRITE (CHMAIL,10000)
               CALL GMAIL(0,0)
*
            ENDIF
*
         ENDIF
*
      ENDIF
10000 FORMAT (' ERROR IN GDELET: CANNOT DELETE PROTECTED VIEW')
      END
+DECK,  GDELTU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDELTU(A,B,Z0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw an ellipse of semi-axes A and B centered            *
C.    *       on Z-axis,at a distance of Z0 from the origin,           *
C.    *       on a plane parallel to X-Y plane                         *
C.    *                                                                *
C.    *    ==>Called by : GDRAWS                                       *
C.    *       Author : A.Solano                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION X(3,41),U(41),V(41)
C.
C.    ------------------------------------------------------------------
C.
      IF (A.LT.0.0001.AND.B.LT.0.0001) GO TO 999
C
      DO 10 I=1,40
        X(1,I)=A*GCOS(I)
        X(2,I)=B*GSIN(I)
        X(3,I)=Z0
   10 CONTINUE
C
      CALL GDFR3D(X,40,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .NE. 0 ) GO TO 999
CM
      U(41)=U(1)
      V(41)=V(1)
      CALL GDRAWV(U,V,41)
C
  999 RETURN
      END

+DECK,  GDFR3D, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDFR3D(X,NPOINT,U,V)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to convert the N 3D points given by array X      *
C.    *       to the 2D points in U and V                              *
C.    *                                                                *
C.    *       If IGMR=1 then 3D points are not projected onto          *
C.    *       U-V plane but used to build the APOLLO-GMR 3D structure  *
C.    *                                                                *
C.    *       ITR3D  = 0 for standard projection;                      *
C.    *             <> 0 for rotation + projection i.e. R-Z projection *
C.    *                 with sign of R located in ITRSGN [ITR3D]       *
C.    *                                                                *
C.    *                                                                *
C.    *       Steps from 3D to 2D when NPOINT>0 :                      *
C.    *                                                                *
C.    *       a) for volumes (IOBJ=1) :                                *
C.    *          transformation of the 3D point (x',y',z') in DRS      *
C.    *          (Daughter Reference System) into the 3D point (x,y,z) *
C.    *          in MARS (MAster Reference System);                    *
C.    *                                                                *
C.    *          for tracks/hits (IOBJ<>1) after GDRVOL with NRS<>0 :  *
C.    *          transformation of the 3D point (x',y',z') in MARS     *
C.    *          into the 3D point (x,y,z) in DRS;                     *
C.    *                                                                *
C.    *          for tracks/hits (IOBJ<>1) after GDRAW/GDRAWC :   *
C.    *          nothing                                               *
C.    *                                                                *
C.    *       b) transformation of the 3D point (x,y,z) in MARS/DRS    *
C.    *          into the 3D point (xx,yy,zz) in PRS (Projection       *
C.    *          Reference System); PRS has its z axis along           *
C.    *          the observer's line of sight (going to into the eye)  *
C.    *                                                                *
C.    *       c) transformation of the 3D point (xx,yy,zz) in PRS      *
C.    *          into the 2D point (u,v) in the plane normal to the    *
C.    *          observer's line of sight; at that stage if ITR3D=0    *
C.    *          (standard projection) then u=xx and v=yy,             *
C.    *          but if ITR3D <> 0 (rotation + projection i.e. R-Z)    *
C.    *          then the 3D point (xx,yy,zz) in PRS is rotated along  *
C.    *          xx axis until it is onto the xx-yy plane and finally  *
C.    *          u=xx (unchanged by the rotation) and v=yy             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GDAHIT, GDARC, GDAXIS, GDCIRC,       *
C.    *                   GDCIRR, GDCIRY, GDCUT, GDCXYZ, GDLINE,       *
C.    *                   GDPART, GDRECT, GDSURF, GDXYZ                *
C.    *       Authors : R.Brun, P.Zanarini   *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVOLU.
+CDE, GCDRAW.
      DIMENSION XC(3),XYZ(3),VL(3),VM(3),VN(3),X(3,1),U(1),V(1)
      DIMENSION XP(3,50)
      SAVE VL,VM,VN
C
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('PERS',IPERS,4,4)
C
      IF(NPOINT.EQ.0)GO TO 100
      N=NPOINT
      IF(NPOINT.LT.0)N=-NPOINT
      IF(NGVIEW.NE.0) GO TO 40
C
C             First call compute the rotation matrix
C
      PH     = ABS(MOD(GPHI,360.))
      THET   = ABS(MOD(GTHETA,360.))
      IF(THET.LE.180.)GO TO 10
      PH     = PH + 180.
      THET   = 360. - THET
C
   10 ST     = SIN(THET * 0.017453)
      CT     = COS(THET * 0.017453)
      SP     = SIN(PH * 0.017453)
      CP     = COS(PH * 0.017453)
C
C             VN is new nu axis
C
      VN(1)  = ST * CP
      VN(2)  = ST * SP
      VN(3)  = CT
C
      IF(ABS(VN(2)).GT.0.99999)GO TO 20
C
      VM(1)  = 0.
      VM(2)  = 1.
      VM(3)  = 0.
C
C             Define new lambda axis
C
      CALL CROSS(VM,VN,VL)
      CALL VUNIT(VL,VL,3)
C
C             Define new mu axis
C
      CALL CROSS(VN,VL,VM)
      GO TO 30
C
C             Special case when observer line of sight is along mu:
C             in this case one chooses arbitrarily the vertical axis of
C             plane of projection as the lambda axis and the horizontal
C             as the nu axis
C
   20 VL(1)  = 0.
      VL(2)  = 0.
      VL(3)  = 1.
      VM(1)  = 1.
      VM(2)  = 0.
      VM(3)  = 0.
   30 CONTINUE
C
      NGVIEW=1
C
   40 CONTINUE
C
C             Begin of a call with viewing tranformation unchanged (NGVI
C
      DO 90  I=1,N
C
         IF (NPOINT.LT.0) THEN
C
C             NPOINT < 0 : X is in MARS
C
            IF (IGMR.EQ.1) THEN
               DO 50  J=1,3
   50          XP(J,I)=X(J,I)
               GO TO 90
            ENDIF
C
C             Transform X (MARS) in XYZ (PRS)
C             i.e. project onto U,V,W
C
            XYZ(1)=X(1,I)*VL(1)+X(2,I)*VL(2)+X(3,I)*VL(3)
            XYZ(2)=X(1,I)*VM(1)+X(2,I)*VM(2)+X(3,I)*VM(3)
            XYZ(3)=X(1,I)*VN(1)+X(2,I)*VN(2)+X(3,I)*VN(3)
C
         ELSE
C
            IF (IOBJ.NE.1) THEN
C
C             NPOINT > 0 and IOBJ <> 1 : X belongs to a track or hit or
C             so it must be transformed from MARS to last DRS used by GD
C             (otherwise GTRAN0 and GRMAT0 are the unitary transformatio
C             and X is still expressed in MARS)
C
               CALL GTRNSF(X(1,I),GTRAN0,GRMAT0,XC)
C
            ELSE
C
C             NPOINT > 0 and IOBJ = 1 : X belongs to a volume,
C             so it must be transformed from DRS to MARS
C
               CALL GINROT(X(1,I),GRMAT(1,NLEVEL),XC)
               DO 60  J=1,3
   60          XC(J)=XC(J)+GTRAN(J,NLEVEL)
C
            ENDIF
C
            IF (IGMR.EQ.1) THEN
               DO 70  J=1,3
   70          XP(J,I)=XC(J)
               GO TO 90
            ENDIF
C
C             Transform XC (MARS or DRS) in XYZ (PRS)
C             i.e. project onto U,V,W
C
            XYZ(1)=XC(1)*VL(1)+XC(2)*VL(2)+XC(3)*VL(3)
            XYZ(2)=XC(1)*VM(1)+XC(2)*VM(2)+XC(3)*VM(3)
            XYZ(3)=XC(1)*VN(1)+XC(2)*VN(2)+XC(3)*VN(3)
C
         ENDIF
C
C             Scale, shift and rotate in in U and V
C
   80    CONTINUE
C
C             R-Z projection ?
C
         IF (ITR3D.NE.0) CALL GDTHRZ(XYZ)
C
C             Perspective projection ?
C
         IF (IPRJ.EQ.IPERS) THEN
            IF (XYZ(3).GE.DPERS) XYZ(3)=DPERS-0.0001
            XYZ(1)=XYZ(1)*DPERS/(DPERS-XYZ(3))
            XYZ(2)=XYZ(2)*DPERS/(DPERS-XYZ(3))
         ENDIF
C
         UU=XYZ(1)*GSCU
         VV=XYZ(2)*GSCV
         U(I)=GU0+UU*COSPSI-VV*SINPSI
         V(I)=GV0+UU*SINPSI+VV*COSPSI
C
C             Zoom processing
C
         U(I)=U(I)*GZUA+GZUB+GZUC
         V(I)=V(I)*GZVA+GZVB+GZVC
C
   90 CONTINUE
C
      IF (IGMR.EQ.1) CALL GM3POL(XP,N)
C
  100 CONTINUE
      END
+DECK,  GDFSPC, T=FORT.
* Revision 1.2  1998/09/25 09:23:48  mclareni
* Modifications for the Mklinux port flagged by CERNLIB_PPC
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDFSPC(NAME,ISORT,INTER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a set of full specification of KNAME                *
C.    *       and all its sons (not duplicated);                       *
C.    *       if ISORT=1 plots will be alfabetically sorted;           *
C.    *       if INTER=1 it will prompt the user at each plot          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCBANK.
+CDE, GCNUM.
      LOGICAL MORE
      CHARACTER*4 CHKEY,NAME,NAME1,NAMOLD
C.
C.    ------------------------------------------------------------------
C.
C             Is NAME an existing volume ?
C
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF (IVO.LE.0) GO TO 999
C
C             Build tree structure using view bank 11
C
      IVTREE=NKVIEW+1
      CALL UCTOH (NAME, IROOT, 4, 4)
      CALL GDTR0 (IVTREE, IROOT, 0, IER)
      IF (IER.NE.0) GO TO 999
C
      JN=1
C
      DO 10 J=2,NUMND1
         IQ(JSCA1+J)=0
   10 CONTINUE
C
      IQ(JSCA1+1)=JN
      JMAX=1
      J=1
   20 CONTINUE
      JX=IQ(JXON1+IQ(JSCA1+J))
   30 IF (JX.EQ.0) GO TO 40
      JMAX=JMAX+1
      IQ(JSCA1+JMAX)=JX
      JX=IQ(JBRO1+JX)
      GO TO 30
   40 J=J+1
      IF (J.LE.JMAX) GO TO 20
C
      DO 50 I=1,JMAX
         IQ(JSCA1+I)=IQ(JNAM1+IQ(JSCA1+I))
   50 CONTINUE
C
      IF (ISORT.NE.1) GO TO 110
+SELF, IF=VAX,MSDOS,WINNT,LINUX, IF=-PPC.
C
C             Reverse bytes of word to be sorted
C
      CALL VXINVB(IQ(JSCA1+1),JMAX)
+SELF.
C
C             Perform bubble sort on names in ISCA1 (ascending order)
C
      NEXLAS=JMAX-1
      MORE=.TRUE.
C
   70 CONTINUE
      IF (.NOT.MORE) GO TO 90
      MORE=.FALSE.
      DO 80  I=1,NEXLAS
         IF (IQ(JSCA1+I).LE.IQ(JSCA1+I+1)) GO TO 80
         ITEMP=IQ(JSCA1+I)
         IQ(JSCA1+I)=IQ(JSCA1+I+1)
         IQ(JSCA1+I+1)=ITEMP
         MORE=.TRUE.
   80 CONTINUE
      GO TO 70
C
   90 CONTINUE
+SELF, IF=VAX,MSDOS,WINNT,LINUX, IF=-PPC.
C
C             Reverse bytes of words that have been sorted
C
      CALL VXINVB(IQ(JSCA1+1),JMAX)
+SELF.
C
C             Draw specs stored in ISCA1
C
  110 CONTINUE
      NAMOLD=' '
      DO 120 I=1,JMAX
         KNAME=IQ(JSCA1+I)
         CALL UHTOC(KNAME,4,NAME1,4)
         IF (NAME1.EQ.NAMOLD) GO TO 120
         NAMOLD=NAME1
         WRITE (CHMAIL,1000) NAME1
         CALL GMAIL(0,0)
         CHKEY=' '
         NCH=0
         IF (INTER.EQ.1) THEN
            CALL IGTERM
            CALL KUALFA
            CALL KUPROC('<CR>, NO, STOP',CHKEY,NCH)
            IF (CHKEY.EQ.'STOP') GO TO 999
         ENDIF
         CALL ICLRWK(0,0)
         IF (NCH.GT.0) GO TO 120
         CALL GDSPEC(NAME1)
  120 CONTINUE
C
C             Delete tree structure on view bank 11
C
      CALL GDTR99(IVTREE)
C
 1000 FORMAT (' DRAWING SPEC OF ',A4)
  999 RETURN
      END
+DECK,  GDHEAD, T=FORT.
* Revision 1.2  1999/09/15 16:09:33  mclareni
* Change In to In.m in Formats to improve the appearance of date and time in Y2k
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDHEAD(ISEL,NAME,CHRSIZ)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This routine draws a graphics header.                    *
C.    *       NAME is an hollerith string terminated by a dollar sign. *
C.    *                                                                *
C.    *       Different options can be chosen by the parameter ISEL :  *
C.    *       =0 to have only the header lines                         *
C.    *       =xxxxx1 to add the text NAME centered on top of header   *
C.    *       =xxxx1x to add global detector name (first vol.) on left *
C.    *       =xxx1xx to add date on right                             *
C.    *       =xx1xxx to select thick characters for NAME (i.e. with   *
C.    *               larger line width)                               *
C.    *       =x1xxxx to add the text 'Event NR x' on top of header    *
C.    *       =1xxxxx to add the text 'Run NR x' on top of header      *
C.    *                                                                *
C.    *       A negative value of ISEL means special headers, i.e.     *
C.    *       directly used by GEANT3 routines :                       *
C.    *       =-1 : GDSPEC header                                      *
C.    *       =-3 : VIEWXY header                                      *
C.    *       =-4 : VIEWYZ header                                      *
C.    *       =-5 : VIEWXZ header                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC, GDTREE              *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCDRAW.
+CDE, GCTIME.
C
      DIMENSION UH(5),VH(5),UHH(2),VHH(2)
      DIMENSION UH1(5),VH1(5),UHH1(2),VHH1(2)
      CHARACTER*9 CHDATE
      CHARACTER*4 CHTEXT
      CHARACTER*(*) NAME
C
      SAVE UH1,VH1,UHH1,VHH1
C
      DATA UH1/0.1,0.1,19.9,19.9,0.1/
      DATA VH1/19.9,0.1,0.1,19.9,19.9/
      DATA UHH1/0.1,19.9/
      DATA VHH1/18.5,18.5/
C.
C.    ------------------------------------------------------------------
C.
C             Normalize to PLTRNX,PLTRNY
C
      DO 10 I=1,5
         UH(I)=UH1(I)*PLTRNX/20.
         VH(I)=VH1(I)*PLTRNY/20.
   10 CONTINUE
      DO 20 I=1,2
         UHH(I)=UHH1(I)*PLTRNX/20.
         VHH(I)=VHH1(I)*PLTRNY/20.
   20 CONTINUE
C
      IF (ISEL.GE.0) THEN
         ISEL5=ISEL/100000
         ISEL5=ISEL5-ISEL5/2*2
         ISEL4=ISEL/10000
         ISEL4=ISEL4-ISEL4/2*2
         ISEL3=ISEL/1000
         ISEL3=ISEL3-ISEL3/2*2
         ISEL2=ISEL/100
         ISEL2=ISEL2-ISEL2/2*2
         ISEL1=ISEL/10
         ISEL1=ISEL1-ISEL1/2*2
         ISEL0=ISEL/1
         ISEL0=ISEL0-ISEL0/2*2
      ENDIF
C
      CALL GDCOL(1)
      CALL GDLW(2)
      CALL GDRAWV(UH,VH,5)
      IF (ISEL.EQ.0) THEN
         CALL GDLW(0)
         GO TO 30
      ENDIF
      CALL GDRAWV(UHH,VHH,2)
      CALL GDLW(0)
      IF (ISEL.LT.0.OR.ISEL1.NE.0) THEN
         CALL UHTOC(IQ(JVOLUM+1),4,CHTEXT,4)
         XTEXT=1.*PLTRNX/20.
         YTEXT=19.*PLTRNY/20.
         CSIZE=0.3*MIN(PLTRNX,PLTRNY)/20.
         CALL GDRAWT(XTEXT,YTEXT,CHTEXT,CSIZE,0.,1,-1)
      ENDIF
      IF (ISEL3.NE.0) THEN
         LWDTH=2
      ELSE
         LWDTH=1
      ENDIF
      IF (ISEL0.NE.0) THEN
         CALL GDCOL(4)
         XTEXT=10.*PLTRNX/20.
         YTEXT=19.*PLTRNY/20.
         CSIZE=CHRSIZ*MIN(PLTRNX,PLTRNY)/20.
         CALL GDRAWT(XTEXT,YTEXT,NAME,CSIZE,0.,LWDTH,0)
         CALL GDCOL(1)
      ENDIF
      IF (ISEL.GT.0) THEN
         IF (ISEL4.NE.0) THEN
            XTEXT=7.*PLTRNX/20.
            YTEXT=18.7*PLTRNY/20.
            CSIZE=0.3*MIN(PLTRNX,PLTRNY)/20.
            CALL GDRAWT(XTEXT,YTEXT,'EVENT',CSIZE,0.,LWDTH,-1)
            XTEXT=9.*PLTRNX/20.
            CALL GDRAWT(XTEXT,YTEXT,'NR',CSIZE,0.,LWDTH,-1)
*
            CHDATE=' '
            WRITE (CHDATE,'(I6)') IDEVT
            XTEXT=12.*PLTRNX/20.
            YTEXT=18.7*PLTRNY/20.
            CSIZE=0.3*MIN(PLTRNX,PLTRNY)/20.
            CALL GDRAWT(XTEXT,YTEXT,CHDATE,CSIZE,0.,LWDTH,1)
         ENDIF
         IF (ISEL5.NE.0) THEN
            XTEXT=7.*PLTRNX/20.
            YTEXT=19.2*PLTRNY/20.
            CSIZE=0.3*MIN(PLTRNX,PLTRNY)/20.
            CALL GDRAWT(XTEXT,YTEXT,'RUN',CSIZE,0.,LWDTH,-1)
            XTEXT=9.*PLTRNX/20.
            CALL GDRAWT(XTEXT,YTEXT,'NR',CSIZE,0.,LWDTH,-1)
*
            CHDATE=' '
            WRITE (CHDATE,'(I6)') IDRUN
            XTEXT=12.*PLTRNX/20.
            YTEXT=19.2*PLTRNY/20.
            CSIZE=0.3*MIN(PLTRNX,PLTRNY)/20.
            CALL GDRAWT(XTEXT,YTEXT,CHDATE,CSIZE,0.,LWDTH,1)
         ENDIF
      ELSE
         IF (ISEL.EQ.-1) THEN
            CALL GDCOL(4)
            XTEXT=8.5*PLTRNX/20.
            YTEXT=19.*PLTRNY/20.
            CSIZE=0.6*MIN(PLTRNX,PLTRNY)/20.
            CALL GDRAWT(XTEXT,YTEXT,NAME,CSIZE,0.,2,1)
            CALL GDCOL(1)
            XTEXT=9.*PLTRNX/20.
            YTEXT=19.*PLTRNY/20.
            CSIZE=0.4*MIN(PLTRNX,PLTRNY)/20.
            CALL GDRAWT(XTEXT,YTEXT,'<SPECIFICATIONS',CSIZE,0.,1,-1)
         ELSE IF (ISEL.EQ.-3) THEN
            CALL GDCOL(4)
            XTEXT=10.*PLTRNX/20.
            YTEXT=19.*PLTRNY/20.
            CSIZE=0.5*MIN(PLTRNX,PLTRNY)/20.
            CALL GDRAWT(XTEXT,YTEXT, 'C<ROSS - >S<ECTION> (<Z >=< >0)',
     +      CSIZE,0.,2,0)
            CALL GDCOL(1)
         ELSE IF (ISEL.EQ.-4) THEN
            CALL GDCOL(4)
            XTEXT=10.*PLTRNX/20.
            YTEXT=19.*PLTRNY/20.
            CSIZE=0.5*MIN(PLTRNX,PLTRNY)/20.
          CALL GDRAWT(XTEXT,YTEXT,
     +      'V<ERTICAL> S<ECTION> (<X >=< >0.5)',CSIZE,0.,2,0)
            CALL GDCOL(1)
         ELSE IF (ISEL.EQ.-5) THEN
            CALL GDCOL(4)
            XTEXT=10.*PLTRNX/20.
            YTEXT=19.*PLTRNY/20.
            CSIZE=0.5*MIN(PLTRNX,PLTRNY)/20.
          CALL GDRAWT(XTEXT,YTEXT,
     +      'H<ORIZONTAL> S<ECTION> (<Y >=< >5)',CSIZE,0.,2,0)
            CALL GDCOL(1)
         ENDIF
      ENDIF
      IF (ISEL.LT.0.OR.ISEL2.NE.0) THEN
         IYEAR  = (IGDATE)/10000
         IMONTH = (IGDATE-IYEAR*10000)/100
         IDAY   = (IGDATE-IYEAR*10000-IMONTH*100)
         CHDATE=' '
         WRITE (CHDATE,'(I2.2,''/'',I2.2,''/'',I2.2)') IDAY,IMONTH,IYEAR
         XTEXT=19.*PLTRNX/20.
         YTEXT=19.*PLTRNY/20.
         CSIZE=0.25*MIN(PLTRNX,PLTRNY)/20.
         CALL GDRAWT(XTEXT,YTEXT,CHDATE,CSIZE,0.,1,1)
      ENDIF
   30 CALL GDCOL(0)
      END
+DECK,  GDHITS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDHITS (IUSET,IUDET,ITRS,ISYMB,SSYMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw HITS points of track ITRS in detector IUDET         *
C.    *       of set IUSET, in case that the spatial coordinates       *
C.    *       of the HITS had been stored as the first three words     *
C.    *       in the argument vector of GSAHIT.                        *
C.    *                                                                *
C.    *       The following characters may be chosen :                 *
C.    *          ISYMB = -1   hardware character    (fast),            *
C.    *                =  0   crosses X by TVDRAW   (default),         *
C.    *                       (size = SSYMB in cm, default = 0.1),     *
C.    *                = 840  characters by HPLSOF                     *
C.    *                   .   according to the table p. 25             *
C.    *                   .   of the HPLOT manual                      *
C.    *                  853  (size = SSYMB in cm)                     *
C.    *             (844,854  white, black asterisk * in addition).    *
C.    *                                                                *
C.    *       JH =LQ(JHITS-ISET)                                       *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)=pointer to the LAST USED word in JHD         *
C.    *         Each hit was packed into JHD in the following format:  *
C.    *        --Track number ITRA not packed;                         *
C.    *        --Volume numbers packed;                                *
C.    *        --Hits transformed and packed.                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Authors : R.Brun, W.Gebel, P.Zanarini, S.Giani ***       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
      CHARACTER*4 IUSET,IUDET
      DIMENSION HITS(3,10)
C
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('OFF ',IOFF,4,4)
C
C            Set IOBJ to HIT
C
      IOBJ=3
C
      IF (JHITS.LE.0)           GOTO 160
      NSET = IQ(JSET-1)
      NS1        = 1
      NS2        = NSET
      IF (IUSET(1:1).EQ.'*')   GOTO  10
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET .LE.0)           GOTO 160
      NS1        = ISET
      NS2        = ISET
   10 CONTINUE
C
C
C            loop on all selected sets
C
      DO 150   ISET=NS1,NS2
         JS = LQ(JSET-ISET)
         JH = LQ(JHITS-ISET)
         IF(JS.LE.0)GO TO 140
         IF(JH.LE.0)GO TO 140
         NDET = IQ(JS-1)
         ND1 = 1
         ND2 = NDET
         IF (IUDET(1:1).EQ.'*') GOTO 20
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF (IDET .EQ.0) GOTO 140
         ND1 = IDET
         ND2 = IDET
   20    CONTINUE
C
C            loop on selected detectors for this set
C
         DO 130 IDET=ND1,ND2
            JD = LQ(JS-IDET)
            JHD = LQ(JH-IDET)
            IF (JHD .LE.0) GOTO 120
            JDH = LQ(JD-1)
            ILAST = IQ(JH+IDET)
            IF (ILAST.EQ.0) GOTO 120
            NV = IQ(JD+2)
            NH = IQ(JD+4)
            NW = IQ(JD+1) + IQ(JD+3) + 1
C
C            Now loop on all hits to get their space coordinates
C
            MH = 0
            IHIT = 0
            DO 110 I=1,ILAST,NW
               IHIT = IHIT + 1
               ITRA = IQ(JHD+I)
C
C            Is this the right track ?
C
               IF (ITRS.NE.0 .AND. ITRS.NE.ITRA) GOTO 110
C
C            Is THRZ option set on (R-Z projection)
C            and the cut lateral (vertical or horizontal) ?
C
               IF (ITHRZ.NE.IOFF) THEN
                  IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-ITRA
               ELSE
                  ITR3D=0
               ENDIF
C
C            Skip words with volume numbers
C
               NK = 1
               K = 1
               IF (NV.LE.0) GOTO 40
               DO 30 IV=1,NV
                  NB = IQ(JD+2*IV+10)
                  IF (NB.EQ.0) NB=32
                  K = NB + K
                  IF (K.LE.33) GOTO 30
                  NK = NK + 1
                  K = NB + 1
   30          CONTINUE
               NK = NK + 1
C
C            Get unpacked (first three !) HITS.
C            Hits origin is shifted. Division by scale factor.
C
   40          CONTINUE
               IF (NH.LE.2) GOTO 110
               MH = MH + 1
               K=1
               DO 80 IH=1,3
                  NB = IQ(JDH+4*IH-2)
                  IF (NB.GT.0) GOTO 50
                  IF (K.GT.1) THEN
                     NK=NK+1
                  ENDIF
                  KHIT = IQ(JHD+I+NK)
                  K = 1
                  NK = NK + 1
                  GOTO 70
   50             IF (K+NB.LE.33) GOTO 60
                  K = 1
                  NK = NK + 1
   60             KHIT = IBITS(IQ(JHD+I+NK),K-1,NB)
                  K = K + NB
   70             CONTINUE
                  HITS(IH,MH)= FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
   80          CONTINUE
C
C            Draw the hits (usually 10 at a time);
C            flush HITS vector if
C             --loop on this detector volume is to finish,
C             --loop on current track is to finish,
C             --HITS vector is full.
C
               IF ((ILAST-I).LT.NW) GOTO 90
               ITRN = IQ(JHD+I+NW)
               IF (ITRA.NE.ITRN) GOTO 90
               IF (MH .NE. 10) GOTO 110
C
   90          CONTINUE
C
               CALL IGPID(1,'Hitset',IQ(JSET+ISET),' ')
               CALL IGPID(2,'Hitdet',IQ(JS+IDET),' ')
               DO 100 II=1,MH
                  IHITNR=IHIT-MH+II
                  CALL IGPID(3,'Hitnum',IHITNR,' ')
                  CALL GDAHIT(HITS(1,II),HITS(2,II),HITS(3,II),ISYMB,
     +            SSYMB)
  100          CONTINUE
               MH=0
C
  110       CONTINUE
C
  120       CONTINUE
  130    CONTINUE
C
  140    CONTINUE
  150 CONTINUE
C
  160 CONTINUE
C
C             Reset ITR3D to 'standard projection'
C
      ITR3D=0
      IOBJ=0
C
      CALL GDCOL(0)
C
      END
+DECK,  GDINIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDINIT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Initialize the drawing package                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>  UGINIT                               *
C.    *       Author : P.Zanarini ; S.Giani   *********                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCDRAW.
+CDE, GCONSP.
+CDE, GCGOBJ.
+CDE, GCMUTR.
+CDE, GCSPEE.
      COMMON/INIFIR/NFIRST
      DIMENSION GR0(10),GT0(3)
+SELF, IF=CG.
      DIMENSION     V(3),T(4,3)
+SELF.
C
      SAVE GR0,GT0
      DATA GR0/1.,0.,0.,0.,1.,0.,0.,0.,1.,0./
      DATA GT0/0.,0.,0./
C.
C.    ------------------------------------------------------------------
C.
C             Initialize general drawing parameters:
C
C             NGVIEW = Flag for GDFR3D, set to 0 if one wants GDFR3D to
C                      compute new transformation matrix
C             NKVIEW = Total number of view banks
C             IDVIEW = Actual view bank (0 means screen)
C             GTHETA,GPHI,...,GSCV = Initial values for GDRAW calling parameters
C             GZUA,GZVA,GZUB,GZVB,GZUC,GZVC = Zoom parameters
C             DPERS  = Distance from the center of projection
C                      (i.e. viewing position) at Z=-DPERS
C                      and the projection plane at Z=0
C             LINBUF = Flag to determine if GDRAWV has to perform
C                      line buffering logic (LINBUF=1) or not
C             IPIONS = Flag for GDFR3D, set to 1 if PIONS is used
C             IGMR   = Flag for GDFR3D, set to 1 if APOLLO-GMR is used
C             IPKHIT = Flag for GPHITS (normally 0); if >0 then print only
C                      hit nr. IPKHIT
C             IDRNUM = Flag for GDRAW, set to 1 when called by GDRVOL
C             PLTRNX = Screen and plotter X range, PLTRNX x PLTRNY cm.
C             PLTRNY = Screen and plotter Y range, PLTRNX x PLTRNY cm.
***           RNGU1,RNGU2,RNGV1,RNGV2 = Limits of user coordinates (2D window)
C
      IF(IFINIT(14).NE.0)RETURN
      IFINIT(14)=1
      NFIRST=0
      NGVIEW=0
      NKVIEW = 0
      IDVIEW= 0
      GTHETA=45.
      GPHI=135.
      GPSI=0.
      GU0=10.
      GV0=10.
      GSCU=0.015
      GSCV=0.015
      SINPSI=SIN(GPSI*DEGRAD)
      COSPSI=COS(GPSI*DEGRAD)
      GZUA=1
      GZVA=1
      GZUB=0
      GZVB=0
      GZUC=0
      GZVC=0
      DPERS=1000
      LINBUF=0
      IPIONS=0
      IGMR=0
      IPKHIT=0
      IDRNUM=0
      PLTRNX=20.
      PLTRNY=20.
C
C             LINATT = Current line attributes
C             LINATP = Permanent line attributes
C             ITXATT = Current text attributes
C
      LINCOL=1
      LINWID=1
      LINSTY=1
      LINFIL=0
      LEP=1
C
      LINATT=0
      CALL MVBITS(LINCOL,0,8,LINATT,16)
      CALL MVBITS(LINWID,0,3,LINATT,7)
      CALL MVBITS(LINSTY,0,3,LINATT,10)
      CALL MVBITS(LINFIL,0,3,LINATT,13)
C
      LINATP=LINATT
C
      ITXWID=1
      ITXCOL=1
C
      ITXATT=0
      CALL MVBITS(ITXWID,0,3,ITXATT,0)
      CALL MVBITS(ITXCOL,0,4,ITXATT,3)
C
C             Initialize drawing options:
C
C             ITR3D  = Flag for GDFR3D : ITR3D=0 for standard projection,
C                      ITR3D <> 0 for rotation + projection i.e. R-Z projection
C                      (refer to the header comments of GDFR3D
C                      to have a detailed explanation of the steps
C                      from 3D to 2D)
C
C             ITHRZ  = Flag for GDHITS/GDCXYZ/GDXYZ : if not set to 'OFF ' all t
C                      hits and tracks drawing routines will apply an R-Z
C                      projection in case of SIDE or TOP view
C
C             IOBJ   = Type of object being currently drawn :
C
C                         1 : VOLUME
C                         2 : TRACK
C                         3 : HIT
C                         0 : None or any other object (axes,header,text,etc.)
C
C             IPRJ   = Flag for GDFR3D :
C
C                      'PARA' : Ortographic parallel projection (default)
C                      'PERS' : Perspective projection
C
C             ITRKOP = Flag for GDXYZ :
C
C                      'LINE' : Lines joining track points are drawn
C                      'POIN' : Only the track points are drawn
C
      ITR3D=0
      CALL UCTOH('OFF ',ITHRZ,4,4)
      IOBJ=0
      CALL UCTOH('PARA',IPRJ,4,4)
      CALL UCTOH('LINE',ITRKOP,4,4)
      CALL UCTOH('OFF ',IHIDEN,4,4)
C
C             Initialize Color look up table
C
      DO 10 I=1,16
  10  LOOKTB(I)=I
C
C             Define tree parameters:
C
C             NWCUT = Max words allocated to be used by the cut routines
C
      NWCUT=5000
C
C             Initialize to unitary transformation
C
      DO 20 I=1,3
   20 GTRAN0(I)=GT0(I)
      DO 30 I=1,10
   30 GRMAT0(I)=GR0(I)
C
C             Set display and user coordinate systems
C
      CALL ISWN(1,0.,PLTRNX,0.,PLTRNY)
      CALL ISVP(1,0.,1.,0.,1.)
      CALL IGSET('TXFP',-61.)
      CALL IGRNG(PLTRNX,PLTRNY)
      CALL IGSA(0)
*JS
*
*  Setting the Viewing parameters to THETA =0., PHI=0., PSI=0.
*
+SELF, IF=CG.
      NCVOLS=0
      NSHIFT=0
      KSHIFT=0
      IHOLE=0
      CGXMIN=-10000.
      CGXMAX=-9999.
      CGYMIN=-10000.
      CGYMAX=-9999.
      CGZMIN=-10000.
      CGZMAX=-9999.
      V(1)=0.
      V(2)=0.
      V(3)=0.
      CALL GDCGVW(V,T)
      CALL CGTSET(NTRCG,T,IREP)
+SELF.
*JS
C
C             Book JDRAW structure for view banks
C
      IF (JDRAW.LE.0) CALL MZBOOK(IXCONS,JDRAW,JDRAW,1,'DRAW',0,0,0,3,0)
C
      END

+DECK,  GDKINE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GDKINE
*
************************************************************************
*                                                                      *
*            RAY-TRACING                                               *
*            Kinematics for the light rays.                            *
*            Parallel and perspective views.                           *
*                                                                      *
*            Author: S.Giani.                                          *
*                                                                      *
************************************************************************
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCONST.
********************************************************************************
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCSPEE.
+CDE, GCHILN.
+CDE, GCRAYT.
********************************************************************************
      DIMENSION VERTEX(6),PLAB(3)
*
*     -----------------------------------------------------------------
*
      XMIP=0.
      CALL VZERO(VERTEX,6)
********************************************************************************
       CALL UCTOH('PERS',IPERS,4,4)
       XCOSXS=(SIN(GTHETA*DEGRAD))*(COS(GPHI*DEGRAD))
       YCOSYS=(SIN(GTHETA*DEGRAD))*(SIN(GPHI*DEGRAD))
       ZCOSZS=COS(GTHETA*DEGRAD)
*       print *,XCOSXS,YCOSYS,ZCOSZS,'direction from gukine'
       VDX=XCOSXS
       VDY=YCOSYS
       VDZ=ZCOSZS
       IK=48
       VERTEX(1)=XPINTS
       VERTEX(2)=YPINTS
       VERTEX(3)=ZPINTS
       IF(IPERS.EQ.IPRJ)THEN
        CONMOD=1./SQRT(((XPINTS-FPINTX)**2)+((YPINTS-FPINTY)**2)+
     +                 ((ZPINTS-FPINTZ)**2))
        XCOSXS=-(XPINTS-FPINTX)*CONMOD
        YCOSYS=-(YPINTS-FPINTY)*CONMOD
        ZCOSZS=-(ZPINTS-FPINTZ)*CONMOD
       ENDIF
       PLAB(1) = -PKINE(1)*XCOSXS
       PLAB(2) = -PKINE(1)*YCOSYS
       PLAB(3) = -PKINE(1)*ZCOSZS
********************************************************************************
      CALL GSVERT(VERTEX,0,0,0,0,NVERT)
      CALL GSKINE(PLAB,IK,NVERT,0,0,NT)
*
      END
+DECK,  GDLCYL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDLCYL(R1,PHI1,Z1,R2,PHI2,Z2)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a line between points (R1,PHI1,Z1) and (R2,PHI2,Z2) *
C.    *       given in cylindrical coordinates                         *
C.    *                                                                *
C.    *    ==>Called by : GDRAWS                                       *
C.    *       Author : A.McPherson   *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION P1(3),P2(3)
C.
C.    ------------------------------------------------------------------
C
      IF (R1.LT.0.0001.AND.R2.LT.0.0001) GO TO 999
C
      PH=PHI1*DEGRAD
      P1(1)=R1*COS(PH)
      P1(2)=R1*SIN(PH)
      P1(3)=Z1
      PH=PHI2*DEGRAD
      P2(1)=R2*COS(PH)
      P2(2)=R2*SIN(PH)
      P2(3)=Z2
C
      CALL GDLINE(P1,P2)
C
  999 RETURN
      END
+DECK,  GDLENS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDLENS(ISEL1,KLSA)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Zoom by the factors ZOOMFU,ZOOMFV                        *
C.    *       around screen coordinates UUZ0,VVZ0                      *
C.    *       and places the resulting picture at UU0,VV0              *
C.    *                                                                *
C.    *       After GDZOOM has been CALLed, any drawing operation      *
C.    *       will actually draw accordingly to last GDZOOM parameters *
C.    *                                                                *
C.    *       If ZOOMFU or ZOOMFV is 0 (or negative) the zoom          *
C.    *       parameters (GZUA,...,GZVC in common GCDRAW) are reset    *
C.    *                                                                *
C.    *       It is now possible to show in different windows the      *
C.    *       `zoomed-views' obtained just clicking in different       *
C.    *       points of the main picture or of the zoomed-pictures     *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author: S. Giani 1992                                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      DIMENSION RVAL(2)
      CHARACTER*4 KLSA
*
      IPX1=1
      IPXSAV=0
      INGR=0
      ISTR=0
   10 GZUA=1
      GZVA=1
      GZUB=0
      GZVB=0
      GZUC=0
      GZVC=0
      MO=0
      CALL IGLOC2(1,NT,UZ1,VZ1,UZ2,VZ2,ISTAT,'R')
      IF (ISTAT.EQ.0)THEN
***              CALL IGCHWK(9,0,0,600,600)
         GZUA=1
         GZVA=1
         GZUB=0
         GZVB=0
         GZUC=0
         GZVC=0
         GO TO 999
      ENDIF
      PLTX=20.
      PLTY=20.
      IF (UZ2-UZ1.EQ.0.) UZ2=UZ1+PLTX*.005
      IF (VZ2-VZ1.EQ.0.) VZ2=VZ1+PLTY*.005
      ZOOMFU=PLTX/ABS(UZ2-UZ1)
      ZOOMFV=PLTY/ABS(VZ2-VZ1)
      ZZFU=ZOOMFU
      ZZFV=ZOOMFV
      UUZ0=(UZ2+UZ1)*.5
      VVZ0=(VZ2+VZ1)*.5
      UU0=(ABS(UZ2-UZ1))*.5
      VV0=20.-(ABS(VZ2-VZ1))*.5
***         CALL IDAWK(1)
      GZUA=GZUA*ZOOMFU
      GZVA=GZVA*ZOOMFV
      GZUB=(GZUB+GZUC)*ZOOMFU
      GZVB=(GZVB+GZVC)*ZOOMFV
      GZUC=UU0-UUZ0*ZOOMFU
      GZVC=VV0-VVZ0*ZOOMFV
      CALL IGQWK(1,'MXDS',RVAL)
      ISU1=UZ1*RVAL(1)*.05
      ISV1=(20.-VZ1)*RVAL(2)*.05
      ISU21=(UZ2-UZ1)*RVAL(1)*.05
      ISV21=(VZ1-VZ2)*RVAL(2)*.05
      IPXSAV=2+IPXSAV
      CALL IGPXMP(IPXSAV,ISU21,ISV21,'OC')
      CALL IGPXMP(IPXSAV,ISU1,ISV1,'S')
      IPX1=2+IPX1
*                             CALL GDSHOW(ISEL1)
      CALL IGPXMP(IPX1,ISU21,ISV21,'O')
***         CALL IGCHWK(9,ISU1,ISV1,ISU21,ISV21)
***         CALL IOPWK(2,1,9)
***         CALL IACWK(2)
      CALL GDSHOW(ISEL1)
      CALL IGPXMP(IPX1,ISU1,ISV1,'CDR')
   20 CONTINUE
      CALL IRQLC(1,MO,JISTA,NT,PX,PY)
      IF(MO.NE.-2.AND.MO.NE.2)THEN
         IF(JISTA.EQ.0)THEN
***           CALL IDAWK(2)
***           CALL ICLWK(2)
***           CALL IACWK(1)
            IF(INGR.EQ.1)THEN
               CALL IGPXMP(IPXSAV,ISU1,ISV1,'DR')
            ELSE
               CALL IGPXMP(IPXSAV,IPXX,IPYY,'DR')
            ENDIF
            GOTO 10
         ELSEIF(JISTA.EQ.1)THEN
            INGR=1
            ISTR=0
            IF(KLSA.EQ.'ON')THEN
               MO=-2
            ELSE
               MO=2
            ENDIF
            GZUA=1
            GZVA=1
            GZUB=0
            GZVB=0
            GZUC=0
            GZVC=0
            ZOOMFU=(.5*PY*PLTX)/ABS(UZ2-UZ1)
            ZOOMFV=(.5*PY*PLTY)/ABS(VZ2-VZ1)
            ZZFU=ZOOMFU
            ZZFV=ZOOMFV
            GZUA=GZUA*ZOOMFU
            GZVA=GZVA*ZOOMFV
            GZUB=(GZUB+GZUC)*ZOOMFU
            GZVB=(GZVB+GZVC)*ZOOMFV
            GZUC=UU0-UUZ0*ZOOMFU
            GZVC=VV0-VVZ0*ZOOMFV
***           CALL ISFAIS(1)
***           CALL ISFACI(0)
***           CALL IGBOX(0.,20.,20.,0.)
            IPX1=IPX1+2
            CALL IGPXMP(IPX1,ISU21,ISV21,'O')
            CALL GDSHOW(ISEL1)
            CALL IGPXMP(IPX1,ISU1,ISV1,'CDR')
            GOTO 20
         ELSEIF(JISTA.EQ.2)THEN
            ISTR=1
            INGR=0
            IF(KLSA.EQ.'ON')THEN
               MO=-2
            ELSE
               MO=2
            ENDIF
            GZUA=1
            GZVA=1
            GZUB=0
            GZVB=0
            GZUC=0
            GZVC=0
            UUZ0=PX
            VVZ0=PY
            GZUA=GZUA*ZOOMFU
            GZVA=GZVA*ZOOMFV
            GZUB=(GZUB+GZUC)*ZOOMFU
            GZVB=(GZVB+GZVC)*ZOOMFV
            GZUC=UU0-UUZ0*ZOOMFU
            GZVC=VV0-VVZ0*ZOOMFV
            IPX1=IPX1+2
            CALL IGPXMP(IPX1,ISU21,ISV21,'O')
            CALL GDSHOW(ISEL1)
            IPXX=PX*RVAL(1)*.05-ISU21*.5
            IPYY=(20.-PY)*RVAL(2)*.05-ISV21*.5
            CALL IGPXMP(IPX1,IPXX,IPYY,'C')
            CALL IGPXMP(IPXSAV,ISU1,ISV1,'DR')
            IPXSAV=IPXSAV+2
            CALL IGPXMP(IPXSAV,ISU21,ISV21,'OC')
            CALL IGPXMP(IPXSAV,IPXX,IPYY,'S')
            CALL IGPXMP(IPX1,IPXX,IPYY,'DR')
            GOTO 20
         ENDIF
      ELSE
         IF(JISTA.EQ.0)THEN
            IF(INGR.EQ.1)THEN
*            CALL IGPXMP(IPXSAV,ISU1,ISV1,'DR')
               MO=0
               GOTO 20
            ELSE
*            CALL IGPXMP(IPXSAV,IPXX,IPYY,'DR')
               MO=0
               ISU1=IPXX
               ISV1=IPYY
               GOTO 20
            ENDIF
*           GOTO 15
         ELSEIF((JISTA.EQ.-1.AND.INGR.EQ.1).OR. (JISTA.GT.0.AND.INGR.EQ
     +   .1.AND.MO.EQ.2))THEN
            GZUA=1
            GZVA=1
            GZUB=0
            GZVB=0
            GZUC=0
            GZVC=0
            ZOOMFU=(.5*PY*PLTX)/ABS(UZ2-UZ1)
            ZOOMFV=(.5*PY*PLTY)/ABS(VZ2-VZ1)
            ZZFU=ZOOMFU
            ZZFV=ZOOMFV
            GZUA=GZUA*ZOOMFU
            GZVA=GZVA*ZOOMFV
            GZUB=(GZUB+GZUC)*ZOOMFU
            GZVB=(GZVB+GZVC)*ZOOMFV
            GZUC=UU0-UUZ0*ZOOMFU
            GZVC=VV0-VVZ0*ZOOMFV
*          CALL ICLRWK(2,1)
***           CALL ISFAIS(1)
***           CALL ISFACI(0)
***           CALL IGBOX(0.,20.,20.,0.)
            IPX1=IPX1+2
            CALL IGPXMP(IPX1,ISU21,ISV21,'O')
            CALL GDSHOW(ISEL1)
            CALL IGPXMP(IPX1,ISU1,ISV1,'CDR')
            GOTO 20
         ELSEIF((JISTA.EQ.-1.AND.ISTR.EQ.1).OR. (JISTA.GT.0.AND.ISTR.EQ
     +   .1.AND.MO.EQ.2))THEN
            GZUA=1
            GZVA=1
            GZUB=0
            GZVB=0
            GZUC=0
            GZVC=0
            UUZ0=PX
            VVZ0=PY
            GZUA=GZUA*ZOOMFU
            GZVA=GZVA*ZOOMFV
            GZUB=(GZUB+GZUC)*ZOOMFU
            GZVB=(GZVB+GZVC)*ZOOMFV
            GZUC=UU0-UUZ0*ZOOMFU
            GZVC=VV0-VVZ0*ZOOMFV
            IPX1=IPX1+2
            CALL IGPXMP(IPX1,ISU21,ISV21,'O')
            CALL GDSHOW(ISEL1)
            CALL IGPXMP(IPX1,IPXX,IPYY,'C')
            CALL IGPXMP(IPXSAV,IPXX,IPYY,'DR')
            IPXX=PX*RVAL(1)*.05-ISU21*.5
            IPYY=(20.-PY)*RVAL(2)*.05-ISV21*.5
            IPXSAV=IPXSAV+2
            CALL IGPXMP(IPXSAV,ISU21,ISV21,'OC')
            CALL IGPXMP(IPXSAV,IPXX,IPYY,'S')
            CALL IGPXMP(IPX1,IPXX,IPYY,'DR')
            GOTO 20
         ENDIF
      ENDIF
C
  999 END
+DECK,  GDLINE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDLINE(P1,P2)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a line between points P1 and P2                     *
C.    *                                                                *
C.    *    ==>Called by : GDLCYL, GDRAWS                               *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
CM
+CDE, GCDRAW.
CM
      DIMENSION P1(3),P2(3),U(2),V(2),X(3,2)
      DIMENSION Q1(3),Q2(3)
      EQUIVALENCE (Q1(1),X(1,1)),(Q2(1),X(1,2))
C.
C.    ------------------------------------------------------------------
C.
      DO 10 I=1,3
         Q1(I)=P1(I)
         Q2(I)=P2(I)
   10 CONTINUE
C
      CALL GDFR3D(X,2,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .EQ. 0 ) CALL GDRAWV(U,V,2)
CM
      END
+DECK,  GDLUMI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GDLUMI(LINCOL,APROSC)
*
******************************************************************
*                                                                *
* RAY-TRACING                                                    *
* Function: Recieve light intensity and angle with surface       *
*           Compute colour shading for the surface               *
*                                                                *
* I/O parameters:                                                *
* LINCOL = colour code                                           *
* APROSC = inclination between light rays and surface            *
*                                                                *
* Author: S. Giani 1992                                          *
*                                                                *
******************************************************************
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCFLAG.
*
+CDE, GCTRAK.
+CDE, GCPIXE.
+CDE, GCRAYT.

      DATA IAAA /456789/
      SAVE IAAA
*
      IF(LINCOL.EQ.2)THEN
         LINCOL=16
      ELSEIF(LINCOL.EQ.3)THEN
         LINCOL=66
      ELSEIF(LINCOL.EQ.4)THEN
         LINCOL=116
      ELSEIF(LINCOL.EQ.5)THEN
         LINCOL=41
      ELSEIF(LINCOL.EQ.6)THEN
         LINCOL=141
      ELSEIF(LINCOL.EQ.7)THEN
         LINCOL=91
      ELSE
         print *,'Warning, color not supported'
         GOTO 998
      ENDIF
*
      LINSAV=LINCOL
      IAAA=MOD(IAAA*1237,1000000)+1
      if(iaaa.lt.1.or.iaaa.gt.1000000)print *,'iaaa<0'
      QIAAA=IAAA
*
      SMIN=-0.001
      SMAX=0.04
      DO 1 I=1,25
       IF(APROSC.GT.SMIN.AND.APROSC.LE.SMAX)THEN
        QD=QIAAA/1000000.
        QCD=QD*(SMAX-SMIN)
        IF((APROSC-SMIN).GT.QCD)THEN
           LINCOL=LINCOL+I
        ELSE
           IF(I.GT.1)THEN
            LINCOL=LINCOL+I-1
           ELSE
            LINCOL=LINCOL+I
           ENDIF
        ENDIF
         GOTO 998
       ELSE
         SMIN=SMAX
         SMAX=SMAX+0.04
       ENDIF
 1    CONTINUE
*
      print *,aprosc,'=aprosc'
*
 998  CONTINUE
*      CALL ISFACI(LINCOL)
*      CALL ISPLCI(LINCOL)
**      IF(ISWIT(9).NE.54321)CALL ISPMCI(LINCOL)
       CALL ISPMCI(LINCOL)
       ICOLOR=LINCOL
*
 999  END

+DECK,  GDLW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDLW(LW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Set line width to LW (between 1 to 5) :                  *
C.    *       if LW > 0 set line width temporarily                     *
C.    *       if LW < 0 set line width permanently                     *
C.    *       if LW = 0 restore permanent line width value             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDHEAD, GDTREE              *
C.    *       Author : P.Zanarini ; S.Giani  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
***      LINW=MOD(IABS(LW),8)
      IF (LW.EQ.0) THEN
         CALL MVBITS(LINATP,7,3,LINATT,7)
      ELSE IF (LW.GT.0) THEN
         CALL MVBITS(LW,0,3,LINATT,7)
      ELSE
         CALL MVBITS(LW,0,3,LINATT,7)
         CALL MVBITS(LW,0,3,LINATP,7)
      ENDIF
      END
+DECK,  GDLW1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDLW1(LW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Change phisically the line width to LW                   *
C.    *                                                                *
C.    *    ==>Called by : GDRAWP, GDRAWT                               *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      SAVE IOLD
      DATA IOLD/-1/
C.
C.    ------------------------------------------------------------------
C.
      LINW=MOD(IABS(LW),8)
C
      IF (LINW.NE.IOLD)THEN
         IOLD=LINW
         CALL ISLWSC(FLOAT(LINW))
      ENDIF
      END
+DECK,  GDMAN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDMAN(U0,V0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a 2D-man at position (U0,V0)                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC                      *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION U(24),V(24),LEN(4),UN(24,4),VN(24,4)
      DIMENSION UN1(24),VN1(24),UN2(8),VN2(8)
      DIMENSION UN3(4),VN3(4),UN4(12),VN4(12)
C
      EQUIVALENCE (UN1(1),UN(1,1)),(VN1(1),VN(1,1))
      EQUIVALENCE (UN2(1),UN(1,2)),(VN2(1),VN(1,2))
      EQUIVALENCE (UN3(1),UN(1,3)),(VN3(1),VN(1,3))
      EQUIVALENCE (UN4(1),UN(1,4)),(VN4(1),VN(1,4))
C
      SAVE LEN,UN1,VN1,UN2,VN2,UN3,VN3,UN4,VN4
      DATA LEN/24,8,4,12/
C
      DATA UN1/1.3,-0.4,-0.7,0.3,-1.2,-1.6,-1.7,-2.8,-3.6,-1.7,
     +         -1.0,-0.1,0.7,1.9,2.4,2.5,1.4,2.9,3.3,3.1,
     +         1.9,0.9,1.0,1.3/
      DATA VN1/6.2,6.3,4.7,4.6,3.7,2.8,-1.9,-9.5,-9.8,-9.8,
     +         -5.5,-3.6,-5.5,-10.0,-10.4,-9.8,-3.6,-1.2,0.2,1.7,
     +         3.8,4.4,4.7,6.2/
C
      DATA UN2/0.0,0.2,1.3,0.9,0.2,-0.3,-0.8,0.2/
      DATA VN2/0.0,2.6,4.1,4.4,2.6,4.3,3.9,2.6/
C
      DATA UN3/1.8,2.4,1.9,1.8/
      DATA VN3/-1.1,0.4,1.9,-1.1/
C
      DATA UN4/-1.2,-1.7,-2.3,-2.1,-2.2,-2.5,-2.6,-1.7,-1.7,
     +         -2.2,-2.1,-1.6/
      DATA VN4/3.7,2.9,-1.3,-1.4,-1.8,-1.7,-2.8,-3.0,-1.9,
     +         -1.8,-1.4,-1.5/
C.
C.    ------------------------------------------------------------------
C.
      DO 20 I=1,4
         JMAX=LEN(I)
         DO 10 J=1,JMAX
            U(J)=UN(J,I)*10.0*GSCU*GZUA+U0
            V(J)=VN(J,I)*10.0*GSCV*GZVA+V0
C
C             Normalize to PLTRNX,PLTRNY
C
            U(J)=U(J)*PLTRNX/20.
            V(J)=V(J)*PLTRNY/20.
   10    CONTINUE
         CALL GDRAWV(U,V,JMAX)
   20 CONTINUE
C
      END
+DECK,  GDNINO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GDNINO
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       RAY-TRACING                                              *
C.    *                                                                *
C.    *       Tracking of light rays.                                  *
C.    *                                                                *
C.    *       Author: S.Giani.                                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVOLU.
+CDE, GCONSP.
+CDE, GCDRAW.
+CDE, GCFLAG.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCBANK.
+CDE, GCKINE.
+SELF, IF=DEBUG.
+CDE, GCUNIT.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
********************************************************************************
+CDE, GCFDIM.
+CDE, GCRAYT.
+CDE, GCPIXE.
      DIMENSION CCVV(3),DDVV(2)
********************************************************************************
C.
C.    ------------------------------------------------------------------
C.
      STEP = BIG
      IF((BOFLAG.NE.1.).and.(VECT(1).le.XCUT.or.VECT(2).le.YCUT
     +.or.VECT(3).le.ZCUT))THEN
       CALL GTNEXT
      ELSE
       IGNEXT=1
       SNEXT=0.0001
       nlevin=nlevel
      ENDIF
      IF (IGNEXT.NE.0) THEN
         STEP = SNEXT + PREC
         step=step+.004
***         if(iombra.eq.9)step=step+.001
         INWVOL= 2
         LMEC(1)=1
*
* *** Linear transport
*
         DO 10 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
               ENDIF
            ENDIF
********************************************************************************
            IF(BOFLAG.NE.1)THEN
              VECT(I) = VECTMP
            ELSE
              INWVOL=0
            ENDIF
   10    CONTINUE
       NOFLAG=0
       IF(BOFLAG.NE.1)THEN
       IF(VECT(1).GT.XCUT.AND.VECT(2).GT.YCUT.AND.
     +    VECT(3).GT.ZCUT)THEN
          NOFLAG=1
          CCXX(1)=1.
          CCXX(2)=1.
          CCXX(3)=0.
          CCXX(4)=0.
          CCYY(1)=1.
          CCYY(2)=0.
          CCYY(3)=1.
          CCYY(4)=0.
          CCZZ(1)=1.
          CCZZ(2)=0.
          CCZZ(3)=0.
          CCZZ(4)=1.
          DO 11 I=1,3
            CCVV(I)=VECT(I+3)
 11       CONTINUE
          STEP1=100000.
          DDXX=GVSAFE(VECT,-XCUT,CCXX,4)
          CALL GVLONG(CCVV,CCXX,4,DDVV,NTAU)
          IF(NTAU.GT.0)THEN
           IF(DDVV(1).GE.0.)THEN
             STEP1=DDVV(1)
           ENDIF
           APFLAG=(CCXX(2)*XCOSXS)+(CCXX(3)*YCOSYS)+
     +     (CCXX(4)*ZCOSZS)
           IXYFLA=1
          ENDIF
          DDYY=GVSAFE(VECT,-YCUT,CCYY,4)
          CALL GVLONG(CCVV,CCYY,4,DDVV,NTAU)
          IF(NTAU.GT.0)THEN
           IF(DDVV(1).LT.STEP1.AND.DDVV(1).GE.0.)THEN
             IXYFLA=2
             STEP1=DDVV(1)
             APFLAG=(CCYY(2)*XCOSXS)+(CCYY(3)*YCOSYS)+
     +       (CCYY(4)*ZCOSZS)
           ENDIF
          ENDIF
          DDZZ=GVSAFE(VECT,-ZCUT,CCZZ,4)
          CALL GVLONG(CCVV,CCZZ,4,DDVV,NTAU)
          IF(NTAU.GT.0)THEN
           IF(DDVV(1).LT.STEP1.AND.DDVV(1).GE.0.)THEN
             IXYFLA=3
             STEP1=DDVV(1)
             APFLAG=(CCZZ(2)*XCOSXS)+(CCZZ(3)*YCOSYS)+
     +       (CCZZ(4)*ZCOSZS)
           ENDIF
          ENDIF
          STEP1=STEP1+.004
          DO 12 I=1,3
            IF(BOFLAG.NE.1)VECT(I)=VECT(I)+STEP1*VECT(I+3)
 12       CONTINUE
          IF(IOMBRA.EQ.9)SLENG=SLENG+STEP1
          IF(IOMBRA.EQ.10)THEN
            XYZMOD=1./SQRT((XLPOS-VECT(1))**2+(YLPOS-VECT(2))**2+
     +                     (ZLPOS-VECT(3))**2)
            XLDIR=(XLPOS-VECT(1))*XYZMOD
            YLDIR=(YLPOS-VECT(2))*XYZMOD
            ZLDIR=(ZLPOS-VECT(3))*XYZMOD
            IF(IXYFLA.EQ.1)THEN
             APFLAH=(CCXX(2)*XLDIR)+(CCXX(3)*YLDIR)+(CCXX(4)*ZLDIR)
*             if(apflah.lt.0.)print *,APFLAH,'=apflah',IXYFLA,'=flag',
*     +       CCXX(2),XLDIR,CCXX(3),YLDIR,CCXX(4),ZLDIR
            ELSEIF(IXYFLA.EQ.2)THEN
             APFLAH=(CCYY(2)*XLDIR)+(CCYY(3)*YLDIR)+(CCYY(4)*ZLDIR)
*             if(apflah.lt.0.)print *,APFLAH,'=apflah',IXYFLA,'=flag',
*     +       CCYY(2),XLDIR,CCYY(3),YLDIR,CCYY(4),ZLDIR
            ELSEIF(IXYFLA.EQ.3)THEN
             APFLAH=(CCZZ(2)*XLDIR)+(CCZZ(3)*YLDIR)+(CCZZ(4)*ZLDIR)
            ENDIF
          ENDIF
       ENDIF
       ELSE
        IF(IOMBRA.EQ.10)THEN
          IOMBRA=9
          XYZMOD=1./SQRT((XLPOS-VECT(1))**2+(YLPOS-VECT(2))**2+
     +                   (ZLPOS-VECT(3))**2)
          VECT(4)=(XLPOS-VECT(1))*XYZMOD
          VECT(5)=(YLPOS-VECT(2))*XYZMOD
          VECT(6)=(ZLPOS-VECT(3))*XYZMOD
          XLDIR=VECT(4)
          YLDIR=VECT(5)
          ZLDIR=VECT(6)
          SLENG=0.
        ELSE
          NSTEP=10000
          ISTOP=0
          IF(IOMBRA.EQ.9)IOMBRA=10
        ENDIF
       ENDIF
      ELSE
          NSTEP=10000
          ISTOP=0
          INWVOL= 2
          LMEC(1)=1
          STEP=.1
          IF(IOMBRA.EQ.9)THEN
             IOMBRA=10
             PRINT *,'WARNING'
          ENDIF
         DO 20 I = 1,3
           IF(BOFLAG.NE.1)VECT(I)  = VECT(I) +STEP*VECT(I+3)
********************************************************************************
   20    CONTINUE
      ENDIF
      SLENG = SLENG +STEP
      END
+DECK,  GDNSON, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDNSON(NAME,NSON,NDIV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Return in NSON the number of sons of object NAME         *
C.    *       and in NDIV its number of divisions, always positive     *
C.    *       (NDIV=0 means no division)                               *
C.    *                                                                *
C.    *    ==>Called by : GDPRTR, GDSPEC, GDTR1                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
      CHARACTER*4 NAME
C.
C.    ------------------------------------------------------------------
C.
      NSON=0
      NDIV=0
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF (IVO.LE.0) GO TO 999
      JVO=LQ(JVOLUM-IVO)
      NIN=Q(JVO+3)
      IF (NIN.EQ.0) GO TO 999
      IF (NIN.GT.0) GO TO 10
C
C             Case of division
C
      NSON=1
      JIN=LQ(JVO-1)
      NDIV=ABS(Q(JIN+3))
      GO TO 999
   10 NSON=NIN
  999 RETURN
      END
+DECK,  GDOPEN, T=FORT.
* Revision 1.2  1997/01/24 14:16:06  mclareni
* NZLEFT 2nd argument 0 instead of blank for Msoft
* Revision 1.1.1.1.2.1  1997/01/21 11:24:20  mclareni
* All mods for Winnt 96a on winnt branch
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDOPEN(IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Open view bank IVIEW for storing; if IVIEW=0 then        *
C.    *       none view bank is opened and drawing is done             *
C.    *       on the screen.                                           *
C.    *                                                                *
C.    *       Q(JDRAW+IVIEW) contains a control word that is :         *
C.    *                                                                *
C.    *       1 for empty banks (created just to avoid gaps)           *
C.    *         or for deleted banks                                   *
C.    *                                                                *
C.    *       2 for opened banks (all banks that have been opened)     *
C.    *                                                                *
C.    *       3 for protected banks (all banks that can't be deleted   *
C.    *         by the user)                                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Authors : R.Brun, P.Zanarini   *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCDRAW.
+CDE, GCUNIT.
      COMMON/GCLOCA/NLOCAL(2),JLOCA(19),JV
C.
C.    ------------------------------------------------------------------
C.
C
C             Book JDRAW structure for view banks if not there
C
      IF (JDRAW.LE.0) CALL MZBOOK(IXCONS,JDRAW,JDRAW,1,'DRAW',0,0,0,3,0)
C
C             Previous view number must be 0 (screen)
C
      IF (IDVIEW.NE.0) GO TO 60
C
C             If want open a view bigger than current number of views
C             then do a pushing of view banks
C
      IF(IVIEW.LE.0)GO TO 999
      IF (IVIEW.GT.NKVIEW) GO TO 20
C
C             Cannot open a view already used
C
      IF (LQ(JDRAW-IVIEW).NE.0) GO TO 40
      IDVIEW=IVIEW
      IF (IDVIEW.EQ.0) GO TO 999
C
C             Open view number IDVIEW
C
   10 Q(JDRAW+IDVIEW)=2.
      CALL MZBOOK(IXCONS,JV,JDRAW,-IDVIEW,'DRAW',6,6,22,3,0)
C
C             Set number of words for creation and for pushing of banks
C             graphic unit, graphic segment, text unit, text segment
C
C
      NLEFT=NZLEFT(IXCONS,0)
      NL=NLEFT/10
      MAXGS=MIN(NL,10000)
      MAXGU=MAXGS/10
      MORGS=MAXGS/2
      MORGU=MAXGU/2
      MAXTU=10
      MORTU=MAXTU
      MAXTS=100
      MORTS=MAXTS
C
      Q(JV+2)=MAXGU
      Q(JV+3)=MORGU
      Q(JV+5)=MAXGS
      Q(JV+6)=MORGS
      Q(JV+8)=MAXTU
      Q(JV+9)=MORTU
      Q(JV+11)=MAXTS
      Q(JV+12)=MORTS
C
      Q(JV+16)=PLTRNX/2.
      Q(JV+17)=PLTRNY/2.
C
C           Set ICUT of the view bank to 0
C
      Q(JV+22)=0.
C
C             Graphic unit, graphic segment, text unit, text segment
C             pointers are reset to zero
C
      IGU=0
      IGS=0
      ITU=0
      ITS=0
C
C             Create view banks
C
      ND1=Q(JV+2)
      ND2=ND1
      ND3=Q(JV+8)
      ND4=Q(JV+5)
      ND5=ND4
      ND6=Q(JV+11)
      CALL MZBOOK(IXCONS,LBANK,JV,-1,'DRAW',0,0,ND1,3,0)
      CALL MZBOOK(IXCONS,LBANK,JV,-2,'DRAW',0,0,ND2,3,0)
      CALL MZBOOK(IXCONS,LBANK,JV,-3,'DRAW',0,0,ND3,3,0)
      CALL MZBOOK(IXCONS,LBANK,JV,-4,'DRAW',0,0,ND4,3,0)
      CALL MZBOOK(IXCONS,LBANK,JV,-5,'DRAW',0,0,ND5,3,0)
      CALL MZBOOK(IXCONS,LBANK,JV,-6,'DRAW',0,0,ND6,3,0)
      GO TO 999
C
C             Push view banks
C
   20 IDVIEW=IVIEW
      NDL=IDVIEW-NKVIEW
      CALL MZPUSH(IXCONS,JDRAW,NDL,NDL,'I')
      IF(IEOTRI.NE.0)GO TO 50
      DO 30 I=NKVIEW+1,IDVIEW-1
         Q(JDRAW+I)=1.
   30 CONTINUE
      NKVIEW=IDVIEW
      GO TO 10
C
   40 WRITE (CHMAIL,1000)
      CALL GMAIL(0,0)
      GO TO 999
C
   50 WRITE (CHMAIL,1100)
      CALL GMAIL(0,0)
      GO TO 999
C
   60 WRITE (CHMAIL,1200)
      CALL GMAIL(0,0)
C
 1000 FORMAT (' ERROR IN GDOPEN: VIEW ALREADY EXISTING')
 1100 FORMAT (' ERROR IN GDOPEN: MEMORY OVERFLOW IN PUSHING A BANK')
 1200 FORMAT (' ERROR IN GDOPEN: ANOTHER VIEW IS ALREADY OPENED')
  999 RETURN
      END
+DECK,  GDOPT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDOPT(IOPTC,IVALC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Set options for the drawing package                      *
C.    *                                                                *
C.    *       IOPTN = option (input)                                   *
C.    *       IVALN = value (input)                                    *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini  J.Salt  S.Giani                     *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCSPEE.
+CDE, GCRAYT.
+CDE, GCVDMA.
+CDE, GCPIXE.
C
      CHARACTER*4 IOPTC,IVALC
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH(IVALC,IVAL,4,4)
      IF (IOPTC.EQ.'THRZ') THEN
         IF (IVALC.EQ.'ON  ') THEN
            ITHRZ=IVAL
         ELSE IF (IVALC.EQ.'OFF ') THEN
            ITHRZ=IVAL
         ELSE IF (IVALC.EQ.'180 ') THEN
            ITHRZ=IVAL
         ELSE IF (IVALC.EQ.'360 ') THEN
            ITHRZ=IVAL
         ELSE
            WRITE (CHMAIL,10200) IOPTC,ITHRZ
            CALL GMAIL(0,0)
         ENDIF
      ELSE IF (IOPTC.EQ.'PROJ') THEN
         IF (IVALC.EQ.'PARA') THEN
            IPRJ=IVAL
         ELSE IF (IVALC.EQ.'PERS') THEN
            IPRJ=IVAL
         ELSE
            WRITE (CHMAIL,10200) IOPTC,IPRJ
            CALL GMAIL(0,0)
         ENDIF
      ELSE IF (IOPTC.EQ.'TRAK') THEN
         IF (IVALC.EQ.'LINE') THEN
            ITRKOP=IVAL
         ELSE IF (IVALC.EQ.'POIN') THEN
            ITRKOP=IVAL
         ELSE
            WRITE (CHMAIL,10200) IOPTC,ITRKOP
            CALL GMAIL(0,0)
         ENDIF
*JS
      ELSE IF (IOPTC.EQ.'HIDE') THEN
         IF (IVALC.EQ.'ON  ') THEN
            IHIDEN=IVAL
         ELSE IF (IVALC.EQ.'OFF ') THEN
            IHIDEN=IVAL
         ELSE
            WRITE (CHMAIL,10200) IOPTC,IHIDEN
            CALL GMAIL(0,0)
         ENDIF
*JS
**SG
      ELSE IF (IOPTC.EQ.'SHAD') THEN
         IF (IVALC.EQ.'ON  ') THEN
            LEP=10
         ELSE IF (IVALC.EQ.'OFF ') THEN
            LEP=1
         ENDIF

      ELSE IF (IOPTC.EQ.'EDGE') THEN
         IF (IVALC.EQ.'OFF ') THEN
            LLEP=ABS(LEP)
            IF(LLEP.EQ.10)LEP=11
         ELSE IF (IVALC.EQ.'ON  ') THEN
            LLEP=ABS(LEP)
            IF(LLEP.EQ.11)LEP=10
            IF(LLEP.EQ.1)LEP=1
         ENDIF

      ELSE IF (IOPTC.EQ.'RAYT') THEN
         IF (IVALC.EQ.'ON  ') THEN
             RAYTRA=1.
             IOMBRA=0
+SELF, IF=OLD.
             RAYTRA=0.
+SELF.
         ELSE IF (IVALC.EQ.'OFF ') THEN
             RAYTRA=0.
         ENDIF

      ELSE IF (IOPTC.EQ.'MAPP') THEN
         IF (IVALC.EQ.'0   ') THEN
             NMAP=0
         ELSE IF (IVALC.EQ.'1   ') THEN
             NMAP=1
         ELSE IF (IVALC.EQ.'2   ') THEN
             NMAP=2
         ELSE IF (IVALC.EQ.'3   ') THEN
             NMAP=3
         ELSE IF (IVALC.EQ.'4   ') THEN
             NMAP=4
         ENDIF

      ELSE IF (IOPTC.EQ.'USER') THEN
         IF (IVALC.EQ.'ON  ') THEN
             IMYSE=1
             CALL GSATT('*   ','SEEN',-10)
             CALL GSATT('*   ','COLO',-10)
             CALL GSATT('*   ','LSTY',-10)
         ELSE IF (IVALC.EQ.'OFF ') THEN
             IMYSE=0
             CALL GSATT('*   ','SEEN',1)
             CALL GSATT('*   ','COLO',1)
             CALL GSATT('*   ','LSTY',1)
         ENDIF
**SG
      ELSE
         WRITE (CHMAIL,10000) IOPTC
         CALL GMAIL(0,0)
         WRITE (CHMAIL,10100)
         CALL GMAIL(0,0)
      ENDIF
C
10000 FORMAT(' GDOPT: ',A4,' is not a valid option')
*JS
10100 FORMAT('    Valid options : THRZ , PROJ , TRAK , HIDE , SHAD')
*JS
10200 FORMAT(' GDOPT: Option ',A4,' is ',A4)
*SG
10300 FORMAT(' GDOPT: Option ',A4,' is ',A4)
10400 FORMAT(' Please, compute and set the right size of Zebra',
     +       ' store, needed for your drawing, with LHC option',
     +       ' OFF. If it is done, good luck !!!')
*SG
      END

+DECK,  GDPART, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDPART(IT,ISEL,SIZE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draws attributes of particle generating track IT         *
C.    *       (for which space points have been stored in banks JXYZ). *
C.    *       IT=0 means all tracks.                                   *
C.    *                                                                *
C.    *       If ISEL=xxxxxx1   then draw track number;                *
C.    *       if ISEL=xxxxx1x   then draw particle name.               *
C.    *                                                                *
C.    *       SIZE is character size used.                             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
      CHARACTER*4 IPTAB(100),IPTAB1(100),IPTAB2(100)
      CHARACTER*5 CHPART
      CHARACTER*12 CHTEXT
      SAVE IPTAB,IPTAB1,IPTAB2
C
      DATA IPTAB /'<[G$','<E>[','<E>[','<[N$','<[M>','<[M>','<[P>',
     +            '<[P>','<[P>','K?L&','K[^+','K[^-','<N$ ','<P$ ',
     +            '<-P$','K?<S','<[C$','[L$ ','[S^+','[S^0','[S^-',
     +            '[X^0','[X^-','[W^-','<-N$','<->[','<->[','<->[',
     +            '<->[','<->[','<->[','<->[','<[T>','<[T>','D[^+',
     +            'D[^-','D[^0','<->D','F[^+','F[^-','[L]?','W[^+',
     +            'W[^-','Z[^0','D$  ','T$  ','<[A$','G$  ',
     +                52*'"4$ '/
      DATA IPTAB1/'    ','^+$ ','^-$ ','    ','^+$ ','^-$ ','^0$ ',
     +            '^+$ ','^-$ ','[^0$','$   ','$   ','    ','    ',
     +            '    ','>&[^','    ','    ','$   ','$   ','$   ',
     +            '$   ','$   ','$   ','    ','L$  ','S^-$','S^0$',
     +            'S^+$','X^0$','X^+$','W^+$','^+$ ','^-$ ','$   ',
     +            '$   ','$   ','[^0$','$   ','$   ','C&[^','$   ',
     +            '$   ','$   ','    ','    ','    ','    ',
     +                52*'    '/
      DATA IPTAB2/'    ','    ','    ','    ','    ','    ','    ',
     +            '    ','    ','L   ','    ','    ','    ','    ',
     +            '    ','0$  ','    ','    ','    ','    ','    ',
     +            '    ','    ','    ','    ','    ','    ','    ',
     +            '    ','    ','    ','    ','    ','    ','    ',
     +            '    ','    ','    ','    ','    ','+$  ','    ',
     +            '    ','    ','    ','    ','    ','    ',
     +                52*'    '/
C.
C.    ------------------------------------------------------------------
C.
+SELF, IF=DEBUG.
      IF (IT.LT.0) THEN
         IPART=0
         DO 10 IV=19,1,-2
            DO 10 IU=1,19,2
               IPART=IPART+1
               CHTEXT=IPTAB(IPART)//IPTAB1(IPART)//IPTAB2(IPART)
               U=IU
               V=IV
               CALL GDRAWT(U,V,CHTEXT,SIZE,0.,1,0)
   10    CONTINUE
      ENDIF
+SELF.
C
      CALL UCTOH('OFF ',IOFF,4,4)
      CALL UCTOH('$   ',IDOL,4,4)
C
C            Set IOBJ to TRACK
C
      IOBJ=2
C
      ISEL1=ISEL/10
      ISEL1=ISEL1-ISEL1/2*2
      ISEL0=ISEL/1
      ISEL0=ISEL0-ISEL0/2*2
C
      IF(JXYZ.LE.0)GO TO 30
      NXYZ=IQ(JXYZ-2)
      N1  =1
      N2  =NXYZ
      IF(IT.NE.0)N1=IT
      IF(IT.NE.0)N2=IT
      IF(N1.LE.0)GO TO 30
      IF(N2.GT.NXYZ)GO TO 30
C
      DO 20 I=N1,N2
C
         JX=LQ(JXYZ-I)
         IF(JX.LE.0)GO TO 20
         IPOINT=JX+3
         IF(IPOINT.GT.JX+IQ(JX-1))GO TO 20
         NPOINT=Q(IPOINT)
         IF(NPOINT.LE.0)GO TO 20
         IPART=Q(IPOINT+1)
C
C            Is THRZ option set on (R-Z projection)
C            and the cut lateral (vertical or horizontal) ?
C
         IF (ITHRZ.NE.IOFF) THEN
            IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-I
         ELSE
            ITR3D=0
         ENDIF
C
         CALL GDFR3D(Q(IPOINT+3*NPOINT-1),1,U0,V0)
C
         IF (ISEL0.NE.0) THEN
C
C             Draw track number I
C
            WRITE (CHPART,'(I4,''$'')') I
            U=U0-0.5*SIZE
            V=V0-1.5*SIZE
            CALL GDRAWT(U,V,CHPART,SIZE,0.,1,0)
         ENDIF
C
         IF (ISEL1.NE.0) THEN
C
C             Draw particle name IPTAB...(IPART)
C
            CHTEXT=IPTAB(IPART)//IPTAB1(IPART)//IPTAB2(IPART)
            U=U0-0.5*SIZE
            V=V0+0.5*SIZE
            CALL GDRAWT(U,V,CHTEXT,SIZE,0.,1,0)
         ENDIF
C
   20 CONTINUE
C
   30 CONTINUE
C
C             Reset ITR3D to 'standard projection'
C
      ITR3D=0
      IOBJ=0
C
      END
+DECK,  GDPLST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDPLST(JVSIM,NAME,LEVMAX,KXXX)
*
***************************************************************
*                                                             *
*  Routine name: GDPLST                     Date: 19-2-92     *
*                                                             *
*  Function: It performs the drawing of the tree under the    *
*            user control. Clicking the left button of the    *
*            mouse when the cursor is inside the name's box   *
*            will display the specification of such a volume, *
*            clicking on the red arrows will display the tree *
*            below it, clicking on the green arrows will dis- *
*            play the tree starting from an upper level.      *
*            The number of levels displayed in both cases     *
*            depends on the arrow which has been clicked.     *
*                                                             *
*  Author: S. Giani   ******                                  *
*                                                             *
***************************************************************
*
+CDE, GCBANK.
+CDE, PAWC.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCGOBJ.
+CDE, GCMUTR.
+CDE, GCSPEE.
+CDE, GCHIL2.
+CDE, GCCURS.
+CDE, GCURSB.
*
      CHARACTER*4 NAME,SAVNAM,NAME1,MOTH,SAVSAN,NNNN
      CHARACTER*1 GCHAR
*
      IF(NNPAR.EQ.3.AND.KXXX.EQ.0)GOTO 110
      JSIM=0
      IDINAM=2
      IF(JAASS1.NE.0) CALL MZDROP(IXSTOR, JAASS1, ' ')
      IF(JAASS2.NE.0) CALL MZDROP(IXSTOR, JAASS2, ' ')
      IF(JAASS3.NE.0) CALL MZDROP(IXSTOR, JAASS3, ' ')
      IF(JAASS4.NE.0) CALL MZDROP(IXSTOR, JAASS4, ' ')
      IF(JTICKS.NE.0) CALL MZDROP(IXSTOR, JTICKS, ' ')
      IF(JMYLLS.NE.0) CALL MZDROP(IXSTOR, JMYLLS, ' ')
      IF(JMYMOT.NE.0) CALL MZDROP(IXSTOR, JMYMOT, ' ')
      NEE=NUMND1+10
      NEES=NEE*7
      CALL MZNEED(IXDIV,NEES,'G')
      CALL MZBOOK(IXDIV,JAASS1,JAASS1,1,'TREX',0,0,NEE,3,-1)
      CALL MZBOOK(IXDIV,JAASS2,JAASS2,1,'TREY',0,0,NEE,3,-1)
      CALL MZBOOK(IXDIV,JAASS3,JAASS3,1,'NAMS',0,0,NEE,2,-1)
      CALL MZBOOK(IXDIV,JAASS4,JAASS4,1,'SCAS',0,0,NEE,2,-1)
      CALL MZBOOK(IXDIV,JTICKS,JTICKS,1,'TICK',0,0,NEE,2,-1)
      CALL MZBOOK(IXDIV,JMYLLS,JMYLLS,1,'MYLS',0,0,NEE,2,-1)
      CALL MZBOOK(IXDIV,JMYMOT,JMYMOT,1,'MYMO',0,0,NEE,2,-1)
      CALL IGRNG(YPLT,XPLT)
      SAVNAM=NAME
      SAVSAN=SAVNAM
      LSAVLE=LEVMAX
      LSAVSA=LSAVLE
      YPLTNE=YPLT
      XPLTNE=XPLT
      NUMNDS=NUMND1
      DO 10  J=1,NUMND1
         Q(JAASS1+J)=Q(JULEV+J)
         Q(JAASS2+J)=Q(JVLEV+J)
         IQ(JAASS3+J)=IQ(JNAM1+J)
         IQ(JAASS4+J)=IQ(JSCA1+J)
         IQ(JTICKS+J)=IQ(JTICK+J)
         IQ(JMYLLS+J)=IQ(JMYLL+J)
         IQ(JMYMOT+J)=IQ(JMOT1+J)
   10 CONTINUE
      IPLAC=LEVMAX
   20 CONTINUE
      IPICK=0
      IF(IDINAM.EQ.2)THEN
        CALL IGRNG(YPLT,XPLT)
      ELSE
        CALL IGRNG(YPLTNE,XPLTNE)
      ENDIF
      IF(KXXX.EQ.1)THEN
        KACKT=1
        KCHAR=1
        IPICK=1
         CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
         IF (IVO.LE.0) GO TO 110
        GOTO 50
      ENDIF
      CALL IRQLC(1,1,KCHAR,NT,V0,U0)
      IF (KCHAR.EQ.0) GO TO 50
      GCHAR=CHAR(KCHAR)
      IF(IDINAM.EQ.2)THEN
        NUMNUM=NUMND1
      ELSE
        NUMNUM=NUMNDS
      ENDIF
      DO 40  J=1,NUMNUM
       IF(IDINAM.EQ.2)THEN
         IF (IQ(JSCA1+J).NE.0) THEN
            IF(U0.LT.(Q(JULEV+J)-SIZD2).OR.U0.GT.(Q(JULEV+J)+SIZD2))
     +      GO TO 30
            IF(V0.LT.(Q(JVLEV+J)-(SIZD2*2.*FACHV)-HALF).OR.V0.GT.(
     +      Q(JVLEV+J)+(SIZD2*2.*FACHV)+HALF)) GO TO 30
            IPICK=J
            KACKT=0
            IF(V0.LT.(Q(JVLEV+J)-(SIZD2*2.*FACHV)))THEN
               KACKT=-1
               PLAC=((Q(JVLEV+J)-(SIZD2*2.*FACHV))-V0)*(IQ(JMYLL+J)
     +         -1)/HALF
               IPLACS=PLAC+1
            ENDIF
            IF(V0.GT.(Q(JVLEV+J)+(SIZD2*2.*FACHV)))THEN
               KACKT=1
               PLAC=(V0-(Q(JVLEV+J)+(SIZD2*2.*FACHV)))*IQ(JTICK+J)/
     +         HALF
               IPLAC=PLAC
*                 IF((PLAC-IPLAC).GT..5)IPLAC=IPLAC+1
               IPLAC=IPLAC+2
            ENDIF
            IF (KCHAR.EQ.1.OR.KCHAR.EQ.2) GO TO 50
            IF(GCHAR.EQ.' ')GO TO 50
            CALL UHTOC(IQ(JNAM1+J),4,NAME1,4)
            IF (GCHAR.EQ.'2') THEN
               CALL GSATT(NAME1,'SEEN',-2)
            ELSE IF (GCHAR.EQ.'-') THEN
               CALL GSATT(NAME1,'SEEN',-1)
            ELSE IF (GCHAR.EQ.'0') THEN
               CALL GSATT(NAME1,'SEEN',0)
            ELSE IF (GCHAR.EQ.'1') THEN
               CALL GSATT(NAME1,'SEEN',1)
            ENDIF
            GO TO 20
         ENDIF
       ENDIF
   30    CONTINUE
   40 CONTINUE
   50 CONTINUE
      IF(KCHAR.EQ.0)THEN
       IF(IDINAM.EQ.2)THEN
         IF(JVSIM.EQ.2.AND.JSIM.EQ.1)CALL ICLWK(2)
         GOTO 110
       ENDIF
      ELSE
         IF (IPICK.NE.0) THEN
          IF(JSIM.EQ.0.AND.JVSIM.EQ.2.AND.KACKT.EQ.0)THEN
            JSIM=1
            CALL IOPWK(2,1,9)
          ENDIF
           IF(IDINAM.EQ.1)THEN
            CALL UHTOC(IQ(JAASS3+IPICK),4,NAME,4)
            CALL IDAWK(1)
            CALL IACWK(JVSIM)
           ELSEIF(IDINAM.EQ.2.AND.KXXX.NE.1)THEN
            CALL UHTOC(IQ(JNAM1+IPICK),4,NAME,4)
           ENDIF
            CALL ISELNT(1)
*            CALL ICLRWK(JVSIM,1)
            IF(KACKT.NE.0)CALL ICLRWK(0,0)
            IF(KACKT.EQ.0)THEN
               CALL IDAWK(1)
               CALL IACWK(JVSIM)
               CALL IGRNG(SAVPLX,SAVPLY)
               CALL ICLRWK(0,0)
               CALL GDSPEC(NAME)
               CALL IDAWK(JVSIM)
               CALL IACWK(1)
               IF(IDINAM.EQ.2.AND.JVSIM.EQ.1)THEN
                     CALL IRQLC(1,1,KCHAR,NT,V0,U0)
                     CALL ICLRWK(0,0)
                     CALL ISELNT(1)
                     INTFLA=1
                     CALL GDTREE(SAVSAN,0,110)
                     INTFLA=-1
                     CALL GDTREE(SAVSAN,LSAVSA,111)
               ENDIF
            ELSEIF(KACKT.EQ.1)THEN
               IF(KXXX.EQ.1)KXXX=0
               NUMNDA=NUMND1
               NUMND1=NUMND2
               NNNN=NAME
               IADDI=0
               DO 81  JI=1,NUMND2
                  IQ(JNAM1+JI)=IQ(JFINAM+JI)
                  IQ(JSCA1+JI)=IQ(JFISCA+JI)
                  IQ(JMOT1+JI)=IQ(JFIMOT+JI)
   81          CONTINUE
               IF(NAME.EQ.MOMO)GOTO 41
               DO 91  II=1,16
                  CALL GDTR8(NAME,MOTH,IONL)
                  IF(MOTH.EQ.MOMO)THEN
                   IADDI=II
                   GOTO 41
                  ENDIF
                  NAME=MOTH
   91          CONTINUE
   41          CONTINUE
               NUMND1=NUMNDA
               NAME=NNNN
               INTFLA=1
               CALL GDTREE(NAME,0,110)
               INTFLA=-1
               IF(NNPAR.NE.3)THEN
                CALL GDTREE(NAME,IPLAC,111)
               ELSE
                CALL GDTREE(NAME,IPLAC,IISELT)
                GOTO 110
               ENDIF
               IF(IDINAM.EQ.2.OR.KCHAR.EQ.2)THEN
                     SAVSAN=NAME
                     LSAVSA=IPLAC
               ENDIF
            ELSEIF(KACKT.EQ.-1)THEN
               NUMNDA=NUMND1
               NUMND1=NUMND2
               IADDI=0
               DO 80  JII=1,NUMND2
                  IQ(JNAM1+JII)=IQ(JFINAM+JII)
                  IQ(JSCA1+JII)=IQ(JFISCA+JII)
                  IQ(JMOT1+JII)=IQ(JFIMOT+JII)
   80          CONTINUE
               DO 90  II=1,IPLACS
                  CALL GDTR8(NAME,MOTH,IONL)
                  NAME=MOTH
   90          CONTINUE
               NNNN=NAME
               IF(NAME.EQ.MOMO)GOTO 42
               DO 92  II=1,16
                  CALL GDTR8(NAME,MOTH,IONL)
                  IF(MOTH.EQ.MOMO)THEN
                   IADDI=II
                   GOTO 42
                  ENDIF
                  NAME=MOTH
   92          CONTINUE
   42          CONTINUE
               NAME=NNNN
               NUMND1=NUMNDA
               INTFLA=1
               CALL GDTREE(NAME,0,110)
               INTFLA=-1
               CALL GDTREE(NAME,IPLAC,111)
               IF(IDINAM.EQ.2.OR.KCHAR.EQ.2)THEN
                     SAVSAN=NAME
                     LSAVSA=IPLAC
               ENDIF
            ENDIF
            CALL ISELNT(1)
            GO TO 20
         ELSE
            GOTO 20
         ENDIF
      ENDIF
*
 110  CONTINUE
***************      CALL IGRNG(SAVPLX,SAVPLY)
      IF(JAASS1.NE.0) CALL MZDROP(IXSTOR, JAASS1, ' ')
      IF(JAASS2.NE.0) CALL MZDROP(IXSTOR, JAASS2, ' ')
      IF(JAASS3.NE.0) CALL MZDROP(IXSTOR, JAASS3, ' ')
      IF(JAASS4.NE.0) CALL MZDROP(IXSTOR, JAASS4, ' ')
      IF(JTICKS.NE.0) CALL MZDROP(IXSTOR, JTICKS, ' ')
      IF(JMYLLS.NE.0) CALL MZDROP(IXSTOR, JMYLLS, ' ')
      IF(JMYMOT.NE.0) CALL MZDROP(IXSTOR, JMYMOT, ' ')
      IF(JMYLL.NE.0) CALL MZDROP(IXSTOR, JMYLL, ' ')
      IF(JTICK.NE.0) CALL MZDROP(IXSTOR, JTICK, ' ')
               IF(JFIMOT.NE.0) CALL MZDROP(IXSTOR, JFIMOT, ' ')
               IF(JFISCA.NE.0) CALL MZDROP(IXSTOR, JFISCA, ' ')
               IF(JFINAM.NE.0) CALL MZDROP(IXSTOR, JFINAM, ' ')
      LARETT(1)=0
  999 END
+DECK,  GDPRTR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:23  cernlib
* Geant

      SUBROUTINE GDPRTR(NAME,YLEV,XLEV,SIZE,FACHV,
     +IDUP,IDRAW,IONL,IDET,ISEEN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draws a box centered in (XLEV,YLEV) of size SIZE.        *
C.    *       On the top half box draws its name NAME and, if IDUP<>1, *
C.    *       on the bottom half draw IDUP preceded by a symbol        *
C.    *       (IDUP<0 means division, IDUP>1 means multiple position,  *
C.    *       IDUP=1 means single position).                           *
C.    *       If IDRAW=1 then over the box draws a normal-view of      *
C.    *       volume NAME (with same seen attributes set by GDSPEC).   *
C.    *       If IONL<>1 then draw two other boxes, slightly shifted,  *
C.    *       behind the original one.                                 *
C.    *       If IDET=1 then draw another box, slightly larger,        *
C.    *       around the original one.                                 *
C.    *       If ISEEN=0 then draw the box(es) with dashed lines.      *
C.    *                                                                *
C.    *    ==>Called by : GDTREE                                       *
C.    *       Author : P.Zanarini ; S.Giani  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCDRAW.
      DIMENSION X(5),Y(5)
      DIMENSION NAMT0(16),NAM0(4)
      DIMENSION PAR(50)
      DIMENSION NNDM(14),INDM(4,14)
      DIMENSION ATT(10)
      CHARACTER*4 NAME,NAMSEE,ISON
      CHARACTER*14 CHNAM0
      SAVE NNDM,INDM
      COMMON/NPILEV/NPILE
C
      DATA NNDM/0,0,0,4,0,2,0,2,4,3,4,3,0,0/
      DATA INDM/0,0,0,0, 0,0,0,0, 0,0,0,0, 2,3,7,11, 0,0,0,0,
     +          4,5,0,0, 0,0,0,0, 6,7,0,0, 3,4,5,6, 4,5,6,0,
     +          1,2,3,4, 1,2,3,0, 0,0,0,0, 0,0,0,0/
C.
C.    ------------------------------------------------------------------
C.
      IF (ISEEN.EQ.0) THEN
         LINSTY=4
      ELSE
         LINSTY=1
      ENDIF
      CALL MVBITS(LINSTY,0,3,LINATT,10)
C
C            Compute box vertex
C
      SIZ2=SIZE/2.
      SIZ4=SIZE/4.
      SIZ8=SIZE/8.
***      X(1)=XLEV-SIZ2
      X(1)=XLEV-(SIZ2*2.*FACHV)
      X(2)=X(1)
***      X(3)=XLEV+SIZ2
      X(3)=XLEV+(SIZ2*2.*FACHV)
      X(4)=X(3)
      X(5)=X(1)
      Y(1)=YLEV+SIZ2
      Y(2)=YLEV-SIZ2
      Y(3)=Y(2)
      Y(4)=Y(1)
      Y(5)=Y(1)
C
C            Draw box
C
      IWTY=IGIWTY(1)
      CALL IGQWK(0,'HWCO',R)
      IF(IWTY.GT.10.OR.IWTY.LT.1.OR.R.EQ.2.)THEN
         LINCOL=1
         CALL MVBITS(LINCOL,0,8,LINATT,16)
         CALL GDRAWV(X,Y,5)
      ELSE
         CALL IGSET('LWID',1.)
         CALL UCTOH(NAME,IIIN,4,4)
         CALL IGPID(1,'Tree',IIIN,' ')
         CALL IGPAVE(X(1),X(3),Y(1),Y(3),SIZ8,1004,1001,'TRS')
      ENDIF
C
C            If volume is also detector draw another box outside
C
      IF (IDET.EQ.1) THEN
         X(1)=X(1)-SIZ8
         X(2)=X(2)-SIZ8
         X(3)=X(3)+SIZ8
         X(4)=X(4)+SIZ8
         X(5)=X(5)-SIZ8
         Y(1)=Y(1)+SIZ8
         Y(2)=Y(2)-SIZ8
         Y(3)=Y(3)-SIZ8
         Y(4)=Y(4)+SIZ8
         Y(5)=Y(5)+SIZ8
         LINCOL=1
         CALL MVBITS(LINCOL,0,8,LINATT,16)
         CALL GDRAWV(X,Y,5)
      ENDIF
C
C            If volume is not 'ONLY' draw two other boxes behind
C
      IF (IONL.NE.1) THEN
         X(1)=XLEV+(SIZ2*2.*FACHV)-SIZ8
         Y(1)=YLEV+SIZ2
         X(2)=X(1)
         Y(2)=Y(1)+SIZ8
         X(3)=X(2)-(SIZE*2.*FACHV)
         Y(3)=Y(2)
         X(4)=X(3)
         Y(4)=Y(3)-SIZE
         X(5)=X(4)+SIZ8
         Y(5)=Y(4)
         LINCOL=1
         CALL MVBITS(LINCOL,0,8,LINATT,16)
         CALL GDRAWV(X,Y,5)
         DO 10 I=1,5
            X(I)=X(I)-SIZ8
            Y(I)=Y(I)+SIZ8
   10    CONTINUE
         CALL GDRAWV(X,Y,5)
      ENDIF
C
      LINSTY=1
      CALL MVBITS(LINSTY,0,3,LINATT,10)
C
C            Draw name
C
      YL=YLEV-SIZ2+(SIZ8/2.)
      IF(FACHV.EQ.1.)YL=YLEV-SIZ8
      XL=XLEV-(SIZ4*FACHV)+SIZ8
      IF(FACHV.EQ.1.)XL=XLEV
      SZ=1.5*SIZ4*2.
      IF(FACHV.EQ.1.)SZ=1.*SIZ4*2.
      ITXCOL=5
      CALL MVBITS(ITXCOL,0,4,ITXATT,3)
      AITXCO=ITXCOL
      CALL IGSET('TXCI',AITXCO)
      CALL IGSET('TXFP',-60.)
      IWTY=IGIWTY(1)
      IF(IWTY.GT.10.OR.IWTY.LT.1)CALL IGSET('TXFP',-61.)
***      CALL IGPID(1,'Tree',NPILE,' ')
      CALL GDRAWT(XL,YL,NAME,SZ,0.,4,0)
      CALL IGSET('TXFP',2.)
      CALL IGSET('TXCI',1.)
C
      IF (IDUP.EQ.1) GO TO 20
C
C            Draw IDUP in bottom half box
C
      CALL UCTOH('<"4#>',NAMT0(1),1,5)
      IF (IDUP.LT.0) CALL UCTOH('F',NAMT0(3),1,1)
      DUP=FLOAT(IABS(IDUP))
      CALL HBCDF(DUP,8,NAMT0(6))
      CALL UCTOH('$',NAMT0(14),1,1)
      CALL UBUNCH(NAMT0,NAM0,14)
      CALL UHTOC(NAM0,4,CHNAM0,14)
      XL=XLEV+(SIZ4*FACHV)+SIZ2
      IF(FACHV.EQ.1.)XL=XLEV-(3.*SIZ8)
      YL=YLEV-SIZ4-SIZ8
      IF(FACHV.EQ.1.)YL=YLEV-SIZ2+(SIZ8/2.)
      SZ=0.7*SIZ4*2.
      IF(FACHV.EQ.1.)SZ=0.7*SIZ4*1.5
      ITXCOL=5
      CALL MVBITS(ITXCOL,0,4,ITXATT,3)
      AITXCO=ITXCOL
      CALL IGSET('TXCI',AITXCO)
      CALL IGSET('TXFP',2.)
***      CALL IGPID(1,'Tree',NPILE,' ')
      CALL GDRAWT(XL,YL,CHNAM0,SZ,0.,10,-1)
      CALL IGSET('TXCI',1.)
C
   20 CONTINUE
C
      IF (IDRAW.NE.1) GO TO 999
C
C             Draw a normal view of the volume
C
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.LE.0) GO TO 999
C
      JVO=LQ(JVOLUM-IVO)
C
C                GET PARAMETERS
C
      CALL GFPARA(NAME,1,0,NPAR,NATT,PAR,ATT)
      IF(NPAR.LE.0) GO TO 999
C
      ISHAPE=Q(JVO+2)
C
C             CHECK parametER SIZES
C
      PARMAX=-1.
      DO 50  I=1,NPAR
         IF(ISHAPE.GT.14)GO TO 50
         IF(NNDM(ISHAPE).LE.0) GO TO 40
C
         NDM=NNDM(ISHAPE)
         DO 30  IDM=1,NDM
C
            IF(I.EQ.INDM(IDM,ISHAPE)) GO TO 50
C
   30    CONTINUE
   40    CONTINUE
C
         ABSPAR=ABS(PAR(I))
         PARMAX=MAX(PARMAX,ABSPAR)
   50 CONTINUE
      XSCALE=SIZE/(3.*PARMAX)
      YSCALE=XSCALE
      XPOS=XLEV-(SIZE*FACHV*2)+SIZ8
      YPOS=YLEV
*      YPOS=YLEV+SIZE
C
      CALL GFATT(NAME,'SEEN',KSEEN)
C
C             Add local value KSEEN 1 to starting node of tree
C
      KSEEN=KSEEN+110
      ISEEN=KSEEN
      CALL GSATT(NAME,'SEEN',ISEEN)
C
      CALL GDNSON(NAME,NSON,IDIV)
      DO 60  N=1,NSON
         CALL GDSON(N,NAME,ISON)
         CALL GFATT(ISON,'SEEN',KSEEN)
C
C             ISON is a volume with multeplicity;
C             first occurrence has already been set
C
         IF (KSEEN.GT.50) GO TO 60
C
C             Add local value SEEN -2 to each one-level-down node
C
         KSEEN=KSEEN+80
         ISEEN=KSEEN
         CALL GSATT(ISON,'SEEN',ISEEN)
   60 CONTINUE
      CALL GDRAW(NAME,45.,135.,0.,XPOS,YPOS,XSCALE,YSCALE)
C
C             Reset global SEEN values
C
      DO 70  IVO=1,NVOLUM
         CALL UHTOC(IQ(JVOLUM+IVO),4,NAMSEE,4)
         CALL GFATT(NAMSEE,'SEEN',KSEEN)
         IF (KSEEN.LT.50) GO TO 70
         ISEENL=KSEEN/10.+0.5
         ISEENG=KSEEN-ISEENL*10.
         CALL GSATT(NAMSEE,'SEEN',ISEENG)
   70 CONTINUE
C
  999 END
+DECK,  GDRACK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GDRACK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       RAY-TRACING                                              *
C.    *       Computation and tracking of all the light rays.          *
C.    *                                                                *
C.    *       Author: S.Giani                                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
********************************************************************************
+CDE, GCDRAW.
+CDE, GCONST.
+CDE, GCMUTR.
+CDE, PAWC.
********************************************************************************
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCPHYS.
+CDE, GCPARM.
+CDE, GCSETS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCNUM.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
********************************************************************************
+CDE, GCFDIM.
+CDE, GCPIXE.
+CDE, GCRAYT.
+CDE, GCVDMA.

      CHARACTER*4 NAME
      DIMENSION VVVMIN(80),VVVMAX(80)
      SAVE VVVMIN,VVVMAX,ZIMPRE
********************************************************************************
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      DIMENSION CUTS(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      SAVE PRECOR
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
C.
C.    ------------------------------------------------------------------
         FINVIS=1./ISFILL
         LLL=1
         ZLN=0.
         IF(IMAP.EQ.1)ZIMPRE=LIMPRE
         IF(IMAP.EQ.2)THEN
           ZRATIO=LIMPRE/ZIMPRE
         ENDIF
         DO 21 IIIJ=1,LIMPRE
           IF(IMAP.EQ.1)THEN
            VVVMIN(IIIJ)=10000.
            VVVMAX(IIIJ)=0.
           ELSEIF(IMAP.EQ.2)THEN
            ZLN=ZLN+1
            IF((ZLN-ZRATIO).GT.0.001)THEN
              ZLN=ZLN-ZRATIO
              LLL=LLL+1
            ENDIF
           ENDIF
           VVV=FINVIS
           IYYY=1
           IF(IIIJ.NE.1)THEN
             UUU=UUU+FINVIS
             IXXX=IXXX+1
           ENDIF
          DO 23 JJJI=1,LIMPRE
           IF(IMAP.EQ.2)THEN
            IF(LLL.EQ.1)THEN
             VVMA=VVVMAX(LLL)
             VVMI=VVVMIN(LLL)
            ELSE
             VVMA=MAX(VVVMAX(LLL-1),VVVMAX(LLL))
             VVMI=MIN(VVVMIN(LLL-1),VVVMIN(LLL))
            ENDIF
            IF(((VVV-(VVMA+ZNMAP1)).GT.0.001).OR.
     +        ((VVV-(VVMI-ZNMAP1)).LT.-0.001))GOTO 22
           ENDIF
            IF(IIIJ.EQ.1.AND.JJJI.EQ.1)THEN
               MYTRME=NUMED
               ime=0
*               print *,vect(1),vect(2),vect(3),'vertex from gtrack'
*               print *,vect(4),vect(5),vect(6),'impulse from gtrack'
               GOTO 9
            ENDIF
                                 XPINTS=ZROTS(1,4)+ZROTS(1,1)*
     +                           UUU+ZROTS(1,2)*VVV+ZROTS(1,3)*
     +                           ZUV
                                 YPINTS=ZROTS(2,4)+ZROTS(2,1)*
     +                           UUU+ZROTS(2,2)*VVV+ZROTS(2,3)*
     +                           ZUV
                                 ZPINTS=ZROTS(3,4)+ZROTS(3,1)*
     +                           UUU+ZROTS(3,2)*VVV+ZROTS(3,3)*
     +                           ZUV
            JON=0
            ISSEEN=0
            IME=0
            SLENG=0.
            NUMED=MYTRME
            NSTEP=0
            INFROM=0
            nlevel=1
       CALL UCTOH('PERS',IPERS,4,4)
       XCOSXS=(SIN(GTHETA*DEGRAD))*(COS(GPHI*DEGRAD))
       YCOSYS=(SIN(GTHETA*DEGRAD))*(SIN(GPHI*DEGRAD))
       ZCOSZS=COS(GTHETA*DEGRAD)
       VDX=XCOSXS
       VDY=YCOSYS
       VDZ=ZCOSZS
       VECT(1)=XPINTS
       VECT(2)=YPINTS
       VECT(3)=ZPINTS
       IF(IPERS.EQ.IPRJ)THEN
        CONMOD=1./SQRT(((XPINTS-FPINTX)**2)+((YPINTS-FPINTY)**2)+
     +                 ((ZPINTS-FPINTZ)**2))
        XCOSXS=-(XPINTS-FPINTX)*CONMOD
        YCOSYS=-(YPINTS-FPINTY)*CONMOD
        ZCOSZS=-(ZPINTS-FPINTZ)*CONMOD
       ENDIF
       VECT(4) = -XCOSXS
       VECT(5) = -YCOSYS
       VECT(6) = -ZCOSZS
       IF(VECT(1).LE.XCUT.OR.VECT(2).LE.YCUT.OR.VECT(3).LE.ZCUT)THEN
         CALL GTMEDI (VECT, NUMED)
       ENDIF
 9    CONTINUE

      ISTOP = 0
      EPSCUR = EPSMAC
      NSTOUT = 0
      INWOLD = 0
      LSAMVL = .FALSE.
      NUMOLD=0
*
* *** Check validity of tracking medium and material parameters
*
   10 IF (NUMED.NE.NUMOLD) THEN
         NUMOLD = NUMED
         IUPD   = 0
         JTM    = LQ(JTMED- NUMED)
         EPSIL    = Q(JTM + 13)
         PRECOR   = MIN(0.1*EPSIL, 0.0010)
*
         NMAT     = Q(JTM + 6)
         JMA   = LQ(JMATE-NMAT)
         DENS = Q(JMA +8)
      ENDIF
        IF(ISCOLO.EQ.-10.OR.IMYSE.EQ.0)ISCOLO=MOD(NUMED,6)+2
        IF(ISLSTY.EQ.-10.OR.IMYSE.EQ.0)ISLSTY=4
        IF(ISSEEN.EQ.-10.OR.IMYSE.EQ.0)THEN
         IF(IME.EQ.1)THEN
         IF(DENS.LT.0.00130)THEN
          ISSEEN=0
         ELSE
          ISSEEN=1
         ENDIF
         ENDIF
        ENDIF
        IF(IME.EQ.0)IME=1
*
      IF(LSAMVL) THEN
*
*       If now the particle is entering in the same volume where
*       it was exiting from last step, and if it has done this for
*       more than 5 times, we decrease the precision of tracking
         NSTOUT=NSTOUT+1
         IF(MOD(NSTOUT,5).EQ.0) THEN
            EPSCUR=NSTOUT*EPSMAC
*            WRITE(CHMAIL,10000)ITRA,ISTAK,NTMULT,NAPART
*10000          FORMAT(' *** GTRACK *** Boundary loop: track ',
*     +         I4,' stack ',I4,' NTMULT ',I5,1X,5A4)
*            CALL GMAIL(1,0)
*            WRITE(CHMAIL,10100) EPSCUR
*10100          FORMAT('                Precision now set to ',G10.3)
*            CALL GMAIL(0,1)
         ENDIF
      ELSE
         NSTOUT = 0
         EPSCUR = EPSMAC
      ENDIF
*
      INWVOL = 1
*
* *** Compute SET and DET number if volume is sensitive
*
      IF (JSET.GT.0) CALL GFINDS
*
*    Clear step dependent variables
*
   80 NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      IGNEXT = 0
      INWOLD = INWVOL
      PREC   = MAX(PRECOR,MAX(ABS(VECT(1)),ABS(VECT(2)),
     +                        ABS(VECT(3)),SLENG)*EPSCUR)
*
*     Give control to user at entrance of volume (INWVOL=1)
*
      IF (INWVOL.EQ.1) THEN
         CALL GDSTEP
         IF (ISTOP.NE.0) GO TO 22
         INWVOL = 0
      ENDIF
*
* *** Propagate particle up to next volume boundary or end of track
*
      INGOTO = 0
      NLEVIN = NLEVEL
      IF (IPARAM.NE.0) THEN
         IF (GEKIN.LE.PACUTS(ITRTYP)) THEN
            NMEC = NMEC+1
            LMEC(NMEC) = 26
            ISTOP = 2
+SELF, IF=-USRJMP.
            CALL GUPARA
+SELF, IF=USRJMP.
            CALL JUMPT0(JUPARA)
+SELF.
            GO TO 90
         ENDIF
      ENDIF

         CALL GDNINO

      STLOSS=STEP
*
*     Check for possible endless loop
*
   90 NSTEP = NSTEP +1

      IF (NSTEP.GT.MAXNST) THEN
         IF (ISTOP.EQ.0) THEN
            ISTOP = 99
            NMEC  = NMEC +1
            LMEC(NMEC) = 30
*            WRITE(CHMAIL,10200) MAXNST
*            CALL GMAIL(1,0)
*            WRITE(CHMAIL,10300)ITRA,ISTAK,NTMULT,(NAPART(I),I=1,5),
*     +      TOFG*1.E9
*            CALL GMAIL(0,1)
*10200       FORMAT(' *** GTRACK *** More than ',I6,
*     +             ' steps, tracking abandoned!')
*10300       FORMAT('                Track ',I4,' stack ',I4,' NTMULT ',
*     +             I5,1X,5A4,1X,'Time of flight ',F10.3,' ns')
         ENDIF
      ENDIF
*
* *** Give control to user at end of each tracking step
*
      SAFETY = SAFETY -STEP
      CALL GDSTEP
*
      IF (ISTOP.NE.0) GO TO 22
*
*      Renormalize direction cosines
*
      CMOD = 1./SQRT(VECT(4)*VECT(4)+VECT(5)*VECT(5)+VECT(6)*VECT(6))
      VECT(4) = VECT(4)*CMOD
      VECT(5) = VECT(5)*CMOD
      VECT(6) = VECT(6)*CMOD
*
      IF (INWVOL.EQ.0) GO TO 80
*
      IF (NJTMAX.GT.0) THEN
         CALL GSTRAC
         IF (NLEVIN.EQ.0) GO TO 100
         GO TO 22
      ELSE
         IF (NLEVIN.GE.NLEVEL) THEN
            INFROM = 0
         ELSE
            IF (NLEVIN.EQ.0) GO TO 100
            INFROM = LINDEX(NLEVIN+1)
         ENDIF
         IF (NLEVIN.NE.NLEVEL) INGOTO = 0
         NLEVEL = NLEVIN
*
         CALL GTMEDI (VECT, NUMED)
         IF (NUMED.NE.0) THEN
            SAFETY = 0.
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
*            print *,NAME
           IF(IMYSE.EQ.1)THEN
            CALL GFIND(NAME,'SEEN',ISSEEN)
            CALL GFIND(NAME,'COLO',ISCOLO)
            CALL GFIND(NAME,'LSTY',ISLSTY)
           ENDIF
*            print *,isseen,iscolo,islsty
            GO TO 10
         ELSE
            ISSEEN=1
         ENDIF
      ENDIF
*
*     Track outside setup, give control to user (INWVOL=3)
*
  100 INWVOL = 3
      ISTOP  = 1
      ISET   = 0
      IDET   = 0
      NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NLCUR  = NLEVEL
      NLEVEL = 1
      CALL GDSTEP
      NLEVEL = NLCUR
 22        CONTINUE
          IF(IMAP.EQ.1)THEN
           IF(JON.EQ.1)THEN
             IF(VVV.LT.VVVMIN(IIIJ))THEN
               VVVMIN(IIIJ)=VVV
             ELSEIF(VVV.GT.VVVMAX(IIIJ))THEN
               VVVMAX(IIIJ)=VVV
             ENDIF
           ENDIF
          ENDIF
           VVV=VVV+FINVIS
           IYYY=IYYY+1
   23     CONTINUE
   21    CONTINUE
*                                                             END GTRACK
  999 END
+DECK,  GDRAW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:24  cernlib
* Geant

      SUBROUTINE GDRAW(NAME,UTHET,UPHI,UPSI,UU0,UV0,SU,SV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This routine draws the object called NAME, with its      *
C.    *       contents, at the screen point (UU0,UV0), with the        *
C.    *       screen factors SU and SV acting on the U and V           *
C.    *       dimensions respectively;                                 *
C.    *       the object is rotated by an angle UTHET along Y-axis     *
C.    *       and UPHI along Z-axis and the resulting 2-D picture      *
C.    *       is also rotated by an angle UPSI along the line of       *
C.    *       projection (i.e. the normal to the 2-D view plane).      *
C.    *                                                                *
C.    *       If IDRNUM<>0 then /GCVOLU/ is already filled by GLVOLU   *
C.    *       and a special case is handled (GDRAW called by GDRVOL).  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDPRTR, GDRAWC, GDRAWX,     *
C.    *                   GDSPEC                                       *
C.    *       Authors : R.Brun, A.McPherson, P.Zanarini,   *********   *
C.    *                 J.Salt, S.Giani                                *
C.    ******************************************************************
C.
***SG**************************************************************************
*                                                                             *
*      Most important improvements in this new version :                      *
*                                                                             *
*      Problems with the number of faces are solved, so that it's             *
*         possible to use all the memory available; moreover it's             *
*         now possible to use HIDE ON on CRAY-like machines;                  *
*                                                                             *
*      Problems with number of volumes now only depends upon the              *
*         size of Zebra store : a message will tell the number of             *
*         words you need more; problems in iterated drawings have             *
*         been solved too.                                                    *
*                                                                             *
*      A NEW SIZE EVALUATION is performed separately for Hide Structure and   *
*         Wire Structure with a resolution of 1 word ; this is the new logic: *
*         create immediately HIDE and WIRE structures and perform the         *
*         drawing WHILE evaluating the memory used; if memory booked in the   *
*         zebra store is not enough, then go on evaluating the number of      *
*         words needed and print it.                                          *
*                                                                             *
*      Multi-colour view of the different parts of a detector is now          *
*         available in Hidden Line Removal; a new bank is created for this.   *
*         Enjoy clipping now !!                                               *
*         Different line styles and width work as well !!                     *
*                                                                             *
*      Zooming is now possible in Hidden Line Removal too; Dspec works        *
*         even when Cvol is on and Seen attribute setting has been            *
*         optimized.                                                          *
*                                                                             *
*      Speed in drawing divided volumes can be increased by a factor about    *
*         linear with the number of volumes (a factor 30 for 900 tubes)!!!    *
*         At the same time, the number of words used can be decreased by a    *
*         factor 50!!! For example, in Gexam1 is possible to draw 22500 tubes *
*         using much less than 800000 words.                                  *
*                                                                             *
*      HIDDEN FACE REMOVAL algorithm has been implemented; it allows to       *
*         increase speed and decrease memory used by the same factors as      *
*         above for any kind of drawings!!! For example, it's now possible    *
*         to draw the complete L3 geometry using less than 3 Mwords (before   *
*         we needed 1 Gigabyte !!!)                                           *
*                                                                             *
*      The new command CVOL has been created: it allows to clip EACH          *
*         VOLUME in the detector by a different SHAPE; moreover, it's possible*
*         to clip twice each volume. You can clip each volume by the following*
*         shapes: BOX , TUBE, CONE, SPHE !                                    *
*                                                                             *
*      The new command SHIFT has been created: it allows to translate each    *
*         volume in the detector into a more visible place; for each volume,  *
*         the last shift you asked is performed.                              *
*                                                                             *
*      The option 'one' has been implemented in the shift command to allow    *
*         the shifting of a single copy for each volume; the new command      *
*         BOMB has been created to allow 'exploded' view of detectors.        *
*                                                                             *
*      A new bank is booked to create CG objects: it's now possible to draw   *
*         in HIDE ON the following shapes as well: PCON, TUBS, SPHE, TRAP     *
*         and Pyramids as TRAP having 4 edges in the same point. Moreover,    *
*         the new shape CTUB has been created even in hide on.                *
*                                                                             *
*      The number of words to draw TUBS, CONS, PCON, PGON can be decreased    *
*         even by a factor 10; moreover, several problems about edge visi-    *
*         bility have been solved.                                            *
*                                                                             *
*      A REFLECTION algorithm has been implemented for hidden line removal    *
*         as well; finally, a new logic scanning the geometrical tree has     *
*         been created to simulate, without alterate, the date structure.     *
*                                                                             *
*      A new SURFACE SHADING algorithm has been written to fill faces with    *
*         solid colours with varying intensity according to the light         *
*         inclination. Please see details in the documentation of the         *
*         routines which are concerned.                                       *
*                                                                             *
***SG**************************************************************************
*
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCONST.
+CDE, GCNUM.
+CDE, GCMUTR.
+CDE, GCGOBJ.
+SELF, IF=CG.
+CDE, CGHPAR.
+SELF.
+CDE, GCHILN.
+CDE, GCSPEE.
*
*    - The following common to be used by GXPICK
*
      COMMON /QUEST/ IQUEST(100)
      COMMON/GCVHLP/NVLAST
      COMMON/SP3D/ISPFLA
      COMMON/INIFIR/NFIRST
*
      CHARACTER*4 NAME,NAMEE2
      DIMENSION X(3),ATT(10)
      DIMENSION LVOLS(15),LINDX(15),LNAMES(15)
      DIMENSION GPAR(50,15)
+SELF, IF=CG.
      DIMENSION V(3),T(4,3)
+SELF.
      SAVE IFIRST, LFIRST
      DATA IFIRST,LFIRST/2*0/
*       Save info for GXPICK in case is needed
      CALL UCTOH(NAME, NVLAST, 4, 4)
***      CALL IGSET('SYNC',1.)
*
*       Hidden flag 'ON" (Default)
*
      CALL UCTOH('ON  ',IFLH,4,4)
*
***SG
*
      IF(NFIRST.EQ.0)THEN
        CALL GDCOTA
        NFIRST=1
      ENDIF
+SELF, IF=CG.
      IF(IHIDEN.EQ.IFLH)THEN
         IF(LFIRST.EQ.0) THEN
*      Link area for the banks
            CALL MZLINT(IXSTOR,'/GCHILN/',LARECG,ICLIP1,ICLIP2)
            LFIRST = 1
         ELSE
            IF(JCGCOL.NE.0) CALL MZDROP(IXSTOR, JCGCOL, ' ')
            IF(JCGOBJ.NE.0) CALL MZDROP(IXSTOR, JCGOBJ, ' ')
            IF(JCOUNT.NE.0) CALL MZDROP(IXSTOR, JCOUNT, ' ')
            IF(JCLIPS.NE.0) CALL MZDROP(IXSTOR, JCLIPS, ' ')
            IF(IMPOIN.NE.0) CALL MZDROP(IXSTOR, IMPOIN, ' ')
            IF(IMCOUN.NE.0) CALL MZDROP(IXSTOR, IMCOUN, ' ')
            IF(JSIX.NE.0) CALL MZDROP(IXSTOR, JSIX, ' ')
            IF(JSIY.NE.0) CALL MZDROP(IXSTOR, JSIY, ' ')
            IF(JSIZ.NE.0) CALL MZDROP(IXSTOR, JSIZ, ' ')
            IF(JPXC.NE.0) CALL MZDROP(IXSTOR, JPXC, ' ')
            IF(JPYC.NE.0) CALL MZDROP(IXSTOR, JPYC, ' ')
            IF(JPZC.NE.0) CALL MZDROP(IXSTOR, JPZC, ' ')
         ENDIF
         LARECG(1)=1
*
*                     Initialization
*
*  NWHS1: n. of words for Hide Structure
*  NWWS1: n. of words for Wire Structure
*  NWFLAG: Indicates if the size of CG bank is precise
*          =0 , it is
*          =-9, it isn't
*  IPAS: This flag indicates if the Size Evaluation has been performed
*        =0 , it does not
*        =1 , it does
*  NOBJ:  Counter of CG objects
*  NUVO:  Counter of CG volumes
*  II: Counter for volumes' line attributes
*  KGG: Flag for booking line attributes bank
*  LSTEP: Number of CG objects forming each volume
*  IFACST: Flag indicating final status of Hide Structure
*          =0 , it's ok
*          <0 , internal error
*          >0 , total number of words needed for Hide Structure
*  NCLAS2: Total number of volumes
*  S1...SS3: Min and Max values of volume scope
*  SRAGMX,SRAGMN: Max values of volume scope along R
*  NFILT= n. of words for HIDE+totalWIRE structures+CG+Line
*  NTCUR= n. of words for HIDE+instantWIRE structures+CG+Line
*  KSTART: Flag for Hidden Volume Removal
*  IOLDOL: Nlevel of last volume setting bounds for scope
*
*         NWHS1=0
*         NWWS1=0
*         NWFLAG=0
         IPER=0
         IPEOLD=0
         NOBJ=0
         NUVO=0
         IPAS=0
         II=0
         KGG=0
         LSTEP=1
         IFACST=0
*         IWORK=0
         NCLAS1=0
         NCLAS2=0
         NCLAS3=0
         IIIIII=0
*    Initialization of Hidden Volume and Face Removal
         S1=0
         S2=0
         S3=0
         SS1=0
         SS2=0
         SS3=0
         SRAGMX=0
         SRAGMN=0
         RAINT1=0
         RAINT2=0
         ISCOP=0
         KSTART=0
         IOLDOL=0
*    Initialisation for Shift
         NIET=0
         IOLDSU=0
         PORGX=0
         PORGY=0
         PORGZ=0
         DO 10  J=1,15
            POX(J)=0
            POY(J)=0
            POZ(J)=0
   10    CONTINUE
         DO 20  J=1,100
            IVECVO(J)=0
   20    CONTINUE
         IVOOLD=0
*         IMENO=0
         IPRELE=0
*    Resetting
         IHPOIN=0
         IWPOIN=0
         ICLIP1=0
         ICLIP2=0
         IVOLNA=0
         LPASS=0
         NWHS=0
         MFLA=0
         MVENLE=0
         MVECOL=0
         LFLA=0
         LVENLE=0
         LVEWID=0
         LFFLA=0
         LFENLE=0
         LVEFIL=0
         IXCG=IXSTOR+1
         JMEMT1=0
         JMEMT3=0
         JMEMT2=0
*    Resetting
         IF(JCG.NE.0)THEN
            CALL MZDROP(IXSTOR, JCG, ' ')
            CALL MZGARB(IXSTOR+1,0)
         ENDIF
*    Booking bank to create CG objects
         CALL MZNEED(IXCG,30000,'G')
         CALL MZBOOK(IXCG,JCGOBJ,JCGOBJ,1,'CGOB',0,0,30000,3,-1)
         CALL MZNEED(IXCG,33000,'G')
         CALL MZBOOK(IXCG,JCLIPS,JCLIPS,1,'CGCLIP',0,0,33000,3,-1)
         ICLIP1=JCLIPS+1
         ICLIP2=JCLIPS+16500
         JMEMT1=IQUEST(11)*.013
         IF(JMEMT1.LT.10000)JMEMT1=10000
         CALL MZNEED(IXCG,JMEMT1,'G')
         CALL MZBOOK(IXCG,JCOUNT,JCOUNT,1,'CGCONT',0,0,JMEMT1,2,-1)
         IQ(JCOUNT+1)=1
         IQ(JCOUNT+2)=4000
         IQ(JCOUNT+3)=8000
         LLEP=ABS(LEP)
         IF(LLEP.NE.1)THEN
            CALL MZNEED(IXCG,54000,'G')
            CALL MZBOOK(IXCG,JSIX,JSIX,1,'XGEN',0,0,9000,3,-1)
            CALL MZBOOK(IXCG,JSIY,JSIY,1,'YGEN',0,0,9000,3,-1)
            CALL MZBOOK(IXCG,JSIZ,JSIZ,1,'ZGEN',0,0,9000,3,-1)
            CALL MZBOOK(IXCG,JPXC,JPXC,1,'XPAR',0,0,9000,3,-1)
            CALL MZBOOK(IXCG,JPYC,JPYC,1,'YPAR',0,0,9000,3,-1)
            CALL MZBOOK(IXCG,JPZC,JPZC,1,'ZPAR',0,0,9000,3,-1)
            JMEMT3=JMEMT1
            CALL MZNEED(IXCG,JMEMT3,'G')
            CALL MZBOOK(IXCG,IMCOUN,IMCOUN,1,'SHCONT',0,0,JMEMT3,2,-1)
            IQ(IMCOUN+1)=1
            IQ(IMCOUN+2)=4000
            IQ(IMCOUN+3)=8000
            JMEMT2=IQUEST(11)*.1
            CALL MZNEED(IXCG,JMEMT2,'G')
            CALL MZBOOK(IXCG,IMPOIN,IMPOIN,1,'SHAFAC',0,0,JMEMT2,2,-1)
         ENDIF
*    Resetting
         CALL GDCGRS
         NFILT=0
         NTCUR=0
         NTNEX=0
         NAIN=0
         ITSTCU=0
      ENDIF
+SELF.
*
***SG
C
C            Set IOBJ to VOLUME
C
      IOBJ=1
C
      IF (IFIRST.NE.0) GO TO 40
C
      IFIRST=1
      DPHI=PI/20.
      PHI=0.
C
      DO 30 I=1,40
         GSIN(I)=SIN(PHI)
         GCOS(I)=COS(PHI)
         PHI=PHI+DPHI
   30 CONTINUE
C
      GSIN(41)=GSIN(1)
      GCOS(41)=GCOS(1)
C
   40 CONTINUE
C
C             Save /GCVOLU/ if necessary
C
      IFCVOL=0
      IF (NLEVEL.NE.0) THEN
         CALL GSCVOL
         IFCVOL=1
      ENDIF
      IF (NLEVEL.LT.0) NLEVEL=IABS(NLEVEL)
C
C             If in cut-mode then open the GDRAWV line buffer
C             else reset ICUT that could have been set by GDRAWC/GDRAWX
C
      IF (ICUTFL.EQ.1) THEN
         CALL GDRAWV(0.,0.,-1)
      ELSE
         ICUT=0
      ENDIF
C
C             Start of general code
C
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF(IVO.LE.0)GO TO 280
C
C             Theta, phi and psi angles are normalized in [0-360[ range
C

      GTHETA=MOD(ABS(UTHET),360.)
      GPHI=MOD(ABS(UPHI),360.)
      GPSI=MOD(ABS(UPSI),360.)
      GU0=UU0
      GV0=UV0
      GSCU=SU
      GSCV=SV
      IMOD=0
*
+SELF, IF=CG.
*              Set Transformation Matrix T for CG Package
*
      IF(IHIDEN.EQ.IFLH)THEN
         V(1)=GTHETA
         V(2)=GPHI
         V(3)=GPSI
         CALL GDCGVW(V,T)
         CALL CGTSET(NTRCG,T,IREP)
         IF(IREP.EQ.-1)THEN
            WRITE(CHMAIL,10200)
            CALL GMAIL(0,0)
         ENDIF
         IF(IREP.EQ.-2)THEN
            WRITE(CHMAIL,10300)
            CALL GMAIL(0,0)
         ENDIF
*
*    Obtaining the IMOD flag for setting the run mode
*
         IF(IPAS.EQ.0)THEN
            IMOD=0
            IF(ICUT.NE.0)IMOD=1
            IF(IHOLE.EQ.1)IMOD=2
         ELSE
            IMOD=3
            IF(ICUT.NE.0)IMOD=4
            IF(IHOLE.EQ.1)IMOD=5
            IF(ICUT.NE.0.OR.IHOLE.EQ.1)THEN
               IFCG=4
               ILCG=3
            ENDIF
         ENDIF
      ENDIF
+SELF.
*JS
*  77  CONTINUE
      SINPSI=SIN(GPSI*DEGRAD)
      COSPSI=COS(GPSI*DEGRAD)
      GU0=UU0
      GV0=UV0
      NGVIEW=0
      JVO=LQ(JVOLUM-IVO)
C
C             Initialize JIN to switch correctly CALL GFPARA/GFIPAR
C
      JIN=0
C
      LEVSEE=1000
C
      IF (IDRNUM.NE.0) GO TO 70
C
C             Initialize for new geometry structure
C
      IF (JGPAR.EQ.0) CALL GMEDIN
      CALL GLMOTH(NAME,1,NLEV,LVOLS,LINDX)
      DO 50 J=1, NLEV
         LNAMES(J)=IQ(JVOLUM+LVOLS(J))
   50 CONTINUE
      NLEV=NLEV+1
      CALL UCTOH(NAME,LNAMES(NLEV),4,4)
      LINDX(NLEV)=1
      DO 60   KLEV=2,NLEV
         JVOF = LQ(JVOLUM-LVOLS(KLEV-1))
         NIN  = Q(JVOF+3)
         IF(NIN.GT.0) THEN
            JIN = LQ(JVOF-LINDX(KLEV))
            ICOPY = Q(JIN+3)
         ELSE
            ICOPY = 1
         ENDIF
         LINDX(KLEV) = ICOPY
   60 CONTINUE
      CALL GLVOLU(NLEV, LNAMES, LINDX, IER)
C
      NLVTOP=NLEVEL
C
   70 CONTINUE
C
      NLMIN=NLEVEL
      NLMAX=NLEVEL
C
      IF (IDRNUM.NE.0) GO TO 110
C
      CALL GFPARA(NAME,1,1,NPAR,NATT,GPAR(1,NLEVEL),ATT)
C
      IF (NPAR.LE.0) GO TO 290
C
      DO 100 LLL=1,NLEVEL
         DO 90 I=1,3
            GTRAN(I,LLL)=0.0
            X(I)=0.0
            DO 80 J=1,3
               K=(I-1)*3+J
               GRMAT(K,LLL)=0.0
   80       CONTINUE
            K=I*4-3
            GRMAT(K,LLL)=1.0
   90    CONTINUE
         GRMAT(10,LLL)=0.0
  100 CONTINUE
C
C             Ready for general case code
C
  110 CONTINUE
*SG
*    Taking volume name and shape from Zebra Structure
*
      IMENO=IVOLNA
      IVOLNA=IQ(JVOLUM+IVO)
      ISHAPE=Q(JVO+2)
*SG
      GSCU=SU
      GSCV=SV
C
      IF (IDRNUM.NE.0) GO TO 120
C
      IF (NLEVEL.EQ.NLVTOP) GO TO 130
C
  120 CONTINUE
C
      IF (IDRNUM.NE.0.AND.JIN.EQ.0) THEN
         CALL UHTOC(NAMES(NLEVEL),4,NAMEE2,4)
         CALL GFPARA(NAMEE2,NUMBER(NLEVEL),1,NPAR,
     +            NATT,GPAR(1,NLEVEL),ATT)
      ELSE
         NPAR=Q(JVO+5)
         NATT=Q(JVO+6)
         JATT=JVO+7+NPAR
         CALL UCOPY(Q(JATT),ATT,NATT)
      ENDIF
C
  130 CONTINUE
C
      WORK=ATT(1)
      SEEN=ATT(2)
*
      LINSTY=ATT(3)
      LINWID=ATT(4)
      LINCOL=ATT(5)
      LINFIL=ATT(6)
      IF(LLEP.EQ.1)LINFIL=0
*SG
*    New logic setting the line attributes
*
      IF(NLEVEL.EQ.1)THEN
***               CALL GDCOTA
         IF(LINFIL.LT.0)THEN
            LINFIL=ABS(LINFIL)
            CALL ISFACI(LINFIL)
            CALL ISFAIS(1)
            CALL IGBOX(0.,20.,20.,0.)
            CALL ISFAIS(0)
            LINFIL=2
         ENDIF
      ENDIF
      IF(LINCOL.LT.2)THEN
         IF(MFLA.EQ.1.AND.NLEVEL.GT.MVENLE)LINCOL=MVECOL
         IF(NLEVEL.LE.MVENLE)MFLA=0
         IF(LINCOL.LT.0)THEN
            MVECOL=ABS(LINCOL)
            LINCOL=MVECOL
            MVENLE=NLEVEL
            MFLA=1
         ENDIF
      ENDIF
      IF(LINWID.LT.2)THEN
         IF(LFLA.EQ.1.AND.NLEVEL.GT.LVENLE)LINWID=LVEWID
         IF(NLEVEL.LE.LVENLE)LFLA=0
         IF(LINWID.LT.0)THEN
            LVEWID=ABS(LINWID)
            LINWID=LVEWID
            LVENLE=NLEVEL
            LFLA=1
         ENDIF
      ENDIF
      IF(LINFIL.LT.1)THEN
         IF(LFFLA.EQ.1.AND.NLEVEL.GT.LFENLE)LINFIL=LVEFIL
         IF(NLEVEL.LE.LFENLE)LFFLA=0
         IF(LINFIL.LT.0)THEN
            LVEFIL=ABS(LINFIL)
            LINFIL=LVEFIL
            LFENLE=NLEVEL
            LFFLA=1
         ENDIF
      ENDIF
*SG
      CALL MVBITS(LINCOL,0,8,LINATT,16)
      CALL MVBITS(LINWID,0,3,LINATT,7)
      CALL MVBITS(LINSTY,0,3,LINATT,10)
      CALL MVBITS(LINFIL,0,3,LINATT,13)
*
***SG
*
*    New logic scanning the geometrical tree:
*    A volume can set bounds OR be compared with bounds;
*    this can happen only IF a relationship mother-daughters exists.
*
*    Optimization for Hidden Volume and Face Removal:
*    POS and DIV cases are considered at the same time.
*
      IF(IPAS.EQ.0)GOTO 170
      IPORLI=0
      ISUBLI=0
      IF(KSTART.EQ.1)THEN
*
         IF(NLEVEL.GT.IOLDOL)THEN
            IF(LPASS.EQ.0)THEN
               ISUBLI=1
            ELSE
               IPORLI=1
               S1=0
               S2=0
               S3=0
               SS1=0
               SS2=0
               SS3=0
               SRAGMX=0
               SRAGMN=0
               RAINT1=0
               RAINT2=0
               ISCOP=0
               LPASS=0
               IF(SEEN.EQ.0.OR.SEEN.EQ.-1)LPASS=1
               IOLDOL=NLEVEL
            ENDIF
*
         ELSE IF(NLEVEL.LE.IOLDOL)THEN
            IPORLI=1
            S1=0
            S2=0
            S3=0
            SS1=0
            SS2=0
            SS3=0
            SRAGMX=0
            SRAGMN=0
            RAINT1=0
            RAINT2=0
            ISCOP=0
            LPASS=0
            IF(SEEN.EQ.0.OR.SEEN.EQ.-1)LPASS=1
            IOLDOL=NLEVEL
         ENDIF
*
         IF(NLEVEL.LE.IPRELE)THEN
            IF(IVOLNA.NE.IMENO)THEN
               NIET=2
               IF(SEEN.EQ.0.OR.IPORLI.EQ.1.OR.SEEN.EQ.-1)THEN
                  DO 140 I=1,15
                     IF((NLEVEL-I).GE.1)THEN
                        IF(POX(NLEVEL-I).NE.0.OR.POY(NLEVEL-I)
     +                  .NE.0.OR. POZ(NLEVEL-I).NE.0)THEN
                           PO1=POX(NLEVEL-I)
                           PO2=POY(NLEVEL-I)
                           PO3=POZ(NLEVEL-I)
                           GOTO 150
                        ENDIF
                     ENDIF
  140             CONTINUE
                  POX(NLEVEL)=0.
                  POY(NLEVEL)=0.
                  POZ(NLEVEL)=0.
                  PORGX=0.
                  PORGY=0.
                  PORGZ=0.
                  GOTO 160
  150             CONTINUE
                  POX(NLEVEL)=PO1
                  POY(NLEVEL)=PO2
                  POZ(NLEVEL)=PO3
               ENDIF
  160          CONTINUE
            ENDIF
         ENDIF
         IPRELE=NLEVEL
      ENDIF
*
      IF(IOLDOL.EQ.0.AND.(SEEN.EQ.1.OR.SEEN.EQ.-2
     +   .OR.SEEN.EQ.9))THEN
         KSTART=1
         IPORLI=1
         LPASS=0
         IOLDOL=NLEVEL
         IPRELE=NLEVEL
      ENDIF
  170 CONTINUE
*
***SG
*
C
C             WORK attribute enabled ?
C
      IF(WORK.LE.0.)GO TO 270
C
C             SEEN attribute processing
C
      IF (SEEN.LT.50.) GO TO 180
      ISEENL=SEEN/10.+0.5
      SEEN=ISEENL-10
  180 CONTINUE
      IF(NLEVEL.LE.LEVSEE)LEVSEE=1000
      IF(SEEN.EQ.-1.)GO TO 270
      IF (NLEVEL.GT.LEVSEE) GO TO 270
      IF(SEEN.EQ.0.)GO TO 220
      IF (SEEN.EQ.-2.) LEVSEE=NLEVEL
*JS
*
*     Logic has been modified  >>>>>
*
C
C       For the Standard Mode:  Draw the shape
C       For CG Mode : Make a CG-Object for each shape
C
      IF(IHIDEN.EQ.IFLH)THEN
*
*              CG Mode:
*
*
*  Case : divided without clipping
*
****SG
*      Optimization for setting seen attributes
*
         NIN=Q(JVO+3)
         IF(SEEN.EQ.9.AND.NIN.NE.0)THEN
            LPASS=1
            ITSTCU=0
            ICGP=0
            IIIIII=1
            GOTO 190
         ELSE
            IIIIII=0
         ENDIF
         IF(NIN.LT.0.AND.((ISHAPE.GT.1.AND.ISHAPE.LT.5).OR.
     +   (ISHAPE.GT.9.AND.ISHAPE.LT.13)))THEN
            IF(IPORLI.EQ.1)ISCOP=1
         ENDIF
         IF(SEEN.EQ.1.AND.NIN.LT.0)GOTO 190
         IF(SEEN.NE.-2.AND.NIN.LT.0.AND.(IMOD.EQ.0.OR.IMOD.EQ.3))
     +    GOTO 240
  190    CONTINUE
*
+SELF, IF=CG.
*
*      Creating, clipping and counting CG objects
*      Inserting the visible ones in Hide and Wire Structures
*
         IF(IIIIII.EQ.1)GOTO 200
         IMSE=IMOD
         IF(ISHAPE.EQ.11)LSTEP=GPAR(4,NLEVEL)-1
         IF(ISHAPE.EQ.12)LSTEP=GPAR(3,NLEVEL)-1
         CALL GDCGOB(IMSE,ISHAPE,GPAR(1,NLEVEL),NOBJ,NWWS,IVOLNA,
     +LSTEP)
  200    CONTINUE
         NOBJ=NOBJ+LSTEP
         NUVO=NUVO+1
         LSTEP=1
         IF(IPAS.NE.0)THEN
            IF(NCLAS2.GT.1000)THEN
               IPER=(100*NOBJ)/NCLAS2
               IF(IPER.EQ.10.OR.IPER.EQ.20.OR.IPER.EQ.30.OR.IPER.EQ.
     +         40.OR.IPER.EQ.50.OR.IPER.EQ.60.OR.IPER.EQ.70.OR.IPER
     +         .EQ.80.OR.IPER.EQ.90)THEN
                  IF(IPER.NE.IPEOLD)THEN
                     WRITE(CHMAIL,11800)IPER
                     CALL GMAIL(0,0)
                     IPEOLD=IPER
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
*
*            Setting line attributes volume by volume
*
         IF(IHIDEN.EQ.IFLH) THEN
            IF(IPAS.NE.0.AND.KGG.EQ.1) THEN
**           IF(ITSTCU.NE.0.AND.IVFUN.NE.0) THEN
               IF((ITSTCU.NE.0).OR. ((ISHAPE.EQ.11.OR.ISHAPE.EQ.12)
     +         .AND.(ICGP.NE.0)))THEN
                  IF(ISHAPE.EQ.11.OR.ISHAPE.EQ.12)LSTEP=ICGP
                  LL=II+1
                  II=II+LSTEP
                  DO 210 KHH=LL,II
                     IQ(JCGCOL+KHH)=LINATT
  210             CONTINUE
                  LSTEP=1
               ENDIF
            ENDIF
         ENDIF
*
*
*      Logic has been modified again :
*      do the size evaluation while creating Hide Structure
*      do the same for Wire Structure
*
*      If number of words booked for Hide Structure or for
*      Wire Structure is not sufficient, then evaluate the
*      the right number of words needed and send a mail.
*
         IF(KCGST.EQ.-9)THEN
*
*      Ten words more for safety
*
            NWHS1 = NCLAS1+ 10
            CALL CGHEVA(Q(IHPOIN),HISI)
            IF(HISI.GT.NWHS1)NWHS1=HISI
            IWORH = NWHS1 - NWHS
            IWORH1= IWORH * 1.666666
            WRITE(CHMAIL,11500)IWORH1
            CALL GMAIL(0,0)
            GOTO 320
         ELSE IF(KCGST.EQ.-10)THEN
            NWWS1 = NCLAS3+ 10
            IWORW = NWWS1 - NWWS
            IWORW1= IWORW * 2.5
            WRITE(CHMAIL,11400)IWORW1
            CALL GMAIL(0,0)
            GOTO 320
         ELSEIF(KCGST.EQ.-4.OR.KCGST.EQ.-1.OR.KCGST.EQ.-2) THEN
*      Exiting without having made evaluation of size
            GOTO 320
         ENDIF
****SG
*    Case: Volume placed by GSPOS, not clipped and 'closed'
*
*XX
*         IF(NIN.GT.0.AND.(IMOD.EQ.0.OR.IMOD.EQ.3).
*     +   AND.KSHIFT.EQ.0.AND.GBOOM.EQ.0.)  GOTO 150
*XX
+SELF.
      ELSE
*
*              Standard Mode: Draw the shape
*
         CALL IGPID(1,'Pick',IVO,' ')
         CALL IGPID(2,'Pick',IQ(JVOLUM+IVO),' ')
         IF (ICUTFL.EQ.1) THEN
            CALL GDRWSC(ISHAPE,GPAR(1,NLEVEL))
         ELSE
            CALL GDRAWS(ISHAPE,GPAR(1,NLEVEL))
         ENDIF
*
      ENDIF
*JS
      JVO=LQ(JVOLUM-IVO)
C
      IF(SEEN.EQ.-2.)GO TO 270
C
  220 CONTINUE
C
***   IF (IDRNUM.NE.0) GO TO 999
C
C             Skip User shapes (not yet implemented)
C
**      ISEARC=Q(JVO+1)
C
C             Now go down the tree
C
      NIN=Q(JVO+3)
      IF(NIN.EQ.0) GO TO 270
      IF(NIN.LT.0) GO TO 240
C
C             Contents placed by GSPOS
C
      IN=0
      IF(NLMAX.GT.NLEVEL) IN=LINDEX(NLEVEL+1)
      IN=IN+1
      IF(IN.GT.NIN.AND.NLEVEL.EQ.NLMIN) GO TO 300
*
      IF(IN.GT.NIN) GO TO 260
*
      CALL GMEPOS(JVO,IN,X,0)
      JIN = LQ(JVO-IN)
*
      NPAR=IQ(JGPAR+NLEVEL)
      DO 230 I=1,NPAR
         GPAR(I,NLEVEL)=Q(LQ(JGPAR-NLEVEL)+I)
  230 CONTINUE
*
      IVO=LVOLUM(NLEVEL)
      JVO=LQ(JVOLUM-IVO)
      NLMAX=NLEVEL
      GO TO 110
C
  240 CONTINUE
C
C             Contents by division
C
      IN=0
      IF(NLMAX.GT.NLEVEL) IN=LINDEX(NLEVEL+1)
      IN=IN+1
      CALL GMEDIV(JVO,IN,X,0)
      JIN = LQ(JVO-IN)
*
      IF (IN.EQ.0) GO TO 260
*
      NPAR=IQ(JGPAR+NLEVEL)
      DO 250 I=1,NPAR
         GPAR(I,NLEVEL)=Q(LQ(JGPAR-NLEVEL)+I)
  250 CONTINUE
*
      IF (IN.EQ.0) GO TO 260
*
      IVO=LVOLUM(NLEVEL)
      JVO=LQ(JVOLUM-IVO)
      NLMAX=NLEVEL
      GO TO 110
C
  260 CONTINUE
      NLMAX=NLEVEL
  270 CONTINUE
      NLEVEL=NLEVEL-1
      IF(NLEVEL.LT.NLMIN) GO TO 300
      IVO=LVOLUM(NLEVEL)
      JVO=LQ(JVOLUM-IVO)
      GO TO 220
C
  280 WRITE(CHMAIL,10000)NAME
      CALL GMAIL(0,0)
      GO TO 300
C
  290 CONTINUE
C
C             TOP OF THE TREE HAS PARAMETERS SET BY GSPOSP.
C             BUT GDRAW DOES NOT HAVE ACCESS TO THE IN BANK
C             WHICH PLACED IT IN ITS MOTHER.
C
      WRITE(CHMAIL,10100) NAME
      CALL GMAIL(0,0)
C
  300 CONTINUE
*
***SG
*
+SELF, IF=CG.
*
*  CG Mode
*
      IF(IHIDEN.EQ.IFLH) THEN
*
*    In CG Mode the program flow has two scanning of the geometrical tree:
*    the first one is to count the number of volumes (IPAS=0);
*    the second one is to compute volumes' visibility with Hidden Volume
*    and Face Removal, inserting them in the Hide and Wire structures if
*    the size of Zebra store is sufficient (IPAS=1).
*
         IF(IPAS.EQ.0)THEN
*
*    Creating a bank for setting line attributes volume by volume.
*    The number of words needed is just equal to the total number
*      of visible volumes.
*
            NCLAS2=NOBJ
            IF(KGG.EQ.0)THEN
               CALL MZNEED(IXCG,NCLAS2+10,'G')
*
*    Take everything is left but leave 100,000 words just in case
*
               MEMO=IQUEST(11)-(IQUEST(11)*.11)
               IF(IQUEST(11).LE.0)THEN
                  WRITE(CHMAIL,11300)NCLAS2+10
                  CALL GMAIL(0,0)
                  GOTO 320
               ENDIF
               CALL MZBOOK(IXCG,JCGCOL,JCGCOL, 1,'LINE',0,0,NCLAS2+10,
     +         2,-1)
            ENDIF
            KGG=KGG+1
            NOBJ=0
            NUVO=0
            IPAS=1
*
            NFILT=63000+NCLAS2+10
*
*    Use max Zebra store for Hide and Wire structures
*
            NWHS=0.6*MEMO
            NWWS=0.4*MEMO
            CALL MZBOOK(IXCG,JCG,JCG,1,'CG',0,0,MEMO,3,-1)
            CALL GDCGRS
*
            IHS=1
            IHPOIN=JCG+1
*
*    Creating the Hidden Structure
*
            IF(NWHS.LE.LHHEAD)NWHS=LHHEAD+1
***SG
            CALL CGHCRE(NTRCG,0,DUMMY,DUMMY,NWHS,Q(IHPOIN))
            NTCUR=NWHS
            IOLDCU=NTCUR
            NFILT=NFILT+NTCUR
            GOTO 40
         ENDIF
         IF(NOBJ.EQ.0)GOTO 320
****SG
*    Closing the Hidden Structure
*
         IHPOIN=JCG+1
*
*     Last size evaluation for Hide Structure
*
         CALL CGHEND(Q(IHPOIN),IFACST,RSHD)
         IF(IFACST.GT.0)THEN
            NWHS1 = IFACST+ 10
            IWORH = NWHS1 - NWHS
            IWORH1= IWORH * 1.666666
            WRITE(CHMAIL,11500)IWORH1
            CALL GMAIL(0,0)
            GOTO 320
         ENDIF
*
* IFACST shouldn't be negative now
*
         IF(IFACST.LT.0)THEN
            WRITE(CHMAIL,10500)
            CALL GMAIL(0,0)
            GOTO 320
         ENDIF
*
*     Setting the right colours
*               and
*     Drawing the CG Objects
*
         IF(ILCG.LT.IFCG)THEN
            WRITE(CHMAIL,10400)
            CALL GMAIL(0,0)
         ELSE
            IF(LEP.GE.0.AND.ISPFLA.NE.1)THEN
               WRITE(CHMAIL,11900)
               CALL GMAIL(0,0)
            ENDIF
***            call write_dxf_sect_entity( 1 )
            DO 310 K=IFCG,ILCG
               IF(IDVIEW.NE.0)THEN
                  IF(ILCG.GT.1000)THEN
                     IPER=(100*K)/ILCG
                     IF(IPER.EQ.10.OR.IPER.EQ.20.OR.IPER.EQ.30.OR.IPER.
     +               EQ. 40.OR.IPER.EQ.50.OR.IPER.EQ.60.OR.IPER.EQ.70.O
     +               R.IPER .EQ.80.OR.IPER.EQ.90)THEN
                        IF(IPER.NE.IPEOLD)THEN
                           WRITE(CHMAIL,12000)IPER
                           CALL GMAIL(0,0)
                           IPEOLD=IPER
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
               LINATT=IQ(JCGCOL+K-IFCG+1)
               IWPOIN=JCG+IQ(JCOUNT+K)
               IF(ISPFLA.EQ.1)ISPFLA=2
               IF(LLEP.NE.1)THEN
                  MMPOIN=IMPOIN+IQ(IMCOUN+K)
                  CALL GD16V((IQ(JCOUNT+K)-1),IQ(MMPOIN))
               ELSE
                  CALL GD16V((IQ(JCOUNT+K)-1),0)
               ENDIF
               IF(ISPFLA.EQ.2)ISPFLA=1
  310       CONTINUE
         ENDIF
***        call write_dxf_sect_entity( 2 )
*
*    Printing statistics
*
         IF(LEP.GE.0.AND.ISPFLA.NE.1)THEN
            NFILT=NFILT-NWHS+RSHD
            INFILT=NFILT
            IRSHD=RSHD
            MEMO1=MEMO+63000+NCLAS2+10+JMEMT2+JMEMT1+JMEMT3+54000
            RSWR =NFILT-RSHD-63000-NCLAS2-10
            IRSWR=RSWR
            ICGOB=63000
            RATIO=RSHD/RSWR
            JJIIKK=0
            JPARGE=0
            IF(LLEP.NE.1)THEN
               JJIIKK=ILCG-IFCG+1
               JPARGE=54000
            ENDIF
            WRITE(CHMAIL,10600)INFILT+NTNEX+ILCG-IFCG+1+JJIIKK+JPARGE
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10700)MEMO1
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10900)NCLAS2+10
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10800)ICGOB
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11000)IRSHD
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11100)IRSWR+ILCG-IFCG+1
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11200)NTNEX+JJIIKK+JPARGE
            CALL GMAIL(0,0)
*         WRITE(CHMAIL,10799)RATIO
*         CALL GMAIL(0,0)
            WRITE(CHMAIL,11600)ILCG-IFCG+1
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11700)NCLAS2
            CALL GMAIL(0,0)
         ENDIF
*
      ENDIF
*
*    Dropping + resetting parameters
*
  320 CONTINUE
      IF(IHIDEN.EQ.IFLH)THEN
         ICUT=0
         IF(JCG.NE.0)CALL MZDROP(IXSTOR,JCG,' ')
         IF(JCGOBJ.NE.0)CALL MZDROP(IXSTOR,JCGOBJ,' ')
         CALL GDCGRS
         IF(JCGCOL.NE.0)CALL MZDROP(IXSTOR,JCGCOL,' ')
         IF(JCOUNT.NE.0)CALL MZDROP(IXSTOR,JCOUNT,' ')
         IF(JCLIPS.NE.0)CALL MZDROP(IXSTOR,JCLIPS,' ')
         IF(IMPOIN.NE.0)CALL MZDROP(IXSTOR,IMPOIN,' ')
         IF(IMCOUN.NE.0)CALL MZDROP(IXSTOR,IMCOUN,' ')
         IF(JSIX.NE.0) CALL MZDROP(IXSTOR, JSIX, ' ')
         IF(JSIY.NE.0) CALL MZDROP(IXSTOR, JSIY, ' ')
         IF(JSIZ.NE.0) CALL MZDROP(IXSTOR, JSIZ, ' ')
         IF(JPXC.NE.0) CALL MZDROP(IXSTOR, JPXC, ' ')
         IF(JPYC.NE.0) CALL MZDROP(IXSTOR, JPYC, ' ')
         IF(JPZC.NE.0) CALL MZDROP(IXSTOR, JPZC, ' ')
         LARECG(1)=0
         CALL MZGARB(IXSTOR+1,0)
*         NWHS1=0
*         NWFLAG=0
         NCLAS1=0
         NCLAS2=0
         NCLAS3=0
      ENDIF
*
****SG
*
+SELF.
      IF (IFCVOL.EQ.1) THEN
         CALL GFCVOL
      ELSE
         NLEVEL=0
      ENDIF
C
C             If in cut-mode then close the GDRAWV line buffer
C
      IF (ICUTFL.EQ.1) CALL GDRAWV(0.,0.,0)
C
C             Restore permanent value of color and return
C
*      CALL GDCOL(0)
      IOBJ=0
C
10000 FORMAT(' *** GDRAW *** : Volume ',A4,' does not exist')
10100 FORMAT(' *** GDRAW *** : Top of tree ',A4,' parameters defined',
     +       '  by GSPOSP - info not available to GDRAW.')
10200 FORMAT(' *** GDRAW *** : Illegal Transformation Matrix',
     +       ' Number NTRCG ')
10300 FORMAT(' *** GDRAW *** :  >>> Det (T) = 0  ')
10400 FORMAT(' *** GDRAW *** :  Warning! Volume is destroyed.')
*SG
10500 FORMAT(' *** GDRAW *** :  Internal error, please report to',
     +       ' GEANT support team')
10600 FORMAT(' *** GDRAW *** : Total memory used    =',I10,' words.')
10700 FORMAT(' *** GDRAW *** : Total memory booked  =',I10,' words.')
10800 FORMAT(' *** GDRAW *** : Memory used for CGOB =',I10,' words.')
10900 FORMAT(' *** GDRAW *** : Memory used for LINE =',I10,' words.')
11000 FORMAT(' *** GDRAW *** : Memory used for HIDE =',I10,' words.')
11100 FORMAT(' *** GDRAW *** : Memory used for WIRE =',I10,' words.')
11200 FORMAT(' *** GDRAW *** : Memory used for SHAD =',I10,' words.')
11300 FORMAT(' *** GDRAW *** : Memory needed for the LINE attributes',
     +       ' =',I10,' words.')
*10799 FORMAT(' *** GDRAW *** : HIDE/WIRE=',F4.2,'.')
11400 FORMAT(' *** GDRAW *** : Please, increase size of Zebra store',
     +       ' by',I10,' words to create WIRE structure.')
11500 FORMAT(' *** GDRAW *** : Please, increase size of Zebra store',
     +       ' by',I10,' words to create HIDE structure.')
11600 FORMAT(' *** GDRAW *** : Visible volumes      =',I10,'.')
11700 FORMAT(' *** GDRAW *** : Total   volumes      =',I10,'.')
11800 FORMAT(' *** GDRAW *** :',I2,'% of volumes analysed.')
11900 FORMAT(' *** GDRAW *** : Now the drawing is starting !')
12000 FORMAT(' *** GDRAW *** :',I2,'% of volumes drawn.')
*
*SG
      END
+DECK,  GDRAW_DOC_D, T=DATA, IF=DOC.
*
* $Id: geang321.car100,v 1.1.1.1 2003/04/24 14:25:11 tretiak Exp $
*
* $Log: geang321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:11  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:20:18  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*             Introduction to the Drawing package                      *
*             -----------------------------------                      *
*                                                                      *
*                                                                      *
* THE DRAWING PACKAGE                                                  *
*                                                                      *
* The drawing package has been designed mainly to:                     *
*                                                                      *
* - draw the detector                                                  *
* - draw the detector geometrical tree                                 *
* - draw particle trajectories                                         *
* - draw hits.                                                         *
*                                                                      *
*  DRAWING THE DETECTOR                                                *
*                                                                      *
*  The detector  can be looked at  from any view point  and with any   *
* scale factor (GDRAW, GDRVOL); appropriate attributes can be set in   *
* order to see  only selected objects (so  avoiding messy pictures);   *
* hidden line removal is available as well as surface shading.         *
*  'Cut'  views,  i.e.  intersections  of a  given  plane  with  the   *
* detector, can also be displayed (GDRAWC, GDRAWX).  This feature is   *
* very useful to  see internal details that the  routine GDRAW would   *
* not show.                                                            *
*  When hidden line  removal is used, the possibility  exists to cut   *
* the volume to be drawn with various shapes, to visualise the inner   *
* details.                                                             *
*                                                                      *
* DRAWING THE GEOMETRICAL TREE                                         *
*                                                                      *
*  The geometrical tree (GDTREE) is  a representation of the overall   *
* structure of the detector, namely the mother-daughter relationship   *
* among  the  various  objects   composing  it.   Several  types  of   *
* additional information are available on request: multiplicity of a   *
* given  volume (i.e.  how  many  times it  is  positioned in  other   *
* places, or  number of  subdivisions), detector  nature, visibility   *
* flag, etc.  This  drawing tree capability can be  very useful when   *
* tuning  the  detector  geometry.    If  used  interactively,  this   *
* facility  allow to  invoke via  a click  of the  mouse the  GDSPEC   *
* utility (see below) for any node of the tree.                        *
*                                                                      *
* DRAWING THE GEOMETRICAL SPECIFICATIONS                               *
*                                                                      *
*  The geometrical  specifications (GDSPEC) give a  detailed picture   *
* of one  particular piece of  the detector.  Three drawings  of the   *
* volume (a projection  view and two cut views), its  shape type and   *
* numerical  parameters  (i.e.  dimensions),  and  a  scale  to  aid   *
* geometric  calculations,  are  presented   together  in  a  single   *
* graphics frame.  The set of  geometrical specifications of all the   *
* descendants of  a given node on  the tree, can easily  be obtained   *
* with the routine GDFSPC.                                             *
*                                                                      *
* DRAWING PARTICLE TRAJECTORIES                                        *
*                                                                      *
*  The tracks generated  by the tracking package, and  stored in the   *
* data structure JXYZ, can be easily drawn with the routine GDXYZ.     *
*  The names of the particles and/or  the track numbers can be drawn   *
* as well (GDPART).                                                    *
*  Four types of representations are  used to display the classes of   *
* particles, with different colour and line style:                     *
*                                                                      *
* - red solid lines for charged particles (GTELEC, GTHADR)             *
* - green dashed lines for muons (GTMUON)                              *
* - black blank/dotted lines for neutral particles (GTNEUT)            *
* - blue dotted lines for gammas (GTGAMA)                              *
*                                                                      *
*  A special routine has been  provided to display the tracks online   *
* (GDCXYZ), if  called under  the DEBUG/SWITCH control  from GUSTEP.   *
* That routine  shows the tracks exactly  at the same time  they are   *
* trasorted by  the tracking package  of GEANT3, giving so  a useful   *
* interactive debugging tool.                                          *
*                                                                      *
* DRAWING HITS                                                         *
*                                                                      *
*  The hits generated by the tracking package and stored in the        *
* data structure JHITS, can be displayed by the hits routines,         *
* with different functionality:                                        *
*                                                                      *
* - draw one hit (GDAHIT); called by user routines                     *
* - draw all the hits of trajectory type sets/detectors (GDHITS)       *
* - draw all the hits of calorimeter type sets/detectors (GDCHIT)      *
*                                                                      *
*  Different symbols for every subdetector can be used, chosen among   *
* hardware characters  (dots), software  crosses, or from  the HPLOT   *
* table of software characters.  The size of the software characters   *
* and crosses is given as an  argument to GDAHIT/GDHITS, while it is   *
* computed as a function of the hits value in GDCHIT.                  *
*                                                                      *
* THE VIEW BANKS                                                       *
*                                                                      *
*  The basic detector drawing  routines (GDRAW, GDRAWC, GDRAWX) have   *
* to scan the  data structure JVOLUM repeatedly.   When the detector   *
* is  described in  a  very  detailed way,  the  time  spent in  the   *
* interpretation of  the JVOLUM bank  and in the  3D transformations   *
* can  increase dramatically.   For a  detector with  more than  100   *
* different volume names, for example, this time can reach real time   *
* minutes on some machines, whereas  the specific time required just   *
* by the  drawing would be only  a few seconds.  If  the hidden line   *
* removal option is active, this  time can reach several minutes and   *
* even  hours,  depending  on  the  speed of  the  machine  and  the   *
* complexity of the drawing requested.                                 *
*  In order to alleviate this  problem the 'bank-mode' routines have   *
* been developed.  The basic idea  is to separate the interpretation   *
* (i.e. the  JVOLUM scanning  to convert  the 3D  geometry structure   *
* into a set of 2D lines) from the drawing itself.  In this way, the   *
* interpretation is performed  only once and all  the 2D information   *
* is stored in view banks  (data structure JDRAW) [DRAW 399].  These   *
* views can then be looked at in  a quicker way, having only to draw   *
* all 2D vectors  previously stored.  For a detector  with more than   *
* 100 different volume  names, for example, this is  achieved at the   *
* cost of only a few thousand words of memory for each view bank.      *
*  One  can therefore  open a  view bank  (GDOPEN), identified  by a   *
* number, perform appropriate drawings  (only interpretation will be   *
* made, of course), close the bank  (GDCLOS) and finally look at the   *
* picture stored in  it (GDSHOW).  When a view bank  has been closed   *
* it cannot  be modified anymore,  but it  can be displayed  as many   *
* times as wanted (GDSHOW) or deleted (GDELET).                        *
*                                                                      *
* OTHER FEATURES                                                       *
*                                                                      *
*  The user can  control some drawing options  (GDOPT), by selecting   *
* for instance  to have  either parallel or  perspective projection,   *
* either  Y-Z  or  R-Z  projection,  hidden  line  removal,  surface   *
* shading, etc.                                                        *
*  There is  a routine (GDZOOM) that,  if called, applies a  zoom to   *
* everything (volumes, tracks, hits, etc.)  will be drawn from then.   *
* This feature, in conjunction  with the interactive command MEASURE   *
* [XINT 110], can be used for detailed viewing.                        *
*  Another  tool that  could help  in the  interactive debugging  or   *
* tuning of the detector geometry  is the routine GEDITV [DRAW 600],   *
* by which it  is possible to modify  interactively some geometrical   *
* parameters  set  by  the   user  routines  defining  the  detector   *
* geometry.                                                            *
*  It is possible to draw the axes of the 3D MAster Reference System   *
* (GDAXIS) oriented in agreement with the current view point.          *
*  Two other  routines draw a scale  (GDSCAL) or a profile  of a man   *
* (GDMAN) in 2D  user coordinates to give an idea  of the dimensions   *
* within current scale  factors.  A 2D text  (GDRAWT) using software   *
* characters (hardware  characters should be implemented  later on),   *
* 2D vectors (GDRAWV) or a frame header (GDHEAD) are also available.   *
*  Attributes  like colour  (GDCOL)  and line  width  (GDLW) can  be   *
* globally set for all 2D  drawings (i.e. text, vectors, man, etc.);   *
* they are overridden in 3D drawings by volume attributes set by the   *
* GSATT routine with 'COLO' or 'LWID' option.                          *
*  A  graphics input  is available  (GDCURS)  to fetch  the 2D  user   *
* coordinates  of the  graphics cursor  on the  screen, allowing  an   *
* immediate user  interface with the interactive  version of GEANT3.   *
* In  particular there  are interactive  commands to  zoom, measure,   *
* pick tracks or hits points that make use of that routine.            *
*  Various conversions from  3D to 3D, and 3D to  2D coordinates are   *
* performed by GDFR3D and GD3D3D.                                      *
*                                                                      *
* BASIC AND ADVANCED GRAPHICS                                          *
*                                                                      *
*  The  underlying graphics  system  is completely  hidden from  the   *
* GEANT program.  All  graphics call are made via  the HIGZ package.   *
* Various implementations of the HIGZ package are available, notably   *
* for X11, GKS, DI3000 and, shortly, PHIGS.                            *
*                                                                      *
*  RUNNING INSTRUCTIONS                                                *
*                                                                      *
*  Thanks to the HIGZ package,  it is possible to produce postscript   *
* metafiles from the drawings.  When  the GKS implementation of HIGZ   *
* is used, the possibility is there  to produce also a GKS metafile.   *
*                                                                      *
* SUMMARY                                                              *
*                                                                      *
*  The drawing package is initialized by (in the order):               *
*  IGINIT    to initialize the HIGZ package and the underlying basic   *
*            graphics software                                         *
*  GDINIT    to initialize the GEANT drawing package                   *
*                                                                      *
*  Main drawing routines are:                                          *
*  GDRAW     to draw a projection view of the detector                 *
*  GDRVOL    to draw a projection view of the detector                 *
*  GDRAWC    to draw a cut view of the detector (along one axis)       *
*  GDRAWX    to draw a cut view of the detector (from any point)       *
*  GDXYZ     to draw tracks at the end of the event                    *
*  GDCXYZ    to draw tracks while the event is running                 *
*  GDPART    to draw particle names and track numbers on tracks        *
*  GDAHIT    to draw one single hit                                    *
*  GDHITS    to draw hits for trajectory type detectors                *
*  GDCHIT    to draw hits for calorimeter type detectors               *
*                                                                      *
*  Routines that show how the detector has been modeled are:           *
*  GDTREE    to draw a picture with the geometrical tree               *
*  GDSPEC    to draw a picture with volume specifications              *
*  GDFSPC    to draw several GDSPEC pictures                           *
*                                                                      *
*  Routines that perform control operations on view banks are:         *
*  GDOPEN    to open a given view bank, identified by a view number;   *
*            in this way we enter in bank-mode                         *
*  GDCLOS    to close  current view bank, i.e. the last  one opened,   *
*            and restore screen-mode                                   *
*  GDSHOW    to show all graphics information contained  in a  given   *
*            view bank                                                 *
*  GDELET    to delete a given view bank from memory                   *
*                                                                      *
*  Other routines are:                                                 *
*  GDOPT     to set drawing options                                    *
*  GDZOOM    to set the zoom parameters                                *
*  GDAXIS    to draw the axes of  the MARS,  oriented according        *
*            to the current view parameters                            *
*  GDSCAL    to draw the current scale                                 *
*  GDMAN     to draw a profile of a man  (or a woman) at the current   *
*            scale                                                     *
*  GDRAWT    to draw text, with software characters                    *
*  GDRAWV    to draw polylines in 2D user coordinates                  *
*  GDHEAD    to draw a frame header                                    *
*  GDCOL     to set colour code                                        *
*  GDLW      to set line width                                         *
*  GDCURS    to have an input from the graphics cursor                 *
*  GDFR3D    to convert from 3D coordinates (either in MARS or DRS)    *
*            to 2D user coordinates                                    *
*  GD3D3D    to convert from 3D MARS coordinates to  3D  Projection    *
*            Reference System coordinates.                             *
*                                                                      *
*        Labelled COMMON blocks related to section DRAW                *
*        ----------------------------------------------                *
*                                                                      *
*    COMMON/GCDRAW/NUMNOD,MAXNOD,NUMND1,LEVVER,LEVHOR,MAXV,IPICK,      *
*   + MLEVV,MLEVH,NWCUT,JNAM,JMOT,JXON,JBRO,JDUP,JSCA,JDVM,JPSM,       *
*   + JNAM1,JMOT1,JXON1,JBRO1,JDUP1,JSCA1,JULEV,JVLEV,                 *
*   + LOOKTB(16),                                                      *
*   + GRMAT0(10),GTRAN0(3),IDRNUM,GSIN(41),GCOS(41),SINPSI,COSPSI,     *
*   + GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV,NGVIEW,                       *
*   + ICUTFL,ICUT,CTHETA,CPHI,DCUT,NSURF,ISURF,                        *
*   + GZUA,GZVA,GZUB,GZVB,GZUC,GZVC,PLTRNX,PLTRNY,                     *
*   + LINATT,LINATP,ITXATT,ITHRZ,IPRJ,DPERS,ITR3D,IPKHIT,IOBJ,LINBUF,  *
*   + MAXGU,MORGU,MAXGS,MORGS,MAXTU,MORTU,MAXTS,MORTS,                 *
*   + IGU,IGS,ITU,ITS,NKVIEW,IDVIEW,                                   *
*   + NOPEN,IGMR,IPIONS,ITRKOP,IHIDEN,                                 *
*   + DDUMMY(18)                                                       *
* C                                                                    *
* NUMNOD  number of nodes in non-optimized tree                        *
* MAXNOD  max. number of nodes of non-optimized tree.                  *
* NUMND1  number of nodes in optimized tree                            *
* LEVVER  vertical level in the tree currently scanned                 *
* LEVHOR  horizontal node in the tree currently scanned                *
* MAXV    max vertical levels in the tree to be scanned                *
* IPICK   node selected by GDTREE                                      *
* MLEVV   number of vertical levels in the last tree scanned           *
* MLEVH   number of horizontal nodes in the last tree scanned          *
* NWCUT   max. workspace allocated by cut routines                     *
* JNAM-JVLEV   pointers used by the tree routines                      *
* LOOKTB  colour look-up table, LOOKTB(I)=I,I=1,16                     *
* GRMAT0  rotation matrix saved by GDRVOL                              *
* GTRAN0  translation matrix saved by GDRVOL                           *
* IDRNUM  flag for GDRAW, set to 1 when called by GDRVOL               *
* GSIN    sine table                                                   *
* GCOS    cosine table                                                 *
* SINPSI  SIN(GPSI*DEGRAD)                                             *
* COSPSI  COS(GPSI DEGRAD)                                             *
* GTHETA  Theta angle of the parallel projection of 3-D images         *
* GPHI    Phi angle of the parallel projection of 3-D images           *
* GPSI    Psi angle of rotation of the image on the screen             *
* GU0     U position (X in screen coordinates) of the origin           *
* GV0     V position (Y in screen coordinates) of the origin           *
* GSCU    scale factor for the U screen coordinate                     *
* GSCV    scale factor for the V screen coordinate                     *
* NGVIEW  flag for GDFR3D and GD3D3D if view point has changed         *
* ICUTFL  flag for GDRAW if it was called by cut routines              *
* ICUT    axis along which the cut is performed                        *
* CTHETA  Theta angle of cut supplied to GDRAWX                        *
* CPHI    Phi angle of cut supplied to GDRAWX                          *
* DCUT    coordinate value at which the cut is performed               *
* NSURF   number of surfaces stored in SURF                            *
* ISURF   pointer for array SURF                                       *
* GZUA    zoom parameter (horizontal scale factor)                     *
* GZVA    zoom parameter (vertical scale factor)                       *
* GZUB    zoom parameter                                               *
* GZVB    zoom parameter                                               *
* GZUC    zoom parameter                                               *
* GZVC    zoom parameter                                               *
* PLTRNX  screen and plotter X range                                   *
* PLTRNY  screen and plotter Y range                                   *
* LINATT  current line attributes                                      *
* LINATP  permanent line attributes                                    *
* ITXATT  current text attributes                                      *
* ITHRZ   string containing the status of THRZ option                  *
* IPRJ    string containing the status of PROJ option                  *
* DPERS   distance from the origin for perspective view                *
* ITR3D   track being scanned                                          *
* IPKHIT  flag for GPHITS, if>0 then print only hit number             *
* IOBJ    type of the object being drawn                               *
* LINBUF  flag for GDRAWV if line buffering is active                  *
* MAXGU   current physical number of words for graphic unit banks      *
* MORGU   number of words to be pushed in graphic unit banks           *
* MAXGS   current physical number of words for graphic segment banks   *
* MORGS   number of words to be pushed in graphic segment banks        *
* MAXTU   current physical number of words for text unit banks         *
* MORTU   number of words to be pushed in text unit banks              *
* MAXTS   current physical number of words for text segment banks      *
* MORTS   number of words to be pushed in text segment banks           *
* IGU     pointer to current graphic unit bank                         *
* IGS     pointer to current graphic segment bank                      *
* ITU     pointer to current text unit bank                            *
* ITS     pointer to current text segment bank                         *
* NKVIEW  number of view data banks                                    *
* IGVIEW  current view bank number or 0 for screen                     *
* NOPEN   unused                                                       *
* IGMR    unused                                                       *
* IPIONS  unused                                                       *
* ITRKOP  status of TRAK option of GDOPT                               *
* DDUMMY  array of dummy words                                         *
*                                                                      *
*                                                                      *
*                                                                      *
*                The View data structure JDRAW                         *
*                -----------------------------                         *
*                                                                      *
* NKVIEW    Number of views                                            *
* IVIEW     Current view selected                                      *
* IGU       Current graphic unit pointer                               *
* MAXGU     Number of graphic units                                    *
* MORGU     Number of words to push in graphic unit bank               *
* IGS       Current graphic segment pointer                            *
* MAXGS     Number of graphic segments                                 *
* MORGS     Number of words to push in graphic segment bank            *
* ITU       Current text unit pointer                                  *
* MAXTU     Number of text units                                       *
* MORTU     Number of words to push in text unit bank                  *
* ITS       Current text segment pointer                               *
* MAXTS     Number of text segments                                    *
* MORTS     Number of words to push in text segment bank               *
* LENGU     Array containing: lengths for each graphic unit + LINATT   *
*           (line attributes)                                          *
* ADDGU     Array containing addresses for each graphic unit           *
* ADDTU     Array containing addresses for each text unit              *
* X         Array containing u-coordinates of graphic segments         *
* Y         Array containing v-coordinates of graphic segments         *
* ICUT      Cut axis (1,2,3 or 0 if no cut) of the view                *
* LINWID    Text line width + ITXATT (text attributes)                 *
* GTHETA,  GPHI,  GPSI,  GU0,  GV0,  GSCU,  GSCV,  are  the  viewing   *
* parameters stored in /GCDRAW/.                                       *
* U0, V0,  SIZE, ANGLE, IOPT, ITEXT  have the same meaning  of those   *
* given as parameters in HPLSOF or GDRAWT routines.                    *
*  A control word is stored  in Q(JDRAW+IVIEW), to identify the view   *
* banks among three classes:                                           *
*                                                                      *
*  =1 for empty  banks (created just  to avoid gaps) or  for deleted   *
*     banks;                                                           *
*  =2 for all previously created banks (i.e. opened);                  *
*  =3 for protected  banks (all banks  that can't be deleted  by the   *
*     user with GDELET, because reserved for internal use).            *
*                                                                      *
*                           | JDRAW                                    *
*                           |                                          *
*     NKVIEW   IVIEW        v                 NKVIEW                   *
*       ........................................                       *
*       |     | |          | |  Control words  |                       *
*       ........................................                       *
*              |                                                       *
*              | JV = LQ(JDRAW-IVIEW)                                  *
*  6           v                                           22          *
* ............................................................         *
* | | | | | | | |igu,maxgu,morgu,igs,maxgs,morgs,itu,maxtu,  |         *
* | | | | | | | |        mortu,its,maxts,morts,gtheta,gphi,  |         *
* | | | | | | | |        gpsi,gu0,gv0,gscu,gscv,-,-,icut     |         *
* ............................................................         *
*  | | | | | |                                                         *
*  | | | | | | JV1 = LQ(JV-1)                                          *
*  | | | | | v                                          MAXGU          *
*  | | | | |..................................................         *
*  | | | | || | lengu(1) | .... | lengu(igu) | .... | lengu(mgu)       *
*  | | | | |..................................................         *
*  | | | | |                                                           *
*  | | | | | JV2 = LQ(JV-2)                                            *
*  | | | | v                                            MAXGU          *
*  | | | |....................................................         *
*  | | | || | addgu(1) | ..... | addgu(igu) | ..... | addgu(mgu)       *
*  | | | |....................................................         *
*  | | | |                                                             *
*  | | | |  JV3 = LQ(JV-3)                                             *
*  | | | v                                              MAXTU          *
*  | | |......................................................         *
*  | | || | addtu(1) | ...... | addtu(itu) | ...... | addtu(mtu)       *
*  | | |......................................................         *
*  | | |                                                               *
*  | | | JV4 = LQ(JV-4)                                                *
*  | | v                                                MAXGS          *
*  | |........................................................         *
*  | || |  x(1)  |  ......  |  x(igs)  |  ......  |  x(mgs)  |         *
*  | |........................................................         *
*  | |                                                                 *
*  | | JV5 = LQ(JV-5)                                                  *
*  | v                                                  MAXGS          *
*  |..........................................................         *
*  || |   y(1)  |  ......  |  y(igs)  |  ......  |  y(mgs)   |         *
*  |..........................................................         *
*  |                                                                   *
*  | JV6 = LQ(JV-6)                                                    *
*  v                                                    MAXTS          *
* ............................................................         *
* | |u0(1)|v0(1)|size(1)|angle(1)|linwid(1)|iopt(1)|itext(1)|nchar(1)|.*
*  ............................................................        *
*                                                                      *
************************************************************************
#endif
+DECK,  GDRAWC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:24  cernlib
* Geant

      SUBROUTINE GDRAWC(NAME,IAX,CUTVAL,U0,V0,SU,SV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This routine draws the intersection of the object        *
C.    *       called NAME with the cut plane normal to one of the      *
C.    *       main axes (IAX=1 is X, IAX=2 is Y, IAX=3 is Z)           *
C.    *       and placed at the distance CUTVAL from the origin.       *
C.    *                                                                *
C.    *       The resulting picture is seen from the axis choosen      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC                      *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
      CHARACTER*4 NAME
      DIMENSION THE(3),PHI(3)
      SAVE THE,PHI
      DATA THE/90.,90.,0./
      DATA PHI/180.,90.,0./
C.
C.    ------------------------------------------------------------------
C.
C             Allocate working space
C
      CALL GWORK(NWCUT)
C
      ICUT=IAX
      DCUT=CUTVAL
C
      NSURF=0
      ISURF=1
C
C             ICUTFL=1 informs GDRAW to call GDRWSC instead of GDRAWS
C             (so that we'll have stored surfaces instead of drawn lines)
C             and to use the line buffer logic of GDRAWV
C
C             PSI is fixed to 0.
C
      ICUTFL=1
      CALL GDRAW(NAME,THE(ICUT),PHI(ICUT),0.,U0,V0,SU,SV)
      ICUTFL=0
      END
+DECK,  GDRAWP, T=FORT.
* Revision 1.2  1996/09/30 13:37:32  ravndal
* Backward compatibility for view banks
* Revision 1.1.1.1  1995/10/24 10:20:24  cernlib
* Geant

      SUBROUTINE GDRAWP(U,V,NP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the polyline described by U and V vectors,          *
C.    *       of length NP.                                            *
C.    *                                                                *
C.    *       Depending on IDVIEW it draws on screen (IDVIEW=0)        *
C.    *       or stores in the current view bank (IDVIEW>0).           *
C.    *                                                                *
C.    *       In LINATT (common GCDRAW) there is                       *
C.    *       a bit mask for the line attributes :                     *
C.    *                                                                *
C.    *       Bit  1- 7 = Used by view bank (LENGU)                    *
C.    *       Bit  8-10 = Line width                                   *
C.    *       Bit 11-13 = Line style                                   *
C.    *       Bit 14-16 = Fill area                                    *
C.    *       Bit 17-24 = Line color                                   *
C.    *                                                                *
C.    *    ==>Called by : GDRAWV                                       *
C.    *       Author : P.Zanarini ; S.Giani  1992 ********             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCSPEE.
*
      COMMON/SP3D/ISPFLA
*
      DIMENSION U(*),V(*)
      SAVE LFILOL
      DATA LFILOL/-1/
C.
C.    ------------------------------------------------------------------
C.
      LLEP=ABS(LEP)
      LINFLA=0
      IF (IDVIEW.EQ.0.OR.IDVIEW.EQ.-175) GO TO 40
C
C             Store on view bank IDVIEW
C
      JV=LQ(JDRAW-IDVIEW)
      IGU=IGU+1
C
   10 IF (IGU.LE.MAXGU) GO TO 20
C
C             Push graphic unit banks
C
      IF(MORGU.EQ.0)MORGU=100
      MORPUS=MAX(MORGU,MAXGU/4)
      JV = LQ(JV-1)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 50
      JV=LQ(JDRAW-IDVIEW)
      JV = LQ(JV-2)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 50
      JV=LQ(JDRAW-IDVIEW)
      MAXGU=MAXGU+MORPUS
      GO TO 10
C
   20 IF ((IGS+NP).LE.MAXGS) GO TO 30
C
C             Push graphic segment banks
C
      IF(MORGS.EQ.0)MORGS=100
      MORPUS=MAX(MORGS,MAXGS/4,NP)
      JV = LQ(JV-4)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 50
      JV=LQ(JDRAW-IDVIEW)
      JV = LQ(JV-5)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 50
      JV=LQ(JDRAW-IDVIEW)
      MAXGS=MAXGS+MORPUS
*
      GO TO 20
C
   30 CONTINUE
      Q(JV+13)=GTHETA
      Q(JV+14)=GPHI
      Q(JV+15)=GPSI
      Q(JV+16)=GU0
      Q(JV+17)=GV0
      Q(JV+18)=GSCU
      Q(JV+19)=GSCV
      JV1=LQ(JV-1)
      JV2=LQ(JV-2)
      JV4=LQ(JV-4)
      JV5=LQ(JV-5)
*
      CALL UCOPY(U,Q(JV4+IGS+1),NP)
      CALL UCOPY(V,Q(JV5+IGS+1),NP)
C
C             Bit 1- 7 = LENGU
C             Bit 8-24 = Line attribute
C
      ISUM=0
      CALL MVBITS(LINATT,0,24,ISUM,0)
      IFIL=IBITS(ISUM,13,3)
      IF(IFIL.EQ.0)THEN
         CALL MVBITS(NP,0,7,ISUM,0)
      ELSE
         CALL MVBITS(NP,0,10,ISUM,0)
      ENDIF
      Q(JV1+IGU)=ISUM
C
      Q(JV2+IGU)=IGS+1
      IGS=IGS+NP
      GO TO 999
C
C             Draw vectors on screen
C
   40 CONTINUE
C
C             Extract the new line attributes
C
      LINCOL=IBITS(LINATT,16,8)
      CALL ISFACI(LINCOL)
      LINFIL=IBITS(LINATT,13,3)
      IF(IDVIEW.NE.-175.OR.LINFIL.EQ.0)THEN
         LINWID=IBITS(LINATT,7,3)
         IF(LINWID.GT.1)LINWID=LINWID*2
      ELSE
         LINWID=8-LINFIL
         IF(LINFIL.EQ.1)LINWID=2
         IF(LINWID.GT.1)LINWID=LINWID*2
         IF(ZZFV.GT.1.)LINWID=LINWID*ZZFV
      ENDIF
      LINSTY=IBITS(LINATT,10,3)
      IF(LINSTY.EQ.7)LINSTY=1
      IF(LINFIL.LE.1.OR.IDVIEW.EQ.-175.OR.ISPFLA.EQ.1)
     +CALL ISPLCI(LINCOL)
      WLINW=LINWID
      CALL IGSET('LWID',WLINW)
C
C             If NP=1 draw a marker
C
      IF (NP.EQ.1) THEN
         CALL IPM(1,U,V)
      ELSE
C
C
C             Fill area
C
*SG
         IF(IDVIEW.EQ.-175)THEN
            IF(LINFIL.GT.0.AND.NP.GT.2.AND.LINSTY.NE.6)THEN
               CALL ISFAIS(1)
               CALL IFA(NP,U,V)
            ENDIF
         ENDIF
C
C             If NP>1 draw a line with a given style
C             and draw black edges both for HIDE OFF
C             and SHAD options in case of FILL
C
         CALL UCTOH('ON  ',IFLH,4,4)
         IF(IHIDEN.NE.IFLH.AND.LINFIL.GT.0)THEN
           CALL ISPLCI(1)
         ENDIF
         IF(LINSTY.EQ.6.AND.LINFIL.NE.0)THEN
            LINSTY=1
            LINFLA=1
            CALL ISPLCI(1)
            CALL IGSET('LWID',3.)
            IF(LINWID.GE.12)CALL IGSET('LWID',6.)
            IF(LINWID.LE.4)CALL IGSET('LWID',1.)
         ENDIF
         IF(LLEP.LE.10.OR.LINFIL.EQ.0.OR.LINFLA.NE.1)THEN
            IF (LINSTY.EQ.1) THEN
***            call write_dxf_pline(np,u,v,lincol,linwid,1)
               CALL IPL(NP,U,V)
C
            ELSE IF (LINSTY.GT.1.AND.LINSTY.LE.4) THEN
               CALL ISLN(LINSTY)
               CALL IPL(NP,U,V)
               CALL ISLN(1)
C
            ENDIF
         ENDIF
C
      ENDIF
C
      GO TO 999
C
   50 WRITE (CHMAIL,10000)
      CALL GMAIL(0,0)
C
10000 FORMAT (' *** GDRAWP ***: Memory overflow in pushing a bank')
  999 END

+DECK,  GDRAWS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:24  cernlib
* Geant

      SUBROUTINE GDRAWS(ISHAPE,PAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the shape number ISHAPE, of parameters PAR          *
C.    *                                                                *
C.    * SHAPE     SHAPE    SHAPE                                       *
C.    * NUMBER    TYPE     PARAMETERS                                  *
C.    * -------------------------------------------------------------- *
C.    *                                                                *
C.    *   1       BOX      DX,DY,DZ                                    *
C.    *   2       TRD1     DX1,DX2,DY,DZ                               *
C.    *   3       TRD2     DX1,DX2,DY1,DY2,DZ                          *
C.    *   4       TRAP     DZ,TX,TY,H1,BL1,TL1,TTH1,H2,BL2,TL2,TTH2    *
C.    *                                                                *
C.    *   5       TUBE     RMIN,RMAX,DZ                                *
C.    *   6       TUBS     RMIN,RMAX,DZ,PHIMIN,PHIMAX                  *
C.    *   7       CONE     DZ,RMIN1,RMAX1,RMIN2,RMAX2                  *
C.    *   8       CONS     DZ,RMIN1,RMAX1,RMIN2,RMAX2,PHIMIN,PHIMAX    *
C.    *                                                                *
C.    *   9       SPHE     RMIN,RMAX,THEMIN,THEMAX,PHIMIN,PHIMAX       *
C.    *                                                                *
C.    *  10       PARA     DX,DY,DZ,TXY,TXZ,TYZ                        *
C.    *  11       PGON     PHIMIN,DPHI,NDIV,NZ,Z(1),RMIN(1),RMAX(1),...*
C.    *  12       PCON     PHIMIN,DPHI,NZ,Z(1),RMIN(1),RMAX(1),Z(2),...*
C.    *  13       ELTU     A,B,DZ                                      *
C.    *  14       HYPE     RMIN,RMAX,DZ,PHI                            *
C.    *  NSGTRA   GTRA     DZ,TH,PHI,TWIST,Y1,XL1,XH1,TH1,Y2,XL2,XH2,..*
C.    *  NSCTUB   CTUB     RMIN,RMAX,DZ,PHIMIN,PHIMAX,LXL,LYL,LZL,LXH,.*
C.    *                                                                *
C.    *    ==>Called by : GDRAW                                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *       Modification log.                                        *
C.    *        1-Jun-88 A.C.McPherson - Introduce cut tube shape.      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCONSP.
+CDE, GCSHNO.
*
      PARAMETER ( NLPC = 40 )
*
*            The constant NLPC defined in the parameter statement
*            is the number of line elements to form a complete
*            circle in the surface definitions for a cut tube.
*
      DIMENSION CPHIS(NLPC+1),SPHIS(NLPC+1)
*
      DIMENSION X(3,46), U(46), V(46)
      DIMENSION PAR(50),P(3,8),PP(3,8)
C.
C.    ------------------------------------------------------------------
C.
      IF (ISHAPE.NE.1) GO TO 200
C
C             BOX
C
      DX1=PAR(1)
      DY1=PAR(2)
      DX2=DX1
      DY2=DY1
      DZ=PAR(3)
      GO TO 1000
C
  200 IF (ISHAPE.NE.2) GO TO 300
C
C             TRD1
C
      DX1=PAR(1)
      DX2=PAR(2)
      DY1=PAR(3)
      DY2=DY1
      DZ=PAR(4)
      GO TO 1000
C
  300 IF (ISHAPE.NE.3) GO TO 400
C
C             TRD2
C
      DX1=PAR(1)
      DX2=PAR(2)
      DY1=PAR(3)
      DY2=PAR(4)
      DZ=PAR(5)
      GO TO 1000
C
  400 IF (ISHAPE.NE.4) GO TO 500
C
C             TRAP
C
      DZ=PAR(1)
      TX=PAR(2)
      TY=PAR(3)
      H1=PAR(4)
      BL1=PAR(5)
      TL1=PAR(6)
      TTH1=PAR(7)
      H2=PAR(8)
      BL2=PAR(9)
      TL2=PAR(10)
      TTH2=PAR(11)
      GO TO 1500
C
  500 IF (ISHAPE.NE.5) GO TO 600
C
C             TUBE
C
      RMIN1=PAR(1)
      RMAX1=PAR(2)
      RMIN2=RMIN1
      RMAX2=RMAX1
      Z2=PAR(3)
      Z1=-Z2
      GO TO 2000
C
  600 IF (ISHAPE.NE.6) GO TO 700
C
C             TUBS
C
      RMIN1=PAR(1)
      RMAX1=PAR(2)
      RMIN2=RMIN1
      RMAX2=RMAX1
      Z2=PAR(3)
      Z1=-Z2
      PHIMIN=PAR(4)
      PHIMAX=PAR(5)
      GO TO 2500
C
  700 IF (ISHAPE.NE.7) GO TO 800
C
C             CONE
C
      RMIN1=PAR(2)
      RMAX1=PAR(3)
      RMIN2=PAR(4)
      RMAX2=PAR(5)
      Z2=PAR(1)
      Z1=-Z2
      GO TO 2000
C
  800 IF (ISHAPE.NE.8) GO TO 900
C
C             CONS
C
      RMIN1=PAR(2)
      RMAX1=PAR(3)
      RMIN2=PAR(4)
      RMAX2=PAR(5)
      Z2=PAR(1)
      Z1=-Z2
      PHIMIN=PAR(6)
      PHIMAX=PAR(7)
      GO TO 2500
C
  900 IF (ISHAPE.NE.9) GO TO 910
C
C             SPHE
C
      RMIN=PAR(1)
      RMAX=PAR(2)
      PHMI=PAR(5)
      PHMA=PAR(6)
      GO TO 3000
C
  910 IF (ISHAPE.NE.10) GO TO 911
C
C             PARA
C
      DX=PAR(1)
      DY=PAR(2)
      DZ=PAR(3)
      TXY=PAR(4)
      TXZ=PAR(5)
      TYZ=PAR(6)
C
      TX=TXZ
      TY=TYZ
      H1=DY
      BL1=DX
      TL1=DX
      TTH1=TXY
      H2=DY
      BL2=DX
      TL2=DX
      TTH2=TXY
      GO TO 1500
C
  911 IF (ISHAPE.NE.11) GO TO 912
C
C             PGON
C
      PHIMIN=PAR(1)
      PHIMAX=PHIMIN+PAR(2)
      NDIV=PAR(3)
      NZ=PAR(4)
      DPHI=(PHIMAX-PHIMIN)/NDIV
C
C             Z(1)=PAR(5) - RMIN(1)=PAR(6) - RMAX(1)=PAR(7) - Z(2)=PAR(8) - ...
C
      GO TO 4000
C
  912 IF (ISHAPE.NE.12) GO TO 950
C
C             PCON
C
      PHIMIN=PAR(1)
      PHIMAX=PHIMIN+PAR(2)
      NZ=PAR(3)
C
C             Z(1)=PAR(4) - RMIN(1)=PAR(5) - RMAX(1)=PAR(6) - Z(2)=PAR(7) - ...
C
      GO TO 5000
C
  950 CONTINUE
C
      IF (ISHAPE.NE.13) GO TO 951
C
C             ELTU
C
      A=PAR(1)
      B=PAR(2)
      Z2=PAR(3)
      Z1=-Z2
      GO TO 7000
  951 CONTINUE
C
      IF (ISHAPE.NE.14) GO TO 955
C
C             HYPErboloid
C
      RMIN1 = PAR(1)
      RMAX1 = PAR(2)
      Z2=PAR(3)
      TANTHS = (TAN(PAR(4)*DEGRAD))**2
      RMIN12 = RMIN1*RMIN1
      RMAX12 = RMAX1*RMAX1
      RMIN2 = SQRT(RMIN12 + Z2*Z2*TANTHS)
      RMAX2 = SQRT(RMAX12 + Z2*Z2*TANTHS)
      Z1=-Z2
      GO TO 7410

  955 CONTINUE
      IF(ISHAPE.NE.28) GO TO 980
C
C             General twisted trapezoid.
C
      DO 970 IL=1,4
      I0=IL*4+11
      P(3,IL)=-PAR(1)
      P(1,IL)=PAR(I0)+PAR(I0+2)*P(3,IL)
      P(2,IL)=PAR(I0+1)+PAR(I0+3)*P(3,IL)
      P(3,IL+4)=PAR(1)
      P(1,IL+4)=PAR(I0)+PAR(I0+2)*P(3,IL+4)
      P(2,IL+4)=PAR(I0+1)+PAR(I0+3)*P(3,IL+4)
  970 CONTINUE
C
      GO TO 1600
*
  980 CONTINUE
      IF( ISHAPE .EQ. NSCTUB ) THEN
*
        DPHIS = PAR(5)-PAR(4)
        IF( DPHIS .LE. 0.0 ) DPHIS=DPHIS+TWOPI
        NL = MAX(DPHIS*NLPC/360.0,1.)
        DPHI = 360.0/NLPC
        PHIS = PAR(4)
        IF( PAR(4) .EQ. 0.0 .AND. PAR(5) .EQ. 360.0 ) THEN
          ISEG = 0
        ELSE
          ISEG = 1
          DPHI = DPHIS/NL
        ENDIF
*
        GO TO 6000
*
      ELSE
        GO TO 9999
      ENDIF
C
 1000 CONTINUE
C
C             Rectilinear shapes: BOX,TRD1,TRD2
C
      X1=0.
      Y1=0.
      X2=0.
      Y2=0.
      Z1=-DZ
      Z2=DZ
C
C             Calculate the 8 vertex for rectilinear shapes
C
      P(1,1)=X1+DX1
      P(2,1)=Y1+DY1
      P(3,1)=Z1
      P(1,2)=X1-DX1
      P(2,2)=Y1+DY1
      P(3,2)=Z1
      P(1,3)=X1-DX1
      P(2,3)=Y1-DY1
      P(3,3)=Z1
      P(1,4)=X1+DX1
      P(2,4)=Y1-DY1
      P(3,4)=Z1
      P(1,5)=X2+DX2
      P(2,5)=Y2+DY2
      P(3,5)=Z2
      P(1,6)=X2-DX2
      P(2,6)=Y2+DY2
      P(3,6)=Z2
      P(1,7)=X2-DX2
      P(2,7)=Y2-DY2
      P(3,7)=Z2
      P(1,8)=X2+DX2
      P(2,8)=Y2-DY2
      P(3,8)=Z2
C
      CALL GDRECT(P(1,1),P(1,2),P(1,3),P(1,4))
      CALL GDRECT(P(1,5),P(1,6),P(1,7),P(1,8))
      CALL GDLINE(P(1,1),P(1,5))
      CALL GDLINE(P(1,2),P(1,6))
      CALL GDLINE(P(1,3),P(1,7))
      CALL GDLINE(P(1,4),P(1,8))
C
      GO TO 9999
C
 1500 CONTINUE
C
C             TRAP,PARA
C
C             Calculate the 8 vertex
C
      P(1,1)=-DZ*TX+TTH1*H1+TL1
      P(2,1)=+H1-DZ*TY
      P(3,1)=-DZ
      P(1,2)=-DZ*TX+TTH1*H1-TL1
      P(2,2)=+H1-DZ*TY
      P(3,2)=-DZ
      P(1,3)=-DZ*TX-TTH1*H1-BL1
      P(2,3)=-H1-DZ*TY
      P(3,3)=-DZ
      P(1,4)=-DZ*TX-TTH1*H1+BL1
      P(2,4)=-H1-DZ*TY
      P(3,4)=-DZ
      P(1,5)=+DZ*TX+TTH2*H2+TL2
      P(2,5)=+H2+DZ*TY
      P(3,5)=+DZ
      P(1,6)=+DZ*TX+TTH2*H2-TL2
      P(2,6)=+H2+DZ*TY
      P(3,6)=+DZ
      P(1,7)=+DZ*TX-TTH2*H2-BL2
      P(2,7)=-H2+DZ*TY
      P(3,7)=+DZ
      P(1,8)=+DZ*TX-TTH2*H2+BL2
      P(2,8)=-H2+DZ*TY
      P(3,8)=+DZ
C
 1600 CONTINUE
C
      CALL GDRECT(P(1,1),P(1,2),P(1,3),P(1,4))
      CALL GDRECT(P(1,5),P(1,6),P(1,7),P(1,8))
      CALL GDLINE(P(1,1),P(1,5))
      CALL GDLINE(P(1,2),P(1,6))
      CALL GDLINE(P(1,3),P(1,7))
      CALL GDLINE(P(1,4),P(1,8))
C
C             Condition for plane sides are :
C
C             TTH1=TTH2
C
C             and
C
C             H2*(BL1-TL1)=H1(BL2-TL2)
C
C             In that case we should draw on each side 10 lines
C             (perpendicular to side lines) to make an easy
C             visualisation that sides are not planes
C
      GO TO 9999
C
 2000 CONTINUE
C
C             Cylindric shapes: TUBE,CONE
C
      CALL GDCIRC(RMAX1,Z1)
      CALL GDCIRC(RMIN1,Z1)
      CALL GDCIRC(RMAX2,Z2)
      CALL GDCIRC(RMIN2,Z2)
      PHIP=GPHI+90.
      PHIM=GPHI+270.
      CALL GDLCYL(RMIN1,PHIP,Z1,RMIN2,PHIP,Z2)
      CALL GDLCYL(RMIN1,PHIM,Z1,RMIN2,PHIM,Z2)
      CALL GDLCYL(RMAX1,PHIP,Z1,RMAX2,PHIP,Z2)
      CALL GDLCYL(RMAX1,PHIM,Z1,RMAX2,PHIM,Z2)
C
      GO TO 9999
C
 2500 CONTINUE
C
C             Segmented cylindric shapes: TUBS,CONS
C
      CALL GDARC(RMAX1,Z1,PHIMIN,PHIMAX)
      CALL GDARC(RMIN1,Z1,PHIMIN,PHIMAX)
      CALL GDARC(RMAX2,Z2,PHIMIN,PHIMAX)
      CALL GDARC(RMIN2,Z2,PHIMIN,PHIMAX)
      PHIP=AMOD((GPHI+90.),360.)
      PHIM=AMOD((GPHI+270.),360.)
      IF (PHIP.LE.PHIMIN.OR.PHIP.GE.PHIMAX) GO TO 2510
      CALL GDLCYL(RMIN1,PHIP,Z1,RMIN2,PHIP,Z2)
      CALL GDLCYL(RMAX1,PHIP,Z1,RMAX2,PHIP,Z2)
 2510 IF (PHIM.LE.PHIMIN.OR.PHIM.GE.PHIMAX) GO TO 2520
      CALL GDLCYL(RMIN1,PHIM,Z1,RMIN2,PHIM,Z2)
      CALL GDLCYL(RMAX1,PHIM,Z1,RMAX2,PHIM,Z2)
 2520 CALL GDLCYL(RMAX1,PHIMIN,Z1,RMAX2,PHIMIN,Z2)
      CALL GDLCYL(RMAX1,PHIMAX,Z1,RMAX2,PHIMAX,Z2)
      CALL GDLCYL(RMIN1,PHIMIN,Z1,RMIN2,PHIMIN,Z2)
      CALL GDLCYL(RMIN1,PHIMAX,Z1,RMIN2,PHIMAX,Z2)
      CALL GDLCYL(RMAX1,PHIMIN,Z1,RMIN1,PHIMIN,Z1)
      CALL GDLCYL(RMAX2,PHIMIN,Z2,RMIN2,PHIMIN,Z2)
      CALL GDLCYL(RMAX1,PHIMAX,Z1,RMIN1,PHIMAX,Z1)
      CALL GDLCYL(RMAX2,PHIMAX,Z2,RMIN2,PHIMAX,Z2)
C
      GO TO 9999
C
 3000 CONTINUE
C
C             SPHE
C
      CALL GDARC(RMAX,0.,PHMI,PHMA)
      CALL GDARC(RMIN,0.,PHMI,PHMA)
      DP = PHMA-PHMI
      IF(DP.LE.0.) DP=DP+360.
      NSTEP = MAX(DP/15.,1.)
      DDP = DP/NSTEP
      PPH = PHMI-DDP
      DO 3005 I=1,NSTEP+1
      PPH = PPH+DDP
      RPPH = PPH*DEGRAD
      COSPH = COS(RPPH)
      SINPH = SIN(RPPH)
      DO 3004 J=1,46
      THET = (J-1)*PI/45.
      X(1,J) = RMAX*SIN(THET)*COSPH
      X(2,J) = RMAX*SIN(THET)*SINPH
      X(3,J) = RMAX*COS(THET)
 3004 CONTINUE
      CALL GDFR3D(X,46,U,V)
      CALL GDRAWV(U,V,46)
 3005 CONTINUE
      IF(RMIN.GE.0.) THEN
      PPH = PHMI-DDP
      DO 3007 I=1,NSTEP+1
      PPH = PPH+DDP
      RPPH = PPH*DEGRAD
      COSPH = COS(RPPH)
      SINPH = SIN(RPPH)
      DO 3006 J=1,46
      THET = (J-1)*PI/45.
      X(1,J) = RMIN*SIN(THET)*COSPH
      X(2,J) = RMIN*SIN(THET)*SINPH
      X(3,J) = RMIN*COS(THET)
 3006 CONTINUE
      CALL GDFR3D(X,46,U,V)
      CALL GDRAWV(U,V,46)
 3007 CONTINUE
      ENDIF
      DO 3010 I=1,3
      DO 3010 J=1,6
 3010 P(I,J)=0.
      IF(DP.GE.360.) THEN
      P(3,1)=-RMAX
      P(3,2)=RMAX
      P(1,3)=-RMAX
      P(1,4)=RMAX
      P(2,5)=RMAX
      P(2,6)=-RMAX
      CALL GDLINE(P(1,1),P(1,2))
      CALL GDLINE(P(1,3),P(1,4))
      CALL GDLINE(P(1,5),P(1,6))
      ELSE
      P(1,1) = RMIN*COS(PHMI*DEGRAD)
      P(2,1) = RMIN*SIN(PHMI*DEGRAD)
      P(1,2) = RMAX*COS(PHMI*DEGRAD)
      P(2,2) = RMAX*SIN(PHMI*DEGRAD)
      CALL GDLINE(P(1,1),P(1,2))
      P(1,1) = RMIN*COS(PHMA*DEGRAD)
      P(2,1) = RMIN*SIN(PHMA*DEGRAD)
      P(1,2) = RMAX*COS(PHMA*DEGRAD)
      P(2,2) = RMAX*SIN(PHMA*DEGRAD)
      CALL GDLINE(P(1,1),P(1,2))
      P(3,3) = -RMAX
      P(3,4) = -RMIN
      CALL GDLINE(P(1,3),P(1,4))
      P(3,3) =  RMAX
      P(3,4) =  RMIN
      CALL GDLINE(P(1,3),P(1,4))
      ENDIF
      GO TO 9999
C
 4000 CONTINUE
C
C             PGON
C
      FACT=1./COS(DEGRAD*DPHI/2.)
      DO 4002 IZ=1,NZ
        PAR(6+(IZ-1)*3)=PAR(6+(IZ-1)*3)*FACT
        PAR(7+(IZ-1)*3)=PAR(7+(IZ-1)*3)*FACT
 4002 CONTINUE
C
      DO 4050 IZ=1,NZ
C
        ZI=PAR(5+(IZ-1)*3)
        R0=PAR(6+(IZ-1)*3)
        R1=PAR(7+(IZ-1)*3)
C
        IF (IZ.EQ.1.OR.IZ.EQ.NZ) GO TO 4003
        R0PRE=PAR(6+(IZ-2)*3)
        R0POST=PAR(6+IZ*3)
        IF (R0.EQ.R0PRE)GO TO 4006
        IF (R0.EQ.R0POST)GO TO 4006
 4003     CONTINUE
          DO 4005 IDIV=1,NDIV
            PHI0=PHIMIN+(IDIV-1)*DPHI
            PHI1=PHI0+DPHI
            CALL GDLCYL(R0,PHI0,ZI,R0,PHI1,ZI)
 4005     CONTINUE
C
 4006   IF (IZ.EQ.1.OR.IZ.EQ.NZ) GO TO 4008
        R1PRE=PAR(7+(IZ-2)*3)
        R1POST=PAR(7+IZ*3)
        IF (R1.EQ.R1PRE )GO TO 4020
        IF (R1.EQ.R1POST)GO TO 4020
 4008     CONTINUE
          DO 4010 IDIV=1,NDIV
            PHI0=PHIMIN+(IDIV-1)*DPHI
            PHI1=PHI0+DPHI
            CALL GDLCYL(R1,PHI0,ZI,R1,PHI1,ZI)
 4010     CONTINUE
C
 4020   IF ((IZ.EQ.1.OR.IZ.EQ.NZ).AND.(PHIMAX-PHIMIN.NE.360.)) THEN
          CALL GDLCYL(R0,PHIMIN,ZI,R1,PHIMIN,ZI)
          CALL GDLCYL(R0,PHIMAX,ZI,R1,PHIMAX,ZI)
        ENDIF
C
        IF (IZ.EQ.1) GO TO 4050
C
        ZI0=PAR(5+(IZ-2)*3)
        R00=PAR(6+(IZ-2)*3)
        R10=PAR(7+(IZ-2)*3)
        DO 4030 IDIV=1,NDIV
          PH=PHIMIN+(IDIV-1)*DPHI
          CALL GDLCYL(R00,PH,ZI0,R0,PH,ZI)
          CALL GDLCYL(R10,PH,ZI0,R1,PH,ZI)
 4030   CONTINUE
        CALL GDLCYL(R00,PHIMAX,ZI0,R0,PHIMAX,ZI)
        CALL GDLCYL(R10,PHIMAX,ZI0,R1,PHIMAX,ZI)
C
 4050 CONTINUE
C
      GO TO 9999
C
 5000 CONTINUE
C
C             PCON
C
      DO 5555 IZ=1,NZ
        ZI=PAR(4+(IZ-1)*3)
        R0=PAR(5+(IZ-1)*3)
        R1=PAR(6+(IZ-1)*3)
        IF (IZ.EQ.1.OR.IZ.EQ.NZ) GO TO 5010
        R1PRE=PAR(6+(IZ-2)*3)
        R1POST=PAR(6+IZ*3)
        IF (R1.LE.R1PRE.OR.R1.LE.R1POST) GO TO 5015
 5010   CONTINUE
        CALL GDARC(R0,ZI,PHIMIN,PHIMAX)
        CALL GDARC(R1,ZI,PHIMIN,PHIMAX)
 5015   CONTINUE
        IF ((PHIMAX-PHIMIN).EQ.360.) GO TO 5020
        CALL GDLCYL(R0,PHIMIN,ZI,R1,PHIMIN,ZI)
        CALL GDLCYL(R0,PHIMAX,ZI,R1,PHIMAX,ZI)
 5020   CONTINUE
        IF (IZ.EQ.1) GO TO 5555
        ZI0=PAR(4+(IZ-2)*3)
        R00=PAR(5+(IZ-2)*3)
        R10=PAR(6+(IZ-2)*3)
        IF ((PHIMAX-PHIMIN).EQ.360.) GO TO 5030
        CALL GDLCYL(R00,PHIMIN,ZI0,R0,PHIMIN,ZI)
        CALL GDLCYL(R10,PHIMIN,ZI0,R1,PHIMIN,ZI)
        CALL GDLCYL(R00,PHIMAX,ZI0,R0,PHIMAX,ZI)
        CALL GDLCYL(R10,PHIMAX,ZI0,R1,PHIMAX,ZI)
C
 5030   CONTINUE
        PHIP=AMOD((GPHI+90.),360.)
        PHIM=AMOD((GPHI+270.),360.)
        IF (PHIP.LT.PHIMIN.OR.PHIP.GT.PHIMAX) GO TO 5510
        CALL GDLCYL(R00,PHIP,ZI0,R0,PHIP,ZI)
        CALL GDLCYL(R10,PHIP,ZI0,R1,PHIP,ZI)
 5510   IF (PHIM.LT.PHIMIN.OR.PHIM.GT.PHIMAX) GO TO 5555
        CALL GDLCYL(R00,PHIM,ZI0,R0,PHIM,ZI)
        CALL GDLCYL(R10,PHIM,ZI0,R1,PHIM,ZI)
 5555 CONTINUE
C
      GO TO 9999
*
 6000 CONTINUE
*
*          Cut tube shape.
*
      CPHIS(1) = COS( PHIS*DEGRAD )
      SPHIS(1) = SIN( PHIS*DEGRAD )
      DO 6010 I = 1, NL
        PHIS = PHIS+DPHI
        CPHIS(I+1) = COS( PHIS*DEGRAD )
        SPHIS(I+1) = SIN( PHIS*DEGRAD )
 6010 CONTINUE
      P( 1, 1) = PAR(2)*CPHIS(1)
      P( 2, 1) = PAR(2)*SPHIS(1)
      P( 3, 1) = -( PAR( 6)*P( 1, 1) +PAR( 7)*P( 2, 1) )/PAR( 8)
     + -PAR( 3)
      P( 1, 4) = PAR(1)*CPHIS(1)
      P( 2, 4) = PAR(1)*SPHIS(1)
      P( 3, 4) = -( PAR( 6)*P( 1, 4) +PAR( 7)*P( 2, 4) )/PAR( 8)
     + -PAR( 3)
      P( 1, 5) = PAR(2)*CPHIS(1)
      P( 2, 5) = PAR(2)*SPHIS(1)
      P( 3, 5) = -( PAR( 9)*P( 1, 5) +PAR( 10)*P( 2, 5) )/PAR( 11)
     + +PAR( 3)
      P( 1, 8) = PAR(1)*CPHIS(1)
      P( 2, 8) = PAR(1)*SPHIS(1)
      P( 3, 8) = -( PAR( 9)*P( 1, 8) +PAR( 10)*P( 2, 8) )/PAR( 11)
     + +PAR( 3)
*
      IF( ISEG .EQ. 1 ) THEN
        CALL GDRECT( P( 1, 1), P( 1, 4), P( 1, 8), P( 1, 5) )
      ENDIF
*
      DO 6020 I = 1, NL
        P( 1, 2) = PAR(2)*CPHIS(I+1)
        P( 2, 2) = PAR(2)*SPHIS(I+1)
        P( 3, 2) = -( PAR( 6)*P( 1, 2) +PAR( 7)*P( 2, 2) )/PAR( 8)
     +   -PAR( 3)
        CALL GDLINE( P( 1, 1),  P( 1, 2) )
        P( 1, 1) = P( 1, 2)
        P( 2, 1) = P( 2, 2)
        P( 3, 1) = P( 3, 2)
 6020 CONTINUE
*
      DO 6030 I = 1, NL
        P( 1, 3) = PAR(1)*CPHIS(I+1)
        P( 2, 3) = PAR(1)*SPHIS(I+1)
        P( 3, 3) = -( PAR( 6)*P( 1, 3) +PAR( 7)*P( 2, 3) )/PAR( 8)
     +   -PAR( 3)
        CALL GDLINE( P( 1, 4),  P( 1, 3) )
        P( 1, 4) = P( 1, 3)
        P( 2, 4) = P( 2, 3)
        P( 3, 4) = P( 3, 3)
 6030 CONTINUE
*
      DO 6040 I = 1, NL
        P( 1, 6) = PAR(2)*CPHIS(I+1)
        P( 2, 6) = PAR(2)*SPHIS(I+1)
        P( 3, 6) = -( PAR( 9)*P( 1, 6) +PAR( 10)*P( 2, 6) )/PAR( 11)
     +   +PAR( 3)
        CALL GDLINE( P( 1, 5),  P( 1, 6) )
        P( 1, 5) = P( 1, 6)
        P( 2, 5) = P( 2, 6)
        P( 3, 5) = P( 3, 6)
 6040 CONTINUE
*
      DO 6050 I = 1, NL
        P( 1, 7) = PAR(1)*CPHIS(I+1)
        P( 2, 7) = PAR(1)*SPHIS(I+1)
        P( 3, 7) = -( PAR( 9)*P( 1, 7) +PAR( 10)*P( 2, 7) )/PAR( 11)
     +   +PAR( 3)
        CALL GDLINE( P( 1, 8),  P( 1, 7) )
        P( 1, 8) = P( 1, 7)
        P( 2, 8) = P( 2, 7)
        P( 3, 8) = P( 3, 7)
 6050 CONTINUE
*
      IF( ISEG .EQ. 1 ) THEN
        CALL GDRECT( P( 1, 1), P( 1, 4), P( 1, 8), P( 1, 5) )
      ENDIF
*
      PHIP = AMOD( GPHI+90.0, 360.0 )
      PHIM = AMOD( GPHI+270.0, 360.0 )
      DPHIP = PHIP-PAR(4)
      DPHIM = PHIM-PAR(4)
      IF( DPHIP .LT. 0.0 ) DPHIP = DPHIP+TWOPI
      IF( DPHIM .LT. 0.0 ) DPHIM = DPHIM+TWOPI
*
      IF( DPHIP .LE. DPHIS ) THEN
        CP = COS( PHIP*DEGRAD )
        SP = SIN( PHIP*DEGRAD )
        P( 1, 1) = PAR(2)*CP
        P( 2, 1) = PAR(2)*SP
        P( 3, 1) = -( PAR( 6)*P( 1, 1) +PAR( 7)*P( 2, 1) )/PAR( 8)
     +   -PAR( 3)
        P( 1, 4) = PAR(1)*CP
        P( 2, 4) = PAR(1)*SP
        P( 3, 4) = -( PAR( 6)*P( 1, 4) +PAR( 7)*P( 2, 4) )/PAR( 8)
     +   -PAR( 3)
        P( 1, 5) = PAR(2)*CP
        P( 2, 5) = PAR(2)*SP
        P( 3, 5) = -( PAR( 9)*P( 1, 5) +PAR( 10)*P( 2, 5) )/PAR( 11)
     +   +PAR( 3)
        P( 1, 8) = PAR(1)*CP
        P( 2, 8) = PAR(1)*SP
        P( 3, 8) = -( PAR( 9)*P( 1, 8) +PAR( 10)*P( 2, 8) )/PAR( 11)
     +   +PAR( 3)
        CALL GDLINE( P( 1, 1), P( 1, 5) )
        CALL GDLINE( P( 1, 4), P( 1, 8) )
*
      ENDIF
*
      IF( DPHIM .LE. DPHIS ) THEN
        CP = COS( PHIM*DEGRAD )
        SP = SIN( PHIM*DEGRAD )
        P( 1, 1) = PAR(2)*CP
        P( 2, 1) = PAR(2)*SP
        P( 3, 1) = -( PAR( 6)*P( 1, 1) +PAR( 7)*P( 2, 1) )/PAR( 8)
     +   -PAR( 3)
        P( 1, 4) = PAR(1)*CP
        P( 2, 4) = PAR(1)*SP
        P( 3, 4) = -( PAR( 6)*P( 1, 4) +PAR( 7)*P( 2, 4) )/PAR( 8)
     +   -PAR( 3)
        P( 1, 5) = PAR(2)*CP
        P( 2, 5) = PAR(2)*SP
        P( 3, 5) = -( PAR( 9)*P( 1, 5) +PAR( 10)*P( 2, 5) )/PAR( 11)
     +   +PAR( 3)
        P( 1, 8) = PAR(1)*CP
        P( 2, 8) = PAR(1)*SP
        P( 3, 8) = -( PAR( 9)*P( 1, 8) +PAR( 10)*P( 2, 8) )/PAR( 11)
     +   +PAR( 3)
        CALL GDLINE( P( 1, 1), P( 1, 5) )
        CALL GDLINE( P( 1, 4), P( 1, 8) )
*
      ENDIF
      GO TO 9999
C
 7000 CONTINUE
C
C             ELTU
C
      CALL GDELTU(A,B,Z1)
      CALL GDELTU(A,B,Z2)
      P(1,1)=A
      P(2,1)=0.
      P(3,1)=Z1
      P(1,2)=A
      P(2,2)=0.
      P(3,2)=Z2
      P(1,3)=-A
      P(2,3)=0.
      P(3,3)=Z1
      P(1,4)=-A
      P(2,4)=0.
      P(3,4)=Z2
      CALL GDLINE(P(1,1),P(1,2))
      CALL GDLINE(P(1,3),P(1,4))
      GO TO 9999
C                               draw HYPErboloid
 7410 CONTINUE
      PP(2,1) = RMAX2
      PP(2,3) = RMIN2
      P(1,1) = 0.
      P(1,2) = 0.
      P(1,3) = 0.
      P(1,4) = 0.
      PP(3,1) = Z2
      PP(3,3) = Z2
      CALL GDCIRC(RMAX2,Z1)
      CALL GDCIRC(RMIN2,Z1)
      CALL GDCIRC(RMAX2,Z2)
      CALL GDCIRC(RMIN2,Z2)
      NZSTEP = 20
      DELZ = Z2 / NZSTEP
      DO 7440 IZ = 1, NZSTEP
         ZZ = Z2 - IZ*DELZ
         PP(3,2) = ZZ
         PP(3,4) = ZZ
         ZZZ = ZZ*ZZ*TANTHS
         PP(2,2) = SQRT(RMAX12 + ZZZ)
         PP(2,4) = SQRT(RMIN12 + ZZZ)
         DO 7430 ISY = -1, +1, 2
         DO 7430 ISZ = -1, +1, 2
            DO 7420 J = 1, 4
               P(2,J) = ISY * PP(2,J)
               P(3,J) = ISZ * PP(3,J)
 7420       CONTINUE
            CALL GDLINE(P(1,1),P(1,2))
            CALL GDLINE(P(1,3),P(1,4))
 7430    CONTINUE
         PP(2,1) = PP(2,2)
         PP(2,3) = PP(2,4)
         PP(3,1) = PP(3,2)
         PP(3,3) = PP(3,4)
 7440 CONTINUE
C
 9999 END
+DECK,  GDRAWT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:25  cernlib
* Geant

      SUBROUTINE GDRAWT(X,Y,CHTEXT,SIZE,ANGLE,LWIDTH,IOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw text with software characters                       *
C.    *                                                                *
C.    *       In ITXATT (common GCDRAW) there is                       *
C.    *       a bit mask for the text attributes :                     *
C.    *                                                                *
C.    *       Bit  1- 3 = Text line width (LWIDTH)                     *
C.    *       Bit  4- 7 = Text color                                   *
C.    *       Bit  8-11 = Text font                                    *
C.    *       Bit 12-24 = Reserved for future use                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDAHIT, GDARR, GDHEAD,      *
C.    *                   GDPART, GDPRTR, GDSCAL, GDSHOW, GDSPEC       *
C.    *       Authors : P.Zanarini ; S.Giani  *********                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCFLAG.
      CHARACTER*(*) CHTEXT
      CHARACTER*1  CHOPT
      DIMENSION AITXFO(2)
C.
C.    ------------------------------------------------------------------
C.
      CALL IGQ('TXCI',AITXCO)
      CALL IGQ('TXFP',AITXFO)
      ALWIDT=LWIDTH
      NCHAR=LNBLNK(CHTEXT)
      IF (IDVIEW.EQ.0.OR.IDVIEW.EQ.-175) GO TO 40
C
C             Store text on view bank IDVIEW
C
      JV=LQ(JDRAW-IDVIEW)
      ITU=ITU+1
C
   10 IF (ITU.LE.MAXTU) GO TO 20
C
C             Push text unit bank
C
      JV = LQ(JV-3)
      CALL MZPUSH(IXCONS,JV,0,MORTU,'I')
      IF(IEOTRI.NE.0)GO TO 50
      JV=LQ(JDRAW-IDVIEW)
      MAXTU=MAXTU+MORTU
      GO TO 10
C
   20 IF ((ITS+6+NCHAR).LE.MAXTS) GO TO 30
C
C             Push text segment bank
C
      JV = LQ(JV-6)
      CALL MZPUSH(IXCONS,JV,0,MORTS,'I')
      IF(IEOTRI.NE.0)GO TO 50
      JV=LQ(JDRAW-IDVIEW)
      MAXTS=MAXTS+MORTS
      GO TO 20
C
   30 JVTS=LQ(JV-6)+ITS+1
      Q(JVTS)=X
      Q(JVTS+1)=Y
      Q(JVTS+2)=SIZE
      Q(JVTS+3)=ANGLE
C
C             Bit 1- 3 = Text line width (LWIDTH)
C             Bit 4-24 = Text attribute
C
      ISUM=0
      ITXCOL=AITXCO
      CALL MVBITS(ITXCOL,0,4,ITXATT,3)
      IF(AITXFO(1).EQ.-6..AND.AITXFO(2).EQ.0.)THEN
         ITXFON=6
      ELSEIF(AITXFO(1).EQ.-6..AND.AITXFO(2).EQ.1.)THEN
         ITXFON=7
      ENDIF
      CALL MVBITS(ITXFON,0,4,ITXATT,7)
      CALL MVBITS(ITXATT,0,24,ISUM,0)
      CALL MVBITS(LWIDTH,0,3,ISUM,0)
      Q(JVTS+4)=ISUM
C
      Q(JVTS+5)=IOPT
      Q(JVTS+6)=NCHAR
      CALL UCTOH(CHTEXT,IQ(JVTS+7),4,NCHAR)
C
      Q(LQ(JV-3)+ITU)=ITS+1
      ITS=ITS+7+NCHAR
      GO TO 999
C
C             Draw text on screen
C
   40 CONTINUE
      IF (IOPT.EQ.-1) THEN
         CHOPT='L'
         ALFLAG=10.
      ELSE IF (IOPT.EQ.0) THEN
         CHOPT='C'
         ALFLAG=20.
      ELSE IF (IOPT.EQ.1) THEN
         CHOPT='R'
         ALFLAG=30.
      ENDIF
      IF(IDVIEW.EQ.-175)THEN
         ITXCOL=IBITS(ITXATT,3,4)
         AITXCO=ITXCOL
         ITXFON=IBITS(ITXATT,7,4)
         IF(ITXFON.EQ.6)THEN
            ITXFON=-60
         ELSEIF(ITXFON.EQ.7)THEN
            ITXFON=-61
         ENDIF
         AITXFP=ITXFON
         CALL IGSET('TXFP',AITXFP)
      ENDIF
      IF(ALWIDT.GT.1.)ALWIDT=ALWIDT*3.
***      CALL IGTEXT(X,Y,CHTEXT,SIZE,ANGLE,CHOPT)
      CALL IGSET('TXAL',ALFLAG)
      CALL IGSET('TANG',ANGLE)
      CALL IGSET('TXCI',AITXCO)
      CALL IGSET('CHHE',SIZE)
      CALL IGSET('LWID',ALWIDT)
      CALL ITX(X,Y,CHTEXT)
      GO TO 999
C
   50 WRITE (CHMAIL,10000)
      CALL GMAIL(0,0)
C
10000 FORMAT (' ERROR IN GDRAWT: MEMORY OVERFLOW IN PUSHING A BANK')
  999 END
+DECK,  GDRAWV, T=FORT.
* Revision 1.2  1996/09/30 13:37:24  ravndal
* Backward compatibility for view banks
* Revision 1.1.1.1  1995/10/24 10:20:27  cernlib
* Geant

      SUBROUTINE GDRAWV(U,V,NP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       GDRAWV stores sparse segments ( NP = 2 ) in a buffer.    *
C.    *       When the buffer is full it is scanned to collect         *
C.    *       segments into polylines ( NP > 2 ), that will be         *
C.    *       drawn by the GDRAWP routine.                             *
C.    *                                                                *
C.    *       Variables used in the routine :                          *
C.    *                                                                *
C.    *       EPS    = Error range of user coordinates until which     *
C.    *                they are considered as coincident points        *
C.    *                                                                *
C.    *       I0     = Pointer to starting point of polyline (in X,Y)  *
C.    *       I1     = Pointer to starting point of segment (in X,Y)   *
C.    *       I2     = Pointer to ending point of segment (in X,Y)     *
C.    *       INEW   = Number of points of polyline (in XNEW,YNEW)     *
C.    *                                                                *
C.    *       NSEG   = Current number of segments                      *
C.    *       MAXSEG = Max number of segments                          *
C.    *       MAXNEW = Max length of polyline                          *
C.    *                                                                *
C.    *       X      = Vector of x-coordinates of input segments       *
C.    *       Y      = Vector of y-coordinates of input segments       *
C.    *       IEMPTY = Vector to flag empty points; if IEMPTY(I)=1     *
C.    *                then X(I),Y(I) has been already linked          *
C.    *                                                                *
C.    *                (X,Y,IEMPTY are dimensioned to MAXSEG*2)        *
C.    *                                                                *
C.    *       IATTL  = Vector of attributes of input segments,         *
C.    *                dimensioned to MAXSEG                           *
C.    *                                                                *
C.    *       XNEW   = Vector of x-coordinates of output polyline      *
C.    *       YNEW   = Vector of y-coordinates of output polyline      *
C.    *                                                                *
C.    *                (XNEW,YNEW are dimensioned to MAXNEW)           *
C.    *                                                                *
C.    *       LUDEB  = If < 0 then no debug printout will be done      *
C.    *                                                                *
C.    *       ISTF   = Flag for statistics printout;                   *
C.    *                if ISTF=1 a statistics of polylines length      *
C.    *                will be done (to be printed interactively)      *
C.    *                                                                *
C.    *       LINBUF = Flag to determine if GDRAWV has to perform      *
C.    *                line buffering logic (LINBUF=1) or not          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDAHIT, GDARC, GDARR,       *
C.    *                   GDCIRC, GDCIRR, GDCIRY, GDCUT, GDHEAD,       *
C.    *                   GDLINE, GDMAN, GDPRTR, GDRAW, GDRECT,        *
C.    *                   GDSCAL, GDSHOW, GDSURF, GDTREE               *
C.    *       Author : P.Zanarini   S.Giani 1992  *********            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCSPEE.
      CHARACTER*80 ILINE
      DIMENSION U(*),V(*)
      DIMENSION X(160),Y(160),IEMPTY(160)
      DIMENSION IATTL(80)
      DIMENSION XNEW(45),YNEW(45)
      DIMENSION IDBIST(2,20),IDBERR(10)
      SAVE X,Y,IEMPTY,IATTL,IDBIST,IDBERR,XNEW,YNEW
      SAVE MAXSEG,MAXNEW,EPS,LUDEB,ISTF,NSEG,INEW
      DATA MAXSEG/80/
      DATA MAXNEW/45/
      DATA EPS/0.00001/
      DATA LUDEB/-1/
      DATA ISTF/0/
      DATA IDBERR,IDBIST/50*0/
C.
C.    ------------------------------------------------------------------
C.
      IF (NP.EQ.-1) THEN
C
C             Initialize (open) the line buffer
C
         LINBUF=1
         NSEG=0
         INEW=0
         GO TO 999
C
      ELSE IF (NP.EQ.0) THEN
C
C             Empties (close) the line buffer
C
         LINBUF=0
         GO TO 10
C
      ELSE IF (NP.GT.2) THEN
C
C             Call directly GDRAWP
C
         CALL GDRAWP(U,V,NP)
         GO TO 999
C
C
      ELSE IF (LINBUF.EQ.0) THEN
C
C             Call directly GDRAWP
C
         CALL GDRAWP(U,V,NP)
         GO TO 999
C
      ENDIF
C
      LTY=IBITS(LINATT,10,3)
      CALL UCTOH('ON  ',IFLH,4,4)
      IF(LTY.NE.6.AND.IHIDEN.EQ.IFLH)THEN
         CALL GDRAWP(U,V,NP)
         GO TO 999
      ENDIF
C             Fill the line buffer
C
      NSEG=NSEG+1
      IATTL(NSEG)=LINATT
C
      NPOINT=NSEG*2
      X(NPOINT-1)=U(1)
      Y(NPOINT-1)=V(1)
      X(NPOINT)=U(2)
      Y(NPOINT)=V(2)
C
      IF (NSEG.NE.MAXSEG) GO TO 999
C
C             Line buffer full : check for joined lines
C
C             Initialisation phase
C
   10 CONTINUE
C
      I0=1
      INEW=0
      NPOINT=NSEG*2
C
      DO 20 I=1,NPOINT
         IEMPTY(I)=0
   20 CONTINUE
C
C             Loop phase
C
   30 CONTINUE
C
      NPOINT=NSEG*2
C
      DO 40 K=I0,NPOINT
         IF (IEMPTY(K).EQ.0) GO TO 50
   40 CONTINUE
C
C             Buffer empty
C
      NSEG=0
      GO TO 999
C
   50 CONTINUE
C
      KDIV2=(K+1)/2
      IF (INEW.EQ.0) LINATT=IATTL(KDIV2)
C
      I1=K
      INEW=INEW+1
      XNEW(INEW)=X(I1)
      YNEW(INEW)=Y(I1)
      IEMPTY(I1)=1
      I0=I1
C
   60 CONTINUE
C
      IF ((I1/2)*2.EQ.I1) THEN
         I2=I1-1
      ELSE
         I2=I1+1
      ENDIF
C
      I2DIV2=(I2+1)/2
      IF (INEW.EQ.0) LINATT=IATTL(I2DIV2)
C
      INEW=INEW+1
      XNEW(INEW)=X(I2)
      YNEW(INEW)=Y(I2)
      IEMPTY(I2)=1
C
      IF (INEW.EQ.MAXNEW) THEN
         IF (LUDEB.GE.0) THEN
            WRITE (CHMAIL,10000) NAMES(NLEVEL),INEW
            CALL GMAIL(0,0)
         ENDIF
         IDBERR(1)=IDBERR(1)+1
         GO TO 70
      ENDIF
C
C             Link is closed ?
C
      IF ((X(I2).LT.X(I0)-EPS).OR.(X(I2).GT.X(I0)+EPS)) GO TO 140
      IF ((Y(I2).LT.Y(I0)-EPS).OR.(Y(I2).GT.Y(I0)+EPS)) GO TO 140
C
C             Link closed
C
   70 CONTINUE
C
      IF (INEW.GT.3) THEN
         CALL GDRAWP(XNEW,YNEW,INEW)
      ELSE
         IF (INEW.EQ.3) CALL GDRAWP(XNEW,YNEW,INEW)
         IF (LUDEB.GE.0) THEN
            WRITE (CHMAIL,10100) NAMES(NLEVEL),INEW
            CALL GMAIL(0,0)
         ENDIF
         IDBERR(2)=IDBERR(2)+1
      ENDIF
C
   80 CONTINUE
C
C             Do some statistics if in statistics mode
C
      IF (ISTF.EQ.1) THEN
         IF (INEW.LE.3) GO TO 120
         LENPOL=INEW-1
   90    CONTINUE
         DO 100 I=1,20
            IF (LENPOL.EQ.IDBIST(1,I)) THEN
               IDBIST(2,I)=IDBIST(2,I)+1
               GO TO 120
            ENDIF
  100    CONTINUE
         DO 110 I=1,20
            IF (IDBIST(1,I).EQ.0) THEN
               IDBIST(1,I)=LENPOL
               GO TO 90
            ENDIF
  110    CONTINUE
         WRITE (CHMAIL,10800) LENPOL
         CALL GMAIL(0,0)
  120    CONTINUE
      ENDIF
C
      IF (LUDEB.LT.0) GO TO 130
C
C             Do some printout if in debugging mode
C
      LENPOL=INEW-1
      WRITE (CHMAIL,10400) NAMES(NLEVEL),LENPOL
      CALL GMAIL(0,0)
      IC0=I0/2
      IF ((I0/2)*2.NE.I0) IC0=IC0+1
      IC1=I1/2
      IF ((I1/2)*2.NE.I1) IC1=IC1+1
      ILINE=' '
      ILINE(IC1:IC1)='1'
      ILINE(IC0:IC0)='0'
      WRITE (CHMAIL,10500) I0,I1,I2,INEW,NSEG
      CALL GMAIL(1,0)
      WRITE (CHMAIL,10600) ILINE(1:NSEG)
      CALL GMAIL(0,0)
      NPOINT=NSEG*2
      NPOIN1=NPOINT-1
      WRITE (CHMAIL,10700) (IEMPTY(JJ),JJ=1,NPOIN1,2)
      CALL GMAIL(0,0)
      WRITE (CHMAIL,10700) (IEMPTY(JJ),JJ=2,NPOINT,2)
      CALL GMAIL(0,0)
C
  130 CONTINUE
      INEW=0
      GO TO 30
C
  140 CONTINUE
C
      NPOINT=NSEG*2
C
C             Compute starting point of next segment
C
      NEXT=0
C
      DO 150 K=I0,NPOINT
         IF (K.EQ.I2) GO TO 150
         IF ((X(I2).LT.X(K)-EPS).OR.(X(I2).GT.X(K)+EPS)) GO TO 150
         IF ((Y(I2).LT.Y(K)-EPS).OR.(Y(I2).GT.Y(K)+EPS)) GO TO 150
         NEXT=K
         GO TO 160
  150 CONTINUE
C
  160 CONTINUE
C
      IF (NEXT.NE.0) THEN
         I1=NEXT
         IEMPTY(I1)=1
         GO TO 60
      ENDIF
C
      IF (I0.EQ.1) THEN
         CALL GDRAWP(XNEW,YNEW,INEW)
         IF (LUDEB.GE.0) THEN
            WRITE (CHMAIL,10200) NAMES(NLEVEL),INEW
            CALL GMAIL(0,0)
         ENDIF
         IDBERR(3)=IDBERR(3)+1
         GO TO 80
      ENDIF
C
C             Reset flag : next call to GDRAWV will re-process
C             the points now forming an open polyline, trying then
C             (with the new points stored) to form a closed polyline
C
      DO 170 I=I0,NPOINT
         IEMPTY(I)=0
  170 CONTINUE
C
      NSEGOL=NSEG
C
C             Try to see if the buffers can be shifted
C
  180 CONTINUE
C
      DO 190 NLIN=1,NSEG
         IF (IEMPTY(NLIN*2).EQ.0) GO TO 210
  190 CONTINUE
C
      IF (NSEG.NE.NSEGOL) THEN
C
C             The buffers have been shifted enough
C
         GO TO 230
C
      ELSE
C
C             The buffers cannot be shifted at all
C
         IF (LUDEB.GE.0) THEN
            WRITE (CHMAIL,10300) NAMES(NLEVEL)
            CALL GMAIL(0,0)
         ENDIF
         IDBERR(4)=IDBERR(4)+1
         LINATT=IATTL(1)
         DO 200 I=1,NSEG
            J=I*2-1
            CALL GDRAWP(X(J),Y(J),2)
  200    CONTINUE
         INEW=0
         GO TO 30
C
      ENDIF
C
  210 CONTINUE
C
C             Shift the buffers
C
      IF (NLIN.EQ.1) GO TO 230
      NSEG=NSEG-NLIN+1
      N=NSEG*2
      J=NLIN*2-2
      DO 220 I=1,N
         X(I) = X(J+I)
         Y(I) = Y(J+I)
         IEMPTY(I) = IEMPTY(J+I)
  220 CONTINUE
      CALL UCOPY(IATTL(NLIN),IATTL(1),NSEG)
C
      IF (NSEG.GT.0) GO TO 180
C
      GO TO 999
C
  230 CONTINUE
C
C             If last call to GDRAWV (NP=0, i.e. close the buffer)
C             and some lines have still to be processed (NSEG>0)
C             then don't RETURN but re-execute the body of GDRAWV
C
      IF (NP.EQ.0.AND.NSEG.GT.0) GO TO 10
C
10000 FORMAT (' *** GDRAWV: ERROR 1 -  NAME = ',A4,' INEW = ',I3)
10100 FORMAT (' *** GDRAWV: ERROR 2 -  NAME = ',A4,' INEW = ',I3)
10200 FORMAT (' *** GDRAWV: ERROR 3 -  NAME = ',A4,' INEW = ',I3)
10300 FORMAT (' *** GDRAWV: ERROR 4 -  NAME = ',A4)
10400 FORMAT (' *** GDRAWV: GDRAWP called for ',A4,' (',I2,' segments)')
10500 FORMAT (' LOOP : I0=',I3,' - I1=',I3,' - I2=',I3,
     +        ' - INEW=',I3,' - NSEG=',I3)
10600 FORMAT (1X,A)
10700 FORMAT (1X,80I1)
10800 FORMAT (' *** STATISTICS OVERFLOW ***   LENPOL =',I3)
  999 END
+DECK,  GDRAWX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:27  cernlib
* Geant

      SUBROUTINE GDRAWX(NAME,CUTTHE,CUTPHI,CUTVAL,THE,PHI,U0,V0,SU,SV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw extended cut : this routine is similar to GDRAWC    *
C.    *       but any cut plane can be choosen, instead of just        *
C.    *       the three planes normal to the main axes.                *
C.    *                                                                *
C.    *       The cut plane is normal to the line given by             *
C.    *       the two cut angles CUTTHE,CUTPHI                         *
C.    *       and it is placed at the distance CUTVAL from the origin. *
C.    *                                                                *
C.    *       The resulting picture is seen from the angles THE,PHI    *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
      CHARACTER*4 NAME
C.
C.    ------------------------------------------------------------------
C.
C             Allocate working space
C
      CALL GWORK(NWCUT)
C
      IF (CUTTHE.EQ.90.AND.CUTPHI.EQ.180) THEN
         ICUT=1
      ELSE IF (CUTTHE.EQ.90.AND.CUTPHI.EQ.0) THEN
         ICUT=1
      ELSE IF (CUTTHE.EQ.90.AND.CUTPHI.EQ.90) THEN
         ICUT=2
      ELSE IF (CUTTHE.EQ.0.AND.CUTPHI.EQ.0) THEN
         ICUT=3
      ELSE
         ICUT=0
      ENDIF
C
      DCUT=CUTVAL
      CTHETA=CUTTHE
      CPHI=CUTPHI
C
      NSURF=0
      ISURF=1
C
C             ICUTFL=1 informs GDRAW to call GDRWSC instead of GDRAWS
C             (so that we'll have stored surfaces instead of drawn lines
C             and to use the line buffer logic of GDRAWV
C
C             PSI is fixed to 0.
C
      ICUTFL=1
      CALL GDRAW(NAME,THE,PHI,0.,U0,V0,SU,SV)
      ICUTFL=0
      END
+DECK,  GDRAYT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GDRAYT(NAME,UTHET,UPHI,UPSI,UU0,UV0,SU,SV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       RAY-TRACING                                              *
C.    *       This routine draws the objects, in the Jvolum data       *
C.    *       data structure, that are visible. The objects are drawn  *
C.    *       at the screen point (UU0,UV0), with the                  *
C.    *       screen factors SU and SV acting on the U and V           *
C.    *       dimensions respectively;                                 *
C.    *       the object is rotated by an angle UTHET along Y-axis     *
C.    *       and UPHI along Z-axis and the resulting 2-D picture      *
C.    *       is also rotated by an angle UPSI along the line of       *
C.    *       projection (i.e. the normal to the 2-D view plane).      *
C.    *                                                                *
C.    *       Author:  S.Giani.                                        *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCDRAW.
+CDE, GCONST.
+CDE, GCMUTR.
********************************************************************************
+CDE, GCFLAG.
+CDE, GCSTAK.
+CDE, GCRAYT.
+CDE, GCPIXE.
      COMMON/INIFIR/NFIRST
********************************************************************************
*
      CHARACTER*4 NAME

      DIMENSION V(3),T(4,3)
      SAVE IFIRST
      DATA IFIRST/0/
*
      CALL UCTOH('PERS',IPERS,4,4)
*
         IF(NFIRST.EQ.0) THEN
            CALL GDCOTA
            NFIRST = 1
         ENDIF
C
      IF (IFIRST.NE.0) GO TO 40
C
      IFIRST=1
      DPHI=PI/20.
      PHI=0.
C
      DO 30 I=1,40
         GSIN(I)=SIN(PHI)
         GCOS(I)=COS(PHI)
         PHI=PHI+DPHI
   30 CONTINUE
C
      GSIN(41)=GSIN(1)
      GCOS(41)=GCOS(1)
C
   40 CONTINUE
C
C             Theta, phi and psi angles are normalized in [0-360[ range
C

      GTHETA=MOD(ABS(UTHET),360.)
      GPHI=MOD(ABS(UPHI),360.)
      GPSI=MOD(ABS(UPSI),360.)
      IMOD=0
*
*              Set Transformation Matrix T as for CG Package
*
         V(1)=GTHETA
         V(2)=GPHI
         V(3)=GPSI
         CALL GDCGVW(V,T)
********************************************************************************
            CALL ISFACI(1)
            CALL ISFAIS(1)
            if(iswit(9).ne.67890)CALL IGBOX(0.,20.,20.,0.)
                           DO 101 IHH=1,3
                              DO 102 JHH=1,4
                                 AROTS(IHH,JHH)=T(JHH,IHH)
  102                         CONTINUE
  101                      CONTINUE
                           AROTS(4,1)=0.
                           AROTS(4,2)=0.
                           AROTS(4,3)=0.
                           AROTS(4,4)=1.
                           DO 105 IHH=1,4
                              DO 106 JHH=1,4
                                 ZROTS(IHH,JHH)=AROTS(IHH,JHH)
  106                         CONTINUE
  105                      CONTINUE
                           CALL RINV(4,ZROTS,4,RRR,IFAIL)
         IFLAPE=0
         IF(IPERS.EQ.IPRJ)THEN
           IFLAPE=1
           IF(DPERS.GT.5000.)DPERS=5000.
           FZUV=8.4+DPERS
                                 FPINTX=ZROTS(1,4)+ZROTS(1,1)*
     +                           10.+ZROTS(1,2)*10.+ZROTS(1,3)*
     +                           FZUV
                                 FPINTY=ZROTS(2,4)+ZROTS(2,1)*
     +                           10.+ZROTS(2,2)*10.+ZROTS(2,3)*
     +                           FZUV
                                 FPINTZ=ZROTS(3,4)+ZROTS(3,1)*
     +                           10.+ZROTS(3,2)*10.+ZROTS(3,3)*
     +                           FZUV
         ENDIF
         ISFILL=0
         CALL GFIND('*','FILL',ISFILL)
         IF(ISFILL.EQ.0)ISFILL=10
*         CALL ISMKSC(0.)
         CALL ISMK(1)
         IMAP=0
         IF(NMAP.GT.4)NMAP=4
         IF(NMAP.GT.0)THEN
          NNIM=2
         ELSE
          NNIM=1
         ENDIF
        DO 211 IM=1,NNIM
         IF(NMAP.GT.0)IMAP=IMAP+1
         IF(IMAP.EQ.1)THEN
           IF(ISFILL.LT.NMAP)ISFILL=NMAP
           ISSAVE=ISFILL
           IOSAVE=IOMBRA
           ISFILL=NMAP
           IOMBRA=0
         ELSEIF(IMAP.EQ.2)THEN
           ZNMAP1=1./NMAP
           ISFILL=ISSAVE
           IOMBRA=IOSAVE
         ENDIF
         UUU=1./ISFILL
         VVV=1./ISFILL
         IXXX=1
         IYYY=1
         IF(IPERS.EQ.IPRJ)THEN
           ZUV=DPERS
         ELSE
           ZUV=5000.
         ENDIF
         LIMPRE=20*ISFILL
*
                                 XPINTS=ZROTS(1,4)+ZROTS(1,1)*
     +                           UUU+ZROTS(1,2)*VVV+ZROTS(1,3)*
     +                           ZUV
                                 YPINTS=ZROTS(2,4)+ZROTS(2,1)*
     +                           UUU+ZROTS(2,2)*VVV+ZROTS(2,3)*
     +                           ZUV
                                 ZPINTS=ZROTS(3,4)+ZROTS(3,1)*
     +                           UUU+ZROTS(3,2)*VVV+ZROTS(3,3)*
     +                           ZUV
*            print *,xpints,ypints,zpints,'vertex from gdraw'
            ISSEEN=0
            CALL GTRIGC
*            IEVENT=IEVENT+1
            CALL GTRIGI
            CALL GTRIG
 211    CONTINUE
*
********************************************************************************
*
 999      END
+DECK,  GDRECT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:27  cernlib
* Geant

      SUBROUTINE GDRECT(P1,P2,P3,P4)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a rectangle of points P1,P2,P3,P4                   *
C.    *                                                                *
C.    *    ==>Called by : GDRAWS                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
CM
+CDE, GCDRAW.
CM
      DIMENSION P1(3),P2(3),P3(3),P4(3),U(5),V(5),X(3,4)
      DIMENSION Q1(3),Q2(3),Q3(3),Q4(3)
      EQUIVALENCE (Q1(1),X(1,1)),(Q2(1),X(1,2))
      EQUIVALENCE (Q3(1),X(1,3)),(Q4(1),X(1,4))
C.
C.    ------------------------------------------------------------------
C.
      DO 10 I=1,3
         Q1(I)=P1(I)
         Q2(I)=P2(I)
         Q3(I)=P3(I)
         Q4(I)=P4(I)
   10 CONTINUE
C
      CALL GDFR3D(X,4,U,V)
C
CM             Short circuit in case of GMR
C
      IF ( IGMR .NE. 0 ) GO TO 999
CM
      U(5)=U(1)
      V(5)=V(1)
      CALL GDRAWV(U,V,5)
C
  999 RETURN
      END
+DECK,  GDRVOL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:27  cernlib
* Geant

      SUBROUTINE GDRVOL(N,NNAME,NNUMB,NRS,UTHET,UPHI,UPSI,UU0,UV0,SU,SV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draws the object NNAME(N),NNUMB(N) with its contents.    *
C.    *       The parameters UTHET,UPHI,...,SV are the same of GDRAW.  *
C.    *       NNAME(1),...,NNAME(N) contain the volume names and       *
C.    *       NNUMB(1),...,NNUMB(N) the volume numbers defining the    *
C.    *       path to go from the top volume to the one to be drawn.   *
C.    *                                                                *
C.    *       This routine differs from GDRAW in the following :       *
C.    *       - the object to be drawn is identified by a full path,   *
C.    *         giving so the possibility to draw a particular copy    *
C.    *         or division of a volume, or even a volume that has     *
C.    *         more than one mother in the geometry tree              *
C.    *       - the object can be drawn either with respect to the     *
C.    *         MAster Reference System (NRS=0) or with respect to its *
C.    *         Daugther Reference System; in the first case it is     *
C.    *         drawn where it stands in the real world, while in      *
C.    *         the second one it is drawn like GDRAW would do         *
C.    *       - in this latter case, track and hit points will be      *
C.    *         drawn with respect to the DRS of the volume last       *
C.    *         drawn by this routine, and not with respect to the     *
C.    *         MARS as it done normally; to reset to the normal       *
C.    *         case a call with NRS=0 or N=0 is required              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini    **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVOLU.
+CDE, GCDRAW.
      DIMENSION NNAME(15),NNUMB(15),GR0(10),GT0(3)
      CHARACTER*4 NAME
      SAVE GR0,GT0
C
      DATA GR0/1.,0.,0.,0.,1.,0.,0.,0.,1.,0./
      DATA GT0/0.,0.,0./
C.
C.    ------------------------------------------------------------------
C.
      IF (N.EQ.0) THEN
C
C             Restore unitary transformation in /GCDRAW/
C
         DO 10 I=1,3
   10    GTRAN0(I)=GT0(I)
         DO 20 I=1,10
   20    GRMAT0(I)=GR0(I)
         GO TO 999
C
      ENDIF
C
      IF (N.GT.15.OR.N.LT.1) GO TO 999
C
C             Save /GCVOLU/ if necessary
C
      IFCVOL=0
      IF (NLEVEL.GT.0) THEN
         CALL GSCVOL
         IFCVOL=1
      ENDIF
C
C             Force GLVOLU to recompute the path
C
      NLEVEL=0
      CALL GLVOLU(N,NNAME,NNUMB,IER)
      IF (IER.NE.0) GO TO 90
C
      IF (NRS.EQ.0) THEN
C
C             Store unitary transformation in /GCDRAW/
C
         DO 30 I=1,3
   30    GTRAN0(I)=GT0(I)
         DO 40 I=1,10
   40    GRMAT0(I)=GR0(I)
C
      ELSE
C
C             Store N-th level transformation in /GCDRAW/
C
         DO 50 I=1,3
   50    GTRAN0(I)=GTRAN(I,N)
         DO 60 I=1,10
   60    GRMAT0(I)=GRMAT(I,N)
C
C             Replace N-th level transformation with the unitary one
C
         DO 70 I=1,3
   70    GTRAN(I,N)=GT0(I)
         DO 80 I=1,10
   80    GRMAT(I,N)=GR0(I)
C
      ENDIF
C
C             NLEVEL < 0 to inform GDRAW that GSCVOL has already been ca
C
      IF (IFCVOL.EQ.1) NLEVEL=-NLEVEL
C
      IDRNUM=1
      CALL UHTOC(NNAME(N),4,NAME,4)
      CALL GDRAW(NAME,UTHET,UPHI,UPSI,UU0,UV0,SU,SV)
      IDRNUM=0
C
   90 CONTINUE
      IF (IFCVOL.EQ.1) THEN
         CALL GFCVOL
      ELSE
         NLEVEL=0
      ENDIF
  999 RETURN
      END
+DECK,  GDRWSC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:27  cernlib
* Geant

      SUBROUTINE GDRWSC(ISHAPE,PAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the shape number ISHAPE, of parameters PAR,         *
C.    *       in cut-mode.                                             *
C.    *                                                                *
C.    *    ==>Called by : GDRAW                                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *       Modification log.                                        *
C.    *       31-May-88 A.C.McPherson - Introduce cut tube shape.      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCONSP.
+CDE, GCSHNO.
      PARAMETER ( NLPC = 40 )
*
*            The constant NLPC defined in the parameter statement
*            is the number of line elements to form a complete
*            circle in the surface definitions for a cut tube.
*
      DIMENSION PAR(50),P(3,8)
      DIMENSION XMAX1(2,42),XMIN1(2,42),XMAX2(2,42),XMIN2(2,42)
C.
C.    ------------------------------------------------------------------
C.
      IF (ISHAPE.NE.1) GO TO 200
C
C             BOX
C
      DX1=PAR(1)
      DY1=PAR(2)
      DX2=DX1
      DY2=DY1
      DZ=PAR(3)
      GO TO 1000
C
  200 IF (ISHAPE.NE.2) GO TO 300
C
C             TRD1
C
      DX1=PAR(1)
      DX2=PAR(2)
      DY1=PAR(3)
      DY2=DY1
      DZ=PAR(4)
      GO TO 1000
C
  300 IF (ISHAPE.NE.3) GO TO 400
C
C             TRD2
C
      DX1=PAR(1)
      DX2=PAR(2)
      DY1=PAR(3)
      DY2=PAR(4)
      DZ=PAR(5)
      GO TO 1000
C
  400 IF (ISHAPE.NE.4) GO TO 500
C
C             TRAP
C
      DZ=PAR(1)
      TX=PAR(2)
      TY=PAR(3)
      H1=PAR(4)
      BL1=PAR(5)
      TL1=PAR(6)
      TTH1=PAR(7)
      H2=PAR(8)
      BL2=PAR(9)
      TL2=PAR(10)
      TTH2=PAR(11)
      GO TO 1500
C
  500 IF (ISHAPE.NE.5) GO TO 600
C
C             TUBE
C
      RMIN1=PAR(1)
      RMAX1=PAR(2)
      RMIN2=RMIN1
      RMAX2=RMAX1
      Z2=PAR(3)
      Z1=-Z2
      GO TO 2000
C
  600 IF (ISHAPE.NE.6) GO TO 700
C
C             TUBS
C
      RMIN1=PAR(1)
      RMAX1=PAR(2)
      RMIN2=RMIN1
      RMAX2=RMAX1
      Z2=PAR(3)
      Z1=-Z2
      PHIMIN=PAR(4)
      PHIMAX=PAR(5)
      GO TO 2500
C
  700 IF (ISHAPE.NE.7) GO TO 800
C
C             CONE
C
      RMIN1=PAR(2)
      RMAX1=PAR(3)
      RMIN2=PAR(4)
      RMAX2=PAR(5)
      Z2=PAR(1)
      Z1=-Z2
      GO TO 2000
C
  800 IF (ISHAPE.NE.8) GO TO 900
C
C             CONS
C
      RMIN1=PAR(2)
      RMAX1=PAR(3)
      RMIN2=PAR(4)
      RMAX2=PAR(5)
      Z2=PAR(1)
      Z1=-Z2
      PHIMIN=PAR(6)
      PHIMAX=PAR(7)
      GO TO 2500
C
  900 IF (ISHAPE.NE.9) GO TO 910
C
C             SPHE
C
      RMIN=PAR(1)
      RMAX=PAR(2)
      GO TO 3000
C
  910 IF (ISHAPE.NE.10) GO TO 911
C
C             PARA
C
      DX=PAR(1)
      DY=PAR(2)
      DZ=PAR(3)
      TXY=PAR(4)
      TXZ=PAR(5)
      TYZ=PAR(6)
C
      TX=TXZ
      TY=TYZ
      H1=DY
      BL1=DX
      TL1=DX
      TTH1=TXY
      H2=DY
      BL2=DX
      TL2=DX
      TTH2=TXY
      GO TO 1500
C
  911 IF (ISHAPE.NE.11) GO TO 912
C
C             PGON
C
      PHIMIN=PAR(1)
      PHIMAX=PHIMIN+PAR(2)
      NDIV=PAR(3)
      NZ=PAR(4)
      DPHI=(PHIMAX-PHIMIN)/NDIV
C
C             Z(1)=PAR(5) - RMIN(1)=PAR(6) - RMAX(1)=PAR(7) - Z(2)=PAR(8) - ...
C
      GO TO 4000
C
  912 IF (ISHAPE.NE.12) GO TO 950
C
C             PCON
C
      PHIMIN=PAR(1)
      PHIMAX=PHIMIN+PAR(2)
      NZ=PAR(3)
C
C             Z(1)=PAR(4) - RMIN(1)=PAR(5) - RMAX(1)=PAR(6) - Z(2)=PAR(7) - ...
C
      GO TO 5000
C
  950 CONTINUE
C
      IF (ISHAPE.NE.13) GO TO 951
C
C             ELTU
C
      A=PAR(1)
      B=PAR(2)
      Z2=PAR(3)
      Z1=-Z2
      GO TO 7000
  951 CONTINUE
C
      IF (ISHAPE.NE.14) GO TO 955
C
C             HYPErboloid
C
      RMIN1 = PAR(1)
      RMAX1 = PAR(2)
      Z2=PAR(3)
      TANTHS = (TAN(PAR(4)*DEGRAD))**2
      RMIN12 = RMIN1*RMIN1
      RMAX12 = RMAX1*RMAX1
      RMIN2 = SQRT(RMIN12 + Z2*Z2*TANTHS)
      RMAX2 = SQRT(RMAX12 + Z2*Z2*TANTHS)
      Z1=-Z2
      GO TO 7350

  955 CONTINUE
      IF(ISHAPE.NE.28) GO TO 980
C
C             General twisted trapezoid.
C
      DO 970 IL=1,4
      I0=IL*4+11
      P(3,IL)=-PAR(1)
      P(1,IL)=PAR(I0)+PAR(I0+2)*P(3,IL)
      P(2,IL)=PAR(I0+1)+PAR(I0+3)*P(3,IL)
      P(3,IL+4)=PAR(1)
      P(1,IL+4)=PAR(I0)+PAR(I0+2)*P(3,IL+4)
      P(2,IL+4)=PAR(I0+1)+PAR(I0+3)*P(3,IL+4)
  970 CONTINUE
C
      GO TO 1600
*
  980 CONTINUE
      IF( ISHAPE .EQ. NSCTUB ) THEN
*
        DPHIS = PAR(5)-PAR(4)
        IF( DPHIS .LE. 0.0 ) DPHIS=DPHIS+TWOPI
        NL = DPHIS*NLPC/360.0
        DPHI = 360.0/NLPC
        PHIS = PAR(4)
        IF( PAR(4) .EQ. 0.0 .AND. PAR(5) .EQ. 360.0 ) THEN
          ISEG = 0
        ELSE
          ISEG = 1
          DPHI = DPHIS/NL
        ENDIF
*
        GO TO 6000
*
      ELSE
        GO TO 9999
      ENDIF
C
 1000 CONTINUE
C
C             Rectilinear shapes: BOX,TRD1,TRD2
C
      X1=0.
      Y1=0.
      X2=0.
      Y2=0.
      Z1=-DZ
      Z2=DZ
C
C             Calculate the 8 vertex for rectilinear shapes
C
      P(1,1)=X1+DX1
      P(2,1)=Y1+DY1
      P(3,1)=Z1
      P(1,2)=X1-DX1
      P(2,2)=Y1+DY1
      P(3,2)=Z1
      P(1,3)=X1-DX1
      P(2,3)=Y1-DY1
      P(3,3)=Z1
      P(1,4)=X1+DX1
      P(2,4)=Y1-DY1
      P(3,4)=Z1
      P(1,5)=X2+DX2
      P(2,5)=Y2+DY2
      P(3,5)=Z2
      P(1,6)=X2-DX2
      P(2,6)=Y2+DY2
      P(3,6)=Z2
      P(1,7)=X2-DX2
      P(2,7)=Y2-DY2
      P(3,7)=Z2
      P(1,8)=X2+DX2
      P(2,8)=Y2-DY2
      P(3,8)=Z2
C
 1600 CONTINUE
C
C             Store all the surfaces (back,front,top,bottom,right,left)
C
      CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,4))
      CALL GDSSUR(P(1,5),P(1,6),P(1,7),P(1,8))
      CALL GDSSUR(P(1,5),P(1,1),P(1,2),P(1,6))
      CALL GDSSUR(P(1,8),P(1,4),P(1,3),P(1,7))
      CALL GDSSUR(P(1,5),P(1,1),P(1,4),P(1,8))
      CALL GDSSUR(P(1,6),P(1,2),P(1,3),P(1,7))
C
C             Intersect cut-plane with all the surfaces of the shape
C             and draw the resulting lines
C
      CALL GDCUT
C
      GO TO 9999
C
 1500 CONTINUE
C
C             TRAP or PARA
C
C             Calculate the 8 vertex
C
      P(1,1)=-DZ*TX+TTH1*H1+TL1
      P(2,1)=+H1-DZ*TY
      P(3,1)=-DZ
      P(1,2)=-DZ*TX+TTH1*H1-TL1
      P(2,2)=+H1-DZ*TY
      P(3,2)=-DZ
      P(1,3)=-DZ*TX-TTH1*H1-BL1
      P(2,3)=-H1-DZ*TY
      P(3,3)=-DZ
      P(1,4)=-DZ*TX-TTH1*H1+BL1
      P(2,4)=-H1-DZ*TY
      P(3,4)=-DZ
      P(1,5)=+DZ*TX+TTH2*H2+TL2
      P(2,5)=+H2+DZ*TY
      P(3,5)=+DZ
      P(1,6)=+DZ*TX+TTH2*H2-TL2
      P(2,6)=+H2+DZ*TY
      P(3,6)=+DZ
      P(1,7)=+DZ*TX-TTH2*H2-BL2
      P(2,7)=-H2+DZ*TY
      P(3,7)=+DZ
      P(1,8)=+DZ*TX-TTH2*H2+BL2
      P(2,8)=-H2+DZ*TY
      P(3,8)=+DZ
C
C             Store all the surfaces (back,front,top,bottom,right,left)
C
      CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,4))
      CALL GDSSUR(P(1,5),P(1,6),P(1,7),P(1,8))
      CALL GDSSUR(P(1,5),P(1,1),P(1,2),P(1,6))
      CALL GDSSUR(P(1,8),P(1,4),P(1,3),P(1,7))
      CALL GDSSUR(P(1,5),P(1,1),P(1,4),P(1,8))
      CALL GDSSUR(P(1,6),P(1,2),P(1,3),P(1,7))
C
C             Intersect cut-plane with all the surfaces of the shape
C             and draw the resulting lines
C
      CALL GDCUT
C
      GO TO 9999
C
 2000 CONTINUE
C
C             Cylindric shapes: TUBE,CONE
C
      DO 2100 I=1,40
C
        P(1,1)=RMAX1*GCOS(I)
        P(2,1)=RMAX1*GSIN(I)
        P(3,1)=Z1
        P(1,2)=RMAX1*GCOS(I+1)
        P(2,2)=RMAX1*GSIN(I+1)
        P(3,2)=Z1
        P(1,3)=RMIN1*GCOS(I+1)
        P(2,3)=RMIN1*GSIN(I+1)
        P(3,3)=Z1
        P(1,4)=RMIN1*GCOS(I)
        P(2,4)=RMIN1*GSIN(I)
        P(3,4)=Z1
        P(1,5)=RMAX2*GCOS(I)
        P(2,5)=RMAX2*GSIN(I)
        P(3,5)=Z2
        P(1,6)=RMAX2*GCOS(I+1)
        P(2,6)=RMAX2*GSIN(I+1)
        P(3,6)=Z2
        P(1,7)=RMIN2*GCOS(I+1)
        P(2,7)=RMIN2*GSIN(I+1)
        P(3,7)=Z2
        P(1,8)=RMIN2*GCOS(I)
        P(2,8)=RMIN2*GSIN(I)
        P(3,8)=Z2
C
C             Store top,bottom,back,front surfaces
C
        CALL GDSSUR(P(1,1),P(1,2),P(1,6),P(1,5))
        CALL GDSSUR(P(1,4),P(1,3),P(1,7),P(1,8))
        CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,4))
        CALL GDSSUR(P(1,5),P(1,6),P(1,7),P(1,8))
C
 2100 CONTINUE
C
C             Intersect cut-plane with all the surfaces of the shape
C             and draw the resulting lines
C
      CALL GDCUT
C
      GO TO 9999
C
 2500 CONTINUE
C
C             Segmented cylindric shapes: TUBS,CONS
C
      CALL GDSARC(RMAX1,PHIMIN,PHIMAX,XMAX1,NP)
      CALL GDSARC(RMIN1,PHIMIN,PHIMAX,XMIN1,NP)
      CALL GDSARC(RMAX2,PHIMIN,PHIMAX,XMAX2,NP)
      CALL GDSARC(RMIN2,PHIMIN,PHIMAX,XMIN2,NP)
C
      NP1=NP-1
C
      DO 2510 I=1,NP1
C
        P(1,1)=XMAX1(1,I)
        P(2,1)=XMAX1(2,I)
        P(3,1)=Z1
        P(1,2)=XMAX1(1,I+1)
        P(2,2)=XMAX1(2,I+1)
        P(3,2)=Z1
        P(1,3)=XMIN1(1,I+1)
        P(2,3)=XMIN1(2,I+1)
        P(3,3)=Z1
        P(1,4)=XMIN1(1,I)
        P(2,4)=XMIN1(2,I)
        P(3,4)=Z1
        P(1,5)=XMAX2(1,I)
        P(2,5)=XMAX2(2,I)
        P(3,5)=Z2
        P(1,6)=XMAX2(1,I+1)
        P(2,6)=XMAX2(2,I+1)
        P(3,6)=Z2
        P(1,7)=XMIN2(1,I+1)
        P(2,7)=XMIN2(2,I+1)
        P(3,7)=Z2
        P(1,8)=XMIN2(1,I)
        P(2,8)=XMIN2(2,I)
        P(3,8)=Z2
C
C             Store top,bottom,back,front surfaces
C
        CALL GDSSUR(P(1,1),P(1,2),P(1,6),P(1,5))
        CALL GDSSUR(P(1,4),P(1,3),P(1,7),P(1,8))
        CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,4))
        CALL GDSSUR(P(1,5),P(1,6),P(1,7),P(1,8))
C
C             Store right surface
C
        IF (I.NE.1) GO TO 2505
        CALL GDSSUR(P(1,5),P(1,1),P(1,4),P(1,8))
C
C             Store left surface
C
 2505   CONTINUE
        IF (I.NE.NP1) GO TO 2510
        CALL GDSSUR(P(1,6),P(1,2),P(1,3),P(1,7))
C
 2510 CONTINUE
C
C             Intersect cut-plane with all the surfaces of the shape
C             and draw the resulting lines
C
      CALL GDCUT
C
      GO TO 9999
C
 3000 CONTINUE
C
C             Normal view or X-view or Y-view or Z-view for SPHE
C
C             Cut not implemented
C
      GO TO 9999
C
 4000 CONTINUE
C
C             PGON
C
      FACT=1./COS(DEGRAD*DPHI/2.)
      DO 4002 IZ=1,NZ
        PAR(6+(IZ-1)*3)=PAR(6+(IZ-1)*3)*FACT
        PAR(7+(IZ-1)*3)=PAR(7+(IZ-1)*3)*FACT
 4002 CONTINUE
C
      NZ1=NZ-1
C
      DO 4050 IZ=1,NZ1
C
        ZI=PAR(5+(IZ-1)*3)
        R0=PAR(6+(IZ-1)*3)
        R1=PAR(7+(IZ-1)*3)
        ZZI=PAR(5+IZ*3)
        RR0=PAR(6+IZ*3)
        RR1=PAR(7+IZ*3)
C
        DO 4045 IDIV=1,NDIV
C
          PHI0=PHIMIN+(IDIV-1)*DPHI
          PHI1=PHI0+DPHI
          PHI0=PHI0*DEGRAD
          PHI1=PHI1*DEGRAD
C
          P(1,1)=R1*COS(PHI0)
          P(2,1)=R1*SIN(PHI0)
          P(3,1)=ZI
          P(1,2)=R1*COS(PHI1)
          P(2,2)=R1*SIN(PHI1)
          P(3,2)=ZI
          P(1,3)=R0*COS(PHI1)
          P(2,3)=R0*SIN(PHI1)
          P(3,3)=ZI
          P(1,4)=R0*COS(PHI0)
          P(2,4)=R0*SIN(PHI0)
          P(3,4)=ZI
          P(1,5)=RR1*COS(PHI0)
          P(2,5)=RR1*SIN(PHI0)
          P(3,5)=ZZI
          P(1,6)=RR1*COS(PHI1)
          P(2,6)=RR1*SIN(PHI1)
          P(3,6)=ZZI
          P(1,7)=RR0*COS(PHI1)
          P(2,7)=RR0*SIN(PHI1)
          P(3,7)=ZZI
          P(1,8)=RR0*COS(PHI0)
          P(2,8)=RR0*SIN(PHI0)
          P(3,8)=ZZI
C
C             Store top and bottom surfaces
C
          CALL GDSSUR(P(1,1),P(1,2),P(1,6),P(1,5))
          CALL GDSSUR(P(1,4),P(1,3),P(1,7),P(1,8))
C
C             Store back surface
C
          IF (IZ.NE.1) GO TO 4010
          CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,4))
C
C             Store front surface
C
 4010     CONTINUE
          IF (IZ.NE.NZ1) GO TO 4020
          CALL GDSSUR(P(1,5),P(1,6),P(1,7),P(1,8))
C
C             Store right surface
C
 4020     CONTINUE
          IF (ABS(PHIMAX-PHIMIN).EQ.360.) GO TO 4045
          IF (IDIV.NE.1) GO TO 4030
          CALL GDSSUR(P(1,5),P(1,1),P(1,4),P(1,8))
C
C             Store left surface
C
 4030     CONTINUE
          IF (IDIV.NE.NDIV) GO TO 4045
          CALL GDSSUR(P(1,6),P(1,2),P(1,3),P(1,7))
C
 4045   CONTINUE
C
C             Intersect cut-plane with the surfaces of one Z section
C             and draw the resulting lines
C
        CALL GDCUT
C
 4050 CONTINUE
C
      GO TO 9999
C
 5000 CONTINUE
C
C             PCON
C
      NZ1=NZ-1
C
      DO 5050 IZ=1,NZ1
C
        ZI=PAR(4+(IZ-1)*3)
        R0=PAR(5+(IZ-1)*3)
        R1=PAR(6+(IZ-1)*3)
        ZZI=PAR(4+IZ*3)
        RR0=PAR(5+IZ*3)
        RR1=PAR(6+IZ*3)
C
        CALL GDSARC(R1,PHIMIN,PHIMAX,XMAX1,NP)
        CALL GDSARC(R0,PHIMIN,PHIMAX,XMIN1,NP)
        CALL GDSARC(RR1,PHIMIN,PHIMAX,XMAX2,NP)
        CALL GDSARC(RR0,PHIMIN,PHIMAX,XMIN2,NP)
        NDIV=NP-1
C
        DO 5005 IDIV=1,NDIV
C
          P(1,1)=XMAX1(1,IDIV)
          P(2,1)=XMAX1(2,IDIV)
          P(3,1)=ZI
          P(1,2)=XMAX1(1,IDIV+1)
          P(2,2)=XMAX1(2,IDIV+1)
          P(3,2)=ZI
          P(1,3)=XMIN1(1,IDIV+1)
          P(2,3)=XMIN1(2,IDIV+1)
          P(3,3)=ZI
          P(1,4)=XMIN1(1,IDIV)
          P(2,4)=XMIN1(2,IDIV)
          P(3,4)=ZI
          P(1,5)=XMAX2(1,IDIV)
          P(2,5)=XMAX2(2,IDIV)
          P(3,5)=ZZI
          P(1,6)=XMAX2(1,IDIV+1)
          P(2,6)=XMAX2(2,IDIV+1)
          P(3,6)=ZZI
          P(1,7)=XMIN2(1,IDIV+1)
          P(2,7)=XMIN2(2,IDIV+1)
          P(3,7)=ZZI
          P(1,8)=XMIN2(1,IDIV)
          P(2,8)=XMIN2(2,IDIV)
          P(3,8)=ZZI
C
C             Store top and bottom surfaces
C
          CALL GDSSUR(P(1,1),P(1,2),P(1,6),P(1,5))
          CALL GDSSUR(P(1,4),P(1,3),P(1,7),P(1,8))
C
C             Store back surface
C
          IF (IZ.NE.1) GO TO 5001
          CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,4))
C
C             Store front surface
C
 5001     CONTINUE
          IF (IZ.NE.NZ1) GO TO 5002
          CALL GDSSUR(P(1,5),P(1,6),P(1,7),P(1,8))
C
C             Store right surface
C
 5002     CONTINUE
          IF (ABS(PHIMAX-PHIMIN).EQ.360.) GO TO 5005
          IF (IDIV.NE.1) GO TO 5003
          CALL GDSSUR(P(1,5),P(1,1),P(1,4),P(1,8))
C
C             Store left surface
C
 5003     CONTINUE
          IF (IDIV.NE.NDIV) GO TO 5005
          CALL GDSSUR(P(1,6),P(1,2),P(1,3),P(1,7))
C
 5005   CONTINUE
C
C             Intersect cut-plane with the surfaces of one Z section
C             and draw the resulting lines
C
        CALL GDCUT
C
 5050 CONTINUE
C
      GO TO 9999
*
 6000 CONTINUE
*
*          Cut tube shape.
*
      CPHIS = COS( PHIS*DEGRAD )
      SPHIS = SIN( PHIS*DEGRAD )
      P( 1, 1) = PAR(2)*CPHIS
      P( 2, 1) = PAR(2)*SPHIS
      P( 3, 1) = -( PAR( 6)*P( 1, 1) +PAR( 7)*P( 2, 1) )/PAR( 8)
     + -PAR( 3)
      P( 1, 4) = PAR(1)*CPHIS
      P( 2, 4) = PAR(1)*SPHIS
      P( 3, 4) = -( PAR( 6)*P( 1, 4) +PAR( 7)*P( 2, 4) )/PAR( 8)
     + -PAR( 3)
      P( 1, 5) = PAR(2)*CPHIS
      P( 2, 5) = PAR(2)*SPHIS
      P( 3, 5) = -( PAR( 9)*P( 1, 5) +PAR( 10)*P( 2, 5) )/PAR( 11)
     + +PAR( 3)
      P( 1, 8) = PAR(1)*CPHIS
      P( 2, 8) = PAR(1)*SPHIS
      P( 3, 8) = -( PAR( 9)*P( 1, 8) +PAR( 10)*P( 2, 8) )/PAR( 11)
     + +PAR( 3)
*
      DO 6010 I = 1, NL
        PHIS = PHIS+DPHI
        CPHIS = COS( PHIS*DEGRAD )
        SPHIS = SIN( PHIS*DEGRAD )
        P( 1, 2) = PAR(2)*CPHIS
        P( 2, 2) = PAR(2)*SPHIS
        P( 3, 2) = -( PAR( 6)*P( 1, 1) +PAR( 7)*P( 2, 1) )/PAR( 8)
     +   -PAR( 3)
        P( 1, 3) = PAR(1)*CPHIS
        P( 2, 3) = PAR(1)*SPHIS
        P( 3, 3) = -( PAR( 6)*P( 1, 4) +PAR( 7)*P( 2, 4) )/PAR( 8)
     +   -PAR( 3)
        P( 1, 6) = PAR(2)*CPHIS
        P( 2, 6) = PAR(2)*SPHIS
        P( 3, 6) = -( PAR( 9)*P( 1, 5) +PAR( 10)*P( 2, 5) )/PAR( 11)
     +   +PAR( 3)
        P( 1, 7) = PAR(1)*CPHIS
        P( 2, 7) = PAR(1)*SPHIS
        P( 3, 7) = -( PAR( 9)*P( 1, 8) +PAR( 10)*P( 2, 8) )/PAR( 11)
     +   +PAR( 3)
*
        CALL GDSSUR( P(1,1), P(1,2), P(1,6), P(1,5) )
        CALL GDSSUR( P(1,4), P(1,3), P(1,7), P(1,8) )
        CALL GDSSUR( P(1,1), P(1,2), P(1,3), P(1,4) )
        CALL GDSSUR( P(1,5), P(1,6), P(1,7), P(1,8) )
*
        IF( ISEG .EQ. 1 ) THEN
          IF( I .EQ. 1 ) THEN
            CALL GDSSUR( P(1,5), P(1,1), P(1,4), P(1,8) )
          ELSEIF ( I .EQ. NL ) THEN
            CALL GDSSUR( P(1,6), P(1,2), P(1,3), P(1,7) )
          ENDIF
        ENDIF
*
        P( 1, 1) = P( 1, 2)
        P( 2, 1) = P( 2, 2)
        P( 3, 1) = P( 3, 2)
        P( 1, 4) = P( 1, 3)
        P( 2, 4) = P( 2, 3)
        P( 3, 4) = P( 3, 3)
        P( 1, 5) = P( 1, 6)
        P( 2, 5) = P( 2, 6)
        P( 3, 5) = P( 3, 6)
        P( 1, 8) = P( 1, 7)
        P( 2, 8) = P( 2, 7)
        P( 3, 8) = P( 3, 7)
*
 6010 CONTINUE
*
      CALL GDCUT
      GO TO 9999
*
 7000 CONTINUE
C
C             ELTU
C
      DO 7010  I=1,40
C
         P(1,1)=A*GCOS(I)
         P(2,1)=B*GSIN(I)
         P(3,1)=Z1
         P(1,2)=A*GCOS(I+1)
         P(2,2)=B*GSIN(I+1)
         P(3,2)=Z1
         P(1,3)=0.
         P(2,3)=0.
         P(3,3)=Z1
         P(1,4)=A*GCOS(I)
         P(2,4)=B*GSIN(I)
         P(3,4)=Z2
         P(1,5)=A*GCOS(I+1)
         P(2,5)=B*GSIN(I+1)
         P(3,5)=Z2
         P(1,6)=0.
         P(2,6)=0.
         P(3,6)=Z2
C
C             Store top,back,front surfaces
C
         CALL GDSSUR(P(1,1),P(1,2),P(1,5),P(1,4))
         CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,3))
         CALL GDSSUR(P(1,4),P(1,5),P(1,6),P(1,6))
C
 7010 CONTINUE
C
C             Intersect cut-plane with all the surfaces of the shape
C             and draw the resulting lines
C
      CALL GDCUT
C
      GO TO 9999
C
*
 7350 CONTINUE
C
C             Another cylindrical shape: HYPE
C
      NZSTEP = 40
      DZ = Z2 / NZSTEP * 2.
      RMA1 = SQRT(RMAX12 + Z2*Z2*TANTHS)
      RMI1 = SQRT(RMIN12 + Z2*Z2*TANTHS)
      ZZ1 = Z2
      DO 7400 J = 1, NZSTEP
         ZZ2 = Z2 - J*DZ
         Z2T = (ZZ2**2) * TANTHS
         RMA2 = SQRT(RMAX12 + Z2T)
         RMI2 = SQRT(RMIN12 + Z2T)
         DO 7390  I=1,40
C
            P(1,1)=RMA1*GCOS(I)
            P(2,1)=RMA1*GSIN(I)
            P(3,1)=ZZ1
            P(1,2)=RMA1*GCOS(I+1)
            P(2,2)=RMA1*GSIN(I+1)
            P(3,2)=ZZ1
            P(1,3)=RMI1*GCOS(I+1)
            P(2,3)=RMI1*GSIN(I+1)
            P(3,3)=ZZ1
            P(1,4)=RMI1*GCOS(I)
            P(2,4)=RMI1*GSIN(I)
            P(3,4)=ZZ1
            P(1,5)=RMA2*GCOS(I)
            P(2,5)=RMA2*GSIN(I)
            P(3,5)=ZZ2
            P(1,6)=RMA2*GCOS(I+1)
            P(2,6)=RMA2*GSIN(I+1)
            P(3,6)=ZZ2
            P(1,7)=RMI2*GCOS(I+1)
            P(2,7)=RMI2*GSIN(I+1)
            P(3,7)=ZZ2
            P(1,8)=RMI2*GCOS(I)
            P(2,8)=RMI2*GSIN(I)
            P(3,8)=ZZ2
C
C             Store top and bottom surfaces only
C
            CALL GDSSUR(P(1,1),P(1,2),P(1,6),P(1,5))
            CALL GDSSUR(P(1,4),P(1,3),P(1,7),P(1,8))
C            CALL GDSSUR(P(1,1),P(1,2),P(1,3),P(1,4))
C            CALL GDSSUR(P(1,5),P(1,6),P(1,7),P(1,8))
C
 7390    CONTINUE
C
         RMA1 = RMA2
         RMI1 = RMI2
         ZZ1 = ZZ2
C
 7400  CONTINUE
C
C             Intersect cut-plane with all the surfaces of the shape
C             and draw the resulting lines
C
      CALL GDCUT
C
*
 9999 END
+DECK,  GDSARC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:27  cernlib
* Geant

      SUBROUTINE GDSARC(R,PHI1,PHI2,X,NP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Computes and store in X(1..2,1..NP) arc points           *
C.    *       (only X and Y coordinates) for GDRWSC                    *
C.    *       of the circle of radius R centered on Z-axis,            *
C.    *       from PHI1 to PHI2,                                       *
C.    *       on a plane parallel to X-Y plane                         *
C.    *                                                                *
C.    *    ==>Called by : GDRWSC                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCDRAW.
+CDE, GCUNIT.
      DIMENSION X(2,42)
      SAVE MAXNP
      DATA MAXNP/42/
C.
C.    ------------------------------------------------------------------
C.
      PHIMIN=PHI1
      PHIMAX=PHI2
C
      NP=1
      PH=PHIMIN*DEGRAD
      X(1,1)=R*COS(PH)
      X(2,1)=R*SIN(PH)
C
      IF(ABS(PHIMAX-PHIMIN).LE.9.) GO TO 20
C
      I1=PHIMIN/9.0+2
      I2=PHIMAX/9.0+1
      NAS=I2-I1+1
      IF(NAS.LE.0) NAS=NAS+40
      IC=I1
C
      IF (NAS.GT.MAXNP-2) GO TO 30
C
      DO 10 IAS=1,NAS
         IF(IC.GT.40) IC=IC-40
         NP=NP+1
         ICC=IC
         IF (ICC.LE.0) ICC=40+ICC
         X(1,NP)=R*GCOS(ICC)
         X(2,NP)=R*GSIN(ICC)
         IC=IC+1
   10 CONTINUE
C
   20 CONTINUE
C
      PH=PHIMAX*DEGRAD
      NP=NP+1
      X(1,NP)=R*COS(PH)
      X(2,NP)=R*SIN(PH)
      GO TO 999
C
   30 CONTINUE
      NP=NAS+2
      WRITE (CHMAIL,1000) NP
      CALL GMAIL(0,0)
C
 1000 FORMAT (' GDSARC: INTERNAL ERROR !!!   -   NP =',I5)
  999 RETURN
      END
+DECK,  GDSCAL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:27  cernlib
* Geant

      SUBROUTINE GDSCAL(U0,V0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw an unitary length segment at position (U0,V0)       *
C.    *       correspondent to current scale factor GSCU               *
C.    *       and zoom factor GZUA                                     *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC                      *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION U(2),V(2)
      CHARACTER*8 IUMC
C.
C.    ------------------------------------------------------------------
C.
      IF (GSCU*GZUA.LE.0.03) THEN
         IUMC='100< CM$'
         UML=100.
      ELSE IF (GSCU*GZUA.LE.0.3) THEN
         IUMC='10 <CM $'
         UML=10.
      ELSE IF (GSCU*GZUA.LE.3.) THEN
         IUMC=' 1 <CM $'
         UML=1.
      ELSE IF (GSCU*GZUA.LE.30.) THEN
         IUMC='0.1<CM $'
         UML=0.1
      ELSE IF (GSCU*GZUA.LE.300.) THEN
         IUMC='100< [M$'
         UML=0.01
      ELSE IF (GSCU*GZUA.LE.3000.) THEN
         IUMC='10 <[M $'
         UML=0.001
      ELSE
         IUMC=' 1<[M $'
         UML=0.0001
      ENDIF
C
      SLEN=UML*GSCU*GZUA
C
C             Normalize to PLTRNX,PLTRNY
C
      SLEN=SLEN*MIN(PLTRNX,PLTRNY)/20.
C
      DX=SLEN/2.
      DY=DX/4.
      U(1)=U0-DX
      U(2)=U0+DX
      V(1)=V0
      V(2)=V0
      CALL GDRAWV(U,V,2)
      U(2)=U0-DX
      V(1)=V0+DY
      V(2)=V0-DY
      CALL GDRAWV(U,V,2)
      U(1)=U0+DX
      U(2)=U0+DX
      CALL GDRAWV(U,V,2)
C
      CSIZ=SLEN/4.
      VV0=V0+3.*DY
      CALL GDRAWT(U0,VV0,IUMC,CSIZ,0.,1,0)
C
      END
+DECK,  GDSHAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

+SELF, IF=CG.
      SUBROUTINE GDSHAD(LINCOL,APROSC)
*
******************************************************************
*                                                                *
* Function: Recieve light intensity and angle with surface       *
*           Compute colour shading for the surface               *
*                                                                *
* I/O parameters:                                                *
* LINCOL = colour code                                           *
* APROSC = inclination between light rays and surface            *
*                                                                *
* Author: S. Giani                                               *
*                                                                *
******************************************************************
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, CGGPAR.
+CDE, CGHPAR.
+CDE, CGCTRA.
+CDE, CGCEDG.
+CDE, GCDRAW.
+CDE, GCFLAG.
*
+CDE, GCTRAK.
+CDE, GCRAYT.
*     DATA AAA /1./
*     SAVE AAA
*
*      print *,aprosc
      IF(LINCOL.EQ.2)THEN
         LINCOL=16
      ELSEIF(LINCOL.EQ.3)THEN
         LINCOL=66
      ELSEIF(LINCOL.EQ.4)THEN
         LINCOL=116
      ELSEIF(LINCOL.EQ.5)THEN
         LINCOL=41
      ELSEIF(LINCOL.EQ.6)THEN
         LINCOL=141
      ELSEIF(LINCOL.EQ.7)THEN
         LINCOL=91
      ELSE
*        print *,'color not supported'
         GOTO 20
      ENDIF
*
**      AAA=AAA+1
*******      AAA=AAA*123.456789
*******      AAA=AINT(AAA)
*******      QD=AAA
*
      SMIN=-1.0001
      SMAX=-1.+0.08
      DO 10 I=1,25
         IF(SMAX.GT.0.99)SMAX=1.0001
         IF(APROSC.GT.SMIN.AND.APROSC.LE.SMAX)THEN
**        QD=RNDM(AAA)
**        QCD=QD*(SMAX-SMIN)
**        IF((APRO-SMIN).GT.QCD)THEN
            LINCOL=LINCOL+(I+1)/1.5
**        ELSE
**           IF(I.GT.1)THEN
**            LINCOL=LINCOL+I-1
**           ELSE
**            LINCOL=LINCOL+I
**           ENDIF
**        ENDIF
            GOTO 20
         ELSE
            SMIN=SMAX
            SMAX=SMAX+0.08
         ENDIF
   10 CONTINUE
*
*     print *,aprosc,'=aprosc'
*
   20 CONTINUE
      CALL ISFACI(LINCOL)
      CALL ISPLCI(LINCOL)
      CALL ISPMCI(LINCOL)
*
  999 END
+SELF.
+DECK,  GDSHIF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDSHIF(IVOLNA,ICPOIN)
*
*     This subroutine allows to shift volumes in a more visible
*     place just for drawing, without alterating the data structure,
*     but perfectly simulating it.
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCVOLU.
+CDE, GCGOBJ.
*SG
+CDE, GCMUTR.
+CDE, GCDRAW.
+CDE, GCHILN.
+CDE, GCSPEE.
*SG
      COMMON /QUEST/IQUEST(100)
*SG
      SAVE IOLDVO
      DATA IOLDVO/0/
*
*    Shifting object
         IF(KSHIFT.EQ.2)THEN
           DO 333 IJ=1,100
             IF(IVOLNA.EQ.IVECVO(IJ))GOTO 554
             IF(IVECVO(IJ).EQ.0)THEN
               IVECVO(IJ)=IVOLNA
               GOTO 334
             ENDIF
 333       CONTINUE
         ENDIF
 334     CONTINUE
         IF(KSHIFT.GT.0)THEN
            IF(ISUBLI.EQ.1.AND.NIET.EQ.1)THEN
             NIET=1
             CALL CGSHIF(PORGX,PORGY,PORGZ,
     +       Q(ICPOIN))
             IF(IVOLNA.EQ.IOLDVO)GOTO 554
             GOTO 54
            ENDIF
            IF(ISUBLI.EQ.1.AND.NIET.EQ.2.AND.IVOOLD.NE.0)THEN
             NIET=1
             IF(IVOLNA.EQ.IOLDVO)THEN
              CALL CGSHIF(PORGX,PORGY,PORGZ,
     +        Q(ICPOIN))
              GOTO 554
             ENDIF
             DO 77 I=1,15
            IF((NLEVEL-I).GT.0)THEN
             IF(POX(NLEVEL-I).NE.0.OR.POY(NLEVEL-I).NE.0.OR.
     +       POZ(NLEVEL-I).NE.0)THEN
              PORGX=POX(NLEVEL-I)
              PORGY=POY(NLEVEL-I)
              PORGZ=POZ(NLEVEL-I)
              GOTO 777
             ENDIF
            ELSE
               PORGX=0.
               PORGY=0.
               PORGZ=0.
               POX(NLEVEL)=0.
               POY(NLEVEL)=0.
               POZ(NLEVEL)=0.
               GOTO 777
            ENDIF
 77          CONTINUE
 777         CONTINUE
             CALL CGSHIF(PORGX,PORGY,PORGZ,
     +       Q(ICPOIN))
             GOTO 54
            ENDIF
             IF(NIET.EQ.0.AND.IVOLNA.EQ.IOLDVO)GOTO 554
             NIET=0
 54          CONTINUE
             DO 553 KHHH=MULTRA,1,-1
                CALL UCTOH(GNVNV(KHHH),IVN,4,4)
                IF(IVN.EQ.IVOLNA)THEN
                   NIET=1
                   CALL CGSHIF(GXXXX(KHHH),GYYYY(KHHH),GZZZZ(KHHH),
     +             Q(ICPOIN))
                   IF(IVOLNA.NE.IOLDVO)THEN
                    POX(NLEVEL)=PORGX+GXXXX(KHHH)
                    POY(NLEVEL)=PORGY+GYYYY(KHHH)
                    POZ(NLEVEL)=PORGZ+GZZZZ(KHHH)
                    PORGX=PORGX+GXXXX(KHHH)
                    PORGY=PORGY+GYYYY(KHHH)
                    PORGZ=PORGZ+GZZZZ(KHHH)
                   ENDIF
                   IVOOLD=IVOLNA
                   IOLDVO=IVOLNA
                   GOTO 554
                ENDIF
  553        CONTINUE
             IOLDVO=IVOLNA
         ENDIF
  554    CONTINUE
  999    END


+DECK,  GDSHOW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDSHOW(IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Show view bank IVIEW on the screen                       *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Authors : R.Brun, P.Zanarini, S.Giani   *********        *
C.    *                                                                *
C.    ******************************************************************
C.
C
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCONST.
      CHARACTER*80 CHTEXT
C.
C.    ------------------------------------------------------------------
C.
      IF (IVIEW.LE.0) GO TO 70
      IF (IVIEW.GT.NKVIEW) GO TO 70
      IF (LQ(JDRAW-IVIEW).EQ.0) GO TO 70
C
      JV=LQ(JDRAW-IVIEW)
      GTHETA=Q(JV+13)
      GPHI=Q(JV+14)
      GPSI=Q(JV+15)
      SINPSI=SIN(GPSI*DEGRAD)
      COSPSI=COS(GPSI*DEGRAD)
      GU0=Q(JV+16)
      GV0=Q(JV+17)
      GSCU=Q(JV+18)
      GSCV=Q(JV+19)
      ICUT=Q(JV+22)
      NGVIEW=0
      IF (IVIEW.EQ.IDVIEW) GO TO 10
C
C             IVIEW is not current view bank
C
      MIGU=Q(JV+1)
      MITU=Q(JV+7)
      GO TO 20
C
C             IVIEW is current view bank
C
   10 MIGU=IGU
      MITU=ITU
C
C             Show graphic units
C
   20 IF (MIGU.EQ.0) GO TO 50
C
      DO 40 I=1,MIGU
C
C             Bit 1- 7 = LENGU
C             Bit 8-24 = Line attribute
C
         ISUM=Q(LQ(JV-1)+I)
*SG
         IFIL=IBITS(ISUM,13,3)
         IF(IFIL.EQ.0)THEN
            ILEN=IBITS(ISUM,0,7)
         ELSE
            ILEN=IBITS(ISUM,0,10)
         ENDIF
         CALL GWORK(2*ILEN)
         LINATT=IBITS(ISUM,0,24)
         IF(IFIL.EQ.0)THEN
            CALL MVBITS(0,0,7,LINATT,0)
         ELSE
            CALL MVBITS(0,0,10,LINATT,0)
         ENDIF
*SG
C
         IADD=Q(LQ(JV-2)+I)
C
         DO 30 J=1,ILEN
C
C             Zoom processing
C
            WS(J) = Q(LQ(JV-4)+IADD+J-1)*GZUA+GZUB+GZUC
            WS(ILEN+J) = Q(LQ(JV-5)+IADD+J-1)*GZVA+GZVB+GZVC
C
   30    CONTINUE
C
         MEMIDV=IDVIEW
         IF (IDVIEW.EQ.0) IDVIEW=-175
         CALL GDRAWV(WS(1),WS(ILEN+1),ILEN)
         IDVIEW=MEMIDV
         JV=LQ(JDRAW-IVIEW)
C
   40 CONTINUE
C
C             Show text units
C
   50 IF (MITU.EQ.0) GO TO 80
C
      DO 60 I=1,MITU
         IADD=Q(LQ(JV-3)+I)
         JVAD=LQ(JV-6)+IADD
         X=Q(JVAD)
         Y=Q(JVAD+1)
C
C             Zoom processing
C
         X=X*GZUA+GZUB+GZUC
         Y=Y*GZVA+GZVB+GZVC
C
         SIZE=Q(JVAD+2)*(GZUA+GZVA)*.5
         ANGLE=Q(JVAD+3)
C
C             Bit 1- 3 = Text line width (LWIDTH)
C             Bit 4-24 = Text attribute
C
         ISUM=Q(JVAD+4)
         LWIDTH=IBITS(ISUM,0,3)
         ITXATT=IBITS(ISUM,0,24)
C
         IOPT=Q(JVAD+5)
C
         NCHAR=Q(JVAD+6)
         CHTEXT=' '
         CALL UHTOC(IQ(JVAD+7),4,CHTEXT,NCHAR)
         MEMIDV=IDVIEW
         IF (IDVIEW.EQ.0) IDVIEW=-175
         CALL GDRAWT(X,Y,CHTEXT,SIZE,ANGLE,LWIDTH,IOPT)
         IDVIEW=MEMIDV
         JV=LQ(JDRAW-IVIEW)
C
   60 CONTINUE
C
      GO TO 80
C
   70 WRITE (CHMAIL,10000) IVIEW
      CALL GMAIL(0,0)
C
   80 CALL GDCOL(0)
      RETURN
10000 FORMAT(' *** GDSHOW ***: View ',I6,' does not exist')
      END
+DECK,  GDSON, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDSON(N,NAME,ISON)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Returns in ISON the N-th son of object NAME              *
C.    *                                                                *
C.    *    ==>Called by : GDPRTR, GDSPEC, GDTR1                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
      CHARACTER*4 NAME,ISON
C.
C.    ------------------------------------------------------------------
C.
      ISON=' '
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF (IVO.LE.0) GO TO 999
      JVO=LQ(JVOLUM-IVO)
      NIN=Q(JVO+3)
      IF (NIN.EQ.0) GO TO 999
      IF (NIN.GT.0) GO TO 10
      IF (N.NE.1) GO TO 999
      JIN=LQ(JVO-1)
      GO TO 20
   10 JIN=LQ(JVO-N)
   20 IVOL=Q(JIN+2)
      CALL UHTOC(IQ(JVOLUM+IVOL),4,ISON,4)
  999 RETURN
      END
+DECK,  GDSPEC, T=FORT.
* Revision 1.3  1996/10/01 14:12:05  ravndal
* right units for SPHE specs.
* Revision 1.2  1996/09/30 14:54:13  ravndal
* Right units for the spec of PARA
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDSPEC(NAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This routine draws specifications of volume NAME         *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDFSPC                      *
C.    *       Authors : P.Zanarini   *********                         *
C.    *                 A.McPherson  *****                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCNUM.
+CDE, GCSHNO.
      CHARACTER*4 ICTUB(11)
      CHARACTER*4 NAME,NAMSEE,ISON
      CHARACTER*4 IBOX(5),ITRD1(5),ITUBE(5),ITUBS(5)
      CHARACTER*4 ITRD2(6),ICON(5),ICONS(7),ISPH(6),ITRAP(11),IPARA(6),
     +IPGON(7),IPCON(6),IGTRA(12),IHYPE(4),IELTU(3)
      DIMENSION PAR(50),IPAR(12),IPA(3),ISPAR(3)
      DIMENSION U0(3),V0(3),THE(3),PHI(3),ISHT(2)
      DIMENSION U01(3),V01(3)
      DIMENSION NNDM(100),INDM(5,100),ATT(10)
      CHARACTER*12 CHTEXT
      SAVE IBOX,ITRD1,ITRD2,ITRAP,ITUBE,ITUBS,ICON,ICONS,ISPH,IPARA
      SAVE IPGON,IPCON,IGTRA,ICTUB,IHYPE,IELTU
      SAVE NNDM,INDM,U01,V01,THE,PHI,XMAN1,YMAN1
C
      DATA IBOX /'DX  ','DY  ','DZ  ','    ','    '/
      DATA ITRD1/'DX1 ','DX2 ','DY  ','DZ  ','    '/
      DATA ITRD2/'DX1 ','DX2 ','DY1 ','DY2 ','DZ  ','    '/
      DATA ITRAP/'DZ  ','THET','PHI ','H1  ','BL1 ','TL1 ','ALP1',
     +'H2  ','BL2 ','TL2 ','ALP2'/
      DATA ITUBE/'RMIN','RMAX','DZ  ','    ','    '/
      DATA ITUBS/'RMIN','RMAX','DZ  ','PHI1','PHI2'/
      DATA ICON /'DZ  ','RMN1','RMX1','RMN2','RMX2'/
      DATA ICONS/'DZ  ','RMN1','RMX1','RMN2','RMX2','PHI1','PHI2'/
      DATA ISPH /'RMIN','RMAX','THE1','THE2','PHI1','PHI2'/
      DATA IPARA/'DX  ','DY  ','DZ  ','ALPH','THET','PHI '/
      DATA IPGON/'PHI1','DPHI','NPDV','NZ  ','Z   ','RMIN','RMAX'/
      DATA IPCON/'PHI1','DPHI','NZ  ','Z   ','RMIN','RMAX'/
      DATA IHYPE/'RMIN','RMAX','DZ  ','TWST'/
      DATA IGTRA/'DZ  ','THET','PHI ','TWIS','H1  ','BL1 ','TL1 ',
     +'ALP1','H2  ','BL2 ','TL2 ','ALP2'/
      DATA ICTUB/'RMIN','RMAX','DZ  ','PHI1','PHI2','LXL ','LYL ',
     +           'LZL ','LXH ','LYH ','LZH '/
      DATA IELTU /'A   ','B   ','DZ  '/
C
      DATA NNDM/0,0,0,4,0,2,0,2,4,3,4,3,0,0,13*0,5,72*0/
      DATA INDM/0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,3,7,11,0, 0,0,0,0,0,
     +          4,5,0,0,0, 0,0,0,0,0, 6,7,0,0,0, 3,4,5,6,0, 4,5,6,0,0,
     +          1,2,3,4,0, 1,2,3,0,0, 0,0,0,0,0, 70*0, 2,3,4,8,12,
     +          360*0/
C
      DATA U01/14.5,5.5,14.5/
      DATA V01/14.,5.,5./
      DATA THE/45.,0.,90./
      DATA PHI/135.,0.,180./
      DATA XMAN1/8.8/
      DATA YMAN1/11.6/
C.
C.    ------------------------------------------------------------------
C.
C             Is NAME an existing volume ?
C
***      CALL IGRNG(20.,20.)
      CALL HPLFRA(0.,20.,0.,20.,'AB')
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF (IVO.LE.0) GO TO 999
C
C             Normalize to PLTRNX,PLTRNY
C
      DO 10 I=1,3
         U0(I)=U01(I)*PLTRNX/20.
         V0(I)=V01(I)*PLTRNY/20.
   10 CONTINUE
      XMAN=XMAN1*PLTRNX/20.
      YMAN=YMAN1*PLTRNY/20.
C
C             Save GDRAW calling parameters
C             and ZOOM internal parameters
C
      SAVTHE=GTHETA
      SAVPHI=GPHI
      SAVPSI=GPSI
      SAVU0=GU0
      SAVV0=GV0
      SAVSCU=GSCU
      SAVSCV=GSCV
      SVGZUA=GZUA
      SVGZVA=GZVA
      SVGZUB=GZUB
      SVGZVB=GZVB
      SVGZUC=GZUC
      SVGZVC=GZVC
      GZUA=1
      GZVA=1
      GZUB=0
      GZVB=0
      GZUC=0
      GZVC=0
C
C             Get shape type
C
      JVO=LQ(JVOLUM-IVO)
      ISHAPE=Q(JVO+2)
C
C             Get user parameters
C
      CALL GFPARA(NAME,1,0,NPAR,NATT,PAR,ATT)
      IF(NPAR.LE.0) GO TO 250
C
C
C             Check parameter sizes
C
      PARMAX=-1.
      DO 40 I=1,NPAR
         IF(NNDM(ISHAPE).LE.0) GO TO 30
         NDM=NNDM(ISHAPE)
         DO 20 IDM=1,NDM
            IF(I.EQ.INDM(IDM,ISHAPE)) GO TO 40
   20    CONTINUE
   30    ABSPAR=ABS(PAR(I))
         PARMAX=MAX(PARMAX,ABSPAR)
   40 CONTINUE
C
      GSCU=MIN(PLTRNX,PLTRNY)/(7.*PARMAX)
      GSCV=GSCU
      AXSIZ=PARMAX*0.35
C
C             Draw header
C
      CALL GDHEAD(-1,NAME,0.)
C
C             Draw parameters list
C
      DY=0.4
      IF(NPAR.GT.20) NPAR=20
      IF(NPAR.GT.10) DY=5.0/NPAR
      H=DY*0.7
C
      DO 210 I=1,NPAR
         CALL UCTOH(' = <',ISPAR(2),4,4)
         CALL UCTOH('CM $',ISPAR(3),4,4)
         IF (ISHAPE.NE.1) GO TO 50
         CALL UCTOH('B<OX',ISHT(1),4,4)
         CALL UCTOH('   $',ISHT(2),4,4)
         CALL UCTOH(IBOX(I),ISPAR(1),4,4)
         GO TO 200
   50    IF (ISHAPE.NE.2) GO TO 60
         CALL UCTOH('T<RD',ISHT(1),4,4)
         CALL UCTOH('>1 $',ISHT(2),4,4)
         CALL UCTOH(ITRD1(I),ISPAR(1),4,4)
         GO TO 200
   60    IF(ISHAPE.NE.3) GO TO 70
         CALL UCTOH('T<RD',ISHT(1),4,4)
         CALL UCTOH('>2 $',ISHT(2),4,4)
         CALL UCTOH(ITRD2(I),ISPAR(1),4,4)
         GO TO 200
   70    IF(ISHAPE.NE.4) GO TO 80
         CALL UCTOH('T<RA',ISHT(1),4,4)
         CALL UCTOH('P  $',ISHT(2),4,4)
         CALL UCTOH(ITRAP(I),ISPAR(1),4,4)
         IF(I.EQ.2.OR.I.EQ.3.OR.I.EQ.7.OR.I.EQ.11)THEN
            CALL UCTOH(' = <',ISPAR(2),4,4)
            CALL UCTOH('DEG$',ISPAR(3),4,4)
         ENDIF
         GO TO 200
   80    IF (ISHAPE.NE.5) GO TO 90
         CALL UCTOH('T<UB',ISHT(1),4,4)
         CALL UCTOH('E  $',ISHT(2),4,4)
         CALL UCTOH(ITUBE(I),ISPAR(1),4,4)
         GO TO 200
   90    IF (ISHAPE.NE.6) GO TO 100
         CALL UCTOH('T<UB',ISHT(1),4,4)
         CALL UCTOH('S  $',ISHT(2),4,4)
         CALL UCTOH(ITUBS(I),ISPAR(1),4,4)
         IF(I.GT.3)THEN
            CALL UCTOH(' = <',ISPAR(2),4,4)
            CALL UCTOH('DEG$',ISPAR(3),4,4)
         ENDIF
         GO TO 200
  100    IF(ISHAPE.NE.7) GO TO 110
         CALL UCTOH('C<ON',ISHT(1),4,4)
         CALL UCTOH('E  $',ISHT(2),4,4)
         CALL UCTOH(ICON(I),ISPAR(1),4,4)
         GO TO 200
  110    IF(ISHAPE.NE.8) GO TO 120
         CALL UCTOH('C<ON',ISHT(1),4,4)
         CALL UCTOH('S  $',ISHT(2),4,4)
         CALL UCTOH(ICONS(I),ISPAR(1),4,4)
         IF(I.GT.5)THEN
            CALL UCTOH(' = <',ISPAR(2),4,4)
            CALL UCTOH('DEG$',ISPAR(3),4,4)
         ENDIF
         GO TO 200
  120    IF(ISHAPE.NE.9) GO TO 130
         CALL UCTOH('S<PH',ISHT(1),4,4)
         CALL UCTOH('E  $',ISHT(2),4,4)
         CALL UCTOH(ISPH(I),ISPAR(1),4,4)
         IF(I.GT.2)THEN
            CALL UCTOH(' = <',ISPAR(2),4,4)
            CALL UCTOH('DEG$',ISPAR(3),4,4)
         ENDIF
         GO TO 200
  130    IF(ISHAPE.NE.10) GO TO 140
         CALL UCTOH('P<AR',ISHT(1),4,4)
         CALL UCTOH('A  $',ISHT(2),4,4)
         CALL UCTOH(IPARA(I),ISPAR(1),4,4)
         IF(I.GT.3)THEN
            CALL UCTOH(' = <',ISPAR(2),4,4)
            CALL UCTOH('DEG$',ISPAR(3),4,4)
         ENDIF
         GO TO 200
  140    IF(ISHAPE.NE.11.AND.ISHAPE.NE.12) GO TO 170
         CALL UCTOH('P<GO',ISHT(1),4,4)
         CALL UCTOH('N  $',ISHT(2),4,4)
         IU=I
         IF(IU.LT.8) GO TO 150
         I2=I-5
         I3=I2/3
         I4=I2-I3*3
         IU=I4+5
  150    CALL UCTOH(IPGON(IU),ISPAR(1),4,4)
         IF(I.LT.3)THEN
            CALL UCTOH(' = <',ISPAR(2),4,4)
            CALL UCTOH('DEG$',ISPAR(3),4,4)
         ENDIF
         IF(I.EQ.3.OR.I.EQ.4)CALL UCTOH('   $', ISPAR(3),4,4)
         IF(ISHAPE.EQ.11) GO TO 200
         CALL UCTOH('P<CO',ISHT(1),4,4)
         IU=I
         IF(IU.LT.7) GO TO 160
         I2=I-4
         I3=I2/3
         I4=I2-I3*3
         IU=I4+4
  160    CALL UCTOH(IPCON(IU),ISPAR(1),4,4)
         IF(I.EQ.4) CALL UCTOH('CM $',ISPAR(3),4,4)
C
         GO TO 200
  170    CONTINUE
         IF(ISHAPE.NE.13) GO TO 180
         CALL UCTOH('E<LT',ISHT(1),4,4)
         CALL UCTOH('U  $',ISHT(2),4,4)
         CALL UCTOH(IELTU(I),ISPAR(1),4,4)
         GO TO 200
  180    CONTINUE
         IF(ISHAPE .NE. 14) GO TO 190
         CALL UCTOH('H<YP',ISHT(1),4,4)
         CALL UCTOH('E  $',ISHT(2),4,4)
         CALL UCTOH(IHYPE(I),ISPAR(1),4,4)
         IF(I .GT. 3) THEN
            CALL UCTOH(' = <',ISPAR(2),4,4)
            CALL UCTOH('DEG$',ISPAR(3),4,4)
         ENDIF
         GO TO 200
C
  190    CONTINUE
C
C             Cut tube
C
         IF (ISHAPE.EQ.NSCTUB) THEN
            CALL UCTOH('CT<U',ISHT(1),4,4)
            CALL UCTOH('B  $',ISHT(2),4,4)
            CALL UCTOH(ICTUB(I),ISPAR(1),4,4)
            IF(I.GE.4.AND.I.LE.5)THEN
               CALL UCTOH(' = <',ISPAR(2),4,4)
               CALL UCTOH('DEG$',ISPAR(3),4,4)
            ELSE IF(I.GE.6)THEN
               CALL UCTOH(' =  ',ISPAR(2),4,4)
               CALL UCTOH('  $ ',ISPAR(3),4,4)
            END IF
            GO TO 200
         ENDIF
C
C             General twisted trapezoid.
C
         IF(ISHAPE.NE.28) GO TO 230
         CALL UCTOH('G>TR',ISHT(1),4,4)
         CALL UCTOH('A  $',ISHT(2),4,4)
         CALL UCTOH(IGTRA(I),ISPAR(1),4,4)
         IF(I.EQ.2.OR.I.EQ.3.OR.I.EQ.4.OR.I.EQ.8.OR. I.EQ.12) CALL
     +   UCTOH('DEG$',ISPAR(3),4,4)
C
  200    CONTINUE
         IF (I.EQ.1) THEN
            XTEXT=4.*PLTRNX/20.
            YTEXT=16.5*PLTRNY/20.
            CSIZE=DY*MIN(PLTRNX,PLTRNY)/20.
            CALL UHTOC(ISHT,4,CHTEXT,12)
            CALL GDRAWT(XTEXT,YTEXT,CHTEXT,CSIZE,0.,1,-1)
         ENDIF
         Y=16.5-(I+0.5)*DY
         XTEXT=3.*PLTRNX/20.
         YTEXT=Y*PLTRNY/20.
         CSIZE=H*MIN(PLTRNX,PLTRNY)/20.
         CALL UHTOC(ISPAR,4,CHTEXT,12)
         CALL GDRAWT(XTEXT,YTEXT,CHTEXT,CSIZE,0.,1,-1)
         CALL HBCDF(PAR(I),8,IPAR)
         IF (PAR(I).EQ.0.) CALL UCTOH('0',IPAR(1),1,1)
         CALL UCTOH('$',IPAR(9),1,1)
         CALL UBUNCH(IPAR,IPA,9)
         XTEXT=(H*10.+3.)*PLTRNX/20.
         YTEXT=Y*PLTRNY/20.
         CSIZE=H*MIN(PLTRNX,PLTRNY)/20.
         CALL UHTOC(IPA,4,CHTEXT,12)
         CALL GDRAWT(XTEXT,YTEXT,CHTEXT,CSIZE,0.,1,-1)
  210 CONTINUE
C
C             Draw views
C
      CALL GFATT(NAME,'SEEN',KSEEN)
C
C             Add local value SEEN 1 to starting node of tree
C
      KSEEN=KSEEN+110
      ISEEN=KSEEN
      CALL GSATT(NAME,'SEEN',ISEEN)
C
      CALL GSATT(NAME,'COLO',2)
      CALL GDNSON(NAME,NSON,IDIV)
      DO 220 N=1,NSON
         CALL GDSON(N,NAME,ISON)
         CALL GFATT(ISON,'SEEN',KSEEN)
C
C             ISON is a volume with multiplicity;
C             first occurrence has already been set
C
         IF (KSEEN.GT.50) GO TO 220
C
C             Add local value SEEN -2 to each one-level-down node
C
         KSEEN=KSEEN+80
         ISEEN=KSEEN
         CALL GSATT(ISON,'SEEN',ISEEN)
C
         CALL GSATT(ISON,'COLO',4)
  220 CONTINUE
C
      CALL GDCOL(3)
      XSCAL=PLTRNX/4.
      YSCAL=PLTRNY/2.
      CALL GDSCAL(XSCAL,YSCAL)
**    IF (GSCU.LE.0.05) CALL GDMAN(XMAN,YMAN)
      IF (GSCU.LE.0.05) CALL GDWMN1(XMAN,YMAN)
C
      CALL GDRAW(NAME,THE(1),PHI(1),0.,U0(1),V0(1),GSCU,GSCV)
      CALL GDAXIS(0.,0.,0.,AXSIZ)
      CALL GDRAWC(NAME,3,0.005,U0(2),V0(2),GSCU,GSCV)
      CALL GDAXIS(0.,0.,0.,AXSIZ)
      CALL GDRAWC(NAME,1,0.005,U0(3),V0(3),GSCU,GSCV)
      CALL GDAXIS(0.,0.,0.,AXSIZ)
C
  230 CALL GDCOL(0)
C
C             Reset global SEEN values
C
      DO 240 IVO=1,NVOLUM
         CALL UHTOC(IQ(JVOLUM+IVO),4,NAMSEE,4)
         CALL GFATT(NAMSEE,'SEEN',KSEEN)
         IF (KSEEN.LT.50) GO TO 240
         ISEENL=KSEEN/10.+0.5
         ISEENG=KSEEN-ISEENL*10.
         CALL GSATT(NAMSEE,'SEEN',ISEENG)
  240 CONTINUE
C
  250 CONTINUE
C
C             Restore GDRAW calling parameters
C             and ZOOM internal parameters
C
      GTHETA=SAVTHE
      GPHI=SAVPHI
      GPSI=SAVPSI
      GU0=SAVU0
      GV0=SAVV0
      GSCU=SAVSCU
      GSCV=SAVSCV
      NGVIEW=0
      GZUA=SVGZUA
      GZVA=SVGZVA
      GZUB=SVGZUB
      GZVB=SVGZVB
      GZUC=SVGZUC
      GZVC=SVGZVC
      CALL ISELNT(1)
  999 END
+DECK,  GDSSUR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDSSUR(P1,P2,P3,P4)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store space points P1,P2,P3,P4 in vector SURF            *
C.    *       starting from SURF(ISURF)                                *
C.    *                                                                *
C.    *    ==>Called by : GDRWSC                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCVOLU.
      DIMENSION SURF(2)
      EQUIVALENCE (WS(1),SURF(1))
      DIMENSION P1(1),P2(1),P3(1),P4(1),RP1(3),RP2(3),RP3(3),RP4(3)
C
C             MPOINT is maximum number of points that can  be stored;
C             at present MPOINT=(2000-12), because SURF is equivalenced
C             from WS(1) to WS(2000)
C
      SAVE MPOINT
      DATA MPOINT/1988/
C.
C.    ------------------------------------------------------------------
C.
C             Rotation matrix
C
      CALL GINROT(P1(1),GRMAT(1,NLEVEL),RP1(1))
      CALL GINROT(P2(1),GRMAT(1,NLEVEL),RP2(1))
      CALL GINROT(P3(1),GRMAT(1,NLEVEL),RP3(1))
      CALL GINROT(P4(1),GRMAT(1,NLEVEL),RP4(1))
C
C             Translation matrix
C
      DO 10 I=1,3
         RP1(I)=RP1(I)+GTRAN(I,NLEVEL)
         RP2(I)=RP2(I)+GTRAN(I,NLEVEL)
         RP3(I)=RP3(I)+GTRAN(I,NLEVEL)
         RP4(I)=RP4(I)+GTRAN(I,NLEVEL)
   10 CONTINUE
C
C             Store space points
C
      SURF(ISURF)=RP1(1)
      SURF(ISURF+1)=RP1(2)
      SURF(ISURF+2)=RP1(3)
      SURF(ISURF+3)=RP2(1)
      SURF(ISURF+4)=RP2(2)
      SURF(ISURF+5)=RP2(3)
      SURF(ISURF+6)=RP3(1)
      SURF(ISURF+7)=RP3(2)
      SURF(ISURF+8)=RP3(3)
      SURF(ISURF+9)=RP4(1)
      SURF(ISURF+10)=RP4(2)
      SURF(ISURF+11)=RP4(3)
      ISURF=ISURF+12
      NSURF=NSURF+1
C
C             If there is not enough space perform a cut
C             to empty the surface buffer SURF
C
      IF (ISURF.GE.MPOINT) CALL GDCUT
C
      END
+DECK,  GDSTEP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GDSTEP
*
************************************************************************
*                                                                      *
*       RAY-TRACING                                                    *
*       Light processing at the end of each step                       *
*                                                                      *
*       Author: S.Giani.                                               *
*                                                                      *
************************************************************************
*
+CDE, GCTMED.
+CDE, GCKING.
+CDE, GCFLAG.
+CDE, GCTRAK.
********************************************************************************
+CDE, GCBANK.
+CDE, GCVDMA.
+CDE, GCPIXE.
+CDE, GCRAYT.

      DIMENSION PROTU(1),PROTV(1)
      DIMENSION OUT(10)
      DIMENSION CKDIFF(8),CKSPRE(8),NEXPO(8)
      DATA CKDIFF/0.40,0.80,0.50,0.50,0.25,0.25,0.00,0.00/
      DATA CKSPRE/0.00,0.00,0.50,0.50,0.75,0.75,1.00,1.00/
      DATA NEXPO/0,0,2,7,2,7,1,10/
*
*  LSTY keys:
*   0=darkmatt; 1=brightmatt; 2=plastic; 3=ceramic; 4=roughmetal;
*   5=shinymetal; 6=glass; 7=mirror.
*
      SAVE MYMED,APROSH,MYOMED,SPONOR,XYZMOD
********************************************************************************
      BOFLAG=0.
      IF(ISSEEN.EQ.1.OR.ISSEEN.EQ.-2)THEN
      IF(INWVOL.EQ.1.OR.(INWVOL.EQ.3.AND.IOMBRA.EQ.9))THEN
        BOFLAG=1.
                   PROTU(1)=UUU
                   PROTV(1)=VVV
       IF(IOMBRA.NE.9)THEN
       IF(NOFLAG.EQ.0)THEN
         out(1)=veccos(1)*vect(4)+veccos(2)*vect(5)+veccos(3)*vect(6)
         out(2)=veccos(1)
         out(3)=veccos(2)
         out(4)=veccos(3)
         OBSNOR=ABS(OUT(1))
         APROSC=ABS(OUT(1))*CKDIFF(ISLSTY+1)
         if(aprosc.lt.0.)then
            print *,'warning: aprosc.lt.0'
         endif
         IF(ISLSTY.NE.0.AND.ISLSTY.NE.1)THEN
           BPROSC=(2.*(OUT(1)**2))-1.
           IF(BPROSC.GT.0.)THEN
             BPROSC=CKSPRE(ISLSTY+1)*(BPROSC**NEXPO(ISLSTY+1))
           ELSE
             BPROSC=0.
           ENDIF
           APROSC=(APROSC+BPROSC)
         ENDIF
       ELSE
         OBSNOR=APFLAG
         APROSC=APFLAG*CKDIFF(ISLSTY+1)
         if(aprosc.lt.0.)then
           print *,'warning: aprosc.lt.0',aprosc
         endif
         IF(ISLSTY.NE.0.AND.ISLSTY.NE.1)THEN
           BPROSC=(2.*(APFLAG**2))-1.
           IF(BPROSC.GT.0.)THEN
             BPROSC=CKSPRE(ISLSTY+1)*(BPROSC**NEXPO(ISLSTY+1))
           ELSE
             BPROSC=0.
           ENDIF
           APROSC=(APROSC+BPROSC)
         ENDIF
       ENDIF
       ENDIF
       IF(IOMBRA.EQ.10)THEN
         XYZMOD=1./SQRT((XLPOS-VECT(1))**2+(YLPOS-VECT(2))**2+
     +                  (ZLPOS-VECT(3))**2)
         IF(NOFLAG.EQ.0)THEN
*         call ggperp(vect,veccos,ierr)
*         if(ierr.eq.1)then
*           veccos(1)=1.
*           veccos(2)=0.
*           veccos(3)=0.
*         endif
         out(1)=veccos(1)*vect(4)+veccos(2)*vect(5)+veccos(3)*vect(6)
         out(2)=veccos(1)
         out(3)=veccos(2)
         out(4)=veccos(3)
          XLDIR=(XLPOS-VECT(1))*XYZMOD
          YLDIR=(YLPOS-VECT(2))*XYZMOD
          ZLDIR=(ZLPOS-VECT(3))*XYZMOD
          APROSH=((OUT(2)*XLDIR)+(OUT(3)*YLDIR)+(OUT(4)*ZLDIR))*
     +    CKDIFF(ISLSTY+1)
          SPONOR=APROSH/CKDIFF(ISLSTY+1)
          IF(ISLSTY.NE.0.AND.ISLSTY.NE.1)THEN
          IF(SPONOR.GT.0.)THEN
            B1=OUT(4)*YLDIR-OUT(3)*ZLDIR
            B2=OUT(2)*ZLDIR-OUT(4)*XLDIR
            B3=OUT(3)*XLDIR-OUT(2)*YLDIR
            VRX=OUT(4)*B2-OUT(3)*B3+OUT(2)*SPONOR
            VRY=OUT(2)*B3-OUT(4)*B1+OUT(3)*SPONOR
            VRZ=OUT(3)*B1-OUT(2)*B2+OUT(4)*SPONOR
            COSB1=VRX*XCOSXS+VRY*YCOSYS+VRZ*ZCOSZS
            IF(COSB1.GT.0.)THEN
              BPROSH=CKSPRE(ISLSTY+1)*(COSB1**NEXPO(ISLSTY+1))
*              print *,COSB1**ISLSTY
            ELSE
              BPROSH=0.
            ENDIF
            APROSH=(APROSH+BPROSH)
          ENDIF
          ENDIF
         ELSE
          SPONOR=APFLAH
          APROSH=APFLAH*CKDIFF(ISLSTY+1)
          IF(ISLSTY.NE.0.AND.ISLSTY.NE.1)THEN
          IF(SPONOR.GT.0.)THEN
            IF(IXYFLA.EQ.1)THEN
              OUT(2)=CCXX(2)
              OUT(3)=CCXX(3)
              OUT(4)=CCXX(4)
            ELSEIF(IXYFLA.EQ.2)THEN
              OUT(2)=CCYY(2)
              OUT(3)=CCYY(3)
              OUT(4)=CCYY(4)
            ELSEIF(IXYFLA.EQ.3)THEN
              OUT(2)=CCZZ(2)
              OUT(3)=CCZZ(3)
              OUT(4)=CCZZ(4)
            ELSE
              print *,'problem for ixyfla'
            ENDIF
            B1=OUT(4)*YLDIR-OUT(3)*ZLDIR
            B2=OUT(2)*ZLDIR-OUT(4)*XLDIR
            B3=OUT(3)*XLDIR-OUT(2)*YLDIR
            VRX=OUT(4)*B2-OUT(3)*B3+OUT(2)*SPONOR
            VRY=OUT(2)*B3-OUT(4)*B1+OUT(3)*SPONOR
            VRZ=OUT(3)*B1-OUT(2)*B2+OUT(4)*SPONOR
            COSB1=VRX*XCOSXS+VRY*YCOSYS+VRZ*ZCOSZS
            IF(COSB1.GT.0.)THEN
              BPROSH=CKSPRE(ISLSTY+1)*(COSB1**NEXPO(ISLSTY+1))
*              print *,COSB1**ISLSTY
            ELSE
              BPROSH=0.
            ENDIF
            APROSH=(APROSH+BPROSH)
          ENDIF
          ENDIF
         ENDIF
       ENDIF
       SAVMED=NUMED
       IF(IOMBRA.EQ.10)MYOMED=ISCOLO
       IF(IOMBRA.NE.9)THEN
           CALL GDLUMI(ISCOLO,APROSC)
       ENDIF
       IF(IOMBRA.NE.9.AND.IOMBRA.NE.10)THEN
        IF(IMAP.EQ.1)THEN
         JON=1
        ELSE
**         IF(ISWIT(9).NE.54321)THEN
          CALL IPM(1,PROTU,PROTV)
**         ELSE
**          CALL IXPIXEL(IXXX,IYYY,ICOLOR)
**         ENDIF
        ENDIF
       ELSEIF(IOMBRA.EQ.10)THEN
         MYMED=ISCOLO
       ELSEIF(IOMBRA.EQ.9)THEN
         IF((INWVOL.EQ.3.AND.SPONOR.GT.0.).OR.(INWVOL.EQ.1.AND.
     +       SPONOR.GT.0..AND.SLENG.GE.(1./XYZMOD)))THEN
           CALL GDLUMI(MYOMED,APROSH)
           SINTEN=INTEN*.1
           FINMED=((1.-SINTEN)*MYMED)+(SINTEN*MYOMED)
           MEDFIN=FINMED
           IF((FINMED-MEDFIN).GT..5)MEDFIN=MEDFIN+1
           CALL ISPMCI(MEDFIN)
           CALL IPM(1,PROTU,PROTV)
           IF(INWVOL.EQ.3.AND.SPONOR.GT.0.)IOMBRA=10
         ELSE
          SINTEN=INTEN*.1
           IF(MYOMED.EQ.2)THEN
            MYOMED=17
           ELSEIF(MYOMED.EQ.3)THEN
            MYOMED=67
           ELSEIF(MYOMED.EQ.4)THEN
            MYOMED=117
           ELSEIF(MYOMED.EQ.5)THEN
            MYOMED=42
           ELSEIF(MYOMED.EQ.6)THEN
            MYOMED=142
           ELSEIF(MYOMED.EQ.7)THEN
            MYOMED=92
           ENDIF
           FINMED=((1.-SINTEN)*MYMED)+(SINTEN*MYOMED)
           MEDFIN=FINMED
           IF((FINMED-MEDFIN).GT..5)MEDFIN=MEDFIN+1
           CALL ISPMCI(MEDFIN)
           CALL IPM(1,PROTU,PROTV)
           IF(INWVOL.EQ.3.AND.SPONOR.LE.0.)IOMBRA=10
         ENDIF
       ENDIF
       NUMED=SAVMED
      ENDIF
      ENDIF
********************************************************************************
*
      END
+DECK,  GDSURF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDSURF(N)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the N-th surface described by the 4 space points    *
C.    *       stored in vector SURF starting from address 12*(N-1)+1   *
C.    *                                                                *
C.    *    ==>Called by : (not called yet)                             *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      DIMENSION SURF(2)
      EQUIVALENCE (WS(1),SURF(1))
      DIMENSION P(3,4),U(5),V(5)
C.
C.    ------------------------------------------------------------------
C.
      IADR=12*(N-1)+1
C
      DO 10  I=1,4
         P(1,I)=SURF(IADR)
         P(2,I)=SURF(IADR+1)
         P(3,I)=SURF(IADR+2)
         IADR=IADR+3
   10 CONTINUE
C
      CALL GDFR3D(P,4,U,V)
      U(5)=U(1)
      V(5)=V(1)
      CALL GDRAWV(U,V,5)
      END
+DECK,  GDTHRZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTHRZ(XYZ)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine processing R-Z projection of tracks and hits     *
C.    *                                                                *
C.    *       XYZ    = Array of X,Y,Z coordinates (input/output)       *
C.    *                                                                *
C.    *    ==>Called by : GDFR3D                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCFLAG.
+CDE, GCNUM.
      DIMENSION XYZ(3),ITRSGN(20),ITRFLG(20)
      LOGICAL BTEST
      SAVE MAXITR,EPS,LIDEVT,LITR3D,ITRSGN,ITRFLG,IFACT
      DATA MAXITR/20/,EPS/0.0001/,LIDEVT/0/
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('360 ',I360,4,4)
C
C             If ITHRZ='ON  ' or '180 ' then use positive or negative ra
C             else if ITHRZ='360 ' then use only positive radius
C
      IF (ITHRZ.EQ.I360) THEN
         XYZ(2)=SQRT(XYZ(2)*XYZ(2)+XYZ(3)*XYZ(3))
         GO TO 999
      ENDIF
C
C             IDEVT  = Event number (in common GCFLAG)
C             LIDEVT = Last event number
C
      IF (IDEVT.NE.LIDEVT) THEN
         DO 10 I=1,MAXITR
            ITRSGN(I)=0
            ITRFLG(I)=0
   10    CONTINUE
         LIDEVT=IDEVT
      ENDIF
C
C             NBIT   = Number of bit per machine word (in common GCNUM)
C             MAXITR = A maximum of NBIT*MAXITR significant track signs
C                      can be stored (after that all signs will be posit
C             IWORD  = 1,2,...,MAXITR
C             IOFSET = 0,1,...,NBIT-1
C
      IWORD=(IABS(ITR3D)/NBIT)+1
      IOFSET=MAX(MOD(IABS(ITR3D),NBIT)-1,0)
C
      IF (IWORD.GT.MAXITR) THEN
         IFACT=1
         XYZ(2)=IFACT*SQRT(XYZ(2)*XYZ(2)+XYZ(3)*XYZ(3))
         GO TO 999
      ENDIF
C
C             If being drawing an hit, with sign already
C             set by previous track, then use that sign
C
      IF (IOBJ.EQ.3.AND.BTEST(ITRFLG(IWORD),IOFSET)) THEN
         IF(BTEST(ITRSGN(IWORD),IOFSET)) THEN
            IFACT=1
         ELSE
            IFACT=-1
         ENDIF
         XYZ(2)=IFACT*SQRT(XYZ(2)*XYZ(2)+XYZ(3)*XYZ(3))
         GO TO 999
      ENDIF
C
      IF (ITR3D.LT.0) THEN
C
C             First call to GDFR3D/GDTHRZ : initialize LITR3D and make I
C
         ITR3D=-ITR3D
         IF (.NOT.BTEST(ITRFLG(IWORD),IOFSET)) THEN
            ITRFLG(IWORD) = IBSET(ITRFLG(IWORD),IOFSET)
            LITR3D=0
         ENDIF
      ENDIF
C
      IF (ITR3D.GT.0) THEN
C
C             LITR3D contains the last ITR3D value,
C             or zero if last point was at U-V origin (0,0,...)
C
         IF (ITR3D.EQ.LITR3D) THEN
C
C             Old track : get R sign from ITRSGN into IFACT
C
            IF(BTEST(ITRSGN(IWORD),IOFSET)) THEN
               IFACT=1
            ELSE
               IFACT=-1
            ENDIF
C
         ELSE
C
C             New track : set R sign into ITRSGN and IFACT
C
            IF (ABS(XYZ(2)).GT.EPS) THEN
               IF (XYZ(2)/ABS(XYZ(2)).GT.0.) THEN
                  ITRSGN(IWORD) = IBSET(ITRSGN(IWORD),IOFSET)
                  IFACT=1
               ELSE
                  ITRSGN(IWORD) = IBCLR(ITRSGN(IWORD),IOFSET)
                  IFACT=-1
               ENDIF
            ENDIF
C
            LITR3D=ITR3D
            IF ((ABS(XYZ(1)).LT.EPS).AND.(ABS(XYZ(2)).LT.EPS)) LITR3D=0
C
         ENDIF
C
   20    CONTINUE
         XYZ(2)=IFACT*SQRT(XYZ(2)*XYZ(2)+XYZ(3)*XYZ(3))
C
      ENDIF
  999 RETURN
      END
+DECK,  GDTR0, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR0(IVTREE,IROOT,LEVMAX,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Steering routine to build geometric structure tree       *
C.    *       (starting from JVOLUM structure until to have an         *
C.    *       optimized tree on IQ(JNAM1),IQ(JBRO1),etc.)              *
C.    *                                                                *
C.    *       IVTREE= view bank used to store tree structure (input)   *
C.    *       IROOT = root of the tree to be built up (input)          *
C.    *       IER   = error flag to detect nodes overflow (output)     *
C.    *                                                                *
C.    *    ==>Called by : GDFSPC, GDTREE                               *
C.    *       Author : P.Zanarini   *********                          *
C.    *       Revised: S.Giani      *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCDRAW.
      COMMON/GCLOCA/NLOCAL(2),JLOCA(19),JV
      COMMON /QUEST/ IQUEST(100)
      CHARACTER*4 NAMZ(16)
      SAVE NAMZ
      DATA NAMZ/'DNAM','DMOT','DXON','DBRO','DDUP','DSCA','DDVM','DPSM',
     +          'DNA1','DMO1','DXO1','DBR1','DDU1','DSC1','DUUU','DVVV'/
C.
C.    ------------------------------------------------------------------
C.
      IF (IVTREE.LE.NKVIEW.AND.LQ(JDRAW-IVTREE).NE.0) THEN
         Q(JDRAW+IVTREE)=1.
         CALL GDELET(IVTREE)
      ELSEIF (IVTREE.GT.NKVIEW) THEN
         NDL=IVTREE-NKVIEW
         CALL MZNEED(IXCONS,2*NDL,'G')
         IF(IQUEST(11).LT.0) GOTO 50
         CALL MZPUSH(IXCONS,JDRAW,NDL,NDL,'I')
         DO 10 I=NKVIEW+1,IVTREE-1
            Q(JDRAW+I)=1.
   10    CONTINUE
         NKVIEW=IVTREE
      ENDIF
C
C             Open view number IVTREE
C
      Q(JDRAW+IVTREE)=3.
      CALL MZBOOK(IXCONS,JV,JDRAW,-IVTREE,'DTRE',16,16,0,3,0)
      IF (JV.EQ.0) GO TO 40
*
      MAXNOD=16000
   20 ND=(10+MAXNOD)*16
      LLL=50+ND
      CALL MZNEED(IXCONS,LLL,'G')
      IQUEST(1)=0
      IF (IQUEST(11).LT.0) THEN
         MAXNOD=MAXNOD*0.9
         GO TO 20
      ENDIF
***   PRINT *,'NEW MAXNOD',MAXNOD
*
      DO 30 I=1,16
         CALL MZBOOK(IXCONS,LBANK,JV,-I,NAMZ(I),0,0,MAXNOD,3,0)
         JV=LQ(JDRAW-IVTREE)
         IF (LBANK.EQ.0) GO TO 40
   30 CONTINUE
C
      GO TO 60
C
   40 WRITE (CHMAIL,10000)
      CALL GMAIL(0,0)
      GO TO 999
C
   50 WRITE (CHMAIL,10100)
      CALL GMAIL(0,0)
      GO TO 999
C
   60 CONTINUE
C
C             1. Scan JVOLUM banks and build non-optimized tree structur
C                with arrays of pointers JNAM,JMOT,JXON,JBRO,JDUP,JDVM
C                Note : IQ(JDUP) is set >0 for multiplicity by positioni
C                       (normal case is 1); IQ(JDVM) is set <0 for
C                       multiplicity by dividing (or 0 if not)
C
C             2. Scan non-optimized tree and build optimized tree,
C                with arrays of pointers JNAM1,JMOT1,JXON1,JBRO1,JDUP1
C                Note : IQ(JDUP1) is set >0 for multiplicity by position
C                       or <0 for multiplicity by dividing (normal case
C
C
C             I = node pointer
C
C             IQ(JNAM+I) = node name (in non-optimized tree)
C             IQ(JMOT+I) = mother (or 0 if top of tree)
C             IQ(JXON+I) = first son (or 0 if any)
C             IQ(JBRO+I) = next brother (or 0 if any)
C             IQ(JDUP+I) = multiplicity (<0 for div. or >0 for pos.)
C             IQ(JSCA+I) = service word (scan flag, etc.)
C             IQ(JDVM+I) = division multiplicity (>0 for div. or 0 for n
C             IQ(JPSM+I) = position multiplicity (>1 for pos. or 1 for d
C
C             IQ(JNAM1+I) = node name (in optimized tree)
C             IQ(JMOT1+I) = mother (or 0 if top of tree)
C             IQ(JXON1+I) = first son (or 0 if any)
C             IQ(JBRO1+I) = next brother (or 0 if any)
C             IQ(JDUP1+I) = multiplicity (<0 for div. or >0 for pos.)
C             IQ(JSCA1+I) = service word (scan flag, etc.)
C             IQ(JULEV+I) = u-coordinate of the node in the tree
C             IQ(JVLEV+I) = v-coordinate of the node in the tree
C
      JNAM=LQ(JV-1)
      JMOT=LQ(JV-2)
      JXON=LQ(JV-3)
      JBRO=LQ(JV-4)
      JDUP=LQ(JV-5)
      JSCA=LQ(JV-6)
      JDVM=LQ(JV-7)
      JPSM=LQ(JV-8)
      JNAM1=LQ(JV-9)
      JMOT1=LQ(JV-10)
      JXON1=LQ(JV-11)
      JBRO1=LQ(JV-12)
      JDUP1=LQ(JV-13)
      JSCA1=LQ(JV-14)
      JULEV=LQ(JV-15)
      JVLEV=LQ(JV-16)
C
      DO 70  J=1,MAXNOD
         IQ(JSCA+J)=0
         IQ(JPSM+J)=1
         IQ(JDUP+J)=0
   70 CONTINUE
C
C             Scan JVOLUM banks and build non-optimized tree structure
C
C      WRITE (CHMAIL,5001)
C      CALL GMAIL(0,0)
      CALL GDTR2(IROOT,JMAX,LEVMAX,IER)
      IF (IER.NE.0) GO TO 999
      NUMNOD=JMAX
C
C             Scan non-optimized tree and build optimized tree
C
C      WRITE (CHMAIL,5002)
C      CALL GMAIL(0,0)
      CALL GDTR4
C      WRITE (CHMAIL,5003)
C      CALL GMAIL(0,0)
      CALL GDTR6(JMAX)
      NUMND1=JMAX
C
C      WRITE (CHMAIL,1500) NLEFT,MAXNOD,NUMNOD,NUMND1
C      CALL GMAIL(0,0)
C
10000 FORMAT (' ERROR IN GDTR0: MEMORY OVERFLOW IN CREATING A BANK')
10100 FORMAT (' ERROR IN GDTR0: MEMORY OVERFLOW IN PUSHING A BANK')
C
  999 END
+DECK,  GDTR1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR1(JM,J1,J2,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Scan one level of JVOLUM structure                       *
C.    *                                                                *
C.    *       JM = mother node (input)                                 *
C.    *       J1 = starting node (input)                               *
C.    *       J2 = ending node (output)                                *
C.    *       IER  = error flag to detect nodes overflow (output)      *
C.    *                                                                *
C.    *    ==>Called by : GDTR2                                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
      CHARACTER*4 NAME, ISON
      DIMENSION N(50),IH(50)
      SAVE NUMCHK,MAXCHK
      DATA NUMCHK/4/,MAXCHK/50/
C.
C.    ------------------------------------------------------------------
C.
      IER=0
C
      IF (NUMCHK.GT.MAXCHK) GO TO 140
C
      CALL UHTOC (IQ(JNAM+JM), 4, NAME, 4)
      CALL GDNSON (NAME, NXONS, MUL)
      IF (NXONS.EQ.0) THEN
         IQ(JXON+JM)=0
         J2=J1
      ELSE
         J2=J1+1
         IQ(JXON+JM)=J2
         CALL UHTOC (IQ(JNAM+JM), 4, NAME, 4)
         CALL GDSON (1, NAME, ISON)
         CALL UCTOH (ISON, LXON, 4, 4)
         LOXON=LXON
         IQ(JNAM+J2)=LXON
         IQ(JMOT+J2)=JM
         IF (NXONS.GT.1) THEN
            IF (J2+NXONS.GE.MAXNOD) GO TO 130
C
            JSAV=J2
C
            DO 10 I=2,NXONS
               CALL UHTOC (IQ(JNAM+JM), 4, NAME, 4)
               CALL GDSON (I, NAME, ISON)
               CALL UCTOH (ISON, LXON, 4, 4)
               IF (LXON.NE.LOXON) THEN
                  LOXON=LXON
                  J=J2+1
                  IQ(JBRO+J2)=J
                  IQ(JNAM+J)=LXON
                  IQ(JMOT+J)=JM
                  J2=J
               ELSE
                  IQ(JPSM+J2)=IQ(JPSM+J2)+1
               ENDIF
   10       CONTINUE
C
            DO 20 K=JSAV,J2
               CALL UHTOC (IQ(JNAM+K), 4, NAME, 4)
               CALL GFATT (NAME, 'SEEN', KVAL)
               IF (KVAL.EQ.-3) GO TO 30
   20       CONTINUE
C
            GO TO 120
C
   30       I=JSAV
C
   40       CONTINUE
C
            DO 50  K=1,NUMCHK
               N(K)=IQ(JNAM+I+K-1)
               IH(K)=N(K)/65536
+SELF, IF=VAX,MSDOS,WINNT.
               IH(K)=N(K)-IH(K)*65536
+SELF.
               IF (IH(1).NE.IH(K)) GO TO 90
   50       CONTINUE
            DO 70  K=1,NUMCHK
               DO 60  KK=K+2,NUMCHK
                  IF (IQ(JNAM+K).EQ.IQ(JNAM+KK)) GO TO 90
   60          CONTINUE
   70       CONTINUE
            DO 80  K=I+2,J2
               IQ(JNAM+K-1)=IQ(JNAM+K)
   80       CONTINUE
            J2=J2-1
            IQ(JPSM+I+1)=IQ(JPSM+I+1)+1
            GO TO 100
   90       CONTINUE
            I=I+1
  100       CONTINUE
C
            IF (J2.GT.I+NUMCHK-2) GO TO 40
C
            DO 110 K=JSAV+1,J2-1
            IF (IQ(JPSM+K).GT.1) CALL UCTOH('    ',IQ(JNAM+K),4,4)
  110       CONTINUE
C
  120       CONTINUE
C
         ENDIF
         IQ(JBRO+J2)=0
      ENDIF
      IQ(JSCA+JM)=1
      GO TO 999
  130 WRITE (CHMAIL,1000) MAXNOD
      CALL GMAIL(0,0)
      IER=1
      GO TO 999
  140 WRITE (CHMAIL,1100)
      CALL GMAIL(0,0)
      IER=1
 1000 FORMAT (' GDTR1 : MAXNOD = ',I5,' - TREE OVERFLOW')
 1100 FORMAT (' GDTR1 : NUMCHK > MAXCHK - TREE NOT EXECUTED')
  999 RETURN
      END
+DECK,  GDTR10, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR10(JNODE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Plot tree structure from JNODE                           *
C.    *                                                                *
C.    *       JNODE = starting node of tree scanning (input)           *
C.    *                                                                *
C.    *    ==>Called by : GDTREE                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
C.
      J=JNODE
      IDIR=1
   10 CONTINUE
      IF (IDIR.EQ.1) THEN
         CALL GDTR11(J,IDIR,JNODE)
         GO TO 10
      ELSE IF (IDIR.EQ.2) THEN
   20    JB=IQ(JBRO1+J)
         IF (JB.EQ.0) THEN
            J=IQ(JMOT1+J)
            IF (J.EQ.0) GO TO 999
            LEVVER=LEVVER-1
            JJ=-J
            CALL GDTR12(JJ)
            IF (J.EQ.JNODE) GO TO 999
            GO TO 20
         ELSE
            J=JB
            CALL GDTR11(J,IDIR,JNODE)
            GO TO 10
         ENDIF
      ELSE
         GO TO 999
      ENDIF
  999 RETURN
      END
+DECK,  GDTR11, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR11(J,IDIR,JNODE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Down a node on the tree                                  *
C.    *                                                                *
C.    *       J = node pointer (input/output)                          *
C.    *       IDIR = direction of search; IDIR=1 for down              *
C.    *              and IDIR=2 for right (input/output)               *
C.    *       JNODE = starting node of tree scanning (input)           *
C.    *                                                                *
C.    *    ==>Called by : GDTR10                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
C.
      JX=IQ(JXON1+J)
      IF (LEVVER.EQ.MAXV) JX=0
      IF (JX.EQ.0) THEN
         CALL GDTR12(J)
         IF (J.EQ.JNODE) THEN
            IDIR=0
         ELSE
            JB=IQ(JBRO1+J)
            IF (JB.EQ.0) THEN
               JM=IQ(JMOT1+J)
               LEVVER=LEVVER-1
               IF (JM.EQ.0) THEN
                  IDIR=0
               ELSE
                  J=JM
                  JJ=-J
                  CALL GDTR12(JJ)
                  IF (J.EQ.JNODE) THEN
                     IDIR=0
                  ELSE
                     IDIR=2
                  ENDIF
               ENDIF
            ELSE
               J=JB
               IDIR=1
            ENDIF
         ENDIF
      ELSE
         LEVVER=LEVVER+1
         MLEVV=MAX(MLEVV,LEVVER)
         J=JX
         IDIR=1
      ENDIF
      END
+DECK,  GDTR12, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR12(JJ)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Plot a node of the tree                                  *
C.    *                                                                *
C.    *       JJ = node pointer; negative when tree is being           *
C.    *            scanned from bottom to up; positive when            *
C.    *            it is scanned top to bottom or left to right        *
C.    *            (input)                                             *
C.    *                                                                *
C.    *    ==>Called by : GDTR10, GDTR11                               *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
C.
      J=IABS(JJ)
      IQ(JSCA1+J)=1
      IF (LEVVER.EQ.MAXV.AND.IQ(JXON1+J).NE.0) IQ(JSCA1+J)=-1
      IF (JJ.GT.0) THEN
         LEVHOR=LEVHOR+1
         Q(JULEV+J)=LEVHOR
      ELSE
         JX=IQ(JXON1+J)
         UL=Q(JULEV+JX)
   10    JB=JX
         JX=IQ(JBRO1+JB)
         IF (JX.NE.0) GO TO 10
         UR=Q(JULEV+JB)
         Q(JULEV+J)=(UL+UR)/2.
      ENDIF
      Q(JVLEV+J)=LEVVER
      END
+DECK,  GDTR2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR2(IROOT,JMAX,LEVMAX,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Scan all JVOLUM structure                                *
C.    *                                                                *
C.    *       IROOT = root of the tree to be built up (input)          *
C.    *       JMAX = total number of nodes (output)                    *
C.    *       LEVMAX = maximum number of levels to be scanned          *
C.    *       IER  = error flag to detect nodes overflow (output)      *
C.    *                                                                *
C.    *    ==>Called by : GDTR0                                        *
C.    *       Authors : P.Zanarini, S.Banerjee   *********             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCBANK.
+CDE, GCNUM.
C.
C.    ------------------------------------------------------------------
C.
      IER=0
C
      IQ(JNAM+1)=IROOT
      IQ(JMOT+1)=0
      IQ(JBRO+1)=0
      J=1
      JMAX=1
      LNOD=1
      LMAX=1
   10 CONTINUE
      IF (IQ(JSCA+J).EQ.0) THEN
         CALL GDTR1(J,JMAX,JNEW,IER)
         IF (IER.NE.0) GO TO 999
C
C             Fill array IQ(JDVM+I) for multiplicity by divisioning
C
         JJ=IQ(JMOT+J)
         IF (JJ.EQ.0) THEN
            IQ(JDVM+J)=0
         ELSE
            IVO=IUCOMP(IQ(JNAM+JJ),IQ(JVOLUM+1),NVOLUM)
            JVO=LQ(JVOLUM-IVO)
            NIN=Q(JVO+3)
            IF (NIN.LT.0) THEN
               JIN=LQ(JVO-1)
               IQ(JDVM+J)=ABS(Q(JIN+3))
            ELSE
               IQ(JDVM+J)=0
            ENDIF
         ENDIF
C
         JMAX=MAX(JMAX,JNEW)
         IF (JMAX.GT.MAXNOD) GO TO 20
      ENDIF
      J=J+1
*
***   IF (J.LE.JMAX) GO TO 10
*
      IF (J.LE.LMAX) THEN
         GO TO 10
      ELSE
         LNOD=LNOD+1
         IF (LNOD.GT.LEVMAX.AND.LEVMAX.GT.0) GO TO 999
         LMAX=JMAX
         IF (J.LE.JMAX) GO TO 10
      ENDIF
*
      GO TO 999
   20 WRITE (CHMAIL,1000) MAXNOD
      CALL GMAIL(0,0)
      IER=1
 1000 FORMAT (' GDTR2 : MAXNOD = ',I5,' - TREE OVERFLOW')
  999 RETURN
      END
+DECK,  GDTR3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR3(JM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Collect multiplicity for one level of JVOLUM structure   *
C.    *                                                                *
C.    *       JM = mother node (input)                                 *
C.    *                                                                *
C.    *    ==>Called by : GDTR4                                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      JX=IQ(JXON+JM)
      IF (JX.NE.0) THEN
   10    CONTINUE
         JXX=IQ(JXON+JM)
         IF (IQ(JSCA+JX).EQ.0) THEN
   20       CONTINUE
            IF (JXX.EQ.0) GO TO 30
            IF (IQ(JNAM+JXX).EQ.IQ(JNAM+JX)) THEN
***             IQ(JDUP+JX)=IQ(JDUP+JX)+1
               IQ(JDUP+JX)=IQ(JDUP+JX)+IQ(JPSM+JXX)
               IQ(JSCA+JXX)=-1
            ENDIF
            JXX=IQ(JBRO+JXX)
            GO TO 20
   30       CONTINUE
         ENDIF
         JX=IQ(JBRO+JX)
         IF (JX.NE.0) GO TO 10
      ENDIF
      IQ(JSCA+JM)=1
      END
+DECK,  GDTR4, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR4
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Collect multiplicity for all JVOLUM structure            *
C.    *                                                                *
C.    *    ==>Called by : GDTR0                                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      DO 10 J=1,NUMNOD
         IQ(JSCA+J)=0
         IQ(JDUP+J)=0
   10 CONTINUE
      IQ(JDUP+1)=1
      DO 30 J=1,NUMNOD
         IF (IQ(JSCA+J).EQ.0) THEN
            CALL GDTR3(J)
            DO 20 I=J,NUMNOD
               IF (IQ(JSCA+I).EQ.-1) IQ(JSCA+I)=0
   20       CONTINUE
         ENDIF
   30 CONTINUE
      END
+DECK,  GDTR5, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:28  cernlib
* Geant

      SUBROUTINE GDTR5(JM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Build one level of optimized tree                        *
C.    *                                                                *
C.    *       JM = mother node (input)                                 *
C.    *                                                                *
C.    *    ==>Called by : GDTR6                                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      JM1=IQ(JSCA+JM)
      JX=IQ(JXON+JM)
      JX1=IQ(JSCA+JX)
C
C             Copy multiplicity from non-optimized to optimized tree
C
      IF (IQ(JDVM+JM).GT.0) THEN
         IQ(JDUP1+JM1)=-IQ(JDVM+JM)
      ELSE
***     IQ(JDUP1+JM1)=IQ(JDUP+JM)*IQ(JPSM+JM)
         IQ(JDUP1+JM1)=IQ(JDUP+JM)
      ENDIF
C
      IF (JX.EQ.0) THEN
         IQ(JXON1+JM1)=0
      ELSE
         IQ(JXON1+JM1)=JX1
         LXON=IQ(JNAM+JX)
         IQ(JNAM1+JX1)=LXON
         IQ(JMOT1+JX1)=JM1
         LBRO=IQ(JBRO+JX)
   10    IF (LBRO.EQ.0) GO TO 20
         IF (IQ(JDUP+LBRO).NE.0) THEN
            LBRO1=IQ(JSCA+LBRO)
            LXON=IQ(JNAM+LBRO)
            IQ(JBRO1+JX1)=LBRO1
            IQ(JNAM1+LBRO1)=LXON
            IQ(JMOT1+LBRO1)=JM1
            JX1=LBRO1
         ENDIF
         LBRO=IQ(JBRO+LBRO)
         GO TO 10
   20    CONTINUE
         IQ(JBRO1+JX1)=0
      ENDIF
      END
+DECK,  GDTR6, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDTR6(JMAX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Build all optimized tree                                 *
C.    *                                                                *
C.    *       JMAX = total number of nodes (output)                    *
C.    *                                                                *
C.    *    ==>Called by : GDTR0                                        *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
C.
      DO 10 J=1,NUMNOD
         IQ(JSCA+J)=0
   10 CONTINUE
      JNEW=0
      DO 40 J=1,NUMNOD
         IF (IQ(JDUP+J).EQ.0) THEN
            JX=IQ(JXON+J)
            IF (JX.NE.0) THEN
               IQ(JDUP+JX)=0
               JB=IQ(JBRO+JX)
   20          IF (JB.EQ.0) GO TO 30
               IQ(JDUP+JB)=0
               JB=IQ(JBRO+JB)
               GO TO 20
   30          CONTINUE
            ENDIF
         ELSE
            JNEW=JNEW+1
            IQ(JSCA+J)=JNEW
         ENDIF
   40 CONTINUE
      JMAX=JNEW
      IQ(JNAM1+1)=IQ(JNAM+1)
      IQ(JMOT1+1)=0
      IQ(JBRO1+1)=0
      DO 50 J=1,NUMNOD
         IF (IQ(JSCA+J).NE.0) CALL GDTR5(J)
   50 CONTINUE
      END
+DECK,  GDTR8, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDTR8(NAME,MOTH,IONL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Like routine GFMOTH                                      *
C.    *                                                                *
C.    *       NAME = volume name (input)                               *
C.    *       MOTH = mother name of NAME (output)                      *
C.    *       IONL = 'ONLY' flag (1 for 'ONLY', 0 for 'MANY') (output) *
C.    *                                                                *
C.    *    ==>Called by : GDTREE                                       *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
+CDE, GCBANK.
+CDE, GCNUM.
      CHARACTER*4 NAME,MOTH
C.
C.    ------------------------------------------------------------------
C.
      IONL=1
      CALL GLOOK(NAME,IQ(JNAM1+1),NUMND1,J)
      JM=IQ(JMOT1+J)
      IF (JM.EQ.0) GO TO 999
      CALL UHTOC(IQ(JNAM1+JM),4,MOTH,4)
      CALL GLOOK(MOTH,IQ(JVOLUM+1),NVOLUM,IVOMOT)
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVOSON)
      JVO=LQ(JVOLUM-IVOMOT)
      NIN=Q(JVO+3)
      MNIN=NIN
      IF (NIN.LT.0) MNIN=1
      DO 10 IN=1,MNIN
         JIN=LQ(JVO-IN)
         IVO=Q(JIN+2)
         IF (IVO.EQ.IVOSON) GO TO 20
   10 CONTINUE
      GO TO 999
   20 CONTINUE
      IF (NIN.GT.0) IONL=Q(JIN+8)
  999 RETURN
      END

+DECK,  GDTR99, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDTR99(IVTREE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Delete the tree structure build by GDTR0                 *
C.    *       on the view bank IVTREE                                  *
C.    *                                                                *
C.    *       IVTREE= view bank used to store tree structure (input)   *
C.    *                                                                *
C.    *    ==>Called by : GDFSPC, GDTREE                               *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      IF (NKVIEW.EQ.IVTREE) THEN
         Q(JDRAW+IVTREE)=1.
         CALL MZDROP(IXCONS,LQ(JDRAW-IVTREE),' ')
         NKVIEW=IVTREE-1
      ELSE
         Q(JDRAW+IVTREE)=1.
         CALL GDELET(IVTREE)
      ENDIF
      END
+DECK,  GDTRAK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDTRAK(CHOPTT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store space point VECT in banks JXYZ                     *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    R.Brun, F.Carena  *********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCTRAK.
+CDE, GCPUSH.
+CDE, GCKINE.
+CDE, GCUNIT.
+CDE, GCDRAW.
      PARAMETER (NPOBUF=50)
      CHARACTER*(*) CHOPTT
      CHARACTER*10  CHOPT
      LOGICAL OPTDRW, OPTREM, FIRST
      INTEGER COLO(8), OLDCOL, OLDLIN
      DIMENSION U(NPOBUF),V(NPOBUF),MODE(8)
C
C             MODE(ITRTYP) and COLO(ITRTYP) are used by ISLN and GDCOL
C             ITRTYP (the track type) correspond to :
C
C             ITRTYP  PARTICLE  |       HIGZ         |
C             ----------------------------------------
C                 1   gammas    | dotted      blue   |
C                 2   electrons | solid       red    |
C                 3   neutral   | dot-dashed  black  |
C                 4   hadrons   | solid       red    |
C                 5   muons     | dashed      green  |
C                 6   geantino  | dot-dashed  black  |
C                 7   Cerenkov  | dotted      yellow |
C                 8   Ions      | solid       light b|
C
      SAVE MODE,COLO,FIRST,IOFF,ILINE,OLDCOL,OLDLIN
      DATA MODE /3, 1, 4, 1, 2, 1, 3, 1/
      DATA COLO/4, 2, 1, 2, 3, 1, 6, 5/
      DATA FIRST /.TRUE./
      DATA OLDCOL/ -1 /, OLDLIN / -1 /
*
*     ------------------------------------------------------------------
*
      IF(JXYZ.EQ.0)THEN
*
*  ***         No bank...
*
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
      IF(ITRA.GT.IQ(JXYZ-2)) GOTO 40
*
      JX=LQ(JXYZ-ITRA)
      IF(JX.EQ.0) GOTO 40
*
      CHOPT  = CHOPTT
      CALL CLTOU(CHOPT)
      OPTDRW = INDEX(CHOPT,'D') .NE. 0
      OPTREM = INDEX(CHOPT,'R') .NE. 0
      IF(.NOT.(OPTDRW.OR.OPTREM)) THEN
         OPTDRW = .TRUE.
         OPTREM = .TRUE.
      ENDIF
*
      IF (FIRST) THEN
         CALL UCTOH('OFF ',IOFF,4,4)
         CALL UCTOH('LINE',ILINE,4,4)
         FIRST  = .FALSE.
      ENDIF
*
      IF (OPTDRW) THEN
*
*  ***        Draw the current track
*
         IPOINT = JX+Q(JX+2)
         NPOINT = Q(IPOINT)
         IPART  = Q(IPOINT+1)
         JPA    = LQ(JPART-IPART)
         ITRTYP = Q(JPA+6)
*
*  ***        Line style and color code
*
         IMOD   = MODE(ITRTYP)
         ICOL   = COLO(ITRTYP)
         IF(ICOL.NE.OLDCOL) THEN
            CALL GDCOL(ICOL)
            CALL GDCOL1(ICOL)
            OLDCOL=ICOL
         ENDIF
*
         NDONE  = 0
   10    NDO    = MIN(NPOINT-NDONE,NPOBUF)
         IF (NDO.GT.0) THEN
*
*            Is THRZ option set on (R-Z projection)
*            and the cut lateral (vertical or horizontal) ?
*
            IF (ITHRZ.NE.IOFF) THEN
               IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-ITRA
            ELSE
               ITR3D=0
            ENDIF
*
            CALL GDFR3D(Q(IPOINT+3*NDONE+2),NDO,U,V)
*
            IF (IDVIEW.EQ.0) THEN
               IF (ITRKOP.EQ.ILINE.AND.NDO.GT.1) THEN
                  IF(OLDLIN.NE.IMOD) THEN
                     CALL ISLN(IMOD)
                     OLDLIN=IMOD
                  ENDIF
                  CALL IPL(NDO,U,V)
               ELSE
                  DO 20 IP=1,NDO
                     CALL IPM(1,U(IP),V(IP))
   20             CONTINUE
               ENDIF
*
            ELSE
               CALL GDRAWP(U,V,NDO)
*
            ENDIF
            NDONE = NDONE + NDO
            GOTO 10
         ENDIF
      ENDIF
      IF (OPTREM) THEN
*
* ***      Remove the current track
*
         IPOINT = JX+INT(Q(JX+2))
         Q(JX+1)= Q(JX+1) + 3.*Q(IPOINT)
         Q(IPOINT) = 0.
         IQ(JX) = -77
      ENDIF
      GOTO 999
*
   40 WRITE (CHMAIL,10100) ITRA
      CALL GMAIL(0,0)
*
10000 FORMAT(' *** GDTRAK: No JXYZ bank')
10100 FORMAT(' *** GDTRAK: No points stored for track ',I10)
  999 END
+DECK,  GDTREE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDTREE(KNAME,LEVMAX,ISEL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the tree of geometric data structure starting       *
C.    *       from object KNAME, for LEVMAX depth levels (0=all)       *
C.    *                                                                *
C.    *       If ISEL=      0   then draw only node name;              *
C.    *       if ISEL=xxxxxx1   then add multiplicity;                 *
C.    *       if ISEL=xxxxx1x   then add 'ONLY' information;           *
C.    *       if ISEL=xxxx1xx   then add 'DET ' information;           *
C.    *       if ISEL=xxx1xxx   then add 'SEEN' information;           *
C.    *       if ISEL=xx1xxxx   then add little picture of volume;     *
C.    *       if ISEL=x1xxxxx   then add graphics cursor and           *
C.    *                         returns in IPICK the node picked;      *
C.    *                                                                *
C.    *       For very big trees, the attribute SEEN -3 can be applied *
C.    *       to any node in the level that has too many different     *
C.    *       nodes (each with a different volume name) : the routine  *
C.    *       GDTREE will draw only the first, the last, and one       *
C.    *       dummy node in the middle that tells how many nodes       *
C.    *       does it stand for.                                       *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Authors : P.Zanarini ; S.Giani  *********                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCDRAW.
+CDE, GCHIL2.
+CDE, GCCURS.
+CDE, GCURSB.
*
      CHARACTER*4 KNAME,NAME,NAME1,MOTH
      DIMENSION U(4),V(4),UUU(15),VVV(15),SVVX(3),SVVY(3)
      SAVE SAVTHE,SAVPHI,SAVU0,SAVV0,SAVSCU,SAVSCV,SVGZUA,SVGZVA
      SAVE SVGZUB,SVGZVB,SVGZUC,SVGZVC
      COMMON/NPILEV/NPILE

C.
C.    ------------------------------------------------------------------
C.
C             Is NAME an existing volume ?
C
*      CALL IGSET('SYNC',1.)
      IF (MOMO.EQ.' ') THEN
         CALL UHTOC(IQ(JVOLUM+1),4,NAME,4)
         MOMO=NAME
      ENDIF
      IF (KNAME.EQ.' ') THEN
         CALL UHTOC(IQ(JVOLUM+1),4,NAME,4)
         KNAME=NAME
      ELSE
         CALL GLOOK(KNAME,IQ(JVOLUM+1),NVOLUM,IVO)
         IF (IVO.LE.0) GO TO 180
         NAME=KNAME
      ENDIF
C
C             Build tree structure using view bank 11
C
      IVTREE=NKVIEW+1
      CALL UCTOH (NAME, IROOT, 4, 4)
      CALL GDTR0 (IVTREE, IROOT, LEVMAX, IER)
      IF (IER.NE.0) GO TO 170
C
      IPICK=0
C
      ISEL5=ISEL/100000
      ISEL5=ISEL5-ISEL5/2*2
      ISEL4=ISEL/10000
      ISEL4=ISEL4-ISEL4/2*2
      ISEL3=ISEL/1000
      ISEL3=ISEL3-ISEL3/2*2
      ISEL2=ISEL/100
      ISEL2=ISEL2-ISEL2/2*2
      ISEL1=ISEL/10
      ISEL1=ISEL1-ISEL1/2*2
      ISEL0=ISEL/1
      ISEL0=ISEL0-ISEL0/2*2
C
C             Save GDRAW calling parameters
C             and ZOOM internal parameters
C
      IDRAW=0
      IF (ISEL4.NE.0) THEN
         IDRAW=1
         SAVTHE=GTHETA
         SAVPHI=GPHI
         SAVU0=GU0
         SAVV0=GV0
         SAVSCU=GSCU
         SAVSCV=GSCV
         SVGZUA=GZUA
         SVGZVA=GZVA
         SVGZUB=GZUB
         SVGZVB=GZVB
         SVGZUC=GZUC
         SVGZVC=GZVC
         GZUA=1
         GZVA=1
         GZUB=0
         GZVB=0
         GZUC=0
         GZVC=0
      ENDIF
C
C             Fill arrays Q(JULEV) and Q(JVLEV)
C
      DO 10 I=1,NUMND1
         IQ(JSCA1+I)=0
   10 CONTINUE
C
      MAXV=LEVMAX
      LEVVER=1
      LEVHOR=0
      MLEVV=1
      CALL GDTR10(1)
      MLEVH=LEVHOR
C
      PLTVER=25.
      SIZE=PLTVER/(4.*MLEVV)
***      SIZE=PLTVER/(4.*MLEVV)
C
C             Compute user coordinates boundaries of tree picture
C
      SIZ2=SIZE*2.
***      SIZ4=SIZE*4.
      IF(MLEVH.GT.MLEVV)THEN
         SIZ4=(MLEVH*SIZ2)/MLEVV
         FACHV=(MLEVH/2.)/MLEVV
         IF(FACHV.LT.2.)FACHV=1.
      ELSE
         SIZ4=SIZE*4.
         FACHV=1.
      ENDIF
      SIZD2=SIZE/2.
      XPLT=MLEVH*SIZ2
      YPLT=MLEVV*SIZ4
C
C             Save current ranges and store new ones
C
      SAVPLX=PLTRNX
      SAVPLY=PLTRNY
C
      PLTRNX=YPLT
      PLTRNY=XPLT
C
      CALL IGRNG(YPLT,XPLT)
*      CALL IGRNG(XPLT,YPLT)
C
C             Draw nodes
C
      IDUP=1
      IONL=1
      IDET=0
      ISEEN=1
*      INTSPI=0
      DO 60 J=1,NUMND1
         IF (IQ(JSCA1+J).NE.0) THEN
            CALL UHTOC(IQ(JNAM1+J),4,NAME,4)
            IF(INTFLA.EQ.10)THEN
               IADDI=0
*               INTSPI=1
               INTFLA=1
               CALL MZLINT(IXDIV,'/GCHIL2/',LARETT,JMYMOT,LARETT)
               LARETT(1)=1
               IF(JTICK.NE.0) CALL MZDROP(IXSTOR, JTICK, ' ')
               IF(JMYLL.NE.0) CALL MZDROP(IXSTOR, JMYLL, ' ')
               NEE=NUMND1+10
               NEES=NEE*2
               CALL MZNEED(IXDIV,NEES,'G')
               CALL MZBOOK(IXDIV,JTICK,JTICK,1,'TTT',0,0,NEE,2,-1)
               CALL MZBOOK(IXDIV,JMYLL,JMYLL,1,'MMM',0,0,NEE,2,-1)
               IF(JFIMOT.NE.0) CALL MZDROP(IXSTOR, JFIMOT, ' ')
               IF(JFISCA.NE.0) CALL MZDROP(IXSTOR, JFISCA, ' ')
               IF(JFINAM.NE.0) CALL MZDROP(IXSTOR, JFINAM, ' ')
               NEES=NEE*3
               CALL MZNEED(IXDIV,NEES,'G')
               CALL MZBOOK(IXDIV,JFIMOT,JFIMOT,1,'FIMO',0,0,NEE,2,-1)
               CALL MZBOOK(IXDIV,JFISCA,JFISCA,1,'FISC',0,0,NEE,2,-1)
               CALL MZBOOK(IXDIV,JFINAM,JFINAM,1,'FINA',0,0,NEE,2,-1)
               NUMND2=NUMND1
            ENDIF
            IF(INTFLA.EQ.1)THEN
               MLETMP=MLEVV
               LEVTMP=LEVVER
               MLEVV=1
               LEVVER=1
               CALL GDTR10(J)
               IQ(JTICK+J)=MLEVV-1
               MLEVV=MLETMP
               LEVVER=LEVTMP
               IF(J.NE.1)THEN
*               IF(INTSPI.NE.1)THEN
*               NUMNDA=NUMND1
*               NUMND1=NUMNDS
*               DO 89  JI=1,NUMNDS
*                  IQ(JNAM1+JI)=IQ(JAASS3+JI)
*                  IQ(JSCA1+JI)=IQ(JAASS4+JI)
*                  IQ(JMOT1+JI)=IQ(JMYMOT+JI)
*   89          CONTINUE
*               ENDIF
                  DO 20  LL=1,16
                     CALL GDTR8(NAME,MOTH,IONL)
                     IF(MOTH.EQ.KNAME)THEN
                        IQ(JMYLL+J)=LL+1+IADDI
                        GOTO 30
                     ENDIF
                     NAME=MOTH
   20             CONTINUE
   30             CONTINUE
*                  IF(INTSPI.NE.1)NUMND1=NUMNDA
               ELSE
                  IQ(JMYLL+J)=1+IADDI
               ENDIF
            ELSE
               Q(JULEV+J) = (Q(JULEV+J)-1.)*SIZ2 + SIZE
***            Q(JVLEV+J) = YPLT - (Q(JVLEV+J)-1.)*SIZ4 - SIZ2
               Q(JVLEV+J) = (Q(JVLEV+J)-1.)*SIZ4 + SIZ2
               IF (ISEL0.NE.0) IDUP=IQ(JDUP1+J)
               IF (ISEL1.NE.0) CALL GDTR8(NAME,MOTH,IONL)
               IF (ISEL2.NE.0) THEN
                  IDET=0
                  KVAL=0
                  CALL GFATT(NAME,'DET ',KVAL)
                  IF (KVAL.GT.0) IDET=1
               ENDIF
               IF (ISEL3.NE.0) THEN
                  KVAL=1
                  CALL GFATT(NAME,'SEEN',KVAL)
                  IF (KVAL.EQ.1.OR.KVAL.EQ.-2) THEN
                     ISEEN=1
                  ELSE
                     ISEEN=0
                  ENDIF
                  IF (J.EQ.1) GO TO 50
                  JM=J
   40             CONTINUE
                  JM=IQ(JMOT1+JM)
                  KVALM=1
                  CALL UHTOC(IQ(JNAM1+JM),4,NAME1,4)
                  CALL GFATT(NAME1,'SEEN',KVALM)
                  IF (KVALM.LT.0) THEN
                     ISEEN=0
                     GO TO 50
                  ENDIF
                  IF (JM.NE.1) GO TO 40
   50             CONTINUE
               ENDIF
*****            CALL GDPRTR(NAME,Q(JVLEV+J),Q(JULEV+J),SIZE,IDUP,IDRAW,
*****     +      IONL, IDET,ISEEN)
               NPILE=IQ(JMYLL+J)
               CALL GDPRTR(NAME,Q(JULEV+J),Q(JVLEV+J),SIZE,FACHV,IDUP,
     +         IDRAW, IONL, IDET,ISEEN)
            ENDIF
         ENDIF
   60 CONTINUE
C
C             Draw links
C
      IF(INTFLA.EQ.1)GOTO 160
      LINCOL=1
      CALL MVBITS(LINCOL,0,8,LINATT,16)
      IF (IQ(JMOT1+1).NE.0) THEN
         U(2)=Q(JULEV+1)
         U(1)=U(2)
         V(2)=Q(JVLEV+1)-(SIZD2*2.*FACHV)
         V(1)=V(2)-(SIZE*2.*FACHV)
         CALL GDRAWV(V,U,2)
***         CALL GDRAWV(U,V,2)
      ENDIF
C
      IGREEN=1
      DO 150 J=1,NUMND1
         IF (IQ(JSCA1+J).EQ.1) THEN
            JX=IQ(JXON1+J)
   70       IF (JX.EQ.0) GO TO 120
*            U(1)=Q(JULEV+J)
*            U(2)=Q(JULEV+JX)
*            V(1)=Q(JVLEV+J)+(SIZD2*2.*FACHV)
*            V(2)=Q(JVLEV+JX)-(SIZD2*2.*FACHV)
            U(1)=Q(JULEV+J)
            U(2)=U(1)
            U(3)=Q(JULEV+JX)
            U(4)=Q(JULEV+JX)
            V(1)=Q(JVLEV+J)+(SIZD2*2.*FACHV)
            V(4)=Q(JVLEV+JX)-(SIZD2*2.*FACHV)
            V(2)=(V(1)+V(4))/2.
            V(3)=V(2)
            IF(J.EQ.1)HALF=V(4)-V(3)
            IF(NNPAR.EQ.3)THEN
               CALL IGPID(1,' ',J,' ')
            ENDIF
            CALL GDRAWV(V,U,4)
***
           IF(INTFLA.EQ.-1)THEN
            ARROWS=(SIZD2*2.*FACHV)/10.
            NPO=IQ(JTICK+J)
            FRA=(V(2)-V(1))/NPO
            DO 80  KJI=1,NPO
               VVV(KJI)=V(1)-(FRA/2.)+(FRA*KJI)
               UUU(KJI)=U(1)
   80       CONTINUE
            CALL ISFACI(2)
            CALL ISFAIS(1)
            DO 90  KJI=1,NPO
               SVVX(1)=VVV(KJI)-ARROWS
               SVVX(2)=VVV(KJI)-ARROWS
               SVVX(3)=VVV(KJI)+ARROWS
               SVVY(1)=UUU(KJI)+ARROWS
               SVVY(2)=UUU(KJI)-ARROWS
               SVVY(3)=UUU(KJI)
               IF(NNPAR.EQ.3)THEN
                  CALL IGPID(1,'Tree',IQ(JNAM1+J),' ')
                  CALL IGPID(2,'Arrow',KJI+1,' ')
               ENDIF
               CALL IFA(3,SVVX,SVVY)
   90       CONTINUE
***            CALL GDRAWV(U,V,2)
            NPO=IQ(JMYLL+J)
            FRA=(V(4)-V(3))/NPO
            DO 100 KJI=1,NPO
               VVV(KJI)=V(3)-(FRA/2.)+(FRA*KJI)
               UUU(KJI)=U(3)
  100       CONTINUE
            CALL ISFACI(3)
            CALL ISFAIS(1)
            IGREEN=IGREEN+1
            IORGO=0
            DO 110 KJI=NPO,1,-1
               IORGO=IORGO+1
               SVVX(1)=VVV(KJI)+ARROWS
               SVVX(2)=VVV(KJI)+ARROWS
               SVVX(3)=VVV(KJI)-ARROWS
               SVVY(1)=UUU(KJI)+ARROWS
               SVVY(2)=UUU(KJI)-ARROWS
               SVVY(3)=UUU(KJI)
               IF(NNPAR.EQ.3)THEN
                  CALL IGPID(1,'Tree',IQ(JNAM1+IGREEN),' ')
                  CALL IGPID(2,'Arrow',-IORGO,' ')
               ENDIF
               CALL IFA(3,SVVX,SVVY)
  110       CONTINUE
           ENDIF
***
            JX=IQ(JBRO1+JX)
            GO TO 70
  120       CONTINUE
         ELSE IF (IQ(JSCA1+J).EQ.-1) THEN
           IF(INTFLA.EQ.-1)THEN
            ARROWS=(SIZD2*2.*FACHV)/10.
            U(1)=Q(JULEV+J)
            U(2)=U(1)
            V(1)=Q(JVLEV+J)+(SIZD2*2.*FACHV)
            V(2)=V(1)+(SIZE*2.*FACHV)
            CALL GDRAWV(V,U,2)
            NPO=IQ(JTICK+J)
            FRA=(V(2)-V(1))/(NPO*2.)
            DO 130 KJI=1,NPO
               VVV(KJI)=V(1)-(FRA/2.)+(FRA*KJI)
               UUU(KJI)=U(1)
  130       CONTINUE
            CALL ISFACI(2)
            CALL ISFAIS(1)
            DO 140 KJI=1,NPO
               SVVX(1)=VVV(KJI)-ARROWS
               SVVX(2)=VVV(KJI)-ARROWS
               SVVX(3)=VVV(KJI)+ARROWS
               SVVY(1)=UUU(KJI)+ARROWS
               SVVY(2)=UUU(KJI)-ARROWS
               SVVY(3)=UUU(KJI)
               IF(NNPAR.EQ.3)THEN
                  CALL IGPID(1,'Tree',IQ(JNAM1+J),' ')
                  CALL IGPID(2,'Arrow',KJI+1,' ')
               ENDIF
               CALL IFA(3,SVVX,SVVY)
  140       CONTINUE
***            CALL GDRAWV(U,V,2)
           ENDIF
         ENDIF
  150 CONTINUE
C
C             Restore GDRAW calling parameters
C             and ZOOM internal parameters
C
  160 CONTINUE
      IF (ISEL4.NE.0) THEN
         GTHETA=SAVTHE
         GPHI=SAVPHI
         GU0=SAVU0
         GV0=SAVV0
         GSCU=SAVSCU
         GSCV=SAVSCV
         NGVIEW=0
         GZUA=SVGZUA
         GZVA=SVGZVA
         GZUB=SVGZUB
         GZVB=SVGZVB
         GZUC=SVGZUC
         GZVC=SVGZVC
      ENDIF
C
C             Restore original ranges previously saved
C
      PLTRNX=SAVPLX
      PLTRNY=SAVPLY
C
************      CALL IGRNG(PLTRNX,PLTRNY)
C
C             Delete tree structure on view bank 11
C
  170 CALL GDTR99(IVTREE)
      GO TO 999
C
  180 WRITE(CHMAIL,10000)KNAME
      CALL GMAIL(0,0)
10000 FORMAT(' GDTREE: VOLUME ',A4,' DOES NOT EXIST')
C
  999 END
+DECK,  GDWMN1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDWMN1(U0,V0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a 2D-girl at position (U0,V0)                       *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC                      *
C.    *       Source adapted from GDGIRL                               *
C.    *       Author : H. Plothow-Besch/CERN-PPE                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION U(23),V(23),LEN(12),UN(23,12),VN(23,12)
      DIMENSION UN1(23),VN1(23),UN2( 8),VN2( 8)
      DIMENSION UN3( 7),VN3( 7),UN4(13),VN4(13)
      DIMENSION UN5( 9),VN5( 9),UN6(11),VN6(11)
      DIMENSION UN7( 5),VN7( 5),UN8(12),VN8(12)
      DIMENSION UN9( 7),VN9( 7),UN10(11),VN10(11)
      DIMENSION UN11( 7),VN11( 7),UN12( 6),VN12( 6)
C
      EQUIVALENCE (UN1(1),UN(1,1)),(VN1(1),VN(1,1))
      EQUIVALENCE (UN2(1),UN(1,2)),(VN2(1),VN(1,2))
      EQUIVALENCE (UN3(1),UN(1,3)),(VN3(1),VN(1,3))
      EQUIVALENCE (UN4(1),UN(1,4)),(VN4(1),VN(1,4))
      EQUIVALENCE (UN5(1),UN(1,5)),(VN5(1),VN(1,5))
      EQUIVALENCE (UN6(1),UN(1,6)),(VN6(1),VN(1,6))
      EQUIVALENCE (UN7(1),UN(1,7)),(VN7(1),VN(1,7))
      EQUIVALENCE (UN8(1),UN(1,8)),(VN8(1),VN(1,8))
      EQUIVALENCE (UN9(1),UN(1,9)),(VN9(1),VN(1,9))
      EQUIVALENCE (UN10(1),UN(1,10)),(VN10(1),VN(1,10))
      EQUIVALENCE (UN11(1),UN(1,11)),(VN11(1),VN(1,11))
      EQUIVALENCE (UN12(1),UN(1,12)),(VN12(1),VN(1,12))
C
      SAVE LEN,UN1,VN1,UN2,VN2,UN3,VN3,UN4,VN4,UN5,VN5,UN6,VN6
      SAVE     UN7,VN7,UN8,VN8,UN9,VN9,UN10,VN10,UN11,VN11,UN12,VN12

      DATA LEN/23, 8, 7, 13, 9, 11, 5, 12, 7, 11, 7, 6/

*     Dress
      DATA UN1/  0.9, 0.6, 1.0, 1.0,-0.1, -0.6, -0.9, -0.5,
     +          -0.8,-0.5,-0.15, -0.5, -0.7, -0.9, -0.6, -0.25,
     +          0.15, 0.0, 0.0, 0.3, 0.9, 0.9, 0.9/
      DATA VN1/  0.8, 1.5, 2.4, 3.4, 2.5,  3.4,  2.4,  1.4,
     +           0.6,-1.4, 0.2 , -1.4, -2.0, -4.2, -4.1, -4.05,
     +         -4.0 ,-3.0,-2.0,-1.4,-0.2, 0.4, 0.8/

*     RArm
      DATA UN2/ 0.9, 0.9, 1.6, 1.3, 1.0, 1.0, 1.2, 0.9/
      DATA VN2/ 0.8, 0.4, 1.5, 3.2, 3.4, 2.4, 1.5, 0.8/

*     Collar
      DATA UN3/-0.1,  1.0,  0.6,-0.1, -0.25, -0.6,-0.1/
      DATA VN3/ 2.5,  3.4,  3.5, 2.5,  3.5 ,  3.4, 2.5/

*     Head
      DATA UN4/-0.1,-0.6,-0.25,-0.1,-0.1,-0.3,-0.5,-0.20, 0.2, 0.4, 0.6,
     +          1.0,-0.1/
      DATA VN4/ 2.5, 3.4, 3.5 , 3.6, 3.7, 3.7, 4.2, 4.75, 4.6, 3.6, 3.5,
     +          3.4, 2.5/

*     Hair
      DATA UN5/ 0.2, 1.0,  1.0, 1.25, 1.25, 1.0, 0.6, 0.4, 0.2/
      DATA VN5/ 4.6, 4.3,  3.9, 3.6 , 3.3 , 3.4, 3.5, 3.6, 4.6/

*     Hardhead
      DATA UN6/0.2,-0.4,-0.7,-0.25, 0.0, 0.4 , 0.8, 1.1, 1.1, 1.0, 0.2/
      DATA VN6/4.6, 4.8, 4.9, 4.85, 5.1, 5.15, 5.0, 4.7, 4.3, 4.3, 4.6/

*     LArm
      DATA UN7/-0.8 , -0.6, -0.8, -1.0, -0.8 /
      DATA VN7/ 2.7 ,  3.4,  3.3,  3.0,  2.7 /

*     Paper
      DATA UN8/-0.8 ,-1.0,-1.3 ,-1.6,-0.9,-0.9,-0.75,-0.7 ,
     +         -0.6 ,-0.5, -0.9,-0.8 /
      DATA VN8/ 2.7 , 3.0, 3.5 , 2.7, 1.6, 1.4, 1.2 , 1.3 ,
     +          1.15, 1.4,  2.4, 2.7 /

*     LHand
      DATA UN9/-0.9, -0.9, -0.75, -0.7 , -0.55, -0.95, -0.9/
      DATA VN9/ 1.6,  1.4,  1.2 ,  1.3 ,  1.45,  2.0 ,  1.6/

*     LTrousers
      DATA UN10/ 0.0, 0.0, 0.15, -0.1,-0.1, 0.2, 0.45, 0.75, 0.3 , 0.3,
     +           0.0/
      DATA VN10/-2.0,-3.0,-4.0 ,-4.05,-4.3,-4.2,-4.15,-4.1 ,-2.15,-1.4,
     +          -2.0/

*     LFoot
      DATA UN11/ 0.2, 0.2, 0.0, 0.2, 0.5, 0.45, 0.2/
      DATA VN11/-4.2,-4.4,-5.0,-5.2,-4.4,-4.15,-4.2/

*     RFoot
      DATA UN12/-0.6,-0.8,-0.3,-0.4,-0.25,-0.6/
      DATA VN12/-4.1,-5.4,-4.7,-4.3,-4.05,-4.1/
C.    ------------------------------------------------------------------
C.
      DO 20 I=1,12
         JMAX=LEN(I)
         DO 10 J=1,JMAX
            U(J)=UN(J,I)*20.0*0.83*GSCU*GZUA+U0
            V(J)=VN(J,I)*20.0*0.83*GSCV*GZVA+V0
C
C             Normalize to PLTRNX,PLTRNY
C
            U(J)=U(J)*PLTRNX/20.
            V(J)=V(J)*PLTRNY/20.
   10    CONTINUE
         CALL GDRAWV(U,V,JMAX)
   20 CONTINUE
      END
+DECK,  GDWMN2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDWMN2(U0,V0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a 2D-Lady at position (U0,V0)                       *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC                      *
C.    *       Source adapted from GDGIRL                               *
C.    *       Author : H. Plothow-Besch/CERN-PPE                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION U(17),V(17),LEN(11),UN(17,11),VN(17,11)
      DIMENSION UN1(17),VN1(17),UN2( 8),VN2( 8)
      DIMENSION UN3( 7),VN3( 7),UN4(13),VN4(13)
      DIMENSION UN5( 9),VN5( 9),UN6(11),VN6(11)
      DIMENSION UN7( 5),VN7( 5),UN8(12),VN8(12)
      DIMENSION UN9( 7),VN9( 7),UN10( 8),VN10( 8)
      DIMENSION UN11(10),VN11(10)
C
      EQUIVALENCE (UN1(1),UN(1,1)),(VN1(1),VN(1,1))
      EQUIVALENCE (UN2(1),UN(1,2)),(VN2(1),VN(1,2))
      EQUIVALENCE (UN3(1),UN(1,3)),(VN3(1),VN(1,3))
      EQUIVALENCE (UN4(1),UN(1,4)),(VN4(1),VN(1,4))
      EQUIVALENCE (UN5(1),UN(1,5)),(VN5(1),VN(1,5))
      EQUIVALENCE (UN6(1),UN(1,6)),(VN6(1),VN(1,6))
      EQUIVALENCE (UN7(1),UN(1,7)),(VN7(1),VN(1,7))
      EQUIVALENCE (UN8(1),UN(1,8)),(VN8(1),VN(1,8))
      EQUIVALENCE (UN9(1),UN(1,9)),(VN9(1),VN(1,9))
      EQUIVALENCE (UN10(1),UN(1,10)),(VN10(1),VN(1,10))
      EQUIVALENCE (UN11(1),UN(1,11)),(VN11(1),VN(1,11))
C
      SAVE LEN,UN1,VN1,UN2,VN2,UN3,VN3,UN4,VN4,UN5,VN5,UN6,VN6
      SAVE     UN7,VN7,UN8,VN8,UN9,VN9,UN10,VN10,UN11,VN11

      DATA LEN/17, 8, 7, 13, 9, 11, 5, 12, 7, 8, 10/

*     Dress
      DATA UN1/ 0.9, 0.6, 1.0, 1.0,-0.1, -0.6, -0.9,-0.5,-0.8, -1.0,
     +         -0.7 , -0.1 , 0.25, 1.4, 0.95, 0.9, 0.9/
      DATA VN1/ 0.8, 1.5, 2.4, 3.4, 2.5,  3.4,  2.4, 1.4, 0.6, -2.3,
     +         -2.25, -2.15,-2.1 ,-1.9,-1.0 , 0.4, 0.8/

*     RArm
      DATA UN2/ 0.9, 0.9, 1.6, 1.3, 1.0, 1.0, 1.2, 0.9/
      DATA VN2/ 0.8, 0.4, 1.5, 3.2, 3.4, 2.4, 1.5, 0.8/

*     Collar
      DATA UN3/-0.1,  1.0,  0.6,-0.1, -0.25, -0.6,-0.1/
      DATA VN3/ 2.5,  3.4,  3.5, 2.5,  3.5 ,  3.4, 2.5/

*     Head
      DATA UN4/-0.1,-0.6,-0.25,-0.1,-0.1,-0.3,-0.5,-0.20, 0.2, 0.4, 0.6,
     +          1.0,-0.1/
      DATA VN4/ 2.5, 3.4, 3.5 , 3.6, 3.7, 3.7, 4.2, 4.75, 4.6, 3.6, 3.5,
     +          3.4, 2.5/

*     Hair
      DATA UN5/ 0.2, 1.0,  1.0, 1.25, 1.25, 1.0, 0.6, 0.4, 0.2/
      DATA VN5/ 4.6, 4.3,  3.9, 3.6 , 3.3 , 3.4, 3.5, 3.6, 4.6/

*     Hardhead
      DATA UN6/0.2,-0.4,-0.7,-0.25, 0.0, 0.4 , 0.8, 1.1, 1.1, 1.0, 0.2/
      DATA VN6/4.6, 4.8, 4.9, 4.85, 5.1, 5.15, 5.0, 4.7, 4.3, 4.3, 4.6/

*     LArm
      DATA UN7/-0.8 , -0.6, -0.8, -1.0, -0.8 /
      DATA VN7/ 2.7 ,  3.4,  3.3,  3.0,  2.7 /

*     Paper
      DATA UN8/-0.8 ,-1.0,-1.3 ,-1.6,-0.9,-0.9,-0.75,-0.7 ,
     +         -0.6 ,-0.5, -0.9,-0.8 /
      DATA VN8/ 2.7 , 3.0, 3.5 , 2.7, 1.6, 1.4, 1.2 , 1.3 ,
     +          1.15, 1.4,  2.4, 2.7 /

*     LHand
      DATA UN9/-0.9, -0.9, -0.75, -0.7 , -0.55, -0.95, -0.9/
      DATA VN9/ 1.6,  1.4,  1.2 ,  1.3 ,  1.45,  2.0 ,  1.6/

*     RLeg
      DATA UN10/-0.7 ,-0.6,-0.8,-0.3,-0.4, 0.0,-0.1 ,-0.7 /
      DATA VN10/-2.25,-3.8,-5.4,-4.7,-4.3,-3.0,-2.15,-2.25/

*     LLeg
      DATA UN11/-0.1 , 0.0,-0.15, 0.2, 0.0, 0.2, 0.5, 0.4, 0.25,-0.1 /
      DATA VN11/-2.15,-3.0,-3.4 ,-4.4,-5.0,-5.2,-4.4,-4.2,-2.1 ,-2.15/
C.    ------------------------------------------------------------------
C.
      DO 20 I=1,11
         JMAX=LEN(I)
         DO 10 J=1,JMAX
            U(J)=UN(J,I)*20.0*0.83*GSCU*GZUA+U0
            V(J)=VN(J,I)*20.0*0.83*GSCV*GZVA+V0
C
C             Normalize to PLTRNX,PLTRNY
C
            U(J)=U(J)*PLTRNX/20.
            V(J)=V(J)*PLTRNY/20.
   10    CONTINUE
         CALL GDRAWV(U,V,JMAX)
   20 CONTINUE
      END
+DECK,  GDWMN3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDWMN3(U0,V0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw a 2D-girl at position (U0,V0)                       *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDSPEC                      *
C.    *       Source adapted from GDGIRL                               *
C.    *       Author : H. Plothow-Besch/CERN-PPE                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
      DIMENSION U(23),V(23),LEN(12),UN(23,12),VN(23,12)
      DIMENSION UN1(23),VN1(23),UN2( 8),VN2( 8)
      DIMENSION UN3( 7),VN3( 7),UN4(13),VN4(13)
      DIMENSION UN5( 9),VN5( 9),UN6(11),VN6(11)
      DIMENSION UN7( 5),VN7( 5),UN8(12),VN8(12)
      DIMENSION UN9( 7),VN9( 7),UN10(11),VN10(11)
      DIMENSION UN11( 7),VN11( 7),UN12( 6),VN12( 6)
C
      EQUIVALENCE (UN1(1),UN(1,1)),(VN1(1),VN(1,1))
      EQUIVALENCE (UN2(1),UN(1,2)),(VN2(1),VN(1,2))
      EQUIVALENCE (UN3(1),UN(1,3)),(VN3(1),VN(1,3))
      EQUIVALENCE (UN4(1),UN(1,4)),(VN4(1),VN(1,4))
      EQUIVALENCE (UN5(1),UN(1,5)),(VN5(1),VN(1,5))
      EQUIVALENCE (UN6(1),UN(1,6)),(VN6(1),VN(1,6))
      EQUIVALENCE (UN7(1),UN(1,7)),(VN7(1),VN(1,7))
      EQUIVALENCE (UN8(1),UN(1,8)),(VN8(1),VN(1,8))
      EQUIVALENCE (UN9(1),UN(1,9)),(VN9(1),VN(1,9))
      EQUIVALENCE (UN10(1),UN(1,10)),(VN10(1),VN(1,10))
      EQUIVALENCE (UN11(1),UN(1,11)),(VN11(1),VN(1,11))
      EQUIVALENCE (UN12(1),UN(1,12)),(VN12(1),VN(1,12))
C
      SAVE LEN,UN1,VN1,UN2,VN2,UN3,VN3,UN4,VN4,UN5,VN5,UN6,VN6
      SAVE     UN7,VN7,UN8,VN8,UN9,VN9,UN10,VN10,UN11,VN11,UN12,VN12

      DATA LEN/23, 8, 7, 13, 9, 11, 5, 12, 7, 11, 7, 6/

*     Dress
      DATA UN1/  0.9, 0.6, 1.0, 1.0,-0.1, -0.6, -0.9, -0.5,
     +          -0.8,-0.5,-0.15, -0.5, -0.7, -0.9, -0.6, -0.25,
     +          0.15, 0.0, 0.0, 0.3, 0.9, 0.9, 0.9/
      DATA VN1/  0.8, 1.5, 2.4, 3.4, 2.5,  3.4,  2.4,  1.4,
     +           0.6,-1.4, 0.2 , -1.4, -2.0, -4.2, -4.1, -4.05,
     +         -4.0 ,-3.0,-2.0,-1.4,-0.2, 0.4, 0.8/

*     RArm
      DATA UN2/ 0.9, 0.9, 1.6, 1.3, 1.0, 1.0, 1.2, 0.9/
      DATA VN2/ 0.8, 0.4, 1.5, 3.2, 3.4, 2.4, 1.5, 0.8/

*     Collar
      DATA UN3/-0.1,  1.0,  0.6,-0.1, -0.25, -0.6,-0.1/
      DATA VN3/ 2.5,  3.4,  3.5, 2.5,  3.5 ,  3.4, 2.5/

*     Head
      DATA UN4/-0.1,-0.6,-0.25,-0.1,-0.1,-0.3,-0.5,-0.20, 0.2, 0.4, 0.6,
     +          1.0,-0.1/
      DATA VN4/ 2.5, 3.4, 3.5 , 3.6, 3.7, 3.7, 4.2, 4.75, 4.6, 3.6, 3.5,
     +          3.4, 2.5/

*     Hair
      DATA UN5/ 0.2, 1.0,  1.0, 1.25, 1.25, 1.0, 0.6, 0.4, 0.2/
      DATA VN5/ 4.6, 4.3,  3.9, 3.6 , 3.3 , 3.4, 3.5, 3.6, 4.6/

*     Hardhead
      DATA UN6/0.2,-0.4,-0.7,-0.25, 0.0, 0.4 , 0.8, 1.1, 1.1, 1.0, 0.2/
      DATA VN6/4.6, 4.8, 4.9, 4.85, 5.1, 5.15, 5.0, 4.7, 4.3, 4.3, 4.6/

*     LArm
      DATA UN7/-0.8 , -0.6, -0.8, -1.0, -0.8 /
      DATA VN7/ 2.7 ,  3.4,  3.3,  3.0,  2.7 /

*     Paper
      DATA UN8/-0.8 ,-1.0,-1.3 ,-1.6,-0.9,-0.9,-0.75,-0.7 ,
     +         -0.6 ,-0.5, -0.9,-0.8 /
      DATA VN8/ 2.7 , 3.0, 3.5 , 2.7, 1.6, 1.4, 1.2 , 1.3 ,
     +          1.15, 1.4,  2.4, 2.7 /

*     LHand
      DATA UN9/-0.9, -0.9, -0.75, -0.7 , -0.55, -0.95, -0.9/
      DATA VN9/ 1.6,  1.4,  1.2 ,  1.3 ,  1.45,  2.0 ,  1.6/

*     LTrousers
      DATA UN10/ 0.0, 0.0, 0.15, -0.1,-0.1, 0.2, 0.45, 0.75, 0.3 , 0.3,
     +           0.0/
      DATA VN10/-2.0,-3.0,-4.0 ,-4.05,-4.3,-4.2,-4.15,-4.1 ,-2.15,-1.4,
     +          -2.0/

*     LFoot
      DATA UN11/ 0.2, 0.2, 0.0, 0.2, 0.5, 0.45, 0.2/
      DATA VN11/-4.2,-4.4,-5.0,-5.2,-4.4,-4.15,-4.2/

*     RFoot
      DATA UN12/-0.6,-0.8,-0.3,-0.4,-0.25,-0.6/
      DATA VN12/-4.1,-5.4,-4.7,-4.3,-4.05,-4.1/
C.    ------------------------------------------------------------------
C.
      DO 20 I=1,12
         JMAX=LEN(I)
         DO 10 J=1,JMAX
            U(J)=UN(J,I)*20.0*0.83*GSCU*GZUA+U0
            V(J)=VN(J,I)*20.0*0.83*GSCV*GZVA+V0
C
C             Normalize to PLTRNX,PLTRNY
C
            U(J)=U(J)*PLTRNX/20.
            V(J)=V(J)*PLTRNY/20.
   10    CONTINUE
         CALL GDRAWV(U,V,JMAX)
   20 CONTINUE
      END
+DECK,  GDXYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDXYZ(IT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draws track IT for which space points have been stored   *
C.    *       in banks JXYZ                                            *
C.    *       If IT=0 draws all tracks                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Authors : R.Brun, P.Zanarini, S.Giani                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
      PARAMETER (NTRTYP=8)
      INTEGER COLO(NTRTYP), MODE(NTRTYP)
      DIMENSION U(50),V(50)
C
C             MODE(ITRTYP) and COLO(ITRTYP) are used by ISLN and GDCOL
C             ITRTYP (the track type) correspond to :
C
C             ITRTYP  PARTICLE  |       HIGZ         |
C             ----------------------------------------
C                 1   gammas    | dotted      blue   |
C                 2   electrons | solid       red    |
C                 3   neutral   | dot-dashed  black  |
C                 4   hadrons   | solid       red    |
C                 5   muons     | dashed      green  |
C                 6   geantino  | dot-dashed  black  |
C                 7   cerenkov  | dotted      yellow |
C                 8   ions      | solid       light b|
C
      SAVE MODE,COLO
      DATA MODE /3, 1, 4, 1, 2, 1, 3, 1/
      DATA COLO/4, 2, 1, 2, 3, 1, 6, 5/
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('OFF ',IOFF,4,4)
      CALL UCTOH('LINE',ILINE,4,4)
C
C            Set IOBJ to TRACK
C
      IOBJ=2
C
      IF(JXYZ.LE.0)GO TO 70
      NXYZ=IQ(JXYZ-2)
      N1  =1
      N2  =NXYZ
      IF(IT.NE.0)N1=IT
      IF(IT.NE.0)N2=IT
      IF(N1.LE.0)GO TO 70
      IF(N2.GT.NXYZ)GO TO 70
C
      DO 60 I=N1,N2
         JX=LQ(JXYZ-I)
         IF(JX.LE.0)GO TO 50
         IPOINT=JX+3
   10    IF(IPOINT.GT.JX+IQ(JX-1))GO TO 50
         NPOINT=Q(IPOINT)
         IF(NPOINT.LE.0)GO TO 50
         IPART=Q(IPOINT+1)
         JPA=LQ(JPART-IPART)
         ITRTYP=Q(JPA+6)
C
C             Line style and color code
C
         IMOD=MODE(ITRTYP)
         ICOL=COLO(ITRTYP)
C
         CALL GDCOL(ICOL)
         CALL GDCOL1(ICOL)
C
         IPF=1
   20    IIPL=IPF+49
         IF(IIPL.GT.NPOINT)IIPL=NPOINT
         NP=IIPL-IPF+1
         IF(NP.LE.0)GO TO 40
C
C            Is THRZ option set on (R-Z projection)
C            and the cut lateral (vertical or horizontal) ?
C
         IF (ITHRZ.NE.IOFF) THEN
            IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-I
         ELSE
            ITR3D=0
         ENDIF
C
         CALL GDFR3D(Q(IPOINT+3*IPF-1),NP,U,V)
C
         IF (IDVIEW.EQ.0) THEN
C
            IF (ITRKOP.EQ.ILINE.AND.NP.GT.1) THEN
               CALL ISLN(IMOD)
               CALL IGPID(1,'Kine',I,' ')
               CALL IPL(NP,U,V)
            ELSE
               DO 30 IP=1,NP
                  CALL IGPID(1,'Kine',I,' ')
                  CALL IPM(1,U(IP),V(IP))
   30          CONTINUE
            ENDIF
C
         ELSE
C
            CALL IGPID(1,'Kine',I,' ')
            CALL GDRAWP(U,V,NP)
C
         ENDIF
C
         IPF=IIPL
         IF(IPF.LT.NPOINT)GO TO 20
   40    IPOINT=IPOINT+3.*Q(IPOINT)+2.
         GO TO 10
C
   50    CONTINUE
C
   60 CONTINUE
C
      CALL GDCOL(0)
      CALL GDCOL1(IBITS(LINATP,16,4))
C
   70 CONTINUE
C
C             Reset line style
C
      CALL ISLN(1)
C
C             Reset ITR3D to 'standard projection'
C
      ITR3D=0
      IOBJ=0
C
      END
+DECK,  GDXZOO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDXZOO(ISEL1,ZOOMFU,ZOOMFV,UUZ0,VVZ0,UU0,VV0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Zoom by the factors ZOOMFU,ZOOMFV                        *
C.    *       around screen coordinates UUZ0,VVZ0                      *
C.    *       and places the resulting picture at UU0,VV0              *
C.    *                                                                *
C.    *       After GDZOOM has been called, any drawing operation      *
C.    *       will actually draw accordingly to last GDZOOM parameters *
C.    *                                                                *
C.    *       If ZOOMFU or ZOOMFV is 0 (or negative) the zoom          *
C.    *       parameters (GZUA,...,GZVC in common GCDRAW) are reset    *
C.    *                                                                *
C.    *       It is now possible to show in different windows the      *
C.    *       `zoomed-views' obtained just clicking in different       *
C.    *       points of the main picture or of the zoomed-pictures     *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author: S. Giani                                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      IF (ZOOMFU.LE.0.OR.ZOOMFV.LE.0) THEN
         GZUA=1
         GZVA=1
         GZUB=0
         GZVB=0
         GZUC=0
         GZVC=0
       ELSE
        II=0
 15     CONTINUE
        II=II+1
        GZUA=1
        GZVA=1
        GZUB=0
        GZVB=0
        GZUC=0
        GZVC=0
        CALL IRQLC(1,2,ISTAT,NT,PX,PY)
        IF(ISTAT.EQ.0)THEN
         DO 16 J=2,II
          CALL ICLWK(J)
 16      CONTINUE
         RETURN
        ENDIF
        IF(ISTAT.EQ.1)THEN
         CALL IDAWK(1)
 17      CONTINUE
         UUZ0=PX
         VVZ0=PY
         GZUA=GZUA*ZOOMFU
         GZVA=GZVA*ZOOMFV
         GZUB=(GZUB+GZUC)*ZOOMFU
         GZVB=(GZVB+GZVC)*ZOOMFV
         GZUC=UU0-UUZ0*ZOOMFU
         GZVC=VV0-VVZ0*ZOOMFV
         CALL IOPWK(II+1,1,II+1)
         CALL IACWK(II+1)
         CALL GDSHOW(ISEL1)
         CALL IRQLC(II+1,2,ISTA2,NT,PX,PY)
         IF(ISTA2.EQ.0)THEN
          CALL IDAWK(II+1)
          CALL IACWK(1)
          GOTO 15
         ELSE
          CALL IDAWK(II+1)
          II=II+1
          GOTO 17
         ENDIF
        ENDIF
      ENDIF
C
      END
+DECK,  GDZOOM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GDZOOM(ZOOMFU,ZOOMFV,UUZ0,VVZ0,UU0,VV0)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Zoom by the factors ZOOMFU,ZOOMFV                        *
C.    *       around screen coordinates UUZ0,VVZ0                      *
C.    *       and places the resulting picture at UU0,VV0              *
C.    *                                                                *
C.    *       After GDZOOM has been called, any drawing operation      *
C.    *       will actually draw accordingly to last GDZOOM parameters *
C.    *                                                                *
C.    *       If ZOOMFU or ZOOMFV is 0 (or negative) the zoom          *
C.    *       parameters (GZUA,...,GZVC in common GCDRAW) are reset    *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCDRAW.
C.
C.    ------------------------------------------------------------------
C.
      IF (ZOOMFU.LE.0.OR.ZOOMFV.LE.0) THEN
         GZUA=1
         GZVA=1
         GZUB=0
         GZVB=0
         GZUC=0
         GZVC=0
      ELSE
         GZUA=GZUA*ZOOMFU
         GZVA=GZVA*ZOOMFV
         GZUB=(GZUB+GZUC)*ZOOMFU
         GZVB=(GZVB+GZVC)*ZOOMFV
         GZUC=UU0-UUZ0*ZOOMFU
         GZVC=VV0-VVZ0*ZOOMFV
      ENDIF
C
      END
+DECK,  GEDITV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:29  cernlib
* Geant

      SUBROUTINE GEDITV(IMENU)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Edit volumes (only for interactive version)              *
C.    *                                                                *
C.    *       IMENU = option selected from menu (input)                *
C.    *                                                                *
C.    *    ==>Called by : GINC3                                        *
C.    *       Author    P.Zanarini  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
      CHARACTER*4 CHNAME,CHNEW,NAMDIV,NAMMOT
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('    ',IBLA,4,4)
C
      CALL KUPROC('Give volume NAME',CHNAME,NCH)
      CALL UCTOH(CHNAME,NAME,4,NCH)
      IVO=IUCOMP(NAME,IQ(JVOLUM+1),NVOLUM)
      IF (IVO.LE.0) GO TO 999
      JVO=LQ(JVOLUM-IVO)
C
C             Get IVOMOT,NIN,JIN
C
      IF (IMENU.GE.4.AND.IMENU.LE.6) THEN
         CALL KUPROI('Give copy NR',NR)
         DO 20 IVOMOT=1,NVOLUM
            JVOMOT=LQ(JVOLUM-IVOMOT)
            NIN=Q(JVOMOT+3)
            IF (NIN.LT.0) THEN
               NIN=1
               IDIV=1
            ELSE
               IDIV=0
            ENDIF
            DO 10 IN=1,NIN
               JIN=LQ(JVOMOT-IN)
               IVOSON=Q(JIN+2)
               IF (IDIV.EQ.1) THEN
                  IF (IVOSON.EQ.IVO) GO TO 30
               ELSE
                  NRSON=Q(JIN+3)
                  IF (IVOSON.EQ.IVO.AND.NRSON.EQ.NR) GO TO 30
               ENDIF
   10       CONTINUE
   20    CONTINUE
         GO TO 999
   30    CONTINUE
      ENDIF
C
C             Get IVOMOT,JDIV
C
      IF (IMENU.GE.7.AND.IMENU.LE.8) THEN
         DO 40 IVOMOT=1,NVOLUM
            JVOMOT=LQ(JVOLUM-IVOMOT)
            NIN=Q(JVOMOT+3)
            IF (NIN.GE.0) GO TO 40
            JDIV=LQ(JVOMOT-1)
            IVOSON=Q(JDIV+2)
            IF (IVOSON.EQ.IVO) GO TO 50
   40    CONTINUE
         GO TO 999
   50    CONTINUE
      ENDIF
C
      IF (IMENU.EQ.1) THEN
C
C             Modify shape parameters PAR given by GSVOLU
C
         NP=Q(JVO+5)
         DO 60 I=1,NP
            PAR=Q(JVO+6+I)
            WRITE (CHMAIL,1100) I,PAR
            CALL GMAIL(0,0)
            CALL KUPROR('Give new value',PAR)
            Q(JVO+6+I)=PAR
   60    CONTINUE

C
      ELSE IF (IMENU.EQ.2) THEN
C
C             Modify NAME given by GSVOLU
C
         CALL KUPROC('Give new NAME',CHNEW,NCH)
         NEWNAM=IBLA
         CALL UCTOH(CHNEW,NEWNAM,4,NCH)
         IQ(JVOLUM+IVO)=NEWNAM
C
      ELSE IF (IMENU.EQ.3) THEN
C
C             Delete NAME given by GSVOLU
C
   70    CONTINUE
         DO 90 IVOMOT=1,NVOLUM
            JVOMOT=LQ(JVOLUM-IVOMOT)
            NIN=Q(JVOMOT+3)
            IF (NIN.LT.0) NIN=1
            DO 80 IN=1,NIN
               JIN=LQ(JVOMOT-IN)
               IVOSON=Q(JIN+2)
               NR=Q(JIN+3)
               IF (IVOSON.EQ.IVO) GO TO 100
   80       CONTINUE
   90    CONTINUE
         GO TO 110
C
  100    CONTINUE
C
C             Unlink NAME,NR
C
+SELF, IF=-USRJMP.
         CALL GUNLIV(IVO,NR,IVOMOT)
+SELF, IF=USRJMP.
         CALL JUMPT3(JUNLIV,IVO,NR,IVOMOT)
+SELF.
         WRITE (CHMAIL,1000) NAME
         CALL GMAIL(0,0)
 1000   FORMAT (' *** GEDITV: ',A4,' UNLINKED')
C
C             Try another link
C
         GO TO 70
C
  110    CONTINUE
C
C             No more links; now delete NAME
C
         IQ(JVOLUM+IVO)=IBLA
C
      ELSE IF (IMENU.EQ.4) THEN
C
C             Unlink NAME,NR given by GSPOS/GSDIV
C
+SELF, IF=-USRJMP.
         CALL GUNLIV(IVO,NR,IVOMOT)
+SELF, IF=USRJMP.
         CALL JUMPT3(JUNLIV,IVO,NR,IVOMOT)
+SELF.
C
      ELSE IF (IMENU.EQ.5) THEN
C
C             Modify X0,Y0,Z0 of NAME,NR given by GSPOS
C
         X0=Q(JIN+5)
         Y0=Q(JIN+6)
         Z0=Q(JIN+7)
         CALL KUPROR('Give X0',X0)
         CALL KUPROR('Give Y0',Y0)
         CALL KUPROR('Give Z0',Z0)
         Q(JIN+5)=X0
         Q(JIN+6)=Y0
         Q(JIN+7)=Z0
C
      ELSE IF (IMENU.EQ.6) THEN
C
C             Modify IROT of NAME,NR given by GSPOS
C
         IROT=Q(JIN+4)
         CALL KUPROI('Give IROT',IROT)
         Q(JIN+4)=IROT
C
      ELSE IF (IMENU.EQ.7.OR.IMENU.EQ.8) THEN
C
         IF (IMENU.EQ.7) THEN
C
C             Modify NDIV given by GSDIV
C
            NDIV=Q(JDIV+3)
            CALL KUPROI('Give NDIV',NDIV)
            Q(JDIV+3)=NDIV
C
         ELSE
C
C             Modify IAXIS given by GSDIV
C
            IAXIS=Q(JDIV+1)
            CALL KUPROI('Give IAXIS',IAXIS)
            Q(JDIV+1)=IAXIS
C
         ENDIF
C
C             Unlink and delete NAME
C
         Q(JVOMOT+3)=0
         CALL MZDROP(IXCONS,LQ(JVOMOT-1),' ')
         JV = LQ(JVOLUM-IVOMOT)
         CALL MZPUSH(IXCONS,JV,-1,0,'I')
         CALL UHTOC(IQ(JVOLUM+IVO),4,NAMDIV,4)
         IQ(JVOLUM+IVO)=IBLA
C
C             Redivide (division is now at NVOLUM-th position)
C
         CALL UHTOC(IQ(JVOLUM+IVOMOT),4,NAMMOT,4)
         NDIV=Q(JDIV+3)
         IAXIS=Q(JDIV+1)
         CALL GSDVN(NAMDIV,NAMMOT,NDIV,IAXIS)
C
C             Swap new division with old one (links + names)
C
         CALL DZSWAP(IXCONS,LQ(JVOLUM-NVOLUM),LQ(JVOLUM-IVO),' ')
         IQ(JVOLUM+IVO)=IQ(JVOLUM+NVOLUM)
         IQ(JVOLUM+NVOLUM)=IBLA
         JVOMOT=LQ(JVOLUM-IVOMOT)
         JDIV=LQ(JVOMOT-1)
         Q(JDIV+2)=IVO
         CALL UCTOH(NAMDIV,IQ(JVOLUM+IVO),4,4)
C
C             Delete definitely old division
C
         CALL MZDROP(IXCONS,LQ(JVOLUM-NVOLUM),' ')
         CALL MZPUSH(IXCONS,JVOLUM,-1,-1,'I')
         NVOLUM=NVOLUM-1
C
      ENDIF
C
 1100 FORMAT('  PAR(',I2,') =',F10.3)
  999 RETURN
      END
+DECK,  GFIND, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GFIND(NAME,IAT,ISVALS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        For attribute IAT find value ISVALS                     *
C.    *        for the volume NAME                                     *
C.    *                                                                *
C.    *    1:  'WORK'   0=volume inactive   1=active volume            *
C.    *    2:  'SEEN'   0=unseen 1=seen -1,-2=tree unseen -3=tree opt. *
C.    *    3:  'LSTY'   line style 1,2,3,...                           *
C.    *    4:  'LWID'   line width 1,2,3,...                           *
C.    *    5:  'COLO'   color code 1,2,3,...                           *
C.    *    6:  'FILL'   fill area  0,1,2,...                           *
C.    *    7:  'SET '   set number associated to this volume           *
C.    *    8:  'DET '   detector number associated to this volume      *
C.    *    9:  'DTYP'   detector type (1,2)                            *
C.    *   10:  'NODE'   <>0=a node is created for 3D (PIONS,GMR,etc.)  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDPRTR,GDSPEC,GDTREE,GSDET, *
C.    *                   GSDETV,GSDVN,GSDVN2,GSDVT,GSDVT2,GSVOLU      *
C.    *          Author  S.Giani  *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
      CHARACTER*4 KATT(10),NAME,IAT
      DIMENSION LATT(10)
      SAVE KATT,IFIRST,LATT
      DATA KATT/'WORK','SEEN','LSTY','LWID','COLO','FILL','SET ',
     +'DET ','DTYP','NODE'/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
C              CHECK IF OPTION EXISTS
C
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KATT,LATT,4,40)
      ENDIF
C
      IPN=5
      IPS=7
C
C              CHECK IF OPTION EXISTS
C
      CALL GLOOK(IAT,LATT,10,IOP)
      IF(IOP.GT.0)GO TO 10
      WRITE(CHMAIL,2000)IAT
      CALL GMAIL(0,0)
      GO TO 99
C              CHECK IF VOLUME EXISTS
C
  10  IF(JVOLUM.GT.0)GO TO 20
      WRITE(CHMAIL,1000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
  20  IF(NAME(1:1).EQ.'*')GO TO 40
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVOLU)
      IF(IVOLU.GT.0)GO TO 30
      WRITE(CHMAIL,1000)NAME
      CALL GMAIL(0,0)
      GO TO 99
C
  30  JVO=LQ(JVOLUM-IVOLU)
      NPAR=Q(JVO+IPN)
      ISVALS=Q(JVO+NPAR+IPS-1+IOP)
      GO TO 99
C
C             SET OPTION VALUE FOR ALL DEFINED VOLUMES
C
  40  CONTINUE
*      DO 50 I=1,NVOLUM
      I=2
      JVO=LQ(JVOLUM-I)
      NPAR=Q(JVO+IPN)
      ISVALS=Q(JVO+NPAR+IPS-1+IOP)
*  50  CONTINUE
C
 1000 FORMAT(' GSATT VOLUME ',A4,' DOES NOT EXIST ')
 2000 FORMAT(' GSATT OPTION ',A4,' NOT IMPLEMENTED ')
  99  RETURN
      END
+DECK,  GKHITS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GKHITS (IUSET,IUDET,EPSILO)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints the hit picked (using the graphics cursor)        *
C.    *       from all the hits of all tracks in detector IUDET        *
C.    *       of set IUSET, in case that the spatial coordinates       *
C.    *       of the hits had been stored as the first three words     *
C.    *       in the argument vector of GSAHIT.                        *
C.    *       If the character typed to pick is 'K' or 'k' then the    *
C.    *       kinematics of the corresponding track is also printed.   *
C.    *       The picking is repeated until the character typed is     *
C.    *       'Q' or 'q'.                                              *
C.    *       EPSILO is the pick aperture, i.e. the first hit that     *
C.    *       falls into the square centered at U0,V0 (the pick point) *
C.    *       with half length EPSILO is kept.                         *
C.    *       If EPSILO is negative then its absolute value is taken   *
C.    *       and in addition the pick square is drawn.                *
C.    *       If EPSILO is zero there is no pick aperture and over all *
C.    *       the hits the one nearest to the pick point is taken.     *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Authors : R.Brun, W.Gebel, P.Zanarini   *********        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
      DIMENSION HITS(3,10)
      DIMENSION U(10),V(10)
      DIMENSION UP(5),VP(5)
      CHARACTER*4 IUSET,IUDET,KIUSET,KIUDET
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('OFF ',IOFF,4,4)
C
C            Set IOBJ to HIT
C
      IOBJ=3
C
   10 CONTINUE
C
      CALL GDCURS(U0,V0,KCHAR)
      IF (KCHAR.EQ.0) GO TO 160
C
      IF (JHITS.LE.0)           GOTO 160
      NSET = IQ(JSET-1)
      NS1        = 1
      NS2        = NSET
      IF (IUSET(1:1).EQ.'*')   GOTO  20
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET .LE.0)           GOTO 160
      NS1        = ISET
      NS2        = ISET
C
   20 CONTINUE
C
      EPSIL=ABS(EPSILO)
      EPSU=PLTRNX*EPSIL/20.
      EPSV=PLTRNY*EPSIL/20.
      IHITNR=0
      DISTPK=1000000.
C
C             Draw the pick box
C
      IF (EPSILO.LT.0) THEN
         UP(1)=U0-EPSU
         VP(1)=V0-EPSV
         UP(2)=U0+EPSU
         VP(2)=VP(1)
         UP(3)=UP(2)
         VP(3)=V0+EPSV
         UP(4)=UP(1)
         VP(4)=VP(3)
         UP(5)=UP(1)
         VP(5)=VP(1)
         CALL GDRAWV(UP,VP,5)
      ENDIF
C
C            loop on all selected sets
C
      DO 140   ISET=NS1,NS2
C
         JS = LQ(JSET-ISET)
         JH = LQ(JHITS-ISET)
         IF(JS.LE.0)GO TO 140
         IF(JH.LE.0)GO TO 140
         NDET = IQ(JS-1)
         ND1 = 1
         ND2 = NDET
         IF (IUDET(1:1).EQ.'*') GOTO 30
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF (IDET .EQ.0) GOTO 140
         ND1 = IDET
         ND2 = IDET
   30    CONTINUE
C
C            loop on selected detectors for this set
C
         DO 130 IDET=ND1,ND2
C
            JD = LQ(JS-IDET)
            JHD = LQ(JH-IDET)
            IF (JHD .LE.0) GOTO 130
            JDH = LQ(JD-1)
            ILAST = IQ(JH+IDET)
            IF (ILAST.EQ.0) GOTO 130
            NV = IQ(JD+2)
            NH = IQ(JD+4)
            NW = IQ(JD+1) + IQ(JD+3) + 1
C
C            Now loop on all hits to get their space coordinates
C
            MH = 0
            IHIT = 0
            DO 120 I=1,ILAST,NW
               IHIT = IHIT + 1
               ITRA = IQ(JHD+I)
C
C            Is THRZ option set on (R-Z projection)
C            and the cut lateral (vertical or horizontal) ?
C
               IF (ITHRZ.NE.IOFF) THEN
                  IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-ITRA
               ELSE
                  ITR3D=0
               ENDIF
C
C            Skip words with volume numbers
C
               NK = 1
               K = 1
               IF (NV.LE.0) GOTO 50
               DO 40 IV=1,NV
                  NB = IQ(JD+2*IV+10)
                  IF (NB.EQ.0) NB=32
                  K = NB + K
                  IF (K.LE.33) GOTO 40
                  NK = NK + 1
                  K = NB + 1
   40          CONTINUE
               NK = NK + 1
C
C            Get unpacked (first three !) HITS.
C            Hits origin is shifted. Division by scale factor.
C
   50          CONTINUE
               IF (NH.LE.2) GOTO 120
               MH = MH + 1
               K=1
               DO 90 IH=1,3
                  NB = IQ(JDH+4*IH-2)
                  IF (NB.GT.0) GOTO 60
                  IF (K.GT.1) THEN
                     NK=NK+1
                  ENDIF
                  KHIT = IQ(JHD+I+NK)
                  K = 1
                  NK = NK + 1
                  GOTO 80
   60             IF (K+NB.LE.33) GOTO 70
                  K = 1
                  NK = NK + 1
   70             KHIT = IBITS(IQ(JHD+I+NK),K-1,NB)
                  K = K + NB
   80             CONTINUE
                  HITS(IH,MH)= FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
   90          CONTINUE
C
C            Scan the hits (usually 10 at a time);
C            flush HITS vector if
C             --loop on this detector volume is to finish,
C             --loop on current track is to finish,
C             --HITS vector is full.
C
               IF ((ILAST-I).LT.NW) GOTO 100
               ITRN = IQ(JHD+I+NW)
               IF (ITRA.NE.ITRN) GOTO 100
               IF (MH .NE. 10) GOTO 120
C
  100          CONTINUE
C
               CALL GDFR3D(HITS(1,1),MH,U,V)
C
               DO 110 IP=1,MH
C
                  IF (EPSILO.NE.0) THEN
                     IF (U(IP).LT.U0-EPSU) GO TO 110
                     IF (U(IP).GT.U0+EPSU) GO TO 110
                     IF (V(IP).LT.V0-EPSV) GO TO 110
                     IF (V(IP).GT.V0+EPSV) GO TO 110
                     II=IP
                     IHITNR=IHIT-MH+II
                     JS = LQ(JSET-ISET)
                     CALL UHTOC(IQ(JSET+ISET),4,KIUSET,4)
                     CALL UHTOC(IQ(JS+IDET)  ,4,KIUDET,4)
                     KITRA=ITRA
                     GO TO 150
                  ELSE
                     DIST=(U(IP)-U0)*(U(IP)-U0)+(V(IP)-V0)*(V(IP)-V0)
                     IF (DIST.LT.DISTPK) THEN
                        DISTPK=DIST
                        II=IP
                        IHITNR=IHIT-MH+II
                        JS = LQ(JSET-ISET)
                        CALL UHTOC(IQ(JSET+ISET),4,KIUSET,4)
                        CALL UHTOC(IQ(JS+IDET)  ,4,KIUDET,4)
                        KITRA=ITRA
                     ENDIF
                  ENDIF
C
  110          CONTINUE
C
               MH=0
C
  120       CONTINUE
C
  130    CONTINUE
C
  140 CONTINUE
C
      IF (EPSILO.EQ.0) GO TO 150
C
C             Hit not picked
C
      WRITE (CHMAIL,1000)
      CALL GMAIL(0,0)
C
C             Restart for another pick operation
C
      GO TO 10
C
C             Hit picked
C
  150 CONTINUE
C
C             Highlight the picked hit
C
      UDELTA=0.05*PLTRNX/20.
      VDELTA=0.05*PLTRNY/20.
      UP(1)=U(II)-UDELTA
      VP(1)=V(II)-VDELTA
      UP(2)=U(II)+UDELTA
      VP(2)=VP(1)
      UP(3)=UP(2)
      VP(3)=V(II)+VDELTA
      UP(4)=UP(1)
      VP(4)=VP(3)
      UP(5)=UP(1)
      VP(5)=VP(1)
      CALL GDRAWV(UP,VP,5)
C
C             Print parameters of the picked hit
C
      IPKHIT=IHITNR
      IF (IPKHIT.GT.0) CALL GPHITS(KIUSET,KIUDET)
      IPKHIT=0
      CALL GPKINE(KITRA)
C
C             Restart for another pick operation
C
      GO TO 10
C
  160 CONTINUE
C
C             Reset ITR3D to 'standard projection'
C
      ITR3D=0
      IOBJ=0
C
 1000 FORMAT (' GKHITS: No hit picked')
      RETURN
      END
+DECK,  GKXYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GKXYZ(EPSILO)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints the kinematics of the track picked (using the     *
C.    *       graphics cursor) in case that the space points of the    *
C.    *       track had been stored in the bank JXYZ.                  *
C.    *       The picking is repeated until the character typed is     *
C.    *       'Q' or 'q'.                                              *
C.    *       EPSILO is the delta angle used for pick, in the sense    *
C.    *       that tracks to be considered as possible candidates      *
C.    *       must start with a direction in the angular range         *
C.    *       between ANG0-EPSILO and ANG0+EPSILO (where ANG0 is the   *
C.    *       angle relative to the cursor position).                  *
C.    *       If EPSILO is zero there is no delta angle concept and    *
C.    *       over all the track points the one nearest to the pick    *
C.    *       point is taken.                                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>                              *
C.    *       Author : P.Zanarini   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCONSP.
+CDE, GCUNIT.
      DIMENSION U(50),V(50)
      DIMENSION UP(5),VP(5)
C
      DIMENSION XZERO(3)
C
      SAVE XZERO
      DATA XZERO/3*0./
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH('OFF ',IOFF,4,4)
C
C            Set IOBJ to TRACK
C
      IOBJ=2
C
   10 CONTINUE
      CALL GDCURS(U0,V0,KCHAR)
      IF (KCHAR.EQ.0) GO TO 130
C
      IF(JXYZ.LE.0)GO TO 130
      NXYZ=IQ(JXYZ-2)
      N1  =1
      N2  =NXYZ
C
      CALL GDFR3D(XZERO,1,UOR,VOR)
      VATAN=V0-VOR
      UATAN=U0-UOR
      IF (VATAN.EQ.0..AND.UATAN.EQ.0.) THEN
         WRITE (CHMAIL,2200)
         CALL GMAIL(0,0)
         GO TO 130
      ENDIF
      ANG0=ATAN2(VATAN,UATAN)
      MAXWS=10000
      IF (EPSILO.EQ.0) MAXWS=MAXWS*2

C
   20 CONTINUE
      CALL GWORK(MAXWS)
      ANGEPS=ABS(EPSILO)
      EPSIL=1.
      EPS=MAX(PLTRNX,PLTRNY)*EPSIL/20.
      IBIAS=0
C
   30 CONTINUE
C
      DO 90 I=N1,N2
C
C             Track is not (yet) a canditate
C
         IFL=0
         ILOOP=0
C
         JX=LQ(JXYZ-I)
         IF(JX.LE.0)GO TO 90
         IPOINT=JX+3
   40    IF(IPOINT.GT.JX+IQ(JX-1))GO TO 90
         NPOINT=Q(IPOINT)
         IF(NPOINT.LE.0)GO TO 90
         IPF=1
   50    IPL=IPF+49
         IF(IPL.GT.NPOINT)IPL=NPOINT
         NP=IPL-IPF+1
         IF(NP.LE.1)GO TO 80
C
C            Is THRZ option set on (R-Z projection)
C            and the cut lateral (vertical or horizontal) ?
C
         IF (ITHRZ.NE.IOFF) THEN
            IF (ICUT.EQ.1.OR.ICUT.EQ.2) ITR3D=-I
         ELSE
            ITR3D=0
         ENDIF
C
         IF (EPSILO.EQ.0) GO TO 60
C
         IF (ILOOP.EQ.0) THEN
            ILOOP=1
C
            CALL GDFR3D(Q(IPOINT+3*IPF-1),2,U,V)
            CALL GDFR3D(Q(IPOINT+3*NPOINT-1),1,ULAST,VLAST)
C
            IF (U0.GE.UOR-EPS.AND.U0.LE.UOR+EPS.AND. V0.GE.VOR-EPS.AND.
     +      V0.LE.VOR+EPS) THEN
C
C             Pick point too near the origin
C
               IFL=1
               GO TO 60
            ELSE IF (U(1).LT.UOR-EPS.OR.U(1).GT.UOR+EPS.OR. V(1).LT.VOR-
     +      EPS.OR.V(1).GT.VOR+EPS) THEN
C
C             First track point does not start near the origin
C
               IFL=1
               GO TO 60
            ELSE
               VATAN=V(2)-V(1)
               UATAN=U(2)-U(1)
               IF (VATAN.EQ.0..AND.UATAN.EQ.0.) THEN
                  IFL=1
                  GO TO 60
               ENDIF
               ANG=ATAN2(VATAN,UATAN)
               VATAN=VLAST-V(1)
               UATAN=ULAST-U(1)
               IF (VATAN.EQ.0..AND.UATAN.EQ.0.) THEN
                  IFL=1
                  GO TO 60
               ENDIF
               ANGLST=ATAN2(VATAN,UATAN)
               IF (ANG.GT.(PI-ANGEPS).OR.ANG.LT.(-PI+ANGEPS)) THEN
C
C             First track point near the +PI/-PI edge
C
                  IFL=1
                  GO TO 60
               ELSE IF (ANG.GT.ANG0-ANGEPS.AND.ANG.LT.ANG0+ANGEPS) THEN
C
C             Pick point inside the pick angle
C
                  IFL=1
                  GO TO 60
               ELSE IF (ANGLST.LT.ANG-ANGEPS.OR.ANGLST.GT.ANG+ANGEPS)
     +         THEN
C
C             Track is too curved
C
                  IFL=1
                  GO TO 60
               ENDIF
            ENDIF
C
         ENDIF
C
C             Skip completely the track ?
C
         IF (IFL.NE.1) GO TO 90
C
   60    CONTINUE
C
         IF (IBIAS+3*NP.GE.MAXWS) THEN
            MAXWS=MAXWS*2
            GO TO 20
         ENDIF
C
         CALL GDFR3D(Q(IPOINT+3*IPF-1),NP,U,V)
C
         DO 70 L=1,NP
            WS(3*L-2+IBIAS)=U(L)
            WS(3*L-1+IBIAS)=V(L)
            WS(3*L+IBIAS)=I
   70    CONTINUE
C
         IBIAS=IBIAS+3*NP
C
         IPF=IPL
         IF(IPF.LT.NPOINT)GO TO 50
   80    IPOINT=IPOINT+3.*Q(IPOINT)+2.
         GO TO 40
C
   90 CONTINUE
C
C
      IF (IBIAS.EQ.0) THEN
         ANGEPS=ANGEPS*2.
         GO TO 30
      ENDIF
C
      DISMIN=1.
      DISTPK=1000000.
      IPK=0
C
      DO 120 I=1,IBIAS,3
         UPK=WS(I)
         VPK=WS(I+1)
         DIST=(UPK-U0)*(UPK-U0)+(VPK-V0)*(VPK-V0)
         IF (DIST.LT.DISTPK) THEN
            DISTPK=DIST
            IPK=I
         ENDIF
  120 CONTINUE
C
      IF (DISTPK.GT.DISMIN) THEN
         IT=0
      ELSE
         UPK=WS(IPK)
         VPK=WS(IPK+1)
         IT=WS(IPK+2)
      ENDIF
C
      IF (IT.EQ.0) THEN
C
         WRITE (CHMAIL,2000)
         CALL GMAIL(0,0)
C
      ELSE
C
C             Draw the picked track point
C
         UDELTA=0.05*PLTRNX/20.
         VDELTA=0.05*PLTRNY/20.
         UP(1)=UPK-UDELTA
         VP(1)=VPK-VDELTA
         UP(2)=UPK+UDELTA
         VP(2)=VP(1)
         UP(3)=UP(2)
         VP(3)=VPK+VDELTA
         UP(4)=UP(1)
         VP(4)=VP(3)
         UP(5)=UP(1)
         VP(5)=VP(1)
         CALL GDRAWV(UP,VP,5)
C
C             Print kinematics of the picked track
C
         CALL GPKINE(IT)
C
      ENDIF
C
C             Restart for another pick operation
C
      GO TO 10
C
  130 CONTINUE
C
C             Reset ITR3D to 'standard projection'
C
      ITR3D=0
      IOBJ=0
      RETURN
 1900 FORMAT (' GKXYZ: Work space doubled - Now is',I6)
 2000 FORMAT (' GKXYZ: No track picked')
 2100 FORMAT (' GKXYZ: Pick angle doubled - Now is',F5.2)
 2200 FORMAT (' GKXYZ: Primary vertex: no track picked')
      END
+DECK,  GLIGHT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GLIGHT(XXLL,YYLL,ZZLL,IILL)
*
+CDE, GCRAYT.
*
      IOMBRA=10
      XLPOS=XXLL
      YLPOS=YYLL
      ZLPOS=ZZLL
      INTEN=IILL
      IF(INTEN.EQ.0)IOMBRA=0
*
      END
+DECK,  GM3POL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GM3POL(X,N)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Dummy routine when GMR is not +USEd                        *
C.    *                                                                *
C.    *    ==>Called by : GDFR3D                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      END
+DECK,  GMCLOS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GMCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Dummy routine when GMR is not +USEd                        *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>                                      *
C.    *                                                                *
C.    ******************************************************************
C.
      END
+DECK,  GMOPEN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GMOPEN(XWIN,YWIN,ISTRUC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Dummy routine when GMR is not +USEd                        *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>                                      *
C.    *                                                                *
C.    ******************************************************************
C.
      END
+DECK,  GRESWK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GRESWK
*
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCSPEE.
*
*
      CALL IDAWK(2)
      CALL IACWK(1)
*      CALL ICLRWK(0,0)
*
 999  END
+DECK,  GSPE3D, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GSPE3D(NAME,TETA3,PHI3,PSI3,U03,V03,ZM3)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       This routine draws specifications of volume NAME         *
C.    *                                                                *
C.    *    ==>Called by : <USER>, <GXINT>, GDFSPC                      *
C.    *                                                                *
C.    *       Author :    S.Giani 29-10-92    ************             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCNUM.
+CDE, GCSHNO.
      COMMON/SP3D/ISPFLA
*
      CHARACTER*4 NAME,NAMSEE,ISON
      DIMENSION PAR(50)
      DIMENSION U0(3),V0(3),THE(3),PHI(3)
      DIMENSION U01(3),V01(3)
      DIMENSION NNDM(100),INDM(5,100),ATT(10)
      SAVE NNDM,INDM,U01,V01,THE,PHI,XMAN1,YMAN1
C
      DATA NNDM/0,0,0,4,0,2,0,2,4,3,4,3,0,0,13*0,5,72*0/
      DATA INDM/0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 2,3,7,11,0, 0,0,0,0,0,
     +          4,5,0,0,0, 0,0,0,0,0, 6,7,0,0,0, 3,4,5,6,0, 4,5,6,0,0,
     +          1,2,3,4,0, 1,2,3,0,0, 0,0,0,0,0, 70*0, 2,3,4,8,12,
     +          360*0/
C
      DATA U01/14.5,5.5,14.5/
      DATA V01/14.,5.,5./
      DATA THE/45.,0.,90./
      DATA PHI/135.,0.,180./
      DATA XMAN1/3./
      DATA YMAN1/3./
C.
C.    ------------------------------------------------------------------
C.
      CALL ICLRWK(1,1)
      ISPFLA=0
C             Is NAME an existing volume ?
C
      CALL IGRNG(20.,20.)
      CALL GLOOK(NAME,IQ(JVOLUM+1),NVOLUM,IVO)
      IF (IVO.LE.0) GO TO 999
C
C             Normalize to PLTRNX,PLTRNY
C
      DO 10 I=1,3
         U0(I)=U01(I)*PLTRNX/20.
         V0(I)=V01(I)*PLTRNY/20.
   10 CONTINUE
      XMAN=XMAN1*PLTRNX/20.
      YMAN=YMAN1*PLTRNY/20.
C
C             Save GDRAW calling parameters
C             and ZOOM internal parameters
C
      GTHETA=TETA3
      GPHI=PHI3
      GPSI=PSI3
*
      SAVTHE=GTHETA
      SAVPHI=GPHI
      SAVPSI=GPSI
      SAVU0=GU0
      SAVV0=GV0
      SAVSCU=GSCU
      SAVSCV=GSCV
      SVGZUA=GZUA
      SVGZVA=GZVA
      SVGZUB=GZUB
      SVGZVB=GZVB
      SVGZUC=GZUC
      SVGZVC=GZVC
      GZUA=1
      GZVA=1
      GZUB=0
      GZVB=0
      GZUC=0
      GZVC=0
C
C             Get shape type
C
      JVO=LQ(JVOLUM-IVO)
      ISHAPE=Q(JVO+2)
C
C             Get user parameters
C
      CALL GFPARA(NAME,1,0,NPAR,NATT,PAR,ATT)
      IF(NPAR.LE.0) GO TO 70
C
C
C             Check parameter sizes
C
      PARMAX=-1.
      DO 40 I=1,NPAR
         IF(NNDM(ISHAPE).LE.0) GO TO 30
         NDM=NNDM(ISHAPE)
         DO 20 IDM=1,NDM
            IF(I.EQ.INDM(IDM,ISHAPE)) GO TO 40
   20    CONTINUE
   30    ABSPAR=ABS(PAR(I))
         PARMAX=MAX(PARMAX,ABSPAR)
   40 CONTINUE
C
      AXSIZ=PARMAX*.5
      PARMAX=PARMAX/ZM3
      GSCU=MIN(PLTRNX,PLTRNY)/(7.*PARMAX)
      GSCV=GSCU
C
C             Draw header
C
      CALL GDHEAD(-1,NAME,0.)
C
C             Draw parameters list
C
C
C             Draw views
C
      CALL GFATT(NAME,'SEEN',KSEEN)
C
C             Add local value SEEN 1 to starting node of tree
C
      KSEEN=KSEEN+110
      ISEEN=KSEEN
      CALL GSATT(NAME,'SEEN',ISEEN)
C
      CALL GSATT(NAME,'COLO',2)
      CALL GDNSON(NAME,NSON,IDIV)
      DO 50  N=1,NSON
         CALL GDSON(N,NAME,ISON)
         CALL GFATT(ISON,'SEEN',KSEEN)
C
C             ISON is a volume with multiplicity;
C             first occurrence has already been set
C
         IF (KSEEN.GT.50) GO TO 50
C
C             Add local value SEEN -2 to each one-level-down node
C
         KSEEN=KSEEN+80
         ISEEN=KSEEN
         CALL GSATT(ISON,'SEEN',ISEEN)
C
         CALL GSATT(ISON,'COLO',4)
   50 CONTINUE
C
      ISPFLA=1
      CALL GDRAW(NAME,TETA3,PHI3,PSI3,U03,V03,GSCU,GSCV)
      CALL GDCOL(3)
*      XSCAL=PLTRNX/4.
*      YSCAL=PLTRNY/2.
      XSCAL=17.
      YSCAL=3.
      CALL GDSCAL(XSCAL,YSCAL)
**    IF (GSCU.LE.0.05) CALL GDMAN(XMAN,YMAN)
      IF (GSCU.LE.0.05) CALL GDWMN1(XMAN,YMAN)
      CALL GDAXIS(0.,0.,0.,AXSIZ)
      ISPFLA=0
C
      CALL GPVOLX(IVO)
*
      CALL GDCOL(0)
C
C             Reset global SEEN values
C
      DO 60  IVO=1,NVOLUM
         CALL UHTOC(IQ(JVOLUM+IVO),4,NAMSEE,4)
         CALL GFATT(NAMSEE,'SEEN',KSEEN)
         IF (KSEEN.LT.50) GO TO 60
         ISEENL=KSEEN/10.+0.5
         ISEENG=KSEEN-ISEENL*10.
         CALL GSATT(NAMSEE,'SEEN',ISEENG)
   60 CONTINUE
C
   70 CONTINUE
C
C             Restore GDRAW calling parameters
C             and ZOOM internal parameters
C
      GTHETA=SAVTHE
      GPHI=SAVPHI
      GPSI=SAVPSI
      GU0=SAVU0
      GV0=SAVV0
      GSCU=SAVSCU
      GSCV=SAVSCV
      NGVIEW=0
      GZUA=SVGZUA
      GZVA=SVGZVA
      GZUB=SVGZUB
      GZVB=SVGZVB
      GZUC=SVGZUC
      GZVC=SVGZVC
  999 END
+DECK,  GUNLIV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GUNLIV(IVO,NR,IVOMOT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Unlink a volume from its mother                          *
C.    *                                                                *
C.    *       IVO = volume pointer (input)                             *
C.    *       NR = volume number (input)                               *
C.    *       IVOMOT = mother volume pointer (input)                   *
C.    *                                                                *
C.    *    ==>Called by : GEDITV                                       *
C.    *       Author    P.Zanarini  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
C.
      JVOMOT=LQ(JVOLUM-IVOMOT)
      NIN=Q(JVOMOT+3)
      IF (NIN.LT.0) THEN
         Q(JVOMOT+3)=0
         CALL MZDROP(IXCONS,LQ(JVOMOT-1),' ')
         JV = LQ(JVOLUM-IVOMOT)
         CALL MZPUSH(IXCONS,JV,-1,0,'I')
      ELSE IF (NIN.EQ.1) THEN
         Q(JVOMOT+3)=0
         CALL MZDROP(IXCONS,LQ(JVOMOT-1),' ')
         JV = LQ(JVOLUM-IVOMOT)
         CALL MZPUSH(IXCONS,JV,-1,0,'I')
         JVOMOT=LQ(JVOLUM-IVOMOT)
         NL=IQ(JVOMOT-2)
         IF (NL.EQ.1) THEN
            CALL MZDROP(IXCONS,LQ(JVOMOT-1),' ')
            JV = LQ(JVOLUM-IVOMOT)
            CALL MZPUSH(IXCONS,JV,-1,0,'I')
         ENDIF
      ELSE IF (NIN.GT.1) THEN
         NL=IQ(JVOMOT-2)
         DO 10 IN=1,NL
            JIN=LQ(JVOMOT-IN)
            IF (Q(JIN+2).EQ.IVO.AND.Q(JIN+3).EQ.NR) GO TO 20
   10    CONTINUE
         GO TO 999
   20    Q(JVOMOT+3)=NIN-1
         DO 30 I=IN,NIN
            CALL DZSWAP(IXCONS,LQ(JVOMOT-I),LQ(JVOMOT-I-1),' ')
   30    CONTINUE
         CALL MZDROP(IXCONS,LQ(JVOMOT-NIN-1),' ')
         JV = LQ(JVOLUM-IVOMOT)
         CALL MZPUSH(IXCONS,JV,-1,0,'I')
         JVOMOT=LQ(JVOLUM-IVOMOT)
         JIN=LQ(JVOMOT-NIN)
         NIN=NIN-1
         DO 40 I=1,NIN
            Q(JIN+I)=I
            Q(JIN+I+NIN)=0
   40    CONTINUE
         JV = LQ(JVOMOT-NIN-1)
         CALL MZPUSH(IXCONS,JV,0,-2,'I')
      ENDIF
  999 RETURN
      END
+DECK,  GVIEWF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:30  cernlib
* Geant

      SUBROUTINE GVIEWF(U,V,NP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Draw the polyline described by U and V vectors,          *
C.    *       of length NP.                                            *
C.    *                                                                *
C.    *       Depending on IDVIEW it draws on screen (IDVIEW=0)        *
C.    *       or stores in the current view bank (IDVIEW>0).           *
C.    *                                                                *
C.    *       In LINATT (common GCDRAW) there is                       *
C.    *       a bit mask for the line attributes :                     *
C.    *                                                                *
C.    *       Bit  1- 7 = Used by view bank (LENGU)                    *
C.    *       Bit  8-10 = Line width                                   *
C.    *       Bit 11-13 = Line style                                   *
C.    *       Bit 14-16 = Fill area                                    *
C.    *       Bit 17-24 = Line color                                   *
C.    *                                                                *
C.    *    ==>Called by : GDRAWV                                       *
C.    *       Author : P.Zanarini ; S.Giani  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCDRAW.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCSPEE.
      DIMENSION U(*),V(*)
      SAVE LFILOL
      DATA LFILOL/-1/
C.
C.    ------------------------------------------------------------------
C.
C
C             Store on view bank IDVIEW
C
      JV=LQ(JDRAW-IDVIEW)
      IGU=IGU+1
C
   10 IF (IGU.LE.MAXGU) GO TO 20
C
C             Push graphic unit banks
C
      IF(MORGU.EQ.0)MORGU=100
      MORPUS=MAX(MORGU,MAXGU/4)
      JV = LQ(JV-1)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 40
      JV=LQ(JDRAW-IDVIEW)
      JV = LQ(JV-2)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 40
      JV=LQ(JDRAW-IDVIEW)
      MAXGU=MAXGU+MORPUS
      GO TO 10
C
   20 IF ((IGS+NP).LE.MAXGS) GO TO 30
C
C             Push graphic segment banks
C
      IF(MORGS.EQ.0)MORGS=100
      MORPUS=MAX(MORGS,MAXGS/4,NP)
      JV = LQ(JV-4)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 40
      JV=LQ(JDRAW-IDVIEW)
      JV = LQ(JV-5)
      CALL MZPUSH(IXCONS,JV,0,MORPUS,'I')
      IF(IEOTRI.NE.0)GO TO 40
      JV=LQ(JDRAW-IDVIEW)
      MAXGS=MAXGS+MORPUS
*
      GO TO 20
C
   30 CONTINUE
      Q(JV+13)=GTHETA
      Q(JV+14)=GPHI
      Q(JV+15)=GPSI
      Q(JV+16)=GU0
      Q(JV+17)=GV0
      Q(JV+18)=GSCU
      Q(JV+19)=GSCV
      JV1=LQ(JV-1)
      JV2=LQ(JV-2)
      JV4=LQ(JV-4)
      JV5=LQ(JV-5)
*
      CALL UCOPY(U,Q(JV4+IGS+1),NP)
      CALL UCOPY(V,Q(JV5+IGS+1),NP)
C
C             Bit 1- 7 = LENGU
C             Bit 8-24 = Line attribute
C
      ISUM=0
      CALL MVBITS(LINATT,0,24,ISUM,0)
      CALL MVBITS(NP,0,10,ISUM,0)
      Q(JV1+IGU)=ISUM
C
      Q(JV2+IGU)=IGS+1
      IGS=IGS+NP
      GO TO 999
C
   40 WRITE (CHMAIL,10000)
      CALL GMAIL(0,0)
C
10000 FORMAT (' *** GVIEWF ***: Memory overflow in pushing a bank')
  999 END
+PATCH, CGPACK.
+DECK,  CGAFFI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:41  cernlib
* Geant

      SUBROUTINE CGAFFI(TT,CG)
************************************************************************
*                                                                      *
*     Name: CGAFFI                                                     *
*     Author: E. Chernyaev                       Date:    24.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Affine transformation of CG-object                     *
*                                                                      *
*     References: CGTSTR                                               *
*                                                                      *
*     Input:  T(4,3) - transformation matrix                           *
*     Output:  CG(*) - CG-object                                       *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      TT(4,3),CG(*)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION T(4,3),X1,Y1,Z1,X2,Y2,Z2,
     +                 A,B,C,Q,S,XGRAV,YGRAV,ZGRAV
+SELF, IF=SINGLE.
      REAL      T(4,3)
+SELF.
*-
      TDEL   = EEWOR / 10.
      CALL CGTSTR(CG,IREP)
      IF (IREP .LT. 0)          GOTO 999
      DO 20 J=1,3
        DO 10 I=1,4
          T(I,J) = TT(I,J)
          IF (ABS(TT(I,J))    .LT. TDEL)        T(I,J) = 0.
          IF (ABS(1.-TT(I,J)) .LT. TDEL)        T(I,J) = 1.
          IF (ABS(1.+TT(I,J)) .LT. TDEL)        T(I,J) =-1.
   10     CONTINUE
   20   CONTINUE
*
**          T R A N S F E R   C O O R D I N A T E S
*
      NFACE  = CG(KCGNF)
      IF (NFACE .EQ. 0)         GOTO 999
      JCG    = LCGHEA
      DO 200 NF=1,NFACE
        NEDGE  = CG(JCG+KCGNE)
        JCG    = JCG + LCGFAC
        DO 100 NE=1,NEDGE
          X1     = CG(JCG+KCGX1)
          Y1     = CG(JCG+KCGY1)
          Z1     = CG(JCG+KCGZ1)
          X2     = CG(JCG+KCGX2)
          Y2     = CG(JCG+KCGY2)
          Z2     = CG(JCG+KCGZ2)
          CG(JCG+KCGX1) = T(1,1)*X1 + T(2,1)*Y1 + T(3,1)*Z1 + T(4,1)
          CG(JCG+KCGY1) = T(1,2)*X1 + T(2,2)*Y1 + T(3,2)*Z1 + T(4,2)
          CG(JCG+KCGZ1) = T(1,3)*X1 + T(2,3)*Y1 + T(3,3)*Z1 + T(4,3)
          CG(JCG+KCGX2) = T(1,1)*X2 + T(2,1)*Y2 + T(3,1)*Z2 + T(4,1)
          CG(JCG+KCGY2) = T(1,2)*X2 + T(2,2)*Y2 + T(3,2)*Z2 + T(4,2)
          CG(JCG+KCGZ2) = T(1,3)*X2 + T(2,3)*Y2 + T(3,3)*Z2 + T(4,3)
          JCG    = JCG + LCGEDG
  100     CONTINUE
  200   CONTINUE
*
**          S E T   N E W   N O R M A L E S
*
      JCG    = LCGHEA
      DO 400 NF=1,NFACE
        JCGFAC = JCG
        NEDGE  = CG(JCG+KCGNE)
        A      = (T(2,2)*T(3,3) - T(3,2)*T(2,3))*CG(JCG+KCGAA) +
     +           (T(3,2)*T(1,3) - T(1,2)*T(3,3))*CG(JCG+KCGBB) +
     +           (T(1,2)*T(2,3) - T(2,2)*T(1,3))*CG(JCG+KCGCC)
        B      = (T(2,3)*T(3,1) - T(3,3)*T(2,1))*CG(JCG+KCGAA) +
     +           (T(3,3)*T(1,1) - T(1,3)*T(3,1))*CG(JCG+KCGBB) +
     +           (T(1,3)*T(2,1) - T(2,3)*T(1,1))*CG(JCG+KCGCC)
        C      = (T(2,1)*T(3,2) - T(3,1)*T(2,2))*CG(JCG+KCGAA) +
     +           (T(3,1)*T(1,2) - T(1,1)*T(3,2))*CG(JCG+KCGBB) +
     +           (T(1,1)*T(2,2) - T(2,1)*T(1,2))*CG(JCG+KCGCC)
*        IF (ABS(A) .LT. EEWOR/10.)   A=0.
*        IF (ABS(B) .LT. EEWOR/10.)   B=0.
*        IF (ABS(C) .LT. EEWOR/10.)   C=0.
        Q      = A*A + B*B + C*C
        S      = 1.
        IF (Q.GT.1+TDEL .OR. Q.LT.1-TDEL)       S = SQRT(Q)
        IF(S.LT.TDEL)S=TDEL
        XGRAV  = 0.
        YGRAV  = 0.
        ZGRAV  = 0.
        JCG    = JCG + LCGFAC
        DO 300 NE=1,NEDGE
          XGRAV  = XGRAV + CG(JCG+KCGX1) + CG(JCG+KCGX2)
          YGRAV  = YGRAV + CG(JCG+KCGY1) + CG(JCG+KCGY2)
          ZGRAV  = ZGRAV + CG(JCG+KCGZ1) + CG(JCG+KCGZ2)
          JCG    = JCG + LCGEDG
  300     CONTINUE
        XGRAV  = XGRAV / (2*NEDGE)
        YGRAV  = YGRAV / (2*NEDGE)
        ZGRAV  = ZGRAV / (2*NEDGE)
        CG(JCGFAC+KCGAA) = A / S
        CG(JCGFAC+KCGBB) = B / S
        CG(JCGFAC+KCGCC) = C / S
        CG(JCGFAC+KCGDD) =-(A*XGRAV + B*YGRAV + C*ZGRAV) / S
  400   CONTINUE
*
  999 RETURN
      END
+DECK,  CGBFIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:41  cernlib
* Geant

      SUBROUTINE CGBFIT(FACE,ABCD,NT)
************************************************************************
*                                                                      *
*     Name: CGBFIT                                                     *
*     Author: E. Chernyaev                       Date:    15.03.89     *
*                                                Revised: S.Giani 1992 *
*                                                                      *
*     Function: Find all intersection points of face with plane        *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: FACE(*) - face                                            *
*            ABCD(4) - plane                                           *
*                                                                      *
*     Output: NT - number of intersections                             *
*                                                                      *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGCEDG.
+CDE, CGDELT.
      REAL      FACE(*),ABCD(4)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION  A,B,C,D
+SELF.
      INTEGER   KCG(6)
      DATA      KCG/KCGX1,KCGY1,KCGZ1,KCGX2,KCGY2,KCGZ2/
*-
      ERROR  = EEWOR
      A      = ABCD(1)
      B      = ABCD(2)
      C      = ABCD(3)
      D      = ABCD(4)
*      D1=0
*      D2=0
      XDELT  = FACE(KCGBB)*C - B*FACE(KCGCC)
      YDELT  = FACE(KCGCC)*A - C*FACE(KCGAA)
      ZDELT  = FACE(KCGAA)*B - A*FACE(KCGBB)
      K      = 1
      IF (ABS(YDELT) .GT. ABS(XDELT))           K = 2
      IF (ABS(ZDELT) .GT. ABS(DELTA(K)))        K = 3
      IF(ABS(DELTA(K)).LT.ERROR)RETURN
      DD     = 1./ABS(DELTA(K))
      DELTA(1)  = DELTA(1) * DD
      DELTA(2)  = DELTA(2) * DD
      DELTA(3)  = DELTA(3) * DD
      KCG1   = KCG(K)
      KCG2   = KCG(K+3)
*        F I N D   I N T E R S E C T I O N S   P O I N T S
      J      = LCGFAC - LCGEDG
      NT     = 0
      NEDGE  = FACE(KCGNE)
      DO 600 NE=1,NEDGE
        J      = J + LCGEDG
        D1     = A*FACE(J+KCGX1) + B*FACE(J+KCGY1) + C*FACE(J+KCGZ1) + D
        D2     = A*FACE(J+KCGX2) + B*FACE(J+KCGY2) + C*FACE(J+KCGZ2) + D
        IF (ABS(D1) .LE. ERROR)         D1 = 0.
        IF (ABS(D2) .LE. ERROR)         D2 = 0.
        IF (D1*D2 .GT. 0.)              GOTO 600
        NT     = NT + 1
        IF (D1.EQ.0. .AND. D2.EQ.0.)    GOTO 500
        IF (D1.LT.0. .OR.  D2.GT.0.)    TTT(2,NT) =-1.
        IF (D1.GT.0. .OR.  D2.LT.0.)    TTT(2,NT) =+1.
*           D 1   O R   D 2   I S   N O T   Z E R O
        IF (NT .NE. 1)                  GOTO 400
        XA     = (D2*FACE(J+KCGX1)-D1*FACE(J+KCGX2)) / (D2 - D1)
        YA     = (D2*FACE(J+KCGY1)-D1*FACE(J+KCGY2)) / (D2 - D1)
        ZA     = (D2*FACE(J+KCGZ1)-D1*FACE(J+KCGZ2)) / (D2 - D1)
        TTT(1,1)   = 0.
        GOTO 600
  400   X      = (D2*FACE(J+KCG1)-D1*FACE(J+KCG2)) / (D2 - D1)
        TTT(1,NT)  = (X - AA(K)) / DELTA(K)
        GOTO 600
*           D 1   A N D   D 2   B O T H   A R E   Z E R O
  500   IF (NT .NE. 1)                  GOTO 510
        XA     = FACE(J+KCGX1)
        YA     = FACE(J+KCGY1)
        ZA     = FACE(J+KCGZ1)
        TTT(1,1)   = 0.
        TTT(2,1)   = 0.
        GOTO 520
  510   X        = FACE(J+KCG1)
        TTT(1,NT)  = (X - AA(K)) / DELTA(K)
        TTT(2,NT)  = 0.
  520   NT       = NT + 1
        X        = FACE(J+KCG2)
        TTT(1,NT)  = (X - AA(K)) / DELTA(K)
        TTT(2,NT)  = 2.
        IF (TTT(1,NT) .GT. TTT(1,NT-1)) GOTO 600
        TTT(2,NT-1)= 2.
        TTT(2,NT)  = 0.
  600   CONTINUE
      RETURN
      END
+DECK,  CGBINT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBINT(A,B,NMAX,C,IREP)
************************************************************************
*                                                                      *
*     Name: CGBINT                                                     *
*     Author: E. Chernyaev                       Date:    23.10.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Intersection of two faces                              *
*                                                                      *
*     References: CGBMMT,CGBTEF,CGBSOR                                 *
*                                                                      *
*     Input: A(*) - 1-st face                                          *
*            B(*) - 2-nd face                                          *
*            NMAX - max length C array                                 *
*                                                                      *
*     Output: C(*) - resulting face                                    *
*             IREP - reply (legth of resulting face)                   *
*                          (-1 if no space)                            *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      A(*),B(*),C(*)
*-
      IF (NMAX .LT. LCGFAC)     GOTO 998
*           M I N - M A X   T E S T   O F   T W O   F A C E S
      CALL CGBMMT(A,B,IREP)
      IF (IREP .EQ. 0)          GOTO 999
*           T E S T   1 - S T   F A C E   A G A I N S T   2 - N D
      C(KCGAF) = NMAX
      C(KCGNE) = 0.
      NEDGE  = A(KCGNE)
      J      = LCGFAC
      INTRNL = -1
      IVAR   = 2
      DO 100 NE=1,NEDGE
        CALL CGBTEF(INTRNL,IVAR,A(J+1),B,C)
        IF (C(KCGAF) .LT. 0.)   GOTO 998
        J      = J + LCGEDG
  100   CONTINUE
*           T E S T   2 - N D   F A C E   A G A I N S T   1 - S T
      NEDGE  = B(KCGNE)
      J      = LCGFAC
      DO 200 NE=1,NEDGE
        CALL CGBTEF(INTRNL,IVAR,B(J+1),A,C)
        IF (C(KCGAF) .LT. 0.)   GOTO 998
        J      = J + LCGEDG
  200   CONTINUE
*           P R E P A R E   N E W   F A C E
      NEDGE = C(KCGNE)
      IF (NEDGE .EQ. 0)         GOTO 997
      CALL CGBSOR(NEDGE,C(LCGFAC+1))
      C(KCGNE) = NEDGE
      IF (NEDGE .EQ. 0)         GOTO 997
      IF (NEDGE .LT. 3) PRINT *,' CGBINT: NEDGE .LT. 3 - face ignored'
      IF (NEDGE .LT. 3)         GOTO 997
      C(KCGAF) = A(KCGAF)
      IF (B(KCGAF) .GT. A(KCGAF)) C(KCGAF) = B(KCGAF)
      C(KCGAA) = A(KCGAA)
      C(KCGBB) = A(KCGBB)
      C(KCGCC) = A(KCGCC)
      C(KCGDD) = A(KCGDD)
      IREP  = LCGFAC + NEDGE*LCGEDG
      GOTO 999
*
  997 IREP   = 0
      GOTO 999
  998 IREP = -1
  999 RETURN
      END
+DECK,  CGBMMT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBMMT(A,B,IREP)
************************************************************************
*                                                                      *
*     Name: CGBMMT                                                     *
*     Author: E. Chernyaev                       Date:    23.10.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Mim-max test of two faces                              *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: A(*) - 1-st face                                          *
*            B(*) - 2-nd face                                          *
*                                                                      *
*     Output: IREP - reply (=0 if NO intersection)                     *
*                          (=1 if there is intersection)               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      A(*),B(*),RMNA(3),RMXA(3),RMNB(3),RMXB(3)
      INTEGER   IND(6)
      DATA      IND/KCGX1,KCGY1,KCGZ1,KCGX2,KCGY2,KCGZ2/
*-
      JJ     =  LCGFAC
      DO 100 I=1,3
        RMNA(I)= A(JJ+IND(I))
        RMXA(I)= A(JJ+IND(I))
        RMNB(I)= B(JJ+IND(I))
        RMXB(I)= B(JJ+IND(I))
  100   CONTINUE
*           C O M P U T E   M I N - M A X   O F   1 - S T   F A C E
      NEDGE  = A(KCGNE)
      JJ     = LCGFAC
      DO 220 NE=1,NEDGE
        DO 210 J=1,3
          I      = J
          IF (J .GT. 3) I = J - 3
          IF (A(JJ+IND(J)) .LT. RMNA(I)) RMNA(I) = A(JJ+IND(J))
          IF (A(JJ+IND(J)) .GT. RMXA(I)) RMXA(I) = A(JJ+IND(J))
  210     CONTINUE
        JJ     = JJ + LCGEDG
  220   CONTINUE
*           C O M P U T E   M I N - M A X   O F   2 - N D   F A C E
      NEDGE  = B(KCGNE)
      JJ     = LCGFAC
      DO 320 NE=1,NEDGE
        DO 310 J=1,3
          I      = J
          IF (J .GT. 3) I = J - 3
          IF (B(JJ+IND(J)) .LT. RMNB(I)) RMNB(I) = B(JJ+IND(J))
          IF (B(JJ+IND(J)) .GT. RMXB(I)) RMXB(I) = B(JJ+IND(J))
  310     CONTINUE
        JJ     = JJ + LCGEDG
  320   CONTINUE
*           M I N - M A X   T E S T
      IREP   = 0
      IF (RMNA(1) .GT. RMXB(1)+EEWOR)   GOTO 999
      IF (RMXA(1) .LT. RMNB(1)-EEWOR)   GOTO 999
      IF (RMNA(2) .GT. RMXB(2)+EEWOR)   GOTO 999
      IF (RMXA(2) .LT. RMNB(2)-EEWOR)   GOTO 999
      IF (RMNA(3) .GT. RMXB(3)+EEWOR)   GOTO 999
      IF (RMXA(3) .LT. RMNB(3)-EEWOR)   GOTO 999
      IREP   = 1
*
  999 RETURN
      END
+DECK,  CGBOOL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBOOL(IFA,IFB,A,B,NMAX,C)
************************************************************************
*                                                                      *
*     Name: CGBOOL                                                     *
*     Author: E. Chernyaev                       Date:    05.04.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Make boolean operation with                            *
*                                                                      *
*     References: CGMNMX,CGCOPY,CGINVE,CGBSEA,CGBSEC,CGBINT,CGBSUB     *
*                                                                      *
*     Input: A(*) - 1-st CG-object                                     *
*            B(*) - 2-nd CG-object                                     *
*            NMAX - max length C array                                 *
*                                                                      *
*     Output: C(*) - resulting CG-object                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL              A(*),B(*),C(*),AMN(3),AMX(3),BMN(3),BMX(3)
*-
      C(KCGSIZ)   = 0.
*           T E S T   P A R A M E T E R S   C O R R E C T N E S S
      CALL CGMNMX(A,AMN,AMX)
      CALL CGMNMX(B,BMN,BMX)
      IF (AMN(1) .GT. AMX(1))           GOTO 999
      IF (BMN(1) .GT. BMX(1))           GOTO 999
      IF (NMAX .LT. LCGHEA)             GOTO 998
      IF (A(KCGNF)  .EQ. 0.)            GOTO 110
      IF (B(KCGNF)  .EQ. 0.)            GOTO 120
      GOTO 150
*           O B J E C T   "A"   I S   E M P T Y
  110 IF (IFA.NE.0 .AND. IFB.EQ.0)      GOTO 999
      IF (IFA .EQ. 0)                   CALL CGCOPY(B,NMAX,C)
      IF (IFB .NE. 0)                   CALL CGCOPY(A,NMAX,C)
      IF (C(KCGSIZ) .LT. 0.)            GOTO 998
      GOTO 999
*           O B J E C T   "B"   I S   E M P T Y
  120 IF (IFB .EQ. 0)                   CALL CGCOPY(A,NMAX,C)
      IF (IFB .NE. 0)                   CALL CGCOPY(B,NMAX,C)
      IF (C(KCGSIZ) .LT. 0.)            GOTO 998
      GOTO 999
*
**          M I N - M A X   T E S T
*
  150 DO 200 I=1,3
        IF (AMN(I) .GT. BMX(I)+EEWOR)   GOTO 210
        IF (AMX(I) .LT. BMN(I)-EEWOR)   GOTO 210
  200   CONTINUE
      GOTO 300
*
**          N O    I N T E R S E C T I O N   O F   S C O P E S
*
  210 IF (IFA.NE.0 .AND. IFB.NE.0)      GOTO 220
****  12-MAR-1990
*
*      IF (IFA.NE.0 .AND. IFB.EQ.0)      GOTO 220
      IF (IFA.NE.0 .AND. IFB.EQ.0)      GOTO 230
*
      IF (IFA.EQ.0 .AND. IFB.EQ.0)      GOTO 240
*           N O   I N T E R S E C T I O N
  220 C(KCGSIZ) = LCGHEA
      C(KCGATT) = 0.
      C(KCGNF)  = 0.
      GOTO 999
*           N O   S U B T R A C T I O N
  230 CALL CGCOPY(A,NMAX,C)
      IF (C(KCGSIZ) .LT. 0.)            GOTO 998
      GOTO 999
*           S I M P L E   S U M   O F   O B J E C T S
  240 LTOTAL = A(KCGSIZ) + B(KCGSIZ) - LCGHEA
      IF (LTOTAL .GT. NMAX)             GOTO 998
      J      = A(KCGSIZ) - LCGHEA + 1
      CALL CGCOPY(B,NMAX,C(J))
      CALL CGCOPY(A,NMAX,C)
      C(KCGSIZ) = LTOTAL
      C(KCGNF)  = A(KCGNF) + B(KCGNF)
      GOTO 999
*
**          F I N D   I N T E R S E C T I O N   O F   F A C E S
**          W I T H   T H E   S A M E   P L A N E
*
  300 IF (IFA .NE. 0)           CALL CGINVE(A)
      IF (IFB .NE. 0)           CALL CGINVE(B)
      JA     = LCGHEA
      JC     = LCGHEA
      NC     = 0
      NFACE  = A(KCGNF)
      DO 330 NF=1,NFACE
        JB     = LCGHEA
        NB     = 0
  310   CALL CGBSEA(A(JA+1),B,NB,JB)
        IF (NB .EQ. 0)  GOTO 320
        CALL CGBINT(A(JA+1),B(JB+1),NMAX-JC,C(JC+1),IREP)
        IF (IREP .LT. 0)        GOTO 997
        IF (IREP .EQ. 0)        GOTO 310
        NC     = NC + 1
        JC     = JC + IREP
        GOTO 310
  320   NEDGE  = A(JA+KCGNE)
        JA     = JA + LCGFAC + NEDGE*LCGEDG
  330   CONTINUE
*
**          F I N D   P A R T   O F   1 - S T   O B J E C T   W H I C H
**          L I E   O U T S I D E   O F   2 - N D   O B J E C T
*
      J      = LCGHEA
      NFACE  = A(KCGNF)
      DO 400 NF=1,NFACE
        JCSAV  = JC
        CALL CGBSEC(A(J+1),B,BMN,BMX,NMAX-JCSAV,C(JCSAV+1),IREP)
        IF (IREP .LT. 0)        GOTO 997
        JC     = JCSAV + IREP
        CALL CGBSUB(IFB,A(J+1),C(JCSAV+1),NMAX-JC,C(JC+1),IREP)
        IF (IREP .LT. 0)        GOTO 997
        JC     = JCSAV + IREP
        IF (IREP .GT. 0)        NC = NC + 1
        NEDGE  = A(J+KCGNE)
        J      = J + LCGFAC + NEDGE*LCGEDG
  400   CONTINUE
*
**          F I N D   P A R T   O F   2 - N D   O B J E C T   W H I C H
**          L I E   O U T S I D E   O F   1 - S T   O B J E C T
*
      J      = LCGHEA
      NFACE  = B(KCGNF)
      DO 500 NF=1,NFACE
        JCSAV  = JC
        CALL CGBSEC(B(J+1),A,AMN,AMX,NMAX-JCSAV,C(JCSAV+1),IREP)
        IF (IREP .LT. 0)        GOTO 997
        JC     = JCSAV + IREP
        CALL CGBSUB(IFA,B(J+1),C(JCSAV+1),NMAX-JC,C(JC+1),IREP)
        IF (IREP .LT. 0)        GOTO 997
        JC     = JCSAV + IREP
        IF (IREP .GT. 0)        NC = NC + 1
        NEDGE  = B(J+KCGNE)
        J      = J + LCGFAC + NEDGE*LCGEDG
  500   CONTINUE
*
      C(KCGSIZ) = JC
      C(KCGATT) = 0.
      C(KCGNF)  = NC
      IF (IFA.NE.0 .OR. IFB.NE.0)       CALL CGINVE(C)
*
  997 IF (IFA .NE. 0)                   CALL CGINVE(A)
      IF (IFB .NE. 0)                   CALL CGINVE(B)
      IF (IREP .GE. 0)                  GOTO 999
  998 C(KCGSIZ) = -1.
  999 RETURN
      END
+DECK,  CGBOX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBOX (XYZ,N1,N2,LCG,CG)
************************************************************************
*                                                                      *
*     Name: CGBOX                                                      *
*     Author: E. Chernyaev                       Date:    12.02.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Create CG-object for box                               *
*                                                                      *
*     References: CGSIZE, CGSNOR                                       *
*                                                                      *
*     Input: XYZ(3,N1+N2) - nodes                                      *
*                N1 - number of nodes in main base                     *
*                N2 - number of nodes in 2-nd base                     *
*               LCG - max-size of CG-object                            *
*                                                                      *
*     Output: CG - CG-object                                           *
*                  CG(1) - length of CG-object                         *
*                        = 0 if error in parameters                    *
*                        < 0 if no space                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      CG(*),XYZ(3,*)
      INTEGER   NFAC(2),NEDG(2)
*-
      CG(KCGSIZ)  = 0.
*           T E S T   P A R A M E T E R S   C O R R E C T N E S S
      IF (N1 .LT. 3)                    GOTO 999
      IF (N2.NE.N1 .AND. N2.NE.1)       GOTO 999
*           C O M P U T E   S I Z E   O F   C G - O B J E C T
      NFATYP = 2
      NEDG(1)= N1
      IF (N2 .NE. 1)                    NEDG(2) = 4
      IF (N2 .EQ. 1)                    NEDG(2) = 3
      IF (N2 .NE. 1)                    NFAC(1) = 2
      IF (N2 .EQ. 1)                    NFAC(1) = 1
      NFAC(2)= N1
      CG(KCGSIZ)  = CGSIZE(LCG,NFATYP,NFAC,NEDG)
      IF (CG(KCGSIZ) .LE. 0.)        GOTO 999
*
**          C R E A T E   C G - O B J E C T
*
      CG(KCGATT) = 0.
      CG(KCGNF)  = NFAC(1) + NFAC(2)
      JCG        = LCGHEA
*           C R E A T E   M A I N   B A S E
      CG(JCG + KCGAF) = 0.
      CG(JCG + KCGNE) = N1
      JCG    = JCG + LCGFAC
      DO 100 I=1,N1
        I1     = I
        I2     = I + 1
        IF (I .EQ. N1)          I2 = 1
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = XYZ(1,I1)
        CG(JCG+KCGY1) = XYZ(2,I1)
        CG(JCG+KCGZ1) = XYZ(3,I1)
        CG(JCG+KCGX2) = XYZ(1,I2)
        CG(JCG+KCGY2) = XYZ(2,I2)
        CG(JCG+KCGZ2) = XYZ(3,I2)
        JCG    = JCG + LCGEDG
  100   CONTINUE
*           C R E A T E   2 - N D   B A S E
      IF (N2 .EQ. 1)            GOTO 300
      CG(JCG + KCGAF) = 0.
      CG(JCG + KCGNE) = N2
      JCG    = JCG + LCGFAC
      DO 200 I=1,N2
        I1     = I
        I2     = I + 1
        IF (I .EQ. N2)          I2 = 1
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = XYZ(1,I2+N1)
        CG(JCG+KCGY1) = XYZ(2,I2+N1)
        CG(JCG+KCGZ1) = XYZ(3,I2+N1)
        CG(JCG+KCGX2) = XYZ(1,I1+N1)
        CG(JCG+KCGY2) = XYZ(2,I1+N1)
        CG(JCG+KCGZ2) = XYZ(3,I1+N1)
        JCG    = JCG + LCGEDG
  200   CONTINUE
*           C R E A T E   S I D E   F A C E S
  300 DO 350 I=1,N1
        I1     = I
        I2     = I + 1
        IF (I .EQ. N1)          I2 = 1
        CG(JCG + KCGAF) = 0.
        CG(JCG + KCGNE) = NEDG(2)
        JCG    = JCG + LCGFAC
*
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = XYZ(1,I2)
        CG(JCG+KCGY1) = XYZ(2,I2)
        CG(JCG+KCGZ1) = XYZ(3,I2)
        CG(JCG+KCGX2) = XYZ(1,I1)
        CG(JCG+KCGY2) = XYZ(2,I1)
        CG(JCG+KCGZ2) = XYZ(3,I1)
        JCG    = JCG + LCGEDG
*
        IF (N2 .NE. 1)          K = N1 + I1
        IF (N2 .EQ. 1)          K = N1 + 1
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = XYZ(1,I1)
        CG(JCG+KCGY1) = XYZ(2,I1)
        CG(JCG+KCGZ1) = XYZ(3,I1)
        CG(JCG+KCGX2) = XYZ(1,K)
        CG(JCG+KCGY2) = XYZ(2,K)
        CG(JCG+KCGZ2) = XYZ(3,K)
        JCG    = JCG + LCGEDG
*
        IF (N2 .EQ. 1)          GOTO 310
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = XYZ(1,I1+N1)
        CG(JCG+KCGY1) = XYZ(2,I1+N1)
        CG(JCG+KCGZ1) = XYZ(3,I1+N1)
        CG(JCG+KCGX2) = XYZ(1,I2+N1)
        CG(JCG+KCGY2) = XYZ(2,I2+N1)
        CG(JCG+KCGZ2) = XYZ(3,I2+N1)
        JCG    = JCG + LCGEDG
*
  310   IF (N2 .NE. 1)          K = N1 + I2
        IF (N2 .EQ. 1)          K = N1 + 1
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = XYZ(1,K)
        CG(JCG+KCGY1) = XYZ(2,K)
        CG(JCG+KCGZ1) = XYZ(3,K)
        CG(JCG+KCGX2) = XYZ(1,I2)
        CG(JCG+KCGY2) = XYZ(2,I2)
        CG(JCG+KCGZ2) = XYZ(3,I2)
        JCG    = JCG + LCGEDG
  350   CONTINUE
*           S E T   N O R M A L E S
      CALL CGSNOR(CG)
      IF (CG(1) .EQ. 0.) PRINT *, ' Problem in CGBOX'
      JCG    = LCGHEA
      A      = CG(JCG + KCGAA)
      B      = CG(JCG + KCGBB)
      C      = CG(JCG + KCGCC)
      D      = CG(JCG + KCGDD)
      DIST   = A*XYZ(1,N1+1) + B*XYZ(2,N1+1) + C*XYZ(3,N1+1) + D
      IF (DIST .LT. 0.)         GOTO 999
*           S E T   I N V E R S E   O R D E R   O F   E D G E S
      NFACE  = CG(KCGNF)
      DO 500 NF=1,NFACE
        CG(JCG + KCGAA) =-CG(JCG + KCGAA)
        CG(JCG + KCGBB) =-CG(JCG + KCGBB)
        CG(JCG + KCGCC) =-CG(JCG + KCGCC)
        CG(JCG + KCGDD) =-CG(JCG + KCGDD)
        NEDGE  = CG(JCG+KCGNE)
        JCG    = JCG + LCGFAC
        DO 400 NE=1,NEDGE
          X      = CG(JCG+KCGX1)
          Y      = CG(JCG+KCGY1)
          Z      = CG(JCG+KCGZ1)
          CG(JCG + KCGX1) = CG(JCG + KCGX2)
          CG(JCG + KCGY1) = CG(JCG + KCGY2)
          CG(JCG + KCGZ1) = CG(JCG + KCGZ2)
          CG(JCG + KCGX2) = X
          CG(JCG + KCGY2) = Y
          CG(JCG + KCGZ2) = Z
          JCG    = JCG + LCGEDG
  400     CONTINUE
  500   CONTINUE
*
  999 RETURN
      END
+DECK,  CGBRIK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBRIK(DX,DY,DZ,LCG,CG)
************************************************************************
*                                                                      *
*     Name: CGBRIK                                                     *
*     Author: E. Chernyaev                       Date:    24.03.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Create CG-object for BRICK                             *
*                                                                      *
*     References: CGSIZE                                               *
*                                                                      *
*     Input:  DX - X-size                                              *
*             DY - Y-size                                              *
*             DZ - Z-size                                              *
*            LCG - max-size of CG-object                               *
*                                                                      *
*     Output: CG - CG-object                                           *
*                  CG(1) - length of CG-object                         *
*                        = 0 if error in parameters                    *
*                        < 0 if no space                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      CG(*),XYZ(3,8)
      INTEGER   IORDER(4,6)
      SAVE XYZ,IORDER
      DATA      XYZ/24*0./
      DATA      IORDER/1,2,3,4,
     +                 1,5,6,2, 2,6,7,3, 3,7,8,4, 4,8,5,1,
     +                 8,7,6,5/
*-
      CG(KCGSIZ)  = 0.
*           T E S T   P A R A M E T E R S   C O R R E C T N E S S
      IF (DX.LE.0. .OR. DY.LE.0. .OR. DZ.LE.0.) GOTO 999
*           C O M P U T E   S I Z E   O F   C G - O B J E C T
      NFATYP   = 1
      NFAC     = 6
      NEDG     = 4
      CG(KCGSIZ)  = CGSIZE(LCG,NFATYP,NFAC,NEDG)
      IF (CG(KCGSIZ) .LE. 0.)        GOTO 999
*           P R E P A R E   N O D E S   C O O R D I N A T E S
      XYZ(2,2) =  DY
      XYZ(1,3) =  DX
      XYZ(2,3) =  DY
      XYZ(1,4) =  DX
      DO 100 I=1,4
        XYZ(1,I+4) = XYZ(1,I)
        XYZ(2,I+4) = XYZ(2,I)
        XYZ(3,I+4) = DZ
  100   CONTINUE
*           C R E A T E   C G - O B J E C T   F O R   B R I K
      CG(KCGATT) = 0.
      CG(KCGNF)  = 6.
      JCG    = LCGHEA
      DO 300 NF=1,6
        CG(JCG+KCGAF) = 0.
        X1     = XYZ(1,IORDER(2,NF))-XYZ(1,IORDER(1,NF))
        Y1     = XYZ(2,IORDER(2,NF))-XYZ(2,IORDER(1,NF))
        Z1     = XYZ(3,IORDER(2,NF))-XYZ(3,IORDER(1,NF))
        X2     = XYZ(1,IORDER(3,NF))-XYZ(1,IORDER(2,NF))
        Y2     = XYZ(2,IORDER(3,NF))-XYZ(2,IORDER(2,NF))
        Z2     = XYZ(3,IORDER(3,NF))-XYZ(3,IORDER(2,NF))
        A      = Y1*Z2 - Y2*Z1
        IF (A .GT. 0.)  A = 1.
        IF (A .LT. 0.)  A =-1.
        B      = X2*Z1 - X1*Z2
        IF (B .GT. 0.)  B = 1.
        IF (B .LT. 0.)  B =-1.
        C      = X1*Y2 - X2*Y1
        IF (C .GT. 0.)  C = 1.
        IF (C .LT. 0.)  C =-1.
        D      =-(A*XYZ(1,IORDER(1,NF)) +
     +            B*XYZ(2,IORDER(1,NF)) +
     +            C*XYZ(3,IORDER(1,NF)) )
        CG(JCG+KCGAA) = A
        CG(JCG+KCGBB) = B
        CG(JCG+KCGCC) = C
        CG(JCG+KCGDD) = D
        CG(JCG+KCGNE) = 4.
        JCG    = JCG + LCGFAC
        DO 200 NE=1,4
          NE2    = NE + 1
          IF (NE .EQ. 4) NE2 = 1
          CG(JCG+KCGAE) = 0.
          CG(JCG+KCGX1) = XYZ(1,IORDER(NE,NF))
          CG(JCG+KCGY1) = XYZ(2,IORDER(NE,NF))
          CG(JCG+KCGZ1) = XYZ(3,IORDER(NE,NF))
          CG(JCG+KCGX2) = XYZ(1,IORDER(NE2,NF))
          CG(JCG+KCGY2) = XYZ(2,IORDER(NE2,NF))
          CG(JCG+KCGZ2) = XYZ(3,IORDER(NE2,NF))
          JCG    = JCG + LCGEDG
  200     CONTINUE
  300   CONTINUE
*
  999 RETURN
      END
+DECK,  CGBSEA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBSEA(A,B,NB,JB)
************************************************************************
*                                                                      *
*     Name: CGBSEA                                                     *
*     Author: E. Chernyaev                       Date:    22.10.88     *
*                                                Revised:              *
*                                                                      *
*     Function: For face A search face with the same plane in object B *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: A(*) - face                                               *
*            B(*) - CG-object                                          *
*     Input                                                            *
*     Output: NB  - current face number in object B                    *
*             JB  - current pointer in object B                        *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      A(*),B(*),ABCD(4)
*-
      ABCD(1)= A(KCGAA)
      ABCD(2)= A(KCGBB)
      ABCD(3)= A(KCGCC)
      ABCD(4)= A(KCGDD)
      IF (NB .EQ. 0)            J = LCGHEA
      IF (NB .EQ. 0)            GOTO 100
      NEDGE  = B(JB+KCGNE)
      J      = JB + LCGFAC + NEDGE*LCGEDG
  100 NSTART = NB + 1
      NFACE  = B(KCGNF)
      IF (NSTART .GT. NFACE)    GOTO 998
      DO 120 NF=NSTART,NFACE
        IF (ABS(B(J+KCGAA)-ABCD(1)) .GT. EEWOR) GOTO 110
        IF (ABS(B(J+KCGBB)-ABCD(2)) .GT. EEWOR) GOTO 110
        IF (ABS(B(J+KCGCC)-ABCD(3)) .GT. EEWOR) GOTO 110
        IF (ABS(B(J+KCGDD)-ABCD(4)) .GT. EEWOR) GOTO 110
        NB     = NF
        JB     = J
        GOTO 999
  110   NEDGE  = B(J+KCGNE)
        J      = J + LCGFAC + NEDGE*LCGEDG
  120   CONTINUE
*
  998 NB     = 0
  999 RETURN
      END
+DECK,  CGBSEC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBSEC(FACE,CG,RMN,RMX,NMAX,C,IREP)
************************************************************************
*                                                                      *
*     Name: CGBTOP                                                     *
*     Author: E. Chernyaev                       Date:    24.10.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Section of CG-object by face plane                     *
*                                                                      *
*     References: CGBTFP, CGBSOR                                       *
*                                                                      *
*     Input: FACE(*) - plane                                           *
*            CG(*)   - CG-object                                       *
*            RMN(3)  - min of CG-object scope                          *
*            RMX(3)  - max of CG-object scope                          *
*            NMAX    - max length of C array                           *
*                                                                      *
*     Output: C(*)   - resulting face                                  *
*             IREP   - reply (length of resulitng face C)              *
*                            (-1 if no space)                          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      FACE(*),CG(*),RMN(3),RMX(3),C(*),D(8),ABCD(4)
*-
      IF (NMAX .LT. LCGFAC)     GOTO 998
      IREP   = 0
      C(KCGAF) = NMAX
      C(KCGNE) = 0.
      ABCD(1)= FACE(KCGAA)
      ABCD(2)= FACE(KCGBB)
      ABCD(3)= FACE(KCGCC)
      ABCD(4)= FACE(KCGDD)
*           M I N - M A X    T E S T
      D(1)   = ABCD(1)*RMN(1)+ABCD(2)*RMN(2)+ABCD(3)*RMN(3)+ABCD(4)
      D(2)   = ABCD(1)*RMX(1)+ABCD(2)*RMN(2)+ABCD(3)*RMN(3)+ABCD(4)
      D(3)   = ABCD(1)*RMN(1)+ABCD(2)*RMX(2)+ABCD(3)*RMN(3)+ABCD(4)
      D(4)   = ABCD(1)*RMX(1)+ABCD(2)*RMX(2)+ABCD(3)*RMN(3)+ABCD(4)
      D(5)   = ABCD(1)*RMN(1)+ABCD(2)*RMN(2)+ABCD(3)*RMX(3)+ABCD(4)
      D(6)   = ABCD(1)*RMX(1)+ABCD(2)*RMN(2)+ABCD(3)*RMX(3)+ABCD(4)
      D(7)   = ABCD(1)*RMN(1)+ABCD(2)*RMX(2)+ABCD(3)*RMX(3)+ABCD(4)
      D(8)   = ABCD(1)*RMX(1)+ABCD(2)*RMX(2)+ABCD(3)*RMX(3)+ABCD(4)
      NPOS   = 0
      NNEG   = 0
      DO 100 I=1,8
        IF (D(I) .GT. EEWOR)    NPOS = NPOS + 1
        IF (D(I) .LT.-EEWOR)    NNEG = NNEG + 1
  100   CONTINUE
      IF (NPOS.EQ.8 .OR. NNEG.EQ.8)     GOTO 999
*
      NFACE  = CG(KCGNF)
      JCG    = LCGHEA
      DO 200 NF=1,NFACE
        CALL CGBTFP(CG(JCG+1),ABCD,C)
        IF (C(KCGAF) .LT. 0.)   GOTO 998
        NEDGE  = CG(JCG+KCGNE)
        JCG    = JCG + LCGFAC + NEDGE*LCGEDG
  200   CONTINUE
*
**          S O R T   E G E S  &  D E L E T E   D O U B L E   E D G E S
*
      NEDGE  = C(KCGNE)
      CALL CGBSOR(NEDGE,C(LCGFAC+1))
      C(KCGNE) = NEDGE
      IF (NEDGE .EQ. 0)         GOTO 997
*      IF (NEDGE .LT. 3) PRINT *,' CGBSEC: NEDGE .LT. 3 - face ignored'
      IF (NEDGE .LT. 3)         GOTO 997
      C(KCGAA) = ABCD(1)
      C(KCGBB) = ABCD(2)
      C(KCGCC) = ABCD(3)
      C(KCGDD) = ABCD(4)
      J      = LCGFAC
      DO 300 NE=1,NEDGE
        C(J+KCGAE) = C(J+KCGAE) - 2.
        J    = J + LCGEDG
  300   CONTINUE
      IREP   = LCGFAC + LCGEDG*NEDGE
      GOTO 999
*
  997 IREP   = 0
      GOTO 999
  998 IREP   =-1
  999 RETURN
      END
+DECK,  CGBSOR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBSOR(NEDGE,EDGE)
************************************************************************
*                                                                      *
*     Name: CGBSOR                                                     *
*     Author: E. Chernyaev                       Date:    15.03.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Shell sort of edges                                    *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  NEDGE - number of edges                                  *
*     Output: EDGE(*,*)  - edges                                       *
*                                                                      *
*     Output:                                                          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      EDGE(LCGEDG,*)
*-
      ERROR  = 1.5*EEWOR
      ATRINV = 4.
      CALL CGSHEL(ATRINV,ERROR,NEDGE,EDGE)
*
**          D E L E T E   D O U B L E   E D G E S
**          A T R I B U T E   A N A L I S A T I O N
*
      IF (NEDGE .LE. 0)                 GOTO 999
      IF (NEDGE .EQ. 1)                 GOTO 810
      J       = 1
      NSAME = 1
      DO 800 NE=2,NEDGE
        IF (J .EQ. 0)                   GOTO 720
        IF (ABS(EDGE(KCGX1,NE)-EDGE(KCGX1,J)) .GT. ERROR) GOTO 720
        IF (ABS(EDGE(KCGY1,NE)-EDGE(KCGY1,J)) .GT. ERROR) GOTO 720
        IF (ABS(EDGE(KCGZ1,NE)-EDGE(KCGZ1,J)) .GT. ERROR) GOTO 720
        IF (ABS(EDGE(KCGX2,NE)-EDGE(KCGX2,J)) .GT. ERROR) GOTO 720
        IF (ABS(EDGE(KCGY2,NE)-EDGE(KCGY2,J)) .GT. ERROR) GOTO 720
        IF (ABS(EDGE(KCGZ2,NE)-EDGE(KCGZ2,J)) .GT. ERROR) GOTO 720
*           A T R I B U T E   A N A L I S A T I O N
        AJ     = EDGE(KCGAE,J)
        ANE    = EDGE(KCGAE,NE)
        IF (AJ .EQ. ANE)                GOTO 705
        IF (AJ.LE.-4. .AND. ANE.GT.-4.) GOTO 710
        IF (AJ.GT.-4. .AND. ANE.LE.-4.) GOTO 710
        IF (AJ .GT. ANE)                EDGE(KCGAE,J) = EDGE(KCGAE,NE)
  705   EDGE(KCGX1,J)=((EDGE(KCGX1,J)*NSAME)+EDGE(KCGX1,NE))/(NSAME+1)
        EDGE(KCGY1,J)=((EDGE(KCGY1,J)*NSAME)+EDGE(KCGY1,NE))/(NSAME+1)
        EDGE(KCGZ1,J)=((EDGE(KCGZ1,J)*NSAME)+EDGE(KCGZ1,NE))/(NSAME+1)
        EDGE(KCGX2,J)=((EDGE(KCGX2,J)*NSAME)+EDGE(KCGX2,NE))/(NSAME+1)
        EDGE(KCGY2,J)=((EDGE(KCGY2,J)*NSAME)+EDGE(KCGY2,NE))/(NSAME+1)
        EDGE(KCGZ2,J)=((EDGE(KCGZ2,J)*NSAME)+EDGE(KCGZ2,NE))/(NSAME+1)
        NSAME = NSAME + 1
        GOTO 800
*
  710   J      = J - 1
        GOTO 800
*
  720   J      = J + 1
        EDGE(KCGAE,J) = EDGE(KCGAE,NE)
        EDGE(KCGX1,J) = EDGE(KCGX1,NE)
        EDGE(KCGY1,J) = EDGE(KCGY1,NE)
        EDGE(KCGZ1,J) = EDGE(KCGZ1,NE)
        EDGE(KCGX2,J) = EDGE(KCGX2,NE)
        EDGE(KCGY2,J) = EDGE(KCGY2,NE)
        EDGE(KCGZ2,J) = EDGE(KCGZ2,NE)
        NSAME = 1
  800   CONTINUE
      NEDGE  = J
*
  810 DO 900 NE=1,NEDGE
        ANE    = EDGE(KCGAE,NE)
        IF (ANE .GE. -3.)       GOTO 850
        ANE    = ANE + 4.
        X      = EDGE(KCGX1,NE)
        Y      = EDGE(KCGY1,NE)
        Z      = EDGE(KCGZ1,NE)
        EDGE(KCGX1,NE) = EDGE(KCGX2,NE)
        EDGE(KCGY1,NE) = EDGE(KCGY2,NE)
        EDGE(KCGZ1,NE) = EDGE(KCGZ2,NE)
        EDGE(KCGX2,NE) = X
        EDGE(KCGY2,NE) = Y
        EDGE(KCGZ2,NE) = Z
  850   IF (ANE .LT. -1.)       ANE = ANE + 2.
        EDGE(KCGAE,NE) = ANE
  900   CONTINUE
*
  999 RETURN
      END
+DECK,  CGBSUB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBSUB(IFB,A,B,NMAX,C,IREP)
************************************************************************
*                                                                      *
*     Name: CGBSUB                                                     *
*     Author: E. Chernyaev                       Date:    23.10.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Subtraction of two faces                               *
*                                                                      *
*     References: CGBMMT,CGBTEF,CGBSOR                                 *
*                                                                      *
*     Input: IFB - flag (=1, if -B)
*            A(*) - 1-st face                                          *
*            B(*) - 2-nd face                                          *
*            NMAX - max length C array                                 *
*                                                                      *
*     Output: B(*) - resulting face                                    *
*             C(*) - working face                                      *
*             IREP - reply (legth of resulting face)                   *
*                          (-1 if no space)                            *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      A(*),B(*),C(*)
      DATA      IEXTNL/1/,IINTNL/-1/
*-
      NAEDGE  = A(KCGNE)
      NBEDGE  = B(KCGNE)
      IF (NBEDGE .EQ. 0)        GOTO 100
*           M I N - M A X   T E S T
      CALL CGBMMT(A,B,IREP)
      IF (IREP .NE. 0)          GOTO 200
*
**           N O   I N T E R S E C T I O N   O F   F A C E S
*
  100 IF (IFB .NE. 0)           GOTO 997
      LENB   = LCGFAC + NBEDGE*LCGEDG
      IREP   = LCGFAC + NAEDGE*LCGEDG
      IF (IREP .GT. NMAX+LENB)  GOTO 998
      DO 110 I=1,IREP
        B(I)   = A(I)
  110   CONTINUE
      GOTO 999
*
**          T E S T   1 - S T   F A C E   A G A I N S T   2 - N D
*
  200 IF (NMAX .LT. LCGFAC)     GOTO 998
      C(KCGAF) = NMAX
      C(KCGNE) = 0.
      IF (IFB .EQ. 0)           IFLAG = IEXTNL
      IF (IFB .NE. 0)           IFLAG = IINTNL
      IVAR   = 1
      J      = LCGFAC
      DO 210 NE=1,NAEDGE
        CALL CGBTEF(IFLAG,IVAR,A(J+1),B,C)
        IF (C(KCGAF) .LT. 0.)   GOTO 998
        J      = J + LCGEDG
  210   CONTINUE
*
**           T E S T   2 - N D   F A C E   A G A I N S T   1 - S T
*
      J      = LCGFAC
      DO 300 NE=1,NBEDGE
        CALL CGBTEF(IINTNL,IVAR,B(J+1),A,C)
        IF (C(KCGAF) .LT. 0.)   GOTO 998
        J      = J + LCGEDG
  300   CONTINUE
*           P R E P A R E   N E W   F A C E
      NEDGE = C(KCGNE)
      IF (NEDGE .EQ. 0)         GOTO 997
      CALL CGBSOR(NEDGE,C(LCGFAC+1))
      C(KCGNE) = NEDGE
      IF (NEDGE .EQ. 0)         GOTO 997
*      IF (NEDGE .LT. 3) PRINT *,' CGBSUB: NEDGE .LT. 3 - face ignored'
      C(KCGAF) = A(KCGAF)
      C(KCGAA) = A(KCGAA)
      C(KCGBB) = A(KCGBB)
      C(KCGCC) = A(KCGCC)
      C(KCGDD) = A(KCGDD)
      IREP  = LCGFAC + NEDGE*LCGEDG
      DO 400 I=1,IREP
        B(I)   = C(I)
  400   CONTINUE
      GOTO 999
*
  997 IREP   = 0
      GOTO 999
  998 IREP = -1
  999 RETURN
      END

+DECK,  CGBTEF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBTEF(IFEXT,IVAR,EDGE,FACE,C)
************************************************************************
*                                                                      *
*     Name: CGBTEF                                                     *
*     Author: E. Chernyaev                       Date:    23.10.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Test edge against face                                 *
*                                                                      *
*     References: CGBEDG, CGTSOR                                       *
*                                                                      *
*     Input: IFEXT - flag for searching external or internal intervals *
*                    ( 1 - external, -1 - internal)                    *
*             IVAR - number of variant                                 *
*                    ( 1 - visibility of intervals the same as edge)   *
*                    ( 2 - intervals are invisible)                    *
*          EDGE(*) - number of edges in face                           *
*        FACE(*,*) - face                                              *
*             NMAX - max length of C array                             *
*                                                                      *
*     Output: C(*) - a set of new edges                                *
*                    (C(KCGAF) = -1 if no space)                       *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGCEDG.
      CHARACTER*2 WHAT
      REAL      EDGE(LCGEDG),FACE(*),C(*),ABCD(4)
      INTEGER   KCG(6)
      DATA      KCG/KCGX1,KCGY1,KCGZ1,KCGX2,KCGY2,KCGZ2/
*-
**          F I N D   I N T E R S E C T I O N   P O I N T S
*
      IF (IFEXT .LE. 0)         WHAT = 'LE'
      IF (IFEXT .GT. 0)         WHAT = 'GE'
      XD     = EDGE(KCGX2) - EDGE(KCGX1)
      YD     = EDGE(KCGY2) - EDGE(KCGY1)
      ZD     = EDGE(KCGZ2) - EDGE(KCGZ1)
      ALENG  = SQRT(XD*XD + YD*YD + ZD*ZD)
      IF(ALENG.LT.1.0E-4)GOTO 998
      XD     = XD / ALENG
      YD     = YD / ALENG
      ZD     = ZD / ALENG
      ABCD(1)= YD*FACE(KCGCC) - FACE(KCGBB)*ZD
      ABCD(2)= ZD*FACE(KCGAA) - FACE(KCGCC)*XD
      ABCD(3)= XD*FACE(KCGBB) - FACE(KCGAA)*YD
      ABCD(4)=-(ABCD(1)*EDGE(KCGX1) +
     +          ABCD(2)*EDGE(KCGY1) +
     +          ABCD(3)*EDGE(KCGZ1))
      CALL CGBFIT(FACE,ABCD,NT)
      IF (NT .GT. 0)                    GOTO 100
      XA     = EDGE(KCGX1)
      YA     = EDGE(KCGY1)
      ZA     = EDGE(KCGZ1)
      XDELT  = EDGE(KCGX2) - EDGE(KCGX1)
      YDELT  = EDGE(KCGY2) - EDGE(KCGY1)
      ZDELT  = EDGE(KCGZ2) - EDGE(KCGZ1)
*
**          P R E P A R E   E D G E S
*
  100 K      = 1
      IF (ABS(YDELT) .GT. ABS(XDELT))   K = 2
      IF (ABS(ZDELT) .GT. ABS(DELTA(K))) K = 3
      TMIN   = (EDGE(KCG(K))    - AA(K)) / DELTA(K)
      TMAX   = (EDGE(KCG(K+3))  - AA(K)) / DELTA(K)
      CALL CGBTTT(WHAT,TMIN,TMAX,NT,NEDGE)
      IF (NEDGE .EQ. 0)                 GOTO 999
      IVIS   = EDGE(KCGAE)
      NMAX   = C(KCGAF)
      NN     = C(KCGNE)
      J      = LCGFAC + NN*LCGEDG
      IF (NMAX .LT. J + NEDGE*LCGEDG)   GOTO 998
      DO 500 NE=1,NEDGE
        IF (IVAR .EQ. 1)                C(J+KCGAE) = IVIS
        IF (IVAR .EQ. 2)                C(J+KCGAE) =-1.
        IF (ITTT(NE) .NE. 0)            C(J+KCGAE) = IVIS
        C(J+KCGX1) = XA + XDELT*TTT(1,NE)
        C(J+KCGY1) = YA + YDELT*TTT(1,NE)
        C(J+KCGZ1) = ZA + ZDELT*TTT(1,NE)
        C(J+KCGX2) = XA + XDELT*TTT(2,NE)
        C(J+KCGY2) = YA + YDELT*TTT(2,NE)
        C(J+KCGZ2) = ZA + ZDELT*TTT(2,NE)
        J      = J + LCGEDG
  500   CONTINUE
      C(KCGNE) = C(KCGNE) + NEDGE
      GOTO 999
*
  998 C(KCGAF) =-1.
  999 RETURN
      END
+DECK,  CGBTFP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBTFP(FACE,ABCD,CC)
************************************************************************
*                                                                      *
*     Name: CGBTFP                                                     *
*     Author: E. Chernyaev                       Date:    25.10.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Test face against plane                                *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: FACE(*) - face                                            *
*            ABCD(4) - plane                                           *
*                                                                      *
*     Output: C(*) - new edges                                         *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGCEDG.
+CDE, CGDELT.
      REAL      FACE(*),ABCD(4),CC(*)
*-
      NMAX   = CC(KCGAF)
      NEDGE  = CC(KCGNE)
      JC     = LCGFAC + NEDGE*LCGEDG
      NEDGE  = FACE(KCGNE)
      J      = LCGFAC
*
**          T E S T :   F A C E   L I E   I N   T H E   SAME PLANE
*
      IF (ABS(FACE(KCGAA)-ABCD(1)) .GT. EEWOR)  GOTO 200
      IF (ABS(FACE(KCGBB)-ABCD(2)) .GT. EEWOR)  GOTO 200
      IF (ABS(FACE(KCGCC)-ABCD(3)) .GT. EEWOR)  GOTO 200
      IF (ABS(FACE(KCGDD)-ABCD(4)) .GT. EEWOR)  GOTO 999
      IF (NMAX .LT. JC+NEDGE*LCGEDG)            GOTO 998
      DO 110 NE=1,NEDGE
        CC(JC+KCGAE) =-1.
        IF (ABS(FACE(J+KCGX1)-FACE(J+KCGX2)) .GT. EEWOR) GOTO 101
        IF (ABS(FACE(J+KCGY1)-FACE(J+KCGY2)) .GT. EEWOR) GOTO 101
        IF (ABS(FACE(J+KCGZ1)-FACE(J+KCGZ2)) .GT. EEWOR) GOTO 101
        PRINT *,' CGBTFP: very small face'
  101   CC(JC+KCGX1) = FACE(J+KCGX2)
        CC(JC+KCGY1) = FACE(J+KCGY2)
        CC(JC+KCGZ1) = FACE(J+KCGZ2)
        CC(JC+KCGX2) = FACE(J+KCGX1)
        CC(JC+KCGY2) = FACE(J+KCGY1)
        CC(JC+KCGZ2) = FACE(J+KCGZ1)
        JC     = JC + LCGEDG
        J      = J  + LCGEDG
  110   CONTINUE
      CC(KCGNE) = CC(KCGNE) + NEDGE
      GOTO 999
*
**          T E S T :   F A C E   L I E   I N   T H E   INVERSE PLANE
*
  200 IF (ABS(FACE(KCGAA)+ABCD(1)) .GT. EEWOR)  GOTO 300
      IF (ABS(FACE(KCGBB)+ABCD(2)) .GT. EEWOR)  GOTO 300
      IF (ABS(FACE(KCGCC)+ABCD(3)) .GT. EEWOR)  GOTO 300
      IF (ABS(FACE(KCGDD)+ABCD(4)) .GT. EEWOR)  GOTO 999
      IF (NMAX .LT. JC+NEDGE*LCGEDG)            GOTO 998
      DO 210 NE=1,NEDGE
        IF (ABS(FACE(J+KCGX1)-FACE(J+KCGX2)) .GT. EEWOR) GOTO 201
        IF (ABS(FACE(J+KCGY1)-FACE(J+KCGY2)) .GT. EEWOR) GOTO 201
        IF (ABS(FACE(J+KCGZ1)-FACE(J+KCGZ2)) .GT. EEWOR) GOTO 201
        PRINT *,' CGBTFP: very small face'
  201   CC(JC+KCGAE) = 0.
        CC(JC+KCGX1) = FACE(J+KCGX1)
        CC(JC+KCGY1) = FACE(J+KCGY1)
        CC(JC+KCGZ1) = FACE(J+KCGZ1)
        CC(JC+KCGX2) = FACE(J+KCGX2)
        CC(JC+KCGY2) = FACE(J+KCGY2)
        CC(JC+KCGZ2) = FACE(J+KCGZ2)
        JC     = JC + LCGEDG
        J      = J  + LCGEDG
  210   CONTINUE
      CC(KCGNE) = CC(KCGNE) + NEDGE
      GOTO 999
*           M A K E   F A C E   S L I C I N G
  300 CALL CGBFIT(FACE,ABCD,NT)
      IF (NT .EQ. 0)                    GOTO 999
*           P R E P A R E   E D G E S
      TMIN  = +1.
      TMAX  = -1.
      CALL CGBTTT('LE',TMIN,TMAX,NT,NEDGE)
      IF (NEDGE .EQ. 0)                 GOTO 999
      DO 700 NE=1,NEDGE
        IF (NMAX .LT. JC+LCGEDG)        GOTO 998
        CC(KCGNE)    = CC(KCGNE) + 1.
        CC(JC+KCGAE) = 0.
        CC(JC+KCGX1) = XA + XDELT*TTT(1,NE)
        CC(JC+KCGY1) = YA + YDELT*TTT(1,NE)
        CC(JC+KCGZ1) = ZA + ZDELT*TTT(1,NE)
        CC(JC+KCGX2) = XA + XDELT*TTT(2,NE)
        CC(JC+KCGY2) = YA + YDELT*TTT(2,NE)
        CC(JC+KCGZ2) = ZA + ZDELT*TTT(2,NE)
        JC     = JC + LCGEDG
  700   CONTINUE
      GOTO 999
*
  998 CC(KCGAF) =-1.
  999 RETURN
      END
+DECK,  CGBTTT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGBTTT(WHAT,TMIN,TMAX,NT,NEDGE)
************************************************************************
*                                                                      *
*     Name: CGBTTT                                                     *
*     Author: E. Chernyaev                       Date:    14.03.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Prepare list of T-intervals                            *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: WHAT - flag: what is need ('GT','GE','LT','LE')           *
*            TMIN - min of T                                           *
*            TMAX - max of T                                           *
*              NT - number of T-points                                 *
*                                                                      *
*     Output: NEDGE - number of edges                                  *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGCEDG.
+CDE, CGDELT.
      CHARACTER*2 WHAT
      CHARACTER*3 STATUS
*-
      TDEL   = 4.*EEWOR
      NE     = 0
      IF (NT .GE. 2)                    GOTO 100
*      IF (NT .EQ. 1)                    PRINT *,' CGBTTT: Number of T=1'
      IF (WHAT(1:1) .EQ. 'L')           GOTO 999
      TTT(1,1) = TMIN
      TTT(2,1) = TMAX
      ITTT(1)  = 0
      NE       = 1
      GOTO 999
*
**          S O R T    I N T E R S E C T I O N   P O I N T S
*
  100 DO 120 I=1,NT-1
        DO 110 J=I,1,-1
          IF (TTT(1,J+1) .GE. TTT(1,J)) GOTO 120
          T1         = TTT(1,J+1)
          T2         = TTT(2,J+1)
          TTT(1,J+1) = TTT(1,J)
          TTT(2,J+1) = TTT(2,J)
          TTT(1,J)   = T1
          TTT(2,J)   = T2
  110     CONTINUE
  120   CONTINUE
*
**         F I N D   S I G N   O F   1 - S T   P O I N T
*
  200 I1NEG  = 0
      I1POS  = 0
      I1ZBEG = 0
      I1ZEND = 0
      I1SIGN =-1
      T1     = TTT(1,1)
      DO 220 I=1,NT
        J      = I
        IF (TTT(1,I)-T1 .LE. TDEL)              GOTO 210
        IF (I1NEG .NE. I1POS)                   GOTO 240
        T1     = TTT(1,I)
        I1NEG  = 0
        I1POS  = 0
        I1ZBEG = 0
        I1ZEND = 0
  210   IF (TTT(2,I) .EQ. -1.)                  I1NEG  = 1
        IF (TTT(2,I) .EQ. +1.)                  I1POS  = 1
        IF (TTT(2,I) .EQ.  0.)                  I1ZBEG = 1
        IF (TTT(2,I) .EQ.  2.)                  I1ZEND = 1
  220   CONTINUE
      IF (I1NEG .EQ. I1POS)                     GOTO 250
  240 IF (I1NEG .EQ. 1)                         I1SIGN =-1
      IF (I1POS .EQ. 1)                         I1SIGN =+1
      IF (I1ZEND.EQ.1 .AND. I1ZBEG.EQ.0)        I1SIGN =-I1SIGN
*
  250 NNTT   = NT
      IF (WHAT(1:1) .EQ. 'L')   GOTO 300
      NNTT   = NT + 1
      TTT(1,NNTT) =+99999.
      TTT(2,NNTT) = I1SIGN
*
**          P R E P A R E   L I S T   O F   I N T E R V A L S
*
  300 T2     = -99999.
      I2NEG  = 0
      I2POS  = 0
      I2ZBEG = 0
      I2ZEND = 0
      IF (I1SIGN .LT. 0)        I2POS = 1
      IF (I1SIGN .GT. 0)        I2NEG = 1
      NE     = 0
      ITCUR  = 1
      STATUS = 'OUT'
*           S T A R T   O F   S E A R C H   F O R   N E X T   P O I N T
  310 T1     = T2
      I1NEG  = I2NEG
      I1POS  = I2POS
      I1ZBEG = I2ZBEG
      I1ZEND = I2ZEND
  320 IF (ITCUR .GT. NNTT)              GOTO 600
      T2     = TTT(1,ITCUR)
      I2NEG  = 0
      I2POS  = 0
      I2ZBEG = 0
      I2ZEND = 0
  330 IF (TTT(2,ITCUR) .EQ.-1.)         I2NEG  = 1
      IF (TTT(2,ITCUR) .EQ.+1.)         I2POS  = 1
      IF (TTT(2,ITCUR) .EQ. 0.)         I2ZBEG = 1
      IF (TTT(2,ITCUR) .EQ. 2.)         I2ZEND = 1
      ITCUR  = ITCUR + 1
      IF (ITCUR .GT. NNTT)              GOTO 400
      IF (TTT(1,ITCUR)-T2 .LE. TDEL)    GOTO 330
*           N E X T   P O I N T   I S   F O U N D E D
  400 T2     = (T2+TTT(1,ITCUR-1))/2.
      IF (I1ZBEG .NE. 0)                GOTO 410
      IF (I2ZBEG*I2ZEND .NE. 0)         GOTO 420
      IF (I2POS*I2NEG .NE. 0)           GOTO 530
      IF (I1SIGN.GT.0 .AND. I2POS.GT.0) GOTO 510
      IF (I1SIGN.LT.0 .AND. I2NEG.GT.0) GOTO 510
      IF (I1SIGN.GT.0 .AND. I2NEG.GT.0) GOTO 520
      IF (I1SIGN.LT.0 .AND. I2POS.GT.0) GOTO 520
      GOTO 310
*           B O U N D A R Y   E D G E
  410 NE        = NE + 1
      TTT(1,NE) = T1
      TTT(2,NE) = T2
      ITTT(NE)  = 1
      IF (I2ZEND .EQ. 0)                I2ZBEG = 1
  405 IF (I1SIGN.GT.0 .AND. I2POS.GT.0) STATUS = 'IN '
      IF (I1SIGN.LT.0 .AND. I2NEG.GT.0) STATUS = 'IN '
      IF (I1SIGN.GT.0 .AND. I2NEG.GT.0) STATUS = 'OUT'
      IF (I1SIGN.LT.0 .AND. I2POS.GT.0) STATUS = 'OUT'
      GOTO 310
*           V E R Y   S M A L L  B O U N D A R Y   E D G E
  420 IF (I2POS+I2NEG .EQ. 0)           GOTO 310
      I2ZBEG = 0
      I2ZEND = 0
      GOTO 405
*
**          C O M E   I N
*
  510 IF (STATUS .EQ. 'IN ')            GOTO 511
      IF (STATUS .EQ. 'OUT')            GOTO 512
  511 IF (WHAT(1:1) .EQ. 'L')           GOTO 550
      GOTO 310
  512 STATUS = 'IN '
      IF (WHAT(1:1) .EQ. 'G')           GOTO 550
      GOTO 310
*           C O M E   O U T
  520 IF (STATUS .EQ. 'IN ')            GOTO 521
      IF (STATUS .EQ. 'OUT')            GOTO 522
  521 STATUS = 'OUT'
      IF (WHAT(1:1) .EQ. 'L')           GOTO 550
      GOTO 310
  522 IF (WHAT(1:1) .EQ. 'L')           GOTO 550
      GOTO 310
*           C O M E   I N / O U T
  530 IF (STATUS .EQ. 'IN ')            GOTO 531
      IF (STATUS .EQ. 'OUT')            GOTO 532
  531 IF (WHAT(1:1) .EQ. 'L')           GOTO 550
      GOTO 310
  532 IF (WHAT(1:1) .EQ. 'G')           GOTO 550
      GOTO 310
*
  550 NE        = NE + 1
      TTT(1,NE) = T1
      TTT(2,NE) = T2
      ITTT(NE)  = 0
      GOTO 310
*
**          S K I P   B O U N D A R Y   E D G E S   (I F   N E E D)
*
  600 IF (NE .EQ. 0)            GOTO 999
      IF (WHAT(2:2) .EQ. 'E')   GOTO 700
      K      = 0
      DO 610 I=1,NE
        IF (ITTT(I) .EQ. 1)     GOTO 610
        K      = K + 1
        TTT(1,K) = TTT(1,I)
        TTT(2,K) = TTT(2,I)
        ITTT(K)  = ITTT(I)
  610   CONTINUE
      NE     = K
*
  700 IF (NE .EQ. 0)            GOTO 999
      IF (TMIN .GT. TMAX)       GOTO 999
      K      = 0
      DO 710 I=1,NE
        IF (TTT(2,I) .LE. TMIN) GOTO 710
        IF (TTT(1,I) .GE. TMAX) GOTO 720
        T1   = TTT(1,I)
        T2   = TTT(2,I)
        IF (T1 .LT. TMIN)       T1 = TMIN
        IF (T2 .GT. TMAX)       T2 = TMAX
        IF (T2-T1 .LT. TDEL)    GOTO 710
        K      = K + 1
        TTT(1,K) = T1
        TTT(2,K) = T2
        ITTT(K)  = ITTT(I)
  710   CONTINUE
  720 NE     = K
*
  999 NEDGE  = NE
      RETURN
      END
+DECK,  CGCEV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGCEV(IFVIS,CG)
************************************************************************
*                                                                      *
*     Name: CGCEV                                                      *
*     Author: E. Chernyaev                       Date:    05.02.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Change edge visibility                                 *
*                                                                      *
*     References: CGTSTR                                               *
*                                                                      *
*     Input:   IFVIS - flag (1 - visible, 0 - unvisible, -1 - inverse) *
*     Output: CG(*)  - CG-object                                       *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      CG(*)
*-
      CALL CGTSTR(CG,IREP)
      IF (IREP .LT. 0)          GOTO 999
      NFACE  = CG(KCGNF)
      IF (NFACE .EQ. 0)         GOTO 999
      JCG    = LCGHEA
      DO 200 NF=1,NFACE
        NEDGE  = CG(JCG+KCGNE)
        JCG    = JCG + LCGFAC
        DO 100 NE=1,NEDGE
          IF (IFVIS .GT. 0)     CG(JCG+KCGAE) = 0.
          IF (IFVIS .EQ. 0)     CG(JCG+KCGAE) =-1.
          IF (IFVIS .LT. 0)     CG(JCG+KCGAE) =-(CG(JCG+KCGAE) + 1.)
          JCG    = JCG + LCGEDG
  100     CONTINUE
  200   CONTINUE
*
  999 RETURN
      END
+DECK,  CGCOPY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGCOPY(A,NMAX,B)
************************************************************************
*                                                                      *
*     Name: CGCOPY                                                     *
*     Author: E. Chernyaev                       Date:    02.11.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Copy one CG-object to another                          *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: A(*)  - 1-st CG-object                                    *
*            NMAX  - max length B array                                *
*                                                                      *
*     Output: B(*) - resulting CG-object                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      A(*),B(*)
*-
      NSIZE     = A(KCGSIZ)
      B(KCGSIZ) = 0.
      IF (NSIZE .LE. 0)         GOTO 999
      IF (NMAX .LE. 0)          GOTO 999
      IF (NSIZE .GT. NMAX)      B(KCGSIZ) = NMAX - NSIZE
      IF (NSIZE .GT. NMAX)      GOTO 999
      DO 100 I=1,NSIZE
        B(I) = A(I)
  100   CONTINUE
*
  999 RETURN
      END
+DECK,  CGELLI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:42  cernlib
* Geant

      SUBROUTINE CGELLI(RX,RY,RZ,KA,KB,LCG,CG)
************************************************************************
*                                                                      *
*     Name: CGELLI                                                     *
*     Author: E. Chernyaev                       Date:    24.01.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Create CG-object for ELLIPSOID                         *
*                                                                      *
*     References: CGSIZE, CGSNOR                                       *
*                                                                      *
*     Input:  RX - 1-st radius                                         *
*             RY - 2-nd radius                                         *
*             RZ - 3-rd radius                                         *
*             KA - number of latitude step                             *
*             KB - number of longitude step                            *
*            LCG - max-size of CG-object                               *
*                                                                      *
*     Output: CG - CG-object                                           *
*                  CG(1) - length of CG-object                         *
*                        = 0 if error in parameters                    *
*                        < 0 if no space                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      CG(*)
      INTEGER   NFAC(2),NEDG(2)
*-
      CG(KCGSIZ)  = 0.
*           T E S T   P A R A M E T E R S   C O R R E C T N E S S
      IF (RX .LE. 0.)   GOTO 999
      IF (RY .LE. 0.)   GOTO 999
      IF (RZ .LE. 0.)   GOTO 999
      IF (KA .LT. 3)    GOTO 999
      IF (KB .LT. 2)    GOTO 999
*           C O M P U T E   S I Z E   O F   C G - O B J E C T
      NFATYP = 2
      NFAC(1)= 2 * KA
      NEDG(1)= 3
      NFAC(2)= (KB - 2) * KA
      NEDG(2)= 4
      CG(KCGSIZ)  = CGSIZE(LCG,NFATYP,NFAC,NEDG)
      IF (CG(KCGSIZ) .LE. 0.)        GOTO 999
*
**          C R E A T E   C G - O B J E C T   F O R   E L L I P S O I D
*
      CG(KCGATT) = 0.
      CG(KCGNF)  = NFAC(1) + NFAC(2)
      PI     = ATAN(1.) * 4.
      DA     = (PI+PI) / KA
      DB     = PI / KB
      JCOSB  = CG(KCGSIZ) - 2*(KB+KA) - 4
      JSINB  = JCOSB + KB + 1
      JCOSA  = JSINB + KB + 1
      JSINA  = JCOSA + KA + 1
*           P R E P A R E   W O R K   T A B L E
      A      = 0.
      B      = 0.
      JA     = 0
      JB     = 0
  100 CG(JCOSA+JA)     = COS(A)
      CG(JCOSA+KA-JA)  = CG(JCOSA+JA)
      CG(JSINA+JA)     = SIN(A)
      CG(JSINA+KA-JA)  =-CG(JSINA+JA)
      JA     = JA + 1
      A      = A + DA
      IF (KA-JA-JA) 200,110,100
  110 CG(JCOSA+JA)     =-1.
      CG(JSINA+JA)     = 0.
*
  200 CG(JCOSB+JB)    = COS(B)
      CG(JCOSB+KB-JB) =-CG(JCOSB+JB)
      CG(JSINB+JB)    = SIN(B)
      CG(JSINB+KB-JB) = CG(JSINB+JB)
      JB     = JB + 1
      B      = B + DB
      IF (KB-JB-JB) 300,210,200
  210 CG(JCOSB+JB)    = 0.
      CG(JSINB+JB)    = 1.
*           C R E A T E   U P P E R   H A L F   O F   E L L I P S O I D
  300 JCG    = LCGHEA
      NB     = KB - KB/2
      DO 500 JB=1,NB
        Z1     = RZ*CG(JCOSB+JB-1)
        Z2     = RZ*CG(JCOSB+JB)
        X4     = RX*CG(JSINB+JB-1)
        X3     = RX*CG(JSINB+JB)
        Y4     = 0.
        Y3     = 0.
        DO 400 JA=1,KA
          CG(JCG+KCGAF) = 0.
          JCGNE  = JCG + KCGNE
          JCG    = JCG + LCGFAC
          X1     = X4
          X2     = X3
          X3     = RX*CG(JSINB+JB)   * CG(JCOSA+JA)
          X4     = RX*CG(JSINB+JB-1) * CG(JCOSA+JA)
          Y1     = Y4
          Y2     = Y3
          Y3     = RY*CG(JSINB+JB)   * CG(JSINA+JA)
          Y4     = RY*CG(JSINB+JB-1) * CG(JSINA+JA)
          CG(JCG+KCGAE) =-1.
          CG(JCG+KCGX1) = X1
          CG(JCG+KCGY1) = Y1
          CG(JCG+KCGZ1) = Z1
          CG(JCG+KCGX2) = X2
          CG(JCG+KCGY2) = Y2
          CG(JCG+KCGZ2) = Z2
*
          CG(JCG+LCGEDG+KCGAE) =-1.
          CG(JCG+LCGEDG+KCGX1) = X2
          CG(JCG+LCGEDG+KCGY1) = Y2
          CG(JCG+LCGEDG+KCGZ1) = Z2
          CG(JCG+LCGEDG+KCGX2) = X3
          CG(JCG+LCGEDG+KCGY2) = Y3
          CG(JCG+LCGEDG+KCGZ2) = Z2
*
          CG(JCG+LCGEDG+LCGEDG+KCGAE) =-1.
          CG(JCG+LCGEDG+LCGEDG+KCGX1) = X3
          CG(JCG+LCGEDG+LCGEDG+KCGY1) = Y3
          CG(JCG+LCGEDG+LCGEDG+KCGZ1) = Z2
          CG(JCG+LCGEDG+LCGEDG+KCGX2) = X4
          CG(JCG+LCGEDG+LCGEDG+KCGY2) = Y4
          CG(JCG+LCGEDG+LCGEDG+KCGZ2) = Z1
          NE     = 3
          IF(X1.EQ.X4 .AND. Y1.EQ.Y4) GOTO 350
          NE     = 4
          CG(JCG+LCGEDG+LCGEDG+LCGEDG+KCGAE) =-1.
          CG(JCG+LCGEDG+LCGEDG+LCGEDG+KCGX1) = X4
          CG(JCG+LCGEDG+LCGEDG+LCGEDG+KCGY1) = Y4
          CG(JCG+LCGEDG+LCGEDG+LCGEDG+KCGZ1) = Z1
          CG(JCG+LCGEDG+LCGEDG+LCGEDG+KCGX2) = X1
          CG(JCG+LCGEDG+LCGEDG+LCGEDG+KCGY2) = Y1
          CG(JCG+LCGEDG+LCGEDG+LCGEDG+KCGZ2) = Z1
  350     JCG    = JCG + NE*LCGEDG
          CG(JCGNE) = NE
  400     CONTINUE
  500   CONTINUE
*           C R E A T E   L O W E R   H A L F   O F   E L L I P S O I D
      JSTOP  = JCG
      JCGUP  = LCGHEA
      JCGLOW = CG(KCGSIZ)
  600 NE     = CG(JCGUP+KCGNE)
      JCGLOW = JCGLOW - LCGFAC - NE*LCGEDG
      IF (JCGLOW .LT. JSTOP)    GOTO 999
      CG(JCGLOW+KCGAF) = CG(JCGUP+KCGAF)
      CG(JCGLOW+KCGNE) = NE
      JL     = JCGLOW + LCGFAC
      JU     = JCGUP  + LCGFAC
*
      CG(JL+KCGAE) = CG(JU+KCGAE)
      CG(JL+KCGX1) = CG(JU+KCGX2)
      CG(JL+KCGY1) = CG(JU+KCGY2)
      CG(JL+KCGZ1) =-CG(JU+KCGZ2)
      CG(JL+KCGX2) = CG(JU+KCGX1)
      CG(JL+KCGY2) = CG(JU+KCGY1)
      CG(JL+KCGZ2) =-CG(JU+KCGZ1)
      JU = JU + (NE-1)*LCGEDG
*
      CG(JL+LCGEDG+KCGAE) = CG(JU+KCGAE)
      CG(JL+LCGEDG+KCGX1) = CG(JU+KCGX2)
      CG(JL+LCGEDG+KCGY1) = CG(JU+KCGY2)
      CG(JL+LCGEDG+KCGZ1) =-CG(JU+KCGZ2)
      CG(JL+LCGEDG+KCGX2) = CG(JU+KCGX1)
      CG(JL+LCGEDG+KCGY2) = CG(JU+KCGY1)
      CG(JL+LCGEDG+KCGZ2) =-CG(JU+KCGZ1)
*
      CG(JL+LCGEDG+LCGEDG+KCGAE) = CG(JU-LCGEDG+KCGAE)
      CG(JL+LCGEDG+LCGEDG+KCGX1) = CG(JU-LCGEDG+KCGX2)
      CG(JL+LCGEDG+LCGEDG+KCGY1) = CG(JU-LCGEDG+KCGY2)
      CG(JL+LCGEDG+LCGEDG+KCGZ1) =-CG(JU-LCGEDG+KCGZ2)
      CG(JL+LCGEDG+LCGEDG+KCGX2) = CG(JU-LCGEDG+KCGX1)
      CG(JL+LCGEDG+LCGEDG+KCGY2) = CG(JU-LCGEDG+KCGY1)
      CG(JL+LCGEDG+LCGEDG+KCGZ2) =-CG(JU-LCGEDG+KCGZ1)
      IF (NE .EQ. 3)    GOTO 700
*
      CG(JL+LCGEDG+LCGEDG+LCGEDG+KCGAE) = CG(JU-LCGEDG-LCGEDG+KCGAE)
      CG(JL+LCGEDG+LCGEDG+LCGEDG+KCGX1) = CG(JU-LCGEDG-LCGEDG+KCGX2)
      CG(JL+LCGEDG+LCGEDG+LCGEDG+KCGY1) = CG(JU-LCGEDG-LCGEDG+KCGY2)
      CG(JL+LCGEDG+LCGEDG+LCGEDG+KCGZ1) =-CG(JU-LCGEDG-LCGEDG+KCGZ2)
      CG(JL+LCGEDG+LCGEDG+LCGEDG+KCGX2) = CG(JU-LCGEDG-LCGEDG+KCGX1)
      CG(JL+LCGEDG+LCGEDG+LCGEDG+KCGY2) = CG(JU-LCGEDG-LCGEDG+KCGY1)
      CG(JL+LCGEDG+LCGEDG+LCGEDG+KCGZ2) =-CG(JU-LCGEDG-LCGEDG+KCGZ1)
  700 JCGUP  = JCGUP + LCGFAC + NE*LCGEDG
      GOTO 600
*
  999 CALL CGSNOR(CG)
      RETURN
      END
+DECK,  CGFAC2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGFAC2(TVVX,TVVY,TVVZ,IN)
*
********************************************************************
*                                                                  *
* Function: Order edges in world coordinates for every face        *
*                                                                  *
* I/O parameters:                                                  *
* TVVX,TVVY,TVVZ = set of edge's coordinates                       *
* IN = number of edges *2.                                         *
*                                                                  *
* Author: S. Giani                                                 *
*                                                                  *
********************************************************************
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, CGGPAR.
+CDE, CGDELT.
+CDE, CGHPAR.
+CDE, CGCTRA.
+CDE, CGCEDG.
+CDE, GCDRAW.
+CDE, GCFLAG.
+CDE, GCSPEE.
*
      DIMENSION VVX(500),VVY(500),VVZ(500)
      DIMENSION TVVX(500),TVVY(500),TVVZ(500)
      DIMENSION IZ(500)
*
      JSC=0
      VVX(1)=TVVX(1)
      VVY(1)=TVVY(1)
      VVZ(1)=TVVZ(1)
      VVX(2)=TVVX(2)
      VVY(2)=TVVY(2)
      VVZ(2)=TVVZ(2)
      IZ(1)=1
      IZ(2)=2
      KZ=3
      DO 143 II=3,IN,2
       DO 144 JJ=3,IN
        DO 9 KK=1,KZ-1
         IF(JJ.EQ.IZ(KK))GOTO 144
 9      CONTINUE
          C11=ABS(TVVX(JJ)-VVX(II-1))
          C12=ABS(TVVY(JJ)-VVY(II-1))
          C13=ABS(TVVZ(JJ)-VVZ(II-1))
          IF(C11.LT..001.AND.C12.LT..001.AND.C13.LT..001)THEN
            VVX(II)=TVVX(JJ)
            VVY(II)=TVVY(JJ)
            VVZ(II)=TVVZ(JJ)
            IZ(KZ)=JJ
            AJ=JJ*.5
            IAJ=AJ
            PDAJ=AJ-IAJ
            IF(PDAJ.GT..01)THEN
              VVX(II+1)=TVVX(JJ+1)
              VVY(II+1)=TVVY(JJ+1)
              VVZ(II+1)=TVVZ(JJ+1)
              IZ(KZ+1)=JJ+1
              KZ=KZ+2
            ELSE
              VVX(II+1)=TVVX(JJ-1)
              VVY(II+1)=TVVY(JJ-1)
              VVZ(II+1)=TVVZ(JJ-1)
              IZ(KZ+1)=JJ-1
              KZ=KZ+2
            ENDIF
            GOTO 143
          ENDIF
 144   CONTINUE
       DO 11 JJA=3,IN
        DO 10 I=1,KZ-1
        IF(JJA.EQ.IZ(I))GOTO 11
 10     CONTINUE
        JJAO=JJA
        GOTO 12
 11     CONTINUE
        PRINT *,'Error in CGFACO'
 12     CONTINUE
        VVX(II)=TVVX(JJAO)
        VVY(II)=TVVY(JJAO)
        VVZ(II)=TVVZ(JJAO)
        VVX(II+1)=TVVX(JJAO+1)
        VVY(II+1)=TVVY(JJAO+1)
        VVZ(II+1)=TVVZ(JJAO+1)
        IZ(KZ)=JJAO
        IZ(KZ+1)=JJAO+1
        KZ=KZ+2
        JSC=II-1
 143  CONTINUE
      DO 145 KK=1,IN
       TVVX(KK)=VVX(KK)
       TVVY(KK)=VVY(KK)
       TVVZ(KK)=VVZ(KK)
 145  CONTINUE
*
 999  END

+DECK,  CGFACO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGFACO(VVX,VVY,IJKLMN,LFULL,APROSC)
*
********************************************************************
*                                                                  *
* Function: Fill fully visible faces with solid colour.            *
*           The colour is determined by the table in GDCOTA.       *
*           The intensity is determined in GDSHAD.                 *
*                                                                  *
* Author: S. Giani                                                 *
*                                                                  *
* I/O parameters:                                                  *
*                                                                  *
* VVX,VVY = set of edge's coordinates                              *
* IJKLMN  = number of edges *2.                                    *
* LFULL   = flag for full visibility                               *
* APROSC  = light intensity                                        *
*                                                                  *
********************************************************************
*
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, CGGPAR.
+CDE, CGDELT.
+CDE, CGHPAR.
+CDE, CGCTRA.
+CDE, CGCEDG.
+CDE, GCDRAW.
+CDE, GCFLAG.
+CDE, GCSPEE.
*
      DIMENSION VVX(500),VVY(500),IZ(500)
      DIMENSION TVVX(500),TVVY(500),IACTU(500)
*
      IACTU(1)=0
      IACT=1
      LINFIL=IBITS(LINATT,13,3)
      CALL ISFAIS(1)
      LINCOL=IBITS(LINATT,16,8)
      MPRECM=9-LINFIL
      IF(MPRECM.EQ.8)THEN
         CALL ISFACI(LINCOL)
         CALL ISPLCI(LINCOL)
      ELSE
         CALL GDSHAD(LINCOL,APROSC)
      ENDIF
*
      DO 10  I=1,IJKLMN
         TVVX(I)=VVX(I)
         TVVY(I)=VVY(I)
   10 CONTINUE
      VVX(1)=TVVX(1)
      VVY(1)=TVVY(1)
      VVX(2)=TVVX(2)
      VVY(2)=TVVY(2)
      IZ(1)=1
      IZ(2)=2
      KZ=3
      IGOR=IJKLMN/2
      DO 90  II=3,IGOR
         DO 40  JJ=3,IJKLMN
            DO 30 I=1,KZ-1
               IF(JJ.EQ.IZ(I))GOTO 40
   30       CONTINUE
            C11=ABS(TVVX(JJ)-VVX(II-1))
            C12=ABS(TVVY(JJ)-VVY(II-1))
            IF(C11.LT..001.AND.C12.LT..001)THEN
               PDJ=JJ*.5
               IPDJ=PDJ
               ARG=PDJ-IPDJ
               IF(ARG.GT..49)THEN
                  VVX(II)=TVVX(JJ+1)
                  VVY(II)=TVVY(JJ+1)
                  IZ(KZ)=JJ
                  IZ(KZ+1)=JJ+1
                  KZ=KZ+2
               ELSE
                  VVX(II)=TVVX(JJ-1)
                  VVY(II)=TVVY(JJ-1)
                  IZ(KZ)=JJ
                  IZ(KZ+1)=JJ-1
                  KZ=KZ+2
               ENDIF
               GOTO 90
            ENDIF
   40    CONTINUE
         IACT=IACT+1
         IACTU(IACT)=II-2
         NUMPON=IACTU(IACT)-IACTU(IACT-1)
         NUPO=IACTU(IACT-1)+1
         IF(NUMPON.GT.2)THEN
*            IF(LEP.LT.0)THEN
*               DO 50  IIJ=NUPO,NUPO+NUMPON-1
*                  IF(VVY(IIJ).LT.1.)VVY(IIJ)=1.
*   50          CONTINUE
*            ENDIF
            IF(IDVIEW.EQ.0)THEN
               CALL IFA(NUMPON,VVX(NUPO),VVY(NUPO))
            ELSE
               LLLINA=LINATT
               CALL MVBITS(LINCOL,0,8,LINATT,16)
               CALL GVIEWF(VVX(NUPO),VVY(NUPO),NUMPON)
               LINATT=LLLINA
            ENDIF
         ENDIF
         DO 70 JJA=3,IJKLMN
            DO 60 I=1,KZ-1
               IF(JJA.EQ.IZ(I))GOTO 70
   60       CONTINUE
            JJAO=JJA
            GOTO 80
   70    CONTINUE
         PRINT *,'Error in CGFACO'
   80    CONTINUE
         PDJJA=JJAO*.5
         IPDJJA=PDJJA
         ARG1=PDJJA-IPDJJA
         IF(ARG1.LT..01)PRINT *,'Error in CGFACO'
         VVX(II-1)=TVVX(JJAO)
         VVY(II-1)=TVVY(JJAO)
         VVX(II)=TVVX(JJAO+1)
         VVY(II)=TVVY(JJAO+1)
         IZ(KZ)=JJAO
         IZ(KZ+1)=JJAO+1
         KZ=KZ+2
   90 CONTINUE
*
      IACT=IACT+1
      IACTU(IACT)=IGOR
      NUMPON=IACTU(IACT)-IACTU(IACT-1)
      NUPO=IACTU(IACT-1)+1
      IF(NUMPON.GT.2)THEN
*         IF(LEP.LT.0)THEN
*            DO 100 IIJ=NUPO,NUPO+NUMPON-1
*               IF(VVY(IIJ).LT.1.)VVY(IIJ)=1.
*  100       CONTINUE
*         ENDIF
         IF(IDVIEW.EQ.0)THEN
            CALL IFA(NUMPON,VVX(NUPO),VVY(NUPO))
         ELSE
            LLLINA=LINATT
            CALL MVBITS(LINCOL,0,8,LINATT,16)
            CALL GVIEWF(VVX(NUPO),VVY(NUPO),NUMPON)
            LINATT=LLLINA
         ENDIF
      ENDIF
*
*      IF(IREP.EQ.0)PRINT *,IREP
      DO 120 I=1,KZ
         IZ(I)=0
         IACTU(I)=0
  120 CONTINUE
*
      END
+DECK,  CGFARE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGFARE(NT,FACE,IVIS,ISHAPE)
************************************************************************
*                                                                      *
*     Name: CGFARE                                                     *
*     Author: S. Giani                           Date:    20.05.91     *
*                                                Revised:              *
*                                                                      *
*     Function: HIDDEN FACE REMOVAL algoritm                           *
*               and transformation to screen coordinates               *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  NT - number of transformation to screen coordinates      *
*             FACE - face                                              *
*                                                                      *
*     Output: IVIS - visibility flag                                   *
*                    1 - if visible face                               *
*                   -1 - if unvisible                                  *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************
+CDE, CGCFAC.
+CDE, CGGPAR.
+CDE, CGDELT.
+CDE, CGCTRA.
+CDE, GCSPEE.
+CDE, GCMUTR.
***SG
      DIMENSION ACCMI1(6),ACCMI2(6),ACCMI3(6),
     +          ACCMA1(6),ACCMA2(6),ACCMA3(6)
      DIMENSION SMI(3),SMA(3),POMI(3),POMA(3)
      SAVE ACCMI1,ACCMI2,ACCMI3,ACCMA1,ACCMA2,ACCMA3
      SAVE POMI,POMA,ACCXT1,ACCXT2,ACCNT1,ACCNT2
***SG
      REAL      FACE(*)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION  T(4,3),A,B,C,S
+SELF, IF=SINGLE.
      REAL      T(4,3)
+SELF.
*-
      IVIS   = -1
      DO 120 I=1,4
         DO 110 J=1,3
            T(I,J) = TSCRN(I,J,NT)
  110    CONTINUE
  120 CONTINUE
*
***SG
**         HIDDEN FACE REMOVAL
*     Computing face scope and skipping if it's 'covered': this
*     can allow a great increase in speed and a great reduction
*     in number of memory words used.
*
         J = LCGFAC
         NTIM=NTIM+1
         SRFMI1 = FACE(J+KCGX1)
         SRFMI2 = FACE(J+KCGY1)
         SRFMI3 = FACE(J+KCGZ1)
         SRFMA1 = FACE(J+KCGX1)
         SRFMA2 = FACE(J+KCGY1)
         SRFMA3 = FACE(J+KCGZ1)
         NEDGE = FACE(KCGNE)
         DO 333 NE=1,NEDGE
            SRFMI1 = MIN(SRFMI1,FACE(J+KCGX1),FACE(J+KCGX2))
            SRFMI2 = MIN(SRFMI2,FACE(J+KCGY1),FACE(J+KCGY2))
            SRFMI3 = MIN(SRFMI3,FACE(J+KCGZ1),FACE(J+KCGZ2))
            SRFMA1 = MAX(SRFMA1,FACE(J+KCGX1),FACE(J+KCGX2))
            SRFMA2 = MAX(SRFMA2,FACE(J+KCGY1),FACE(J+KCGY2))
            SRFMA3 = MAX(SRFMA3,FACE(J+KCGZ1),FACE(J+KCGZ2))
            J = J + LCGEDG
  333    CONTINUE
*        If volume set limits
         IF(IPORLI.EQ.1)THEN
*         If no clipping or shifting or exploding mode
          IF(NAIN.EQ.0.AND.KSHIFT.EQ.0.AND.GBOOM.EQ.0)THEN
*          If volume created by cgbox
           IF(ISHAPE.LT.5.OR.ISHAPE.EQ.10)THEN
*           Set 'faces scope' for sublim faces created by cgbox
            ACCMI1(NTIM) = SRFMI1
            ACCMI2(NTIM) = SRFMI2
            ACCMI3(NTIM) = SRFMI3
            ACCMA1(NTIM) = SRFMA1
            ACCMA2(NTIM) = SRFMA2
            ACCMA3(NTIM) = SRFMA3
*           Set 'volume scope' for sublim faces of revolution
            POMI(1)=S1
            POMI(2)=S2
            POMI(3)=S3
            POMA(1)=SS1
            POMA(2)=SS2
            POMA(3)=SS3
            ACCXT2=SRAGMX
            ACCXT1=SRAGMN
            ACCNT1=RAINT1
            ACCNT2=RAINT2
*          If volume of revolution
           ELSE
*           Set 'faces scope' for sublim faces created by cgbox
            ACCMI1(4)=S1
            ACCMI1(6)=SS1
            ACCMI2(3)=SS2
            ACCMI2(5)=S2
            ACCMI3(1)=S3
            ACCMI3(2)=SS3
            ACCMA1(4)=S1
            ACCMA1(6)=SS1
            ACCMA2(3)=SS2
            ACCMA2(5)=S2
            ACCMA3(1)=S3
            ACCMA3(2)=SS3
*           Set 'volume scope' and 'radial scope' for sublim faces of revolution
            POMI(1)=S1
            POMI(2)=S2
            POMI(3)=S3
            POMA(1)=SS1
            POMA(2)=SS2
            POMA(3)=SS3
            ACCXT2=SRAGMX
            ACCXT1=SRAGMN
            ACCNT1=RAINT1
            ACCNT2=RAINT2
           ENDIF
*         If clipping or shifting or exploding mode on
          ELSE
*          Set 'volume scope' for all sublim faces, and 'radial scope' as
*          well for sublim faces of revolution
           POMI(1)=S1
           POMI(2)=S2
           POMI(3)=S3
           POMA(1)=SS1
           POMA(2)=SS2
           POMA(3)=SS3
           ACCXT2=SRAGMX
           ACCXT1=SRAGMN
           ACCNT1=RAINT1
           ACCNT2=RAINT2
          ENDIF
*        If volume is to be compared with limits
         ELSEIF(ISUBLI.EQ.1)THEN
*         If no clipping or shifting or exploding mode
          IF(NAIN.EQ.0.AND.KSHIFT.EQ.0.AND.GBOOM.EQ.0)THEN
*          If volume created by cgbox
           IF(ISHAPE.LT.5.OR.ISHAPE.EQ.10)THEN
*           Comparison face by face
            IF(NTIM.EQ.1)THEN
               IF(SRFMI3.GT.ACCMI3(NTIM).AND.SRFMA3
     +         .GT.ACCMA3(NTIM))GOTO 999
            ELSEIF(NTIM.EQ.2)THEN
               IF(SRFMI3.LT.ACCMI3(NTIM).AND.SRFMA3
     +         .LT.ACCMA3(NTIM))GOTO 999
            ELSEIF(NTIM.EQ.3)THEN
               IF(SRFMI2.LT.ACCMI2(NTIM).AND.SRFMA2
     +         .LT.ACCMA2(NTIM))GOTO 999
            ELSEIF(NTIM.EQ.5)THEN
               IF(SRFMI2.GT.ACCMI2(NTIM).AND.SRFMA2
     +         .GT.ACCMA2(NTIM))GOTO 999
            ELSEIF(NTIM.EQ.4)THEN
               IF(SRFMI1.GT.ACCMI1(NTIM).AND.SRFMA1
     +         .GT.ACCMA1(NTIM))GOTO 999
            ELSEIF(NTIM.EQ.6)THEN
               IF(SRFMI1.LT.ACCMI1(NTIM).AND.SRFMA1
     +         .LT.ACCMA1(NTIM))GOTO 999
            ENDIF
            GOTO 888
*          If volume of revolution
           ELSE
*           Comparison with mother scopes
            SMI(1)=SRFMI1
            SMI(2)=SRFMI2
            SMI(3)=SRFMI3
            SMA(1)=SRFMA1
            SMA(2)=SRFMA2
            SMA(3)=SRFMA3
            EXTRA1=RMAX1
            EXTRA2=RMAX2
            ENTRA1=RMIN1
            ENTRA2=RMIN2
*           If mother was created by cgbox or if it was of revolution
            ISP=0
            DO 127 I=1,3
             SPMI=SMI(I)-POMI(I)
             SPMA=SMA(I)-POMA(I)
             ASPMI=ABS(SPMI)
             ASPMA=ABS(SPMA)
             SMIA=SMI(I)-SMA(I)
             ASMIA=ABS(SMIA)
             IF(SPMI.GE.-0.001.AND.SPMA.LE.0.001)THEN
              ISP=ISP+1
              IF(ASPMI.LE.0.001.OR.ASPMA.LE.0.001)THEN
               IF(ASMIA.LE.0.001)GOTO 888
              ENDIF
             ENDIF
  127       CONTINUE
            IF(ISP.EQ.3)THEN
*            If mother was of revolution
             IF(ACCXT2.NE.0)THEN
              IF(ISCOP.EQ.1.AND.(ISHAPE.EQ.11.OR.ISHAPE.EQ.12
     +        .OR.ISHAPE.EQ.7.OR.ISHAPE.EQ.8))THEN
              EXXT1=EXTRA1-ACCXT1
              EXXT2=EXTRA2-ACCXT2
              ENNT1=ENTRA1-ACCNT1
              ENNT2=ENTRA2-ACCNT2
              IF(EXXT1.LT.-0.001.AND.EXXT2.LT.-0.001.AND.
     +        ENNT1.GT.0.001.AND.ENNT2.GT.0.001)THEN
               GOTO 999
              ELSEIF(EXXT1.LT.-0.001.AND.EXXT2.LT.-0.001.AND.
     +        ACCNT1.LT.0.001.AND.ACCNT2.LT.0.001)THEN
               GOTO 999
              ELSE
               GOTO 888
              ENDIF
              ELSE
              DO 701 ITER=1,IPORNT
                EXXT1=EXTRA1-PORMAR(ITER)
                EXXT2=EXTRA2-PORMAR(ITER)
                AEXXT1=ABS(EXXT1)
                AEXXT2=ABS(EXXT2)
                ENNT1=ENTRA1-PORMIR(ITER)
                ENNT2=ENTRA2-PORMIR(ITER)
                AENNT1=ABS(ENNT1)
                AENNT2=ABS(ENNT2)
                IF(AEXXT1.LT.0.001.OR.AEXXT2.LT.0.001)GOTO 888
                IF(AENNT1.LT.0.001.OR.AENNT2.LT.0.001)THEN
                  IF(PORMIR(ITER).NE.0.)GOTO 888
                ENDIF
 701          CONTINUE
              ENDIF
             ENDIF
             GOTO 999
            ELSE
             GOTO 888
            ENDIF
           ENDIF
*         If clipping or shifting or exploding mode on
          ELSE
*          Get scopes of the daughter (of each kind)
           SMI(1)=SRFMI1
           SMI(2)=SRFMI2
           SMI(3)=SRFMI3
           SMA(1)=SRFMA1
           SMA(2)=SRFMA2
           SMA(3)=SRFMA3
           EXTRA1=RMAX1
           EXTRA2=RMAX2
           ENTRA1=RMIN1
           ENTRA2=RMIN2
* If mother was clipped, check relative position of daughter and clipping
*   volumes; only if they don't interact, hidden face removal can work.
           DO 111 IJ=1,JPORJJ
            IFVFUN=0
            DO 301 J=1,3
             PMISMA=CLIPMI(J+3*IJ-3)-SMA(J)
             SMIPMA=SMI(J)-CLIPMA(J+3*IJ-3)
             APMISM=ABS(PMISMA)
             ASMIPM=ABS(SMIPMA)
             SMASMI=SMA(J)-SMI(J)
             ASMASM=ABS(SMASMI)
             IF(PMISMA.GE.-0.001.OR.
     +       SMIPMA.GE.-0.001)THEN
               IFVFUN=1
               IF(APMISM.LT.0.001.OR.
     +         ASMIPM.LT.0.001)THEN
                IF(ASMASM.LT.0.0001)GOTO 888
               ENDIF
               GO TO 302
             ENDIF
  301       CONTINUE
  302       CONTINUE
           IF(IFVFUN.EQ.0.AND.NAIN.NE.3)GO TO 888
  111      CONTINUE
*          If mother was created by cgbox or if it was of revolution
           ISP=0
           DO 128 I=1,3
            SPMI=SMI(I)-POMI(I)
            SPMA=SMA(I)-POMA(I)
            ASPMI=ABS(SPMI)
            ASPMA=ABS(SPMA)
            SMIA=SMI(I)-SMA(I)
            ASMIA=ABS(SMIA)
            IF(SPMI.GE.-0.001.AND.SPMA.LE.0.001)THEN
             ISP=ISP+1
             IF(ASPMI.LE.0.001.OR.ASPMA.LE.0.001)THEN
              IF(ASMIA.LE.0.001)GOTO 888
             ENDIF
            ENDIF
  128      CONTINUE
           IF(ISP.EQ.3)THEN
*           If mother was of revolution
            IF(ACCXT2.NE.0)THEN
              IF(ISCOP.EQ.1.AND.(ISHAPE.EQ.11.OR.ISHAPE.EQ.12
     +        .OR.ISHAPE.EQ.7.OR.ISHAPE.EQ.8))THEN
              EXXT1=EXTRA1-ACCXT1
              EXXT2=EXTRA2-ACCXT2
              ENNT1=ENTRA1-ACCNT1
              ENNT2=ENTRA2-ACCNT2
              IF(EXXT1.LT.-0.001.AND.EXXT2.LT.-0.001.AND.
     +        ENNT1.GT.0.001.AND.ENNT2.GT.0.001)THEN
               GOTO 999
              ELSEIF(EXXT1.LT.-0.001.AND.EXXT2.LT.-0.001.AND.
     +        ACCNT1.LT.0.001.AND.ACCNT2.LT.0.001)THEN
               GOTO 999
              ELSE
               GOTO 888
              ENDIF
              ELSE
              DO 702 ITER=1,IPORNT
                EXXT1=EXTRA1-PORMAR(ITER)
                EXXT2=EXTRA2-PORMAR(ITER)
                AEXXT1=ABS(EXXT1)
                AEXXT2=ABS(EXXT2)
                ENNT1=ENTRA1-PORMIR(ITER)
                ENNT2=ENTRA2-PORMIR(ITER)
                AENNT1=ABS(ENNT1)
                AENNT2=ABS(ENNT2)
                IF(AEXXT1.LT.0.001.OR.AEXXT2.LT.0.001)GOTO 888
                IF(AENNT1.LT.0.001.OR.AENNT2.LT.0.001)THEN
                  IF(PORMIR(ITER).NE.0.)GOTO 888
                ENDIF
 702          CONTINUE
              ENDIF
            ENDIF
            IF(ISCOP.EQ.1)THEN
             IF((ISHAPE.GT.1.AND.ISHAPE.LT.5).OR.ISHAPE.EQ.10)
     +       GOTO 888
            ENDIF
            GOTO 999
           ELSE
            GOTO 888
           ENDIF
          ENDIF
         ENDIF
 888  CONTINUE
*
***SG
*
      C      = (T(2,1)*T(3,2) - T(3,1)*T(2,2))*FACE(KCGAA) +
     +         (T(3,1)*T(1,2) - T(1,1)*T(3,2))*FACE(KCGBB) +
     +         (T(1,1)*T(2,2) - T(2,1)*T(1,2))*FACE(KCGCC)
      IF (C .LE. 0.)     GOTO 999
      B      = (T(2,3)*T(3,1) - T(3,3)*T(2,1))*FACE(KCGAA) +
     +         (T(3,3)*T(1,1) - T(1,3)*T(3,1))*FACE(KCGBB) +
     +         (T(1,3)*T(2,1) - T(2,3)*T(1,1))*FACE(KCGCC)
      A      = (T(2,2)*T(3,3) - T(3,2)*T(2,3))*FACE(KCGAA) +
     +         (T(3,2)*T(1,3) - T(1,2)*T(3,3))*FACE(KCGBB) +
     +         (T(1,2)*T(2,3) - T(2,2)*T(1,3))*FACE(KCGCC)
      S      = 1./SQRT(A*A+B*B+C*C)
      AABCD(1) = A*S
      AABCD(2) = B*S
      AABCD(3) = C*S
*
      F1(KCGAF) = FACE(KCGAF)
      F1(KCGNE) = FACE(KCGNE)
      F1(KCGAA) = 0.
      F1(KCGBB) = 0.
      F1(KCGCC) = 1.
      F1(KCGDD) = 0.
      F1(KCGNE) = FACE(KCGNE)
*
**           T R A S F E R   P O I N T   C O O R D I N A T E S
*
      NEDGE  = FACE(KCGNE)
      IF (LCGFAC+NEDGE*LCGEDG .GT. LABC)
     +       PRINT *, ' Problem in CGFVIS: no space'
      XGRAV  = 0.
      YGRAV  = 0.
      ZGRAV  = 0.
      J      = LCGFAC
      DO 200 NE=1,NEDGE
         F1(J+KCGAE) = FACE(J+KCGAE)
         X = FACE(J+KCGX1)
         Y = FACE(J+KCGY1)
         Z = FACE(J+KCGZ1)
         F1(J+KCGX1) = T(1,1)*X + T(2,1)*Y + T(3,1)*Z + T(4,1)
         F1(J+KCGY1) = T(1,2)*X + T(2,2)*Y + T(3,2)*Z + T(4,2)
         F1(J+KCGZ1) = T(1,3)*X + T(2,3)*Y + T(3,3)*Z + T(4,3)
         X = FACE(J+KCGX2)
         Y = FACE(J+KCGY2)
         Z = FACE(J+KCGZ2)
         F1(J+KCGX2) = T(1,1)*X + T(2,1)*Y + T(3,1)*Z + T(4,1)
         F1(J+KCGY2) = T(1,2)*X + T(2,2)*Y + T(3,2)*Z + T(4,2)
         F1(J+KCGZ2) = T(1,3)*X + T(2,3)*Y + T(3,3)*Z + T(4,3)
         XGRAV = XGRAV + F1(J+KCGX1) + F1(J+KCGX2)
         YGRAV = YGRAV + F1(J+KCGY1) + F1(J+KCGY2)
         ZGRAV = ZGRAV + F1(J+KCGZ1) + F1(J+KCGZ2)
         J = J + LCGEDG
  200 CONTINUE
      XFACT = 1./(2.*NEDGE)
      XGRAV = XGRAV * XFACT
      YGRAV = YGRAV * XFACT
      ZGRAV = ZGRAV * XFACT
      AABCD(4) =-(AABCD(1)*XGRAV + AABCD(2)*YGRAV + AABCD(3)*ZGRAV)
*
**           F I N D   F A C E   M I N - M A X
*
      J      = LCGFAC
      RFMIN(1) = F1(J+KCGX1)
      RFMIN(2) = F1(J+KCGY1)
      RFMIN(3) = F1(J+KCGZ1)
      RFMAX(1) = F1(J+KCGX1)
      RFMAX(2) = F1(J+KCGY1)
      RFMAX(3) = F1(J+KCGZ1)
      DO 300 NE=1,NEDGE
         RFMIN(1) = MIN(RFMIN(1),F1(J+KCGX1),F1(J+KCGX2))
         RFMIN(2) = MIN(RFMIN(2),F1(J+KCGY1),F1(J+KCGY2))
         RFMIN(3) = MIN(RFMIN(3),F1(J+KCGZ1),F1(J+KCGZ2))
         RFMAX(1) = MAX(RFMAX(1),F1(J+KCGX1),F1(J+KCGX2))
         RFMAX(2) = MAX(RFMAX(2),F1(J+KCGY1),F1(J+KCGY2))
         RFMAX(3) = MAX(RFMAX(3),F1(J+KCGZ1),F1(J+KCGZ2))
         F1(J+KCGZ1) = 0.
         F1(J+KCGZ2) = 0.
         J = J + LCGEDG
  300 CONTINUE
      DRFACE(1) =-RFMAX(1)
      DRFACE(2) =-RFMAX(2)
      DRFACE(3) = RFMIN(1)
      DRFACE(4) = RFMIN(2)
      DRFACE(5) = RFMIN(3)
*
**          C O M P U T E    F A C E    V I S I B L E    A R E A
*
      J      = LCGFAC
      S      = 0.
      DLMAX  = 0.
      DO 400 NE=1,NEDGE
         S = S + F1(J+KCGX1)*F1(J+KCGY2) - F1(J+KCGX2)*F1(J+KCGY1)
         DL = ABS(F1(J+KCGX2)-F1(J+KCGX1)) + ABS(F1(J+KCGY2)-F1(J+
     +   KCGY1))
         IF (DLMAX .LT. DL) DLMAX = DL
         J = J + LCGEDG
  400 CONTINUE
      IF (DLMAX .LT. EESCR)     GOTO 999
      IF (S .GT. DLMAX*EESCR)   IVIS = 1
*
  999 RETURN
      END
+DECK,  CGFVIS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGFVIS(NT,FACE,IVIS,ISHAPE)
************************************************************************
*                                                                      *
*     Name: CGFVIS                                                     *
*     Authors: E. Chernyaev, S. Giani            Date:    01.08.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Transfer face to screen coordinates                    *
*               and find face min-max and face visibility              *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  NT - number of transformation to screen coordinates      *
*             FACE - face                                              *
*                                                                      *
*     Output: IVIS - visibility flag                                   *
*                    1 - if visible face                               *
*                   -1 - if unvisible                                  *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGCFAC.
+CDE, CGGPAR.
+CDE, CGDELT.
+CDE, CGCTRA.
+CDE, GCSPEE.
***SG
      DIMENSION ACCMI1(6),ACCMI2(6),ACCMI3(6),
     +          ACCMA1(6),ACCMA2(6),ACCMA3(6)
***SG
      REAL      FACE(*)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION  T(4,3),A,B,C,S
+SELF, IF=SINGLE.
      REAL      T(4,3)
+SELF.
*-
      IVIS   = -1
      DO 120 I=1,4
         DO 110 J=1,3
            T(I,J) = TSCRN(I,J,NT)
  110    CONTINUE
  120 CONTINUE
*
***SG
**         HIDDEN FACE REMOVAL
*     Computing face scope and skipping if it's 'covered': this
*     can allow a great increase in speed and a great reduction
*     in number of memory words used.
*
      IF(ISHAPE.LE.4.OR.ISHAPE.EQ.10)THEN
         NTIM=NTIM+1
         J = LCGFAC
         SRFMI1 = FACE(J+KCGX1)
         SRFMI2 = FACE(J+KCGY1)
         SRFMI3 = FACE(J+KCGZ1)
         SRFMA1 = FACE(J+KCGX1)
         SRFMA2 = FACE(J+KCGY1)
         SRFMA3 = FACE(J+KCGZ1)
         NEDGE = FACE(KCGNE)
         DO 333 NE=1,NEDGE
            SRFMI1 = MIN(SRFMI1,FACE(J+KCGX1),FACE(J+KCGX2))
            SRFMI2 = MIN(SRFMI2,FACE(J+KCGY1),FACE(J+KCGY2))
            SRFMI3 = MIN(SRFMI3,FACE(J+KCGZ1),FACE(J+KCGZ2))
            SRFMA1 = MAX(SRFMA1,FACE(J+KCGX1),FACE(J+KCGX2))
            SRFMA2 = MAX(SRFMA2,FACE(J+KCGY1),FACE(J+KCGY2))
            SRFMA3 = MAX(SRFMA3,FACE(J+KCGZ1),FACE(J+KCGZ2))
            J = J + LCGEDG
  333    CONTINUE
         IF(IPORLI.EQ.1)THEN
            ACCMI1(NTIM) = SRFMI1
            ACCMI2(NTIM) = SRFMI2
            ACCMI3(NTIM) = SRFMI3
            ACCMA1(NTIM) = SRFMA1
            ACCMA2(NTIM) = SRFMA2
            ACCMA3(NTIM) = SRFMA3
         ELSEIF(ISUBLI.EQ.1)THEN
            IF(NTIM.EQ.1.OR.NTIM.EQ.2)THEN
               IF(SRFMI3.LT.ACCMI3(NTIM).AND.SRFMA3
     +         .LT.ACCMA3(NTIM))GOTO 999
            ELSEIF(NTIM.EQ.3.OR.NTIM.EQ.5)THEN
               IF(SRFMI2.LT.ACCMI2(NTIM).AND.SRFMA2
     +         .LT.ACCMA2(NTIM))GOTO 999
            ELSEIF(NTIM.EQ.4.OR.NTIM.EQ.6)THEN
               IF(SRFMI1.LT.ACCMI1(NTIM).AND.SRFMA1
     +         .LT.ACCMA1(NTIM))GOTO 999
            ENDIF
         ENDIF
      ENDIF
*
***SG
*
      C      = (T(2,1)*T(3,2) - T(3,1)*T(2,2))*FACE(KCGAA) +
     +         (T(3,1)*T(1,2) - T(1,1)*T(3,2))*FACE(KCGBB) +
     +         (T(1,1)*T(2,2) - T(2,1)*T(1,2))*FACE(KCGCC)
      IF (C .LE. 0.)     GOTO 999
      B      = (T(2,3)*T(3,1) - T(3,3)*T(2,1))*FACE(KCGAA) +
     +         (T(3,3)*T(1,1) - T(1,3)*T(3,1))*FACE(KCGBB) +
     +         (T(1,3)*T(2,1) - T(2,3)*T(1,1))*FACE(KCGCC)
      A      = (T(2,2)*T(3,3) - T(3,2)*T(2,3))*FACE(KCGAA) +
     +         (T(3,2)*T(1,3) - T(1,2)*T(3,3))*FACE(KCGBB) +
     +         (T(1,2)*T(2,3) - T(2,2)*T(1,3))*FACE(KCGCC)
      S      = 1./SQRT(A*A+B*B+C*C)
      AABCD(1) = A*S
      AABCD(2) = B*S
      AABCD(3) = C*S
*
      F1(KCGAF) = FACE(KCGAF)
      F1(KCGNE) = FACE(KCGNE)
      F1(KCGAA) = 0.
      F1(KCGBB) = 0.
      F1(KCGCC) = 1.
      F1(KCGDD) = 0.
      F1(KCGNE) = FACE(KCGNE)
*
**           T R A S F E R   P O I N T   C O O R D I N A T E S
*
      NEDGE  = FACE(KCGNE)
      IF (LCGFAC+NEDGE*LCGEDG .GT. LABC)
     +       PRINT *, ' Problem in CGFVIS: no space'
      XGRAV  = 0.
      YGRAV  = 0.
      ZGRAV  = 0.
      J      = LCGFAC
      DO 200 NE=1,NEDGE
         F1(J+KCGAE) = FACE(J+KCGAE)
         X = FACE(J+KCGX1)
         Y = FACE(J+KCGY1)
         Z = FACE(J+KCGZ1)
         F1(J+KCGX1) = T(1,1)*X + T(2,1)*Y + T(3,1)*Z + T(4,1)
         F1(J+KCGY1) = T(1,2)*X + T(2,2)*Y + T(3,2)*Z + T(4,2)
         F1(J+KCGZ1) = T(1,3)*X + T(2,3)*Y + T(3,3)*Z + T(4,3)
         X = FACE(J+KCGX2)
         Y = FACE(J+KCGY2)
         Z = FACE(J+KCGZ2)
         F1(J+KCGX2) = T(1,1)*X + T(2,1)*Y + T(3,1)*Z + T(4,1)
         F1(J+KCGY2) = T(1,2)*X + T(2,2)*Y + T(3,2)*Z + T(4,2)
         F1(J+KCGZ2) = T(1,3)*X + T(2,3)*Y + T(3,3)*Z + T(4,3)
         XGRAV = XGRAV + F1(J+KCGX1) + F1(J+KCGX2)
         YGRAV = YGRAV + F1(J+KCGY1) + F1(J+KCGY2)
         ZGRAV = ZGRAV + F1(J+KCGZ1) + F1(J+KCGZ2)
         J = J + LCGEDG
  200 CONTINUE
      XFACT = 1./(2.*NEDGE)
      XGRAV = XGRAV * XFACT
      YGRAV = YGRAV * XFACT
      ZGRAV = ZGRAV * XFACT
      AABCD(4) =-(AABCD(1)*XGRAV + AABCD(2)*YGRAV + AABCD(3)*ZGRAV)
*
**           F I N D   F A C E   M I N - M A X
*
      J      = LCGFAC
      RFMIN(1) = F1(J+KCGX1)
      RFMIN(2) = F1(J+KCGY1)
      RFMIN(3) = F1(J+KCGZ1)
      RFMAX(1) = F1(J+KCGX1)
      RFMAX(2) = F1(J+KCGY1)
      RFMAX(3) = F1(J+KCGZ1)
      DO 300 NE=1,NEDGE
         RFMIN(1) = MIN(RFMIN(1),F1(J+KCGX1),F1(J+KCGX2))
         RFMIN(2) = MIN(RFMIN(2),F1(J+KCGY1),F1(J+KCGY2))
         RFMIN(3) = MIN(RFMIN(3),F1(J+KCGZ1),F1(J+KCGZ2))
         RFMAX(1) = MAX(RFMAX(1),F1(J+KCGX1),F1(J+KCGX2))
         RFMAX(2) = MAX(RFMAX(2),F1(J+KCGY1),F1(J+KCGY2))
         RFMAX(3) = MAX(RFMAX(3),F1(J+KCGZ1),F1(J+KCGZ2))
         F1(J+KCGZ1) = 0.
         F1(J+KCGZ2) = 0.
         J = J + LCGEDG
  300 CONTINUE
      DRFACE(1) =-RFMAX(1)
      DRFACE(2) =-RFMAX(2)
      DRFACE(3) = RFMIN(1)
      DRFACE(4) = RFMIN(2)
      DRFACE(5) = RFMIN(3)
*
**          C O M P U T E    F A C E    V I S I B L E    A R E A
*
      J      = LCGFAC
      S      = 0.
      DLMAX  = 0.
      DO 400 NE=1,NEDGE
         S = S + F1(J+KCGX1)*F1(J+KCGY2) - F1(J+KCGX2)*F1(J+KCGY1)
         DL = ABS(F1(J+KCGX2)-F1(J+KCGX1)) + ABS(F1(J+KCGY2)-F1(J+
     +   KCGY1))
         IF (DLMAX .LT. DL) DLMAX = DL
         J = J + LCGEDG
  400 CONTINUE
      IF (DLMAX .LT. EESCR)     GOTO 999
      IF (S .GT. DLMAX*EESCR)   IVIS = 1
*
  999 RETURN
      END
+DECK,  CGHCRE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGHCRE(NT,IFWIND,W1,W2,N,H)
************************************************************************
*                                                                      *
*     Name: CGHCRE                                                     *
*     Author: E. Chernyaev                       Date:    05.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Initiate HIDE-structure                                *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input :   NT - number of transformation to screen system         *
*           IFWIND - window flag                                       *
*            W1(2) - left lower window corner                          *
*            W2(2) - rigth upper window corner                         *
*                N - max size of H array                               *
*             H(*) - HIDE-structure                                    *
*                                                                      *
*     Output: none                                                     *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGHPAR.
+CDE, CGCTRA.
      REAL H(*),W1(2),W2(2)
*-
      H(KHSIZE) = 0.
      IF (N .LT. LHHEAD)                GOTO 999
      DO 100 I=1,LHHEAD
        H(I)    = 0.
  100   CONTINUE
      IF (NT.LE.0 .OR. NT.GT.NTMAX)     GOTO 999
      H(KHSIZE) = N
      H(KHNT)   = NT
      H(KHIFWI) = IFWIND
      IF (IFWIND .LE. 0)                GOTO 999
      H(KHIFWI+1) = W1(1)
      H(KHIFWI+2) = W1(2)
      H(KHIFWI+3) = W2(1)
      H(KHIFWI+4) = W2(2)
  999 RETURN
      END
+DECK,  CGHDFA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGHDFA(NFACE,XYZ,IFACE,IPFACE,DFACE)
************************************************************************
*                                                                      *
*     Name: CGHDFA                                                     *
*     Author: E. Chernyaev                       Date:    07.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Compute faces min-max                                  *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: NFACE - number of faces                                   *
*         XYZ(3,*) - node coordinates                                  *
*         IFACE(*) - face array                                        *
*        IPFACE(*) - pointers to faces beginings in IFACE              *
*                                                                      *
*     Output: DFACE(6,*) - faces min-max                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
      REAL      XYZ(3,*),DFACE(6,*)
*SG
      INTEGER      IFACE(*)
      INTEGER      IPFACE(*)
*
*  Error status flag for integer*2 variables :
*SG
      COMMON /CGOVER/ IHSERR
       IHSERR=0
*JS
*-
      DO 300 NF=1,NFACE
        J      = IPFACE(NF)
        NEDGE  = IFACE(J)
        J      = J + 1
        DFACE(1,NF) = 99999.
        DFACE(2,NF) = 99999.
        DFACE(3,NF) = 99999.
        DFACE(4,NF) =-99999.
        DFACE(5,NF) =-99999.
        DFACE(6,NF) =-99999.
        DO 200 NE=1,NEDGE
          DO 100 NN=1,2
            N      = IFACE(J)
***SG
*    Eliminating integer*2 variables, it's impossible to obtain
*    iface(j) < 0.
*JS
            IF(N.LT.0)THEN
               IHSERR=1
               RETURN
            ENDIF
*JS
***SG
            J      = J + 1
            IF(XYZ(1,N) .LT. DFACE(1,NF))       DFACE(1,NF) = XYZ(1,N)
            IF(XYZ(2,N) .LT. DFACE(2,NF))       DFACE(2,NF) = XYZ(2,N)
            IF(XYZ(3,N) .LT. DFACE(3,NF))       DFACE(3,NF) = XYZ(3,N)
            IF(XYZ(1,N) .GT. DFACE(4,NF))       DFACE(4,NF) = XYZ(1,N)
            IF(XYZ(2,N) .GT. DFACE(5,NF))       DFACE(5,NF) = XYZ(2,N)
            IF(XYZ(3,N) .GT. DFACE(6,NF))       DFACE(6,NF) = XYZ(3,N)
  100       CONTINUE
  200     CONTINUE
        DFACE(1,NF) =-DFACE(1,NF)
        DFACE(2,NF) =-DFACE(2,NF)
        DFACE(3,NF) = DFACE(4,NF)
        DFACE(4,NF) = DFACE(5,NF)
        DFACE(5,NF) = DFACE(6,NF)
        DFACE(6,NF) =-99999.
  300   CONTINUE
      RETURN
      END
+DECK,  CGHEND, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGHEND(H,JERR,RSHD)
************************************************************************
*                                                                      *
*     Name: CGHEND                                                     *
*     Author: E. Chernyaev                       Date:    07.08.88     *
*     Revised by: S.Giani                        Date:    25.04.91     *
*                                                                      *
*     Function: Terminate creation of HIDE-structure                   *
*                                                                      *
*     References: CGHSHI, CGHDFA, CGHTRE                               *
*                                                                      *
*     Input : H(*) - HIDE-structure                                    *
*     Output:        H(1) .EQ. 0 - error in input data (see CGHCRE)    *
*                    H(1) .LT. 0 - no space                            *
*                                                                      *
*             IHSERR : Flag for indicating the Memory Size Overflow    *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
*SG
+CDE, CGHPAR.
*
*  I4SIZE is now = 1 to compute the right pointers after that all the
*  integer*2 variables have been eliminated.
*SG
      REAL H(*)
*JS
      COMMON /CGOVER/ IHSERR
      JERR=0
*JS
*-
      IF (H(KHSIZE) .EQ. 0.)    GOTO 999
      NHSIZE = H(KHSIZE)
      NT     = H(KHNT)
      NXYZ   = H(KHNXYZ)
      NFACE  = H(KHNFAC)
      NEDGE  = H(KHNEDG)
*           S P A C E   F O R   N O D E S
      NX     = 3*NXYZ
*           S P A C E   F O R   F A C E S
      NF     = (NFACE+NEDGE*2)/I4SIZE + 1
      NP     = NFACE
      NDF    = 6*NFACE
*           S P A C E   F O R   T R E E
      NTR    = 4*NFACE/I4SIZE
      NST    = NFACE/I4SIZE + 1
      NAL    = NFACE
      NAR    = NFACE
*            C H E C K   S P A C E
      NTOTAL = LHHEAD + NX + NF + NP + NDF + NTR + NST + NAL + NAR
      IF (NTOTAL .LT. NHSIZE)   GOTO 100
**SG
*  If size of Hide Structure is too big, tell GDRAW the new number
*    of words needed to build it.
*
      H(KHSIZE) = NHSIZE - NTOTAL
      JERR=NTOTAL+1
      GOTO 999
**SG
*
**          S E T   P O I N T E R S
*
  100 H(KHSIZE) = NTOTAL
*SG
      RSHD=NTOTAL+1
*SG
      JXYZ1      = LHHEAD + 1
      JFA       = JXYZ1 + NX
      JPFA      = JFA  + NF
      JDFA      = JPFA + NP
      JTRE      = JDFA + NDF
      JSTA      = JTRE + NTR
      JALE      = JSTA + NST
      JARI      = JALE + NAL
      H(KHJXYZ) = JXYZ1
      H(KHJFA)  = JFA
      H(KHJPFA) = JPFA
      H(KHJDFA) = JDFA
      H(KHJTRE) = JTRE
      H(KHJSTA) = JSTA
      H(KHJALE) = JALE
      H(KHJARI) = JARI
*
**          S H I F T   F A C E S
**          C O M P U T E   F A C E S   M I N - M A X
**          B U I L D   T R E E
*
      NH        = NHSIZE*I4SIZE
      CALL CGHSHI(NH,NFACE,NEDGE,H(1),H(JFA),H(JPFA))
      H(KHNFAC) = NFACE
      H(KHNEDG) = NEDGE
      CALL CGHDFA(NFACE,H(JXYZ1),H(JFA),H(JPFA),H(JDFA))
      JERR=IHSERR
      IF(IHSERR.NE.0) RETURN
      CALL CGHTRE(NFACE,H(JDFA),H(JSTA),H(JTRE),H(JALE),H(JARI))
*
  999 RETURN
      END
+DECK,  CGHEVA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:43  cernlib
* Geant

      SUBROUTINE CGHEVA(H,HISI)
*SG
+CDE, CGHPAR.
*
      REAL H(*)
*-
      HISI=0
      NHSIZE = H(KHSIZE)
*      NT     = H(KHNT)
      NXYZ   = H(KHNXYZ)
      NFACE  = H(KHNFAC)
      NEDGE  = H(KHNEDG)
*           S P A C E   F O R   N O D E S
      NX     = 3*NXYZ
*           S P A C E   F O R   F A C E S
      NF     = (NFACE+NEDGE*2)/I4SIZE + 1
      NP     = NFACE
      NDF    = 6*NFACE
*           S P A C E   F O R   T R E E
      NTR    = 4*NFACE/I4SIZE
      NST    = NFACE/I4SIZE + 1
      NAL    = NFACE
      NAR    = NFACE
*            C H E C K   S P A C E
      NTOTAL = LHHEAD + NX + NF + NP + NDF + NTR + NST + NAL + NAR
      IF(NTOTAL .GT. NHSIZE)THEN
        HISI=NTOTAL+1
      ENDIF
 999  END
*SG
+DECK,  CGHINS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGHINS(CG,H,ISHAPE)
************************************************************************
*                                                                      *
*     Name: CGHINS                                                     *
*     Author: E. Chernyaev                       Date:    04.08.88     *
*     Revised by: S.Giani                        Date:    24.04.91     *
*                                                                      *
*     Function: Add next CG-object to HIDE-structure                   *
*                                                                      *
*     References: CGHSIZ, CGHMOV                                       *
*                                                                      *
*     Input: CG(*) - CG-object                                         *
*             H(*) - HIDE-structure                                    *
*                                                                      *
*     Output: none                                                     *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGHPAR.
*SG
+CDE, GCGOBJ.
*SG
      REAL CG(*),H(*)
*-          P A R A M E T E R S   C H E C K
      IF (H(KHSIZE)  .LE. 0.)   GOTO 999
      CALL CGTSTR(CG,IREP)
*      IF (IREP .LT. 0) PRINT *, 'CGHINS: CG-structure test failed'
      IF (IREP .LT. 0)          GOTO 999
*
      NHSIZE = H(KHSIZE)
      NT     = H(KHNT)
      NXYZ   = H(KHNXYZ)
      NFACE  = H(KHNFAC)
      NEDGE  = H(KHNEDG)
      CALL CGHSIZ(CG,NT,NVF,NVE,ISHAPE)
      IF (NVF .EQ. 0)           GOTO 999
      NX     = 3*(NXYZ + NVE*2)
      NF     = (NFACE + NEDGE*2 + NVF + NVE*2)/I4SIZE + 1
      NP     = (NVE*2*2)/I4SIZE + 1
      NTOTAL = LHHEAD + NX + NF + NP
*           T E S T   S P A C E
      IF (NTOTAL .LT. NHSIZE)   GOTO 100
*SG
*   Setting new number of words needed
*
      NCLAS1=NTOTAL+1
      KCGST=-8
*SG
      H(KHNXYZ) = NXYZ + NVE*2
      H(KHNFAC) = NFACE + NVF
      H(KHNEDG) = NEDGE + NVE
      GOTO 999
*
  100 JXYZ1   = LHHEAD + NXYZ*3 + 1
      JPOINT = JXYZ1 + NVE*2*3
      JFACE  = 1
*SG
*   Resetting flag for size evaluation of Wire Structure
*
      KCGST=0
*SG
      CALL CGHMOV(CG,H,NVF,NVE,H(JXYZ1),H(JPOINT),H(JFACE))
*
  999 RETURN
      END
+DECK,  CGHMOV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGHMOV(CG,H,NVF,NVE,XYZ,IP,IFACE)
************************************************************************
*                                                                      *
*     Name: CGHMOV                                                     *
*     Author: E. Chernyaev                       Date:    04.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Move visible faces from CG-object to HIDE-structure    *
*                                                                      *
*     References: CGHREN                                               *
*                                                                      *
*     Input :   CG - CG-object                                         *
*                H - HIDE-structure                                    *
*              NVF - number of visible faces                           *
*              NVE - number of visible edges                           *
*         XYZ(3,*) - array for new nodes coordinates                   *
*          IP(2,*) - work array for node renumbering                   *
*         IFACE(*) - faces array                                       *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGHPAR.
      REAL      CG(*),H(*),XYZ(6,*)
*SG
      INTEGER   IP(2,*),IFACE(*)
*SG
*-
      JFACE  = H(KHSIZE)*I4SIZE-((H(KHNFAC)+NVF)+(H(KHNEDG)+NVE)*2)+1
      JF     = 0
      JE     = 0
      NN     = 0
      JCG    = LCGHEA
      NFACE  = CG(KCGNF)
      DO 400 NF=1,NFACE
        NEDGE = CG(JCG+KCGNE)
        IF (NEDGE .LT. 0)       GOTO 300
        IFACE(JFACE+JF) = NEDGE
        DO 100 I=1,NEDGE*2
          IFACE(JFACE+JF+I) = NN + I
  100     CONTINUE
        DO 200 I=1,NEDGE
          J     = JCG + LCGFAC + (I-1)*LCGEDG
          XYZ(1,JE+I) = CG(J+KCGX1)
          XYZ(2,JE+I) = CG(J+KCGY1)
          XYZ(3,JE+I) = CG(J+KCGZ1)
          XYZ(4,JE+I) = CG(J+KCGX2)
          XYZ(5,JE+I) = CG(J+KCGY2)
          XYZ(6,JE+I) = CG(J+KCGZ2)
  200     CONTINUE
        NN    = NN + NEDGE*2
        JF    = JF + NEDGE*2 + 1
        JE    = JE + NEDGE
  300   IF (NEDGE .LT. 0)       NEDGE =-NEDGE
        CG(JCG+KCGNE) = NEDGE
        JCG   = JCG + LCGFAC + NEDGE*LCGEDG
  400   CONTINUE
      NT     = H(KHNT)
      NOLD   = H(KHNXYZ)
      NNEW   = NVE*2
      CALL CGHREN(NT,NOLD,NNEW,NVF,XYZ,IP,IFACE(JFACE),NTOTAL)
      H(KHNXYZ) = NTOTAL
      H(KHNFAC) = H(KHNFAC) + NVF
      H(KHNEDG) = H(KHNEDG) + NVE
*
  999 RETURN
      END
+DECK,  CGHPLA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGHPLA(IFACE,XYZ,ABCD)
************************************************************************
*                                                                      *
*     Name: CGHPLA                                                     *
*     Author: E. Chernyaev                       Date:    08.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Compute face plane equation coefficients:              *
*                    Ax + By + Cz + D = 0                              *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: IFACE(*) - face                                           *
*            XYZ(3,*) - node coordinates                               *
*                                                                      *
*     Output: ABCD(4) - plane equation coefficients                    *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
      REAL            XYZ(3,*),ABCD(4),GRAV(3)
*SG
      INTEGER         IFACE(*)
*SG
*-
      NEDGE = IFACE(1)
      A      = 0.
      B      = 0.
      C      = 0.
      GRAV(1)= 0.
      GRAV(2)= 0.
      GRAV(3)= 0.
      JF     = 2
      DO 100 NE=1,NEDGE
        N1     = IFACE(JF)
        N2     = IFACE(JF+1)
        JF     = JF + 2
        A      = A + XYZ(2,N1)*XYZ(3,N2) - XYZ(2,N2)*XYZ(3,N1)
        B      = B + XYZ(3,N1)*XYZ(1,N2) - XYZ(3,N2)*XYZ(1,N1)
        C      = C + XYZ(1,N1)*XYZ(2,N2) - XYZ(1,N2)*XYZ(2,N1)
        GRAV(1)= GRAV(1) + XYZ(1,N1) + XYZ(1,N2)
        GRAV(2)= GRAV(2) + XYZ(2,N1) + XYZ(2,N2)
        GRAV(3)= GRAV(3) + XYZ(3,N1) + XYZ(3,N2)
  100   CONTINUE
      HNGRAV = 0.5/NEDGE
      GRAV(1)= GRAV(1) * HNGRAV
      GRAV(2)= GRAV(2) * HNGRAV
      GRAV(3)= GRAV(3) * HNGRAV
      IF (ABS(A) .LT. 0.000001) A=0.
      IF (ABS(B) .LT. 0.000001) B=0.
      IF (ABS(C) .LT. 0.000001) C=0.
      AREAI  = 1./SQRT(A*A + B*B + C*C)
      ABCD(1)= A * AREAI
      ABCD(2)= B * AREAI
      ABCD(3)= C * AREAI
      ABCD(4)=-(A*GRAV(1) + B*GRAV(2) + C*GRAV(3)) * AREAI
      END
+DECK,  CGHREN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGHREN(NT,NOLD,NNEW,NFACE,XYZ,IP,IFACE,NXYZ)
************************************************************************
*                                                                      *
*     Name: CGHREN                                                     *
*     Author: E. Chernyaev                       Date:    04.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Transform coordinates to screen system and             *
*               make renumeration                                      *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:    NT - number of transformation                          *
*             NOLD - number of old nodes                               *
*             NNEW - number of new nodes                               *
*            NFACE - number of new faces                               *
*         XYZ(3,*) - node coordinates                                  *
*          IP(2,*) - work array for renumbering                        *
*         IFACE(*) - faces                                             *
*                                                                      *
*     Output: NXYZ - total number of nodes after renumeration          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGDELT.
+CDE, CGCTRA.
      REAL      XYZ(3,*),SXYZ(3)
*SG
      INTEGER  IP(2,*),IFACE(*)
*SG
*
**          T R A N S F O R M   T O   S C R E E N   COORDINATES
**          D I S C R E T I S A T I O N
*
      DO 200 I=1,NNEW
        DO 100 K=1,3
          SXYZ(K) = TSCRN(1,K,NT)*XYZ(1,I) + TSCRN(2,K,NT)*XYZ(2,I) +
     +              TSCRN(3,K,NT)*XYZ(3,I) + TSCRN(4,K,NT)
*          IF (SXYZ(K) .GE. 0.) KK = (SXYZ(K) + DESCR) * DELSCR
*          IF (SXYZ(K) .LT. 0.) KK = (SXYZ(K) - DESCR) * DELSCR
*          SXYZ(K) = KK * EESCR
  100     CONTINUE
        IP(1,I) = I
        XYZ(1,I) = SXYZ(1)
        XYZ(2,I) = SXYZ(2)
        XYZ(3,I) = SXYZ(3)
  200   CONTINUE
*
**         S H E L L   S O R T   O F   C O O R D N A T E S
*
*      ISTEP  = 1
*  290 ISTEP  = ISTEP*3 + 1
*      IF (ISTEP*2 .LT. NNEW)    GOTO 290
*  300 ISTEP  = ISTEP/3
*      DO 500 M=1,NNEW-ISTEP
*        IF(XYZ(1,M)-XYZ(1,M+ISTEP))     500,310,350
*  310   IF(XYZ(2,M)-XYZ(2,M+ISTEP))     500,320,350
*  320   IF(XYZ(3,M)-XYZ(3,M+ISTEP))     500,500,350
**
*  350   SXYZ(1)    = XYZ(1,M+ISTEP)
*        SXYZ(2)    = XYZ(2,M+ISTEP)
*        SXYZ(3)    = XYZ(3,M+ISTEP)
*        IPCUR      =  IP(1,M+ISTEP)
*        I          = M
*  400   XYZ(1,I+ISTEP) = XYZ(1,I)
*        XYZ(2,I+ISTEP) = XYZ(2,I)
*        XYZ(3,I+ISTEP) = XYZ(3,I)
*        IP (1,I+ISTEP) =  IP(1,I)
*        I          = I - ISTEP
*        IF (I .LE. 0)           GOTO 450
*        IF (XYZ(1,I)-SXYZ(1))   450,410,400
*  410   IF (XYZ(2,I)-SXYZ(2))   450,420,400
*  420   IF (XYZ(3,I)-SXYZ(3))   450,450,400
*  450   XYZ(1,I+ISTEP) = SXYZ(1)
*        XYZ(2,I+ISTEP) = SXYZ(2)
*        XYZ(3,I+ISTEP) = SXYZ(3)
*        IP (1,I+ISTEP) = IPCUR
**
*  500   CONTINUE
*      IF (ISTEP .NE. 1)          GOTO 300
*
**          N O D E   R E N U M E R A T I O N
*
      NN           = 1
      NIP11=IP(1,1)
      IP(2,NIP11)= NN + NOLD
      DO 650 I=2,NNEW
*        IF (XYZ(1,I) .NE. XYZ(1,I-1)) GOTO 610
*        IF (XYZ(2,I) .NE. XYZ(2,I-1)) GOTO 610
*        IF (XYZ(3,I) .EQ. XYZ(3,I-1)) GOTO 620
  610   NN = NN + 1
        XYZ(1,NN) = XYZ(1,I)
        XYZ(2,NN) = XYZ(2,I)
        XYZ(3,NN) = XYZ(3,I)
  620   NIP=IP(1,I)
        IP(2,NIP)= NN + NOLD
  650   CONTINUE
*
**          S E T   N E W   N O D E   N U M B E R S   I N   F A C E S
*
      JF     = 1
      DO 800 NF=1,NFACE
        NEDGE  = IFACE(JF)
        DO 700 NE=1,NEDGE*2
          NIF=IFACE(JF+NE)
          IFACE(JF+NE) = IP(2,NIF)
  700     CONTINUE
        JF = JF + 1 + NEDGE*2
  800   CONTINUE
*
      NXYZ   = NN + NOLD
      RETURN
      END
+DECK,  CGHSHI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGHSHI(NSIZE,NFACE,NEDGE,IHIDE,IFACE,IPFACE)
************************************************************************
*                                                                      *
*     Name: CGHSHI                                                     *
*     Author: E. Chernyaev                       Date:    07.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Shift face array and set pointers to faces             *
*                                                                      *
*     References:                                                      *
*                                                                      *
*     Input : NSIZE - size of IHIDE array (in INTEGER*2 words)         *
*     Output: NFACE - number of faces before and after shift           *
*             NEDGE - number of edges before and after shift           *
*          IHIDE(*) - old face array                                   *
*          IFACE(*) - new face array                                   *
*         IPFACE(*) - pointers to faces beginings in IFACE             *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
*SG
      INTEGER  IHIDE(*),IFACE(*)
      INTEGER  IPFACE(*)
*SG
*-
      NF     = 0
      NE     = 0
      JHIDE  = NSIZE - (NFACE+NEDGE*2) + 1
      JFACE  = 1
      DO 200 NNF=1,NFACE
        IE     = 0
        IEDGE  = IHIDE(JHIDE)
        JHIDE  = JHIDE + 1
        JWF    = JFACE + 1
        DO 100 NNE=1,IEDGE
          N1     = IHIDE(JHIDE)
          N2     = IHIDE(JHIDE+1)
          JHIDE  = JHIDE + 2
          IF (N1 .EQ. N2)       GOTO 100
          IFACE(JWF)   = N1
          IFACE(JWF+1) = N2
          JWF    = JWF + 2
          IE     = IE + 1
  100     CONTINUE
        IF (IE .EQ. 0)          GOTO 200
        NF     = NF + 1
        NE     = NE + IE
        IFACE(JFACE) = IE
        IPFACE(NF)   = JFACE
        JFACE  = JWF
  200   CONTINUE
      NFACE  = NF
      NEDGE  = NE
      RETURN
      END
+DECK,  CGHSIZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGHSIZ(CG,NT,NVF,NVE,ISHAPE)
************************************************************************
*                                                                      *
*     Name: CGHSIZ                                                     *
*     Author: E. Chernyaev                       Date:    02.08.88     *
*     Revised by: S.Giani                        Date:    26.04.91     *
*                                                                      *
*     Function: Compute number of visible FACES and EDGE               *
*                                                                      *
*     References: CGFVIS                                               *
*                                                                      *
*     Input:  CG - CG-object                                           *
*             NT - number for transformation to screen coordinates     *
*                                                                      *
*     Output: NVF - number of visible faces                            *
*             NVE - number of visible edges                            *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, GCSPEE.
      REAL      CG(*)
*-
**SG
      NTFLAG = 1
      NTIM   = 0
**SG
      NVF    = 0
      NVE    = 0
      JCG    = LCGHEA
      NFACE  = CG(KCGNF)
      DO 100 NF=1,NFACE
        NEDGE = CG(JCG+KCGNE)
        CALL CGFARE(NT,CG(JCG+1),IVIS,ISHAPE)
        IF (IVIS .LT. 0)        CG(JCG+KCGNE) =-CG(JCG+KCGNE)
        JCG   = JCG + LCGFAC + NEDGE*LCGEDG
        IF (IVIS .LT. 0)        GOTO 100
        NVF   = NVF + 1
        NVE   = NVE + NEDGE
  100   CONTINUE
*SG
      NTFLAG = 0
*SG
  999 RETURN
      END
+DECK,  CGHTRE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGHTRE(NFACE,DFACE,IORDER,ITREE,ALEFT,ARIGHT)
************************************************************************
*                                                                      *
*     Name: CGHDFA                                                     *
*     Author: E. Chernyaev                       Date:    07.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: build tree of faces min-max                            *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: NFACE      - number of faces                              *
*            DFACE(6,*) - min-max of faces                             *
*            IORDER     - work array                                   *
*                                                                      *
*     Output: ITREE(4,*) - tree of faces min-max                       *
*             ALEFT(*)   - min-max of left subtree                     *
*             ARIGHT(*)  - min-max of right subtree                    *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
      REAL            DFACE(6,*),ALEFT(*),ARIGHT(*)
      REAL            RNDM(1)
*SG
      INTEGER         IORDER(*),ITREE(4,*)
      INTEGER         INDLFT(5),INDRGT(5)
*SG
      DATA            INDLFT/3,4,5,1,2/,INDRGT/3,4,1,2,1/
*-
      DO 100 I=1,NFACE
        IORDER(I)  = I
  100   CONTINUE
*
**           T R E E   B U I L D
*
      K      = NFACE + 1
      IND    = 0
      JFREE  = 1
      DO 500 I=1,NFACE
        K      = K - 1
        CALL GRNDM(RNDM,1)
        IRNDM  = INT(RNDM(1)*K) + 1
        KF     = IORDER(IRNDM)
        IORDER(IRNDM) = IORDER(K)
        IF (I .EQ. 1)                   GOTO 400
        IT     = 1
  200   JT     = IT
        NF     = ITREE(1,JT)
        IND    = ITREE(4,JT)
        IF (DFACE(IND,KF) .GT. DFACE(IND,NF)) GOTO 300
*             S T E P   T O   L E F T
        INDL    = INDLFT(IND)
        IF (DFACE(INDL,KF) .GT. ALEFT(JT))    ALEFT(JT)=DFACE(INDL,KF)
        IT     = ITREE(2,JT)
        IF (IT .NE. 0)                  GOTO 200
        ITREE(2,JT) = JFREE
        GOTO 400
*             S T E P   T O   R I G H T
  300   INDR    = INDRGT(IND)
        IF (DFACE(INDR,KF) .GT. ARIGHT(JT))   ARIGHT(JT)=DFACE(INDR,KF)
        IT     = ITREE(3,JT)
        IF (IT .NE. 0)                  GOTO 200
        ITREE(3,JT) = JFREE
*             S E T   N E W   T R E E   N O D E
  400   IND    = IND + 1
        IF (IND .EQ. 6)                 IND = 1
        ITREE(1,JFREE) = KF
        ITREE(2,JFREE) = 0
        ITREE(3,JFREE) = 0
        ITREE(4,JFREE) = IND
        ALEFT (JFREE)  =-99999.
        ARIGHT(JFREE)  =-99999.
        JFREE  = JFREE+1
  500   CONTINUE
  999 RETURN
      END
+DECK,  CGINVE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGINVE(CG)
************************************************************************
*                                                                      *
*     Name: CGINVE                                                     *
*     Author: E. Chernyaev                       Date:    20.02.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Invert edge direction                                  *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: CG(*) - CG-object                                         *
*     Output:                                                          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      CG(*)
*-
      NFACE  = CG(KCGNF)
      JCG    = LCGHEA
      DO 200 NF=1,NFACE
        CG(JCG+KCGAA) =-CG(JCG+KCGAA)
        CG(JCG+KCGBB) =-CG(JCG+KCGBB)
        CG(JCG+KCGCC) =-CG(JCG+KCGCC)
        CG(JCG+KCGDD) =-CG(JCG+KCGDD)
        NEDGE  = CG(JCG+KCGNE)
        JCG    = JCG + LCGFAC
        DO 100 NE=1,NEDGE
          X      = CG(JCG+KCGX1)
          Y      = CG(JCG+KCGY1)
          Z      = CG(JCG+KCGZ1)
          CG(JCG+KCGX1) = CG(JCG+KCGX2)
          CG(JCG+KCGY1) = CG(JCG+KCGY2)
          CG(JCG+KCGZ1) = CG(JCG+KCGZ2)
          CG(JCG+KCGX2) = X
          CG(JCG+KCGY2) = Y
          CG(JCG+KCGZ2) = Z
          JCG    = JCG + LCGEDG
  100     CONTINUE
  200   CONTINUE
      RETURN
      END
+DECK,  CGMNMX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGMNMX(CG,RMIN,RMAX)
************************************************************************
*                                                                      *
*     Name: CGMNMX                                                     *
*     Author: E. Chernyaev                       Date:    19.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Compute scope of CG-object                             *
*                                                                      *
*     References: CGTSTR                                               *
*                                                                      *
*     Input:  CG(*) - CG-object                                        *
*                                                                      *
*     Output: RMIN(3) - min coordinates                                 *
*             RMAX(3) - max coordinates                                 *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      CG(*),RMIN(3),RMAX(3)
*-
      DO 100 I=1,3
        RMIN(I) =+999999.
        RMAX(I) =-999999.
  100   CONTINUE
      CALL CGTSTR(CG,IREP)
      IF (IREP .LT. 0)          GOTO 999
*
      NFACE  = CG(KCGNF)
      IF (NFACE .EQ. 0)         GOTO 999
      JCG    = LCGHEA
      DO 300 NF=1,NFACE
        NEDGE  = CG(JCG+KCGNE)
        JCG    = JCG + LCGFAC
        DO 200 NE=1,NEDGE
          IF (CG(JCG+KCGX1) .LT. RMIN(1))       RMIN(1) = CG(JCG+KCGX1)
          IF (CG(JCG+KCGY1) .LT. RMIN(2))       RMIN(2) = CG(JCG+KCGY1)
          IF (CG(JCG+KCGZ1) .LT. RMIN(3))       RMIN(3) = CG(JCG+KCGZ1)
          IF (CG(JCG+KCGX2) .LT. RMIN(1))       RMIN(1) = CG(JCG+KCGX2)
          IF (CG(JCG+KCGY2) .LT. RMIN(2))       RMIN(2) = CG(JCG+KCGY2)
          IF (CG(JCG+KCGZ2) .LT. RMIN(3))       RMIN(3) = CG(JCG+KCGZ2)
*
          IF (CG(JCG+KCGX1) .GT. RMAX(1))       RMAX(1) = CG(JCG+KCGX1)
          IF (CG(JCG+KCGY1) .GT. RMAX(2))       RMAX(2) = CG(JCG+KCGY1)
          IF (CG(JCG+KCGZ1) .GT. RMAX(3))       RMAX(3) = CG(JCG+KCGZ1)
          IF (CG(JCG+KCGX2) .GT. RMAX(1))       RMAX(1) = CG(JCG+KCGX2)
          IF (CG(JCG+KCGY2) .GT. RMAX(2))       RMAX(2) = CG(JCG+KCGY2)
          IF (CG(JCG+KCGZ2) .GT. RMAX(3))       RMAX(3) = CG(JCG+KCGZ2)
          JCG    = JCG + LCGEDG
  200     CONTINUE
  300   CONTINUE
*
  999 RETURN
      END
+DECK,  CGPERS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGPERS(CG)
************************************************************************
*                                                                      *
*     Name: CGPERS                                                     *
*     Author: S.Giani                            Date:    22.05.92     *
*                                                                      *
*     Function: Transform CG object according to  perspective view     *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  CG - CG-object                                           *
*     Output:                                                          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
+CDE, GCDRAW.
      REAL      CG(*),GRAV(3)
      COMMON/PROSP/SVN(3)
*-
      IF (CG(KCGSIZ) .LE. 0.) GOTO 999
      LENG  = CG(KCGSIZ)
      CG(KCGSIZ) = 0.
      IF (LENG .LE. LCGHEA) GOTO 999
      NFACE  = CG(KCGNF)
      IF (NFACE .LE. 0) GOTO 999
      JCG    = LCGHEA
      DO 20  NF=1,NFACE
         JCGFAC = JCG
         NEDGE = CG(JCG+KCGNE)
         IF (NEDGE .LE. 0) GOTO 999
         A = 0.
         B = 0.
         C = 0.
         GRAV(1)= 0.
         GRAV(2)= 0.
         GRAV(3)= 0.
         JCG = JCG + LCGFAC
*             C O M P U T E   F A C E   A R E A
         DO 10  NE=1,NEDGE
*SG
*          PERSPECTIVE
*
            CALL UCTOH('PERS',IPERS,4,4)
            IF (IPRJ.EQ.IPERS) THEN
               XYZ3=CG(JCG+KCGX1)*SVN(1)+CG(JCG+KCGY1)*SVN(2)+ CG(JCG+
     +         KCGZ1)*SVN(3)
               IF (XYZ3.GE.DPERS) XYZ3=DPERS-0.1
               F=DPERS/(DPERS-XYZ3)
               CG(JCG+KCGX1)=CG(JCG+KCGX1)*F
               CG(JCG+KCGY1)=CG(JCG+KCGY1)*F
               CG(JCG+KCGZ1)=CG(JCG+KCGZ1)*F
               XYZ3=CG(JCG+KCGX2)*SVN(1)+CG(JCG+KCGY2)*SVN(2)+ CG(JCG+
     +         KCGZ2)*SVN(3)
               IF (XYZ3.GE.DPERS) XYZ3=DPERS-0.1
               F=DPERS/(DPERS-XYZ3)
               CG(JCG+KCGX2)=CG(JCG+KCGX2)*F
               CG(JCG+KCGY2)=CG(JCG+KCGY2)*F
               CG(JCG+KCGZ2)=CG(JCG+KCGZ2)*F
            ENDIF
*SG
            A = A + CG(JCG+KCGY1) * CG(JCG+KCGZ2) - CG(JCG+KCGY2) *
     +      CG(JCG+KCGZ1)
            B = B + CG(JCG+KCGZ1) * CG(JCG+KCGX2) - CG(JCG+KCGZ2) *
     +      CG(JCG+KCGX1)
            C = C + CG(JCG+KCGX1) * CG(JCG+KCGY2) - CG(JCG+KCGX2) *
     +      CG(JCG+KCGY1)
            GRAV(1)= GRAV(1) + CG(JCG+KCGX1) + CG(JCG+KCGX2)
            GRAV(2)= GRAV(2) + CG(JCG+KCGY1) + CG(JCG+KCGY2)
            GRAV(3)= GRAV(3) + CG(JCG+KCGZ1) + CG(JCG+KCGZ2)
            JCG = JCG + LCGEDG
   10    CONTINUE
         GRAV(1) = GRAV(1) / (2*NEDGE)
         GRAV(2) = GRAV(2) / (2*NEDGE)
         GRAV(3) = GRAV(3) / (2*NEDGE)
         AREA = SQRT(A*A + B*B + C*C)
*SG
*
*   Consider pyramid as a limit TRAP
*
         IF (AREA .LT. EEWOR)AREA=.1
*
         IF (AREA .LT. EEWOR) GOTO 999
*SG
         D =-(A*GRAV(1) + B*GRAV(2) + C*GRAV(3)) / AREA
         A = A / AREA
         B = B / AREA
         C = C / AREA
         CG(JCGFAC+KCGAA) = A
         CG(JCGFAC+KCGBB) = B
         CG(JCGFAC+KCGCC) = C
         CG(JCGFAC+KCGDD) = D
   20 CONTINUE
      CG(KCGSIZ) = LENG
  999 END
+DECK,  CGRIFL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGRIFL(TT,CG)
*
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      TT(4,3),CG(*)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION T(4,3),DET1,DET2,DET3,DETTT
+SELF, IF=SINGLE.
      REAL      T(4,3)
+SELF.
*-
*      TDEL   = EEWOR / 10.
      CALL CGTSTR(CG,IREP)
      IF (IREP .LT. 0)          GOTO 999
      DO 20 J=1,3
        DO 10 I=1,4
          T(I,J) = TT(I,J)
*          IF (ABS(TT(I,J))    .LT. TDEL)        T(I,J) = 0.
*          IF (ABS(1.-TT(I,J)) .LT. TDEL)        T(I,J) = 1.
*          IF (ABS(1.+TT(I,J)) .LT. TDEL)        T(I,J) =-1.
   10     CONTINUE
   20   CONTINUE
*
      DET1=T(1,1)*(T(2,2)*T(3,3)-T(2,3)*T(3,2))
      DET2=T(1,2)*(T(2,1)*T(3,3)-T(2,3)*T(3,1))
      DET3=T(1,3)*(T(2,1)*T(3,2)-T(3,1)*T(2,2))
      DETTT=DET1-DET2+DET3
      IF(DETTT.LT.0.)THEN
*           S E T   I N V E R S E   O R D E R   O F   E D G E S
      JCG=LCGHEA
      NFACE  = CG(KCGNF)
      DO 500 NF=1,NFACE
        CG(JCG + KCGAA) =-CG(JCG + KCGAA)
        CG(JCG + KCGBB) =-CG(JCG + KCGBB)
        CG(JCG + KCGCC) =-CG(JCG + KCGCC)
        CG(JCG + KCGDD) =-CG(JCG + KCGDD)
        NEDGE  = CG(JCG+KCGNE)
        JCG    = JCG + LCGFAC
        DO 400 NE=1,NEDGE
          X      = CG(JCG+KCGX1)
          Y      = CG(JCG+KCGY1)
          Z      = CG(JCG+KCGZ1)
          CG(JCG + KCGX1) = CG(JCG + KCGX2)
          CG(JCG + KCGY1) = CG(JCG + KCGY2)
          CG(JCG + KCGZ1) = CG(JCG + KCGZ2)
          CG(JCG + KCGX2) = X
          CG(JCG + KCGY2) = Y
          CG(JCG + KCGZ2) = Z
          JCG    = JCG + LCGEDG
  400     CONTINUE
  500   CONTINUE
        ENDIF
  999   RETURN
        END


+DECK,  CGSAAN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGSAAN(A1,A2,NA,NB,IREP)
************************************************************************
*                                                                      *
*     Name: CGSAAN                                                     *
*     Author: E. Chernyaev                       Date:    01.02.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Set parameters of rotation                             *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: A1 - intitial angle                                       *
*            A2 - end angle                                            *
*            NA - 1-st number of steps                                 *
*            NB - 2-nd number of steps                                 *
*                                                                      *
*     Output: IREP - reply (-1 if error in parameters)                 *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGCAAN.
      SAVE IFIRST
      DATA      IFIRST/1/
*-
      IF (IFIRST .NE. 0)                RAD = ATAN(1.0D+00)*4./180.
      IFIRST = 0
      IREP   =-1
      IF (NA .LE. 0)                    GOTO 999
      IF (NB .LE. 0)                    GOTO 999
      IF (A1 .GE. A2)                   GOTO 999
      DA     = A2 - A1
      IF (DA .GT. 360.)                 GOTO 999
      IF (DA .EQ. 360.)                 IFULL = 1
      IF (DA .LT. 360.)                 IFULL = 0
      NASTP(1) = NA
      NASTP(2) = NB
      COSI     = COS(A1*RAD)
      SINI     = SIN(A1*RAD)
      COSDA(1) = COS(DA*RAD/NA)
      SINDA(1) = SIN(DA*RAD/NA)
      COSDA(2) = COS(DA*RAD/NB)
      SINDA(2) = SIN(DA*RAD/NB)
      IREP   = 0
  999 RETURN
      END
+DECK,  CGSCOP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGSCOP(IFIRST,CG,RMIN,RMAX)
************************************************************************
*                                                                      *
*     Name: CGSCOP                                                     *
*     Author: E. Chernyaev                       Date:    30.01.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Compute CUBE scope of set of CG-objects                *
*                                                                      *
*     References: CGMNMX                                               *
*                                                                      *
*     Input:  IFIRST - flag (1 - if begin of the set)                  *
*             CG(*) - CG-object                                        *
*                                                                      *
*     Output: RMIN(3) - min coordinates of the CUBE                     *
*             RMAX(3) - max coordinates of the CUBE                     *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
      REAL      CG(*),RMIN(3),RMAX(3)
      REAL      RMID(3),RCMIN(3),RCMAX(3)
*-
      CALL CGMNMX(CG,RMIN,RMAX)
      IF (IFIRST .EQ. 0)                GOTO 100
      RCMIN(1) = RMIN(1)
      RCMIN(2) = RMIN(2)
      RCMIN(3) = RMIN(3)
      RCMAX(1) = RMAX(1)
      RCMAX(2) = RMAX(2)
      RCMAX(3) = RMAX(3)
  100 IF (RMIN(1) .GT. RMAX(1))         GOTO 999
      RRR = RCMAX(1) - RCMIN(1)
      DO 200 I=1,3
        IF (RCMIN(I) .GT. RMIN(I))      RCMIN(I) = RMIN(I)
        IF (RCMAX(I) .LT. RMAX(I))      RCMAX(I) = RMAX(I)
        RMID(I) = (RCMIN(I) + RCMAX(I))/2.
        IF (RRR .LT. RCMAX(I)-RCMIN(I)) RRR = RCMAX(I) - RCMIN(I)
  200   CONTINUE
      DO 300 I=1,3
        RCMIN(I) = RMID(I) - RRR/2.
        RCMAX(I) = RMID(I) + RRR/2.
  300   CONTINUE
*
  999 RMIN(1)  = RCMIN(1)
      RMIN(2)  = RCMIN(2)
      RMIN(3)  = RCMIN(3)
      RMAX(1)  = RCMAX(1)
      RMAX(2)  = RCMAX(2)
      RMAX(3)  = RCMAX(3)
      RETURN
      END
+DECK,  CGSHEL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGSHEL(ATRINV,ERROR,NEDGE,EDGE)
************************************************************************
*                                                                      *
*     Name: CGSHEL                                                     *
*     Author: E. Chernyaev                       Date:    13.04.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Shell sort of edges                                    *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  ATRINV - atribute decrement for inverse edges            *
*             ERROR  - presision error                                 *
*     Output: NEDGE - number of edges                                  *
*             EDGE(*,*)  - edges                                       *
*                                                                      *
*     Output:                                                          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      EDGE(LCGEDG,*),SAVE(LCGEDG)
*-
      IF (NEDGE .LE. 1)                 GOTO 999
      KE     = 0
      DO 200 NE=1,NEDGE
        IF (EDGE(KCGX1,NE) .GT. EDGE(KCGX2,NE)+ERROR)   GOTO 120
        IF (EDGE(KCGX1,NE) .LT. EDGE(KCGX2,NE)-ERROR)   GOTO 110
        IF (EDGE(KCGY1,NE) .GT. EDGE(KCGY2,NE)+ERROR)   GOTO 120
        IF (EDGE(KCGY1,NE) .LT. EDGE(KCGY2,NE)-ERROR)   GOTO 110
        IF (EDGE(KCGZ1,NE) .GT. EDGE(KCGZ2,NE)+ERROR)   GOTO 120
        IF (EDGE(KCGZ1,NE) .LT. EDGE(KCGZ2,NE)-ERROR)   GOTO 110
        GOTO 200
  110   KE     = KE + 1
        IF (KE .EQ. NE)         GOTO 200
        EDGE(KCGAE,KE) = EDGE(KCGAE,NE)
        EDGE(KCGX1,KE) = EDGE(KCGX1,NE)
        EDGE(KCGY1,KE) = EDGE(KCGY1,NE)
        EDGE(KCGZ1,KE) = EDGE(KCGZ1,NE)
        EDGE(KCGX2,KE) = EDGE(KCGX2,NE)
        EDGE(KCGY2,KE) = EDGE(KCGY2,NE)
        EDGE(KCGZ2,KE) = EDGE(KCGZ2,NE)
        GOTO 200
  120   KE     = KE + 1
        EDGE(KCGAE,KE) = EDGE(KCGAE,NE)-ATRINV
        X      = EDGE(KCGX1,NE)
        Y      = EDGE(KCGY1,NE)
        Z      = EDGE(KCGZ1,NE)
        EDGE(KCGX1,KE) = EDGE(KCGX2,NE)
        EDGE(KCGY1,KE) = EDGE(KCGY2,NE)
        EDGE(KCGZ1,KE) = EDGE(KCGZ2,NE)
        EDGE(KCGX2,KE) = X
        EDGE(KCGY2,KE) = Y
        EDGE(KCGZ2,KE) = Z
  200   CONTINUE
      NEDGE = KE
*
**          S H E L L   S O R T   O F   E D G E S
*
      IF (NEDGE .LE. 1)                 GOTO 999
      ISTEP  = 1
  210 ISTEP  = ISTEP*3 + 1
      IF (ISTEP*2 .LT. NEDGE)           GOTO 210
*
  300 ISTEP  = ISTEP/3
      DO 500 I=1,NEDGE-ISTEP
        J1    = I
        J2    = I + ISTEP
*           I F  (E D G E (J 1)  .L E.  E D G E (J 2))  G O T O  5 0 0
        IF (EDGE(KCGX1,J1) .LT. EDGE(KCGX1,J2)-ERROR)   GOTO 500
        IF (EDGE(KCGX1,J1) .GT. EDGE(KCGX1,J2)+ERROR)   GOTO 350
        IF (EDGE(KCGY1,J1) .LT. EDGE(KCGY1,J2)-ERROR)   GOTO 500
        IF (EDGE(KCGY1,J1) .GT. EDGE(KCGY1,J2)+ERROR)   GOTO 350
        IF (EDGE(KCGZ1,J1) .LT. EDGE(KCGZ1,J2)-ERROR)   GOTO 500
        IF (EDGE(KCGZ1,J1) .GT. EDGE(KCGZ1,J2)+ERROR)   GOTO 350
        IF (EDGE(KCGX2,J1) .LT. EDGE(KCGX2,J2)-ERROR)   GOTO 500
        IF (EDGE(KCGX2,J1) .GT. EDGE(KCGX2,J2)+ERROR)   GOTO 350
        IF (EDGE(KCGY2,J1) .LT. EDGE(KCGY2,J2)-ERROR)   GOTO 500
        IF (EDGE(KCGY2,J1) .GT. EDGE(KCGY2,J2)+ERROR)   GOTO 350
        IF (EDGE(KCGZ2,J1) .LT. EDGE(KCGZ2,J2)-ERROR)   GOTO 500
        IF (EDGE(KCGZ2,J1) .GT. EDGE(KCGZ2,J2)+ERROR)   GOTO 350
        GOTO 500
*            S A V E = E D G E (J 2)
  350   SAVE(KCGAE) = EDGE(KCGAE,J2)
        SAVE(KCGX1) = EDGE(KCGX1,J2)
        SAVE(KCGY1) = EDGE(KCGY1,J2)
        SAVE(KCGZ1) = EDGE(KCGZ1,J2)
        SAVE(KCGX2) = EDGE(KCGX2,J2)
        SAVE(KCGY2) = EDGE(KCGY2,J2)
        SAVE(KCGZ2) = EDGE(KCGZ2,J2)
*            E D G E (J 2) = E D G E (J 1)
  400   EDGE(KCGAE,J2) = EDGE(KCGAE,J1)
        EDGE(KCGX1,J2) = EDGE(KCGX1,J1)
        EDGE(KCGY1,J2) = EDGE(KCGY1,J1)
        EDGE(KCGZ1,J2) = EDGE(KCGZ1,J1)
        EDGE(KCGX2,J2) = EDGE(KCGX2,J1)
        EDGE(KCGY2,J2) = EDGE(KCGY2,J1)
        EDGE(KCGZ2,J2) = EDGE(KCGZ2,J1)
        J2     = J1
        J1     = J1 - ISTEP
        IF (J1 .LE. 0)     GOTO 450
*           I F  (E D G E (J 1) .G T. S A V E)  G O T O  4 0 0
        IF (EDGE(KCGX1,J1) .LT. SAVE(KCGX1)-ERROR)      GOTO 450
        IF (EDGE(KCGX1,J1) .GT. SAVE(KCGX1)+ERROR)      GOTO 400
        IF (EDGE(KCGY1,J1) .LT. SAVE(KCGY1)-ERROR)      GOTO 450
        IF (EDGE(KCGY1,J1) .GT. SAVE(KCGY1)+ERROR)      GOTO 400
        IF (EDGE(KCGZ1,J1) .LT. SAVE(KCGZ1)-ERROR)      GOTO 450
        IF (EDGE(KCGZ1,J1) .GT. SAVE(KCGZ1)+ERROR)      GOTO 400
        IF (EDGE(KCGX2,J1) .LT. SAVE(KCGX2)-ERROR)      GOTO 450
        IF (EDGE(KCGX2,J1) .GT. SAVE(KCGX2)+ERROR)      GOTO 400
        IF (EDGE(KCGY2,J1) .LT. SAVE(KCGY2)-ERROR)      GOTO 450
        IF (EDGE(KCGY2,J1) .GT. SAVE(KCGY2)+ERROR)      GOTO 400
        IF (EDGE(KCGZ2,J1) .LT. SAVE(KCGZ2)-ERROR)      GOTO 450
        IF (EDGE(KCGZ2,J1) .GT. SAVE(KCGZ2)+ERROR)      GOTO 400
*           E D G E (J 2) = S A V E
  450   EDGE(KCGAE,J2) = SAVE(KCGAE)
        EDGE(KCGX1,J2) = SAVE(KCGX1)
        EDGE(KCGY1,J2) = SAVE(KCGY1)
        EDGE(KCGZ1,J2) = SAVE(KCGZ1)
        EDGE(KCGX2,J2) = SAVE(KCGX2)
        EDGE(KCGY2,J2) = SAVE(KCGY2)
        EDGE(KCGZ2,J2) = SAVE(KCGZ2)
  500   CONTINUE
      IF (ISTEP .NE. 1)         GOTO 300
*
  999 RETURN
      END
+DECK,  CGSHIF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGSHIF(DX,DY,DZ,CG)
************************************************************************
*                                                                      *
*     Name: CGSHIF                                                     *
*     Author: E. Chernyaev                       Date:    24.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Shift of  CG-object                                    *
*                                                                      *
*     References: CGAFFI                                               *
*                                                                      *
*     Input:     DX - X-shift                                          *
*                DY - Y-shift                                          *
*                DZ - Z-shift                                          *
*     Output: CG(*) - CG-object                                        *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
      REAL      CG(*),T(4,3)
*-
      T(1,1) = 1.
      T(2,1) = 0.
      T(3,1) = 0.
      T(4,1) = DX
*
      T(1,2) = 0.
      T(2,2) = 1.
      T(3,2) = 0.
      T(4,2) = DY
*
      T(1,3) = 0.
      T(2,3) = 0.
      T(3,3) = 1.
      T(4,3) = DZ
*
      CALL CGAFFI(T,CG)
      RETURN
      END
+DECK,  CGSIZE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      FUNCTION CGSIZE(N,NFATYP,NFAC,NEDG)
************************************************************************
*                                                                      *
*     Name: CGSIZE                                                     *
*     Author: E. Chernyaev                       Date:    20.03.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Compute size of CG-object                              *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  N       - max size of CG-object                          *
*             NFATYP  - number of different face type                  *
*             NFAC(*) - number of faces of given type                  *
*             NEDG(*) - number of edges in face of given type          *
*                                                                      *
*     Output: CGSIZE - CG-object size (= 0, if error in parameters)    *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      INTEGER   NFAC(*),NEDG(*)
*-
      CGSIZE = 0.
      IF (N .LE. 1)             GOTO 999
      IF (NFATYP .LE. 0)        GOTO 999
      NEED  = LCGHEA
      DO 100 I=1,NFATYP
        IF (NFAC(I).LT.0 .OR. NEDG(I).LT.3)     GOTO 999
        NEED   = NEED + NFAC(I)*(LCGFAC + NEDG(I)*LCGEDG)
  100   CONTINUE
      IF (NEED .EQ. LCGHEA)     GOTO 999
      IF (N-NEED .LT. 0)        CGSIZE = N - NEED
      IF (N-NEED .GE. 0)        CGSIZE = NEED
  999 RETURN
      END
+DECK,  CGSLIC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGSLIC(A,SLIC,NMAX,B)
************************************************************************
*                                                                      *
*     Name: CGSLIC                                                     *
*     Author: E. Chernyaev                       Date:    20.04.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Make slice of CG-object                                *
*                                                                      *
*     References: CGMNMX                                               *
*                                                                      *
*     Input:  A(*) - CG-object                                         *
*          SLIC(4) - slicing plane                                     *
*            NMAX  - max size of B-array                               *
*                                                                      *
*     Output:  B - resulting CG-object                                 *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      PARAMETER (NWORK=LCGHEA+6*(LCGFAC+4*LCGEDG))
      REAL      A(*),B(*),SLIC(4),ABCD(4)
      REAL      RMN(3),RMX(3),RMID(3),W(NWORK),XYZ(3,8)
*-
      B(1)   = 0.
*           T E S T   P A R A M E T E R S    C O R R E C T N E S S
      IF (NMAX .LT. LCGHEA)     GOTO 999
      S      = SQRT(SLIC(1)*SLIC(1)+SLIC(2)*SLIC(2)+SLIC(3)*SLIC(3))
      IF (S .LE. EEWOR)         GOTO 999
      ABCD(1)= SLIC(1) / S
      ABCD(2)= SLIC(2) / S
      ABCD(3)= SLIC(3) / S
      ABCD(4)= SLIC(4) / S
      CALL CGSCOP(1,A,RMN,RMX)
*      CALL CGMNMX(A,RMN,RMX)
      IF (RMN(1) .GT. RMX(1))   GOTO 999
*           M I N - M A X    T E S T
      NFACE  = A(KCGNF)
      IF (NFACE .EQ. 0)         GOTO 998
      NPOS   = 0
      NNEG   = 0
      J      = LCGHEA
      DO 120 NF=1,NFACE
        NEDGE  = A(J+KCGNE)
        J      = J + LCGFAC
        DO 110 NE=1,NEDGE
          DIST = ABCD(1)*A(J+KCGX1)+ABCD(2)*A(J+KCGY1)
     +          +ABCD(3)*A(J+KCGZ1) + ABCD(4)
          IF (DIST .GT.-EEWOR)    NPOS = NPOS + 1
          IF (DIST .LT.+EEWOR)    NNEG = NNEG + 1
          J      = J + LCGEDG
  110   CONTINUE
  120 CONTINUE
      IF (NPOS .EQ. 0)            GOTO 998
      IF (NNEG .EQ. 0)            CALL CGCOPY(A,NMAX,B)
      IF (NNEG .EQ. 0)            GOTO 999
*           P R E P A R E   S L I C I N G   O B J E C T
      K      = 1
      IF (ABS(ABCD(2)) .GT. ABS(ABCD(1)))       K = 2
      IF (ABS(ABCD(3)) .GT. ABS(ABCD(K)))       K = 3
      RMID(1) = (RMN(1)+RMX(1)) / 2.
      RMID(2) = (RMN(2)+RMX(2)) / 2.
      RMID(3) = (RMN(3)+RMX(3)) / 2.
      RX      = RMX(1) - RMN(1)
      RY      = RMX(2) - RMN(2)
      RZ      = RMX(3) - RMN(3)
*
      GOTO (210,220,230),K
  210 XYZ(2,1) = RMID(2) + RY
      XYZ(3,1) = RMID(3) + RZ
      XYZ(2,2) = RMID(2) - RY
      XYZ(3,2) = RMID(3) + RZ
      XYZ(2,3) = RMID(2) - RY
      XYZ(3,3) = RMID(3) - RZ
      XYZ(2,4) = RMID(2) + RY
      XYZ(3,4) = RMID(3) - RZ
      DO 215 I=1,4
        XYZ(1,I) = -(ABCD(2)*XYZ(2,I)+ABCD(3)*XYZ(3,I)+ABCD(4))/ABCD(1)
  215   CONTINUE
      GOTO 250
*
  220 XYZ(1,1) = RMID(1) + RX
      XYZ(3,1) = RMID(3) + RZ
      XYZ(1,2) = RMID(1) - RX
      XYZ(3,2) = RMID(3) + RZ
      XYZ(1,3) = RMID(1) - RX
      XYZ(3,3) = RMID(3) - RZ
      XYZ(1,4) = RMID(1) + RX
      XYZ(3,4) = RMID(3) - RZ
      DO 225 I=1,4
        XYZ(2,I) = -(ABCD(1)*XYZ(1,I)+ABCD(3)*XYZ(3,I)+ABCD(4))/ABCD(2)
  225   CONTINUE
      GOTO 250
*
  230 XYZ(1,1) = RMID(1) + RX
      XYZ(2,1) = RMID(2) + RY
      XYZ(1,2) = RMID(1) - RX
      XYZ(2,2) = RMID(2) + RY
      XYZ(1,3) = RMID(1) - RX
      XYZ(2,3) = RMID(2) - RY
      XYZ(1,4) = RMID(1) + RX
      XYZ(2,4) = RMID(2) - RY
      DO 235 I=1,4
        XYZ(3,I) = -(ABCD(1)*XYZ(1,I)+ABCD(2)*XYZ(2,I)+ABCD(4))/ABCD(3)
  235   CONTINUE
      GOTO 250
*
  250 IF (ABCD(K) .GT. 0)     S = -3.
      IF (ABCD(K) .LT. 0)     S = +3.
      RX = 0.
      RY = 0.
      RZ = 0.
      IF (K .EQ. 1)           RX = S * (RMX(1)-RMN(1))
      IF (K .EQ. 2)           RY = S * (RMX(2)-RMN(2))
      IF (K .EQ. 3)           RZ = S * (RMX(3)-RMN(3))
      DO 255 I=1,4
        XYZ(1,I+4) = XYZ(1,I) + RX
        XYZ(2,I+4) = XYZ(2,I) + RY
        XYZ(3,I+4) = XYZ(3,I) + RZ
  255   CONTINUE
      CALL CGBOX(XYZ,4,4,NWORK,W)
      CALL CGCEV(1,W)
*           M A K E   S L I C E
      CALL CGSUB(A,W,NMAX,B)
      GOTO 999
*
  998 B(KCGSIZ) = LCGHEA
      B(KCGATT) = 0.
      B(KCGNF)  = 0.
  999 RETURN
      END
+DECK,  CGSNOR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGSNOR(CG)
************************************************************************
*                                                                      *
*     Name: CGSNOR                                                     *
*     Author: E. Chernyaev                       Date:    23.08.88     *
*     Revised by: S.Giani                        Date:    25.04.91     *
*                                                                      *
*     Function: Set normals for faces in CG-object                     *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  CG - CG-object                                           *
*     Output:                                                          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      CG(*),GRAV(3)
*-
      IF (CG(KCGSIZ) .LE. 0.)   GOTO 999
      LENG  = CG(KCGSIZ)
      CG(KCGSIZ) = 0.
      IF (LENG .LE. LCGHEA)     GOTO 999
      NFACE  = CG(KCGNF)
      IF (NFACE .LE. 0)         GOTO 999
      JCG    = LCGHEA
      DO 200 NF=1,NFACE
        JCGFAC = JCG
        NEDGE  = CG(JCG+KCGNE)
        IF (NEDGE .LE. 0)       GOTO 999
        A      = 0.
        B      = 0.
        C      = 0.
        GRAV(1)= 0.
        GRAV(2)= 0.
        GRAV(3)= 0.
        JCG    = JCG + LCGFAC
*             C O M P U T E   F A C E   A R E A
        DO 100 NE=1,NEDGE
          A      = A + CG(JCG+KCGY1) * CG(JCG+KCGZ2)
     +               - CG(JCG+KCGY2) * CG(JCG+KCGZ1)
          B      = B + CG(JCG+KCGZ1) * CG(JCG+KCGX2)
     +               - CG(JCG+KCGZ2) * CG(JCG+KCGX1)
          C      = C + CG(JCG+KCGX1) * CG(JCG+KCGY2)
     +               - CG(JCG+KCGX2) * CG(JCG+KCGY1)
          GRAV(1)= GRAV(1) + CG(JCG+KCGX1) + CG(JCG+KCGX2)
          GRAV(2)= GRAV(2) + CG(JCG+KCGY1) + CG(JCG+KCGY2)
          GRAV(3)= GRAV(3) + CG(JCG+KCGZ1) + CG(JCG+KCGZ2)
          JCG    = JCG + LCGEDG
  100     CONTINUE
        GRAV(1) = GRAV(1) / (2*NEDGE)
        GRAV(2) = GRAV(2) / (2*NEDGE)
        GRAV(3) = GRAV(3) / (2*NEDGE)
        AREA   = SQRT(A*A + B*B + C*C)
*SG
*
*   Consider pyramid as a limit TRAP
*
        IF (AREA .LT. EEWOR)AREA=.1
*
        IF (AREA .LT. EEWOR)    GOTO 999
*SG
        D      =-(A*GRAV(1) + B*GRAV(2) + C*GRAV(3)) / AREA
        A      = A / AREA
        B      = B / AREA
        C      = C / AREA
        CG(JCGFAC+KCGAA) = A
        CG(JCGFAC+KCGBB) = B
        CG(JCGFAC+KCGCC) = C
        CG(JCGFAC+KCGDD) = D
  200   CONTINUE
      CG(KCGSIZ) = LENG
  999 RETURN
      END
+DECK,  CGSPHE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:44  cernlib
* Geant

      SUBROUTINE CGSPHE(R,KA,KB,LCG,CG)
************************************************************************
*                                                                      *
*     Name: CGSPHE                                                     *
*     Author: E. Chernyaev                       Date:    24.01.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Create CG-object for SPHERE (BALL)                     *
*                                                                      *
*     References: CGELLI                                               *
*                                                                      *
*     Input:  R  - sphere radius                                       *
*             KA - number of latitude step                             *
*             KB - number of longitude step                            *
*            LCG - max-size of CG-object                               *
*                                                                      *
*     Output: CG - CG-object                                           *
*                  CG(1) - length of CG-object                         *
*                        = 0 if error in parameters                    *
*                        < 0 if no space                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
      REAL      CG(*)
*-
      CALL CGELLI(R,R,R,KA,KB,LCG,CG)
      RETURN
      END
+DECK,  CGSUB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGSUB(A,B,NMAX,C)
************************************************************************
*                                                                      *
*     Name: CGSUB                                                      *
*     Author: E. Chernyaev                       Date:    05.04.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Subrtarc one CG-objects from another                   *
*                                                                      *
*     References: CGBOOL                                               *
*                                                                      *
*     Input: A(*) - 1-st CG-object                                     *
*            B(*) - 2-nd CG-object                                     *
*            NMAX - max length C array                                 *
*                                                                      *
*     Output: C(*) - resulting CG-object                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
      REAL      A(*),B(*),C(*)
*-
      CALL CGBOOL(1,0,A,B,NMAX,C)
      RETURN
      END
+DECK,  CGTSET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGTSET(N,T,IREP)
************************************************************************
*                                                                      *
*     Name: CGTSET                                                     *
*     Author: E. Chernyaev                       Date:    31.07.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Set transformation to screen coordinates and           *
*               find back transformation to world coordinates          *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: N - transformation number                                 *
*            T(4,3) - transformation matrix                            *
*                                                                      *
*     Output: IREP - reply ( 0 - O.K.                                  *
*                           -1 - if illigal N,                         *
*                           -2 - if DET(T)=0.)                         *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGCTRA.
      REAL T(4,3)
*-          P A R A M E T E R S   C H E C K
      IREP   = 0
      IF (N.LE.0 .OR. N.GT.NTMAX)       IREP = -1
      DET = T(1,1)*T(2,2)*T(3,3) - T(3,1)*T(2,2)*T(1,3) +
     +      T(3,1)*T(1,2)*T(2,3) - T(1,1)*T(3,2)*T(2,3) +
     +      T(2,1)*T(3,2)*T(1,3) - T(2,1)*T(1,2)*T(3,3)
*      IF (ABS(DET) .LT. 1./DELWOR)      IREP = -2
      IF (IREP .LT. 0)                  GOTO 999
*           S E T   T R A N S F O R M A T I O N   M A T R I X
      DO 200 I=1,4
        DO 100 J=1,3
          TSCRN(I,J,N) = T(I,J)
  100     CONTINUE
  200   CONTINUE
*           F I N D   M A T R I X   F O R   B A C K   TRANSFORMATION
      TBACK(1,1,N) = (T(2,2)*T(3,3) - T(2,3)*T(3,2)) / DET
      TBACK(2,1,N) =-(T(2,1)*T(3,3) - T(2,3)*T(3,1)) / DET
      TBACK(3,1,N) = (T(2,1)*T(3,2) - T(2,2)*T(3,1)) / DET
      TBACK(4,1,N) =-(T(2,1)*T(3,2)*T(4,3) - T(4,1)*T(3,2)*T(2,3) +
     +                T(4,1)*T(2,2)*T(3,3) - T(2,1)*T(4,2)*T(3,3) +
     +                T(3,1)*T(4,2)*T(2,3) - T(3,1)*T(2,2)*T(4,3))/DET
      TBACK(1,2,N) =-(T(1,2)*T(3,3) - T(1,3)*T(3,2)) / DET
      TBACK(2,2,N) = (T(1,1)*T(3,3) - T(1,3)*T(3,1)) / DET
      TBACK(3,2,N) =-(T(1,1)*T(3,2) - T(1,2)*T(3,1)) / DET
      TBACK(4,2,N) = (T(1,1)*T(3,2)*T(4,3) - T(4,1)*T(3,2)*T(1,3) +
     +                T(4,1)*T(1,2)*T(3,3) - T(1,1)*T(4,2)*T(3,3) +
     +                T(3,1)*T(4,2)*T(1,3) - T(3,1)*T(1,2)*T(4,3))/DET
      TBACK(1,3,N) = (T(1,2)*T(2,3) - T(1,3)*T(2,2)) / DET
      TBACK(2,3,N) =-(T(1,1)*T(2,3) - T(1,3)*T(2,1)) / DET
      TBACK(3,3,N) = (T(1,1)*T(2,2) - T(1,2)*T(2,1)) / DET
      TBACK(4,3,N) =-(T(1,1)*T(2,2)*T(4,3) - T(4,1)*T(2,2)*T(1,3) +
     +                T(4,1)*T(1,2)*T(2,3) - T(1,1)*T(4,2)*T(2,3) +
     +                T(2,1)*T(4,2)*T(1,3) - T(2,1)*T(1,2)*T(4,3))/DET
*
  999 RETURN
      END
+DECK,  CGTSTR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGTSTR(CG,IREP)
************************************************************************
*                                                                      *
*     Name: CGTSTR                                                     *
*     Author: E. Chernyaev                       Date:    12.02.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Test structure of CG-object                            *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input:  CG(*) - CG-object                                        *
*                                                                      *
*     Output: IREP - replay (0 - O.K, -1. - error in structure)        *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
      REAL      CG(*)
*-
      IREP   =-1
      LTOTAL = CG(KCGSIZ)
      IF (LTOTAL .LT. LCGHEA)                  GOTO 999
      NFACE  = CG(KCGNF)
      IF (NFACE .LT. 0)                        GOTO 999
      IF (NFACE .GT. 99999)                    GOTO 999
*
      JCG    = LCGHEA
      IF (NFACE .EQ. 0)                         GOTO 200
      DO 100 NF=1,NFACE
        IF (LTOTAL .LT. JCG+LCGFAC)            GOTO 999
        NEDGE  = CG(JCG+KCGNE)
        IF (NEDGE .LE. 0)                      GOTO 999
        IF (NEDGE .GT. 99999)                  GOTO 999
        JCG    = JCG + LCGFAC + NEDGE*LCGEDG
        IF (LTOTAL .LT. JCG)                   GOTO 999
  100   CONTINUE
  200 IF (JCG .EQ. LTOTAL)                      IREP = 0
*
  999 RETURN
      END
+DECK,  CGVEDG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGVEDG(NT,P1,P2,IVIS)
************************************************************************
*                                                                      *
*     Name: CGVEDG                                                     *
*     Author: E. Chernyaev                       Date:    08.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Compute ALL about edge:                                *
*               parametric equations X=X1+T(X2-X1), Y=Y1+T(Y2-Y1)      *
*               edge line equation   Ax+By+C=0                         *
*               edge min-max                                           *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: NT - number of transformation to screen coordinates       *
*            P1(3) - 1-st edge point                                   *
*            P2(3) - 2-nd edge point                                   *
*                                                                      *
*     Output: IVIS = -1 for very small edges                           *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGDELT.
+CDE, CGCTRA.
+CDE, CGCEDG.
      REAL    P1(3),P2(3)
*-
      DO 100 I=1,3
        AA(I) = P1(1)*TSCRN(1,I,NT) + P1(2)*TSCRN(2,I,NT) +
     +          P1(3)*TSCRN(3,I,NT) + TSCRN(4,I,NT)
        BB(I) = P2(1)*TSCRN(1,I,NT) + P2(2)*TSCRN(2,I,NT) +
     +          P2(3)*TSCRN(3,I,NT) + TSCRN(4,I,NT)
        DELTA(I) = BB(I) - AA(I)
  100   CONTINUE
*
      IVIS   =-1
      AXDELT=ABS(XDELT)
      AYDELT=ABS(YDELT)
      IF ((AXDELT.LE.EESCR).AND.(AYDELT.LE.EESCR))GOTO 999
      IVIS   = 0
*           C O M P U T E   E D G E   E Q U A T I O N
      Q        = XDELT*XDELT + YDELT*YDELT
      ABC(1,1) = XDELT/Q
      ABC(2,1) = YDELT/Q
      ABC(3,1) =-(XDELT*XA + YDELT*YA)/Q
      XXXQ        = SQRT(Q)
      ABC(1,2) =-YDELT/XXXQ
      ABC(2,2) = XDELT/XXXQ
      ABC(3,2) = (YDELT*XA - XDELT*YA)/XXXQ
*           C O M P U T E   E D G E   M I N - M A X
      DEDGE(1) =-MAX(XA,XB)
      DEDGE(2) =-MAX(YA,YB)
      DEDGE(3) = MIN(XA,XB)
      DEDGE(4) = MIN(YA,YB)
      DEDGE(5) = MIN(ZA,ZB)
*
      NPART  = 0
      TDEL   = EESCR / XXXQ
  999 RETURN
      END
+DECK,  CGVHED, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGVHED(XYZ,IFACE,IPF,DFACE,ITREE,ISTACK,ALEFT,ARIGHT)
************************************************************************
*                                                                      *
*     Name: CGVHED                                                     *
*     Author: E. Chernyaev                       Date:    08.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Hidden line removal algorithm                          *
*               (tree search is used for min-max test)                 *
*                                                                      *
*     References: CGVEDG, CGVTEF                                       *
*                                                                      *
*     Input: XYZ(3,*) - nodes coordinates                              *
*         IFACE(*) - faces                                             *
*           IPF(*) - pointers to faces beginings                       *
*       DFACE(6,*) - faces min-max                                     *
*       ITREE(4,*) - tree of faces min-max                             *
*        ISTACK(*) - stack for tree search                             *
*         ALEFT(*) - min-max of left subtrees                          *
*        ARIGHT(*) - min-max of rigth subtrees                         *
*                                                                      *
*     Output: none                                                     *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGCEDG.
      REAL            XYZ(3,*),DFACE(6,*),ALEFT(*),ARIGHT(*)
*SG
      INTEGER         IPF(*)
      INTEGER         IFACE(*)
      INTEGER         ISTACK(*),ITREE(4,*)
      INTEGER         INDLFT(5),INDRGT(5)
*SG
      DATA            INDLFT/3,4,5,1,2/,INDRGT/3,4,1,2,1/
*-
      JS     = 0
      JT     = 1
*           T R E E   S E A R C H
  200 NF     = ITREE(1,JT)
      IND    = ITREE(4,JT)
      IF (DEDGE(IND) .GT. DFACE(IND,NF))      GOTO 300
      DO 210 I=1,5
        IF (DEDGE(I) .GT. DFACE(I,NF))        GOTO 220
  210   CONTINUE
      NIPF=IPF(NF)
      CALL CGVTEF(IFACE(NIPF),XYZ,IVIS)
      IF (IVIS .LT. 0)                        GOTO 900
*           S T O R E   L E F T   L I N K   I N   S T A C K  (IF NEED)
  220 IF (DEDGE(INDLFT(IND)) .GT. ALEFT(JT))  GOTO 300
      JS     = JS + 1
      ISTACK(JS) = ITREE(2,JT)
*           S T E P   T O   R I G H T
  300 IF (DEDGE(INDRGT(IND)) .GT. ARIGHT(JT)) GOTO 400
      JT     = ITREE(3,JT)
      GOTO 200
*           R E S T O R E   L E F T   L I N K   F R O M   S T A C K
  400 IF (JS .EQ. 0)                          GOTO 999
      JT     = ISTACK(JS)
      JS     = JS - 1
      GOTO 200
*
  900 NPART = -1
  999 RETURN
      END
+DECK,  CGVTEF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGVTEF(IFACE,XYZ,IVIS)
************************************************************************
*                                                                      *
*     Name: CGVTEF                                                     *
*     Author: E. Chernyaev                       Date:    16.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Test edge against face                                 *
*                                                                      *
*     References: CGHPLA, CGVTIN                                       *
*                                                                      *
*     Input: IFACE(*) - face                                           *
*            XYZ(3,*) - nodes coordinates                              *
*                                                                      *
*     Output: IVIS = -1 for unvisible edge                             *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGDELT.
+CDE, CGCEDG.
*SG
      INTEGER   IFACE(*)
*SG
      REAL      XYZ(3,*),ABCD(4)
*-
      ERROR  = 2.*EESCR
      IVIS   = 0
      NEDGE  = IFACE(1)
      JF     = 2
      JT     = 0
      TMIN   = 99999.
      TMAX   =-99999.
*           C O M P U T E   A L L   I N T E R S E C T I O N   POINTS
      DO 140 NE=1,NEDGE
        N1     = IFACE(JF)
        N2     = IFACE(JF+1)
        JF     = JF + 2
        TY1    = ABC(1,2)*XYZ(1,N1) + ABC(2,2)*XYZ(2,N1) + ABC(3,2)
        TY2    = ABC(1,2)*XYZ(1,N2) + ABC(2,2)*XYZ(2,N2) + ABC(3,2)
        IF (ABS(TY1) .LE. ERROR) TY1 = 0.
        IF (ABS(TY2) .LE. ERROR) TY2 = 0.
        IF (TY1*TY2) 110,120,140
  110   TX1    = ABC(1,1)*XYZ(1,N1) + ABC(2,1)*XYZ(2,N1) + ABC(3,1)
        TX2    = ABC(1,1)*XYZ(1,N2) + ABC(2,1)*XYZ(2,N2) + ABC(3,1)
        T1     = (TX1*TY2-TX2*TY1) / (TY2-TY1)
        T2     = 0.
        GOTO 130
  120   IF (TY2 .NE. 0.) GOTO 121
        IF (TY1 .NE. 0.) GOTO 122
        TTT(1,JT+1) = ABC(1,1)*XYZ(1,N1) + ABC(2,1)*XYZ(2,N1) + ABC(3,1)
        TTT(2,JT+1) = 0
        TTT(1,JT+2) = ABC(1,1)*XYZ(1,N2) + ABC(2,1)*XYZ(2,N2) + ABC(3,1)
        TTT(2,JT+2) = 0
        IF (TTT(1,JT+1) .LT. TMIN)  TMIN = TTT(1,JT+1)
        IF (TTT(1,JT+1) .GT. TMAX)  TMAX = TTT(1,JT+1)
        IF (TTT(1,JT+2) .LT. TMIN)  TMIN = TTT(1,JT+1)
        IF (TTT(1,JT+2) .GT. TMAX)  TMAX = TTT(1,JT+1)
        GOTO 140
  121   T1     = ABC(1,1)*XYZ(1,N1) + ABC(2,1)*XYZ(2,N1) + ABC(3,1)
        IF (TY2 .LT. 0.) T2=-1.
        IF (TY2 .GT. 0.) T2= 1.
        GOTO 130
  122   T1     = ABC(1,1)*XYZ(1,N2) + ABC(2,1)*XYZ(2,N2) + ABC(3,1)
        IF (TY1 .LT. 0.) T2=-1
        IF (TY1 .GT. 0.) T2= 1
        GOTO 130
  130   JT     = JT + 1
        TTT(1,JT)= T1
        TTT(2,JT)= T2
        IF (TTT(1,JT) .LT. TMIN)  TMIN = TTT(1,JT)
        IF (TTT(1,JT) .GT. TMAX)  TMAX = TTT(1,JT)
  140   CONTINUE
*           C H E C K   I F   F A C E   O U T   O F   E D G E
      IF (JT .EQ. 0)                  GOTO 999
      IF (TMIN.GE.1.-TDEL .OR. TMAX.LE.0.+TDEL) GOTO 999
*           C O M P U T E   F A C E   P L A N E
*           C H E C K   I F   E D G E   B E F O R E  P L A N E
      CALL CGHPLA(IFACE,XYZ,ABCD)
      DA    = ABCD(1)*AA(1)+ABCD(2)*AA(2)+ABCD(3)*AA(3)+ABCD(4)
      DB    = ABCD(1)*BB(1)+ABCD(2)*BB(2)+ABCD(3)*BB(3)+ABCD(4)
      IF (DA.GE.-2.*EESCR .AND. DB.GE.-2.*EESCR)      GOTO 999
      IF (DA.LE.0. .AND. DB.LE.0.)              GOTO 150
      T0    = DA/(DA-DB)
      IF (DA.GE.0. .AND. TMAX.LE.T0+TDEL)       GOTO 999
      IF (DB.GE.0. .AND. TMIN.GE.T0-TDEL)       GOTO 999
*          S O R T   I N T E R S E C T I O N   P O I N T S
      IF (JT .EQ. 1)    GOTO 400
  150 DO 300 I=1,JT-1
        DO 200 J=I,1,-1
          IF (TTT(1,J+1) .GE. TTT(1,J))   GOTO 300
          T1         = TTT(1,J+1)
          T2         = TTT(2,J+1)
          TTT(1,J+1) = TTT(1,J)
          TTT(2,J+1) = TTT(2,J)
          TTT(1,J)   = T1
          TTT(2,J)   = T2
  200     CONTINUE
  300   CONTINUE
*
      DO 310 I=2,JT
        IF (TTT(2,I-1) .EQ. -2.)      GOTO 310
*
******* 02-FEB-1990  **** R.N.
        IF(.0001.LT.ABS(TTT(1,I)-TTT(1,I-1)))GOTO 310
******* 02-FEB-1990  **** R.N.
*
        IF (TTT(1,I) .NE. TTT(1,I-1)) GOTO 310
        IF (TTT(2,I) .EQ. TTT(2,I-1)) GOTO 305
        IF (TTT(2,I) .EQ. 0.)         GOTO 305
        IF (TTT(2,I-1) .EQ. 0.)       GOTO 305
        TTT(2,I)   = -2
        GOTO 310
  305   TTT(2,I-1) = -2.
        TTT(2,I)   = -2.
  310   CONTINUE
*
      J     = 0
      DO 320 I=1,JT
        IF (TTT(2,I) .EQ. -2.)        GOTO 320
        J     = J + 1
        TTT(1,J) = TTT(1,I)
  320   CONTINUE
      JT    = J
      IF (JT .EQ. 0)                  GOTO 999
*
  400 T1    = 0.
      T2    = 1.
      IF (DA .GT. 0.)           T1 = T0
      IF (DB .GT. 0.)           T2 = T0
      DO 500 I=1,JT,2
        IF (TTT(1,I+1) .LE. T1)   GOTO 500
        IF (TTT(1,I)   .GE. T2)   GOTO 999
        TMIN = TTT(1,I)
        TMAX = TTT(1,I+1)
        IF (TMIN .LT. T1)       TMIN = T1
        IF (TMAX .GT. T2)       TMAX = T2
        IF (TMAX-TMIN.LE.TDEL)  GOTO 500
        CALL CGVTIN(TMIN,TMAX,IVIS)
        IF (IVIS .LT. 0)        GOTO 999
  500   CONTINUE
  999 RETURN
      END
+DECK,  CGVTIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGVTIN(TMIN,TMAX,IVIS)
************************************************************************
*                                                                      *
*     Name: CGVTIN                                                     *
*     Author: E. Chernyaev                       Date:    18.08.88     *
*                                                Revised:              *
*                                                                      *
*     Function: Insert new portion in hidden portions list             *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: TMIN - portion begin                                      *
*            TMAX - portion end                                        *
*                                                                      *
*     Output: IVIS = -1 if edge fully unvisible                        *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGCEDG.
*-
      IF (TMAX-TMIN .LT. TDEL)          GOTO 999
      KJ     = 0
      IF (NPART .EQ. 0)                 GOTO 210
*           C H E C K   C O V E R E D   P O R T I O N   OF LINE AGAINST
*           P R E V I O U S   C O V E R E D   P O R T I O N S
      DO 100 I = 1,NPART
        IF (TMIN.LE.TSTRT(I) .AND. KJ.EQ.0)     KJ = I
        IF (TMIN.GT.TEND(I)+TDEL .OR. TMAX.LT.TSTRT(I)-TDEL)    GOTO 100
*           T H E R E   I S   C O V E R E D   PORTIONS  INTERSECTIONS
        IF (TMIN.GE.TSTRT(I)-TDEL .AND. TMAX.LE.TEND(I)+TDEL)   GOTO 999
        IF (TMIN .LT. TSTRT(I))         TSTRT(I) = TMIN
        IF (TMAX .GT. TEND(I))          TEND(I)  = TMAX
        GOTO 300
  100   CONTINUE
*           N O   C O V E R E D   P O R T I O N S   INTERSECTION.
*           C R E A T E   N E W   P O R T I O N
      IF (KJ .EQ .0)                    GOTO 210
      DO 200 I = NPART,KJ,-1
        TSTRT(I+1) = TSTRT(I)
        TEND(I+1)  = TEND(I)
  200   CONTINUE
  210 NPART  = NPART + 1
      IF (KJ .EQ. 0)                    KJ = NPART
      TSTRT(KJ) = TMIN
      TEND(KJ)  = TMAX
*           C O V E R E D   P O R T I O N S   RECONSTRUCTION (IF NEED)
  300 IF (NPART .LE. 1)                 GOTO 600
      J      = 1
      DO 500 I = 2,NPART
        IF (TSTRT(I)-TEND(J) .LT. TDEL) GOTO 490
        J = J+1
        TSTRT(J) = TSTRT(I)
        TEND(J)  = TEND (I)
        GOTO 500
  490   TEND(J)  = MAX (TEND(J),TEND(I))
  500   CONTINUE
      NPART  = J
*           C H E C K   I F   L I N E   I S   F U L L Y   C O V E R E D
  600 T0     = 0.
      T1     = 1.
      IF (TSTRT(1) .LE. TDEL)           T0 = TEND(1)
      IF (TEND(NPART) .GE. 1.-TDEL)     T1 = TSTRT(NPART)
      IF (T0 .GE. T1)                   IVIS = -1
*
  999 RETURN
      END
+DECK,  CGWIRE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGWIRE(CG,NTRAN,IFHIDE,NMAX,WIRE,ISHAPE,SHADE)
************************************************************************
*                                                                      *
*     Name: CGWIRE                                                     *
*     Author: E. Chernyaev                       Date:    15.04.88     *
*     Revised by: S.Giani                        Date:    24.04.91     *
*                                                                      *
*     Function: Transfer CG-object to WIRE-object                      *
*                                                                      *
*     References: CGTSTR, CGFVIS, CGWSOR                               *
*                                                                      *
*     Input:  CG - CG-object                                           *
*             NT - number of transformation to screen coordinates      *
*         IFHIDE - flag ( 0 - all edges,-1 - only not hidden)          *
*          NMAX  - max-length of WIRE array                            *
*                                                                      *
*     Output: WIRE - WIRE-object                                       *
*                    WIRE(1) - length of WIRE-object                   *
*                        = 0 if error in CG-object structure           *
*                        < 0 if no space in WIRE array or error        *
*                            in parameters                             *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGCTRA.
*SG
+CDE, GCDRAW.
+CDE, GCGOBJ.
+CDE, GCSPEE.
*SG
      REAL      CG(*),WIRE(*)
      INTEGER   SHADE(*)
*-
      LLEP=ABS(LEP)
      WIRE(1)= 0.
      IF(LLEP.NE.1)SHADE(1)=0.
      MMM=1
*           T E S T   P A R A M E T E R S
      IF (NTRAN .LE. 0)                 GOTO 999
      IF (NTRAN .GT. NTMAX)             GOTO 999
      IF (NMAX  .LE. 0)                 GOTO 999
      CALL CGTSTR(CG,IREP)
      IF (IREP .LT. 0)                  GOTO 999
      NFACE  = CG(KCGNF)
*SG
      IF (NFACE .EQ. 0)THEN
         WIRE(KCGNF)=0
         GOTO 999
      ENDIF
*SG
*           I N I T I A L I S A T I O N
      NWIRE  = 0
      JCG    = LCGHEA
      JWR    = LCGHEA
*
**          L O O P   A L O N G   F A C E S
*SG
      NTIM=0
*SG
      DO 300 NF=1,NFACE
        JCGFAC = JCG
        NEDGE  = CG(JCG+KCGNE)
*           D E F I N E   V A L U E   O F  "IFVIS"
        IFVIS  = -1
        IF (IFHIDE .NE. 0)              GOTO 200
        JCG    = JCG + LCGFAC
        DO 100 NE=1,NEDGE
          IF (CG(JCG+KCGAE) .LT. 0.)    GOTO 200
          JCG   = JCG + LCGEDG
  100     CONTINUE
        IFVIS = 0
        GOTO 210
*
**           T E S T   F A C E   V I S I B I L I T Y
**           M O V E   E D G E S   T O   W I R E - O B J E C T
*
  200   CALL CGFARE(NTRAN,CG(JCGFAC+1),IFVIS,ISHAPE)
  210   IF (IFHIDE.NE.0 .AND. IFVIS.LT.0)       GOTO 290
        JCG    = JCGFAC
        AFACE  = CG(JCG+KCGAF)
        JCG    = JCG + LCGFAC
        DO 250 NE=1,NEDGE
          IF (CG(JCG+KCGAE) .LT. 0.)            AEDGE =-AFACE - 1
          IF (CG(JCG+KCGAE) .GE. 0.)            AEDGE = AFACE
          IF (AEDGE.LT.0. .AND. IFVIS.LT.0)     GOTO 240
          IF (NCLAS3+JWR+LCGEDG .GT. NMAX)             GOTO 220
          WIRE(JWR+KCGAE) = AEDGE
          WIRE(JWR+KCGX1) = CG(JCG+KCGX1)
          WIRE(JWR+KCGY1) = CG(JCG+KCGY1)
          WIRE(JWR+KCGZ1) = CG(JCG+KCGZ1)
          WIRE(JWR+KCGX2) = CG(JCG+KCGX2)
          WIRE(JWR+KCGY2) = CG(JCG+KCGY2)
          WIRE(JWR+KCGZ2) = CG(JCG+KCGZ2)
  220     NWIRE  = NWIRE + 1
          JWR    = JWR + LCGEDG
  240     JCG    = JCG + LCGEDG
  250     CONTINUE
        MMM=MMM+1
        IF(LLEP.NE.1)SHADE(MMM)=NWIRE
  290   JCG    = JCGFAC + LCGFAC + NEDGE*LCGEDG
  300   CONTINUE
*
**          D E L E T E  V E R Y   S M A L L   W I R E S
**          S E T   N E E D E D   D I R E C T I O N
**          S O R T   W I R E S
*
*SG
*        Finding the total number of words needed to build
*        the whole Wire Structure.
*
      NCLAS3=NCLAS3+JWR
      IF(NCLAS3.GE.NMAX)THEN
         KCGST=-8
         GOTO 999
      ENDIF
*SG
      IF (JWR .GT. NMAX)        GOTO 998
*SG
      LINFIL=IBITS(LINATT,13,3)
      IF(LINFIL.EQ.0)CALL CGWSOR(NWIRE,WIRE(KCGNF+1))
*SG
      WIRE(KCGSIZ) = LCGHEA + NWIRE*LCGEDG
      IF(LLEP.NE.1)SHADE(1)=MMM
      WIRE(KCGATT) = CG(KCGATT)
      WIRE(KCGNF)  = NWIRE
      GOTO 999
*
  998 WIRE(KCGSIZ) = NMAX - JWR
  999 RETURN
      END
+DECK,  CGWSOR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGWSOR(NWIRE,WIRE)
************************************************************************
*                                                                      *
*     Name: CGWSOR                                                     *
*     Author: E. Chernyaev                       Date:    16.04.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Prepare wire array                                     *
*                                                                      *
*     References: CGSHEL                                               *
*                                                                      *
*     Input:  NWIRE - number of edges                                  *
*     Output: WIRE(*,*)  - edges                                       *
*                                                                      *
*     Output:                                                          *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
      REAL      WIRE(LCGEDG,*),SAVE(LCGEDG)
*-
      ERROR  = 1.5*EEWOR
      NE     = 0
      ATRINV = 0.
      CALL CGSHEL(ATRINV,ERROR,NWIRE,WIRE)
      IF (NWIRE .LE. 0)                 GOTO 999
*
**          D E L E T E   U N V I S I B L E    D O U B L E  E D G E S
**          A T R I B U T E   A N A L I S A T I O N
*
      J      = 1
  100 IF (J .GT. NWIRE)                 GOTO 999
      A1          = WIRE(KCGAE,J)
      SAVE(KCGX1) = WIRE(KCGX1,J)
      SAVE(KCGY1) = WIRE(KCGY1,J)
      SAVE(KCGZ1) = WIRE(KCGZ1,J)
      SAVE(KCGX2) = WIRE(KCGX2,J)
      SAVE(KCGY2) = WIRE(KCGY2,J)
      SAVE(KCGZ2) = WIRE(KCGZ2,J)
      J     = J + 1
  150 IF (J .GT. NWIRE)                                 GOTO 200
      IF (ABS(WIRE(KCGX1,J)-SAVE(KCGX1)) .GT. ERROR)    GOTO 200
      IF (ABS(WIRE(KCGY1,J)-SAVE(KCGY1)) .GT. ERROR)    GOTO 200
      IF (ABS(WIRE(KCGZ1,J)-SAVE(KCGZ1)) .GT. ERROR)    GOTO 200
      IF (ABS(WIRE(KCGX2,J)-SAVE(KCGX2)) .GT. ERROR)    GOTO 200
      IF (ABS(WIRE(KCGY2,J)-SAVE(KCGY2)) .GT. ERROR)    GOTO 200
      IF (ABS(WIRE(KCGZ2,J)-SAVE(KCGZ2)) .GT. ERROR)    GOTO 200
*           D O U B L E   W I R E
      A2     = WIRE(KCGAE,J)
      J      = J + 1
      IF (A1.LT.0. .AND. A2.LT.0.)                      GOTO 100
      IF (A1.LT.0.)                                     A1 =-A1 - 1.
      IF (A2.LT.0.)                                     A2 =-A2 - 1.
      IF (A2.GT.A1)                                     A1 = A2
      GOTO 150
*           I N S E R T   I N   W I R E (*)
  200 NE      = NE + 1
      IF (A1.LT.0.)                                     A1 =-A1 - 1.
      WIRE(KCGAE,NE) = A1
      WIRE(KCGX1,NE) = SAVE(KCGX1)
      WIRE(KCGY1,NE) = SAVE(KCGY1)
      WIRE(KCGZ1,NE) = SAVE(KCGZ1)
      WIRE(KCGX2,NE) = SAVE(KCGX2)
      WIRE(KCGY2,NE) = SAVE(KCGY2)
      WIRE(KCGZ2,NE) = SAVE(KCGZ2)
      GOTO 100
*
  999 NWIRE  = NE
      RETURN
      END
+DECK,  CGZRE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGZRE(K,CG,LCG)
************************************************************************
*                                                                      *
*     Name: CGZROT                                                     *
*     Author: E. Chernyaev                       Date:    01.02.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Rotate edge about Z-axis                               *
*                                                                      *
*     References: none                                                 *
*                                                                      *
*     Input: K  - number for step                                      *
*            CG - CG-object                                            *
*                                                                      *
*     Output: LCG - last index in CG-object                            *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
+CDE, CGCAAN.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION  X1,Y1,H1,X2,Y2,H2,AW,AA,BB,CC,DD,S
      DOUBLE PRECISION  D1,D2,DX1,DY1,DH1,DX2,DY2,DH2
+SELF.
      REAL      CG(*)
*-
      J      = 0
      D1     = ABS(XYHA(1,1)) + ABS(XYHA(2,1))
      D2     = ABS(XYHA(1,2)) + ABS(XYHA(2,2))
      IF (D1.LT.EEWOR .AND. D2.LT.EEWOR)        GOTO 999
      X1     = XYHA(1,1)*COSI - XYHA(2,1)*SINI
      Y1     = XYHA(1,1)*SINI + XYHA(2,1)*COSI
      X2     = XYHA(1,2)*COSI - XYHA(2,2)*SINI
      Y2     = XYHA(1,2)*SINI + XYHA(2,2)*COSI
      H1     = XYHA(3,1)
      H2     = XYHA(3,2)
      IF (ABS(H1-H2) .LT. EEWOR)               GOTO 200
      DX1    = X1 - (X2*COSDA(K)-Y2*SINDA(K))
      DY1    = Y1 - (X2*SINDA(K)+Y2*COSDA(K))
      DH1    = H1 - H2
      DX2    = (X1*COSDA(K)-Y1*SINDA(K)) - X2
      DY2    = (X1*SINDA(K)+Y1*COSDA(K)) - Y2
      DH2    = H1 - H2
      AA     = DY1*DH2 - DY2*DH1
      BB     = DH1*DX2 - DH2*DX1
      CC     = DX1*DY2 - DX2*DY1
      S      = SQRT(AA*AA + BB*BB + CC*CC)
      IF (S .LT. EEWOR)                         GOTO 999
      AA     = AA / S
      BB     = BB / S
      CC     = CC / S
      DD     =-(AA*X1 + BB*Y1 + CC*H1)
      DO 130 I=1,NASTP(K)
        CG(J+KCGAF) = 0.
        CG(J+KCGAA) = AA
        CG(J+KCGBB) = BB
        CG(J+KCGCC) = CC
        CG(J+KCGDD) = DD
        AW     = AA*COSDA(K) - BB*SINDA(K)
        BB     = AA*SINDA(K) + BB*COSDA(K)
        AA     = AW
        CG(J+KCGNE) = 4.
        IF (D1.LT.EEWOR .OR. D2.LT.EEWOR)       CG(J+KCGNE) = 3.
        J      = J + LCGFAC
*
        CG(J+KCGAE) = ATREDG
        IF (I.EQ.1 .AND. IFULL.EQ.0)    CG(J+KCGAE) = 0.
        CG(J+KCGX1) = X2
        CG(J+KCGY1) = Y2
        CG(J+KCGZ1) = H2
        CG(J+KCGX2) = X1
        CG(J+KCGY2) = Y1
        CG(J+KCGZ2) = H1
        J      = J + LCGEDG
*
        IF (D1 .LT. EEWOR)              GOTO 110
        CG(J+KCGAE) = XYHA(4,1)
        CG(J+KCGX1) = X1
        CG(J+KCGY1) = Y1
        CG(J+KCGZ1) = H1
        IF (I.NE.NASTP(K) .OR.  IFULL.EQ.0)
     +                         CG(J+KCGX2) = X1*COSDA(K) - Y1*SINDA(K)
        IF (I.NE.NASTP(K) .OR.  IFULL.EQ.0)
     +                         CG(J+KCGY2) = X1*SINDA(K) + Y1*COSDA(K)
        IF (I.EQ.NASTP(K) .AND. IFULL.NE.0)
     +                         CG(J+KCGX2) = CG(LCGFAC+KCGX2)
        IF (I.EQ.NASTP(K) .AND. IFULL.NE.0)
     +                         CG(J+KCGY2) = CG(LCGFAC+KCGY2)
        CG(J+KCGZ2) = H1
        X1     = CG(J+KCGX2)
        Y1     = CG(J+KCGY2)
        J      = J + LCGEDG
*
  110   IF (D2 .LT. EEWOR)              GOTO 120
        CG(J+KCGAE) = XYHA(4,2)
        CG(J+KCGX2) = X2
        CG(J+KCGY2) = Y2
        CG(J+KCGZ2) = H2
        IF (I.NE.NASTP(K) .OR.  IFULL.EQ.0)
     +                         CG(J+KCGX1) = X2*COSDA(K) - Y2*SINDA(K)
        IF (I.NE.NASTP(K) .OR.  IFULL.EQ.0)
     +                         CG(J+KCGY1) = X2*SINDA(K) + Y2*COSDA(K)
        IF (I.EQ.NASTP(K) .AND. IFULL.NE.0)
     +                         CG(J+KCGX1) = CG(LCGFAC+KCGX1)
        IF (I.EQ.NASTP(K) .AND. IFULL.NE.0)
     +                         CG(J+KCGY1) = CG(LCGFAC+KCGY1)
        CG(J+KCGZ1) = H2
        X2     = CG(J+KCGX1)
        Y2     = CG(J+KCGY1)
        J      = J + LCGEDG
*
  120   CG(J+KCGAE) = ATREDG
        IF (I.EQ.NASTP(K) .AND. IFULL.EQ.0)     CG(J+KCGAE) = 0.
        CG(J+KCGX1) = X1
        CG(J+KCGY1) = Y1
        CG(J+KCGZ1) = H1
        CG(J+KCGX2) = X2
        CG(J+KCGY2) = Y2
        CG(J+KCGZ2) = H2
        J      = J + LCGEDG
  130   CONTINUE
      GOTO 999
*
**          M A K E   H O R I Z O N T A L   F A C E
*
  200 DD     = D1 - D2
      IF (ABS(DD) .LT. EEWOR)          GOTO 999
      K1     = K
      K2     = 3 - K
      CG(J+KCGAF) = 0.
      CG(J+KCGAA) = 0.
      CG(J+KCGBB) = 0.
      IF (DD .GT. 0)                    CG(J+KCGCC) = 1.
      IF (DD .LT. 0)                    CG(J+KCGCC) =-1.
      CG(J+KCGDD) =-XYHA(3,1) * CG(J+KCGCC)
      NEDGE  = 0.
      IF (D1 .GT. 0)                    NEDGE = NEDGE + NASTP(K1)
      IF (D2 .GT. 0)                    NEDGE = NEDGE + NASTP(K2)
      IF (IFULL .EQ. 0)                 NEDGE = NEDGE + 2
      CG(J+KCGNE) = NEDGE
      J      = J + LCGFAC
      IF (IFULL .NE. 0)                 GOTO 210
      CG(J+KCGAE) = 0.
      CG(J+KCGX1) = X2
      CG(J+KCGY1) = Y2
      CG(J+KCGZ1) = H2
      CG(J+KCGX2) = X1
      CG(J+KCGY2) = Y1
      CG(J+KCGZ2) = H1
      J      = J + LCGEDG
  210 IF (D1 .EQ. 0.)                    GOTO 230
      DO 220 I=1,NASTP(K1)
        CG(J+KCGAE) = XYHA(4,1)
        CG(J+KCGX1) = X1
        CG(J+KCGY1) = Y1
        CG(J+KCGZ1) = H1
        CG(J+KCGX2) = X1*COSDA(K1) - Y1*SINDA(K1)
        CG(J+KCGY2) = X1*SINDA(K1) + Y1*COSDA(K1)
        CG(J+KCGZ2) = H1
        X1     = CG(J+KCGX2)
        Y1     = CG(J+KCGY2)
        J      = J + LCGEDG
  220   CONTINUE
      IF (IFULL .EQ. 0)                  GOTO 230
      X1     = XYHA(1,1)*COSI - XYHA(2,1)*SINI
      Y1     = XYHA(1,1)*SINI + XYHA(2,1)*COSI
      CG(J-LCGEDG+KCGX2) = X1
      CG(J-LCGEDG+KCGY2) = Y1
*
  230 IF (D2 .EQ. 0.)                    GOTO 250
      DO 240 I=1,NASTP(K2)
        CG(J+KCGAE) = XYHA(4,2)
        CG(J+KCGX2) = X2
        CG(J+KCGY2) = Y2
        CG(J+KCGZ2) = H2
        CG(J+KCGX1) = X2*COSDA(K2) - Y2*SINDA(K2)
        CG(J+KCGY1) = X2*SINDA(K2) + Y2*COSDA(K2)
        CG(J+KCGZ1) = H2
        X2     = CG(J+KCGX1)
        Y2     = CG(J+KCGY1)
        J      = J + LCGEDG
  240   CONTINUE
      IF (IFULL .EQ. 0)                  GOTO 250
      X2     = XYHA(1,2)*COSI - XYHA(2,2)*SINI
      Y2     = XYHA(1,2)*SINI + XYHA(2,2)*COSI
      CG(J-LCGEDG+KCGX1) = X2
      CG(J-LCGEDG+KCGY1) = Y2
*
  250 IF (IFULL .NE. 0)                 GOTO 999
      CG(J+KCGAE) = 0.
      CG(J+KCGX1) = X1
      CG(J+KCGY1) = Y1
      CG(J+KCGZ1) = H1
      CG(J+KCGX2) = X2
      CG(J+KCGY2) = Y2
      CG(J+KCGZ2) = H2
      J      = J + LCGEDG
*
  999 LCG    = J
      RETURN
      END
+DECK,  CGZREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:45  cernlib
* Geant

      SUBROUTINE CGZREV(RZ,A1,A2,NA,LCG,CG)
************************************************************************
*                                                                      *
*     Name: CGZREV                                                     *
*     Author: E. Chernyaev                       Date:    05.02.89     *
*                                                Revised:              *
*                                                                      *
*     Function: Create CG-object by revolution around Z-axis           *
*                                                                      *
*     References: CGSIZE, CGSAAN, CGZRE                                *
*                                                                      *
*     Input: RZ(2,4) - 4 node contour (1-st must be left lower node)   *
*                A1 - initial angle                                    *
*                A2 - end angle                                        *
*                NA - number of steps on angle                         *
*               LCG - max-size of CG-object                            *
*                                                                      *
*     Output: CG - CG-object                                           *
*                  CG(1) - length of CG-object                         *
*                        = 0 if error in parameters                    *
*                        < 0 if no space                               *
*                                                                      *
*     Errors: none                                                     *
*                                                                      *
************************************************************************
+CDE, CGGPAR.
+CDE, CGDELT.
+CDE, CGCAAN.
      REAL      RZ(2,4),CG(*)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION  SINE,COSE
+SELF.
      INTEGER   NFAC(4),NEDG(4)
*-
      CG(KCGSIZ)  = 0.
*           T E S T   P A R A M E T E R S   C O R R E C T N E S S
      DO 100 I=1,4
        IF (RZ(1,I) .LT. 0.)    GOTO 999
        K      = I + 1
        IF (I .EQ. 4)           K = 1
        RLENG  = ABS(RZ(1,I)-RZ(1,K))
        ZLENG  = ABS(RZ(2,I)-RZ(2,K))
        IF (RLENG.LT.EEWOR .AND. ZLENG.LT.EEWOR)        GOTO 999
  100   CONTINUE
      CALL CGSAAN(A1,A2,NA,NA,IREP)
*           C O M P U T E   S I Z E   O F   C G - O B J E C T
      NFATYP = 4
      NEDG(1)= 3
      NEDG(2)= 4
      IF (IFULL .NE. 0)         NEDG(3)= NA
      IF (IFULL .EQ. 0)         NEDG(3)= NA + 2
      IF (IFULL .NE. 0)         NEDG(4)= NA + NA
      IF (IFULL .EQ. 0)         NEDG(4)= NA + NA + 2
      NFAC(1)= 0
      IF (IFULL .NE. 0)         NFAC(2)= 0
      IF (IFULL .EQ. 0)         NFAC(2)= 2
      NFAC(3)= 0
      NFAC(4)= 0
*
      DO 150 I=1,4
        K      = I + 1
        IF (I .EQ. 4)           K = 1
        IF (RZ(1,I).LT.EEWOR .AND. RZ(1,K).LT.EEWOR)    GOTO 150
        IF (ABS(RZ(2,I)-RZ(2,K)) .LT. EEWOR)            GOTO 110
        J      = 2
        IF (RZ(1,I) .LT. EEWOR)    J = J - 1
        IF (RZ(1,K) .LT. EEWOR)    J = J - 1
        NFAC(J) = NFAC(J) + NA
        GOTO 150
  110   IF (ABS(RZ(1,I)-RZ(1,K)) .LT. EEWOR)            GOTO 150
        J      = 4
        IF (RZ(1,I) .LT. EEWOR)    J = J - 1
        IF (RZ(1,K) .LT. EEWOR)    J = J - 1
        NFAC(J) = NFAC(J) + 1
  150   CONTINUE
      CG(KCGSIZ)  = CGSIZE(LCG,NFATYP,NFAC,NEDG)
      IF (CG(KCGSIZ) .LE. 0.)   GOTO 999
*
**          C R E A T E   C G - O B J E C T
*
      CG(KCGATT) = 0.
      CG(KCGNF)  = NFAC(1) + NFAC(2) + NFAC(3) + NFAC(4)
      JCG        = LCGHEA
      ATREDG     =-1.
      XYHA(2,1)  = 0.
      XYHA(2,2)  = 0.
      XYHA(4,1)  = 0.
      XYHA(4,2)  = 0.
      DO 200 I=1,4
        K      = I + 1
        IF (I .EQ. 4)           K = 1
        XYHA(1,1) = RZ(1,I)
        XYHA(3,1) = RZ(2,I)
        XYHA(1,2) = RZ(1,K)
        XYHA(3,2) = RZ(2,K)
        CALL CGZRE(2,CG(JCG+1),J)
        JCG    = JCG + J
  200   CONTINUE
      IF (IFULL .NE. 0.)        GOTO 999
*           C R E A T E   S I D E   F A C E S
      CG(JCG+KCGAF) = 0.
      CG(JCG+KCGAA) = SINI
      CG(JCG+KCGBB) =-COSI
      CG(JCG+KCGCC) = 0.
      CG(JCG+KCGDD) = 0.
      CG(JCG+KCGNE) = 4.
      JCG    = JCG + LCGFAC
      DO 300 I=1,4
        K      = I + 1
        IF (I .EQ. 4)           K = 1
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = RZ(1,I)*COSI
        CG(JCG+KCGY1) = RZ(1,I)*SINI
        CG(JCG+KCGZ1) = RZ(2,I)
        CG(JCG+KCGX2) = RZ(1,K)*COSI
        CG(JCG+KCGY2) = RZ(1,K)*SINI
        CG(JCG+KCGZ2) = RZ(2,K)
        JCG    = JCG + LCGEDG
  300   CONTINUE
*
      CG(JCG+KCGAF) = 0.
      COSE   = COS(A2*RAD)
      SINE   = SIN(A2*RAD)
      CG(JCG+KCGAA) =-SINE
      CG(JCG+KCGBB) = COSE
      CG(JCG+KCGCC) = 0.
      CG(JCG+KCGDD) = 0.
      CG(JCG+KCGNE) = 4.
      JCG    = JCG + LCGFAC
      DO 400 I=1,4
        K      = I + 1
        IF (I .EQ. 4)           K = 1
        CG(JCG+KCGAE) = 0.
        CG(JCG+KCGX1) = RZ(1,K)*COSE
        CG(JCG+KCGY1) = RZ(1,K)*SINE
        CG(JCG+KCGZ1) = RZ(2,K)
        CG(JCG+KCGX2) = RZ(1,I)*COSE
        CG(JCG+KCGY2) = RZ(1,I)*SINE
        CG(JCG+KCGZ2) = RZ(2,I)
        JCG    = JCG + LCGEDG
  400   CONTINUE
*
  999 RETURN
      END
+PATCH, PAMEND.
*- THIS IS THE LAST LINE OF THE PAM FILE geant321
