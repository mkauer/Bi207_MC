+TITLE.
C higz 0.00/00 21/01/03 11.23.07 CVSTOCAR RESTAURATION 
+PATCH, *HIGZ.
+USE, IZ, IG, IG3, IH, IPOST, IFALCO, MENU, GED, IKERNEL, HIGZCC.
+USE, HIGZX11.
+DECK,  PILOT, IF=HIGZ.
+USE, GKS, IF=GKSGRAL,MKGS,PLOT10GKS,UNIGKS,DECGKS,GK2000,ATCGKS,GKSBX.


+USE, X11, IF=-GKS.

+USE, FALCO, IF=-GKS.


+USE, NTC.

+USE, PSCRIPT.

+USE, ZEBRA.

+USE, VAX, IF=ALPHA.

+USE, X11, IF=WINNT,TK_WINDOWS.

+USE, F2C, IF=MSDOS,LINUX, IF=-WINNT.

+USE, BSLASH, IF=SUN,SGI,DECS,IBMRT,HPUX,IPSC,F2C,QMALPH,WINNT.

+USE, BSLASH, T=INHIBIT, IF=QFMSOFT.

+USE, GKSGRAL, IF=SUNGKS,GKSIBM.

+USE, GKS, IF=GKSGRAL,MGKS,PLOT10GKS,UNIGKS,DECGKS,GK2000,ATCGKS,GKSBX.

+USE, CIPACK, IF=MSDOS.
+USE, GL, IF=MSDOS.

+USE, ZBUF, IF=X11.

+USE, GIF, IF=X11, IF=-GIF, IF=-WINNT.

+USE, KERNEL, IF=GL,X11,MACMPW,MSDOS,WINNT.

+USE, QXNO_SC, IF=CRAY,VAX,IBM.

+USE, QX_SC, IF=SGI,IBMRT,SUN,CONVEX,DECS,AIX370,HPUX,NEXT,CONVEX,F2C.

+USE, QXCAPT, IF=MSSTDCALL.
#define type_of_call __stdcall, IF=MSSTDCALL.

# define type_of_call.

+USE, NOVERS, IF=PHIGS.

+USE, CVX, IF=CONVEX, IF=-SINGLE.

+USE, CVY, IF=CONVEX, IF=-SINGLE.
+PATCH, HIGZ.
+KEEP, HIBITVAX.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* hibitvax.inc
      JBIT (IZW,IZP)=JIBITS (IZW,IZP-1,1)
      JBYT (IZW,IZP,NZB)=JIBITS (IZW,IZP-1,NZB)

+KEEP, DI3DEV, IF=DI3000.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* di3dev.inc
      LOGICAL          ENTRY_FLAG
      COMMON /DI3DEV/  ENTRY_FLAG


+KEEP, DI3MET, IF=DI3000.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* di3met.inc
      CHARACTER*30     METNAM
      COMMON /DI3MET/  METNAM


+KEEP, DI3SEG, IF=DI3000.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* di3seg.inc
      LOGICAL          SEGOPN
      COMMON /DI3SEG/  SEGOPN


+KEEP, DICDES.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
*  COMMONS FOR HIGZ-DI3000 INTERFACE

+KEEP, GLIBM, IF=KERNEL, IF=-MSDOS, IF=GL, IF=IBMRT.
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz
* glibm.inc
      INCLUDE 'gl/fgl.h'
      INCLUDE 'gl/fdevice.h'


+KEEP, GLSGI, IF=KERNEL, IF=-MSDOS, IF=GL, IF=SGI.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* glsgi.inc
#include <fgl.h>
#include <fdevice.h>


+KEEP, GOLDEN, IF=MSDOS.
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz
* golden.inc
C--
C--     PARAMETERS FOR SURFER META-FILE
C
        INTEGER    PA,MA,TR,PS,SC,SS,SP
        PARAMETER (NJOB = 7)
        PARAMETER (PA=1,MA=2,TR=3,PS=4,SC=5,SS=6,SP=7)

        PARAMETER (LBUF=256)
        COMMON /GOLDEN/ LUNG(9), NREC, M_OPEN, BIMODE, BUFFER(LBUF/4)
     *,                        IPOINT, SYMFIL,COOR(4), LOCK, FRADEL
        LOGICAL BIMODE, M_OPEN, LOCK, FRADEL
        CHARACTER*80 SYMFIL
        CHARACTER*512 CHMBUF
        EQUIVALENCE (BUFFER,CHMBUF)

+KEEP, GREX, IF=MSDOS.
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz
* grex.inc
C        INCLUDE 'GREX.FH'
C        INCLUDE 'DOS.FH'
       integer get_video_mode
       integer video_configuration
       integer graphics_mode
       integer super_vga
       integer clear
       integer get_device_limits
       integer move
       integer draw
       integer get_cursor
       integer get_clip_limits
       integer set_clip_limits
       integer graphic_text
       integer locate
       integer pause
       integer delete_graphics
       integer beep
       integer set_xor
       integer write_string
       integer set_color
       integer vga_palette
       integer define_color
       integer filled_rectangle
       integer filled_ellipse
       integer open_ellipse
       integer linewi
       integer ixsetfs
       integer setpat
       integer polfil
       integer set_pixel
       integer set_dash
       integer move_cursor
       integer init_mouse
       integer get_mouse
       integer set_mouse
       integer set_mp_ratio
       integer set_palette
       integer magnify_text
       integer text_mode
       integer write_screen
       integer display_off
       integer display_on

+KEEP, HCEQUI, IF=VAX,DECS,LINUX, IF=-PPC.
* Revision 1.2  1998/09/25 09:23:54  mclareni
* Modifications for the Mklinux port flagged by CERNLIB_PPC
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hcequi.inc
      PARAMETER         (I2EQUI=2)

+KEEP, HCEQUI, IF=-VAX, IF=-DECS, IF=-LINUX, IF=-PPC.
* Revision 1.2  1998/09/25 09:23:54  mclareni
* Modifications for the Mklinux port flagged by CERNLIB_PPC
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hcequi.inc
      PARAMETER         (I2EQUI=1)

+KEEP, HCLEVL.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hclevl.inc
      PARAMETER         (LLEV=256)
      COMMON /HCLEVL/   NLEV,FUNLEV(LLEV+1),ICLEV(LLEV+2)

+KEEP, HCLIGH.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hcligh.inc
      PARAMETER (LLIGHT = 4)
      COMMON /HCLIGH/   LOFF,YDL,YLS(LLIGHT),VLS(3,LLIGHT),QA,QD,QS,NQS

+KEEP, HCLINE.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hcline.inc
      PARAMETER         (LLINES=200)
      COMMON /HCLINE/   NLINES,ILLEVL(LLINES),PLINES(3,2,LLINES)

+KEEP, HCMCTR.
* Revision 1.2  2002/05/22 09:16:20  couet
* - the dimension of ABCD was wrong
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hcmctr.inc
      PARAMETER         (NISO = 4, NMAXP = NISO*13, NMAXT = NISO*12)
      REAL              XYZ(3,NMAXP),XYZN(3,NMAXP),GRAD(3,NMAXP)
      REAL              DTRIA(6,NMAXT),ABCD(4,NMAXT)
      INTEGER           ITRIA(3,NMAXT),IATTR(NMAXT),IORDER(NMAXT)
      COMMON /HCMCTR/   XYZ,XYZN,GRAD,DTRIA,ABCD,ITRIA,IATTR,IORDER

+KEEP, HCMCUB.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hcmcub.inc
      COMMON /HCMCUB/   P8(3,8),F8(8),G8(3,8)

+KEEP, HCPHI.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hcphi.inc
      PARAMETER         (NPMAX=180)
      COMMON /HCPHI/    APHI(NPMAX+3)

+KEEP, HCRAST.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* hcrast.inc
      PARAMETER          (NBW=30, L1=NBW/2, L2=(NBW+1)/2)
      PARAMETER          (LMASK=(NBW+1)*L1+(NBW-L1*2)*L2)
      INTEGER            IRAST(4),JMASK(NBW),MASK(LMASK)
      COMMON /HCRAST/    NXRAST,NYRAST,XRAST,DXRAST,YRAST,DYRAST,
     &                   IFRAST,JRAST,IRAST,JMASK,MASK

+KEEP, HCSCRN.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* hcscrn.inc
      PARAMETER         (NSLIC=1000, NTMAX=100)
      COMMON /HCSCRN/   TN(4,3),TB(4,3),
     &                  NT,X0,DX,U(2,NSLIC),D(2,NSLIC),T(2,NTMAX)

+KEEP, HCTNOR.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* hctnor.inc
      COMMON /HCTNOR/   TNORM(4,3),TBACK(4,3)

+KEEP, HCZBUF.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hczbuf.inc
      INTEGER*2         IBUFF(1)
      COMMON /HCZBUF/   KXSCR,KYSCR,JSCRN,JZBUF,IBUFF

+KEEP, HCZCLI.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hczcli.inc
      COMMON /HCZCLI/   KX1CLI,KX2CLI,KY1CLI,KY2CLI

+KEEP, HCZPOR.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hczpor.inc
      COMMON /HCZPOR/   IXP1,IXP2,IYP1,IYP2,IZP1,IZP2

+KEEP, HCZWIN.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hczwin.inc
      COMMON /HCZWIN/   XW1,XW2,YW1,YW2,ZW1,ZW2

+KEEP, HI3D.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hi3d.inc
      COMMON /HI3D/ AWNX,BWNX,CWNX,DWNX,
     +              AWNY,BWNY,CWNY,DWNY,
     +              AWNZ,BWNZ,CWNZ,DWNZ

+KEEP, HIAADR.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* Attributes adresses in the current picture
* hiaadr.inc
      COMMON /HIAADR/ IATADR(60)


+KEEP, HIACA.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* hiaca.inc
      COMMON/HIACA/ IACHOP,IADRAT


+KEEP, HIATNB.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* Number of INTEGER and REAL attributes
* hiatnb.inc
      PARAMETER (NBRATT=12,NBIATT=13)


+KEEP, HIATNM.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* Attributes names
* hiatnm.inc
      CHARACTER*4 CHRATT(NBRATT),CHIATT(NBIATT)
      DATA CHRATT /'MSCF','LWID','BASL','TANG','CHHE','CSHI'
     +,            'BARO','BARW','AWLN','TMSI','LASI','LAOF'/
      DATA CHIATT /'PLCI','LTYP','PMCI','MTYP','FACI','FAIS'
     +,            'FASI','TXCI','TXAL','TXFP','PASS','BORD'
     +,            'NLIN'/


+KEEP, HIATT.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* Attributes list
* hiatt.inc
      INTEGER INTR,IWTYPE,IDID,IDTY,ILOPWK(10),IWTYL(10),INOPWK
     +,       IWINID(10),IPICT,ICLIP,NT0PRI,IPLCI,ILN,IPMCI,IMK,IFACI
     +,       IFAIS,IFASI,ITXCI,ITXALG,IFTPR,INPASS,IBORD,INLINE
     +,       INTATT(17),IFONT,IPREC,ITXALH,ITXALV,IDIM,INBCOL,IZBUF
      REAL XRATIO,YRATIO,RWXMIN,RWXMAX,RWYMIN,RWYMAX,RVXMIN,RVXMAX
     +,    RVYMIN,RVYMAX,RDWXMI,RDWXMA,RDWYMI,RDWYMA,RDVXMI,RDVXMA
     +,    RDVYMI,RDVYMA,RMDSX,RMDSY,XWKSIZ(10),YWKSIZ(10),WKMAX(10)
     +,    XWKR(10),YWKR(10),XWKW1(10),YWKW1(10),XWKV1(10),YWKV1(10)
     +,    XWKW2(10),YWKW2(10),XWKV2(10),YWKV2(10),REDIT,RMKSC,RLWSC
     +,    RBSL,RANGLE,RCHH,RCSHIF,RBOF,RBWD,RAWL,RTMS,RALH,RALD
     +,    REAATT(18),RCHUX,RCHUY
       LOGICAL ACWKFL(10),NODRFL(10)
      COMMON /HIATT/ INTR,XRATIO,YRATIO
     +,RWXMIN,RWXMAX,RWYMIN,RWYMAX,RVXMIN,RVXMAX,RVYMIN,RVYMAX
     +,RDWXMI,RDWXMA,RDWYMI,RDWYMA,RDVXMI,RDVXMA,RDVYMI,RDVYMA
     +,RMDSX ,RMDSY ,IWTYPE,IDID  ,IDTY
     +,ILOPWK,ACWKFL,NODRFL,IWTYL ,INOPWK
     +,XWKSIZ,YWKSIZ,WKMAX ,IWINID,XWKR  ,YWKR
     +,XWKW1 ,YWKW1 ,XWKV1 ,YWKV1
     +,XWKW2 ,YWKW2 ,XWKV2 ,YWKV2
     +,IPICT ,ICLIP ,REDIT,NT0PRI
     +,RMKSC ,RLWSC ,RBSL  ,RANGLE,RCHH  ,RCSHIF,RBOF  ,RBWD
     +,RAWL  ,RTMS  ,RALH  ,RALD  ,REAATT
     +,IPLCI ,ILN   ,IPMCI ,IMK   ,IFACI ,IFAIS ,IFASI ,ITXCI
     +,ITXALG,IFTPR ,INPASS,IBORD ,INLINE,INTATT
     +,IFONT ,IPREC ,ITXALH,ITXALV,RCHUX ,RCHUY
     +,IDIM  ,INBCOL,IZBUF

+KEEP, HIBIT, IF=VAX.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* hibit.inc
+CDE, HIBITVAX.
*

+KEEP, HICODE.
* Revision 1.2  1996/11/20 15:15:32  couet
* *** empty log message ***
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* Attributes codes
* hicode.inc
      PARAMETER (INOPCO=1 ,IUNDCO=2 ,IPICO1=3 ,IPICO2=4 ,IMIDCO=5
     +,IHISCO=6 ,IPM1CO=7 ,IPL2CO=8 ,IPLCO =9 ,IPMCO =10,IFACO =11
     +,ITXCO =12,IBXCO =13,IFBXCO=14,IARCCO=15,IAXICO=16,IGTXCO=17
     +,IMLCO =18,ILBLCO=19,ITABCO=20,IGRACO=21,IPAVCO=22
     +,ICRCO =48,ICLICO=49
     +,IMKSCO=50,ILWSCO=51,IBSLCO=52,IANGCO=53,ICHHCO=54,IGTSCO=55
     +,IBOFCO=56,IBWDCO=57,IAWLCO=58,ITMSCO=59,IALHCO=60,IALDCO=61
     +,IPLCCO=80,ILNCO =81,IPMCCO=82,IMKCO =83,IFACCO=84,IFAICO=85
     +,IFASCO=86,ITXCCO=87,ITXACO=88,ITXFCO=89,IGTWCO=90,IBORCO=91
     +,INLICO=92)
+KEEP, HICONT.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hicont.inc
      COMMON /HICONT/ DZ,ZMIN,ZMAX


+KEEP, HICONV.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hiconv.inc
      COMMON /HICONV/ X1MIN,X1MAX,Y1MIN,Y1MAX,X2MIN,X2MAX,Y2MIN,Y2MAX


+KEEP, HICUR.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* hicur.inc
      COMMON /HICUR/ HICDIR
      CHARACTER*32 HICDIR


+KEEP, HIFC1.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hifc1.inc
      COMMON/HIFC1/ISFL

+KEEP, HIFC2.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hifc2.inc
      COMMON/HIFC2/FX,FY,XMIN,XMAX,YMIN,YMAX,IXMIN,IXMAX,IYMIN,IYMAX

+KEEP, HIFC3.
* Revision 1.1.1.1  1996/02/14 13:10:12  mclareni
* Higz
* hifc3.inc
      COMMON/HIFC3/XL,YL,FLAG1

+KEEP, HIFC6.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hifc6.inc
      COMMON/HIFC6/ISCR,IPOUT,JPIN,MFL

+KEEP, HIFLAG.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hiflag.inc
      COMMON /HIFLAG/ GFLAG,GLFLAG,ZFLAG,PFLAG,MFLAG,TFLAG
     +,ASFLAG,GRFLAG,AXFLAG,CFLAG
      LOGICAL GFLAG,GLFLAG,ZFLAG,PFLAG,MFLAG,TFLAG
     +,ASFLAG,GRFLAG,AXFLAG,CFLAG


+KEEP, HIFLAT.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* Attributes control flags
* hiflat.inc
      COMMON /HIFLAT/
     + KMKSC,KLWSC,KBSL ,KTANG,KCHH ,KTXSH
     +,KBOF ,KBWD ,KAWL ,KTMS ,KALH ,KALD
     +,KRFLAG(18)
     +,KPLCI,KLN  ,KPMCI,KMK  ,KFACI,KFAIS
     +,KFASI,KTXCI,KTXAL,KFONT,KTXPA,KBOR
     +,KNLIN
     +,KIFLAG(17)


+KEEP, HIGED.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* higed.inc
      COMMON /HIGED/ XPM(2,3),YPM(2,3),ICUMEN(3),ICUCHO(3),NBU(3)
     +,NBITEM(3),ISOF,ICPLCI,ICLN,ICFACI,ICFAIS,ICFASI,ICBOCI,ICBOIS
     +,ICBOSI,ICBOBO,ICFBCI,ICFBIS,ICFBSI,ICFBBO,ICPMCI,ICMK,RCMKSC
     +,RCSTAN,RCSTSI,ICSTPA,RCSTSH,ICSTCI,RCTXAN,RCTXSI,ICTXFT,ICTXPR
     +,ICTXCI,ICTXAH,ICTXAV,RCBOF,RCBWD,ICHILN,ICHIPC,ICHIFC,ICHIFI
     +,ICHIFS,RCARSI,ICARLC,ICARFC,ICARFI,ICARFS,ICARLN,RCAXTS,RCAXLS
     +,RCAXLO,RCAXW1,RCAXW2,ICAXND,ICAXLN,ICAXLC,ICAXLF,ICAXLP,ICACFI
     +,ICACFS,ICACBO,ICACLC,ICACFC,RCLWSC,X(100),Y(100)
     +,IXSTEP,IYSTEP,IXFACT,IYFACT,ICPBST,ICPFST,RCDZPV
      CHARACTER*32 TITLE(3)
      CHARACTER*20 CHUSKE(20,3)
      CHARACTER*32 CHITEM(20,3)
      CHARACTER*80 CHDEF(20)
      CHARACTER*32 CHOPST,CHOPAX,CHOPHI,CHOPPV
      CHARACTER*80 CCST,CCTX
      CHARACTER*80 CHFAC,CHPLC,CHTXC,CHPMC,CHFAIS,CHHIFC,CHHIPC,CHARFC
     +            ,CHARLC,CHARFI,CHBOC,CHBOIS,CHFBC,CHFBIS,CHSTC,CHHIIS
     +            ,CHAXLC,CHACIS,CHACLC,CHACFC
      CHARACTER*8 CHDOAR,CHBOBO,CHFBBO,CHAFL,CHACBO
      CHARACTER*80 EDIPIC
      COMMON /HIGEDC/ TITLE,CHUSKE,CHITEM,CHDEF,CHOPST,CHOPAX,CHOPHI
     +,CCST,CCTX,CHFAC,CHPLC,CHTXC,CHPMC,CHFAIS,CHHIFC,CHHIPC,CHARFC
     +,CHARLC,CHARFI,CHBOC,CHBOIS,CHFBC,CHFBIS,CHSTC,CHHIIS,CHAXLC
     +,CHACIS,CHACLC,CHACFC,CHDOAR,CHBOBO,CHFBBO,CHAFL,CHACBO,EDIPIC
     +,CHOPPV


+KEEP, HIGRAF.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* higraf.inc
      PARAMETER (NPMAX=500)
      COMMON /HIGRAF/ NGRAF,XGRAF(NPMAX),YGRAF(NPMAX)
      COMMON /HIGRA3/ ZGRAF(NPMAX)

+KEEP, HIHID.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* hihid.inc
      PARAMETER (MAXSTK=10)
      COMMON /HIHID/ REFWRD(MAXSTK),ZMINST,ZMAXST
     +,IXFCHA(MAXSTK),IYFCHA(MAXSTK),IXNCHA(MAXSTK),IYNCHA(MAXSTK)
     +,ISTCOL(MAXSTK),ISTCO2(MAXSTK),ISTCOT,ISTCOB,IADRES(MAXSTK)
     +,NIDS,XSTP,YSTP,XLAB1,YLAB1,XLAB2,YLAB2,IDRGR,RLEGBO,RLEGBW
     +,I4AXI,ISYS,ILOGX,ILOGY,XVAL1,XVAL2,YVAL1,YVAL2,RINRAD,DANG

+KEEP, HIHIST.
* Revision 1.2  2001/10/17 14:36:53  couet
* - The WORK buffers were too small and the follwoing macro didn't not
*   work for more that 101 points:
*   vec/del *
*   n = [1]
*   vec/cr time([n])
*   vec/cr etime([n]) r [n]*0.0
*   vec/cr y([n]) r
*   vec/cr ey([n]) r [n]*0.7
*   do i = 1, [n]
*     vec/input time([i]) [i]
*     vec/input y([i]) $eval(3.0+0.01*[i])
*   enddo
*   null -10 160 0 10
*   hplot/errors time y etime ey [n] 20 0.1 3
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hihist.inc
      COMMON /HIHIST/ XWORK(1004),YWORK(1004),XWORKL(1004),YWORKL(1004)
+KEEP, HIKERN, IF=KERNEL, IF=-MSDOS, IF=GL, IF=SGI.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
+CDE, GLSGI.
      PARAMETER (IBUFSI=1000)
      COMMON /HIKERN/ WKSC(10),WINSIZ(4),IPOS(2,IBUFSI),IXX,IYY,ICURWK
     +,LOINS,ICURCI(10),IOFCOL,IXLOCO,IYLOCO,LUNWIN
      LOGICAL LOINS
      INTEGER WINSIZ,WINID
      INTEGER*2 IVAL
      COMMON /HIKERC/ FILEN
      CHARACTER*80 FILEN

*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
*
*   COMMON BLOCK for the Windows NT interface
*
*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface

+KEEP, HIKERN, IF=KERNEL, IF=-MSDOS, IF=GL, IF=IBMRT.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
+CDE, GLIBM.
      PARAMETER (IBUFSI=1000)
      COMMON /HIKERN/ WKSC(10),WINSIZ(4),IPOS(2,IBUFSI),IXX,IYY,ICURWK
     +,LOINS,ICURCI(10),IOFCOL,IXLOCO,IYLOCO,LUNWIN
      LOGICAL LOINS
      INTEGER WINSIZ,WINID
      INTEGER*2 IVAL
      COMMON /HIKERC/ FILEN
      CHARACTER*80 FILEN

*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
*
*   COMMON BLOCK for the Windows NT interface
*
*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface

+KEEP, HIKERN, IF=KERNEL, IF=-MSDOS, IF=GL.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
      PARAMETER (IBUFSI=1000)
      COMMON /HIKERN/ WKSC(10),WINSIZ(4),IPOS(2,IBUFSI),IXX,IYY,ICURWK
     +,LOINS,ICURCI(10),IOFCOL,IXLOCO,IYLOCO,LUNWIN
      LOGICAL LOINS
      INTEGER WINSIZ,WINID
      INTEGER*2 IVAL
      COMMON /HIKERC/ FILEN
      CHARACTER*80 FILEN

*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
*
*   COMMON BLOCK for the Windows NT interface
*
*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface

+KEEP, HIKERN, IF=KERNEL, IF=-MSDOS, IF=X11, IF=-WINNT.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
      PARAMETER (IBUFSI=1000)
      COMMON /HIKERN/ WKSC(10),ICURWK,WINSIZ(4)
     +,IPOS(2,IBUFSI),LUNWIN,THX11,IFPX11,RMAGN
      INTEGER WINSIZ
      INTEGER*2 IPOS
      COMMON /HIKERC/ CHHOST,FILEN,FX11
      CHARACTER*80 CHHOST,FILEN,FX11

*
*   COMMON BLOCK for the Windows NT interface
*
*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface

+KEEP, HIKERN, IF=KERNEL, IF=-MSDOS, IF=WINNT.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
*
*   COMMON BLOCK for the Windows NT interface
*
      PARAMETER (IBUFSI=1000)
      COMMON /HIKERN/ WKSC(10),ICURWK,WINSIZ(4)
     +,IPOS(2,IBUFSI),LUNWIN,THX11,IFPX11
      INTEGER WINSIZ
      COMMON /HIKERC/ CHHOST,FILEN,FX11
      CHARACTER*80 CHHOST,FILEN,FX11

*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface

+KEEP, HIKERN, IF=KERNEL, IF=-MSDOS, IF=MACMPW.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
*
*   COMMON BLOCK for the Windows NT interface
*
*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
      PARAMETER (IBUFSI=1000)
      COMMON /HIKERN/ WKSC(10),ICURWK,WINSIZ(4)
     +,IPOS(2,IBUFSI),LUNWIN
      INTEGER WINSIZ
      COMMON /HIKERC/ FILEN
      CHARACTER*80 FILEN

* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface

+KEEP, HIKERN, IF=MSDOS, IF=NDP.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
*
*   COMMON BLOCK for the Windows NT interface
*
*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
+CDE, GREX.
      PARAMETER (IBUFSI=1000)
      PARAMETER (ISURF= 18)
      PARAMETER (IRIS = 17)

+CDE, GOLDEN.

       COMMON /HIKERN/ WKSC(10),WINSIZ(4),IPOS(IBUFSI,2),IXX,IYY,ICURWK
     +,LOINS,ICURCI(10),IOFCOL,IXLOCO,IYLOCO,IWKNB,LUNMET(10)
     *, MAX_COLOR(10), IER, DASH_PATTERN(16), video_system(4)
     *, PAL, ISTEP, MAG_X, MAG_Y, MOUSE, IXSAVE(10), IYSAVE(10)
       LOGICAL LOINS, MOUSE
      INTEGER WINSIZ,WINID,video_system
      CHARACTER*4 DASH_PATTERN
      CHARACTER PAL(20)
C---      INTEGER STRWID
* COMMON BLOCK for the NDP_PC interface

+KEEP, HIKERN, IF=MSDOS, IF=-NDP.
* Revision 1.3  1998/01/28 14:34:07  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:09  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   COMMON BLOCK for the GL interface
* hikern.inc
*
*   COMMON BLOCK for the X11 interface
*
* hikern.inc
*
*
*   COMMON BLOCK for the Windows NT interface
*
*
*   COMMON BLOCK for the MacIntosh interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
*
* hikern.inc
*
* COMMON BLOCK for the NDP_PC interface
+CDE, GREX.
      PARAMETER (IBUFSI=1000)
      PARAMETER (ISURF= 18)
      PARAMETER (IRIS = 17)

+CDE, GOLDEN.

       COMMON /HIKERN/ WKSC(10),WINSIZ(4),IPOS(2,IBUFSI),IXX,IYY,ICURWK
     +,LOINS,ICURCI(10),IOFCOL,IXLOCO,IYLOCO,IWKNB,LUNMET(10)
     *, MAX_COLOR(10), IER, DASH_PATTERN(16), video_system(4)
     *, PAL, ISTEP, MAG_X, MAG_Y, MOUSE, IXSAVE(10), IYSAVE(10)
       LOGICAL LOINS, MOUSE
      INTEGER WINSIZ,WINID,video_system
      CHARACTER*4 DASH_PATTERN
      CHARACTER PAL(20)
C---      INTEGER STRWID

+KEEP, HILABS.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* hilabs.inc
      PARAMETER (MAXLAB=100)
      CHARACTER*32 HILABS
      COMMON/HILBL1/NHILAB
      COMMON/HILBL2/HILABS(MAXLAB)


+KEEP, HILINK.
* hilink.inc
      COMMON /HILINK/ LHIGZ,LCG,LWV
     +,               LPICT,LHNT0,LHI,LHF,LHC,LHNT,LHNTLA
     +,               LPICD,LDNT0,LDI,LDF,LDC,LDNT,LDNTLA
     +,               LPIC2,L2NT0,L2I,L2F,L2C,L2NT,L2NTLA
     +,               LNDECO,LIDECO,LFDECO,LCDECO
     +,               LPSAV,LPCOP,LNTCOP,LSTACK(10),LAST
+KEEP, HILOC.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hiloc.inc
      COMMON /HILOC/ OLDXP,OLDYP


+KEEP, HILUN.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hilun.inc
      COMMON /HILUN/ LUNIN,LUNOUT,LUNERR


+KEEP, HILUT.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hilut.inc
      PARAMETER (NBCLUT=256)
      COMMON /HILUT/ REDLUT(NBCLUT),GRNLUT(NBCLUT),BLULUT(NBCLUT)


+KEEP, HIMAIL.
* Revision 1.2  1996/04/16 08:11:17  couet
* delete blank lines
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* himail.inc
      COMMON /HIMAIC/ CHMAIL,CHOPTM,CHCTRL,CHEOR,ALIGN2
      CHARACTER*2 CHCTRL
      CHARACTER*1 CHEOR,ALIGN2
      CHARACTER*80 CHMAIL,CHOPTM
+KEEP, HIMDOS.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* himdos.inc
      COMMON /HIMDOS/ IPICNM,SCMETA

+KEEP, HIMENU.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* himenu.inc
      COMMON /HIMENU/ Y3,Y4,YT,XSIZ,YSIZ,RINT,REDLOC,NBCHOI,ICUCH,DEC
     +,OTH,TH,XPOS(2),YPOS(2),IRSU,ILSU,XM,XML,XMR,YSTEP,XP,YP
     +,XOPT,IPARA,ISOFT,NBUSER,UTH,USIZ,ISEGM(100),MENNUM


+KEEP, HIMET2.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* himet2.inc
      COMMON /HIMET2/ ITGKS,METDEF,IFUSER


+KEEP, HIMETA, IF=MSDOS.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* himeta.inc
      COMMON /HIMETA/ IDMETA,XMFACT,YMFACT,TEKACT,METACT,FILOPN
      LOGICAL TEKACT,METACT,FILOPN
      COMMON /HIMETC/ CHMETA
      CHARACTER*24 CHMETA
+CDE, HIMDOS.


+KEEP, HIMETA.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* himeta.inc
      COMMON /HIMETA/ IDMETA,XMFACT,YMFACT,TEKACT,METACT,FILOPN
      LOGICAL TEKACT,METACT,FILOPN
      COMMON /HIMETC/ CHMETA
      CHARACTER*24 CHMETA


+KEEP, HINT.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hint.inc
      PARAMETER (INWDNT=2)
      PARAMETER (NBNTMX=100)
      COMMON /HINT/ NTSTOR(INWDNT*NBNTMX+1),WNVPST(8*NBNTMX)


+KEEP, HIPACK.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hipack.inc
      COMMON /HIPACK/ NCX,NCY,IPACK,ILOG,ZLOW,ZHIGH,IDIM1,IOPTER


+KEEP, HIPAW.
* Revision 1.2  2001/12/07 14:57:44  couet
* - HILINK common block move to the hilink.inc include file.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hipaw.inc
      COMMON /PAWC/ NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKU,IFENCE(5)
     +,             LMAIN, IPAW(9989)
      DIMENSION IQ(2),Q(2),LQ(8000)
      EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN)
      COMMON /QUEST/ IQUEST(100)
      DIMENSION RQUEST(100)
      EQUIVALENCE (IQUEST(1),RQUEST(1))
+CDE, HILINK.
      COMMON /HIPTR/  ITBPTR,INTPTR,IFLPTR,ISTPTR
     +,               IIAPTR,IRAPTR
      COMMON /HISIZE/ INSIZ,IISIZ,IFSIZ,ISSIZ
     +,               IRNSIZ,IRISIZ,IRFSIZ,IRSSIZ
      COMMON /HINUM/  NBPICT,INBNT,INBLEV
+KEEP, HIPHIG, IF=PHIGS.
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz
*   COMMON BLOCK for the PHIGS interface
* hiphig.inc
      COMMON /HIPHIG/ LOSTOP,LOSTEX,ICSTN
      LOGICAL LOSTOP,LOSTEX

+KEEP, HIPICK.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz
* hipick.inc
      PARAMETER (LEVLEN=16)
      COMMON /HIPICK/ CHLVL,CHLVL2
      CHARACTER*(LEVLEN) CHLVL,CHLVL2


+KEEP, HIPOST.
* Revision 1.2  1999/07/21 15:48:10  couet
* - Improvements in PS Patterns drawing
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hipost.inc
      COMMON /HIPOST/ X1V,X2V,Y1V,Y2V,X1W,X2W,Y1W,Y2W,FX,FY
     +,LUNPS,LENBUF,IPSCI,PSRED,PSGRN,PSBLU,IPSMSC
     +,IPSLT,IPSLW,IPSWID,IPSI,IPSWTY,IPTWTY,LENBMX,IPATD
     +,XVP1,XVP2,YVP1,YVP2,XVS1,XVS2,YVS1,YVS2,XPSR,YPSR
     +,NX,NY,IXZ,IYZ,MODE,NPAGES,IPCLIP,IPDXC,IPDYC,IPXC,IPYC
     +,LOPRT,LOBB,LOCLR,LOPRNG,LOSCLI,LOZONE,NBSAVE,NBSAV0
      LOGICAL LOPRT,LOBB,LOCLR,LOPRNG,LOSCLI,LOZONE
      COMMON /HIPOSC/ STRBUF,BSLASH,ALIGN1
      CHARACTER*132 STRBUF
      CHARACTER*1 BSLASH
      CHARACTER*3 ALIGN1
+KEEP, HIQUES.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hiques.inc
      COMMON /QUEST/ IQUEST(100)
      DIMENSION RQUEST(100)
      EQUIVALENCE (IQUEST(1),RQUEST(1))


+KEEP, HISAVA.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* hisava.inc
      COMMON /HISAVA/ ISAVA(NBIATT),RSAVA(NBRATT)


+KEEP, HISAVE.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* hisave.inc
      COMMON /HISAVE/ ISAVE(NBIATT),RSAVE(NBRATT),ISVNT,WNVPSV(8)


+KEEP, HISVED.
* Revision 1.1.1.1  1996/02/14 13:10:14  mclareni
* Higz
* hisved.inc
      COMMON /HISVED/ ISAVED(NBIATT),RSAVED(NBRATT)


+KEEP, HIVERS, IF=MSDOS.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hivers.inc
      COMMON /HIVERS/ CHVERS
      CHARACTER*8 CHVERS
*
* hivers.inc
*
      character*52 CHVERS
      DATA
     * CHVERS /' 1.14/13D (FineSoft,JINR, fine@main2.jinr.dubna.su)'/

+KEEP, HIVERS.
* Revision 1.1.1.1  1996/02/14 13:10:13  mclareni
* Higz
* hivers.inc
      COMMON /HIVERS/ CHVERS
      CHARACTER*8 CHVERS
*
* hivers.inc
*

+KEEP, HIWCDC, IF=KERNEL, IF=-MSDOS, IF=GL.
* Revision 1.3  1998/01/28 14:34:09  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:10  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   Convert WC to DC for the GL interface
* hiwcdc.inc
      IXWCDC(U)=INT(WKSC(IWKNB)*(RVXMIN+XRATIO*(U-RWXMIN)))
      IYWCDC(V)=INT(WKSC(IWKNB)*(RVYMIN+YRATIO*(V-RWYMIN)))

*
*   Convert WC to DC for X11
*
* hiwcdc.inc
*
*
*   Convert WC to DC for X11
*
*
*   Convert WC to DC for MacIntosh
*
* hiwcdc.inc
*
*
*   Convert WC to DC for the PC AT 386/486 interface
*
* hiwcdc.inc
*

+KEEP, HIWCDC, IF=KERNEL, IF=-MSDOS, IF=X11, IF=VAX.
* Revision 1.3  1998/01/28 14:34:09  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:10  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   Convert WC to DC for the GL interface
* hiwcdc.inc
*
*   Convert WC to DC for X11
*
* hiwcdc.inc
*
      IXWCDC(U)=MAX(MIN(XWKV1(IWKNB)+
     +XWKR(IWKNB)*(XRATIO*(U-RWXMIN)+RVXMIN-XWKW1(IWKNB))
     +,32767.),-32766.)
      IYWCDC(V)=MAX(MIN(YWKSIZ(IWKNB)-(YWKV1(IWKNB)+
     +YWKR(IWKNB)*(YRATIO*(V-RWYMIN)+RVYMIN-YWKW1(IWKNB)))
     +,32767.),-32766.)

*
*   Convert WC to DC for X11
*
*
*   Convert WC to DC for MacIntosh
*
* hiwcdc.inc
*
*
*   Convert WC to DC for the PC AT 386/486 interface
*
* hiwcdc.inc
*

+KEEP, HIWCDC, IF=KERNEL, IF=-MSDOS, IF=X11, IF=-VAX.
* Revision 1.3  1998/01/28 14:34:09  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:10  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   Convert WC to DC for the GL interface
* hiwcdc.inc
*
*   Convert WC to DC for X11
*
* hiwcdc.inc
*
*
*   Convert WC to DC for X11
*
      IXWCDC(U)=XWKV1(IWKNB)+
     +XWKR(IWKNB)*(XRATIO*(U-RWXMIN)+RVXMIN-XWKW1(IWKNB))
      IYWCDC(V)=YWKSIZ(IWKNB)-(YWKV1(IWKNB)+
     +YWKR(IWKNB)*(YRATIO*(V-RWYMIN)+RVYMIN-YWKW1(IWKNB)))

*
*   Convert WC to DC for MacIntosh
*
* hiwcdc.inc
*
*
*   Convert WC to DC for the PC AT 386/486 interface
*
* hiwcdc.inc
*

+KEEP, HIWCDC, IF=KERNEL, IF=-MSDOS, IF=MACMPW.
* Revision 1.3  1998/01/28 14:34:09  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:10  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   Convert WC to DC for the GL interface
* hiwcdc.inc
*
*   Convert WC to DC for X11
*
* hiwcdc.inc
*
*
*   Convert WC to DC for X11
*
*
*   Convert WC to DC for MacIntosh
*
* hiwcdc.inc
*
      IXWCDC(U)=WKSC(IWKNB)*(RVXMIN+XRATIO*(U-RWXMIN))
      IYWCDC(V)=YWKSIZ(IWKNB)-WKSC(IWKNB)*(RVYMIN+YRATIO*(V-RWYMIN))
*
*   Convert WC to DC for the PC AT 386/486 interface
*
* hiwcdc.inc
*

+KEEP, HIWCDC, IF=MSDOS.
* Revision 1.3  1998/01/28 14:34:09  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:10  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
*   Convert WC to DC for the GL interface
* hiwcdc.inc
*
*   Convert WC to DC for X11
*
* hiwcdc.inc
*
*
*   Convert WC to DC for X11
*
*
*   Convert WC to DC for MacIntosh
*
* hiwcdc.inc
*
*
*   Convert WC to DC for the PC AT 386/486 interface
*
* hiwcdc.inc
*
      IXWCDC(U)=NINT(WKSC(IWKNB)*(RVXMIN+XRATIO*(U-RWXMIN)))
      IYWCDC(V)=NINT(YWKSIZ(IWKNB)
     *               -WKSC(IWKNB)*(RVYMIN+YRATIO*(V-RWYMIN)))

+KEEP, HIWCPS.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* hiwcps.inc
      IXWCPS(U)=NINT(4.*WKMAX(IPSI)*(FX*(U-X1W)+X1V))
      IYWCPS(V)=NINT(4.*WKMAX(IPSI)*(FY*(V-Y1W)+Y1V))

+KEEP, ICMTOP.
* Revision 1.1.1.1  1996/02/14 13:10:15  mclareni
* Higz
* icmtop.inc
      ICMTOP(U)=NINT(72.*U/2.54)

+KEEP, IHDES.
* Revision 1.1.1.1  1996/02/14 13:10:16  mclareni
* Higz

+KEEP, KERDES.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz

+KEEP, MSDES.
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz

+KEEP, PHIGSDES.
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz

+KEEP, PINUM, IF=MSDOS.
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz
* pinum.inc
      PARAMETER (PI=3.1415926, PI2 = 2*PI)

+KEEP, PNVMAX.
* Revision 1.1.1.1  1996/02/14 13:10:17  mclareni
* Higz
* pnvmax.inc
      PARAMETER         (NVMAX=20)

+PATCH, IWIN32.
+KEEP, IX_HIGZ.
#define IX11_HIGZ_MSG WM_USER+10 /* ID of HIGZ messages           */
                                 /*   +10 because WM_USER is used */
                                 /*       by WIN32 itself ! ! !   */
 enum HIGZ_Graphics_Msg {
                        HIGZ_Control, HIGZ_Primitive, HIGZ_Text   , HIGZ_Attribute,
                        HIGZ_Marker , HIGZ_Input    , HIGZ_Inquiry, HIGZ_Pixmap,
                        HIGZ_Dummies
                       };
/*     Emulation of X11 control HIGZ routines
**
**               HIGZ_Control set
*/

enum    L_HIGZ_Control
     {
        IX_OPNDS,      // Open X11 display
        IX_OPNWI,      // Open X11 window
        IX_SELWI,      // Select the current X11 window
        IX_CLSWI,      // Close an X11 window
        IX_CLSDS,      // Close an X11 session
        IX_SETHN,      // Set X11 host name
        IX_CLRWI,      // Clear an X11 window
        IX_UPDWI,      // Update an X11 window
        IX_RSCWI,      // Resize an X11 window
        IX_CLIP ,      // Define the X11 clipping rectangle
        IX_NOCLI       // Deactivate the X11 clipping rectangle
     };
#define ExtHIGZWindow 0
struct HIGZWindow {
       struct HIGZWindow  *ptbw;   // Previous Winodws in this list
       struct HIGZWindow  *ptfw;   // Next Windows in this list
       HWND hwnd;           // Handle of this Windows
       HDC  hdcWindow;      // Device context of display
       RECT HIGZWindowSize; /* size of the client area of the          */
                            /* window in logical untis                 */
       int  WinType;        // Type of HIGZ window
                            /* window variables for HIGZ text input fasility*/
       DWORD   dwCharX, dwCharY, dwAscent;

       HDC  hdcPixBuffer;   // Device context of the bitmap buffer
       HBITMAP hbBuffer;    // Bitmap handle for double buffering
       HDC  hdcHistory;     // History metafile DC
       HRGN HIGZClipRegion;  /* != NULL clip is ON and                  */
                             /* clip = (handle) RECT of the clip region */
       BOOL HIGZCursor,
            SystemCursorVisible,
            SetTextInput;
       int  MouseInit;       // Type of HIGZ mouse cursor or 0
       POINT loc, locp;      // Positions of HIGZ graphics locator
       int   button_press, button_up;
       BOOL  isopening;      /* HIGZ window is restoring its own position
                              * from icon state
                              */
       HCURSOR hHIGZCursor;
       } HIGZWindow;


HWND CreateTextClass(struct CREATEHIGZWINDOW *);
struct CREATEHIGZWINDOW { int x,y,w,h,lentit,flag; char *title;HANDLE semaphore;
                          HWND hwnd;};
#define HIGZCLASS "HIGZ"
#define WHITE_HIGZ_COLOR HIGZColorIndex(0)

/*   ID of the current thread manageing main windows loop. */
struct {DWORD ID_Thread;} IDStruct_;
#define IDThread (IDStruct_.ID_Thread)
char*  string(char *, int);
LRESULT APIENTRY HIGZ_Act(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_S2BUF(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_CPPX(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_WIPX(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_MARKE(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_FLARE(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_BOX  (HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_CA   (HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_REQLO(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY Wnd_REQST(HWND, UINT, WPARAM, LPARAM);
LPTHREAD_START_ROUTINE HIGZ_MsgLoop(HANDLE);
+KEEP, IX_WIN32.
+CDE, IX_HIGZ.

+KEEP, IW_TEXT.
#define TEXTCLASS "HIGZTEXT"

#define IDM_EDCOPY   1
#define ID_EDITCHILD 1
#define TEXT_BUFFER 2048

LRESULT APIENTRY WndText(HWND, UINT, WPARAM, LPARAM);

typedef struct tagTextWindow {
       struct TextWindow  *ptbw;   // Previous Winodws in this list
       struct TextWindow  *ptfw;   // Next Windows in this list
       HWND hwnd;                  // Handle of this Windows
       HDC  hdcWindow;             // Device context of display
       RECT HIGZWindowSize;        // size of the client area of the 
                                   // window in logical untis
       int  WinType;               // Type of HIGZ window
                                   // window variables for HIGZ text input facility
       DWORD   dwCharX, dwCharY, dwAscent;
       } TextWindow;
+DECK,  IW_TEXT, T=CC.
#define CERNLIB_QFMSOFT
#define CERNLIB_QXCAPT
#define type_of_call _stdcall

#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

+CDE, IX_WIN32.
+CDE, IW_TEXT.

+SELF, IF=QX_NC.
#define igxmes  igxmes_
#define ixopnwi ixopnwi_
+SELF.

+SELF, IF=QXCAPT.
#define igxmes  type_of_call IGXMES
#define ixopnwi type_of_call IXOPNWI
+SELF.

static BOOL open = {FALSE};

int lenocc(char *c,int l)
 {
   int i;
   for (i=l-1;i>=0 && c[i] == " ";i--);
   return i+1;
  }


/*_______________________________________________________________*/
/*  This is a pool of routines to present text in Windows/NT */

+SELF, IF=-QFMSOFT.
void igxmes(ix, iy, nc, n, chmess, chtit, chopt, chmess_len,
	chtit_len, chopt_len)
+SELF, IF=QFMSOFT.
void igxmes(ix, iy, nc, n, chmess, chmess_len,
                      chtit,  chtit_len,
		      chopt,  chopt_len)
+SELF.

int *ix, *iy, *nc, *n;
char *chmess, *chtit, *chopt;
int chmess_len;
int chtit_len;
int chopt_len;
{
 char *title;
 static HWND hwnd, hwndEdit;
 struct CREATEHIGZWINDOW WinThr;
 static RECT FmtRect;
 char *temp;
 int i,j,k, sw;

 sw=0; for(i=0;i<chopt_len;i++) if (*(chopt+i) == 'P') sw = i+1;

 if (sw) {
   if (!open) {

     WinThr.x = *ix;
     WinThr.y = *iy;
     WinThr.w = 180;

     WinThr.h = 160;

     FmtRect.left = 10;
     FmtRect.right = WinThr.w - FmtRect.left - 10;
     FmtRect.top   = 0;
     FmtRect.bottom = WinThr.h;

     WinThr.lentit = lenocc(chtit,chtit_len)+1;
     title = malloc( WinThr.lentit );
     memcpy(title,chtit,WinThr.lentit-1);
     title[WinThr.lentit-1] = (char)NULL;
     WinThr.title = title;
     WinThr.flag = 2;


      /* Create HIGZ  message window */

     WinThr.semaphore = CreateSemaphore(NULL, 0, 1, NULL);

     while(!PostThreadMessage(IDThread,
           IX11_HIGZ_MSG,MAKEWPARAM(IX_OPNWI,HIGZ_Control), &WinThr));

     WaitForSingleObject(WinThr.semaphore, INFINITE);
     CloseHandle(WinThr.semaphore);
     free(title);

     hwnd     = WinThr.hwnd;
     hwndEdit = (HWND)GetWindowLong(hwnd,0);

     ShowWindow(WinThr.hwnd,SW_SHOWDEFAULT);
     UpdateWindow(WinThr.hwnd);
   }
/* Allocate intermediate  buffer for whole page */
   j = (chmess_len+2)*(*n);    /* Two bytes should be reserved to intend "hard end of line" */
   title = malloc(j+1);
/* Copy a user message to itermediate buffer    */
   j = 0; k=0;
   for (i=0;i<*n;i++) {
     memcpy(&title[j],&chmess[k],chmess_len); /* Copy one string */
     j += lenocc(&chmess[k],chmess_len);      /* Truncate it     */
     title[j] = (char)13;                     /* insert "hard end-of-line" */
     j++;
     title[j] = (char)10;
     j++;
     title[j] = (char)0;
     k += chmess_len;
    }


    if (!open) {
          SendMessage(hwndEdit, EM_SETRECT, 0, &FmtRect);
          open = TRUE;
    }
    i = SendMessage(hwndEdit, EM_GETFIRSTVISIBLELINE, 0, 0);
    SendMessage(hwndEdit,WM_SETTEXT,0,(LPARAM) title);
    if (i)  SendMessage(hwndEdit,EM_LINESCROLL,0, (LPARAM) i);
    free(title);
  }
  sw=0; for(i=0;i<chopt_len;i++) if (chopt[i] == 'C') sw = 1;
  if (sw) {
  if (open) {
     SendMessage(hwnd,WM_CLOSE, 0, 0);
     open = FALSE;
  }
 }
 sw=0; for(i=0;i<chopt_len;i++) if (chopt[i] == 'D') sw = 1;
 if (sw)  SendMessage(hwndEdit,WM_SETTEXT,0, 0);
 }

/*_______________________________________________________________*/
HWND CreateTextClass(WinThr)
  struct CREATEHIGZWINDOW *WinThr;
  {
   HWND  hwndHIGZ;
   HMENU hmenu;
   WNDCLASS  text_display;

/* Make sure that this window hasn't been registered yet */

  if (!GetClassInfo(GetModuleHandle(NULL),TEXTCLASS,&text_display)) {

  /* Set the common wndClass information. This is common for all windows
  ** of this application.
  */

   text_display.style      = CS_HREDRAW | CS_VREDRAW;
   text_display.cbClsExtra = 0;

   text_display.cbWndExtra = 4;

   text_display.hCursor    = LoadCursor(NULL, IDC_IBEAM);
   text_display.hInstance  = GetModuleHandle (NULL);

  /*
  ** Reister the main top-level window
  */

   text_display.lpfnWndProc   = (WNDPROC) WndText;
   text_display.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
   text_display.hbrBackground = GetStockObject(WHITE_BRUSH);
   text_display.lpszMenuName   = NULL;
   text_display.lpszClassName  = TEXTCLASS;

   if (!RegisterClass(&text_display)) return -1;
  }
/* Create "frame" window */
   hmenu = CreateMenu();
   AppendMenu(hmenu,MF_STRING,IDM_EDCOPY,"&Copy");
   hwndHIGZ = CreateWindowEx(
              WS_EX_TOPMOST,
              TEXTCLASS,                 /*extended window style                       */
              string(WinThr->title,WinThr->lentit),   /*address of window name                      */
//=              WS_OVERLAPPED | WS_VISIBLE |
//=              WS_THICKFRAME,
              WS_OVERLAPPEDWINDOW,
 //            | WS_VSCROLL | WS_HSCROLL,                /* Window style   */
              WinThr->x, WinThr->y,                   // *x, *y,
              WinThr->w, WinThr->h,                   // *w, *h,
              NULL,                     /*handle of parent of owner window            */
              hmenu,                    /*handle of menu, or child-window identifier  */
              text_display.hInstance,   /*handle of application instance              */
              NULL);                    /*address of window-creation data             */
    return  hwndHIGZ;
}

/*_______________________________________________________________*/
LRESULT APIENTRY WndText(hwnd, uMsg, wParam, lParam)
HWND   hwnd;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
{
    static HWND hwndEdit;

    switch (uMsg) {
       case WM_CREATE:
           hwndEdit = CreateWindow(
                            "EDIT",                /* Predefined class */
                             NULL,                 /* no window title  */
                             WS_CHILD | WS_VISIBLE | WS_VSCROLL |
                             ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
                             0,0,0,0,   /* set size in WM_SIZE message */
                             hwnd,              /* parent window */
                             (HMENU) ID_EDITCHILD , /* edit control ID */
                             (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE),
                             NULL);                  /* pointer not need */
           SetWindowLong(hwnd,0,  hwndEdit);
           break;
         case WM_COMMAND:
           switch (wParam) {
            case IDM_EDCOPY:
               SendMessage(hwndEdit, WM_COPY, 0, 0);
               break;
             default:
               return DefWindowProc(hwnd,uMsg,wParam,lParam);
            }
          break;

          case WM_SETFOCUS:
            SetFocus(hwndEdit);
            break;

          case WM_SIZE:

           /*
            * Make the edit control the size of the window's
            * client area
            */

            MoveWindow(hwndEdit,
                       0,0,  /* Starting x- and y-coordinates   */
                       LOWORD(lParam), /* width of client area  */
                       HIWORD(lParam), /* height of client area */
                       TRUE);          /* repaint window        */
            break;

           case WM_DESTROY:
             open = FALSE;
             break;
           default: break;

    }
    return DefWindowProc(hwnd,uMsg,wParam,lParam);
 }

+DECK,  IX_HIGZ, T=CC.
#define CERNLIB_QXCAPT
#define CERNLIB_QFMSOFT
#define type_of_call _stdcall
#include <windows.h>
#include <math.h>
#include "ix_win32.h"

#define ColorOffset 20
#define HIGZColorIndex(ic) ColorIndex(ic)

/* #include <f2c.h>  */  // +SEQ, F2C.
#define IX11_HIGZ_Input IX11_HIGZ_MSG+1
 enum ListDC {
/*   
 *          Windows 95 checks to see if cbWndExtra or cbClsExtra is greater than 40. If
 */
               LastExtraMember};

 static struct HIGZWindow *cHw = NULL,         // Current HIGZ Window
                          *fHw = NULL,         // First HIGZ Window
                          *lHw = NULL,         // Last  HIGZ Window
                          *lpHpixmap = NULL;   // Current pixmap
 static int Number_of_HIGZ_Windows = 0;        // Total numaber of the HIGZ
                                               // Windows


/*___________________________________________________________________*/
/*      X11 output primitives
**
**          HIGZ_Primitive
*/

enum    L_HIGZ_Primitive
     {
        IX_LINE ,      // Draw a line through all points
        IX_MARKE,      // Draw a marker ar each point
        IX_FLARE,      // Fill area described by polygon
        IX_BOX  ,      // Draw a box
        IX_CA          // Draw a cell array
     };

/*      X11 text
**
**          HIGZ_Text
*/

enum    L_HIGZ_Text
     {
        IX_TEXT,       // Draw a text string using the current font
        IX_TXTL,       // Return the width and height of character string in the current font
        IW_SETCH       // Set a height for the charatcter
     };


/*     X11 output attributes
**
**          HIGZ_Attribute
*/

enum    L_HIGZ_Attribute
     {
        IX_SETCO,      // Set color intensities for given colour index
        IX_SETLN,      // Set line width
        IX_SETLS,      // Set line style
        IX_SETLC,      // Set colour index for lines
        IX_DRMDE       // Set drawing mode
     };

/*     X11 marker style
**
**       HIGZ_Marker
*/

enum    L_HIGZ_Marker
     {
        IX_SETMS,      // Set market style
        IX_SETMC,      // Set colour indx for markers
        IX_SETFS,      // Set fill area style
        IX_SETFC,      // Set colour index for fill area

        IX_SETTA,      // Set text alignment
        IX_SETTF,      // Set text font to specified name
        IX_SETTC,      // Set colour index for text
        IX_SYNC ,      // X11 synchronization
     };


/*     X11 input functions
**
**         HIGZ_Input
 */

enum    L_HIGZ_Input
     {
        IX_REQLO,      // Request locator input.
        IX_REQST       // Request a string input
     };


/*      X11 inquiry routines
**
**         HIGZ_Inquiry
 */

enum     L_HIGZ_Inquiry
      {
        IX_GETGE,      // Returns position and size of Window
        IX_GETWI,      // Returns the X11 window identifier
        IX_GETPL,      // Returns the maximal number of planes of the display
        IX_GETCOL      // Returns the X11 colour representation
      };


/*      Pixmap manipulation
**
**         HIGZ_Pixmap
 */

enum    L_HIGZ_Pixmap
     {
        IX_OPNPX,      // Open a new pixmap
        IX_CLPX ,      // Close the current opened pixmap
        IX_CPPX ,      // Copy the pixmap
        IX_CLRPX,      // Clear the pixmap
        IX_RMPX ,      // Remove the pixmap
        IX_WRPX ,      // Write the pixmap
        IX_WIPX        // Copy the area in the current window
     };


/*             Dummies
**
**           HIGZ_Dummies
 */

enum    L_HIGZ_Dummies
     {
        IX_S2BUF,
        IX_SDSWI
     };

#define WndActHeader( arg )  LRESULT APIENTRY \
                   Wnd_(arg) (hwnd, uMsg, wParam, lParam) \
                   HWND  hwnd; UINT   uMsg; WPARAM wParam; LPARAM lParam;

/*-- Author : V.Fine */
/*
 * Fortran interface to Window/NT SDK routines for HIGZ
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>



+SELF, IF=QX_SC.
#define igerr   igerr_
#define wrtlst  wrtlst_
#define clrlst  clrlst_
#define ixbord  ixbord_



#define ixclip  ixclip_
#define ixclrwi ixclrwi_
#define ixclsds ixclsds_
#define ixclswi ixclswi_
#define ixflare ixflare_
#define ixgetge ixgetge_
#define ixgetpl ixgetpl_
#define ixgetht ixgetht_
#define ixline  ixline_
#define ixmarke ixmarke_
#define ixnocli ixnocli_
#define ixopnds ixopnds_
#define ixopnwi ixopnwi_
#define ixreqlo ixreqlo_
#define ixreqst ixreqst_
#define ixselwi ixselwi_
#define ixsetco ixsetco_
#define ixsetfc ixsetfc_
#define ixsetfs ixsetfs_
#define ixsetlc ixsetlc_
#define ixsetln ixsetln_
#define ixsetls ixsetls_
#define ixsetmc ixsetmc_
#define ixsetms ixsetms_
#define ixsetta ixsetta_
#define ixsettc ixsettc_
#define ixsettf ixsettf_
#define ixtext  ixtext_
#define ixupdwi ixupdwi_
#define ixbox   ixbox_
#define ixtxtl  ixtxtl_
#define ixdrmde ixdrmde_
#define ixsync  ixsync_
#define ixsethn ixsethn_
#define ixopnpx ixopnpx_
#define ixclpx  ixclpx_
#define ixcppx  ixcppx_
#define ixrmpx  ixrmpx_
#define ixwipx  ixwipx_
#define ixclrpx ixclrpx_
#define ixs2buf ixs2buf_
#define ixq2buf ixq2buf_
#define ixwrpx  ixwrpx_
#define ixrsiz  ixrsiz_
#define ixsavwi ixsavwi_
#define ixsetwi ixsetwi_
#define ixrscwi ixrscwi_
#define ixminit ixminit_
#define ixca    ixca_
#define ixldgif ixldgif_
#define ixdogif ifdogif_
+SELF.

+SELF, IF=QXCAPT.
#define igerr   IGERR
#define wrtlst  WRLST
#define clrlst  CLRLST
#define ixbord  IXBORD



#define ixclip  type_of_call IXCLIP
#define ixclrwi type_of_call IXCLRWI 
#define ixclsds type_of_call IXCLSDS 
#define ixclswi type_of_call IXCLSWI 
#define ixflare type_of_call IXFLARE 
#define ixgetge type_of_call IXGETGE 
#define ixgetpl type_of_call IXGETPL 
#define ixgetht type_of_call IXGETHT 
#define ixline  type_of_call IXLINE 
#define ixmarke type_of_call IXMARKE 
#define ixnocli type_of_call IXNOCLI 
#define ixopnds type_of_call IXOPNDS 
#define ixopnwi type_of_call IXOPNWI 
#define ixreqlo type_of_call IXREQLO 
#define ixreqst type_of_call IXREQST 
#define ixselwi type_of_call IXSELWI 
#define ixsetco type_of_call IXSETCO 
#define ixsetfc type_of_call IXSETFC 
#define ixsetfs type_of_call IXSETFS 
#define ixsetlc type_of_call IXSETLC 
#define ixsetln type_of_call IXSETLN 
#define ixsetls type_of_call IXSETLS 
#define ixsetmc type_of_call IXSETMC 
#define ixsetms type_of_call IXSETMS 
#define ixsetta type_of_call IXSETTA 
#define ixsettc type_of_call IXSETTC 
#define ixsettf type_of_call IXSETTF 
#define ixtext  type_of_call IXTEXT 
#define ixupdwi type_of_call IXUPDWI 
#define ixbox   type_of_call IXBOX
#define ixtxtl  type_of_call IXTXTL 
#define ixdrmde type_of_call IXDRMDE 
#define ixsync  type_of_call IXSYNC 
#define ixsethn type_of_call IXSETHN 
#define ixopnpx type_of_call IXOPNPX 
#define ixclpx  type_of_call IXCLPX 
#define ixcppx  type_of_call IXCPPX 
#define ixrmpx  type_of_call IXRMPX 
#define ixwipx  type_of_call IXWIPX 
#define ixclrpx type_of_call IXCLRPX 
#define ixs2buf type_of_call IXS2BUF 
#define ixq2buf type_of_call IXQ2BUF 
#define ixwrpx  type_of_call IXWRPX 
#define ixrsiz  type_of_call IXRSIZ 
#define ixsavwi type_of_call IXSAVWI 
#define ixsetwi type_of_call IXSETWI 
#define ixrscwi type_of_call IXRSCWI 
#define ixminit type_of_call IXMINIT 
#define ixca    type_of_call IXCA 
#define ixldgif type_of_call IXLDGIF
#define ixdogif type_of_call IXDOGIF
+SELF.

/* #define ixmotif ixmotif_ */
/* +SELF. */

#define forever while(1)
#define LNULL 0L

#define XPoint POINT             /* Change Xpoint by X11 to POINT by Windows/NT */

#define MAXWN 20                 /* maximum number of windows                 */
static struct {
  int      open;                 /* 1 if the window is open, 0 if not         */
  int      motif;                /* 1 if the window is a motif window         */
  int      double_buffer;        /* 1 if the double buffer is on, 0 if not    */
  int width;                     /* width of the window                       */
  int height;                    /* height of the window                      */
  int clip;                      /* 1 if the clipping is on                   */
  int xclip;                     /* x coordinate of the clipping rectangle    */
  int yclip;                     /* y coordinate of the clipping rectangle    */
  int wclip;                     /* width of the clipping rectangle           */
  int hclip;                     /* height of the clipping rectangle          */

  LOGPEN    pen;       /*********    */
  LOGBRUSH  gcfill;
  LOGFONT   font;
  LOGPALETTE palette;
  BITMAP   pixmap;

} windows[MAXWN],                /* windows : list of the opened windows      */
  *cws, *tws, *sws;              /* cws : pointer to the current window       */

#define MAXCOL 256
  static int maxcol;

  struct HIGZPEN {
                   LOGPEN   pen;
                   LOGBRUSH brush;
                   int      lUserDash;
                   int      *UserDash;
                 } pen = { BS_SOLID,0, 0, 1,    //  lopnStyle, lopnWidth, lopnColor
                           BS_SOLID,   0, 0, //  lbStyle, lbColor, lbHatch
                           0, NULL};         //  n dashes, pointer to an array of dashes
  LOGBRUSH  gcfill;

  LOGFONT   HIGZFont = { 0,   // lfHeight
                         0,   // lfWidth
                         0,   // lfEscapement
                         0,   // lfOrientation (doesn't used by HIGZ)
                       400,   // lfWeigh  (Normal = 400, BOLD =800)
                     FALSE,   // lfItalic
                     FALSE,   // lfUnderline
                     FALSE,   // lfStrikeOut
              ANSI_CHARSET,   // lfCharSet
        OUT_DEFAULT_PRECIS,   // lfOutPrecision
       CLIP_DEFAULT_PRECIS,
           DEFAULT_QUALITY,
               FF_DONTCARE,   // lfPitchAndFamily;
                      };
  PALETTEENTRY HIGZcolors[MAXCOL];
  NPLOGPALETTE lpPalette; // =  {0x300, MAXCOL, HIGZcolors};
  BOOLEAN bord = {FALSE};


/*         Global variable to plot HIGZ graphics cursor */
     static RECT rect;
     static HPEN   CurPen;
     static HBRUSH CurBrush;
     static HRGN CurClipRgn;
/* ==================================================== */

/*   Common HANDLES of the graphics attributes for all HIGZ windows */

static HPALETTE hdCommonPalette = NULL;
static HBRUSH   hdCommonBrush   = NULL;
static HPEN     hdCommonPen     = NULL;
static HFONT    hdCommonFont    = NULL;
static HPEN     hdCursorPen;     // Pen to draw HIGZ locator
static HBRUSH   hdCursorBrush;   // Brush to draw HIGZ locator 3 or 5
static RECT     CommonClipRectangle;
static int      dwCommonTextAlign = TA_LEFT | TA_BASELINE;
static COLORREF dwCommonTextColor;
static BOOL     PixMapON = {FALSE};

     int ixText,iyText;
     static HWND ConWindow; //  Handler of console window

/* ==================================================== */


/* =================== */
static int ispix = 0;            /* if ispix=1 a pixmap has been opened       */

static char hname[132];          /* host name                                 */

static int external_int = 0;

static int do_raise = 0;         /* if do_raise =1 cws is raised in ixupdwi   */


/*  External variables for Windows/NT  */ // V.E. Fine 21.07.93

#ifdef WINEX
 WNDCLASSEX *p_higz_display, higz_display;
#else
 WNDCLASS *p_higz_display, higz_display;
#endif

HWND CurrentHIGZWindow;
HDC CurrentDC, MetaFileDC, HistoryDC;

/*  LOGPALLETE HIGZ_palette[MAXCOL];
    HPALETTE WindowPalette;
 */


/*
 * colors[1]           : foreground also used for b/w screen
 * colors[0]           : background also used for b/w screen
 * colors[2..MAXCOL-1] : colors which can be set by IXSETCO
 */
static int colored;             /* Flag if color screen                      */

static struct {
  int defined;
  unsigned long pixel;
  float red;
  float green;
  float blue;
} colors[MAXCOL] = {0, 0, 1., 1., 1.};

/*
 * Primitives Graphic Contexts global for all windows
 */

/*
 * Input echo Graphic Context global for all windows
 */

static int fill_hollow;                     /* Flag if fill style is hollow   */
static int current_fasi = 0;                /* Current fill area style index  */
static int align_hori = -1;                 /* Align text left, center, right */
static int align_vert = -1;                 /* Align text bottom, middle, top */


static int current_font_number = 0;         /* current font number in font[]  */


/*
 * data to create fill area interior style
 */
static char p1_bits[] = {
   ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55),
   ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55),
   ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55)};
static char p2_bits[] = {
   ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11),
   ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11),
   ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11)};
static char p3_bits[] = {
   ~(0x00), ~(0x00), ~(0x44), ~(0x44), ~(0x00), ~(0x00), ~(0x11), ~(0x11), ~(0x00), ~(0x00), ~(0x44), ~(0x44),
   ~(0x00), ~(0x00), ~(0x11), ~(0x11), ~(0x00), ~(0x00), ~(0x44), ~(0x44), ~(0x00), ~(0x00), ~(0x11), ~(0x11),
   ~(0x00), ~(0x00), ~(0x44), ~(0x44), ~(0x00), ~(0x00), ~(0x11), ~(0x11)};
static char p4_bits[] = {
   ~(0x80), ~(0x80), ~(0x40), ~(0x40), ~(0x20), ~(0x20), ~(0x10), ~(0x10), ~(0x08), ~(0x08), ~(0x04), ~(0x04),
   ~(0x02), ~(0x02), ~(0x01), ~(0x01), ~(0x80), ~(0x80), ~(0x40), ~(0x40), ~(0x20), ~(0x20), ~(0x10), ~(0x10),
   ~(0x08), ~(0x08), ~(0x04), ~(0x04), ~(0x02), ~(0x02), ~(0x01), ~(0x01)};
static char p5_bits[] = {
   ~(0x20), ~(0x20), ~(0x40), ~(0x40), ~(0x80), ~(0x80), ~(0x01), ~(0x01), ~(0x02), ~(0x02), ~(0x04), ~(0x04),
   ~(0x08), ~(0x08), ~(0x10), ~(0x10), ~(0x20), ~(0x20), ~(0x40), ~(0x40), ~(0x80), ~(0x80), ~(0x01), ~(0x01),
   ~(0x02), ~(0x02), ~(0x04), ~(0x04), ~(0x08), ~(0x08), ~(0x10), ~(0x10)};
static char p6_bits[] = {
   ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44),
   ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44),
   ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44)};
static char p7_bits[] = {
   ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0xff), ~(0xff), ~(0x00), ~(0x00), ~(0x00), ~(0x00),
   ~(0x00), ~(0x00), ~(0xff), ~(0xff), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0xff), ~(0xff),
   ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0xff), ~(0xff)};
static char p8_bits[] = {
   ~(0x11), ~(0x11), ~(0xb8), ~(0xb8), ~(0x7c), ~(0x7c), ~(0x3a), ~(0x3a), ~(0x11), ~(0x11), ~(0xa3), ~(0xa3),
   ~(0xc7), ~(0xc7), ~(0x8b), ~(0x8b), ~(0x11), ~(0x11), ~(0xb8), ~(0xb8), ~(0x7c), ~(0x7c), ~(0x3a), ~(0x3a),
   ~(0x11), ~(0x11), ~(0xa3), ~(0xa3), ~(0xc7), ~(0xc7), ~(0x8b), ~(0x8b)};
static char p9_bits[] = {
   ~(0x10), ~(0x10), ~(0x10), ~(0x10), ~(0x28), ~(0x28), ~(0xc7), ~(0xc7), ~(0x01), ~(0x01), ~(0x01), ~(0x01),
   ~(0x82), ~(0x82), ~(0x7c), ~(0x7c), ~(0x10), ~(0x10), ~(0x10), ~(0x10), ~(0x28), ~(0x28), ~(0xc7), ~(0xc7),
   ~(0x01), ~(0x01), ~(0x01), ~(0x01), ~(0x82), ~(0x82), ~(0x7c), ~(0x7c)};

BITMAP FillBitMap = { 0,   // Specifies the bitmap type. This member must be zero
                     16,   // Specifies the width, in pixel, of the bitmap
                     16,   // Specifies the height, in pixel, of the bitmap
                      2,   // Specifies the number of bytes in each scan line.
                      1,   // Specifies the count of color planes.
                      1,   // Specifies the number of bits required to ind. th color
                &p2_bits   // points to the location of the bit values for the bitmap
                    };

#define MAXMK 100
static struct MARKER {
  int cindex;
  int type;
  int n;
  XPoint xy[MAXMK];
} marker;                        /* point list to draw marker                 */


/*___________________________________________________________________*/
/*
 *    Set input on or off
 */
void
  setinput(inp)
int inp;
{

}

//______________________________________________________________________________
COLORREF ColorIndex(int ic) {
  COLORREF c;
  if (hdCommonPalette)
       c =  PALETTEINDEX(ic+ColorOffset);
  else {
    PALETTEENTRY palentr = lpPalette->palPalEntry[ic];
    c = *(DWORD *)(&palentr) & 0x00FFFFFF;
  }
  return c;
}

/*___________________________________________________________________*/
/*
 * set the foreground color in GC
 */
void
  setcolor( gc, ci )
int gc;
int ci;
{
  if( colored && ( ci < 0 || ci >= MAXCOL || !colors[ci].defined ) )
    {
     ci = 0;
    }
  else if (!colored && ci < 0 )
    {
     ci = 0;
    }
  else if (!colored && ci > 0 )
    {
     ci = 1;
    }


  /* make sure that foreground and background are different */
}


/*___________________________________________________________________*/
/*
 * return null terminated and blank trimmed string
 */
char*
  string( s, l )
char *s;
int l;
{
  static char str[256];
  int i;

  if( l >= sizeof( str ) )
    l = sizeof( str ) - 1;

  for( i = 0; i < l; i++ )
    str[i] = s[i];
  while( l > 0 && str[l-1] == ' ' )
    l--;

  str[l] = '\0';
  return( str );
}




/*___________________________________________________________________*/
/*
 *    Allows to set the DISPLAY and the WINDOW address
 *    from outside HIGZ (ie a MOTIF program).
 */
void
  ixsdswi( dsp , win )
  int *dsp;
  int win;
{

}

/*___________________________________________________________________*/
/*
 *    Allows KUIP to give to HIGZ the adress of three routines:
 *    1) motif_open  : to open a KUIP motif window
 *    2) motif_init  : to initalize a KUIP motif window (add the callbacks)
 *    3) motif_close : to close a KUIP motif window
 */
void
  ixmotif( dsp , open, init, close)
  int *dsp;
  int (*open)();
  void (*init)();
  void (*close)();
{
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXMINIT(WID)
 *    INTEGER WID : Window ID
 *
 *    Initialize the Motif windows (add the callbacks)
 */
void
  ixminit(wid)
  int *wid;
{
}

/*___________________________________________________________________*/
 LRESULT APIENTRY
         HIGZDrawing(wParam,lParam)
/* Dispatch a drawing operation either to real window or to pixmap */
WPARAM wParam;
LPARAM lParam;
 {
   if (PixMapON){
           DWORD rvalue;
           HGDIOBJ hbr,hpn;

           cHw = lpHpixmap;
           CurrentDC = lpHpixmap->hdcWindow;
           hbr = SelectObject(CurrentDC,hdCommonBrush);
           hpn = SelectObject(CurrentDC,hdCommonPen);

           rvalue = (int) HIGZ_Act(NULL,IX11_HIGZ_MSG,wParam, lParam);
/*                  Restore all attributes                               */
           SelectObject(CurrentDC,hpn);
           SelectObject(CurrentDC,hbr);
           return rvalue;
   }
   else return SendMessage(CurrentHIGZWindow,
                           IX11_HIGZ_MSG,wParam,lParam);
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETHN(LENHST,HOST)
 *    INTEGER LENHST      : host name length
 *    CHARACTER*(*) HOST  : host name
 *
 *    Set host name (fill global variable hname)
 */
void
  ixsethn( lenhst, host, len_host )
char *host;
int *lenhst;
int len_host;
{
 strcpy (hname,string( host, *lenhst ));
}


/*___________________________________________________________________*/
  HBITMAP CreateHIGZBuffer(hwnd)
  HWND hwnd;
  {
  HBITMAP hdBuffer,oldbit,hdNewBuffer;
  HDC     hdPixmapDC,hdWindowDC,oldbitDC,hdNewDC;
  SIZE    WindowSize,BufferSize;

     hdPixmapDC = cHw->hdcPixBuffer;
     hdWindowDC = cHw->hdcWindow;
     hdBuffer   = cHw->hbBuffer;

/*  Create New Memory Device context */
     hdNewDC = CreateCompatibleDC(NULL);
     SetMapMode (hdNewDC,MM_ISOTROPIC);
     SetBkMode  (hdNewDC,TRANSPARENT);
/*  Set HIGZ pallete */
     if (hdCommonPalette != NULL) 
             DeleteObject(SelectPalette(hdNewDC,hdCommonPalette,TRUE));
/*  Create a new BITMAP for double buffering  and coordinate transformation  */
     GetWindowExtEx(hdWindowDC,&WindowSize);
     GetViewportExtEx(hdWindowDC,&BufferSize);
     hdNewBuffer = CreateCompatibleBitmap(hdWindowDC,BufferSize.cx,
                                                  BufferSize.cy);
     SetWindowExtEx(hdNewDC,WindowSize.cx,WindowSize.cy,NULL);
     SetViewportExtEx(hdNewDC,BufferSize.cx,BufferSize.cy,NULL);
/*             Set new bitmap                       */
     DeleteObject(SelectObject(hdNewDC,hdNewBuffer));

     if (hdPixmapDC) { /* Copy old bitmap to new one */
        BitBlt(hdNewDC,0,0,WindowSize.cx,WindowSize.cy,
               hdPixmapDC,  0,0,SRCCOPY);
/*  Delete previous buffer */
        DeleteObject(SelectObject(hdPixmapDC,hdNewBuffer));
        DeleteDC(hdPixmapDC);
     }
     else { /*  Clear new bitmap */
         rect.left   = 0;
         rect.right  = WindowSize.cx;
         rect.top    = 0;
         rect.bottom = WindowSize.cy;
         FillRect(hdNewDC,&rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
         DeleteObject(CurBrush);
     }


/*  Set window variable */

     cHw->hdcPixBuffer=hdNewDC;
     cHw->hbBuffer    =hdNewBuffer;
     return cHw->hbBuffer;
  }


/*___________________________________________________________________*/
  HBITMAP FlushHIGZBuffer(hwnd)
  HWND hwnd;
  {
  HBITMAP hdBuffer;
  HDC     hdPixmapDC,hdWindowDC;
  SIZE    WindowSize,BufferSize;
  HRGN    TempClip;

     hdPixmapDC = cHw->hdcPixBuffer;
     hdWindowDC = cHw->hdcWindow;
     hdBuffer   = cHw->hbBuffer;

     if (hdPixmapDC) {
       if (hdBuffer) {
         GetWindowExtEx(hdWindowDC,&WindowSize);

/*    Set an application palette                           */
        if (hdCommonPalette) {
         SetSystemPaletteUse(hdWindowDC,SYSPAL_NOSTATIC);
         RealizePalette(hdWindowDC);
        }
/*            Cancel  clipping temporary                                   */
        if (cHw->HIGZClipRegion)
              TempClip = SelectClipRgn(hdWindowDC,NULL);

/*           Hide HIGZCursor                          */
         BitBlt(hdWindowDC,0L,0L,WindowSize.cx,WindowSize.cy,
                hdPixmapDC,0L,0L,SRCCOPY);
/*          Restore HIGZCursor */
/*    Compare size of Window and its Buffer           */
         if (WindowSize.cx  != BufferSize.cx)
/*          One needs change a scale                  */
                            hdBuffer = CreateHIGZBuffer(hwnd);
/*    Restore the current clipboard                   */
         if (cHw->HIGZClipRegion)
               TempClip = SelectClipRgn(hdWindowDC,TempClip);


       }
     }
    return hdBuffer;
  }

/*___________________________________________________________________*/
LRESULT APIENTRY WndHIGZ(hwnd, uMsg, wParam, lParam)
HWND   hwnd;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
{
    PAINTSTRUCT ps;

    cHw = (struct HIGZWindow *)GetWindowLong(hwnd,ExtHIGZWindow);
    if (cHw) CurrentDC = cHw->hdcWindow;

    // HistoryDC = (HDC) GetWindowLong(hwnd,4*offHistoryDC);
    switch (uMsg) {
       case WM_LBUTTONDOWN:
       case WM_MBUTTONDOWN:
       case WM_RBUTTONDOWN:
         if (!cHw->MouseInit) break;
         cHw->MouseInit = 0;
         Wnd_REQLO(hwnd,uMsg,wParam,lParam);
         return 0;
       case WM_MOUSEMOVE:
         SetCursor(cHw->hHIGZCursor);
       case WM_RBUTTONUP:
       case WM_MBUTTONUP:
       case WM_LBUTTONUP:
         if (!cHw->MouseInit)  break;
         Wnd_REQLO(hwnd,uMsg,wParam,lParam);
         return 0;
//_______________________________________________________________
        // The WM_QUERYNEWPALETTE message informs a window that it is about to
        // receive input focus. In response, the window receiving focus should
        // realize its palette as a foreground palette and update its client
        // area. If the window realizes its palette, it should return TRUE;
        // otherwise, it should return FALSE.

       case WM_QUERYNEWPALETTE:
        {
           HDC     hDC;
		   HPALETTE hpalOld = NULL;

           if(hdCommonPalette)
           {
               hDC = GetDC(hwnd);

               // Select and realize the palette

               hpalOld = SelectPalette(hDC, hdCommonPalette, FALSE);
               RealizePalette(hDC);

               // Redraw the client area

               InvalidateRect(hwnd, NULL, TRUE);
               UpdateWindow(hwnd);

               if(hpalOld)
                   SelectPalette(hDC, hpalOld, FALSE);

               ReleaseDC(hwnd, hDC);

               return TRUE;
           }

           return FALSE;
        }

//_______________________________________________________________
        // The WM_PALETTECHANGED message informs all windows that the window
        // with input focus has realized its logical palette, thereby changing 
        // the system palette. This message allows a window without input focus
        // that uses a color palette to realize its logical palettes and update
        // its client area.
        //
        // This message is sent to all windows, including the one that changed
        // the system palette and caused this message to be sent. The wParam of
        // this message contains the handle of the window that caused the system
        // palette to change. To avoid an infinite loop, care must be taken to
        // check that the wParam of this message does not match the window's
        // handle.

        case WM_PALETTECHANGED:
        {
            HDC         hDC; 
 		    HPALETTE hpalOld = NULL;

            // Before processing this message, make sure we
            // are indeed using a palette

            if (hdCommonPalette)
            {
                // If this application did not change the palette, select
                // and realize this application's palette

                if (wParam != (WPARAM)hwnd)
                {
                    // Need the window's DC for SelectPalette/RealizePalette

                    hDC = GetDC(hwnd);

                    // Select and realize our palette

                    hpalOld = SelectPalette(hDC, hdCommonPalette, FALSE);
                    RealizePalette(hDC);

                    // When updating the colors for an inactive window,
                    // UpdateColors can be called because it is faster than
                    // redrawing the client area (even though the results are
                    // not as good)

                    UpdateColors(hDC);

                    // Clean up

                    if (hpalOld)
                       SelectPalette(hDC, hpalOld, FALSE);

                    ReleaseDC(hwnd, hDC);
                }
            }
            break;
        }


//______________________   WM_CREATE ______________________
       case WM_CREATE:
       { int iLoop;
         TEXTMETRIC *tm;
         RECT RectClient;
         HPALETTE hpallete;
         SIZE WindowSize;
         HMENU hmenu;

/* Yin cursor AND bitmask */

BYTE ANDmaskCursor[] =
                       {0xff, 0xfc, 0x7f, 0xff,   /* line 1 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 2 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 3 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 4 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 5 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 6 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 7 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 8 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 9 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 10 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 11 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 12 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 13 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 14 */

                        0x00, 0x02, 0x80, 0x01,   /* line 15 */
                        0x00, 0x01, 0x00, 0x01,   /* line 16 */
                        0x00, 0x02, 0x80, 0x01,   /* line 17 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 18 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 19 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 20 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 21 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 22 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 23 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 24 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 25 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 26 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 27 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 28 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 29 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 30 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 31 */

                        0xff, 0xff, 0xff, 0xff};  /* line 32 */

/* Yin cursor XOR bitmask */

BYTE XORmaskCursor[] =
                       {0x00, 0x02, 0x80, 0x00,   /* line 1 */
                        0x00, 0x02, 0x80, 0x00,   /* line 2 */
                        0x00, 0x02, 0x80, 0x00,   /* line 3 */
                        0x00, 0x02, 0x80, 0x00,   /* line 4 */

                        0x00, 0x02, 0x80, 0x00,   /* line 5 */

                        0x00, 0x02, 0x80, 0x00,   /* line 6 */
                        0x00, 0x02, 0x80, 0x00,   /* line 7 */
                        0x00, 0x02, 0x80, 0x00,   /* line 8 */

                        0x00, 0x02, 0x80, 0x00,   /* line 9 */
                        0x00, 0x02, 0x80, 0x00,   /* line 10 */
                        0x00, 0x02, 0x80, 0x00,   /* line 11 */
                        0x00, 0x02, 0x80, 0x00,   /* line 12 */

                        0x00, 0x02, 0x80, 0x00,   /* line 13 */
                        0x00, 0x02, 0x80, 0x00,   /* line 14 */

                        0xFF, 0xFC, 0x7F, 0xFE,   /* line 15 white border */
                        0x00, 0x00, 0x00, 0x00,   /* line 16 black cross  */
                        0xFF, 0xFC, 0x7F, 0xFE,   /* line 17 white border */
 
                        0x00, 0x02, 0x80, 0x00,   /* line 18 */
                        0x00, 0x02, 0x80, 0x00,   /* line 19 */
                        0x00, 0x02, 0x80, 0x00,   /* line 20 */

                        0x00, 0x02, 0x80, 0x00,   /* line 21 */
                        0x00, 0x02, 0x80, 0x00,   /* line 22 */

                        0x00, 0x02, 0x80, 0x00,   /* line 23 */
                        0x00, 0x02, 0x80, 0x00,   /* line 24 */

                        0x00, 0x02, 0x80, 0x00,   /* line 25 */
                        0x00, 0x02, 0x80, 0x00,   /* line 26 */
                        0x00, 0x02, 0x80, 0x00,   /* line 27 */
                        0x00, 0x02, 0x80, 0x00,   /* line 28 */

                        0x00, 0x02, 0x80, 0x00,   /* line 29 */
                        0x00, 0x02, 0x80, 0x00,   /* line 30 */
                        0x00, 0x02, 0x80, 0x00,   /* line 31 */

                        0x00, 0x00, 0x00, 0x00};  /* line 32 */

/* Create a custom cursor at run time. */

HCURSOR hCursor = CreateCursor(
      (HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE),  /* app instance          */
                               15,     /* horiz pos of hot spot */
                               15,     /* vert pos of hot spot  */

                               32,     /* cursor width          */
                               32,     /* cursor height         */
                     ANDmaskCursor,    /* AND bitmask           */
                     XORmaskCursor);   /* XOR bitmask           */

/*
 *
 * AND	XOR	Display
 *
 * 0	 0 	 Black
 * 0	 1	 White
 * 1	 0	 Screen
 * 1	 1	 Reverse screen
 *
 */

/*  To define whether our graphics device has a pallette */

  int iPalExist;

/* Disable the Close postion in the System Menu */
         hmenu = GetSystemMenu(hwnd,FALSE);
         EnableMenuItem(hmenu,6 , MF_GRAYED | MF_BYPOSITION);

/* Create Extended data block                */
          cHw = malloc(sizeof(HIGZWindow));
         /*  Insert in dadata chain */
          if (fHw == NULL) {
             fHw = cHw;
             cHw->ptbw =  NULL;
           }
           else {
             lHw->ptfw = cHw;
             cHw->ptbw = lHw;
           }

/* Initial fill the data structure in */
           cHw->WinType = 0;
           cHw->ptfw                = NULL;
           cHw->hwnd                = hwnd;
           cHw->hdcWindow           = GetDC(hwnd);
           cHw->hdcPixBuffer        = (HDC) NULL;
           cHw->HIGZClipRegion      = (HRGN)NULL;
           cHw->HIGZCursor          = FALSE;
           cHw->SystemCursorVisible = TRUE;
           cHw->MouseInit           = 0;
           cHw->SetTextInput        = FALSE;
           cHw->loc.x = 0; cHw->loc.y=0; cHw->locp.x=0; cHw->locp.y=0;
           cHw->isopening = FALSE;
           cHw->hHIGZCursor = hCursor;

           SetWindowLong(hwnd,ExtHIGZWindow,(LONG)cHw);

           lHw = cHw;
           Number_of_HIGZ_Windows++;

           CurrentDC = cHw->hdcWindow;

           /* Create caret to character input */

             tm = malloc(sizeof(TEXTMETRIC));
             GetTextMetrics(CurrentDC,tm);
             cHw->dwCharX = tm->tmAveCharWidth;
             cHw->dwCharY = tm->tmHeight;
             cHw->dwAscent= tm->tmAscent;
             free(tm);

             SetMapMode    (CurrentDC,MM_ISOTROPIC);
             RectClient.left   = 0;
             RectClient.top    = 0;
             RectClient.right  = 1023;
             RectClient.bottom = 1023;

 /*          Create HistoryDC (memory MetaFile) DC to perform PAINT operation          */

//             HistoryDC = CreateEnhMetaFile(CurrentDC,"META.emf",&RectClient,NULL);
             HistoryDC = 0;
             if (HistoryDC) cHw->hdcHistory =HistoryDC;

             SetWindowExtEx(CurrentDC,
                                         RectClient.right+1,
                                         RectClient.bottom+1,
                                         NULL);
             SetBkMode(CurrentDC,TRANSPARENT);
             SetTextAlign(CurrentDC,
                          TA_BASELINE | TA_LEFT | TA_NOUPDATECP);
             if (HistoryDC)
               {
                 SetMapMode    (HistoryDC,MM_ISOTROPIC);
 /*                SetWindowExtEx(HistoryDC,
                                         RectClient.right+1,
                                         RectClient.bottom+1,
                                         NULL);
  */               SetBkMode(HistoryDC,TRANSPARENT);
                 SetTextAlign(CurrentDC,
                              TA_BASELINE | TA_LEFT | TA_NOUPDATECP);
               }
             GetClientRect(hwnd,&RectClient);
             SetViewportExtEx (CurrentDC,
                                         RectClient.right,
                                         RectClient.bottom,
                                         NULL);
             GetClientRect(hwnd,&(cHw->HIGZWindowSize));
             DPtoLP(CurrentDC,(POINT*) (&(cHw->HIGZWindowSize)),2);

//          if (hdCommonPalette == NULL) {

/*  
 *   Let's define whether we have a palette or any true color facilities 
 */
            iPalExist = GetDeviceCaps(CurrentDC,RASTERCAPS) & RC_PALETTE ;
 
            if (iPalExist)
               maxcol = GetDeviceCaps(CurrentDC,SIZEPALETTE);
            else {
               maxcol = GetDeviceCaps(CurrentDC,NUMCOLORS);
               if (maxcol == -1)
                      maxcol = 256;
               hdCommonPalette = NULL;
            }
 
            maxcol = min(256,maxcol);
 /* Allocate enough memory for a logical palette with
               * PALETTESIZE entries and set the size and version fields
               * of the logical palette structure.
               */
              lpPalette = (NPLOGPALETTE) malloc((sizeof (LOGPALETTE) +
                                                (sizeof (PALETTEENTRY) * (maxcol))));

          if(!lpPalette){
            MessageBox(hwnd, "<WM_CREATE> Not enough memory for palette.", NULL, MB_OK | MB_ICONHAND);
                PostQuitMessage (0) ;
            break;
          }

              lpPalette->palVersion    = 0x300;
              lpPalette->palNumEntries = maxcol;

              /* fill in intensities for all palette entry colors */
          if (iPalExist) {
              GetSystemPaletteEntries(CurrentDC,0,20, lpPalette->palPalEntry);

              /*  create a logical color palette according the information
               *  in the LOGPALETTE structure.
               */
              hdCommonPalette = CreatePalette ((LPLOGPALETTE) lpPalette);
          }

        if(hdCommonPalette != NULL)
             DeleteObject(SelectPalette(CurrentDC,hdCommonPalette,TRUE));
        // if (HistoryDC) DeleteObject(SelectPalette(HistoryDC,hpallete,TRUE));
        return 0;

          }
       case WM_PAINT:
            if (BeginPaint(hwnd,&ps)) {
              HDC hdc;
              ENHMETAHEADER mfHeader;
              HENHMETAFILE  hmf,hmfOld;
              HRGN TempClip;
              RECT rect;

/*             Close History Metafile and create a new one  and play old   */
//             hdc=(HDC)GetWindowLong(hwnd,4*offHistoryDC);

             if (hdCommonPalette) {
               SetSystemPaletteUse(CurrentDC,SYSPAL_NOSTATIC);
               RealizePalette(CurrentDC);
             }
/*    Hide HIGZ mouse locator  and text caret   */
             if (!cHw->isopening)
               if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);
             else cHw->isopening = FALSE;
             if (cHw->SetTextInput) HideCaret(hwnd);
             FlushHIGZBuffer(hwnd);
/*    Restore HIGZ mouse locator and text caret */
             if (cHw->SetTextInput) ShowCaret(hwnd);
             if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);

             hdc = HistoryDC;
             if (hdc) {
/*             Get Old metafile                                            */
                hmf = CloseEnhMetaFile(hdc);
//==>                printf("PAINT ==>  hmf  is %x   with error code %d  \n", hmf, GetLastError());

/*             Create new metafile                                         */
                GetEnhMetaFileHeader(hmf,sizeof(ENHMETAHEADER),&mfHeader);
//==>                printf("==> PAINT:   Rectangle retrivied by GetEnh %d %d %d %d  Error code is %d \n",
//                mfHeader.rclFrame.top,mfHeader.rclFrame.right,
//                mfHeader.rclFrame.left,mfHeader.rclFrame.bottom, GetLastError());

                 HistoryDC = CreateEnhMetaFile(ps.hdc,NULL,&(mfHeader.rclFrame),NULL);
//==>                 printf(" PAINT, CreateEnh HistoryDC = %x \n", HistoryDC);

               cHw->hdcHistory = HistoryDC;
/*             Play Old metafile in new one and ti window                  */
                GetClientRect(hwnd,&rect);
                DPtoLP(ps.hdc,&rect,2);
//==>                printf("New rectangle will be %d %d %d %d \n",rect.top, rect.left,rect.bottom,rect.right);

//                 PlayEnhMetaFile(HistoryDC,hmf,&rect);

/*                        Set clipping temporary for PAINT arear           */
 //              TempClip = SelectClipRgn(ps.hdc,
//                                       CreateRectRgnIndirect(&ps.rcPaint));

           if (hdCommonPalette) {
            SetSystemPaletteUse(CurrentDC,SYSPAL_NOSTATIC);
            RealizePalette(CurrentDC);
           }
               PlayEnhMetaFile(ps.hdc,hmf,&rect);

/*                       Restore clip region                               */
//               SelectClipRgn(ps.hdc,TempClip);

/*             Delete Old metafile                                         */
                DeleteEnhMetaFile(hmf);
               }

              EndPaint(hwnd, &ps);
            }

            return  DefWindowProc(hwnd,uMsg, wParam, lParam);
       case WM_ERASEBKGND:
          {
            HRGN TempClip;
/*            Cancel  clipping temporary                                   */
            if (cHw->HIGZClipRegion)
                TempClip = SelectClipRgn((HDC)wParam,NULL);
/*    Hide HIGZ mouse locator */
            if (!cHw->isopening)
              if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);
            else cHw->isopening = FALSE;
              GetClientRect(hwnd,&rect);
              DPtoLP(CurrentDC,&rect,2);
              FillRect(CurrentDC,&rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
              DeleteObject(CurBrush);
//            DefWindowProc(hwnd,uMsg, wParam, lParam);
/*    Restore HIGZ mouse locator */
            if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);
            if (cHw->HIGZClipRegion)
                TempClip = SelectClipRgn((HDC)wParam,TempClip);
            return TRUE;
//            return FALSE // Window will remain marked for erasing
          }
       case WM_SIZE:

/* WM_SIZE
 * fwSizeType = wParam;     -  resizing flag
 * nWidth = LOWORD(lParam); -  width of client area
 *nHeight = HIWORD(lParam); -  height of client area
 */
           SetViewportExtEx(CurrentDC, LOWORD(lParam), HIWORD(lParam), NULL);
           cHw->HIGZWindowSize.right = LOWORD(lParam);
           cHw->HIGZWindowSize.bottom = HIWORD(lParam);
           DPtoLP(CurrentDC,(POINT*) (&(cHw->HIGZWindowSize)),2);
           return 0;
  /*           return DefWindowProc(hwnd,uMsg, wParam, lParam); */
       case WM_SETFOCUS:
           if (!cHw->SetTextInput) break;
               CreateCaret(hwnd, (HBITMAP) 1, cHw->dwCharX, cHw->dwAscent);
               SetCaretPos(ixText, iyText);
               ShowCaret(hwnd);
               return 0;
       case WM_KILLFOCUS:

        /*
         *   Hide and destroy the caret when the window loses
         *   keyboard focus
         */

           if (!cHw->SetTextInput) break;
               HideCaret(hwnd);
               DestroyCaret();
               return 0;
       case WM_CHAR:
           if (cHw->SetTextInput) return Wnd_REQST(hwnd, uMsg, wParam, lParam);
           break;
       case WM_KEYDOWN:
           if      (cHw->MouseInit)    Wnd_REQLO(hwnd, uMsg, wParam, lParam);
           else if (cHw->SetTextInput) Wnd_REQST(hwnd, uMsg, wParam, lParam);
           break;
       case WM_QUERYOPEN:
           cHw->isopening = TRUE;
           break;
       case WM_DESTROY:
           DeleteDC(CurrentDC);
           DestroyCursor(cHw->hHIGZCursor);  /* 3.06.94 */
           if (HistoryDC)  CloseEnhMetaFile(HistoryDC);
           break;
//           return 0;

       case IX11_HIGZ_MSG:
          {
           DWORD rvalue;
           HGDIOBJ hbr,hpn;
           HDC hdc;
/*   Set double buffering DC */
           if (cHw->hdcPixBuffer)
                CurrentDC = cHw->hdcPixBuffer;
           if (hdCommonPalette) {
             SetSystemPaletteUse(CurrentDC,SYSPAL_NOSTATIC);
             RealizePalette(CurrentDC);
           }
           hbr = SelectObject(CurrentDC,hdCommonBrush);
           hpn = SelectObject(CurrentDC,hdCommonPen);

           rvalue = (DWORD)HIGZ_Act(hwnd,uMsg, wParam, lParam);
/*                  Restore all attributes                               */
           SelectObject(CurrentDC,hpn);
           SelectObject(CurrentDC,hbr);
           return rvalue;
          }
       case IX11_HIGZ_Input:
          {
           switch (LOWORD(wParam)) {
             case IX_REQLO:
                Wnd_REQLO(hwnd,uMsg, wParam, lParam);
                break;
             case IX_REQST:      // Request a string input
                Wnd_REQST(hwnd, uMsg, wParam, lParam);
                break;
             default:
                break;
           }
          }
       default:
               break;
    }
    return DefWindowProc(hwnd,uMsg, wParam, lParam);
}

/*___________________________________________________________________*/
LPTHREAD_START_ROUTINE HIGZ_MsgLoop(ThrSem)
 HANDLE ThrSem;
 {
   MSG msg;
   HWND hwndHIGZ;
   int value;
   struct CREATEHIGZWINDOW *WinThr;

   ReleaseSemaphore(ThrSem, 1, NULL);
   while(GetMessage(&msg,NULL,0,0))
    {
       if (msg.hwnd == NULL & msg.message == IX11_HIGZ_MSG) {

         switch(HIWORD(msg.wParam)) {
           case HIGZ_Control:
             switch (LOWORD(msg.wParam)) {
               case IX_OPNWI:
/*                  Create new window                                                 */
                 WinThr = msg.lParam;
                 if ( WinThr->flag != 2)
                   hwndHIGZ = CreateWindow(
                              HIGZCLASS,           /*extended window style                       */
                              string(WinThr->title,WinThr->lentit),   /*address of window name                      */
                              WS_OVERLAPPEDWINDOW | WS_VISIBLE, /*window style   */
                              CW_USEDEFAULT, CW_USEDEFAULT,  // *x, *y,
                              WinThr->w, WinThr->h,            // *w, *h,
                              NULL,                    /*handle of parent of owner window            */
                              NULL,                    /*handle of menu, or child-window identifier  */
                              higz_display.hInstance,  /*handle of application instance              */
                              NULL);                   /*address of window-creation data             */
                 else {
                   hwndHIGZ = CreateTextClass(WinThr);
                 }

                 WinThr->hwnd = hwndHIGZ;

                 ReleaseSemaphore(WinThr->semaphore, 1, NULL);
                 break;  /* IX_OPNWI */
             default:
                 break;
             } /* End of HIGZ_Control */
           case HIGZ_Attribute:
             switch (LOWORD(msg.wParam))
               {
                default:
                   break;
                 }
           default:
               break;
          }
       }
       else {
          if (msg.message != IX11_HIGZ_MSG)
                           TranslateMessage(&msg);
          DispatchMessage(&msg);
       }
    }
    ExitThread(0);
    return 0;
 } /* HIGZ_MsgLoop */


/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXOPNDS(LENHST,HOST)
 *    INTEGER LENHST      : host name length
 *    CHARACTER*(*) HOST  : host name
 *
 *    Open the display. Return -1 if the opening fails
 */
int
  ixopnds( lenhst, host 
+SELF, IF=QFMSOFT.
          , len_host
+SELF.
)
+SELF, IF=QFMSOFT.
       int len_host;
+SELF.
char *host;
int *lenhst;
{
 HINSTANCE hinst  = GetModuleHandle(NULL);      /* handle of current instance */
 ATOM iregcode;

//  HINSTANCE hinst  = NULL;      /* handle of current instance */


  /* Make sure that this window hasn't been registered yet */

#ifdef WINEX
  higz_display.cbSize = sizeof(WNDCLASSEX); 
#endif

#ifdef WINEX
  if (GetClassInfoEx(hinst,HIGZCLASS,&higz_display))
#else
  if (GetClassInfo(hinst,HIGZCLASS,&higz_display))
#endif
      return 0;

  /* Set the common wndClass information. This is common for all windows
  ** of this application.
  */

  higz_display.style      = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
  higz_display.cbClsExtra = 0;

  higz_display.cbWndExtra = sizeof(LONG)+LastExtraMember*sizeof(HANDLE);

  higz_display.hCursor    = NULL;
//  higz_display.hCursor    = LoadCursor(NULL, IDC_CROSS);
//  higz_display.hCursor    = LoadCursor(hinst, hCursor);
  higz_display.hInstance  = hinst;
#ifdef WINEX
  higz_display.hIconSm = NULL;  /* For Windows NT it must be NULL */
#endif

  /*
  ** Register the main top-level window
  */

  higz_display.lpfnWndProc   = (WNDPROC) WndHIGZ;
  higz_display.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
  higz_display.hbrBackground = GetStockObject(WHITE_BRUSH);
  higz_display.lpszMenuName   = NULL;
  higz_display.lpszClassName  = HIGZCLASS;

#ifdef  WINEX
  if (!RegisterClassEx(&higz_display)) {
#else
  if (!RegisterClass(&higz_display)) {
#endif
    int ierrcode;
    ierrcode = GetLastError();
    printf("  Open Display error %d RegCode= %i \n", ierrcode, iregcode);   
          return -1;
      }
  else 
   {
     HANDLE ThrSem;
/*
 *    Retrieve the applicaiton instance
 */

        /* Create thread to do loop msg */

     ThrSem = CreateSemaphore(NULL, 0, 1, NULL);

     CreateThread(NULL,0, (LPTHREAD_START_ROUTINE) HIGZ_MsgLoop,
                  (LPVOID) ThrSem, 0,  &IDThread);

     WaitForSingleObject(ThrSem, INFINITE);
     CloseHandle(ThrSem);
/*   Create  common object                */
     hdCursorPen   = GetStockObject(BLACK_PEN);
//        CreatePen(PS_SOLID,0,RGB(64,64,64));// Pen to draw HIGZ locator
     hdCursorBrush =
        GetStockObject(HOLLOW_BRUSH);    // Brush to draw HIGZ locator 3 or 5
     return 0;}
}


/*___________________________________________________________________*/
LRESULT APIENTRY
                 HIGZ_Act(hwnd, uMsg, wParam, lParam)
HWND   hwnd;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
     {
           switch (HIWORD(wParam)) {

             case HIGZ_Control:
                 switch (LOWORD(wParam))
                   {
                     case IX_OPNDS:  // Open X11 display
                       break;
                     case IX_OPNWI:  // Open X11 window
                        break;
                     case IX_SELWI:  // Select the current X11 window
                        break;
                     case IX_CLSWI:  // Close an X11 window
                        if (hdCommonPalette) {
                          SetSystemPaletteUse(CurrentDC,SYSPAL_STATIC);
                          RealizePalette(CurrentDC);
                        }
                        while(!PostMessage(HWND_BROADCAST,WM_SYSCOLORCHANGE, 0, 0));

                        if (HistoryDC) DeleteEnhMetaFile(CloseEnhMetaFile(HistoryDC));
                        /* Delete data structure */
                        /* Link previous and next structure */
                        if (cHw->ptbw == NULL) fHw = cHw->ptfw; /* This is the first structure in the list */
                        else cHw->ptbw->ptfw = cHw->ptfw;

                        if (cHw->ptfw == NULL) lHw = cHw->ptbw; /* This is the last structure in the list */
                        else cHw->ptfw->ptbw = cHw->ptbw;
                        /* Now the current structure is free and we may delete it */
                        free(cHw);
                        Number_of_HIGZ_Windows--;
                        DestroyWindow( hwnd );
                        return 0;
                     case IX_CLSDS:  // Close an X11 session
                        PostQuitMessage(0);
                        break;

                     case IX_SETHN:  // Set X11 host name
                       return TRUE;
                     case IX_CLRWI:  // Clear an X11 window
                       {
                      /*  HBRUSH CurBrush; */
                      /*  RECT rect;       */
                        HRGN TempClip, clip;
                        char buftext[20]= {"HI\0PAW\0\0" };

/*                        Cancel clipping temporary                  */

                        clip = cHw->HIGZClipRegion;
                        if (clip != NULL) TempClip = SelectClipRgn(CurrentDC,NULL);
                        GetClientRect(hwnd,&rect);
                        DPtoLP(CurrentDC,&rect,2);
                        FillRect(CurrentDC,&rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
                        DeleteObject(CurBrush);
                        if (clip != NULL) TempClip = SelectClipRgn(CurrentDC,TempClip);

/*             Close History Metafile and create a new one                       */

//                        if (HistoryDC) {
                          if(FALSE) {
                          ENHMETAHEADER mfHeader;
                          HENHMETAFILE  hmf;
                           hmf = CloseEnhMetaFile(HistoryDC);
//==>                           printf(" Metafile ID %x with error %d  for %x Histiry DC \n", hmf,GetLastError(),HistoryDC);
                           GetEnhMetaFileHeader(hmf,sizeof(ENHMETAHEADER),&mfHeader);
                           DeleteEnhMetaFile(hmf);
                           HistoryDC = CreateEnhMetaFile(CurrentDC ,NULL,&(mfHeader.rclFrame),
                             NULL);
//==>                           printf(" HistoryDC inside od CLRWI %x with Error %d \n", HistoryDC,
//                           GetLastError());
                           cHw->hdcHistory = HistoryDC;
                        }
                        return TRUE;
                       }

                     case IX_UPDWI:  // Update an X11 window
                          FlushHIGZBuffer(hwnd);
//---->   1.08.96 It caused strange behav under Win 95 -->     BringWindowToTop(hwnd);
                          break;
                     case IX_RSCWI:  // Resize an X11 window
                       return TRUE;
                     case IX_CLIP :  // Define the X11 clipping rectangle
                         {
                          LPPOINT ClipRectPoint;
                          LPRECT  ClipRectFromPoint;
                          HDC     hdc;
                          HRGN    clip;

                           hdc = CurrentDC;
                           ClipRectPoint     = (LPPOINT) lParam;
                           ClipRectFromPoint = (LPPOINT) lParam;
                           LPtoDP(hdc,ClipRectPoint, 2);

                           if (clip = cHw->HIGZClipRegion)
                                           DeleteObject(clip);
/*   Select clippping for Display */
                           hdc = cHw->hdcWindow;
                           SelectClipRgn(hdc,
                                         clip = CreateRectRgnIndirect( ClipRectFromPoint));

/*   Select clippping for bitmap buffer */
                           hdc = cHw->hdcPixBuffer;
                           if (hdc)
                             SelectClipRgn(hdc,
                                           clip = CreateRectRgnIndirect( ClipRectFromPoint));
                           cHw->HIGZClipRegion = clip;
                           return (LRESULT) TRUE;
                         }
                     case IX_NOCLI:  // Deactivate the X11 clipping rectangle
                         {
                           HDC     hdc;
                           HRGN    clip;

                           clip = cHw->HIGZClipRegion;
                           if (clip != NULL) {
                             DeleteObject(clip);
                             hdc = cHw->hdcWindow;
                             SelectClipRgn(hdc,NULL);
                             /* Cancel cliiping for bitmap buffer */
                             hdc = cHw->hdcPixBuffer;
                             if (hdc) SelectClipRgn(hdc,NULL);
                             cHw->HIGZClipRegion = (HRGN) NULL;;
                           }
                           return (LRESULT) TRUE;
                         }
                  default:
                          return TRUE;
                   }
                   break;


                     /*      X11 output primitives                  */
             case  HIGZ_Primitive:
                 switch (LOWORD(wParam))
                   {
                     case IX_LINE :      // Draw a line through all points
                       {
                         struct { int n; XPoint *xy;} *line;
                         HDC     hdc;
                         int i;

                         line = lParam;
                         hdc = CurrentDC;
                         if ( line->n > 1 )
                            return Polyline(hdc,line->xy,line->n);
                         else
                            return SetPixel(hdc, line->xy[0].x,line->xy[0].y, RGB(0,0,0));
                       }
                     case IX_MARKE:      // Draw a marker ar each point
                       return  Wnd_MARKE(hwnd, uMsg, wParam, lParam);

                     case IX_FLARE:      // Fill area described by polygon
                       return Wnd_FLARE(hwnd, uMsg, wParam, lParam);
                     case IX_BOX  :      // Draw a box
                       return Wnd_BOX(hwnd, uMsg, wParam, lParam);
                     case IX_CA   :      // Draw a cell array
                         return Wnd_CA(hwnd, uMsg, wParam, lParam);
                  default:
                     return TRUE;
                   }
                   break;
                    /*      X11 text                               */
             case  HIGZ_Text:
               {
                 TEXTMETRIC *tm;
                 HGDIOBJ hdf;
/*                    Save default values and set cthe current one                  */
                 hdf    = SelectObject(CurrentDC,hdCommonFont);

                           /* Update text metric's */

                 tm = malloc(sizeof(TEXTMETRIC));
                 GetTextMetrics(CurrentDC,tm);
                 cHw->dwCharX = tm->tmAveCharWidth;
                 cHw->dwCharY = tm->tmHeight;
                 cHw->dwAscent= tm->tmAscent;
                 free(tm);

                 switch (LOWORD(wParam))
                   {
                     case IX_TEXT :      // Draw a text string using the current font
                        {
                         struct {int mode,x,y,lentxt; float angle, mgn;  char *text;} *text_msg;
                         COLORREF clrref;
                         int y_shift = 0,
                             x_shift = 0;
                         int txtA;
                         double t_rotate;

/*                     Save default values  and set current one                                */
                         clrref = SetTextColor(CurrentDC,dwCommonTextColor);
                         txtA   = SetTextAlign(CurrentDC,dwCommonTextAlign);

                         text_msg = lParam;
                    /* therefore Windows font hasn'ta  "vertical cernter attribute"
                        one should emulate it by hand
                     */
                         if (align_vert == 0) {
                            t_rotate = cos(0.1*HIGZFont.lfEscapement);
                            y_shift  = (cHw->dwAscent/2)*t_rotate;
                            x_shift  = (cHw->dwAscent/2)*sqrt(1.0-t_rotate*t_rotate);
                         }
                         ExtTextOut(CurrentDC,
                                        text_msg->x+x_shift, text_msg->y+y_shift,
                                        0, NULL,
                                        text_msg->text, text_msg->lentxt,
                                        NULL);
/*                     Restore default values                                       */
                         SetTextColor(CurrentDC,clrref);
                         SetTextAlign(CurrentDC,txtA );
                         break;
                        }
                     case IX_TXTL :      // Return the width and height of character string in the current font
                        {
                           SIZE text_size;
                           struct { int w,h, lmess; char *mess;} *sText;
                           sText = lParam;
                           GetTextExtentPoint(CurrentDC,
                                              sText->mess,sText->lmess, &text_size);
                           sText->w = text_size.cx;
                           sText->h = text_size.cy;
                           break;
                        }
                     default:
                           break;
                   }
/*                     Restore Default font                       */

                 SelectObject(CurrentDC,hdf);

                 tm = malloc(sizeof(TEXTMETRIC));
                 GetTextMetrics(CurrentDC,tm);
                 cHw->dwCharX = tm->tmAveCharWidth;
                 cHw->dwCharY = tm->tmHeight;
                 cHw->dwAscent= tm->tmAscent;
                 free(tm);

                 break;
               }
/*              X11 output attributes                             */
             case HIGZ_Attribute:
                 switch (LOWORD(wParam))
                   {
                     case IX_DRMDE:      // Set drawing mode
                       SetROP2(CurrentDC,lParam);
                       return TRUE;
                   }
                   break;
                    /*     X11 marker style                        */

             case HIGZ_Marker:
                 switch (LOWORD(wParam))
                   {
                     case IX_SETTA:      // Set text alignment
                        SetTextAlign(CurrentDC,lParam);
                        break;
                     case IX_SETTF:      // Set text font to specified name
                       {
                        TEXTMETRIC *tm;
                        DeleteObject(SelectObject(CurrentDC,
                                      CreateFontIndirect((LOGFONT*) lParam))
                                    );
                           /* Update text metric's */

                        tm = malloc(sizeof(TEXTMETRIC));
                        GetTextMetrics(CurrentDC,tm);
                        cHw->dwCharX = tm->tmAveCharWidth;
                        cHw->dwCharY = tm->tmHeight;
                        cHw->dwAscent= tm->tmAscent;
                        free(tm);

                        break;
                       }

                     case IX_SYNC :      // X11 synchronization

                  default:
                     return TRUE;
                   }
                   break;
                   /*      X11 inquiry routines                   */
             case HIGZ_Inquiry:
                 switch (LOWORD(wParam))
                   {
                     case IX_GETGE:       // Returns position and size of Window
                       GetWindowExtEx(CurrentDC,(LPSIZE)lParam);
                       return TRUE;
                     case IX_GETWI:       // Returns the X11 window identifier
                     case IX_GETPL:       // Returns the maximal number of planes of the display
                     case IX_GETCOL:      // Returns the X11 colour representation
                       {
                        struct {int index; struct tagPALETTEENTRY rgb;} *lpHIGZ_rgb;
                        HGDIOBJ hpl;

                        lpHIGZ_rgb = lParam;
                        hpl = GetCurrentObject(CurrentDC,OBJ_PAL);
                        GetPaletteEntries(hpl,lpHIGZ_rgb->index,1,&(lpHIGZ_rgb->rgb));
                        break;
                       }
                  default:
                     return TRUE;
                   }
                  break;

        /*          Pixmap manipulation                    */

             case HIGZ_Pixmap:
                 switch (LOWORD(wParam))
                {
                     case IX_CPPX :       // Copy the pixmap
                       Wnd_CPPX(hwnd, uMsg, wParam, lParam);
                       break;
                     case IX_WRPX :       // Write the pixmap
//                       Wnd_WRPX(hwnd, uMsg, wParam, lParam);
                       break;
                     case IX_WIPX :       // Copy the area in the current window
                       Wnd_WIPX(hwnd, uMsg, wParam, lParam);
                       break;
                   default:
                       return TRUE;
                }
                return TRUE;
           /*             Dummies                         */

             case HIGZ_Dummies:
                 switch (LOWORD(wParam))
                   {
                     case IX_S2BUF:
                       Wnd_S2BUF(hwnd, uMsg, wParam, lParam);
                       break;
                     case IX_SDSWI:
                  default:
                     return TRUE;
                   }
            default:
                      return TRUE;
            }
            return TRUE;
  }   /*  HIGZ_Act */

/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXOPNWI(X,Y,W,H,LENTIT,TITLE,FLAG)
 *    INTEGER X,Y         : initial window position
 *    INTEGER W,H         : initial window width and height
 *    INTEGER LENTIT      : title length
 *    CHARACTER*(*) TITLE : window title
 *    INTEGER FLAG        : FLAG<>1 allows to open a non MOTIF window
 *                          even if ixmotif has been called.
 *
 *    Open window and returns window number which can be used with IXSELWIN
 *    return -1 if window creation fails
 */
int
  ixopnwi( x, y, w, h, lentit,title, 
+SELF, IF=QFMSOFT.
         len_title, 
+SELF.
         flag )
char *title;
+SELF, IF=QFMSOFT.
        int len_title;
+SELF.
int *x, *y;
int *w, *h;
int *lentit;
int *flag;
{
 HWND hwndHIGZ;
 int value;
 static struct CREATEHIGZWINDOW WinThr;

 WinThr.x = *x;
 WinThr.y = *y;
 WinThr.w = *w+2*GetSystemMetrics(SM_CXFRAME);

 WinThr.h = *h+  GetSystemMetrics(SM_CYCAPTION)
              +2*GetSystemMetrics(SM_CYFRAME)
              -  GetSystemMetrics(SM_CYBORDER);
 WinThr.lentit = *lentit;
 WinThr.title = title;


      /* Create HIGZ window */

  WinThr.semaphore = CreateSemaphore(NULL, 0, 1, NULL);

  while(!PostThreadMessage(IDThread,
         IX11_HIGZ_MSG,MAKEWPARAM(IX_OPNWI,HIGZ_Control), &WinThr));

  WaitForSingleObject(WinThr.semaphore, INFINITE);
  CloseHandle(WinThr.semaphore);

  ShowWindow(WinThr.hwnd,SW_SHOWDEFAULT);
  UpdateWindow(WinThr.hwnd);

  return (int)WinThr.hwnd;

 }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXRSCWI(WID, W, H)
 *    INTEGER WID  : Window identifier.
 *    INTEGER W    : Width
 *    INTEGER H    : Heigth
 *
 *    Rescale the window WID
 */
void
   ixrscwi(wid, w, h)
  HWND *wid;
  int *w;
  int *h;
{
   int new_w,new_h;

   new_w = *w+2*GetSystemMetrics(SM_CXFRAME);

   new_h = *h+  GetSystemMetrics(SM_CYCAPTION)
             +2*GetSystemMetrics(SM_CYFRAME)
             -  GetSystemMetrics(SM_CYBORDER);

   SetWindowPos(*wid,HWND_TOP,0,0,new_w,new_h,
                 SWP_DRAWFRAME|SWP_NOMOVE |SWP_NOZORDER );
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXS2BUF(WID,MODE)
 *    INTEGER WID  : Window identifier.
 *                   999 means all the opened windows.
 *    INTEGER MODE : 1 double buffer is on
 *                   0 double buffer is off
 *
 *    Set the double buffer on/off on window WID.
 */
void
  ixs2buf( wid, mode )
  int *wid;
  int *mode;
{
  SendMessage(*wid,
              IX11_HIGZ_MSG,MAKEWPARAM(IX_S2BUF,HIGZ_Dummies),*mode);
}

/*___________________________________________________________________*/
LRESULT APIENTRY
        Wnd_S2BUF (hwnd, uMsg, wParam, lParam)
HWND  hwnd;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
/*   Global variable used:
 *
 *   offPixmapDC  - handle of the memory device context
 *   offPixBuffer - handle of the bitmap in memory DC
 *                = NULL - means there os no double buffering
 *                         for the current window.
 */
 {
  HBITMAP hdBuffer;
  HDC     hdPixmapDC;

     hdPixmapDC = cHw->hdcPixBuffer;
     hdBuffer   = cHw->hbBuffer;

     if (lParam) {
/*         Turn double bufferring ON           */
      if (hdPixmapDC)  FlushHIGZBuffer(hwnd);
      else CreateHIGZBuffer(hwnd);
     }
     else
/*         Turn double bufferring OFF           */
      if (hdPixmapDC){
        hdBuffer = FlushHIGZBuffer(hwnd);
        DeleteDC(hdPixmapDC);
        DeleteObject(hdBuffer);

        cHw->hdcPixBuffer = NULL;
        cHw->hbBuffer = NULL;
      }
 }

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXQ2BUF(WID)
 *    INTEGER WID  : Window identifier.
 *
 *    Query the double buffer value for the window WID.
 */
int
  ixq2buf( wid )
  int *wid;
{
  int rval;
  struct HIGZWindow *Hw;
  Hw = (struct HIGZWindow *)GetWindowLong(*wid,ExtHIGZWindow);
  rval = (int) (Hw->hbBuffer);
  if (rval) return rval;
  else return -1;
}



/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXOPNPX(W, H)
 *    INTEGER W,H : Width and height of the pixmap.
 *
 *    Open a new pixmap.
 */
int
  ixopnpx(w, h)
int *w, *h;
{
  static struct {SIZE PixMap;HANDLE semaphore;HBITMAP ipix;} HIGZPixmap;

  HIGZPixmap.PixMap.cx = *w;
  HIGZPixmap.PixMap.cy = *h;

 lpHpixmap  = malloc(sizeof(HIGZWindow));
 if (lpHpixmap) {
  lpHpixmap->hdcWindow =  CreateCompatibleDC(NULL);
  SetMapMode (lpHpixmap->hdcWindow,MM_ISOTROPIC);
  SetBkMode  (lpHpixmap->hdcWindow,TRANSPARENT);
  if (hdCommonPalette!= NULL) 
      DeleteObject(SelectPalette(lpHpixmap->hdcWindow,hdCommonPalette,TRUE));

  lpHpixmap->HIGZWindowSize.right  = *w;
  lpHpixmap->HIGZWindowSize.bottom = *h;
  cHw = (struct HIGZWindow *)GetWindowLong(CurrentHIGZWindow,ExtHIGZWindow);
  lpHpixmap->hbBuffer = CreateCompatibleBitmap(cHw->hdcWindow,
                                     lpHpixmap->HIGZWindowSize.right,
                                     lpHpixmap->HIGZWindowSize.bottom);
  SelectObject(lpHpixmap->hdcWindow,lpHpixmap->hbBuffer);
  PixMapON = TRUE;
 }
 return (int) lpHpixmap->hbBuffer;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLRPX(PIX)
 *    INTEGER PIX : Pixmap address
 *
 *    Clear the pixmap PIX.
 */
void
  ixclrpx(pix )
HGDIOBJ *pix;
{
      RECT rect;
      BITMAP Bitmap_buffer;

     if (lpHpixmap) {
       if (lpHpixmap->hbBuffer == *pix) {
        GetObject(*pix, sizeof(BITMAP),&Bitmap_buffer);
        rect.left   = 0;
        rect.top    = 0;
        rect.right  = Bitmap_buffer.bmWidth;
        rect.bottom = Bitmap_buffer.bmHeight;
        FillRect(lpHpixmap->hdcWindow,
                 &rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
        DeleteObject(CurBrush);
       }
     }
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLPX
 *
 *    Close the current opened pixmap.
 */
void
  ixclpx()
{
 PixMapON = FALSE;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCPPX(PIX, XPOS, YPOS)
 *    INTEGER PIX : Pixmap address
 *    INTEGER XPOS, YPOS : Pixmap Position
 *
 *    Copy the pixmap PIX at the position XPOS YPOS.
 */
void
  ixcppx(pix, xpos, ypos)
int *pix;
int *xpos, *ypos;
{
  POINT point;
  point.x = *xpos;
  point.y = *ypos;
  if (lpHpixmap->hbBuffer == *pix)
     SendMessage(CurrentHIGZWindow,
                 IX11_HIGZ_MSG,MAKEWPARAM(IX_CPPX,HIGZ_Pixmap),&point);
}

/*___________________________________________________________________*/
LRESULT APIENTRY
        Wnd_CPPX (hwnd, uMsg, wParam, lParam)
                   HWND  hwnd; UINT   uMsg; WPARAM wParam; LPARAM lParam;
{
   BITMAP Bitmap_buffer;
   int w,h;
   GetObject(lpHpixmap->hbBuffer, sizeof(BITMAP),&Bitmap_buffer);
   w = Bitmap_buffer.bmWidth;
   h = Bitmap_buffer.bmHeight;
   BitBlt(CurrentDC,((POINT*)lParam)->x,((POINT*)lParam)->y,w,h,
          lpHpixmap->hdcWindow,0,0,SRCCOPY);

}



/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXWRPX(PIX,W,H,LENNAME,PXNAME)
 *    INTEGER PIX : Pixmap address
 *    INTEGER W,H : Width and height of the pixmap.
 *    INTEGER LENNAME     : pixmap name length
 *    CHARACTER*(*) PXNAME: pixmap name
 *
 *    Write the pixmap IPX in the bitmap file PXNAME.
 */
void
  ixwrpx(pix, w, h, lenname, pxname,lpxname )
char *pxname;
int *pix;
int *w, *h;
int *lenname;
int lpxname;
{
 unsigned int wval, hval;
  wval = *w;
  hval = *h;
/*  XWriteBitmapFile(display,string(pxname,*lenname),*pix,wval,hval,-1,-1);
*/
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXWIPX(PIX, XPOS, YPOS)
 *    INTEGER PIX : Pixmap address
 *    INTEGER XPOS, YPOS : Position in the current window
 *
 *    Copy the area at the position XPOS YPOS in the current
 *    window in the pixmap PIX. The area copied has the size
 *    of the pixmap PIX.
 */
void
  ixwipx(pix, xpos, ypos )
int *pix;
int *xpos, *ypos;
{
  POINT point;
  point.x = *xpos;
  point.y = *ypos;
  SendMessage(CurrentHIGZWindow,
              IX11_HIGZ_MSG,MAKEWPARAM(IX_WIPX,HIGZ_Pixmap),&point);
}

/*___________________________________________________________________*/
LRESULT APIENTRY
        Wnd_WIPX (hwnd, uMsg, wParam, lParam)
                   HWND  hwnd; UINT   uMsg; WPARAM wParam; LPARAM lParam;
{
   int w,h;
   BITMAP Bitmap_buffer;

   GetObject(lpHpixmap->hbBuffer, sizeof(BITMAP),&Bitmap_buffer);
   w = Bitmap_buffer.bmWidth;
   h = Bitmap_buffer.bmHeight;
   BitBlt(lpHpixmap->hdcWindow,0,0,w,h,
          CurrentDC,((POINT*)lParam)->x,((POINT*)lParam)->y,SRCCOPY);

}



/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXRMPX(PIX)
 *    INTEGER PIX : Pixmap adress
 *
 *    Remove the pixmap PIX.
 */
void
  ixrmpx(pix)
int *pix;
{
 PixMapON = FALSE;
 DeleteDC(lpHpixmap->hdcWindow);
 DeleteObject(lpHpixmap->hbBuffer);
 free(lpHpixmap);
 lpHpixmap = NULL;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLSDS
 *
 *    Delete all windows and close connection
 */
void
  ixclsds()
{
/* Delete common objects */
  DeleteObject(hdCursorPen);
  DeleteObject(hdCursorBrush);
  PostMessage(CurrentHIGZWindow,
              IX11_HIGZ_MSG,MAKEWPARAM(IX_CLSDS,HIGZ_Control), 0);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLSWI
 *
 *    Delete current window
 */
void
  ixclswi()
{
  int wid;

   SendMessage(CurrentHIGZWindow,
               IX11_HIGZ_MSG,MAKEWPARAM(IX_CLSWI,HIGZ_Control), 0);

//  ixclsds(); /* no open window left */
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSELWI(WID)
 *    INTEGER WID : window number returned by IXOPNWIN
 *
 *    Select window to which subsequent output is directed
 */
void
  ixselwi( wid )
HWND *wid;
{
  CurrentHIGZWindow = *wid;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSAVWI
 *
 *    Save the adress of the current active window
 */
void
  ixsavwi()
{
  sws = cws;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETWI
 *
 *    Restore the adress of the saved window
 */
void
  ixsetwi()
{
  cws = sws;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXGETGE(WID,X,Y,W,H)
 *    INTEGER WID : window identifier
 *    INTEGER X,Y : window position (output)
 *    INTEGER W,H : window size (output) (in Windowa/NT logical coordinat)
 *
 *    Return position and size of window wid
 *    if wid < 0 the size of the display is returned
 */
void
   ixgetge( wid, x, y, w, h )
HWND *wid;
int *x, *y;
unsigned int *w, *h;
{
  HDC junkwin;
  static SIZE win_pos;
  if( *wid < 0 ) {
    /* Retrive size of full screen in the device unit */
     junkwin = GetDC(NULL);
     *x = 0;
     *y = 0;
     *w = GetDeviceCaps(junkwin,HORZRES);
     *h = GetDeviceCaps(junkwin,VERTRES);
     ReleaseDC(NULL,junkwin);
   } else {
      junkwin = SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_GETGE,HIGZ_Inquiry), &win_pos);
     /* Retrive size of DISPLAY in the logical unit */
      *x = 0;
      *y = 0;
      *w = win_pos.cx;
      *h = win_pos.cy;
  }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXGETPL(NPLANES)
 *    INTEGER NPLANES     : number of bit planes
 *
 *    Get maximum number of planes
 */
void
   ixgetpl(nplanes)
int *nplanes;
{
   HDC  hDCGlobal;
   hDCGlobal = GetDC(NULL);
   *nplanes  = GetDeviceCaps(hDCGlobal,PLANES);
   ReleaseDC(NULL,hDCGlobal);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXRSIZ(WID)
 *    INTEGER WID     : window to be resized
 *
 *    Resize the current window if necessary
 */
void
   ixrsiz(wid)
int *wid;
{

}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXGETHT(IL,CHHOST)
 *    INTEGER IL           : host name length (output)
 *    CHARACTER*(*) CHHOST : host name (output)
 *
 *    Return the host name given with IGWKTY.
 */
void
   ixgetht (il, chhost)
   int *il;
   char *chhost; /* host name */
{
   GetComputerName(chhost,il);
}


/*___________________________________________________________________*/
void
   ixgetwi (wkid, idg)
   int wkid;    /* workstation identifier (input) */
   int *idg; /* window identifier (output) */
{
   *idg = 1;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLRWI
 *
 *    Clear current window
 */
void
  ixclrwi()
{
  HIGZDrawing(MAKEWPARAM(IX_CLRWI,HIGZ_Control), 0);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXUPDWI(MODE)
 *    INTEGER MODE : (1) or (11) The window is raised
 *                   (0) or (10) The window is not raised
 *                   (0) or (1)  no synchonisation between client and server
 *                  (10) or (11) synchonisation between client and server
 *
 *    Update display and raise current window to top of stack.
 *    Synchronise client and server once (not permanent).
 *    Copy the pixmap cws->buffer on the window cws-> window
 *    if the double buffer is on.
 */
void
  ixupdwi(mode)
  int *mode;
{
  SendMessage(CurrentHIGZWindow,IX11_HIGZ_MSG,
              MAKEWPARAM(IX_UPDWI,HIGZ_Control), *mode);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLIP(WID,X,Y,W,H)
 *    INTEGER WID : Window indentifier
 *    INTEGER X,Y : origin of clipping rectangle
 *    INTEGER W,H : size of clipping rectangle;
 *
 *    Set clipping region for the window wid
 */
void
  ixclip( wid, x, y, w, h )
HWND *wid;
int *x, *y;
int *w, *h;
{
  static RECT region;

  region.left   = *x;
  region.top    = *y;
  region.right  = *x+*w;
  region.bottom = *y+*h;

  SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_CLIP,HIGZ_Control), &region);

}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IWCLIP(WID,XMIN,YMIN,XMAX,YMAX)
 *    INTEGER WID : Window indentifier
 *    INTEGER XMIN,YMIN, XMAX, YMAX : clipping rectangle
 *
 *    Set clipping region for the window wid
 */
void
  iwclip( wid, xmin, ymin, xmax, ymax )
HWND *wid;
int *xmin, *ymin, *xmax, *ymax;
{
  static RECT region;

  region.left   = *xmin;
  region.top    = *ymin;
  region.right  = *xmax;
  region.bottom = *ymax;

  SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_CLIP,HIGZ_Control), &region);

}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXNOCLI(WID)
 *    INTEGER WID : Window indentifier
 *
 *    Switch off the clipping for the window wid
 */
void
  ixnocli(wid)
HWND *wid;
{

  SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_NOCLI,HIGZ_Control), 0 );

}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETCO(CINDEX,R,G,B)
 *    INTEGER CINDEX : color index
 *    REAL R,G,B     : red, green, blue intensities between 0.0 and 1.0
 *
 *    Set color intensities for given color index
 */
#define BIGGEST_RGB_VALUE 255  // 65535

void
  ixsetco( cindex, r, g, b )
int *cindex;
float *r, *g, *b;
{
  static PALETTEENTRY ChColor;
  static struct {UINT ci; struct PALETTEENTRY *lpChColor;}  NewColor;
  int i;

  if (*cindex >= MAXCOL-1) return;
  if (hdCommonPalette != NULL) {
    NewColor.ci = *cindex;
    NewColor.lpChColor = &ChColor;

    ChColor.peRed   = (BYTE) (*r*BIGGEST_RGB_VALUE);
    ChColor.peGreen = (BYTE) (*g*BIGGEST_RGB_VALUE);
    ChColor.peBlue  = (BYTE) (*b*BIGGEST_RGB_VALUE);

    ChColor.peFlags = PC_NOCOLLAPSE;

    i = NewColor.ci+ColorOffset;
    SetPaletteEntries(hdCommonPalette,i,1,&ChColor);
  }
  else if (lpPalette){
    lpPalette->palPalEntry[*cindex].peRed   = (BYTE) (*r*BIGGEST_RGB_VALUE);
    lpPalette->palPalEntry[*cindex].peGreen = (BYTE) (*g*BIGGEST_RGB_VALUE);
    lpPalette->palPalEntry[*cindex].peBlue  = (BYTE) (*b*BIGGEST_RGB_VALUE);
  }
}


/*___________________________________________________________________*/
void
  ixgetcol( index, r, g, b )
int index; /* input */
float *r, *g, *b; /* output */
{
  static struct {int index; PALETTEENTRY rgb;} HIGZ_rgb;
  if (hdCommonPalette) {
   HIGZ_rgb.index = index;
   SendMessage(CurrentHIGZWindow,
               IX11_HIGZ_MSG,MAKEWPARAM(IX_GETCOL,HIGZ_Inquiry),&HIGZ_rgb);
   *r = (float)HIGZ_rgb.rgb.peRed  /BIGGEST_RGB_VALUE;
   *g = (float)HIGZ_rgb.rgb.peGreen/BIGGEST_RGB_VALUE;
   *b = (float)HIGZ_rgb.rgb.peBlue /BIGGEST_RGB_VALUE;
  }
  else if (lpPalette) {
    *r = lpPalette->palPalEntry[index].peRed/BIGGEST_RGB_VALUE;
    *g = lpPalette->palPalEntry[index].peGreen/BIGGEST_RGB_VALUE;
    *b = lpPalette->palPalEntry[index].peBlue/BIGGEST_RGB_VALUE;
  }
  else {
   *r = *g = *b = 0;
  }
  return ;
}

/*___________________________________________________________________*/
HPEN CreateHIGZPen(lpPen)
struct HIGZPEN *lpPen;
 {
     static int dwWidth, dwStyle;

     dwWidth = lpPen->pen.lopnWidth.x;
     if (dwWidth <= 1)  dwWidth=1;

      dwStyle = lpPen->pen.lopnStyle |
                         ((dwWidth == 1)? PS_COSMETIC:
                                          PS_GEOMETRIC | PS_INSIDEFRAME);

     if (hdCommonPen) DeleteObject(hdCommonPen);
     return ExtCreatePen( dwStyle,
                          dwWidth,
                          &(lpPen->brush),
                          lpPen->lUserDash,
                          lpPen->UserDash);
 }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETLN(WIDTH)
 *    INTEGER WIDTH : line width in pixels
 *
 *    Set line width
 */
void
  ixsetln( width )
int *width;
{
  if (pen.pen.lopnWidth.x != *width)
  {
    pen.pen.lopnWidth.x = *width;
    hdCommonPen = CreateHIGZPen(&pen);
  }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETLS(N,DASH)
 *    INTEGER N       : length of dash list
 *    INTEGER DASH(N) : dash segment lengths
 *
 *    Set line style:
 *    if N.LE.0 use pre-defined Windows style:
 *         0 - solid lines
 *        -1 - solid lines
 *        -2 - dash line
 *        -3 - dot  line
 *        -4 - dash-dot line
 *        -5 - dash-dot-dot line
 *    .LE.-6 - solid line
 *
 *    if N.GT.0 use dashed lines described by DASH(N)
 *    e.g. N=4,DASH=(6,3,1,3) gives a dashed-dotted line with dash length 6
 *    and a gap of 7 between dashes
 */
void
  ixsetls( n, dash )
int *n;
int *dash;
{
  UINT style;
  if( *n <= 0 ) {
    pen.lUserDash = 0;
    pen.UserDash = NULL;
    switch (*n)
     {
       case  0:  style = PS_SOLID;
                 break;
       case -1:  style = PS_SOLID;
                 break;
       case -2:  style = PS_DASH;
                 break;
       case -3:  style = PS_DOT;
                 break;
       case -4:  style = PS_DASHDOT;
                 break;
       case -5:  style = PS_DASHDOTDOT;
                 break;
       default:  style = PS_SOLID;
                break;
     }
   if (pen.pen.lopnStyle == style ) return;
   pen.pen.lopnStyle = style;
  }
  else
  {
    pen.pen.lopnStyle = PS_USERSTYLE;
    pen.lUserDash = *n;
    pen.UserDash = dash;
  }
  hdCommonPen = CreateHIGZPen(&pen);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETLC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for lines
 */
void
  ixsetlc( cindex )
int *cindex;
{
  if (pen.pen.lopnColor != *cindex)
    {
     pen.pen.lopnColor = *cindex;
     pen.brush.lbColor = HIGZColorIndex(pen.pen.lopnColor);

     hdCommonPen = CreateHIGZPen(&pen);
    }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXLINE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Draw a line through all points
 */
void
  ixline( n, xy )
int *n;
XPoint *xy;
{
  static struct { int n; XPoint *xy;} line;
  line.n  = *n;
  line.xy = xy;
  HIGZDrawing(MAKEWPARAM(IX_LINE,HIGZ_Primitive),&line);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETMS(TYPE,N,XY)
 *    INTEGER TYPE      : marker type
 *    INTEGER N         : length of marker description
 *    INTEGER*2 XY(2,N) : list of points describing marker shape
 *
 *    Set marker style:
 *    if N.EQ.0 marker is a single point
 *    if TYPE.EQ.0 marker is hollow circle of diameter N
 *    if TYPE.EQ.1 marker is filled circle of diameter N
 *    if TYPE.EQ.2 marker is a hollow polygon describe by line XY
 *    if TYPE.EQ.3 marker is a filled polygon describe by line XY
 *    if TYPE.EQ.4 marker is described by segmented line XY
 *    e.g. TYPE=4,N=4,XY=(-3,0,3,0,0,-3,0,3) sets a plus shape of 7x7 pixels
 */
void
  ixsetms( type, n, xy )
int *type;
int *n;
XPoint *xy;
{
  int i;

  marker.type = *type;
  marker.n = *n < MAXMK ? *n : MAXMK;
  if( marker.type >= 2 )
    for( i = 0; i < marker.n; i++ )
      marker.xy[i] = xy[i];
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETMC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for markers
 */
void
  ixsetmc( cindex )
int *cindex;
{
  marker.cindex = *cindex;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXMARKE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Draw a marker at each point
 */
void
   ixmarke( n, xy )
int *n;
XPoint *xy;
{
  static struct { int n; XPoint *xy; struct MARKER *marker;} markers;

  markers.n = *n;
  markers.xy = xy;
  markers.marker = &marker;

  HIGZDrawing(MAKEWPARAM(IX_MARKE,HIGZ_Primitive),&markers);

}

/*___________________________________________________________________*/
 LRESULT APIENTRY
      Wnd_MARKE(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
  {
  struct { int n; XPoint *xy; struct MARKER *marker;} *markers;
  int m,n;
  XPoint *xy;
  COLORREF mColor;
  struct MARKER  *CurMarker;
  int ownBrush;

  markers = lParam;
  n       = markers->n;
  xy      = markers->xy;
  CurMarker  = markers->marker;

                  /* Set marker Color */
  mColor  = HIGZColorIndex(CurMarker->cindex);

  if( CurMarker->n <= 0 )
     for (m=0; m < n; m++)  SetPixel(CurrentDC, xy[m].x,xy[m].y, mColor);

  else {
    int r = CurMarker->n / 2;
    HGDIOBJ  CurBrush, CurPen;

    CurPen   = SelectObject(CurrentDC, CreatePen(PS_SOLID,0,mColor));

    switch (CurMarker -> type) {
      case 0:
      case 3:
     default:
          ownBrush = TRUE;
          CurBrush = SelectObject(CurrentDC, CreateSolidBrush(mColor));
          break;
      case 1:
      case 2:
          ownBrush = TRUE;
          CurBrush = SelectObject(CurrentDC, GetStockObject(HOLLOW_BRUSH));
          break;
      case 4:
          ownBrush = FALSE;
          break;
      }

    for( m = 0; m < n; m++ ) {
      int i;

      switch( CurMarker->type ) {

      case 0:        /* hollow circle */
      case 1:        /* filled circle */


         Ellipse( CurrentDC,
                  xy[m].x - r, xy[m].y - r,
                  xy[m].x + r, xy[m].y + r);
         break;

      case 2:        /* hollow polygon */
      case 3:        /* filled polygon */
        for( i = 0; i < CurMarker->n; i++ ) {
                                         CurMarker->xy[i].x += xy[m].x;
                                         CurMarker->xy[i].y += xy[m].y;
                                        }
        Polygon(CurrentDC,CurMarker->xy,CurMarker->n);
        for( i = 0; i < CurMarker->n; i++ ) {
          CurMarker->xy[i].x -= xy[m].x;
          CurMarker->xy[i].y -= xy[m].y;
         }
      break;

      case 4:        /* segmented line */
      for( i = 0; i < CurMarker->n; i += 2 )
       {
        MoveToEx(CurrentDC,xy[m].x + CurMarker->xy[i].x, xy[m].y + CurMarker->xy[i].y,NULL);
        LineTo(CurrentDC,xy[m].x + CurMarker->xy[i+1].x, xy[m].y + CurMarker->xy[i+1].y);
       }
       break;
      }
    }


    if (ownBrush) DeleteObject(SelectObject(CurrentDC, CurBrush));
    DeleteObject( SelectObject(CurrentDC, CurPen ));
   }
   return (LRESULT)TRUE;
 }



/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETFS(STYLE,FASI)
 *    INTEGER STYLE : fill area interior style hollow or solid
 *
 *    Set fill area style
 */
void
  ixsetfs( style, fasi )
int *style;
int *fasi;
{
  if (hdCommonBrush != NULL) DeleteObject(hdCommonBrush);
  switch( *style ) {

  case 0:         /* solid */
    gcfill.lbStyle = BS_HOLLOW;
    hdCommonBrush = GetStockObject(HOLLOW_BRUSH);
    break;
  case 1:         /* solid */
    gcfill.lbStyle = BS_SOLID;
//    if (gcfill.lbColor)
       hdCommonBrush = CreateSolidBrush(HIGZColorIndex(gcfill.lbColor));
//    else
//       hdCommonBrush = GetStockObject(WHITE_BRUSH);
    break;

  case 2:         /* pattern */
    gcfill.lbStyle = BS_PATTERN;
    gcfill.lbHatch = &FillBitMap;
      switch( *fasi ) {
        case 1: FillBitMap.bmBits = &p1_bits;
                break;
        case 2: FillBitMap.bmBits = &p2_bits;
                break;
        case 3: FillBitMap.bmBits = &p3_bits;
                break;
        case 4: FillBitMap.bmBits = &p4_bits;
                break;
        case 5: FillBitMap.bmBits = &p5_bits;
                break;
        case 6: FillBitMap.bmBits = &p6_bits;
                break;
        case 7: FillBitMap.bmBits = &p7_bits;
                break;
        case 8: FillBitMap.bmBits = &p8_bits;
                break;
        case 9: FillBitMap.bmBits = &p9_bits;
                break;
       default: FillBitMap.bmBits = &p2_bits;
                break;
        }
       hdCommonBrush =
           CreatePatternBrush(CreateBitmapIndirect((LPBITMAP)gcfill.lbHatch));
       break;

  case 3:         /* hatch */
      gcfill.lbStyle = BS_HATCHED;
      switch (*fasi)
        {
          case 1: gcfill.lbHatch = HS_BDIAGONAL;
                  break;
          case 2: gcfill.lbHatch = HS_CROSS;
                  break;
          case 3: gcfill.lbHatch = HS_DIAGCROSS;
                  break;
          case 4: gcfill.lbHatch = HS_FDIAGONAL;
                  break;
          case 5: gcfill.lbHatch = HS_HORIZONTAL;
                  break;
          case 6: gcfill.lbHatch = HS_VERTICAL;
                  break;
         default: gcfill.lbHatch = HS_FDIAGONAL;
                  break;
        }
        hdCommonBrush =
           CreateHatchBrush(gcfill.lbHatch,HIGZColorIndex(gcfill.lbColor));
        break;
 default:         /* solid */
      gcfill.lbStyle = BS_NULL;
//      if (gcfill.lbColor)
         hdCommonBrush = CreateSolidBrush(HIGZColorIndex(gcfill.lbColor));
//      else
//         hdCommonBrush = GetStockObject(WHITE_BRUSH);
      break;

 }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETFC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for fill areas
 */
void
  ixsetfc( cindex )
int *cindex;
{
  if (gcfill.lbColor != *cindex) {
   gcfill.lbColor = *cindex;

   switch (gcfill.lbStyle)
     {
       case BS_HOLLOW  :
       case BS_PATTERN :
/*                 Hollow and Patten styles needn't a change of brush */
           break;
       case BS_HATCHED :
          if (hdCommonBrush) DeleteObject(hdCommonBrush);
          hdCommonBrush =
             CreateHatchBrush(gcfill.lbHatch,HIGZColorIndex(gcfill.lbColor));
          break;
       case BS_SOLID   :
       default         :
          if (hdCommonBrush) DeleteObject(hdCommonBrush);
//          if (gcfill.lbColor)
            hdCommonBrush = CreateSolidBrush(HIGZColorIndex(gcfill.lbColor));
//          else
//            hdCommonBrush = GetStockObject(WHITE_BRUSH);
          break;
     }
   }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXFLARE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Fill area described by polygon
 */
void
  ixflare( n, xy )
int *n;
XPoint *xy;
{
  static struct {int n; XPoint *xy;} polygon;

  polygon.n = *n;
  polygon.xy = xy;
  HIGZDrawing(MAKEWPARAM(IX_FLARE,HIGZ_Primitive),&polygon);
}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_FLARE(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
 {
   static struct {int n; XPoint *xy;} *polygon;
   static COLORREF CurTextColor;
   static HGDIOBJ lpCurPen;

   polygon = lParam;

   if (!bord & gcfill.lbStyle != BS_HOLLOW)
               lpCurPen = SelectObject(CurrentDC, GetStockObject(NULL_PEN));


   if (gcfill.lbStyle == BS_PATTERN) {
             CurTextColor = SetTextColor(CurrentDC,HIGZColorIndex(gcfill.lbColor));
             Polygon(CurrentDC,polygon->xy,polygon->n);
             SetTextColor(CurrentDC,CurTextColor);
   }
   else {
             Polygon(CurrentDC,polygon->xy,polygon->n);
   }
   if (!bord & gcfill.lbStyle != BS_HOLLOW)
             DeleteObject(SelectObject(CurrentDC,lpCurPen));

   return TRUE;
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETTA(ALIGNH,ALIGNV)
 *    INTEGER ALIGNH : horizontal text alignment
 *    INTEGER ALIGNV : vertical text alignment
 *
 *    Set text alignment:
 *    if ALIGNH.EQ.2 align center
 *    if ALIGHH.EQ.3 align right
 *              else align left
 *
 *    if ALIGNV.EQ.1 align top
 *    if ALIGNV.EQ.2 align top
 *    if ALIGNV.EQ.3 align middle
 *              else align base
 */
void
  ixsetta( align_h, align_v )
int *align_h;
int *align_v;
{
  dwCommonTextAlign = 0;
  switch( *align_h ) {

  case 2:
    dwCommonTextAlign |= TA_CENTER;
    break;

  case 3:
    dwCommonTextAlign |= TA_RIGHT;
    break;

  default:
    dwCommonTextAlign |= TA_LEFT;
  }


  switch( *align_v ) {

  case 1:
  case 2:
    dwCommonTextAlign |= TA_TOP;
    align_vert = 1;
    break;

  case 3:
    dwCommonTextAlign |= TA_BASELINE;
    align_vert = 0;
    break;

  default:
    dwCommonTextAlign |= TA_BASELINE;
    align_vert = -1;
  }
}

/*___________________________________________________________________*/
/*
 *    FUNCTION IXSETTF(MODE,LENFNT,FONTNAME)
 *    INTEGER *MODE       : Option message
 *                 [0]     : = 1 - Italic
 *                 [1]     : = BOLD
 *                 [2]     : = Height of the character
 *                 [3]     : = Angle
 *                 [4]     : = Precision
 *    INTEGER LENFNT     : font name length
 *    CHARACTER*(*) FONT : font name
 *
 *    Set text font to specified name. This function returns 0 if
 *    the specified font is found, 1 if not.
 */
int
  ixsettf( mode, lenfnt,  fontname
+SELF, IF=QFMSOFT.
	, len_fontname
+SELF.
 )
char *fontname;
+SELF, IF=QFMSOFT.
	int len_fontname;
+SELF.

int *mode;
int *lenfnt;
{
   HIGZFont.lfItalic = (BYTE) mode[0];
   HIGZFont.lfWeight = (LONG) mode[1]*100;
   HIGZFont.lfHeight = (LONG) mode[2]*1.1; // To account "tail"
 //  HIGZFont.lfWidth  = (LONG) mode[2]*1.2
   HIGZFont.lfEscapement   = (LONG)mode[3];
   HIGZFont.lfOutPrecision = 0; // (LONG)mode[4];
   strcpy(HIGZFont.lfFaceName,fontname);

   if (hdCommonFont != NULL) DeleteObject(hdCommonFont);
   hdCommonFont = CreateFontIndirect(&HIGZFont);

  return 0;
 }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETTC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for text
 */
void
  ixsettc( cindex )
int *cindex;
{
   dwCommonTextColor = HIGZColorIndex((COLORREF)(*cindex));
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXTEXT(MODE,X,Y,ANGLE,MGN,LENTXT,TEXT)
 *    INTEGER MODE       : drawing mode
 *            MODE=0     : the background is not drawn
 *            MODE=1     : the background is drawn
 *    INTEGER X,Y        : text position
 *    REAL    ANGLE      : text angle
 *    REAL    MGN        : magnification factor
 *    INTEGER LENTXT     : text length
 *    CHARACTER*(*) TEXT : text string
 *
 *    Draw a text string using current font
 */
void
  ixtext( mode, x, y, angle, mgn, lentxt, text, len_text )
char *text;
int len_text;
int *mode;
int *x, *y;
float *angle;
float *mgn;
int *lentxt;
{
  int dx = 0;
  int dy = 0;
  static struct {int mode,x,y,lentxt; float angle, mgn;  char *text;} text_msg;

  text_msg.mode = *mode;
  text_msg.x    = *x;
  text_msg.y    = *y;
  text_msg.angle = *angle;
  text_msg.mgn   = *mgn;
  text_msg.text  = text;
  text_msg.lentxt=*lentxt;

  HIGZDrawing(MAKEWPARAM(IX_TEXT,HIGZ_Text), &text_msg);

//  do_raise = 1;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXTXTL(IW,IH,LMESS,MESS)
 *    INTEGER IW          : text width
 *    INTEGER IH          : text height
 *    INTEGER LMES        : message length
 *    CHARACTER*(*) MESS  : message
 *
 *    Return the size of a character string
 */
void
  ixtxtl( w, h, lmess, mess
+SELF, IF=QFMSOFT.
         , len_mess
+SELF.
 )
char *mess;
+SELF, IF=QFMSOFT.
         int len_mess;
+SELF.

int *lmess;
int *w;
int *h;
{
   static struct { int w,h, lmess; char *mess;} sText;
   HIGZDrawing(MAKEWPARAM(IX_TXTL,HIGZ_Text), &sText);
   *w = sText.w;
   *h = sText.h;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXBOX(X1,X2,Y1,Y2,MODE)
 *    INTEGER X1,Y1 : left down corner
 *    INTEGER X2,Y2 : right up corner
 *    INTEGER MODE : drawing mode
 *
 *            MODE=0 hollow
 *            MODE=1 solid
 *
 *    Draw a box
 */
void
  ixbox( x1, x2, y1, y2, mode)
int *x1, *x2, *y1, *y2;
int *mode;
{
   static struct { int  x1, y1, x2, y2, mode;} box;

   box.mode  = *mode;
   box.x1    = min(*x1,*x2);
   box.x2    = max(*x1,*x2);
   box.y1    = min(*y1,*y2);
   box.y2    = max(*y1,*y2);

   HIGZDrawing(MAKEWPARAM(IX_BOX,HIGZ_Primitive), &box);

}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_BOX(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
 {
  struct { int  x1, y1, x2, y2, mode;} *box;
  HGDIOBJ NewBrush, lpCurPen;
  static COLORREF CurTextColor;

  box = lParam;
  if (box->mode == 0) {
     if (box->x1 == box->x2 | box->y1 == box->y2) {
/*          Draw a line  instead the rectangle            */
         MoveToEx(CurrentDC,box->x1,box->y1,NULL);
         LineTo  (CurrentDC,box->x2,box->y2);
     }
     else {
         CurBrush = SelectObject(CurrentDC, GetStockObject(HOLLOW_BRUSH));
         Rectangle(CurrentDC,box->x1, box->y1, box->x2, box->y2);
         DeleteObject(SelectObject(CurrentDC,CurBrush));
     }
  }
  else {
//                             CurBrush = GetCurrentObject(CurrentDC,OBJ_BRUSH);
     if (gcfill.lbStyle == BS_PATTERN) {
         CurTextColor = SetTextColor(CurrentDC,HIGZColorIndex(gcfill.lbColor));
         FillRect(CurrentDC, (RECT*)box, hdCommonBrush);
         SetTextColor(CurrentDC,CurTextColor);
     }
     else
         FillRect(CurrentDC, (RECT*)box, hdCommonBrush);
  }
  return TRUE;
 }

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCA(X1,X2,Y1,Y2,NX,NY,IC)
 *    INTEGER X1,Y1 : left down corner
 *    INTEGER X2,Y2 : right up corner
 *    INTEGER NX,NY : array size
 *    INTEGER IC : array
 *
 *    Draw a cell array. The drawing is done with the pixel presicion
 *    if (X2-X1)/NX (or Y) is not a exact pixel number the position of
 *    the top rigth corner may be wrong.
 */
void
  ixca(x1, x2, y1, y2, nx, ny, ic)
int *x1, *x2, *y1, *y2, *nx, *ny;
int ic[];
{

   static struct { int x1, x2, y1, y2, nx, ny; int *ic;} cell;

   cell.x1 = *x1;
   cell.x2 = *x2;
   cell.y1 = *y1;
   cell.y2 = *y2;

   cell.nx = *nx;
   cell.ny = *ny;
   cell.ic = ic;

   cell.x1 = *x1;
   HIGZDrawing(MAKEWPARAM(IX_CA,HIGZ_Primitive), &cell);
}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_CA(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
   {
    int i,j,icol,ix,iy,w,h,hh,current_icol;
    struct { int x1, x2, y1, y2, nx, ny; int *ic;} *cell;
    HBRUSH CurCABrush = NULL;
    RECT box;
    cell = lParam;

    current_icol = -1;
    w            = max((cell->x2-cell->x1)/(cell->nx),1);
    h            = max((cell->y1-cell->y2)/(cell->ny),1);
    ix           = cell->x1;

    box.bottom = cell->y1;
    box.top    = cell->y1;
    box.left   = cell->x1;
    box.right  = box.left+h;
    for ( i=0; i<cell->nx; i++ ) {
      box.top -= h;
      for ( j=0; j<cell->ny; j++ ) {
         icol = cell->ic[i+(cell->nx*j)];
         if(icol != current_icol){
            if (CurCABrush != NULL) DeleteObject(CurCABrush);
            CurCABrush = CreateSolidBrush(HIGZColorIndex(icol));
            current_icol = icol;
         }
         FillRect(CurrentDC, &box, CurCABrush);
         box.bottom = box.top;
         box.top -= h;
      }
      box.left = box.right;
      box.right += w;
    }

    DeleteObject(CurCABrush);
    return TRUE;
   }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXDRMDE(MODE)
 *    INTEGER MODE : drawing mode
 *
 *            MODE=1 copy       R2_COPYPEN
 *            MODE=2 xor     -  R2_XORPEN
 *            MODE=3 invert  -  R2_NOT
 *
 *    Set the drawing mode
 */
void
  ixdrmde( mode )
  int *mode;
{
  static int OP[3] = {R2_COPYPEN, R2_XORPEN, R2_NOT};
  HIGZDrawing(MAKEWPARAM(IX_DRMDE,HIGZ_Attribute), OP[*mode-1]);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSYNC(MODE)
 *    INTEGER MODE : synchronisation on/off
 *
 *            MODE=1 on
 *            MODE<>0 off
 *
 *    Set synchronisation on or off
 */
void
  ixsync( mode )
  int *mode;
{
  int i;
}


/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXREQLO(MODE,CTYP,X,Y)
 *    INTEGER X,Y : cursor position out moment of button press (output)
 *    INTEGER CTYP : cursor type (input)
 *
 *            CTYP=1 tracking cross
 *            CTYP=2 cross-hair
 *            CTYP=3 rubber circle
 *            CTYP=4 rubber band
 *            CTYP=5 rubber rectangle
 *
 *    INTEGER MODE : input mode
 *
 *            MODE=0 request
 *            MODE=1 sample
 *
 *    Request locator:
 *    return button number  1 = left is pressed
 *                          2 = middle is pressed
 *                          3 = right is pressed
 *         in sample mode:
 *                         11 = left is released
 *                         12 = middle is released
 *                         13 = right is released
 *                         -1 = nothing is pressed or released
 *                         -2 = leave the window
 */
int
  ixreqlo( mode, ctyp, x, y )
int *mode, *ctyp, *x, *y;
{
  static struct {int mode, ctyp, x, y, button; HANDLE semaphore;} HIGZmouse;

  HIGZmouse.x    = *x;
  HIGZmouse.y    = *y;
  HIGZmouse.ctyp = *ctyp;
  HIGZmouse.mode = *mode;
  HIGZmouse.semaphore = CreateSemaphore(NULL, 0, 1, NULL);

  SendMessage(CurrentHIGZWindow,
      IX11_HIGZ_Input,MAKEWPARAM(IX_REQLO,HIGZ_Input),&HIGZmouse);

  WaitForSingleObject(HIGZmouse.semaphore, INFINITE);
  CloseHandle(HIGZmouse.semaphore);

  *x = HIGZmouse.x;
  *y = HIGZmouse.y;
  return HIGZmouse.button;

}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_REQLO(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
   {
    /* Global for draw cursor utilities variables */
     static struct {int mode, ctyp, x, y, button; HANDLE semaphore;} *lpHIGZmouse;


     if (hdCommonPalette) {
       SetSystemPaletteUse(cHw->hdcWindow,SYSPAL_NOSTATIC);
       RealizePalette(cHw->hdcWindow);
     }

     cHw->button_press =  0;
     cHw->button_up    =  0;
     switch (uMsg) {
       case WM_RBUTTONUP:
         cHw->button_up++;
       case WM_MBUTTONUP:
         cHw->button_up++;
       case WM_LBUTTONUP:
         cHw->button_up++;
         cHw->button_press++;
       case WM_RBUTTONDOWN:
         cHw->button_press++;
       case WM_MBUTTONDOWN:
         cHw->button_press++;
       case WM_LBUTTONDOWN:
         cHw->button_press++;
       case WM_MOUSEMOVE:

              /* Clean an old position */

        DrawHIGZCursor(lpHIGZmouse->ctyp);

             /* Plot new cursor position */

        cHw->loc.x = (LONG) (MAKEPOINTS(lParam).x);
        cHw->loc.y = (LONG) (MAKEPOINTS(lParam).y);
        DPtoLP(CurrentDC,&(cHw->loc),1);
        DrawHIGZCursor(lpHIGZmouse->ctyp);

  /*  Reset system cursor near the bord id frame */

         if (lpHIGZmouse->mode) {
           if      (cHw->button_press == 0)
                       cHw->button_press = -1;
           else if (cHw->button_press == 4)
                       cHw->button_press = cHw->button_up+10;
           RestoreHIGZ(lpHIGZmouse->ctyp);
           lpHIGZmouse->x = cHw->loc.x ;  lpHIGZmouse->y = cHw->loc.y ;
           lpHIGZmouse->button = cHw->button_press;

//           RestoreDC(CurrentDC,-1);
           ReleaseSemaphore(lpHIGZmouse->semaphore,1L,NULL);

          }
         else if (cHw->button_press > 0 & cHw->button_up ==0) {
           RestoreHIGZ(lpHIGZmouse->ctyp);
           lpHIGZmouse->x = cHw->loc.x ;  lpHIGZmouse->y = cHw->loc.y;
           lpHIGZmouse->button = cHw->button_press;

           ReleaseSemaphore(lpHIGZmouse->semaphore,1L,NULL);
          }

         break;
       case IX11_HIGZ_Input:
         lpHIGZmouse = lParam;
         cHw->loc.x  = lpHIGZmouse->x; cHw->loc.y  =  lpHIGZmouse->y;
         cHw->locp.x = lpHIGZmouse->x; cHw->locp.y =  lpHIGZmouse->y;

         HIGZCursorInit(hwnd,lpHIGZmouse->ctyp);
         break;
       default:
         break;
       }
}

     DrawHIGZCursor( ctyp)
     int ctyp;
     {
        int radius, CurMxX, CurMxY;
        POINT loc,locp;
        loc.x = cHw->loc.x;
        loc.y = cHw->loc.y;

        locp.x = cHw->locp.x;
        locp.y = cHw->locp.y;

        CurMxX = cHw->HIGZWindowSize.right;
        CurMxY = cHw->HIGZWindowSize.bottom;

        switch ( ctyp ) {

        case 1 : /*  Default HIGZ window cursor is CROSS  -> do nothing here */
                 /*
                  *  MoveToEx(CurrentDC,max(0,loc.x-10),     loc.y,NULL);
                  *  LineTo  (CurrentDC,min(CurMxX,loc.x+10),loc.y);

                  *  MoveToEx(CurrentDC,loc.x,max(0,loc.y-10)     ,NULL);
                  *  LineTo  (CurrentDC,loc.x,min(CurMxY,loc.y+10));
                  */
                 break;

        case 2 : MoveToEx(CurrentDC,0,     loc.y,NULL);
                 LineTo  (CurrentDC,CurMxX,loc.y);

                 MoveToEx(CurrentDC,loc.x,0,    NULL);
                 LineTo  (CurrentDC,loc.x,CurMxY);

                 break;

        case 3 : radius = (int) sqrt((double)((loc.x-locp.x)*(loc.x-locp.x)+
                                              (loc.y-locp.y)*(loc.y-locp.y)));
                 Pie(CurrentDC,locp.x-radius,locp.y-radius,
                               locp.x+radius,locp.y+radius,
                               locp.x-radius,locp.y-radius,
                               locp.x-radius,locp.y-radius);
                 break;

        case 4 : MoveToEx(CurrentDC,loc.x, loc.y, NULL);
                 LineTo  (CurrentDC,locp.x,locp.y);
                 break;

        case 5 : Rectangle(CurrentDC,locp.x, locp.y, loc.x, loc.y);
                 break;
        default:
                 break;
      }
   }

/*___________________________________________________________________*/
   HIGZCursorInit(hwnd,ctyp)
   HWND hwnd;
   int ctyp;
   {
        SaveDC(CurrentDC);
   /* Create Brush or Pen to draw HIGZ graphics cursor */

        SelectObject(CurrentDC,hdCursorPen);
        if (ctyp == 3 | ctyp == 5)
            SelectObject(CurrentDC, hdCursorBrush);

   /* Suspend current clipping */

        SelectClipRgn(CurrentDC, NULL);


   /* Set a new mix mode to XOR */

        SetROP2(CurrentDC,R2_NOT);

   /* Set Cursor on the screen */
        DrawHIGZCursor(ctyp);
        cHw->MouseInit = ctyp;
    }

/*___________________________________________________________________*/
RestoreHIGZ(int ctyp)
  {
    cHw->MouseInit = 0;
/* Clean cursor off the screen */
    DrawHIGZCursor(ctyp);
    RestoreDC(CurrentDC,-1);
  }


/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXREQST(X,Y,TEXT)
 *    INTEGER X,Y        : position where text is displayed
 *    CHARACTER*(*) TEXT : text displayed (input), edited text (output)
 *
 *    Request string:
 *    text is displayed and can be edited with Emacs-like keybinding
 *    return termination code (0 for ESC, 1 for RETURN)
 */
int
 ixreqst( x, y, len_text,  text
+SELF, IF=QFMSOFT.
                       ,   lenn_text 
+SELF.
)
char *text;

+SELF, IF=QFMSOFT.
int lenn_text;
+SELF.

int *len_text;
int *x, *y;
{
   static struct {int x, y, len_tex; char *text;
                  int BreakKey; HANDLE semaphore;}
                  HIGZText;
   HIGZText.x = *x;
   HIGZText.y = *y;
   HIGZText.len_tex = *len_text;
   HIGZText.text    = text;
   HIGZText.BreakKey = -1;
   HIGZText.semaphore = CreateSemaphore(NULL, 0, 1, NULL);

   SendMessage(CurrentHIGZWindow,
         IX11_HIGZ_Input,MAKEWPARAM(IX_REQST,HIGZ_Input),&HIGZText);

   WaitForSingleObject(HIGZText.semaphore, INFINITE);
   CloseHandle(HIGZText.semaphore);

   return HIGZText.BreakKey;

}

/*___________________________________________________________________*/
 int CharWidth(ch)
 char ch;
    {int LenOfChar;
       GetCharWidth(CurrentDC, (UINT) ch, (UINT) ch,  &LenOfChar);
       return LenOfChar;}

/*___________________________________________________________________*/
 LRESULT APIENTRY
         Wnd_REQST(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
   {
#define ixg(x) (ix0+x)
#define iyg(y) (iy0+y)
 /*             Application message                     */
    static struct {int x, y, len_tex; char *text;
                  int BreakKey; HANDLE semaphore;}
                  *lpHIGZText;

   static char ch;        // entered symbol
   static char *lpInstr;  // Input line buffer
   static int nCur,       // Current text cursor postion
              lStr,       // Current length of the entered string
                pt,       // Current symbol position
              BreakKey,   // Code of the entered "End of Line" terminator
              nCharWidth, // Width of the current symbol
              LenLine,    // Pixel length of the entered string
              ix0,iy0;
    static    char *Instr;     // temporary buffer


   static int insert;
   int i;

      switch (uMsg) {
       case WM_CHAR:
         switch(wParam) {

           case 0x0A: /* line feed       */
           case 0x0D: /* carriage return */
                     (lpHIGZText->BreakKey)++;
           case 0x1B: /* escape          */
                     (lpHIGZText->BreakKey)++;

                     cHw->SetTextInput = FALSE;
                     HideCaret(hwnd);
                     DestroyCaret();
                     if (lpHIGZText->len_tex > 0) {
                       for (i=0;i<lStr;i++)                     lpInstr[i] = Instr[i];
                       for (i=lStr; i<lpHIGZText->len_tex; i++) lpInstr[i]=' ';
                       free(Instr);
                     }


/*          End of text input from keyboard
 *            and restore previous active window
 */
              SetActiveWindow(ConWindow);
              SetFocus(ConWindow);

              ReleaseSemaphore(lpHIGZText->semaphore,1L,NULL);
              break;

           case 0x09: /* Tab */
           case 0x08: /* backspace */
              break;
           default:   /* all other letters */
             ch = (TCHAR) wParam;
             HideCaret(hwnd);

                 if (nCur != lStr){/*             Clear the old tail of the string            */
                                   COLORREF CurTextCol;
                                   CurTextCol = SetTextColor(CurrentDC,GetBkColor(CurrentDC));
                                   TextOut(CurrentDC,ixg(ixText),iyg(iyText),
                                           &Instr[nCur],lStr-nCur);
                                   SetTextColor(CurrentDC,CurTextCol);
                                  }
                 if (insert==1)    {/*                      Shift string                       */
                                   for (i=lStr; i>nCur; i--) Instr[i] = Instr[i-1];
                                   /*   Increasing of the acctual length                       */
                                   lStr++;
                                   Instr[lStr] = 0x0;
                                  }
                 else if (nCur == lStr) lStr++;
                 else // reduce length of string
                      LenLine -= CharWidth(Instr[nCur]);

/*             Put enreted symbol in place                 */
             Instr[nCur] = ch;
/*            Out the  new tail of the text                 */
             TextOut(CurrentDC,ixg(ixText),iyg(iyText),
                     &Instr[nCur],lStr-nCur);

             LenLine += CharWidth(ch); // pixel length of entered string
             ixText  += CharWidth(ch); // Reset Graphics position for next input
             nCur++;
             break;
          }
         SetCaretPos(ixg(ixText),iyg(iyText-(cHw->dwAscent) ));
         ShowCaret(hwnd);
         return 0;
       case WM_KEYDOWN:
         HideCaret(hwnd);
         switch(wParam) {
           case VK_LEFT:
               nCur--;
               ixText -= CharWidth(Instr[nCur]);
               break;
           case VK_RIGHT:
               ixText += CharWidth(Instr[nCur]);
               nCur++;
               break;
           case VK_HOME:
               ixText = 0;
               nCur = 0;
               break;
           case VK_END:
               ixText = LenLine;
               nCur = lStr;
               break;
           case VK_INSERT:
                insert = -insert;
                break;
           case VK_DELETE:
/*             Clear the old tail of the string            */
                          { COLORREF CurTextCol;
                            CurTextCol = SetTextColor(CurrentDC,GetBkColor(CurrentDC));
                            TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
                            SetTextColor(CurrentDC,CurTextCol);
                          }
/*           Reduce current lenght of string               */
                   LenLine -= CharWidth(Instr[nCur]);

                    for (i=nCur; i<lStr;i++)
                      Instr[i] = Instr[i+1];
                    lStr = max(lStr-1, nCur);
                    if (lStr != nCur)
                       TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
                else
                    Beep(1000L,100L);
                 break;

           case VK_BACK:
               nCur--;
               if (nCur >= 0) {
/*             Clear the old tail of the string            */
                    ixText -= CharWidth(Instr[nCur]);
                    { COLORREF CurTextCol;
                      CurTextCol = SetTextColor(CurrentDC,GetBkColor(CurrentDC));
                      TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
                      SetTextColor(CurrentDC,CurTextCol);
                    }
/*             Reduce current lenght of string               */
                   LenLine -= CharWidth(Instr[nCur]);

                    for (i=nCur; i<lStr;i++)
                      Instr[i] = Instr[i+1];
                    lStr = max(lStr-1, nCur);
                    if (lStr != nCur)
                       TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
               } else {
                 Beep(1000L,100L);
                 nCur = 0;
               }
               break;
        default:
              return  DefWindowProc(hwnd,uMsg, wParam, lParam);
         }
        SetCaretPos(ixg(ixText),iyg(iyText-(cHw->dwAscent)));
        ShowCaret(hwnd);
        return 0;  // User procedure SHOULD return ZERO if it is process
       case IX11_HIGZ_Input:
           lpHIGZText = lParam;
 /*       Write  TEXT to the pointed position on the screen */
           ix0 =  lpHIGZText->x;
           iy0 =  lpHIGZText->y;
           ixText = 0;
           iyText = 0;
/*        Init of string input                 */
          lpInstr = lpHIGZText->text;
          nCur    = 0;
          lStr    = 0;
          insert  = 1;

          if (lpHIGZText->len_tex >0 ) {
            Instr = malloc(lpHIGZText->len_tex);
            Instr[0] = 0x0;
          }
          LenLine = 0;


/*         Create and set Caret             */

           CreateCaret(hwnd, (HBITMAP) 1, cHw->dwCharX, cHw->dwAscent);
           SetCaretPos(ixg(ixText),iyg(iyText-(cHw->dwAscent)));
           ShowCaret(hwnd);

           SetFocus(hwnd);
           ConWindow = SetActiveWindow(hwnd);

           cHw->SetTextInput = TRUE;

           break;
       default: break;
     }
   }


/*___________________________________________________________________*/
/*      SUBROUTINE IGERR(ERRTEX,RNAME)
*.===========>
*.
*.   This prints on the screen the error message (ERRTEX) and
*. the routine name (RNAME). This routine sets also IQUEST(1)
*. to 1. If RNAME equal ' ' only a warning is printed and
*. IQUEST(1) is sets to 0.
*.
*. _Input parameters:
*.
*.  INTEGER ERRTEX : Error text .
*.  CHARACTER RNAME : Routine name .
*.
*.
*/

 void _stdcall igerr(errtex,rname,lerr,lname)
   char *errtex, *rname;
   int lerr, lname;
   {
    struct {
        int iquest[100];
    } quest_;

#define quest_1 quest_

     LPCTSTR lpszText;  /* address of text in message box       */
     LPCTSTR lpszTitle; /* address of title of message box      */
     lpszText = malloc(lerr);
     strcpy(lpszText,string(errtex,lerr));
     if (lname <= 1 & rname[0] == ' ') {
     /* This is a warning message */
       lpszTitle = malloc(15);
       strcpy(lpszTitle,"*** Warning ***");
       MessageBox(NULL, lpszText, lpszTitle,
                  MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
       quest_1.iquest[0] = 0;
     }
     else {
     /* This is an error message */
       lpszTitle = malloc(lname+18);
       strcpy(lpszTitle,"*** ERROR in ");
       strcat(lpszTitle,string(rname,lname));
       strcat(lpszTitle," ***");
       MessageBox(NULL, lpszText, lpszTitle,
                  MB_OK | MB_SETFOREGROUND | MB_ICONHAND);
       quest_1.iquest[0] = 1;
     }
     free(lpszTitle);
     free(lpszText);
   }

/*___________________________________________________________________*/
 wrtlst(wid, mess, lmess)
 HWND *wid;
 char *mess;
 int *lmess;
 {
   SendMessage(*wid,LB_ADDSTRING,0, (LPARAM) string(mess,*lmess));
 }

/*___________________________________________________________________*/
 clrlst(wid)
 HWND *wid;
 {
   int n;
   if (n = SendMessage(*wid,LB_GETCOUNT,0,0)   !=   LB_ERR)
           SendMessage(*wid,LB_DELETESTRING,(WPARAM) n, 0);
 }

  ixbord()
  {bord = ~bord;}

/*__________________________________________________________________*/
  void ixldgif (x0, y0, len, file, lenfile )
  char *file;
  int lenfile;
  int *len;
  int *x0,*y0;
  { }
 
/*__________________________________________________________________*/
  void ixdogif( len,
          file, lenfile )
  char *file;
  int lenfile;
  int *len;
  { }

+DECK,  IX_HIGZ_DEF_D, T=DATA, IF=DOC.
LIBRARY IX_HIGZ

EXPORTS

 IGERR
 WRLST
 CLRLST
 IXBORD
 IXCLIP
 IXCLRWI
 IXCLSDS
 IXCLSWI
 IXFLARE
 IXGETGE
 IXGETPL
 IXGETHT
 IXLINE
 IXMARKE
 IXNOCLI
 IXOPNDS
 IXOPNWI
 IXREQLO
 IXREQST
 IXSELWI
 IXSETCO
 IXSETFC
 IXSETFS
 IXSETLC
 IXSETLN
 IXSETLS
 IXSETMC
 IXSETMS
 IXSETTA
 IXSETTC
 IXSETTF
 IXTEXT
 IXUPDWI
 IXBOX
 IXTXTL
 IXDRMDE
 IXSYNC
 IXSETHN
 IXOPNPX
 IXCLPX
 IXCPPX
 IXRMPX
 IXWIPX
 IXCLRPX
 IXS2BUF
 IXQ2BUF
 IXWRPX
 IXRSIZ
 IXSAVWI
 IXSETWI
 IXRSCWI
 IXMINIT
 IXCA
 IXLDGIF
 IXDOGIF
 IGXMES
 ixmotif
+DECK,  IX_WIN32, T=CC.
#include <windows.h>
#include <math.h>
+CDE, IX_WIN32.

#define ColorOffset 20
#define HIGZColorIndex(ic) PALETTEINDEX(ic+ColorOffset)

/* #include <f2c.h>  */  // +SEQ, F2C.
#define IX11_HIGZ_Input IX11_HIGZ_MSG+1
enum ListDC { offWindowDC, offHistoryDC, offPixmapDC, offMetafileDC, offPixBuffer,
              Number_of_DC_Handle,
              offClipWindowDC,offClipHistoryDC,offClipPixmapDC,
              offClipMetafileDC,
              LastExtraMember};

 static struct HIGZWindow *cHw = NULL,         // Current HIGZ Window
                          *fHw = NULL,         // First HIGZ Window
                          *lHw = NULL,         // Last  HIGZ Window
                          *lpHpixmap = NULL;   // Current pixmap
 static int Number_of_HIGZ_Windows = 0;        // Total numaber of the HIGZ
                                               // Windows


/*___________________________________________________________________*/
/*      X11 output primitives
**
**          HIGZ_Primitive
*/

enum    L_HIGZ_Primitive
     {
        IX_LINE ,      // Draw a line through all points
        IX_MARKE,      // Draw a marker ar each point
        IX_FLARE,      // Fill area described by polygon
        IX_BOX  ,      // Draw a box
        IX_CA          // Draw a cell array
     };

/*      X11 text
**
**          HIGZ_Text
*/

enum    L_HIGZ_Text
     {
        IX_TEXT,       // Draw a text string using the current font
        IX_TXTL,       // Return the width and height of character string in the current font
        IW_SETCH       // Set a height for the charatcter
     };


/*     X11 output attributes
**
**          HIGZ_Attribute
*/

enum    L_HIGZ_Attribute
     {
        IX_SETCO,      // Set color intensities for given colour index
        IX_SETLN,      // Set line width
        IX_SETLS,      // Set line style
        IX_SETLC,      // Set colour index for lines
        IX_DRMDE       // Set drawing mode
     };

/*     X11 marker style
**
**       HIGZ_Marker
*/

enum    L_HIGZ_Marker
     {
        IX_SETMS,      // Set market style
        IX_SETMC,      // Set colour indx for markers
        IX_SETFS,      // Set fill area style
        IX_SETFC,      // Set colour index for fill area

        IX_SETTA,      // Set text alignment
        IX_SETTF,      // Set text font to specified name
        IX_SETTC,      // Set colour index for text
        IX_SYNC ,      // X11 synchronization
     };


/*     X11 input functions
**
**         HIGZ_Input
 */

enum    L_HIGZ_Input
     {
        IX_REQLO,      // Request locator input.
        IX_REQST       // Request a string input
     };


/*      X11 inquiry routines
**
**         HIGZ_Inquiry
 */

enum     L_HIGZ_Inquiry
      {
        IX_GETGE,      // Returns position and size of Window
        IX_GETWI,      // Returns the X11 window identifier
        IX_GETPL,      // Returns the maximal number of planes of the display
        IX_GETCOL      // Returns the X11 colour representation
      };


/*      Pixmap manipulation
**
**         HIGZ_Pixmap
 */

enum    L_HIGZ_Pixmap
     {
        IX_OPNPX,      // Open a new pixmap
        IX_CLPX ,      // Close the current opened pixmap
        IX_CPPX ,      // Copy the pixmap
        IX_CLRPX,      // Clear the pixmap
        IX_RMPX ,      // Remove the pixmap
        IX_WRPX ,      // Write the pixmap
        IX_WIPX        // Copy the area in the current window
     };


/*             Dummies
**
**           HIGZ_Dummies
 */

enum    L_HIGZ_Dummies
     {
        IX_S2BUF,
        IX_SDSWI
     };

#define WndActHeader( arg )  LRESULT APIENTRY \
                   Wnd_(arg) (hwnd, uMsg, wParam, lParam) \
                   HWND  hwnd; UINT   uMsg; WPARAM wParam; LPARAM lParam;

/*-- Author : V.Fine */
/*
 * Fortran interface to Window/NT SDK routines for HIGZ
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>



+SELF, IF=QX_SC..
#define igerr   igerr_
#define wrtlst  wrtlst_
#define clrlst  clrlst_
#define ixbord  ixbord_



#define ixclip  ixclip_
#define ixclrwi ixclrwi_
#define ixclsds ixclsds_
#define ixclswi ixclswi_
#define ixflare ixflare_
#define ixgetge ixgetge_
#define ixgetpl ixgetpl_
#define ixgetht ixgetht_
#define ixline  ixline_
#define ixmarke ixmarke_
#define ixnocli ixnocli_
#define ixopnds ixopnds_
#define ixopnwi ixopnwi_
#define ixreqlo ixreqlo_
#define ixreqst ixreqst_
#define ixselwi ixselwi_
#define ixsetco ixsetco_
#define ixsetfc ixsetfc_
#define ixsetfs ixsetfs_
#define ixsetlc ixsetlc_
#define ixsetln ixsetln_
#define ixsetls ixsetls_
#define ixsetmc ixsetmc_
#define ixsetms ixsetms_
#define ixsetta ixsetta_
#define ixsettc ixsettc_
#define ixsettf ixsettf_
#define ixtext  ixtext_
#define ixupdwi ixupdwi_
#define ixbox   ixbox_
#define ixtxtl  ixtxtl_
#define ixdrmde ixdrmde_
#define ixsync  ixsync_
#define ixsethn ixsethn_
#define ixopnpx ixopnpx_
#define ixclpx  ixclpx_
#define ixcppx  ixcppx_
#define ixrmpx  ixrmpx_
#define ixwipx  ixwipx_
#define ixclrpx ixclrpx_
#define ixs2buf ixs2buf_
#define ixq2buf ixq2buf_
#define ixwrpx  ixwrpx_
#define ixrsiz  ixrsiz_
#define ixsavwi ixsavwi_
#define ixsetwi ixsetwi_
#define ixrscwi ixrscwi_
#define ixminit ixminit_
#define ixca    ixca_
+SELF.

+SELF, IF=QXCAPT..
#define igerr   IGERR
#define wrtlst  WRLST
#define clrlst  CLRLST
#define ixbord  IXBORD



#define ixclip  type_of_call IXCLIP
#define ixclrwi type_of_call IXCLRWI
#define ixclsds type_of_call IXCLSDS
#define ixclswi type_of_call IXCLSWI
#define ixflare type_of_call IXFLARE
#define ixgetge type_of_call IXGETGE
#define ixgetpl type_of_call IXGETPL
#define ixgetht type_of_call IXGETHT
#define ixline  type_of_call IXLINE
#define ixmarke type_of_call IXMARKE
#define ixnocli type_of_call IXNOCLI
#define ixopnds type_of_call IXOPNDS
#define ixopnwi type_of_call IXOPNWI
#define ixreqlo type_of_call iXREQLO
#define ixreqst type_of_call IXREQST
#define ixselwi type_of_call IXSELWI
#define ixsetco type_of_call IXSETCO
#define ixsetfc type_of_call IXSETFC
#define ixsetfs type_of_call IXSETFS
#define ixsetlc type_of_call IXSETLC
#define ixsetln type_of_call IXSETLN
#define ixsetls type_of_call IXSETLS
#define ixsetmc type_of_call IXSETMC
#define ixsetms type_of_call IXSETMS
#define ixsetta type_of_call IXSETTA
#define ixsettc type_of_call IXSETTC
#define ixsettf type_of_call IXSETTF
#define ixtext  type_of_call IXTEXT
#define ixupdwi type_of_call IXUPDWI
#define ixbox   type_of_call IXBOX
#define ixtxtl  type_of_call IXTXTL
#define ixdrmde type_of_call IXDRMDE
#define ixsync  type_of_call IXSYNC
#define ixsethn type_of_call IXSETHN
#define ixopnpx type_of_call IXOPNPX
#define ixclpx  type_of_call IXCLPX
#define ixcppx  type_of_call IXCPPX
#define ixrmpx  type_of_call IXRMPX
#define ixwipx  type_of_call IXWIPX
#define ixclrpx type_of_call IXCLRPX
#define ixs2buf type_of_call IXS2BUF
#define ixq2buf type_of_call IXQ2BUF
#define ixwrpx  type_of_call IXWRPX
#define ixrsiz  type_of_call IXRSIZ
#define ixsavwi type_of_call IXSAVWI
#define ixsetwi type_of_call IXSETWI
#define ixrscwi type_of_call IXRSCWI
#define ixminit type_of_call IXMINIT
#define ixca    type_of_call IXCA
+SELF.

/* #define ixmotif ixmotif_ */
/* +SELF. */

#define forever while(1)
#define LNULL 0L

#define XPoint POINT             /* Change Xpoint by X11 to POINT by Windows/NT */

#define MAXWN 20                 /* maximum number of windows                 */
static struct {
  int      open;                 /* 1 if the window is open, 0 if not         */
  int      motif;                /* 1 if the window is a motif window         */
  int      double_buffer;        /* 1 if the double buffer is on, 0 if not    */
  int width;                     /* width of the window                       */
  int height;                    /* height of the window                      */
  int clip;                      /* 1 if the clipping is on                   */
  int xclip;                     /* x coordinate of the clipping rectangle    */
  int yclip;                     /* y coordinate of the clipping rectangle    */
  int wclip;                     /* width of the clipping rectangle           */
  int hclip;                     /* height of the clipping rectangle          */

  LOGPEN    pen;       /*********    */
  LOGBRUSH  gcfill;
  LOGFONT   font;
  LOGPALETTE palette;
  BITMAP   pixmap;

} windows[MAXWN],                /* windows : list of the opened windows      */
  *cws, *tws, *sws;              /* cws : pointer to the current window       */

#define MAXCOL 256
  static int maxcol;

  struct HIGZPEN {
                   LOGPEN   pen;
                   LOGBRUSH brush;
                   int      lUserDash;
                   int      *UserDash;
                 } pen = { BS_SOLID,0, 0, 1,    //  lopnStyle, lopnWidth, lopnColor
                           BS_SOLID,   0, 0, //  lbStyle, lbColor, lbHatch
                           0, NULL};         //  n dashes, pointer to an array of dashes
  LOGBRUSH  gcfill;

  LOGFONT   HIGZFont = { 0,   // lfHeight
                         0,   // lfWidth
                         0,   // lfEscapement
                         0,   // lfOrientation (doesn't used by HIGZ)
                       400,   // lfWeigh  (Normal = 400, BOLD =800)
                     FALSE,   // lfItalic
                     FALSE,   // lfUnderline
                     FALSE,   // lfStrikeOut
              ANSI_CHARSET,   // lfCharSet
        OUT_DEFAULT_PRECIS,   // lfOutPrecision
       CLIP_DEFAULT_PRECIS,
           DEFAULT_QUALITY,
               FF_DONTCARE,   // lfPitchAndFamily;
                      };
  PALETTEENTRY HIGZcolors[MAXCOL];
  NPLOGPALETTE lpPalette; // =  {0x300, MAXCOL, HIGZcolors};
  BOOLEAN bord = {FALSE};


/*         Global variable to plot HIGZ graphics cursor */
     static RECT rect;
     static HPEN   CurPen;
     static HBRUSH CurBrush;
     static HRGN CurClipRgn;
/* ==================================================== */

/*   Common HANDLES of the graphics attributes for all HIGZ windows */

static HPALETTE hdCommonPalette = NULL;
static HBRUSH   hdCommonBrush   = NULL;
static HPEN     hdCommonPen     = NULL;
static HFONT    hdCommonFont    = NULL;
static HPEN     hdCursorPen;     // Pen to draw HIGZ locator
static HBRUSH   hdCursorBrush;   // Brush to draw HIGZ locator 3 or 5
static RECT     CommonClipRectangle;
static int      dwCommonTextAlign = TA_LEFT | TA_BASELINE;
static COLORREF dwCommonTextColor;
static BOOL     PixMapON = {FALSE};

     int ixText,iyText;
     static HWND ConWindow; //  Handler of console window

/* ==================================================== */


/* =================== */
static int ispix = 0;            /* if ispix=1 a pixmap has been opened       */

static char hname[132];          /* host name                                 */

static int external_int = 0;

static int do_raise = 0;         /* if do_raise =1 cws is raised in ixupdwi   */


/*  External variables for Windows/NT  */ // V.E. Fine 21.07.93

WNDCLASS *p_higz_display, higz_display;

HWND CurrentHIGZWindow;
HDC CurrentDC, MetaFileDC, HistoryDC;

/*  LOGPALLETE HIGZ_palette[MAXCOL];
    HPALETTE WindowPalette;
 */


/*
 * colors[1]           : foreground also used for b/w screen
 * colors[0]           : background also used for b/w screen
 * colors[2..MAXCOL-1] : colors which can be set by IXSETCO
 */
static int colored;             /* Flag if color screen                      */

static struct {
  int defined;
  unsigned long pixel;
  float red;
  float green;
  float blue;
} colors[MAXCOL] = {0, 0, 1., 1., 1.};

/*
 * Primitives Graphic Contexts global for all windows
 */

/*
 * Input echo Graphic Context global for all windows
 */

static int fill_hollow;                     /* Flag if fill style is hollow   */
static int current_fasi = 0;                /* Current fill area style index  */
static int align_hori = -1;                 /* Align text left, center, right */
static int align_vert = -1;                 /* Align text bottom, middle, top */


static int current_font_number = 0;         /* current font number in font[]  */


/*
 * data to create fill area interior style
 */
static char p1_bits[] = {
   ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55),
   ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55),
   ~(0xaa), ~(0xaa), ~(0x55), ~(0x55), ~(0xaa), ~(0xaa), ~(0x55), ~(0x55)};
static char p2_bits[] = {
   ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11),
   ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11),
   ~(0x44), ~(0x44), ~(0x11), ~(0x11), ~(0x44), ~(0x44), ~(0x11), ~(0x11)};
static char p3_bits[] = {
   ~(0x00), ~(0x00), ~(0x44), ~(0x44), ~(0x00), ~(0x00), ~(0x11), ~(0x11), ~(0x00), ~(0x00), ~(0x44), ~(0x44),
   ~(0x00), ~(0x00), ~(0x11), ~(0x11), ~(0x00), ~(0x00), ~(0x44), ~(0x44), ~(0x00), ~(0x00), ~(0x11), ~(0x11),
   ~(0x00), ~(0x00), ~(0x44), ~(0x44), ~(0x00), ~(0x00), ~(0x11), ~(0x11)};
static char p4_bits[] = {
   ~(0x80), ~(0x80), ~(0x40), ~(0x40), ~(0x20), ~(0x20), ~(0x10), ~(0x10), ~(0x08), ~(0x08), ~(0x04), ~(0x04),
   ~(0x02), ~(0x02), ~(0x01), ~(0x01), ~(0x80), ~(0x80), ~(0x40), ~(0x40), ~(0x20), ~(0x20), ~(0x10), ~(0x10),
   ~(0x08), ~(0x08), ~(0x04), ~(0x04), ~(0x02), ~(0x02), ~(0x01), ~(0x01)};
static char p5_bits[] = {
   ~(0x20), ~(0x20), ~(0x40), ~(0x40), ~(0x80), ~(0x80), ~(0x01), ~(0x01), ~(0x02), ~(0x02), ~(0x04), ~(0x04),
   ~(0x08), ~(0x08), ~(0x10), ~(0x10), ~(0x20), ~(0x20), ~(0x40), ~(0x40), ~(0x80), ~(0x80), ~(0x01), ~(0x01),
   ~(0x02), ~(0x02), ~(0x04), ~(0x04), ~(0x08), ~(0x08), ~(0x10), ~(0x10)};
static char p6_bits[] = {
   ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44),
   ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44),
   ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44), ~(0x44)};
static char p7_bits[] = {
   ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0xff), ~(0xff), ~(0x00), ~(0x00), ~(0x00), ~(0x00),
   ~(0x00), ~(0x00), ~(0xff), ~(0xff), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0xff), ~(0xff),
   ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0x00), ~(0xff), ~(0xff)};
static char p8_bits[] = {
   ~(0x11), ~(0x11), ~(0xb8), ~(0xb8), ~(0x7c), ~(0x7c), ~(0x3a), ~(0x3a), ~(0x11), ~(0x11), ~(0xa3), ~(0xa3),
   ~(0xc7), ~(0xc7), ~(0x8b), ~(0x8b), ~(0x11), ~(0x11), ~(0xb8), ~(0xb8), ~(0x7c), ~(0x7c), ~(0x3a), ~(0x3a),
   ~(0x11), ~(0x11), ~(0xa3), ~(0xa3), ~(0xc7), ~(0xc7), ~(0x8b), ~(0x8b)};
static char p9_bits[] = {
   ~(0x10), ~(0x10), ~(0x10), ~(0x10), ~(0x28), ~(0x28), ~(0xc7), ~(0xc7), ~(0x01), ~(0x01), ~(0x01), ~(0x01),
   ~(0x82), ~(0x82), ~(0x7c), ~(0x7c), ~(0x10), ~(0x10), ~(0x10), ~(0x10), ~(0x28), ~(0x28), ~(0xc7), ~(0xc7),
   ~(0x01), ~(0x01), ~(0x01), ~(0x01), ~(0x82), ~(0x82), ~(0x7c), ~(0x7c)};

BITMAP FillBitMap = { 0,   // Specifies the bitmap type. This member must be zero
                     16,   // Specifies the width, in pixel, of the bitmap
                     16,   // Specifies the height, in pixel, of the bitmap
                      2,   // Specifies the number of bytes in each scan line.
                      1,   // Specifies the count of color planes.
                      1,   // Specifies the number of bits required to ind. th color
                &p2_bits   // points to the location of the bit values for the bitmap
                    };

#define MAXMK 100
static struct MARKER {
  int cindex;
  int type;
  int n;
  XPoint xy[MAXMK];
} marker;                        /* point list to draw marker                 */


/*___________________________________________________________________*/
/*
 *    Set input on or off
 */
void
  setinput(inp)
int inp;
{

}


/*___________________________________________________________________*/
/*
 * set the foreground color in GC
 */
void
  setcolor( gc, ci )
int gc;
int ci;
{
  if( colored && ( ci < 0 || ci >= MAXCOL || !colors[ci].defined ) )
    {
     ci = 0;
    }
  else if (!colored && ci < 0 )
    {
     ci = 0;
    }
  else if (!colored && ci > 0 )
    {
     ci = 1;
    }


  /* make sure that foreground and background are different */
}


/*___________________________________________________________________*/
/*
 * return null terminated and blank trimmed string
 */
char*
  string( s, l )
char *s;
int l;
{
  static char str[256];
  int i;

  if( l >= sizeof( str ) )
    l = sizeof( str ) - 1;

  for( i = 0; i < l; i++ )
    str[i] = s[i];
  while( l > 0 && str[l-1] == ' ' )
    l--;

  str[l] = '\0';
  return( str );
}




/*___________________________________________________________________*/
/*
 *    Allows to set the DISPLAY and the WINDOW address
 *    from outside HIGZ (ie a MOTIF program).
 */
void
  ixsdswi( dsp , win )
  int *dsp;
  int win;
{

}

/*___________________________________________________________________*/
/*
 *    Allows KUIP to give to HIGZ the adress of three routines:
 *    1) motif_open  : to open a KUIP motif window
 *    2) motif_init  : to initalize a KUIP motif window (add the callbacks)
 *    3) motif_close : to close a KUIP motif window
 */
void
  ixmotif( dsp , open, init, close)
  int *dsp;
  int (*open)();
  void (*init)();
  void (*close)();
{
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXMINIT(WID)
 *    INTEGER WID : Window ID
 *
 *    Initialize the Motif windows (add the callbacks)
 */
void
  ixminit(wid)
  int *wid;
{
}

/*___________________________________________________________________*/
 LRESULT APIENTRY
         HIGZDrawing(wParam,lParam)
/* Dispatch a drawing operation either to real window or to pixmap */
WPARAM wParam;
LPARAM lParam;
 {
   if (PixMapON){
           DWORD rvalue;
           HGDIOBJ hbr,hpn;

           cHw = lpHpixmap;
           CurrentDC = lpHpixmap->hdcWindow;
           hbr = SelectObject(CurrentDC,hdCommonBrush);
           hpn = SelectObject(CurrentDC,hdCommonPen);

           rvalue = (int) HIGZ_Act(NULL,IX11_HIGZ_MSG,wParam, lParam);
/*                  Restore all attributes                               */
           SelectObject(CurrentDC,hpn);
           SelectObject(CurrentDC,hbr);
           return rvalue;
   }
   else return SendMessage(CurrentHIGZWindow,
                           IX11_HIGZ_MSG,wParam,lParam);
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETHN(LENHST,HOST)
 *    INTEGER LENHST      : host name length
 *    CHARACTER*(*) HOST  : host name
 *
 *    Set host name (fill global variable hname)
 */
void
  ixsethn( lenhst, host )
char *host;
int *lenhst;
{
 strcpy (hname,string( host, *lenhst ));
}


/*___________________________________________________________________*/
  HBITMAP CreateHIGZBuffer(hwnd)
  HWND hwnd;
  {
  HBITMAP hdBuffer,oldbit,hdNewBuffer;
  HDC     hdPixmapDC,hdWindowDC,oldbitDC,hdNewDC;
  SIZE    WindowSize,BufferSize;

     hdPixmapDC = cHw->hdcPixBuffer;
     hdWindowDC = cHw->hdcWindow;
     hdBuffer   = cHw->hbBuffer;

/*  Create New Memory Device context */
     hdNewDC = CreateCompatibleDC(NULL);
     SetMapMode (hdNewDC,MM_ISOTROPIC);
     SetBkMode  (hdNewDC,TRANSPARENT);
/*  Set HIGZ pallete */
     DeleteObject(SelectPalette(hdNewDC,hdCommonPalette,TRUE));
/*  Create a new BITMAP for double buffering  and coordinate transformation  */
     GetWindowExtEx(hdWindowDC,&WindowSize);
     GetViewportExtEx(hdWindowDC,&BufferSize);
     hdNewBuffer = CreateCompatibleBitmap(hdWindowDC,BufferSize.cx,
                                                  BufferSize.cy);
     SetWindowExtEx(hdNewDC,WindowSize.cx,WindowSize.cy,NULL);
     SetViewportExtEx(hdNewDC,BufferSize.cx,BufferSize.cy,NULL);
/*             Set new bitmap                       */
     DeleteObject(SelectObject(hdNewDC,hdNewBuffer));

     if (hdPixmapDC) { /* Copy old bitmap to new one */
        BitBlt(hdNewDC,0,0,WindowSize.cx,WindowSize.cy,
               hdPixmapDC,  0,0,SRCCOPY);
/*  Delete previous buffer */
        DeleteObject(SelectObject(hdPixmapDC,hdNewBuffer));
        DeleteDC(hdPixmapDC);
     }
     else { /*  Clear new bitmap */
         rect.left   = 0;
         rect.right  = WindowSize.cx;
         rect.top    = 0;
         rect.bottom = WindowSize.cy;
         FillRect(hdNewDC,&rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
         DeleteObject(CurBrush);
     }


/*  Set window variable */

     cHw->hdcPixBuffer=hdNewDC;
     cHw->hbBuffer    =hdNewBuffer;
     return cHw->hbBuffer;
  }


/*___________________________________________________________________*/
  HBITMAP FlushHIGZBuffer(hwnd)
  HWND hwnd;
  {
  HBITMAP hdBuffer;
  HDC     hdPixmapDC,hdWindowDC;
  SIZE    WindowSize,BufferSize;

     hdPixmapDC = cHw->hdcPixBuffer;
     hdWindowDC = cHw->hdcWindow;
     hdBuffer   = cHw->hbBuffer;

     if (hdPixmapDC) {
       if (hdBuffer) {
         GetWindowExtEx(hdWindowDC,&WindowSize);

/*    Set an application palette                      */
        SetSystemPaletteUse(hdWindowDC,SYSPAL_NOSTATIC);
        RealizePalette(hdWindowDC);

/*           Hide HIGZCursor                          */
         BitBlt(hdWindowDC,0L,0L,WindowSize.cx,WindowSize.cy,
                hdPixmapDC,0L,0L,SRCCOPY);
/*          Restore HIGZCursor */
/*    Compare size of Window and its Buffer           */
         if (WindowSize.cx  != BufferSize.cx)
/*          One needs change a scale                  */
                            hdBuffer = CreateHIGZBuffer(hwnd);
       }
     }
    return hdBuffer;
  }

/*___________________________________________________________________*/
LRESULT APIENTRY WndHIGZ(hwnd, uMsg, wParam, lParam)
HWND   hwnd;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
{
    PAINTSTRUCT ps;

    cHw = (struct HIGZWindow *)GetWindowLong(hwnd,ExtHIGZWindow);
    if (cHw) CurrentDC = cHw->hdcWindow;

    // HistoryDC = (HDC) GetWindowLong(hwnd,4*offHistoryDC);
    switch (uMsg) {
       case WM_LBUTTONDOWN:
       case WM_MBUTTONDOWN:
       case WM_RBUTTONDOWN:
         if (!cHw->MouseInit) break;
         cHw->MouseInit = 0;
         Wnd_REQLO(hwnd,uMsg,wParam,lParam);
         return 0;
       case WM_MOUSEMOVE:
         SetCursor(cHw->hHIGZCursor);
       case WM_RBUTTONUP:
       case WM_MBUTTONUP:
       case WM_LBUTTONUP:
         if (!cHw->MouseInit)  break;
         Wnd_REQLO(hwnd,uMsg,wParam,lParam);
         return 0;
       case WM_CREATE:
       { int iLoop;
         TEXTMETRIC *tm;
         RECT RectClient;
         HPALETTE hpallete;
         SIZE WindowSize;
         HMENU hmenu;

/* Yin cursor AND bitmask */

BYTE ANDmaskCursor[] =
                       {0xff, 0xfc, 0x7f, 0xff,   /* line 1 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 2 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 3 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 4 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 5 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 6 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 7 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 8 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 9 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 10 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 11 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 12 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 13 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 14 */

                        0x00, 0x00, 0x00, 0x01,   /* line 15 */
                        0x00, 0x00, 0x00, 0x01,   /* line 16 */
                        0x00, 0x00, 0x00, 0x01,   /* line 17 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 18 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 19 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 20 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 21 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 22 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 23 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 24 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 25 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 26 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 27 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 28 */

                        0xff, 0xfc, 0x7f, 0xff,   /* line 29 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 30 */
                        0xff, 0xfc, 0x7f, 0xff,   /* line 31 */

                        0xff, 0xff, 0xff, 0xff};  /* line 32 */

/* Yin cursor XOR bitmask */

BYTE XORmaskCursor[] =
                       {0x00, 0x02, 0x80, 0x00,   /* line 1 */
                        0x00, 0x02, 0x80, 0x00,   /* line 2 */
                        0x00, 0x02, 0x80, 0x00,   /* line 3 */
                        0x00, 0x02, 0x80, 0x00,   /* line 4 */

                        0x00, 0x02, 0x80, 0x00,   /* line 5 */

                        0x00, 0x02, 0x80, 0x00,   /* line 6 */
                        0x00, 0x02, 0x80, 0x00,   /* line 7 */
                        0x00, 0x02, 0x80, 0x00,   /* line 8 */

                        0x00, 0x02, 0x80, 0x00,   /* line 9 */
                        0x00, 0x02, 0x80, 0x00,   /* line 10 */
                        0x00, 0x02, 0x80, 0x00,   /* line 11 */
                        0x00, 0x02, 0x80, 0x00,   /* line 12 */

                        0x00, 0x02, 0x80, 0x00,   /* line 13 */
                        0x00, 0x02, 0x80, 0x00,   /* line 14 */

                        0xFF, 0xFE, 0xFF, 0xFE,   /* line 15 white border */
                        0x00, 0x00, 0x00, 0x00,   /* line 16 black cross  */
                        0xFF, 0xFE, 0xFF, 0xFE,   /* line 17 white border */

                        0x00, 0x02, 0x80, 0x00,   /* line 18 */
                        0x00, 0x02, 0x80, 0x00,   /* line 19 */
                        0x00, 0x02, 0x80, 0x00,   /* line 20 */

                        0x00, 0x02, 0x80, 0x00,   /* line 21 */
                        0x00, 0x02, 0x80, 0x00,   /* line 22 */

                        0x00, 0x02, 0x80, 0x00,   /* line 23 */
                        0x00, 0x02, 0x80, 0x00,   /* line 24 */

                        0x00, 0x02, 0x80, 0x00,   /* line 25 */
                        0x00, 0x02, 0x80, 0x00,   /* line 26 */
                        0x00, 0x02, 0x80, 0x00,   /* line 27 */
                        0x00, 0x02, 0x80, 0x00,   /* line 28 */

                        0x00, 0x02, 0x80, 0x00,   /* line 29 */
                        0x00, 0x02, 0x80, 0x00,   /* line 30 */
                        0x00, 0x02, 0x80, 0x00,   /* line 31 */

                        0x00, 0x00, 0x00, 0x00};  /* line 32 */

/* Create a custom cursor at run time. */

HCURSOR hCursor = CreateCursor(
      (HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE),  /* app instance          */
                               15,     /* horiz pos of hot spot */
                               15,     /* vert pos of hot spot  */

                               32,     /* cursor width          */
                               32,     /* cursor height         */
                     ANDmaskCursor,    /* AND bitmask           */
                     XORmaskCursor);   /* XOR bitmask           */

/*
 *
 * AND	XOR	Display
 *
 * 0	 0 	 Black
 * 0	 1	 White
 * 1	 0	 Screen
 * 1	 1	 Reverse screen
 *
 */


/* Disable the Close postion in the System Menu */
         hmenu = GetSystemMenu(hwnd,FALSE);
         EnableMenuItem(hmenu,6 , MF_GRAYED | MF_BYPOSITION);

/* Create Extended data block                */
          cHw = malloc(sizeof(HIGZWindow));
         /*  Insert in dadata chain */
          if (fHw == NULL) {
             fHw = cHw;
             cHw->ptbw =  NULL;
           }
           else {
             lHw->ptfw = cHw;
             cHw->ptbw = lHw;
           }

/* Initial fill the data structure in */
           cHw->WinType = 0;
           cHw->ptfw                = NULL;
           cHw->hwnd                = hwnd;
           cHw->hdcWindow           = GetDC(hwnd);
           cHw->hdcPixBuffer        = (HDC) NULL;
           cHw->HIGZClipRegion      = (HRGN)NULL;
           cHw->HIGZCursor          = FALSE;
           cHw->SystemCursorVisible = TRUE;
           cHw->MouseInit           = 0;
           cHw->SetTextInput        = FALSE;
           cHw->loc.x = 0; cHw->loc.y=0; cHw->locp.x=0; cHw->locp.y=0;
           cHw->isopening = FALSE;
           cHw->hHIGZCursor = hCursor;

           SetWindowLong(hwnd,ExtHIGZWindow,(LONG)cHw);

           lHw = cHw;
           Number_of_HIGZ_Windows++;

           CurrentDC = cHw->hdcWindow;

           /* Create caret to character input */

             tm = malloc(sizeof(TEXTMETRIC));
             GetTextMetrics(CurrentDC,tm);
             cHw->dwCharX = tm->tmAveCharWidth;
             cHw->dwCharY = tm->tmHeight;
             cHw->dwAscent= tm->tmAscent;
             free(tm);

             SetMapMode    (CurrentDC,MM_ISOTROPIC);
             RectClient.left   = 0;
             RectClient.top    = 0;
             RectClient.right  = 1023;
             RectClient.bottom = 1023;

 /*          Create HistoryDC (memory MetaFile) DC to perform PAINT operation          */

//             HistoryDC = CreateEnhMetaFile(CurrentDC,"META.emf",&RectClient,NULL);
             HistoryDC = 0;
             if (HistoryDC) cHw->hdcHistory =HistoryDC;

             SetWindowExtEx(CurrentDC,
                                         RectClient.right+1,
                                         RectClient.bottom+1,
                                         NULL);
             SetBkMode(CurrentDC,TRANSPARENT);
             SetTextAlign(CurrentDC,
                          TA_BASELINE | TA_LEFT | TA_NOUPDATECP);
             if (HistoryDC)
               {
                 SetMapMode    (HistoryDC,MM_ISOTROPIC);
 /*                SetWindowExtEx(HistoryDC,
                                         RectClient.right+1,
                                         RectClient.bottom+1,
                                         NULL);
  */               SetBkMode(HistoryDC,TRANSPARENT);
                 SetTextAlign(CurrentDC,
                              TA_BASELINE | TA_LEFT | TA_NOUPDATECP);
               }
             GetClientRect(hwnd,&RectClient);
             SetViewportExtEx (CurrentDC,
                                         RectClient.right,
                                         RectClient.bottom,
                                         NULL);
             GetClientRect(hwnd,&(cHw->HIGZWindowSize));
             DPtoLP(CurrentDC,(POINT*) (&(cHw->HIGZWindowSize)),2);

          if (hdCommonPalette == NULL) {
 /* Allocate enough memory for a logical palette with
               * PALETTESIZE entries and set the size and version fields
               * of the logical palette structure.
               */
              maxcol = GetDeviceCaps(CurrentDC,SIZEPALETTE);
              lpPalette = (NPLOGPALETTE) malloc((sizeof (LOGPALETTE) +
                                                (sizeof (PALETTEENTRY) * (maxcol))));

          if(!lpPalette){
            MessageBox(hwnd, "<WM_CREATE> Not enough memory for palette.", NULL, MB_OK | MB_ICONHAND);
                PostQuitMessage (0) ;
            break;
          }

              lpPalette->palVersion    = 0x300;
              lpPalette->palNumEntries = maxcol;

              /* fill in intensities for all palette entry colors */
              GetSystemPaletteEntries(CurrentDC,0,20, lpPalette->palPalEntry);

              /*  create a logical color palette according the information
               *  in the LOGPALETTE structure.
               */
              hdCommonPalette = CreatePalette ((LPLOGPALETTE) lpPalette);
        }

              DeleteObject(SelectPalette(CurrentDC,hdCommonPalette,TRUE));
              if (HistoryDC) DeleteObject(SelectPalette(HistoryDC,hpallete,TRUE));


             return 0;

          }
       case WM_PAINT:
            if (BeginPaint(hwnd,&ps)) {
              HDC hdc;
              ENHMETAHEADER mfHeader;
              HENHMETAFILE  hmf,hmfOld;
              HRGN TempClip;
              RECT rect;

/*             Close History Metafile and create a new one  and play old   */
//             hdc=(HDC)GetWindowLong(hwnd,4*offHistoryDC);

             SetSystemPaletteUse(CurrentDC,SYSPAL_NOSTATIC);
             RealizePalette(CurrentDC);
/*    Hide HIGZ mouse locator  and text caret   */
             if (!cHw->isopening)
               if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);
             else cHw->isopening = FALSE;
             if (cHw->SetTextInput) HideCaret(hwnd);
             FlushHIGZBuffer(hwnd);
/*    Restore HIGZ mouse locator and text caret */
             if (cHw->SetTextInput) ShowCaret(hwnd);
             if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);

             hdc = HistoryDC;
             if (hdc) {
/*             Get Old metafile                                            */
                hmf = CloseEnhMetaFile(hdc);
                printf("PAINT ==>  hmf  is %x   with error code %d  \n", hmf, GetLastError());

/*             Create new metafile                                         */
                GetEnhMetaFileHeader(hmf,sizeof(ENHMETAHEADER),&mfHeader);
                printf("==> PAINT:   Rectangle retrivied by GetEnh %d %d %d %d  Error code is %d \n",
                mfHeader.rclFrame.top,mfHeader.rclFrame.right,
                mfHeader.rclFrame.left,mfHeader.rclFrame.bottom, GetLastError());

                 HistoryDC = CreateEnhMetaFile(ps.hdc,NULL,&(mfHeader.rclFrame),NULL);
                 printf(" PAINT, CreateEnh HistoryDC = %x \n", HistoryDC);

               cHw->hdcHistory = HistoryDC;
/*             Play Old metafile in new one and ti window                  */
                GetClientRect(hwnd,&rect);
                DPtoLP(ps.hdc,&rect,2);
                printf("New rectangle will be %d %d %d %d \n",rect.top, rect.left,rect.bottom,rect.right);

//                 PlayEnhMetaFile(HistoryDC,hmf,&rect);

/*                        Set clipping temporary for PAINT arear           */
 //              TempClip = SelectClipRgn(ps.hdc,
//                                       CreateRectRgnIndirect(&ps.rcPaint));

           SetSystemPaletteUse(CurrentDC,SYSPAL_NOSTATIC);
           RealizePalette(CurrentDC);
               PlayEnhMetaFile(ps.hdc,hmf,&rect);

/*                       Restore clip region                               */
//               SelectClipRgn(ps.hdc,TempClip);

/*             Delete Old metafile                                         */
                DeleteEnhMetaFile(hmf);
               }

              EndPaint(hwnd, &ps);
            }

            return  DefWindowProc(hwnd,uMsg, wParam, lParam);
       case WM_ERASEBKGND:
          {
            HRGN TempClip;
/*            Cancel  clipping temporary                                   */
            if (cHw->HIGZClipRegion)
                TempClip = SelectClipRgn((HDC)wParam,NULL);
/*    Hide HIGZ mouse locator */
            if (!cHw->isopening)
              if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);
            else cHw->isopening = FALSE;
              GetClientRect(hwnd,&rect);
              DPtoLP(CurrentDC,&rect,2);
              FillRect(CurrentDC,&rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
              DeleteObject(CurBrush);
//            DefWindowProc(hwnd,uMsg, wParam, lParam);
/*    Restore HIGZ mouse locator */
            if (cHw->MouseInit) DrawHIGZCursor(cHw->MouseInit);
            if (cHw->HIGZClipRegion)
                TempClip = SelectClipRgn((HDC)wParam,TempClip);
            return TRUE;
//            return FALSE // Window will remain marked for erasing
          }
       case WM_SIZE:

/* WM_SIZE
 * fwSizeType = wParam;     -  resizing flag
 * nWidth = LOWORD(lParam); -  width of client area
 *nHeight = HIWORD(lParam); -  height of client area
 */
           SetViewportExtEx(CurrentDC, LOWORD(lParam), HIWORD(lParam), NULL);
           cHw->HIGZWindowSize.right = LOWORD(lParam);
           cHw->HIGZWindowSize.bottom = HIWORD(lParam);
           DPtoLP(CurrentDC,(POINT*) (&(cHw->HIGZWindowSize)),2);
           return 0;
  /*           return DefWindowProc(hwnd,uMsg, wParam, lParam); */
       case WM_SETFOCUS:
           if (!cHw->SetTextInput) break;
               CreateCaret(hwnd, (HBITMAP) 1, cHw->dwCharX, cHw->dwAscent);
               SetCaretPos(ixText, iyText);
               ShowCaret(hwnd);
               return 0;
       case WM_KILLFOCUS:

        /*
         *   Hide and destroy the caret when the window loses
         *   keyboard focus
         */

           if (!cHw->SetTextInput) break;
               HideCaret(hwnd);
               DestroyCaret();
               return 0;
       case WM_CHAR:
           if (cHw->SetTextInput) return Wnd_REQST(hwnd, uMsg, wParam, lParam);
           break;
       case WM_KEYDOWN:
           if      (cHw->MouseInit)    Wnd_REQLO(hwnd, uMsg, wParam, lParam);
           else if (cHw->SetTextInput) Wnd_REQST(hwnd, uMsg, wParam, lParam);
           break;
       case WM_QUERYOPEN:
           cHw->isopening = TRUE;
           break;
       case WM_DESTROY:
           DeleteDC(CurrentDC);
           DestroyCursor(cHw->hHIGZCursor);  /* 3.06.94 */
           if (HistoryDC)  CloseEnhMetaFile(HistoryDC);
           break;
//           return 0;

       case IX11_HIGZ_MSG:
          {
           DWORD rvalue;
           HGDIOBJ hbr,hpn;
           HDC hdc;
/*   Set double buffering DC */
           if (cHw->hdcPixBuffer)
                CurrentDC = cHw->hdcPixBuffer;
           SetSystemPaletteUse(CurrentDC,SYSPAL_NOSTATIC);
           RealizePalette(CurrentDC);
           hbr = SelectObject(CurrentDC,hdCommonBrush);
           hpn = SelectObject(CurrentDC,hdCommonPen);

           rvalue = (DWORD)HIGZ_Act(hwnd,uMsg, wParam, lParam);
/*                  Restore all attributes                               */
           SelectObject(CurrentDC,hpn);
           SelectObject(CurrentDC,hbr);
           return rvalue;
          }
       case IX11_HIGZ_Input:
          {
           switch (LOWORD(wParam)) {
             case IX_REQLO:
                Wnd_REQLO(hwnd,uMsg, wParam, lParam);
                break;
             case IX_REQST:      // Request a string input
                Wnd_REQST(hwnd, uMsg, wParam, lParam);
                break;
             default:
                break;
           }
          }
       default:
               break;
    }
    return DefWindowProc(hwnd,uMsg, wParam, lParam);
}

/*___________________________________________________________________*/
LPTHREAD_START_ROUTINE HIGZ_MsgLoop(ThrSem)
 HANDLE ThrSem;
 {
   MSG msg;
   HWND hwndHIGZ;
   int value;
   struct CREATEHIGZWINDOW *WinThr;

   ReleaseSemaphore(ThrSem, 1, NULL);
   while(GetMessage(&msg,NULL,0,0))
    {
       if (msg.hwnd == NULL & msg.message == IX11_HIGZ_MSG) {

         switch(HIWORD(msg.wParam)) {
           case HIGZ_Control:
             switch (LOWORD(msg.wParam)) {
               case IX_OPNWI:
/*                  Create new window                                                 */
                 WinThr = msg.lParam;
                 if ( WinThr->flag != 2)
                   hwndHIGZ = CreateWindow(
                              HIGZCLASS,           /*extended window style                       */
                              string(WinThr->title,WinThr->lentit),   /*address of window name                      */
                              WS_OVERLAPPEDWINDOW | WS_VISIBLE, /*window style   */
                              CW_USEDEFAULT, CW_USEDEFAULT,  // *x, *y,
                              WinThr->w, WinThr->h,            // *w, *h,
                              NULL,                    /*handle of parent of owner window            */
                              NULL,                    /*handle of menu, or child-window identifier  */
                              higz_display.hInstance,  /*handle of application instance              */
                              NULL);                   /*address of window-creation data             */
                 else {
                   hwndHIGZ = CreateTextClass(WinThr);
                 }

                 WinThr->hwnd = hwndHIGZ;

                 ReleaseSemaphore(WinThr->semaphore, 1, NULL);
                 break;  /* IX_OPNWI */
             default:
                 break;
             } /* End of HIGZ_Control */
           case HIGZ_Attribute:
             switch (LOWORD(msg.wParam))
               {
                default:
                   break;
                 }
           default:
               break;
          }
       }
       else {
          if (msg.message != IX11_HIGZ_MSG)
                           TranslateMessage(&msg);
          DispatchMessage(&msg);
       }
    }
    ExitThread(0);
    return 0;
 } /* HIGZ_MsgLoop */


/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXOPNDS(LENHST,HOST)
 *    INTEGER LENHST      : host name length
 *    CHARACTER*(*) HOST  : host name
 *
 *    Open the display. Return -1 if the opening fails
 */
int
  ixopnds( lenhst, host )
char *host;
int *lenhst;
{
 HINSTANCE hinst  = GetModuleHandle(NULL);      /* handle of current instance */
//  HINSTANCE hinst  = NULL;      /* handle of current instance */


  /* Make sure that this window hasn't been registered yet */

  if (GetClassInfo(hinst,HIGZCLASS,&higz_display))
      return 0;

  /* Set the common wndClass information. This is common for all windows
  ** of this application.
  */

  higz_display.style      = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
  higz_display.cbClsExtra = 0;

  higz_display.cbWndExtra = sizeof(LONG)+LastExtraMember*sizeof(HANDLE);

  higz_display.hCursor    = NULL;
//  higz_display.hCursor    = LoadCursor(NULL, IDC_CROSS);
//  higz_display.hCursor    = LoadCursor(hinst, hCursor);
  higz_display.hInstance  = hinst;

  /*
  ** Register the main top-level window
  */

  higz_display.lpfnWndProc   = (WNDPROC) WndHIGZ;
  higz_display.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
  higz_display.hbrBackground = GetStockObject(WHITE_BRUSH);
  higz_display.lpszMenuName   = NULL;
  higz_display.lpszClassName  = HIGZCLASS;

  if (!RegisterClass(&higz_display)) {
          return -1;
      }
  else {
     HANDLE ThrSem;
/*
 *    Retrieve the applicaiton instance
 */

        /* Create thread to do loop msg */

     ThrSem = CreateSemaphore(NULL, 0, 1, NULL);

     CreateThread(NULL,0, (LPTHREAD_START_ROUTINE) HIGZ_MsgLoop,
                  (LPVOID) ThrSem, 0,  &IDThread);

     WaitForSingleObject(ThrSem, INFINITE);
     CloseHandle(ThrSem);
/*   Create  common object                */
     hdCursorPen   = GetStockObject(BLACK_PEN);
//        CreatePen(PS_SOLID,0,RGB(64,64,64));// Pen to draw HIGZ locator
     hdCursorBrush =
        GetStockObject(HOLLOW_BRUSH);    // Brush to draw HIGZ locator 3 or 5
     return 0;}
}


/*___________________________________________________________________*/
LRESULT APIENTRY
                 HIGZ_Act(hwnd, uMsg, wParam, lParam)
HWND   hwnd;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
     {
           switch (HIWORD(wParam)) {

             case HIGZ_Control:
                 switch (LOWORD(wParam))
                   {
                     case IX_OPNDS:  // Open X11 display
                       break;
                     case IX_OPNWI:  // Open X11 window
                        break;
                     case IX_SELWI:  // Select the current X11 window
                        break;
                     case IX_CLSWI:  // Close an X11 window
                        SetSystemPaletteUse(CurrentDC,SYSPAL_STATIC);
                        RealizePalette(CurrentDC);
                        while(!PostMessage(HWND_BROADCAST,WM_SYSCOLORCHANGE, 0, 0));

                        if (HistoryDC) DeleteEnhMetaFile(CloseEnhMetaFile(HistoryDC));
                        /* Delete data structure */
                        /* Link previous and next structure */
                        if (cHw->ptbw == NULL) fHw = cHw->ptfw; /* This is the first structure in the list */
                        else cHw->ptbw->ptfw = cHw->ptfw;

                        if (cHw->ptfw == NULL) lHw = cHw->ptbw; /* This is the last structure in the list */
                        else cHw->ptfw->ptbw = cHw->ptbw;
                        /* Now the current structure is free and we may delete it */
                        free(cHw);
                        Number_of_HIGZ_Windows--;
                        DestroyWindow( hwnd );
                        return 0;
                     case IX_CLSDS:  // Close an X11 session
                        PostQuitMessage(0);
                        break;

                     case IX_SETHN:  // Set X11 host name
                       return TRUE;
                     case IX_CLRWI:  // Clear an X11 window
                       {
                      /*  HBRUSH CurBrush; */
                      /*  RECT rect;       */
                        HRGN TempClip, clip;
                        char buftext[20]= {"HI\0PAW\0\0" };

/*                        Cancel clipping temporary                  */

                        clip = cHw->HIGZClipRegion;
                        if (clip != NULL) TempClip = SelectClipRgn(CurrentDC,NULL);
                        GetClientRect(hwnd,&rect);
                        DPtoLP(CurrentDC,&rect,2);
                        FillRect(CurrentDC,&rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
                        DeleteObject(CurBrush);
                        if (clip != NULL) TempClip = SelectClipRgn(CurrentDC,TempClip);

/*             Close History Metafile and create a new one                       */

//                        if (HistoryDC) {
                          if(FALSE) {
                          ENHMETAHEADER mfHeader;
                          HENHMETAFILE  hmf;
                           hmf = CloseEnhMetaFile(HistoryDC);
                           printf(" Metafile ID %x with error %d  for %x Histiry DC \n", hmf,GetLastError(),HistoryDC);
                           GetEnhMetaFileHeader(hmf,sizeof(ENHMETAHEADER),&mfHeader);
                           DeleteEnhMetaFile(hmf);
                           HistoryDC = CreateEnhMetaFile(CurrentDC ,NULL,&(mfHeader.rclFrame),
                             NULL);
                           printf(" HistoryDC inside od CLRWI %x with Error %d \n", HistoryDC,
                           GetLastError());
                           cHw->hdcHistory = HistoryDC;
                        }
                        return TRUE;
                       }

                     case IX_UPDWI:  // Update an X11 window
                          FlushHIGZBuffer(hwnd);
                          break;
                     case IX_RSCWI:  // Resize an X11 window
                       return TRUE;
                     case IX_CLIP :  // Define the X11 clipping rectangle
                         {
                          LPPOINT ClipRectPoint;
                          LPRECT  ClipRectFromPoint;
                          HDC     hdc;
                          HRGN    clip;

                           hdc = CurrentDC;
                           ClipRectPoint     = (LPPOINT) lParam;
                           ClipRectFromPoint = (LPPOINT) lParam;
                           LPtoDP(hdc,ClipRectPoint, 2);

                           if (clip = cHw->HIGZClipRegion)
                                           DeleteObject(clip);
/*   Select clippping for Display */
                           hdc = cHw->hdcWindow;
                           SelectClipRgn(hdc,
                                         clip = CreateRectRgnIndirect( ClipRectFromPoint));

/*   Select clippping for bitmap buffer */
                           hdc = cHw->hdcPixBuffer;
                           if (hdc)
                             SelectClipRgn(hdc,
                                           clip = CreateRectRgnIndirect( ClipRectFromPoint));
                           cHw->HIGZClipRegion = clip;
                           return (LRESULT) TRUE;
                         }
                     case IX_NOCLI:  // Deactivate the X11 clipping rectangle
                         {
                           HDC     hdc;
                           HRGN    clip;

                           clip = cHw->HIGZClipRegion;
                           if (clip != NULL) {
                             DeleteObject(clip);
                             hdc = cHw->hdcWindow;
                             SelectClipRgn(hdc,NULL);
                             /* Cancel cliiping for bitmap buffer */
                             hdc = cHw->hdcPixBuffer;
                             if (hdc) SelectClipRgn(hdc,NULL);
                             cHw->HIGZClipRegion = (HRGN) NULL;;
                           }
                           return (LRESULT) TRUE;
                         }
                  default:
                          return TRUE;
                   }
                   break;


                     /*      X11 output primitives                  */
             case  HIGZ_Primitive:
                 switch (LOWORD(wParam))
                   {
                     case IX_LINE :      // Draw a line through all points
                       {
                         struct { int n; XPoint *xy;} *line;
                         HDC     hdc;
                         int i;

                         line = lParam;
                         hdc = CurrentDC;
                         if ( line->n > 1 )
                            return Polyline(hdc,line->xy,line->n);
                         else
                            return SetPixel(hdc, line->xy[0].x,line->xy[0].y, RGB(0,0,0));
                       }
                     case IX_MARKE:      // Draw a marker ar each point
                       return  Wnd_MARKE(hwnd, uMsg, wParam, lParam);

                     case IX_FLARE:      // Fill area described by polygon
                       return Wnd_FLARE(hwnd, uMsg, wParam, lParam);
                     case IX_BOX  :      // Draw a box
                       return Wnd_BOX(hwnd, uMsg, wParam, lParam);
                     case IX_CA   :      // Draw a cell array
                         return Wnd_CA(hwnd, uMsg, wParam, lParam);
                  default:
                     return TRUE;
                   }
                   break;
                    /*      X11 text                               */
             case  HIGZ_Text:
               {
                 TEXTMETRIC *tm;
                 HGDIOBJ hdf;
/*                    Save default values and set cthe current one                  */
                 hdf    = SelectObject(CurrentDC,hdCommonFont);

                           /* Update text metric's */

                 tm = malloc(sizeof(TEXTMETRIC));
                 GetTextMetrics(CurrentDC,tm);
                 cHw->dwCharX = tm->tmAveCharWidth;
                 cHw->dwCharY = tm->tmHeight;
                 cHw->dwAscent= tm->tmAscent;
                 free(tm);

                 switch (LOWORD(wParam))
                   {
                     case IX_TEXT :      // Draw a text string using the current font
                        {
                         struct {int mode,x,y,lentxt; float angle, mgn;  char *text;} *text_msg;
                         COLORREF clrref;
                         int y_shift = 0,
                             x_shift = 0;
                         int txtA;
                         double t_rotate;

/*                     Save default values  and set current one                                */
                         clrref = SetTextColor(CurrentDC,dwCommonTextColor);
                         txtA   = SetTextAlign(CurrentDC,dwCommonTextAlign);

                         text_msg = lParam;
                    /* therefore Windows font hasn'ta  "vertical cernter attribute"
                        one should emulate it by hand
                     */
                         if (align_vert == 0) {
                            t_rotate = cos(0.1*HIGZFont.lfEscapement);
                            y_shift  = (cHw->dwAscent/2)*t_rotate;
                            x_shift  = (cHw->dwAscent/2)*sqrt(1.0-t_rotate*t_rotate);
                         }
                         ExtTextOut(CurrentDC,
                                        text_msg->x+x_shift, text_msg->y+y_shift,
                                        0, NULL,
                                        text_msg->text, text_msg->lentxt,
                                        NULL);
/*                     Restore default values                                       */
                         SetTextColor(CurrentDC,clrref);
                         SetTextAlign(CurrentDC,txtA );
                         break;
                        }
                     case IX_TXTL :      // Return the width and height of character string in the current font
                        {
                           SIZE text_size;
                           struct { int w,h, lmess; char *mess;} *sText;
                           sText = lParam;
                           GetTextExtentPoint(CurrentDC,
                                              sText->mess,sText->lmess, &text_size);
                           sText->w = text_size.cx;
                           sText->h = text_size.cy;
                           break;
                        }
                     default:
                           break;
                   }
/*                     Restore Default font                       */

                 SelectObject(CurrentDC,hdf);

                 tm = malloc(sizeof(TEXTMETRIC));
                 GetTextMetrics(CurrentDC,tm);
                 cHw->dwCharX = tm->tmAveCharWidth;
                 cHw->dwCharY = tm->tmHeight;
                 cHw->dwAscent= tm->tmAscent;
                 free(tm);

                 break;
               }
/*              X11 output attributes                             */
             case HIGZ_Attribute:
                 switch (LOWORD(wParam))
                   {
                     case IX_DRMDE:      // Set drawing mode
                       SetROP2(CurrentDC,lParam);
                       return TRUE;
                   }
                   break;
                    /*     X11 marker style                        */

             case HIGZ_Marker:
                 switch (LOWORD(wParam))
                   {
                     case IX_SETTA:      // Set text alignment
                        SetTextAlign(CurrentDC,lParam);
                        break;
                     case IX_SETTF:      // Set text font to specified name
                       {
                        TEXTMETRIC *tm;
                        DeleteObject(SelectObject(CurrentDC,
                                      CreateFontIndirect((LOGFONT*) lParam))
                                    );
                           /* Update text metric's */

                        tm = malloc(sizeof(TEXTMETRIC));
                        GetTextMetrics(CurrentDC,tm);
                        cHw->dwCharX = tm->tmAveCharWidth;
                        cHw->dwCharY = tm->tmHeight;
                        cHw->dwAscent= tm->tmAscent;
                        free(tm);

                        break;
                       }

                     case IX_SYNC :      // X11 synchronization

                  default:
                     return TRUE;
                   }
                   break;
                   /*      X11 inquiry routines                   */
             case HIGZ_Inquiry:
                 switch (LOWORD(wParam))
                   {
                     case IX_GETGE:       // Returns position and size of Window
                       GetWindowExtEx(CurrentDC,(LPSIZE)lParam);
                       return TRUE;
                     case IX_GETWI:       // Returns the X11 window identifier
                     case IX_GETPL:       // Returns the maximal number of planes of the display
                     case IX_GETCOL:      // Returns the X11 colour representation
                       {
                        struct {int index; struct tagPALETTEENTRY rgb;} *lpHIGZ_rgb;
                        HGDIOBJ hpl;

                        lpHIGZ_rgb = lParam;
                        hpl = GetCurrentObject(CurrentDC,OBJ_PAL);
                        GetPaletteEntries(hpl,lpHIGZ_rgb->index,1,&(lpHIGZ_rgb->rgb));
                        break;
                       }
                  default:
                     return TRUE;
                   }
                  break;

        /*          Pixmap manipulation                    */

             case HIGZ_Pixmap:
                 switch (LOWORD(wParam))
                {
                     case IX_CPPX :       // Copy the pixmap
                       Wnd_CPPX(hwnd, uMsg, wParam, lParam);
                       break;
                     case IX_WRPX :       // Write the pixmap
//                       Wnd_WRPX(hwnd, uMsg, wParam, lParam);
                       break;
                     case IX_WIPX :       // Copy the area in the current window
                       Wnd_WIPX(hwnd, uMsg, wParam, lParam);
                       break;
                   default:
                       return TRUE;
                }
                return TRUE;
           /*             Dummies                         */

             case HIGZ_Dummies:
                 switch (LOWORD(wParam))
                   {
                     case IX_S2BUF:
                       Wnd_S2BUF(hwnd, uMsg, wParam, lParam);
                       break;
                     case IX_SDSWI:
                  default:
                     return TRUE;
                   }
            default:
                      return TRUE;
            }
            return TRUE;
  }   /*  HIGZ_Act */

/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXOPNWI(X,Y,W,H,LENTIT,TITLE,FLAG)
 *    INTEGER X,Y         : initial window position
 *    INTEGER W,H         : initial window width and height
 *    INTEGER LENTIT      : title length
 *    CHARACTER*(*) TITLE : window title
 *    INTEGER FLAG        : FLAG<>1 allows to open a non MOTIF window
 *                          even if ixmotif has been called.
 *
 *    Open window and returns window number which can be used with IXSELWIN
 *    return -1 if window creation fails
 */
int
  ixopnwi( x, y, w, h, lentit,title, flag )
char *title;

int *x, *y;
int *w, *h;
int *lentit;
int *flag;
{
 HWND hwndHIGZ;
 int value;
 static struct CREATEHIGZWINDOW WinThr;

 WinThr.x = *x;
 WinThr.y = *y;
 WinThr.w = *w+2*GetSystemMetrics(SM_CXFRAME);

 WinThr.h = *h+  GetSystemMetrics(SM_CYCAPTION)
              +2*GetSystemMetrics(SM_CYFRAME)
              -  GetSystemMetrics(SM_CYBORDER);
 WinThr.lentit = *lentit;
 WinThr.title = title;


      /* Create HIGZ window */

  WinThr.semaphore = CreateSemaphore(NULL, 0, 1, NULL);

  while(!PostThreadMessage(IDThread,
         IX11_HIGZ_MSG,MAKEWPARAM(IX_OPNWI,HIGZ_Control), &WinThr));

  WaitForSingleObject(WinThr.semaphore, INFINITE);
  CloseHandle(WinThr.semaphore);

  ShowWindow(WinThr.hwnd,SW_SHOWDEFAULT);
  UpdateWindow(WinThr.hwnd);

  return (int)WinThr.hwnd;

 }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXRSCWI(WID, W, H)
 *    INTEGER WID  : Window identifier.
 *    INTEGER W    : Width
 *    INTEGER H    : Heigth
 *
 *    Rescale the window WID
 */
void
   ixrscwi(wid, w, h)
  HWND *wid;
  int *w;
  int *h;
{
   int new_w,new_h;

   new_w = *w+2*GetSystemMetrics(SM_CXFRAME);

   new_h = *h+  GetSystemMetrics(SM_CYCAPTION)
             +2*GetSystemMetrics(SM_CYFRAME)
             -  GetSystemMetrics(SM_CYBORDER);

   SetWindowPos(*wid,HWND_TOP,0,0,new_w,new_h,
                 SWP_DRAWFRAME|SWP_NOMOVE |SWP_NOZORDER );
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXS2BUF(WID,MODE)
 *    INTEGER WID  : Window identifier.
 *                   999 means all the opened windows.
 *    INTEGER MODE : 1 double buffer is on
 *                   0 double buffer is off
 *
 *    Set the double buffer on/off on window WID.
 */
void
  ixs2buf( wid, mode )
  int *wid;
  int *mode;
{
  SendMessage(*wid,
              IX11_HIGZ_MSG,MAKEWPARAM(IX_S2BUF,HIGZ_Dummies),*mode);
}

/*___________________________________________________________________*/
LRESULT APIENTRY
        Wnd_S2BUF (hwnd, uMsg, wParam, lParam)
HWND  hwnd;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
/*   Global variable used:
 *
 *   offPixmapDC  - handle of the memory device context
 *   offPixBuffer - handle of the bitmap in memory DC
 *                = NULL - means there os no double buffering
 *                         for the current window.
 */
 {
  HBITMAP hdBuffer;
  HDC     hdPixmapDC;

     hdPixmapDC = cHw->hdcPixBuffer;
     hdBuffer   = cHw->hbBuffer;

     if (lParam) {
/*         Turn double bufferring ON           */
      if (hdPixmapDC)  FlushHIGZBuffer(hwnd);
      else CreateHIGZBuffer(hwnd);
     }
     else
/*         Turn double bufferring OFF           */
      if (hdPixmapDC){
        hdBuffer = FlushHIGZBuffer(hwnd);
        DeleteDC(hdPixmapDC);
        DeleteObject(hdBuffer);

        cHw->hdcPixBuffer = NULL;
        cHw->hbBuffer = NULL;
      }
 }

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXQ2BUF(WID)
 *    INTEGER WID  : Window identifier.
 *
 *    Query the double buffer value for the window WID.
 */
int
  ixq2buf( wid )
  int *wid;
{
  int rval;
  struct HIGZWindow *Hw;
  Hw = (struct HIGZWindow *)GetWindowLong(*wid,ExtHIGZWindow);
  rval = (int) (Hw->hbBuffer);
  if (rval) return rval;
  else return -1;
}



/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXOPNPX(W, H)
 *    INTEGER W,H : Width and height of the pixmap.
 *
 *    Open a new pixmap.
 */
int
  ixopnpx(w, h)
int *w, *h;
{
  static struct {SIZE PixMap;HANDLE semaphore;HBITMAP ipix;} HIGZPixmap;

  HIGZPixmap.PixMap.cx = *w;
  HIGZPixmap.PixMap.cy = *h;

 lpHpixmap  = malloc(sizeof(HIGZWindow));
 if (lpHpixmap) {
  lpHpixmap->hdcWindow =  CreateCompatibleDC(NULL);
  SetMapMode (lpHpixmap->hdcWindow,MM_ISOTROPIC);
  SetBkMode  (lpHpixmap->hdcWindow,TRANSPARENT);
  DeleteObject(SelectPalette(lpHpixmap->hdcWindow,hdCommonPalette,TRUE));

  lpHpixmap->HIGZWindowSize.right  = *w;
  lpHpixmap->HIGZWindowSize.bottom = *h;
  cHw = (struct HIGZWindow *)GetWindowLong(CurrentHIGZWindow,ExtHIGZWindow);
  lpHpixmap->hbBuffer = CreateCompatibleBitmap(cHw->hdcWindow,
                                     lpHpixmap->HIGZWindowSize.right,
                                     lpHpixmap->HIGZWindowSize.bottom);
  SelectObject(lpHpixmap->hdcWindow,lpHpixmap->hbBuffer);
  PixMapON = TRUE;
 }
 return (int) lpHpixmap->hbBuffer;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLRPX(PIX)
 *    INTEGER PIX : Pixmap address
 *
 *    Clear the pixmap PIX.
 */
void
  ixclrpx(pix )
HGDIOBJ *pix;
{
      RECT rect;
      BITMAP Bitmap_buffer;

     if (lpHpixmap) {
       if (lpHpixmap->hbBuffer == *pix) {
        GetObject(*pix, sizeof(BITMAP),&Bitmap_buffer);
        rect.left   = 0;
        rect.top    = 0;
        rect.right  = Bitmap_buffer.bmWidth;
        rect.bottom = Bitmap_buffer.bmHeight;
        FillRect(lpHpixmap->hdcWindow,
                 &rect, CurBrush = CreateSolidBrush(WHITE_HIGZ_COLOR));
        DeleteObject(CurBrush);
       }
     }
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLPX
 *
 *    Close the current opened pixmap.
 */
void
  ixclpx()
{
 PixMapON = FALSE;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCPPX(PIX, XPOS, YPOS)
 *    INTEGER PIX : Pixmap address
 *    INTEGER XPOS, YPOS : Pixmap Position
 *
 *    Copy the pixmap PIX at the position XPOS YPOS.
 */
void
  ixcppx(pix, xpos, ypos)
int *pix;
int *xpos, *ypos;
{
  POINT point;
  point.x = *xpos;
  point.y = *ypos;
  if (lpHpixmap->hbBuffer == *pix)
     SendMessage(CurrentHIGZWindow,
                 IX11_HIGZ_MSG,MAKEWPARAM(IX_CPPX,HIGZ_Pixmap),&point);
}

/*___________________________________________________________________*/
LRESULT APIENTRY
        Wnd_CPPX (hwnd, uMsg, wParam, lParam)
                   HWND  hwnd; UINT   uMsg; WPARAM wParam; LPARAM lParam;
{
   BITMAP Bitmap_buffer;
   int w,h;
   GetObject(lpHpixmap->hbBuffer, sizeof(BITMAP),&Bitmap_buffer);
   w = Bitmap_buffer.bmWidth;
   h = Bitmap_buffer.bmHeight;
   BitBlt(CurrentDC,((POINT*)lParam)->x,((POINT*)lParam)->y,w,h,
          lpHpixmap->hdcWindow,0,0,SRCCOPY);

}



/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXWRPX(PIX,W,H,LENNAME,PXNAME)
 *    INTEGER PIX : Pixmap address
 *    INTEGER W,H : Width and height of the pixmap.
 *    INTEGER LENNAME     : pixmap name length
 *    CHARACTER*(*) PXNAME: pixmap name
 *
 *    Write the pixmap IPX in the bitmap file PXNAME.
 */
void
  ixwrpx(pix, w, h, lenname, pxname, lpxname )
char *pxname;
int *pix;
int *w, *h;
int *lenname;
int lpxname;
{
 unsigned int wval, hval;
  wval = *w;
  hval = *h;
/*  XWriteBitmapFile(display,string(pxname,*lenname),*pix,wval,hval,-1,-1);
*/
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXWIPX(PIX, XPOS, YPOS)
 *    INTEGER PIX : Pixmap address
 *    INTEGER XPOS, YPOS : Position in the current window
 *
 *    Copy the area at the position XPOS YPOS in the current
 *    window in the pixmap PIX. The area copied has the size
 *    of the pixmap PIX.
 */
void
  ixwipx(pix, xpos, ypos )
int *pix;
int *xpos, *ypos;
{
  POINT point;
  point.x = *xpos;
  point.y = *ypos;
  SendMessage(CurrentHIGZWindow,
              IX11_HIGZ_MSG,MAKEWPARAM(IX_WIPX,HIGZ_Pixmap),&point);
}

/*___________________________________________________________________*/
LRESULT APIENTRY
        Wnd_WIPX (hwnd, uMsg, wParam, lParam)
                   HWND  hwnd; UINT   uMsg; WPARAM wParam; LPARAM lParam;
{
   int w,h;
   BITMAP Bitmap_buffer;

   GetObject(lpHpixmap->hbBuffer, sizeof(BITMAP),&Bitmap_buffer);
   w = Bitmap_buffer.bmWidth;
   h = Bitmap_buffer.bmHeight;
   BitBlt(lpHpixmap->hdcWindow,0,0,w,h,
          CurrentDC,((POINT*)lParam)->x,((POINT*)lParam)->y,SRCCOPY);

}



/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXRMPX(PIX)
 *    INTEGER PIX : Pixmap adress
 *
 *    Remove the pixmap PIX.
 */
void
  ixrmpx(pix)
int *pix;
{
 PixMapON = FALSE;
 DeleteDC(lpHpixmap->hdcWindow);
 DeleteObject(lpHpixmap->hbBuffer);
 free(lpHpixmap);
 lpHpixmap = NULL;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLSDS
 *
 *    Delete all windows and close connection
 */
void
  ixclsds()
{
/* Delete common objects */
  DeleteObject(hdCursorPen);
  DeleteObject(hdCursorBrush);
  PostMessage(CurrentHIGZWindow,
              IX11_HIGZ_MSG,MAKEWPARAM(IX_CLSDS,HIGZ_Control), 0);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLSWI
 *
 *    Delete current window
 */
void
  ixclswi()
{
  int wid;

   SendMessage(CurrentHIGZWindow,
               IX11_HIGZ_MSG,MAKEWPARAM(IX_CLSWI,HIGZ_Control), 0);

//  ixclsds(); /* no open window left */
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSELWI(WID)
 *    INTEGER WID : window number returned by IXOPNWIN
 *
 *    Select window to which subsequent output is directed
 */
void
  ixselwi( wid )
HWND *wid;
{
  CurrentHIGZWindow = *wid;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSAVWI
 *
 *    Save the adress of the current active window
 */
void
  ixsavwi()
{
  sws = cws;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETWI
 *
 *    Restore the adress of the saved window
 */
void
  ixsetwi()
{
  cws = sws;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXGETGE(WID,X,Y,W,H)
 *    INTEGER WID : window identifier
 *    INTEGER X,Y : window position (output)
 *    INTEGER W,H : window size (output) (in Windowa/NT logical coordinat)
 *
 *    Return position and size of window wid
 *    if wid < 0 the size of the display is returned
 */
void
   ixgetge( wid, x, y, w, h )
HWND *wid;
int *x, *y;
unsigned int *w, *h;
{
  HDC junkwin;
  static SIZE win_pos;
  if( *wid < 0 ) {
    /* Retrive size of full screen in the device unit */
     junkwin = GetDC(NULL);
     *x = 0;
     *y = 0;
     *w = GetDeviceCaps(junkwin,HORZRES);
     *h = GetDeviceCaps(junkwin,VERTRES);
     ReleaseDC(NULL,junkwin);
   } else {
      junkwin = SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_GETGE,HIGZ_Inquiry), &win_pos);
     /* Retrive size of DISPLAY in the logical unit */
      *x = 0;
      *y = 0;
      *w = win_pos.cx;
      *h = win_pos.cy;
  }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXGETPL(NPLANES)
 *    INTEGER NPLANES     : number of bit planes
 *
 *    Get maximum number of planes
 */
void
   ixgetpl(nplanes)
int *nplanes;
{
   HDC  hDCGlobal;
   hDCGlobal = GetDC(NULL);
   *nplanes  = GetDeviceCaps(hDCGlobal,PLANES);
   ReleaseDC(NULL,hDCGlobal);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXRSIZ(WID)
 *    INTEGER WID     : window to be resized
 *
 *    Resize the current window if necessary
 */
void
   ixrsiz(wid)
int *wid;
{

}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXGETHT(IL,CHHOST)
 *    INTEGER IL           : host name length (output)
 *    CHARACTER*(*) CHHOST : host name (output)
 *
 *    Return the host name given with IGWKTY.
 */
void
   ixgetht (il, chhost)
   int *il;
   char *chhost; /* host name */
{
   GetComputerName(chhost,il);
}


/*___________________________________________________________________*/
void
   ixgetwi (wkid, idg)
   int wkid;    /* workstation identifier (input) */
   int *idg; /* window identifier (output) */
{
   *idg = 1;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLRWI
 *
 *    Clear current window
 */
void
  ixclrwi()
{
  HIGZDrawing(MAKEWPARAM(IX_CLRWI,HIGZ_Control), 0);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXUPDWI(MODE)
 *    INTEGER MODE : (1) or (11) The window is raised
 *                   (0) or (10) The window is not raised
 *                   (0) or (1)  no synchonisation between client and server
 *                  (10) or (11) synchonisation between client and server
 *
 *    Update display and raise current window to top of stack.
 *    Synchronise client and server once (not permanent).
 *    Copy the pixmap cws->buffer on the window cws-> window
 *    if the double buffer is on.
 */
void
  ixupdwi(mode)
  int *mode;
{
  SendMessage(CurrentHIGZWindow,IX11_HIGZ_MSG,
              MAKEWPARAM(IX_UPDWI,HIGZ_Control), *mode);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCLIP(WID,X,Y,W,H)
 *    INTEGER WID : Window indentifier
 *    INTEGER X,Y : origin of clipping rectangle
 *    INTEGER W,H : size of clipping rectangle;
 *
 *    Set clipping region for the window wid
 */
void
  ixclip( wid, x, y, w, h )
HWND *wid;
int *x, *y;
int *w, *h;
{
  static RECT region;

  region.left   = *x;
  region.top    = *y;
  region.right  = *x+*w;
  region.bottom = *y+*h;

  SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_CLIP,HIGZ_Control), &region);

}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IWCLIP(WID,XMIN,YMIN,XMAX,YMAX)
 *    INTEGER WID : Window indentifier
 *    INTEGER XMIN,YMIN, XMAX, YMAX : clipping rectangle
 *
 *    Set clipping region for the window wid
 */
void
  iwclip( wid, xmin, ymin, xmax, ymax )
HWND *wid;
int *xmin, *ymin, *xmax, *ymax;
{
  static RECT region;

  region.left   = *xmin;
  region.top    = *ymin;
  region.right  = *xmax;
  region.bottom = *ymax;

  SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_CLIP,HIGZ_Control), &region);

}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXNOCLI(WID)
 *    INTEGER WID : Window indentifier
 *
 *    Switch off the clipping for the window wid
 */
void
  ixnocli(wid)
HWND *wid;
{

  SendMessage(*wid,IX11_HIGZ_MSG,MAKEWPARAM(IX_NOCLI,HIGZ_Control), 0 );

}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETCO(CINDEX,R,G,B)
 *    INTEGER CINDEX : color index
 *    REAL R,G,B     : red, green, blue intensities between 0.0 and 1.0
 *
 *    Set color intensities for given color index
 */
#define BIGGEST_RGB_VALUE 255  // 65535

void
  ixsetco( cindex, r, g, b )
int *cindex;
float *r, *g, *b;
{
  static PALETTEENTRY ChColor;
  static struct {UINT ci; struct PALETTEENTRY *lpChColor;}  NewColor;
  int i;

  if (*cindex < MAXCOL-1) {
    NewColor.ci = *cindex;
    NewColor.lpChColor = &ChColor;

    ChColor.peRed   = (BYTE) (*r*BIGGEST_RGB_VALUE);
    ChColor.peGreen = (BYTE) (*g*BIGGEST_RGB_VALUE);
    ChColor.peBlue  = (BYTE) (*b*BIGGEST_RGB_VALUE);

    ChColor.peFlags = PC_NOCOLLAPSE;

    i = NewColor.ci+ColorOffset;
    SetPaletteEntries(hdCommonPalette,i,1,&ChColor);
  }
}


/*___________________________________________________________________*/
void
  ixgetcol( index, r, g, b )
int index; /* input */
float *r, *g, *b; /* output */
{
  static struct {int index; PALETTEENTRY rgb;} HIGZ_rgb;
  HIGZ_rgb.index = index;
  SendMessage(CurrentHIGZWindow,
              IX11_HIGZ_MSG,MAKEWPARAM(IX_GETCOL,HIGZ_Inquiry),&HIGZ_rgb);
  *r = (float)HIGZ_rgb.rgb.peRed  /BIGGEST_RGB_VALUE;
  *g = (float)HIGZ_rgb.rgb.peGreen/BIGGEST_RGB_VALUE;
  *b = (float)HIGZ_rgb.rgb.peBlue /BIGGEST_RGB_VALUE;
  return ;
}

/*___________________________________________________________________*/
HPEN CreateHIGZPen(lpPen)
struct HIGZPEN *lpPen;
 {
     static int dwWidth, dwStyle;

     dwWidth = lpPen->pen.lopnWidth.x;
     if (dwWidth <= 1)  dwWidth=1;

      dwStyle = lpPen->pen.lopnStyle |
                         ((dwWidth == 1)? PS_COSMETIC:
                                          PS_GEOMETRIC | PS_INSIDEFRAME);

     if (hdCommonPen) DeleteObject(hdCommonPen);
     return ExtCreatePen( dwStyle,
                          dwWidth,
                          &(lpPen->brush),
                          lpPen->lUserDash,
                          lpPen->UserDash);
 }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETLN(WIDTH)
 *    INTEGER WIDTH : line width in pixels
 *
 *    Set line width
 */
void
  ixsetln( width )
int *width;
{
  if (pen.pen.lopnWidth.x != *width)
  {
    pen.pen.lopnWidth.x = *width;
    hdCommonPen = CreateHIGZPen(&pen);
  }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETLS(N,DASH)
 *    INTEGER N       : length of dash list
 *    INTEGER DASH(N) : dash segment lengths
 *
 *    Set line style:
 *    if N.LE.0 use pre-defined Windows style:
 *         0 - solid lines
 *        -1 - solid lines
 *        -2 - dash line
 *        -3 - dot  line
 *        -4 - dash-dot line
 *        -5 - dash-dot-dot line
 *    .LE.-6 - solid line
 *
 *    if N.GT.0 use dashed lines described by DASH(N)
 *    e.g. N=4,DASH=(6,3,1,3) gives a dashed-dotted line with dash length 6
 *    and a gap of 7 between dashes
 */
void
  ixsetls( n, dash )
int *n;
int *dash;
{
  UINT style;
  if( *n <= 0 ) {
    pen.lUserDash = 0;
    pen.UserDash = NULL;
    switch (*n)
     {
       case  0:  style = PS_SOLID;
                 break;
       case -1:  style = PS_SOLID;
                 break;
       case -2:  style = PS_DASH;
                 break;
       case -3:  style = PS_DOT;
                 break;
       case -4:  style = PS_DASHDOT;
                 break;
       case -5:  style = PS_DASHDOTDOT;
                 break;
       default:  style = PS_SOLID;
                break;
     }
   if (pen.pen.lopnStyle == style ) return;
   pen.pen.lopnStyle = style;
  }
  else
  {
    pen.pen.lopnStyle = PS_USERSTYLE;
    pen.lUserDash = *n;
    pen.UserDash = dash;
  }
  hdCommonPen = CreateHIGZPen(&pen);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETLC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for lines
 */
void
  ixsetlc( cindex )
int *cindex;
{
  if (pen.pen.lopnColor != *cindex)
    {
     pen.pen.lopnColor = *cindex;
     pen.brush.lbColor = HIGZColorIndex(pen.pen.lopnColor);

     hdCommonPen = CreateHIGZPen(&pen);
    }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXLINE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Draw a line through all points
 */
void
  ixline( n, xy )
int *n;
XPoint *xy;
{
  static struct { int n; XPoint *xy;} line;
  line.n  = *n;
  line.xy = xy;
  HIGZDrawing(MAKEWPARAM(IX_LINE,HIGZ_Primitive),&line);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETMS(TYPE,N,XY)
 *    INTEGER TYPE      : marker type
 *    INTEGER N         : length of marker description
 *    INTEGER*2 XY(2,N) : list of points describing marker shape
 *
 *    Set marker style:
 *    if N.EQ.0 marker is a single point
 *    if TYPE.EQ.0 marker is hollow circle of diameter N
 *    if TYPE.EQ.1 marker is filled circle of diameter N
 *    if TYPE.EQ.2 marker is a hollow polygon describe by line XY
 *    if TYPE.EQ.3 marker is a filled polygon describe by line XY
 *    if TYPE.EQ.4 marker is described by segmented line XY
 *    e.g. TYPE=4,N=4,XY=(-3,0,3,0,0,-3,0,3) sets a plus shape of 7x7 pixels
 */
void
  ixsetms( type, n, xy )
int *type;
int *n;
XPoint *xy;
{
  int i;

  marker.type = *type;
  marker.n = *n < MAXMK ? *n : MAXMK;
  if( marker.type >= 2 )
    for( i = 0; i < marker.n; i++ )
      marker.xy[i] = xy[i];
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETMC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for markers
 */
void
  ixsetmc( cindex )
int *cindex;
{
  marker.cindex = *cindex;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXMARKE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Draw a marker at each point
 */
void
   ixmarke( n, xy )
int *n;
XPoint *xy;
{
  static struct { int n; XPoint *xy; struct MARKER *marker;} markers;

  markers.n = *n;
  markers.xy = xy;
  markers.marker = &marker;

  HIGZDrawing(MAKEWPARAM(IX_MARKE,HIGZ_Primitive),&markers);

}

/*___________________________________________________________________*/
 LRESULT APIENTRY
      Wnd_MARKE(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
  {
  struct { int n; XPoint *xy; struct MARKER *marker;} *markers;
  int m,n;
  XPoint *xy;
  COLORREF mColor;
  struct MARKER  *CurMarker;
  int ownBrush;

  markers = lParam;
  n       = markers->n;
  xy      = markers->xy;
  CurMarker  = markers->marker;

                  /* Set marker Color */
  mColor  = HIGZColorIndex(CurMarker->cindex);

  if( CurMarker->n <= 0 )
     for (m=0; m < n; m++)  SetPixel(CurrentDC, xy[m].x,xy[m].y, mColor);

  else {
    int r = CurMarker->n / 2;
    HGDIOBJ  CurBrush, CurPen;

    CurPen   = SelectObject(CurrentDC, CreatePen(PS_SOLID,0,mColor));

    switch (CurMarker -> type) {
      case 0:
      case 3:
     default:
          ownBrush = TRUE;
          CurBrush = SelectObject(CurrentDC, CreateSolidBrush(mColor));
          break;
      case 1:
      case 2:
          ownBrush = TRUE;
          CurBrush = SelectObject(CurrentDC, GetStockObject(HOLLOW_BRUSH));
          break;
      case 4:
          ownBrush = FALSE;
          break;
      }

    for( m = 0; m < n; m++ ) {
      int i;

      switch( CurMarker->type ) {

      case 0:        /* hollow circle */
      case 1:        /* filled circle */


         Pie( CurrentDC,
              xy[m].x - r, xy[m].y - r,
              xy[m].x + r, xy[m].y + r,
              xy[m].x - r, xy[m].y - r,
              xy[m].x - r, xy[m].y - r);
         break;

      case 2:        /* hollow polygon */
      case 3:        /* filled polygon */
        for( i = 0; i < CurMarker->n; i++ ) {
                                         CurMarker->xy[i].x += xy[m].x;
                                         CurMarker->xy[i].y += xy[m].y;
                                        }
        Polygon(CurrentDC,CurMarker->xy,CurMarker->n);
        for( i = 0; i < CurMarker->n; i++ ) {
          CurMarker->xy[i].x -= xy[m].x;
          CurMarker->xy[i].y -= xy[m].y;
         }
      break;

      case 4:        /* segmented line */
      for( i = 0; i < CurMarker->n; i += 2 )
       {
        MoveToEx(CurrentDC,xy[m].x + CurMarker->xy[i].x, xy[m].y + CurMarker->xy[i].y,NULL);
        LineTo(CurrentDC,xy[m].x + CurMarker->xy[i+1].x, xy[m].y + CurMarker->xy[i+1].y);
       }
       break;
      }
    }


    if (ownBrush) DeleteObject(SelectObject(CurrentDC, CurBrush));
    DeleteObject( SelectObject(CurrentDC, CurPen ));
   }
   return (LRESULT)TRUE;
 }



/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETFS(STYLE,FASI)
 *    INTEGER STYLE : fill area interior style hollow or solid
 *
 *    Set fill area style
 */
void
  ixsetfs( style, fasi )
int *style;
int *fasi;
{
  if (hdCommonBrush != NULL) DeleteObject(hdCommonBrush);
  switch( *style ) {

  case 0:         /* solid */
    gcfill.lbStyle = BS_HOLLOW;
    hdCommonBrush = GetStockObject(HOLLOW_BRUSH);
    break;
  case 1:         /* solid */
    gcfill.lbStyle = BS_SOLID;
//    if (gcfill.lbColor)
       hdCommonBrush = CreateSolidBrush(HIGZColorIndex(gcfill.lbColor));
//    else
//       hdCommonBrush = GetStockObject(WHITE_BRUSH);
    break;

  case 2:         /* pattern */
    gcfill.lbStyle = BS_PATTERN;
    gcfill.lbHatch = &FillBitMap;
      switch( *fasi ) {
        case 1: FillBitMap.bmBits = &p1_bits;
                break;
        case 2: FillBitMap.bmBits = &p2_bits;
                break;
        case 3: FillBitMap.bmBits = &p3_bits;
                break;
        case 4: FillBitMap.bmBits = &p4_bits;
                break;
        case 5: FillBitMap.bmBits = &p5_bits;
                break;
        case 6: FillBitMap.bmBits = &p6_bits;
                break;
        case 7: FillBitMap.bmBits = &p7_bits;
                break;
        case 8: FillBitMap.bmBits = &p8_bits;
                break;
        case 9: FillBitMap.bmBits = &p9_bits;
                break;
       default: FillBitMap.bmBits = &p2_bits;
                break;
        }
       hdCommonBrush =
           CreatePatternBrush(CreateBitmapIndirect((LPBITMAP)gcfill.lbHatch));
       break;

  case 3:         /* hatch */
      gcfill.lbStyle = BS_HATCHED;
      switch (*fasi)
        {
          case 1: gcfill.lbHatch = HS_BDIAGONAL;
                  break;
          case 2: gcfill.lbHatch = HS_CROSS;
                  break;
          case 3: gcfill.lbHatch = HS_DIAGCROSS;
                  break;
          case 4: gcfill.lbHatch = HS_FDIAGONAL;
                  break;
          case 5: gcfill.lbHatch = HS_HORIZONTAL;
                  break;
          case 6: gcfill.lbHatch = HS_VERTICAL;
                  break;
         default: gcfill.lbHatch = HS_FDIAGONAL;
                  break;
        }
        hdCommonBrush =
           CreateHatchBrush(gcfill.lbHatch,HIGZColorIndex(gcfill.lbColor));
        break;
 default:         /* solid */
      gcfill.lbStyle = BS_NULL;
//      if (gcfill.lbColor)
         hdCommonBrush = CreateSolidBrush(HIGZColorIndex(gcfill.lbColor));
//      else
//         hdCommonBrush = GetStockObject(WHITE_BRUSH);
      break;

 }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETFC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for fill areas
 */
void
  ixsetfc( cindex )
int *cindex;
{
  if (gcfill.lbColor != *cindex) {
   gcfill.lbColor = *cindex;

   switch (gcfill.lbStyle)
     {
       case BS_HOLLOW  :
       case BS_PATTERN :
/*                 Hollow and Patten styles needn't a change of brush */
           break;
       case BS_HATCHED :
          if (hdCommonBrush) DeleteObject(hdCommonBrush);
          hdCommonBrush =
             CreateHatchBrush(gcfill.lbHatch,HIGZColorIndex(gcfill.lbColor));
          break;
       case BS_SOLID   :
       default         :
          if (hdCommonBrush) DeleteObject(hdCommonBrush);
//          if (gcfill.lbColor)
            hdCommonBrush = CreateSolidBrush(HIGZColorIndex(gcfill.lbColor));
//          else
//            hdCommonBrush = GetStockObject(WHITE_BRUSH);
          break;
     }
   }
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXFLARE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Fill area described by polygon
 */
void
  ixflare( n, xy )
int *n;
XPoint *xy;
{
  static struct {int n; XPoint *xy;} polygon;

  polygon.n = *n;
  polygon.xy = xy;
  HIGZDrawing(MAKEWPARAM(IX_FLARE,HIGZ_Primitive),&polygon);
}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_FLARE(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
 {
   static struct {int n; XPoint *xy;} *polygon;
   static COLORREF CurTextColor;
   static HGDIOBJ lpCurPen;

   polygon = lParam;

   if (!bord & gcfill.lbStyle != BS_HOLLOW)
               lpCurPen = SelectObject(CurrentDC, GetStockObject(NULL_PEN));


   if (gcfill.lbStyle == BS_PATTERN) {
             CurTextColor = SetTextColor(CurrentDC,HIGZColorIndex(gcfill.lbColor));
             Polygon(CurrentDC,polygon->xy,polygon->n);
             SetTextColor(CurrentDC,CurTextColor);
   }
   else {
             Polygon(CurrentDC,polygon->xy,polygon->n);
   }
   if (!bord & gcfill.lbStyle != BS_HOLLOW)
             DeleteObject(SelectObject(CurrentDC,lpCurPen));

   return TRUE;
}

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETTA(ALIGNH,ALIGNV)
 *    INTEGER ALIGNH : horizontal text alignment
 *    INTEGER ALIGNV : vertical text alignment
 *
 *    Set text alignment:
 *    if ALIGNH.EQ.2 align center
 *    if ALIGHH.EQ.3 align right
 *              else align left
 *
 *    if ALIGNV.EQ.1 align top
 *    if ALIGNV.EQ.2 align top
 *    if ALIGNV.EQ.3 align middle
 *              else align base
 */
void
  ixsetta( align_h, align_v )
int *align_h;
int *align_v;
{
  dwCommonTextAlign = 0;
  switch( *align_h ) {

  case 2:
    dwCommonTextAlign |= TA_CENTER;
    break;

  case 3:
    dwCommonTextAlign |= TA_RIGHT;
    break;

  default:
    dwCommonTextAlign |= TA_LEFT;
  }


  switch( *align_v ) {

  case 1:
  case 2:
    dwCommonTextAlign |= TA_TOP;
    align_vert = 1;
    break;

  case 3:
    dwCommonTextAlign |= TA_BASELINE;
    align_vert = 0;
    break;

  default:
    dwCommonTextAlign |= TA_BASELINE;
    align_vert = -1;
  }
}

/*___________________________________________________________________*/
/*
 *    FUNCTION IXSETTF(MODE,LENFNT,FONTNAME)
 *    INTEGER *MODE       : Option message
 *                 [0]     : = 1 - Italic
 *                 [1]     : = BOLD
 *                 [2]     : = Height of the character
 *                 [3]     : = Angle
 *                 [4]     : = Precision
 *    INTEGER LENFNT     : font name length
 *    CHARACTER*(*) FONT : font name
 *
 *    Set text font to specified name. This function returns 0 if
 *    the specified font is found, 1 if not.
 */
int
  ixsettf( mode, lenfnt,  fontname )
char *fontname;
int *mode;
int *lenfnt;
{
   HIGZFont.lfItalic = (BYTE) mode[0];
   HIGZFont.lfWeight = (LONG) mode[1]*100;
   HIGZFont.lfHeight = (LONG) mode[2]*1.1; // To account "tail"
 //  HIGZFont.lfWidth  = (LONG) mode[2]*1.2
   HIGZFont.lfEscapement   = (LONG)mode[3];
   HIGZFont.lfOutPrecision = 0; // (LONG)mode[4];
   strcpy(HIGZFont.lfFaceName,fontname);

   if (hdCommonFont != NULL) DeleteObject(hdCommonFont);
   hdCommonFont = CreateFontIndirect(&HIGZFont);

  return 0;
 }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSETTC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCOL
 *
 *    Set color index for text
 */
void
  ixsettc( cindex )
int *cindex;
{
   dwCommonTextColor = HIGZColorIndex((COLORREF)(*cindex));
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXTEXT(MODE,X,Y,ANGLE,MGN,LENTXT,TEXT)
 *    INTEGER MODE       : drawing mode
 *            MODE=0     : the background is not drawn
 *            MODE=1     : the background is drawn
 *    INTEGER X,Y        : text position
 *    REAL    ANGLE      : text angle
 *    REAL    MGN        : magnification factor
 *    INTEGER LENTXT     : text length
 *    CHARACTER*(*) TEXT : text string
 *
 *    Draw a text string using current font
 */
void
  ixtext( mode, x, y, angle, mgn, lentxt, text )
char *text;
int *mode;
int *x, *y;
float *angle;
float *mgn;
int *lentxt;
{
  int dx = 0;
  int dy = 0;
  static struct {int mode,x,y,lentxt; float angle, mgn;  char *text;} text_msg;

  text_msg.mode = *mode;
  text_msg.x    = *x;
  text_msg.y    = *y;
  text_msg.angle = *angle;
  text_msg.mgn   = *mgn;
  text_msg.text  = text;
  text_msg.lentxt=*lentxt;

  HIGZDrawing(MAKEWPARAM(IX_TEXT,HIGZ_Text), &text_msg);

//  do_raise = 1;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXTXTL(IW,IH,LMESS,MESS)
 *    INTEGER IW          : text width
 *    INTEGER IH          : text height
 *    INTEGER LMES        : message length
 *    CHARACTER*(*) MESS  : message
 *
 *    Return the size of a character string
 */
void
  ixtxtl( w, h, lmess, mess )
char *mess;
int *lmess;
int *w;
int *h;
{
   static struct { int w,h, lmess; char *mess;} sText;
   HIGZDrawing(MAKEWPARAM(IX_TXTL,HIGZ_Text), &sText);
   *w = sText.w;
   *h = sText.h;
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXBOX(X1,X2,Y1,Y2,MODE)
 *    INTEGER X1,Y1 : left down corner
 *    INTEGER X2,Y2 : right up corner
 *    INTEGER MODE : drawing mode
 *
 *            MODE=0 hollow
 *            MODE=1 solid
 *
 *    Draw a box
 */
void
  ixbox( x1, x2, y1, y2, mode)
int *x1, *x2, *y1, *y2;
int *mode;
{
   static struct { int  x1, y1, x2, y2, mode;} box;

   box.mode  = *mode;
   box.x1    = min(*x1,*x2);
   box.x2    = max(*x1,*x2);
   box.y1    = min(*y1,*y2);
   box.y2    = max(*y1,*y2);

   HIGZDrawing(MAKEWPARAM(IX_BOX,HIGZ_Primitive), &box);

}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_BOX(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
 {
  struct { int  x1, y1, x2, y2, mode;} *box;
  HGDIOBJ NewBrush, lpCurPen;
  static COLORREF CurTextColor;

  box = lParam;
  if (box->mode == 0) {
     if (box->x1 == box->x2 | box->y1 == box->y2) {
/*          Draw a line  instead the rectangle            */
         MoveToEx(CurrentDC,box->x1,box->y1,NULL);
         LineTo  (CurrentDC,box->x2,box->y2);
     }
     else {
         CurBrush = SelectObject(CurrentDC, GetStockObject(HOLLOW_BRUSH));
         Rectangle(CurrentDC,box->x1, box->y1, box->x2, box->y2);
         DeleteObject(SelectObject(CurrentDC,CurBrush));
     }
  }
  else {
//                             CurBrush = GetCurrentObject(CurrentDC,OBJ_BRUSH);
     if (gcfill.lbStyle == BS_PATTERN) {
         CurTextColor = SetTextColor(CurrentDC,HIGZColorIndex(gcfill.lbColor));
         FillRect(CurrentDC, (RECT*)box, hdCommonBrush);
         SetTextColor(CurrentDC,CurTextColor);
     }
     else
         FillRect(CurrentDC, (RECT*)box, hdCommonBrush);
  }
  return TRUE;
 }

/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXCA(X1,X2,Y1,Y2,NX,NY,IC)
 *    INTEGER X1,Y1 : left down corner
 *    INTEGER X2,Y2 : right up corner
 *    INTEGER NX,NY : array size
 *    INTEGER IC : array
 *
 *    Draw a cell array. The drawing is done with the pixel presicion
 *    if (X2-X1)/NX (or Y) is not a exact pixel number the position of
 *    the top rigth corner may be wrong.
 */
void
  ixca(x1, x2, y1, y2, nx, ny, ic)
int *x1, *x2, *y1, *y2, *nx, *ny;
int ic[];
{

   static struct { int x1, x2, y1, y2, nx, ny; int *ic;} cell;

   cell.x1 = *x1;
   cell.x2 = *x2;
   cell.y1 = *y1;
   cell.y2 = *y2;

   cell.nx = *nx;
   cell.ny = *ny;
   cell.ic = ic;

   cell.x1 = *x1;
   HIGZDrawing(MAKEWPARAM(IX_CA,HIGZ_Primitive), &cell);
}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_CA(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
   {
    int i,j,icol,ix,iy,w,h,hh,current_icol;
    struct { int x1, x2, y1, y2, nx, ny; int *ic;} *cell;
    HBRUSH CurCABrush = NULL;
    RECT box;
    cell = lParam;

    current_icol = -1;
    w            = max((cell->x2-cell->x1)/(cell->nx),1);
    h            = max((cell->y1-cell->y2)/(cell->ny),1);
    ix           = cell->x1;

    box.bottom = cell->y1;
    box.top    = cell->y1;
    box.left   = cell->x1;
    box.right  = box.left+h;
    for ( i=0; i<cell->nx; i++ ) {
      box.top -= h;
      for ( j=0; j<cell->ny; j++ ) {
         icol = cell->ic[i+(cell->nx*j)];
         if(icol != current_icol){
            if (CurCABrush != NULL) DeleteObject(CurCABrush);
            CurCABrush = CreateSolidBrush(HIGZColorIndex(icol));
            current_icol = icol;
         }
         FillRect(CurrentDC, &box, CurCABrush);
         box.bottom = box.top;
         box.top -= h;
      }
      box.left = box.right;
      box.right += w;
    }

    DeleteObject(CurCABrush);
    return TRUE;
   }


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXDRMDE(MODE)
 *    INTEGER MODE : drawing mode
 *
 *            MODE=1 copy       R2_COPYPEN
 *            MODE=2 xor     -  R2_XORPEN
 *            MODE=3 invert  -  R2_NOT
 *
 *    Set the drawing mode
 */
void
  ixdrmde( mode )
  int *mode;
{
  static int OP[3] = {R2_COPYPEN, R2_XORPEN, R2_NOT};
  HIGZDrawing(MAKEWPARAM(IX_DRMDE,HIGZ_Attribute), OP[*mode]);
}


/*___________________________________________________________________*/
/*
 *    SUBROUTINE IXSYNC(MODE)
 *    INTEGER MODE : synchronisation on/off
 *
 *            MODE=1 on
 *            MODE<>0 off
 *
 *    Set synchronisation on or off
 */
void
  ixsync( mode )
  int *mode;
{
  int i;
}


/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXREQLO(MODE,CTYP,X,Y)
 *    INTEGER X,Y : cursor position out moment of button press (output)
 *    INTEGER CTYP : cursor type (input)
 *
 *            CTYP=1 tracking cross
 *            CTYP=2 cross-hair
 *            CTYP=3 rubber circle
 *            CTYP=4 rubber band
 *            CTYP=5 rubber rectangle
 *
 *    INTEGER MODE : input mode
 *
 *            MODE=0 request
 *            MODE=1 sample
 *
 *    Request locator:
 *    return button number  1 = left is pressed
 *                          2 = middle is pressed
 *                          3 = right is pressed
 *         in sample mode:
 *                         11 = left is released
 *                         12 = middle is released
 *                         13 = right is released
 *                         -1 = nothing is pressed or released
 *                         -2 = leave the window
 */
int
  ixreqlo( mode, ctyp, x, y )
int *mode, *ctyp, *x, *y;
{
  static struct {int mode, ctyp, x, y, button; HANDLE semaphore;} HIGZmouse;

  HIGZmouse.x    = *x;
  HIGZmouse.y    = *y;
  HIGZmouse.ctyp = *ctyp;
  HIGZmouse.mode = *mode;
  HIGZmouse.semaphore = CreateSemaphore(NULL, 0, 1, NULL);

  SendMessage(CurrentHIGZWindow,
      IX11_HIGZ_Input,MAKEWPARAM(IX_REQLO,HIGZ_Input),&HIGZmouse);

  WaitForSingleObject(HIGZmouse.semaphore, INFINITE);
  CloseHandle(HIGZmouse.semaphore);

  *x = HIGZmouse.x;
  *y = HIGZmouse.y;
  return HIGZmouse.button;

}

/*___________________________________________________________________*/
 LRESULT APIENTRY
       Wnd_REQLO(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
   {
    /* Global for draw cursor utilities variables */
     static struct {int mode, ctyp, x, y, button; HANDLE semaphore;} *lpHIGZmouse;


     SetSystemPaletteUse(cHw->hdcWindow,SYSPAL_NOSTATIC);
     RealizePalette(cHw->hdcWindow);

     cHw->button_press =  0;
     cHw->button_up    =  0;
     switch (uMsg) {
       case WM_RBUTTONUP:
         cHw->button_up++;
       case WM_MBUTTONUP:
         cHw->button_up++;
       case WM_LBUTTONUP:
         cHw->button_up++;
         cHw->button_press++;
       case WM_RBUTTONDOWN:
         cHw->button_press++;
       case WM_MBUTTONDOWN:
         cHw->button_press++;
       case WM_LBUTTONDOWN:
         cHw->button_press++;
       case WM_MOUSEMOVE:

              /* Clean an old position */

        DrawHIGZCursor(lpHIGZmouse->ctyp);

             /* Plot new cursor position */

        cHw->loc.x = (LONG) (MAKEPOINTS(lParam).x);
        cHw->loc.y = (LONG) (MAKEPOINTS(lParam).y);
        DPtoLP(CurrentDC,&(cHw->loc),1);
        DrawHIGZCursor(lpHIGZmouse->ctyp);

  /*  Reset system cursor near the bord id frame */

         if (lpHIGZmouse->mode) {
           if      (cHw->button_press == 0)
                       cHw->button_press = -1;
           else if (cHw->button_press == 4)
                       cHw->button_press = cHw->button_up+10;
           RestoreHIGZ(lpHIGZmouse->ctyp);
           lpHIGZmouse->x = cHw->loc.x ;  lpHIGZmouse->y = cHw->loc.y ;
           lpHIGZmouse->button = cHw->button_press;

//           RestoreDC(CurrentDC,-1);
           ReleaseSemaphore(lpHIGZmouse->semaphore,1L,NULL);

          }
         else if (cHw->button_press > 0 & cHw->button_up ==0) {
           RestoreHIGZ(lpHIGZmouse->ctyp);
           lpHIGZmouse->x = cHw->loc.x ;  lpHIGZmouse->y = cHw->loc.y;
           lpHIGZmouse->button = cHw->button_press;

           ReleaseSemaphore(lpHIGZmouse->semaphore,1L,NULL);
          }

         break;
       case IX11_HIGZ_Input:
         lpHIGZmouse = lParam;
         cHw->loc.x  = lpHIGZmouse->x; cHw->loc.y  =  lpHIGZmouse->y;
         cHw->locp.x = lpHIGZmouse->x; cHw->locp.y =  lpHIGZmouse->y;

         HIGZCursorInit(hwnd,lpHIGZmouse->ctyp);
         break;
       default:
         break;
       }
}

     DrawHIGZCursor( ctyp)
     int ctyp;
     {
        int radius, CurMxX, CurMxY;
        POINT loc,locp;
        loc.x = cHw->loc.x;
        loc.y = cHw->loc.y;

        locp.x = cHw->locp.x;
        locp.y = cHw->locp.y;

        CurMxX = cHw->HIGZWindowSize.right;
        CurMxY = cHw->HIGZWindowSize.bottom;

        switch ( ctyp ) {

        case 1 : /*  Default HIGZ window cursor is CROSS  -> do nothing here */
                 /*
                  *  MoveToEx(CurrentDC,max(0,loc.x-10),     loc.y,NULL);
                  *  LineTo  (CurrentDC,min(CurMxX,loc.x+10),loc.y);

                  *  MoveToEx(CurrentDC,loc.x,max(0,loc.y-10)     ,NULL);
                  *  LineTo  (CurrentDC,loc.x,min(CurMxY,loc.y+10));
                  */
                 break;

        case 2 : MoveToEx(CurrentDC,0,     loc.y,NULL);
                 LineTo  (CurrentDC,CurMxX,loc.y);

                 MoveToEx(CurrentDC,loc.x,0,    NULL);
                 LineTo  (CurrentDC,loc.x,CurMxY);

                 break;

        case 3 : radius = (int) sqrt((double)((loc.x-locp.x)*(loc.x-locp.x)+
                                              (loc.y-locp.y)*(loc.y-locp.y)));
                 Pie(CurrentDC,locp.x-radius,locp.y-radius,
                               locp.x+radius,locp.y+radius,
                               locp.x-radius,locp.y-radius,
                               locp.x-radius,locp.y-radius);
                 break;

        case 4 : MoveToEx(CurrentDC,loc.x, loc.y, NULL);
                 LineTo  (CurrentDC,locp.x,locp.y);
                 break;

        case 5 : Rectangle(CurrentDC,locp.x, locp.y, loc.x, loc.y);
                 break;
        default:
                 break;
      }
   }

/*___________________________________________________________________*/
   HIGZCursorInit(hwnd,ctyp)
   HWND hwnd;
   int ctyp;
   {
        SaveDC(CurrentDC);
   /* Create Brush or Pen to draw HIGZ graphics cursor */

        SelectObject(CurrentDC,hdCursorPen);
        if (ctyp == 3 | ctyp == 5)
            SelectObject(CurrentDC, hdCursorBrush);

   /* Suspend current clipping */

        SelectClipRgn(CurrentDC, NULL);


   /* Set a new mix mode to XOR */

        SetROP2(CurrentDC,R2_NOT);

   /* Set Cursor on the screen */
        DrawHIGZCursor(ctyp);
        cHw->MouseInit = ctyp;
    }

/*___________________________________________________________________*/
RestoreHIGZ(int ctyp)
  {
    cHw->MouseInit = 0;
/* Clean cursor off the screen */
    DrawHIGZCursor(ctyp);
    RestoreDC(CurrentDC,-1);
  }


/*___________________________________________________________________*/
/*
 *    INTEGER FUNCTION IXREQST(X,Y,TEXT)
 *    INTEGER X,Y        : position where text is displayed
 *    CHARACTER*(*) TEXT : text displayed (input), edited text (output)
 *
 *    Request string:
 *    text is displayed and can be edited with Emacs-like keybinding
 *    return termination code (0 for ESC, 1 for RETURN)
 */
int
 ixreqst( x, y, len_text,  text )
char *text;
int *len_text;
int *x, *y;
{
   static struct {int x, y, len_tex; char *text;
                  int BreakKey; HANDLE semaphore;}
                  HIGZText;
   HIGZText.x = *x;
   HIGZText.y = *y;
   HIGZText.len_tex = *len_text;
   HIGZText.text    = text;
   HIGZText.BreakKey = -1;
   HIGZText.semaphore = CreateSemaphore(NULL, 0, 1, NULL);

   SendMessage(CurrentHIGZWindow,
         IX11_HIGZ_Input,MAKEWPARAM(IX_REQST,HIGZ_Input),&HIGZText);

   WaitForSingleObject(HIGZText.semaphore, INFINITE);
   CloseHandle(HIGZText.semaphore);

   return HIGZText.BreakKey;

}

/*___________________________________________________________________*/
 int CharWidth(ch)
 char ch;
    {int LenOfChar;
       GetCharWidth(CurrentDC, (UINT) ch, (UINT) ch,  &LenOfChar);
       return LenOfChar;}

/*___________________________________________________________________*/
 LRESULT APIENTRY
         Wnd_REQST(hwnd, uMsg, wParam, lParam)
 HWND   hwnd;
 UINT   uMsg;
 WPARAM wParam;
 LPARAM lParam;
   {
#define ixg(x) (ix0+x)
#define iyg(y) (iy0+y)
 /*             Application message                     */
    static struct {int x, y, len_tex; char *text;
                  int BreakKey; HANDLE semaphore;}
                  *lpHIGZText;

   static char ch;        // entered symbol
   static char *lpInstr;  // Input line buffer
   static int nCur,       // Current text cursor postion
              lStr,       // Current length of the entered string
                pt,       // Current symbol position
              BreakKey,   // Code of the entered "End of Line" terminator
              nCharWidth, // Width of the current symbol
              LenLine,    // Pixel length of the entered string
              ix0,iy0;
    static    char *Instr;     // temporary buffer


   static int insert;
   int i;

      switch (uMsg) {
       case WM_CHAR:
         switch(wParam) {

           case 0x0A: /* line feed       */
           case 0x0D: /* carriage return */
                     (lpHIGZText->BreakKey)++;
           case 0x1B: /* escape          */
                     (lpHIGZText->BreakKey)++;

                     cHw->SetTextInput = FALSE;
                     HideCaret(hwnd);
                     DestroyCaret();
                     if (lpHIGZText->len_tex > 0) {
                       for (i=0;i<lStr;i++)                     lpInstr[i] = Instr[i];
                       for (i=lStr; i<lpHIGZText->len_tex; i++) lpInstr[i]=' ';
                       free(Instr);
                     }


/*          End of text input from keyboard
 *            and restore previous active window
 */
              SetActiveWindow(ConWindow);
              SetFocus(ConWindow);

              ReleaseSemaphore(lpHIGZText->semaphore,1L,NULL);
              break;

           case 0x09: /* Tab */
           case 0x08: /* backspace */
              break;
           default:   /* all other letters */
             ch = (TCHAR) wParam;
             HideCaret(hwnd);

                 if (nCur != lStr){/*             Clear the old tail of the string            */
                                   COLORREF CurTextCol;
                                   CurTextCol = SetTextColor(CurrentDC,GetBkColor(CurrentDC));
                                   TextOut(CurrentDC,ixg(ixText),iyg(iyText),
                                           &Instr[nCur],lStr-nCur);
                                   SetTextColor(CurrentDC,CurTextCol);
                                  }
                 if (insert==1)    {/*                      Shift string                       */
                                   for (i=lStr; i>nCur; i--) Instr[i] = Instr[i-1];
                                   /*   Increasing of the acctual length                       */
                                   lStr++;
                                   Instr[lStr] = 0x0;
                                  }
                 else if (nCur == lStr) lStr++;
                 else // reduce length of string
                      LenLine -= CharWidth(Instr[nCur]);

/*             Put enreted symbol in place                 */
             Instr[nCur] = ch;
/*            Out the  new tail of the text                 */
             TextOut(CurrentDC,ixg(ixText),iyg(iyText),
                     &Instr[nCur],lStr-nCur);

             LenLine += CharWidth(ch); // pixel length of entered string
             ixText  += CharWidth(ch); // Reset Graphics position for next input
             nCur++;
             break;
          }
         SetCaretPos(ixg(ixText),iyg(iyText-(cHw->dwAscent) ));
         ShowCaret(hwnd);
         return 0;
       case WM_KEYDOWN:
         HideCaret(hwnd);
         switch(wParam) {
           case VK_LEFT:
               nCur--;
               ixText -= CharWidth(Instr[nCur]);
               break;
           case VK_RIGHT:
               ixText += CharWidth(Instr[nCur]);
               nCur++;
               break;
           case VK_HOME:
               ixText = 0;
               nCur = 0;
               break;
           case VK_END:
               ixText = LenLine;
               nCur = lStr;
               break;
           case VK_INSERT:
                insert = -insert;
                break;
           case VK_DELETE:
/*             Clear the old tail of the string            */
                          { COLORREF CurTextCol;
                            CurTextCol = SetTextColor(CurrentDC,GetBkColor(CurrentDC));
                            TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
                            SetTextColor(CurrentDC,CurTextCol);
                          }
/*           Reduce current lenght of string               */
                   LenLine -= CharWidth(Instr[nCur]);

                    for (i=nCur; i<lStr;i++)
                      Instr[i] = Instr[i+1];
                    lStr = max(lStr-1, nCur);
                    if (lStr != nCur)
                       TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
                else
                    Beep(1000L,100L);
                 break;

           case VK_BACK:
               nCur--;
               if (nCur >= 0) {
/*             Clear the old tail of the string            */
                    ixText -= CharWidth(Instr[nCur]);
                    { COLORREF CurTextCol;
                      CurTextCol = SetTextColor(CurrentDC,GetBkColor(CurrentDC));
                      TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
                      SetTextColor(CurrentDC,CurTextCol);
                    }
/*             Reduce current lenght of string               */
                   LenLine -= CharWidth(Instr[nCur]);

                    for (i=nCur; i<lStr;i++)
                      Instr[i] = Instr[i+1];
                    lStr = max(lStr-1, nCur);
                    if (lStr != nCur)
                       TextOut(CurrentDC,ixg(ixText),iyg(iyText), &Instr[nCur],lStr-nCur);
               } else {
                 Beep(1000L,100L);
                 nCur = 0;
               }
               break;
        default:
              return  DefWindowProc(hwnd,uMsg, wParam, lParam);
         }
        SetCaretPos(ixg(ixText),iyg(iyText-(cHw->dwAscent)));
        ShowCaret(hwnd);
        return 0;  // User procedure SHOULD return ZERO if it is process
       case IX11_HIGZ_Input:
           lpHIGZText = lParam;
 /*       Write  TEXT to the pointed position on the screen */
           ix0 =  lpHIGZText->x;
           iy0 =  lpHIGZText->y;
           ixText = 0;
           iyText = 0;
/*        Init of string input                 */
          lpInstr = lpHIGZText->text;
          nCur    = 0;
          lStr    = 0;
          insert  = 1;

          if (lpHIGZText->len_tex >0 ) {
            Instr = malloc(lpHIGZText->len_tex);
            Instr[0] = 0x0;
          }
          LenLine = 0;


/*         Create and set Caret             */

           CreateCaret(hwnd, (HBITMAP) 1, cHw->dwCharX, cHw->dwAscent);
           SetCaretPos(ixg(ixText),iyg(iyText-(cHw->dwAscent)));
           ShowCaret(hwnd);

           SetFocus(hwnd);
           ConWindow = SetActiveWindow(hwnd);

           cHw->SetTextInput = TRUE;

           break;
       default: break;
     }
   }


/*___________________________________________________________________*/
/*      SUBROUTINE IGERR(ERRTEX,RNAME)
*.===========>
*.
*.   This prints on the screen the error message (ERRTEX) and
*. the routine name (RNAME). This routine sets also IQUEST(1)
*. to 1. If RNAME equal ' ' only a warning is printed and
*. IQUEST(1) is sets to 0.
*.
*. _Input parameters:
*.
*.  INTEGER ERRTEX : Error text .
*.  CHARACTER RNAME : Routine name .
*.
*.
*/

 void igerr(errtex,rname,lerr,lname)
   char *errtex, *rname;
   int lerr, lname;
   {
    struct {
        int iquest[100];
    } quest_;

#define quest_1 quest_

     LPCTSTR lpszText;  /* address of text in message box       */
     LPCTSTR lpszTitle; /* address of title of message box      */
     lpszText = malloc(lerr);
     strcpy(lpszText,string(errtex,lerr));
     if (lname <= 1 & rname[0] == ' ') {
     /* This is a warning message */
       lpszTitle = malloc(15);
       strcpy(lpszTitle,"*** Warning ***");
       MessageBox(NULL, lpszText, lpszTitle,
                  MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
       quest_1.iquest[0] = 0;
     }
     else {
     /* This is an error message */
       lpszTitle = malloc(lname+18);
       strcpy(lpszTitle,"*** ERROR in ");
       strcat(lpszTitle,string(rname,lname));
       strcat(lpszTitle," ***");
       MessageBox(NULL, lpszText, lpszTitle,
                  MB_OK | MB_SETFOREGROUND | MB_ICONHAND);
       quest_1.iquest[0] = 1;
     }
     free(lpszTitle);
     free(lpszText);
   }

/*___________________________________________________________________*/
 wrtlst(wid, mess, lmess)
 HWND *wid;
 char *mess;
 int *lmess;
 {
   SendMessage(*wid,LB_ADDSTRING,0, (LPARAM) string(mess,*lmess));
 }

/*___________________________________________________________________*/
 clrlst(wid)
 HWND *wid;
 {
   int n;
   if (n = SendMessage(*wid,LB_GETCOUNT,0,0)   !=   LB_ERR)
           SendMessage(*wid,LB_DELETESTRING,(WPARAM) n, 0);
 }

  ixbord()
  {bord = ~bord;}

+DECK,  MAKEFILE_D, T=DATA, IF=DOC.
# Some nmake macros for Win32 apps development

!include <f77.mak>
!include <ntwin32.mak>

PROJ = hplexam

# application specific C defines

#  Fortram compilers specifics:

.SUFFIXES: .f

#for = f2c

!IF "$(FOR)" != "f77"
for = f2c
FFLAGS = -w -Nn802 -Nx802 -NL802
flib   = f2c.lib
!ELSE
for = $(f77)
FFLAGS = $(fflags) -align:dcommon -align:records -debug:full
flib   = $(f77libs)
!ENDIF

# Rules to constract obj either under f2c or under "native" FORTRAN

.f.obj:
!IF "$(for)" == "f2c"
    $(for)  $(fflags) $*.f
    $(cc)  $(cflags) $(cvars) $(cdebug) $(cf) /Op /Yd /Zi  $*.c >> $*_c.log
!ELSE
    $(for) $(FFLAGS) $*.f /nolink /object:$@      >>$*_f.log
!ENDIF

.c.obj:
	$(cc) /Op /Yd /Zi $(cflags) $(cvars) $(cdebug) $(cf)  $*.c >$*.log



cf = -DNT -DWIN -DNOT_IMPLEMENTED -D_MT -D_PORTABLE_32BIT_CONTEXT

# This line allows NMAKE to work as well

all: $(PROJ).exe

IX_HIGZ.obj: IX_HIGZ.c IX_HIGZ.h

IW_TEXT.obj: IW_TEXT.c IX_HIGZ.h IW_TEXT.H

# Update the executable file if necessary, and if so, add the resource back in.
IX_HIGZ.exp: IX_HIGZ.def IX_HIGZ.obj IW_TEXT.obj
  $(implib) /out:$*.lib $*.obj  IW_TEXT.obj /def:$*.def

IX_HIGZ.dll: IX_HIGZ.obj IW_TEXT.obj IX_HIGZ.exp
        $(link) /out:$*.dll /dll /entry:_CRT_INIT$(DLLENTRY) $(linkdebug) \
                $*.obj IW_TEXT.obj $*.exp \
                $(guilibs)

$(PROJ).exe: $(PROJ).obj
        $(link) $(linkdebug) $(conflags) -out:$(PROJ).exe   \
        $(PROJ).obj   \
        ix_higz.lib \
        d:\cern\lib\94a\hplot.lib d:\cern\lib\94a\higz.lib \
        d:\cern\lib\94a\hbook.lib \
        d:\cern\lib\94a\zebra.lib  d:\cern\lib\94a\math.lib \
        d:\cern\lib\94a\kern.lib \
        $(flib) $(guilibs)
+DECK,  MAKEFILE_MAK_D, T=DATA, IF=DOC.
# Some nmake macros for Win32 apps development

# !include <f77.mak>
!include <ntwin32.mak>

PROJ = hplexam

# application specific C defines

#  Fortran compilers specifics:

.SUFFIXES: .f

#for = f2c

!IF "$(FOR)" != "f77"
for = f2c
FFLAGS = -w -Nn802 -Nx802 -NL802
flib   = f2c.lib
!ELSE
for = $(f77)
FFLAGS = $(fflags) -align:dcommon -align:records -debug:full
flib   = $(f77libs)
!ENDIF

# Rules to constract obj either under f2c or under "native" FORTRAN

.f.obj:
!IF "$(for)" == "f2c"
    $(for)  $(fflags) $*.f
    $(cc)  $(cflags) $(cvarsdll) -O2  $*.c >> $*_c.log
!ELSE
    $(for) $(FFLAGS) $*.f /nolink /object:$@      >>$*_f.log
!ENDIF

.c.obj:
	$(cc) -c -O2 $(cflags) $(cvarsdll)  /G5  $*.c >$*.log



cf = -DNT -DWIN -DNOT_IMPLEMENTED -D_MT -D_PORTABLE_32BIT_CONTEXT

# This line allows NMAKE to work as well

all: $(PROJ).exe

IX_HIGZ.obj: IX_HIGZ.c IX_HIGZ.h

IW_TEXT.obj: IW_TEXT.c IX_HIGZ.h IW_TEXT.H

# Update the executable file if necessary, and if so, add the resource back in.
IX_HIGZ.exp: IX_HIGZ.def IX_HIGZ.obj IW_TEXT.obj
  $(implib) /out:$*.lib $*.obj  IW_TEXT.obj /def:$*.def

IX_HIGZ.dll: IX_HIGZ.obj IW_TEXT.obj IX_HIGZ.exp
        $(link) /out:$*.dll $(dlllflags)  \
                $*.obj IW_TEXT.obj $*.exp \
                $(guilibsdll)

$(PROJ).exe: $(PROJ).obj
        $(link) $(linkdebug) $(conflags) -out:$(PROJ).exe   \
        $(PROJ).obj   \
        ix_higz.lib \
        \misf58\cern\lib\hplot.lib \misf58\cern\lib\higz.lib \
        \misf58\cern\lib\94a\hbook.lib \
        \misf58\cern\lib\zebra.lib  \misf58\cern\lib\mathlib.lib \
        \misf58\cern\lib\kernlib.lib \
        $(flib) $(guilibs)
+PATCH, DOC_KUMACS.
+DECK,  HELP_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:18  mclareni
* Higz
*
*
#include "sys/CERNLIB_machine.h"
#include "_higz/pilot.h"
*CMZ :  1.13/00 06/02/92  15.14.55  by  O.Couet
*-- Author :    O.Couet   04/10/91
   Macro HELP
*
   Mess ' '
   Mess ' The installation procedure of the PAW library is:'
   Mess ' '
   Mess '     CMZ -INSTALL PAW LIB_NAM SRC_DIR OPTIONS'
   Mess ' '
   Mess ' Where :'
   Mess ' '
   Mess ' LIB_NAM is the library name'
   Mess ' '
   Mess ' SRC_DIR is the source directory name'
   Mess ' '
   Mess ' OPTIONS :'
   Mess '        - DEBUG compile with debug option'
   Mess ' '
   Mess ' The installation procedure of the PAW examples is:'
   Mess ' '
   Mess '     CMZ -INSTALL PAW DIR example'
   Mess ' '
   Mess ' Where :'
   Mess ' '
   Mess ' DIR is the directory where the example will be installed'
   Mess ' '
*
   Return
+DECK,  INSTALL_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
#include "sys/CERNLIB_machine.h"
#include "_higz/pilot.h"
*CMZ :  2.07/06 11/07/95  17.46.47  by  O.Couet
*-- Author :    O.Couet   04/10/91
   Macro INSTALL 1=X 2=ftn 3=X 4=X
*
   If [1]='?' Then
      Exec help
      Goto END
   Endif
   File hbook
   Pilot *hbook
   Rel hbook
*
*  Set the FORTRAN extension
*
   Case $MACHINE In
      (APOLLO) Alias/Create ext ftn
      (IBM)    Alias/Create ext fortran
      (VAX)    Alias/Create ext for
      (*)      Alias/Create ext f
   Endcase
*
*  LIBRARY    Library name
*  CODEDIR    Source code directory
*
   LIBRARY  = $Lower([1])
   CODEDIR  = $Lower([2])
*
*  Install the examples
*
   If [CODEDIR]='example' Then
      Select  $MACHINE
      Set [LIBRARY]/*.kumac -D
      Ctot -Y //paw/paxmac/*
      Set [LIBRARY]/*.ext -D
      Ctot //paw/paxfor/*
      Set [LIBRARY]/*.dat   -D
      Ctot //paw/paxdat/*
      Goto END
   Endif
*
   D = FALSE
   M = FALSE
   Do I = 3,[#]
      Case $Upper([%I]) In
         (DEBUG) D = TRUE
         (MOTIF) M = TRUE
      Endcase
   Enddo
*
   Mess ' '
   Mess Installation of PAWLIB on $MACHINE _
        starting at $DATE $TIME .
   Mess ' '
*
   Set [CODEDIR]/paw.sh -XADCL
*
*  Set up the library name
*
   If [LIBRARY] = 'x' Then
      Set [CODEDIR]/$cmzfile.a -L
   Else
      Set [LIBRARY] -L
   Endif
*
   If [D] = TRUE Then
      Case $MACHINE In
         (APOLLO) D=' -dba'
         (HPUX,SGI,SUN,DECS,IBMRT) D=' -g'
         (VAX) D='/NOOP/DEB'
      Endcase
   Else
      D=' '
   Endif
*
   If [M] = TRUE Then
      Sel MOTIF
   Endif
*
*  Set up the FORTRAN compiling options
*
   Set FORTRAN -LAN
   Set [CODEDIR]/*.ext -F
   Case $MACHINE In
      (APOLLO) Set '/com/ftn $compfile//[D]//' -indexl -save' -C
      (HPUX) Set 'f77 -c'//[D]//' +ppu $compfile' -C
      (SUN) Set 'f77 -c'//[D]//' -O $compfile' -C
      (IBMRT) Set 'xlf -c'//[D]//' -qextname $compfile' -C
      (SGI,DECS) Set 'f77 -c'//[D]//' $compfile G 3' -C
      (VAX) Set 'FOR'//[D]//' $compfile' -C
   Endcase
*
*  Select the options
*
   Select  $MACHINE
*
   Pilot *PAW
*
*  CMZ, FORTRAN, Library ...
*
   Set
   seq
   Cfl -P
*
*  Motif Part
*
   If [M] = FALSE Goto END
   Set C -LAN
   Set [CODEDIR]/*.c -F
*
   if $MACHINE = HPUX Then
      OPTC = ' -z -DSYSV -Aa -D_HPUX_SOURCE'
      X11H = ' -I/usr/include/X11R4'
      XMH  = ' -I/usr/include/Motif1.1'
      Set 'cc -c'//[D]//[OPTC]//[X11H]//[XMH]//' $compfile' -C
   Endif
   if $MACHINE = IBMRT Then
      Set 'cc -c'//[D]//' $compfile' -C
   Endif
*
   Pilot *PAW
   Set
   Cfl -P
*
END:
   Return
+PATCH, DOC_VERSIONS.
+DECK,  V1_02_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          09/02/95  15.51.10  by  O.Couet
*-- Author :
*
*::>          VERSION  1.02/00   880420
*
*  27/03/87 New version of IZMERG the option 'D' is available
*
*  27/03/87 The routine IRQLC fills the COMMON /QUEST/ with the window
*           and viewport parameters. For more precision see the comments
*           at the beginning of the routine
*
*  30/03/87 New version of IGAXIS with beautiful ticks marks and labels
*
*  01/04/87 A new version of IZMERG
*
*  02/04/87 First implementation of IGRAPH
*
*  06/04/87 New format in the option SHOW in IGSET
*
*  07/04/87 Correction of IGARC in case of R1=R2 and PHIMIN=PHIMAX
*
*  13/04/87 Corrections for IBM/VM
*
*  13/04/87 New version of IGRAPH for Fill Area
*
*  13/04/87 New picture structure : Control bank.
*
*  16/04/87 The routine IGSA is implemented
*
*  21/04/87 New internal coding of the control bank
*
*  22/04/87 Polyline with two points and marker with one point are stored
*           in a compact way
*
*  23/04/87 Line type from 12 to 15 are available . They are independent from
*           the basic graphics package . For this line types the Basic Segment
*           Length may be sets with the routine IGSET
*
*  11/05/87 Implementation of the routines IGSG and IGSA for IBM
*
*  20/05/87 First version of IGPIE
*
*  27/05/87 Modifications for the GTS_GRAL version of GKS
*
*  27/05/87 The routine IGRNG is available. This routine maps the workstation
*           window onto the whole screen and select the normalization
*           transformation number 1 according to the XSIZ and YSIZ parameters
*
*  12/06/87 Mods in IGAXIS to solve rounding problems for log axis
*
*  17/06/87 New error routine IGERR
*
*  18/06/87 Bar charts implemented in IGRAPH (option "B")
*
*  26/06/87 Changes in routine IGMETA (variable IWTYPE was reset!)
*
*  30/06/87 Bug corrected in IZPICT when GFLAG=.FALSE.
*
*  02/07/87 Bug corrected when ZFLAG=.TRUE. and GFLAG=.FALSE.
*
*  16/07/87 Bars attributes in IGRAPH are now stored in the data structure.
*
*  29/07/87 RBOF,RBWD are returned in RQUEST(1) and RQUEST(2) after a call
*           to IGRAPH with option 'B'
*
*  06/08/87 Some bugs in IGRAPH are corrected
*
*  10/08/87 New version of IGRAPH with new options "L" and "M"
*
*  12/08/87 IZGRAP corrected according to the new version of IGRAPH
*
*  13/08/87 IGRAPH is now IGHIST (cf. doc) and IZGRAP is now IZHIST.
*           The old option "A" is now the option "F" for "Fill area"
*
*  13/08/87 The angle of IGARC are now in degrees
*
*  20/08/87 Changes in IGAXIS (temporary variable CHTEMP)
*
*  28/09/87 New version of IGAXIS: option I (Integer labeling). Correction
*           in IGSET : BARO can be .LT.0.
*
*  05/10/87 The routines IGSA and IGSG have the "Workstation Type" as input
*           parameter.
*
*  20/10/87 The routine IZRIOS is replaced by the routines IZIN, IZOUT, IZSCR
*
*  28/10/87 This file contains now the PATCH MENU and the PATCH GED
*
*  30/11/87 A priority system is available between the normalization
*           transformation. The last selected transformation by ISELNT
*           has the higher priority. In case of overlaping of the
*           transformations the transformations with the higher priority
*           is choosen by IRQLC .
*
*  04/01/88 Modifications to IGRAP1. Normalization in X and Y
*
*  04/03/88 Mods in the IZ routine (IZHIST)
*
*  30/03/88 Bug corrected in IPM
*
*  18/04/88 Changes in HICDES to run on CRAY
*
*  24/05/88 Mods in IGMETA
*
+DECK,  V1_03_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          09/02/95  15.51.10  by  O.Couet
*-- Author :
*
*::>          VERSION  1.03/00   880906
*
*    Changes in IGINIT and IGEND
*    Structure for GMR,UISDC,DI3000 versions introduced.
*    New patches IGKS,IGMR,IGKS3D
*    New PILOT patches for master versions.
*    ZEBRA flag introduced (if Z option not wanted)
*    The new attribute: Axis Wire Length is reachable via IGSET
*    PATCH,HIGZEXAM introduced
*
+DECK,  V1_04_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          09/02/95  15.51.10  by  O.Couet
*-- Author :
*
*::>          VERSION  1.04/00   881104
*
*    New routine IUWK
*    Changes in IGRNG (call to IUWK)
*    IPM changed to GPM in routine IPL (recursivity from IPM)
*    Bug corrected in IZSCHU.
*    DECGKS version introduced.
*    PostScript Interface introduced (-111=Portrait -112=Landscape).
*    Character height and position of the PostScript Font are OK.
*    Minor bugs corrected.
*    Bugs corrected in IZGED in order to be called in STYLE G of PAW
*    The alphanumeric axis labels are now stored in the ZEBRA structure
*    The clipping is supported in the PostScript interface
*    The menu position in IGMENU are given in % of the screen size
*    Improvement in IGMENU and IZGED (Menu FILES introduced).
*    Line width introduced in IZGED
*    Bug corrected in IGAXIS in case of NDIV.LE.3
*    Bug corrected in IGSET if AWLN<0
*    Error with a local ZEBRA link corrected in IZGED
*    Bug corrected in IZLBL
*    New option 'M' in IGAXIS
*
+DECK,  V1_05_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          10/07/91  19.40.26  by  Rene Brun
*-- Author :
*
*
            Routine PAWWID deleted. Replaced by HIGZ routine IGWKTY
*
*::>          VERSION  1.05/04   890403  8.30
*
*           New menu /NETWORK with 2 new commands RLOGIN and RSHELL
*           New routines RLOGIN and RSHELL
*           Interface for the ZEBRA server ZS rewritten
*           Call to PACSEL added in PANTUP (for lego and contour)
*           Changes in PANTUP (avoid 2 passes when ID exists)
*           ==>Important change in HGETID and HGETNT
*              If current directory is not //PAWC, then ID in /PAWC/
*              is always deleted and HRIN called
*              H/plot ID always gets a copy from Current Directory
*              IDOLD not used anymore
*           More information given in the HELP of Ntuple/Plot.
*           New command PAVE
*           LOCATE command returns CONTENT of channel/cell
*           Hbook functions HX and HXY callable from COMIS
*
*::>          VERSION  1.05/03   890301 18.57
*
*           Changes for IWK in PAWWID,PANTUP
*           Changes in PAGPRI (Dim for XLOG changed to 800 from 200)
*           Changes in Command Fit/Function (additional parameters)
*           Sequence NTSCAN renamed PCSCAN
*              (Version never released)
*
*
*::>          VERSION  1.05/02   890124 16.07
*
*
*           New sequences PCPATL,PCCHAR and PCFUNC
*           Use above sequences instead of local variables
*           KUGETI(ID) changed to PAGETI(ID). New routine PAGETI
*           ID='*' means ID='0'
*           All local variables SAVEd
*           List of COMIS routines printed by ENTRY PAWCSH
*           Protections in PAHFIT and PAWSEL
*           New command DDIR to delete a directory
*           Command ARROW can draw a double arrow
*           CDF modified
*           Modified HBOOK sequence HCDIRE introduced.
*           HFNAME filled with file name
*           Sequence HPL1 deleted. Use HPLOPT(opt,-1) instead
*           Protections in HGETID,HGETNT and PAWROP
*           Automatic setting of workstation type on Apollos
*           Changes in PANTUP for automatic binning
*           New command Ntuple/Merge
*              New routines PAMERG,PAMER1 and PAMER2
*           NUPD changed from 30000 to 1000000
*
*::>          VERSION  1.05/01   881221 14.05
*
*           Unused variables or commons deleted.
*           Routine PAWUSR called with an argument in PAWINT and PAEXIT
*           Changes in PAWFOP for IBM (IOFILE01 instead of IOFILE1)
*           Routine VECDEF called from PAWDEF and not from KUINIT
*           New routine PAHELP
*           Mods in CDF for new HELP facility (PAHELP)
*           New routine PACLOS (FILEDEF CLEAR on VM)
*           New routines PAOPEN,PAREAD,PAWRIT (callable from COMIS)
*           New PATCH,CDF introduced
*           ZLOWNT,ZUPNT introduced in /PAWNTU/
*           Changes in PANTUP (LOSTAT) and 40 bins for 2-Dim
*
+DECK,  V1_06_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          10/07/91  19.40.26  by  Rene Brun
*-- Author :
*
*::>          VERSION  1.06/00   890629 12.25
*
*       Bug corrected in PAWROP (VAX)
*       Bug corrected in HPROJ0 (double counting in MASKs)
*       Bug corrected in HPROJA (remove CALL PAWFCI)
*       Routine KUTIME added in PAWCS
*       Routine HPLOC  added in PAWCS
*       Routine HDERIV added in PAWCS
*       Bug corrected in PAWUWF (comma missing in case of V_..)
*       Common blocks /QUEST/ and /KCWORK/ added to PAWCS
*       Changes for log/log scales in PAFUNC
*       CALL KUTERM(IGTERM) added in PAWINT (to empty graphics buffers)
*       Changes in PACSEL and PANTUP (when typing CSEL CB)
*       test .LE. changed to.EQ. after KUGETV (for ? vector)
*       BATCH version introduced
*       New routine PAWARG (NOLOG,BATCH,BATCHF)
*
+DECK,  V1_07_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          10/07/91  19.40.26  by  Rene Brun
*-- Author :
*
*::>          VERSION  1.07/00   891010 18.23
*
*
*       Correction in PAFUNC (option 'S')
*       Number of Ntuple variables extended to 512
*       Bug fixed in PAHFIT
*       PAHFIT modified for the new HFITGA,EX,PO
*       New commands Histo/Fit and Vector/Fit
*       Correction in PAFUNC for LOGY scales
*       Changes in HGETID fir status word bit 5 of HBOOK
*       New routine PALOGS for PAW monitoring
*       Changes in PAMAIN (PAW$LOGON on VAX,etc)
*       RSHELL writes on LOUT
*       Command Picture/SCR activated.
*       Added Interactive Minuit to HFITH/HFITV.
*       PAHIST modified to call HPLTAB for sub-ranges.
*       Mods in PAFORT and PASIGM to permit calling
*        COMIS or SIGMA in KUIP macros.
*       CDF modified
*       PAWROP. Automatic LRECL on VAX.
*       Ranges in CONTOUR,LEGO,SURFACE.

+DECK,  V1_08_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          10/07/91  19.40.26  by  Rene Brun
*-- Author :
*
*::>          VERSION  1.09/00   900124 10.42
*
*        Fix bug in PAMERG
*        Command Ntuple/Plot can now book/fill a Profile histogram
*           if option 'P' is given.
*
*::>          VERSION  1.08/00   891220 18.47
*
*        New parameter in command CONTOUR to plot user contours
*        When option 'E' is selected in Ntuple/Plot, HBARX is
*           automatically called for the output histogram
*        New routines HCDIR and HGIVEN in PAWCS
*        Command NULL now based on HPLFRA from HPLOT
*         This allow the redefinition of LOG/LIN scales
*         on a LIN/LOG scale frame.
*        Special connection ID for GKS metafiles 4011-->4230
*

+DECK,  V1_09_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          09/02/95  15.51.10  by  O.Couet
*-- Author :
*
*::>          VERSION  1.09/00   891219 15.24
*
*    Bugs corrected in IZHIST in case of not equidistant bins
*    Correction for CRAY in IGSET (NINT used in TXAL)
*    Correction in IUWK (PATCH IGKS) to call IPUWK even if GFLAG=.FALSE.
*    New version of clear for PostScript (see IZCLRD)
*    Accents are available in PostScript
*    New PostScript metafile type -2xx with 132 characters per lines
*    Telnetg : Protections added in IMFIN and IMFOUT (if XMIN=XMAX)
*    Bug corrected in IPINIT (CALL IZSELN is added)
*    In IGTABL, the contour plot can now drawn a given set of altitudes
*    Changes in IGTABL to allow scaling change on Lego plots
*    New routine IPTEXT (called by IZTX) in PATCH IPOST to draw the
*        PostScript text like IGTEXT if 0 < Font < -25 and Precision = 1
*
+DECK,  V1_10_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          10/07/91  19.40.26  by  Rene Brun
*-- Author :
*
*::>          VERSION  1.10/00   901107 14.12
*
*       Option LOGX and LOGY available for 2D histos and Ntuples
*       The command MAX works now on 2D histograms
*       Bug corrected in PAGPRI (command HIST in case of non
*           equidistants bins)
*       New application : SLIDE
*       Mods in installation craddle
*       Bug corrected in FUN/PLOT in case of option same
*       New commands:
*          /FUNCTION/DRAW  UFUNC [ CHOPT ]
*          /FUNCTION/ANGLE  [ THETA PHI ]
*          /FUNCTION/RANGE  [ XLOW XUP YLOW YUP ZLOW ZUP ]
*          /GRAPHICS/ATTRIBUTES/PALETTE  PALNB [ NEL LIST ]
*          /GRAPHICS/WORKSTATION  IWKID [ CHOPT IWTYP ]
*          /NTUPLE/LINTRA  IDN [ CHOPT NEVENT IFIRST NVARS VARLIS ]
*       Commands modified, in order to take care of the new 3D
*          plots facilities of HIGZ:
*          /HISTOGRAM/2D_PLOT/LEGO  [ ID THETA PHI CHOPT ]
*          /HISTOGRAM/2D_PLOT/SURFACE  [ ID THETA PHI CHOPT ]
*          /HISTOGRAM/PLOT  [ ID CHOPT ]
*
+DECK,  V1_11_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz
*
*
*CMZ :          24/07/91  17.55.48  by  Rene Brun
*-- Author :
*
*::>          VERSION  1.11/03   910708 14.44
*
*       New routine HCOPYP to copy a projection into a 1-dim hist.
*       Ex: If ID=20 contains a PROX and 20 SLIX, then
*           H/copy 20.prox 1 copy PROX from 20 inti ID=1
*           H/copy 20.slix.12 12 copy SLIX.12 into ID=12
*
*       Bug corrected in GET/Abscisa (C.Erd)
*       New versions of LOCATE and VLOCATE using the sample mode
*          facility of the X11 version of HIGZ.
*       Protection in PAFITV to avoid to draw a bar chart if 'B'
*          (Bounds) is selected in V/FIT.
*
*       Corrections for NEWLIB version (Harald Butenschoen,DESY)
*       in routines PAMAIN,PAHIO,PAOPEN,PAWFOP
*
*       New routines HMAXIM,HMINIM,HMAX,HMIN,HNORMA,HREND in PAWCS
*       New routine HGFIT in PAWCS
*       Buffer size for COMIS increased from 5000 to 10000 words
*
*       Bug corrected in PASCA1 whem masks are used
*
*       Change in PANTUP for Ntuple/Read on VM
*
*       First version of PAW_MOTIF: Flag MOTIF introduced and
*       new patches FPMOTIF and CPMOTIF.
*
*::>          VERSION  1.11/02   910307 11.55
*
*       Bug corrected in command Ntuple/Lintra
*       Rename parameter CHOPT to OPTION in command Ntuple/Plot
*       Memory mapping implemented in command GLOBAL
*       (requires mapping routines from HBOOK and KUIP)
*
*::>          VERSION  1.11/01   910225  8.40
*
*       Changes in PILOT,PATCH *PAW
*       Changes in RLOGIN to allow hostnames up to 16 characters
*
*::>          VERSION  1.11/00   910214 18.30
*
*       New COMMON HIGRAF introduced in PAWCS. This allows to
*          access the points used by the command GRAPH with
*          option 'C' in a COMIS program.
*       New option 'F' in the command GRAPH. The command GRAPH
*          with option 'C' or 'CF' allows now to draw closed
*          contours.
*
*       Correction in PAGKSA: LIST change in PALETTE
*       Upgrade of command SCAN. It is now possible to scan
*          expressions of the original variables.
*       In the command CONTOUR, IFLAG is now replaced by CHOPT.
*          This allow to superimpose contour plots. This mod is
*          compatible with the previous version.
*
+DECK,  V1_12_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :          03/03/92  14.15.24  by  O.Couet
*-- Author :    Rene Brun   02/09/91
*
*::>          VERSION  1.12/00   910902 11.17
*
*       Changes in PAFITH to add option E in fit commands
*
+DECK,  V1_13_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :          14/07/92  13.29.42  by  Rene Brun
*-- Author :    O.Couet   03/03/92
*
*::>          VERSION  1.13/01   920306  9.49
*
*       Bugs corrected in PAWUWF (changes in PAWIDN)
*       LINTRA command revisited. Sequence EQULIN replaced by PCLINT
*
*::>          VERSION  1.13/00   920303 14.00
*
*       First version of the $KUMACS PATCH.
*       Bug corrected in PAWFCU (A.Nathaniel)
*       Default values for X and Y in command TICKS are changed
*          to 1.E30.
*
*       Bug corrected in PAWFCU (bug submitted by W.Mueller GSI)
*       Description : If one wants to fill with NTUPLE/PROJECT a
*                     histogram with both  a cut C and a weight W
*                     one can use a command like
*                        NTU/PROJ 10 100.exp W*(C)
*                 e.g.   NTU/PROJ 10 100.x   a*(y>0)
*              which will increment at x with weight a if y>0.
*              This works fine, but the very similar case with two
*              conditions
*                        NTU/PROJ 10 100.exp W*(C1)*(C2)
*              never increments the histogram no matter what the
*              conditions are. (bug corrected by Andy Cox)
*
*       Many new routines added in PAWCS
*         (Most of the HBOOK user callable routines)
*
*       IGTERM is called in the PAWEX macros.
*
*       Mod in PAHIST to take care of the option "3" and "4" in the
*          command SURFACE
*
*       New routines PANT3D, PANTAX and PANTPM to plot Ntuple in 3D
*       (G.Richards)
*       In the comand CUTS, the parameter CHOPT is now called OPTION
*
*  More details on PAW version 1.13/00 are given in PAW.NEWS113
*
+DECK,  V1_14_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :          20/10/92  10.03.08  by  O.Couet
*-- Author :    Rene Brun   14/07/92
*
*::>          VERSION  1.14/01   920715  9.31
*
*       Change in PAWLOC, ISTAT is now tested just after the call
*          to IRQLC (koellner@lbl.Bitnet).
*
*::>          VERSION  1.14/00   920714 13.29
*
*       Routine PMLOCA removed from FPMOTIF (it was not used).
*       Bug corrected in PANT3D LOGX was tested instead of LOGZ.
*       The polymarker color index in now reset in PANTPM.
*       Bug corrected in PAHIST: angles not used in H/PLOT
*       Routines ERF,ERFC,FREQ,PROB added to list of callable routines
*          from COMIS in PAWCS.
*       Commons /HCFITS/ and /HCFITD/ added to PAWCS.
*       bug corrected in PAMASK for option CLOSE (L option in <MZDROP)
*       bug corrected in PAHIST: ANGLEs not used for 2D histos
*          without subranges.
*       Bug corrected in PAHIST (side effect of the previous correction)
*          slices were ignored in HISTO/PLOT ID.SLIX.
*
+DECK,  V1_15_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.15/03 22/07/92  12.17.38  by  O.Couet
*-- Author :    O.Couet   14/07/92
*
*::>          VERSION  1.15/03   920722 12.17
*
*   Bug corrected in IGSEE and ITX at the PATCHY level (MSDOS
*      flag side effect).
*   Change in IGINIT: the alpha numeric labels are now initialized
*      with ' '. And in IGLBL: if the label list has N<50 labels, the
*      labels form N+1 to 50 are reset to ' '.
*   Bug fixed in IGADID: the IZPUSH parameter was not correct.
*
*::>          VERSION  1.15/02   920717 14.25
*
*   Bug fixed in lego and surface drawing: on VM legos with a small
*      range on X or Y axis were shifted. some variables needed
*      to be in DOUBLE PRECISION in the IH PATCH (on VM).
*
*::>          VERSION  1.15/01   920715 10.00
*
*   Change in IGCHWK. In the case of GKS OPND and LUNWIN were not
*      initialized <GUNTER@CERNVM>.
*   Change in IRQLC for ATCGKS (call to GPREC) (koellner@lbl.Bitnet).
*
*::>          VERSION  1.15/00   920714 16.29
*
*   New flag GKSIBM for the native version of GKS on IBM RS6000.
*      To install this version of HIGZ the following selection are
*      needed: +USE,*HIGZ,IBMRT,GKSIBM. (Roger Howard <RH2@CERNVM>).
*   Mods in X11INT for IBM/VM: the static variable are now initialised
*      with a "long NULL" (LNULL).
*
+DECK,  V1_16_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.16/13 01/02/93  14.50.45  by  Rene Brun
*-- Author :    O.Couet   23/07/92
*
*::>          VERSION  1.16/13   930201 14.50
*
*
*     Inprovments in the X11 fonts management. 4 fonts are kept in
*        memory in order to avoid too many fonts loading.
*
*::>          VERSION  1.16/12   930126 10.15
*
*     Bug fixed in IPDLIN. Some line where missing in PS file
*        if they were too small.
*     Improvements in IPTEXT. The PostScript text was always visible
*        even if the text position was outside the paper.
*
*::>          VERSION  1.16/11   930122  9.40
*
*     Bug fix in IPZONE for the marker type 1 size.
*
*::>          VERSION  1.16/10   930118 15.57
*
*     Mods in IPTEXT in the ' ' and \040 management.
*     Improvments in the intermediate label drawing in case of
*        LOG axis. the rule is now: If  1 =< WMIN <100 and
*        Log(WMAX/WMIN) <2, some intermediate label are drawn.
*
*::>          VERSION  1.16/09   930112 11.26
*
*    Changes in IKFNTX: on IBM/VM only non proportional fonts are
*       used in the X11 version because for the proportional fonts
*       the text width is not correctly computed.
*    Bug fixed in IZPM: In PostScript files, invalid marker types
*       produce points.
*    Improvments in IGTAB5 in order to have the size of the axis
*       value, the size of the axis tick marks and the offset of the
*       values independant of the viewing angles in the surface and
*       lego plots drawing.
*    Bug fixed in IGTAB2: in case of LOGZ option the position of the
*       contour plot was not correct with the SURF3 option of IGTABL.
*
*::>          VERSION  1.16/08   930106 11.16
*
*    A few bugs fixed in the DI3000 PATCH <MARRAFINO@FNPSP>
*    Mods in x11int in the graphics context used to draw the
*       rubberbanding cursor: it is now more portable
*       jank@sunra1.cern.ch or jank@cernvm (Werner Jank)
*    Mods in the PostScript driver for EPS files: a new dictionnary
*       is defined in order to be included in WORD.<SCHRODER@CERNVM>
*    Mods in the PostScript driver for EPS files: the new dictionnary
*       was too small.
*    Changes in IZPICT. The options C, O, and D can be invoked in the
*       same CALL to IZPICT.
*    Mods in IGHIST. The 1Dim histogram with 1 or 2 bins are not plotted
*       with a marker or with a line but according to the current
*       option choosen.
*
*::>          VERSION  1.16/07   921126 11.40
*
*    Bug corrected in IZHIST: The value give to IZPUSH was not
*       correct in case of non equidistant bins.
*    New version of the routine ixmotif. New routine ixminit to
*       initialize the Motif call backs from IOPWK.
*    Mods in IHSDRL (IH) to avoid precision problems on NEXT.
*    New version of the routine IGMESS calling the routine IGXMES
*       which allows a more flexible usage of the X11 windows.
*    Mod in ixopnwi: if the window name begins with '-' the extension
*       ' @ machine_name' is not added to the window title.
*    Mods in the MSDOS driver in the routines  IGWKTY, IGSG, IOPWK
*       and MAPCOL to support SuperVGA 800x600 with 16 colors screen
*       (Dr.Valery Fine LCTA/JINR Dubna).
*
*::>          VERSION  1.16/06   921030 11.04
*
*    Changes in IGAXIS. With LOG scale, intermediate division
*      are ploted if one one decade is visible. This implies also
*      mods in IZRTOC.
*    Bug fixed in IPTEXT. The @ mechanism to escape control characters
*       was wrong for <, >, ", #, ?, !, & and $.
*    New sequence HIPICK use in IGPID and IGPICK.
*    Default FONT and PRECISION change to 0,2 in IGSET.
*
*::>          VERSION  1.16/05   921013 16.26
*
*   Changes in IGAXIS secondary and tertiary axis divisions are
*      optimized like the primary divisions.
*   Changes in the MacIntosh driver (fill area management) (C.Delaat).
*   Bug fixed in the IKERNEL PATCH: With the FALCO driver, some
*      attributes (FACI, FAIS etc...) where not correctly stored in
*      the ZEBRA data structure.
*
*::>          VERSION  1.16/04   921009 13.53
*
*   Some fixes in the Macintosh driver (Cees Delaat).
*   New option 'Q' in IZPICT.
*   Changes in the X11 interface. The routine ixmotif allows to
*      manage several window in a motif program. The routine ixopnwi
*      has one additional parameter IFLAG.
*   New flag APOF77 for the f77 apollo compiler.
*   New flag QX_SC and QXNO_SC to add or not an "_" in the C routines.
*   Bug fixed: the PostScript marker size is now reset in IPZONE.
*   Some changes in IGAXI3 in order to get a better automatic
*      labeling of the axis.
*   Changes in IPTEXT: the control characters can be escaped with '@'.
*
*::>          VERSION  1.16/03   920824  9.44
*
*   Bug fixed in IZSELN: the graphics editor didn't work. This
*      was a side effect of the introduction of IGPID (Lee Roberts).
*   Bug fixed in the routine IRQST for GL: the blank was forgotten.
*      (Lee Roberts).
*
*::>          VERSION  1.16/02   920820 10.06
*
*   Mods in x11int. The window is raised by ixupdwi only
*      if necessary.
*   New version of PostScript text (routine IPTEXT in PATCH IPOST)..
*       (P.Juillot CRN Strasbourg <JUILLOT@CERNVM).
*
*::>          VERSION  1.16/01   920818 11.03
*
*   Mods in the Mac interface (Cees de Laat)
*   Bug fixed in x11int (ixsetco) the RGB value were not stored.
*   Bug fixed in IGAXIS in the optimization of the secondary divisions.
*
*::>          VERSION  1.16/00   920723 13.57
*
*   Change in IGAXIS for the TOP->DOWN labels.
*
+DECK,  V1_17_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.17/03 22/03/93  10.04.38  by  O.Couet
*-- Author :    O.Couet   24/02/93
*
*::>          VERSION  1.17/03   930322 10.04
*
*   The maximal number of NTs is now 100.
*   The routine XGetCGValues is not used for VAX machines (x11int).
*   A cross cursor is displayed together with the cross-air (x11int).
*   The line type of the contour plots is controled with IGSET LTYP
*      when all the contours are drawn with the same line type (IGTABL)
*   Bug fixed in IFA3: NGRAF was not initialized.
*
*::>          VERSION  1.17/02   930309 11.58
*
*   Improvements in the GDDM driver. This version may be used on
*      IBM 3192G terminals, IBM 5080 stations and corresponding
*      emulators (notable the Macintosh version of tn3270).
*      The modifications have been contributed by J.Salicio/CIEMAT.
*
*::>          VERSION  1.17/01   930302 12.20
*
*    Bug fixed in IKERNEL/IOPWK: in case of "Invalid Workstation type"
*       INOPWK wasn't decremented.
*    Mods in IGWKTY: when '?' is typed by the user, the metafile
*       types are not displayed.
*
*::>          VERSION  1.17/00   930224 15.51
*
*    Improvments in IGAXIS: If the intermediate labels in LOG scale
*       overlap each other, they are not drawn. The position of the
*       exponants is now better in case of LOG scale.
*    New routine IZGRAP to store the IGRAPH primitive.
*    New option Z in IGRAPH.
*    Improvments in IGAXIS: If the intermediate labels in LOG scale
*       are drawn if YMAX < 10000.
*
+DECK,  V1_18_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.18/10 22/06/93  17.28.47  by  O.Couet
*-- Author :    O.Couet   30/04/93
*
*::>          VERSION  1.18/10   930622 17.28
*
*   In the FALCO driver the marker type 3 (*) in known. This implies
*      mods in IGPM.
*   Mod in IGAXIS to have a better alignment for the vertical right
*      labeled axis.
*   Line type for FALCO implemented (merlant@csnvs1.in2p3.fr).
*   Bug fixed in ISCHH (patch IKERNEL): in case of FALCO, CHHE was
*      not stored in the pictures.
*
*::>          VERSION  1.18/09   930611  9.40
*
*   Bug fixed in ICLWK in case one the workstation was a PS file.
*   New version of IGTABL and IGTAB6 to allow POL etc.. with
*      Gouraud shading surfaces.
*
*::>          VERSION  1.18/08   10/06/93 17.50.50
*
*   In IKERNEL/IOPWK for the X11 version the string :0.0 is append after
*      the display name/adress only if ":" is not yet in the name.
*   New primitive ICA to draw cell arrays.
*   Remove bug in IGSSE (introduced with the changes for DECGKS)
*
*::>          VERSION  1.18/07   930601 17.22
*
*   Changes in IKERNEL/IOPWK for the X11 version to allow to change
*      the HIGZ window name. In higz_windows.dat after the adress
*      of the host it is possible to give the window name.
*
*::>          VERSION  1.18/06   930528  9.32
*
*   Improvment in IPSCOL (set the PostScript Color): if the color is
*      black, the operator "setgray" is used instead of "setrgbcolor"
*      because on some color printers black is better with "setgray".
*
*::>          VERSION  1.18/05   930527 15.01
*
*   LINUX version introduced. <balashov@main1.jinr.dubna.su>
*   New version of hidden line removal algorithm for Polar, Cylindrical,
*      and Sperical coordinates.
*   Bug fixed in IGTCCH: CHBUF is now erased before to be filled.
*
*::>          VERSION  1.18/04   930526 14.08
*
*   Bug fixed in IKFILE: on IBM/VM the string CCHOST was too long.
*
*::>          VERSION  1.18/03   930525 17.06
*
*   Mods for the GKSGRAL,NEWLIB version in IGSA, IGSG ad IGWKTY
*      (Harald Butenschoen)
*
*::>          VERSION  1.18/02   930525 10.13
*
*   The string CHHOST in HIKERC was too small it is now 80 characters.
*      (mjk@illini.physics.utah.edu)
*   "IF=" on PATCH cards.
*   In the X11 driver, the class hint is now equal to "HIGZ" (W.Brueckner).
*
*::>          VERSION  1.18/01   930511 17.24
*
*   The X11 mode to draw the cursor in ixreqlo is define according to
*      the XServerVendor output.
*   In IGMETA, if LUN=999, the metafile is deactivated AND closed.
*   New routine IGMETN to set the metafile name. It is usefull for
*      some HIGZ version (ATCGKS, MSDOS ...)
*   Mods in IH routine to have the angle on the first coordinate with
*      Polar, Cylindrical and Spherical reprsentations.
*   Bug fixed in ntmgt: #include <stdio.h> was missing for SUN
*   New routine IGTCCH to translate IGTEXT control characters (in a string)
*      into their printable version.
*
*::>          VERSION  1.18/00   930430 12.57
*
*   New C deck NTMGT to manage dynamically the NT. Now used only with X11.
*   Mods in IZPICT and IZSELN: The NT banks have now the same name in order
*      to describe there structure with dzdoc.
*   In IGTEXT, XW,YW and WDTH are now initialized to 0.
*   Mods in various routines for DECGKS on VAX (Lynn Garren <GARREN@FNPSP>).
*   Now the number of colors in HILUT is 256.
*   New options POL, CYL, SPH, and PSD in IGTABL.
*   Sequences are now splited in hicdes, and QFTITLECH is used to set
*      the version number.
*   Logarithmic scales on X and Y axis are now available for Lego and Surface
*      plots. It implies mods in many routines around IGTABL and also
*      in IGAXIS: with options W and G the label were not correct.
*   The X11 mode to draw the cursor in ixreqlo is now "GXxor" which seems
*      to work in a better way than "GXinvert".
*
+DECK,  V1_19_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.19/17 22/10/93  17.59.07  by  O.Couet
*-- Author :    O.Couet   28/06/93
*
*::>          VERSION  1.19/17   22/10/93 17.59.07
*
*   Mods in IGRAP1 in order to draw Curves with in infinite number
*      of point (ZEBRA banks replace HIGRAF common block). Mods also
*      in IGRAPH to take advantage of the new version of IGRAP1.
*
*::>          VERSION  1.19/16   22/10/93 09.34.26
*
*   Bug fixed in IZGRAP in case the original data are in a zebra bank.
*   The format in IZPICT (for the listing) are now I5 instead of I2.
*
*::>          VERSION  1.19/15   12/10/93 12.10.10
*
*   Bug fixed in IGAXIS (case NULL 9.999 10).
*   Optimization in IGAXIS. In case of overlap, the alphanumeric labels
*      are rotated.
*   Mods in IGTABL, IZTABL and IZDNB to allow 2D plots with more than 999
*      bins (with subranges).
*
*::>          VERSION  1.19/14   07/10/93 15.33.40
*
*   Flag NOVAGKS suppressed.
*   Useless pilot patches *GKSGRAL, *DECGKS, *SUNGKS, *GPR, *GL, *X11 and
*      *DI3000 are removed. The installation of HIGZ should be done with
*      the pilot patch *HIGZ.
*   For DecStation Color, GXinvert should be use for rubberbanding.
*
*::>          VERSION  1.19/13   01/10/93 10.54.59
*
*   Speed improvments in IPM4ID (3-4 times faster).
*   Mods in IGWKTY. For UNIX machines wokstation type read is done via
*      a C routine (IXGETL) in order to allow:
*      $ paw < filename
*                       or
*      $ cat filename | paw
*
*::>          VERSION  1.19/12   28/09/93 17.37.09
*
*   Bug fixed in IZGRAP: The BASL attributes was not flaged.
*   Bug fixed in IRQST for FALCO: the output parameter L was not correct.
*   IGSG is now called in ISLN for the FALCO driver.
*   New routine IPM4ID to draw NT/PLOT id.x%y%z%t
*
*::>          VERSION  1.19/11   27/09/93 11.59.25
*
*   In IGTCCH the character % is translated into '"Y#'
*
*::>          VERSION  1.19/10   15/09/93 11.16.41
*
*   Changes in IGTAB5, and IGTABL to be able to define the log option
*      from the calling sequence and not via COMMON.
*   Bug fixed in IZMERG.
*
*::>          VERSION  1.19/09   06/09/93 11.29.16
*
*   Mods in IGRAPH: when it was called with an invalid CHOPT (for
*      example '?'), a blank CHOPT was stored in the picture and
*      the image produced with IZPICT was different from the original.
*   Bug fixed in IKBOX. For the 7879 driver and solid filled areas,
*      IGHATC was not called correctly.
*
*::>          VERSION  1.19/08   03/09/93 17.08.41
*
*   Flag QMALPH added in *HIGZ.
*   The routine ixgetwi in x11int is now a FORTRAN callable routine.
*
*::>          VERSION  1.19/07   31/08/93 09.39.07
*
*   Mods in the PATCH IMAC: New version of imacplo an f_readwi.
*      The deck imacevl is now obsolete.
*
*::>          VERSION  1.19/06   27/08/93 17.15.44
*
*   Improvments in the vertical centering of rotated texts. This
*     implies mods in the ITX routines (IKERNEL, IGKS and IDI3000)
*     and in the routine IPTEXT.
*   Small Improvments in the 3d function drawing (PATCH IH).
*
*::>          VERSION  1.19/05   26/08/93 11.58.10
*
*   Improvments in the 3d function drawing (PATCH IH). It is
*      also possible to draw with hidden lines removal.
*
*::>          VERSION  1.19/04   25/08/93 10.19.48
*
*   Changes for CONVEX (V.Balashov).
*   Bug fixed in IOPKS in the pathes IGKS an IDI3000: The string
*      CHVERS was not initialized.
*
*::>          VERSION  1.19/03   24/08/93 12.03.26
*
*   New flag WINNT introduced.
*   In IGTEXT, IA is saved for MACMPW (Cees Delaat).
*   Lot of changes in the IMAC PATCH (Cees Delaat).
*
*::>          VERSION  1.19/02   930729 13.07
*
*   Unreachable code suppressed in IGTAB6.
*   IF=HIGZEXAM on +PATCH,HIGZEXAM.
*   CHDEFT has now 256 in IGMENU (instead of 80). (Roger Ruber
*      RUBER@JPNKEKVX.BITNET)
*   Bug fixed in IPDEF for the not A4 landscape PS file.
*
*::>          VERSION  1.19/01   930705 12.42
*
*   Protection added in IGMENU if the multiple choices ended with ','.
*
*::>          VERSION  1.19/00   930628 12.14
*
*   Protection added in IPTEXT: if the text size is less or equal
*      to zero, a RETURN is performed.
*   The EPS files contain now a showpage.
*
+DECK,  V1_20_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.20/11 28/02/94  11.26.52  by  O.Couet
*-- Author :    O.Couet   02/11/93
*
*::>          VERSION  1.20/11   28/02/94 11.26.52
*
*   Bugs fixed in IGTABL (default parameter values initialization).
*   IGERR was called in IGWKTY without LUNERR and LUNOUT initialized.
*   Update in IZHIST to take into account the new 'Z' option of IGHIST.
*
*::>          VERSION  1.20/10   21/02/94 11.15.35
*
*   Mods in IGTEXT, IKFNTX *HIGZ and *HIGZEXAM for Windows-NT (Valery Fine)
*   New option 'Z' in IGHIST. Like in IGRAPH, if it is selected, the vectors
*      X and Y are taken into PAWC at the adresses IQUEST(81) and IQUEST(82).
*      This protect agains the ZEBRA garbage collections.
*
*::>          VERSION  1.20/09   26/01/94 09.21.23
*
*   IGPICK is now able to pick IGARC.
*   Mod in IXOPNDS (x11int): The display was reopen for each window.
*   The READ in IGWKTY is in FORTRAN (IXGETL under the flag CCREAD) because
*      KUIP do the READ in FORTRAN (cf FFREAD).
*   Mod in ISTXFP for the FALCO driver.
*
*::>          VERSION  1.20/08   20/01/94 11.30.15
*
*   The 3D is available (ISWN3, ISVP3) for the X11 only. ntmgt should be
*      used also with the GKS version.
*   New routine IXDOGIF to produce gif files. It is available only if
*      if the FLAG GIF is selected.
*   Correction in IKERNEL/IPM: The marker size was not linear
*
*::>          VERSION  1.20/07   17/01/94 18.06.42
*
*   Mods in the FALCO driver: John Clement
*   Protection added in IZDIPI. (LN)
*   IXCLSDS perform immediatly a return if display=NULL
*   Bug fixed in IHPVIE (a RETURN was missing).
*   Mods in IOPWK, IGWKTY, IGINIT and IKFILE to be able to call
*      IGWKTY before or after IGINIT.
*
*::>          VERSION  1.20/06   07/01/94 18.38.19
*
*   Mod in IGXMES for IBM/VM.
*   New 3D routines: ISWN3 and ISVP3. See the HIGZ manual for more details
*   Protection added in IHSDRL (if NT > NTMAX).
*   Mods in IGTABL to use the new 3D routines
*   Mods for FALCO driver: John Clement, Rice University
*      <CLEMENT@physics.rice.edu>. I some places, test like IWTYPE.EQ.7878
*      should be IGIWTY(IWKID).EQ.7878
*
*::>          VERSION  1.20/05   08/12/93 09.33.04
*
*   Bug fixed in IGAXIS. In some cases (it seems very rarely because
*      the code has not change in this part since at least 3 years)
*      in the test:
*          IF((X00-XONE).GT.EPSIL) GOTO 150
*      EPSIL was to big. Now the test is:
*          IF(X00.GT.XONE) GOTO 150
*      and in fact that is what is needed in this case.
*   Changes in rotated to avoid warnings with /com/cc on APOLLO.
*
*::>          VERSION  1.20/04   26/11/93 13.42.06
*
*   Fix in higzcc/rotated for IBM/VM: The text width returned for
*      lowercase is 0. Now it is protected.
*   New routine IGDWK to Get the Default WorKstation type. This
*      routine is called by IGWKTY.
*
*::>          VERSION  1.20/03   23/11/93 11.44.01
*
*   Mods in IGCOLM in order to support default position and color map.
*   The xvertext package to rotate and scale X11 fonts is now available
*      in higzcc/rotated (Alan Richardson(mppa3@uk.ac.sussex.syma))
*      Now the X11 fonts are managed as follows:
*            font=xx precision=0 : X11 font a rotated
*            font=xx precision=1 : IGTEXT is used on the screen
*            font=xx precision=2 : X11 font a rotated and scaled.
*   Fix in higzcc/rotated for IBM/VM.
*   Protection added in ixgetge: sometimes (for instance after a CTRL-C),
*      XGetGeometry returns wrong values. In this case the previous "good
*      values" are used.
*
*::>          VERSION  1.20/02   08/11/93 09.53.03
*
*   IXSELWI is now called in IACWK (X11) to be sure the window
*      in active even if IGTERM is not called.
*
*::>          VERSION  1.20/01   03/11/93 11.12.27
*
*   The unused routine IGPHSL is now removed.
*   The PATCH IGKS3D is removed (not used and not documented). The
*      related routines in IG and the corresding KEEP in HICDES are
*      also removed.
*
*::>          VERSION  1.20/00   02/11/93 17.44.57
*
*   Some unused sequences are removed.
*
+DECK,  V1_21_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.21/12 25/10/94  13.47.25  by  O.Couet
*-- Author :    O.Couet   30/03/94
*
*::>          VERSION  1.21/12   25/10/94 13.47.24
*
*   Bug fixed in IPIOUT: the I7 format was too small. It is now I15.
*
*::>          VERSION  1.21/11   21/10/94 12.01.27
*
*   Improvement in IGAXIS in case of integer labelling. The optimization
*      provide by IGAXI0 is better than the one provide by IGAXI4. When
*      integer labelling is required, IGAXI0 is invoke first and only
*      if the result is not an integer labelling, IGAXI4 is invoked.
*
*::>          VERSION  1.21/10   17/10/94 15.08.15
*
*   VIDQQ is now removed from IGINIT because it is now in igvers.
*   Mods IGAXIS to have a better drawing of label like 10^xxx: Now we
*      take into account the length of the exponant to avoid
*      overlapping text. (improvement suggested by Mike Kelsey).
*   New option HWCO in IGQWK to return the number of hardware colours
*      available.
*
*::>          VERSION  1.21/09   27/09/94 17.41.14
*
*   In IGPICK, TA_IND was not declared as an INTEGER. It is now
*      replaced by ITAIND.
*   Mods in X11INT: VAX machines was asumed to be X11R3 now
*      they are consider as X11R4 (at least) machines. APOLLO machines
*      are still consider as X11R3 machines.
*   Bug fixed in IACWK (X11 version). The line width set was not the
*      same as the one set by ISLWSC.
*   Bug fixed in ICLKS. This routine close all the workstations still
*      open. It was looping on ILOPWK but this list was changed by
*      ICLWK, so ICLKS tried to close a non opened workstation. Now
*      ILOPWK is copied in an intermediate array.
*   Mods in IRQST/GPR. A small editor is now available.
*      (Robert Franchisseur robert@ramses.ibp.fr)
*   New C routine igvers to return the current HIGZ version. It is
*      used by the PAW command BUGREPORT
*   Precision problem in LOG scale has been solved (hopefully) in
*      IGAXIS. (XMNLOG-IH1).GT.EPSIL is now (XMNLOG-IH1).GT.0.. This
*      problem has been reflected in the pawdemo file.
*   Protection added in ISTXAL (IKERNEL): ixsetta was called even
*      with GFLAG=.FALSE.
*   New option 'X' in IGZSET to turn OFF the 'Z' mode without changing
*      the 'G' mode (used in HPLOPT).
*   New set of pattern in the X11 driver.
*   The Fill Pattern from 1 to 25 are now available also on PS files.
*      be careful with GhostView because to many filled areas with
*      such patterns can block this program.
*   Speed optimization in the PS file writing (a factor 3.6). A fast
*      writting routine has been introduced (IPPSTF entry point of
*      IPPSTR). In IPIOUT some code of IPPSTR is now inlined. IPDRAW
*      call has been replaced by two IPIOUT calls. The speed up gained
*      is the following (a 100x100 scatter plot):
*         Real time 00:01:08 (Old version)
*         Real time 00:00:34 (new IPIOUT)
*         Real time 00:00:22 (IPPSTF and inline in IPIOUT)
*         Real time 00:00:19 (suppress IPDRAW in IZPM)
*
*::>          VERSION  1.21/08   22/07/94 15.22.13
*
*   New routine IXWARP in x11int to move the pointer at a given
*      position (Adeyemi Adesanya).
*   New routine IZPAVE to store IGPAVE as a macro primitive. It implies
*      also mods in IZDNB and IGPICK.
*   Mods in IGRAP1 (push the LX and LY banks) in order to draw
*      filled area in one go.
*   Changes in IGPICK to pick text (Yemi)
*   A blank was missing in IPFON (DECS only)
*
*::>          VERSION  1.21/07   30/06/94 14.56.15
*
*   Protection added in IKFILE (ERR=999 in the last READ).
*   New routine IXQPTR in x11int to query the current pointer
*      position (Adeyemi Adesanya).
*   Mods in IGTAB5 to return in QUEST the axis positions (useful
*      for HPLOT to draw the axis titles).
*
*::>          VERSION  1.21/06   27/06/94 18.21.00
*
*   Mods in IZFILE to take into account the new option 'N' of RZMAKE.
*   Mods in IGTABL and IGTAB2 in order to close the surface plots
*      when the options POL, CYL, SPH or PSD are used.
*   Bug fixed in ixreqlo (x11int) when a button was pressed, the
*      cursor was undefined but not set to NULL (now it is).
*
*::>          VERSION  1.21/05   17/06/94 17.41.08
*
*   Bug fixed in IXCLSDS (X11INT): isdisp was not reset.
*      (Thierry MOUTHUY, <mouthuy@marpix1.in2p3.fr>).
*   New options 'E' and 'C' in IGZSET.
*   New options 'FB' and 'BB' in IGTABL.
*
*::>          VERSION  1.21/04   10/06/94 15.05.39
*
*   New option 'K' in IGHIST (histogram are pacKed like in HBOOK).
*   Fix in X11INT/ixreqst: in some cases, the '?' cursor was not
*      set correctly.
*   Protection added in IZPM and IGAXIS: when IGTEXT is called with
*      option 'S', the ANGLE parameter should be initialize to 0.
*   Optimization in IGAXIS to avoid identical labels on the same
*      axis (IF1 and IF2 too small), and to avoid x10^0.
*   In the sequence HIATT, all the variables are now declared.
*
*::>          VERSION  1.21/03   06/06/94 13.34.58
*
*   New version of IZPM (PS driver) to have shorter files.
*   Mods in IKFNTX to have a better maping between X11 and PS fonts.
*   Interface to GKSBx (CMZ flag: GKSBX).
*   Mods in IGKS and IDI3000 to use the C management of the NTs.
*   The cursor is reset after a request locator in sample mode (X11).
*   Mods is IPTEXT: the "stwn" value is now printed in I6.
*   Bug fixed in IGSA (FALCO version): it was a side effect of the
*     last mod apply for GPR (bug reported by Andrea Parri).
*
*::>          VERSION  1.21/02   19/05/94 10.09.37
*
*   Bug fixed in IGAXIS (precision problem on IBM/VM). This was a side
*      effect of the fix made in the version 1.20/05 for the X00 and
*      XONE comparison. Now the variable XMNSAV is not used, only XMNLOG
*      is used.
*   Bug fixed in IGSA (GPR version). GPR_RELEASE_DISPLAY was not
*      called if no workstation was opened.
*   Bug fixed in the PostScript driver: if EPS is selected and if the
*      BoundingBox is not yet in the file, the clipping cannot be set.
*
*::>          VERSION  1.21/01   11/05/94 18.57.56
*
*   New option 'W' in IGPXMP (write a pixmap in a bitmap file).
*   Major changes in the PostScript driver: the clipping is now
*      managed in the PS file itself.
*
*::>          VERSION  1.21/00   30/03/94 18.14.42
*
*   IGINIT: If GKSIBM is selected, METDEF = 3
*   In IGSA (DECGKS), '\' is now BSLASH (AlphaVMS).
*
+DECK,  V1_22_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :  1.22/11 07/04/95  10.46.41  by  O.Couet
*-- Author :    O.Couet   10/11/94
*
*::>          VERSION  1.22/11   07/04/95 10.46.41
*
* Bug fixed in IGPAVE: The coordinates was not stored in the correct
* order.
*
*::>          VERSION  1.22/10   05/04/95 15.48.50
*
* Fix in IZTX: the IGTEXT call (for PS) was not done with GFLAG=.TRUE.
*
* 05/04/95  11.03.50
* Bug fixed in IGAXIS. When the axis is close to the vertical a test
* XMIN = XMAX was done. Now we compare the difference to EPSIL.
*
* 03/04/95  17.08.19
* Fix in IPPATT: the trailing blank before the continuation line in
* the middle of a character string are removed on VAXes.
*
* 03/04/95  10.36.54
* Bug fixed in //HIGZ/IKERNEL/IRQLC. After the MAIL option removal
* the SAMPLE variable was not initialized (a +SELF was missing).
*
*::>          VERSION  1.22/09   23/03/95 15.25.29
*
* Bug fixed in IPL (all the versions): The clipping on line type
* greater than 12 was not correct.
*
* 09/03/95  16.17.22
* Mods in IGTABL and IGHCXY to drawn the errors (color) correctly for
* 1D histos.
*
*::>          VERSION  1.22/08   09/03/95 14.09.16
*
* New option E in IGTABL. This option allows to draw the error
* on 2D histograms. Used with S1, S2, etc the colors are mapped
* on the errors not on the content.
*
* 27/02/95  17.41.51
* The MAIL option (telnetg) has bin removed from the installation
* cradle *HIGZ.
*
* 24/02/95  16.57.11
* Misplaced RETURN in IGWWK (options 2BUF and HWCO).
*
* 24/02/95  15.46.45
* Bug fixed in IGTAB4: Th background color for surface was not correct
* if, for example, BCOL=1102.
*
* 22/02/95  12.05.12
* All the ONtuple material has been moved in the OBSOLETE patch.
*
* 14/02/95  10.43.48
* Bug fixed in IKBOX for the FALCO driver. IGSG was missing.
*
*::>          VERSION  1.22/07   09/02/95 17.03.34
*
* Bug fixed in IPTEXT. Some arrays was accessed with wrong indeces.
*
* 07/02/95  10.10.51
* Mod in IPEND: In some cases (for example NEXT at the end of a macro)
* a PS file was terminated like an EPS file.
*
*::>          VERSION  1.22/06   03/02/95 12.15.27
*
* Bug fixed in IPTEXT: in some case the text was cutted in the middle
* of an octal code.
*
*::>          VERSION  1.22/05   30/01/95 11.02.06
*
*   Bug fixed in IZSCLI. The PostScript clipping was stored in
*   the LaTex file (-777).
*
* 27/01/95  16.28.10
*
*   Better drawing of the ARC border. Patch IG: IGARC2 IGARC3 IGARC4
*
*::>          VERSION  1.22/04   25/01/95 17.50.08
*
*   New routine IXMOVWI to move an X11 window.
*
* 25/01/95  15.44.18
*
*   New option WIID in IGQWK to return the window identifier associated
*   to a given workstation ID.
*
*   Bug fixed in ixgetwi (x11int): It was not working for several
*   windows.
*
*::>          VERSION  1.22/03   06/01/95 15.29.04
*
*   ISWN3 is called in IGTABL instead of IHSVIE. If IHSVIE is called,
*      a sequence like:
*         call hplfr3(0.,4.,0.,1.,0.,1.,30.,30.,'WBF')
*         lego 20
*      does not work because the window (ISWN3) is not normalized after
*      the call to HPLFR3.
*   Protection added in ISVP3 and ISWN3
*
*::>          VERSION  1.22/02   05/01/95 15.10.45
*
*   Mods in IZSCLI, IPINIT, IPZONE: The clipping is now set only
*      if IPZONE has been called. Otherwise some clipping problems
*      can append if there is several zones in the PS file
*   Mod in IPDEF: atend is replaced by (atend).
*
*::>          VERSION  1.22/01   15/11/94 15.57.56
*
*   Modif in IGAXIS to have the correct label alignment (L,R,C) for
*      vertical axis. I the previous version it was set to Left always
*      if the axis was drawn TOP do DOWN. IGCOLM also been modified
*      accordingly.
*
*::>          VERSION  1.22/00   10/11/94 11.49.51
*
*   Modif in the definition of the clipping for PostScript to avoid
*      side effect in FrameMaker.
*
+DECK,  V1_23_D, T=DATA, IF=DOC.
*
* $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
*
* $Log: higzzz.car602,v $
* Revision 1.4  2005/04/14 11:59:03  tretiak
* *** empty log message ***
*
* Revision 1.1.1.1  1996/02/14 13:10:19  mclareni
* Higz
*
*
*CMZ :          11/01/96  17.24.46  by  O.Couet
*-- Author :    O.Couet   05/05/95
*
* 11/01/96  17.23.40  by  O.Couet
* Mods in IGTABL: the box plot is now proportional to the surface
* of the bin.
*
*::>          VERSION  1.23/06   07/12/95 16.10.56
*
* New routine IGGIF which call ixdogif to generate gif files
*
* 06/12/95  15.21.14  by  O.Couet
* It is now possible to load a GIF file in the HIGZ window.
*
* 04/12/95  16.08.02  by  O.Couet
* ZBUFFER is now available in X11 and PS modes
*
* 30/11/95  15.27.00  by  O.Couet
* The patch OBSOLETE is now removed (ONT).
*
* 22/11/95  10.38.53  by  O.Couet
* __stdcall added in the fortran callable C routines under the flags
* TKTCL and WINNT.
*
* 22/11/95  10.14.20  by  O.Couet
* TkHIGZ added in HIGZCC (flaged with TKTCL,WINNT).
*
* 15/11/95  09.28.50  by  O.Couet
* The GIFencode routine is suppressed. It is recommended to use
* xwpick instead.
*
* 10/11/95  10.51.30  by  O.Couet
* Mods in IGCOLM
*
* 01/11/95  14.05.51  by  O.Couet
* Mods in IMAC (Cees Th. de Laat)
*
*::>          VERSION  1.23/05   18/10/95 10.14.00
*
* In x11int, size_hints and wm_hints are memset to 0.
*
* 17/10/95  18.22.29  by  O.Couet
* New routine IGELLI to draw an ellipse.
*
* 11/10/95  17.26.20  by  O.Couet
* The default value of CHHE in igset is now 0.28 (like in HPLOT).
*
* 04/10/95  17.40.07  by  O.Couet
* IRAST was not initialized in IGTABL
*
* 02/10/95  17.14.30  by  O.Couet
* TK_WINDOWS flag in x11int
*
*::>          VERSION  1.23/04   28/09/95 09.54.20
*
* Mods in x11int: free the colors before defining a new one.
*
*::>          VERSION  1.23/03   20/09/95 14.08.27
*
* Bug fixed in IZPM. The marker types different from 1 to 5 produced
* some PS output in the LaTex files.
*
* 05/09/95  15.03.33
* A +SELF was missing in ISTXAL in IKERNEL
*
* 04/09/95  12.17.57
* Fixes in IGOBJ and IGPICK for the picking in PAW++
*
* 01/09/95  09.45.00
* IKFILE crashed if the file higz_windows.dat was r/w protected.
*
*::>          VERSION  1.23/02   30/08/95 18.20.27
*
* Bug fixed in IZDNB: the alpha numeric labels was not stored
* in the picture in case of IZMERG.
*
* 30/08/95  13.44.39
* The test of validity on window size in IGSSE is now a
* .LT.0 test instead of .LE.0 test
*
* 29/08/95  11.43.13
* The PASS attribute is now use as line width for the PS
* hollow fonts.
*
* 15/08/95  17.39.19
* IKFNTX called IXSETTF as a subroutine, rather than an
* integer function in the MSDOS part.
*
* 07/06/95  17.36.31
* %%BeginProlog and %%EndProlog was misplaced in PS files.
*
* 01/06/95  16.16.50
* Xflush is now called at the end of ixreqlo (x11int) to be
* sure that rubberdanding line has been erased.
*
* 30/05/95  09.45.20
* Bug fixed in igaxis: The alignment of the exponent was
* not correct on the axis drawn on the right of the plots.
*
*::>          VERSION  1.23/01   24/05/95 11.13.21
*
* The "gsave" an "grestore" are now managed via the routine
* IPSVRT which count the number of gsave in the variable NBSAVE.
* This allows to write the correct number of grestore at the
* end of the PS file.
*
* 08/05/95  11.51.44
* New MSDOS version (Valery Fine)
*
*::>          VERSION  1.23/00   05/05/95 15.25.21
*
* In IZGRAP and IZHIST, BORD was not consider as a possible
* attribute for graphs and histograms.
*
* 10/04/95  17.50.26
* Bug fixed in IGPICK for the picking of IGTABL.
*
* 10/04/95  10.39.58
* New version of IGOBJ which looks in all the NTs if nothing is found
* in the one the user picked in. A new routine to scan the NTs in a
* picture has been created for that (IZGNNT).
*
+PATCH, MENU.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
SRCS_F=	igcmp.F igdelm.F igdime.F iggch.F iggdef.F ighigh.F \ @@\
	igmenu.F igsmp.F

SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  IGCMP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

      SUBROUTINE IGCMP(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT,IR)
*.===========>
*.
*.   This routine change the place of the current displayed menu.
*.
*..==========> (O.Couet)
+CDE, HIMENU.
+CDE, HILOC.
+SELF, IF=GKS,DI3000.
+CDE, HIATT.
+SELF, IF=GKS,DI3000.
+CDE, HIFLAG.
+SELF.
      DIMENSION IOPT(*)
      CHARACTER*(*) CHITEM(*),TITLE,CHDEF(*),CHVAL
      CHARACTER*(*) CHUSER(*)
*.______________________________________
*
      CALL IGDELM(IOPT)
+SELF, IF=GKS, IF=-MGKS.
      IF(GFLAG)THEN
         IF(MENNUM.NE.0)THEN
            IF(ISEGM(MENNUM).NE.0)THEN
               CALL GDSGWK(IDID,MENNUM)
               ISEGM(MENNUM)=0
               RETURN
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=DI3000.
      IF(MENNUM.NE.0)THEN
         IF(ISEGM(MENNUM).NE.0)THEN
            CALL JPURGE(MENNUM)
            ISEGM(MENNUM)=0
            RETURN
         ENDIF
      ENDIF
+SELF.
*
      IF(IR.NE.0)THEN
   10    CALL IGLOC(1,NT,IBN,X1,Y1,XWC,YWC)
         IF(IBN.EQ.0)GOTO 10
         XPOS(1)=X1-(XPOS(2)-XPOS(1))
         YPOS(1)=Y1-(YPOS(2)-YPOS(1))
         XPOS(2)=X1
         YPOS(2)=Y1
         GOTO 30
      ELSE
   20    CALL IGLOC(1,NT,IBN,X1,Y1,XWC,YWC)
         IF(IBN.EQ.0)GOTO 20
         CALL IGLOC(51,NT,IBN,X2,Y2,XWC,YWC)
         IF(IBN.EQ.0)GOTO 20
         IF((ABS(X1-X2).LT.0.01).OR.
     +   (ABS(Y1-Y2).LT.0.01))GOTO 30
         XPOS(1)=X1
         XPOS(2)=X2
         YPOS(1)=Y1
         YPOS(2)=Y2
         IF(XPOS(2).LT.XPOS(1))THEN
            R=XPOS(2)
            XPOS(2)=XPOS(1)
            XPOS(1)=R
         ENDIF
         IF(YPOS(2).LT.YPOS(1))THEN
            R=YPOS(2)
            YPOS(2)=YPOS(1)
            YPOS(1)=R
         ENDIF
      ENDIF
*
   30 ICUCHS=ICUCH
      CALL ISTXCI(1)
      CALL IGDIME(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT)
      IF(IOPT(1).NE.0.AND.IOPT(5).EQ.0)THEN
         CALL IGHIGH(ICUCHS,CHITEM,CHUSER,IOPT)
      ENDIF
      OLDXP=XPOS(1)+(XPOS(2)-XPOS(1))/2
      OLDYP=Y3-YSTEP
*
      END
+DECK,  IGDELM, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:15  mclareni
* Higz

      SUBROUTINE IGDELM(IOPT)
*.===========>
*.
*.   This routine delete the current displayed menu.
*.
*..==========> (O.Couet)
+CDE, HIMENU.
+SELF, IF=GKS,DI3000.
+CDE, HIFLAG.
+SELF.
      CHARACTER*8 CHOPT
      DIMENSION IOPT(*)
*.______________________________________
*
+SELF, IF=GKS, IF=-MGKS.
      IF(GFLAG)THEN
         IF(MENNUM.NE.0)THEN
            IF(ISEGM(MENNUM).NE.0)THEN
               CALL GSVIS(MENNUM,0)
               RETURN
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=DI3000.
      IF(MENNUM.NE.0)THEN
         IF(ISEGM(MENNUM).NE.0)THEN
            CALL JVISBL(MENNUM,0)
            RETURN
         ENDIF
      ENDIF
+SELF.
*
      CHOPT=' '
      DZ=0.
      IF(IOPT(14).NE.0)CHOPT(1:2)='TR'
      IF(IOPT(15).NE.0)CHOPT(1:2)=' R'
      IF(IOPT(16).NE.0)CHOPT(3:3)='P'
      IF(IOPT(18).NE.0)CHOPT(4:4)='S'
      IF(IOPT(19).NE.0)CHOPT(5:5)='K'
      IF(CHOPT.NE.' ')DZ=5.*DEC
      CHOPT(6:6)='D'
      CALL IGPAVE(XPOS(1),XPOS(2),YPOS(1),YPOS(2)
     +,           DZ,0,0,CHOPT)
*
      END
+DECK,  IGDIME, T=FORT.
* Revision 1.2  1998/01/30 15:22:46  couet
* - APOLLO version removed
* Revision 1.1.1.1  1996/02/14 13:11:15  mclareni
* Higz

      SUBROUTINE IGDIME(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT)
*.===========>
*.
*.   This routine display the menu.
*.
*..==========> (O.Couet)
+CDE, HIMENU.
+SELF, IF=GKS,DI3000.
+CDE, HIFLAG.
+SELF.
      DIMENSION X(6),Y(6)
      DIMENSION IOPT(*)
      CHARACTER*4 CHOPT
      CHARACTER*(*) CHITEM(*),TITLE,CHDEF(*),CHVAL(*)
      CHARACTER*(*) CHUSER(*)
*.______________________________________
*
      CALL IGSMP(IOPT)
*
+SELF, IF=GKS, IF=-MGKS.
      IF(GFLAG)THEN
         IF(MENNUM.NE.0)THEN
            IF(ISEGM(MENNUM).NE.0)THEN
               CALL GSVIS(MENNUM,1)
               ICUCH=0
               RETURN
            ELSE
               ISEGM(MENNUM)=1
               CALL GCRSG(MENNUM)
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=DI3000.
      IF(MENNUM.NE.0)THEN
         IF(ISEGM(MENNUM).NE.0)THEN
            CALL JVISBL(MENNUM,1)
            ICUCH=0
            RETURN
         ELSE
            ISEGM(MENNUM)=1
            CALL JROPEN(MENNUM)
         ENDIF
      ENDIF
+SELF.
*
*              Set the correct font and precision
*
      IF(ISOFT.NE.0)THEN
         CALL ISTXFP(0,2)
      ELSE
+SELF, IF=X11.
         CALL ISTXFP(-8,0)
+SELF, IF=-X11.
         CALL ISTXFP(1,0)
+SELF.
      ENDIF
      CALL ISPLCI(1)
      CALL ISLN(1)
      CALL IGSET('BORD',1.)
*
      CALL ISCLIP(0)
*
*              Draw the Frame
*
      IF(IOPT(19).NE.0)GOTO 10
      CHOPT=' '
      DZ=0.
      ISFRAM=0
      IF(IOPT(14).NE.0)CHOPT(1:2)='TR'
      IF(IOPT(15).NE.0)CHOPT(1:2)=' R'
      IF(IOPT(16).NE.0)CHOPT(3:3)='P'
      IF(IOPT(18).NE.0)CHOPT(4:4)='S'
      IF(CHOPT.NE.' ')THEN
         DZ=5.*DEC
         IF(IOPT(18).EQ.0)THEN
+SELF, IF=GL,X11, IF=-MSDOS.
            ISFRAM=2
+SELF, IF=GKSGRAL,MSDOS.
            ISFRAM=-104
+SELF, IF=-GKSGRAL, IF=-GL, IF=-X11.
            ISFRAM=1
+SELF.
         ELSE
            ISFRAM=1001
         ENDIF
      ENDIF
      CALL IGPAVE(XPOS(1),XPOS(2),YPOS(1),YPOS(2)
     +,           DZ,0,ISFRAM,CHOPT)
      IF(NBCHOI.GT.0)THEN
         CALL ISFACI(0)
         CALL IGSET('BORD',1.)
         CALL IGBOX(XPOS(1)+DEC,XPOS(2)-DEC,Y4,Y3)
      ENDIF
      X(1)=XPOS(1)+RINT
      X(2)=X(1)
      Y(1)=Y3
      Y(2)=YPOS(2)
      CALL IPL(2,X,Y)
      X(1)=XPOS(2)-RINT
      X(2)=X(1)
      CALL IPL(2,X,Y)
      Y(1)=Y4
      Y(2)=Y4
      CALL IPL(2,XPOS,Y)
*
*              Draw the Title bar
*
   10 IF(IOPT(13).EQ.0)THEN
         CALL ISCHH(TH)
         CALL IGSET('TANG',0.)
         CALL ISTXAL(2,0)
         CALL ITX(XM,YT,TITLE)
         CALL ISFACI(0)
         X(1)=XPOS(1)+DEC
         X(2)=XPOS(1)+RINT-DEC
         Y(1)=Y3+DEC
         Y(2)=YPOS(2)-DEC
         CALL IGBOX(X(1),X(2),Y(1),Y(2))
         X(1)=XPOS(2)-RINT+DEC
         X(2)=XPOS(2)-DEC
         CALL IGBOX(X(1),X(2),Y(1),Y(2))
      ENDIF
*
*              Draw the middle bar in case of panel menu type
*
      IF(IOPT(5).NE.0)THEN
         X(1)=XM
         X(2)=XM
         Y(1)=Y3
         Y(2)=Y4
         CALL IPL(2,X,Y)
         X(1)=XPOS(2)-RINT
         X(2)=X(1)
         CALL IPL(2,X,Y)
      ENDIF
*
*              Draw the Options
*
      CALL ISCHH(OTH)
      YOPT=0.
      XOPT=XPOS(1)+RINT
      DO 20 I=1,NBCHOI
         Y(1)=Y3-YSIZ*(I-1)
         Y(2)=Y(1)
         IF(I.NE.1)THEN
            X(1)=XPOS(1)+DEC
            X(2)=XPOS(2)-DEC
            CALL IPL(2,X,Y)
         ELSE
            X(1)=XPOS(1)
            X(2)=XPOS(2)
            CALL IPL(2,X,Y)
         ENDIF
         YOPT=YOPT+YSTEP
         CALL ISTXAL(0,0)
         IF(CHITEM(I)(1:1).EQ.'|')THEN
            CALL ISFAIS(1)
            CALL ISFACI(1)
            CALL IGBOX(XPOS(1),XPOS(1)+DEC,Y(1)-YSIZ,Y(1))
            CALL ITX(XOPT,Y3-YOPT,CHITEM(I)(2:))
         ELSEIF(CHITEM(I)(1:1).EQ.'-')THEN
            CALL ISFAIS(3)
+SELF, IF=GL,X11, IF=-MSDOS.
            CALL ISFASI(2)
+SELF, IF=GKSGRAL,MSDOS.
            CALL ISFASI(-104)
+SELF, IF=-GKSGRAL, IF=-GL, IF=-X11.
            CALL ISFASI(1)
+SELF.
            CALL ISFACI(1)
            CALL IGBOX(XPOS(1)+DEC,XPOS(2)-DEC,Y(1)-YSIZ,Y(1))
            CALL ITX(XOPT,Y3-YOPT,CHITEM(I)(2:))
         ELSE
            CALL ITX(XOPT,Y3-YOPT,CHITEM(I))
         ENDIF
         CALL ISTXAL(2,0)
         IF(IOPT(5).NE.0)THEN
            CALL ISTXAL(0,0)
            CALL ITX(XM+RINT,Y3-YOPT,CHVAL(I))
            IF(INDEX(CHDEF(I),',').NE.0)THEN
               CALL ISFAIS(1)
               CALL ISFACI(1)
               CALL IGBOX(XPOS(2)-RINT+0.3*DEC,XPOS(2)-1.3*DEC ,
     +         Y(1)-YSIZ+0.3*DEC,Y(1)-0.3*DEC)
            ENDIF
            CALL ISTXAL(2,0)
         ENDIF
         YOPT=YOPT+YSIZ-YSTEP
   20 CONTINUE
*
*              Draw the user keys
*
      IF(NBUSER.NE.0)THEN
         CHOPT=' '
         DZ=0.
         ISFRAM=0
         IF(IOPT(19).NE.0)THEN
            DZ=5.*DEC
            CHOPT='TRK'
+SELF, IF=GL,X11, IF=-MSDOS.
            ISFRAM=2
+SELF, IF=GKSGRAL,MSDOS.
            ISFRAM=-104
+SELF, IF=-GKSGRAL, IF=-GL, IF=-X11.
            ISFRAM=1
+SELF.
         ENDIF
         Y(1)=YPOS(1)
         Y(2)=Y4
         X(1)=XPOS(1)
         X(2)=XPOS(1)+USIZ
         DO 30 I=1,NBUSER
            CALL IGPAVE(X(1),X(2),Y(1),Y(2)
     +,                 DZ,1000,ISFRAM,CHOPT)
            X(1)=X(1)+USIZ+IOPT(19)*DZ*2
            X(2)=X(1)+USIZ
   30    CONTINUE
         YU=YPOS(1)+RINT/2.-(UTH/2.)
         XU=XPOS(1)+USIZ/2.
         CALL ISCHH(UTH)
         CALL ISTXAL(2,0)
         DO 40 I=1,NBUSER
            CALL ITX(XU,YU,CHUSER(I))
            XU=XU+USIZ+IOPT(19)*DZ*2
   40    CONTINUE
      ENDIF
*
+SELF, IF=GKS, IF=-MGKS.
      IF(GFLAG)THEN
         IF(MENNUM.NE.0)THEN
            CALL GCLSG
         ENDIF
      ENDIF
+SELF, IF=DI3000.
      IF (GFLAG) THEN
         IF(MENNUM.NE.0)THEN
            CALL JRCLOS
         ENDIF
      ENDIF
+SELF.
*
      ICUCH=0
*
      END
+DECK,  IGGCH, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:15  mclareni
* Higz

      SUBROUTINE IGGCH(XPI,YPI,ICH,IOPT)
*.===========>
*.
*.   This routine gets the choice number.
*.
*. ICH=0 : out of the menu
*. ICH=-100 : title bar
*. ICH=-101 : left square
*. ICH=-102 : right square
*. ICH=-1... -NBUSER : user keys
*. ICH= integer > 0 : option number
*.
*..==========> (O.Couet)
+CDE, HIMENU.
      DIMENSION IOPT(*)
*.______________________________________
*
      IF((XPI.GT.XPOS(2)).OR.(XPI.LT.XPOS(1))
     +                  .OR.
     +   (YPI.GT.YPOS(2)).OR.(YPI.LT.YPOS(1)))THEN
         ICH=0
         RETURN
      ENDIF
*
      IF(YPI.GT.Y3)THEN
         IF(XPI.LT.XPOS(1)+RINT)THEN
            ICH=-101
            RETURN
         ENDIF
         IF(XPI.GT.XPOS(2)-RINT)THEN
            ICH=-102
            RETURN
         ENDIF
         ICH=-100
         RETURN
      ENDIF
*
      IF(YPI.LT.Y4)THEN
         IF(IOPT(19).NE.0)THEN
            TUSIZ=USIZ+10.*DEC
            ITCH=INT((XPI-XPOS(1))/TUSIZ)+1
            ULEN=ITCH*USIZ+(ITCH-1)*10.*DEC
            IF(XPI.GT.ULEN+XPOS(1))THEN
               ICH=0
            ELSE
               ICH=-ITCH
            ENDIF
         ELSE
            ICH=-(INT((XPI-XPOS(1))/USIZ)+1)
         ENDIF
         RETURN
      ENDIF
*
      ICH=NBCHOI-INT((YPI-Y4)/YSIZ)
*
      END

+DECK,  IGGDEF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:15  mclareni
* Higz

      SUBROUTINE IGGDEF(CCHIN,NB,CHOUT)
*.===========>
*.
*.   This routine returns the option number NB of CHIN in CHOUT.
*.
*..==========> (O.Couet)
      CHARACTER*(*) CCHIN,CHOUT
      CHARACTER*255 CHIN
*.______________________________________
*
      CHIN=CCHIN
      IF(INDEX(CHIN,',').EQ.0)THEN
         ILEN=LENOCC(CHIN)
         CHOUT=CHIN(1:ILEN)
      ELSE
         ILEN=INDEX(CHIN,',')
         CHOUT=CHIN(1:ILEN-1)
         IF(NB.GT.1)THEN
            DO 10 I=1,NB-1
               ILEN=INDEX(CHIN,',')
               IF(ILEN.EQ.0)RETURN
               CHIN(1:ILEN)=' '
   10       CONTINUE
            ILAST=LENOCC(CHIN)
            IF(INDEX(CHIN,',').NE.0)ILAST=INDEX(CHIN,',')-1
            CHOUT=CHIN(ILEN+1:ILAST)
         ENDIF
      ENDIF
*
      END
+DECK,  IGHIGH, T=FORT.
* Revision 1.2  1998/01/30 15:22:48  couet
* - APOLLO version removed
* Revision 1.1.1.1  1996/02/14 13:11:15  mclareni
* Higz

      SUBROUTINE IGHIGH(ICHOIC,CHITEM,CHUSER,IOPT)
*.===========>
*.
*.   This routine highlith the choice
*.
*..==========> (O.Couet)
+CDE, HIMENU.
+CDE, HIFLAG.
      DIMENSION X(2),Y(2)
      DIMENSION IOPT(*)
      CHARACTER*(*) CHITEM(*)
      CHARACTER*(*) CHUSER(*)
      LOGICAL ZFS,GFS
*.______________________________________
*
      ZFS=ZFLAG
      GFS=GFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
*
      IF(ICHOIC.LE.-100.OR.ICHOIC.GT.NBCHOI)GOTO 10
      CALL ISTXAL(0,0)
      CALL IGSET('TANG',0.)
      IF(ISOFT.NE.0)THEN
         CALL ISTXFP(0,2)
      ELSE
+SELF, IF=X11.
         CALL ISTXFP(-8,0)
+SELF, IF=-X11.
         CALL ISTXFP(1,0)
+SELF.
      ENDIF
      CALL ISCHH(OTH)
      XOPT=XPOS(1)+RINT
*
*              Highlith user key
*
      IF(ICHOIC.LT.0)THEN
         CALL ISFAIS(1)
         CALL ISFACI(1)
         CALL ISPLCI(1)
         CALL ISTXCI(0)
         Y(1)=YPOS(1)
         Y(2)=Y4
         X(1)=XPOS(1)-(ICHOIC+1)*USIZ-IOPT(19)*(ICHOIC+1)*10.*DEC
         X(2)=X(1)+USIZ
         CALL IGBOX(X(1),X(2),Y(1),Y(2))
         YU=YPOS(1)+RINT/2.-(UTH/2.)
         XU=X(1)+(USIZ/2.)
         CALL ISCHH(UTH)
         CALL ISTXAL(2,0)
         CALL ITX(XU,YU,CHUSER(-ICHOIC))
         GOTO 10
      ENDIF
*
*              Invert the last highlithed choice ICUCH
*
      IF(ICUCH.GE.0)THEN
         IF(ICUCH.EQ.0)ICUCH=ICHOIC
         CALL ISFAIS(1)
         CALL ISFACI(0)
         CALL ISPLCI(1)
         CALL ISTXCI(1)
         CALL IGSET('BORD',1.)
         X(1)=XPOS(1)+DEC
         X(2)=XPOS(1)+XSIZ-DEC
         Y(1)=Y3-ICUCH*YSIZ
         Y(2)=Y3-(ICUCH-1)*YSIZ
         CALL IGBOX(X(1),X(2),Y(1),Y(2))
         IF(CHITEM(ICUCH)(1:1).EQ.'-')THEN
            CALL ISFACI(1)
            CALL ISFAIS(3)
+SELF, IF=GL,X11.
            CALL ISFASI(2)
+SELF, IF=GKSGRAL.
            CALL ISFASI(-104)
+SELF, IF=-GKSGRAL, IF=-GL, IF=-X11.
            CALL ISFASI(1)
+SELF.
            CALL IGBOX(X(1),X(2),Y(1),Y(2))
         ENDIF
         IF(CHITEM(ICUCH)(1:1).EQ.'|')THEN
            CALL ITX(XOPT,Y3-YSIZ*(ICUCH-1)-YSTEP,CHITEM(ICUCH)(2:))
         ELSEIF(CHITEM(ICUCH)(1:1).EQ.'-')THEN
            CALL ITX(XOPT,Y3-YSIZ*(ICUCH-1)-YSTEP,CHITEM(ICUCH)(2:))
         ELSE
            CALL ITX(XOPT,Y3-YSIZ*(ICUCH-1)-YSTEP,CHITEM(ICUCH))
         ENDIF
      ENDIF
*
*              Highlith the choice ICHOIC
*
      CALL ISFAIS(1)
      CALL ISFACI(1)
      CALL ISPLCI(1)
      CALL ISTXCI(0)
      X(1)=XPOS(1)+DEC
      X(2)=XPOS(1)+XSIZ-DEC
      Y(1)=Y3-ICHOIC*YSIZ
      Y(2)=Y3-(ICHOIC-1)*YSIZ
      CALL IGBOX(X(1),X(2),Y(1),Y(2))
      IF(CHITEM(ICHOIC)(1:1).EQ.'|')THEN
         CALL ITX(XOPT,Y3-YSIZ*(ICHOIC-1)-YSTEP,CHITEM(ICHOIC)(2:))
      ELSEIF(CHITEM(ICHOIC)(1:1).EQ.'-')THEN
         CALL ITX(XOPT,Y3-YSIZ*(ICHOIC-1)-YSTEP,CHITEM(ICHOIC)(2:))
      ELSE
         CALL ITX(XOPT,Y3-YSIZ*(ICHOIC-1)-YSTEP,CHITEM(ICHOIC))
      ENDIF
      ICUCH=ICHOIC
*
   10 ZFLAG=ZFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFS
      END

+DECK,  IGMENU, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:15  mclareni
* Higz

      SUBROUTINE IGMENU(MN,TITLE,X1,X2,Y1,Y2,NBU,CHUSER
     +,                 N,CHITEM,CHDEF,CHVAL,ICHOIC,CHOPT)
*.===========>
*.
*.   This routine displays a menu and returns the users choice in ICHOIC
*.
*. _Input parameters:
*.
*. INTEGER MN            : Menu number. To use bitmap capabilities.
*. CHARACTER TITLE       : Menu title.
*. REAL X1,Y1            : Down left corner menu coordinates.
*. REAL X2,Y2            : Up right coner menu coordinates.
*. INTEGER NBU           : User squares number.
*. CHARACTER CHUSER(NBU) : Text in the users squares.
*. INTEGER N             : Number of items.
*. CHARACTER CHITEM(N)   : Text of the item.
*. CHARACTER CHDEF(N)    : Text of parameters.
*. INTEGER ICHOIC        : Input parameter if CHOPT='U' or CHOPT='H'.
*. CHARACTER CHOPT       : Options.
*.
*.      CHOPT='H' : The picked choice is Highlighted the last current
*.                  choice is given in ICHOIC.
*.      CHOPT='D' : Display the menu.
*.      CHOPT='C' : Permit a choice in the displayed menu.
*.      CHOPT='E' : Erase the menu.
*.      CHOPT='P' : The menu is a menu with parameters.
*.      CHOPT='R' : Return the current position of the menu.
*.      CHOPT='S' : Software character are used.
*.      CHOPT='U' : Update the user text user squares. The user square
*.                  number is given in ICHOIC. N.B. that options 'U'
*.                  and 'H' are incompatible because they used both
*.                  ICHOIC as input parameter.
*.      CHOPT='N' : The last input position is used to compute the value
*.                  of ICHOIC.
*.      CHOPT='M' : GKS Metafiles are activated.
*.      CHOPT='Z' : HIGZ metafiles are activated.
*.      CHOPT='B' : A rubberbanding boxe is used for the locator.
*.      CHOPT='T' : The title bar is not drawn, then the menu can not
*.                  be moved interactively.
*.      CHOPT='W' : The menu is drawn with Width.
*.      CHOPT='A' : The menu is drawn with shAdow.
*.      CHOPT='V' : Draw only the vertical part of Width.
*.      CHOPT='O' : 'V' Without "Oreilles".
*.      CHOPT='I' : Input menu. A parameter menu is displayed and IGMENU
*.                  Enter directly in request string. This is usefull to
*.                  do a request string without having a very complicated
*.                  initialization part.
*.      CHOPT='K' : Key menu. The user keys are drawn as a keyboard
*.
*. _Output parameters:
*.
*. CHARACTER CHVAL(N) : Array of parameters choiced.
*. INTEGER ICHOIC : Choice number.
*.
*. _Specials characters in first position of CHITEM(i):
*.
*. '|' The left of CHITEM(i) is colored in black
*. '-' The box of CHITEM(i) is colored in gray
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIMENU.
+CDE, HIMETA.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF.
      DIMENSION IOPT(19),IPLACE(50)
      SAVE IOPT
      DIMENSION X(2),Y(2)
      CHARACTER*(*) CHOPT,CHITEM(*),TITLE,CHDEF(*),CHVAL(*),CHUSER(*)
      CHARACTER*256 CHDEFT
      EQUIVALENCE (IOPT(1),IOPTH) ,(IOPT(2),IOPTD) ,(IOPT(3),IOPTC)
      EQUIVALENCE (IOPT(4),IOPTE) ,(IOPT(5),IOPTP) ,(IOPT(6),IOPTR)
      EQUIVALENCE (IOPT(7),IOPTS) ,(IOPT(8),IOPTU) ,(IOPT(9),IOPTN)
      EQUIVALENCE (IOPT(10),IOPTM),(IOPT(11),IOPTZ),(IOPT(12),IOPTB)
      EQUIVALENCE (IOPT(13),IOPTT),(IOPT(14),IOPTW),(IOPT(15),IOPTV)
      EQUIVALENCE (IOPT(16),IOPTO),(IOPT(17),IOPTI),(IOPT(18),IOPTA)
      EQUIVALENCE (IOPT(19),IOPTK)
      LOGICAL ZFS,GFS,MFS
*.______________________________________
*
      CALL UOPTC (CHOPT,'HDCEPRSUNMZBTWVOIAK',IOPT)
+SELF, IF=MAIL.
*
*              MAIL option
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(4I3,I10)') 557,MN,NBU,N,ICHOIC
         CALL IMWRIT(1)
         WRITE (CHMAIL,'(4E16.7,A16)') X1,X2,Y1,Y2,CHOPT
         CALL IMWRIT(2)
         IF(IOPTT.EQ.0)THEN
            CHMAIL=' '
            CHMAIL=TITLE
            CALL IMWRIT(2)
         ENDIF
         DO 10 I=1,N
            CHMAIL=' '
            WRITE (CHMAIL,'(2A32)') CHITEM(I),CHDEF(I)
            CALL IMWRIT(2)
   10    CONTINUE
         DO 20 I=1,NBU
            CHMAIL=' '
            CHMAIL=CHUSER(I)
            CALL IMWRIT(2)
   20    CONTINUE
*
         IF(IOPTC.NE.0)THEN
            READ (5,'(I5)') ICHOIC
            IF(IOPTP.NE.0.AND.N.GT.0)THEN
               CHMAIL='DUMMY'
               DO 30 I=1,N
                  CALL IMWRIT(2)
                  READ (5,'(A)') CHVAL(I)
   30          CONTINUE
            ENDIF
         ENDIF
         IF(IOPTI.NE.0)THEN
            READ (5,'(A)') CHVAL(1)
         ENDIF
         CALL IMWRIT(5)
         RETURN
      ENDIF
+SELF.
*
*              Check the valididy of the menu
*
      IF((NBU+N.EQ.0).AND.(IOPTT.EQ.1))THEN
         ICHOIC=0
         CALL IGERR('Empty menu','IGMENU')
         RETURN
      ENDIF
*
*              Save the currents attributes and the current NT
*
      CALL IZSAV
*
      ZFS=ZFLAG
      GFS=GFLAG
      IF(IOPTZ.NE.0)THEN
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      ELSE
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      ENDIF
      GFLAG=.TRUE.
*
      MFS=METACT
      IF(IOPTM.NE.0)THEN
         IF(.NOT.METACT)CALL IACWK(IDMETA)
         METACT=.TRUE.
      ELSE
         IF(METACT)CALL IDAWK(IDMETA)
         METACT=.FALSE.
      ENDIF
*
      CALL ISTXCI(1)
      CALL ISPLCI(1)
      CALL ISFAIS(1)
      CALL ISLN(1)
      CALL ISLWSC(1.)
      IF(ISOFT.NE.0)THEN
         CALL ISTXFP(0,2)
      ELSE
+SELF, IF=X11.
         CALL ISTXFP(-8,0)
+SELF, IF=-X11.
         CALL ISTXFP(1,0)
+SELF.
      ENDIF
      CALL IGSET('TANG',0.)
*
      REDLOC=REDIT
      CALL IGSRAP(0.)
      CALL ISELNT(0)
*
*              Set the locator type
*
      IF(IOPTB.NE.0)THEN
         ICURS=51
      ELSE
         ICURS=1
      ENDIF
*
*              Initialize the menu position
*
      MENNUM=MN
      NBCHOI=N
      NBUSER=NBU
      IF((ABS(X1-X2).LT.0.01).OR.(ABS(Y1-Y2).LT.0.01))THEN
         ICHOIC=0
         IF(IOPTC.NE.0)THEN
            REDIT=REDLOC
            CALL IGLOC(ICURS,NT,IBN,XP,YP,XWC,YWC)
            REDIT=0.
         ENDIF
         IF(IBN.EQ.0)ICHOIC=-1000
         RETURN
      ENDIF
      XPOS(1)=X1
      XPOS(2)=X2
      YPOS(1)=Y1
      YPOS(2)=Y2
      RATIO=RMDSY/RMDSX
      IF(RMDSX.GT.RMDSY)THEN
         YPOS(1)=Y1*RATIO
         YPOS(2)=Y2*RATIO
      ELSE
         XPOS(1)=X1/RATIO
         XPOS(2)=X2/RATIO
      ENDIF
      IF(XPOS(2).LT.XPOS(1))THEN
         R=XPOS(2)
         XPOS(2)=XPOS(1)
         XPOS(1)=R
      ENDIF
      IF(YPOS(2).LT.YPOS(1))THEN
         R=YPOS(2)
         YPOS(2)=YPOS(1)
         YPOS(1)=R
      ENDIF
*
*              Set the menu parameters in case of choice
*
      IF((IOPTN.NE.0).OR.(IOPTC.NE.0))THEN
         CALL IGSMP(IOPT)
      ENDIF
*
*              Input menu
*
      IF(IOPTI.NE.0)THEN
         IOPT(13)=1
         IOPT(5)=1
         IOPT(19)=0
         NBUSER=0
         CHVAL(1)=' '
         CALL IGDIME(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT)
         CALL ISTXAL(0,0)
         RQUEST(81)=((XM+RINT)*RMDSX)/RDWXMA
         RQUEST(82)=((XPOS(2)-RINT)*RMDSX)/RDWXMA
         RQUEST(91)=((Y3-YSTEP)*RMDSY)/RDWYMA
         RQUEST(92)=((Y3-YSTEP+OTH)*RMDSY)/RDWYMA
         CHDEFT=CHVAL(1)
         IWTMP=-IDID
         CALL IRQST(IWTMP,1,ISTA,ILEN,CHDEFT)
         IF(ISTA.NE.0)THEN
            IILEN=LENOCC(CHDEFT)
            CHVAL(1)=CHDEFT(1:IILEN)
         ENDIF
      ENDIF
*
*              Update the user keys
*
      IF((IOPTU.NE.0).AND.(ICHOIC.GT.0))THEN
         CALL IGSMP(IOPT)
         CALL ISFAIS(1)
         CALL ISFACI(0)
         CALL ISPLCI(1)
         CALL ISTXCI(1)
         CALL ISCHH(UTH)
         CALL ISTXAL(2,0)
         CALL IGSET('BORD',1.)
         Y(1)=YPOS(1)
         Y(2)=Y4
         X(1)=XPOS(1)+(ICHOIC-1)*USIZ+IOPT(19)*(ICHOIC-1)*10.*DEC
         X(2)=X(1)+USIZ
         CALL IGBOX(X(1),X(2),Y(1),Y(2))
         YU=YPOS(1)+RINT/2-UTH/2
         XU=X(1)+(USIZ/2.)
         CALL ITX(XU,YU,CHUSER(ICHOIC))
      ENDIF
*
*              Set the current highlihted choice
*
      IF(IOPTH.NE.0)THEN
         IF(ICHOIC.LT.0.OR.ICHOIC.GT.N)THEN
            ICUCH=0
         ELSE
            ICUCH=ICHOIC
         ENDIF
      ENDIF
*
*              Display the menu
*
      IF(IOPTD.NE.0)THEN
         IF(NBUSER.GE.100)NBUSER=99
         ISOFT=0
         IF(IOPTS.NE.0)ISOFT=1
         IF(IOPTP.NE.0)THEN
            DO 40 I=1,NBCHOI
               ILEN=INDEX(CHDEF(I),',')-1
               IF(ILEN.LT.0)ILEN=LENOCC(CHDEF(I))
               CHVAL(I)=CHDEF(I)(1:ILEN)
   40       CONTINUE
         ENDIF
         ICUCH=0
         CALL IGDIME(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT)
      ENDIF
*
*              Request the choice
*
      IF(IOPTC.NE.0)THEN
         DO 50 I=1,50
            IPLACE(I)=1
   50    CONTINUE
         IF(IOPTP.NE.0)THEN
            DO 60 I=1,NBCHOI
               ILEN=INDEX(CHDEF(I),',')-1
               IF(ILEN.LT.0)ILEN=LENOCC(CHDEF(I))
               CHVAL(I)=CHDEF(I)(1:ILEN)
   60       CONTINUE
            IF(IOPTN.NE.0)GOTO 80
   70       REDIT=REDLOC
            CALL IGLOC(ICURS,NT,IBN,XP,YP,XWC,YWC)
            REDIT=0.
            IQUEST(10)=NT
            RQUEST(11)=XP
            RQUEST(12)=YP
            RQUEST(13)=XWC
            RQUEST(14)=YWC
            IF(IBN.EQ.0)THEN
               ICHOIC=-1000
               GOTO 120
            ENDIF
   80       CALL IGGCH(XP,YP,ICHOIC,IOPT)
            IF(ICHOIC.EQ.-101)THEN
               CALL IGCMP(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT,0)
               GOTO 70
            ELSEIF(ICHOIC.EQ.-102)THEN
               CALL IGCMP(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT,1)
               GOTO 70
            ELSEIF(ICHOIC.GT.0)THEN
               ICUCH=ICHOIC
               IF(XP.LE.XM)THEN
                  CALL IGGDEF(CHDEF(ICUCH),1,CHVAL(ICUCH))
                  CALL ISFAIS(1)
                  CALL ISFACI(0)
                  CALL ISPLCI(1)
                  CALL ISTXCI(1)
                  CALL ISCHH(OTH)
                  CALL IGSET('BORD',1.)
                  X(1)=XM
                  X(2)=XM+XSIZ-RINT
                  Y(1)=Y3-ICUCH*YSIZ
                  Y(2)=Y3-(ICUCH-1)*YSIZ
                  CALL IGBOX(X(1),X(2),Y(1),Y(2))
                  CALL ISTXAL(0,0)
                  CALL ITX(XM+RINT,Y3-YSIZ*(ICUCH-1)-YSTEP
     +,                    CHVAL(ICUCH))
                  CALL ISTXAL(2,0)
                  LINENO=ICUCH
                  IF(LINENO.GT.50)LINENO=50
                  IPLACE(LINENO)=1
                  GOTO 70
               ELSEIF((XP.GE.(XPOS(2)-RINT)).AND.
     +                (INDEX(CHDEF(ICUCH),',').NE.0))THEN
                  CHDEFT=CHDEF(ICUCH)
                  IMOD=1
                  ILEN=LENOCC(CHDEFT)
                  IF(CHDEFT(ILEN:ILEN).EQ.',')CHDEFT(ILEN:ILEN)=' '
   90             ILEN=INDEX(CHDEFT,',')
                  IF(ILEN.NE.0)THEN
                     CHDEFT=CHDEFT(ILEN+1:LENOCC(CHDEFT))
                     IMOD=IMOD+1
                     GOTO 90
                  ENDIF
                  LINENO=ICUCH
                  IF(LINENO.GT.50)LINENO=50
                  IPLACE(LINENO)=IPLACE(LINENO)+1
                  IF(IPLACE(LINENO).GT.IMOD)IPLACE(LINENO)=1
                  CALL IGGDEF(CHDEF(ICUCH),IPLACE(LINENO)
     +,                       CHVAL(ICUCH))
                  CALL ISFAIS(1)
                  CALL ISFACI(0)
                  CALL ISPLCI(1)
                  CALL ISTXCI(1)
                  CALL ISCHH(OTH)
                  CALL IGSET('BORD',1.)
                  X(1)=XM
                  X(2)=XM+XSIZ-RINT
                  Y(1)=Y3-ICUCH*YSIZ
                  Y(2)=Y3-(ICUCH-1)*YSIZ
                  CALL IGBOX(X(1),X(2),Y(1),Y(2))
                  CALL ISTXAL(0,0)
                  CALL ITX(XM+RINT,Y3-YSIZ*(ICUCH-1)-YSTEP
     +,                    CHVAL(ICUCH))
                  CALL ISTXAL(2,0)
                  GOTO 70
               ELSEIF((XP.GT.XM).AND.(XP.LT.(XPOS(2)-RINT)))THEN
                  CALL ISFAIS(1)
                  CALL ISFACI(0)
                  CALL ISPLCI(1)
                  CALL ISTXCI(1)
                  CALL IGSET('BORD',1.)
                  CALL ISCHH(OTH)
                  X(1)=XM
                  X(2)=XM+XSIZ-RINT
                  Y(1)=Y3-ICUCH*YSIZ
                  Y(2)=Y3-(ICUCH-1)*YSIZ
                  CALL IGBOX(X(1),X(2),Y(1),Y(2))
                  CALL ISTXAL(0,0)
                  RQUEST(81)=((XM+RINT)*RMDSX)/RDWXMA
                  RQUEST(82)=((XPOS(2)-RINT)*RMDSX)/RDWXMA
                  RQUEST(91)=((Y3-YSIZ*(ICUCH-1)-YSTEP)*RMDSY)/RDWYMA
                  RQUEST(92)=((Y3-YSIZ*(ICUCH-1)-YSTEP+OTH)*RMDSY)/
     +                        RDWYMA
                  CHDEFT=CHVAL(ICUCH)
                  IWTMP=-IDID
                  CALL IRQST(IWTMP,1,ISTA,ILEN,CHDEFT)
                  IF(ISTA.NE.0)THEN
                     CHVAL(ICUCH)=' '
                     IILEN=LENOCC(CHDEFT)
                     CHVAL(ICUCH)=CHDEFT(1:IILEN)
                  ENDIF
                  CALL IGBOX(X(1),X(2),Y(1),Y(2))
                  CALL ITX(XM+RINT,Y3-YSIZ*(ICUCH-1)-YSTEP
     +,                    CHVAL(ICUCH))
                  CALL ISTXAL(2,0)
                  GOTO 70
               ENDIF
               GOTO 70
            ENDIF
         ELSE
            IF(IOPTN.NE.0)GOTO 110
  100       REDIT=REDLOC
            CALL IGLOC(ICURS,NT,IBN,XP,YP,XWC,YWC)
            REDIT=0.
            IQUEST(10)=NT
            RQUEST(11)=XP
            RQUEST(12)=YP
            RQUEST(13)=XWC
            RQUEST(14)=YWC
            IF(IBN.EQ.0)THEN
               ICHOIC=-1000
               GOTO 120
            ENDIF
  110       CALL IGGCH(XP,YP,ICHOIC,IOPT)
            IF(ICHOIC.EQ.-101)THEN
               CALL IGCMP(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT,0)
               GOTO 100
            ELSEIF(ICHOIC.EQ.-102)THEN
               CALL IGCMP(TITLE,CHUSER,CHITEM,CHDEF,CHVAL,IOPT,1)
               GOTO 100
            ELSEIF(ICHOIC.LT.0.AND.ICHOIC.GT.-100)THEN
               IF(IOPTH.NE.0.AND.IOPTP.EQ.0)CALL IGHIGH(ICHOIC,CHITEM
     +,                                                 CHUSER,IOPT)
            ELSEIF(ICHOIC.GT.0)THEN
               IF(IOPTH.NE.0.AND.IOPTP.EQ.0)CALL IGHIGH(ICHOIC,CHITEM
     +,                                                 CHUSER,IOPT)
               ICUCH=ICHOIC
            ENDIF
         ENDIF
      ENDIF
*
*              Erase the menu
*
      IF(IOPTE.NE.0)THEN
         CALL IGDELM(IOPT)
      ENDIF
*
*              Return the menu position
*
  120 IF(IOPTR.NE.0)THEN
         X1=XPOS(1)
         X2=XPOS(2)
         Y1=YPOS(1)
         Y2=YPOS(2)
         IF(RMDSX.GT.RMDSY)THEN
            Y1=Y1/RATIO
            Y2=Y2/RATIO
         ELSE
            X1=X1*RATIO
            X2=X2*RATIO
         ENDIF
      ENDIF
*
*              Reset the initial environment
*
      CALL IZSET
*
      CALL IGTERM
      CALL IGSRAP(REDLOC)
      ZFLAG=ZFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFS
      IF(MFS)THEN
         IF(METACT)THEN
            RETURN
         ELSE
            CALL IACWK(IDMETA)
         ENDIF
      ELSE
         IF(METACT)THEN
            CALL IDAWK(IDMETA)
         ELSE
            RETURN
         ENDIF
      ENDIF
      METACT=MFS
*
      END
+DECK,  IGSMP, T=FORT.
* Revision 1.2  1998/01/30 15:22:49  couet
* - APOLLO version removed
* Revision 1.1.1.1  1996/02/14 13:11:15  mclareni
* Higz

      SUBROUTINE IGSMP(IOPT)
*.===========>
*.
*.   This routine sets the menu parameters
*.
*..==========> (O.Couet)
+CDE, HIMENU.
+CDE, HIATT.
      DIMENSION IOPT(*)
*.______________________________________
*
      IF(XPOS(1).GT.RDWXMA)XPOS(1)=RDWXMA
      IF(XPOS(2).GT.RDWXMA)XPOS(2)=RDWXMA
      IF(XPOS(1).LT.0)XPOS(1)=0.
      IF(XPOS(2).LT.0)XPOS(2)=0.
      IF(YPOS(1).GT.RDWYMA)YPOS(1)=RDWYMA
      IF(YPOS(2).GT.RDWYMA)YPOS(2)=RDWYMA
      IF(YPOS(1).LT.0)YPOS(1)=0.
      IF(YPOS(2).LT.0)YPOS(2)=0.
*
      XSIZ=XPOS(2)-XPOS(1)
      NDIV=NBCHOI
      IF(IOPT(13).EQ.0)NDIV=NDIV+1
      IF(NBUSER.NE.0)NDIV=NDIV+1
      RINT=(YPOS(2)-YPOS(1))/FLOAT(NDIV)
      DEC=RINT/6.
*
      IF(IOPT(13).NE.0)THEN
         Y3=YPOS(2)
      ELSE
         Y3=YPOS(2)-RINT
      ENDIF
*
      IF(NBUSER.NE.0)THEN
         Y4=YPOS(1)+RINT
         USIZ=(XSIZ-IOPT(19)*(NBUSER-1)*10.*DEC)/NBUSER
      ELSE
         Y4=YPOS(1)
         USIZ=0.
      ENDIF
*
      YSIZ=RINT
      XM=XPOS(1)+(XSIZ/2.)
      IF(IOPT(5).NE.0)XSIZ=XSIZ/2.
*
      UTH=0.66*RINT
      TH=UTH
      OTH=UTH
*
      YT=YPOS(2)-(YSIZ/2.)-(TH/2.)
      YSTEP=(YSIZ/2.)+(OTH/2.)
*
      END

+PATCH, IZ.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
DoIncludePackage(higz)
#include "pilot.h"

SRCS_F=	izctoi.F izctor.F izitoc.F izpave.F izrtoc.F izsav.F izsava.F \ @@\
	izset.F izseta.F

#if defined(CERNLIB_ZEBRA)
SRCS_F := $(SRCS_F) izcda.F izcfa.F izcopy.F izdatt.F izdipi.F izdnb.F	\ @@\
	izfa3.F izfile.F izgadr.F izgcod.F izghnp.F izgngt.F izgnnt.F	\ @@\
	izgntp.F izin.F izincf.F izinci.F izincs.F izinit.F izmerg.F	\ @@\
	izml3.F izopen.F izout.F izpict.F izpl3.F izpm3.F izpush.F	\ @@\
	izrpip.F izscan.F izscpi.F izscr.F izsenv.F izstcc.F iztx3.F	\ @@\
	izwip.F
#endif

#if defined(CERNLIB_ZEBRA) || defined(CERNLIB_MAIL)
SRCS_F := $(SRCS_F) izarc.F izatt.F izaxis.F izend.F izfbox.F izgrap.F	\ @@\
	izhist.F izlbl.F izml.F izscor.F iztabl.F iztext.F
#endif

#if defined(CERNLIB_ZEBRA) || defined(CERNLIB_MAIL) || defined(CERNLIB_PSCRIPT)
SRCS_F := $(SRCS_F) izbox.F izclrd.F izfa.F izpl.F izpm.F izscli.F	\ @@\
	izseln.F iztx.F
#endif

#if !defined(CERNLIB_NTC) && !defined(CERNLIB_X11)
SRCS_F := $(SRCS_F) izgnt.F
#endif

SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  IZARC, T=FORT.
* Revision 1.2  1996/11/20 15:21:44  couet
* *** empty log message ***
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZARC(X,Y,R1,R2,PHI1,PHI2)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. draw an arc of circle .
*.
*. _Input parameters:
*.
*.  REAL X,Y : Center of the arc .
*.  REAL R1 : First radius .
*.  REAL R2 : Second radius .
*.  REAL PHI1 : First angle .
*.  REAL PHI2 : Second angle .
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(0,6,0,'IGARC').NE.0)RETURN
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(IBORCO,1)
*
         CALL IZSTCC(IARCCO,IFLPTR)
         Q(LHF+IFLPTR)=X
         Q(LHF+IFLPTR+1)=Y
         Q(LHF+IFLPTR+2)=R1
         Q(LHF+IFLPTR+3)=R2
         Q(LHF+IFLPTR+4)=PHI1
         Q(LHF+IFLPTR+5)=PHI2
         CALL IZINCF(6)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,4E16.7)') IARCCO,X,Y,R1,R2
         CALL IMWRIT(1)
         WRITE (CHMAIL,'(2E16.7)') PHI1,PHI2
         CALL IMWRIT(3)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZATT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZATT(IATTCO)
*.===========>
*.
*.   This routine stores in the current picture the REAL and INTEGER
*. HIGZ attributes. When an INTEGER attribute is stored in the data
*. structure, 100000 is added to the value of this attribute to
*. prevent the negatives values of some INTEGER attributes. In this
*. routine the case of the option MAIL is also managed.
*.   If CFLAG is true (default), attributes are stored only if they are
*. different from the current value in the bank. If CFLAG is false, they
*. are always stored. The value of CFLAG can be cahnged via a call to
*. IGZSET ('E' ==> false, 'C' ==> true).
*.
*. _Input parameters:
*.
*.  INTEGER IATTCO : Attribute code
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
+CDE, HIATNB.
+CDE, HIATT.
+CDE, HIFLAT.
+CDE, HIFLAG.
+CDE, HIAADR.
      DIMENSION RATVAL(NBRATT)
      EQUIVALENCE (RATVAL(1),RMKSC)
      DIMENSION IATVAL(NBIATT)
      EQUIVALENCE (IATVAL(1),IPLCI)
      DIMENSION IRFLAT(NBRATT),IIFLAT(NBIATT)
      EQUIVALENCE (IRFLAT(1),KMKSC),(IIFLAT(1),KPLCI)
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IPOS=IATADR(IATTCO-49)
         IF(IPOS.LT.0)CALL IZSCAN(LHNT,IATTCO,ITBPTR-1,-1,IPOS)
         IATADR(IATTCO-49)=IPOS
*
         IF(IATTCO.LT.80)THEN
            INDEX=IATTCO-49
            IF(IRFLAT(INDEX).NE.0)THEN
               IF(IPOS.EQ.0)THEN
                  IF((Q(LHF+IRAPTR+INDEX-1).EQ.RATVAL(INDEX))
     +               .AND.CFLAG)RETURN
                  GOTO 10
               ELSE
                  IF((Q(LHF+IZGADR(LHNT,IPOS)).EQ.RATVAL(INDEX))
     +               .AND.CFLAG)RETURN
                  GOTO 10
               ENDIF
   10          IF(IZPUSH(0,1,0,'IZATT').NE.0)RETURN
               IATADR(IATTCO-49)=ITBPTR
               CALL IZSTCC(IATTCO,IFLPTR)
               Q(LHF+IFLPTR)=RATVAL(INDEX)
               CALL IZCFA(IATTCO,0)
               CALL IZINCF(1)
            ELSE
               IF(IPOS.EQ.0)THEN
                  CALL IZCDA(IATTCO)
               ELSE
                  Q(LHF+IZGADR(LHNT,IPOS))=RATVAL(INDEX)
               ENDIF
            ENDIF
         ELSE
            INDEX=IATTCO-79
            IF(IIFLAT(INDEX).NE.0)THEN
               IF(IPOS.EQ.0)THEN
                  IF((IQ(LHI+IIAPTR+INDEX-1).EQ.IATVAL(INDEX))
     +               .AND.CFLAG)RETURN
                  GOTO 20
               ELSE
                  IF((IZGADR(LHNT,IPOS).EQ.(IATVAL(INDEX)+100000))
     +               .AND.CFLAG)RETURN
                  GOTO 20
               ENDIF
   20          IF(IZPUSH(0,0,0,'IZATT').NE.0)RETURN
               IATADR(IATTCO-49)=ITBPTR
               CALL IZSTCC(IATTCO,IATVAL(INDEX)+100000)
               CALL IZCFA(IATTCO,0)
            ELSE
               IF(IPOS.EQ.0)THEN
                  CALL IZCDA(IATTCO)
               ELSE
                  IQ(LHNT+IPOS)=1000000*IATTCO+(IATVAL(INDEX)+100000)
               ENDIF
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         IF(IATTCO.LT.80)THEN
            IND=IATTCO-49
            WRITE (CHMAIL,'(I3,E16.7)') IATTCO,RATVAL(IND)
         ELSE
            IND=IATTCO-79
            WRITE (CHMAIL,'(I3,E16.7)') IATTCO,FLOAT(IATVAL(IND))
         ENDIF
         CALL IMWRIT(4)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZAXIS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZAXIS(X0,X1,Y0,Y1,WMIN,WMAX,NDIV,IOPT)
*.===========>
*.
*.   This routine store in the current picture the necessary data to
*. draw an axis .
*.
*. _Input parameters:
*.
*.  REAL X0 : X origin axis coordinate in WC space .
*.  REAL X1 : X end axis coordinate in WC space .
*.  REAL Y0 : Y origin axis coordinate in WC space .
*.  REAL Y1 : Y end axis coordinate in WC space .
*.  REAL WMIN : Lowest value for the tick marks labels written on axis .
*.  REAL WMAX : Highest value for the tick marks labels written on axis .
*.  INTEGER NDIV : Number of division .
*.  INTEGER IOPT : Option . (See IGAXIS comments)
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
      DIMENSION IOPT(*)
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(3,6,0,'IGAXIS').NE.0)RETURN
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(ITMSCO,1)
         CALL IZCFA(IALHCO,1)
         CALL IZCFA(IALDCO,1)
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(ITXFCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
         CALL IZCFA(IAWLCO,1)
*
         CALL IZSTCC(IAXICO,INTPTR)
         IQ(LHI+INTPTR)=IFLPTR
         IQ(LHI+INTPTR+1)=NDIV
         DO 10 I=1,25
            IF(IOPT(I).NE.0)CALL SBIT1(IQ(LHI+INTPTR+2),I)
   10    CONTINUE
         CALL IZINCI(3)
         Q(LHF+IFLPTR)=X0
         Q(LHF+IFLPTR+1)=X1
         Q(LHF+IFLPTR+2)=Y0
         Q(LHF+IFLPTR+3)=Y1
         Q(LHF+IFLPTR+4)=WMIN
         Q(LHF+IFLPTR+5)=WMAX
         CALL IZINCF(6)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,4E16.7)') IAXICO,X0,X1,Y0,Y1
         CALL IMWRIT(1)
         WRITE (CHMAIL,'(2E16.7,I10,A10)') WMIN,WMAX,NDIV,CHOPTM
         CALL IMWRIT(3)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZBOX, T=FORT.
* Revision 1.2  1999/07/21 15:48:28  couet
* - Improvements in PS Patterns drawing
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZBOX(X1,X2,Y1,Y2)
*.===========>
*.
*.   This routine store in the current picture the necessary data to
*. draw a line box .
*.
*. _Input parameters:
*.
*.  REAL X1,Y1 : Left down corner .
*.  REAL X2,Y2 : Right up corner .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIATT.
+CDE, HIPOST.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      LOGICAL GSAV
      DIMENSION X(4),Y(4)
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIWCPS.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      IF(PFLAG)THEN
         CALL IPZONE
         IF(ICLIP.NE.0)THEN
            IX1=IXWCPS(MIN(MAX(X1,X1W),X2W))
            IX2=IXWCPS(MIN(MAX(X2,X1W),X2W))
            IY1=IYWCPS(MIN(MAX(Y1,Y1W),Y2W))
            IY2=IYWCPS(MIN(MAX(Y2,Y1W),Y2W))
         ELSE
            IX1=IXWCPS(X1)
            IX2=IXWCPS(X2)
            IY1=IYWCPS(Y1)
            IY2=IYWCPS(Y2)
         ENDIF
*
         IF(IFAIS.EQ.3.OR.IFAIS.EQ.2)THEN
            IF(IFASI.GE.100)THEN
               GSAV=GFLAG
               GFLAG=.FALSE.
               X(1)=X1
               X(2)=X2
               X(3)=X2
               X(4)=X1
               Y(1)=Y1
               Y(2)=Y1
               Y(3)=Y2
               Y(4)=Y2
               CALL IGFA(4,X,Y)
               GFLAG=GSAV
            ENDIF
            IF(IFASI.GE.1.AND.IFASI.LE.25..AND..NOT.TFLAG)THEN
               CALL IPDPAT(IFASI,IFACI)
               X(1)=X1
               X(2)=X2
               X(3)=X2
               X(4)=X1
               Y(1)=Y1
               Y(2)=Y1
               Y(3)=Y2
               Y(4)=Y2
               CALL IPDRAW(-4,X,Y)
               CALL IPPSTF(3,' FA')
            ENDIF
            IF(IFASI.EQ.-3.AND..NOT.TFLAG)THEN
               CALL IPSCOL(5)
               CALL IPIOUT(IX2-IX1)
               CALL IPIOUT(IY2-IY1)
               CALL IPIOUT(IX1)
               CALL IPIOUT(IY1)
               CALL IPPSTF(3,' bf')
            ENDIF
         ENDIF
*
         IF(.NOT.TFLAG.AND.IFAIS.EQ.1)THEN
            CALL IPLWID(1)
            CALL IPLTYP(1)
            CALL IPSCOL(IFACI)
            CALL IPIOUT(IX2-IX1)
            CALL IPIOUT(IY2-IY1)
            CALL IPIOUT(IX1)
            CALL IPIOUT(IY1)
            CALL IPPSTF(3,' bf')
         ENDIF
*
         IF(TFLAG.AND.IFAIS.EQ.1)THEN
            CALL IPTLIN('m',IX1,IY1)
            CALL IPTLIN('f',IX2-IX1,IY2-IY1)
         ENDIF
*
         IF(IFAIS.EQ.0.OR.IBORD.NE.0)THEN
            IF(TFLAG) THEN
               CALL IPPSTR(BSLASH//'put')
               CALL IPJOUT(IX1,IY1)
               CALL IPPSTR('{'//BSLASH//'framebox')
               CALL IPJOUT(IX2-IX1,IY2-IY1)
               CALL IPPSTR('{}}')
            ELSE
               CALL IPLWID(INT(RLWSC))
               CALL IPLTYP(1)
               CALL IPSCOL(IPLCI)
               CALL IPIOUT(IX2-IX1)
               CALL IPIOUT(IY2-IY1)
               CALL IPIOUT(IX1)
               CALL IPIOUT(IY1)
               CALL IPPSTF(3,' bl')
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,4E16.7)') IBXCO,X1,X2,Y1,Y2
         CALL IMWRIT(4)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(0,4,0,'IGBOX').NE.0)RETURN
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(IBORCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZSTCC(IBXCO,IFLPTR)
         Q(LHF+IFLPTR)=X1
         Q(LHF+IFLPTR+1)=X2
         Q(LHF+IFLPTR+2)=Y1
         Q(LHF+IFLPTR+3)=Y2
         CALL IZINCF(4)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZCDA, T=FORT.
* Revision 1.2  1996/11/20 15:21:45  couet
* *** empty log message ***
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZCDA(IATTCO)
*.===========>
*.
*.   This routine Changes the current normalisation transformation
*. Default Attributes .
*.
*. _Input parameters:
*.
*.  INTEGER IATTCO : Code of the attribute function .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATNB.
+CDE, HIATT.
      DIMENSION RATVAL(NBRATT)
      EQUIVALENCE (RATVAL(1),RMKSC)
      DIMENSION IATVAL(NBIATT)
      EQUIVALENCE (IATVAL(1),IPLCI)
*.______________________________________
*
      IF(LPICT.LE.0)RETURN
      INBIAT=IZGCOD(LHNT,8)
      INBRAT=IZGCOD(LHNT,9)
*
      IF(IATTCO.EQ.0)THEN
         DO 10 I=1,INBRAT
            Q(LHF+IRAPTR+I-1)=RATVAL(I)
 10      CONTINUE
         DO 20 I=1,INBIAT
            IQ(LHI+IIAPTR+I-1)=IATVAL(I)
 20      CONTINUE
      ELSE
         IF(IATTCO.LT.80)THEN
            INDEX=IATTCO-49
            IF(INDEX.GT.INBRAT)RETURN
            Q(LHF+IRAPTR+INDEX-1)=RATVAL(INDEX)
         ELSE
            INDEX=IATTCO-79
            IF(INDEX.GT.INBIAT)RETURN
            IQ(LHI+IIAPTR+INDEX-1)=IATVAL(INDEX)
         ENDIF
      ENDIF
*
      END
+SELF.
+DECK,  IZCFA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZCFA(IATTCO,IUD)
*.===========>
*.
*.   Change the Flag Attribute (of the current NT) IATTCO to the value IUD .
*.
*. _Input parameters:
*.
*.  INTEGER IATTCO : Code of the attribute function .
*.  INTEGER IUD : New flag state Up/Down (0/1) .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATNB.
+CDE, HIFLAT.
      DIMENSION IRFLAT(NBRATT),IIFLAT(NBIATT)
      EQUIVALENCE (IRFLAT(1),KMKSC),(IIFLAT(1),KPLCI)
*.______________________________________
*
      IF(IATTCO.LT.80)THEN
         INDEX=IATTCO-49
         CALL SBIT(IUD,IQ(LHNT+7),INDEX)
         IRFLAT(INDEX)=IUD
      ELSE
         INDEX=IATTCO-79
         CALL SBIT(IUD,IQ(LHNT+6),INDEX)
         IIFLAT(INDEX)=IUD
      ENDIF
*
      END
+SELF.
+DECK,  IZCLRD, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZCLRD
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. clear a workstation .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIPOST.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      IF(PFLAG)THEN
         IF(LOPRT)THEN
            IF(TFLAG)THEN
               CALL IPPSTR(BSLASH//'fi'//BSLASH//'end{picture}@')
               IF(IPTWTY.EQ.-778)THEN
                  CALL IPPSTR(BSLASH//'vfill'//BSLASH//'eject@')
                  LOBB=.FALSE.
               ENDIF
            ELSE
               IF (NBSAVE.GT.NBSAV0) CALL IPSVRT(-1)
            ENDIF
            LOPRT=.FALSE.
            LOCLR=.TRUE.
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         CALL SBIT1(IQ(LPICT),1)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3)') 101
         CALL IMWRIT(4)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZCOPY, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZCOPY(PNME1,PNME2,CHOPT)
*.===========>
*.
*.   This routine copy or rename the picture PNAME1 to the picture PNAME2
*. according to the parameter CHOPT .
*.
*. _Input parameters:
*.
*.  CHARACTER PNME1 : Picture name 1 .
*.  CHARACTER PNME2 : Picture name 2 .
*.  CHARACTER CHOPT : Option .
*.
*.                    CHOPT='C'opy .
*.                    CHOPT='R'ename .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
      CHARACTER*(*) CHOPT,PNME1,PNME2
      CHARACTER*20 PNAME1,PNAME2
      DIMENSION IOPT(2)
      LOGICAL GFSAV,ZFSAV
      EQUIVALENCE (IOPT(1),IOPTC),(IOPT(2),IOPTR)
*.______________________________________
*
      CALL UOPTC (CHOPT,'CR',IOPT)
      IF(CHOPT.EQ.' ')IOPTC=1
      PNAME1=PNME1
      PNAME2=PNME2
      NCHP2=LENOCC(PNME2)
      IF(NCHP2.GT.20)NCHP2=20
      IQUEST(1)=0
*
*              Adressing pictures by number
*
      INUM=IGASCI(PNAME2(1:1))
      IF(49.LE.INUM.AND.INUM.LE.57)GOTO 20
      INUM=IGASCI(PNAME1(1:1))
      IF(49.LE.INUM.AND.INUM.LE.57)THEN
         READ (PNAME1,'(I15)',ERR=20  ) INUM
         IF(INUM.GT.NBPICT)THEN
            CALL IGERR('Picture not in memory','IZCOPY')
            RETURN
         ENDIF
         LP=LQ(LHIGZ)
         DO 10  I=1,INUM-1
            LP=LQ(LP)
   10    CONTINUE
         LCH=LQ(LP-4)
         CALL UHTOC(IQ(LCH+1),4,PNAME1,IQ(LP+1))
      ENDIF
      GOTO 30
   20 CALL IGERR('PNAME must begin with a letter','IZCOPY')
      RETURN
   30 CONTINUE
*
*              Check the validity of PNAME1 and PNAME2
*
      LP1=IZRPIP(PNAME1)
      LP2=IZRPIP(PNAME2)
      IF(PNAME1.EQ.' ')LP1=LPICT
      IF(LP2.NE.0)THEN
         CALL IGERR('Picture already exist','IZCOPY')
         RETURN
      ENDIF
      IF(LP1.EQ.0)THEN
         CALL IGERR('Picture not in memory','IZCOPY')
         RETURN
      ENDIF
*
*              Copy
*
      IF(IOPTC.NE.0)THEN
         LPIC2=LP1
         L2NT0=LQ(LPIC2-1)
         L2I=LQ(LPIC2-2)
         L2F=LQ(LPIC2-3)
         L2C=LQ(LPIC2-4)
         CALL IZPICT(PNAME2,'M')
         GFSAV=GFLAG
         ZFSAV=ZFLAG
         GFLAG=.FALSE.
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         L2NT=L2NT0
         N=IQ(LPIC2+8)
         DO 50 I=1,N
            NT=IQ(L2NT+1)
            IF(NT.EQ.0)GOTO 40
            J=IQ(L2NT+2)
            CALL ISWN(NT,Q(L2F+J),Q(L2F+J+1),Q(L2F+J+2),Q(L2F+J+3))
            CALL ISVP(NT,Q(L2F+J+4),Q(L2F+J+5),Q(L2F+J+6),Q(L2F+J+7))
   40       CALL ISELNT(NT)
            CALL IZDNB(L2NT,L2I,L2F,L2C,0,0)
            L2NT=LQ(L2NT)
            IF(L2NT.EQ.0)GOTO 60
   50    CONTINUE
         IF(JBIT(IQ(LP1),1).NE.0)CALL SBIT1(IQ(LP2),1)
   60    GFLAG=GFSAV
         ZFLAG=ZFSAV
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL IZPICT(PNAME1,'C')
         RETURN
      ENDIF
*
*              Rename
*
      IF(IOPTR.NE.0)THEN
         LPSAV=LPICT
         CALL IZSCPI(LP1)
         CALL UCTOH(PNAME2,IQ(LHC+1),4,20)
         IQ(LPICT+1)=NCHP2
         LPICT=LPSAV
         IF(LPSAV.GT.0)CALL IZSCPI(LPSAV)
         RETURN
      ENDIF
*
      END
+SELF.
+DECK,  IZCTOI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:09  mclareni
* Higz

      SUBROUTINE IZCTOI(CVAL,IVAL)
*.===========>
*.
*. Convert character string CVAL into integer value IVAL
*.
*..==========>
+CDE, HIQUES.
      CHARACTER*(*) CVAL
      PARAMETER (MAXDIG=15)
      CHARACTER*(MAXDIG) CHTEMP,BLANK
*.______________________________________
*
      IQUEST(1)=0
      L=LENOCC(CVAL)
      IF (L.EQ.0)RETURN
      IF (L.GT.MAXDIG) THEN
         IQUEST(1)=1
         RETURN
      ENDIF
      BLANK=' '
      IF (L.EQ.MAXDIG) THEN
         CHTEMP=CVAL
      ELSE
         CHTEMP=BLANK(:MAXDIG-L)//CVAL
      ENDIF
      READ (CHTEMP,'(I15)',ERR=10 ) IVAL
      RETURN
   10 IQUEST(1)=1
*
      END
+DECK,  IZCTOR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:09  mclareni
* Higz

      SUBROUTINE IZCTOR(CVAL,RVAL)
*.===========>
*.
*. Convert character string CVAL into real value RVAL
*.
*..==========>
      CHARACTER*(*) CVAL
      PARAMETER (MAXDIG=16)
      CHARACTER*(MAXDIG) CHTEMP,BLANK
*.______________________________________
*
      L=LENOCC(CVAL)
      IF (L.EQ.0)RETURN
      IF (L.GT.MAXDIG)RETURN
      BLANK=' '
      IF (L.EQ.MAXDIG) THEN
         CHTEMP=CVAL
      ELSE
         CHTEMP=BLANK(:MAXDIG-L)//CVAL
      ENDIF
      CALL CLTOU(CHTEMP)
      I1 =INDEX(CHTEMP,'.')
      II1=0
      IF (I1.LT.L) II1=INDEX(CHTEMP(I1+1:),'.')
      I2=INDEX(CHTEMP,'E')
      II2=0
      IF (I2.LT.L) II2=INDEX(CHTEMP(I2+1:),'E')
      IF (II1+II2.NE.0)RETURN
      IF (I1+I2.EQ.0) THEN
         CALL IZCTOI(CHTEMP,IVAL)
         RVAL=IVAL
         RETURN
      ENDIF
      IF (I1.EQ.L.AND.I2.EQ.0) THEN
         CALL IZCTOI(CHTEMP(:I1-1),IVAL)
         RVAL=IVAL
         RETURN
      ENDIF
      BLANK(1:15)=CHTEMP(2:16)
      CHTEMP=BLANK(1:15)//'0'
      READ (CHTEMP,'(G15.9)',END=999,ERR=999) RVAL
*
  999 END

+DECK,  IZDATT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:09  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZDATT(IADR1,IADR2)
*.===========>
*.
*.   This routine Decodes the attributes in the from the adress IADR1
*. to the adress IADR2 in the bank LNDECO.
*.
*. _Input parameters:
*.
*.  INTEGER IADR1 : Starting adress.
*.  INTEGER IADR2 : End adress.
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATNB.
+CDE, HIATT.
+CDE, HIATNM.
*.______________________________________
*
      IF(IADR1.LE.9)THEN
         IREPTR=9
      ELSE
         IREPTR=IADR1-1
      ENDIF
      IDIAA=IZGADR(LNDECO,8)
      IDRAA=IZGADR(LNDECO,9)
      INBIAT=IZGCOD(LNDECO,8)
      INBRAT=IZGCOD(LNDECO,9)
      IF(IADR1.GT.10)GOTO 1
*
*              Set the default attributes
*
      DO 3 I=1,INBIAT
         CALL IGSET(CHIATT(I),FLOAT(IQ(LIDECO+IDIAA+I-1)))
 3    CONTINUE
      DO 4 I=1,INBRAT
         CALL IGSET(CHRATT(I),Q(LFDECO+IDRAA+I-1))
 4    CONTINUE
*
*              Decode the LN bank
*
 1    IREPTR=IREPTR+1
      IF(IREPTR.EQ.IQ(LNDECO+4))RETURN
      IF(IREPTR.EQ.IADR2+1)RETURN
      IADRI=ABS(IZGADR(LNDECO,IREPTR))
      ICODE=IZGCOD(LNDECO,IREPTR)
*
      GOTO (2,2,2,2,2
     +,     2,2,2,2,2,2,2,2,2,2,2,2,2,2,480,490
     +,     2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
     +,     5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
     +,     8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
     +      ),ABS(ICODE)
*
 2    CONTINUE
      GOTO 1
*
*              Set color representation
*
 480  IADRF=IQ(LIDECO+IADRI)
      CALL ISCR(IDID
     +,         IQ(LIDECO+IADRI+1)
     +,         Q(LFDECO+IADRF)
     +,         Q(LFDECO+IADRF+1)
     +,         Q(LFDECO+IADRF+2))
      GOTO 1
*
*              Set clipping indicator
*
 490  CALL ISCLIP(IADRI)
      GOTO 1
*
*              Real attributes
*
  5   CALL IGSET(CHRATT(ICODE-49),Q(LFDECO+IADRI))
      GOTO 1
*
*              Integer attributes
*
  8   CALL IGSET(CHIATT(ICODE-79),FLOAT(IADRI-100000))
      GOTO 1
*
      END
+SELF.
+DECK,  IZDIPI, T=FORT.
* Revision 1.2  1998/12/01 15:48:40  couet
* - Clean up: commented lines of code removed
* Revision 1.1.1.1  1996/02/14 13:11:09  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZDIPI(LP)
*.===========>
*.
*.   This routine displays the picture which is at the adress LP in the
*. ZEBRA data structure. For more details about the structure of the
*. HIGZ pictures see the comments in the routine IZPICT .
*.
*. _Input parameters:
*.
*.  INTEGER LP : Picture adress in the ZEBRA data structure .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
+CDE, HIMETA.
+CDE, HICONV.
      EQUIVALENCE (LPCOP,LN)
      LOGICAL GFSAV,ZFSAV,LOSIZE
*.______________________________________
*
      IF(LP.LT.0)RETURN
*
      LPICD=LP
      LDNT0=LQ(LPICD-1)
      IHP=IZGHNP(LPICD)-1
      LDNT=IZGNGT(LPICD,IHP)
      LDI=LQ(LPICD-2)
      LDF=LQ(LPICD-3)
      LDC=LQ(LPICD-4)
*
      GFSAV=GFLAG
      ZFSAV=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      IF((.NOT.TEKACT).AND.(METACT).AND.(PFLAG).OR.MFLAG)THEN
         GFLAG=.FALSE.
      ELSE
         GFLAG=.TRUE.
      ENDIF
*
*              Compute in LN1 the bank adress of the NT 1
*
      LN=LDNT0
      LN1=0
      DO 10 I=1,IQ(LPICD+8)
         IF(LN.EQ.0)GOTO 20
         IF(IQ(LN+1).EQ.1)THEN
            LN1=LN
            GOTO 20
         ENDIF
         LN=LQ(LN)
   10 CONTINUE
*
   20 IF(JBIT(IQ(LPICD),1).NE.0)CALL ICLRWK(0,0)
*
      IF(LN1.NE.0)THEN
         CALL IGRNG(Q(LDF+IQ(LN1+2)+1)
     +,             Q(LDF+IQ(LN1+2)+3))
         IWVA=IQ(LN1+2)
         X1MIN=Q(LDF+IWVA+4)
         X1MAX=Q(LDF+IWVA+5)
         Y1MIN=Q(LDF+IWVA+6)
         Y1MAX=Q(LDF+IWVA+7)
         X2MIN=RQUEST(12)
         X2MAX=RQUEST(14)+RQUEST(12)
         Y2MIN=RQUEST(13)
         Y2MAX=RQUEST(15)+RQUEST(13)
         LOSIZE=.TRUE.
      ELSE
         LOSIZE=.FALSE.
      ENDIF
*
*              Display the NT banks according to there priorities
*
      NGT=0
      LN=IZGNGT(LPICD,NGT)
      DO 40 I=1,IQ(LPICD+8)
         IF(LN.EQ.0)GOTO 50
*
* Set the normalisation transformation
*
         IWVA=IQ(LN+2)
         INTN=IQ(LN+1)
*
         IF(INTN.EQ.0)GOTO 30
         CALL ISWN(INTN
     +,            Q(LDF+IWVA)
     +,            Q(LDF+IWVA+1)
     +,            Q(LDF+IWVA+2)
     +,            Q(LDF+IWVA+3))
         IF(LOSIZE)CALL IGCONV(2,Q(LDF+IWVA+4),Q(LDF+IWVA+6))
         CALL ISVP(INTN
     +,            Q(LDF+IWVA+4)
     +,            Q(LDF+IWVA+5)
     +,            Q(LDF+IWVA+6)
     +,            Q(LDF+IWVA+7))
   30    CALL ISELNT(INTN)
*
* Decode the NT bank linked to LN
*
         CALL IZDNB(LN,LDI,LDF,LDC,0,0)
*
* Give the link of the next highest priority NT bank
*
         NGT=IQ(LN+3)
         LN=IZGNGT(LPICD,NGT)
   40 CONTINUE
*
   50 ZFLAG=ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFSAV
      END
+SELF.
+DECK,  IZDNB, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:09  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZDNB(LN,LI,LF,LC,IADRES,IALON)
*.===========>
*.
*.   This routine Decode the NT Bank referenced by LN.
*.
*. _Input parameters:
*.
*.  INTEGER LN : NT bank link in the ZEBRA data structure .
*.  INTEGER LI : LHI bank link in the ZEBRA data structure .
*.  INTEGER LF : LHF bank link in the ZEBRA data structure .
*.  INTEGER LC : LHC bank link in the ZEBRA data structure .
*.  INTEGER IADRES : Adress to be decode if IALON=1.
*.  INTEGER IALON : =0 the whole bank is decoded ;
*.                  =1 only the code at the adress IADRES is decoded
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATNB.
+CDE, HIATT.
+CDE, HILABS.
      CHARACTER*256 CHARS,STR
      CHARACTER*80 CHOPT
      CHARACTER*1 CHAXIS(25),CHHIST(14),CHTEXT(3),CHTABL(11),CHGRAP(12)
     +,           CHPAVE(9)
      DIMENSION X(2),Y(2)
+CDE, HIATNM.
      DATA CHAXIS /'G','B','A','V','+','-','U','P','O'
     +,            'R','L','C','=','.','H','D','Y','T'
     +,            'W','S','N','I','M','0','X'/
      DATA CHHIST /'H','F','C','*','R','1','B','N','L'
     +,            'P','A','G','X','Y'/
      DATA CHTEXT /'L','C','R'/
      DATA CHTABL /'P','B','C','T','K','L','S',' ','A','+','R'/
      DATA CHGRAP /'L','A','C','*','P','B','R','1','G','X','Y','F'/
      DATA CHPAVE /'T','B','L','R','-','S','P','K','D'/
*.______________________________________
*
      LNDECO=LN
      LIDECO=LI
      LFDECO=LF
      LCDECO=LC
*
      IF(IALON.NE.0)THEN
         IREPTR=IADRES
         IREPTR=IREPTR-1
         GOTO 1
      ENDIF
*
      IREPTR=9
      IDIAA=IZGADR(LNDECO,8)
      IDRAA=IZGADR(LNDECO,9)
      INBIAT=IZGCOD(LNDECO,8)
      INBRAT=IZGCOD(LNDECO,9)
*
*              Set the default attributes
*
      DO 3 I=1,INBIAT
         CALL IGSET(CHIATT(I),FLOAT(IQ(LIDECO+IDIAA+I-1)))
 3    CONTINUE
      DO 4 I=1,INBRAT
         CALL IGSET(CHRATT(I),Q(LFDECO+IDRAA+I-1))
 4    CONTINUE
*
*              Decode the LN bank
*
    1 IREPTR=IREPTR+1
      IF(IREPTR.EQ.IQ(LNDECO+4))RETURN
      IADRI=ABS(IZGADR(LNDECO,IREPTR))
      ICODE=IZGCOD(LNDECO,IREPTR)
*
      GOTO (2,2,2,2,2
     +,     60,70,80,90,100,110,120,130,140,150,160,170,180,190
     +,     200,210,220,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
     +,     2,480,490
     +,     5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
     +,     8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
     +      ),ABS(ICODE)
*
    2 CONTINUE
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Histograms
*
   60 IADRI2=IADRI
      IF(ICODE.GT.0)THEN
         ICHOPT=IQ(LIDECO+IADRI+2)
      ELSE
         ICHOPT=-1
      ENDIF
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
   61    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 61
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 62 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 63
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.2).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
                  ICHOPT=IQ(LIDECO+IADRI2+3)
               ENDIF
               KATT=1
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
   62    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      IF(ICHOPT.LT.0)THEN
         ICHOPT=IQ(LIDECO+IADRI2+2)
      ENDIF
      CHOPT=' '
      DO 64 I=1,14
         IF(JBIT(ICHOPT,I).NE.0)CHOPT(I:I)=CHHIST(I)
   64 CONTINUE
      NN=2
      IF(JBIT(ICHOPT,8).NE.0)THEN
         NN=IQ(LIDECO+IADRI2+1)+1
      ENDIF
      IF(JBIT(ICHOPT,5).NE.0)THEN
         IQUEST(81)   = LFDECO+IADRF+NN
         IQUEST(82)   = LFDECO+IADRF
         CHOPT(20:20) = 'Z'
         CALL IGHIST(IQ(LIDECO+IADRI2+1)
     +,               Q(LFDECO+IADRF+NN)
     +,               Q(LFDECO+IADRF)
     +,               CHOPT)
         GOTO 1
      ENDIF
      NBIN=IQ(LIDECO+IADRI2+1)
      IF(IZPUSH(3,NBIN+2,0,'IZDNB').NE.0)RETURN
      IQUEST(81)   = LFDECO+IADRF
      IQUEST(82)   = LFDECO+IADRF+NN
      CHOPT(20:20) = 'Z'
      CALL IGHIST(NBIN
     +,            Q(LFDECO+IADRF)
     +,            Q(LFDECO+IADRF+NN)
     +,            CHOPT)
      IF(ICODE.LT.0)CALL IZSETA
*
   63 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Polymarker with one point
*
   70 IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
   71    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 71
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 72 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 73
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
   72    CONTINUE
      ENDIF
*
      IF(IZPUSH(2,2,0,'IZDNB').NE.0)RETURN
      CALL IPM(1,Q(LFDECO+IADRI2),Q(LFDECO+IADRI2+1))
      IF(ICODE.LT.0)CALL IZSETA
*
   73 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Polyline with two points
*
   80 DX=0.
      DY=0.
      IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
   81    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 81
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 82 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 83
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
   82    CONTINUE
      ENDIF
*
      X(1)=Q(LFDECO+IADRI2)+DX
      X(2)=Q(LFDECO+IADRI2+1)+DX
      Y(1)=Q(LFDECO+IADRI2+2)+DY
      Y(2)=Q(LFDECO+IADRI2+3)+DY
      CALL IPL(2,X,Y)
      IF(ICODE.LT.0)CALL IZSETA
*
   83 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Polyline
*
   90 DX=0.
      DY=0.
      IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
   91    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 91
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 92 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 93
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
   92    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      N=IQ(LIDECO+IADRI2+1)
      IF(DX.NE.0..OR.DY.NE.0.)THEN
         DO 94 I=0,N-1
            Q(LFDECO+IADRF+I)=Q(LFDECO+IADRF+I)+DX
            Q(LFDECO+IADRF+I+N)=Q(LFDECO+IADRF+I+N)+DY
   94    CONTINUE
      ENDIF
      IF(IZPUSH(2,2*N,0,'IZDNB').NE.0)RETURN
      CALL IPL(N
     +,        Q(LFDECO+IADRF)
     +,        Q(LFDECO+IADRF+N))
      IF(DX.NE.0..OR.DY.NE.0.)THEN
         DO 95 I=0,N-1
            Q(LFDECO+IADRF+I)=Q(LFDECO+IADRF+I)-DX
            Q(LFDECO+IADRF+I+N)=Q(LFDECO+IADRF+I+N)-DY
   95    CONTINUE
      ENDIF
      IF(ICODE.LT.0)CALL IZSETA
*
   93 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Polymarker
*
  100 IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  101    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 101
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 102 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 103
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  102    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      N=IQ(LIDECO+IADRI2+1)
      IF(IZPUSH(2,2*N,0,'IZDNB').NE.0)RETURN
      CALL IPM(N
     +,        Q(LFDECO+IADRF)
     +,        Q(LFDECO+IADRF+N))
      IF(ICODE.LT.0)CALL IZSETA
*
  103 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Fill area
*
  110 DX=0.
      DY=0.
      IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  111    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 111
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 112 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 113
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  112    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      N=IQ(LIDECO+IADRI2+1)
      IF(DX.NE.0..OR.DY.NE.0.)THEN
         DO 114 I=0,N-1
            Q(LFDECO+IADRF+I)=Q(LFDECO+IADRF+I)+DX
            Q(LFDECO+IADRF+I+N)=Q(LFDECO+IADRF+I+N)+DY
  114    CONTINUE
      ENDIF
      IF(IZPUSH(2,2*N,0,'IZDNB').NE.0)RETURN
      CALL IFA(N
     +,        Q(LFDECO+IADRF)
     +,        Q(LFDECO+IADRF+N))
      IF(DX.NE.0..OR.DY.NE.0.)THEN
         DO 115 I=0,N-1
            Q(LFDECO+IADRF+I)=Q(LFDECO+IADRF+I)-DX
            Q(LFDECO+IADRF+I+N)=Q(LFDECO+IADRF+I+N)-DY
  115    CONTINUE
      ENDIF
      IF(ICODE.LT.0)CALL IZSETA
*
  113 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Text
*
  120 DX=0.
      DY=0.
      IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  121    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 121
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 122 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 123
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  122    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      IADRC=IQ(LIDECO+IADRI2+1)
      NCHP=IQ(LIDECO+IADRI2+2)
      CALL UHTOC(IQ(LCDECO+IADRC),4,STR,NCHP)
      CHARS=STR(1:NCHP)
      IF(IZPUSH(3,2,(NCHP+3)/4,'IZDNB').NE.0)RETURN
      CALL ITX(Q(LFDECO+IADRF)+DX
     +,        Q(LFDECO+IADRF+1)+DY
     +,        CHARS)
      IF(ICODE.LT.0)CALL IZSETA
*
  123 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Boxe
*
  130 DX=0.
      DY=0.
      IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  131    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 131
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 132 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 133
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  132    CONTINUE
      ENDIF
*
      IF(IZPUSH(0,4,0,'IZDNB').NE.0)RETURN
      CALL IGBOX(Q(LFDECO+IADRI2)+DX
     +,          Q(LFDECO+IADRI2+1)+DX
     +,          Q(LFDECO+IADRI2+2)+DY
     +,          Q(LFDECO+IADRI2+3)+DY)
      IF(ICODE.LT.0)CALL IZSETA
*
  133 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Frame box
*
  140 DX=0.
      DY=0.
      IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  141    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 141
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 142 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 143
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  142    CONTINUE
      ENDIF
*
      IF(IZPUSH(0,8,0,'IZDNB').NE.0)RETURN
      CALL IGFBOX(Q(LFDECO+IADRI2)+DX
     +,           Q(LFDECO+IADRI2+1)+DX
     +,           Q(LFDECO+IADRI2+2)+DY
     +,           Q(LFDECO+IADRI2+3)+DY
     +,           Q(LFDECO+IADRI2+4)+DX
     +,           Q(LFDECO+IADRI2+5)+DX
     +,           Q(LFDECO+IADRI2+6)+DY
     +,           Q(LFDECO+IADRI2+7)+DY)
      IF(ICODE.LT.0)CALL IZSETA
*
  143 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Arc
*
  150 DX=0.
      DY=0.
      IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  151    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 151
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 152 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 153
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  152    CONTINUE
      ENDIF
*
      IF(IZPUSH(0,6,0,'IZDNB').NE.0)RETURN
      CALL IGARC(Q(LFDECO+IADRI2)+DX
     +,          Q(LFDECO+IADRI2+1)+DY
     +,          Q(LFDECO+IADRI2+2)
     +,          Q(LFDECO+IADRI2+3)
     +,          Q(LFDECO+IADRI2+4)
     +,          Q(LFDECO+IADRI2+5))
      IF(ICODE.LT.0)CALL IZSETA
*
  153 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Axis
*
  160 DX=0.
      DY=0.
      IADRI2=IADRI
      IF(ICODE.GT.0)THEN
         ICHOPT=IQ(LIDECO+IADRI+2)
      ELSE
         ICHOPT=-1
      ENDIF
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  161    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 161
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 162 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 163
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.2).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
                  ICHOPT=IQ(LIDECO+IADRI2+3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  162    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      IF(ICHOPT.LT.0)THEN
         ICHOPT=IQ(LIDECO+IADRI2+2)
      ENDIF
      CHOPT=' '
      DO 164 I=1,25
         IF(JBIT(ICHOPT,I).NE.0)CHOPT(I:I)=CHAXIS(I)
  164 CONTINUE
      IF(IZPUSH(3,6,0,'IZDNB').NE.0)RETURN
      CALL IGAXIS(Q(LFDECO+IADRF)+DX
     +,           Q(LFDECO+IADRF+1)+DX
     +,           Q(LFDECO+IADRF+2)+DY
     +,           Q(LFDECO+IADRF+3)+DY
     +,           Q(LFDECO+IADRF+4)
     +,           Q(LFDECO+IADRF+5)
     +,          IQ(LIDECO+IADRI2+1)
     +,           CHOPT)
      IF(ICODE.LT.0)CALL IZSETA
*
  163 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Software characters
*
  170 DX=0.
      DY=0.
      IADRI2=IADRI
      IF(ICODE.GT.0)THEN
         ICHOPT=IQ(LIDECO+IADRI+3)
      ELSE
         ICHOPT=-1
      ENDIF
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  171    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 171
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 172 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 173
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.2).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
                  ICHOPT=IQ(LIDECO+IADRI2+3)
               ENDIF
               KATT=1
            ENDIF
            IF(IZGCOD(LIDECO,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LIDECO,IADRI2)
               DX=DX+Q(LFDECO+IADRI4)
               DY=DY+Q(LFDECO+IADRI4+1)
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  172    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      IADRC=IQ(LIDECO+IADRI2+1)
      NCHP=IQ(LIDECO+IADRI2+2)
      IF(ICHOPT.LT.0)THEN
         ICHOPT=IQ(LIDECO+IADRI2+3)
      ENDIF
      CHOPT=' '
      DO 174 I=1,3
         IF(JBIT(ICHOPT,I).NE.0)CHOPT(I:I)=CHTEXT(I)
  174 CONTINUE
      CALL UHTOC(IQ(LCDECO+IADRC),4,STR,NCHP)
      CHARS=STR(1:NCHP)
      IF(IZPUSH(4,4,(NCHP+3)/4,'IZDNB').NE.0)RETURN
      CALL IGTEXT(Q(LFDECO+IADRF)+DX
     +,           Q(LFDECO+IADRF+1)+DY
     +,           CHARS
     +,           Q(LFDECO+IADRF+2)
     +,           Q(LFDECO+IADRF+3)
     +,           CHOPT)
      IF(ICODE.LT.0)CALL IZSETA
*
  173 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Multiline
*
  180 IADRI2=IADRI
*
      IF(ICODE.LT.0)THEN
         CALL IZSAVA
         NBNOP=1
         KATT=0
  181    IF(IQ(LNDECO+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LNDECO,IADRI2))
            GOTO 181
         ENDIF
         IADRI2=IZGADR(LNDECO,IADRI2)
         DO 182 I=1,NBNOP
            IF(IQ(LIDECO+IADRI2).EQ.0)THEN
               GOTO 183
            ENDIF
            IF((IQ(LIDECO+IADRI2).EQ.1).AND.(KATT.EQ.0))THEN
               IF(IALON.NE.-1)THEN
                  IADRI3=ABS(IZGADR(LNDECO,IQ(LIDECO+IADRI2+2)))-1
                  CALL IZDATT(IREPTR+1,IADRI3)
               ENDIF
               KATT=1
            ENDIF
            IADRI2=IQ(LIDECO+IADRI2+1)
  182    CONTINUE
      ENDIF
*
      IADRF=IQ(LIDECO+IADRI2)
      N=IQ(LIDECO+IADRI2+1)
      IF(IZPUSH(2,2*N,0,'IZDNB').NE.0)RETURN
      CALL IML(N
     +,        Q(LFDECO+IADRF)
     +,        Q(LFDECO+IADRF+N))
      IF(ICODE.LT.0)CALL IZSETA
*
  183 IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Table
*
  200 NX=IQ(LIDECO+IADRI)
      NY=IQ(LIDECO+IADRI+1)
      NYY=MAX(NY,1)
      IADRF=IQ(LIDECO+IADRI+2)
      NPAR=IQ(LIDECO+IADRI+3)
      ICHOPT=IQ(LIDECO+IADRI+4)
      CHOPT=' '
      IF(JBIT(ICHOPT, 1).NE.0)CHOPT( 1: 3)='COL'
      IF(JBIT(ICHOPT,13).NE.0)CHOPT(16:17)='S1'
      IF(JBIT(ICHOPT,14).NE.0)CHOPT(16:17)='S2'
      IF(JBIT(ICHOPT,15).NE.0)CHOPT(16:17)='L1'
      IF(JBIT(ICHOPT,16).NE.0)CHOPT(16:17)='L2'
      IF(JBIT(ICHOPT,17).NE.0)CHOPT(18:19)='GZ'
      IF(JBIT(ICHOPT,18).NE.0)CHOPT(20:21)='GX'
      IF(JBIT(ICHOPT,19).NE.0)CHOPT(22:23)='GY'
      IF(JBIT(ICHOPT,20).NE.0)CHOPT(15:16)='LB'
      IF(JBIT(ICHOPT,21).NE.0)CHOPT( 4: 4)='Z'
      IF(JBIT(ICHOPT,22).NE.0)CHOPT(16:17)='S3'
      IF(JBIT(ICHOPT,23).NE.0)CHOPT(16:17)='S4'
      IF(JBIT(ICHOPT,24).NE.0)CHOPT( 1: 3)='POL'
      IF(JBIT(ICHOPT,25).NE.0)CHOPT( 1: 3)='CYL'
      IF(JBIT(ICHOPT,26).NE.0)CHOPT( 1: 3)='SPH'
      IF(JBIT(ICHOPT,27).NE.0)CHOPT( 1: 3)='PSD'
      IF(JBIT(ICHOPT,28).NE.0)CHOPT(38:39)='BB'
      IF(JBIT(ICHOPT,29).NE.0)CHOPT(36:37)='FB'
      IF(JBIT(ICHOPT,30).NE.0)CHOPT(41:41)='E'
      DO 201 I=2,12
         IF(JBIT(ICHOPT,I).NE.0)CHOPT(I+2:I+2)=CHTABL(I-1)
  201 CONTINUE
      CHOPT(40:40) = 'I'
*
      NPAR2=NPAR
      IF(NPAR.GE.9)THEN
         IF(Q(LFDECO+IADRF+8).LT.0.)THEN
            IQUEST(60)=Q(LFDECO+IADRF+NPAR)
            NPAR2=NPAR+2
         ENDIF
         IF(Q(LFDECO+IADRF+9).LT.0.)THEN
            IQUEST(61)=Q(LFDECO+IADRF+NPAR+1)
            NPAR2=NPAR+2
         ENDIF
      ENDIF
*
      IF(IZPUSH(5,NX*NYY+NPAR,0,'IZDNB').NE.0)RETURN
      CALL IGTABL(NX
     +,           NY
     +,           FLOAT(LFDECO+IADRF+NPAR2-1)
     +,           NPAR
     +,           Q(LFDECO+IADRF)
     +,           CHOPT)
*
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Graph
*
  210 IADRF  = IQ(LIDECO+IADRI)
      N      = IQ(LIDECO+IADRI+1)
      ICHOPT = IQ(LIDECO+IADRI+2)
      CHOPT  = ' '
      DO 211 I=1,12
         IF(JBIT(ICHOPT,I).NE.0)CHOPT(I:I)=CHGRAP(I)
  211 CONTINUE
*
      IF(IZPUSH(3,2*N,0,'IZDNB').NE.0)RETURN
      IQUEST(81)   = LFDECO+IADRF
      IQUEST(82)   = LFDECO+IADRF+N
      CHOPT(20:20) = 'Z'
      CALL IGRAPH(N
     +,           Q(LFDECO+IADRF)
     +,           Q(LFDECO+IADRF+N)
     +,           CHOPT)
*
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Pave
*
  220 IADRF  = IQ(LIDECO+IADRI)
      ICHOPT = IQ(LIDECO+IADRI+3)
      CHOPT  = ' '
      DO 221 I=1,9
         IF(JBIT(ICHOPT,I).NE.0)CHOPT(I:I)=CHPAVE(I)
  221 CONTINUE
*
      IF(IZPUSH(4,5,0,'IZDNB').NE.0)RETURN
      CALL IGPAVE(Q(LFDECO+IADRF)
     +,           Q(LFDECO+IADRF+1)
     +,           Q(LFDECO+IADRF+2)
     +,           Q(LFDECO+IADRF+3)
     +,           Q(LFDECO+IADRF+4)
     +,           IQ(LIDECO+IADRI+1)
     +,           IQ(LIDECO+IADRI+2)
     +,           CHOPT)
*
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Alpha numerique axis labels
*
  190 NHILAB=IQ(LIDECO+IADRI)
      IADRC=IQ(LIDECO+IADRI+1)
      LBLLEN=0
      DO 191 I=1,NHILAB
         NCHP=IQ(IADRI+LIDECO+I+1)
         HILABS(I)=' '
         CALL UHTOC(IQ(LCDECO+IADRC+LBLLEN),4,HILABS(I),NCHP)
         LBLLEN=LBLLEN+((NCHP+3)/4)
  191 CONTINUE
      CALL IZLBL
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Set color representation
*
  480 IADRF=IQ(LIDECO+IADRI)
      IF(IZPUSH(2,3,0,'IZDNB').NE.0)RETURN
      CALL ISCR(IDID
     +,         IQ(LIDECO+IADRI+1)
     +,         Q(LFDECO+IADRF)
     +,         Q(LFDECO+IADRF+1)
     +,         Q(LFDECO+IADRF+2))
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Set clipping indicator
*
  490 CALL ISCLIP(IADRI)
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Real attributes
*
  5   IF(IZPUSH(0,1,0,'IZDNB').NE.0)RETURN
      CALL IGSET(CHRATT(ICODE-49),Q(LFDECO+IADRI))
      IF(IALON.NE.0)RETURN
      GOTO 1
*
*              Integer attributes
*
  8   IF(IZPUSH(0,0,0,'IZDNB').NE.0)RETURN
      CALL IGSET(CHIATT(ICODE-79),FLOAT(IADRI-100000))
      IF(IALON.NE.0)RETURN
      GOTO 1
*
      END
+SELF.
+DECK,  IZEND, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:09  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZEND
*.===========>
*.
*.   End with HIGZ . If the automatic saving is on the whole
*. pictures always in memory are saved in the current open
*. HIGZ file.
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HICUR.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
      DIMENSION INAME(5)
      CHARACTER*32 OLDDIR
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF((NBPICT.NE.0).AND.ASFLAG)THEN
         LP=LQ(LHIGZ)
         CALL RZCDIR(OLDDIR,'R')
         CALL RZCDIR(HICDIR,' ')
         DO 10 I=1,NBPICT
            CALL IZSCPI(LP)
            CALL VBLANK(INAME,5)
            LOOP=(IQ(LPICT+1)+3)/4
            DO 20 II=1,LOOP
               INAME(II)=IQ(LQ(LPICT-4)+II)
  20        CONTINUE
            CALL IZWIP(LPICT)
            CALL RZOUT(IXHIGZ,LPICT,INAME,ICYCLE,' ')
            CALL RZSAVE
            LP=LQ(LPICT)
  10     CONTINUE
         CALL RZCDIR(OLDDIR,' ')
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3)') 999
         CALL IMWRIT(4)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZFA, T=FORT.
* Revision 1.3  1999/07/21 15:48:29  couet
* - Improvements in PS Patterns drawing
* Revision 1.2  1998/05/26 09:19:28  couet
* - For filling patterns 1 to 25 the PS ouput was wrong in some cases. For those
* the pattern we now close the polygon (move to X1 Y1).
* Revision 1.1.1.1  1996/02/14 13:11:09  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZFA(N,X,Y)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. draw a fill area .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIATT.
+CDE, HIPOST.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      DIMENSION X(*),Y(*)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      LOGICAL GSAV
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIWCPS.
      IF(PFLAG)THEN
         IF(IFAIS.EQ.3.AND.IFASI.GE.100)GOTO 10
         CALL IPZONE
         GSAV=GFLAG
         GFLAG=.FALSE.
         IF(.NOT.TFLAG) THEN
            CALL IPSCOL(IFACI)
            CALL IPLWID(1)
         ENDIF
         CALL IPLTYP(1)
         IF(IFAIS.EQ.0.AND..NOT.TFLAG)THEN
            CALL IPDRAW(-N,X,Y)
            CALL IPPSTF(5,' cl s')
         ELSEIF(IFAIS.EQ.3.OR.IFAIS.EQ.2)THEN
            IF(IFASI.EQ.-101)CALL IGHATC(0.0075,180.,N,X,Y)
            IF(IFASI.EQ.-102)CALL IGHATC(0.0075,90.,N,X,Y)
            IF(IFASI.EQ.-103)CALL IGHATC(0.0075,135.,N,X,Y)
            IF(IFASI.EQ.-104)CALL IGHATC(0.0075,45.,N,X,Y)
            IF(IFASI.EQ.-105)CALL IGHATC(0.0075,150.,N,X,Y)
            IF(IFASI.EQ.-106)CALL IGHATC(0.0075,30.,N,X,Y)
            IF(IFASI.EQ.-107)CALL IGHATC(0.0075,120.,N,X,Y)
            IF(IFASI.EQ.-108)CALL IGHATC(0.0075,60.,N,X,Y)
            IF(IFASI.EQ.-109)CALL IGHATC(0.01,180.,N,X,Y)
            IF(IFASI.EQ.-110)CALL IGHATC(0.01,90.,N,X,Y)
            IF(IFASI.EQ.-111)CALL IGHATC(0.01,135.,N,X,Y)
            IF(IFASI.EQ.-112)CALL IGHATC(0.01,45.,N,X,Y)
            IF(IFASI.EQ.-113)CALL IGHATC(0.01,150.,N,X,Y)
            IF(IFASI.EQ.-114)CALL IGHATC(0.01,30.,N,X,Y)
            IF(IFASI.EQ.-115)CALL IGHATC(0.01,120.,N,X,Y)
            IF(IFASI.EQ.-116)CALL IGHATC(0.01,60.,N,X,Y)
            IF(IFASI.EQ.-117)CALL IGHATC(0.015,180.,N,X,Y)
            IF(IFASI.EQ.-118)CALL IGHATC(0.015,90.,N,X,Y)
            IF(IFASI.EQ.-119)CALL IGHATC(0.015,135.,N,X,Y)
            IF(IFASI.EQ.-120)CALL IGHATC(0.015,45.,N,X,Y)
            IF(IFASI.EQ.-121)CALL IGHATC(0.015,150.,N,X,Y)
            IF(IFASI.EQ.-122)CALL IGHATC(0.015,30.,N,X,Y)
            IF(IFASI.EQ.-123)CALL IGHATC(0.015,120.,N,X,Y)
            IF(IFASI.EQ.-124)CALL IGHATC(0.015,60.,N,X,Y)
            IF(IFASI.GE.1.AND.IFASI.LE.25..AND..NOT.TFLAG)THEN
               CALL IPDPAT(IFASI,IFACI)
               CALL IPDRAW(-N,X,Y)
               CALL IPPSTF(3,' FA')
            ENDIF
            IF(IFASI.EQ.-3.AND..NOT.TFLAG)THEN
               CALL IPSCOL(5)
               CALL IPDRAW(-N,X,Y)
               CALL IPPSTF(2,' f')
            ENDIF
         ELSEIF(.NOT.TFLAG) THEN
            CALL IPDRAW(-N,X,Y)
            CALL IPPSTF(2,' f')
         ENDIF
         GFLAG=GSAV
      ENDIF
   10 CONTINUE
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,I5)') IFACO,N
         CALL IMWRIT(1)
         CALL IMFOUT(N,X)
         CALL IMFOUT(N,Y)
         CALL IMWRIT(5)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(2,2*N,0,'IFA').NE.0)RETURN
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZSTCC(IFACO,INTPTR)
         IQ(LHI+INTPTR)   = IFLPTR
         IQ(LHI+INTPTR+1) = N
         CALL IZINCI(2)
         IADR  = LHF+IFLPTR-1
         IADRN = IADR+N
         DO 20 I=1,N
            Q(IADR+I)  = X(I)
            Q(IADRN+I) = Y(I)
   20    CONTINUE
         CALL IZINCF(2*N)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZFA3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZFA3(N,X,Y,Z)
*.===========>
*.
*..==========> (O.Couet)
      DIMENSION X(*),Y(*),Z(*)
*.______________________________________
*
      END
+SELF.
+DECK,  IZFBOX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZFBOX(X1,X2,Y1,Y2,X3,X4,Y3,Y4)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. draw a frame boxe .
*.
*. _Input parameters:
*.
*.  INTEGER X1,Y1 : Left down corner of the inside boxe .
*.  INTEGER X2,Y2 : Right up corner of the inside boxe .
*.  INTEGER X3,Y3 : Left down corner of the outside boxe .
*.  INTEGER X4,Y4 : Right up corner of the outside boxe .
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(0,8,0,'IGFBOX').NE.0)RETURN
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(IBORCO,1)
*
         CALL IZSTCC(IFBXCO,IFLPTR)
         Q(LHF+IFLPTR)=X1
         Q(LHF+IFLPTR+1)=X2
         Q(LHF+IFLPTR+2)=Y1
         Q(LHF+IFLPTR+3)=Y2
         Q(LHF+IFLPTR+4)=X3
         Q(LHF+IFLPTR+5)=X4
         Q(LHF+IFLPTR+6)=Y3
         Q(LHF+IFLPTR+7)=Y4
         CALL IZINCF(8)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,4E16.7)') IFBXCO,X1,X2,Y1,Y2
         CALL IMWRIT(1)
         WRITE (CHMAIL,'(4E16.7)') X3,X4,Y3,Y4
         CALL IMWRIT(3)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZFILE, T=FORT.
* Revision 1.2  1999/10/13 12:32:22  couet
* - rzmake is now called with 32000
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZFILE(LUN,CHDIR,CHOPT)
*.===========>
*.
*.   This routine create a RZ file .
*.
*. _Input parameters:
*.
*.  INTEGER LUN : Logical unit number .
*.  CHARACTER CHDIR : Top directoy .
*.  CHARACTER CHOPT : Option .
*.
*.                    CHOPT='N' : New RZ file .
*.                    CHOPT='X' : EXchange mode .
*.                    CHOPT=' ' : Open an existing file .
*.                    CHOPT='A' : Pictures are Automatically saved in RZ file .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
+CDE, HICUR.
      CHARACTER*(*) CHDIR,CHOPT
      CHARACTER*8 CHTAG(5),CHOPTT
      DIMENSION IOPT(9)
      EQUIVALENCE (IOPT(1),IOPTN),(IOPT(2),IOPTX),(IOPT(3),IOPTA)
*.______________________________________
*
      CHOPTT=CHOPT
      CALL CLTOU(CHOPTT)
      CALL UOPTC (CHOPTT,'NXA',IOPT)
*
      IF(IOPTN.NE.0)THEN
         CHTAG(1)=' '
         CHTAG(2)='PICTURE'
         CHTAG(3)='NAME'
         CHTAG(4)=' '
         CHTAG(5)=' '
         I=INDEX(CHOPTT,'N')
         CHOPTT(I:I)='?'
         CALL RZMAKE(LUN,CHDIR,5,'AAAAA',CHTAG,32000,CHOPTT)
      ELSE
         CALL RZFILE(LUN,CHDIR,CHOPTT)
      ENDIF
      CALL RZCDIR(HICDIR,'R')
*
      IF(IOPTA.NE.0)THEN
         ASFLAG=.TRUE.
      ENDIF
*
      END

+SELF.
+DECK,  IZGADR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      FUNCTION IZGADR(LN,IPOS)
*.===========>
*.
*.   This function Gives the ADRess in the word number IPOS in the bank LN .
*.
*. _Input parameters:
*.
*.  INTEGER LN : NT link .
*.  INTEGER IPOS : Word position .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IF(LN.GT.0)THEN
         IZGADR=MOD(IQ(LN+IPOS),1000000)
      ELSE
         IZGADR=0
      ENDIF
*
      END
+SELF.
+DECK,  IZGCOD, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      FUNCTION IZGCOD(LN,IPOS)
*.===========>
*.
*.   This function Gives the CODe in the word number IPOS in the bank LN .
*.
*. _Input parameters:
*.
*.  INTEGER LN : NT link .
*.  INTEGER IPOS : Word position .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IF(LN.GT.0)THEN
         IZGCOD=INT(IQ(LN+IPOS)/1000000)
      ELSE
         IZGCOD=0
      ENDIF
*
      END
+SELF.
+DECK,  IZGHNP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      INTEGER FUNCTION IZGHNP(LP)
*.===========>
*.
*.   This function Gives the Higher Normalisation
*. transformation Priority in the picture LP .
*.
*. _Input parameters:
*.
*.  INTEGER LP : Picture link .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IZGHNP=1
      IF(LP.LE.0)RETURN
      LN=LQ(LP-1)
      DO 10 I=1,IQ(LP+8)
         IF(LN.EQ.0)RETURN
         IF(IQ(LN+3).GT.IZGHNP)IZGHNP=IQ(LN+3)
         LN=LQ(LN)
 10   CONTINUE
*
      END
+SELF.
+DECK,  IZGNGT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      INTEGER FUNCTION IZGNGT(LP,NGT)
*.===========>
*.
*.   This function Gives the link to the first normalisation transformation
*. which priority is Greater Than NGT in the picture LP .
*.
*. _Input parameters:
*.
*.  INTEGER LP : Picture link .
*.  INTEGER NGT : Lower value of priority .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IZGNGT=0
      LN=LQ(LP-1)
      IGP=IZGHNP(LP)
      DO 10 I=1,IQ(LP+8)
         IF(LN.EQ.0)GOTO 99
         IP=IQ(LN+3)
         IF(IP.GT.NGT)THEN
            IF(IP.LE.IGP)THEN
               IGP=IP
               IZGNGT=LN
            ENDIF
         ENDIF
         LN=LQ(LN)
 10   CONTINUE
*
 99   END
+SELF.
+DECK,  IZGNNT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      FUNCTION IZGNNT(NT)
*.===========>
*.
*.   This function returns in the current picture the Normalisation
*. Transformation stored after NT. This is useful to loop over all
*. the transformations in a picture. If -1 is return the transformation
*. NT has not be found, or the last NT has been found.
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalisation transformation number .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IZGNNT = -1
      IF (LPICT.LE.0) GOTO 999
      LN = LHNT0
      DO 10 I=1,INBNT
         IF (LN.EQ.0) THEN
            GOTO 999
         ELSE
            IF (IQ(LN+1).EQ.NT) THEN
               LN = LQ(LN)
               IF (LN.EQ.0) THEN
                  GOTO 999
               ELSE
                  IZGNNT = IQ(LN+1)
                  GOTO 999
               ENDIF
            ENDIF
            LN = LQ(LN)
         ENDIF
   10 CONTINUE
*
  999 END
+SELF.
+DECK,  IZGNT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=-NTC, IF=-X11.
      SUBROUTINE IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*.===========>
*.
*.   This routine searchs in the NT storage if the transformation NT
*. exits. And returns the adress and the priority of the transformation
*. NT if IFIND.NE.0 .
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalisation transformation number .
*.
*. _Output parameters:
*.
*. INTEGER IFIND : IFIND.NE.0 if NT already exist (IFIND = Adress of the
*.                 priority word).
*. INTEGER IAWV : Transformation parameters adress .
*. INTEGER IPRIO : NT priority .
*. INTEGER IHPRIO : Highest NT priority .
*.
*..==========> (O.Couet, R.Wilhelm)
+CDE, HINT.
+CDE, HIATT.
*.______________________________________
*
      IFIND=0
      IHPRIO=NT0PRI
      IF(NTSTOR(1).EQ.0)RETURN
*
      DO 10 I=0,NTSTOR(1)-1
         IOFF=INWDNT*I
         IOF3=IOFF+3
         IF(NTSTOR(2+IOFF).EQ.NT)THEN
            IFIND=IOF3
            IPRIO=NTSTOR(IFIND)
            IAWV=I*8+1
         ENDIF
         IF(NTSTOR(IOF3).GT.IHPRIO)IHPRIO=NTSTOR(IOF3)
   10 CONTINUE
*
      END
+SELF.
+DECK,  IZGNTP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      FUNCTION IZGNTP(NT)
*.===========>
*.
*.   This routine searchs in the current picture if the Normalisation
*. Transformation bank NT exits .
*.
*. If IZGNTP=0 : There is no transformation bank NT in the current picture .
*. If IZGNTP>0 : The transformation bank NT exists in the current picture
*.               and IZGNTP gives the link NT bank value .
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalisation transformation number .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IZGNTP=0
      IF(LPICT.LE.0)GOTO 99
      LN=LHNT0
      DO 10 I=1,INBNT
         IF(LN.EQ.0)GOTO 99
         IF(IQ(LN+1).EQ.NT)THEN
            IZGNTP=LN
            GOTO 99
         ENDIF
         LN=LQ(LN)
 10   CONTINUE
*
  99  END
+SELF.
+DECK,  IZGRAP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZGRAP(N,X,Y,IOPT,IOPTZ)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. to draw a graphic .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N or 2 or N+1) : X coordinates .
*.  REAL Y(N or 2 or N+1) : Y coordinates .
*.  INTEGER IOPT : Option .
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
      EQUIVALENCE (LXADR,L2NTLA),(LYADR,LDNTLA)
      DIMENSION IOPT(*)
      DIMENSION X(2),Y(2)
*.______________________________________
*
+CDE, HIBIT.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(3,2*N,0,'IGRAPH').NE.0)RETURN
         CALL IZCFA(IBOFCO,1)
         CALL IZCFA(IBWDCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(IBSLCO,1)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(ITMSCO,1)
         CALL IZCFA(IALHCO,1)
         CALL IZCFA(IALDCO,1)
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(ITXFCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
         CALL IZCFA(IAWLCO,1)
         CALL IZCFA(IMKCO,1)
         CALL IZCFA(IMKSCO,1)
         CALL IZCFA(IPMCCO,1)
         CALL IZCFA(IBORCO,1)
*
         CALL IZSTCC(IGRACO,INTPTR)
         IQ(LHI+INTPTR)   = IFLPTR
         IQ(LHI+INTPTR+1) = N
         DO 10 I=1,12
            IF(IOPT(I).NE.0)CALL SBIT1(IQ(LHI+INTPTR+2),I)
   10    CONTINUE
         CALL IZINCI(3)
         IF(IOPT(7).NE.0)THEN
            DO 20 I=1,N
               IF(IOPTZ.NE.0)THEN
                  Q(LHF+IFLPTR+I-1)   = Q(LYADR+I-1)
                  Q(LHF+IFLPTR+I+N-1) = Q(LXADR+I-1)
               ELSE
                  Q(LHF+IFLPTR+I-1)   = Y(I)
                  Q(LHF+IFLPTR+I+N-1) = X(I)
               ENDIF
   20       CONTINUE
         ELSE
            DO 30 I=1,N
               IF(IOPTZ.NE.0)THEN
                  Q(LHF+IFLPTR+I-1)   = Q(LXADR+I-1)
                  Q(LHF+IFLPTR+I+N-1) = Q(LYADR+I-1)
               ELSE
                  Q(LHF+IFLPTR+I-1)   = X(I)
                  Q(LHF+IFLPTR+I+N-1) = Y(I)
               ENDIF
   30       CONTINUE
         ENDIF
         CALL IZINCF(2*N)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,A10,I5)') IGRACO,CHOPTM,N
         CALL IMWRIT(1)
         CALL IMFOUT(N,X)
         CALL IMFOUT(N,Y)
         CALL IMWRIT(5)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZHIST, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZHIST(N,X,Y,IOPT,IOPTZ)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. to draw a graphic .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N or 2 or N+1) : X coordinates .
*.  REAL Y(N or 2 or N+1) : Y coordinates .
*.  INTEGER IOPT : Option .
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
      EQUIVALENCE (LXADR,L2NTLA),(LYADR,LDNTLA)
      DIMENSION IOPT(*)
      DIMENSION X(2),Y(2)
*.______________________________________
*
+CDE, HIBIT.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IOPT(8).NE.0)THEN
            IF(IZPUSH(3,2*N+2,0,'IGHIST').NE.0)RETURN
         ELSE
            IF(IZPUSH(3,N+2,0,'IGHIST').NE.0)RETURN
         ENDIF
         CALL IZCFA(IBOFCO,1)
         CALL IZCFA(IBWDCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(ITMSCO,1)
         CALL IZCFA(IALHCO,1)
         CALL IZCFA(IALDCO,1)
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(ITXFCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
         CALL IZCFA(IAWLCO,1)
         CALL IZCFA(IMKCO,1)
         CALL IZCFA(IMKSCO,1)
         CALL IZCFA(IPMCCO,1)
         CALL IZCFA(IBORCO,1)
*
         CALL IZSTCC(IHISCO,INTPTR)
         IQ(LHI+INTPTR)=IFLPTR
         IQ(LHI+INTPTR+1)=N
         DO 10 I=1,14
            IF(IOPT(I).NE.0)CALL SBIT1(IQ(LHI+INTPTR+2),I)
   10    CONTINUE
         CALL IZINCI(3)
         NN=2
         IF(IOPT(5).NE.0)THEN
            IF(IOPTZ.NE.0)THEN
               Q(LHF+IFLPTR)=Q(LYADR)
               Q(LHF+IFLPTR+1)=Q(LYADR+1)
            ELSE
               Q(LHF+IFLPTR)=Y(1)
               Q(LHF+IFLPTR+1)=Y(2)
            ENDIF
            IF(IOPT(8).NE.0)THEN
               NN=N+1
               DO 20 I=3,NN
                  IF(IOPTZ.NE.0)THEN
                     Q(LHF+IFLPTR+I-1)=Q(LYADR+I-1)
                  ELSE
                     Q(LHF+IFLPTR+I-1)=Y(I)
                  ENDIF
   20          CONTINUE
            ENDIF
            CALL IZINCF(NN)
            DO 30 I=1,N
               IF(IOPTZ.NE.0)THEN
                  Q(LHF+IFLPTR+I-1)=Q(LXADR+I-1)
               ELSE
                  Q(LHF+IFLPTR+I-1)=X(I)
               ENDIF
   30       CONTINUE
         ELSE
            IF(IOPTZ.NE.0)THEN
               Q(LHF+IFLPTR)=Q(LXADR)
               Q(LHF+IFLPTR+1)=Q(LXADR+1)
            ELSE
               Q(LHF+IFLPTR)=X(1)
               Q(LHF+IFLPTR+1)=X(2)
            ENDIF
            IF(IOPT(8).NE.0)THEN
               NN=N+1
               DO 40 I=3,NN
                  IF(IOPTZ.NE.0)THEN
                     Q(LHF+IFLPTR+I-1)=Q(LXADR+I-1)
                  ELSE
                     Q(LHF+IFLPTR+I-1)=X(I)
                  ENDIF
   40          CONTINUE
            ENDIF
            CALL IZINCF(NN)
            DO 50 I=1,N
               IF(IOPTZ.NE.0)THEN
                  Q(LHF+IFLPTR+I-1)=Q(LYADR+I-1)
               ELSE
                  Q(LHF+IFLPTR+I-1)=Y(I)
               ENDIF
   50       CONTINUE
         ENDIF
         CALL IZINCF(N)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,A10,I5)') IHISCO,CHOPTM,N
         CALL IMWRIT(1)
         IF(IOPT(5).NE.0)THEN
            IF(IOPT(8).NE.0)THEN
               CALL IMFOUT(N+1,Y)
            ELSE
               CALL IMFOUT(2,Y)
            ENDIF
            CALL IMFOUT(N,X)
         ELSE
            IF(IOPT(8).NE.0)THEN
               CALL IMFOUT(N+1,X)
            ELSE
               CALL IMFOUT(2,X)
            ENDIF
            CALL IMFOUT(N,Y)
         ENDIF
         CALL IMWRIT(5)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
* Control if the current directory is a picture data base.
      SUBROUTINE IZIN(PNAME,ICYCLE)
*.===========>
*.
*.   This routine manages the INput of the pictures on RZ files .
*.
*. _Input parameters:
*.
*.  CHARACTER PNAME : Picture name .
*.  INTEGER ICYCLE : Cycle number of the picture on the RZ file .
*.
*.  Special cases:
*.
*.      If ICYCLE<0 then IABS(ICYCLE) is assumed to be the
*.      picture serial number in the RZ file.
*.      In this case PNAME is an output parameter containing
*.      the name of the picture.
*.      If this serial number does not exist, then PNAME is set to ' '
*.      and IQUEST(1)=1
*.
*.      If PNAME='*' all pictures on disk are put in memory
*.
*..==========> (O.Couet)
+CDE, HIPAW.
      CHARACTER*(*) PNAME
      CHARACTER*20 PNAMEI
      CHARACTER*32 CHPATH
      DIMENSION NAME(5)
      CHARACTER*1 CHOPT
      CHARACTER*8 CHTAG(5),CHFORM
*.______________________________________
*
*              Verify if the picture PNAME is in memory
*
      IF(IZRPIP(PNAME).NE.0)THEN
         CALL IGERR('Picture already in memory','IZIN')
         RETURN
      ENDIF
*
*              Verify if the current working directrory
*              is a pictures data base
*
      CALL RZKEYD(NWKEY,CHFORM,CHTAG)
      IF(CHTAG(2).NE.'PICTURE')RETURN
*
*              Create the bank LHIGZ if it does'nt exist
*
      LPSAV=LPICT
      IF(LHIGZ.EQ.0)THEN
         CALL MZBOOK(IXHIGZ,LPICT,LHIGZ,1,'PICT',1,1,5,2,0)
      ENDIF
*
*              Compute the link of the last picture in memory
*
      LP=LHIGZ
   10 IF(LP.NE.0)THEN
         LAST=LP
         LP=LQ(LP)
         GOTO 10
      ENDIF
*
*              Get the number of pictures on disk
*
      CALL RZCDIR(CHPATH,'RP')
      NKEYS=IQUEST(7)
*
*              Put all pictures on disk in memory
*
      IF(PNAME.EQ.'*')THEN
         DO 40 I=1,NKEYS
            CALL RZIN(IXHIGZ,LAST,0,I,9999,'S')
            LP=LHIGZ
   20       IF(LP.NE.0)THEN
               LAST=LP
               LP=LQ(LP)
               GOTO 20
            ENDIF
            CALL IZSCPI(LAST)
            IF(IQUEST(1).EQ.0)NBPICT=NBPICT+1
            CALL IZPICT(PNAMEI,'R')
            LP=IZRPIP(PNAMEI)
            IF((LP.GT.0).AND.(LP.NE.LPICT))CALL IZPICT(' ','S')
            LP=LHIGZ
   30       IF(LP.NE.0)THEN
               LAST=LP
               LP=LQ(LP)
               GOTO 30
            ENDIF
   40    CONTINUE
         CALL IZSCPI(LPSAV)
         RETURN
      ENDIF
*
*              Put one picture on disk in memory (by name or by number)
*
      IF(ICYCLE.GE.0)THEN
         CHOPT=' '
         LP=IZRPIP(PNAME)
         NCH=LENOCC(PNAME)
         CALL VBLANK(NAME,5)
         CALL UCTOH(PNAME,NAME,4,NCH)
         ICY=ICYCLE
      ELSE
         NAME(1)=-ICYCLE
         PNAME=' '
         IF(NAME(1).GT.NKEYS)THEN
            IQUEST(1)=1
            RETURN
         ENDIF
         NCH=LEN(PNAME)
         NCH=MIN(NCH,20)
         CHOPT='S'
         LP=0
         ICY=9999
      ENDIF
      IF(LP.GT.0) CALL MZDROP(IXHIGZ,LP,' ')
      IF(LAST.EQ.0)THEN
         CALL RZIN(IXHIGZ,LHIGZ,1,NAME,ICY,CHOPT)
      ELSE
         CALL RZIN(IXHIGZ,LAST,0,NAME,ICY,CHOPT)
      ENDIF
      IF(IQUEST(1).EQ.0)THEN
         NBPICT=NBPICT+1
         IF(ICYCLE.LT.0) CALL UHTOC(IQUEST(21),4,PNAME,NCH)
      ENDIF
      CALL IZSCPI(LPSAV)
*
      END
+SELF.
+DECK,  IZINCF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZINCF(INC)
*.===========>
*.
*.   Increments the (F) bank pointer .
*.
*. _Input parameters:
*.
*.  INTEGER INC : Increment .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IFLPTR=IFLPTR+INC
      IQ(LPICT+3)=IFLPTR
*
      END
+SELF.
+DECK,  IZINCI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZINCI(INC)
*.===========>
*.
*.   Increments the (I) bank pointer .
*.
*. _Input parameters:
*.
*.  INTEGER INC : Increment .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      INTPTR=INTPTR+INC
      IQ(LPICT+2)=INTPTR
*
      END
+SELF.
+DECK,  IZINCS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZINCS(INC)
*.===========>
*.
*.   Increments the (C) bank pointer .
*.
*. _Input parameters:
*.
*.  INTEGER INC : Increment .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      ISTPTR=ISTPTR+INC
      IQ(LPICT+4)=ISTPTR
*
      END
+SELF.
+DECK,  IZINIT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZINIT(NWORDS)
*.===========>
*.
*.   This routine initialize the IZ package :
*.
*. -Creates an HIGZ division .
*. -Initialise the links .
*. -Initialize the following parameters :
*.
*.  INSIZ : Default (NT) bank size .
*.  IISIZ : Default (I) bank size .
*.  IFSIZ : Default (F) bank size .
*.  ISSIZ : Default (C) bank size .
*.  NBPICT : Number of pictures in memory .
*.  LPICT : Current picture link . If < 0 , there is no current picture .
*.  LPICD : Displayed picture link . If < 0 , there is no displayed picture .
*.  KXXX : Flag for XXX attributes . Indicate if a primitive with XXX
*.        attributes has been called since the last call to the
*.        XXX attribute .
*.
*. _Input parameters:
*.
*.  INTEGER NWORDS : Minimal ZEBRA space in memory
*.                   (if=0 , standart memory allocation)
*.
*..==========> (O.Couet)
+CDE, HIATNB.
+CDE, HIPAW.
+CDE, HIFLAT.
      DIMENSION IRFLAT(NBRATT),IIFLAT(NBIATT)
      EQUIVALENCE (IRFLAT(1),KMKSC),(IIFLAT(1),KPLCI)
*.______________________________________
*
*              Default bank sizes initialisation
*
      INSIZ=100
      IISIZ=500
      IFSIZ=1000
      ISSIZ=100
*
*              ZEBRA space initialisation
*
      NW=NWORDS
      IF(NW.LT.500)NW=500
      IF(NW.GT.NWPAW-1000)NW=NWPAW-1000
*
*              HIGZ division initialisation
*              Links  initialisation
*
      CALL MZDIV(IXPAWC,IXHIGZ,'HIGZ',NW,NWPAW,'P')
      CALL MZLINK(IXPAWC,'/HILINK/',LHIGZ,LWV,LAST)
*
*              Number of pictures=0
*              No current IZ picture
*              Display picture=current IZ picture
*
      NBPICT=0
      LPICT=-1
      LPICD=LPICT
*
*              Attributes flags initialisation
*
      DO 10 I=1,NBRATT
         IRFLAT(I)=0
   10 CONTINUE
      DO 20 I=1,NBIATT
         IIFLAT(I)=0
   20 CONTINUE
*
      END
+SELF.
+DECK,  IZITOC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:10  mclareni
* Higz

      SUBROUTINE IZITOC(IVAL,CVAL)
*.===========>
*.
*. Convert integer value IVAL into character string CVAL
*.
*..==========>
      CHARACTER*(*) CVAL
      CHARACTER*12 CODED
*.______________________________________
*
      IF1=1
      IIVAL=IVAL
 10   IIVAL=IIVAL/10
      IF(IIVAL.NE.0)THEN
         IF1=IF1+1
         GOTO 10
      ENDIF
      IF(IVAL.LT.0)THEN
         IF1=IF1+1
      ENDIF
      WRITE(CODED,1000)IF1
      WRITE(CVAL,CODED)IVAL
*
 1000 FORMAT(2H(I,I2,1H))
      END
+DECK,  IZLBL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:11  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZLBL
*.===========>
*.
*.   This routine stores the IGLBL data in the current picture .
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
+CDE, HILABS.
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LE.0)RETURN
         IF(IZPUSH(NHILAB+2,0,0,'IGLBL').NE.0)RETURN
         IPUSH=0
         DO 10 I=1,NHILAB
            ILEN  = LENOCC(HILABS(I))
            IPUSH = IPUSH+((ILEN+3)/4)
   10    CONTINUE
         IF(IZPUSH(0,0,IPUSH,'IGLBL').NE.0)RETURN
*
         CALL IZSTCC(ILBLCO,INTPTR)
         IQ(LHI+INTPTR)   = NHILAB
         IQ(LHI+INTPTR+1) = ISTPTR
         DO 20 I=1,NHILAB
            ILEN               = LENOCC(HILABS(I))
            IQ(LHI+INTPTR+I+1) = ILEN
            CALL UCTOH(HILABS(I),IQ(LHC+ISTPTR),4,ILEN)
            CALL IZINCS((ILEN+3)/4)
   20    CONTINUE
         CALL IZINCI(NHILAB+2)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,I5)') ILBLCO,NHILAB
         CALL IMWRIT(1)
         DO 30 I=1,NHILAB
            CHMAIL=HILABS(I)
            CALL IMWRIT(2)
   30    CONTINUE
         CALL IMWRIT(5)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZMERG, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:11  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZMERG(PNAMEI,X0I,Y0I,RI,CHOPT)
*.===========>
*.
*.   This routine merges the picture PNAME in the current picture .
*. the viewport defined in PNAME are transformed according to the
*. parameters X0,Y0,R . These parameters are defined in the NDC space .
*.
*. _Input parameters:
*.
*.  REAL X0,Y0 : Down left corner (in NDC space) of the PNAME picture in
*.               the current picture .
*.  REAL R : Lenght in NDC of the square onto is mapped the transformation 0 .
*.  CHARACTER PNAME : Picture name .
*.  CHARACTER CHOPT : Option .
*.
*.                    CHOPT='D' : If the displayed picture is not the current
*.                                picture the displayed picture is cleared and
*.                                the current picture is displayed .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
      CHARACTER*(*) PNAMEI,CHOPT
      CHARACTER*20 PNAME
      LOGICAL GFSAV,ZFSAV
      DIMENSION IOPT(1)
      EQUIVALENCE (IOPT(1),IOPTD)
*.______________________________________
*
      CALL UOPTC (CHOPT,'D',IOPT)
      PNAME=PNAMEI
*
*              Adressing pictures by number
*
      INUM=IGASCI(PNAME(1:1))
      IF(49.LE.INUM.AND.INUM.LE.57)THEN
         READ (PNAME,'(I15)',ERR=20 ) INUM
         IF(INUM.GT.NBPICT)THEN
            CALL IGERR('Picture not in memory','IZMERG')
            RETURN
         ENDIF
         LP=LQ(LHIGZ)
         DO 10 I=1,INUM-1
            LP=LQ(LP)
   10    CONTINUE
         LCH=LQ(LP-4)
         CALL UHTOC(IQ(LCH+1),4,PNAME,IQ(LP+1))
         GOTO 30
   20    CALL IGERR('PNAME must begin with a letter','IZMERG')
         RETURN
      ENDIF
   30 CONTINUE
*
      X0=X0I
      Y0=Y0I
      R=RI
      LPIC2=IZRPIP(PNAME)
      IF(LPIC2.LE.0)RETURN
      IF(LPICT.LE.0)THEN
         CALL IGERR('No current picture','IZMERG')
         RETURN
      ENDIF
*
      IF((X0.LT.0.).OR.(X0.GT.1.))RETURN
      IF((Y0.LT.0.).OR.(Y0.GT.1.))RETURN
      IF((R.LT.0.).OR.(R.GT.1.))RETURN
      RX=-1.
      RY=-1.
      IF(X0+R.GT.1.)RX=1.-X0
      IF(Y0+R.GT.1.)RY=1.-Y0
      IF((RX.GE.0).OR.(RY.GE.0.))R=MAX(RX,RY)
      IF((RX.GE.0).AND.(RY.GE.0.))R=MIN(RX,RY)
*
      L2NT0=LQ(LPIC2-1)
      L2I=LQ(LPIC2-2)
      L2F=LQ(LPIC2-3)
      L2C=LQ(LPIC2-4)
*
      GFSAV=GFLAG
      ZFSAV=ZFLAG
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      IF((IOPTD.NE.0).AND.(.NOT.MFLAG))THEN
         GFLAG=.TRUE.
         IF(LPICD.NE.LPICT)THEN
            ZFLAG=.FALSE.
            GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
            CALL ICLRWK(0,0)
            CALL IZDIPI(LPICT)
         ENDIF
      ENDIF
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      NTNEW=99
   40 NTNEW=NTNEW+1
+SELF, IF=ZEBRA, IF=-NTC, IF=-X11.
      CALL IZGNT(NTNEW,IFIND,IAWV,IPRIO,IHPRIO)
      IF(IFIND.NE.0)GOTO 40
+SELF, IF=ZEBRA, IF=NTC,X11.
      IF(IGNSCU(NTNEW).NE.0)GOTO 40
+SELF, IF=ZEBRA.
      CALL ISVP(NTNEW,X0,X0+R,Y0,Y0+R)
      CALL ISELNT(NTNEW)
      CALL IZDNB(L2NT0,L2I,L2F,L2C,0,0)
      IF(IQ(LPIC2+8).EQ.1)GOTO 90
*
*              Merge the NT banks
*
      NGT=0
   50 L2NT=IZGNGT(LPIC2,NGT)
      NGT=IQ(L2NT+3)
      IF(IQ(L2NT+1).EQ.0)GOTO 50
      N=IQ(LPIC2+8)-1
      DO 80 I=1,N
*
* Set the normalisation transformation
*
   60    NTNEW=NTNEW+1
+SELF, IF=ZEBRA, IF=-NTC, IF=-X11.
         CALL IZGNT(NTNEW,IFIND,IAWV,IPRIO,IHPRIO)
         IF(IFIND.NE.0)GOTO 60
+SELF, IF=ZEBRA, IF=NTC,X11.
         IF(IGNSCU(NTNEW).NE.0)GOTO 60
+SELF, IF=ZEBRA.
         IWVA=IQ(L2NT+2)
         CALL ISWN(NTNEW
     +,            Q(L2F+IWVA)
     +,            Q(L2F+IWVA+1)
     +,            Q(L2F+IWVA+2)
     +,            Q(L2F+IWVA+3))
         CALL ISVP(NTNEW
     +,           (Q(L2F+IWVA+4)*R+X0)
     +,           (Q(L2F+IWVA+5)*R+X0)
     +,           (Q(L2F+IWVA+6)*R+Y0)
     +,           (Q(L2F+IWVA+7)*R+Y0))
         CALL ISELNT(NTNEW)
*
* Decode the NT bank linked to LN
*
         CALL IZDNB(L2NT,L2I,L2F,L2C,0,0)
*
* Give the link of the next highest priority NT bank
*
   70    LN=IZGNGT(LPIC2,NGT)
         IF(LN.EQ.0)RETURN
         L2NT=LN
         NGT=IQ(L2NT+3)
         IF(IQ(L2NT+1).EQ.0)GOTO 70
   80 CONTINUE
*
   90 GFLAG=GFSAV
      ZFLAG=ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      END
+SELF.
+DECK,  IZML, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:11  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZML(N,X,Y)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. to draw a multiline .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
      DIMENSION X(*),Y(*)
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,I5)') IMLCO,N
         CALL IMWRIT(1)
         CALL IMFOUT(N,X)
         CALL IMFOUT(N,Y)
         CALL IMWRIT(5)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(2,2*N,0,'IML').NE.0)RETURN
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZSTCC(IMLCO,INTPTR)
         IQ(LHI+INTPTR)=IFLPTR
         IQ(LHI+INTPTR+1)=N
         CALL IZINCI(2)
         DO 10 I=1,N
            Q(LHF+IFLPTR+I-1)=X(I)
   10    CONTINUE
         DO 20 I=1,N
            Q(LHF+IFLPTR+I+N-1)=Y(I)
   20    CONTINUE
         CALL IZINCF(2*N)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZML3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:11  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZML3(N,X,Y,Z)
*.===========>
*.
*..==========> (O.Couet)
      DIMENSION X(*),Y(*),Z(*)
*.______________________________________
*
      END
+SELF.
+DECK,  IZOPEN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:12  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZOPEN(LUN,CHDIR,CFNAME,CHOPTT,LRECL,ISTAT)
*.==========>
*.           Open a HIGZ/RZ picture file
*..=========> ( R.Brun )
      CHARACTER*(*) CFNAME,CHDIR,CHOPTT
      CHARACTER*8 CHOPT
*.___________________________________________
*
      CHOPT=CHOPTT
      CALL CLTOU(CHOPT)
*
      CALL RZOPEN(LUN,CHDIR,CFNAME,CHOPT,LRECL,ISTAT)
      IF(ISTAT.NE.0)THEN
         CALL IGERR('Cannot open file','IZOPEN')
         RETURN
      ENDIF
*
      CALL IZFILE(LUN,CHDIR,CHOPT)
*
      END
+SELF.
+DECK,  IZOUT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:12  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZOUT(PNAME,ICYCLE)
*.===========>
*.
*.   This routine manages the OUTput of the pictures on RZ files .
*.
*. _Input parameters:
*.
*.  CHARACTER PNAME : Picture name.
*.                   - If PNAME='*' all pictures in memory
*.                     are stored on disk
*.                   - If PNAME=' ' the current picture in memory
*.                     is stored on disk
*.  INTEGER ICYCLE : Number of version of the picture on the RZ file .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
      CHARACTER*(*) PNAME
      CHARACTER*20 PNAMEI
      DIMENSION NAME(5)
*.______________________________________
*
      IF(NBPICT.EQ.0)THEN
         CALL IGERR('No picture in memory','IZOUT')
         RETURN
      ENDIF
      PNAMEI=PNAME
*
*              Adressing pictures by number
*
      INUM=IGASCI(PNAMEI(1:1))
      IF(49.LE.INUM.AND.INUM.LE.57)THEN
         READ (PNAMEI,'(I15)',ERR=21 ) INUM
         IF(INUM.GT.NBPICT)THEN
            CALL IGERR('Picture not in memory','IZOUT')
            RETURN
         ENDIF
         LP=LQ(LHIGZ)
         DO 11 I=1,INUM-1
            LP=LQ(LP)
   11    CONTINUE
         LCH=LQ(LP-4)
         CALL UHTOC(IQ(LCH+1),4,PNAMEI,IQ(LP+1))
         GOTO 31
   21    CALL IGERR('PNAME must begin with a letter','IZOUT')
         RETURN
      ENDIF
   31 CONTINUE
*
*              Store all pictures in memory in the current
*              picture data base.
*
      IF(PNAMEI.EQ.'*')THEN
         LP=LPICT
         IF(LP.GT.0)LPSAV=LPICT
         CALL IZPICT(' ','F')
         DO 10 I=1,NBPICT
            CALL IZPICT(PNAMEI,'R')
            IF(PNAMEI.EQ.' ')GOTO 20
            LAST=IZRPIP(PNAMEI)
            NCH=LENOCC(PNAMEI)
            CALL VBLANK(NAME,5)
            CALL UCTOH(PNAMEI,NAME,4,NCH)
            CALL IZWIP(LAST)
            CALL RZOUT(IXHIGZ,LAST,NAME,ICYCLE,' ')
            CALL RZSAVE
            CALL IZPICT(' ','N')
   10    CONTINUE
   20    IF(LP.GT.0)THEN
            CALL IZSCPI(LPSAV)
         ELSE
            LPICT=-1
         ENDIF
         RETURN
      ENDIF
*
*              Store the picture PNAME (or the current picture if
*              PNAME=' ') in memory in the current picture data base.
*
      IF(PNAMEI.NE.' ')THEN
         LAST=IZRPIP(PNAMEI)
         IF(LAST.EQ.0)THEN
            CALL IGERR('This picture is not in memory','IZOUT')
            RETURN
         ENDIF
      ELSE
         IF(LPICT.LE.0)THEN
            CALL IGERR('No current picture','IZOUT')
            RETURN
         ENDIF
         LAST=LPICT
         CALL IZPICT(PNAMEI,'R')
      ENDIF
      NCH=LENOCC(PNAMEI)
      CALL VBLANK(NAME,5)
      CALL UCTOH(PNAMEI,NAME,4,NCH)
      CALL IZWIP(LAST)
      CALL RZOUT(IXHIGZ,LAST,NAME,ICYCLE,' ')
      CALL RZSAVE
*
      END
+SELF.
+DECK,  IZPAVE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:12  mclareni
* Higz

      SUBROUTINE IZPAVE(X1I,X2I,Y1I,Y2I,DZ,ISBOX,ISFRAM,IOPT)
*.===========>
*.
*.   This routine store in the current picture the necessary data to
*. draw a pave.
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA.
+CDE, HIPAW.
+SELF.
      DIMENSION IOPT(*)
*.______________________________________
*
+SELF, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(4,5,0,'IGPAVE').NE.0)RETURN
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(ILNCO,1)
*
         CALL IZSTCC(IPAVCO,INTPTR)
         IQ(LHI+INTPTR)   = IFLPTR
         IQ(LHI+INTPTR+1) = ISBOX
         IQ(LHI+INTPTR+2) = ISFRAM
         DO 10 I=1,9
            IF(IOPT(I).NE.0)CALL SBIT1(IQ(LHI+INTPTR+3),I)
   10    CONTINUE
         CALL IZINCI(4)
         Q(LHF+IFLPTR)   = X1I
         Q(LHF+IFLPTR+1) = X2I
         Q(LHF+IFLPTR+2) = Y1I
         Q(LHF+IFLPTR+3) = Y2I
         Q(LHF+IFLPTR+4) = DZ
         CALL IZINCF(5)
      ENDIF
+SELF.
*
      END
+DECK,  IZPICT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:12  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZPICT(PNAMEI,CHOPT)
*.===========>
*.
*.    This routine acts on the picture representation in the ZEBRA data
*. base according to the values of CHOPT. The following diagram shows
*. the general structure of an HIGZ picture.
*.
*.
*.              General structure of an HIGZ picture
*.             ______________________________________
*.
*.                      LPICT
*.                        |
*.                        |
*.  +----+----+----+----+-V-+----------------------------------\
*.  | -4 | -3 | -2 | -1 |   | Top control bank (TCB)            >
*.  +--+-+--+-+--+-+--+-+---+----------------------------------/
*.     |LHC |LHF |LHI |LHNT0
*.     |    |    |    |         +----------\
*.     |    |    |    +-------->| NT banks  >
*.     |    |    |              +----------/
*.     |    |    |              +--------------+
*.     |    |    +------------->| Integer bank |
*.     |    |                   +--------------+
*.     |    |                   +-----------+
*.     |    +------------------>| Real bank |
*.     |                        +-----------+
*.     |                        +----------------+
*.     +----------------------->| Character bank |
*.                              +----------------+
*.
*.                      Content of the Top Control bank
*.                     _________________________________
*.
*.        1                2                 3                 4
*. +--------------+-----------------+-----------------+----------------+
*. | PNAME length | Integer bank    | Real bank       | Character bank |
*. | in character | pointer: INTPTR | pointer: IFLPTR | pointer: ISTPTR|
*. +--------------+-----------------+-----------------+----------------+
*.
*.     5        6        7        8
*. +--------+--------+--------+--------+
*. | IRISIZ | IRFSIZ | IRSSIZ | INBNT  |
*. +--------+--------+--------+--------+
*.
*.                      Content of a NT bank
*.                     ______________________
*.
*.        1                  2                        3            4
*. +-----------+----------------------------+------------------+-------+
*. | NT Number | Window and Viewport adress | Display Priority | ITBPTR|
*. +-----------+----------------------------+------------------+-------+
*.
*.     5                 6                       7
*. +-------+--------------------------+-----------------------+
*. | Level | Integer Attributes Flags | Real Attributes Flags |
*. +-------+--------------------------+-----------------------+
*.
*.                     8
*. +------------------------------------------+
*. | Adress of the default Integer attributes |
*. +------------------------------------------+
*.
*.                     9
*. +---------------------------------------+
*. | Adress of the default real attributes |
*. +---------------------------------------+
*.
*.     10 ...
*. +---------- - - - -  -   -    -     -
*. | Graphics primitives and attributes
*. +---------- - - - -  -   -    -     -
*.
*.                      Content of the Integer bank
*.                     _____________________________
*.
*.          1 .... NBIATT
*. +------------------------------------------+
*. |  Integer attributes word of the NT 0     |
*. +------------------------------------------+
*.
*.       NBIATT ...
*. +----------- - - - -  -   -
*. | Graphics Integer data
*. +----------- - - - -  -   -
*.
*.                      Content of the Real bank
*.                     __________________________
*.
*.          1 .... NBRATT
*. +---------------------------------------+
*. |  Real attributes word of the NT 0     |
*. +---------------------------------------+
*.
*.       NBRATT ...
*. +----------- - - - -  -   -
*. | Graphics Real data
*. +----------- - - - -  -   -
*.
*.                      Content of the Character bank
*.                     _______________________________
*.
*.      1 .... 5
*. +-----------------+
*. |  Picture name   |
*. +-----------------+
*.
*.       6 ...
*. +----------- - - - -  -   -
*. | Character data
*. +----------- - - - -  -   -
*.
*. _Input parameters:
*.
*.  CHARACTER PNAMEI : Picture name . Input parameter with the options :
*.                     M,D,S,P,C,O
*.  CHARACTER CHOPT : Option .
*.
*.              CHOPT='M'ake a new picture.
*.              CHOPT='D'isplay the picture PNAMEI.
*.              CHOPT='S'cratch picture.
*.              CHOPT='N'ext picture.
*.              CHOPT='L'ist pictures.
*.              CHOPT='AL' Full listing of the pictures.
*.              CHOPT='F'irst picture.
*.              CHOPT='P'rint the contain of a picture.
*.              CHOPT='C'urrent picture.
*.              CHOPT='R'etrieve picture name.
*.              CHOPT='Q'uiet (not error message).
*.              CHOPT='G' retrieve the dispalyed (Graphic) picture name.
*.              CHOPT='O'rder the NT banks in the picture PNAMEI
*.                     in the order of creation.
*.
*. _Output parameters:
*.
*.  CHARACTER PNAMEI : Picture name .
*.                     Output parameter with the option : R or G
*.
*. N.B. PNAMEI is not used if CHOPT='L' or CHOPT='AL'
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HILUN.
+CDE, HIFLAG.
+CDE, HIATNB.
+CDE, HIATT.
+CDE, HIFLAT.
+CDE, HICUR.
      DIMENSION IRFLAT(NBRATT),IIFLAT(NBIATT)
      EQUIVALENCE (IRFLAT(1),KMKSC),(IIFLAT(1),KPLCI)
      CHARACTER*(*) CHOPT,PNAMEI
      CHARACTER*80 STR,OLDDIR,PNAME
      CHARACTER*80 CHARS
      CHARACTER*10 CHPTNO
      DIMENSION IOPT(13),INAME(5)
      EQUIVALENCE (IOPT(1) ,IOPTM),(IOPT(2) ,IOPTD),(IOPT(3) ,IOPTS)
      EQUIVALENCE (IOPT(4) ,IOPTN),(IOPT(5) ,IOPTL),(IOPT(6) ,IOPTF)
      EQUIVALENCE (IOPT(7) ,IOPTP),(IOPT(8) ,IOPTC),(IOPT(9) ,IOPTR)
      EQUIVALENCE (IOPT(10),IOPTG),(IOPT(11),IOPTQ),(IOPT(12),IOPTA)
      EQUIVALENCE (IOPT(13),IOPTO)
*.______________________________________
*
      CALL UOPTC (CHOPT,'MDSNLFPCRGQAO',IOPT)
      PNAME=PNAMEI
      IQUEST(1)=0
*
*              Adressing pictures by number
*
      INUM=IGASCI(PNAME(1:1))
      IF(49.LE.INUM.AND.INUM.LE.57)THEN
         IF(IOPTM.NE.0)GOTO 20
         CALL IZCTOI(PNAME,INUM)
         IF(IQUEST(1).NE.0)GOTO 20
         IF(INUM.GT.NBPICT)THEN
            IF(IOPTQ.EQ.0)CALL IGERR('Picture not in memory',' ')
            RETURN
         ENDIF
         LP=LQ(LHIGZ)
         DO 10 I=1,INUM-1
            LP=LQ(LP)
   10    CONTINUE
         LCH=LQ(LP-4)
         CALL UHTOC(IQ(LCH+1),4,STR,IQ(LP+1))
         PNAME=STR(1:IQ(LP+1))
         GOTO 30
   20    IF(IOPTQ.EQ.0)CALL IGERR('PNAME must begin with a letter'
     +,                           'IZPICT')
         RETURN
      ENDIF
   30 CONTINUE
*.______________________________________
*
*              First picture
*
      IF(IOPTF.NE.0)THEN
         IF(NBPICT.NE.0)THEN
            IF(LPICT.GT.0)CALL IZWIP(LPICT)
            CALL IZSCPI(LQ(LHIGZ))
            ZFLAG=.TRUE.
            GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         ELSE
            IF(IOPTQ.EQ.0)CALL IGERR('No picture in memory',' ')
            RETURN
         ENDIF
      ENDIF
*.______________________________________
*
*              Current picture
*

      IF(IOPTC.NE.0)THEN
         IF(NBPICT.NE.0)THEN
            IF(LPICT.GT.0)CALL IZWIP(LPICT)
            IF(PNAME.EQ.' '.OR.PNAME.EQ.'*')GOTO 40
            LP=IZRPIP(PNAME)
            IF(LP.NE.0)THEN
               CALL IZSCPI(LP)
               ZFLAG=.TRUE.
               GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
            ELSE
               IF(IOPTQ.EQ.0)CALL IGERR('This picture is not in memory'
     +,                                 ' ')
               RETURN
            ENDIF
         ELSE
            IF(IOPTQ.EQ.0)CALL IGERR('No picture in memory',' ')
            RETURN
         ENDIF
      ENDIF
   40 CONTINUE
*.______________________________________
*
*              Next picture
*
      IF(IOPTN.NE.0)THEN
         IF(NBPICT.NE.0)THEN
            IF(LPICT.LT.0)THEN
               IF(IOPTQ.EQ.0)CALL IGERR('No current picture',' ')
               RETURN
            ENDIF
            CALL IZWIP(LPICT)
            IF(LQ(LPICT).NE.0)THEN
               CALL IZSCPI(LQ(LPICT))
            ELSE
               CALL IZSCPI(LQ(LHIGZ))
            ENDIF
         ELSE
            IF(IOPTQ.EQ.0)CALL IGERR('No picture in memory',' ')
            RETURN
         ENDIF
      ENDIF
*.______________________________________
*
*             Make a new picture in memory with name PNAME
*
      IF(IOPTM.NE.0)THEN
*
* HIGZ is automatically set in the state 'Z' or 'GZ'
*
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
* Automatic naming of the picture if PNAME=' ' or PNAME='*'
*
         IF((PNAME.EQ.' ').OR.(PNAME.EQ.'*'))THEN
            WRITE (CHPTNO,10100) IPICT
            IPICT=IPICT+1
            NLAST=LENOCC(CHPTNO)
            NFIRST=1
   50       IF(CHPTNO(NFIRST:NFIRST).EQ.' ')THEN
               NFIRST=NFIRST+1
               GOTO 50
            ENDIF
            PNAME='PICT'//CHPTNO(NFIRST:NLAST)
         ENDIF
*
* Automatic saving of the current picture in the RZ data base
*
         IF(LPICT.GT.0)THEN
            CALL IZWIP(LPICT)
            IF(ASFLAG)THEN
               CALL VBLANK(INAME,5)
               LOOP=(IQ(LPICT+1)+3)/4
               DO 60 I=1,LOOP
                  INAME(I)=IQ(LQ(LPICT-4)+I)
   60          CONTINUE
               LPSAV=LPICT
               CALL RZCDIR(OLDDIR,'R')
               CALL RZCDIR(HICDIR,' ')
               CALL RZOUT(IXHIGZ,LPSAV,INAME,ICYCLE,' ')
               CALL RZSAVE
               CALL RZCDIR(OLDDIR,' ')
               IF(LQ(LPSAV).NE.0)THEN
                  CALL IZSCPI(LQ(LPSAV))
               ELSE
                  CALL IZSCPI(LQ(LHIGZ))
               ENDIF
               CALL MZDROP(IXHIGZ,LPSAV,' ')
               NBPICT=NBPICT-1
               IF(NBPICT.EQ.0)THEN
                  CALL MZDROP(IXHIGZ,LHIGZ,' ')
                  LHIGZ=0
                  LPICT=-1
               ENDIF
            ENDIF
         ENDIF
*
* Create a small bank (LHIGZ) onto the all HIGZ structure is linked
*
         IF(LHIGZ.EQ.0)THEN
            CALL MZBOOK(IXHIGZ,LPICT,LHIGZ,1,'PICT',1,1,5,2,0)
         ENDIF
*
* If PNAME already exist
*
         IF(IZRPIP(PNAME).NE.0)THEN
            IF(IOPTQ.EQ.0)CALL IGERR('This picture already exist'
     +,                              'IZPICT')
            RETURN
         ENDIF
*
* Compute the link of the last picture in memory. The new picture
* is linked to the last picture in memory (LPICT=LAST)
*
         LP=LHIGZ
   70    IF(LP.NE.0)THEN
            LAST=LP
            LP=LQ(LP)
            GOTO 70
         ENDIF
         LPICT=LAST
*
* Create the Top Control Bank
*
         CALL MZBOOK(IXHIGZ,LHP,LPICT,0,'PICT',4,4,8,2,0)
         LPICT  = LHP
         LAST   = LPICT
*
* Create the Normalisation Transformation Bank number 0
*
         CALL MZBOOK(IXHIGZ,LHNT0,LPICT,-1,'HZNT',0,0,INSIZ,2,0)
*
* Create the Integer Data Bank
*
         CALL MZBOOK(IXHIGZ,LHI,LPICT,-2,'PICI',0,0,IISIZ,2,0)
*
* Create the Floating Point Data Bank
*
         CALL MZBOOK(IXHIGZ,LHF,LPICT,-3,'PICF',0,0,IFSIZ,3,0)
*
* Create the Character Data Bank
*
         CALL MZBOOK(IXHIGZ,LHC,LPICT,-4,'PICC',0,0,ISSIZ,5,0)
*
* (Number of pictures in memory) = (Number of pictures in menory) + 1
*
         NBPICT = NBPICT+1
*
* Links initialisation
*
         LHNT   = LHNT0
         LHNTLA = LHNT
*
* Number of Normalisation Transformation in the current picture
*
         INBNT  = 1
*
* The structure level number is 0
*
         INBLEV = 0
*
* Pointers initialisation
*
*   ITBPTR = Last free adress in the current transformation bank
*   INTPTR = Last free adress in the INTEGER bank data
*   IFLPTR = Last free adress in the REAL bank data
*   ISTPTR = Last free adress in the CHARACTER bank data
*   IIAPTR = Default INTEGER attributes adress
*   IRAPTR = Default REAL attributes adress
*
         ITBPTR = 10
         INTPTR = NBIATT+1
         IFLPTR = NBRATT+1
         ISTPTR = 1
         IIAPTR = 1
         IRAPTR = 1
*
* Initialisation of the real size of the bank
*
*   IRNSIZ = Real size of the current transformation bank
*   IRISIZ = Real size of the current INTEGER bank
*   IRFSIZ = Real size of the current REAL bank
*   IRSSIZ = Real size of the current CHARACTER bank
*
         IRNSIZ = INSIZ
         IRISIZ = IISIZ
         IRFSIZ = IFSIZ
         IRSSIZ = ISSIZ
*
* Names the picture. The picture name is truncated to 20 characters
*
         NCHP   = LENOCC(PNAME)
         IF(NCHP.GT.20)NCHP=20
         IF(NCHP.NE.0)THEN
            CALL UCTOH(PNAME,IQ(LHC+1),4,NCHP)
            CALL IZINCS(5)
         ENDIF
*
* Initialisation of the top control bank
*
         IQ(LPICT+1) = NCHP
         IQ(LPICT+2) = INTPTR
         IQ(LPICT+3) = IFLPTR
         IQ(LPICT+4) = ISTPTR
         IQ(LPICT+5) = IRISIZ
         IQ(LPICT+6) = IRFSIZ
         IQ(LPICT+7) = IRSSIZ
         IQ(LPICT+8) = INBNT
*
* Initialisation of the Normalisation Transformation bank 0
*
         IQ(LHNT+1) = 0
         CALL SBIT0(IQ(LHNT0+2),1)
         IQ(LHNT+3) = 1
         IQ(LHNT+4) = ITBPTR
         IQ(LHNT+5) = 0
         IQ(LHNT+8) = 1000000*NBIATT+IIAPTR
         IQ(LHNT+9) = 1000000*NBRATT+IRAPTR
         CALL IZCDA(0)
*
* Attributes flags initialisation
*
         DO 80 I=1,NBRATT
            IRFLAT(I) = 0
   80    CONTINUE
         DO 90 I=1,NBIATT
            IIFLAT(I) = 0
   90    CONTINUE
*
* Sets the current displayed picture pointers
*
         IF(GFLAG)THEN
            LPICD  = LPICT
            LDNT0  = LQ(LPICD-1)
            LDI    = LQ(LPICD-2)
            LDF    = LQ(LPICD-3)
            LDC    = LQ(LPICD-4)
            LDNT   = LDNT0
            LDNTLA = LDNT
         ENDIF
      ENDIF
*.______________________________________
*
*              Sort NT banks in the picture PNAME
*
      IF(IOPTO.NE.0)THEN
         IF(NBPICT.NE.0)THEN
*
* Order all pictures in memory
*
            IF(PNAME.EQ.'*')THEN
               LPSAV = LQ(LHIGZ)
               DO 120 I=1,NBPICT
                  LN = LQ(LPSAV-1)
                  DO 100 J=1,IQ(LPSAV+8)
                     IF(LN.EQ.0)GOTO 110
                     IQ(LN+3) = J
                     LN       = LQ(LN)
  100             CONTINUE
  110             LPSAV       = LQ(LPSAV)
                  IF(LPSAV.EQ.0)GOTO 140
  120          CONTINUE
            ENDIF
*
* Order one picture in memory
*
            IF(PNAME.EQ.' ')THEN
               LP = LPICT
            ELSE
               LP = IZRPIP(PNAME)
            ENDIF
            IF(LP.NE.0)THEN
               LN = LQ(LP-1)
               DO 130 I=1,IQ(LP+8)
                  IF(LN.EQ.0)GOTO 140
                  IQ(LN+3) = I
                  LN       = LQ(LN)
  130          CONTINUE
            ELSE
               IF(IOPTQ.EQ.0)CALL IGERR('This picture is not in memory'
     +,                                 ' ')
               RETURN
            ENDIF
         ELSE
            IF(IOPTQ.EQ.0)CALL IGERR('No picture in memory',' ')
            RETURN
         ENDIF
      ENDIF
  140 CONTINUE
*.______________________________________
*
*              Display pictures in memory
*
      IF(IOPTD.NE.0)THEN
         IF(NBPICT.NE.0)THEN
*
* Display all pictures in memory
*
            IF(PNAME.EQ.'*')THEN
               LPSAV=LQ(LHIGZ)
               DO 150 I=1,NBPICT
                  CALL IZDIPI(LPSAV)
                  LPSAV=LQ(LPSAV)
                  IF(LPSAV.EQ.0)RETURN
  150          CONTINUE
               RETURN
            ENDIF
*
* Display the current picture in memory
*
            IF(PNAME.EQ.' ')THEN
               IF(LPICT.LT.0)THEN
                  IF(IOPTQ.EQ.0)CALL IGERR('No current picture',' ')
                  RETURN
               ENDIF
               CALL IZDIPI(LPICT)
               RETURN
            ENDIF
*
* Display the picture PNAME in memory
*
            LP=IZRPIP(PNAME)
            IF(LP.NE.0)THEN
               CALL IZDIPI(LP)
            ELSE
               IF(IOPTQ.EQ.0)CALL IGERR('This picture is not in memory'
     +,                                 'IZPICT')
               RETURN
            ENDIF
         ELSE
            IF(IOPTQ.EQ.0)CALL IGERR('No picture in memory',' ')
            RETURN
         ENDIF
      ENDIF
*.______________________________________
*
*              Scratch the picture PNAME from memory
*
      IF(IOPTS.NE.0)THEN
         IF(NBPICT.NE.0)THEN
*
* Delete all pictures in memory
*
            IF(PNAME.EQ.'*')THEN
               LPSAV=LQ(LHIGZ)
               DO 160 I=1,NBPICT
                  CALL MZDROP(IXHIGZ,LPSAV,' ')
                  LPSAV=LQ(LPSAV)
                  IF(LPSAV.EQ.0)GOTO 170
  160          CONTINUE
  170          NBPICT=0
               LPICT=-1
               LPICD=-1
               CALL MZDROP(IXHIGZ,LHIGZ,' ')
               LHIGZ=0
               RETURN
            ENDIF
*
* Delete one picture in memory
*
            IF(PNAME.EQ.' ')THEN
               LP=LPICT
            ELSE
               LP=IZRPIP(PNAME)
            ENDIF
            IF(LP.NE.0)THEN
               IF(LP.EQ.LPICD)LPICD=-1
               IF(LP.EQ.LPICT)THEN
                  IF(LQ(LPICT).NE.0)THEN
                     CALL IZSCPI(LQ(LPICT))
                  ELSE
                     CALL IZSCPI(LQ(LHIGZ))
                  ENDIF
               ENDIF
               CALL MZDROP(IXHIGZ,LP,' ')
               NBPICT=NBPICT-1
               IF(NBPICT.EQ.0)THEN
                  CALL MZDROP(IXHIGZ,LHIGZ,' ')
                  LHIGZ=0
                  LPICT=-1
               ENDIF
            ELSE
               IF(IOPTQ.EQ.0)CALL IGERR('This picture is not in memory'
     +,                                 ' ')
               RETURN
            ENDIF
         ELSE
            IF(IOPTQ.EQ.0)CALL IGERR('No picture in memory',' ')
            RETURN
         ENDIF
      ENDIF
*.______________________________________
*
*              List the pictures in memory
*

      IF(IOPTL.NE.0)THEN
         IF(NBPICT.NE.0)THEN
            CALL IGSA(0)
            LP=LQ(LHIGZ)
            IF(IOPTA.NE.0)WRITE(LUNOUT,10400)
            DO 190 I=1,NBPICT
               LCH=LQ(LP-4)
               CALL UHTOC(IQ(LCH+1),4,STR,IQ(LP+1))
               CHARS=STR(1:IQ(LP+1))
*
* Full listing
*
               IF(IOPTA.NE.0)THEN
                  LN=LQ(LP-1)
                  IP=IQ(LN+3)
                  NT=IQ(LN+1)
                  IS=IQ(LP+2)+IQ(LP+3)+IQ(LP+4)
                  DO 180 J=1,IQ(LP+8)
                     IS=IS+IQ(LN+4)
                     IF(IQ(LN+3).GT.IP)THEN
                        IP=IQ(LN+3)
                        NT=IQ(LN+1)
                     ENDIF
                     LN=LQ(LN)
  180             CONTINUE
                  IF(LP.EQ.LPICT)THEN
                     WRITE(LUNOUT,10300) I,CHARS(1:20),IS,IQ(LP+8),NT
                  ELSE
                     WRITE(LUNOUT,10200) I,CHARS(1:20),IS,IQ(LP+8),NT
                  ENDIF
               ELSE
*
* Simple listing
*
                  IF(LP.EQ.LPICT)THEN
                     CHARS=CHARS(1:LENOCC(CHARS))//' <-- Current '
     +               //'Picture'
                     IF(ZFLAG)THEN
                        CHARS=CHARS(1:LENOCC(CHARS))//' (Active)'
                     ENDIF
                  ENDIF
                  WRITE(LUNOUT,10000) I,CHARS(1:LENOCC(CHARS))
               ENDIF
               LP=LQ(LP)
  190       CONTINUE
         ELSE
            IF(IOPTQ.EQ.0)CALL IGERR('No picture in memory',' ')
            RETURN
         ENDIF
      ENDIF
*.______________________________________
*
*              Print the picture data structure
*
      IF(IOPTP.NE.0)THEN
         CALL IGSA(0)
         IF(PNAME.NE.' ')THEN
            LP=IZRPIP(PNAME)
            IF(LP.NE.0)THEN
               CALL IZWIP(LP)
               CALL DZSHOW(PNAME,IXHIGZ,LP,'BV',0,0,0,0)
            ELSE
               IF(IOPTQ.EQ.0)CALL IGERR('This picture is not in memory'
     +,                                 ' ')
               RETURN
            ENDIF
         ELSE
            IF(LPICT.GT.0)THEN
               CALL IZWIP(LPICT)
               CALL DZSHOW(PNAME,IXHIGZ,LPICT,'BV',0,0,0,0)
            ELSE
               IF(IOPTQ.EQ.0)CALL IGERR('No current picture',' ')
               RETURN
            ENDIF
         ENDIF
      ENDIF
*.______________________________________
*
*              Retrieve current picture name
*

      IF(IOPTR.NE.0)THEN
         PNAMEI=' '
         IF(LPICT.LT.0)RETURN
         CALL UHTOC(IQ(LHC+1),4,STR,IQ(LPICT+1))
         PNAMEI=STR(1:IQ(LPICT+1))
      ENDIF
*.______________________________________
*
*              Retrieve displayed picture name
*
      IF(IOPTG.NE.0)THEN
         PNAMEI=' '
         IF(LPICD.LT.0)RETURN
         CALL UHTOC(IQ(LDC+1),4,STR,IQ(LPICD+1))
         PNAMEI=STR(1:IQ(LPICD+1))
      ENDIF
*
10000 FORMAT(1X,I5,': ',A)
10100 FORMAT(I10)
10200 FORMAT(1X,I5,': ',A,3X,I6,10X,I5,10X,I6)
10300 FORMAT(1X,I5,': ',A,'*',2X,I6,10X,I5,10X,I6)
10400 FORMAT(1X,/,'          PICTURE NAME      '
     +,'SIZE IN WORDS   ','NUMBER OF NT   ','CURRENT NT'/)
      END
+SELF.
+DECK,  IZPL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:12  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZPL(N,X,Y)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. to draw a polyline .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIATT.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      DIMENSION X(*),Y(*)
*.______________________________________
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      IF(PFLAG)THEN
         IF(ILN.GE.12.AND.ILN.LE.15)GOTO 10
         CALL IPZONE
         CALL IPLTYP(ILN)
         IF(TFLAG)THEN
            CALL IPDRAW(N,X,Y)
         ELSE
            CALL IPLWID(INT(RLWSC))
            CALL IPSCOL(IPLCI)
            CALL IPDRAW(N,X,Y)
            IF(X(1).EQ.X(N).AND.Y(1).EQ.Y(N))THEN
               CALL IPPSTF(3,' cl')
            ENDIF
            CALL IPPSTF(2,' s')
         ENDIF
      ENDIF
   10 CONTINUE
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         IF(N.EQ.2)THEN
            WRITE (CHMAIL,'(I3,4E16.7)') IPL2CO,X(1),X(2),Y(1),Y(2)
            CALL IMWRIT(4)
         ELSE
            WRITE (CHMAIL,'(I3,I5)') IPLCO,N
            CALL IMWRIT(1)
            CALL IMFOUT(N,X)
            CALL IMFOUT(N,Y)
            CALL IMWRIT(5)
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(2,2*N,0,'IPL').NE.0)RETURN
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(IBSLCO,1)
         IF(N.NE.2)THEN
            CALL IZSTCC(IPLCO,INTPTR)
            IQ(LHI+INTPTR)   = IFLPTR
            IQ(LHI+INTPTR+1) = N
            CALL IZINCI(2)
            IADR  = LHF+IFLPTR-1
            IADRN = IADR+N
            DO 20 I=1,N
               Q(IADR+I)  = X(I)
               Q(IADRN+I) = Y(I)
   20       CONTINUE
            CALL IZINCF(2*N)
         ELSE
            CALL IZSTCC(IPL2CO,IFLPTR)
            Q(LHF+IFLPTR)   = X(1)
            Q(LHF+IFLPTR+1) = X(2)
            Q(LHF+IFLPTR+2) = Y(1)
            Q(LHF+IFLPTR+3) = Y(2)
            CALL IZINCF(4)
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZPL3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZPL3(N,X,Y,Z)
*.===========>
*.
*..==========> (O.Couet)
      DIMENSION X(*),Y(*),Z(*)
*.______________________________________
*
      END
+SELF.
+DECK,  IZPM, T=FORT.
* Revision 1.4  1998/05/26 09:19:30  couet
* - For filling patterns 1 to 25 the PS ouput was wrong in some cases. For those
* the pattern we now close the polygon (move to X1 Y1).
* Revision 1.3  1997/01/30 10:49:15  couet
* - Initialisation of NP was missing (in case all the points are outside the
* world coordinates).
* Revision 1.2  1997/01/30 10:04:18  couet
* - Bug fixed in the marker PS drawing: when the markers drawn were too for from
* the world coordinates, unvalid PS coordinates were generated.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZPM(N,X,Y)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. to draw polymarkers .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIATT.
+CDE, HIPOST.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      DIMENSION X(*),Y(*)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      CHARACTER*4 CHTEMP
      CHARACTER TEXMRK(5)*7
      LOGICAL ZFSAV
      PARAMETER (ISTS = 100)
      DATA TEXMRK/'dot','plus','star','circle','cross'/
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIWCPS.
      IF(PFLAG)THEN
         CALL IPZONE
         IF(TFLAG)THEN
            LM=ABS(IMK)
            IF(LM.GE.2 .AND. LM.LE.5) THEN
               IM=NINT(RMKSC*16)
            ELSE
               LM=1
               IM=NINT(RMKSC)
            ENDIF
            CALL IPPSTR(BSLASH//'let'//BSLASH//'higzmarker='//
     +         BSLASH//'higz'//TEXMRK(LM)(:INDEX(TEXMRK(LM),' ')-1)//
     +         BSLASH//'higzmsize=')
            CALL IPIOUT(IM)
            DO 10  I=1,N
               IF(X(I).GE.X1W .AND. X(I).LE.X2W .AND.
     +            Y(I).GE.Y1W .AND. Y(I).LE.Y2W) THEN
                  IXD=IXWCPS(X(I))
                  IYD=IYWCPS(Y(I))
                  CALL IPTLIN('p',IXD,IYD)
               ENDIF
   10       CONTINUE
         ELSE
            CALL IPLWID(INT(RLWSC))
            CALL IPLTYP(1)
            CALL IPSCOL(IPMCI)
            LM = ABS(IMK)
            IF(LM.LE.0) CHTEMP =' m20'
            IF(LM.EQ.1) CHTEMP =' m20'
            IF(LM.EQ.2) CHTEMP =' m2'
            IF(LM.EQ.3) CHTEMP =' m31'
            IF(LM.EQ.4) CHTEMP =' m24'
            IF(LM.EQ.5) CHTEMP =' m5'
            IF(LM.GE.6.AND.LM.LE.19) CHTEMP = ' m20'
            IF(LM.GE.20.AND.LM.LE.31)THEN
               CHTEMP=' m  '
               WRITE (CHTEMP(3:4),'(I2)') LM
            ENDIF
            IF(LM.GE.32) CHTEMP = ' m20'
*
*              Normalized space
*
            ZFSAV  = ZFLAG
            ZFLAG  = .FALSE.
            GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
            INTSAV = INTR
            SVXMAX = RVXMAX
            SVXMIN = RVXMIN
            SWXMAX = RWXMAX
            SWXMIN = RWXMIN
            SVYMAX = RVYMAX
            SVYMIN = RVYMIN
            SWYMAX = RWYMAX
            SWYMIN = RWYMIN
            LOSCLI = .TRUE.
            CALL ISELNT(0)
*
*              Set the PostScript marker size
*
            RMKSIZ = 0.009*RMKSC
            RNSIZ  = 0.
            CALL IGTEXT(0.,0.,'"0 ',RMKSIZ,RNSIZ,'S')
            IMSIZ  = IYWCPS(RNSIZ)-IYWCPS(0.)
            IF(LM.EQ.1)IMSIZ=INT(2.*RMKSC)
            IF(LM.EQ.6.OR.LM.EQ.7)IMSIZ=INT(4.*RMKSC)
            IF(IPSMSC.NE.IMSIZ)THEN
               IPSMSC = IMSIZ
               CALL IPPSTF(3,' /w')
               CALL IPIOUT(IMSIZ)
               CALL IPPSTF(40,
     +                     ' def /w2 {w 2 div} def /w3 {w 3 div} def')
            ENDIF
*
            XV=(((SVXMAX-SVXMIN)*(X(1)-SWXMIN))/(SWXMAX-SWXMIN))+SVXMIN
            YV=(((SVYMAX-SVYMIN)*(Y(1)-SWYMIN))/(SWYMAX-SWYMIN))+SVYMIN
            IXPS = IXWCPS(XV)
            IYPS = IYWCPS(YV)
            NP = 0
            IF (IXPS.GE.0.AND.IYPS.GE.0) THEN
               CALL IPIOUT(IXPS)
               CALL IPIOUT(IYPS)
               IF(N.EQ.1)THEN
                  CALL IPPSTR(CHTEMP)
                  GOTO 40
               ENDIF
               NP = 1
            ENDIF
            DO 20 I=2,N
               XV = (((SVXMAX-SVXMIN)*(X(I)-SWXMIN))/
     +                (SWXMAX-SWXMIN))+SVXMIN
               YV = (((SVYMAX-SVYMIN)*(Y(I)-SWYMIN))/
     +                (SWYMAX-SWYMIN))+SVYMIN
               IXPS = IXWCPS(XV)
               IYPS = IYWCPS(YV)
               IF (IXPS.GE.0.AND.IYPS.GE.0) THEN
                  CALL IPIOUT(IXWCPS(XV))
                  CALL IPIOUT(IYWCPS(YV))
                  NP = NP+1
               ENDIF
               IF(NP.EQ.ISTS.OR.I.EQ.N)THEN
                  IF (NP.GT.0) THEN
                     CALL IPIOUT(NP)
                     CALL IPPSTF(2,' {')
                     CALL IPPSTR(CHTEMP)
                     CALL IPPSTF(3,'} R')
                     NP = 0
                  ENDIF
               ENDIF
   20       CONTINUE
   40       CALL ISELNT(INTSAV)
            LOSCLI = .FALSE.
            ZFLAG  = ZFSAV
            GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         IF(N.EQ.1)THEN
            WRITE (CHMAIL,'(I3,4E16.7)') IPM1CO,X(1),Y(1)
            CALL IMWRIT(4)
         ELSE
            WRITE (CHMAIL,'(I3,I5)') IPMCO,N
            CALL IMWRIT(1)
            CALL IMFOUT(N,X)
            CALL IMFOUT(N,Y)
            CALL IMWRIT(5)
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(2,2*N,0,'IPM').NE.0)RETURN
         CALL IZCFA(IMKCO,1)
         CALL IZCFA(IMKSCO,1)
         CALL IZCFA(IPMCCO,1)
         IF(N.NE.1)THEN
            CALL IZSTCC(IPMCO,INTPTR)
            IQ(LHI+INTPTR)   = IFLPTR
            IQ(LHI+INTPTR+1) = N
            CALL IZINCI(2)
            IADR  = LHF+IFLPTR-1
            IADRN = IADR+N
            DO 50 I=1,N
               Q(IADR+I)  = X(I)
               Q(IADRN+I) = Y(I)
   50       CONTINUE
            CALL IZINCF(2*N)
         ELSE
            CALL IZSTCC(IPM1CO,IFLPTR)
            Q(LHF+IFLPTR)   = X(1)
            Q(LHF+IFLPTR+1) = Y(1)
            CALL IZINCF(2)
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZPM3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZPM3(N,X,Y,Z)
*.===========>
*.
*..==========> (O.Couet)
      DIMENSION X(*),Y(*),Z(*)
*.______________________________________
*
      END
+SELF.
+DECK,  IZPUSH, T=FORT.
* Revision 1.2  1998/12/01 15:48:41  couet
* - Clean up: commented lines of code removed
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA.
      FUNCTION IZPUSH(IIDS,IFDS,ISDS,CHROUT)
*.===========>
*.
*.   This function enlarge the (NT),(I),(F) and (C) bank when there is
*. not enough place to put data into one of this bank .
*.   If IZPUSH .EQ. 0 the pushing is OK if not , there is not enough
*. space in memory .
*.
*. _Input parameters:
*.
*.  INTEGER IIDS : Integer Data Size to put into (I) .
*.  INTEGER IFDS : Floating point Data Size to put into (F) .
*.  INTEGER ISDS : Character Data Size to put into (C) .
*.  CHARACTER CHROUT : Calling routine name (in case of error) .
*.
*. N.B. For the current NT bank the number of new data is always 1.
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
      CHARACTER*(*) CHROUT
*.______________________________________
*
      IZPUSH=0
      IF(.NOT.ZFLAG)RETURN
      IF(LPICT.LE.0)THEN
         CALL IGERR('No current picture',CHROUT)
         RETURN
      ENDIF
*
*              Enlarge the current NT bank
*
      IF(ITBPTR+1.GT.IRNSIZ)THEN
         INPUSH=2+INSIZ-IRNSIZ+ITBPTR-1
         INPUSH=MAX(INPUSH,IQ(LHNT-1)/4)
         NWNEED=IQ(LHNT-1)+IQ(LHNT-2)+INPUSH+25
         CALL MZNEED(IXHIGZ,NWNEED,'G')
         IF(IQUEST(11).LT.0)GOTO 10
         CALL MZPUSH(IXHIGZ,LHNT,0,INPUSH,' ')
         IRNSIZ=IRNSIZ+INPUSH
      ENDIF
*
*              Enlarge the INTEGER bank
*
      IF(INTPTR+IIDS.GT.IRISIZ+1)THEN
         IIPUSH=IIDS+IISIZ-IRISIZ+INTPTR-1
         IIPUSH=MAX(IIPUSH,IQ(LHI-1)/4)
         NWNEED=IQ(LHI-1)+IQ(LHI-2)+IIPUSH+25
         CALL MZNEED(IXHIGZ,NWNEED,'G')
         IF(IQUEST(11).LT.0)GOTO 10
         CALL MZPUSH(IXHIGZ,LHI,0,IIPUSH,' ')
         IRISIZ=IRISIZ+IIPUSH
         IQ(LPICT+5)=IRISIZ
      ENDIF
*
*              Enlarge the REAL bank
*
      IF(IFLPTR+IFDS.GT.IRFSIZ+1)THEN
         IFPUSH=IFDS+IFSIZ-IRFSIZ+IFLPTR-1
         IFPUSH=MAX(IFPUSH,IQ(LHF-1)/4)
         NWNEED=IQ(LHF-1)+IQ(LHF-2)+IFPUSH+25
         CALL MZNEED(IXHIGZ,NWNEED,'G')
         IF(IQUEST(11).LT.0)GOTO 10
         CALL MZPUSH(IXHIGZ,LHF,0,IFPUSH,' ')
         IRFSIZ=IRFSIZ+IFPUSH
         IQ(LPICT+6)=IRFSIZ
      ENDIF
*
*              Enlarge the CHARACTER bank
*
      IF(ISTPTR+ISDS.GT.IRSSIZ+1)THEN
         ISPUSH=ISDS+ISSIZ-IRSSIZ+ISTPTR-1
         ISPUSH=MAX(ISPUSH,IQ(LHC-1)/4)
         NWNEED=IQ(LHC-1)+IQ(LHC-2)+ISPUSH+25
         CALL MZNEED(IXHIGZ,NWNEED,'G')
         IF(IQUEST(11).LT.0)GOTO 10
         CALL MZPUSH(IXHIGZ,LHC,0,ISPUSH,' ')
         IRSSIZ=IRSSIZ+ISPUSH
         IQ(LPICT+7)=IRSSIZ
      ENDIF
      RETURN
*
*             Error. Not enough space left
*
   10 IZPUSH=1
      CALL IGERR('Not enough space in memory',CHROUT)
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+SELF.
+DECK,  IZRPIP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA.
* Bugs corrected IZRPIP=LP only if NCHP=IQ(LPICT+1)
      INTEGER FUNCTION IZRPIP(PNAME)
*.===========>
*.
*.   This routine Retrieves the PIcture Pointer of the picture PNAME .
*.
*. _Input parameters:
*.
*.  CHARACTER PNAME : Picture name .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
      CHARACTER*(*) PNAME
      DIMENSION INAME(5)
*.______________________________________
*
      IZRPIP=0
      IF(LHIGZ.EQ.0)RETURN
      NCHP=LENOCC(PNAME)
      IF(NCHP.GT.20)NCHP=20
      IF(NCHP.LT.1)RETURN
      CALL UCTOH(PNAME,INAME(1),4,NCHP)
      LP=LQ(LHIGZ)
      IF(LP.EQ.0)RETURN
      LCH=LQ(LP-4)
      I=0
*
   10 I=I+1
      IF(I.GT.NBPICT)RETURN
      DO 20 J=1,(NCHP+3)/4
         IF(INAME(J).NE.IQ(LCH+J))THEN
            LP=LQ(LP)
            IF(LP.EQ.0)RETURN
            LCH=LQ(LP-4)
            GOTO 10
         ENDIF
   20 CONTINUE
      IF(NCHP.EQ.IQ(LP+1))THEN
         IZRPIP=LP
         RETURN
      ELSE
         LP=LQ(LP)
         IF(LP.EQ.0)RETURN
         LCH=LQ(LP-4)
         GOTO 10
      ENDIF
*
      END
+SELF.
+DECK,  IZRTOC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

      SUBROUTINE IZRTOC(RVAL,CVAL)
*.===========>
*.
*. Convert character string CVAL into real value RVAL
*.
*..==========>
      PARAMETER (MAXDIG=16)
      CHARACTER*(MAXDIG) CHTMP1,CHTMP2
      CHARACTER*(*) CVAL
*.______________________________________
*
      IF(RVAL.EQ.0)THEN
         CVAL='0.'
         RETURN
      ENDIF
*
      IF(RVAL.GE.0.001.AND.RVAL.LE.10.)THEN
         WRITE (CHTMP1,'(F10.5)') RVAL
      ELSE
         WRITE (CHTMP1,'(G15.5)') RVAL
      ENDIF
*
*              Remove the leading blanks
*
      I1=LENOCC(CHTMP1)
   10 IF(CHTMP1(1:1).EQ.' ')THEN
         CHTMP2=CHTMP1(2:I1)
         CHTMP1=CHTMP2
         I1=I1-1
         GOTO 10
      ENDIF
*
*              Remove the trailing 0
*
      I2=INDEX(CHTMP1,'E')
      IF(I2.NE.0)THEN
   20    IF(CHTMP1(I2-1:I2-1).EQ.'0')THEN
            CHTMP2=CHTMP1(1:I2-2)//CHTMP1(I2:)
            CHTMP1=CHTMP2
            I1=I1-1
         ELSE
            GOTO 40
         ENDIF
         I2=INDEX(CHTMP1,'E')
         GOTO 20
      ELSE
   30    IF(CHTMP1(I1:I1).EQ.'0')THEN
            CHTMP2=CHTMP1(1:I1-1)
            CHTMP1=CHTMP2
            I1=I1-1
            GOTO 30
         ENDIF
      ENDIF
*
*              Add a 0 in front of the '.'
*
   40 IF(CHTMP1(1:1).EQ.'.')THEN
         CHTMP2='0'//CHTMP1
         CHTMP1=CHTMP2
         I1=I1+1
      ENDIF
*
      CVAL=CHTMP1(1:I1)
*
      END
+DECK,  IZSAV, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

      SUBROUTINE IZSAV
*.===========>
*.
*. This saves the attributes environment.
*.
*..==========> (O.Couet)
+CDE, HIATNB.
+CDE, HIATT.
+CDE, HISAVE.
      DIMENSION RATVAL(NBRATT)
      EQUIVALENCE (RATVAL(1),RMKSC)
      DIMENSION IATVAL(NBIATT)
      EQUIVALENCE (IATVAL(1),IPLCI)
*.______________________________________
*
      DO 10 I=1,NBIATT
         ISAVE(I)=IATVAL(I)
 10   CONTINUE
      DO 20 I=1,NBRATT
         RSAVE(I)=RATVAL(I)
 20   CONTINUE
      WNVPSV(1)=RWXMIN
      WNVPSV(2)=RWXMAX
      WNVPSV(3)=RWYMIN
      WNVPSV(4)=RWYMAX
      WNVPSV(5)=RVXMIN
      WNVPSV(6)=RVXMAX
      WNVPSV(7)=RVYMIN
      WNVPSV(8)=RVYMAX
      ISVNT=INTR
*
      END
+DECK,  IZSAVA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

      SUBROUTINE IZSAVA
*.===========>
*.
*. This saves the attributes environment.
*.
*..==========> (O.Couet)
+CDE, HIATNB.
+CDE, HIATT.
+CDE, HISAVA.
      DIMENSION RATVAL(NBRATT)
      EQUIVALENCE (RATVAL(1),RMKSC)
      DIMENSION IATVAL(NBIATT)
      EQUIVALENCE (IATVAL(1),IPLCI)
*.______________________________________
*
      DO 10 I=1,NBIATT
         ISAVA(I)=IATVAL(I)
 10   CONTINUE
      DO 20 I=1,NBRATT
         RSAVA(I)=RATVAL(I)
 20   CONTINUE
*
      END
+DECK,  IZSCAN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZSCAN(LN,IFCODE,IADRS,ISEN,IPOS)
*.===========>
*.
*.   This routine scans the NT bank at the adress LN and returns the
*. position of the graphic function number IFCODE in this bank .
*.
*. _Input parameters:
*.
*.  INTEGER LN : Link of th NT bank to be scanned .
*.  INTEGER IFCODE : Graphic function code .
*.  INTEGER IADRS : Starting adress . if IADRS < 0 IFCODE is not a function code
*.                  but an integer word .
*.  INTEGER ISEN : Sense of scanning . If ISEN < 0 the scanning is reverve .
*.
*. _Output parameters:
*.
*.  INTEGER IPOS : Position, in the NT bank, of the function IFCODE .
*.                 If IPOS equal 0: The function has not be found .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IPOS=0
      IF(IADRS.LT.0)GOTO 30
*
      IF(ISEN.GE.0)THEN
         DO 10 I=IADRS,IQ(LN+4)-1
            IF(IZGCOD(LN,I).NE.IFCODE)GOTO 10
            IPOS=I
            RETURN
  10     CONTINUE
      ELSE
         DO 20 I=IADRS,10,-1
            IF(IZGCOD(LN,I).NE.IFCODE)GOTO 20
            IPOS=I
            RETURN
  20     CONTINUE
      ENDIF
      RETURN
*
  30  IF(ISEN.GE.0)THEN
         DO 40 I=ABS(IADRS),IQ(LN+4)-1
            IF(IQ(LN+I).NE.IFCODE)GOTO 40
            IPOS=I
            RETURN
  40     CONTINUE
      ELSE
         DO 50 I=ABS(IADRS),10,-1
            IF(IQ(LN+I).NE.IFCODE)GOTO 50
            IPOS=I
            RETURN
  50     CONTINUE
      ENDIF
*
      END
+SELF.
+DECK,  IZSCLI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZSCLI(ICLSW)
*.===========>
*.
*.   This routine stores in the current NT bank the state of the clipping
*. indicator .
*.
*. _Input parameters:
*.
*.  INTEGER ICLSW : Clipping indicator .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIPOST.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIATT.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIWCPS.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      IF(LOSCLI.OR..NOT.LOZONE)GOTO 20
      IF(PFLAG.AND..NOT.TFLAG)THEN
         IF(IPSWTY.EQ.-113.AND..NOT.LOBB)GOTO 20
         IF(ICLSW.NE.0)THEN
            IDXNC = IXWCPS(X2W)-IXWCPS(X1W)
            IDYNC = IYWCPS(Y2W)-IYWCPS(Y1W)
            IXNC  = IXWCPS(X1W)
            IYNC  = IYWCPS(Y1W)
            IF(IDXNC .EQ.IPDXC.AND.IDYNC.EQ.IPDYC.AND.
     +         IXNC  .EQ.IPXC .AND.IYNC .EQ.IPYC .AND.
     +         IPCLIP.EQ.ICLSW)GOTO 10
            CALL IPIOUT(IDXNC)
            CALL IPIOUT(IDYNC)
            CALL IPIOUT(IXNC)
            CALL IPIOUT(IYNC)
            CALL IPPSTF(2,' C')
            IPDXC = IDXNC
            IPDYC = IDYNC
            IPXC  = IXNC
            IPYC  = IYNC
         ELSE
            IF(IPCLIP.NE.ICLSW)CALL IPPSTF(3,' NC')
         ENDIF
   10    IPCLIP = ICLSW
      ENDIF
   20 CONTINUE
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,I2)') ICLICO,ICLSW
         CALL IMWRIT(4)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         CALL IZSCAN(LHNT,ICLICO,ITBPTR-1,-1,IPOS)
         IF(IPOS.NE.0)THEN
            IF(IZGADR(LHNT,IPOS).EQ.ICLSW)RETURN
            IF(IPOS.EQ.ITBPTR-1)THEN
               IQ(LHNT+IPOS)=1000000*ICLICO+ICLSW
               RETURN
            ENDIF
         ENDIF
         IF(IZPUSH(0,0,0,'IZSCLI').NE.0)RETURN
         CALL IZSTCC(ICLICO,ICLSW)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZSCOR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZSCOR(IWKID,IC,CR,CG,CB)
*.===========>
*.
*.   This routine stores the color representation in the current picture.
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  INTEGER CI : Color index .
*.  REAL CR : Red .
*.  REAL CG : Green .
*.  REAL CB : Blue .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
*.______________________________________
*
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(2I3,I5,3E16.7)')ICRCO,IWKID,IC,CR,CG,CB
         CALL IMWRIT(4)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(2,3,0,'ISCR').NE.0)RETURN
         CALL IZSTCC(ICRCO,INTPTR)
         IQ(LHI+INTPTR)=IFLPTR
         IQ(LHI+INTPTR+1)=IC
         CALL IZINCI(2)
         Q(LHF+IFLPTR)=CR
         Q(LHF+IFLPTR+1)=CG
         Q(LHF+IFLPTR+2)=CB
         CALL IZINCF(3)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZSCPI, T=FORT.
* Revision 1.2  1998/12/01 15:48:42  couet
* - Clean up: commented lines of code removed
* Revision 1.1.1.1  1996/02/14 13:11:13  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZSCPI(LP)
*.===========>
*.
*.   Sets the picture LP as current picture .
*.
*. _Input parameters:
*.
*.  INTEGER LP : Picture pointer .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATNB.
+CDE, HIFLAT.
+CDE, HIAADR.
      DIMENSION IRFLAT(NBRATT),IIFLAT(NBIATT)
      EQUIVALENCE (IRFLAT(1),KMKSC),(IIFLAT(1),KPLCI)
*.______________________________________
*
      LPICT=LP
      IF(LPICT.LE.0)RETURN
*
      INBNT=IQ(LPICT+8)
      LHNT0=LQ(LPICT-1)
      LHI=LQ(LPICT-2)
      LHF=LQ(LPICT-3)
      LHC=LQ(LPICT-4)
      LN=LHNT0
      LHNT=LHNT0
      LHNTLA=LHNT0
*
*              Sets the normalisation transformation with
*            the highest priority as the current transformation.
*
      DO 10 I=1,INBNT
         LN=LQ(LN)
         IF(LN.EQ.0)GOTO 20
         LHNTLA=LN
         IF(IQ(LN+3).GT.IQ(LHNT+3))LHNT=LN
   10 CONTINUE
*
   20 CONTINUE
      ITBPTR=IQ(LHNT+4)
      INBLEV=IQ(LHNT+5)
      IRNSIZ=IQ(LHNT-1)
*
*              Set the Flags Attributes
*              Initialise the attributes adresses
*
      DO 30 I=1,NBIATT
         IIFLAT(I)=JBIT(IQ(LHNT+6),I)
         IATADR(30+I)=-1
   30 CONTINUE
      DO 40 I=1,NBRATT
         IRFLAT(I)=JBIT(IQ(LHNT+7),I)
         IATADR(I)=-1
   40 CONTINUE
*
*              Set the adress of the default attributes
*
      IIAPTR=IZGADR(LHNT,8)
      IRAPTR=IZGADR(LHNT,9)
*
*              Set pointers and bank size
*
      INTPTR=IQ(LPICT+2)
      IFLPTR=IQ(LPICT+3)
      ISTPTR=IQ(LPICT+4)
      IRISIZ=IQ(LPICT+5)
      IRFSIZ=IQ(LPICT+6)
      IRSSIZ=IQ(LPICT+7)
*
      END
+SELF.
+DECK,  IZSCR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZSCR(PNAME,ICYCLE)
*.===========>
*.
*.   This routine manages the SCRatch of the pictures on RZ files .
*.
*. _Input parameters:
*.
*.  CHARACTER PNAME : Picture name .
*.  INTEGER ICYCLE : Number of version of the picture on the RZ file .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
      CHARACTER*(*) PNAME
      DIMENSION NAME(5)
*.______________________________________
*
      LPSAV=LPICT
      IF(LHIGZ.EQ.0)THEN
         CALL MZBOOK(IXHIGZ,LPICT,LHIGZ,1,'PICT',1,1,5,2,0)
      ENDIF
      NCH=LENOCC(PNAME)
      CALL VBLANK(NAME,5)
      CALL UCTOH(PNAME,NAME,4,NCH)
*
      CALL RZDELK(NAME,ICYCLE,' ')
      CALL RZSAVE
*
      END
+SELF.
+DECK,  IZSELN, T=FORT.
* Revision 1.2  1998/12/01 15:48:42  couet
* - Clean up: commented lines of code removed
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZSELN(NT)
*.===========>
*.
*.   This routine create in the current picture a bank for the
*. normalisation transformation .
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalization transformation number.
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIATNB.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIPOST.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIFLAT.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIAADR.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
      DIMENSION IRFLAT(NBRATT),IIFLAT(NBIATT)
      EQUIVALENCE (IRFLAT(1),KMKSC),(IIFLAT(1),KPLCI)
      LOGICAL LOPSAV
*.______________________________________
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA, IF=PSCRIPT.
+CDE, ICMTOP.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      IF(PFLAG)THEN
         X1W=RWXMIN
         X2W=RWXMAX
         Y1W=RWYMIN
         Y2W=RWYMAX
         IF(LOPRNG)THEN
            X1V=((XVP2-XVP1)/(XVS2-XVS1))*(RVXMIN-XVS1)+XVP1
            X2V=((XVP2-XVP1)/(XVS2-XVS1))*(RVXMAX-XVS1)+XVP1
            Y1V=((YVP2-YVP1)/(YVS2-YVS1))*(RVYMIN-YVS1)+YVP1
            Y2V=((YVP2-YVP1)/(YVS2-YVS1))*(RVYMAX-YVS1)+YVP1
         ELSE
            X1V=RVXMIN
            X2V=RVXMAX
            Y1V=RVYMIN
            Y2V=RVYMAX
         ENDIF
         FX=(X2V-X1V)/(X2W-X1W)
         FY=(Y2V-Y1V)/(Y2W-Y1W)
         IF(IPSWTY.EQ.-113.AND.NT.EQ.1.AND..NOT.LOBB)THEN
            LOPSAV=LOPRT
            IF(TFLAG) THEN
               CALL IPTMAC
            ELSE
               CALL IPPSTR('@%%BoundingBox: ')
               CALL IPIOUT(ICMTOP(X1W))
               CALL IPIOUT(ICMTOP(Y1W))
               CALL IPIOUT(ICMTOP(X2W))
               CALL IPIOUT(ICMTOP(Y2W))
               CALL IPPSTR('@')
            ENDIF
            CALL IPDEF
            LOBB=.TRUE.
            LOPRT=LOPSAV
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,I5)') 200,NT
         CALL IMWRIT(1)
         WRITE (CHMAIL,'(4E16.7)') RWXMIN,RWXMAX,RWYMIN,RWYMAX
         CALL IMWRIT(2)
         WRITE (CHMAIL,'(4E16.7)') RVXMIN,RVXMAX,RVYMIN,RVYMAX
         CALL IMWRIT(3)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         DO 10 I=1,NBIATT
            IATADR(30+I)=-1
   10    CONTINUE
         DO 20 I=1,NBRATT
            IATADR(I)=-1
   20    CONTINUE
*
*              The normalization transformation is the transformation 0
*
         IF(NT.EQ.0)THEN
            LHNT=LHNT0
            IQ(LHNT+3)=IZGHNP(LPICT)+1
            ITBPTR=IQ(LHNT+4)
            INBLEV=IQ(LHNT+5)
            IRNSIZ=IQ(LHNT-1)
            IIAPTR=IZGADR(LHNT,8)
            IRAPTR=IZGADR(LHNT,9)
            IF(NT.NE.INTR)THEN
               DO 30 I=1,NBIATT
                  IIFLAT(I)=JBIT(IQ(LHNT+6),I)
   30          CONTINUE
               DO 40 I=1,NBRATT
                  IRFLAT(I)=JBIT(IQ(LHNT+7),I)
   40          CONTINUE
               CALL IZSENV
            ENDIF
            RETURN
         ENDIF
*
         LN=IZGNTP(NT)
*
*              The normalization transformation NT is not yet in
*              the current IZ picture
*
         IF(LN.EQ.0)THEN
*
* Create the Normalisation Tranformation Bank number NT
*
            CALL MZBOOK(IXHIGZ,LHNTP,LHNTLA,0,'HZNT',0,0,INSIZ,2,0)
            LHNT=LHNTP
            LHNTLA=LHNT
*
* Initialisation of the Normalisation Transformation bank NT
*
            IQ(LHNT+1)=NT
            ITBPTR=10
            IQ(LHNT+3)=IZGHNP(LPICT)+1
            IQ(LHNT+4)=ITBPTR
            IRNSIZ=INSIZ
            IQ(LHNT+5)=0
            INBLEV=IQ(LHNT+5)
            IIAPTR=INTPTR
            IRAPTR=IFLPTR
            IQ(LHNT+8)=1000000*NBIATT+IIAPTR
            IQ(LHNT+9)=1000000*NBRATT+IRAPTR
*
* Store the default attributes in the new NT bank
*
            IF(IZPUSH(NBIATT,NBRATT,0,'ISELNT').NE.0)RETURN
            CALL IZCDA(0)
            CALL IZINCI(NBIATT)
            CALL IZINCF(NBRATT)
*
* Attributes flags initialization
*
            DO 50 I=1,NBRATT
               IRFLAT(I)=0
   50       CONTINUE
            DO 60 I=1,NBIATT
               IIFLAT(I)=0
   60       CONTINUE
*
* Increment the NT bank counter
*
            INBNT=INBNT+1
            IQ(LPICT+8)=INBNT
*
* Store the window and viewport parameters in the REAL bank
*
            IQ(LHNT+2)=IFLPTR
            IF(IZPUSH(0,8,0,'ISELNT').NE.0)RETURN
            Q(LHF+IFLPTR)=RWXMIN
            Q(LHF+IFLPTR+1)=RWXMAX
            Q(LHF+IFLPTR+2)=RWYMIN
            Q(LHF+IFLPTR+3)=RWYMAX
            Q(LHF+IFLPTR+4)=RVXMIN
            Q(LHF+IFLPTR+5)=RVXMAX
            Q(LHF+IFLPTR+6)=RVYMIN
            Q(LHF+IFLPTR+7)=RVYMAX
            CALL IZINCF(8)
            RETURN
         ELSE
*
*              The normalisation transformation bank NT exits in the
*              current picture . The transformation NT becomes the
*              current transformation .
*
            LHNT=LN
            Q(LHF+IQ(LHNT+2))=RWXMIN
            Q(LHF+IQ(LHNT+2)+1)=RWXMAX
            Q(LHF+IQ(LHNT+2)+2)=RWYMIN
            Q(LHF+IQ(LHNT+2)+3)=RWYMAX
            Q(LHF+IQ(LHNT+2)+4)=RVXMIN
            Q(LHF+IQ(LHNT+2)+5)=RVXMAX
            Q(LHF+IQ(LHNT+2)+6)=RVYMIN
            Q(LHF+IQ(LHNT+2)+7)=RVYMAX
            IQ(LHNT+3)=IZGHNP(LPICT)+1
            ITBPTR=IQ(LHNT+4)
            IRNSIZ=IQ(LHNT-1)
            INBLEV=IQ(LHNT+5)
            IIAPTR=IZGADR(LHNT,8)
            IRAPTR=IZGADR(LHNT,9)
            IF(NT.NE.INTR)THEN
*
* Set the Flags Attributes .
*
               DO 70 I=1,NBIATT
                  IIFLAT(I)=JBIT(IQ(LHNT+6),I)
   70          CONTINUE
               DO 80 I=1,NBRATT
                  IRFLAT(I)=JBIT(IQ(LHNT+7),I)
   80          CONTINUE
               CALL IZSENV
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZSENV, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZSENV
*.===========>
*.
*.   This routine copies the graphic environnement in the current picture .
*.
*..==========> (O.Couet)
+CDE, HIATNB.
*.______________________________________
*
*              Real attributes .
*
      DO 10 I=50,50+NBRATT-1
         CALL IZATT(I)
 10   CONTINUE
*
*              Integer attributes .
*
      DO 20 I=80,80+NBIATT-1
         CALL IZATT(I)
 20   CONTINUE
*
      END
+SELF.
+DECK,  IZSET, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

* Test if ISVNT=0
      SUBROUTINE IZSET
*.===========>
*.
*. This restores the attributes environment.
*.
*..==========> (O.Couet)
+CDE, HIATNB.
+CDE, HISAVE.
+CDE, HIATNM.
*.______________________________________
*
      DO 10 I=1,NBIATT
         CALL IGSET(CHIATT(I),FLOAT(ISAVE(I)))
 10   CONTINUE
      DO 20 I=1,NBRATT
         CALL IGSET(CHRATT(I),RSAVE(I))
 20   CONTINUE
      IF(ISVNT.NE.0)THEN
         CALL ISWN(ISVNT,WNVPSV(1),WNVPSV(2),WNVPSV(3),WNVPSV(4))
         CALL ISVP(ISVNT,WNVPSV(5),WNVPSV(6),WNVPSV(7),WNVPSV(8))
      ENDIF
      CALL ISELNT(ISVNT)
*
      END
+DECK,  IZSETA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

      SUBROUTINE IZSETA
*.===========>
*.
*. This restores the attributes environment.
*.
*..==========> (O.Couet)
+CDE, HIATNB.
+CDE, HISAVA.
+CDE, HIATNM.
*.______________________________________
*
      DO 10 I=1,NBIATT
         CALL IGSET(CHIATT(I),FLOAT(ISAVA(I)))
 10   CONTINUE
      DO 20 I=1,NBRATT
         CALL IGSET(CHRATT(I),RSAVA(I))
 20   CONTINUE
*
      END
+DECK,  IZSTCC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZSTCC(ICODE,IADR)
*.===========>
*.
*.   This routine STores the Control Code ICODE and the adress IADR in the
*. current normalisation transformation bank .
*.
*. _Input parameters:
*.
*.  INTEGER ICODE : Control code .
*.  INTEGER IADR : Adress .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IQ(LHNT+ITBPTR)=1000000*ICODE+IADR
      ITBPTR=ITBPTR+1
      IQ(LHNT+4)=ITBPTR
*
      END
+SELF.
+DECK,  IZTABL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZTABL(NX,NY,V,NPARI,PAR,IOPT)
*.===========>
*.
*.   This routine stores in the current picture the necessary data to
*. to draw a table .
*.
*. _Input parameters:
*.
*.  INTEGER NX x NY : Number of points .
*.  REAL V(NX,NY) : Table contain .
*.  INTEGER NPAR : Number of additional parameters .
*.  REAL PAR(NPAR) : additional parameters .
*.  INTEGER IOPT : Option .
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPACK.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
      DIMENSION IOPT(*)
      DIMENSION PAR(*),V(NX,1)
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
      CHARACTER*16 CHTEMP
+SELF, IF=ZEBRA,MAIL.
      REAL IGCELL
*.______________________________________
*
+CDE, HIBIT.
*
      NYY  = MAX(NY,1)
      NPAR = NPARI
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(PAR(9).LT.0..OR.PAR(10).LT.0.)NPAR=NPAR+2
         IF(IPACK.NE.0)LWV=INT(V(1,1))
         IF(IZPUSH(5,NX*NYY+NPAR,0,'IGTABL').NE.0)RETURN
         IF(IPACK.NE.0)V(1,1)=FLOAT(LWV)
         CALL IZCFA(IBOFCO,1)
         CALL IZCFA(IBWDCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(ITMSCO,1)
         CALL IZCFA(IALHCO,1)
         CALL IZCFA(IALDCO,1)
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(ITXFCO,1)
         CALL IZCFA(ICHHCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
         CALL IZCFA(IAWLCO,1)
         CALL IZCFA(IMKCO,1)
         CALL IZCFA(IMKSCO,1)
         CALL IZCFA(IPMCCO,1)
*
         CALL IZSTCC(ITABCO,INTPTR)
         IQ(LHI+INTPTR)  =NX
         IQ(LHI+INTPTR+1)=NY
         IQ(LHI+INTPTR+2)=IFLPTR
         IQ(LHI+INTPTR+3)=NPARI
         DO 10 I=1,30
            IF(IOPT(I).NE.0)CALL SBIT1(IQ(LHI+INTPTR+4),I)
   10    CONTINUE
         CALL IZINCI(5)
         DO 20 I=1,NPARI
            Q(LHF+IFLPTR+I-1)=PAR(I)
   20    CONTINUE
         IF(PAR(9).LT.0.) Q(LHF+IFLPTR+NPARI)=IQUEST(60)
         IF(PAR(10).LT.0.)Q(LHF+IFLPTR+NPARI+1)=IQUEST(61)
         CALL IZINCF(NPAR)
         DO 40 J=1,NYY
            DO 30 I=1,NX
               Q(LHF+IFLPTR+I-1+(J-1)*NX)=IGCELL(NX,NY,V,I,J,1)
   30       CONTINUE
   40    CONTINUE
         CALL IZINCF(NX*NYY)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         IF(IOPT(11).NE.0)THEN
            CALL IGERR('Stacked LEGO not implemented with telnetg'
     +,                'IGTABL')
            RETURN
         ENDIF
         IOP=INDEX(CHOPTM,'H')
         IF(IOP.GT.0)CHOPTM(IOP:IOP)=' '
         IF(PAR(9).LT.0.) PAR(9) =1000.*ABS(PAR(9))+IQUEST(60)
         IF(PAR(10).LT.0.)PAR(10)=1000.*ABS(PAR(10))+IQUEST(61)
         WRITE (CHMAIL,'(I3,A20,3I5)') ITABCO,CHOPTM,NX,NY,NPARI
         CALL IMWRIT(1)
         CALL IMFOUT(NPARI,PAR)
         JJ=0
         CHMAIL=' '
         DO 70 J=1,NYY
            DO 60 I=1,NX
               WRITE (CHTEMP,'(G13.7)')IGCELL(NX,NY,V,I,J,1)
               K=(13*JJ)+1
               CHMAIL(K:K+12)=CHTEMP(1:13)
               JJ=JJ+1
               IF(JJ.EQ.6)THEN
                  JJ=0
                  CALL IMWRIT(2)
               ENDIF
   60       CONTINUE
   70    CONTINUE
         IF(JJ.NE.0)CALL IMWRIT(2)
         CALL IMWRIT(5)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZTEXT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA,MAIL.
      SUBROUTINE IZTEXT(X,Y,KTEXT,SSIZE,ANGLE,IOPT)
*.===========>
*.
*.   This routine stores the IGTEXT data in the current picture .
*.
*. _Input parameters:
*.
*.  REAL X,Y : Coordinates for beginning of text .
*.  CHARACTER KTEXT : Text .
*.  INTEGER SSIZE : Text size .
*.  REAL ANGLE : The rotation angle in degrees .
*.  INTEGER IOPT : Option .
*.
*..==========> (O.Couet)
+CDE, HICODE.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,MAIL.
      CHARACTER*(*) KTEXT
      DIMENSION IOPT(*)
*.______________________________________
*
      NCHP=LENOCC(KTEXT)
      IF(NCHP.LE.0)RETURN
+SELF, IF=ZEBRA,MAIL, IF=ZEBRA.
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(4,4,(NCHP+3)/4,'IGTEXT').NE.0)RETURN
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
*
         CALL IZSTCC(IGTXCO,INTPTR)
         IQ(LHI+INTPTR)=IFLPTR
         IQ(LHI+INTPTR+1)=ISTPTR
         IQ(LHI+INTPTR+2)=NCHP
         DO 10 I=1,3
            IF(IOPT(I).NE.0)CALL SBIT1(IQ(LHI+INTPTR+3),I)
   10    CONTINUE
         CALL IZINCI(4)
         Q(LHF+IFLPTR)=X
         Q(LHF+IFLPTR+1)=Y
         Q(LHF+IFLPTR+2)=SSIZE
         Q(LHF+IFLPTR+3)=ANGLE
         CALL IZINCF(4)
         CALL UCTOH(KTEXT,IQ(LHC+ISTPTR),4,NCHP)
         CALL IZINCS((NCHP+3)/4)
      ENDIF
+SELF, IF=ZEBRA,MAIL, IF=MAIL.
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,4E16.7,A4)') IGTXCO,X,Y,SSIZE,ANGLE,CHOPTM
         CALL IMWRIT(1)
         CHMAIL=' '
         CHMAIL=KTEXT
         CALL IMWRIT(3)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
*
      END
+SELF.
+DECK,  IZTX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      SUBROUTINE IZTX(XX,YY,CHARS)
*.===========>
*.
*.   This routine stores the text data in the current picture .
*.
*. _Input parameters:
*.
*.  REAL XX,YY : Text position in world coordinates .
*.  CHARACTER CHARS : Text string .
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA,MAIL.
+CDE, HICODE.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
+CDE, HIATT.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
+CDE, HIFLAG.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      CHARACTER*(*) CHARS
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      LOGICAL ZSAV,GSAV
      CHARACTER*1 CHOPT
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*.______________________________________
*
      X=XX
      Y=YY
      NCHP=LENOCC(CHARS)
      IF(NCHP.LE.0)RETURN
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=PSCRIPT.
      IF(PFLAG)THEN
         GSAV   = GFLAG
         GFLAG  = .FALSE.
         ZSAV   = ZFLAG
         ZFLAG  = .FALSE.
         GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL IPZONE
         CALL IPSCOL(ITXCI)
         IF((ITXALV.EQ.2).OR.(ITXALV.EQ.1))Y=Y-RCHH
         IF(ITXALV.EQ.3)Y=Y-(RCHH/2.)
   10    IF((IFONT.EQ.0).AND.(IPREC.EQ.2))THEN
            IF(ITXALH.EQ.2)THEN
               CHOPT='C'
            ELSEIF(ITXALH.EQ.3)THEN
               CHOPT='R'
            ELSE
               CHOPT='L'
            ENDIF
            CALL IGTEXT(X,Y,CHARS,RCHH,RANGLE,CHOPT)
         ELSEIF(TFLAG) THEN
            CALL IPTTEX(XX,YY,CHARS)
         ELSE
            CALL IPTEXT(XX,YY,CHARS)
         ENDIF
         GFLAG  = GSAV
         ZFLAG  = ZSAV
         GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=ZEBRA.
*
      IF(ZFLAG)THEN
         IF(LPICT.LT.0)RETURN
         IF(IZPUSH(3,2,(NCHP+3)/4,'ITX').NE.0)RETURN
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(ITXACO,1)
         CALL IZCFA(ICHHCO,1)
         CALL IZCFA(IANGCO,1)
         CALL IZCFA(ITXFCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
*
         CALL IZSTCC(ITXCO,INTPTR)
         IQ(LHI+INTPTR)=IFLPTR
         IQ(LHI+INTPTR+1)=ISTPTR
         IQ(LHI+INTPTR+2)=NCHP
         CALL IZINCI(3)
         Q(LHF+IFLPTR)=X
         Q(LHF+IFLPTR+1)=Y
         CALL IZINCF(2)
         CALL UCTOH(CHARS,IQ(LHC+ISTPTR),4,NCHP)
         CALL IZINCS((NCHP+3)/4)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,2E16.7)') ITXCO,X,Y
         CALL IMWRIT(1)
         CHMAIL=' '
         CHMAIL=CHARS
         CALL IMWRIT(3)
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
*
      END
+SELF.
+DECK,  IZTX3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZTX3(X,Y,Z,VX,VY,VZ,TEXT)
*.===========>
*.
*..==========> (O.Couet)
      DIMENSION VX(2),VY(2),VZ(2)
      CHARACTER*(*) TEXT
*.______________________________________
*
      END
+SELF.
+DECK,  IZWIP, T=FORT.
* Revision 1.2  1998/12/01 15:48:42  couet
* - Clean up: commented lines of code removed
* Revision 1.1.1.1  1996/02/14 13:11:14  mclareni
* Higz

+SELF, IF=ZEBRA.
      SUBROUTINE IZWIP(LP)
*.===========>
*.
*.   This routine supress the empty words of the picture LP .
*.
*. _Input parameters:
*.
*.  INTEGER LP : Picture link .
*.
*..==========> (O.Couet)
+CDE, HIPAW.
*.______________________________________
*
      IF(LP.LE.0)RETURN
      LPSAV=LPICT
      CALL IZSCPI(LP)
*
*              Cleaning of the NT banks
*
      LN=LHNT0
      DO 10 I=1,INBNT
         IF(LN.EQ.0)GOTO 30
         INPUSH=IQ(LN+4)-IQ(LN-1)
         IF(INPUSH.EQ.0)GOTO 20
         CALL MZPUSH(IXHIGZ,LN,0,INPUSH,' ')
         IF(LN.EQ.LHNT)IRNSIZ=IQ(LN-1)
 20      LN=LQ(LN)
 10   CONTINUE
 30   CONTINUE
*
*              Cleaning of the INTEGER bank
*
      IIPUSH=INTPTR-IRISIZ
      IF(IIPUSH.NE.0)THEN
         CALL MZPUSH(IXHIGZ,LHI,0,IIPUSH,' ')
         IRISIZ=IRISIZ+IIPUSH
         IQ(LPICT+5)=IRISIZ
      ENDIF
*
*              Cleaning of the REAL bank
*
      IFPUSH=IFLPTR-IRFSIZ
      IF(IFPUSH.NE.0)THEN
         CALL MZPUSH(IXHIGZ,LHF,0,IFPUSH,' ')
         IRFSIZ=IRFSIZ+IFPUSH
         IQ(LPICT+6)=IRFSIZ
      ENDIF
*
*              Cleaning of the CHARACTER bank
*
      ISPUSH=ISTPTR-IRSSIZ
      IF(ISPUSH.NE.0)THEN
         CALL MZPUSH(IXHIGZ,LHC,0,ISPUSH,' ')
         IRSSIZ=IRSSIZ+ISPUSH
         IQ(LPICT+7)=IRSSIZ
      ENDIF
*
      IF(LPSAV.GT.0)THEN
         CALL IZSCPI(LPSAV)
      ELSE
         LPICT=LPSAV
      ENDIF
*
      END
+SELF.
+PATCH, IPOST.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
SRCS_F=	ipdef.F ipdlin.F ipdraw.F ipend.F ipfon.F ipfout.F \ @@\
	ipinit.F ipiout.F ipjout.F ipltyp.F iplwid.F ipmark.F ipmove.F \ @@\
	ippatt.F ippstr.F iprng.F ipscol.F ipspec.F ipsvrt.F iptext.F \ @@\
	iptlin.F iptmac.F ipttex.F ipzone.F

#ifdef CERNLIB_QMVAOS
SpecialFortranLibObjectRule(iptext,iptext,FortranNoSaveFlags,NullParameter)
#endif

SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  IPDEF, T=FORT.
* Revision 1.3  2000/04/03 14:53:14  couet
* - "newpath" has been added at the beginning of the PS and EPS file to close
*   some graphics path which may have been left opened by the application in
*   which the HIGZ PS or EPS file is included.
* Revision 1.2  1999/07/20 14:09:03  couet
* - New version of the pattern polygon filling. It now uses the Pattern
*   functionality provided by PostScript level 2. This allows to have
*   colored pattern and a better drawing of the pattern.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPDEF
*.===========>
*.
*.  This routine initialise the following PostScript procedures:
*.
*. +------------+------------------+-----------------------------------+
*. | Macro Name | Input parameters |            Explanation            |
*. +------------+------------------+-----------------------------------+
*. |     l      | x y              | Draw a line to the x y position   |
*. +------------+------------------+-----------------------------------+
*. |     m      | x y              | Move to the position x y          |
*. +------------+------------------+-----------------------------------+
*. |     box    | dx dy x y        | Define a box                      |
*. +------------+------------------+-----------------------------------+
*. |     bl     | dx dy x y        | Draw a line box                   |
*. +------------+------------------+-----------------------------------+
*. |     bf     | dx dy x y        | Draw a filled box                 |
*. +------------+------------------+-----------------------------------+
*. |     sw     | text             | Return string width of text       |
*. +------------+------------------+-----------------------------------+
*. |     t      | x y              | Translate                         |
*. +------------+------------------+-----------------------------------+
*. |     r      | angle            | Rotate                            |
*. +------------+------------------+-----------------------------------+
*. |     rl     | i j              | Roll the stack                    |
*. +------------+------------------+-----------------------------------+
*. |     d      | x y              | Draw a relative line to x y       |
*. +------------+------------------+-----------------------------------+
*. |     X      | x                | Draw a relative line to x (y=0)   |
*. +------------+------------------+-----------------------------------+
*. |     Y      | y                | Draw a relative line to y (x=0)   |
*. +------------+------------------+-----------------------------------+
*. |     rm     | x y              | Move relatively to x y            |
*. +------------+------------------+-----------------------------------+
*. |     gr     |                  | Restore the graphic context       |
*. +------------+------------------+-----------------------------------+
*. |     lw     | lwidth           | Set line width to lwidth          |
*. +------------+------------------+-----------------------------------+
*. |     sd     | [] 0             | Set dash line define by []        |
*. +------------+------------------+-----------------------------------+
*. |     s      |                  | Stroke mode                       |
*. +------------+------------------+-----------------------------------+
*. |     c      | r g b            | Set rgb color to r g b            |
*. +------------+------------------+-----------------------------------+
*. |     cl     |                  | Close path                        |
*. +------------+------------------+-----------------------------------+
*. |     f      |                  | Fill the last describe path       |
*. +------------+------------------+-----------------------------------+
*. |     mXX    | x y              | Draw the marker type XX at (x,y)  |
*. +------------+------------------+-----------------------------------+
*. |     Zone   | ix iy            | Define the current zone           |
*. +------------+------------------+-----------------------------------+
*. |     black  |                  | The color is black                |
*. +------------+------------------+-----------------------------------+
*. |     C      | dx dy x y        | Clipping on                       |
*. +------------+------------------+-----------------------------------+
*. |     NC     |                  | Clipping off                      |
*. +------------+------------------+-----------------------------------+
*. |     R      |                  | repeat                            |
*. +------------+------------------+-----------------------------------+
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIPOST.
+CDE, HIFLAG.
      CHARACTER*80 CHPS1,CHPS2
+CDE, HIVERS.
*.______________________________________
*
+CDE, ICMTOP.
      NPAGES=1
*
* Mode is last digit of Postscript Workstation type
*     mode=1,2 for portrait/landscape black and white
*     mode=3 for Encapsulated PostScript File
*     mode=4 for portrait colour
*     mode=5 for lanscape colour
*
      MODE=MOD(ABS(IPSWTY),10)
      IF(MODE.LE.0.OR.MODE.GT.5)GOTO 20
*
* NX (NY) is the total number of windows in x (y)
*
      NX=MOD(ABS(IPSWTY),1000)/100
      NY=MOD(ABS(IPSWTY),100)/10
      IF(NX.LE.0.OR.NY.LE.0)GOTO 20
      IXZ=1
      IYZ=1
*
* IFMT = 0-99 is the European page format (A4,A3 ...)
* IFMT = 100 is the US format  8.5x11.0 inch
* IFMT = 200 is the US format  8.5x14.0 inch
* IFMT = 300 is the US format 11.0x17.0 inch
*
      IFMT=ABS(IPSWTY/1000)
      IF(IFMT.EQ.0)IFMT=4
      IF(IFMT.EQ.99)IFMT=0
      IF(TFLAG)GOTO 10
*
      CHPS1='%%Title: '
      INQUIRE(UNIT=LUNPS,NAME=CHPS2)
      CHPS1(10:)=CHPS2(1:LENOCC(CHPS2))
      ILEN=MIN(LENOCC(CHPS1),60)
      CALL IPPSTR(CHPS1(1:ILEN))
      IF(MODE.NE.3)THEN
         IF(MODE.EQ.1.OR.MODE.EQ.4)CALL IPPSTF(10,' (Portrait')
         IF(MODE.EQ.2.OR.MODE.EQ.5)CALL IPPSTF(11,' (Landscape')
         IF(IFMT.LE.99)THEN
            CALL IPPSTF(2,' A')
            CALL IPIOUT(IFMT)
            CALL IPPSTF(1,')')
         ELSE
            IF(IFMT.EQ.100)CALL IPPSTF(8,' Letter)')
            IF(IFMT.EQ.200)CALL IPPSTF(7,' Legal)')
            IF(IFMT.EQ.300)CALL IPPSTF(8,' Ledger)')
         ENDIF
         CALL IPPSTR('@')
         CALL IPPSTR('%%Pages: (atend)@')
      ELSE
         CALL IPPSTR('@')
      ENDIF
*
      CALL IPPSTF(23,'%%Creator: HIGZ Version')
      CALL IPPSTR(CHVERS)
      CALL IPPSTR('@')
*
      CALL IPPSTF(15,'%%CreationDate:')
      CALL IGDATE(CHPS1)
      CHPS2=' '
      CHPS2(2:)=CHPS1(1:LENOCC(CHPS1))
      CALL IPPSTR(CHPS2)
      CALL IPPSTR('@')
      CALL IPPSTR('%%EndComments@')
      CALL IPPSTR('%%BeginProlog@')
*
      IF(MODE.EQ.3)CALL IPPSTR('80 dict begin@')
*
*              Initialization of PostScript procedures
*
      CALL IPPSTR('/s {stroke} def /l {lineto} def /m {moveto} def /t {t
     +ranslate} def@')
      CALL IPPSTR('/sw {stringwidth} def /r {rotate} def /rl {roll}  def
     + /R {repeat} def@')
      CALL IPPSTR('/d {rlineto} def /rm {rmoveto} def /gr {grestore} def
     + /f {eofill} def@')
      CALL IPPSTR('/c {setrgbcolor} def /lw {setlinewidth} def /sd {setd
     +ash} def@')
      CALL IPPSTR('/cl {closepath} def /sf {scalefont setfont} def /blac
     +k {0 setgray} def@')
      CALL IPPSTR('/box {m dup 0 exch d exch 0 d 0 exch neg d cl} def@')
      CALL IPPSTR('/NC{systemdict begin initclip end}def/C{NC box clip n
     +ewpath}def@')
      CALL IPPSTR('/bl {box s} def /bf {box f} def /Y { 0 exch d} def /X
     + { 0 d} def @')
*
      CALL IPMARK
      CALL IPFON
      CALL IPSPEC
*
*     mode=1 for portrait black/white
*
      IF (MODE.EQ.1) THEN
         RPXMIN = 0.7
         RPYMIN = SQRT(2.)*RPXMIN
         IF (IFMT.EQ.100) THEN
            WIDTH  = (8.5*2.54)-2.*RPXMIN
            HEIGTH = (11.*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.200) THEN
            WIDTH  = (8.5*2.54)-2.*RPXMIN
            HEIGTH = (14.*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.300) THEN
            WIDTH  = (11.*2.54)-2.*RPXMIN
            HEIGTH = (17.*2.54)-2.*RPYMIN
         ELSE
            WIDTH  = 21.0-2.*RPXMIN
            HEIGTH = 29.7-2.*RPYMIN
         ENDIF
      ENDIF
*
*     mode=2 for landscape black/white
*
      IF (MODE.EQ.2) THEN
         RPYMIN = 0.7
         RPXMIN = SQRT(2.)*RPYMIN
         IF (IFMT.EQ.100) THEN
            WIDTH  = (11.*2.54)-2.*RPXMIN
            HEIGTH = (8.5*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.200) THEN
            WIDTH  = (14.*2.54)-2.*RPXMIN
            HEIGTH = (8.5*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.300) THEN
            WIDTH  = (17.*2.54)-2.*RPXMIN
            HEIGTH = (11.*2.54)-2.*RPYMIN
         ELSE
            WIDTH  = 29.7-2.*RPXMIN
            HEIGTH = 21-2.*RPYMIN
         ENDIF
      ENDIF
*
*     mode=3 encapsulated PostScript
*
   10 IF (MODE.EQ.3) THEN
         WIDTH  = X2W
         HEIGTH = Y2W
         IFMT   = 4
         NX     = 1
         NY     = 1
      ENDIF
*
*     mode=4 for portrait colour
*
      IF (MODE.EQ.4) THEN
         RPXMIN = 0.7
         RPYMIN = 3.4
         IF (IFMT.EQ.100) THEN
            WIDTH  = (8.5*2.54)-2.*RPXMIN
            HEIGTH = (11.*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.200) THEN
            WIDTH  = (8.5*2.54)-2.*RPXMIN
            HEIGTH = (14.*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.300) THEN
            WIDTH  = (11.*2.54)-2.*RPXMIN
            HEIGTH = (17.*2.54)-2.*RPYMIN
         ELSE
            WIDTH  = (21.0-2*RPXMIN)
            HEIGTH = (29.7-2.*RPYMIN)
         ENDIF
      ENDIF
*
*     mode=5 for lanscape colour
*
      IF (MODE.EQ.5) THEN
         RPXMIN = 3.4
         RPYMIN = 0.7
         IF (IFMT.EQ.100) THEN
            WIDTH  = (11.*2.54)-2.*RPXMIN
            HEIGTH = (8.5*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.200) THEN
            WIDTH  = (14.*2.54)-2.*RPXMIN
            HEIGTH = (8.5*2.54)-2.*RPYMIN
         ELSEIF (IFMT.EQ.300) THEN
            WIDTH  = (17.*2.54)-2.*RPXMIN
            HEIGTH = (11.*2.54)-2.*RPYMIN
         ELSE
            WIDTH  = (29.7-2*RPXMIN)
            HEIGTH = (21-2.*RPYMIN)
         ENDIF
      ENDIF
*
      IF (IFMT.LT.100) THEN
         VALUE = 21.*SQRT(2.)**(4-IFMT)
      ELSEIF (IFMT.EQ.100) THEN
         VALUE = 8.5*2.54
      ELSEIF (IFMT.EQ.200) THEN
         VALUE=8.5*2.54
      ELSEIF (IFMT.EQ.300) THEN
         VALUE = 11.*2.54
      ENDIF
*
      IF (IFMT.GE.100) IFMT = 4
*
* Compute size (in points) of the window for each picture = f(NX,NY)
*
      IPSI         = IGIWIN(IPSWID)
      XWKSIZ(IPSI) = WIDTH/FLOAT(NX)*SQRT(2.)**(4-IFMT)
      YWKSIZ(IPSI) = HEIGTH/FLOAT(NY)*SQRT(2.)**(4-IFMT)
      WKMAX(IPSI)  = FLOAT(MAX(ICMTOP(XWKSIZ(IPSI))
     +,                    ICMTOP(YWKSIZ(IPSI))))
      NPX          = 4*ICMTOP(XWKSIZ(IPSI))
      NPY          = 4*ICMTOP(YWKSIZ(IPSI))
*
      IF (TFLAG) RETURN
*
* Procedure Zone
*
      IF (MODE.NE.3) THEN
         CALL IPPSTF(33,'/Zone {/iy exch def /ix exch def ')
         CALL IPPSTF(10,' ix 1 sub ')
         CALL IPIOUT(NPX)
         CALL IPPSTF(5,' mul ')
         CALL IPFOUT(FLOAT(NY))
         CALL IPPSTF(8,' iy sub ')
         CALL IPIOUT(NPY)
         CALL IPPSTR(' mul t} def@')
      ENDIF
*
      CALL IPPSTR('%%EndProlog@')
*
      CALL IPPSTF(8,'newpath ')
      CALL IPSVRT(1)
      IF (MODE.EQ.1.OR.MODE.EQ.4) THEN
         CALL IPIOUT(ICMTOP(RPXMIN))
         CALL IPIOUT(ICMTOP(RPYMIN))
         CALL IPPSTF(2,' t')
      ENDIF
      IF (MODE.EQ.2.OR.MODE.EQ.5) THEN
         CALL IPPSTF(7,' 90 r 0')
         CALL IPIOUT(ICMTOP(-VALUE))
         CALL IPPSTF(3,' t ')
         CALL IPIOUT(ICMTOP(RPXMIN))
         CALL IPIOUT(ICMTOP(RPYMIN))
         CALL IPPSTF(2,' t')
      ENDIF
*
      CALL IPPSTF(15,' .25 .25 scale ')
      IF (MODE.NE.3) CALL IPSVRT(1)
*
      NBSAV0 = NBSAVE
      IF (MODE.NE.3) CALL IPPSTR('%%Page: number 1@')
*
      RETURN
*
   20 CALL IGERR('Invalid PostScript file type','IPDEF')
      PFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IPDLIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPDLIN(NN,IX,IY)
      DIMENSION IX(*),IY(*)
*.===========>
*.
*.   Write the drawing command to the LaTeX metafile
*.   after removing intermediate points lying on a straight line.
*.
*..==========> (A.Nathaniel)
+CDE, HIFLAG.

      IF(NN.EQ.0) RETURN

   10 CONTINUE
      DO 30 I=2,NN
         IDX1=IX(I-1)
         IDY1=IY(I-1)
         IDX2=IX(I)
         IDY2=IY(I)
         IF(SIGN(1,IDX1).EQ.SIGN(1,IDX2).AND.SIGN(1,IDY1).EQ.
     +      SIGN(1,IDY2).AND.IDX1*IDY2.EQ.IDX2*IDY1)THEN
            IX(I-1)=IDX1+IDX2
            IY(I-1)=IDY1+IDY2
            NN=NN-1
            DO 20 J=I,NN
               IX(J)=IX(J+1)
               IY(J)=IY(J+1)
   20       CONTINUE
            GOTO 10
         ENDIF
   30 CONTINUE
      DO 40 I=1,NN
         IF(IX(I).EQ.0) THEN
            IF(IY(I).GT.0) THEN
               CALL IPTLIN('U',IY(I),0)
            ELSE
               CALL IPTLIN('D',-IY(I),0)
            ENDIF
         ELSEIF(IY(I).EQ.0) THEN
            IF(IX(I).GT.0) THEN
               CALL IPTLIN('h',IX(I),0)
            ELSE
               CALL IPTLIN('r',-IX(I),0)
            ENDIF
         ELSE
            CALL IPTLIN('s',IX(I),IY(I))
         ENDIF
   40 CONTINUE
      NN=0
      END
+DECK,  IPDPAT, T=FORT.
* Revision 1.2  1999/07/21 15:48:24  couet
* - Improvements in PS Patterns drawing
* Revision 1.1  1999/07/20 14:09:04  couet
* - New version of the pattern polygon filling. It now uses the Pattern
*   functionality provided by PostScript level 2. This allows to have
*   colored pattern and a better drawing of the pattern.

      SUBROUTINE IPDPAT(IPAT,ICOL)
*.===========>
*.
*. Define the pattern IPAT in the current PS file. IPAT can varies from 1 to 25.
*. Together with the pattern, the color (ICOL) in which the pattern has to be
*. drawn is also required.
*. A pattern is defined in the current PS file only the first time it is used.
*. Some level 2 Postscript functions are used, so on level 1 printers, patterns
*. will not work. This is not a big problem because, as we said, patterns are
*. define only if they are used, so if they are not used a PS level 1 file will
*. not be poluted by level 2 features, and in any case the old patterns (defined
*. by the routine IPPATT) used a lot of memory which made them almost unusable
*. on old level 1 printers. Finally we should say that level 1 devices are
*. becoming very rare. The official PostScript is now level 3 !
*.
*..==========> (O.Couet)
+CDE, HILUT.
+CDE, HIPOST.
      CHARACTER*28, CDEF
      CHARACTER*4, CPAT
*.______________________________________
*
      CPAT = ' P  '
      WRITE (CPAT(3:4),'(I2.2)') IPAT
*
* IPATD is used as a set of bits. If JBIT(IPATD,IPAT).NE.0 the
* pattern number IPAT as already be defined is this file and it
* is not necessary to redefine it. IPATD is set to zero in IPINIT.
* The bit number 26 allows to know if the macro "cs" has already
* been defined in the current file (see label 200).
*
      IF (JBIT(IPATD,IPAT).NE.0) GOTO 200
*
* Define the Patterns.
*
      CALL IPPSTR(' << /PatternType 1 /PaintType 2 /TilingType 1')
*
      GOTO (  1,  2,  3,  4,  5,  6,  7,  8,  9, 10
     +,      11, 12, 13, 14, 15, 16, 17, 18, 19, 20
     +,      21, 22, 23, 24, 25), IPAT
*
  1   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 98 /YStep 4')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' [1] 0 sd 2 4 m 99 4 l s 1 3 m 98 3 l s')
      CALL IPPSTR(' 2 2 m 99 2 l s 1 1 m 98 1 l s')
      CALL IPPSTR(' gr end } >> [ 4.0 0 0 4.0 0 0 ]')
      GOTO 100
*
  2   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 96 /YStep 4')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' [1 3] 0 sd 2 4 m 98 4 l s 0 3 m 96 3 l s')
      CALL IPPSTR(' 2 2 m 98 2 l s 0 1 m 96 1 l s')
      CALL IPPSTR(' gr end } >> [ 3.0 0 0 3.0 0 0 ]')
      GOTO 100
*
  3   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 96 /YStep 16')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' [1 3] 0 sd 2 13 m 98 13 l s 0 9 m 96 9 l s')
      CALL IPPSTR(' 2 5 m 98 5 l s 0 1 m 96 1 l s')
      CALL IPPSTR(' gr end } >> [ 2.0 0 0 2.0 0 0 ]')
      GOTO 100
*
  4   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 0 m 100 100 l s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
  5   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 100 m 100 0 l s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
  6   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 50 0 m 50 100 l s')
      CALL IPPSTR(' gr end } >> [ 0.12 0 0 0.12 0 0 ]')
      GOTO 100
*
  7   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 50 m 100 50 l s')
      CALL IPPSTR(' gr end } >> [ 0.12 0 0 0.12 0 0 ]')
      GOTO 100
*
  8   CALL IPPSTR(' /BBox [ 0 0 101 101 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 0 m 0 30 l 30 0 l f 0 70 m 0 100 l 30 100 l f')
      CALL IPPSTR(' 70 100 m 100 100 l 100 70 l f 70 0 m 100 0 l')
      CALL IPPSTR(' 100 30 l f 50 20 m 20 50 l 50 80 l 80 50 l f')
      CALL IPPSTR(' 50 80 m 30 100 l s 20 50 m 0 30 l s 50 20 m')
      CALL IPPSTR(' 70 0 l s 80 50 m 100 70 l s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
  9   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 50 m 50 50 50 180 360 arc')
      CALL IPPSTR(' 0 50 m 0 100 50 270 360 arc')
      CALL IPPSTR(' 50 100 m 100 100 50 180 270 arc s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
 10   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 50 m 100 50 l 1 1 m 100 1 l')
      CALL IPPSTR(' 0 0 m 0 50 l 100 0 m 100 50 l')
      CALL IPPSTR(' 50 50 m 50 100 l s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
 11   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 0 m 0 20 l 50 0 m 50 20 l')
      CALL IPPSTR(' 100 0 m 100 20 l 0 80 m 0 100 l')
      CALL IPPSTR(' 50 80 m 50 100 l 100 80 m 100 100 l')
      CALL IPPSTR(' 25 30 m 25 70 l 75 30 m 75 70 l')
      CALL IPPSTR(' 0 100 m 20 85 l 50 100 m 30 85 l')
      CALL IPPSTR(' 50 100 m 70 85 l 100 100 m 80 85 l')
      CALL IPPSTR(' 0 0 m 20 15 l 50 0 m 30 15 l')
      CALL IPPSTR(' 50 0 m 70 15 l 100 0 m 80 15 l')
      CALL IPPSTR(' 5 35 m 45 65 l 5 65 m 45 35 l')
      CALL IPPSTR(' 55 35 m 95 65 l 55 65 m 95 35 l s')
      CALL IPPSTR(' gr end } >> [ 0.5 0 0 0.5 0 0 ]')
      GOTO 100
*
 12   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 80 m 0 100 20 270 360 arc')
      CALL IPPSTR(' 30 100 m 50 100 20 180 360 arc')
      CALL IPPSTR(' 80 100 m 100 100 20 180 270 arc')
      CALL IPPSTR(' 20 0 m 0 0 20 0 90 arc')
      CALL IPPSTR(' 70 0 m 50 0 20 0 180 arc')
      CALL IPPSTR(' 100 20 m 100 0 20 90 180 arc')
      CALL IPPSTR(' 45 50 m 25 50 20 0 360 arc')
      CALL IPPSTR(' 95 50 m 75 50 20 0 360 arc s')
      CALL IPPSTR(' gr end } >> [ 0.5 0 0 0.5 0 0 ]')
      GOTO 100
*
 13   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 0 m 100 100 l 0 100 m 100 0 l s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
 14   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 80 /YStep 80')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 20 m 100 20 l 20 0 m 20 100 l')
      CALL IPPSTR(' 0 80 m 100 80 l 80 0 m 80 100 l')
      CALL IPPSTR(' 20 40 m 60 40 l 60 20 m 60 60 l')
      CALL IPPSTR(' 40 40 m 40 80 l 40 60 m 80 60 l s')
      CALL IPPSTR(' gr end } >> [ 0.60 0 0 0.60 0 0 ]')
      GOTO 100
*
 15   CALL IPPSTR(' /BBox [ 0 0 60 60 ]')
      CALL IPPSTR(' /XStep 60 /YStep 60')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 55 m 0 60 5 270 360 arc')
      CALL IPPSTR(' 25 60 m 30 60 5 180 360 arc')
      CALL IPPSTR(' 55 60 m 60 60 5 180 270 arc')
      CALL IPPSTR(' 20 30 m 15 30 5 0 360 arc')
      CALL IPPSTR(' 50 30 m 45 30 5 0 360')
      CALL IPPSTR(' arc 5 0 m 0 0 5 0 90 arc')
      CALL IPPSTR(' 35 0 m 30 0 5 0 180 arc')
      CALL IPPSTR(' 60 5 m 60 0 5 90 180 arc s')
      CALL IPPSTR(' gr end } >> [ 0.41 0 0 0.41 0 0 ]')
      GOTO 100
*
 16   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 50 50 m 25 50 25 0 180 arc s')
      CALL IPPSTR(' 50 50 m 75 50 25 180 360 arc s')
      CALL IPPSTR(' gr end } >> [ 0.4 0 0 0.2 0 0 ]')
      GOTO 100
*
 17   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' [24] 0 setdash 0 0 m 100 100 l s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
 18   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' [24] 0 setdash 0 100 m 100 0 l s')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
 19   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 90 50 m 50 50 40 0 360 arc')
      CALL IPPSTR(' 0 50 m 0 100 50 270 360 arc')
      CALL IPPSTR(' 50 0 m 0 0 50 0 90 arc')
      CALL IPPSTR(' 100 50 m 100 0 50 90 180 arc')
      CALL IPPSTR(' 50 100 m 100 100 50 180 270 arc s')
      CALL IPPSTR(' gr end } >> [ 0.47 0 0 0.47 0 0 ]')
      GOTO 100
*
 20   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 50 50 m 50 75 25 270 450 arc s')
      CALL IPPSTR(' 50 50 m 50 25 25 90  270 arc s')
      CALL IPPSTR(' gr end } >> [ 0.2 0 0 0.4 0 0 ]')
      GOTO 100
*
 21   CALL IPPSTR(' /BBox [ 0 0 101 101 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 1 1 m 25 1 l 25 25 l 50 25 l 50 50 l')
      CALL IPPSTR(' 75 50 l 75 75 l 100 75 l 100 100 l')
      CALL IPPSTR(' 50 1 m 75 1 l 75 25 l 100 25 l 100 50 l')
      CALL IPPSTR(' 0 50 m 25 50 l 25 75 l 50 75 l 50 100 l s')
      CALL IPPSTR(' gr end } >> [ 0.5 0 0 0.5 0 0 ]')
      GOTO 100
*
 22   CALL IPPSTR(' /BBox [ 0 0 101 101 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 1 100 m 25 100 l 25 75 l 50 75 l 50 50 l')
      CALL IPPSTR(' 75 50 l 75 25 l 100 25 l 100 1 l')
      CALL IPPSTR(' 50 100 m 75 100 l 75 75 l 100 75 l 100 50 l')
      CALL IPPSTR(' 0 50 m 25 50 l 25 25 l 50 25 l 50 1 l s')
      CALL IPPSTR(' gr end } >> [ 0.5 0 0 0.5 0 0 ]')
      GOTO 100
*
 23   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' [1 7] 0 sd 0 8 50 { dup dup m 2 mul 0 l s } for')
      CALL IPPSTR(' 0 8 50 { dup dup 2 mul 100 m 50 add exch 50')
      CALL IPPSTR(' add l s } for 100 0 m 100 100 l 50 50 l f')
      CALL IPPSTR(' gr end } >> [ 0.24 0 0 0.24 0 0 ]')
      GOTO 100
*
 24   CALL IPPSTR(' /BBox [ 0 0 100 100 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 100 100 m 100 36 l 88 36 l 88 88 l f')
      CALL IPPSTR(' 100 0 m 100 12 l 56 12 l 50 0 l f')
      CALL IPPSTR(' 0 0 m 48 0 l 48 48 l 50 48 l 56 60 l')
      CALL IPPSTR(' 36 60 l 36 12 l 0 12 l f [1 7] 0 sd')
      CALL IPPSTR(' 61 8 87 { dup dup dup 12 exch m 88 exch l s')
      CALL IPPSTR(' 16 exch 4 sub m 88 exch 4 sub l s } for')
      CALL IPPSTR(' 13 8 35 { dup dup dup 0 exch m 36 exch l s')
      CALL IPPSTR(' 4 exch 4 sub m 36 exch 4 sub l s } for')
      CALL IPPSTR(' 37 8 59 { dup dup dup 12 exch m 36 exch l s')
      CALL IPPSTR(' 16 exch 4 sub m 36 exch 4 sub l s } for')
      CALL IPPSTR(' 13 8 60 { dup dup dup 56 exch m 100 exch l s')
      CALL IPPSTR(' 60 exch 4 sub m 100 exch 4 sub l s } for')
      CALL IPPSTR(' gr end } >> [ 0.5 0 0 0.5 0 0 ]')
      GOTO 100
*
 25   CALL IPPSTR(' /BBox [ 0 0 101 101 ]')
      CALL IPPSTR(' /XStep 100 /YStep 100')
      CALL IPPSTR(' /PaintProc { begin gsave')
      CALL IPPSTR(' 0 0 m 30 30 l 70 30 l 70 70 l 100 100 l 100 0 l')
      CALL IPPSTR(' f 30 30 m 30 70 l 70 70 l f')
      CALL IPPSTR(' gr end } >> [ 0.5 0 0 0.5 0 0 ]')
*
 100  CDEF = ' makepattern /    exch def'
      CDEF(15:17) = CPAT(2:4)
      CALL IPPSTF(26,CDEF(1:26))
      CALL SBIT1(IPATD,IPAT)
*
* Activate the pattern.
*
 200  IF (JBIT(IPATD,26).EQ.0) THEN
         CALL IPPSTR(' /cs {[/Pattern /DeviceRGB] setcolorspace} def')
         CALL IPPSTR(' /FA {f [/DeviceRGB] setcolorspace} def')
         CALL SBIT1(IPATD,26)
      ENDIF
      CALL IPPSTF(3,' cs')
      I = ICOL+1
      IF (I.LT.1) I=1
      IF (I.GT.NBCLUT) I=NBCLUT
      CALL IPFOUT(REDLUT(I))
      CALL IPFOUT(GRNLUT(I))
      CALL IPFOUT(BLULUT(I))
      CALL IPPSTF(4,CPAT)
      CALL IPPSTF(9,' setcolor')
*
      END
+DECK,  IPDRAW, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPDRAW(NN,XW,YW)
*.===========>
*.
*.   Draw a line with  the points  XW,YW. If NN=1
*. this routine do a move only. If NN=0 the XW(1)
*. and YW(1) are  written  in the PostScript file
*. according to the current NT.  If NN>0 the line
*. is clipped as a line, if NN<0 the line is clip-
*. -ped as a fill area.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIPOST.
+CDE, HIQUES.
      DIMENSION XW(*),YW(*)
      DIMENSION XC(2),YC(2)
      PARAMETER(MWORK=50)
      DIMENSION IXWORK(MWORK),IYWORK(MWORK)
      LOGICAL LOMOVE,LOLINE,LOCLIP
*.______________________________________
*
+CDE, HIWCPS.
      IF(NN.LT.0)THEN
         N      = ABS(NN)
         LOLINE = .FALSE.
      ELSE
         N      = NN
         LOLINE = .TRUE.
      ENDIF
*
      IF(N.LE.1)THEN
         IXD=IXWCPS(XW(1))
         IYD=IYWCPS(YW(1))
         IF(TFLAG) THEN
            CALL IPTLIN('m',IXD,IYD)
         ELSE
            CALL IPIOUT(IXD)
            CALL IPIOUT(IYD)
            IF(N.EQ.0)RETURN
            CALL IPPSTF(2,' m')
         ENDIF
         RETURN
      ENDIF
*
      IF (TFLAG) THEN
         NWORK = 0
         LOCLIP = .FALSE.
         LOMOVE = .TRUE.
         DO 10 I=2,N
            XC(1) = XW(I-1)
            XC(2) = XW(I)
            YC(1) = YW(I-1)
            YC(2) = YW(I)
            IF(IGCLIP(XC,YC,X1W,X2W,Y1W,Y2W).NE.0)THEN
               IF(LOMOVE)THEN
                  IF(NN.GT.0)CALL IPDLIN(NWORK,IXWORK,IYWORK)
                  IXD0 = IXWCPS(XC(1))
                  IYD0 = IYWCPS(YC(1))
                  CALL IPTLIN('m',IXD0,IYD0)
                  LOMOVE = .FALSE.
               ENDIF
               IXD = IXWCPS(XC(2))
               IYD = IYWCPS(YC(2))
               NWORK = NWORK+1
               IXWORK(NWORK) = IXD-IXD0
               IYWORK(NWORK) = IYD-IYD0
               IXD0 = IXD
               IYD0 = IYD
               IF(NWORK.EQ.MWORK)CALL IPDLIN(NWORK,IXWORK,IYWORK)
               IF(IQUEST(50).NE.0)THEN
                  IF(LOLINE)LOMOVE = .TRUE.
                  LOCLIP = .TRUE.
               ENDIF
            ELSE
               IF(LOLINE)LOMOVE = .TRUE.
               LOCLIP = .TRUE.
            ENDIF
   10    CONTINUE
         CALL IPDLIN(NWORK,IXWORK,IYWORK)
      ELSE
         IXD0 = IXWCPS(XW(1))
         IYD0 = IYWCPS(YW(1))
         CALL IPIOUT(IXD0)
         CALL IPIOUT(IYD0)
         CALL IPPSTF(2,' m')
         IDX = 0
         IDY = 0
         DO 20 I=2,N
            IXDI = IXWCPS(XW(I))
            IYDI = IYWCPS(YW(I))
            IX   = IXDI-IXD0
            IY   = IYDI-IYD0
            IXD0 = IXDI
            IYD0 = IYDI
            IF(IX.NE.0.AND.IY.NE.0)THEN
               IF(IDX.NE.0)THEN
                  CALL IPMOVE(IDX,0)
                  IDX = 0
               ENDIF
               IF(IDY.NE.0)THEN
                  CALL IPMOVE(0,IDY)
                  IDY = 0
               ENDIF
               CALL IPMOVE(IX,IY)
            ELSEIF(IX.NE.0)THEN
               IF(IDY.NE.0)THEN
                  CALL IPMOVE(0,IDY)
                  IDY = 0
               ENDIF
               IF(IDX.EQ.0)THEN
                  IDX = IX
               ELSEIF(ISIGN(IX,IDX).EQ.IX)THEN
                  IDX = IDX+IX
               ELSE
                  CALL IPMOVE(IDX,0)
                  IDX = IX
               ENDIF
            ELSEIF(IY.NE.0)THEN
               IF(IDX.NE.0)THEN
                  CALL IPMOVE(IDX,0)
                  IDX = 0
               ENDIF
               IF(IDY.EQ.0)THEN
                  IDY = IY
               ELSEIF(ISIGN(IY,IDY).EQ.IY)THEN
                  IDY = IDY+IY
               ELSE
                  CALL IPMOVE(0,IDY)
                  IDY = IY
               ENDIF
            ENDIF
   20    CONTINUE
         IF(IDX.NE.0)CALL IPMOVE(IDX,0)
         IF(IDY.NE.0)CALL IPMOVE(0,IDY)
      ENDIF
*
      END
+DECK,  IPEND, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPEND
+CDE, HIFLAG.
+CDE, HIPOST.
*
      IF(TFLAG) THEN
         CALL IPPSTR(BSLASH//'fi'//BSLASH//'end{picture}@')
         IF(IPTWTY.EQ.-778)CALL IPPSTR(BSLASH//'end{document}@')
      ELSE
         IF(MODE.NE.3)THEN
            CALL IPSVRT(-1)
            IF (LOPRT) THEN
               CALL IPPSTR('showpage@')
               CALL IPSVRT(-1)
            ENDIF
            CALL IPPSTR('%%Trailer@')
            CALL IPPSTR('%%Pages: ')
            CALL IPIOUT(NPAGES)
            CALL IPPSTR('@')
   10       IF (NBSAVE.GT.0) THEN
               CALL IPSVRT(-1)
               GOTO 10
            ENDIF
         ELSE
            CALL IPPSTR('@')
   20       IF (NBSAVE.GT.0) THEN
               CALL IPSVRT(-1)
               GOTO 20
            ENDIF
            CALL IPPSTR('showpage@')
            CALL IPPSTR('end@')
         ENDIF
         CALL IPPSTR('%%EOF@')
      ENDIF
      IF (NBSAVE.NE.0)
     +   CALL IGERR('Invalid number of ''grestore''','IPEND')
      PFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      END
+DECK,  IPFON, T=FORT.
* Revision 1.2  2001/11/12 16:08:06  couet
* - Blanck added after some continuaton character (col 7). When the last
*   character (col 72) in the previous line is blanck it is ignored on
*   Windows. So we add it into the next line.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPFON
*.===========>
*.
*. Font reencoding
*.
*..==========> (O.Couet)
      CALL IPPSTR('@/reencdict 24 dict def')
      CALL IPPSTR(' /ReEncode')
      CALL IPPSTR(' {reencdict begin')
      CALL IPPSTR(' /nco&na exch def')
      CALL IPPSTR('@/nfnam exch def /basefontname exch')
      CALL IPPSTR(' def /basefontdict basefontname')
      CALL IPPSTR(' findfont def')
      CALL IPPSTR('@/newfont basefontdict maxlength dict def')
      CALL IPPSTR(' basefontdict')
      CALL IPPSTR(' {exch dup /FID ne')
      CALL IPPSTR('@{dup /Encoding eq')
      CALL IPPSTR(' {exch dup length array copy')
      CALL IPPSTR(' newfont 3 1 roll put} {exch ')
      CALL IPPSTR('@newfont 3 1 roll put}')
      CALL IPPSTR(' ifelse}')
      CALL IPPSTR(' {pop pop}')
      CALL IPPSTR(' ifelse')
      CALL IPPSTR(' } forall newfont')
      CALL IPPSTR('@/FontName nfnam put')
      CALL IPPSTR(' nco&na aload pop')
      CALL IPPSTR(' nco&na length 2 idiv {newfont')
      CALL IPPSTR('@/Encoding get 3 1 roll put}')
      CALL IPPSTR(' repeat')
      CALL IPPSTR(' nfnam newfont definefont pop')
      CALL IPPSTR(' end } def')
      CALL IPPSTR('@/accvec [')
      CALL IPPSTR(' 176 /agrave     ')
      CALL IPPSTR(' 181 /Agrave     ')
      CALL IPPSTR(' 190 /acircumflex')
      CALL IPPSTR(' 192 /Acircumflex')
      CALL IPPSTR('@201 /adieresis  ')
      CALL IPPSTR(' 204 /Adieresis  ')
      CALL IPPSTR(' 209 /ccedilla   ')
      CALL IPPSTR(' 210 /Ccedilla   ')
      CALL IPPSTR(' 211 /eacute     ')
      CALL IPPSTR('@212 /Eacute     ')
      CALL IPPSTR(' 213 /egrave     ')
      CALL IPPSTR(' 214 /Egrave     ')
      CALL IPPSTR(' 215 /ecircumflex')
      CALL IPPSTR(' 216 /Ecircumflex')
      CALL IPPSTR('@217 /edieresis  ')
      CALL IPPSTR(' 218 /Edieresis  ')
      CALL IPPSTR(' 219 /icircumflex')
      CALL IPPSTR(' 220 /Icircumflex')
      CALL IPPSTR('@221 /idieresis  ')
      CALL IPPSTR(' 222 /Idieresis  ')
      CALL IPPSTR(' 223 /ntilde     ')
      CALL IPPSTR(' 224 /Ntilde     ')
      CALL IPPSTR(' 226 /ocircumflex')
      CALL IPPSTR('@228 /Ocircumflex')
      CALL IPPSTR(' 229 /odieresis  ')
      CALL IPPSTR(' 230 /Odieresis  ')
      CALL IPPSTR(' 231 /ucircumflex')
      CALL IPPSTR(' 236 /Ucircumflex')
      CALL IPPSTR('@237 /udieresis  ')
      CALL IPPSTR(' 238 /Udieresis  ')
      CALL IPPSTR(' 239 /aring      ')
      CALL IPPSTR(' 242 /Aring      ')
      CALL IPPSTR(' 243 /ydieresis  ')
      CALL IPPSTR('@244 /Ydieresis  ')
      CALL IPPSTR(' 246 /aacute     ')
      CALL IPPSTR(' 247 /Aacute     ')
      CALL IPPSTR(' 252 /ugrave     ')
      CALL IPPSTR(' 253 /Ugrave     ')
      CALL IPPSTR('] def')
      CALL IPPSTR('/Times-Roman /Times-Roman accvec ReEncode@')
      CALL IPPSTR('/Times-Italic /Times-Italic accvec ReEncode@')
      CALL IPPSTR('/Times-Bold /Times-Bold accvec ReEncode@')
      CALL IPPSTR('/Times-BoldItalic /Times-BoldItalic accvec ReEncode@'
     +)
      CALL IPPSTR('/Helvetica /Helvetica accvec ReEncode@')
      CALL IPPSTR('/Helvetica-Oblique /Helvetica-Oblique accvec ReEncode
     +@')
      CALL IPPSTR('/Helvetica-Bold /Helvetica-Bold accvec ReEncode@
     +')
      CALL IPPSTR('/Helvetica-BoldOblique /Helvetica-BoldOblique  accvec
     + ReEncode@')
      CALL IPPSTR('/Courier /Courier accvec ReEncode@')
      CALL IPPSTR('/Courier-Oblique /Courier-Oblique accvec ReEncode')
      CALL IPPSTR('/Courier-Bold /Courier-Bold accvec ReEncode@')
      CALL IPPSTR('/Courier-BoldOblique /Courier-BoldOblique accvec ReEn
     +code@')
*
*              Initialization of text PostScript procedures
*
      CALL IPPSTR('/oshow {gsave [] 0 sd true charpath stroke gr} def@')
      CALL IPPSTR('/stwn { /fs exch def /fn exch def /text exch def fn f
     +indfont fs sf')
      CALL IPPSTR(' text sw pop xs add /xs exch def} def@')
      CALL IPPSTR('/stwb { /fs exch def /fn exch def /nbas exch def /tex
     +tf exch def')
      CALL IPPSTR('textf length /tlen exch def nbas tlen gt {/nbas tlen
     + def} if')
      CALL IPPSTR('fn findfont fs sf textf dup length nbas sub nbas geti
     +nterval sw')
      CALL IPPSTR('pop neg xs add /xs exch def} def@')
*
      END
+DECK,  IPFOUT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPFOUT(Z)
*.===========>
*.
*.   Write the real Z in the PostScript file.
*.
*..==========> (O.Couet)
      CHARACTER*20 STR
*.______________________________________
*
      CALL IZRTOC(Z,STR)
      ILEN=LENOCC(STR)
      IF(STR(ILEN:ILEN).EQ.'.')THEN
         IF(ILEN.GT.1)THEN
            ILEN=ILEN-1
         ELSE
            STR='0'
            ILEN=1
         ENDIF
      ENDIF
      CALL IPPSTR(' '//STR(1:ILEN))
*
      END
+DECK,  IPINIT, T=FORT.
* Revision 1.2  1999/07/20 14:09:06  couet
* - New version of the pattern polygon filling. It now uses the Pattern
*   functionality provided by PostScript level 2. This allows to have
*   colored pattern and a better drawing of the pattern.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPINIT(IWID,LUN,IPSWK)
*.===========>
*.
*.  Initialise the PostScript interface
*.
*. _Input parameters:
*.
*. INTEGER IWID : Workstation identifier.
*. INTEGER LUN : Logical Unit Number for the PostScript file.
*. INTEGER IPSWK : Workstation type.
*.
*..==========> (O.Couet)
+CDE, HIPOST.
+CDE, HIFLAG.
*.______________________________________
*
      IPSLT  = 0
      IPSLW  = 0
      IPSCI  = 0
      IPSMSC = -1
      PSRED  = -1.
      PSGRN  = -1.
      PSBLU  = -1.
      LUNPS  = LUN
      IPSWID = IWID
      STRBUF = ' '
      LENBUF = 0
      LENBMX = 80
      IPCLIP = 0
      IPDXC  = 0
      IPDYC  = 0
      IPXC   = 0
      IPYC   = 0
      NBSAVE = 0
      IPATD  = 0
+SELF, IF=-BSLASH.
      BSLASH = '\'
+SELF, IF=BSLASH.
      BSLASH = '\\'
+SELF.
      TFLAG = .FALSE.
      IF(IPSWK.EQ.-777.OR.IPSWK.EQ.-778)TFLAG = .TRUE.
      IF(TFLAG) THEN
         IPSWTY = -113
         IPTWTY = IPSWK
         LOBB   = .FALSE.
         LOCLR  = .FALSE.
         LOZONE = .TRUE.
+SELF, IF=IBM.
         LENBMX = 80
+SELF, IF=-IBM.
         LENBMX = 132
+SELF.
         IF(IPTWTY.EQ.-778)THEN
            CALL IPPSTR(BSLASH//'documentstyle{article}')
            CALL IPPSTR(BSLASH//'pagestyle{empty}')
            CALL IPPSTR(BSLASH//'evensidemargin-.5in')
            CALL IPPSTR(BSLASH//'oddsidemargin-.5in')
            CALL IPPSTR(BSLASH//'topmargin-.5in')
            CALL IPPSTR(BSLASH//'multiply'//BSLASH//'textheight14')
            CALL IPPSTR(BSLASH//'divide'//BSLASH//'textheight10')
            CALL IPPSTR(BSLASH//'multiply'//BSLASH//'textwidth14')
            CALL IPPSTR(BSLASH//'divide'//BSLASH//'textwidth10')
            CALL IPPSTR(BSLASH//'begin{document}@')
         ENDIF
      ELSE
         IPSWTY = IPSWK
         LOCLR  = .TRUE.
         LOZONE = .FALSE.
         IF(IPSWK.EQ.-113)THEN
            LOBB = .FALSE.
            CALL IPPSTR('%!PS-Adobe-2.0 EPSF-2.0@')
         ELSE
            LOBB = .TRUE.
            CALL IPPSTR('%!PS-Adobe-2.0@')
            CALL IPDEF
         ENDIF
      ENDIF
      LOPRT  = .FALSE.
      LOPRNG = .FALSE.
      LOSCLI = .FALSE.
*
      END
+DECK,  IPIOUT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPIOUT(N)
*.===========>
*.
*.   Write the integer N in the PostScript file.
*.
*..==========> (O.Couet)
+CDE, HIPOST.
      PARAMETER (LENSTR=16)
      CHARACTER*(LENSTR)  STR
*.______________________________________
*
      STR = ' '
      WRITE (STR(2:),'(I15)') N
      I = 2
  10  IF (STR(I:I).EQ.' ') THEN
         I = I+1
         GOTO 10
      ENDIF
      ILEN = LENSTR+2-I
      IF ((ILEN+LENBUF).GT.LENBMX) THEN
         WRITE (LUNPS,'(A)',ERR=999) STRBUF(1:LENBUF)
         STRBUF = STR(I-1:)
         LENBUF = ILEN
      ELSE
         STRBUF(LENBUF+1:) = STR(I-1:)
         LENBUF            = LENBUF+ILEN
      ENDIF
*
  999 END
+DECK,  IPJOUT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPJOUT(NX,NY)
*.===========>
*.
*.   Write coordinate pair (nx,ny) in LaTeX file.
*.
*..==========> (A.Nathaniel)
      CHARACTER*20 STR
*.______________________________________
*
      STR='('
      CALL IZITOC(NX,STR(2:))
      L=LENOCC(STR)
      STR(L+1:)=','
      CALL IZITOC(NY,STR(L+2:))
      L=LENOCC(STR)
      STR(L+1:)=')'
      CALL IPPSTR(STR)
*
      END
+DECK,  IPLTYP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz

      SUBROUTINE IPLTYP(LTYPE)
*.===========>
*.
*.   This routine writes the commands for changing the line style
*.   to the Postscript/LaTeX metafile.
*.
*. _Input parameters:
*.
*.  INTEGER LTYPE : line type
*.                  2 = dashed
*.                  3 = dotted
*.                  4 = dash-dotted
*                   else = solid
*.
*..==========> (A.Nathaniel)
+CDE, HIFLAG.
+CDE, HIPOST.
      IF(LTYPE.EQ.IPSLT)RETURN
      IPSLT=LTYPE
      IF(TFLAG) THEN
         IF(LTYPE.EQ.2) THEN
*--- dashed line
            CALL IPPSTR(BSLASH//'let'//BSLASH//'higzline='//
     +         BSLASH//'higzdashed'//BSLASH//'higzoffs=0'//
     +         BSLASH//'higzadash=12'//BSLASH//'higzbdash=24'//
     +         BSLASH//'higzcdash=36'//BSLASH//'higzddash=48')
         ELSEIF(LTYPE.EQ.3) THEN
*--- dotted line
            CALL IPPSTR(BSLASH//'let'//BSLASH//'higzline='//
     +         BSLASH//'higzdashed'//BSLASH//'higzoffs=0'//
     +         BSLASH//'higzadash=1'//BSLASH//'higzbdash=12'//
     +         BSLASH//'higzcdash=13'//BSLASH//'higzddash=24')
         ELSEIF(LTYPE.EQ.4) THEN
*--- dash-dotted line
            CALL IPPSTR(BSLASH//'let'//BSLASH//'higzline='//
     +         BSLASH//'higzdashed'//BSLASH//'higzoffs=0'//
     +         BSLASH//'higzadash=12'//BSLASH//'higzbdash=24'//
     +         BSLASH//'higzcdash=25'//BSLASH//'higzddash=36')
         ELSEIF(LTYPE.NE.0) THEN
*--- solid line
            CALL IPPSTR(BSLASH//'let'//BSLASH//'higzline='//
     +         BSLASH//'higzsolid')
         ENDIF
      ELSE
         IF(LTYPE.EQ.2) THEN
            CALL IPPSTF(13,' [12 12] 0 sd')
         ELSEIF(LTYPE.EQ.3) THEN
            CALL IPPSTF(11,' [4 8] 0 sd')
         ELSEIF(LTYPE.EQ.4) THEN
            CALL IPPSTF(18,' [12 15 4 15] 0 sd')
         ELSE
            CALL IPPSTF(8,' [] 0 sd')
         ENDIF
      ENDIF
      END
+DECK,  IPLWID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPLWID(IWID)
*.===========>
*.
*.  Set the line width
*.
*. _Input parameters:
*.
*. INTEGER IWID : Line width.
*.
*..==========> (O.Couet)
+CDE, HIPOST.
*.______________________________________
*
      IF(IWID.EQ.IPSLW)RETURN
      IPSLW=IWID
      CALL IPIOUT(IPSLW)
      CALL IPPSTF(3,' lw')
*
      END
+DECK,  IPMARK, T=FORT.
* Revision 1.2  2001/11/12 16:08:06  couet
* - Blanck added after some continuaton character (col 7). When the last
*   character (col 72) in the previous line is blanck it is ignored on
*   Windows. So we add it into the next line.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPMARK
*.===========>
*.
*.  This routine define the markers
*.
*.==========> (O.Couet)
      CALL IPPSTR('/mp {newpath /y exch def /x exch def} def@')
      CALL IPPSTR('/side {[w .77 mul w .23 mul] .385 w mul sd w 0 l curr
     +entpoint t -144 r} def@')
      CALL IPPSTR('/mr {mp x y w2 0 360 arc} def /m24 {mr s} def /m20 {m
     +r f} def@')
      CALL IPPSTR('/mb {mp x y w2 add m w2 neg 0 d 0 w neg d w 0 d 0 w d
     + cl} def@')
      CALL IPPSTR('/mt {mp x y w2 add m w2 neg w neg d w 0 d cl} def@')
      CALL IPPSTR('/m21 {mb f} def /m25 {mb s} def /m22 {mt f} def /m26
     + {mt s} def@')
      CALL IPPSTR('/m23 {mp x y w2 sub m w2 w d w neg 0 d cl f} def@')
      CALL IPPSTR('/m27 {mp x y w2 add m w3 neg w2 neg d w3 w2 neg d w3
     + w2 d cl s} def@')
      CALL IPPSTR('/m28 {mp x w2 sub y w2 sub w3 add m w3 0 d ')
      CALL IPPSTR(' 0 w3 neg d w3 0 d 0 w3 d w3 0 d ')
      CALL IPPSTR(' 0 w3 d w3 neg 0 d 0 w3 d w3 neg 0 d')
      CALL IPPSTR(' 0 w3 neg d w3 neg 0 d cl s } def@')
      CALL IPPSTR('/m29 {mp gsave x w2 sub y w2 add w3 sub m currentpoin
     +t t')
      CALL IPPSTR(' 4 {side} repeat cl fill gr} def@')
      CALL IPPSTR('/m30 {mp gsave x w2 sub y w2 add w3 sub m currentpoin
     +t t')
      CALL IPPSTR(' 5 {side} repeat s gr} def@')
      CALL IPPSTR('/m31 {mp x y w2 sub m 0 w d x w2 sub y m w 0 d')
      CALL IPPSTR(' x w2 sub y w2 add m w w neg d x w2 sub y w2')
      CALL IPPSTR(' sub m w w d s} def@')
      CALL IPPSTR('/m2 {mp x y w2 sub m 0 w d x w2 sub y m w 0 d s} def@
     +')
      CALL IPPSTR('/m5 {mp x w2 sub y w2 sub m w w d x w2 sub y w2 add m
     + w w neg d s} def@')
*
      END
+DECK,  IPMOVE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPMOVE(IX,IY)
      IF (IX.NE.0.AND.IY.NE.0) THEN
          CALL IPIOUT(IX)
          CALL IPIOUT(IY)
          CALL IPPSTF(2,' d')
       ELSEIF (IX.NE.0) THEN
          CALL IPIOUT(IX)
          CALL IPPSTF(2,' X')
       ELSEIF (IY.NE.0) THEN
          CALL IPIOUT(IY)
          CALL IPPSTF(2,' Y')
       ENDIF
       END
+DECK,  IPPSTR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPPSTR(STR)
*.===========>
*.
*.  Output the string STR in the buffer STRBUF
*.
*. _Input parameters:
*.
*. CHARACTER STR : String to be buffered.
*.
*..==========> (O.Couet)
+CDE, HIPOST.
      CHARACTER*(*) STR
*.______________________________________
*
      LEN=LENOCC(STR)
      IF(STR(1:1).EQ.'@')THEN
         IF(LENBUF.NE.0)THEN
            WRITE(LUNPS,10000,ERR=999) STRBUF(1:LENBUF)
         ENDIF
         IF(LEN.LT.2)THEN
            STRBUF=' '
         ELSE
            STRBUF=STR(2:LEN)
         ENDIF
         LENBUF=LEN-1
         GOTO 999
      ENDIF
*
      IF(STR(LEN:LEN).EQ.'@')THEN
         IF(LENBUF.NE.0)THEN
            WRITE(LUNPS,10000,ERR=999) STRBUF(1:LENBUF)
         ENDIF
         WRITE(LUNPS,10000,ERR=999) STR(1:LEN-1)
         LENBUF=0
         GOTO 999
      ENDIF
*
      IF((LEN+LENBUF).GT.LENBMX)THEN
         WRITE(LUNPS,10000,ERR=999) STRBUF(1:LENBUF)
         STRBUF=STR(1:LEN)
         LENBUF=LEN
      ELSE
         STRBUF(LENBUF+1:) = STR(1:LEN)
         LENBUF            = LENBUF+LEN
      ENDIF
      GOTO 999
*
*====>        Fast write in the PS file
*
      ENTRY IPPSTF(ILEN,STR)
*
      IF((ILEN+LENBUF).GT.LENBMX)THEN
         WRITE (LUNPS,10000,ERR=999) STRBUF(1:LENBUF)
         STRBUF = STR(1:ILEN)
         LENBUF = ILEN
      ELSE
         STRBUF(LENBUF+1:) = STR(1:ILEN)
         LENBUF            = LENBUF+ILEN
      ENDIF
      GOTO 999
*
*====>        Fast write in the PS file without buffering
*             (Print Full STring)
*
      ENTRY IPPFST(STR)
      LEN=LENOCC(STR)
      WRITE (LUNPS,10000,ERR=999) STR(1:LEN)
*
10000 FORMAT (A)
  999 LOPRT = .TRUE.
      END
+DECK,  IPRNG, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPRNG(XSIZI,YSIZI)
*.==========>
*.
*.  This routine sets the range for the paper in cm.
*.
*. _Input parameters:
*.
*.  REAL XSIZ YSIZ : Paper range.
*.
*..=========>
+CDE, HIATT.
+CDE, HIPOST.
*.______________________________________
*
      XSIZ=XSIZI
      YSIZ=YSIZI
*
      IF(IPSWTY.NE.-113)THEN
         XPS=XWKSIZ(IPSI)
         YPS=YWKSIZ(IPSI)
      ELSE
         XPS=XSIZ
         YPS=YSIZ
      ENDIF
      XPSR=XSIZ
      YPSR=YSIZ
*
      IF(XSIZ.LE.XPS.AND.YSIZ.LT.YPS)THEN
         XYMAX=MAX(XPS,YPS)
         XNCM=XSIZ/XYMAX
         YNCM=YSIZ/XYMAX
         DXWN=((XPS/XYMAX)-XNCM)/2.
         DYWN=((YPS/XYMAX)-YNCM)/2.
      ELSE
         XWKWN=MIN(1.,XPS/YPS)
         YWKWN=MIN(1.,YPS/XPS)
*
         IF (XSIZ.LT.YSIZ) THEN
            XNCM=YWKWN*XSIZ/YSIZ
            YNCM=YWKWN
            DXWN=(XWKWN-XNCM)/2.
            DYWN=0.
            IF(DXWN.LT.0.)THEN
               XNCM=XWKWN
               DXWN=0.
               YNCM=XWKWN*YSIZ/XSIZ
               DYWN=(YWKWN-YNCM)/2.
            ENDIF
         ELSE
            XNCM=XWKWN
            YNCM=XWKWN*YSIZ/XSIZ
            DXWN=0.
            DYWN=(YWKWN-YNCM)/2.
            IF(DYWN.LT.0.)THEN
               YNCM=YWKWN
               DYWN=0.
               XNCM=YWKWN*XSIZ/YSIZ
               DXWN=(XWKWN-XNCM)/2.
            ENDIF
         ENDIF
      ENDIF
      XVP1=DXWN
      XVP2=XNCM+DXWN
      YVP1=DYWN
      YVP2=YNCM+DYWN
      LOPRNG=.TRUE.
*
      END
+DECK,  IPSCOL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPSCOL(ICOL)
*.===========>
*.
*.  Set the current color
*.
*. _Input parameters:
*.
*. INTEGER ICOL : Color Index.
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIPOST.
+CDE, HILUT.
*.______________________________________
*
      IPSCI=ICOL
      IF(IPSCI.LT.0)IPSCI=0
      IF(IPSCI.GT.NBCLUT-1)IPSCI=NBCLUT-1
      I=IPSCI+1
      IF(REDLUT(I).EQ.PSRED.AND.
     +   GRNLUT(I).EQ.PSGRN.AND.
     +   BLULUT(I).EQ.PSBLU)RETURN
      PSRED=REDLUT(I)
      PSGRN=GRNLUT(I)
      PSBLU=BLULUT(I)
      IF(.NOT.TFLAG) THEN
         IF(REDLUT(I).LE.0..AND.
     +      GRNLUT(I).LE.0..AND.
     +      BLULUT(I).LE.0.)THEN
            CALL IPPSTF(6,' black')
         ELSE
            CALL IPFOUT(REDLUT(I))
            CALL IPFOUT(GRNLUT(I))
            CALL IPFOUT(BLULUT(I))
            CALL IPPSTF(2,' c')
         ENDIF
      ENDIF
*
      END
+DECK,  IPSPEC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPSPEC
*.===========>
*.
*. Reencode the Greek (/Symbol) font into the special font (/Special).
*.
*..==========> (O.Couet)
      CALL IPPSTR('@/accspe [')
      CALL IPPSTR(' 65 /plusminus ')
      CALL IPPSTR(' 66 /bar ')
      CALL IPPSTR(' 67 /existential ')
      CALL IPPSTR(' 68 /universal ')
      CALL IPPSTR('@69 /exclam ')
      CALL IPPSTR(' 70 /numbersign')
      CALL IPPSTR(' 71 /greater ')
      CALL IPPSTR(' 72 /question ')
      CALL IPPSTR(' 73 /integral ')
      CALL IPPSTR('@74 /colon ')
      CALL IPPSTR(' 75 /semicolon ')
      CALL IPPSTR(' 76 /less ')
      CALL IPPSTR(' 77 /bracketleft ')
      CALL IPPSTR(' 78 /bracketright')
      CALL IPPSTR('@79 /greaterequal')
      CALL IPPSTR(' 80 /braceleft')
      CALL IPPSTR(' 81 /braceright')
      CALL IPPSTR(' 82 /radical')
      CALL IPPSTR('@83 /spade')
      CALL IPPSTR(' 84 /heart')
      CALL IPPSTR(' 85 /diamond')
      CALL IPPSTR(' 86 /club')
      CALL IPPSTR(' 87 /lessequal')
      CALL IPPSTR('@88 /multiply')
      CALL IPPSTR(' 89 /percent')
      CALL IPPSTR(' 90 /infinity')
      CALL IPPSTR(' 48 /circlemultiply')
      CALL IPPSTR(' 49 /circleplus')
      CALL IPPSTR('@50 /emptyset ')
      CALL IPPSTR(' 51 /lozenge')
      CALL IPPSTR(' 52 /bullet')
      CALL IPPSTR(' 53 /arrowright')
      CALL IPPSTR(' 54 /arrowup')
      CALL IPPSTR('@55 /arrowleft')
      CALL IPPSTR(' 56 /arrowdown')
      CALL IPPSTR(' 57 /arrowboth')
      CALL IPPSTR(' 48 /degree')
      CALL IPPSTR(' 44 /comma')
      CALL IPPSTR(' 43 /plus')
      CALL IPPSTR(' 45 /angle')
      CALL IPPSTR(' 42 /angleleft')
      CALL IPPSTR(' 47 /divide')
      CALL IPPSTR(' 61 /notequal')
      CALL IPPSTR(' 40 /equivalence')
      CALL IPPSTR(' 41 /second')
*
      CALL IPPSTR(' 97 /approxequal')
      CALL IPPSTR(' 98 /congruent')
      CALL IPPSTR(' 99 /perpendicular')
      CALL IPPSTR(' 100 /partialdiff')
      CALL IPPSTR(' 101 /florin')
      CALL IPPSTR(' 102 /intersection')
      CALL IPPSTR(' 103 /union')
      CALL IPPSTR(' 104 /propersuperset')
      CALL IPPSTR(' 105 /reflexsuperset')
      CALL IPPSTR(' 106 /notsubset')
      CALL IPPSTR(' 107 /propersubset')
      CALL IPPSTR(' 108 /reflexsubset')
      CALL IPPSTR(' 109 /element')
      CALL IPPSTR(' 110 /notelement')
      CALL IPPSTR(' 111 /gradient')
      CALL IPPSTR(' 112 /logicaland')
      CALL IPPSTR(' 113 /logicalor')
      CALL IPPSTR(' 114 /arrowdblboth')
      CALL IPPSTR(' 115 /arrowdblleft')
      CALL IPPSTR(' 116 /arrowdblup')
      CALL IPPSTR(' 117 /arrowdblright')
      CALL IPPSTR(' 118 /arrowdbldown')
      CALL IPPSTR(' 119 /ampersand')
      CALL IPPSTR(' 120 /omega1')
      CALL IPPSTR(' 121 /similar')
      CALL IPPSTR(' 122 /aleph')
      CALL IPPSTR(' ] def')
      CALL IPPSTR('/Symbol /Special accspe ReEncode@')
*
      END
+DECK,  IPSVRT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPSVRT(IFLAG)
+CDE, HIPOST.
      IF (IFLAG.EQ.1) THEN
         CALL IPPSTF(7,' gsave ')
         NBSAVE = NBSAVE+1
      ELSE
         CALL IPPSTF(4,' gr ')
         NBSAVE = NBSAVE-1
      ENDIF
      END
+DECK,  IPTEXT, T=FORT.
* Revision 1.4  2001/11/23 16:03:32  couet
* - minor fix ...
* Revision 1.3  1996/03/08 16:53:41  couet
* Comment line added after \ at the end of the line
* Revision 1.2  1996/02/29 16:30:41  cernlib
* This had \\ at the end of some comments, which on osf disturbed the
*   following line-- was indented by a few blanks -- and the label ended
*   up beyond col. 6
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPTEXT(XX,YY,CHARS)
*.===========>
*.
*.    This routine writes the a into a PostScript file
*.         according to the IGTEXT control characters.
*.
*. _Input parameters:
*.
*.  REAL XX,YY : Text position in world coordinates .
*.  CHARACTER CHARS : Text string .
*.
*..==========> (P.Juillot)
+CDE, HIATT.
+CDE, HIPOST.
*
* npiece= max number of pieces of text ( separated by escape characters)
      PARAMETER (NPIECE=50)
      DIMENSION IFNB(NPIECE),IFNS(NPIECE),LEVEL(NPIECE),LBACK(NPIECE)

* maximum length of a (PostScript) string

      CHARACTER*(*) CHARS
      CHARACTER*512 NEWTXT
      CHARACTER*512 CHAR2
      CHARACTER*80 PIECE(NPIECE)

* this common is needed for some routines in CHPACK (KERNLIB M432)
      COMMON /SLATE/ND,NE,NF,NG,DUMMY(36)

      CHARACTER*30 PSFONT(42)
      DIMENSION PSRAP(30)
      CHARACTER*3 PSTMP
      CHARACTER*13 CFLIP
      CHARACTER*3  CFLIPC(13)

      LOGICAL UPPER,LOWER,ESCAPE
      LOGICAL ROMAN,GREEK,SPECIA,ZAPF,NORMAL,SUB,SUPER
      LOGICAL OSHOW

      DATA CFLIP /'["?^]#!~&$<>@'/
      DATA CFLIPC /'133','42','77','136','135','43','41',
     +             '176','46','44','74','76','100'/
      DATA PSRAP /1.031,1.000,1.026,0.932,0.931,0.931,0.930,1.204,1.204,
     +            1.168,1.166,1.007,1.026,0.964,
     +            16*1.0/

      DATA PSFONT /'/Times-Italic','/Times-Bold','/Times-BoldItalic'
     +,'/Helvetica','/Helvetica-Oblique','/Helvetica-Bold'
     +,'/Helvetica-BoldOblique','/Courier','/Courier-Oblique'
     +,'/Courier-Bold','/Courier-BoldOblique','/Symbol','/Times-Roman'
     +,'/ZapfDingbats','/Times-Italic','/Times-Bold','/Times-BoldItalic'
     +,'/Helvetica','/Helvetica-Oblique','/Helvetica-Bold'
     +,'/Helvetica-BoldOblique','/Symbol','/Times-Roman','/ZapfDingbats'
     +,'/Special','/ZapfChancery-MediumItalic','/AvantGarde-Book'
     +,'/AvantGarde-BookOblique','/AvantGarde-Demi'
     +,'/AvantGarde-DemiOblique','/Bookman-Demi','/Bookman-DemiItalic'
     +,'/Bookman-Light','/Bookman-LightItalic','/Palatino-Roman'
     +,'/Palatino-Italic','/Palatino-Bold','/Palatino-BoldItalic'
     +,'/NewCenturySchlbk-Roman','/NewCenturySchlbk-Italic'
     +,'/NewCenturySchlbk-Bold','/NewCenturySchlbk-BoldItalic'/
*.______________________________________
*
+CDE, HIWCPS.
*
      X    = XX
      Y    = YY
      NOLD = MIN(LENOCC(CHARS),512)
*
* Text colour and vertical alignment
*
      CALL IPSCOL(ITXCI)
      IF((ITXALV.EQ.2).OR.(ITXALV.EQ.1))THEN
         Y = Y-RCHH*COS((3.14159/180.)*RANGLE)
         X = X+RCHH*SIN((3.14159/180.)*RANGLE)
      ELSEIF(ITXALV.EQ.3)THEN
         Y = Y-(RCHH/2.)*COS((3.14159/180.)*RANGLE)
         X = X+(RCHH/2.)*SIN((3.14159/180.)*RANGLE)
      ENDIF
*
* Compute the fonts size. Exit if it is 0
*
      NFON = ABS(IFONT)
      IF(NFON.GT.42.OR.NFON.LT.1)NFON = 1
      FONRAP = 75./51.
      IF(NFON.LE.14.AND.NFON.GE.1)FONRAP = FONRAP*PSRAP(NFON)
      IS = IYWCPS(RCHH*FONRAP)-IYWCPS(0.)
      IF(IS.LE.0)GOTO 999
      NP = IPREC
*
* The hollow fonts are set on by the roman font number
* The number of passes define the width of the hollow text
*
      OSHOW = .FALSE.
      IF (NFON.GT.14.AND.NFON.LT.25) THEN
         OSHOW = .TRUE.
         CALL IPIOUT(INPASS)
         CALL IPPSTR(' lw')
      ENDIF
*
* Start a first parsing:
*  - looking for the < and > escape characters,
*  - remove them and build a new string changing
*    upper <=> lower characters
*  - manage the '@' escape character
*  - check if the input string is not too long (J<=505)
*
      ESCAPE = .FALSE.
      UPPER  = .FALSE.
      LOWER  = .FALSE.
      NEWTXT = ' '
      PSTMP  = ' '
      J      = 0
      DO 10 I=1,NOLD
         IF(J.GE.505)GOTO 360
         IF(ESCAPE)THEN
            ESCAPE = .FALSE.
            GOTO 10
         ENDIF
         IF(CHARS(I:I).EQ.'@')THEN
            IFLIP=INDEX(CFLIP,CHARS(I+1:I+1))
            IF(IFLIP.NE.0)THEN
               J = J+1
               NEWTXT(J:J) = BSLASH
               J = J+1
               NEWTXT(J:) = CFLIPC(IFLIP)
               J = LENOCC(NEWTXT)
               ESCAPE = .TRUE.
               GOTO 10
            ENDIF
         ENDIF
         IF (CHARS(I:I).EQ.'<') THEN
            LOWER = .TRUE.
            UPPER = .FALSE.
         ELSEIF(CHARS(I:I).EQ.'>') THEN
            LOWER = .FALSE.
            UPPER = .TRUE.
         ELSE
            PSTMP(1:1)=CHARS(I:I)
            IF(LOWER)CALL CUTOL(PSTMP(1:1))
            IF(UPPER)CALL CLTOU(PSTMP(1:1))
            J = J+1
            NEWTXT(J:J) = PSTMP(1:1)
         ENDIF
   10 CONTINUE
      NCHP = LENOCC(NEWTXT)
*
* Now a second parsing to search for the PostScript
* characters (following a \) and ( , ), \
*
      CHAR2 = ' '
* loop on NCHP old characters and look for \
*
      IOLD=0
      INEW=0
   20 IOLD=IOLD+1
      IF(IOLD.EQ.NCHP+1) GO TO 70
*
*              1. find an antislash
*
      IF (NEWTXT(IOLD:IOLD).EQ.BSLASH) THEN
* if this \ is not the last character of the string, then
* study the character following this \
*
         IF(IOLD.EQ.NCHP) GO TO 60
*
*  1.1  the character following this \ is also an \
*
         IF (NEWTXT(IOLD+1:IOLD+1).EQ.BSLASH) THEN
*       copy both \\,
            INEW=INEW+1
            CHAR2(INEW:INEW)=BSLASH
            INEW=INEW+1
            CHAR2(INEW:INEW)=BSLASH
*       and go to the next character
            IOLD=IOLD+1
            GO TO 20
         ENDIF
*
*  1.2  the character following this \ is a parenthesis: ( or )
*
         IF(NEWTXT(IOLD+1:IOLD+1).EQ.'(' .OR.
     +       NEWTXT(IOLD+1:IOLD+1).EQ.')') THEN
*       copy the \ and the parenthesis,
            INEW=INEW+1
            CHAR2(INEW:INEW)=BSLASH
            INEW=INEW+1
            CHAR2(INEW:INEW)=NEWTXT(IOLD+1:IOLD+1)
*       and go to the following character
            IOLD=IOLD+1
            GO TO 20
         ENDIF
*
*  1.3  the character following this \ is also a special
*       PostScript character:
*      \n    linefeed (newline)
*      \r    carriage return
*      \t    horizontal tab
*      \f    form feed
*
         IF(NEWTXT(IOLD+1:IOLD+1).EQ.'n' .OR.
     +      NEWTXT(IOLD+1:IOLD+1).EQ.'r' .OR.
     +      NEWTXT(IOLD+1:IOLD+1).EQ.'t' .OR.
     +      NEWTXT(IOLD+1:IOLD+1).EQ.'f') THEN
*       copy nothing and go to the following character
            IOLD=IOLD+1
            GO TO 20
         ENDIF
*
*  1.4  the character following this \ is the special
*       PostScript character:
*      \b    back space
*
         IF(NEWTXT(IOLD+1:IOLD+1).EQ.'b') THEN
*       replace the sequence \b by the & escape character
            INEW=INEW+1
            CHAR2(INEW:INEW)='&'
*       and forget the b
            IOLD=IOLD+1
            GO TO 20
         ENDIF
*
*  1.5  the character following this \ is a digit between 0 and 7,
*  which means that the input text contains a string like \123 where
*  123 is an octal number the accepted ranges are 40-176 and 241-376
*  ( all others are ASCII control characters )
*
*    =>   first, study the range 40-77 (case of 2 digits after the \)
*
         PSTMP=' '
         DO 40 K=40,77
            WRITE(PSTMP(1:2),'(I2.2)') K
            IADD = 0
            IF(PSTMP(1:2).EQ.NEWTXT(IOLD+1:IOLD+2))GOTO 30
            IF(NEWTXT(IOLD+1:IOLD+1).EQ.'0'.AND.
     +         PSTMP(1:2).EQ.NEWTXT(IOLD+2:IOLD+3))THEN
               IADD = 1
               GOTO 30
            ENDIF
            GOTO 40
*   OK:  copy the \ and the 2 following digits and add a 0
   30       CHAR2(INEW+1:INEW+1) = BSLASH
            CHAR2(INEW+2:INEW+2) = '0'
            CHAR2(INEW+3:INEW+4) = NEWTXT(IOLD+1+IADD:IOLD+2+IADD)
            INEW = INEW+4
*       and go parsing the next following old character
            IOLD=IOLD+2+IADD
            GO TO 20
   40    CONTINUE
*
*    =>   then, study the ranges  100-177 and 241-377
*           (case of 3 digits after the \)
         PSTMP=' '
         DO 50 K=100,377
            IF(K.GE.178 .AND. K.LE.240) GO TO 50
            WRITE(PSTMP(1:3),'(I3.3)') K
            IF(PSTMP(1:3).EQ.NEWTXT(IOLD+1:IOLD+3))THEN
*   OK:  copy the \ and the 3 following digits
               CHAR2(INEW+1:) = NEWTXT(IOLD:IOLD+3)
               INEW = INEW+4
*       and go parsing the next following old character
               IOLD = IOLD+3
               GO TO 20
            ENDIF
   50    CONTINUE
*
*  1.6 this \ is followed by nothing understandable in PostScript,
*   it is an "isolated \" which will appear as \\ (leave one space for cpp)
*       copy two \\ (leave one space for cpp)
*
   60    INEW=INEW+1
         CHAR2(INEW:INEW)=BSLASH
         INEW=INEW+1
         CHAR2(INEW:INEW)=BSLASH
         GO TO 20
*
* 2. find ( or ) not preceeded by an \ : include one \
*
      ELSEIF(NEWTXT(IOLD:IOLD).EQ.'('
     +  .OR. NEWTXT(IOLD:IOLD).EQ.')') THEN
*   2.1 if this (,) is not preceeded by a \, include one \
*
*         IF(I.EQ.1 .OR. NEWTXT(IOLD-1:IOLD-1).NE.BSLASH) THEN
         IF(IOLD.EQ.1 .OR. NEWTXT(IOLD-1:IOLD-1).NE.BSLASH) THEN
            INEW=INEW+1
            CHAR2(INEW:INEW)=BSLASH
            INEW=INEW+1
            CHAR2(INEW:INEW)=NEWTXT(IOLD:IOLD)
            GO TO 20
         ENDIF
         GO TO 20
* 3. treat normal text
      ELSE
         INEW=INEW+1
         CHAR2(INEW:INEW)=NEWTXT(IOLD:IOLD)
      ENDIF
      GO TO 20
   70 CONTINUE

      NCHP=LENOCC(CHAR2)

** now a third parsing to cut the text into pieces
*** for each piece of text, I define
*      a. the string content = PIECE(I)
*      b. the font # = IFNB(I)= NFON: roman, 12: greek ,
*                         14: ZapfdingBats
*      c. the font size = IFNS(I)
*      d. a level flag = LEVEL(I) = 1: normal
*                                   2: superscript
*                                   3: subscript
*      e. a "backward" flag = LBACK(I) = 0: normal text ,
*                                      = 1: superscript and
*                                           subscript start at
*                                           the same x
*                                      = -n: for n backspaces
*
      DO 80 I=1,50
         PIECE(I)=' '
         IFNS(I)=0
         IFNB(I)=0
         LEVEL(I)=0
         LBACK(I)=0
   80 CONTINUE

      ROMAN=.TRUE.
      GREEK=.FALSE.
      SPECIA=.FALSE.
      ZAPF=.FALSE.
      NORMAL=.TRUE.
      SUPER=.FALSE.
      SUB=.FALSE.

*NT=number for pieces  of text
      NT=0
      I=0
   90 I=I+1
      IF(I.GT.NCHP) GO TO 140
      NBAS=0
*
*  read character number I and check if it is an escape character
*    using KERNLIB M432 with NG in /SLATE/ as return code
*
      JX=ICFMUL(CFLIP,CHAR2,I,I)
      IF(NG.GT.0) THEN
*
* find [ : go to greek
*
         IF(CHAR2(I:I).EQ.CFLIP(1:1)) THEN
            GREEK=.TRUE.
*
* find " : go to special
*
         ELSE IF(CHAR2(I:I).EQ.CFLIP(2:2)) THEN
            SPECIA=.TRUE.
* find ? : go to subscript
         ELSE IF(CHAR2(I:I).EQ.CFLIP(3:3)) THEN
            SUB=.TRUE.
            SUPER=.FALSE.
* find ^ : go to superscript
         ELSE IF(CHAR2(I:I).EQ.CFLIP(4:4)) THEN
            SUPER=.TRUE.
            SUB=.FALSE.
* find ] : end of greek or of Zapf=> go to roman
         ELSE IF(CHAR2(I:I).EQ.CFLIP(5:5)) THEN
            GREEK=.FALSE.
            ZAPF=.FALSE.
            ROMAN=.TRUE.
* find # : end of special or of Zapf => go to roman
         ELSE IF(CHAR2(I:I).EQ.CFLIP(6:6)) THEN
            ROMAN=.TRUE.
            ZAPF=.FALSE.
            SPECIA=.FALSE.
* find ! : go to normal level of script
         ELSE IF(CHAR2(I:I).EQ.CFLIP(7:7)) THEN
            NORMAL=.TRUE.
            SUPER=.FALSE.
            SUB=.FALSE.
* find ~ : go to ZapfDingbats
         ELSE IF(CHAR2(I:I).EQ.CFLIP(8:8)) THEN
            ZAPF=.TRUE.
* find & : backspace is required
         ELSE IF(CHAR2(I:I).EQ.CFLIP(9:9)) THEN
            NBAS=1
*       check if many backspaces are required:
*       compute how many consecutive backspaces
*       in the NCHP-I remaining characters
            DO 100 J=I+1,NCHP
               IF(CHAR2(J:J).EQ.CFLIP(9:9)) THEN
                  NBAS=NBAS+1
               ELSE
                  GO TO 110
               ENDIF
  100       CONTINUE
  110       CONTINUE
*
* Since I have to backspace some text, (part of the preceeding piece),
* I define two pieces:
*
* a. the string which follows normally the & ( i.e. up to the next
*    escape character)
*
* b. the string to be backspaced, i.e. a part of the preceeding piece so
*    I create a new piece which is a copy the preceeding with LBACK<0
*
            NT=NT+1
            LBACK(NT)=-NBAS
*     and the other parameters identical
            PIECE(NT)=PIECE(NT-1)
            IFNB(NT)=IFNB(NT-1)
            IFNS(NT)=IFNS(NT-1)
*      except the level, since the backspaced piece is not printed
            LEVEL(NT)=0
*       however, in case of multiple backspaces, take the &&&...&&& as a
*       whole
            IF(NBAS.GT.1) THEN
               I=I+NBAS-1
               GO TO 90
            ENDIF
* find $ : optional terminaison character
         ELSE IF(CHAR2(I:I).EQ.CFLIP(10:10)) THEN
            IF(I.EQ.NCHP) GO TO 140
         ENDIF
* the character is not a control character
      ELSE
*
* START of a new text: on the first character, or on the
*    first non escape char. which follows an escape char.
         IF(I.NE.1)JX=ICFMUL(CFLIP,CHAR2,I-1,I-1)
         IF(NG.NE.0.OR.I.EQ.1) THEN
            IDEB=I
            NT=NT+1
* set font # (IFNB)
            IF(ROMAN) IFNB(NT)=NFON
            IF(GREEK) IFNB(NT)=12
            IF(ZAPF) IFNB(NT)=14
            IF(SPECIA) IFNB(NT)=25
* set font size (IFNS)
            JSIZP=NINT(0.7*IS)
            JSIZB=NINT(0.7*IS)
            IFNS(NT)=IS
            IF(SUPER) IFNS(NT)=JSIZP
            IF(SUB) IFNS(NT)=JSIZB
* set level flag (LEVEL)
            NYPOS=0
            NYSUP=NINT(IS/2.)
            NYSUB=NINT(-IS/3.)
            LEVEL(NT)=NYPOS
            IF(SUPER) LEVEL(NT)=NYSUP
            IF(SUB) LEVEL(NT)=NYSUB
         ENDIF
*set LBACK flag (1 for sub/uperscript)
         IF(SUPER.OR.SUB) LBACK(NT)=1

* END of a this text: on the last character or on
*      the last non escape which preceeds an escape (but
*      the terminating escape character itself is not known)
         IF(I.NE.NCHP)JX=ICFMUL(CFLIP,CHAR2,I+1,I+1)
         IF(NG.NE.0.OR.I.EQ.NCHP) THEN
            IFIN = I
*      compute text length and make one piece if length <74
*      and not 80, because of the () and \040 on the PostScript file
            ILEN = IFIN-IDEB+1
            IF(ILEN.LT.74) THEN
               PIECE(NT) = CHAR2(IDEB:IFIN)
*      if the last character is ' ' it is replaced with \040
               IF(CHAR2(IFIN:IFIN).EQ.' ')THEN
                  PIECE(NT)(ILEN:ILEN) = BSLASH
                  PIECE(NT)(ILEN+1:)   = '040'
               ENDIF
*      make several pieces if length > 74
            ELSE
               I1  = IDEB
               I2  = I1+73
               NTS = NT
*      check if CHAR2 will not be cut in the middle of an octal code
  120          IB  = INDEX(CHAR2(I2-2:I2),BSLASH)
               IF (IB.NE.0.AND.I2-I1.EQ.73.AND.I2.NE.NCHP) I2 = I2-4+IB
*      copy CHAR2 in the piece number NT with I2 readjusted
               PIECE(NT) = CHAR2(I1:I2)
*      if the last character is ' ' it is replaced with \040
               IF(CHAR2(I2:I2).EQ.' ')THEN
                  ILP = LENOCC(PIECE(NT))+1
                  PIECE(NT)(ILP:ILP) = BSLASH
                  PIECE(NT)(ILP+1:)  = '040'
               ENDIF
               IF (I2.EQ.ILEN) GOTO 130
               I1        = I2+1
               I2        = MIN(ILEN,I1+73)
               NT        = NT+1
               IFNB(NT)  = IFNB(NTS)
               IFNS(NT)  = IFNS(NTS)
               LEVEL(NT) = LEVEL(NTS)
               LBACK(NT) = LBACK(NTS)
               GOTO 120
            ENDIF
  130       CONTINUE
         ENDIF
      ENDIF
      GO TO 90
  140 CONTINUE
*
* Finally, a fourth parsing for 3 reasons:
*
      DO 160 I=1,NT
*** 1. LEVEL of sub/superscript after a multiple backsp. text:
*      one has:
*      i-2: text normally output lback=0
*      i-1 : text following in superscript mode
*      i : part of the preceeding (not printed) in which one
*          computes the backspace
*      i+1: text following the backspace
*      =>  since PIECE(i-1) and PIECE(I+1) are superposed;
*      I increase the level such that LEVEL(I-1)=IFNS(I-1)

         IF(LBACK(I).LT.-1) THEN
            IF (I.GT.1) THEN
*   superscript
               IF(LEVEL(I-1).GT.0) LEVEL(I-1)=IFNS(I-1)
*   subscript
               IF(LEVEL(I-1).LT.0) LEVEL(I-1)=-IFNS(I-1)
            ENDIF
         ENDIF

*** 2. LEVEL of sub/ superscript after ONE backspaced text:
*   put the LEVEL to +(actual font size) for superscript
*    and to - (actuel font size) for subscript
         IF (I.GT.1) THEN
            IF(LBACK(I-1).EQ.-1) THEN
*   superscript
               IF(LEVEL(I).GT.0) LEVEL(I)=IFNS(I)
*   subscript
               IF(LEVEL(I).LT.0) LEVEL(I)=-IFNS(I)
            ENDIF
         ENDIF

*** 3. correct in the greek text the 4 characters in the /Symbol font
* which are not " at their correct place" w.r.t. the HIGZ official table
         IF(IFNB(I).EQ.12) THEN
            DO 150 J=1,LENOCC(PIECE(I))
               IF(PIECE(I)(J:J).EQ.'J') THEN
                  PIECE(I)(J:J)='I'
               ELSEIF(PIECE(I)(J:J).EQ.'V') THEN
                  PIECE(I)(J:J)='C'
               ELSEIF(PIECE(I)(J:J).EQ.'C') THEN
                  PIECE(I)(J:J)='H'
               ELSEIF(PIECE(I)(J:J).EQ.'H') THEN
                  PIECE(I)(J:J)='C'
*
               ELSEIF(PIECE(I)(J:J).EQ.'j') THEN
                  PIECE(I)(J:J)='i'
               ELSEIF(PIECE(I)(J:J).EQ.'v') THEN
                  PIECE(I)(J:J)='c'
               ELSEIF(PIECE(I)(J:J).EQ.'c') THEN
                  PIECE(I)(J:J)='h'
               ELSEIF(PIECE(I)(J:J).EQ.'h') THEN
                  PIECE(I)(J:J)='c'
               ENDIF
  150       CONTINUE
         ENDIF
  160 CONTINUE
*
* write PS
* position of text from arguments
*
      PSANGL=RANGLE
*
      CALL IPPSTR('@')

* 1. text is left aligned
      IF(ITXALH.LE.1) THEN
         CALL IPSVRT(1)
         CALL IPDRAW(0,X,Y)
         CALL IPPSTR('@')
         WRITE (LUNPS,10000,ERR=350) NINT(PSANGL)
10000    FORMAT(' t ',I3,' r 0 0 m')
*
*   2. the text is centered or right-adjusted => compute
*      the whole length
*
      ELSEIF(ITXALH.EQ.2.OR.ITXALH.EQ.3) THEN

*    initialize the variable containing the string length
         WRITE(LUNPS,10100,ERR=350)
10100    FORMAT(' /xs 0 def ')

*    loop on all pieces and add the length of each piece
         IPIECE=0
  170    IPIECE=IPIECE+1
         IF(IPIECE.GT.NT) GO TO 250
*
*   2.1. ONE bakspaced text: forget the piece to be backspaced
*        and the piece which follows
*
         IF(LBACK(IPIECE).EQ.-1) THEN
            IPIECE=IPIECE+1
            GO TO 170
         ENDIF
*
*   2.2  backspaced text by more than one backspace
*
         IF(LBACK(IPIECE).LT.-1) THEN
            ILEN=LENOCC(PIECE(IPIECE))
            WRITE(LUNPS,13100,ERR=999) PIECE(IPIECE)(1:ILEN)
            WRITE(LUNPS,13400,ERR=350) ABS(LBACK(IPIECE))
     +,     PSFONT(IFNB(IPIECE))(1:LENOCC(PSFONT(IFNB(IPIECE))))
     +,     IFNS(IPIECE)
            GO TO 170
         ENDIF
*
*  2.3  many superscript and many subscript at the same x
*
         IF(LBACK(IPIECE).EQ.1.AND.LBACK(IPIECE+1).EQ.1) THEN
*
*   loop on pieces, computes how many pieces withe LBACK=1
*    and check if they are all at the same level;
*    if yes, this is "standart" text
            N1=0
            N2=0
            DO 180 J=IPIECE,NT
               IF(LBACK(J).NE.1) GO TO 190
               IF(LEVEL(J).EQ.LEVEL(IPIECE)) THEN
                  N1=N1+1
               ELSE
                  N2=N2+1
               ENDIF
  180       CONTINUE
  190       CONTINUE
            IF(N1.EQ.0.OR.N2.EQ.0) GO TO 240
*
*      since many fonts are possible in sub/superscript, we output all
*      the pieces in super/subscript then thoses in sub/superscript
*
*   a) first pieces subscript or superscript
            WRITE(LUNPS,10200)
10200       FORMAT(' /s1 0 def ')
            DO 200 J=IPIECE,NT
               IF(LEVEL(J).NE.LEVEL(IPIECE)) GO TO 210
               WRITE(LUNPS,13200,ERR=350)
     +         PSFONT(IFNB(J))(1:LENOCC(PSFONT(IFNB(J)))),IFNS(IPIECE)
               ILEN=LENOCC(PIECE(J))
               WRITE(LUNPS,10300,ERR=999) PIECE(J)(1:ILEN)
10300          FORMAT(' (',A,') sw pop s1 add /s1 exch def')
*
               NEW=J
  200       CONTINUE
  210       CONTINUE

*   b) then superscript or subscript
            WRITE(LUNPS,10400)
10400       FORMAT(' /s2 0 def ')
            NEW=NEW+1
            DO 220 J=NEW,NT
               IF(LEVEL(J).NE.LEVEL(NEW)) GO TO 230
               WRITE(LUNPS,13200,ERR=350)
     +         PSFONT(IFNB(J))(1:LENOCC(PSFONT(IFNB(J)))),IFNS(IPIECE)
               ILEN=LENOCC(PIECE(J))
               WRITE(LUNPS,10500,ERR=999) PIECE(J)(1:ILEN)
10500          FORMAT(' (',A,') sw pop s2 add /s2 exch def')
               NNEW=J
  220       CONTINUE
  230       CONTINUE
*
* between subscript and superscript, which one is the longest?
            WRITE(LUNPS,10600,ERR=350)
10600       FORMAT(' s1 s2 ge { xs s1 add /xs exch def}'
     +        ,' { xs s2 add /xs exch def} ifelse ')
*
* since many pieces are treated :increase piece counter accordingly
            IPIECE=NNEW
            GO TO 170
         ENDIF
*
* 2.4. "standart" text:
*
  240    CONTINUE
         IF(LBACK(IPIECE).EQ.0.OR.LBACK(IPIECE).EQ.1) THEN
            ILEN=LENOCC(PIECE(IPIECE))
            WRITE(LUNPS,13100,ERR=999) PIECE(IPIECE)(1:ILEN)
            WRITE(LUNPS,10700,ERR=350)
     +      PSFONT(IFNB(IPIECE))(1:LENOCC(PSFONT(IFNB(IPIECE))))
     +,     IFNS(IPIECE)
10700       FORMAT(1X,A,1X,I6,' stwn ')
         ENDIF
         GO TO 170
  250    CONTINUE
*
*              Centered text
*
         IF(ITXALH.EQ.2) THEN
            CALL IPSVRT(1)
            CALL IPDRAW(0,X,Y)
            CALL IPPSTR('@')
            WRITE(LUNPS,10800,ERR=350) NINT(PSANGL)
10800       FORMAT(' t ',I3,' r ',' xs 2 div neg 0 t 0 0 m')
*
*              Right adjusted text
*
         ELSEIF(ITXALH.EQ.3) THEN
            CALL IPSVRT(1)
            CALL IPDRAW(0,X,Y)
            CALL IPPSTR('@')
            WRITE(LUNPS,10900,ERR=350) NINT(PSANGL)
10900       FORMAT(' t ',I3,' r ',' xs neg 0 t 0 0 m')
         ENDIF
      ENDIF

*   now output the pieces
      IPIECE=0
  260 IPIECE=IPIECE+1
      IF(IPIECE.GT.NT) GO TO 340
*
* make the PostScript file:
*
* 1. ONE bakspace: output "piece" to be backspaced AND following piece
*    first save current graphic state, compute backward distance,
*       and move to that point
*
      IF(LBACK(IPIECE).EQ.-1) THEN
         CALL IPSVRT(1)
         WRITE(LUNPS,11000,ERR=350)
     +   PSFONT(IFNB(IPIECE))(1:LENOCC(PSFONT(IFNB(IPIECE))))
     +,  IFNS(IPIECE)
11000    FORMAT(A,' findfont ',I4,' sf ')
         ILEN=LENOCC(PIECE(IPIECE))
         WRITE(LUNPS,13100,ERR=999) PIECE(IPIECE)(1:ILEN)
         WRITE(LUNPS,11100,ERR=350)
11100    FORMAT( ' dup length 1 sub 1 getinterval ')
         WRITE(LUNPS,11200,ERR=350) LEVEL(IPIECE)
11200    FORMAT( ' stringwidth pop 2 div neg ',I4,' rm ')

* then, text following one backspace: backspace also 1/2 of text
*   ( normally one character) print and restore preceeding graphic state
         WRITE(LUNPS,11300,ERR=350)
     +   PSFONT(IFNB(IPIECE+1))(1:LENOCC(PSFONT(IFNB(IPIECE+1))))
     +,  IFNS(IPIECE+1),LEVEL(IPIECE+1)
11300    FORMAT(1X,A,' findfont ',I4,' sf 0 ',I4,' rm ')
         ILEN=LENOCC(PIECE(IPIECE+1))
         WRITE(LUNPS,13100,ERR=999) PIECE(IPIECE+1)(1:ILEN)
         WRITE(LUNPS,11400,ERR=350)
11400    FORMAT(' stringwidth pop 2 div neg 0 rm ')
         ILEN=LENOCC(PIECE(IPIECE+1))
         WRITE(LUNPS,13100,ERR=999) PIECE(IPIECE+1)(1:ILEN)
         IF(OSHOW) THEN
            WRITE(LUNPS,'('' oshow'')',ERR=350)
            CALL IPSVRT(-1)
         ELSE
            WRITE(LUNPS,'('' show'')',ERR=350)
            CALL IPSVRT(-1)
         ENDIF
* since two pieces are treated increase piece counter
         IPIECE=IPIECE+1
         GO TO 260
      ENDIF
*
*   2. Many Backspaces
*
      IF(LBACK(IPIECE).LT.-1) THEN
*       first, protect against a number of bakspaces larger than
*       the total number of characters in the string to be
*       backspaced
         ILEN=LENOCC(PIECE(IPIECE))
         WRITE(LUNPS,13300,ERR=350) ABS(LBACK(IPIECE))
     +,  PIECE(IPIECE)(1:ILEN)
*       then output
         WRITE(LUNPS,13200,ERR=350)
     +   PSFONT(IFNB(IPIECE))(1:LENOCC(PSFONT(IFNB(IPIECE))))
     +,  IFNS(IPIECE)
         WRITE(LUNPS,13100,ERR=999) PIECE(IPIECE)(1:ILEN)
         WRITE(LUNPS,11700,ERR=350)
11700    FORMAT(' dup length nbas sub nbas getinterval stringwidth '
     +   ,'pop neg 0 t ')
         GO TO 260
      ENDIF
*
*  3.  superscript and subscript at the same x
      IF(LBACK(IPIECE).EQ.1.AND.LBACK(IPIECE+1).EQ.1) THEN
*
*   loop on pieces, computes how many pieces withe LBACK=1
*    and check if they are all at the same level;
*    if yes, this is "standart" text
         N1=0
         N2=0
         DO 270 J=IPIECE,NT
            IF(LBACK(J).NE.1) GO TO 280
            IF(LEVEL(J).EQ.LEVEL(IPIECE)) THEN
               N1=N1+1
            ELSE
               N2=N2+1
            ENDIF
  270    CONTINUE
  280    CONTINUE
         IF(N1.EQ.0.OR.N2.EQ.0) GO TO 330
*
*      since many fonts are possible in sub/superscript, we output all
*      the pieces in super/subscript then thoses in sub/superscript
*
*   a) first pieces subscript or superscript
         CALL IPSVRT(1)
         CALL IPSVRT(1)
         WRITE(LUNPS,11900,ERR=350) LEVEL(IPIECE)
11900    FORMAT(' 0 ',I4,' rm ')
*
         DO 290 J=IPIECE,NT
            IF(LEVEL(J).NE.LEVEL(IPIECE)) GO TO 300
            WRITE(LUNPS,13200,ERR=350)
     +      PSFONT(IFNB(J))(1:LENOCC(PSFONT(IFNB(J)))),IFNS(IPIECE)
            ILEN=LENOCC(PIECE(J))
            WRITE(LUNPS,13100,ERR=999) PIECE(J)(1:ILEN)
            IF(OSHOW) THEN
               WRITE(LUNPS,12000,ERR=350)
12000          FORMAT(' dup oshow  true charpath currentpoint pop'
     +               ,' /s1 exch def')
            ELSE
               WRITE(LUNPS,12100,ERR=350)
12100          FORMAT(' show currentpoint pop /s1 exch def')
            ENDIF
*
            NEW=J
  290    CONTINUE
  300    CONTINUE
         CALL IPSVRT(-1)
*
*   b) then superscript or subscript
         NEW=NEW+1
*
         WRITE(LUNPS,11900,ERR=350) LEVEL(NEW)
         DO 310 J=NEW,NT
            IF(LEVEL(J).NE.LEVEL(NEW)) GO TO 320
            WRITE(LUNPS,13200,ERR=350)
     +      PSFONT(IFNB(J))(1:LENOCC(PSFONT(IFNB(J)))),IFNS(IPIECE)
            ILEN=LENOCC(PIECE(J))
            WRITE(LUNPS,13100,ERR=999) PIECE(J)(1:ILEN)
            IF(OSHOW) THEN
               WRITE(LUNPS,12300,ERR=350)
12300          FORMAT(' dup oshow  true charpath currentpoint pop '
     +                , ' /s2 exch def')
            ELSE
               WRITE(LUNPS,12400,ERR=350)
12400          FORMAT(' show currentpoint pop /s2 exch def')
            ENDIF
            NNEW=J
  310    CONTINUE

  320    CONTINUE
         CALL IPSVRT(-1)
*
* at which x- value, should one translate the current state?
         WRITE(LUNPS,12500,ERR=350)
12500    FORMAT(' s1 s2 ge {s1 0 t} {s2 0 t} ifelse ')
*
* since many pieces are treated :increase piece counter accordingly
         IPIECE=NNEW
         GO TO 260
      ENDIF
*
* 4. "standart" text: output current "piece" of text
*
  330 CONTINUE
      IF(LBACK(IPIECE).EQ.0.OR.LBACK(IPIECE).EQ.1) THEN
         WRITE(LUNPS,12600,ERR=350)
     +   PSFONT(IFNB(IPIECE))(1:LENOCC(PSFONT(IFNB(IPIECE))))
     +,  IFNS(IPIECE),LEVEL(IPIECE)
12600    FORMAT(1X,A,' findfont ',I4,' sf 0 ',I4,' m ')
         ILEN=LENOCC(PIECE(IPIECE))
         WRITE(LUNPS,13100,ERR=999) PIECE(IPIECE)(1:ILEN)
         IF(OSHOW) THEN
            WRITE(LUNPS,12700,ERR=350)
12700       FORMAT(' dup oshow')
*           move currentpoint ( if not last piece of text)
            IF(IPIECE.NE.NT) WRITE(LUNPS,12800,ERR=350)
12800       FORMAT(' true charpath currentpoint pop 0 t ')
         ELSE
            WRITE(LUNPS,12900,ERR=350)
12900       FORMAT(' show ')
*           move currentpoint ( if not last piece of text)
            IF(IPIECE.NE.NT) WRITE(LUNPS,13000,ERR=350)
13000       FORMAT(' currentpoint pop 0 t ')
         ENDIF
         GO TO 260
      ENDIF

*  end of loop on pieces
  340 CONTINUE

* restore graphic state after the last piece of text
      CALL IPSVRT(-1)
      GOTO 999
*
  350 CALL IGERR('Cannot write in the PostScript file','IPTEXT')
      GOTO 999
*
  360 CALL IGERR('Too many characters in input string','IPTEXT')
13100 FORMAT('(',A,')')
13200 FORMAT(1X,A,' findfont ',I4,' sf')
13300 FORMAT(1X,I4,' /nbas exch def ',/,1X,'(',A,')',/,
     +' length /tlen exch def nbas tlen gt { /nbas tlen def } if ')
13400 FORMAT(' ',I2,' ',A,I4,' stwb ')
*
  999 END
+DECK,  IPTLIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPTLIN(CMD,IX,IY)
      CHARACTER CMD*(*)
*.===========>
*.
*.    This routine writes a drawing command to the LaTeX metafile
*.
*. _Input parameters:
*.
*.  CHARACTER CMD   : name of drawing macro
*.  INTEGER IX,IY   : coordinates
*.
*..==========> (A.Nathaniel)
+CDE, HIPOST.
      CHARACTER*30 STR
*.______________________________________
*
      STR=BSLASH//CMD
      L=INDEX(STR,' ')
      CALL IZITOC(IX,STR(L:))
      IF(INDEX('hrUD',CMD).EQ.0) THEN
         L=INDEX(STR,' ')
         STR(L:)=','
         CALL IZITOC(IY,STR(L+1:))
      ENDIF
      L=INDEX(STR,' ')
      STR(L:)=';'
      CALL IPPSTR(STR)
      END
+DECK,  IPTMAC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:07  mclareni
* Higz

      SUBROUTINE IPTMAC
*.===========>
*.
*.   Write the LaTeX macro definitions to the metafile:
*.      \h<n>;      horizontal line left
*.      \r<n>;      horizontal line right
*.      \U<n>;      vertical line up
*.      \D<n>;      vertical line down
*.      \s<m>,<n>;  slanted line
*.      \m<m>,<n>;  move
*.      \p<m>,<n>;  plot
*.      \f<m>,<n>;  filled box
*.
*..==========> (A.Nathaniel)
*.______________________________________
*
+CDE, HIATT.
+CDE, HIPOST.
      CHARACTER CHDATE*20
+CDE, HIVERS.

*     convert centimeter to minimal resolution 0.1mm
      IPTCM(CM)=INT(CM*100)
      CALL IGDATE(CHDATE)
      CALL IPPSTR('% HIGZ version'//CHVERS//
     +   ' LaTeX metafile created  '//CHDATE(:LENOCC(CHDATE))//'@')
*------------------------------------------------------------------*
* Don't change the following compressed macro definitions by hand. *
* Instead change the expanded form in deck MACROTEX and insert the *
* Fortran code generated by the awk script in deck MACROAWK:       *
*    awk -f macro.awk macro.tex                                    *
*------------------------------------------------------------------*
      CALL IPPSTR(BSLASH//'ifx'//BSLASH//'higzunit')
      CALL IPPSTR(BSLASH//'undefined'//BSLASH//'unitlength=0pt{}')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'unitlength=')
      CALL IPPSTR(BSLASH//'higzunit'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'ifdim'//BSLASH//'unitlength=0pt')
      CALL IPPSTR(BSLASH//'unitlength='//BSLASH//'textwidth')
      CALL IPPSTR(BSLASH//'divide'//BSLASH//'unitlength')
      CALL IPIOUT(IPTCM(X2W-X1W))
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'par'//BSLASH//'noindent')
      CALL IPPSTR(BSLASH//'begin{picture}')
      CALL IPJOUT(IPTCM(X2W-X1W),IPTCM(Y2W-Y1W))
      CALL IPJOUT(IPTCM(X1W),IPTCM(Y1W))
      CALL IPPSTR(BSLASH//'ifx'//BSLASH//'higzdraft')
      CALL IPPSTR(BSLASH//'undefined'//BSLASH//'newcount')
      CALL IPPSTR(BSLASH//'higzdraft'//BSLASH//'higzdraft=0{}')
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'ifnum'//BSLASH//'higzdraft>0')
      CALL IPPSTR(BSLASH//'put(0,0){'//BSLASH//'framebox')
      CALL IPJOUT(IPTCM(X2W-X1W),IPTCM(Y2W-Y1W))
      CALL IPPSTR('{}}'//BSLASH//'else'//BSLASH//'ifx')
      CALL IPPSTR(BSLASH//'higzstep'//BSLASH//'undefined')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzstep')
      CALL IPPSTR(BSLASH//'higzstep=0{}'//BSLASH//'fi'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzstep<1'//BSLASH//'higzstep=2')
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'ifx'//BSLASH//'higzxx')
      CALL IPPSTR(BSLASH//'undefined'//BSLASH//'newcount')
      CALL IPPSTR(BSLASH//'higzxx'//BSLASH//'newcount')
      CALL IPPSTR(BSLASH//'higzyy'//BSLASH//'newcount'//BSLASH//'higzx')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzy')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzdx')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzdy')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzlx')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzly')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzslope')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzlen')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzllen')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzoffs')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzloffs')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzadash')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzbdash')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzcdash')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzddash')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higzmsize')
      CALL IPPSTR(BSLASH//'newcount'//BSLASH//'higztemp'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'def'//BSLASH//'higzstroke#1,#2,#3,#4;{')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzloffs')
      CALL IPPSTR(BSLASH//'higzllen'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzloffs>#1'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzloffs-'//BSLASH//'higzllen')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzloffs-#1')
      CALL IPPSTR(BSLASH//'higzloffs=-'//BSLASH//'higzloffs')
      CALL IPPSTR(BSLASH//'ifnum#2>0'//BSLASH//'put(')
      CALL IPPSTR(BSLASH//'higzlx,'//BSLASH//'higzly){')
      CALL IPPSTR(BSLASH//'line(#3,#4){'//BSLASH//'higzloffs}}')
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'ifnum#2<0'//BSLASH//'put(')
      CALL IPPSTR(BSLASH//'higzlx,'//BSLASH//'higzly){')
      CALL IPPSTR(BSLASH//'circle*{0}}'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'higztemp='//BSLASH//'higzloffs')
      CALL IPPSTR(BSLASH//'multiply'//BSLASH//'higztemp#3')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzlx')
      CALL IPPSTR(BSLASH//'higztemp'//BSLASH//'higztemp=')
      CALL IPPSTR(BSLASH//'higzloffs'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higztemp#4'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzly'//BSLASH//'higztemp')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzllen-')
      CALL IPPSTR(BSLASH//'higzloffs'//BSLASH//'higzloffs=#1')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'ifnum#2>0'//BSLASH//'put(')
      CALL IPPSTR(BSLASH//'higzlx,'//BSLASH//'higzly){')
      CALL IPPSTR(BSLASH//'line(#3,#4){'//BSLASH//'higzllen}}')
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'ifnum#2<0'//BSLASH//'put(')
      CALL IPPSTR(BSLASH//'higzlx,'//BSLASH//'higzly){')
      CALL IPPSTR(BSLASH//'circle*{0}}'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'higzllen=0'//BSLASH//'fi}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'higzdashed#1,#2,#3,#4,#5;{{')
      CALL IPPSTR(BSLASH//'higzlx=#1'//BSLASH//'higzly=#2')
      CALL IPPSTR(BSLASH//'higzllen=#5'//BSLASH//'higzloffs=')
      CALL IPPSTR(BSLASH//'higzoffs'//BSLASH//'loop'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzloffs<'//BSLASH//'higzadash')
      CALL IPPSTR(BSLASH//'ifnum'//BSLASH//'higzadash>1')
      CALL IPPSTR(BSLASH//'higzstroke'//BSLASH//'higzadash,1,#3,#4;')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'higzstroke')
      CALL IPPSTR(BSLASH//'higzadash,-1,#3,#4;'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'ifnum'//BSLASH//'higzloffs<')
      CALL IPPSTR(BSLASH//'higzbdash'//BSLASH//'higzstroke')
      CALL IPPSTR(BSLASH//'higzbdash,0,#3,#4;'//BSLASH//'else')
      CALL IPPSTR(BSLASH//'ifnum'//BSLASH//'higzloffs<')
      CALL IPPSTR(BSLASH//'higzcdash'//BSLASH//'higztemp=')
      CALL IPPSTR(BSLASH//'higzcdash'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higztemp-'//BSLASH//'higzbdash')
      CALL IPPSTR(BSLASH//'ifnum'//BSLASH//'higztemp>1')
      CALL IPPSTR(BSLASH//'higzstroke'//BSLASH//'higzcdash,1,#3,#4;')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'higzstroke')
      CALL IPPSTR(BSLASH//'higzcdash,-1,#3,#4;'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'ifnum'//BSLASH//'higzloffs<')
      CALL IPPSTR(BSLASH//'higzddash'//BSLASH//'higzstroke')
      CALL IPPSTR(BSLASH//'higzddash,0,#3,#4;'//BSLASH//'else')
      CALL IPPSTR(BSLASH//'higzloffs=0'//BSLASH//'fi'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'fi'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzllen>0'//BSLASH//'repeat')
      CALL IPPSTR(BSLASH//'global'//BSLASH//'higzoffs=')
      CALL IPPSTR(BSLASH//'higzloffs}}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'higzsolid#1,#2,#3,#4,#5;{')
      CALL IPPSTR(BSLASH//'put(#1,#2){'//BSLASH//'line(#3,#4){#5}}}')
      CALL IPPSTR(BSLASH//'def'//BSLASH//'higzhslant#1,#2,#3;{')
      CALL IPPSTR(BSLASH//'higzslope=#1'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzslope1000'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzslope500'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzslope#2'//BSLASH//'higzlen=')
      CALL IPPSTR(BSLASH//'higzslope'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzlen'//BSLASH//'higzstep')
      CALL IPPSTR(BSLASH//'divide'//BSLASH//'higzlen1000')
      CALL IPPSTR(BSLASH//'higzdy=0'//BSLASH//'loop'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzdy<#2'//BSLASH//'higzx=')
      CALL IPPSTR(BSLASH//'higzxx'//BSLASH//'higzy='//BSLASH//'higzyy')
      CALL IPPSTR(BSLASH//'higzdx='//BSLASH//'higzslope')
      CALL IPPSTR(BSLASH//'multiply'//BSLASH//'higzdx')
      CALL IPPSTR(BSLASH//'higzdy'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzdx500'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzdx1000'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzy'//BSLASH//'higzdy'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzdx#3'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzx'//BSLASH//'higzdx'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzdx#3'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzdx'//BSLASH//'higzlen'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzdx>#1'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzlen#1'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzlen-'//BSLASH//'higzdx'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'higzline'//BSLASH//'higzx,')
      CALL IPPSTR(BSLASH//'higzy,#3,0,'//BSLASH//'higzlen;')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzdy')
      CALL IPPSTR(BSLASH//'higzstep'//BSLASH//'repeat}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'higzvslant#1,#2,#3;{')
      CALL IPPSTR(BSLASH//'higzslope=#2'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzslope1000'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzslope500'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzslope#1'//BSLASH//'higzlen=')
      CALL IPPSTR(BSLASH//'higzslope'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzlen'//BSLASH//'higzstep')
      CALL IPPSTR(BSLASH//'divide'//BSLASH//'higzlen1000')
      CALL IPPSTR(BSLASH//'higzdx=0'//BSLASH//'loop'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzdx<#1'//BSLASH//'higzx=')
      CALL IPPSTR(BSLASH//'higzxx'//BSLASH//'higzy='//BSLASH//'higzyy')
      CALL IPPSTR(BSLASH//'higzdy='//BSLASH//'higzslope')
      CALL IPPSTR(BSLASH//'multiply'//BSLASH//'higzdy')
      CALL IPPSTR(BSLASH//'higzdx'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzdy500'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzdy1000'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzx'//BSLASH//'higzdx'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzdy#3'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzy'//BSLASH//'higzdy'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzdy#3'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzdy'//BSLASH//'higzlen'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzdy>#2'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzlen#2'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzlen-'//BSLASH//'higzdy'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'higzline'//BSLASH//'higzx,')
      CALL IPPSTR(BSLASH//'higzy,0,#3,'//BSLASH//'higzlen;')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzdx')
      CALL IPPSTR(BSLASH//'higzstep'//BSLASH//'repeat}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'s#1,#2;{'//BSLASH//'higzdx=#1{}')
      CALL IPPSTR(BSLASH//'ifnum'//BSLASH//'higzdx<0')
      CALL IPPSTR(BSLASH//'higzdx=-'//BSLASH//'higzdx'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'higzdy=#2{}'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzdy<0'//BSLASH//'higzdy=-')
      CALL IPPSTR(BSLASH//'higzdy'//BSLASH//'fi'//BSLASH//'ifnum')
      CALL IPPSTR(BSLASH//'higzdx<'//BSLASH//'higzdy'//BSLASH//'ifnum')
      CALL IPPSTR('#1<0'//BSLASH//'advance'//BSLASH//'higzxx#1')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzyy#2')
      CALL IPPSTR(BSLASH//'ifnum#2<0'//BSLASH//'higzvslant-#1,-#2,1;')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'higzvslant-#1,#2,-1;')
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'else'//BSLASH//'ifnum#2<0')
      CALL IPPSTR(BSLASH//'higzvslant#1,-#2,-1;'//BSLASH//'else')
      CALL IPPSTR(BSLASH//'higzvslant#1,#2,1;'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzxx#1')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzyy#2'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'ifnum#2<0')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzxx#1')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzyy#2')
      CALL IPPSTR(BSLASH//'ifnum#1<0'//BSLASH//'higzhslant-#1,-#2,1;')
      CALL IPPSTR(BSLASH//'else'//BSLASH//'higzhslant#1,-#2,-1;')
      CALL IPPSTR(BSLASH//'fi'//BSLASH//'else'//BSLASH//'ifnum#1<0')
      CALL IPPSTR(BSLASH//'higzhslant-#1,#2,-1;'//BSLASH//'else')
      CALL IPPSTR(BSLASH//'higzhslant#1,#2,1;'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzxx#1')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzyy#2'//BSLASH//'fi')
      CALL IPPSTR(BSLASH//'fi}'//BSLASH//'def'//BSLASH//'h#1;{')
      CALL IPPSTR(BSLASH//'higzline'//BSLASH//'higzxx,')
      CALL IPPSTR(BSLASH//'higzyy,1,0,#1;'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzxx#1}'//BSLASH//'def'//BSLASH//'r#1;{')
      CALL IPPSTR(BSLASH//'higzline'//BSLASH//'higzxx,')
      CALL IPPSTR(BSLASH//'higzyy,-1,0,#1;'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzxx-#1}'//BSLASH//'def'//BSLASH//'U#1;{')
      CALL IPPSTR(BSLASH//'higzline'//BSLASH//'higzxx,')
      CALL IPPSTR(BSLASH//'higzyy,0,1,#1;'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzyy#1}'//BSLASH//'def'//BSLASH//'D#1;{')
      CALL IPPSTR(BSLASH//'higzline'//BSLASH//'higzxx,')
      CALL IPPSTR(BSLASH//'higzyy,0,-1,#1;'//BSLASH//'advance')
      CALL IPPSTR(BSLASH//'higzyy-#1}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'m#1,#2;{'//BSLASH//'higzxx=#1')
      CALL IPPSTR(BSLASH//'higzyy=#2}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'higzdot#1,#2;{'//BSLASH//'put(#1,#2){')
      CALL IPPSTR(BSLASH//'circle*{'//BSLASH//'higzmsize}}}')
      CALL IPPSTR(BSLASH//'def'//BSLASH//'higzplus#1,#2;{')
      CALL IPPSTR(BSLASH//'higzx=#1'//BSLASH//'multiply')
      CALL IPPSTR(BSLASH//'higzx2'//BSLASH//'advance'//BSLASH//'higzx-')
      CALL IPPSTR(BSLASH//'higzmsize'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzx2'//BSLASH//'put(')
      CALL IPPSTR(BSLASH//'higzx,#2){'//BSLASH//'line(1,0){')
      CALL IPPSTR(BSLASH//'higzmsize}}'//BSLASH//'higzy=#2')
      CALL IPPSTR(BSLASH//'multiply'//BSLASH//'higzy2')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzy-')
      CALL IPPSTR(BSLASH//'higzmsize'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzy2'//BSLASH//'put(#1,')
      CALL IPPSTR(BSLASH//'higzy){'//BSLASH//'line(0,1){')
      CALL IPPSTR(BSLASH//'higzmsize}}}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'higzstar#1,#2;{'//BSLASH//'higzplus#1,#2;')
      CALL IPPSTR(BSLASH//'higzcross#1,#2;}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'higzcircle#1,#2;{'//BSLASH//'put(#1,#2){')
      CALL IPPSTR(BSLASH//'circle{'//BSLASH//'higzmsize}}}')
      CALL IPPSTR(BSLASH//'def'//BSLASH//'higzcross#1,#2;{')
      CALL IPPSTR(BSLASH//'let'//BSLASH//'higzsave'//BSLASH//'higzline')
      CALL IPPSTR(BSLASH//'let'//BSLASH//'higzline')
      CALL IPPSTR(BSLASH//'higzsolid'//BSLASH//'higzlx=#1')
      CALL IPPSTR(BSLASH//'multiply'//BSLASH//'higzlx2')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzlx-')
      CALL IPPSTR(BSLASH//'higzmsize'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzlx2'//BSLASH//'higzly=#2')
      CALL IPPSTR(BSLASH//'multiply'//BSLASH//'higzly2')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzly-')
      CALL IPPSTR(BSLASH//'higzmsize'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzly2'//BSLASH//'m'//BSLASH//'higzlx,')
      CALL IPPSTR(BSLASH//'higzly;'//BSLASH//'s'//BSLASH//'higzmsize,')
      CALL IPPSTR(BSLASH//'higzmsize;'//BSLASH//'higzly=#2')
      CALL IPPSTR(BSLASH//'multiply'//BSLASH//'higzly2')
      CALL IPPSTR(BSLASH//'advance'//BSLASH//'higzly')
      CALL IPPSTR(BSLASH//'higzmsize'//BSLASH//'divide')
      CALL IPPSTR(BSLASH//'higzly2'//BSLASH//'m'//BSLASH//'higzlx,')
      CALL IPPSTR(BSLASH//'higzly;'//BSLASH//'s'//BSLASH//'higzmsize,-')
      CALL IPPSTR(BSLASH//'higzmsize;'//BSLASH//'let')
      CALL IPPSTR(BSLASH//'higzline'//BSLASH//'higzsave}')
      CALL IPPSTR(BSLASH//'def'//BSLASH//'p#1,#2;{')
      CALL IPPSTR(BSLASH//'higzmarker#1,#2;}'//BSLASH//'def')
      CALL IPPSTR(BSLASH//'f#1,#2;{'//BSLASH//'put('//BSLASH//'higzxx,')
      CALL IPPSTR(BSLASH//'higzyy){'//BSLASH//'makebox(#1,#2)[lb]{')
      CALL IPPSTR(BSLASH//'rule{#1'//BSLASH//'unitlength')
      CALL IPPSTR('}{#2'//BSLASH//'unitlength}}}}')
*------------------------------------------------------------------*
      CALL IPPSTR('% End of Initialisation@')
      CALL IPLTYP(0)
      CALL IPLTYP(ILN)
      END
+DECK,  IPTTEX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

      SUBROUTINE IPTTEX(X,Y,CHARS)
      CHARACTER*(*) CHARS
*.===========>
*.
*.    This routine translates text to TeX format
*.    according to the IGTEXT control characters.
*.
*. _Input parameters:
*.
*.  CHARACTER CHARS : Text string .
*.
*..==========> (A.Nathaniel)
+CDE, HIATT.
+CDE, HIPOST.
      PARAMETER(MFONTS=8)
      CHARACTER CH*1,FONTS(MFONTS)*2
      LOGICAL LOWER,LGREEK,LSPEC,LSUPER
      CHARACTER LETTER(26,4)*12
*--- LaTeX names for greek letters and special symbols
*        '123456789012','123456789012','123456789012','123456789012'
      DATA (LETTER(I,1),I=1,26)/
     +   '|alpha      ','|beta       ','|eta        ','|delta      ',
     +   '|epsilon    ','|phi        ','|gamma      ','|chi        ',
     +   '|iota       ','|iota       ','|kappa      ','|lambda     ',
     +   '|mu         ','|nu         ','o           ','|pi         ',
     +   '|theta      ','|rho        ','|sigma      ','|tau        ',
     +   '|upsilon    ','|chi        ','|omega      ','|xi         ',
     +   '|psi        ','|zeta       '/
      DATA (LETTER(I,2),I=1,26)/
     +   'A           ','B           ','H           ','|Delta      ',
     +   'E           ','|Phi        ','|Gamma      ','X           ',
     +   'I           ','I           ','K           ','|Lambda     ',
     +   'M           ','N           ','O           ','|Pi         ',
     +   '|Theta      ','R           ','|Sigma      ','T           ',
     +   '|Upsilon    ','X           ','|Omega      ','|Xi         ',
     +   '|Psi        ','Z           '/
      DATA (LETTER(I,3),I=1,26)/
     +   '|pm         ','|mid        ','|ast        ','|$          ',
     +   '!           ','|#          ','>           ','?           ',
     +   '|int        ',':           ',';           ','<           ',
     +   '[           ',']           ','|leq        ','|{          ',
     +   '|}          ','|surd       ','|cap        ','|dagger     ',
     +   '|ddagger    ','|cup        ','|&          ','|times      ',
     +   '|partial    ','|infty      '/
      DATA (LETTER(I,4),I=1,26)/
     +   '|pm         ','|mid        ','|div        ','|$          ',
     +   '!           ','|#          ','>           ','?           ',
     +   '|int        ',':           ',';           ','<           ',
     +   '[           ',']           ','|geq        ','|{          ',
     +   '|}          ','|surd       ','|spadesuit  ','|heartsuit  ',
     +   '|diamondsuit','|clubsuit   ','|&          ','|times      ',
     +   '|%          ','|infty      '/

      DATA FONTS/'rm','em','bf','it','sl','sf','sc','tt'/
*.______________________________________
*
+CDE, HIWCPS.
      IF(X.LT.X1W .OR. X.GT.X2W .OR. Y.LT.Y1W .OR. Y.GT.Y2W) RETURN
      CALL IPPSTR(BSLASH//'put')
      IXD=IXWCPS(X)
      IYD=IYWCPS(Y)
      CALL IPJOUT(IXD,IYD)
      CALL IPPSTR('{'//BSLASH//'makebox(0,0)')
      IF(ITXALH.NE.2 .OR. ITXALV.NE.3) THEN
         CALL IPPSTR('[')
         IF(ITXALV.EQ.1 .OR. ITXALV.EQ.2) THEN
            CALL IPPSTR('t')
         ELSEIF(ITXALV.NE.3) THEN
            CALL IPPSTR('b')
         ENDIF
         IF(ITXALH.EQ.3) THEN
            CALL IPPSTR('r')
         ELSEIF(ITXALH.NE.2) THEN
            CALL IPPSTR('l')
         ENDIF
         CALL IPPSTR(']')
      ENDIF
      IFNT=ABS(IFONT)
      IF(IFNT.LT.1 .OR. IFNT.GT.MFONTS) IFNT=1
      CALL IPPSTR('{$'//BSLASH//FONTS(IFNT)//'{}')

      LOWER=.FALSE.
      LGREEK=.FALSE.
      LSPEC=.FALSE.
      LSUPER=.FALSE.

      DO 10  I=1,LENOCC(CHARS)
         CH=CHARS(I:I)
         LLOW=ICHAR(CH)-ICHAR('a')+1
         LCAP=ICHAR(CH)-ICHAR('A')+1
         IF(LOWER .AND. LCAP.GE.1 .AND. LCAP.LE.26) THEN
            LLOW=LCAP
            LCAP=0
            CH=CHAR(LLOW+ICHAR('a')-1)
         ENDIF
         IF(LLOW.GE.1 .AND. LLOW.LE.26 .OR.
     +      LCAP.GE.1 .AND. LCAP.LE.26) THEN
            IF(LLOW.GE.1 .AND. LLOW.LE.26) THEN
               IF(LGREEK) THEN
                  ICASE=1
               ELSEIF(LSPEC) THEN
                  ICASE=3
               ELSE
                  ICASE=0
               ENDIF
            ELSE
               LLOW=LCAP
               IF(LGREEK) THEN
                  ICASE=2
               ELSEIF(LSPEC) THEN
                  ICASE=4
               ELSE
                  ICASE=0
               ENDIF
            ENDIF
            IF(ICASE.EQ.0) THEN
               CALL IPPSTR(CH)
            ELSE
               L=INDEX(LETTER(LLOW,ICASE),' ')
               IF(L.EQ.0) L=LEN(LETTER(LLOW,ICASE))+1
               IF(LETTER(LLOW,ICASE)(1:1).EQ.'|') THEN
                  CALL IPPSTR(BSLASH//LETTER(LLOW,ICASE)(2:L-1)//'{}')
               ELSE
                  CALL IPPSTR(LETTER(LLOW,ICASE)(:L-1))
               ENDIF
            ENDIF
         ELSEIF(CH.EQ.' ') THEN
            CALL IPPSTR(BSLASH//' {}')
         ELSEIF(CH.EQ.'<') THEN
            LOWER=.TRUE.
         ELSEIF(CH.EQ.'>') THEN
            LOWER=.FALSE.
         ELSEIF(CH.EQ.'[') THEN
            LGREEK=.TRUE.
            LSPEC=.FALSE.
         ELSEIF(CH.EQ.']') THEN
            LGREEK=.FALSE.
         ELSEIF(CH.EQ.'"') THEN
            LSPEC=.TRUE.
            LGREEK=.FALSE.
         ELSEIF(CH.EQ.'#') THEN
            LSPEC=.FALSE.
         ELSEIF(CH.EQ.'^') THEN
            IF(LSUPER) CALL IPPSTR('}')
            CALL IPPSTR('^{')
            LSUPER=.TRUE.
         ELSEIF(CH.EQ.'?') THEN
            IF(LSUPER) CALL IPPSTR('}')
            CALL IPPSTR('_{')
            LSUPER=.TRUE.
         ELSEIF(CH.EQ.'!') THEN
            IF(LSUPER) CALL IPPSTR('}')
            LSUPER=.FALSE.
         ELSEIF(CH.EQ.'$') THEN
            IF(LSUPER) CALL IPPSTR('}')
            LSUPER=.FALSE.
            GOTO 20
         ELSEIF(CH.EQ.'*') THEN
            CALL IPPSTR(BSLASH//'ast{}')
         ELSEIF(INDEX('%}_',CH).GT.0) THEN
*--- TeX special characters which need to be escaped
            CALL IPPSTR(BSLASH//CH)
         ELSEIF(CH.EQ.'{' .OR. CH.EQ.BSLASH) THEN
*--- enter TeX mode
            IF(LSUPER) CALL IPPSTR('}')
            LSUPER=.FALSE.
            CALL IPPSTR(CHARS(I:))
            GOTO 20
         ELSE
            CALL IPPSTR(CH)
         ENDIF
   10 CONTINUE
   20 CONTINUE
      IF(LSUPER) CALL IPPSTR('}')
      CALL IPPSTR('$}}')
      END
+DECK,  IPZONE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:08  mclareni
* Higz

      SUBROUTINE IPZONE
+CDE, HIATT.
+CDE, HIPOST.
+CDE, HIFLAG.
*.______________________________________
*
      IF(.NOT.LOCLR.OR.TFLAG)RETURN
      LOCLR=.FALSE.
* When IPZONE has been called, LOZONE is TRUE
      LOZONE=.TRUE.
*
      IF(IYZ.GT.NY)THEN
         IYZ=1
         IF(MODE.NE.3)THEN
            CALL IPPSTR('@showpage')
            CALL IPSVRT(-1)
            NPAGES = NPAGES+1
            CALL IPPSTR('@%%Page: number ')
            CALL IPIOUT(NPAGES)
            CALL IPPSTR('@')
         ELSE
            CALL IPPSTF(9,' showpage')
            CALL IPSVRT(-1)
         ENDIF
      ENDIF
*
*              No grestore the first time
*
      IF(MODE.NE.3)THEN
         IF (IXZ.NE.1.OR.IYZ.NE.1) CALL IPSVRT(-1)
         CALL IPSVRT(1)
         CALL IPPSTR('@')
         CALL IPIOUT(IXZ)
         CALL IPIOUT(IYZ)
         CALL IPPSTF(5,' Zone')
         CALL IPPSTR('@')
         IXZ=IXZ+1
         IF(IXZ.GT.NX)THEN
            IXZ=1
            IYZ=IYZ+1
         ENDIF
      ENDIF
*
*              Picture Initialisation
*
      CALL IPSVRT(1)
      CALL IPPSTF(5,'0 0 t')
      IPSLT  = 0
      IPSLW  = 0
      IPSCI  = 0
      IPSMSC = -1
      PSRED  = -1.
      PSGRN  = -1.
      PSBLU  = -1.
      CALL IPSCOL(1)
      CALL IPLTYP(1)
      CALL IPLWID(1)
      LOPRT=.FALSE.
*
*              Force the clipping definition if required.
*
      IF (ICLIP.NE.0) THEN
         IPDXC = -IPDXC
         CALL ISCLIP(ICLIP)
      ENDIF
*
      END
+PATCH, IMSDOS.
+DECK,  CIRCF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE CIRCF(IX,IY,IRAD)
+CDE, GREX.
      IER = FILLED_ELLIPSE(IX,IY,IRAD,IRAD)
      END
+SELF.
+DECK,  CIRCI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE CIRCI(IX,IY,IRAD)
+CDE, GREX.
      IER = OPEN_ELLIPSE(IX,IY,IRAD,IRAD)
      END
+SELF.
+DECK,  COLOR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE COLOR(INDEX)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, HIMETA.
      I = INDEX
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IF (IWTYL(IWKNB) .EQ. ISURF) THEN
            CALL GOLWRI(SP,I,' ')
         END IF
      ELSE
         IER = SET_COLOR(I)
      END IF
      END
+SELF.
+DECK,  CURSOF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE CURSOF
+CDE, GREX.
      IER = MOVE_CURSOR(-1,-1)
      END
+SELF.
+DECK,  DRAW2I, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE DRAW2I(IX,IY)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, HIMETA.
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IXSAVE(IWKNB) = IX
         IYSAVE(IWKNB) = IY
         IF (IWTYL(IWKNB) .EQ. ISURF) THEN
            COOR(1) = IX
            COOR(2) = YWKSIZ(IWKNB)-IY
            CALL GOLWRI(PA,COOR,' ')
         END IF
      ELSE
         IER = DRAW(IX,IY)
      END IF
      END
+SELF.
+DECK,  ICRAWL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

+SELF, IF=MSDOS, IF=NDP.
      FUNCTION ICRAWL(X,Y)
*.
*...  CHANGE POSITION OF THE CURSOR
*.
*..   INPUT:
*.      -----
*.      X, Y - INITIAL POSITION
*.
*..     OUTPUT:
*.      ------
*.      X, Y - NEW POSITION
*.      ICRAWL  =  10*XFLAG + YFLAG
*.                 XFLAG = 1 - X POSITION HAVE BEEN CHANGED
*.                 YFLAG = 1 - Y POSITION HAVE BEEN CHANGED
*.              = -1 KEY "ESC" HAVE BEEN PRESSED OR LEFT BUTTON
*.              =  0 KEY "ENTER" HAVE BEEN PRESSED OR RIGHT BUTTON
+CDE, HIKERN.
      INTEGER XMIN,YMIN,XMAX,YMAX,X,Y, CTRL_C, ESC, ENTER
      PARAMETER (CTRL_C=3, ESC=27, RETKEY=13)
      INTEGER K
*
      LOGICAL SAMPLE
      LOGICAL MIDPR,LEFTPR,RIGHTPR
      SAVE MIDPR,LEFTPR,RIGHTPR
      DATA MIDPR,LEFTPR,RIGHTPR /3*.true./
*
      IER = GET_CLIP_LIMITS(XMIN,YMIN,XMAX,YMAX)

      ICRAWL = 0
   10 IF (MOUSE) THEN
         IBUT = 0
         CALL GET_MOUSE(IBUT,IX,IY)
         IF (IX .NE. X) THEN
            IF(IX.GT.XMAX) IX = XMIN
            if(IX.lt.xmin) IX = xmax
            icrawl = icrawl + 10
         END IF

         IF (IY .NE. Y) THEN
            IF(IY.GT.YMAX) IY = YMIN
            IF(IY.LT.YMIN) IY = YMAX
            icrawl = icrawl + 1
         END IF

         IF (ICRAWL .EQ. 0 .AND. IBUT .EQ. 0) then
            MIDPR = .TRUE.
            LEFTPR = .TRUE.
            RIGHTPR = .TRUE.
            GO TO 70
         END IF
         IF (IBUT .GT. 0) THEN
            GO TO (30,20,40,50),IBUT
   20       CONTINUE
*--
*--     LEFT BUTTON ARE PRESSING
*
            IF (.NOT.LEFTPR) GO TO 70
            MIDPR = .TRUE.
            RIGHTPR = .TRUE.
            LEFTPR = .NOT. LEFTPR
            ICRAWL = IBUT - 2
            GO TO 60
   30       CONTINUE
*--
*--     RIGHT BUTTON ARE PRESSING
*
            IF (.NOT.RIGHTPR) GO TO 70
            MIDPR = .TRUE.
            LEFTPR = .TRUE.
            RIGHTPR = .NOT. RIGHTPR
            ICRAWL = IBUT - 2
            GO TO 60
   40       CONTINUE
*--
*--     MIDDLE BUTTON ARE PRESSING
*
   50       CONTINUE
            IF (.NOT.MIDPR) GO TO 70
            RIGHTPR = .TRUE.
            LEFTPR = .TRUE.
            MIDPR = .NOT. MIDPR
            ICRAWL = IBUT - 2
         ELSE
            MIDPR = .TRUE.
            LEFTPR = .TRUE.
            RIGHTPR = .TRUE.
            Y = IY
            X = IX
            CALL SET_MOUSE(X,Y)
         END IF
   60    CONTINUE
         GO TO 80
      END IF
   70 CONTINUE
      K = INKEY$()
      IF (K .EQ. 0) GO TO 10
      IF (K .EQ. CTRL_C) THEN
         CALL IGEND
         CALL ABEND
      END IF
      IF(K.LT.0) THEN
         K = -K
         IF(K.EQ.83) THEN
*--
*--     [DEL] KEY have been pressed
*--     to decrease the speed of cursor
*
            ISTEP = ISTEP-1
            ISTEP = MAX0(ISTEP,1)
            IF (MOUSE) THEN
               IRAT = 64/ISTEP + 1
               CALL SET_MP_RATIO(IRAT,IRAT)
            END IF
            GO TO 10
         END IF
*
         IF(K.EQ.82) THEN
*--
*--     [INS] KEY have been pressed
*--     to increase the speed of cursor
*
            ISTEP = ISTEP+1
            ISTEP = MIN0(ISTEP,100)
            IF (MOUSE) THEN
               IRAT = 64/ISTEP + 1
               CALL SET_MP_RATIO(IRAT,IRAT)
            END IF
            GO TO 10
         END IF
*
         IF(K.LT.71.OR.K.GT.81) GO TO 10
*--
*--        Arrow keys have been pressed
*
*
*              Y MOTION
*
         IF(K.EQ.71.OR.K.EQ.72.OR.K.EQ.73) THEN
            Y = Y - ISTEP
            ICRAWL = ICRAWL + 1
         ELSE IF(K.EQ.79.OR.K.EQ.80.OR.K.EQ.81) THEN
            Y = Y + ISTEP
            ICRAWL = ICRAWL + 1
         END IF
*
*        X MOTION
*
         IF(K.EQ.71.OR.K.EQ.75.OR.K.EQ.79) THEN
            X = X - ISTEP
            ICRAWL = ICRAWL + 10
         ELSE IF(K.EQ.73.OR.K.EQ.77.OR.K.EQ.81) THEN
            X = X + ISTEP
            ICRAWL = ICRAWL + 10
         END IF
         IF(X.LT.XMIN) X = XMAX
         IF(Y.LT.YMIN) Y = YMAX
         IF(X.GT.XMAX) X = XMIN
         IF(Y.GT.YMAX) Y = YMIN
         IF (MOUSE) CALL SET_MOUSE(X,Y)
      ELSE IF (K .EQ. ESC) THEN
         ICRAWL = -1
      ELSE IF (K .EQ. RETKEY) THEN
         ICRAWL =  0
      ELSE
         GO TO 10
      END IF
   80 RETURN
      END
+SELF.
+DECK,  LINEWI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

+SELF, IF=MSDOS, IF=NDP.
      SUBROUTINE LINEWI(LWSC)
      END
+SELF.
+DECK,  MAPCOL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE MAPCOL(ICI,RED,GREEN,BLUE)
+CDE, HIKERN.
+CDE, HIATT.
      PARAMETER (IVGA = 18)

      if (ICI .gt. INBCOL) return
       IRED  = MIN(NINT(RED*3),3)
       IGREEN= MIN(NINT(GREEN*3),3)
       IBLUE = MIN(NINT(BLUE*3),3)
       IIIC = ISHFT(IAND(IRED,2),4)+ISHFT(IAND(IRED,1),2)
       IIIC2= ISHFT(IAND(IGREEN,2),3)+ISHFT(IAND(IGREEN,1),1)
       IIIC = IOR(IIIC,IIIC2)
       IIIC2= ISHFT(IAND(IBLUE,2),2)+JBIT(IBLUE,1)
       IIIC = IOR(IIIC,IIIC2)
      IF (IWTYL(Icurwk) .LT. IVGA) THEN
        CALL DEFINE_COLOR(ICI,IIIC)
        PAL(ICI+1) = CHAR(IIIC)
      ELSE
**      IER    = SET_PALETTE(PAL)
        IRED   =  NINT(RED*63)
        IGREEN =  NINT(GREEN*63)
        IBLUE  =  NINT(BLUE*63)
        CALL DEFINE_COLOR(ICI,ICI+IOFCOL)
        PAL(ICI+1) = CHAR(ICI+IOFCOL)
        CALL VGA_PALETTE(ICI+IOFCOL,IRED,IGREEN,IBLUE)
      END IF
      END
+SELF.
+DECK,  MARKER, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE MARKER(N,X,Y)
+CDE, HIATT.
+CDE, HIKERN.
+CDE, HIMETA.
      DIMENSION X(N),Y(N)
C--
C--     Corresponing between marker type and it code into centered.sym
C
      DIMENSION IPLMTP(5)
      DATA IPLMTP / 59, 39, 41, 33, 40/
*
+CDE, HIWCDC.
C
      IF (IMK .EQ. 1) THEN
         DO 10 I=1,N
            IXX = IXWCDC(X(I))
            IYY = IYWCDC(Y(I))
            CALL SETPIX(IXX,IYY)
   10    CONTINUE
      ELSE
         IS = IWKNB
         NTSAV = INTR
         CALL ISELNT(0)
         IWKNB = IS
         ISF = IXWCDC(RMKSC*0.009)
         CALL ISELNT(NTSAV)
         IWKNB = IS
         IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
            IF (IWTYL(IWKNB) .EQ. ISURF) THEN
               CALL GOLWRI(SS,0,'CENTERED.SYM')
               DO 20 I=1,N
                  COOR(1) = FLOAT(IXWCDC(X(I)))
                  COOR(2) = YWKSIZ(IWKNB)-IYWCDC(Y(I))
                  COOR(3) = FLOAT(ISF)
                  COOR(4) = 0.0
                  IF (IMK .LE. 5) THEN
                     CALL GOLWRI(PS,COOR,CHAR(IPLMTP(IMK)))
                  ELSE
                     CALL GOLWRI(PS,COOR,CHAR(IMK+31))
                  END IF
   20          CONTINUE
               CALL GOLWRI(SS,0,SYMFIL)
            END IF
         ELSE
            ISF = ISF/2
            DO 80 I=1,N
               IXX = IXWCDC(X(I))
               IYY = IYWCDC(Y(I))
               GO TO (30,40,50,60),MOD(IMK-1,4)+1
   30          CALL SBOXI(IXX-ISF,IYY-ISF,IXX+ISF,IYY+ISF)
               GOTO 70
   40          CALL SBOXFI(IXX-ISF,IYY-ISF,IXX+ISF,IYY+ISF)
               GOTO 70
   50          CALL CIRCI(IXX,IYY,ISF)
               GOTO 70
   60          CALL CIRCF(IXX,IYY,ISF)
   70          CONTINUE
   80       CONTINUE
            IXSAVE(IWKNB) = IXX
            IYSAVE(IWKNB) = IYY
         END IF
         IWKNB = IS
      END IF
      END
+SELF.
+DECK,  MOVE2I, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:03  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE MOVE2I(IX,IY)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, HIMETA.
*
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IF (IX .NE. IXSAVE(IWKNB) .OR. IY .NE. IYSAVE(IWKNB)) THEN
            IXSAVE(IWKNB) = IX
            IYSAVE(IWKNB) = IY
            IF (IWTYL(IWKNB).EQ. ISURF) THEN
               COOR(1) = IX
               COOR(2) = (YWKSIZ(IWKNB)-IY)
               CALL GOLWRI(MA,COOR,' ')
            END IF
         END IF
      ELSE
         IER = MOVE(IX,IY)
      END IF
      END
+SELF.
+DECK,  OUTTEXT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:04  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE OUT_TEXT(CHARS,IX,IY,ICOLOR)
+CDE, HIATT.
+CDE, HIKERN.
+CDE, HIMETA.
      CHARACTER CHARS*(*)
*
+CDE, HIWCDC.
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IF (IWTYL(IWKNB) .EQ. ISURF) THEN
            COOR(1) = IX
            COOR(2) = YWKSIZ(IWKNB)-IY
            COOR(3) = YWKSIZ(IWKNB) - IYWCDC(RCHH)
            COOR(4) = RANGLE
            CALL GOLWRI(PS,COOR,CHARS)
         END IF
      ELSE
         IHHH = STRWID(CHARS,1)
         IER = GRAPHIC_TEXT(CHARS,IX,IY -IHHH+1,ICOLOR)
      END IF
      IXSAVE(IWKNB) = -1
      IYSAVE(IWKNB) = -1
      END
+SELF.
+DECK,  POLF2I, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:04  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE POLF2I(N,IXY)
*.
*.   by Fine V. from LCTA JINR (fine@main2.jinr.dubna.su)
*.       (based on IGHATC)
*.
      INTEGER IXY(N,2)
*.___________________________________________
*
+CDE, HIKERN.
+CDE, HIATT.
      INTEGER IXY(IBUFSI,2)
      III =IFACI+IOFCOL
+SELF, IF=MSDOS, IF=NDP.
      IER = POLYFILL (IXY(1,1),IXY(1,2),N,III, III)
+SELF, IF=MSDOS, IF=-NDP.
      IER = POLFIL (IXY,N,III, III)
+SELF, IF=MSDOS.
      END
+SELF.
+DECK,  POLY2I, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:04  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE POLY2I(N,IPOS)
+SELF, IF=MSDOS, IF=NDP.
      DIMENSION IPOS(1000,2)
      IF (N .GT. 0) THEN
         IF (N .EQ. 1) THEN
            CALL SETPIX(IPOS(1,1),IPOS(1,2))
         ELSE
            CALL MOVE2I(IPOS(1,1),IPOS(1,2))
            DO 10 I=2,N
               CALL DRAW2I(IPOS(I,1),IPOS(I,2))
   10       CONTINUE
            IF (N .GT. 2) CALL DRAW2I(IPOS(1,1),IPOS(1,2))
+SELF, IF=MSDOS, IF=-NDP.
      DIMENSION IPOS(2,1000)
      IF (N .GT. 0) THEN
         IF (N .EQ. 1) THEN
            CALL SETPIX(IPOS(1,1),IPOS(2,1))
         ELSE
            CALL MOVE2I(IPOS(1,1),IPOS(2,1))
            DO 10 I=2,N
               CALL DRAW2I(IPOS(1,I),IPOS(2,I))
   10       CONTINUE
            IF (N .GT. 2) CALL DRAW2I(IPOS(1,1),IPOS(2,1))
+SELF, IF=MSDOS.
         END IF
      END IF
      END
+SELF.
+DECK,  SBOXFI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:04  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE SBOXFI(IX1,IY1,IX2,IY2)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, HIMETA.
      DIMENSION IBX(2,4)
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IF (IWTYL(IWKNB).EQ. ISURF) THEN
            IBX(2,1) = IX1
            IBX(2,1) = IX2
            IBX(3,1) = IX2
            IBX(4,1) = IX1
            IBX(1,2) = IY1
            IBX(2,2) = IY1
            IBX(3,2) = IY2
            IBX(4,2) = IY2
            IDX = IABS(IX2-IX1)
            IDY = IABS(IY2-IY1)
            IF (IDX .GT. IDY) THEN
               IFY = MIN(IY1,IY2)-1
               DO 10 I=1,IDY
                  CALL MOVE2I(IX1,IFY+I)
                  CALL DRAW2I(IX2,IFY+I)
   10          CONTINUE
            ELSE
               IFX = MIN(IX1,IX2)-1
               DO 20 I=1,IDX
                  CALL MOVE2I(IFX+I,IY1)
                  CALL DRAW2I(IFX+1,IY2)
   20          CONTINUE
            END IF
         END IF
      ELSE
         IER = FILLED_RECTANGLE(IX1,IY2,IX2,IY1)
      END IF
      END
+SELF.
+DECK,  SBOXI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:04  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE SBOXI(IX1,IY1,IX2,IY2)
+CDE, HIATT.
      CALL SETLIN(1)
      CALL MOVE2I(IX1,IY1)
      CALL DRAW2I(IX2,IY1)
      CALL DRAW2I(IX2,IY2)
      CALL DRAW2I(IX1,IY2)
      CALL DRAW2I(IX1,IY1)
      CALL SETLIN(ILN)
      END
+SELF.
+DECK,  SCRMAS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:04  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE SCRMAS(IX1,IX2,IY2,IY1)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, GREX.
      IYMIN = IY1 - 1
      IYMAX = IY2 + 1
      IXMIN = IX1 - 1
      IXMAX = IX2 + 1
      IYMIN = MAX(0,IYMIN)
      IXMIN = MAX(0,IXMIN)
      IYMAX = MIN(INT(YWKSIZ(IWKNB))-1,IYMAX)
      IXMAX = MIN(INT(XWKSIZ(IWKNB))-1,IXMAX)
      IER = SET_CLIP_LIMITS(IXMIN,IYMIN,IXMAX,IYMAX)
      END
+SELF.
+DECK,  SETLIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:04  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE SETLIN(ILIN)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, HIMETA.
      I = ILIN
      IF (I .LE. 0) I = 1
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IF (IWTYL(IWKNB) .EQ. ISURF) THEN
         END IF
      ELSE
         IER = SET_DASH(DASH_PATTERN(ILN))
      END IF
      END
+SELF.
+DECK,  SETPAT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:05  mclareni
* Higz
+SELF, IF=MSDOS.

+SELF, IF=MSDOS, IF=NDP.
      SUBROUTINE SETPAT(IFASI)
      END
+SELF.
+DECK,  SETPIX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:05  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE SETPIX(IX,IY)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, HIMETA.
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IF (IWTYL(IWKNB) .EQ. ISURF) THEN
            CALL MOVE2I(IX,IY)
            CALL DRAW2I(IX,IY)
         END IF
      ELSE
         IER = SET_PIXEL(IX,IY)
         IXSAVE(IWKNB) = IX
         IYSAVE(IWKNB) = IY
      END IF
      END
+SELF.
+DECK,  STRWID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:05  mclareni
* Higz
+SELF, IF=MSDOS.

      FUNCTION STRWID(CH,LCH)
+CDE, HIATT.
+CDE, HIKERN.
+CDE, HIMETA.
      CHARACTER*(*) CH
+CDE, HIWCDC.
      IF (ILOPWK(IWKNB) .EQ. IDMETA) THEN
         IF (IWTYL(IWKNB) .EQ. ISURF) THEN
            CALL IGTEXT(0.0,0.0,CH(:LCH),RCHH,A,'S')
            STRWID = IXWCDC(A)
         END IF
      ELSE
         STRWID = 8*MAG_X*lch-1
      END IF
      END
+SELF.
+DECK,  WINCLO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:05  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE WINCLO(IDUMMY)
      END
+SELF.
+DECK,  WINOPE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:05  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE WINOPE(I,J)
      CHARACTER I
      END
+SELF.
+DECK,  WINPOP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:05  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE WINPOP
      END
+SELF.
+DECK,  WINSET, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:06  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE WINSET(IWINID)
      END
+SELF.
+PATCH, IMAIL.
+DECK,  IMFIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:02  mclareni
* Higz
+SELF, IF=MAIL.

      INTEGER FUNCTION IMFIN(CHBUF,NBREAD,X)
*.===========>
*.
*.   This routine write input CHBUF in X. If IMFIN=0,
*.   the array X is not fill with NBREAD value, if IMFIN
*.   =1 the array is filled with NBREAD value, if IMFIN
*.   =-1, an errors has occured.
*.
*. _Input parameters:
*.
*.  CHARACTER CHBUF : Character buffer
*.  INTEGER NBREAD : Number of reals to be read
*.  REAL X(N) : Array.
*.
*..==========> (O.Couet)
      DIMENSION X(*),IX(16)
      CHARACTER*(*) CHBUF
      SAVE FACT,XMIN
      SAVE IPTR,IX
      DATA IPTR /0/
*.______________________________________
*
      IMFIN=0
*
      IF(NBREAD.EQ.2)THEN
         READ (CHBUF,'(2E16.7)') X(1),X(2)
         IPTR=0
         IMFIN=1
         RETURN
      ENDIF
*
      IF(IPTR.EQ.0)THEN
         READ (CHBUF,'(2E16.7)',ERR=40) FACT,XMIN
         IF(FACT.LE.0.)THEN
            DO 10 K=1,NBREAD
               X(K)=XMIN
   10       CONTINUE
            IPTR=0
            IMFIN=1
         ELSE
            IPTR=1
         ENDIF
         RETURN
      ENDIF
      IF(IPTR+15.LE.NBREAD)THEN
         READ (CHBUF,'(16I5)',ERR=40) (IX(I),I=1,16)
         DO 20 I=IPTR,IPTR+15
            X(I)=FACT*IX(I-IPTR+1)+XMIN
   20    CONTINUE
         IF(IPTR+15.EQ.NBREAD)THEN
            IPTR=0
            IMFIN=1
            RETURN
         ELSE
            IPTR=IPTR+16
            RETURN
         ENDIF
      ELSE
         J=NBREAD-IPTR
         READ (CHBUF,'(16I5)',ERR=40) (IX(I),I=1,J+1)
         DO 30 I=IPTR,IPTR+J
            X(I)=FACT*IX(I-IPTR+1)+XMIN
   30    CONTINUE
         IPTR=0
         IMFIN=1
         RETURN
      ENDIF
   40 IMFIN=-1
*
      END
+SELF.
+DECK,  IMFOUT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:02  mclareni
* Higz
+SELF, IF=MAIL.

      SUBROUTINE IMFOUT(N,X)
*.===========>
*.
*.   This routine write a buffer of N floating points
*. on the std output.
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of floating points.
*.  REAL X(N) : Array.
*.
*..==========> (O.Couet)
+CDE, HIMAIL.
      DIMENSION X(*)
      CHARACTER*8 CHTEMP
*.______________________________________
*
      IF(N.EQ.2)THEN
         WRITE (CHMAIL,'(2E16.7)') X(1),X(2)
         CALL IMWRIT(2)
         RETURN
      ENDIF
*
      XMIN=VMIN(X,N)
      XMAX=VMAX(X,N)
      IF(XMIN.EQ.XMAX)THEN
         FACT=-1.
      ELSE
         FACT=(XMAX-XMIN)/99999.
      ENDIF
      WRITE (CHMAIL,'(2E16.7)') FACT,XMIN
      CALL IMWRIT(2)
      IF(FACT.LE.0.)RETURN
      J=0
      DO 10 I=1,N
         IX=(X(I)-XMIN)/FACT
         WRITE (CHTEMP,'(I5)') IX
         K=(5*J)+1
         CHMAIL(K:K+4)=CHTEMP(1:5)
         J=J+1
         IF(J.EQ.16)THEN
            J=0
            CALL IMWRIT(2)
         ENDIF
   10 CONTINUE
      IF(J.NE.0)CALL IMWRIT(2)
*
      END
+SELF.
+DECK,  IMINT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:02  mclareni
* Higz
+SELF, IF=MAIL.

      SUBROUTINE IMINT(CHBUFI,IO)
*.===========>
*.
*.   Interface between: TELNET "G" and HIGZ
*.                      3270   "G" and HIGZ
*.
*. _Input parameters:
*.
*.  CHARACTER CHBUFI : Buffer to be interpreted
*.  INTEGER IO : Lenght of the significant characters
*.               in CHBUFI.
*.
*. _Output parameters:
*.
*.  INTEGER IO : =0 Ouput
*.               =1 Input
*.
*..==========> (O.Couet)
      PARAMETER (IMEN=50)
      PARAMETER (NWORDS=20000)
      COMMON /PAWC/ H(NWORDS)
+CDE, HIQUES.
+CDE, HIATNB.
+CDE, HILABS.
+CDE, HIFLAG.
      CHARACTER*80 CHBUFI,CHBUF
      CHARACTER*80 CHARS
      CHARACTER*32 CHOPT
      CHARACTER*32 CHITEM(IMEN),TITLE,CHDEF(IMEN)
      CHARACTER*32 CHVAL(IMEN),CHUSER(IMEN)
      PARAMETER (IBUFSI=10000)
      DIMENSION X(IBUFSI),Y(IBUFSI)
      SAVE CHOPT,CHITEM,TITLE,CHDEF,CHVAL,CHUSER,CHARS
      SAVE X,Y
      SAVE NEWCOD,NT,N,NN,IXREAD,IERR,NX,NY,NYY,NPAR
      SAVE MN,NBU,ICHOIC,IPTR,ICODE,IO2
+CDE, HIATNM.
      DATA NEWCOD /1/
      DATA IXREAD /1/
      DATA IERR   /0/
      DATA IO2    /0/
*.______________________________________
*
      CHBUF=' '
      CHBUF=CHBUFI(1:IO)
*
*              Errors management
*
      IF(IERR.EQ.-1)THEN
         IF(CHBUF(1:1).EQ.'%')THEN
            IERR=0
            NEWCOD=1
         ELSE
            GOTO 999
         ENDIF
      ENDIF
*
*              Read the code of the HIGZ function to be performed
*
      IO=0
      IF(NEWCOD.NE.0)THEN
         IF(CHBUF(1:1).EQ.'%')THEN
            READ (CHBUF,'(1X,I3)',ERR=2) ICODE
         ELSE
            GOTO 999
         ENDIF
      ENDIF
*
*              Start with HIGZ
*
      IF(ICODE.EQ.100)THEN
         READ (CHBUF,'(4X,I5,I10)',ERR=99)IFIL,IWT
         CALL MZEBRA(-3)
         CALL MZPAW(NWORDS,' ')
         CALL IGINIT(100)
         CALL IGSSE(IFIL,IWT)
         CALL IGZSET('G')
         WRITE (CHBUFI,'(2E16.7)') RQUEST(11),RQUEST(12)
         CHBUFI(79:79)=CHAR(13)
         CHBUFI(80:80)=CHAR(10)
         IO=1
         GOTO 999
      ENDIF
*
*              Clear workstation
*
      IF(ICODE.EQ.101)THEN
         IF(ZFLAG)THEN
            CALL IZPICT(' ','S')
            CALL IZPICT(' ','M')
         ENDIF
         CALL ICLRWK(0,0)
         GOTO 999
      ENDIF
*
*              Normalization transformations
*
      IF(ICODE.EQ.200)THEN
         IF(NEWCOD.NE.0)THEN
            READ (CHBUF,'(4X,I5)',ERR=99) NT
            NEWCOD=0
            IXREAD=1
         ELSE
            IF(IXREAD.EQ.1)THEN
               READ (CHBUF,'(4E16.7)') X(1),X(2),X(3),X(4)
               IXREAD=0
            ELSE
               READ (CHBUF,'(4E16.7)') X(5),X(6),X(7),X(8)
               CALL ISWN(NT,X(1),X(2),X(3),X(4))
               CALL ISVP(NT,X(5),X(6),X(7),X(8))
               CALL ISELNT(NT)
               NEWCOD=1
            ENDIF
         ENDIF
         GOTO 999
      ENDIF
*
*              IGRNG
*
      IF(ICODE.EQ.201)THEN
         READ (CHBUF,'(4X,2E16.7)',ERR=99) X(1),Y(1)
         CALL IGRNG(X(1),Y(1))
         WRITE (CHBUFI,'(5E15.6)') RQUEST(11),RQUEST(12),RQUEST(13)
     +,                            RQUEST(14),RQUEST(15)
         CHBUFI(79:79)=CHAR(13)
         CHBUFI(80:80)=CHAR(10)
         IO=1
         GOTO 999
      ENDIF
*
*              Request locator
*
      IF(ICODE.EQ.555)THEN
         READ (CHBUF,'(4X,2I3)',ERR=99) N,NN
         CALL IRQLC(N,NN,ISTAT,NT,XLOC,YLOC)
         WRITE (CHBUFI,'(2I5,2E16.7)') ISTAT,NT,XLOC,YLOC
         CHBUFI(79:79)=CHAR(13)
         CHBUFI(80:80)=CHAR(10)
         IO=1
         GOTO 999
      ENDIF
*
*              Request string
*
      IF(ICODE.EQ.556)THEN
         READ (CHBUF,'(4X,2I3)',ERR=99) N,NN
         CALL IRQST(N,NN,ISTAT,L,CHOPT)
         IF(L.GT.78)L=32
         WRITE (CHBUFI,'(2I5,A)') ISTAT,L,CHOPT
         CHBUFI(79:79)=CHAR(13)
         CHBUFI(80:80)=CHAR(10)
         IO=1
         GOTO 999
      ENDIF
*
*              IGMENU
*
      IF(ICODE.EQ.557)THEN
         IF(IO2.NE.0)GOTO 5571
         IF(NEWCOD.NE.0)THEN
            READ (CHBUF,'(4X,3I3,I10)',ERR=99) MN,NBU,N,ICHOIC
            NEWCOD=0
            IXREAD=1
            GOTO 999
         ENDIF
         IF(IXREAD.NE.0)THEN
            READ (CHBUF,'(4E16.7,A16)',ERR=99) X(1),X(2)
     +,                                        Y(1),Y(2),CHOPT
            IXREAD=0
            IF(INDEX(CHOPT,'T').EQ.0)THEN
               IPTR=0
            ELSE
               IPTR=1
               TITLE=' '
            ENDIF
            IF(NBU.EQ.0.AND.N.EQ.0)THEN
               IPTR=0
               GOTO 5570
            ENDIF
            GOTO 999
         ENDIF
         IF(IPTR.EQ.0)THEN
            READ (CHBUF,'(A)') TITLE
            IPTR=1
            GOTO 999
         ENDIF
         IF(IPTR.NE.0)THEN
            IF(IPTR.LE.N)THEN
               READ (CHBUF,'(2A32)',ERR=99) CHITEM(IPTR),CHDEF(IPTR)
               IPTR=IPTR+1
               IF(NBU.EQ.0.AND.IPTR.EQ.N+1)THEN
                  IPTR=0
                  GOTO 5570
               ENDIF
               GOTO 999
            ENDIF
            IF(IPTR.LE.N+NBU)THEN
               READ (CHBUF,'(A)') CHUSER(IPTR-N)
               IPTR=IPTR+1
               IF(IPTR.EQ.N+NBU+1)THEN
                  IPTR=0
                  GOTO 5570
               ENDIF
               GOTO 999
            ENDIF
         ENDIF
*
 5570    CALL IGMENU(MN,TITLE,X(1),X(2),Y(1),Y(2),NBU,CHUSER
     +,              N,CHITEM,CHDEF,CHVAL,ICHOIC,CHOPT)
*
 5571    IF(INDEX(CHOPT,'C').NE.0)THEN
            IF(IPTR.EQ.0)THEN
               WRITE (CHBUFI,'(I5)') ICHOIC
               CHBUFI(79:79)=CHAR(13)
               CHBUFI(80:80)=CHAR(10)
               IO=1
               IPTR=1
               IF(INDEX(CHOPT,'P').NE.0.AND.N.GT.0)THEN
                  IO2=1
                  NEWCOD=0
               ELSE
                  NEWCOD=1
               ENDIF
               GOTO 999
            ENDIF
            IF(INDEX(CHOPT,'P').NE.0)THEN
               IF(IPTR.NE.0)THEN
                  CHBUFI=CHVAL(IPTR)
                  CHBUFI(79:79)=CHAR(13)
                  CHBUFI(80:80)=CHAR(10)
                  IO=1
                  IPTR=IPTR+1
                  IF(IPTR.GT.N)THEN
                     NEWCOD=1
                     IO2=0
                  ENDIF
                  GOTO 999
               ENDIF
            ENDIF
         ENDIF
         IF(INDEX(CHOPT,'I').NE.0)THEN
            CHBUFI=CHVAL(1)
            CHBUFI(79:79)=CHAR(13)
            CHBUFI(80:80)=CHAR(10)
            IO=1
         ENDIF
         NEWCOD=1
         GOTO 999
      ENDIF
*
*              Set the REDIT factor
*
      IF(ICODE.EQ.558)THEN
         READ (CHBUF,'(4X,E16.7)',ERR=99) R1
         R2=R1
         CALL IGSRAP(R1)
         IF(R2.LT.0)THEN
            WRITE (CHBUFI,'(E16.7)') R1
            CHBUFI(79:79)=CHAR(13)
            CHBUFI(80:80)=CHAR(10)
            IO=1
         ENDIF
         GOTO 999
      ENDIF
*
*              IGTERM
*
      IF(ICODE.EQ.559)THEN
         CALL IGTERM
         GOTO 999
      ENDIF
*
*              END with HIGZ
*
      IF(ICODE.EQ.999)THEN
         CALL IGEND
         RETURN
      ENDIF
*
      GOTO (2,2,2,2,2
     +,     60,70,80,90,100,110,120,130,140,150,160,170,180,190
     +,     200,210,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
     +,     480,490
     +,     5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
     +,     8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
     +      ),ICODE
*
    2 CONTINUE
      GOTO 999
*
*              Histograms
*
   60 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,A10,I5)',ERR=99) CHOPT,N
         NEWCOD=0
         IXREAD=1
         NN=2
         IF(INDEX(CHOPT,'N').NE.0)NN=N+1
         GOTO 999
      ENDIF
      IF(IXREAD.NE.0)THEN
         IERR=IMFIN(CHBUF,NN,X)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=0
         ENDIF
         GOTO 999
      ELSE
         IERR=IMFIN(CHBUF,N,Y)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=1
            GOTO 61
         ENDIF
         GOTO 999
      ENDIF
   61 IF(INDEX(CHOPT,'R').NE.0)THEN
         CALL IGHIST(N,Y,X,CHOPT)
      ELSE
         CALL IGHIST(N,X,Y,CHOPT)
      ENDIF
      NEWCOD=1
      GOTO 999
*
*              Polymarker with one point
*
   70 READ (CHBUF,'(4X,2E16.7)',ERR=99) X(1),Y(1)
      CALL IPM(1,X,Y)
      GOTO 999
*
*              Polyline with two points
*
   80 READ (CHBUF,'(4X,4E16.7)',ERR=99) X(1),X(2),Y(1),Y(2)
      CALL IPL(2,X,Y)
      GOTO 999
*
*              Polyline
*
   90 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,I5)',ERR=99) N
         NEWCOD=0
         IXREAD=1
         GOTO 999
      ENDIF
      IF(IXREAD.NE.0)THEN
         IERR=IMFIN(CHBUF,N,X)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=0
         ENDIF
         GOTO 999
      ELSE
         IERR=IMFIN(CHBUF,N,Y)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=1
            GOTO 91
         ENDIF
         GOTO 999
      ENDIF
   91 CALL IPL(N,X,Y)
      NEWCOD=1
      GOTO 999
*
*              Polymarker
*
  100 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,I5)',ERR=99) N
         NEWCOD=0
         IXREAD=1
         GOTO 999
      ENDIF
      IF(IXREAD.NE.0)THEN
         IERR=IMFIN(CHBUF,N,X)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=0
         ENDIF
         GOTO 999
      ELSE
         IERR=IMFIN(CHBUF,N,Y)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=1
            GOTO 101
         ENDIF
         GOTO 999
      ENDIF
  101 CALL IPM(N,X,Y)
      NEWCOD=1
      GOTO 999
*
*              Fill area
*
  110 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,I5)',ERR=99) N
         NEWCOD=0
         IXREAD=1
         GOTO 999
      ENDIF
      IF(IXREAD.NE.0)THEN
         IERR=IMFIN(CHBUF,N,X)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=0
         ENDIF
         GOTO 999
      ELSE
         IERR=IMFIN(CHBUF,N,Y)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=1
            GOTO 111
         ENDIF
         GOTO 999
      ENDIF
  111 CALL IFA(N,X,Y)
      NEWCOD=1
      GOTO 999
*
*              Text
*
  120 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,2E16.7)',ERR=99) X(1),Y(1)
         NEWCOD=0
         GOTO 999
      ELSE
         READ (CHBUF,'(A)',ERR=99) CHARS
         NEWCOD=1
      ENDIF
      CALL ITX(X(1),Y(1),CHARS)
      GOTO 999
*
*              Box
*
  130 READ (CHBUF,'(4X,4E16.7)',ERR=99) X(1),X(2),X(3),X(4)
      CALL IGBOX(X(1),X(2),X(3),X(4))
      GOTO 999
*
*              Frame box
*
  140 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,4E16.7)',ERR=99) X(1),X(2),X(3),X(4)
         NEWCOD=0
         GOTO 999
      ELSE
         READ (CHBUF,'(4E16.7)',ERR=99) X(5),X(6),X(7),X(8)
         NEWCOD=1
      ENDIF
      CALL IGFBOX(X(1),X(2),X(3),X(4),X(5),X(6),X(7),X(8))
      GOTO 999
*
*              Arc
*
  150 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,4E16.7)',ERR=99) X(1),X(2),X(3),X(4)
         NEWCOD=0
         GOTO 999
      ELSE
         READ (CHBUF,'(2E16.7)',ERR=99) X(5),X(6)
         NEWCOD=1
      ENDIF
      CALL IGARC(X(1),X(2),X(3),X(4),X(5),X(6))
      GOTO 999
*
*              Axis
*
  160 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,4E16.7)',ERR=99) X(1),X(2),X(3),X(4)
         NEWCOD=0
         GOTO 999
      ELSE
         READ (CHBUF,'(2E16.7,I10,A10)',ERR=99) X(5),X(6),NDIV,CHOPT
         NEWCOD=1
      ENDIF
      CALL IGAXIS(X(1),X(2),X(3),X(4),X(5),X(6),NDIV,CHOPT)
      GOTO 999
*
*              Software characters
*
  170 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,4E16.7,A4)',ERR=99) X(1),X(2),X(3),X(4),CHOPT
         NEWCOD=0
         GOTO 999
      ELSE
         READ (CHBUF,'(A)',ERR=99) CHARS
         NEWCOD=1
      ENDIF
      CALL IGTEXT(X(1),X(2),CHARS,X(3),X(4),CHOPT)
      GOTO 999
*
*              Multiline
*
  180 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,I5)',ERR=99) N
         NEWCOD=0
         IXREAD=1
         GOTO 999
      ENDIF
      IF(IXREAD.NE.0)THEN
         IERR=IMFIN(CHBUF,N,X)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=0
         ENDIF
         GOTO 999
      ELSE
         IERR=IMFIN(CHBUF,N,Y)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=1
            GOTO 181
         ENDIF
         GOTO 999
      ENDIF
  181 CALL IML(N,X,Y)
      NEWCOD=1
      GOTO 999
*
*              Alpha numerique axis labels
*
  190 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,I5)',ERR=99) NHILAB
         NEWCOD=0
         N=1
         GOTO 999
      ELSE
         READ (CHBUF,'(A)',ERR=99) HILABS(N)
         N=N+1
         IF(N.GT.NHILAB)GOTO 999
      ENDIF
      NEWCOD=1
      GOTO 999
*
*              Tables
*
  200 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,A20,3I5)',ERR=99) CHOPT,NX,NY,NPAR
         NYY=MAX(NY,1)
         IF(NX*NY.GT.IBUFSI)THEN
            CALL IGERR('To many data','TELNETG')
            GOTO 99
         ENDIF
         NEWCOD=0
         IXREAD=0
         GOTO 999
      ENDIF
      IF(IXREAD.EQ.0)THEN
         IERR=IMFIN(CHBUF,NPAR,X)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=1
         ENDIF
         GOTO 999
      ELSE
         READ (CHBUF,'(6G13.7)',ERR=99) (Y((IXREAD-1)*6+I),I=1,6)
         IXREAD=IXREAD+1
         IF(IXREAD*6.GT.NX*NYY)GOTO 201
         GOTO 999
      ENDIF
  201 CALL IGTABL(NX,NY,Y,NPAR,X,CHOPT)
      NEWCOD=1
      GOTO 999
*
*              Graphs
*
  210 IF(NEWCOD.NE.0)THEN
         READ (CHBUF,'(4X,A10,I5)',ERR=99) CHOPT,N
         NEWCOD=0
         IXREAD=1
         GOTO 999
      ENDIF
      IF(IXREAD.NE.0)THEN
         IERR=IMFIN(CHBUF,NN,X)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=0
         ENDIF
         GOTO 999
      ELSE
         IERR=IMFIN(CHBUF,N,Y)
         IF(IERR.EQ.-1)GOTO 999
         IF(IERR.EQ.1)THEN
            IXREAD=1
            GOTO 211
         ENDIF
         GOTO 999
      ENDIF
  211 CALL IGRAPH(N,X,Y,CHOPT)
      NEWCOD=1
      GOTO 999
*
*
*              Set color representation
*
  480 READ (CHBUF,'(4X,I3,I5,3E16.7)',ERR=99)IWKID,IC,X(1),X(2),X(3)
      CALL ISCR(IDID,IC,X(1),X(2),X(3))
      GOTO 999
*
*              Set clipping indicator
*
  490 READ (CHBUF,'(4X,I2)',ERR=99)ICLSW
      CALL ISCLIP(ICLSW)
      GOTO 999
*
*              Real attributes
*
    5 READ (CHBUF,'(4X,E16.7)',ERR=99) X(1)
      CALL IGSET(CHRATT(ICODE-49),X(1))
      GOTO 999
*
*              Integer attributes
*
    8 READ (CHBUF,'(4X,E16.7)',ERR=99) X(1)
      CALL IGSET(CHIATT(ICODE-79),X(1))
      GOTO 999
*
*              Read Errors
*
   99 CONTINUE
      IERR=-1
  999 CONTINUE
      CALL IGSA(0)
*
      END
+SELF.
+DECK,  IMTEK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:02  mclareni
* Higz
+SELF, IF=MAIL.

      SUBROUTINE IMTEK(KCHAR)
      INTEGER*4 KCHAR
      END
+SELF.
+DECK,  IMWRIT, T=FORT.
* Revision 1.2  1998/01/30 15:22:42  couet
* - APOLLO version removed
* Revision 1.1.1.1  1996/02/14 13:11:02  mclareni
* Higz
+SELF, IF=MAIL.

      SUBROUTINE IMWRIT(IMC)
*.===========>
*.
*.   This routine write CHMAIL on the std output.
*.
*. _Input parameters:
*.
*.  INTEGER IMC : Control, IMC=1 <==> First record
*.                         IMC=2 <==> Middle record
*.                         IMC=3 <==> Last record
*.                         IMC=4 <==> 1+2+3
*.                         IMC=5 <==> Only CHCTRL
*.
*..==========> (O.Couet)
+CDE, HIMAIL.
*.______________________________________
*
      IF(IMC.EQ.5)THEN
         WRITE (6,10400) CHCTRL
         RETURN
      ENDIF
*
      IF(IGASCI(CHMAIL(1:1)).LT.32)CHMAIL=' '
      ILEN=LENOCC(CHMAIL)
      IF(ILEN.EQ.0)ILEN=2
+SELF, IF=MAIL, IF=IBM, IF=-NEWLIB.
      ICR=IOSCLR()
+SELF, IF=MAIL.
*
      GOTO(10,20,30,40)IMC
*
   10 WRITE (6,10000) CHCTRL,CHEOR,CHMAIL(1:ILEN),CHEOR
      GOTO 50
*
   20 WRITE (6,10100) CHEOR,CHMAIL(1:ILEN),CHEOR
      GOTO 50
*
   30 WRITE (6,10200) CHEOR,CHMAIL(1:ILEN),CHEOR,CHCTRL
      GOTO 50
*
   40 WRITE (6,10300) CHCTRL,CHEOR,CHMAIL(1:ILEN),CHEOR,CHCTRL
*
   50 CHMAIL=' '
      RETURN
*
+SELF, IF=MAIL, IF=UNIX.
10000 FORMAT(A2,A1,'%',A,A1)
10100 FORMAT(A1,A,A1)
10200 FORMAT(A1,A,A1,A2)
10300 FORMAT(A2,A1,'%',A,A1,A2)
10400 FORMAT(A2)
+SELF, IF=MAIL, IF=-UNIX.
10000 FORMAT(1X,A2,A1,'%',A,A1)
10100 FORMAT(1X,A1,A,A1)
10200 FORMAT(1X,A1,A,A1,A2)
10300 FORMAT(1X,A2,A1,'%',A,A1,A2)
10400 FORMAT(1X,A2)
+SELF, IF=MAIL.
      END
+SELF.
+PATCH, IMAC.
+DECK,  F_DOBACK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:59  mclareni
* Higz
+SELF, IF=MACMPW.

!!IFC NOT LSPOWERF
!!mp 68kinlines
!!ELSEC
!!mp PPCinlines
!!ENDC
        subroutine F_DoBackground
!!SETC USINGINCLUDES = .FALSE.
!!T72-
        include 'Events.f'
        record /EventRecord/TheEvent
        logical*4 F_BACKEVENT
        external F_BACKEVENT
        logical jev
        integer*2 mask
        integer*4 mySleep
c
        mask=everyEvent-keyDownMask
        mySleep=0
100     if(WaitNextEvent(mask,%ref(TheEvent),mySleep,nil))then
         call F_ReadWindowEvent(TheEvent)
         if(TheEvent.what.ne.0)jev=F_BACKEVENT(%ref(TheEvent))
         goto 100
        endif
c
        return
        end
+SELF.
+DECK,  F_READWI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:59  mclareni
* Higz
+SELF, IF=MACMPW.

!!IFC NOT LSPOWERF
!!mp 68kinlines
!!ELSEC
!!mp PPCinlines
!!ENDC
        SUBROUTINE F_ReadWindowEvent(TheEvent)
c+
c       SUBROUTINE F_ReadWindowEvent(TheEvent)
c
c Someone else requested something similar to your event handling and we have
c an undocumented call that is described below.  Although I will put your entire
c commentary on events into the suggestions list so that the programmers can
c ponder your ideas.
c If you write a subroutine:
c       SUBROUTINE F_ReadWindowEvent(TheEvent)
c
c and put it in your link ahead of FORTRANlib, you will get a chance to see and
c steal every event that comes through during a READ from the output window.  If
c you handle the event you should set the .what field to 0 so the FORTRAN
c runtime code won't try to handle the event again.
c-
!!SETC USINGINCLUDES = .FALSE.
!!T72-
        include 'types.f'
        include 'Windows.f'
        include 'Events.f'
        include 'QDOffscreen.f'
        include 'Quickdraw.f'
        include 'globals.f'
c
        integer  OutputWindow
        external OutputWindow
c
        record /EventRecord/    TheEvent
        record /WindowPtr/      wptr
        record /GWorldptr/      oldGWorld
        record /GDHandle/       oldGDHandle
        record /CWindowPtr/     myCWindow
        record /GWorldptr/      myGWorld
        record /GDHandle/       mywGDHandle,mygGDHandle
        record /RGBcolor/       colorblack,colorwhite
        record /PixMapHandle/   myPixMapHandle
        record /grafport/       myGport
c       record /TEHandle/       myTEHandle
        logical jclgra,jfrmst,jmouse
        common /mpwevt/jclgra,jfrmst,jmouse,ixcur,iycur,
     #  myCWindow,myGWorld,mywGDHandle,mygGDHandle,colorblack,
     #  colorwhite,myGport
        integer*2 WindowPart
        logical jdone,jevdon,jlocal
        save
        data jdone/.false./
c
        if(.not.jdone)then
         call F_AboutString(
     #   '         Program and libraries',
     #   '             written by',
     #   '            C.Th. de Laat',
     #   'Physics department, Utrecht University',
     #   '   (all rights reserved 1988 - 1995)')
         call F_GetOutWindowSize(il,it,ir,ib)
         call MoveOutWindow(10,it,542,ib)
         call OutWindowScroll(9999)
         jdone=.true.
         jfrmst=.true.
        endif
        jevdon=.false.
c
        if(TheEvent.what.eq.nullEvent)then
        elseif(TheEvent.what.eq.mouseDown)then
         WindowPart = FINDWindow(TheEvent.Where,%ref(wptr))
         if(WindowPart.eq.inDesk)then
         elseif(WindowPart.eq.inMenuBar)then
cccc      if(myCWindow.P.eq.FrontWindow())jevdon=.true.
         elseif(WindowPart.eq.inSysWindow)then
          call SystemClick(theEvent,wptr)
          jevdon=.true.
         elseif(WindowPart.eq.inContent)then
          if(wptr.P .eq. myCWindow.P)then
           if(wptr.P.eq.FrontWindow())jmouse=.true.
           jevdon=.true.
          endif
          if(wptr.P.ne.FrontWindow())call SelectWindow(wptr.P)
         elseif(WindowPart.eq.inDrag)then
          if(wptr.P.ne.FrontWindow())call SelectWindow(wptr.P)
          if(wptr.P.eq.myCWindow.P)then
!!IFC NOT LSPOWERF
        QDG = JQDGLOBALS()
!!ELSEC
        QDG = %loc(qd)
!!ENDC
           call DragWindow(wptr,TheEvent.where,QDG^.screenbits.bounds)
           ier=UpdateGWorld(%ref(myGWorld.P),int2(0),
     #     myCWindow.P^.portrect,nil,nil,clipPix)
           jevdon=.true.
          endif
         elseif(WindowPart.eq.inGrow)then
         elseif(WindowPart.eq.inGoAway)then
          if(wptr.P .eq. OutputWindow() )then
           jlocal = TrackGoaway(wptr,TheEvent.where)
           if(jlocal.and.myCWindow.P.ne.nil)then
            call SelectWindow(myCWindow.P)
           endif
           jevdon=.true.
          elseif(wptr.P .eq. myCWindow.P)then
           jlocal = TrackGoaway(wptr,TheEvent.where)
           jclgra = jclgra.or.jlocal
           if(jlocal.and.OutputWindow().ne.nil)then
            call SelectWindow( %val(OutputWindow()) )
           endif
           jevdon=.true.
          endif
         endif
        elseif(TheEvent.what.eq.mouseUp)then
        elseif(TheEvent.what.eq.keyDown)then
        elseif(TheEvent.what.eq.keyUp)then
        elseif(TheEvent.what.eq.autoKey)then
        elseif(TheEvent.what.eq.updateEvt)then
         if(TheEvent.message.eq.myCWindow.P)then
          call BeginUpdate(TheEvent.message)
          call GetGWorld(%ref(oldGWorld),%ref(oldGDHandle))
          call SetGWorld(myCWindow,mywGDHandle)
          call RGBForeColor(colorblack)
          call RGBBackColor(colorwhite)
          ier=LockPixels(myGWorld.P^.portPixMap)
          myPixMapHandle.H=GetGWorldPixMap(myGWorld)
          call copybits(
     #        myPixMapHandle.H^.P^,myCWindow.P^.portPixMap.H^.P^,
     #        myGWorld.P^.portrect,myCWindow.P^.portrect,
     #        srccopy             ,myCWindow.P^.visrgn)
          call UnlockPixels(myGWorld.P^.portPixMap)
          ixcur=-11111
          iycur=-11111
          call SetGWorld(oldGWorld,oldGDHandle)
          call EndUpdate(TheEvent.message)
          jevdon=.true.
ccccc
c        elseif(TheEvent.message.eq.OutputWindow())then
c         call BeginUpdate(TheEvent.message)
c         call F_DRAWOUTPWINDOW
c         call DrawControls(TheEvent.message)
c         call DrawGrowIcon(TheEvent.message)
c         call EndUpdate(TheEvent.message)
c         jevdon=.true.
ccccc
         endif
        elseif(TheEvent.what.eq.diskEvt)then
        elseif(TheEvent.what.eq.activateEvt)then
        elseif(TheEvent.what.eq.networkEvt)then
        elseif(TheEvent.what.eq.driverEvt)then
        elseif(TheEvent.what.eq.app1Evt)then
        elseif(TheEvent.what.eq.app2Evt)then
        elseif(TheEvent.what.eq.app3Evt)then
        elseif(TheEvent.what.eq.osEvt)then
         if(iand(ishft(theEvent.message,-24),suspendResumeMessage).ne.0)
     #   jfrmst=iand(theEvent.message,resumeFlag).ne.0
        endif
        if(jevdon)TheEvent.what=0
        return
        end
+SELF.
+DECK,  IMACPLO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:59  mclareni
* Higz
+SELF, IF=MACMPW.

!!IFC NOT LSPOWERF
!!mp 68kinlines
!!ELSEC
!!mp PPCinlines
!!ENDC
        subroutine  macplo(ix,iy,ip)
        entry      imacplo(ix,iy,ip)
c+
c       subroutine  macplo(ix,iy,ip)
c       entry      imacplo(ix,iy,ip)
c
c device plot routine for Macintosh screen in MPW-LS-fortran window.
c This routine is also usable as interface under the CERN-higz package.
c
c Normally ix and iy are integer plot coordinates, they should range
c from 0 inclusive to some upper bound in both directions.
c The point (0,0) should be at the left bottom corner, the positive
c x axis to the right and the positive y axis is upwards.
c
c ip is the function code (those preceded by * are supported):
c*ip =  999     close plot, it is ready
c*ip = 31       give back type of device
c               ix is device, iy = 1 = screen with cursor readout,
c                             iy = 2 = screen without cursor readout,
c                             iy = 3 = plotter
c                             iy = 4 = file.
c*ip = 11 - 30  give back characters of names of devices
c               ix is device, iy contains character ip-10
c*ip = 10       give back number of defined devices in ix
c               give back capabillities in iy:
c               iy=  1 = can do clipping
c                   +2 = can do polyfill
c                   +4 = can do block fill
c                   +8 = can do pen clear
c                  +16 = can do pen invert
c*ip =  9       set pen width (ix) and height (iy)
c*ip = -8       unset clipping rectangle
c*ip =  8       set clipping rectangle from old position to ix,iy
c*ip =  7       end defining and draw filled polygon with color
c       ix=style, iy=pattern number
c       ix=0=hollow
c       ix=1=solid
c       ix=2=pattern
c       ix=3=pattern
c*ip =  6       start defining polygon, ix,iy is starting point
c*ip =  5       fill rectangle from old position to ix,iy with color
c*ip =  4       set pen to color ix (mod iy)
c               coding of color in big color pallette
c               ix = ired + iy*igreen + iy**2 * iblue
c*ip =  3       set pen to clear mode
c*ip =  2       set pen to invert mode
c*ip =  1       set pen to set mode
c*ip =  0       move pen to new coordinates (ix,iy)
c*ip =  -1      draw line to new coordinates (ix,iy)
c*ip =  -2      initialize for new plot (clear screen, new paper)
c       ix = 1 tektronics shape (1024*780)
c       ix = 2 three quarter size tektronics shape (768*585)
c       ix = 3 half size tektronics shape (512*390)
c       ix = 4 quarter size tektronics shape (256*195)
c       ix = 5 full screen
c       ix = 6 higz_cern
c*ip =  -3      activates cursor and performes readout (request mode)
c*ip =  -13     activates cursor and performes readout (sample mode)
c*ip =  -4      give back maximum possible ix and iy coordinates
c*ip =  -14     give back position of window on display in ix and iy
c*ip =  -5      give back number of pixels (steps) per unit of length
c*ip =  -6      give back supported number of colors (2-16777216) (8)
c*ip =  -999    stop plotting for the moment, it will continue later,
c               in the mean time terminal i/o might be undertaken.
c*ip =  -9999   bring graphics window to the front
c
c Function codes 10-31 are special and used to inform the software layer
c above about available devices. These calls (10-31) are also passed to the
c underlying layer but can be done also if there is no device open.
c-
!!SETC USINGINCLUDES = .FALSE.
!!T72-
        include 'types.f'
        include 'OSUtils.f'
        include 'Windows.f'
        include 'QDOffscreen.f'
        include 'Quickdraw.f'
        include 'globals.f'
c
        integer    minus1
        parameter (minus1 = -1)
        record /Cursor/         mycursor
        record /rect/           bounds,localrect,myportrect,updaterect
        record /WindowPeek/     front
        record /SysEnvRec/      myenv
        record /PolyHandle/     mypoly
        record /Point/          pnLoc,pnt1,pnt2
        record /CWindowPtr/     myCWindow
        record /GWorldptr/      myGWorld,tmpGWorld
        record /RGBcolor/       currcolor,colorblack,colorwhite
        record /GDHandle/       mywGDHandle,mygGDHandle,tmpGDHandle
        record /grafport/       myGport
        record /Pattern/        mypattern
        parameter (mxbf=500)
        logical jcdraw,jpoly
        logical jclgra,jfrmst,jmouse
        common /mpwevt/jclgra,jfrmst,jmouse,ixcur,iycur,
     #  myCWindow,myGWorld,
     #  mywGDHandle,mygGDHandle,colorblack,colorwhite,myGport,
     #  ixl(mxbf),iyl(mxbf),ipl(mxbf),updsec,mycursor,bounds,
     #  localrect,myportrect,updaterect,front,myenv,mypoly,pnLoc,
     #  currcolor,tmpGWorld,tmpGDHandle,jpoly,pnt1,pnt2
c
        logical jopn,jact,jfrm,jprev
        logical jtitle
        character chtit*(*)
        parameter (mxdv=8,mxnd=mxdv-1)
        character txt*80,cdev(mxdv)*20
        integer itdv(mxdv)
        integer ixpos(mxdv),iypos(mxdv),ixwid(mxdv),iywid(mxdv)
        string*255 title
        logical*1 visible,goAway
        integer*1 ipatt(8,9)
        save
        data ipatt/
     #  Z'aa',Z'55',Z'aa',Z'55',Z'aa',Z'55',Z'aa',Z'55',
     #  Z'44',Z'11',Z'44',Z'11',Z'44',Z'11',Z'44',Z'11',
     #  Z'00',Z'44',Z'00',Z'11',Z'00',Z'44',Z'00',Z'11',
     #  Z'80',Z'40',Z'20',Z'10',Z'08',Z'04',Z'02',Z'01',
     #  Z'20',Z'40',Z'80',Z'01',Z'02',Z'04',Z'08',Z'10',
     #  Z'44',Z'44',Z'44',Z'44',Z'44',Z'44',Z'44',Z'44',
     #  Z'00',Z'00',Z'00',Z'ff',Z'00',Z'00',Z'00',Z'ff',
     #  Z'11',Z'b8',Z'7c',Z'3a',Z'11',Z'a3',Z'c7',Z'8b',
     #  Z'10',Z'10',Z'28',Z'c7',Z'01',Z'01',Z'82',Z'7c'/
        data cdev/'s4_tek_screen','s3_tek_screen','s2_tek_screen',
     #  's1_tek_screen','mac_screen','macflat','machigh','higz_cern'/
        data ixpos/4,4,4,4,4,4,4,4/
        data iypos/40,40,40,40,40,40,40,40/
        data ixwid/1024,768,512,256,10000,580,290,620/
        data iywid/ 780,585,390,195,10000,290,580,436/
        data itdv/1,1,1,1,1,1,1,1/
        data jact/.false./,jopn/.false./,jtitle/.false./
        data nbfl/0/,ipenw/1/,ipenh/1/
c-----------------------------------------------------------------------
c first, check for the information function calls
c
        if(ip.ge.10.and.ip.le.31)then
         if(ip.eq.10)then
          ix=mxdv
          iy=1+2+4+8+16
         elseif(ip.eq.31)then
          iy=itdv(max(1,min(mxdv,ix)))
         else
          iy=ichar(cdev(max(1,min(mxdv,ix)))(ip-10:ip-10))
         endif
         return
        endif
c-----------------------------------------------------------------------
c in all cases except initialisation the workstation must be activated.
c
        if(.not.jopn.and.ip.ne.-2)return
        if(jopn.and..not.jact)then
         jact=.true.
         updsec=secnds(0.0)
        endif
c-----------------------------------------------------------------------
        if(ip.ge.-1.and.ip.le.9.or.ip.eq.-8)then
         nbfl=nbfl+1
         ixl(nbfl)=ix
         iyl(nbfl)=iy
         ipl(nbfl)=ip
         if(ip.eq.-1.or.ip.eq.0.or.ip.eq.5.or.ip.eq.8)then
          if(idev.le.mxnd)iyl(nbfl)=iyen-iyl(nbfl)
          ixl(nbfl)=ixl(nbfl)-ipenw/2
          iyl(nbfl)=iyl(nbfl)-ipenh/2
         elseif(ip.eq.9)then
          ipenw=max(ix,1)
          ipenh=max(iy,1)
         endif
         if(nbfl.lt.mxbf.and.abs(secnds(updsec)).le.1.0)return
        elseif(ip.eq.-4)then
         ix=ixen
         iy=iyen
         return
        elseif(ip.eq.-14)then
         ix=bounds.left
         iy=bounds.top
         return
        elseif(ip.eq.-5)then
         ix=min((ixen-ixbg+1)/10.24,(iyen-iybg+1)/7.80) + .001
         iy=ix
         return
        elseif(ip.eq.-6)then
         ix=mxcl
         iy=mxgr
         return
        endif
c-----------------------------------------------------------------------
c       in all cases except draw (modes) the buffer must be flushed
c
        if(jopn.and.nbfl.gt.0)then
         call GetGWorld(%ref(tmpGWorld.P),%ref(tmpGDHandle.H))
         call SetGWorld(myGWorld,mygGDHandle)
         ier=LockPixels(myGWorld.P^.portPixMap)
         do 10 i=1,nbfl
          if(ipl(i).eq.0)then
           call MoveTo(int2(ixl(i)),int2(iyl(i)))
           ixold=ixl(i)
           iyold=iyl(i)
           pnt2.h=ixl(i)
           pnt2.v=iyl(i)
          elseif(ipl(i).eq.-1)then
           call LineTo(int2(ixl(i)),int2(iyl(i)))
           ixold=ixl(i)
           iyold=iyl(i)
           pnt1=pnt2
           pnt2.h=ixl(i)
           pnt2.v=iyl(i)
           if(.not.jpoly)then
            call Pt2Rect(pnt1,pnt2,localrect)
            call unionrect(localrect,updaterect,updaterect)
           endif
          elseif(ipl(i).eq.9)then
           call PenSize(int2(ixl(i)),int2(iyl(i)))
          elseif(ipl(i).eq.-8)then
           call ClipRect(myGWorld.P^.portRect)
          elseif(ipl(i).eq.8)then
           if(idev.le.mxnd)then
            call setrect(localrect,int2(ixold),int2(iyl(i)),
     #                   int2(ixl(i)+1),int2(iyold+1))
           else
            call setrect(localrect,int2(ixold),int2(iyold),
     #                   int2(ixl(i)+1),int2(iyl(i)+1))
           endif
           call ClipRect(localrect)
          elseif(ipl(i).eq.7)then
           call ClosePoly
           if(ixl(i).eq.1)then
            call PaintPoly(mypoly)
           elseif(ixl(i).eq.2.or.ixl(i).eq.3)then
            np=max(1,min(9,iyl(i)))
            mypattern.pat(0)=ipatt(1,np)
            mypattern.pat(1)=ipatt(2,np)
            mypattern.pat(2)=ipatt(3,np)
            mypattern.pat(3)=ipatt(4,np)
            mypattern.pat(4)=ipatt(5,np)
            mypattern.pat(5)=ipatt(6,np)
            mypattern.pat(6)=ipatt(7,np)
            mypattern.pat(7)=ipatt(8,np)
            call FillPoly(mypoly,mypattern)
           else
            call FramePoly(mypoly)
           endif
           call unionrect(mypoly.H^.P^.polyBBox,updaterect,updaterect)
           call KillPoly(mypoly)
           jpoly=.false.
          elseif(ipl(i).eq.6)then
           mypoly.H=OpenPoly
           jpoly=.true.
          elseif(ipl(i).eq.5)then
           if(idev.le.mxnd)then
            call setrect(localrect,int2(ixold),int2(iyl(i)),
     #                   int2(ixl(i)+1),int2(iyold+1))
           else
            call setrect(localrect,int2(ixold),int2(iyold),
     #                   int2(ixl(i)+1),int2(iyl(i)+1))
           endif
           call paintrect(localrect)
           call unionrect(localrect,updaterect,updaterect)
          elseif(ipl(i).eq.4)then
           if(mxcl.gt.2.or.mxgr.gt.2)then
            ncl=max(2,iyl(i))
            fc=65535./float(ncl-1)
            ic=abs(ixl(i))
            currcolor.red  = nint(fc*mod(ic,ncl))
            ic=ic/ncl
            currcolor.green= nint(fc*mod(ic,ncl))
            ic=ic/ncl
            currcolor.blue = nint(fc*mod(ic,ncl))
            call RGBForeColor(currcolor)
           else
            if(ixl(i).eq.iyl(i)*iyl(i)*iyl(i)-1)then
             call RGBForeColor(colorwhite)
            else
             call RGBForeColor(colorblack)
            endif
           endif
          elseif(ipl(i).eq.3)then
           call PenMode(patBic)
          elseif(ipl(i).eq.2)then
           call PenMode(patXor)
          elseif(ipl(i).eq.1)then
           call PenMode(patCopy)
          endif
10       continue
         call UnlockPixels(myGWorld.P^.portPixMap)
         call SetGWorld(tmpGWorld,tmpGDHandle)
         nbfl=0
         if((ip.ge.-1.and.ip.le.9.or.ip.eq.-8).and.
     #   abs(secnds(updsec)).le.1.0)return
        endif
c-----------------------------------------------------------------------
        if(ip.eq.999)then
         call DisposeGWorld(myGWorld)
         myGWorld.P=nil
         call DisposeWindow(myCWindow.P)
         myCWindow.P=nil
         jopn=.false.
         jact=.false.
c-----------------------------------------------------------------------
        elseif(ip.eq.-2)then
         if(.not.jopn)then
          front.P=FrontWindow()
          if(front.P.eq.nil)write(6,*)' '
!!IFC NOT LSPOWERF
          ierror = SysEnvirons(curSysEnvVers,myenv)
          jcdraw = myenv.hasColorQD
          if(.not.jcdraw)then
           write(6,*)'macplo: Color Quickdraw is not installed!'
           write(6,*)'macplo: update your system.'
           return
          endif
          QDG = JQDGLOBALS()
!!ELSEC
          QDG = %loc(qd)
!!ENDC
          idev=max(1,min(mxdv,ix))
          isl=QDG^.screenbits.bounds.left   +  4
          isr=QDG^.screenbits.bounds.right  -  4
          ist=QDG^.screenbits.bounds.top    + 40
          isb=QDG^.screenbits.bounds.bottom -  4
c
          if(idev.ge.1.and.idev.le.mxnd)then
           call fclenv('plot_windowposition',txt)
           call plcwps(isl,isr,ist,isb,ixwid(idev),iywid(idev),
     #     txt,iwl,iwr,iwt,iwb)
           if(idev.le.4)then
            f=min(float(iwb - iwt + 1)/780.,float(iwr - iwl + 1)/1024.)
            iwb = iwt  + nint(f *  780.) - 1
            iwr = iwl  + nint(f * 1024.) - 1
           endif
          else
           iwr = min(isr,max(isl,ixpos(idev))+ixwid(idev))
           iwl = max(isl,iwr-ixwid(idev))
           iwb = min(isb,max(ist,iypos(idev))+iywid(idev))
           iwt = max(ist,iwb-iywid(idev))
          endif
c
          if(mod(iwr-iwl+1,2).eq.1)iwr=iwr+1
          if(mod(iwb-iwt+1,2).eq.1)iwb=iwb+1
          ixbg=0
          iybg=0
          ixen=iwr-iwl
          iyen=iwb-iwt
          bounds.right  = iwr
          bounds.left   = iwl
          bounds.bottom = iwb
          bounds.top    = iwt
c
          if(.not.jtitle)then
           write(txt,'(a,i5,a,i5,a)')
     #     'MacPlo =>',ixen+1,'*',iyen+1,' pixels'
           title   = txt(1:27)
          endif
          visible = .true.
          goAway  = .true.
          myCwindow.P=nil
          mywGDHandle.H=nil
          myGWorld.P=nil
          myCWindow.P = NewCWindow(nil,bounds,title,visible,
     #                  int2(noGrowDocProc),minus1,goAway,nil)
          call SetPort(myCWindow.P)
          myportrect=myCWindow.P^.portRect
          call ClipRect(myCWindow.P^.portRect)
          call PenMode(patCopy)
          colorblack.red   = 0
          colorblack.green = 0
          colorblack.blue  = 0
          colorwhite.red   = -1
          colorwhite.green = -1
          colorwhite.blue  = -1
          call RGBForeColor(colorblack)
          call RGBBackColor(colorwhite)
          call GetGWorld(%ref(myCWindow.P),%ref(mywGDHandle.H))
          mxcl=myCWindow.P^.portpixmap.H^.P^.pixelsize
          if(mxcl.eq.16)mxcl=15
          mxcl=2**max(1,min(24,mxcl))
          mxgr=min(256,mxcl)
          ier=NewGWorld(%ref(myGWorld.P),int2(0),bounds,nil,nil,nil)
          if(ier.ne.0)then
           call DisposeWindow(myCWindow.P)
           myCWindow.P=nil
           write(6,*)'macplo: GWorld creation failed, error:',ier
           write(6,*)'macplo: allocate more memory to this application'
           write(6,*)'bounds.right,bounds.left,bounds.bottom,bounds.top'
           write(6,*)bounds.right,bounds.left,bounds.bottom,bounds.top
           return
          endif
          mygGDHandle.H=nil
          jopn=.true.
          jact=.true.
         elseif(jtitle)then
          call SetWTitle(myCWindow.P,title)
         endif
c
         call SetGWorld(myGWorld,mygGDHandle)
         ier=LockPixels(myGWorld.P^.portPixMap)
         call RGBForeColor(colorblack)
         call RGBBackColor(colorwhite)
         call ClipRect(myGWorld.P^.portRect)
         call EraseRect(myGWorld.P^.portRect)
         call UnlockPixels(myGWorld.P^.portPixMap)
         nbfl=0
         jpoly=.false.
         updaterect=myportrect
c-----------------------------------------------------------------------
        elseif(ip.eq.-3.or.ip.eq.-13)then
c
         call SetGWorld(myCWindow,mywGDHandle)
         do 90 i=0,15
          mycursor.mask.bits(i)=$0000
90       continue
         mycursor.data=mycursor.mask
         mycursor.hotSpot.h=8
         mycursor.hotSpot.v=8
         ixcur=-11111
         iycur=-11111
         jfrm=.true.
c
100      jprev=jfrm
         jclgra=.false.
         jmouse=.false.
         call F_DoBackground
         jfrm=jfrmst
         if(.not.jprev.and.jfrm)then
110       if(button)goto 110
          goto 100
         endif
c
         if(jclgra)then
          ixx=0
          iyy=iyen
          goto 190
         endif
c
         if(myCWindow.P.ne.FrontWindow())goto 100
c
c       draw (parts of) new cursor and erase (parts of) old cursor
c
         call SetGWorld(myCWindow,mywGDHandle)
         if(.not.jfrm)then
          ixx=-11111
          iyy=-11111
         else
          call GetMouse(%ref(pnLoc))
          ixx=pnLoc.h
          iyy=pnLoc.v
         endif
         if(ixx.lt.0.or.ixx.gt.ixen.or.iyy.lt.0.or.iyy.gt.iyen)then
          ixx=-11111
          iyy=-11111
         endif
         if(ixx.ne.ixcur.or.iyy.ne.iycur)then
          call SetCursor(mycursor)
          if(ip.eq.-3)then
           call PenMode(patXor)
           if(ixx.ne.ixcur)then
            call MoveTo(int2(ixx),int2(iybg))
            call LineTo(int2(ixx),int2(iyen))
            call MoveTo(int2(ixcur),int2(iybg))
            call LineTo(int2(ixcur),int2(iyen))
            ixcur=ixx
           endif
           if(iyy.ne.iycur)then
            call MoveTo(int2(ixbg),int2(iyy))
            call LineTo(int2(ixen),int2(iyy))
            call MoveTo(int2(ixbg),int2(iycur))
            call LineTo(int2(ixen),int2(iycur))
            iycur=iyy
           endif
           call PenMode(patCopy)
          endif
         endif
c
         if(ixx.ge.0.and.ixx.le.ixen.and.iyy.ge.0.and.iyy.le.iyen)then
          if(jmouse.or.ip.eq.-13)then
130        if(button)goto 130
           goto 190
          endif
         else
          call InitCursor
         endif
         goto 100
c
190      call PenMode(patXor)
         call MoveTo(int2(ixcur),int2(iybg))
         call LineTo(int2(ixcur),int2(iyen))
         call MoveTo(int2(ixbg),int2(iycur))
         call LineTo(int2(ixen),int2(iycur))
         call PenMode(patCopy)
         call InitCursor
         ix=max(0,min(ixen,ixx))
         iy=max(0,min(iyen,iyy))
         if(idev.le.mxnd)iy=iyen-iy
c-----------------------------------------------------------------------
        elseif(ip.eq.-999)then
         jact=.false.
c-----------------------------------------------------------------------
        elseif(ip.eq.-9999)then
         front.P=FrontWindow()
         if(front.P^.windowKind.ne.dBoxProc)then
ccc       call GetGWorld(%ref(tmpGWorld.P),%ref(tmpGDHandle.H))
          call SetGWorld(myCWindow,mywGDHandle)
          call SelectWindow(myCWindow)
ccc       call SetGWorld(tmpGWorld,tmpGDHandle)
         endif
        endif
c-----------------------------------------------------------------------
        if(jopn)then
         if(.not.EmptyRect(updaterect))then
ccc       call GetGWorld(%ref(tmpGWorld.P),%ref(tmpGDHandle.H))
          call SetGWorld(myCWindow,mywGDHandle)
          updaterect.left  =updaterect.left  -ipenw/2
          updaterect.top   =updaterect.top   -ipenh/2
          updaterect.right =updaterect.right +ipenw
          updaterect.bottom=updaterect.bottom+ipenh
          call InvalRect(updaterect)
          call SetRect(updaterect,int2( 10000),int2( 10000),
     #                            int2(-10000),int2(-10000))
ccc       call SetGWorld(tmpGWorld,tmpGDHandle)
         endif
         call F_DoBackground
         updsec=secnds(0.0)
        endif
        return
c-----------------------------------------------------------------------
        entry imsettit(lentit,chtit)
        if(lentit.gt.0.and.lentit.le.255)then
         title=chtit(1:lentit)
         jtitle=.true.
        else
         jtitle=.false.
        endif
        return
c-----------------------------------------------------------------------
        entry imsetwsz(ixp,iyp,ixw,iyh)
        ixpos(5)=ixp
        iypos(5)=iyp
        ixwid(5)=ixw
        iywid(5)=iyh
        ixpos(6)=ixp
        iypos(6)=iyp
        ixwid(6)=ixw
        iywid(6)=iyh
        return
c-----------------------------------------------------------------------
        entry imgetds(idxp,idyp,idxw,idyh)
!!IFC NOT LSPOWERF
        QDG = JQDGLOBALS()
!!ELSEC
        QDG = %loc(qd)
!!ENDC
        idxp=QDG^.screenbits.bounds.left
        idyp=QDG^.screenbits.bounds.top
        idxw=QDG^.screenbits.bounds.right  - QDG^.screenbits.bounds.left
        idyw=QDG^.screenbits.bounds.bottom - QDG^.screenbits.bounds.top
        return
c-----------------------------------------------------------------------
        entry imgetms(im)
        if(jmouse)then
         im=2
        else
         im=0
        endif
        end
+SELF.
+DECK,  IMCLIP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:59  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imclip(ix,iy,iw,ih)
c+
c       subroutine imclip(ix,iy,iw,ih)
c
c Set clipping to the rectangle ix,iy,iw,ih
c-
      call imacplo(ix,iy,0)
      call imacplo(ix+iw,iy+ih,8)
      end
+SELF.
+DECK,  IMCLRWI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imclrwi
c+
c       subroutine imclrwi
c
c Clears the window. If the window is not open, it will be opened.
c-
      call imacplo(ima,idm,10)
      call imacplo(ima,0,-2)
      end
+SELF.
+DECK,  IMCLSDS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imclsds
c+
c       subroutine imclsds
c
c Closes window.
c-
      call imacplo(0,0,999)
      end
+SELF.
+DECK,  IMCLSWI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imclswi
c+
c       subroutine imclswi
c
c Closes window.
c-
      call imacplo(0,0,999)
      end
+SELF.
+DECK,  IMDRMDE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imdrmde(mode)
c+
c       subroutine imdrmde(mode)
c
c Set drawing mode
c mode = 1 = pixels are set
c mode = 2 = xor mode
c-
      if(mode.eq.1)then
         call imacplo(0,0,1)
      elseif(mode.eq.2)then
         call imacplo(0,0,2)
      endif
      end
+SELF.
+DECK,  IMFLARE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:01  mclareni
* Higz
+SELF, IF=MACMPW.

        subroutine imflare(n,ixy)
c+
c       subroutine imflare(n,ixy)
c
c Draw a line trough the points given in ixy(2,n)
c n     <= integer, number of points
c ixy   <= integer array, set of points to draw the line through.
c
c style = 0 = hollow
c         1 = solid
c         2 = pattern
c         3 = hatch
c-
      integer ixy(2,*),ixyloc(2,5)
      data indxf/1/,istyl/0/,ifasi/2/
      save indxf,istyl,ifasi
c
      call imsetcc(indxf)
      call imacplo(0,0,6)
      ip=0
      do 10 i=1,n
          call imacplo(ixy(1,i),ixy(2,i),ip)
        ip=-1
   10 continue
      call imacplo(istyl,ifasi,7)
      return
c-----------------------------------------------------------------------
      entry imsetfc(index)
      indxf=index
      return
c-----------------------------------------------------------------------
      entry imsetfs(istyle,ifasii)
      istyl=max(0,min(3,istyle))
      ifasi=ifasii
      if(ifasi.le.0.or.ifasi.gt.9)ifasi=2
      return
c-----------------------------------------------------------------------
      entry imbox(ix1,ix2,iy1,iy2,mode)
c+
c       subroutine imbox(ix1,ix2,iy1,iy2,mode)
c Draws a rectangle
c mode not equals 0 rect = filled with current color.
c-
      if(mode.eq.0)then
        ixyloc(1,1)=ix1
        ixyloc(2,1)=iy1
        ixyloc(1,2)=ix2
        ixyloc(2,2)=iy1
        ixyloc(1,3)=ix2
        ixyloc(2,3)=iy2
        ixyloc(1,4)=ix1
        ixyloc(2,4)=iy2
        ixyloc(1,5)=ix1
        ixyloc(2,5)=iy1
        call imline(5,ixyloc)
      else
        call imsetcc(indxf)
        call imacplo(min(ix1,ix2),min(iy1,iy2),0)
        call imacplo(max(ix1,ix2),max(iy1,iy2),5)
      endif
      end
+SELF.
+DECK,  IMGETGE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imgetge(iwid,ix,iy,iw,ih)
c+
c       subroutine imgetge(iwid,ix,iy,iw,ih)
c
c iwid smaller than zero, returns display size, otherwise open window size.
c-
      if(iwid.lt.0)then
         call imgetds(ix,iy,iw,ih)
      else
         call imacplo(ix,iy,-14)
         call imacplo(iw,ih,-4)
      endif
      end
+SELF.
+DECK,  IMLINE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imline(n,ixy)
c+
c       subroutine imline(n,ixy)
c
c Draw a line trough the points given in ixy(2,n)
c n     <= integer, number of points
c ixy   <= integer array, set of points to draw the line through.
c-
      integer ixy(2,*)
      data indxl/1/
      save
c
      call imsetcc(indxl)
      ip=0
      do 10 i=1,n
         call imacplo(ixy(1,i),ixy(2,i),ip)
         ip=-1
   10 continue
      return
c-----------------------------------------------------------------------
      entry imsetlc(index)
      indxl=index
      return
c-----------------------------------------------------------------------
      end
+SELF.
+DECK,  IMNOCLI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imnocli
c+
c       subroutine imnocli
c
c Remove clipping.
c-
      call imacplo(0,0,-8)
      end
+SELF.
+DECK,  IMOPNWI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      integer function imopnwi(ix,iy,iw,ih,lentit,chtit)
c+
c       integer function imopnwi(ix,iy,iw,ih,lentit,chtit)
c
c Opens a window on the screen at position ix,iy. Size of the window
c will be iw * ih pixels. Coordinates on display and in the window are
c increasing from top to down and from left to right.
c
c ix,iy,iw,iy <= integer, position and size of window
c lentit      <= integer, length of the window title. If a zero or negative
c                number is supplied, a default title will be generated.
c chtit       <= character string, title for the window.
c imopnwi     => integer, return status, -1 is failure.
c It is possible to open only one grapics window.
c-
      character chtit*(*)
      call imsettit(lentit,chtit)
      call imsetwsz(ix,iy,iw,ih)
      call imacplo(ima,idm,10)
      call imacplo(ima,0,-2)
      i=0
      j=0
      call imacplo(i,j,-4)
      if(i.eq.0.or.j.eq.0)then
         imopnwi=-1
      else
         imopnwi=0
         call imsetco(0,1.,1.,1.)
         call imsetco(1,0.,0.,0.)
      endif
      end
+SELF.
+DECK,  IMREQLO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      integer function imreqlo(mode,ityp,ix,iy)
c+
c       integer function imreqlo(mode,ityp,ix,iy)
c locator request, always crosshair,
c mode = 0 normal mode
c mode = 1 sampling mode
c-
      if(mode.eq.0)then
         call imacplo(ix,iy,-3)
         imreqlo=2
      elseif(mode.eq.1)then
         call imacplo(ix,iy,-13)
         call imgetms(imreqlo)
      endif
      end
+SELF.
+DECK,  IMSETCO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:00  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imsetco(index,r,g,b)
c+
c       subroutine imsetco(index,r,g,b)
c Set color r,g,b for index. The requested color will be mapped to the
c closest available color in the map of the screen.
c
c Color index management, index between 0 and 255 inclusive.
c-
      parameter (mxcl=1000)
      integer irgb(0:255),indold
      save
      data irgb/256*0/,indold/-1/
c
      indold=-1
      if(index.ge.0.and.index.le.255)then
         if(r.ge.0..and.r.le.1..and.
     +      g.ge.0..and.g.le.1..and.
     +      b.ge.0..and.b.le.1.)then
            ir=nint(r*(mxcl-1))
            ig=nint(g*(mxcl-1))
            ib=nint(b*(mxcl-1))
            irgb(index)=ir+(ig+ib*mxcl)*mxcl
         endif
      endif
      return
c-----------------------------------------------------------------------
      entry imgetcol(index,r,g,b)
c+
c returns the requested color mapping of the index, not the on screen
c actual!!!
c+
      if(index.ge.0.and.index.le.255)then
         fc=1./float(mxcl-1)
         ic=irgb(index)
         r=nint(fc*mod(ic,mxcl))
         ic=ic/mxcl
         g=nint(fc*mod(ic,mxcl))
         ic=ic/mxcl
         b=nint(fc*mod(ic,mxcl))
      endif
      return
c-----------------------------------------------------------------------
      entry imsetcc(index)
c+
c       entry imsetcc(index)
c sets the color for all following drawing operations.
c=
      if(index.ge.0.and.index.le.255.and.index.ne.indold)then
         indold=index
         call imacplo(irgb(indold),mxcl,4)
      endif
      end
+SELF.
+DECK,  IMSETLN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:01  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imsetln(iwidth)
c+
c       subroutine imsetln(iwidth)
c
c Set line width in pixels.
c-
      call imacplo(iwidth,iwidth,9)
      end
+SELF.
+DECK,  IMSETMS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:01  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imsetms(itype,n,ixy)
c+
c       subroutine imsetms(itype,n,ixy)
c
c Set marker type. The definition is the same as for the corresponding
c ixsetms routine, but the filled polygon routines are not implemented and
c will only produce the hollow shapes.
c
c itype    <= integer, marker type
c n        <= integer, number of points in ixy
c ixy(2,n) <= integer, array of x,y points in ixy(2,n)
c       n.eq.0 Marker is a single point
c       itype = 0 or 1, Marker is hollow circle of diameter N
c       itype = 2 or 3, Marker is hollow polygon described by ixy
c       itype = 4, Marker is described by segmented line ixy
c-
      integer ixy(2,*),mkxy(2,40)
      save
      data mktp/-1/,mknn/0/,nmkc/1/
c
      if(n.le.0.or.itype.lt.0.or.itype.gt.4)then
         mktp=-1
         mknn=0
      elseif(itype.eq.0.or.itype.eq.1)then
         mktp=itype
         fac=2.*3.14159264358/32.
         nr=max(1,n/2)
         mkxy(1,1)=nr
         mkxy(2,1)=0
         mknn=2
         do 10  i=2,32
            phi=float(i-1)*fac
            mkxy(1,mknn)=nint(nr*cos(phi))
            mkxy(2,mknn)=nint(nr*sin(phi))
            if(mkxy(1,mknn-1).ne.mkxy(1,mknn).or. mkxy(1,mknn-1)
     +      .ne.mkxy(1,mknn))mknn=mknn+1
   10    continue
         mkxy(1,mknn)=mkxy(1,1)
         mkxy(2,mknn)=mkxy(2,1)
      elseif(itype.eq.2.or.itype.eq.3.or.itype.eq.4)then
         mktp=itype
         mknn=min(n,40)
         do 20  i=1,mknn
            mkxy(1,i)=ixy(1,i)
            mkxy(2,i)=ixy(2,i)
   20    continue
      endif
      return
c-----------------------------------------------------------------------
      entry imsetmc(index)
c+
c       entry imsetmc(index)
c
c Set color index for markers
c index <= integer, index of color defined previously by imsetco
c-
      nmkc=index
      return
c-----------------------------------------------------------------------
      entry immarke(n,ixy)
c+
c       entry immarke(n,ixy)
c Sets a marker at each of the points in ixy
c
c ixy   <= integer, array of points where marker will be drawn.
c-
      call imsetcc(nmkc)
      do 40 i=1,n
         ixo=ixy(1,i)
         iyo=ixy(2,i)
         if(mktp.eq.-1)then
            call imacplo(ixo,iyo,0)
            call imacplo(ixo,iyo,-1)
         elseif(mktp.ge.0.and.mktp.le.4)then
            ip=0
            do 30 j=1,mknn
               ix=ixy(1,i)+mkxy(1,j)
               iy=ixy(2,i)+mkxy(2,j)
               call imacplo(ix,iy,ip)
               if(mktp.eq.4)then
                  ip=-1-ip
               else
                  ip=-1
               endif
   30       continue
         endif
   40 continue
      end
+SELF.
+DECK,  IMUPDWI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:11:01  mclareni
* Higz
+SELF, IF=MACMPW.

      subroutine imupdwi
c+
c       subroutine imupdwi
c
c the window is updated and moved to the top of the stack.
c-
      call imacplo(0,0,-999)
      end
+SELF.
+PATCH, IKERNEL.
+DECK,  IACWK, T=FORT.
* Revision 1.2  1996/09/25 14:58:40  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE IACWK(IWKID)
      ENTRY      GACWK(IWKID)
+CDE, HIFLAG.
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=MSDOS.
+CDE, HIMETA.
+SELF, IF=X11.
      INTEGER DASHED(2),DOTTED(2),DSHDOT(4)
      DATA DASHED/5,5/
      DATA DOTTED/1,3/
      DATA DSHDOT/5,3,1,3/
+SELF, IF=-BATCH.
      IF(IWKID.EQ.0)THEN
         CALL IGERR('Workstation identifier equal 0','IACWK')
         RETURN
      ENDIF
      DO 10 I=1,INOPWK
         IF(ILOPWK(I).EQ.IWKID)THEN
            ACWKFL(I)=.TRUE.
            IF(IWTYL(I).LE.0)THEN
               NODRFL(I)=.TRUE.
            ELSE
               NODRFL(I)=.FALSE.
            ENDIF
            IWKIND=I
            GOTO 20
         ENDIF
   10 CONTINUE
      CALL IGERR('Workstation is not open','IACWK')
      RETURN
   20 CONTINUE
+SELF, IF=MSDOS.
      ISAVE = IWKNB
      IWKNB = IWKIND
+SELF, IF=PSCRIPT.
*
*              Active the PostScript metafile
*
      IF(IGIWTY(IWKID).LT.0)THEN
         PFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         RETURN
      ENDIF
+SELF, IF=KERNEL.
*
*              Initialise the default attributes for the screen
*
      CALL IGSG(IWKIND)
+SELF, IF=GL, IF=-MSDOS.
      CALL COLOR(IPLCI+IOFCOL)
      ICURCI(IWKIND)=IPLCI
      IF(IFAIS.LE.1)THEN
         CALL SETPAT(0)
      ELSE
         CALL SETPAT(IFASI)
      ENDIF
      CALL SETLIN(ILN-1)
      CALL LINEWI(INT(RLWSC))
*
+SELF, IF=MSDOS.
      CALL COLOR(IPLCI+IOFCOL)
      ICURCI(IWKIND)=IPLCI
      IF(IFAIS.LE.1)THEN
         CALL SETPAT(0)
      ELSE
         CALL SETPAT(IFASI)
      ENDIF
      CALL SETLIN(ILN)
      CALL LINEWI(INT(RLWSC))
      IF(IWKID.EQ.IDMETA)THEN
         IF(IWTYL(IWKNB).EQ.ISURF)THEN
            XMFACT = 1.0
            YMFACT = 1.0
         ENDIF
      ENDIF
      IWKNB = ISAVE
*
+SELF, IF=FALCO.
      IF(IGIWTY(IWKID).EQ.7878)RETURN
      IF(IGIWTY(IWKID).EQ.7879)THEN
         CALL IGSA(0)
         RETURN
      ENDIF
+SELF, IF=X11.
      CALL IXSELWI(IWINID(IWKIND))
      CALL IXSETFC(IFACI)
      CALL IXSETLC(IPLCI)
      CALL IXSETMC(IPMCI)
      CALL IXSETTC(ITXCI)
      CALL IXSETFS(MIN(1,IFAIS),0)
+SELF, IF=X11, IF=-WINNT.
      IF(ILN.EQ.1)CALL IXSETLS(0,0)
      IF(ILN.EQ.2)CALL IXSETLS(2,DASHED)
      IF(ILN.EQ.3)CALL IXSETLS(2,DOTTED)
      IF(ILN.EQ.4)CALL IXSETLS(4,DSHDOT)
+SELF, IF=X11, IF=WINNT.
      CALL IXSETLS(-ILN, 0)
+SELF, IF=X11.
      CALL IXSETLN(MAX(INT(RLWSC/2.2),1))
      CALL IXSETTA(ITXALH,ITXALV)
*
+SELF, IF=KERNEL.
      CALL IGSA(0)
+SELF.
      END
+DECK,  ICLKS, T=FORT.
* Revision 1.2  1996/09/25 14:58:40  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE ICLKS
      ENTRY      GCLKS
+CDE, HIATT.
      DIMENSION ICLSWK(10)
      IEND = INOPWK
      DO 10 I=1,IEND
         ICLSWK(I) = ILOPWK(I)
   10 CONTINUE
      DO 20 I=1,IEND
         CALL ICLWK(ICLSWK(I))
   20 CONTINUE
+SELF, IF=X11.
      CALL IXCLSDS
+SELF, IF=MACMPW.
      CALL IMCLSDS
+SELF, IF=PHIGS.
      CALL PCLPH
+SELF.
      END
+DECK,  ICLRWK, T=FORT.
* Revision 1.3  1998/01/28 14:34:40  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:41  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

+SELF, IF=-MSDOS.
      SUBROUTINE ICLRWK(IWKID,ICOFL)
      ENTRY      GCLRWK(IWKID,ICOFL)
+SELF, IF=-MSDOS, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=-MSDOS.
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION RVAL(2)
*
      IF(GFLAG)THEN
+SELF, IF=-MSDOS, IF=KERNEL,FALCO,PHIGS.
         IF(IWKID.EQ.0)THEN
            DO 10 I=1,INOPWK
               IF(NODRFL(I))GOTO 10
               CALL IGQWK(ILOPWK(I),'MXDS',RVAL)
               IF((REDIT.NE.0).AND.(REDIT.NE.1.))THEN
                  CALL IGCLES
               ELSE
                  CALL IGSG(I)
+SELF, IF=-MSDOS, IF=FALCO.
                  IF(IWTYL(I).EQ.7878.OR.IWTYL(I).EQ.7879)THEN
                     CALL IFCLR(IWTYL(I))
                     GOTO 10
                  ENDIF
+SELF, IF=-MSDOS, IF=GL.
                  CALL WINPOP
                  CALL SETPAT(0)
                  CALL COLOR(IOFCOL)
                  ICURCI(I)=0
                  CALL CLEAR
                  IF(IFAIS.GT.1)CALL SETPAT(IFASI)
+SELF, IF=-MSDOS, IF=X11.
                  CALL IXCLRWI
+SELF, IF=-MSDOS, IF=ZBUF.
                  IF (IZBUF.NE.0) CALL IHZCLE(0)
+SELF, IF=-MSDOS, IF=MACMPW.
                  CALL IMCLRWI
+SELF, IF=-MSDOS, IF=PHIGS.
                  CALL PXCLEAR_WS(ILOPWK(I))
+SELF, IF=-MSDOS, IF=KERNEL,FALCO,PHIGS.
               ENDIF
   10       CONTINUE
         ELSE
            IWT=IGIWTY(IWKID)
            IF(IWT.LE.0)GOTO 999
            CALL IGQWK(IWKID,'MXDS',RVAL)
            IF((REDIT.NE.0).AND.(REDIT.NE.1.))THEN
               CALL IGCLES
            ELSE
               I=IGIWIN(IWKID)
               CALL IGSG(I)
+SELF, IF=-MSDOS, IF=FALCO.
               IF(IWT.EQ.7878.OR.IWT.EQ.7879)THEN
                  CALL IFCLR(IWT)
                  GOTO 999
               ENDIF
+SELF, IF=-MSDOS, IF=GL.
               CALL WINPOP
               CALL SETPAT(0)
               CALL COLOR(IOFCOL)
               ICURCI(I)=0
               CALL CLEAR
               IF(IFAIS.GT.1)CALL SETPAT(IFASI)
+SELF, IF=-MSDOS, IF=X11.
               CALL IXCLRWI
+SELF, IF=-MSDOS, IF=ZBUF.
               IF (IZBUF.NE.0) CALL IHZCLE(0)
+SELF, IF=-MSDOS, IF=MACMPW.
               CALL IMCLRWI
+SELF, IF=-MSDOS, IF=PHIGS.
               CALL PXCLEAR_WS(IWKID)
+SELF, IF=-MSDOS, IF=KERNEL,FALCO,PHIGS.
            ENDIF
         ENDIF
+SELF, IF=-MSDOS.
      ENDIF
  999 CONTINUE
+SELF, IF=-MSDOS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZCLRD
+SELF, IF=-MSDOS.
      END
+SELF.
+DECK,  ICLWK, T=FORT.
* Revision 1.2  1996/09/25 14:58:42  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE ICLWK(IWKID)
      ENTRY      GCLWK(IWKID)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=PSCRIPT.
+CDE, HIPOST.
+SELF.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIMETA.
*
      IF(IGIWIN(IWKID).EQ.0)THEN
         CALL IGERR('This workstation is not open','ICLWK')
         RETURN
      ENDIF
+SELF, IF=-BATCH.
      IF(IGIWTY(IWKID).GT.0.AND.GFLAG)THEN
+SELF, IF=GL, IF=-MSDOS.
         CALL WINCLO(IWINID(IGIWIN(IWKID)))
+SELF, IF=MSDOS.
         IF(IGIWTY(IWKID).EQ.ISURF.AND.IWKID.EQ.IDMETA) THEN
            CALL GOLCLO
         ELSE
            CALL TEXT_MODE
         ENDIF
+SELF, IF=FALCO.
         ITY = IGIWTY(IWKID)
         IF(ITY.EQ.7878.OR.ITY.EQ.7879)THEN
            IWTYPE = 0
            GOTO 10
         ENDIF
+SELF, IF=X11.
         CALL IXSELWI(IWINID(IGIWIN(IWKID)))
         CALL IXCLSWI
+SELF, IF=MACMPW.
         CALL IMCLSWI
+SELF, IF=PHIGS.
         CALL PCLWK(IWKID)
+SELF, IF=-BATCH.
         GOTO 10
      ENDIF
+SELF, IF=PSCRIPT.
      IF(IGIWTY(IWKID).LT.0)THEN
         CALL IPEND
         IF(IWKID.EQ.IDMETA.AND.FILOPN)FILOPN=.FALSE.
         GOTO 10
      ENDIF
+SELF.
   10 CONTINUE
      DO 30 I=1,INOPWK
         IF(ILOPWK(I).EQ.IWKID)THEN
            INOPWK=INOPWK-1
            DO 20 J=I,INOPWK
               ILOPWK(J) = ILOPWK(J+1)
               IWTYL(J)  = IWTYL(J+1)
+SELF, IF=PSCRIPT.
               IF (IWTYL(J).LT.0) IPSI = J
+SELF.
               ACWKFL(J) = ACWKFL(J+1)
               XWKSIZ(J) = XWKSIZ(J+1)
               YWKSIZ(J) = YWKSIZ(J+1)
               WKMAX(J)  = WKMAX(J+1)
               IWINID(J) = IWINID(J+1)
               NODRFL(J) = NODRFL(J+1)
+SELF, IF=KERNEL.
               WKSC(J)   = WKSC(J+1)
               XWKR(J)   = XWKR(J+1)
               YWKR(J)   = YWKR(J+1)
               XWKW1(J)  = XWKW1(J+1)
               YWKW1(J)  = YWKW1(J+1)
               XWKV1(J)  = XWKV1(J+1)
               YWKV1(J)  = YWKV1(J+1)
               XWKW2(J)  = XWKW2(J+1)
               YWKW2(J)  = YWKW2(J+1)
               XWKV2(J)  = XWKV2(J+1)
               YWKV2(J)  = YWKV2(J+1)
+SELF.
   20       CONTINUE
            RETURN
         ENDIF
   30 CONTINUE
      END
+DECK,  IDAWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE IDAWK(IWKID)
      ENTRY      GDAWK(IWKID)
+CDE, HIFLAG.
+CDE, HIATT.
      DO 10 I=1,INOPWK
         IF(ILOPWK(I).EQ.IWKID)THEN
            ACWKFL(I)=.FALSE.
            NODRFL(I)=.TRUE.
            GOTO 20
         ENDIF
 10   CONTINUE
      CALL IGERR('Workstation is not active','IDAWK')
      RETURN
 20   CONTINUE
+SELF, IF=PSCRIPT.
      IF(IGIWTY(IWKID).LT.0)THEN
         PFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         RETURN
      ENDIF
+SELF.
      END
+DECK,  IFA, T=FORT.
* Revision 1.3  1998/01/28 14:34:41  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:43  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE IFA(N,X,Y)
      ENTRY      GFA(N,X,Y)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=FALCO,MACMPW.
      DIMENSION XCLOSE(2),YCLOSE(2)
+SELF.
      DIMENSION X(*),Y(*)
*
+SELF, IF=KERNEL.
+CDE, HIWCDC.
+SELF, IF=KERNEL.
      IF(N.LT.3.OR.N.GT.IBUFSI-1)THEN
         CALL IGERR('Invalid number of points','IFA')
         RETURN
      ENDIF
+SELF.
      IF(IFAIS.EQ.3.AND.IFASI.GE.100)THEN
         CALL IGFA(N,X,Y)
      ELSE
         IF(GFLAG)THEN
+SELF, IF=PHIGS.
            CALL PFA(N,X,Y)
+SELF, IF=KERNEL,FALCO.
            DO 70 IWKNB=1,INOPWK
               IF(NODRFL(IWKNB))GOTO 70
               CALL IGSG(IWKNB)
+SELF, IF=FALCO.
               IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)THEN
                  IF(IFAIS.EQ.1)THEN
                     CALL IGHATC(0.001,0.,N,X,Y)
                  ELSE
                     CALL IFPL(N,X,Y)
                     XCLOSE(1)=X(1)
                     YCLOSE(1)=Y(1)
                     XCLOSE(2)=X(N)
                     YCLOSE(2)=Y(N)
                     CALL IFPL(2,XCLOSE,YCLOSE)
                  ENDIF
                  GOTO 70
               ENDIF
+SELF, IF=GL, IF=-MSDOS.
               DO 20 I=1,N
                  IPOS(1,I)=IXWCDC(X(I))
                  IPOS(2,I)=IYWCDC(Y(I))
   20          CONTINUE
               IF(ICURCI(IWKNB).NE.IFACI)THEN
                  CALL COLOR(IFACI+IOFCOL)
                  ICURCI(IWKNB)=IFACI
               ENDIF
               IF(IFAIS.NE.0)THEN
                  CALL POLF2I(N,IPOS)
               ELSE
                  CALL POLY2I(N,IPOS)
               ENDIF
+SELF, IF=MSDOS.
               IF(IFAIS.EQ.1.AND.ILOPWK(IWKNB).EQ.IDMETA)THEN
                  CALL IGHATC(0.001,0.0,N,X,Y)
               ELSE
                  DO 30 I=1,N
+SELF, IF=MSDOS, IF=NDP.
                     IPOS(I,1)=IXWCDC(X(I))
                     IPOS(I,2)=IYWCDC(Y(I))
+SELF, IF=MSDOS, IF=-NDP.
                     IPOS(1,I)=IXWCDC(X(I))
                     IPOS(2,I)=IYWCDC(Y(I))
+SELF, IF=MSDOS.
   30             CONTINUE
                  IF(ICURCI(IWKNB).NE.IFACI)THEN
                     CALL COLOR(IFACI+IOFCOL)
                     ICURCI(IWKNB)=IFACI
                  ENDIF
                  IF(IFAIS.NE.0)THEN
                     CALL POLF2I(N,IPOS)
                  ELSE
                     CALL POLY2I(N,IPOS)
                  ENDIF
               ENDIF
+SELF, IF=X11.
               NP=N
               DO 40 I=1,NP
                  IPOS(1,I)=IXWCDC(X(I))
                  IPOS(2,I)=IYWCDC(Y(I))
   40          CONTINUE
+SELF, IF=X11, IF=-WINNT.
               IF(IFAIS.EQ.0)THEN
                  IPOS(1,NP+1)=IPOS(1,1)
                  IPOS(2,NP+1)=IPOS(2,1)
                  NP=NP+1
               ENDIF
+SELF, IF=X11.
               CALL IXFLARE(NP,IPOS)
+SELF, IF=MACMPW.
               NP=N
               DO 60 I=1,NP
                  IPOS(1,I)=IXWCDC(X(I))
                  IPOS(2,I)=IYWCDC(Y(I))
   60          CONTINUE
               IF(IFAIS.EQ.0)THEN
                  IPOS(1,NP+1)=IPOS(1,1)
                  IPOS(2,NP+1)=IPOS(2,1)
                  NP=NP+1
               ENDIF
               CALL IMFLARE(NP,IPOS)
+SELF, IF=KERNEL,FALCO.
   70       CONTINUE
+SELF.
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZFA(N,X,Y)
+SELF.
*
      END
+DECK,  IGSA, T=FORT.
* Revision 1.3  1998/01/28 14:34:41  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:44  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE IGSA(IWK)
+SELF, IF=FALCO.
+CDE, HIATT.
+SELF.
+CDE, HIFLAG.
+SELF, IF=FALCO.
      CHARACTER*4 CHREP
+SELF.
      IF(GRFLAG)THEN
         GRFLAG=.FALSE.
+SELF, IF=FALCO.
         IF(IWK.EQ.0)THEN
            DO 10 I=1,INOPWK
               IF(IWTYL(I).EQ.7878)THEN
                  CALL IFMOVE(0.,0.)
                  CALL IFPUT(0)
                  READ (*,'(A)') CHREP
                  CALL IFPUT(31)
                  CALL IFPUT(24)
                  CALL IFPUT(0)
                  GOTO 10
               ENDIF
               IF(IWTYL(I).EQ.7879)THEN
                  CALL IFPUT(27)
                  CALL IFPUT(3)
                  CALL IFPUT(0)
                  GOTO 10
               ENDIF
   10       CONTINUE
         ELSE
            IWT = IGIWTY(IWK)
            IF(IWT.EQ.7878)THEN
               CALL IFMOVE(0.,0.)
               CALL IFPUT(0)
               READ (*,'(A)') CHREP
               CALL IFPUT(31)
               CALL IFPUT(24)
               CALL IFPUT(0)
               RETURN
            ENDIF
            IF(IWT.EQ.7879)THEN
               CALL IFPUT(27)
               CALL IFPUT(3)
               CALL IFPUT(0)
               RETURN
            ENDIF
         ENDIF
+SELF, IF=MSDOS.
         CALL LOCATE(0,0)
+SELF, IF=MACMPW.
         CALL IMACPLO(0,0,-999)
+SELF.
      ENDIF
      END
+DECK,  IGSG, T=FORT.
* Revision 1.2  1996/09/25 14:58:45  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE IGSG(IWK)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=MSDOS.
+CDE, HIMETA.
+SELF.
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=MSDOS.
      PARAMETER (IVGA=18)
+SELF.
      IF(ICURWK.NE.IWK)THEN
+SELF, IF=FALCO.
         IF(IGIWTY(IWK).EQ.7878.OR.IGIWTY(IWK).EQ.7879)GOTO 10
+SELF, IF=GL.
         CALL WINSET(IWINID(IWK))
+SELF, IF=X11.
         CALL IXSELWI(IWINID(IWK))
+SELF.
         ICURWK=IWK
      ENDIF
   10 IF(.NOT.GRFLAG)THEN
+SELF, IF=MSDOS.
         IF(ILOPWK(IWK).NE.IDMETA)THEN
            I = GET_VIDEO_MODE(LRX,LCY)
            IF (I .GT. 0 .and. I .le. 7) THEN
              IF (IWTYL(IWK) .LE. IVGA+1) THEN
                 IER = GRAPHICS_MODE(IWTYL(IWK))
              ELSE
                 IER = SUPER_VGA(IWTYL(IWK), 800, 600)
              END IF
            END IF
            IF (IWTYL(IWK) .LT. IVGA) THEN
               IER = SET_PALETTE(PAL)
            ELSE
               CALL MAPCOL(0,1.,1.,1.)
               CALL MAPCOL(1,0.,0.,0.)
               CALL MAPCOL(2,1.,0.,0.)
               CALL MAPCOL(3,0.,1.,0.)
               CALL MAPCOL(4,0.,0.,1.)
               CALL MAPCOL(5,1.,1.,0.)
               CALL MAPCOL(6,1.,0.,1.)
               CALL MAPCOL(7,0.,0.,0.)
            END IF
         ENDIF
+SELF.
         GRFLAG=.TRUE.
+SELF, IF=FALCO.
         IF(IGIWTY(IWK).EQ.7879)THEN
            CALL IFPUT(27)
            CALL IFPUT(IGASCI('['))
            CALL IFPUT(IGASCI('?'))
            CALL IFPUT(IGASCI('3'))
            CALL IFPUT(IGASCI('8'))
            CALL IFPUT(IGASCI('h'))
            CALL IFPUT(0)
         ENDIF
+SELF.
      ENDIF
      END
+DECK,  IKBOX, T=FORT.
* Revision 1.2  1996/09/25 14:58:46  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

+SELF, IF=GL,X11,FALCO,MACMPW.
      SUBROUTINE IKBOX(X1,X2,Y1,Y2)
*.===========>
*.
*.   This routine draws a boxe. The boxe is drawn according to the
*. current fill area attributes. Most of the time the basic graphics
*. packages are able to draw boxes in a very fast way. This routines
*. access this type of facilities.
*.
*. _Input parameters:
*.
*.  REAL X1,Y1 : Left down corner (in WC).
*.  REAL X2,Y2 : Right up corner (in WC).
*.
*..==========> (O.Couet)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=GL,X11,FALCO,MACMPW.
+CDE, HIFLAG.
+CDE, HIATT.
      DIMENSION X(4),Y(4)
*.______________________________________
*
+SELF, IF=GL,X11,FALCO,MACMPW, IF=KERNEL.
+CDE, HIWCDC.
+SELF, IF=GL,X11,FALCO,MACMPW.
*
*              Draw the inside of the box with the portable
*              HIGZ hatches.
*
      IF(IFAIS.EQ.3.AND.IFASI.GE.100)THEN
         X(1)=X1
         X(2)=X2
         X(3)=X2
         X(4)=X1
         Y(1)=Y1
         Y(2)=Y1
         Y(3)=Y2
         Y(4)=Y2
         CALL IGFA(4,X,Y)
         GOTO 20
      ENDIF
+SELF, IF=GL,X11,FALCO,MACMPW, IF=FALCO.
      IF(IWTYPE.EQ.7878.OR.IWTYPE.EQ.7879)GOTO 20
+SELF, IF=GL,X11,FALCO,MACMPW, IF=KERNEL.
*
*              Draw the inside of the box with color or
*              device dependant pattern.
*
      IF(IFAIS.NE.0)THEN
         IF(GFLAG)THEN
            DO 10 IWKNB=1,INOPWK
               IF(NODRFL(IWKNB))GOTO 10
               CALL IGSG(IWKNB)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=GL.
               IX1=IXWCDC(X1)
               IX2=IXWCDC(X2)
               IY1=IYWCDC(Y1)
               IY2=IYWCDC(Y2)
               IF(IFAIS.NE.0)THEN
                  IF(ICURCI(IWKNB).NE.IFACI)THEN
                     CALL COLOR(IFACI+IOFCOL)
                     ICURCI(IWKNB)=IFACI
                  ENDIF
                  CALL SBOXFI(IX1,IY1,IX2,IY2)
               ENDIF
+SELF, IF=GL,X11,FALCO,MACMPW, IF=X11.
               IX1=IXWCDC(X1)
               IX2=IXWCDC(X2)
               IY1=IYWCDC(Y1)
               IY2=IYWCDC(Y2)
               MODE=1
               CALL IXBOX(IX1,IX2,IY1,IY2,MODE)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=MACMPW.
               IX1=IXWCDC(X1)
               IX2=IXWCDC(X2)
               IY1=IYWCDC(Y1)
               IY2=IYWCDC(Y2)
               MODE=1
               CALL IMBOX(IX1,IX2,IY1,IY2,MODE)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=KERNEL.
   10       CONTINUE
         ENDIF
      ENDIF
+SELF, IF=GL,X11,FALCO,MACMPW.
   20 CONTINUE
+SELF, IF=GL,X11,FALCO,MACMPW, IF=FALCO.
      IF(IWTYPE.EQ.7878.OR.IWTYPE.EQ.7879)THEN
         CALL IGSG(1)
         IF(GFLAG)THEN
            X(1)=X1
            X(2)=X2
            X(3)=X2
            X(4)=X1
            Y(1)=Y1
            Y(2)=Y1
            Y(3)=Y2
            Y(4)=Y2
            IF(IFAIS.EQ.1)CALL IGHATC(0.001,0.,4,X,Y)
            IF(IFAIS.EQ.0.OR.IBORD.EQ.1)THEN
               CALL IFPL(4,X,Y)
               X(2)=X(4)
               Y(2)=Y(4)
               CALL IFPL(2,X,Y)
            ENDIF
         ENDIF
         RETURN
      ENDIF
+SELF, IF=GL,X11,FALCO,MACMPW, IF=KERNEL.
*
*              Draw the border of the box
*
      IF(IFAIS.EQ.0.OR.IBORD.NE.0)THEN
         IF(GFLAG)THEN
            DO 30 IWKNB=1,INOPWK
               IF(NODRFL(IWKNB))GOTO 30
               CALL IGSG(IWKNB)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=GL.
               IX1=IXWCDC(X1)
               IX2=IXWCDC(X2)
               IY1=IYWCDC(Y1)
               IY2=IYWCDC(Y2)
               IF(ICURCI(IWKNB).NE.IPLCI)THEN
                  CALL COLOR(IPLCI+IOFCOL)
                  ICURCI(IWKNB)=IPLCI
               ENDIF
               CALL SBOXI(IX1,IY1,IX2,IY2)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=X11.
               IX1=IXWCDC(X1)
               IX2=IXWCDC(X2)
               IY1=IYWCDC(Y1)
               IY2=IYWCDC(Y2)
               MODE=0
               CALL IXBOX(IX1,IX2,IY1,IY2,MODE)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=MACMPW.
               IX1=IXWCDC(X1)
               IX2=IXWCDC(X2)
               IY1=IYWCDC(Y1)
               IY2=IYWCDC(Y2)
               MODE=0
               CALL IMBOX(IX1,IX2,IY1,IY2,MODE)
+SELF, IF=GL,X11,FALCO,MACMPW, IF=KERNEL.
   30       CONTINUE
         ENDIF
      ENDIF
+SELF, IF=GL,X11,FALCO,MACMPW.
*
      END
+SELF.
+DECK,  IKFILE, T=FORT.
* Revision 1.4  1998/01/30 15:22:36  couet
* - APOLLO version removed
* Revision 1.3  1998/01/28 14:34:42  couet
* - GGDM driver removed
* Revision 1.2  1997/10/23 12:29:55  mclareni
* NT mods
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS.
      SUBROUTINE IKFILE(IWTYP)
*.===========>
*.
*. Open the file higz_windows.dat :
*.
*.  1) in the current working directory
*.  2) in the HOME directory
*.  3) create this file in the home directory
*.     if it doesn't exits.
*.
*. and read in this file the informations concerning
*. the workstation type IWTYP
*.
*..==========>
+CDE, HIKERN.
      CHARACTER*64    UHOME
      CHARACTER*128   TNAME
      LOGICAL         INIT,OPND,EXIST1
      SAVE            INIT,LUHOME,UHOME
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=IBM.
      CHARACTER*24 CHREAD
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=CRAY.
      INTEGER         GETENV
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=X11, IF=IBM, IF=-IBMMVS.
      CHARACTER*3 CHLUN
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS.
      DATA            INIT   /.FALSE./
      DATA            LUHOME /0/
      DATA            UHOME  /' '/
*.______________________________________
*
      LUNWIN=20
      DO 10 I=20,99
         INQUIRE(UNIT=I,OPENED=OPND)
         IF(.NOT.OPND)THEN
            LUNWIN=I
            OPND=.TRUE.
            GOTO 20
         ENDIF
   10 CONTINUE
*
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=IBM.
   20 FILEN='/HIGZWIN DATA A'
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-IBM, IF=-IPSC.
   20 FILEN='higz_windows.dat'
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=IPSC.
   20 FILEN='higz_windows'
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-IBM.
*
      WINSIZ(1)=0
      WINSIZ(2)=0
      WINSIZ(3)=600
      WINSIZ(4)=600
      IF(.NOT.OPND)RETURN
*
      INQUIRE(FILE=FILEN,EXIST=EXIST1)
      IF(EXIST1)THEN
         OPEN(UNIT=LUNWIN,FILE=FILEN,FORM='FORMATTED',STATUS='OLD'
     +,       IOSTAT=ISTA)
         IF (ISTA.NE.0) THEN
            CALL IGERR('Cannot open higz_windows.dat','IKFILE')
            GOTO 999
         ELSE
            GOTO 50
         ENDIF
      ENDIF
*
      IF (.NOT.INIT) THEN
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=UNIX,CRAY.
         UHOME=' '
         CALL GETENVF('HOME',UHOME)
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=VAX.
         UHOME='SYS$LOGIN:'
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-IBM.
         LUHOME=LENOCC(UHOME)
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-VAX, IF=-IBM.
         IF (UHOME(LUHOME:LUHOME) .NE. '/'
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-VAX, IF=-IBM, IF=WINNT.
     *       .OR. UHOME(LUHOME:LUHOME) .NE. '\'
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-VAX, IF=-IBM.
     *                      ) THEN
           LUHOME=LUHOME+1
           UHOME(LUHOME:LUHOME)='/'
         ENDIF
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-IBM.
         INIT=.TRUE.
      ENDIF
*
      TNAME = FILEN
      FILEN = UHOME(1:LUHOME)//TNAME
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS.
*
   30 INQUIRE(FILE=FILEN,EXIST=EXIST1)
      IF(EXIST1)THEN
         OPEN(UNIT=LUNWIN,FILE=FILEN,FORM='FORMATTED',STATUS='OLD'
     +,       IOSTAT=ISTA)
         IF (ISTA.NE.0) THEN
            CALL IGERR('Cannot open higz_windows.dat','IKFILE')
            GOTO 999
         ENDIF
      ELSE
         OPEN(UNIT=LUNWIN,FILE=FILEN,FORM='FORMATTED',STATUS='NEW'
     +,       IOSTAT=ISTA)
         IF(ISTA.EQ.0)THEN
            DO 40 I=1,10
               WRITE(LUNWIN,'('' 0000 0000 0600 0600'')',ERR=999)
   40       CONTINUE
            CLOSE(LUNWIN)
            GOTO 30
         ELSE
            OPND=.FALSE.
         ENDIF
      ENDIF
*
   50 IF(OPND)THEN
         DO 60 I=1,IWTYP
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=X11, IF=-IBM.
            READ(LUNWIN,'(4(1X,I4),1X,A)',ERR=999,END=999)
     +          (WINSIZ(J),J=1,4),CHHOST
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=X11, IF=IBM.
            READ(LUNWIN,'(4(1X,I4),1X,A)',ERR=999,END=999)
     +          (WINSIZ(J),J=1,4),CHREAD
            CHHOST=CHREAD
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=-X11.
            READ(LUNWIN,'(4(1X,I4))',ERR=999,END=999)
     +          (WINSIZ(J),J=1,4)
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS.
   60    CONTINUE
         CLOSE(LUNWIN)
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS, IF=X11, IF=IBM, IF=-IBMMVS.
         WRITE(CHLUN,'(I3)')LUNWIN
         FILEN='FILEDEF '//CHLUN//'  CLEAR'
         CALL VMCMS(FILEN,ISTAT)
         FILEN='/HIGZWIN DATA A'
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS.
      ENDIF
*
  999 END
+SELF.
+DECK,  IKFNTX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

+SELF, IF=X11.
      INTEGER FUNCTION IKFNTX(IWKNB)
*.===========>
*.
*. This routine manages the X11 hardware text fonts.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIKERN.
+SELF, IF=X11, IF=-WINNT.
      PARAMETER (IFSIZE=7,IBIG=16)
      DIMENSION X11RAP(13)
      DATA X11RAP /1.000,1.000,1.010,0.910,0.920,0.920,0.925,1.204,
     +             1.204,1.168,1.166,1.007,1.026/
+SELF, IF=X11, IF=WINNT.
      DIMENSION IMSG(5)
      EQUIVALENCE (IMSG(1), Italic), (IMSG(2), IBOLD),
     +            (IMSG(3), IH)
+SELF, IF=X11.
*.______________________________________
*
      IKFNTX=0
      IF(RCHH.EQ.THX11.AND.IFPX11.EQ.ABS(IFONT))RETURN
*
      THX11  = RCHH
      IFPX11 = ABS(IFONT)
      FX11   = ' '
      IH     = INT(WKSC(IWKNB)*YRATIO*RCHH*1.5)
+SELF, IF=X11, IF=-WINNT.
      RSIZE  = FLOAT(IH)
      IF(IH.GT.40)IH=40
*
*              Set the X11 font name
*
+SELF, IF=X11, IF=-IBM, IF=-WINNT.
      IF (IFPX11.EQ. 1) FX11='-*-times-medium-i-normal--'
      IF (IFPX11.EQ. 2) FX11='-*-times-bold-r-normal--'
      IF (IFPX11.EQ. 3) FX11='-*-times-bold-i-normal--'
      IF (IFPX11.EQ. 4) FX11='-*-helvetica-medium-r-normal--'
      IF (IFPX11.EQ. 5) FX11='-*-helvetica-medium-o-normal--'
      IF (IFPX11.EQ. 6) FX11='-*-helvetica-bold-r-normal--'
      IF (IFPX11.EQ. 7) FX11='-*-helvetica-bold-o-normal--'
      IF (IFPX11.EQ. 8) FX11='-*-courier-medium-r-normal--'
      IF (IFPX11.EQ. 9) FX11='-*-courier-medium-o-normal--'
      IF (IFPX11.EQ.10) FX11='-*-courier-bold-r-normal--'
      IF (IFPX11.EQ.11) FX11='-*-courier-bold-o-normal--'
      IF (IFPX11.EQ.12) FX11='-*-symbol-medium-r-normal--'
      IF (IFPX11.EQ.13) FX11='-*-times-medium-r-normal--'
+SELF, IF=X11, IF=IBM, IF=-WINNT.
      IF (IFPX11.EQ. 1) FX11='-*-courier-medium-o-normal--'
      IF (IFPX11.EQ. 2) FX11='-*-courier-bold-r-normal--'
      IF (IFPX11.EQ. 3) FX11='-*-courier-bold-o-normal--'
      IF (IFPX11.EQ. 4) FX11='-*-courier-medium-r-normal--'
      IF (IFPX11.EQ. 5) FX11='-*-courier-medium-o-normal--'
      IF (IFPX11.EQ. 6) FX11='-*-courier-bold-r-normal--'
      IF (IFPX11.EQ. 7) FX11='-*-courier-bold-o-normal--'
      IF (IFPX11.EQ. 8) FX11='-*-courier-medium-r-normal--'
      IF (IFPX11.EQ. 9) FX11='-*-courier-medium-o-normal--'
      IF (IFPX11.EQ.10) FX11='-*-courier-bold-r-normal--'
      IF (IFPX11.EQ.11) FX11='-*-courier-bold-o-normal--'
      IF (IFPX11.EQ.12) FX11='-*-symbol-medium-r-normal--'
      IF (IFPX11.EQ.13) FX11='-*-courier-medium-r-normal--'
+SELF, IF=X11, IF=-WINNT.
      IF(FX11.EQ.' ') RETURN
      IL=LENOCC(FX11)
*
*              Find the smallest size available.
*
      ISXFNT=IFSIZE
   10 CALL IZITOC(ISXFNT,FX11(IL+1:))
      IL2=LENOCC(FX11)+1
      FX11(IL2:IL2+1)='-*'
      IF(IXSETTF(0,IL2+1,FX11).NE.0)THEN
         IF(ISXFNT.EQ.IBIG)THEN
            CALL IGERR('X11 fonts not available','IKFNTX')
            RETURN
         ENDIF
         ISXFNT=ISXFNT+1
         GOTO 10
      ENDIF
*
*              Find the closest size available
*
   20 IF(IH.LT.ISXFNT)IH=ISXFNT
      CALL IZITOC(IH,FX11(IL+1:))
      IL2=LENOCC(FX11)+1
      FX11(IL2:IL2+1)='-*'
      ILL=IL2+1
      IF(IXSETTF(1,ILL,FX11).NE.0)THEN
         IF(IH.EQ.ISXFNT)THEN
            CALL IGERR('X11 fonts not available','IKFNTX')
            IKFNTX=1
            RETURN
         ENDIF
         IH=IH-1
         GOTO 20
      ENDIF
      IF(IPREC.EQ.2)THEN
         RMAGN = X11RAP(IFPX11)*RSIZE/FLOAT(IH)
      ELSE
         RMAGN = 1.
      ENDIF
*
+SELF, IF=X11, IF=WINNT.
*
*              Set the Windows/NT True Type text font.
*
      IF (IFPX11 .LE. 14) THEN
         GO TO (30 ,40 ,50 ,60 ,70 ,80 ,90 ,100,110,120 ,130 ,140 ,
     +   150, 160 ) IFPX11
         GO TO 100
   30    FX11 = 'Times New Roman'
         Italic = 1
         IBOLD = 4
         GO TO 170
   40    FX11 = 'Times New Roman'
         Italic = 0
         IBOLD = 8
         GO TO 170
   50    FX11 = 'Times New Roman'
         Italic = 1
         IBOLD = 8
         GO TO 170
   60    FX11 = 'Arial'
         Italic = 0
         IBOLD = 4
         GO TO 170
   70    FX11 = 'Arial'
         Italic = 1
         IBOLD = 4
         GO TO 170
   80    FX11 = 'Arial'
         Italic = 0
         IBOLD = 8
         GO TO 170
   90    FX11 = 'Arial'
         Italic = 1
         IBOLD = 8
         GO TO 170
  100    FX11 = 'Courier New'
         Italic = 0
         IBOLD = 4
         GO TO 170
  110    FX11 = 'Courier New'
         Italic = 1
         IBOLD = 4
         GO TO 170
  120    FX11 = 'Courier New'
         Italic = 0
         IBOLD = 8
         GO TO 170
  130    FX11 = 'Courier New'
         Italic = 1
         IBOLD = 8
         GO TO 170
  140    FX11 = 'Symbol'
         Italic = 0
         IBOLD = 6
         GO TO 170
  150    FX11 = 'Times New Roman'
         Italic = 0
         IBOLD = 4
         GO TO 170
  160    FX11 = 'Wingdings'
         Italic = 0
         IBOLD = 4
         GO TO 170
      ENDIF
  170 IMSG(4) = 10*RANGLE
      IMSG(5) = IPREC
      L       = LENOCC(FX11)
      IRET = IXSETTF(IMSG,L,FX11(:L)//CHAR(0))
+SELF, IF=X11.
      END
+SELF.
+DECK,  IKPL, T=FORT.
* Revision 1.3  1998/01/28 14:34:43  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:46  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

+SELF, IF=-BATCH.
      SUBROUTINE IKPL(N,X,Y)
+SELF, IF=-BATCH, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=-BATCH.
+CDE, HIATT.
      DIMENSION X(*),Y(*)
*
+SELF, IF=-BATCH, IF=KERNEL.
+CDE, HIWCDC.
+SELF, IF=-BATCH, IF=KERNEL, IF=-X11.
      IF(N.GT.IBUFSI)THEN
         CALL IGERR('Invalid number of points','IPL')
         RETURN
      ENDIF
+SELF, IF=-BATCH, IF=PHIGS.
      CALL PPL(N,X,Y)
+SELF, IF=-BATCH, IF=KERNEL,FALCO.
      DO 60 IWKNB=1,INOPWK
         IF(NODRFL(IWKNB))GOTO 60
         CALL IGSG(IWKNB)
+SELF, IF=-BATCH, IF=FALCO.
         IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)THEN
            CALL IFPL(N,X,Y)
            GOTO 60
         ENDIF
+SELF, IF=-BATCH, IF=GL.
         IF(ICURCI(IWKNB).NE.IPLCI)THEN
            CALL COLOR(IPLCI+IOFCOL)
            ICURCI(IWKNB)=IPLCI
         ENDIF
         IXX=IXWCDC(X(1))
         IYY=IYWCDC(Y(1))
         CALL MOVE2I(IXX,IYY)
         DO 20 I=2,N
            IXX=IXWCDC(X(I))
            IYY=IYWCDC(Y(I))
            CALL DRAW2I(IXX,IYY)
   20    CONTINUE
+SELF, IF=-BATCH, IF=X11.
         IPOS(1,1) = IXWCDC(X(1))
         IPOS(2,1) = IYWCDC(Y(1))
         NP        = 1
         DO 30 I=2,N
            IXX = IXWCDC(X(I))
            IYY = IYWCDC(Y(I))
            IF(IXX.NE.IPOS(1,NP).OR.IYY.NE.IPOS(2,NP))THEN
               NP         = NP+1
               IPOS(1,NP) = IXX
               IPOS(2,NP) = IYY
               IF(NP.EQ.IBUFSI)THEN
                  CALL IXLINE(NP,IPOS)
                  NP        = 1
                  IPOS(1,1) = IXX
                  IPOS(2,1) = IYY
               ENDIF
            ENDIF
   30    CONTINUE
         IF(NP.GT.1)CALL IXLINE(NP,IPOS)
+SELF, IF=-BATCH, IF=MACMPW.
         IPOS(1,1)=IXWCDC(X(1))
         IPOS(2,1)=IYWCDC(Y(1))
         NP=1
         DO 40 I=2,N
            IXX=IXWCDC(X(I))
            IYY=IYWCDC(Y(I))
            IF(IXX.NE.IPOS(1,NP).OR.IYY.NE.IPOS(2,NP))THEN
               NP=NP+1
               IPOS(1,NP)=IXX
               IPOS(2,NP)=IYY
            ENDIF
   40    CONTINUE
         CALL IMLINE(NP,IPOS)
+SELF, IF=-BATCH, IF=KERNEL,FALCO.
   60 CONTINUE
+SELF, IF=-BATCH.
      END
+SELF.
+DECK,  IKUWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

+SELF, IF=X11.
      SUBROUTINE IKUWK(IWKID)
+CDE, HIATT.
      I       = IGIWIN(IWKID)
      RW      = (XWKW2(I)-XWKW1(I)) / (YWKW2(I)-YWKW1(I))
      XWKV2N  = RW*(YWKV2(I)-YWKV1(I)) + XWKV1(I)
      YWKV2N  = (1./RW)*(XWKV2(I)-XWKV1(I)) + YWKV1(I)
      IF(XWKV2N.GT.XWKV2(I))THEN
         YWKV2(I) = YWKV2N
         GOTO 10
      ENDIF
      IF(YWKV2N.GT.YWKV2(I))THEN
         XWKV2(I) = XWKV2N
         GOTO 10
      ENDIF
   10 R       = REDIT
      IF(R.LE.0)R=1
      XWKR(I) = R*(XWKV2(I)-XWKV1(I)) / (XWKW2(I)-XWKW1(I))
      YWKR(I) = R*(YWKV2(I)-YWKV1(I)) / (YWKW2(I)-YWKW1(I))
      END
+SELF.
+DECK,  IOPKS, T=FORT.
* Revision 1.29  2002/05/22 09:18:45  couet
* - 1.28/07
* Revision 1.28  2002/05/16 15:32:16  couet
* - 1.28/06
* Revision 1.27  2002/04/04 10:23:23  couet
* - 1.28/05
* Revision 1.26  2002/03/18 16:25:53  couet
* - 1.28/04
* Revision 1.25  2001/12/07 15:52:32  couet
* - 1.28/03
* Revision 1.24  2001/11/23 16:09:39  couet
* - 1.28/02
* Revision 1.23  2001/10/17 14:42:58  couet
* - 1.28/01
* Revision 1.22  2001/10/08 16:18:10  couet
* - 1.28/00
* Revision 1.21  2001/05/31 08:08:43  couet
* - 1.27/03
* Revision 1.20  2000/08/29 14:04:11  couet
* - 1.27/02
* Revision 1.19  2000/07/14 15:19:10  couet
* - 1.27/01
* Revision 1.18  2000/04/03 15:41:44  couet
* - 1.27/00
* Revision 1.17  1999/10/20 14:17:03  couet
* - 1.26/04
* Revision 1.16  1999/10/13 12:35:50  couet
* - 1.26/03
* Revision 1.15  1999/10/06 14:05:35  couet
* - 1.26/02
* Revision 1.14  1999/06/21 16:48:43  couet
* - 1.26/01
* Revision 1.13  1999/05/06 06:59:38  couet
* - version 1.26/00 to tag the following bug fixe in x11int.c:
*  "MapNotify is not supported by all the X11 emulators (problem on Mac !!!)"
* Revision 1.12  1999/01/07 15:31:33  couet
* - 1.25/05
* Revision 1.11  1998/12/07 13:45:29  couet
* - 1.25/04
* Revision 1.10  1998/11/16 11:14:10  couet
* - 1.25/03
* Revision 1.9  1998/11/13 10:52:37  couet
* - 1.25/02
* Revision 1.8  1998/05/26 09:23:04  couet
* - 1.25/01
* Revision 1.7  1998/04/09 13:08:23  couet
* - new version
* Revision 1.6  1998/01/28 14:34:44  couet
* - GGDM driver removed
* Revision 1.5  1997/01/30 10:55:24  couet
* - version 1.23/09
* Revision 1.4  1996/09/25 14:58:47  couet
* - GPR driver removed
* Revision 1.3  1996/04/23 08:37:23  couet
* - version number incremented.
* Revision 1.2  1996/03/08 17:08:03  couet
* The initialization of the Version string was wrong.
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz


*-- Author : O.Couet
      SUBROUTINE IOPKS(IERFIL)
      ENTRY      GOPKS(IERFIL)
+CDE, HILUN.
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+CDE, HIVERS.
      CHARACTER*16 TCARD
*
      CALL UHTOC(
     + 40HVERSION  1.28/07   22/05/02
+SELF, IF=-CRAY.
     +,4,TCARD,16)
+SELF, IF=CRAY.
     +,8,TCARD,16)
+SELF.
      CHVERS = TCARD(9:16)
+SELF, IF=-NOVERS.
      PRINT*,'Version'//CHVERS//' of HIGZ started'
+SELF.
*
* ICURWK = Index of the current active workstation
* NODRFL = If .TRUE. the basic graphics package is not called
*          in each primitives of IKERNEL
* ICURCI = Current color
* IOFCOL = Offset in the color table
*
      ICURWK=0
      DO 10 I=1,10
         NODRFL(I)=.TRUE.
+SELF, IF=GL, IF=-MSDOS.
         ICURCI(I)=-1
+SELF, IF=MSDOS.
         ICURCI(I)=0
+SELF.
   10 CONTINUE
+SELF, IF=GL, IF=-MSDOS.
      IXLOCO=0
      IYLOCO=0
      IOFCOL=64
      LOINS=.FALSE.
+SELF, IF=MSDOS.
      IXLOCO=0
      IYLOCO=0
      IWKNB=0
      IOFCOL=0
      LOINS=.FALSE.
+SELF, IF=X11.
      THX11=0.
      IFPX11=0.
+SELF, IF=PHIGS.
      CALL POPPH(IERFIL,-1)
      IDIM=3
+SELF.
      IF(IERFIL.GT.0)LUNERR=IERFIL
      END
+DECK,  IOPWK, T=FORT.
* Revision 1.4  1998/12/01 15:48:36  couet
* - Clean up: commented lines of code removed
* Revision 1.3  1998/01/28 14:34:45  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:48  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE IOPWK(IWKID,ICONID,IWTYPI)
      ENTRY      GOPWK(IWKID,ICONID,IWTYPI)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=MSDOS.
+CDE, HIMETA.
+SELF.
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=KERNEL.
      CHARACTER*32 CHWIN
+SELF.
      DIMENSION RVAL(2)
+SELF, IF=-X11.
      SAVE IFIRST
+SELF, IF=X11.
      INTEGER WINID
+SELF, IF=X11, IF=IBM, IF=-IBMMVS.
      CHARACTER*3 CHLUN
+SELF, IF=GL, IF=-MSDOS.
      INTEGER*2 IHATCH(16,8)
      DATA (IHATCH(I,1),I=1,16)
     +   / X'8888' , X'2222' , X'8888' , X'2222'
     +   , X'8888' , X'2222' , X'8888' , X'2222'
     +   , X'8888' , X'2222' , X'8888' , X'2222'
     +   , X'8888' , X'2222' , X'8888' , X'2222' /
      DATA (IHATCH(I,2),I=1,16)
     +   / X'9999' , X'0000' , X'6666' , X'0000'
     +   , X'9999' , X'0000' , X'6666' , X'0000'
     +   , X'9999' , X'0000' , X'6666' , X'0000'
     +   , X'9999' , X'0000' , X'6666' , X'0000' /
      DATA (IHATCH(I,3),I=1,16)
     +   / X'8181' , X'0000' , X'0000' , X'0000'
     +   , X'1818' , X'0000' , X'0000' , X'0000'
     +   , X'8181' , X'0000' , X'0000' , X'0000'
     +   , X'1818' , X'0000' , X'0000' , X'0000' /
      DATA (IHATCH(I,4),I=1,16)
     +   / X'8001' , X'0000' , X'0000' , X'0000'
     +   , X'0000' , X'0000' , X'0000' , X'0000'
     +   , X'0180' , X'0000' , X'0000' , X'0000'
     +   , X'0000' , X'0000' , X'0000' , X'0000' /
      DATA (IHATCH(I,5),I=1,16)
     +   / X'FFFF' , X'8181' , X'8181' , X'8181'
     +   , X'FFFF' , X'FFFF' , X'1818' , X'1818'
     +   , X'1818' , X'1818' , X'FFFF' , X'FFFF'
     +   , X'8181' , X'8181' , X'8181' , X'FFFF' /
      DATA (IHATCH(I,6),I=1,16)
     +   / X'CCCC' , X'CCCC' , X'3333' , X'3333'
     +   , X'CCCC' , X'CCCC' , X'3333' , X'3333'
     +   , X'CCCC' , X'CCCC' , X'3333' , X'3333'
     +   , X'CCCC' , X'CCCC' , X'3333' , X'3333' /
      DATA (IHATCH(I,7),I=1,16)
     +   / X'F0F0' , X'F0F0' , X'F0F0' , X'F0F0'
     +   , X'0F0F' , X'0F0F' , X'0F0F' , X'0F0F'
     +   , X'F0F0' , X'F0F0' , X'F0F0' , X'F0F0'
     +   , X'0F0F' , X'0F0F' , X'0F0F' , X'0F0F' /
      DATA (IHATCH(I,8),I=1,16)
     +   / X'FF00' , X'FF00' , X'FF00' , X'FF00'
     +   , X'FF00' , X'FF00' , X'FF00' , X'FF00'
     +   , X'00FF' , X'00FF' , X'00FF' , X'00FF'
     +   , X'00FF' , X'00FF' , X'00FF' , X'00FF' /
+SELF, IF=-X11.
      DATA IFIRST/1/
+SELF.
*
      IF(IWKID.EQ.0)THEN
         CALL IGERR('Workstation identifier equal 0','IOPWK')
         RETURN
      ENDIF
      IF(INOPWK.EQ.10)THEN
         CALL IGERR('Maximal number of open workstation is 10','IOPWK')
         RETURN
      ENDIF
      IF(IGIWIN(IWKID).NE.0)THEN
         CALL IGERR('Workstation already open','IOPWK')
         RETURN
      ENDIF
*
      IWTYP=IWTYPI
+SELF, IF=X11.
      IF(IWTYP.EQ.999)IWTYP=1
+SELF.
      INOPWK=INOPWK+1
      ILOPWK(INOPWK)=IWKID
      IWTYL(INOPWK)=IWTYP
      ACWKFL(INOPWK)=.FALSE.
      NODRFL(INOPWK)=.TRUE.
+SELF, IF=MSDOS.
      ISAVE  = IWKNB
      IWKNB  = INOPWK
+SELF, IF=PSCRIPT.
*
      IF(IWTYP.LT.0)THEN
         CALL IPINIT(IWKID,ABS(ICONID),IWTYP)
         RETURN
      ENDIF
+SELF, IF=-BATCH.
*
      IF(GFLAG)THEN
+SELF, IF=FALCO.
         IF(IWTYP.EQ.7878.OR.IWTYP.EQ.7879)THEN
            IWTYPE = IWTYP
            IFONT  = 0
            IPREC  = 2
            IFTPR  = 20
            CALL IFINIT
            CALL IFVWIN(0.,1.,0.,.8)
            IF(IWTYP.EQ.7878)THEN
               CALL IFSWIN(0,128000,0,100000)
            ELSE
               CALL IFSWIN(0,128000,0,101120)
            ENDIF
            RETURN
         ENDIF
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS.
         IF(IWTYP.LE.0.OR.IWTYP.GT.20)THEN
            CALL IGERR('Invalid workstation type','IOPWK')
            INOPWK=INOPWK-1
            RETURN
         ENDIF
+SELF, IF=MSDOS.
         IF(IWTYP.LE.0.)THEN
            CALL IGERR('Invalid workstation type','IOPWK')
            INOPWK=INOPWK-1
            RETURN
         ENDIF
         IF(IWTYP.GT.10)IWTYP=IWTYP-10
*
+SELF, IF=KERNEL, IF=-PHIGS, IF=-MSDOS.
         CALL IKFILE(IWTYP)
+SELF, IF=KERNEL, IF=-PHIGS.
*
         WRITE(CHWIN,'(''HIGZ_'',I2.2)') IWKID
+SELF, IF=GL, IF=SGI, IF=-MSDOS.
         CALL FOREGR
+SELF, IF=GL, IF=-MSDOS.
         CALL PREFPO(WINSIZ(1),WINSIZ(1)+WINSIZ(3)-1
     +,              WINSIZ(2),WINSIZ(2)+WINSIZ(4)-1)
         WINID=WINOPE(CHWIN,11)
         IWINID(INOPWK)=WINID
         CALL ICLRWK(IWKID,0)
         CALL WINCON
         CALL CONCAV(.TRUE.)
         IF(IFIRST.NE.0)THEN
            IFIRST=0
            CALL DEFLIN(1,X'F0F0')
            CALL DEFLIN(2,X'8888')
            CALL DEFLIN(3,X'E4E4')
            CALL DEFLIN(4,X'FAFA')
            DO 20 I=1,8
               CALL DEFPAT(I,16,IHATCH(1,I))
   20       CONTINUE
            CALL SETPAT(0)
         ENDIF
+SELF, IF=MSDOS.
         CALL IGSG(INOPWK)
         IER = GET_DEVICE_LIMITS(IXX
     +,                          IYY
     +,                          MAX_COLOR(INOPWK))
         XWKSIZ(INOPWK) = IXX
         YWKSIZ(INOPWK) = IYY
         CALL ICLRWK(IWKID,0)
         IF (IFIRST .NE. 0) THEN
            IFIRST = 0
            DASH_PATTERN( 1) =
     +             CHAR(Z'FF')//CHAR(Z'FF')//CHAR(Z'FF')//CHAR(Z'FF')
            DASH_PATTERN( 2) =
     +            CHAR(Z'0F')//CHAR(Z'0F')//CHAR(Z'0F')//CHAR(Z'0F')
            DASH_PATTERN(3) =
     +            CHAR(Z'11')//CHAR(Z'11')//CHAR(Z'11')//CHAR(Z'11')
            DASH_PATTERN(4) =
     +            CHAR(Z'F6')//CHAR(Z'F6')//CHAR(Z'F6')//CHAR(Z'F6')
            DASH_PATTERN( 5) =
     +             CHAR(Z'F0')//CHAR(Z'F0')//CHAR(Z'F0')//CHAR(Z'F0')
            DASH_PATTERN( 6) =
     +             CHAR(Z'00')//CHAR(Z'FF')//CHAR(Z'FF')//CHAR(Z'FF')
            DASH_PATTERN( 7) =
     +             CHAR(Z'FF')//CHAR(Z'00')//CHAR(Z'FF')//CHAR(Z'00')
            DASH_PATTERN( 8) =
     +            CHAR(Z'00')//CHAR(Z'FF')//CHAR(Z'00')//CHAR(Z'FF')
            DASH_PATTERN( 9) =
     +            CHAR(Z'F0')//CHAR(Z'0F')//CHAR(Z'F0')//CHAR(Z'0F')
            DASH_PATTERN(10) =
     +             CHAR(Z'00')//CHAR(Z'00')//CHAR(Z'00')//CHAR(Z'FF')
            DASH_PATTERN(11) =
     +             CHAR(Z'00')//CHAR(Z'00')//CHAR(Z'FF')//CHAR(Z'FF')
            DASH_PATTERN(12) = DASH_PATTERN(2)
            DASH_PATTERN(13) = DASH_PATTERN(4)
            DASH_PATTERN(14) = DASH_PATTERN(3)
            DASH_PATTERN(15) =
     +            CHAR(Z'55')//CHAR(Z'55')//CHAR(Z'55')//CHAR(Z'55')
            DASH_PATTERN(16) =
     +            CHAR(Z'AA')//CHAR(Z'AA')//CHAR(Z'AA')//CHAR(Z'AA')
            MAG_X = 1
            MAG_Y = 1
         ENDIF
         IF(IWKID.EQ.IDMETA)THEN
            LUNMET(INOPWK) = ABS(ICONID)
         ENDIF
         IWKNB = ISAVE
+SELF, IF=X11.
         IWINN=INDEX(CHHOST,' ')
         I=IWINN-1
         IF(I.LE.0)I=LENOCC(CHHOST)
         IF(I.NE.0)THEN
+SELF, IF=X11, IF=IBM, IF=-IBMMVS.
            CALL VMCMS('GLOBALV SELECT CENV SETL DISPLAY '
     +      //CHHOST(1:I)//':0',IRET)
+SELF, IF=X11.
            FX11 = CHHOST
            IF(INDEX(CHHOST,':').EQ.0)THEN
               FX11(I+1:) = ':0.0'
               I          = I+4
            ENDIF
         ELSE
            FX11 = ' '
         ENDIF
         IF(IXOPNDS(I,FX11).LT.0)THEN
            CALL IGERR('Can''t open DISPLAY','IOPWK')
            INOPWK=INOPWK-1
            IWTYPE=0
            RETURN
         ENDIF
         IF(LENOCC(CHHOST).GT.I)THEN
            CHWIN(1:1)='-'
            CHWIN(2:)=CHHOST(IWINN:)
         ENDIF
         IFLAG=0
         WINID=IXOPNWI(WINSIZ(1),WINSIZ(2),WINSIZ(3),WINSIZ(4)
     +,                 LENOCC(CHWIN),CHWIN,IFLAG)
         IF(WINID.LT.0)THEN
            CALL IGERR('Can''t open WINDOW','IOPWK')
            INOPWK=INOPWK-1
            IWTYPE=0
            RETURN
         ENDIF
         CALL IXMINIT(WINID)
         IWINID(INOPWK)=WINID
         CALL IXSETCO(1,0.,0.,0.)
         CALL IXSETFC(1)
         CALL IXSETLC(1)
         CALL IXSETMC(1)
         CALL IXSETTC(1)
         CALL ICLRWK(IWKID,0)
*
         CALL IGQWK(IWKID,'MXDS',RVAL)
         XWKWN=MIN(1.,RVAL(1)/RVAL(2))
         YWKWN=MIN(1.,RVAL(2)/RVAL(1))
         CALL ISWKWN(IWKID,0.,XWKWN,0.,YWKWN)
         CALL ISWKVP(IWKID,0.,RVAL(1),0.,RVAL(2))
         CALL IKUWK(IWKID)
*
+SELF, IF=PHIGS.
         CALL POPWK(IWKID,1,IWTYP)
         CALL PXOPEN_PIPE(IWKID)
+SELF, IF=MACMPW.
         WINID=IMOPNWI(WINSIZ(1),WINSIZ(2),WINSIZ(3),WINSIZ(4)
     +,                20,'HIGZ Graphics Window')
+SELF, IF=-BATCH.
      ENDIF
+SELF.
*
      END
+DECK,  IPL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE IPL(N,X,Y)
      ENTRY      GPL(N,X,Y)
*.===========>
*.
*.   This routine draws a polyline . The line type from 12 to 15 are independent
*. from the underlaying basic graphics package .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points in the polyline .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*),XX(2),YY(2)
      DIMENSION XDOT(2),YDOT(2)
      LOGICAL ZSAV
      EQUIVALENCE (XOLD,XX(1)),(XNEW,XX(2))
      EQUIVALENCE (YOLD,YY(1)),(YNEW,YY(2))
      DATA XLSTEP,SMIN/0.2,0.0002/
*.______________________________________
*
      IF(N.LT.2)THEN
         CALL IGERR('Invalid number of points','IPL')
         RETURN
      ENDIF
*
      IF((ILN.GE.12).AND.(GFLAG.OR.PFLAG))THEN
         ZSAV=ZFLAG
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         NTSAV=INTR
         RATIO1=(RVXMAX-RVXMIN)/(RWXMAX-RWXMIN)
         RATIO2=(RVYMAX-RVYMIN)/(RWYMAX-RWYMIN)
         RWX1=RWXMIN
         RWY1=RWYMIN
         RVX1=RVXMIN
         RVY1=RVYMIN
         RVX2=RVXMAX
         RVY2=RVYMAX
         XLSTEP=RBSL
         SMIN=0.001*XLSTEP
         CALL ISELNT(0)
         ILNS=ILN
         CALL ISLN(1)
         IF((XLSTEP.LE.0.).OR.(XLSTEP.GT.1))XLSTEP=0.01
*
*              Possibly dashed lines drawn
*
   10    MODE=1
         IDOT=0
         SRES=XLSTEP
*
         DO 90  I=2,N
            XOLD=RATIO1*(X(I-1)-RWX1)+RVX1
            YOLD=RATIO2*(Y(I-1)-RWY1)+RVY1
*
            DXSTEP=RATIO1*(X(I)-RWX1)+RVX1-XOLD
            DYSTEP=RATIO2*(Y(I)-RWY1)+RVY1-YOLD
            ADX=ABS(DXSTEP)
            ADY=ABS(DYSTEP)
            IF(ADX.LE.SMIN)THEN
               STEP=ADY
               DSX=0.
               DSY=SIGN(1.,DYSTEP)
               GOTO 20
            ENDIF
            IF(ADY.LE.SMIN)THEN
               STEP=ADX
               DSX=SIGN(1.,DXSTEP)
               DSY=0.
               GOTO 20
            ENDIF
            STEP=SQRT(DXSTEP*DXSTEP+DYSTEP*DYSTEP)
            DSX=DXSTEP/STEP
            DSY=DYSTEP/STEP
   20       IF(STEP.LE.0.)GO TO 90
            DRES=STEP
*
   30       ST=SRES
            IF(ST.GT.DRES)ST=DRES
            SRES=SRES-ST
            DRES=DRES-ST
            XNEW=XOLD+ST*DSX
            YNEW=YOLD+ST*DSY
*
            IF(ICLIP.EQ.1)THEN
               ICL=IGCLIP(XX,YY,RVX1,RVX2,RVY1,RVY2)
               IF(ICL.EQ.0)GOTO 80
            ENDIF
*
            GO TO (40 ,40 ,50 ,60 ,70 ),ILNS-10
*
*              Dashed line _ _ _ _ _ _ _
*
   40       CONTINUE
            IF(MODE.NE.0)THEN
+SELF, IF=PSCRIPT.
               IF(PFLAG)CALL IZPL(2,XX,YY)
+SELF, IF=-BATCH.
               IF(GFLAG)CALL IKPL(2,XX,YY)
+SELF.
            ENDIF
            GO TO 80
*
*              Dash-dot line _._._._._.
*
   50       IF(MODE.EQ.0)GO TO 70
+SELF, IF=PSCRIPT.
            IF(PFLAG)CALL IZPL(2,XX,YY)
+SELF, IF=-BATCH.
            IF(GFLAG)CALL IKPL(2,XX,YY)
+SELF.
            GO TO 80
*
*              Dot-blank  . . . . . . .
*
   60       IF(MODE.EQ.0)GO TO 80
*
*              Dotted line  ............
*
   70       IF (SRES.LT.0.5*XLSTEP) IDOT=IDOT+1
            IF (IDOT.NE.1) GOTO 80
            XDOT(1)=XNEW-(0.5*XLSTEP-SRES)*DSX
            YDOT(1)=YNEW-(0.5*XLSTEP-SRES)*DSY
            MTS=IMK
            MCOL=IPMCI
            RMSC=RMKSC
            CALL ISMKSC(RLWSC)
            CALL ISMK(1)
            CALL ISPMCI(IPLCI)
            IF(GFLAG)CALL IPM(1,XDOT,YDOT)
+SELF, IF=PSCRIPT.
            IF(PFLAG)CALL IZPM(1,XDOT,YDOT)
+SELF.
            CALL ISMKSC(RMSC)
            CALL ISMK(MTS)
            CALL ISPMCI(MCOL)
*
   80       XOLD=XNEW
            YOLD=YNEW
            IF(SRES.LE.SMIN)THEN
               IDOT=0
               SRES=XLSTEP
               MODE=MODE+1
               IF(MODE.EQ.2)MODE=0
            ENDIF
            IF(DRES.GT.SMIN)GO TO 30
   90    CONTINUE
         CALL ISELNT(NTSAV)
         CALL ISLN(ILNS)
         ZFLAG=ZSAV
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      ELSE
+SELF, IF=-BATCH.
         IF(GFLAG)CALL IKPL(N,X,Y)
+SELF.
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZPL(N,X,Y)
+SELF.
*
      END
+DECK,  IPM, T=FORT.
* Revision 1.3  1998/01/28 14:34:46  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:49  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE IPM(N,X,Y)
      ENTRY      GPM(N,X,Y)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=MSDOS.
+CDE, HIMETA.
+SELF.
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*)
*
+SELF, IF=KERNEL.
+CDE, HIWCDC.
+SELF, IF=KERNEL, IF=-X11.
      IF(N.LT.1.OR.N.GT.IBUFSI)THEN
         CALL IGERR('Invalid number of points','IPM')
         RETURN
      ENDIF
+SELF.
      IF(IMK.GE.20)THEN
         CALL IGPM(N,X,Y,IMK)
      ELSE
         IF(GFLAG)THEN
+SELF, IF=PHIGS.
            CALL PPM(N,X,Y)
+SELF, IF=KERNEL,FALCO.
            DO 70 IWKNB=1,INOPWK
               IF(NODRFL(IWKNB))GOTO 70
               CALL IGSG(IWKNB)
+SELF, IF=FALCO.
               IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)THEN
                  IF(IMK.EQ.3)THEN
                     CALL IGPM(N,X,Y,31)
                  ELSEIF(IMK.EQ.4)THEN
                     CALL IGPM(N,X,Y,24)
                  ELSE
                     DO 10 I=1,N
                        XFALCO=(RVXMIN+XRATIO*(X(I)-RWXMIN))
                        YFALCO=(RVYMIN+YRATIO*(Y(I)-RWYMIN))
                        CALL IFMOVE(XFALCO,YFALCO)
                        CALL IFDRAW(XFALCO,YFALCO)
   10                CONTINUE
                     CALL IFPUT(0)
                  ENDIF
                  GOTO 70
               ENDIF
+SELF, IF=GL, IF=-MSDOS.
               IF(ICURCI(IWKNB).NE.IPMCI)THEN
                  CALL COLOR(IPMCI+IOFCOL)
                  ICURCI(IWKNB)=IPMCI
               ENDIF
               DO 30 I=1,N
                  IXX=IXWCDC(X(I))
                  IYY=IYWCDC(Y(I))
                  CALL MOVE2I(IXX,IYY)
                  CALL DRAW2I(IXX,IYY)
   30          CONTINUE
+SELF, IF=MSDOS.
               CALL MARKER(N,X,Y)
+SELF, IF=X11.
               LM=ABS(IMK)
               IM=NINT(RMKSC*4)
               IF(IM.LE.0) LM=1
               IF(LM.EQ.2) THEN
*--- + shaped marker
                  IPOS(1,1)=-IM
                  IPOS(2,1)=0
                  IPOS(1,2)=IM
                  IPOS(2,2)=0
                  IPOS(1,3)=0
                  IPOS(2,3)=-IM
                  IPOS(1,4)=0
                  IPOS(2,4)=IM
                  CALL IXSETMS(4,4,IPOS)
               ELSEIF(LM.EQ.3) THEN
*--- * shaped marker
                  IPOS(1,1)=-IM
                  IPOS(2,1)=0
                  IPOS(1,2)=IM
                  IPOS(2,2)=0
                  IPOS(1,3)=0
                  IPOS(2,3)=-IM
                  IPOS(1,4)=0
                  IPOS(2,4)=IM
                  IM=NINT(IM*0.707)
                  IPOS(1,5)=-IM
                  IPOS(2,5)=-IM
                  IPOS(1,6)=IM
                  IPOS(2,6)=IM
                  IPOS(1,7)=-IM
                  IPOS(2,7)=IM
                  IPOS(1,8)=IM
                  IPOS(2,8)=-IM
                  CALL IXSETMS(4,8,IPOS)
               ELSEIF(LM.EQ.4) THEN
*--- O shaped marker
                  CALL IXSETMS(0,IM*2,IPOS)
               ELSEIF(LM.EQ.5) THEN
*--- X shaped marker
                  IM=NINT(IM*0.707)
                  IPOS(1,1)=-IM
                  IPOS(2,1)=-IM
                  IPOS(1,2)=IM
                  IPOS(2,2)=IM
                  IPOS(1,3)=-IM
                  IPOS(2,3)=IM
                  IPOS(1,4)=IM
                  IPOS(2,4)=-IM
                  CALL IXSETMS(4,4,IPOS)
               ELSEIF(LM.EQ.6) THEN
*--- + shaped marker (with 1 pixel)
                  IPOS(1,1)=-1
                  IPOS(2,1)=0
                  IPOS(1,2)=1
                  IPOS(2,2)=0
                  IPOS(1,3)=0
                  IPOS(2,3)=-1
                  IPOS(1,4)=0
                  IPOS(2,4)=1
                  CALL IXSETMS(4,4,IPOS)
               ELSEIF(LM.EQ.7) THEN
*--- . shaped marker (with 9 pixel)
                  IPOS(1,1)=-1
                  IPOS(2,1)=1
                  IPOS(1,2)=1
                  IPOS(2,2)=1
                  IPOS(1,3)=-1
                  IPOS(2,3)=0
                  IPOS(1,4)=1
                  IPOS(2,4)=0
                  IPOS(1,5)=-1
                  IPOS(2,5)=-1
                  IPOS(1,6)=1
                  IPOS(2,6)=-1
                  CALL IXSETMS(4,6,IPOS)
               ELSEIF(LM.EQ.8) THEN
*--- O shaped marker (filled)
                  CALL IXSETMS(1,IM*2,IPOS)
               ELSE
*--- single dot
                  CALL IXSETMS(0,0,IPOS)
               ENDIF
               NPT = 0
               DO 40 I=1,N
                  NPT = NPT+1
                  IPOS(1,NPT) = IXWCDC(X(I))
                  IPOS(2,NPT) = IYWCDC(Y(I))
                  IF(NPT.EQ.IBUFSI.OR.I.EQ.N)THEN
                     CALL IXMARKE(NPT,IPOS)
                     NPT = 0
                  ENDIF
   40          CONTINUE
+SELF, IF=MACMPW.
               DO 50 I=1,N
                  IPOS(1,I)=IXWCDC(X(I))
                  IPOS(2,I)=IYWCDC(Y(I))
   50          CONTINUE
               CALL IMMARKE(N,IPOS)
+SELF, IF=KERNEL,FALCO.
   70       CONTINUE
+SELF.
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZPM(N,X,Y)
+SELF.
*
      END
+DECK,  IRQLC, T=FORT.
* Revision 1.4  1998/12/01 15:48:36  couet
* - Clean up: commented lines of code removed
* Revision 1.3  1998/01/28 14:34:47  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:50  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE IRQLC(IWKIDI,LCN,ISTATI,ITNRI,XLOC,YLOC)
      ENTRY      GRQLC(IWKIDI,LCN,ISTATI,ITNRI,XLOC,YLOC)
*.===========>
*.
*.   This routine returns the graphic cursor position in WC space in
*. XLOC and YLOC. The same position in the NDC space is available in
*. RQUEST(11) and RQUEST(12). The normalization tranformation number
*. is returned in TNR. After a call to IRQLC the window coordinates
*. are available in RQUEST(20), RQUEST(21), RQUEST(22), and RQUEST(23).
*. The viewport coordinates are available in RQUEST(30), RQUEST(31),
*. RQUEST(32), and  RQUEST(33). This routine computed the XLOC and YLOC
*. value according to value of the REDIT factor, but the value of
*. RQUEST(11) and RQUEST(12) do not care about the value of REDIT. The
*. REDIT factor is usefull for the graphics editor and the menu mode of
*. KUIP.
*.   The values of XLOC and YLOC are computed with the parameters stored
*. in the NT storage (HINT) if ZEBRA is not used, or if there no
*. displayed picture. If an HIGZ picture is displayed, only the NT
*. existing in this picture are used to compute the values of XLOC and
*. YLOC.
*.   This routine can work in two modes :
*.    - The REQUEST mode where a "Button_Press" event is necesary to get
*.      the cursor position.
*.    - The SAMPLE mode where only a move of the mouse is enough to get
*.      the cursor position.
*.
*. _Input parameters:
*.
*.  INTEGER IWKIDI : Workstation identifier .
*.  INTEGER LCN    : Input device number .
*.                   If LCN>10 then LCN=10*IPET+LNDNR
*.
*.                 LCN=10 tracking cross
*.                 LCN=20 cross-hair
*.                 LCN=30 rubber circle
*.                 LCN=40 rubber band
*.                 LCN=50 rubber rectangle
*.                 LCN=99 the screen coordinates are taken
*.                        in XLOC and YLOC (X11 only).
*.
*.                 LCN>0  request mode
*.                 LCN<0  sample mode
*.
*. _Output parameters:
*.
*.  INTEGER ISTATI : Return status: 0=BREAK, 1=OK .
*.  INTEGER ITNRI  : Normalization transformation number .
*.  REAL XLOC YLOC : Cursor position in WC space .
*.
*..==========> (O.Couet)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=-ZEBRA.
+CDE, HIQUES.
+SELF, IF=-NTC, IF=-X11.
+CDE, HINT.
+SELF.
+CDE, HILOC.
+CDE, HIATT.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=MAIL.
+CDE, HIFLAG.
+SELF.
      LOGICAL SAMPLE
+SELF, IF=GL.
      SAVE IXLOCP,IYLOCP
+SELF.
*.______________________________________
*
      IWKIND    = IGIWIN(IWKIDI)
      IQUEST(1) = 0
      IF(IWKIND.EQ.0)THEN
         CALL IGERR('Workstation is not open','IRQLC')
         RETURN
      ENDIF
      IF(IWTYL(IWKIND).LE.0)THEN
* No locator for Metafile.
         CALL IGERR('No request locator on metafile','IRQLC')
         RETURN
      ENDIF
+SELF, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(3I3)') 555,IWKIDI,LCN
         CALL IMWRIT(1)
         READ (5,'(2I5,2E16.7)') ISTATI,ITNRI,XLOC,YLOC
         CALL IMWRIT(5)
         RETURN
      ENDIF
+SELF.
*
      IF (LCN.GE.0) THEN
         SAMPLE = .FALSE.
      ELSE
         SAMPLE = .TRUE.
      ENDIF
      IPET = 1
      IF(ABS(LCN).GE.10)THEN
         IPET = ABS(LCN)/10
      ENDIF
+SELF, IF=MSDOS.
      ISAVE = IWKNB
      IWKNB = IWKIND
+SELF, IF=FALCO.
*
      IF(IWTYL(IWKIND).EQ.7878.OR.IWTYL(IWKIND).EQ.7879)THEN
* Here we use space as affirmative reply and any other char as NO
         IF (ISTATI.EQ.ICHAR(' ')) THEN
            ISTATI=1
         ELSE
            ISTATI=0
         ENDIF
         GOTO 90
      ENDIF
+SELF, IF=GL, IF=-MSDOS.
*
      CALL ISCLIP(0)
      CALL QDEVIC(LEFTMO)
      CALL QDEVIC(RIGHTM)
      CALL QDEVIC(MOUSEX)
      CALL QDEVIC(MOUSEY)
      CALL LOGICO(LOXOR)
      CALL GETORI(IXORI,IYORI)
      CALL COLOR(1)
      CALL QRESET
      IXLOCP=IXLOCO
      IYLOCP=IYLOCO
   40 CONTINUE
      CALL WINSET(IWINID(IWKIND))
      CALL CURSOF
      IF(LOINS)THEN
         IF(IPET.EQ.1)THEN
            CALL MOVE2I(IXLOC,IYLOC-10)
            CALL DRAW2I(IXLOC,IYLOC+10)
            CALL MOVE2I(IXLOC-10,IYLOC)
            CALL DRAW2I(IXLOC+10,IYLOC)
         ENDIF
         IF(IPET.EQ.2)THEN
            CALL MOVE2I(IXLOC,0)
            CALL DRAW2I(IXLOC,INT(YWKSIZ(IWKIND)))
            CALL MOVE2I(0,IYLOC)
            CALL DRAW2I(INT(XWKSIZ(IWKIND)),IYLOC)
         ENDIF
         IF(IPET.EQ.3)THEN
            RX=FLOAT(IXLOC-IXLOCP)
            RY=FLOAT(IYLOC-IYLOCP)
            IRAD=INT(SQRT(RX*RX+RY*RY))
            CALL CIRCI(IXLOCP,IYLOCP,IRAD)
         ENDIF
         IF(IPET.EQ.4.OR.IPET.EQ.3)THEN
            CALL MOVE2I(IXLOCP,IYLOCP)
            CALL DRAW2I(IXLOC,IYLOC)
         ENDIF
         IF(IPET.EQ.5)THEN
            CALL SBOXI(IXLOCP,IYLOCP,IXLOC,IYLOC)
         ENDIF
      ENDIF
      IXLOCO=IXLOC
      IYLOCO=IYLOC
      IDEV=QREAD(IVAL)
      IF(IDEV.EQ.MOUSEX.OR.IDEV.EQ.MOUSEY.OR.LOINS)THEN
         IF(IDEV.EQ.MOUSEX)THEN
            IXLOC=IVAL-IXORI
            RQUEST(11)=FLOAT(IXLOC)/WKMAX(IWKIND)
            GOTO 50
         ENDIF
         IF(IDEV.EQ.MOUSEY)THEN
            IYLOC=IVAL-IYORI
            RQUEST(12)=FLOAT(IYLOC)/WKMAX(IWKIND)
            GOTO 50
         ENDIF
   50    IF(LOINS)THEN
            IF(IPET.EQ.1)THEN
               CALL MOVE2I(IXLOCO,IYLOCO-10)
               CALL DRAW2I(IXLOCO,IYLOCO+10)
               CALL MOVE2I(IXLOCO-10,IYLOCO)
               CALL DRAW2I(IXLOCO+10,IYLOCO)
            ENDIF
            IF(IPET.EQ.2)THEN
               CALL MOVE2I(IXLOCO,0)
               CALL DRAW2I(IXLOCO,INT(YWKSIZ(IWKIND)))
               CALL MOVE2I(0,IYLOCO)
               CALL DRAW2I(INT(XWKSIZ(IWKIND)),IYLOCO)
            ENDIF
            IF(IPET.EQ.3)THEN
               RX=FLOAT(IXLOCO-IXLOCP)
               RY=FLOAT(IYLOCO-IYLOCP)
               IRAD=INT(SQRT(RX*RX+RY*RY))
               CALL CIRCI(IXLOCP,IYLOCP,IRAD)
            ENDIF
            IF(IPET.EQ.4.OR.IPET.EQ.3)THEN
               CALL MOVE2I(IXLOCP,IYLOCP)
               CALL DRAW2I(IXLOCO,IYLOCO)
            ENDIF
            IF(IPET.EQ.5)THEN
               CALL SBOXI(IXLOCP,IYLOCP,IXLOCO,IYLOCO)
            ENDIF
         ENDIF
         LOINS=.TRUE.
         GOTO 60
      ENDIF
   60 IF(IDEV.EQ.LEFTMO)THEN
         IDEV=QREAD(IVAL)
         ISTATI=1
         GOTO 70
      ENDIF
      IF(IDEV.EQ.RIGHTM)THEN
         IDEV=QREAD(IVAL)
         ISTATI=0
         GOTO 70
      ENDIF
      IF(IDEV.EQ.INPTCH)THEN
         LOINS=.NOT.LOINS
         GOTO 40
      ENDIF
      GOTO 40
   70 CALL UNQDEV(LEFTMO)
      CALL UNQDEV(RIGHTM)
      CALL UNQDEV(MOUSEX)
      CALL UNQDEV(MOUSEY)
      CALL LOGICO(LOSRC)
      CALL COLOR(IPLCI+IOFCOL)
      CALL CURSON
      LOINS=.FALSE.
+SELF, IF=MSDOS.
      RQUEST(11)=OLDXP
      RQUEST(12)=OLDYP
*
      IXLOCO = NINT(RQUEST(11)*WKMAX(IWKIND))
      IYLOCO = NINT(YWKSIZ(IWKIND)-RQUEST(12)*WKMAX(IWKIND))
+SELF, IF=MSDOS, IF=NDP.
*
      CALL ISCLIP(0)
      IER = SET_XOR(1)
      CALL COLOR(6)
      IF (MOUSE) CALL SET_MOUSE(IXLOCO,IYLOCO)
      IXLOCP=IXLOCO
      IYLOCP=IYLOCO
   40 CONTINUE
      CALL WINSET(IWINID(IWKIND))
      CALL CURSOF
      IF(LOINS)THEN
         IF(IPET.EQ.1)THEN
            CALL MOVE2I(IXLOC,IYLOC-10)
            CALL DRAW2I(IXLOC,IYLOC+10)
            CALL MOVE2I(IXLOC-10,IYLOC)
            CALL DRAW2I(IXLOC+10,IYLOC)
         ENDIF
         IF(IPET.EQ.2)THEN
            CALL MOVE2I(IXLOC,0)
            CALL DRAW2I(IXLOC,INT(YWKSIZ(IWKIND)))
            CALL MOVE2I(0,IYLOC)
            CALL DRAW2I(INT(XWKSIZ(IWKIND)),IYLOC)
         ENDIF
         IF(IPET.EQ.3)THEN
            RX=FLOAT(IXLOC-IXLOCP)
            RY=FLOAT(IYLOC-IYLOCP)
            IRAD=NINT(SQRT(RX*RX+RY*RY))
            CALL CIRCI(IXLOCP,IYLOCP,IRAD)
         ENDIF
         IF(IPET.EQ.4.OR.IPET.EQ.3)THEN
            CALL MOVE2I(IXLOCP,IYLOCP)
            CALL DRAW2I(IXLOC,IYLOC)
         ENDIF
         IF(IPET.EQ.5)THEN
            CALL SBOXI(IXLOCP,IYLOCP,IXLOC,IYLOC)
         ENDIF
      ENDIF
      IXLOCO=IXLOC
      IYLOCO=IYLOC
      ISTATI=ICRAWL(IXLOC,IYLOC)
      IF(ISTATI.GT. 0 .OR. LOINS)THEN
         IF(ISTATI .EQ. 10 .or. ISTATI .EQ. 11)THEN
            RQUEST(11)=FLOAT(IXLOC)/WKMAX(IWKIND)
         ENDIF
         IF(ISTATI .EQ. 1 .or. ISTATI .EQ. 11)THEN
            RQUEST(12)=(YWKSIZ(IWKIND)-FLOAT(IYLOC))/WKMAX(IWKIND)
         ENDIF
   50    IF(LOINS)THEN
            IF(IPET.EQ.1)THEN
               CALL MOVE2I(IXLOCO,IYLOCO-10)
               CALL DRAW2I(IXLOCO,IYLOCO+10)
               CALL MOVE2I(IXLOCO-10,IYLOCO)
               CALL DRAW2I(IXLOCO+10,IYLOCO)
            ENDIF
            IF(IPET.EQ.2)THEN
               CALL MOVE2I(IXLOCO,0)
               CALL DRAW2I(IXLOCO,INT(YWKSIZ(IWKIND)))
               CALL MOVE2I(0,IYLOCO)
               CALL DRAW2I(INT(XWKSIZ(IWKIND)),IYLOCO)
            ENDIF
            IF(IPET.EQ.3)THEN
               RX=FLOAT(IXLOCO-IXLOCP)
               RY=FLOAT(IYLOCO-IYLOCP)
               IRAD=NINT(SQRT(RX*RX+RY*RY))
               CALL CIRCI(IXLOCP,IYLOCP,IRAD)
            ENDIF
            IF(IPET.EQ.4.OR.IPET.EQ.3)THEN
               CALL MOVE2I(IXLOCP,IYLOCP)
               CALL DRAW2I(IXLOCO,IYLOCO)
            ENDIF
            IF(IPET.EQ.5)THEN
               CALL SBOXI(IXLOCP,IYLOCP,IXLOCO,IYLOCO)
            ENDIF
         ENDIF
         LOINS=.TRUE.
         GOTO 60
      ENDIF
   60 IF(ISTATI .EQ. 0)THEN
         ISTATI=1
         GOTO 70
      ENDIF
      IF(ISTATI .EQ. -1)THEN
         ISTATI=0
         GOTO 70
      ENDIF
      IF (.NOT. SAMPLE) GOTO 40
      ISTATI = 1
   70 CONTINUE
      IER =  SET_XOR(0)
      CALL COLOR(IPLCI+IOFCOL)
      LOINS=.FALSE.
      IWKNB = ISAVE
+SELF, IF=MSDOS, IF=-NDP.
      IIX= IXLOCO
      IIY= IYLOCO
+SELF, IF=X11,MSDOS, IF=-NDP.
*
      IF(LCN.EQ.99)THEN
         IIX=INT(XLOC)
         IIY=INT(YLOC)
         ISTATI=99
         GOTO 80
      ENDIF
      CALL IXSELWI(IWINID(IWKIND))
      IF(SAMPLE)THEN
         ISTATI=IXREQLO(1,IPET,IIX,IIY)
      ELSE
         ISTATI=IXREQLO(0,IPET,IIX,IIY)
      ENDIF
      IF(ISTATI.EQ.3)ISTATI=0
   80 RQUEST(11)=FLOAT(IIX)/WKMAX(IWKIND)
      RQUEST(12)=(YWKSIZ(IWKIND)-FLOAT(IIY))/WKMAX(IWKIND)
+SELF, IF=MACMPW.
*
      IF(SAMPLE)THEN
         ISTATI=IMREQLO(1,IPET,IIX,IIY)
      ELSE
         ISTATI=IMREQLO(0,IPET,IIX,IIY)
      ENDIF
      IF(ISTATI.EQ.3)ISTATI=0
      RQUEST(11)=FLOAT(IIX)/WKMAX(IWKIND)
      RQUEST(12)=(YWKSIZ(IWKIND)-FLOAT(IIY))/WKMAX(IWKIND)
+SELF.
*
   90 IF(ISTATI.EQ.0.AND..NOT.SAMPLE)THEN
         RQUEST(11)=OLDXP
         RQUEST(12)=OLDYP
         RETURN
      ENDIF
      OLDXP=RQUEST(11)
      OLDYP=RQUEST(12)
      SCALE=1.
      IF(REDIT.NE.0.)SCALE=REDIT
      RQUEST(20)=0.
      RQUEST(21)=1.
      RQUEST(22)=0.
      RQUEST(23)=1.
      RQUEST(30)=0.
      RQUEST(31)=1.
      RQUEST(32)=0.
      RQUEST(33)=1.
      ITNRI=0
      XLOC=(RQUEST(11)+RDWXMI*REDIT)/SCALE
      YLOC=(RQUEST(12)+RDWYMI*REDIT)/SCALE
+SELF, IF=ZEBRA.
*
*             There is displayed picture
*
      IF(LPICD.GT.0)THEN
         IPRIOO=IQ(LDNT0+3)
         NBNT=IQ(LPICD+8)-1
         LN=LQ(LDNT0)
         DO 100 I=1,NBNT
            IAWV=LDF+IQ(LN+2)
            IPRION=IQ(LN+3)
            RQUEST(20)=Q(IAWV)
            RQUEST(21)=Q(IAWV+1)
            RQUEST(22)=Q(IAWV+2)
            RQUEST(23)=Q(IAWV+3)
            RQUEST(30)=Q(IAWV+4)
            RQUEST(31)=Q(IAWV+5)
            RQUEST(32)=Q(IAWV+6)
            RQUEST(33)=Q(IAWV+7)
            IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +         (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +         (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +         (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
               IF(IPRION.GT.IPRIOO)THEN
                  XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +                 -RQUEST(30))
     +                 /(RQUEST(31)-RQUEST(30)))
     +                 *(RQUEST(21)-RQUEST(20))
     +                +RQUEST(20)
                  YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +                 -RQUEST(32))
     +                 /(RQUEST(33)-RQUEST(32)))
     +                 *(RQUEST(23)-RQUEST(22))
     +                 +RQUEST(22)
                  ITNRI=IQ(LN+1)
                  IPRIOO=IPRION
               ENDIF
            ENDIF
            LN=LQ(LN)
            IF(LN.EQ.0)RETURN
  100    CONTINUE
         RETURN
      ENDIF
+SELF, IF=-NTC, IF=-X11.
*
*             The computing of XLOC and YLOC in done with the parameters
*             stored in HINT.
*
      NBNT=NTSTOR(1)
      IPRIOO=NT0PRI
      DO 110 I=1,NBNT
         NNT=NTSTOR(2*I)
         CALL IZGNT(NNT,IFIND,IAWV,IPRION,IHPRIO)
         RQUEST(20)=WNVPST(IAWV)
         RQUEST(21)=WNVPST(IAWV+1)
         RQUEST(22)=WNVPST(IAWV+2)
         RQUEST(23)=WNVPST(IAWV+3)
         RQUEST(30)=WNVPST(IAWV+4)
         RQUEST(31)=WNVPST(IAWV+5)
         RQUEST(32)=WNVPST(IAWV+6)
         RQUEST(33)=WNVPST(IAWV+7)
         IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +      (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +      (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +      (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
            IF(IPRION.GT.IPRIOO)THEN
               XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +              -RQUEST(30))
     +              /(RQUEST(31)-RQUEST(30)))
     +              *(RQUEST(21)-RQUEST(20))
     +             +RQUEST(20)
               YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +              -RQUEST(32))
     +              /(RQUEST(33)-RQUEST(32)))
     +              *(RQUEST(23)-RQUEST(22))
     +              +RQUEST(22)
               ITNRI=NNT
               IPRIOO=IPRION
            ENDIF
         ENDIF
  110 CONTINUE
+SELF, IF=NTC,X11.
      IPRIOO = NT0PRI
      IEND   = IGNNXT(1)
  120 IF(IEND.EQ.0)THEN
         CALL IGNGET(NNT,IPRION,IHPRIO
     +,              RQUEST(20),RQUEST(21),RQUEST(22),RQUEST(23)
     +,              RQUEST(30),RQUEST(31),RQUEST(32),RQUEST(33),I3D)
         IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +      (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +      (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +      (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
            IF(IPRION.GT.IPRIOO)THEN
               XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +              -RQUEST(30))
     +              /(RQUEST(31)-RQUEST(30)))
     +              *(RQUEST(21)-RQUEST(20))
     +             +RQUEST(20)
               YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +              -RQUEST(32))
     +              /(RQUEST(33)-RQUEST(32)))
     +              *(RQUEST(23)-RQUEST(22))
     +              +RQUEST(22)
               ITNRI=NNT
               IPRIOO=IPRION
            ENDIF
         ENDIF
         IEND = IGNNXT(0)
         GOTO 120
      ENDIF
+SELF.
*
      END
+DECK,  IRQST, T=FORT.
* Revision 1.2  1996/09/25 14:58:51  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE IRQST(IWKID,ISTD,IISTAT,L,STR)
      ENTRY      GRQST(IWKID,ISTD,IISTAT,L,STR)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+CDE, HIQUES.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=MAIL.
+CDE, HIFLAG.
+SELF.
      CHARACTER*(*) STR
*
+SELF, IF=MSDOS.
      INTEGER BACKSP, RETKEY, LARROW, DELCHR, CTRL_C, ESC
      DATA BACKSP, RETKEY, LARROW, DELCHR, ESC /8, 13, -75, -83, 27/
      DATA CTRL_C /3/
+SELF.
      IF(IWKID.LT.0)THEN
         IIWKID = ABS(IWKID)
         RXPOS  = RQUEST(81)
         RYPOS  = RQUEST(91)
      ELSE
         IIWKID = IWKID
         RXPOS  = 0.
         RYPOS  = 0.
      ENDIF
*
      IWKIND    = IGIWIN(IIWKID)
      IQUEST(1) = 0
      IF(IWKIND.EQ.0)THEN
         CALL IGERR('Workstation is not open','IRQST')
         RETURN
      ENDIF
      IF(IWTYL(IWKIND).LE.0)THEN
* No locator for Metafile.
         CALL IGERR('Request string is not available','IRQST')
         RETURN
      ENDIF
*
      IISTAT=0
+SELF, IF=MSDOS.
      ISAVE = IWKNB
      IWKNB = IWKIND
+SELF.
*
+SELF, IF=MAIL.
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(3I3)') 556,IIWKID,ISTD
         CALL IMWRIT(1)
         READ (5,'(2I5,A)') IISTAT,L,STR
         CALL IMWRIT(5)
         RETURN
      ENDIF
*
+SELF, IF=MACMPW.
      CALL IMACPLO(0,0,-999)
      WRITE (6,'(X,A,$)',ERR=100,END=100) '>'
      READ (5,'(A)',ERR=100,END=100) STR
      L=LENOCC(STR)
      IISTAT=1
100   RETURN
+SELF, IF=FALCO.
      IF(IWTYL(IWKIND).EQ.7878.OR.IWTYL(IWKIND).EQ.7879)THEN
         CALL IFMOVE(0.,0.)
         CALL IFPUT(0)
         READ (*,'(A)') STR
         CALL IFPUT(31)
         CALL IFPUT(24)
         CALL IFPUT(0)
         L = LENOCC(STR)
         RETURN
      ENDIF
*
+SELF, IF=GL, IF=-MSDOS.
      CALL WINSET(IWINID(IWKIND))
      CALL QRESET
      CALL QDEVIC(KEYBD)
      CALL QDEVIC(RETKEY)
      CALL QDEVIC(BACKSP)
      CALL CLKON
      IXPOS=INT(RXPOS)
      L=1
      STR=' '
   20 CALL COLOR(IOFCOL+1)
      ICURCI(IWKIND)=1
      CALL CMOV2I(IXPOS,INT(RYPOS))
      CALL CHARST('_',1)
      IDEV=QREAD(IVAL)
      CALL COLOR(IOFCOL)
      ICURCI(IWKIND)=0
      CALL CMOV2I(IXPOS,INT(RYPOS))
      CALL CHARST('_',1)
      IF(IDEV.EQ.RETKEY)THEN
         CALL UNQDEV(KEYBD)
         CALL UNQDEV(RETKEY)
         CALL UNQDEV(BACKSP)
         CALL CLKOFF
         IISTAT=1
         RETURN
      ENDIF
      IF(IDEV.EQ.BACKSP)THEN
         IF(L.EQ.1)THEN
            CALL RINGBE
            GOTO 20
         ENDIF
         L=L-1
         IXPOS=IXPOS-STRWID(STR(L:L),1)
         CALL CMOV2I(IXPOS,INT(RYPOS))
         CALL CHARST(STR(L:L),1)
         STR(L:L)=' '
         GOTO 20
      ENDIF
      IF(IVAL.LT.32)GOTO 20
      IF(L.GT.LEN(STR))THEN
         CALL RINGBE
         GOTO 20
      ENDIF
      CALL COLOR(IOFCOL+1)
      ICURCI(IWKIND)=1
      CALL CMOV2I(IXPOS,INT(RYPOS))
      CALL CHARST(CHAR(IVAL),1)
      STR(L:L)=CHAR(IVAL)
      IXPOS=IXPOS+STRWID(CHAR(IVAL),1)
      L=L+1
      GOTO 20
*
+SELF, IF=MSDOS.
      CALL WINSET(IWINID(IWKIND))
      IHHH  = STRWID('_',1)
      RYPOS = YWKSIZ(IWKIND)-RYPOS
      IXPOS = NINT(RXPOS)
      IYPOS = NINT(RYPOS) - IHHH + 1
      L     = 1
      STR   = ' '
   30 CALL COLOR(IOFCOL+1)
      ICURCI(IWKIND)=1
      IER  = GRAPHIC_TEXT('_',IXPOS,IYPOS,IOFCOL+1)
      IDEV = PAUSE()
      IF (IDEV .EQ. CTRL_C) THEN
         CALL IGEND
         CALL ABEND
      END IF
      IF (IDEV .EQ. LARROW .OR. IDEV .EQ. DELCHR) IDEV = BACKSP
      IF (IDEV .LE. 0)GOTO 30
      CALL COLOR(IOFCOL)
      ICURCI(IWKIND)=0
      IER = GRAPHIC_TEXT('_',IXPOS,IYPOS,IOFCOL)
      IF(IDEV.EQ.RETKEY .OR. IDEV .EQ. ESC)THEN
         IISTAT=1
         IWKNB = ISAVE
         RETURN
      ENDIF
      IF(IDEV.EQ.BACKSP)THEN
         IF(L.EQ.1)THEN
            IER = BEEP()
            IER = BEEP()
            GOTO 30
         ENDIF
         L=L-1
         IXPOS=IXPOS-STRWID(STR(L:L),1)
         IER = GRAPHIC_TEXT(STR(L:L),IXPOS,IYPOS,IOFCOL)
         STR(L:L)=' '
         GOTO 30
      ENDIF
      IF(IDEV.LT.32)GOTO 30
      IF(L.GT.LEN(STR))THEN
         IER = BEEP()
         IER = BEEP()
         GOTO 30
      ENDIF
      CALL COLOR(IOFCOL+1)
      ICURCI(IWKIND)=1
      IER = GRAPHIC_TEXT(CHAR(IDEV),IXPOS,IYPOS,IOFCOL+1)
      STR(L:L)=CHAR(IDEV)
      IXPOS=IXPOS+STRWID(CHAR(IDEV),1)
      L=L+1
      GOTO 30
*
+SELF, IF=X11.
      RYPOS  = YWKSIZ(IWKIND)-RYPOS
      IXPOS  = NINT(RXPOS)
      IYPOS  = NINT(RYPOS)
      L      = LEN(STR)
      IISTAT = IXREQST(IXPOS,IYPOS,L,STR)
      L      = LENOCC(STR)
*
+SELF.
      END
+DECK,  ISCHH, T=FORT.
* Revision 1.2  1998/01/28 14:34:48  couet
* - GGDM driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE ISCHH(CHH)
      ENTRY      GSCHH(CHH)
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
+SELF, IF=MSDOS.
+CDE, HIKERN.
+SELF, IF=MSDOS.
+CDE, HIWCDC.
+SELF.
      IF(CHH.EQ.RCHH)RETURN
      RCHH=CHH
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ICHHCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=FALCO.
         IF(IWTYPE.EQ.7878.OR.IWTYPE.EQ.7879)RETURN
+SELF, IF=PHIGS.
         CALL PSCHH(CHH)
+SELF, IF=MSDOS.
         ISAVE=IWKNB
         IWKNB=IGIWIN(1)
         IF(IWKNB.NE.0)THEN
            MAG_Y=IABS(IYWCDC(RCHH)-IYWCDC(0.0))/8
            IF(MAG_Y.EQ.0)MAG_Y=1
            MAG_X=MAG_Y
            IER=MAGNIFY_TEXT(MAG_X,MAG_Y)
         ENDIF
         IWKNB = ISAVE
+SELF.
      ENDIF
      END
+DECK,  ISCHUP, T=FORT.
* Revision 1.2  1998/01/28 14:34:49  couet
* - GGDM driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE ISCHUP(CHUX,CHUY)
      ENTRY      GSCHUP(CHUX,CHUY)
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF((CHUX.EQ.RCHUX).AND.(CHUY.EQ.RCHUY))RETURN
      RCHUX=CHUX
      RCHUY=CHUY
      IF((RCHUX.EQ.0.).AND.(RCHUY.EQ.1.))THEN
         RANGLE=0.
      ELSEIF((RCHUX.EQ.-1.).AND.(RCHUY.EQ.0.))THEN
         RANGLE=90.
      ELSEIF((RCHUX.EQ.0.).AND.(RCHUY.EQ.-1.))THEN
         RANGLE=180.
      ELSEIF((RCHUX.EQ.1.).AND.(RCHUY.EQ.0.))THEN
         RANGLE=270.
      ELSE
         RANGLE=((ACOS(RCHUX/SQRT(RCHUX**2+RCHUY**2))*180.)
     +           /3.14159)-90.
         IF(RCHUY.LT.0.)RANGLE=180.-RANGLE
         IF(ABS(RANGLE).LE.0.01)RANGLE=0.
      ENDIF
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IANGCO)
+SELF.
      END
+DECK,  ISCLIP, T=FORT.
* Revision 1.3  1998/01/28 14:34:50  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:52  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE ISCLIP(ICLSW)
      ENTRY      GSCLIP(ICLSW)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=KERNEL.
+CDE, HIWCDC.
+SELF.
      ICLIP=ICLSW
      IF(GFLAG)THEN
+SELF, IF=KERNEL,FALCO.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=FALCO.
            IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)GOTO 10
+SELF, IF=GL.
            IF(ICLIP.NE.0)THEN
               WINSIZ(1)=IXWCDC(RWXMIN)
               WINSIZ(2)=IXWCDC(RWXMAX)
               WINSIZ(3)=IYWCDC(RWYMIN)
               WINSIZ(4)=IYWCDC(RWYMAX)
            ELSE
               WINSIZ(1)=0
               WINSIZ(2)=INT(XWKSIZ(IWKNB))
               WINSIZ(3)=0
               WINSIZ(4)=INT(YWKSIZ(IWKNB))
            ENDIF
            CALL SCRMAS(WINSIZ(1),WINSIZ(2),WINSIZ(3),WINSIZ(4))
+SELF, IF=X11.
            IF(ICLIP.NE.0)THEN
               IX=IXWCDC(RWXMIN)
               IY=IYWCDC(RWYMAX)
               IW=IXWCDC(RWXMAX)-IXWCDC(RWXMIN)
               IH=IYWCDC(RWYMIN)-IYWCDC(RWYMAX)
               CALL IXCLIP(IWINID(IWKNB),IX,IY,IW,IH)
            ELSE
               CALL IXNOCLI(IWINID(IWKNB))
            ENDIF
+SELF, IF=MACMPW.
            IF(ICLIP.NE.0)THEN
               IX=IXWCDC(RWXMIN)
               IY=IYWCDC(RWYMAX)
               IW=IXWCDC(RWXMAX)-IXWCDC(RWXMIN)
               IH=IYWCDC(RWYMIN)-IYWCDC(RWYMAX)
               CALL IMCLIP(IX,IY,IW,IH)
            ELSE
               CALL IMNOCLI
            ENDIF
+SELF, IF=KERNEL,FALCO.
   10    CONTINUE
+SELF.
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZSCLI(ICLSW)
+SELF.
      END
+DECK,  ISCR, T=FORT.
* Revision 1.2  1996/09/25 14:58:53  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:56  mclareni
* Higz

      SUBROUTINE ISCR(IWKID,ICI,CR,CG,CB)
      ENTRY      GSCR(IWKID,ICI,CR,CG,CB)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIFLAG.
+CDE, HILUT.
+SELF, IF=X11,FALCO.
+CDE, HIATT.
+SELF.
*
      I=MIN(NBCLUT-1,ABS(ICI))+1
      REDLUT(I)=CR
      GRNLUT(I)=CG
      BLULUT(I)=CB
*
      IF(GFLAG)THEN
         J=IGIWTY(IWKID)
         IF(J.LE.0)RETURN
+SELF, IF=FALCO.
         IF(J.EQ.7878.OR.J.EQ.7879)RETURN
+SELF, IF=GL, IF=-MSDOS.
         CALL MAPCOL(ICI+IOFCOL,INT(255.*CR),INT(255.*CG),INT(255.*CB))
+SELF, IF=MSDOS.
         CALL MAPCOL(ICI+IOFCOL,CR,CG,CB)
+SELF, IF=X11.
         CALL IXSETCO(ICI,CR,CG,CB)
         IF(IPLCI.EQ.ICI)CALL IXSETLC(ICI)
         IF(IFACI.EQ.ICI)CALL IXSETFC(ICI)
         IF(IPMCI.EQ.ICI)CALL IXSETMC(ICI)
         IF(ITXCI.EQ.ICI)CALL IXSETTC(ICI)
+SELF, IF=MACMPW.
         CALL IMSETCO(ICI,CR,CG,CB)
+SELF, IF=PHIGS.
         CALL PSCR(IWKID,ICI,CR,CG,CB)
+SELF.
      ENDIF
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZSCOR(IWKID,ICI,CR,CG,CB)
+SELF.
      END
+DECK,  ISELNT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISELNT(NT)
      ENTRY      GSELNT(NT)
+SELF, IF=-NTC, IF=-X11.
+CDE, HINT.
+SELF.
+CDE, HIFLAG.
+CDE, HIATT.
+SELF, IF=PHIGS.
      DIMENSION RMOR(3,3),RMAP(3,3),VWWNLM(4),PJVPLM(4)
*
+SELF, IF=-NTC, IF=-X11.
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
      IF(NT.EQ.0)THEN
         NT0PRI=IHPRIO+1
         RWXMIN=0.
         RWYMIN=0.
         RWXMAX=1.
         RWYMAX=1.
         RVXMIN=0.
         RVYMIN=0.
         RVXMAX=1.
         RVYMAX=1.
         GOTO 10
      ENDIF
*
      IF(IFIND.NE.0)THEN
         RWXMIN=WNVPST(IAWV)
         RWYMIN=WNVPST(IAWV+2)
         RWXMAX=WNVPST(IAWV+1)
         RWYMAX=WNVPST(IAWV+3)
         RVXMIN=WNVPST(IAWV+4)
         RVYMIN=WNVPST(IAWV+6)
         RVXMAX=WNVPST(IAWV+5)
         RVYMAX=WNVPST(IAWV+7)
         NTSTOR(IFIND)=IHPRIO+1
      ELSE
         RWXMIN=0.
         RWYMIN=0.
         RWXMAX=1.
         RWYMAX=1.
         RVXMIN=0.
         RVYMIN=0.
         RVXMAX=1.
         RVYMAX=1.
         NBNT=NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISELNT')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2)=NT
         NTSTOR(2*NBNT+3)=IHPRIO+1
         WNVPST(8*NBNT+1)=0.
         WNVPST(8*NBNT+2)=1.
         WNVPST(8*NBNT+3)=0.
         WNVPST(8*NBNT+4)=1.
         WNVPST(8*NBNT+5)=0.
         WNVPST(8*NBNT+6)=1.
         WNVPST(8*NBNT+7)=0.
         WNVPST(8*NBNT+8)=1.
         NTSTOR(1)=NTSTOR(1)+1
      ENDIF
   10 CONTINUE
*
+SELF, IF=NTC,X11.
      IF(IGNSCU(NT).EQ.0)CALL IGNCRE(NT)
      CALL IGNGET(I0,I1,IHPRIO
     +,           RWXMIN,RWXMAX,RWYMIN,RWYMAX
     +,           RVXMIN,RVXMAX,RVYMIN,RVYMAX,I3D)
      CALL IGNSPR(IHPRIO+1)
      IF(I3D.NE.0)CALL IGSVIE
*
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZSELN(NT)
+SELF, IF=-PHIGS.
      XRATIO=(RVXMAX-RVXMIN)/(RWXMAX-RWXMIN)
      YRATIO=(RVYMAX-RVYMIN)/(RWYMAX-RWYMIN)
+SELF, IF=PHIGS.
      VWWNLM(1)=RWXMIN
      VWWNLM(2)=RWXMAX
      VWWNLM(3)=RWYMIN
      VWWNLM(4)=RWYMAX
      PJVPLM(1)=RVXMIN
      PJVPLM(2)=RVXMAX
      PJVPLM(3)=RVYMIN
      PJVPLM(4)=RVYMAX
      CALL PEVOM(0.,0.,0.,1.,IERR,RMOR)
      CALL PEVMM(VWWNLM,PJVPLM,IERR,RMAP)
      IF(NT.NE.0)THEN
         DO 20 I=1,INOPWK
            CALL PSVWR(ILOPWK(I),NT,RMOR,RMAP,PJVPLM,1)
            CALL PUWK(ILOPWK(I),1)
   20    CONTINUE
      ENDIF
      CALL PSVWI(NT)
+SELF.
      INTR=NT
      CALL ISCLIP(ICLIP)
      END
+DECK,  ISFACI, T=FORT.
* Revision 1.3  1998/01/28 14:34:51  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:56  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISFACI(ICOLI)
      ENTRY      GSFACI(ICOLI)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(ICOLI.EQ.IFACI)RETURN
      IFACI=ICOLI
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFACCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=PHIGS.
         CALL PSICI(IFACI)
+SELF, IF=KERNEL,FALCO.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=FALCO.
            IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)GOTO 10
+SELF, IF=GL.
            CALL COLOR(IFACI+IOFCOL)
            ICURCI(IWKNB)=IFACI
+SELF, IF=X11.
            CALL IXSETFC(IFACI)
+SELF, IF=MACMPW.
            CALL IMSETFC(IFACI)
+SELF, IF=KERNEL,FALCO.
   10    CONTINUE
+SELF.
      ENDIF
      END
+DECK,  ISFAIS, T=FORT.
* Revision 1.3  1996/12/09 13:47:28  couet
* - protection added against IWTYP=0
* Revision 1.2  1996/09/25 14:58:56  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISFAIS(INTS)
      ENTRY      GSFAIS(INTS)
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(INTS.EQ.IFAIS)RETURN
      IF((INTS.LT.0).OR.(INTS.GT.3))THEN
         CALL IGERR('Fill area interior style must be > -1 and < 4'
     +,             'ISFAIS')
         RETURN
      ENDIF
      IFAIS=INTS
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFAICO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=FALCO.
         IF(IWTYPE.EQ.7878.OR.IWTYPE.EQ.7879)RETURN
+SELF, IF=GL, IF=-MSDOS.
         IF(IFAIS.EQ.1)CALL SETPAT(0)
+SELF, IF=X11,MSDOS, IF=-NDP.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IXSETFS(IFAIS,ABS(IFASI))
   10    CONTINUE
+SELF, IF=MACMPW.
         CALL IMSETFS(IFAIS,ABS(IFASI))
+SELF, IF=PHIGS.
         CALL PSIS(IFAIS)
+SELF.
      ENDIF
      END
+DECK,  ISFASI, T=FORT.
* Revision 1.2  1998/01/28 14:34:52  couet
* - GGDM driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISFASI(ISTYL)
      ENTRY      GSFASI(ISTYL)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(ISTYL.EQ.IFASI)RETURN
      IFASI=ISTYL
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFASCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=FALCO.
         IF(IWTYPE.EQ.7878.OR.IWTYPE.EQ.7879)RETURN
+SELF, IF=GL.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
            IF(IFAIS.LE.1)THEN
               CALL SETPAT(0)
            ELSE
               CALL SETPAT(IFASI)
            ENDIF
   10    CONTINUE
+SELF, IF=X11.
         CALL IXSETFS(IFAIS,ABS(IFASI))
+SELF, IF=MACMPW.
         CALL IMSETFS(IFAIS,ABS(IFASI))
+SELF, IF=PHIGS.
         CALL PSISI(IFASI)
+SELF.
      ENDIF
      END
+DECK,  ISLN, T=FORT.
* Revision 1.3  1998/01/28 14:34:53  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:57  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISLN(LTYPE)
      ENTRY      GSLN(LTYPE)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=X11.
      INTEGER DASHED(2),DOTTED(2),DSHDOT(4)
      DATA DASHED/5,5/
      DATA DOTTED/1,3/
      DATA DSHDOT/5,3,1,3/
+SELF.
      IF(LTYPE.EQ.ILN)RETURN
      ILN=LTYPE
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ILNCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=PHIGS.
         CALL PSLN(ILN)
+SELF, IF=-BATCH.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=FALCO.
            IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)THEN
               CALL IGSG(1)
               CALL IFPUT(27)
               IF(ILN.EQ.1)CALL IFPUT(IGASCI('`'))
               IF(ILN.EQ.2)CALL IFPUT(IGASCI('a'))
               IF(ILN.EQ.3)CALL IFPUT(IGASCI('c'))
               IF(ILN.EQ.4)CALL IFPUT(IGASCI('b'))
               IF(ILN.EQ.5)CALL IFPUT(IGASCI('d'))
               CALL IFPUT(0)
               GOTO 10
            ENDIF
+SELF, IF=GL.
            CALL SETLIN(ILN-1)
+SELF, IF=X11, IF=-WINNT.
            IF(ILN.EQ.1)CALL IXSETLS(0,0)
            IF(ILN.EQ.2)CALL IXSETLS(2,DASHED)
            IF(ILN.EQ.3)CALL IXSETLS(2,DOTTED)
            IF(ILN.EQ.4)CALL IXSETLS(4,DSHDOT)
+SELF, IF=WINNT.
            CALL IXSETLS(-ILN,0)
+SELF, IF=-BATCH.
   10    CONTINUE
+SELF.
      ENDIF
      END
+DECK,  ISLWSC, T=FORT.
* Revision 1.3  1998/01/28 14:34:54  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:58  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISLWSC(WIDTH)
      ENTRY      GSLWSC(WIDTH)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(WIDTH.EQ.RLWSC)RETURN
      RLWSC=WIDTH
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ILWSCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=PHIGS.
         CALL PSLWSC(RLWSC)
+SELF, IF=-BATCH.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=FALCO.
            IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)GOTO 10
+SELF, IF=GL.
            CALL LINEWI(INT(RLWSC))
+SELF, IF=X11.
            CALL IXSETLN(MAX(INT(RLWSC/2.2),1))
+SELF, IF=MACMPW.
            CALL IMSETLN(INT(RLWSC))
+SELF, IF=-BATCH.
   10    CONTINUE
+SELF.
      ENDIF
      END
+DECK,  ISMK, T=FORT.
* Revision 1.2  1998/01/28 14:34:55  couet
* - GGDM driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISMK(MTYPE)
      ENTRY      GSMK(MTYPE)
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(MTYPE.EQ.IMK)RETURN
      IMK=MTYPE
+SELF, IF=-X11.
      IF(IMK.EQ.3)IMK=31
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IMKCO)
+SELF, IF=PHIGS.
      CALL PSMK(MTYPE)
+SELF.
      END
+DECK,  ISMKSC, T=FORT.
* Revision 1.2  1998/01/28 14:34:56  couet
* - GGDM driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISMKSC(RMSCF)
      ENTRY      GSMKSC(RMSCF)
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(RMSCF.EQ.RMKSC)RETURN
      RMKSC=RMSCF
+SELF, IF=PHIGS.
      CALL PSMKSC(RMKSC)
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IMKSCO)
+SELF.
      END
+DECK,  ISPLCI, T=FORT.
* Revision 1.3  1998/01/28 14:34:57  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:58:59  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:57  mclareni
* Higz

      SUBROUTINE ISPLCI(ICOLI)
      ENTRY      GSPLCI(ICOLI)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(ICOLI.EQ.IPLCI)RETURN
      IPLCI=ICOLI
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IPLCCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=PHIGS.
         CALL PSPLCI(IPLCI)
+SELF, IF=KERNEL,FALCO.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=FALCO.
            IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)GOTO 10
+SELF, IF=GL.
            CALL COLOR(IPLCI+IOFCOL)
            ICURCI(IWKNB)=IPLCI
+SELF, IF=X11.
            CALL IXSETLC(IPLCI)
+SELF, IF=MACMPW.
            CALL IMSETLC(IPLCI)
+SELF, IF=KERNEL,FALCO.
   10    CONTINUE
+SELF.
      ENDIF
      END
+DECK,  ISPMCI, T=FORT.
* Revision 1.3  1998/01/28 14:34:57  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:59:00  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:58  mclareni
* Higz

      SUBROUTINE ISPMCI(ICOLI)
      ENTRY      GSPMCI(ICOLI)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(ICOLI.EQ.IPMCI)RETURN
      IPMCI=ICOLI
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IPMCCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=PHIGS.
         CALL PSPMCI(IPMCI)
+SELF, IF=KERNEL,FALCO.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=FALCO.
            IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)GOTO 10
+SELF, IF=GL.
            CALL COLOR(IPMCI+IOFCOL)
            ICURCI(IWKNB)=IPMCI
+SELF, IF=X11.
            CALL IXSETMC(IPMCI)
+SELF, IF=MACMPW.
            CALL IMSETMC(IPMCI)
+SELF, IF=KERNEL,FALCO.
   10    CONTINUE
+SELF.
      ENDIF
      END
+DECK,  ISTXAL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:58  mclareni
* Higz

      SUBROUTINE ISTXAL(JTXALH,JTXALV)
      ENTRY      GSTXAL(JTXALH,JTXALV)
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF((JTXALH.EQ.ITXALH).AND.(JTXALV.EQ.ITXALV))RETURN
      ITXALH=JTXALH
      ITXALV=JTXALV
      ITXALG=10*JTXALH+JTXALV
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ITXACO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=FALCO.
         IF(IWTYPE.EQ.7878.OR.IWTYPE.EQ.7879)RETURN
+SELF, IF=X11.
         CALL IXSETTA(ITXALH,ITXALV)
+SELF.
      ENDIF
      END
+DECK,  ISTXCI, T=FORT.
* Revision 1.3  1998/01/28 14:34:58  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:59:01  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:58  mclareni
* Higz

      SUBROUTINE ISTXCI(ICOLI)
      ENTRY      GSTXCI(ICOLI)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
      IF(ICOLI.EQ.ITXCI)RETURN
      ITXCI=ICOLI
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ITXCCO)
+SELF.
      IF(GFLAG)THEN
+SELF, IF=PHIGS.
         CALL PSTXCI(ITXCI)
+SELF, IF=KERNEL,FALCO.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=FALCO.
            IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)GOTO 10
+SELF, IF=GL.
            CALL COLOR(ITXCI+IOFCOL)
            ICURCI(IWKNB)=ITXCI
+SELF, IF=X11.
            CALL IXSETTC(ITXCI)
+SELF, IF=KERNEL,FALCO.
   10    CONTINUE
+SELF.
      ENDIF
      END
+DECK,  ISTXFP, T=FORT.
* Revision 1.2  1996/09/25 14:59:02  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:58  mclareni
* Higz

      SUBROUTINE ISTXFP(JFONT,JPREC)
      ENTRY      GSTXFP(JFONT,JPREC)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIATT.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF.
+CDE, HIFLAG.
*
      IF((JFONT.EQ.IFONT).AND.(JPREC.EQ.IPREC))RETURN
      IFONT=JFONT
      IPREC=JPREC
+SELF, IF=MACMPW.
      IF(.NOT.((IFONT.EQ.0.AND.IPREC.EQ.2).OR.
     +  (IFONT.LT.0.AND.IFONT.GT.-25.AND.IPREC.EQ.1)))THEN
        IFONT=0
        IPREC=2
      ENDIF
+SELF.
      IFTPR=10*JFONT+ISIGN(1,JFONT)*JPREC
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ITXFCO)
+SELF.
      IF(IPREC.EQ.2)RETURN
      IF(GFLAG)THEN
+SELF, IF=FALCO.
         IF(IWTYPE.EQ.7878.OR.IWTYPE.EQ.7879)THEN
            IF(IFONT.LT.0.AND.IFONT.GT.-25.AND.IPREC.EQ.1)RETURN
            IFONT=0
            IPREC=2
            RETURN
         ENDIF
+SELF, IF=PHIGS.
         CALL PSTXPR(JPREC)
         CALL PSTXFN(JFONT)
+SELF, IF=-BATCH.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
+SELF, IF=-BATCH.
   10    CONTINUE
+SELF.
      ENDIF
      END
+DECK,  ISVP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:58  mclareni
* Higz

      SUBROUTINE ISVP(NT,X1,X2,Y1,Y2)
      ENTRY      GSVP(NT,X1,X2,Y1,Y2)
+SELF, IF=-NTC, IF=-X11.
+CDE, HINT.
+SELF.
+CDE, HIFLAG.
+CDE, HIATT.
      IF((X1.LT.0).OR.(X1.GT.1)
     +            .OR.
     +   (X2.LT.0).OR.(X2.GT.1)
     +            .OR.
     +   (Y1.LT.0).OR.(Y1.GT.1)
     +            .OR.
     +   (Y2.LT.0).OR.(Y2.GT.1)
     +            .OR.
     +   (Y1.GE.Y2).OR.(X1.GE.X2))THEN
         CALL IGERR('Invalid viewport definition','ISVP')
         RETURN
      ENDIF
      IF(NT.EQ.0)RETURN
+SELF, IF=-NTC, IF=-X11.
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
      IF(IFIND.NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            RVXMIN=X1
            RVYMIN=Y1
            RVXMAX=X2
            RVYMAX=Y2
         ENDIF
         WNVPST(IAWV+4)=X1
         WNVPST(IAWV+5)=X2
         WNVPST(IAWV+6)=Y1
         WNVPST(IAWV+7)=Y2
*
      ELSE
         NBNT=NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISVP')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2)=NT
         WNVPST(8*NBNT+1)=0.
         WNVPST(8*NBNT+2)=1.
         WNVPST(8*NBNT+3)=0.
         WNVPST(8*NBNT+4)=1.
         WNVPST(8*NBNT+5)=X1
         WNVPST(8*NBNT+6)=X2
         WNVPST(8*NBNT+7)=Y1
         WNVPST(8*NBNT+8)=Y2
         NTSTOR(1)=NTSTOR(1)+1
      ENDIF
+SELF, IF=NTC,X11.
      IF(IGNSCU(NT).NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            RVXMIN=X1
            RVYMIN=Y1
            RVXMAX=X2
            RVYMAX=Y2
         ENDIF
      ELSE
         CALL IGNCRE(NT)
      ENDIF
      CALL IGNSVP(X1,X2,Y1,Y2)
+SELF.
      END
+DECK,  ISWKVP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:58  mclareni
* Higz

      SUBROUTINE ISWKVP(IWKID,X1,X2,Y1,Y2)
      ENTRY      GSWKVP(IWKID,X1,X2,Y1,Y2)
+CDE, HIATT.
      I=IGIWIN(IWKID)
      IF(I.LE.0)THEN
         CALL IGERR('Invalid workstation window parameters','ISWKVP')
         RETURN
      ENDIF
      RDVXMI   = X1
      RDVXMA   = X2
      RDVYMI   = Y1
      RDVYMA   = Y2
      XWKV1(I) = X1
      XWKV2(I) = X2
      YWKV1(I) = Y1
      YWKV2(I) = Y2
+SELF, IF=PHIGS.
      CALL PSWKV(IWKID,X1,X2,Y1,Y2)
+SELF.
      END
+DECK,  ISWKWN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:58  mclareni
* Higz

      SUBROUTINE ISWKWN(IWKID,X1,X2,Y1,Y2)
      ENTRY      GSWKWN(IWKID,X1,X2,Y1,Y2)
+CDE, HIATT.
      I=IGIWIN(IWKID)
      IF((X1.LT.0).OR.(X1.GT.1)
     +            .OR.
     +   (X2.LT.0).OR.(X2.GT.1)
     +            .OR.
     +   (Y1.LT.0).OR.(Y1.GT.1)
     +            .OR.
     +   (Y2.LT.0).OR.(Y2.GT.1).OR.(I.LE.0))THEN
         CALL IGERR('Invalid workstation window parameters','ISWKWN')
         RETURN
      ENDIF
      RDWXMI   = X1
      RDWXMA   = X2
      RDWYMI   = Y1
      RDWYMA   = Y2
      XWKW1(I) = X1
      XWKW2(I) = X2
      YWKW1(I) = Y1
      YWKW2(I) = Y2
+SELF, IF=PHIGS.
      CALL PSWKW(IWKID,X1,X2,Y1,Y2)
+SELF.
      END
+DECK,  ISWN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:59  mclareni
* Higz

      SUBROUTINE ISWN(NT,X1,X2,Y1,Y2)
      ENTRY      GSWN(NT,X1,X2,Y1,Y2)
+SELF, IF=-NTC, IF=-X11.
+CDE, HINT.
+SELF.
+CDE, HIFLAG.
+CDE, HIATT.
      IF(NT.EQ.0)RETURN
*
      IF(X1.GE.X2.OR.Y1.GE.Y2)THEN
         CALL IGERR('Bad window range','ISWN')
         RETURN
      ENDIF
*
+SELF, IF=-NTC, IF=-X11.
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
      IF(IFIND.NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            RWXMIN=X1
            RWYMIN=Y1
            RWXMAX=X2
            RWYMAX=Y2
         ENDIF
         WNVPST(IAWV)  =X1
         WNVPST(IAWV+1)=X2
         WNVPST(IAWV+2)=Y1
         WNVPST(IAWV+3)=Y2
*
      ELSE
         NBNT=NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISWN')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2)=NT
         WNVPST(8*NBNT+1)=X1
         WNVPST(8*NBNT+2)=X2
         WNVPST(8*NBNT+3)=Y1
         WNVPST(8*NBNT+4)=Y2
         WNVPST(8*NBNT+5)=0.
         WNVPST(8*NBNT+6)=1.
         WNVPST(8*NBNT+7)=0.
         WNVPST(8*NBNT+8)=1.
         NTSTOR(1)=NTSTOR(1)+1
      ENDIF
+SELF, IF=NTC,X11.
      IF(IGNSCU(NT).NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            RWXMIN=X1
            RWYMIN=Y1
            RWXMAX=X2
            RWYMAX=Y2
         ENDIF
      ELSE
         CALL IGNCRE(NT)
      ENDIF
      CALL IGNSWN(X1,X2,Y1,Y2)
+SELF.
      END
+DECK,  ITX, T=FORT.
* Revision 1.3  1998/01/28 14:34:59  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:59:03  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:59  mclareni
* Higz

      SUBROUTINE ITX(X,Y,CHARS)
      ENTRY      GTX(X,Y,CHARS)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
+CDE, HIFLAG.
+CDE, HIATT.
      CHARACTER*(*) CHARS
      CHARACTER*1 CHOPT
      LOGICAL ZFSAV,PFSAV
*
+SELF, IF=KERNEL.
+CDE, HIWCDC.
+SELF.
      ILEN = LENOCC(CHARS)
      IF(ILEN.EQ.0)RETURN
      IF((IFONT.EQ.0.AND.IPREC.EQ.2).OR.
     +         (IFONT.LT.0.AND.IFONT.GT.-25.AND.IPREC.EQ.1))THEN
         IF((ITXALH.EQ.0).OR.(ITXALH.EQ.1))CHOPT='L'
         IF(ITXALH.EQ.2)THEN
            CHOPT = 'C'
         ELSEIF(ITXALH.EQ.3)THEN
            CHOPT = 'R'
         ELSE
            CHOPT = 'L'
         ENDIF
         IF((ITXALV.EQ.2).OR.(ITXALV.EQ.1))THEN
            YY = Y-RCHH*COS((3.14159/180.)*RANGLE)
            XX = X+RCHH*SIN((3.14159/180.)*RANGLE)
         ELSEIF(ITXALV.EQ.3)THEN
            YY = Y-(RCHH/2.)*COS((3.14159/180.)*RANGLE)
            XX = X+(RCHH/2.)*SIN((3.14159/180.)*RANGLE)
         ELSE
            YY = Y
            XX = X
         ENDIF
         ZFSAV  = ZFLAG
         ZFLAG  = .FALSE.
         PFSAV  = PFLAG
         PFLAG  = .FALSE.
         GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL IGTEXT(XX,YY,CHARS,RCHH,RANGLE,CHOPT)
         ZFLAG  = ZFSAV
         PFLAG  = PFSAV
         GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
      ELSE
         IF(GFLAG)THEN
+SELF, IF=PHIGS.
            CALL PTX(X,Y,CHARS)
+SELF, IF=KERNEL,FALCO.
            IF(ITXALH.EQ.0)ITXALH=1
            DO 10 IWKNB=1,INOPWK
               IF(NODRFL(IWKNB))GOTO 10
               CALL IGSG(IWKNB)
+SELF, IF=FALCO.
               IF(IWTYL(IWKNB).EQ.7878.OR.IWTYL(IWKNB).EQ.7879)GOTO 10
+SELF, IF=GL,MSDOS.
               CALL COLOR(ITXCI+IOFCOL)
               ICURCI(IWKNB)=ITXCI
               ITXW2=STRWID(CHARS,ILEN)/2
               IXX=IXWCDC(X)-(ITXALH-1)*ITXW2
               IYY=IYWCDC(Y)
+SELF, IF=GL, IF=-MSDOS.
               CALL CMOV2I(IXX,IYY)
               CALL CHARST(CHARS,ILEN)
+SELF, IF=MSDOS.
               CALL OUT_TEXT(CHARS(1:ILEN),IXX,IYY,ITXCI+IOFCOL)
+SELF, IF=X11.
               CALL IXSETTA(ITXALH,ITXALV)
               IXX=IXWCDC(X)
               IYY=IYWCDC(Y)
               IF(IKFNTX(IWKNB).EQ.0)THEN
                  CALL IXTEXT(0,IXX,IYY,RANGLE,RMAGN,ILEN,CHARS(1:ILEN))
               ENDIF
+SELF, IF=KERNEL,FALCO.
   10       CONTINUE
+SELF.
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZTX(X,Y,CHARS(1:ILEN))
+SELF.
      END
+DECK,  IUWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:59  mclareni
* Higz

      SUBROUTINE IUWK(IWKID,IRFLG)
      ENTRY      GUWK(IWKID,IRFLG)
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=ZBUF.
+CDE, HIWCDC.
+SELF, IF=PHIGS.
      CALL PXCLOSE_PIPE
+SELF, IF=X11, IF=ZBUF.
      CALL IGNG3D(W3X1,W3X2,W3Y1,W3Y2,W3Z1,W3Z2
     +,           PHI,THETA,PSI
     +,           V3X1,V3X2,V3Y1,V3Y2)
+SELF.
      IF(IWKID.NE.0)THEN
         ITY=IGIWTY(IWKID)
         IF(ITY.GT.0.AND.GRFLAG)THEN
+SELF, IF=FALCO.
            IF(ITY.EQ.7878.OR.ITY.EQ.7879)RETURN
+SELF, IF=GL, IF=SGI.
            CALL GFLUSH
+SELF, IF=X11, IF=ZBUF.
            IF (IZBUF.NE.0) THEN
               IWKNB=1
               IZX = IXWCDC(V3X1)
               IZY = IYWCDC(V3Y2)
               CALL IHZTOX(0,IZX,IZY)
            ENDIF
+SELF, IF=X11.
            CALL IXSELWI(IWINID(IGIWIN(IWKID)))
            CALL IXUPDWI(1)
            CALL IKUWK(IWKID)
+SELF, IF=MACMPW.
            CALL IMUPDWI
+SELF, IF=PHIGS.
            CALL PXOPEN_PIPE(IWKID)
+SELF, IF=MSDOS.
            CALL IMFUWK(ITY)
+SELF.
         ENDIF
      ELSE
         DO 10 I=1,INOPWK
            ITY=IGIWTY(ILOPWK(I))
            IF(ITY.GT.0.AND.ACWKFL(I))THEN
+SELF, IF=FALCO.
               IF(ITY.EQ.7878.OR.ITY.EQ.7879)GOTO 10
+SELF, IF=GL, IF=SGI.
               CALL GFLUSH
+SELF, IF=X11, IF=ZBUF.
               IF (IZBUF.NE.0) THEN
                  IWKNB=I
                  IZX = IXWCDC(V3X1)
                  IZY = IYWCDC(V3Y2)
                  CALL IHZTOX(0,IZX,IZY)
               ENDIF
+SELF, IF=X11.
               CALL IXSELWI(IWINID(I))
               CALL IXUPDWI(1)
               CALL IKUWK(ILOPWK(I))
+SELF, IF=MACMPW.
               CALL IMUPDWI
+SELF, IF=PHIGS.
               CALL PXOPEN_PIPE(ILOPWK(I))
+SELF, IF=MSDOS.
               CALL IMFUWK(ITY)
+SELF.
            ENDIF
   10    CONTINUE
      ENDIF
      END
+PATCH, IH.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
SRCS_F=	ihaxiv.F ihbbox.F ihclev.F ihcspe.F ihdf01.F ihdf02.F \ @@\
	ihdf03.F ihdfl1.F ihdfl2.F ihdfr1.F ihdfr2.F iheran.F ihfbox.F \ @@\
	ihimpf.F ihiso.F ihlegc.F ihlegp.F ihlegr.F ihlegs.F ihligh.F \ @@\
	ihlumi.F ihmc00.F ihmc03.F ihmc04.F ihmc06.F ihmc07.F ihmc10.F \ @@\
	ihmc12.F ihmc13.F ihmcmp.F ihmcpp.F ihmctt.F ihmcub.F ihmcx.F \ @@\
	ihpff.F ihprop.F ihpvie.F ihrcle.F ihrfil.F ihrini.F ihrlin.F \ @@\
	ihroff.F ihsdrl.F ihsini.F ihsmdf.F ihsurc.F ihsurp.F ihsurr.F \ @@\
	ihsurs.F ihsvie.F ihwlin.F ihwphi.F ihwth.F ihwton.F ihwv01.F \ @@\
	ihwv02.F ihwvr1.F ihwvr2.F ihwwnn.F ihwzn.F ihzdep.F ihztst.F

SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  IHAXIV, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz

      SUBROUTINE IHAXIV(RMIN,RMAX,ANG,AV,IX1,IX2,IY1,IY2,IZ1,IZ2)
************************************************************************
*                                                                      *
*     IHAXIV                                     Date:    20.09.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Define axis vertecies                                  *
*                                                                      *
*     Input: RMIN(3) - min-                                            *
*            RMAX(3) -     max scope                                   *
*            ANG     - angle between X and Y axis                      *
*                                                                      *
*     Output: AV(3,8) - axis vertixes                                  *
*             IX1     - 1st point of X-axis                            *
*             IX2     - 2nd point of X-axis                            *
*             IY1     - 1st point of Y-axis                            *
*             IY2     - 2nd point of Y-axis                            *
*             IZ1     - 1st point of Z-axis                            *
*             IZ2     - 2nd point of Z-axis                            *
*                                                                      *
*                  8                        6                          *
*                 / \                      /|\                         *
*              5 /   \ 7                5 / | \ 7                      *
*               |\   /|                  |  |  |                       *
*   THETA < 90  | \6/ |     THETA > 90   | /2\ |                       *
*   (Top view)  |  |  |   (Bottom view)  |/   \|                       *
*              1 \ | /3                 1 \   /3                       *
*                 \|/                      \ /                         *
*                  2                        4                          *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
      REAL              RMIN(3),RMAX(3),AV(3,8),P(2,4)
      DOUBLE PRECISION  RAD,COSA,SINA
*-
      RAD    = ATAN(1.D0)*4./180.
      SINA   = SIN(ANG*RAD)
      COSA   = COS(ANG*RAD)
      P(1,1) = RMIN(1)
      P(2,1) = RMIN(2)
      P(1,2) = RMAX(1)
      P(2,2) = RMIN(2)
      P(1,3) = RMAX(1)
      P(2,3) = RMAX(2)
      P(1,4) = RMIN(1)
      P(2,4) = RMAX(2)
*           F I N D   T H E   M O S T   L E F T   P O I N T
      I1     = 1
      IF (TN(1,1) .LT. 0.)                      I1 = 2
      IF (TN(1,1)*COSA+TN(2,1)*SINA .LT. 0.)    I1 = 5 - I1
*          S E T   O T H E R   P O I N T S
      I2     = MOD(I1,4) + 1
      I3     = MOD(I2,4) + 1
      I4     = MOD(I3,4) + 1
*
**        S E T   A X I S   V E R T I X E S
*
      AV(1,1) = P(1,I1)
      AV(2,1) = P(2,I1)
      AV(1,2) = P(1,I2)
      AV(2,2) = P(2,I2)
      AV(1,3) = P(1,I3)
      AV(2,3) = P(2,I3)
      AV(1,4) = P(1,I4)
      AV(2,4) = P(2,I4)
      DO 100 I=1,4
        AV(3,I)   = RMIN(3)
        AV(1,I+4) = AV(1,I)
        AV(2,I+4) = AV(2,I)
        AV(3,I+4) = RMAX(3)
  100 CONTINUE
*
**          S E T   A X I S
*
      IF (AV(1,1) .EQ. AV(1,2))         IX = 2
      IF (AV(2,1) .EQ. AV(2,2))         IX = 1
      IY     = 3 - IX
*           X - A X I S
      IX1    = IX
      IF (AV(1,IX) .GT. AV(1,IX+1))     IX1 = IX + 1
      IX2    = IX*2 - IX1 + 1
*           Y - A X I S
      IY1    = IY
      IF (AV(2,IY) .GT. AV(2,IY+1))     IY1 = IY + 1
      IY2    = IY*2 - IY1 + 1
*           Z - A X I S
      IZ1    = 1
      IZ2    = 5
*
      IF (TN(3,3) .GE. 0.)              GOTO 999
      K      = (IX1-1)*3 + IX2
*           11  12  13  21  22  23  31  32  33
      GOTO(999,212,999,221,999,223,999,232,999),K
  212 IX1    = 4
      IX2    = 3
      GOTO 300
  221 IX1    = 3
      IX2    = 4
      GOTO 300
  223 IX1    = 1
      IX2    = 4
      GOTO 300
  232 IX1    = 4
      IX2    = 1
      GOTO 300
*
  300 K      = (IY1-1)*3 + IY2
*           11  12  13  21  22  23  31  32  33
      GOTO(999,312,999,321,999,323,999,332,999),K
  312 IY1    = 4
      IY2    = 3
      GOTO 999
  321 IY1    = 3
      IY2    = 4
      GOTO 999
  323 IY1    = 1
      IY2    = 4
      GOTO 999
  332 IY1    = 4
      IY2    = 1
      GOTO 999
*
  999 END
+DECK,  IHBBOX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz

      SUBROUTINE IHBBOX(RMIN,RMAX,ANG,DRFACE)
************************************************************************
*                                                                      *
*     IHBBOX                                     Date:    13.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Draw back surfaces of surrounding box                  *
*                                                                      *
*     References: IHAXIV                                               *
*                                                                      *
*     Input: RMIN(3) - MIN -                                           *
*            RMAX(3) -       MAX scope                                 *
*            ANG     - angle between X and Y axis                      *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
************************************************************************
      REAL              RMIN(3),RMAX(3),AV(3,8),R(3,8),TT(4)
      DOUBLE PRECISION  RAD,COSA,SINA
      INTEGER           ICODES(3),IFACE1(4),IFACE2(4)
      EXTERNAL          DRFACE
      DATA              IFACE1/1,4,8,5/,IFACE2/4,3,7,8/
*-
      RAD    = ATAN(1.D0)*4./180.
      COSA   = COS(RAD*ANG)
      SINA   = SIN(RAD*ANG)
      CALL IHAXIV(RMIN,RMAX,ANG,AV,IX1,IX2,IY1,IY2,IZ1,IZ2)
      DO 10 I=1,8
        R(1,I) = AV(1,I) + AV(2,I)*COSA
        R(2,I) = AV(2,I)*SINA
        R(3,I) = AV(3,I)
  10    CONTINUE
*
**          D R A W   F O R W A R D   F A C E S
*
      ICODES(1) = 0
      ICODES(2) = 0
      ICODES(3) = 0
      TT(1)  = R(3,IFACE1(1))
      TT(2)  = R(3,IFACE1(2))
      TT(3)  = R(3,IFACE1(3))
      TT(4)  = R(3,IFACE1(4))
      CALL DRFACE(ICODES,R,4,IFACE1,TT)
      TT(1)  = R(3,IFACE2(1))
      TT(2)  = R(3,IFACE2(2))
      TT(3)  = R(3,IFACE2(3))
      TT(4)  = R(3,IFACE2(4))
      CALL DRFACE(ICODES,R,4,IFACE2,TT)
*
      RETURN
      END
+DECK,  IHCLEV, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz

      SUBROUTINE IHCLEV(NL,FL,ICL,IREP)
************************************************************************
*                                                                      *
*     IHCLEV                                     Date:    09.01.92     *
*     Author: E.Chernyaev (IHEP/Protvino)        Revised:              *
*                                                                      *
*     Function: Set correspondance between function and color levels   *
*                                                                      *
*     Input: NL        - number of levels                              *
*            FL(NL)    - function levels                               *
*            ICL(NL+1) - colors for levels                             *
*                                                                      *
*     Output: IREP     - reply: 0 O.K.                                 *
*                              -1 error in parameters:                 *
*                          illegal number of levels                    *
*                          function levels must be in increasing order *
*                          negative color index                        *
*                                                                      *
************************************************************************
+CDE, HCLEVL.
      REAL              FL(*)
      INTEGER           ICL(*)
*-
      IREP   = 0
      IF (NL .EQ. 0) THEN
        NLEV   = 0
        GOTO 999
      END IF
*
**          C H E C K   P A R A M E T E R S
*
      IF (NL.LT.0 .OR. NL.GT.LLEV)      GOTO 996
      DO 110 I=2,NL
        IF (FL(I) .LE. FL(I-1))         GOTO 997
  110 CONTINUE
      DO 120 I=1,NL+1
        IF (ICL(I) .LT. 0)              GOTO 998
  120 CONTINUE
*
**          S E T   L E V E L S
*
      NLEV   = NL
      DO 210 I=1,NLEV
        FUNLEV(I) = FL(I)
  210 CONTINUE
      DO 220 I=1,NLEV+1
        ICLEV(I) = ICL(I)
  220 CONTINUE
      GOTO 999
*
  996 WRITE(*,*) 'IHCLEV: illegal number of levels'
      IREP   =-1
      GOTO 999
  997 WRITE(*,*) 'IHCLEV: function levels must be in increasing order'
      IREP   =-1
      GOTO 999
  998 WRITE(*,*) 'IHCLEV: negative color index'
      IREP   =-1
      GOTO 999
  999 RETURN
      END
+DECK,  IHCSPE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz

      SUBROUTINE IHCSPE(NL,FMIN,FMAX,IC,IDC,IREP)
************************************************************************
*                                                                      *
*     IHCSPE                                     Date:    09.01.92     *
*     Author: E.Chernyaev (IHEP/Protvino)        Revised:              *
*                                                                      *
*     Function: Set spectr                                             *
*                                                                      *
*     Input: NL   - number of levels                                   *
*            FMIN - MIN fuction value                                  *
*            FMAX - MAX fuction value                                  *
*            IC   - initial color index (for 1st level)                *
*            IDC  - color index increment                              *
*                                                                      *
*     Output: IREP - reply: 0 O.K.                                     *
*                          -1 error in parameters                      *
*                             F_max less than F_min                    *
*                             illegal number of levels                 *
*                             initial color index is negative          *
*                             color index increment must be positive   *
*                                                                      *
************************************************************************
+CDE, HCLEVL.
*-
      IREP   = 0
      IF (NL .EQ. 0) THEN
        NLEV   = 0
        GOTO 999
      END IF
*
**          C H E C K   P A R A M E T E R S
*
      IF (FMAX .LE. FMIN)               GOTO 995
      IF (NL.LT.0 .OR. NL.GT.LLEV)      GOTO 996
      IF (IC .LT. 0)                    GOTO 997
      IF (IDC .LT. 0)                   GOTO 998
*
**          S E T  S P E C T R
*
      DELF   = (FMAX-FMIN) / NL
      NLEV   =-(NL+1)
      DO 100 I=1,NL+1
        FUNLEV(I)  = FMIN + (I-1)*DELF
        ICLEV(I+1) = IC + (I-1)*IDC
  100 CONTINUE
      ICLEV(1) = ICLEV(2)
      ICLEV(NL+2) = ICLEV(NL+1)
      GOTO 999
*
  995 WRITE (*,*) 'IHCSPE: F_max less than F_min'
      IREP   =-1
      GOTO 999
  996 WRITE (*,*) 'IHCSPE: illegal number of levels'
      IREP   =-1
      GOTO 999
  997 WRITE (*,*) 'IHCSPE: initial color index is negative'
      IREP   =-1
      GOTO 999
  998 WRITE (*,*) 'IHCSPE: color index increment must be positive'
      IREP   =-1
      GOTO 999
  999 RETURN
      END
+DECK,  IHDF01, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHDF01(ICODES,XYZ,NP,IFACE,T)
************************************************************************
*                                                                      *
*     IHDF01                                     Date:    17.09.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 10.01.92     *
*                                                         15.08.93     *
*     Function: Draw face - 1st variant                                *
*               (2 colors: 1st for external surface, 2nd for internal) *
*                                                                      *
*     References: IHWTON                                               *
*                                                                      *
*     Input: ICODES(*) - set of codes for the line (not used)          *
*              ICODES(1) - IX                                          *
*              ICODES(2) - IY                                          *
*            XYZ(3,*)  - coordinates of nodes                          *
*            NP        - number of nodes                               *
*            IFACE(NP) - face                                          *
*            T(NP)     - additional function defined on this face      *
*                        (not used in this routine)                    *
*                                                                      *
************************************************************************
      REAL      XYZ(3,*),P3(2,12),X(13),Y(13),T(*)
      INTEGER   ICODES(*),IFACE(*)
*-
**          T R A N S F E R   T O   N O R M A L I S E D   COORDINATES
*
      IFNEG  = 0
      DO 100 I=1,NP
        K      = IFACE(I)
        IF (K .LT. 0)   IFNEG = 1
        IF (K .LT. 0)   K =-K
        CALL IHWTON(XYZ(1,K),P3(1,I))
        X(I)   = P3(1,I)
        Y(I)   = P3(2,I)
  100   CONTINUE
*
**          F I N D   N O R M A L
*
      Z      = 0.
      DO 200 I=1,NP
        I1 = I
        I2 = I1 + 1
        IF (I2 .GT. NP)  I2 = 1
        Z      =  Z + P3(2,I1)*P3(1,I2) - P3(1,I1)*P3(2,I2)
  200   CONTINUE
*
**          D R A W   F A C E
*
      IF (Z .GT. 0) CALL ISFACI(2)
      IF (Z .LE. 0) CALL ISFACI(3)
      CALL ISFAIS(1)
      CALL IFA(NP,X,Y)
*
**          D R A W   B O R D E R
*
      IF (IFNEG .EQ. 0) THEN
        CALL ISFAIS(0)
        CALL ISFACI(1)
        CALL IFA(NP,X,Y)
      ELSE
        X(NP+1) = X(1)
        Y(NP+1) = Y(1)
        CALL ISPLCI(1)
        DO 300 I=1,NP
          IF (IFACE(I) .GT. 0) CALL IPL(2,X(I),Y(I))
  300   CONTINUE
      END IF
      END
+DECK,  IHDF02, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHDF02(ICODES,XYZ,NP,IFACE,T)
************************************************************************
*                                                                      *
*     IHDF02                                     Date:    17.09.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 10.01.92     *
*                                                                      *
*     Function: Draw face - 2nd option                                 *
*               (fill in correspondance with function levels)          *
*                                                                      *
*     References: IHWTON, IHPFF                                        *
*                                                                      *
*     Input: ICODES(*) - set of codes for the line (not used)          *
*              ICODES(1) - IX                                          *
*              ICODES(2) - IY                                          *
*            XYZ(3,*)  - coordinates of nodes                          *
*            NP        - number of nodes                               *
*            IFACE(NP) - face                                          *
*            T(NP)     - additional function defined on this face      *
*                                                                      *
************************************************************************
+CDE, HIHID.
      REAL      XYZ(3,*),P3(3,12),X(12),Y(12),T(*)
      INTEGER   ICODES(*),IFACE(*)
*-
**          T R A N S F E R   T O   N O R M A L I S E D   COORDINATES
*
      DO 100 I=1,NP
        K       = IFACE(I)
        CALL IHWTON(XYZ(1,K),P3(1,I))
        X(I)   = P3(1,I)
        Y(I)   = P3(2,I)
  100 CONTINUE
*
**          D R A W   F A C E   &   B O R D E R
*
      CALL IHPFF(NP,P3,T)
      IF(IDRGR.EQ.1)THEN
        CALL ISFACI(1)
        CALL ISFAIS(0)
        CALL IFA(NP,X,Y)
      ENDIF
      END
+DECK,  IHDF03, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHDF03(ICODES,XYZ,NP,IFACE,T)
************************************************************************
*                                                                      *
*     IHDF03                                     Date:    17.09.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 12.01.92     *
*                                                                      *
*     Function: Draw face - 3rd option                                 *
*               (draw face for stacked lego plot)                      *
*                                                                      *
*     References: IHWTON                                               *
*                                                                      *
*     Input: ICODES(*) - set of codes for the line                     *
*              ICODES(1) - IX coordinate of the line cell              *
*              ICODES(2) - IY coordinate of the line cell              *
*              ICODES(3) - lego number                                 *
*              ICODES(4) - side: 1-face,2-right,3-back,4-left,         *
*                                5-bottom, 6-top                       *
*              XYZ(3,*)  - coordinates of nodes                        *
*              NP        - number of nodes                             *
*              IFACE(NP) - face                                        *
*              T(*)      - additional function (not used here)         *
*                                                                      *
*                                                                      *
************************************************************************
+CDE, HIHID.
      REAL      XYZ(3,*),X(4),Y(4),P3(3,4),T(*)
      INTEGER   ICODES(4),IFACE(*)
*-
      IF (ICODES(4).EQ.6) ICOL = ISTCOT
      IF (ICODES(4).EQ.5) ICOL = ISTCOB
      IF (ICODES(4).EQ.1) ICOL = ISTCOL(ICODES(3))
      IF (ICODES(4).EQ.2) ICOL = ISTCO2(ICODES(3))
      IF (ICODES(4).EQ.3) ICOL = ISTCOL(ICODES(3))
      IF (ICODES(4).EQ.4) ICOL = ISTCO2(ICODES(3))
      DO 100 I=1,NP
        K      = IFACE(I)
        CALL IHWTON(XYZ(1,K),P3(1,I))
        X(I)   = P3(1,I)
        Y(I)   = P3(2,I)
  100 CONTINUE
*
      CALL ISFAIS(1)
      CALL ISFACI(ICOL)
      CALL IFA(NP,X,Y)
      IF(IDRGR.NE.0)THEN
         CALL ISLN(1)
         CALL ISFAIS(0)
         CALL ISFACI(1)
         CALL IFA(NP,X,Y)
      ENDIF
      END
+DECK,  IHDFL1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHDFL1(ICODES,XYZ,NP,IFACE,TT)
************************************************************************
*                                                                      *
*     IHDFL1                                     Date:    10.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Draw face - 1st variant for "MOVING SCREEN" algorithm  *
*               (draw face with level lines)                           *
*                                                                      *
*     References: IHWLIN, IHWTON, IHSDRL, IHSMDF                       *
*                                                                      *
*     Input: ICODES(*) - set of codes for the line (not used)          *
*              ICODES(1) - IX                                          *
*              ICODES(2) - IY                                          *
*            XYZ(3,*)  - coordinates of nodes                          *
*            NP        - number of nodes                               *
*            IFACE(NP) - face                                          *
*            TT(NP)    - additional function defined on this face      *
*                        (not used in this routine)                    *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
+CDE, HCLINE.
      REAL              XYZ(3,*),P1(3),P2(3),P3(3,12),TT(*),X(2),Y(2)
      INTEGER           ICODES(*),IFACE(*)
*-
**          C O P Y   P O I N T S   T O   A R R A Y
*
      DO 100 I=1,NP
        K      = IFACE(I)
        P3(1,I) = XYZ(1,K)
        P3(2,I) = XYZ(2,K)
        P3(3,I) = XYZ(3,K)
  100   CONTINUE
*
**          F I N D   L E V E L   L I N E S
*
      CALL IHWLIN(NP,P3,TT)
*
**          D R A W   L E V E L   L I N E S
*
      CALL ISLN(3)
      DO 220 IL=1,NLINES
        CALL IHSDRL(PLINES(1,1,IL),PLINES(1,2,IL))
        CALL IHWTON(PLINES(1,1,IL),P1)
        CALL IHWTON(PLINES(1,2,IL),P2)
        XDEL   = P2(1) - P1(1)
        YDEL   = P2(2) - P1(2)
        DO 210 IT=1,NT
          X(1) = P1(1) + XDEL*T(1,IT)
          Y(1) = P1(2) + YDEL*T(1,IT)
          X(2) = P1(1) + XDEL*T(2,IT)
          Y(2) = P1(2) + YDEL*T(2,IT)
          CALL IPL(2,X,Y)
  210   CONTINUE
  220 CONTINUE
*
**          D R A W   F A C E
*
      CALL ISLN(1)
      DO 320 I=1,NP
        I1     = I
        I2     = I + 1
        IF (I .EQ. NP)           I2 = 1
        CALL IHSDRL(P3(1,I1),P3(1,I2))
        CALL IHWTON(P3(1,I1),P1)
        CALL IHWTON(P3(1,I2),P2)
        XDEL   = P2(1) - P1(1)
        YDEL   = P2(2) - P1(2)
        DO 310 IT=1,NT
          X(1) = P1(1) + XDEL*T(1,IT)
          Y(1) = P1(2) + YDEL*T(1,IT)
          X(2) = P1(1) + XDEL*T(2,IT)
          Y(2) = P1(2) + YDEL*T(2,IT)
          CALL IPL(2,X,Y)
  310   CONTINUE
  320 CONTINUE
*
**          M O D I F Y    S C R E E N
*
      DO 400 I=1,NP
        I1     = I
        I2     = I + 1
        IF (I .EQ. NP)           I2 = 1
        CALL IHSMDF(P3(1,I1),P3(1,I2))
  400 CONTINUE
*
      END
+DECK,  IHDFL2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHDFL2(ICODES,XYZ,NP,IFACE,TT)
************************************************************************
*                                                                      *
*     IHDFL2                                     Date:    12.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Draw face - 2nd variant for "MOVING SCREEN" algorithm  *
*               (draw face for stacked lego plot)                      *
*                                                                      *
*     References: IHWLIN, IHWTON, IHSDRL, IHSMDF                       *
*                                                                      *
*     Input: ICODES(*) - set of codes for the line (not used)          *
*              ICODES(1) - IX                                          *
*              ICODES(2) - IY                                          *
*              ICODES(3) - line code (N of lego)                       *
*            XYZ(3,*)  - coordinates of nodes                          *
*            NP        - number of nodes                               *
*            IFACE(NP) - face                                          *
*            TT(NP)    - additional function defined on this face      *
*                        (not used in this routine)                    *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
+CDE, HIHID.
      REAL              XYZ(3,*),P1(3),P2(3),P3(3,12),TT(*),X(2),Y(2)
      INTEGER           ICODES(*),IFACE(*)
*-
**          C O P Y   P O I N T S   T O   A R R A Y
*
      DO 100 I=1,NP
        K      = IFACE(I)
        P3(1,I) = XYZ(1,K)
        P3(2,I) = XYZ(2,K)
        P3(3,I) = XYZ(3,K)
  100   CONTINUE
*
**          D R A W   F A C E
*
      ICOL   = ICODES(3)
      IF(ICOL.NE.0)THEN
         CALL ISPLCI(ISTCOL(ICOL))
      ELSE
         CALL ISPLCI(1)
      ENDIF
      DO 320 I=1,NP
        I1     = I
        I2     = I + 1
        IF (I .EQ. NP)           I2 = 1
        CALL IHSDRL(P3(1,I1),P3(1,I2))
        CALL IHWTON(P3(1,I1),P1)
        CALL IHWTON(P3(1,I2),P2)
        XDEL   = P2(1) - P1(1)
        YDEL   = P2(2) - P1(2)
        DO 310 IT=1,NT
          X(1) = P1(1) + XDEL*T(1,IT)
          Y(1) = P1(2) + YDEL*T(1,IT)
          X(2) = P1(1) + XDEL*T(2,IT)
          Y(2) = P1(2) + YDEL*T(2,IT)
          CALL IPL(2,X,Y)
  310   CONTINUE
  320 CONTINUE
*
**          M O D I F Y    S C R E E N
*
      DO 400 I=1,NP
        I1     = I
        I2     = I + 1
        IF (I .EQ. NP)           I2 = 1
        CALL IHSMDF(P3(1,I1),P3(1,I2))
  400 CONTINUE
*
      END
+DECK,  IHDFR1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHDFR1(ICODES,XYZ,NP,IFACE,TT)
************************************************************************
*                                                                      *
*     IHDFR1                                     Date:    19.05.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Draw face - 1st variant for "RASTER SCREEN" algorithm  *
*               (draw face with level lines)                           *
*                                                                      *
*     References: IHWLIN, IHWTON, IHRLIN, IHRFIL                       *
*                                                                      *
*     Input: ICODES(*) - set of codes for the line (not used)          *
*              ICODES(1) - IX                                          *
*              ICODES(2) - IY                                          *
*            XYZ(3,*)  - coordinates of nodes                          *
*            NP        - number of nodes                               *
*            IFACE(NP) - face                                          *
*            TT(NP)    - additional function defined on this face      *
*                        (not used in this routine)                    *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
+CDE, HCLINE.
      REAL              XYZ(3,*),P1(3),P2(3),P3(3,12),TT(*),X(2),Y(2)
      REAL              PP(2,12)
      INTEGER           ICODES(*),IFACE(*)
*-
**          C O P Y   P O I N T S   T O   A R R A Y
*
      DO 100 I=1,NP
        K      = IFACE(I)
        IF(K.LT.0)K = -K
        P3(1,I) = XYZ(1,K)
        P3(2,I) = XYZ(2,K)
        P3(3,I) = XYZ(3,K)
        CALL IHWTON(P3(1,I),PP(1,I))
  100   CONTINUE
*
**          F I N D   L E V E L   L I N E S
*
      CALL IHWLIN(NP,P3,TT)
*
**          D R A W   L E V E L   L I N E S
*
      CALL ISLN(3)
      DO 220 IL=1,NLINES
        CALL IHWTON(PLINES(1,1,IL),P1)
        CALL IHWTON(PLINES(1,2,IL),P2)
        CALL IHRLIN(P1,P2,NTMAX,NT,T)
        XDEL   = P2(1) - P1(1)
        YDEL   = P2(2) - P1(2)
        DO 210 IT=1,NT
          X(1) = P1(1) + XDEL*T(1,IT)
          Y(1) = P1(2) + YDEL*T(1,IT)
          X(2) = P1(1) + XDEL*T(2,IT)
          Y(2) = P1(2) + YDEL*T(2,IT)
          CALL IPL(2,X,Y)
  210   CONTINUE
  220 CONTINUE
*
**          D R A W   F A C E
*
      CALL ISLN(1)
      DO 320 I=1,NP
        IF(IFACE(I).LT.0)GOTO 320
        I1     = I
        I2     = I + 1
        IF (I .EQ. NP)           I2 = 1
        CALL IHRLIN(PP(1,I1),PP(1,I2),NTMAX,NT,T)
        XDEL   = PP(1,I2) - PP(1,I1)
        YDEL   = PP(2,I2) - PP(2,I1)
        DO 310 IT=1,NT
          X(1) = PP(1,I1) + XDEL*T(1,IT)
          Y(1) = PP(2,I1) + YDEL*T(1,IT)
          X(2) = PP(1,I1) + XDEL*T(2,IT)
          Y(2) = PP(2,I1) + YDEL*T(2,IT)
          CALL IPL(2,X,Y)
  310   CONTINUE
  320 CONTINUE
*
**          M O D I F Y    S C R E E N
*
      CALL IHRFIL(NP,PP)
*
      END
+DECK,  IHDFR2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHDFR2(ICODES,XYZ,NP,IFACE,TT)
************************************************************************
*                                                                      *
*     IHDFR2                                     Date:    19.05.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Draw face - 2nd variant for "RASTER SCREEN" algorithm  *
*               (draw face for stacked lego plot)                      *
*                                                                      *
*     References: IHWTON, IHRLIN, IHRFIL                               *
*                                                                      *
*     Input: ICODES(*) - set of codes for the line (not used)          *
*              ICODES(1) - IX                                          *
*              ICODES(2) - IY                                          *
*              ICODES(3) - line code (N of lego)                       *
*            XYZ(3,*)  - coordinates of nodes                          *
*            NP        - number of nodes                               *
*            IFACE(NP) - face                                          *
*            TT(NP)    - additional function defined on this face      *
*                        (not used in this routine)                    *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
+CDE, HIHID.
      REAL              XYZ(3,*),P(3),PP(2,12),TT(*),X(2),Y(2)
      INTEGER           ICODES(*),IFACE(*)
*-
**          C O P Y   P O I N T S   T O   A R R A Y
*
      DO 100 I=1,NP
        K      = IFACE(I)
        IF(K.LT.0)K = -K
        CALL IHWTON(XYZ(1,K),P)
        PP(1,I) = P(1)
        PP(2,I) = P(2)
  100   CONTINUE
*
**          D R A W   F A C E
*
      ICOL   = ICODES(3)
      IF(ICOL.NE.0)THEN
         CALL ISPLCI(ISTCOL(ICOL))
      ELSE
         CALL ISPLCI(1)
      ENDIF
      DO 320 I=1,NP
        IF(IFACE(I).LT.0)GOTO 320
        I1     = I
        I2     = I + 1
        IF (I .EQ. NP)           I2 = 1
        CALL IHRLIN(PP(1,I1),PP(1,I2),NTMAX,NT,T)
        XDEL   = PP(1,I2) - PP(1,I1)
        YDEL   = PP(2,I2) - PP(2,I1)
        DO 310 IT=1,NT
          X(1) = PP(1,I1) + XDEL*T(1,IT)
          Y(1) = PP(2,I1) + YDEL*T(1,IT)
          X(2) = PP(1,I1) + XDEL*T(2,IT)
          Y(2) = PP(2,I1) + YDEL*T(2,IT)
          CALL IPL(2,X,Y)
  310   CONTINUE
  320 CONTINUE
*
**          M O D I F Y    R A S T E R   S C R E E N
*
      CALL IHRFIL(NP,PP)
*
      END
+DECK,  IHERAN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHERAN(P1,P2,F1,F2,FMIN,FMAX,KPP,PP)
************************************************************************
*                                                                      *
*     IHERAN                                     Date:    20.03.90     *
*     Author: E. Chernyaev (IHEP)                Revised: 13.09.90     *
*                                                                      *
*     Function: Find part of edge where function defined on this edge  *
*               has value from FMIN to FMAX                            *
*                                                                      *
*     Input: P1(3) - 1st point                                         *
*            P2(3) - 2nd point                                         *
*            F1    - function value at 1st point                       *
*            F2    - function value at 2nd point                       *
*            FMIN  - min value of layer                                *
*            FMAX  - max value of layer                                *
*                                                                      *
*     Output: KPP - current number of point                            *
*             PP(3,*) - coordinates of new face                        *
*                                                                      *
************************************************************************
      REAL      P1(3),P2(3),PP(3,*)
*-
      K1    = 0
      IF (F1 .LT. FMIN)         K1 =-2
      IF (F1 .EQ. FMIN)         K1 =-1
      IF (F1 .EQ. FMAX)         K1 =+1
      IF (F1 .GT. FMAX)         K1 =+2
      K2    = 0
      IF (F2 .LT. FMIN)         K2 =-2
      IF (F2 .EQ. FMIN)         K2 =-1
      IF (F2 .EQ. FMAX)         K2 =+1
      IF (F2 .GT. FMAX)         K2 =+2
      KK = (K1+2)*5 + (K2+2) + 1
*
**    K2:    -2  -1   0  +1  +2
*                                      K1: -2 -1 0 +1 +2
      GOTO (999,999,200,200,600,
     +      100,100,100,100,500,
     +      400,100,100,100,500,
     +      400,100,100,100,100,
     +      700,300,300,999,999), KK
*
**          1 - S T   P O I N T
*
  100 KPP       = KPP + 1
      PP(1,KPP) = P1(1)
      PP(2,KPP) = P1(2)
      PP(3,KPP) = P1(3)
      GOTO 999
*
**           I N T E R S E C T I O N   W I T H   Fmin
*
  200 KPP       = KPP + 1
      D1        = (FMIN - F1) / (F1 - F2)
      D2        = (FMIN - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      GOTO 999
*
**           I N T E R S E C T I O N   W I T H   Fmax
*
  300 KPP       = KPP + 1
      D1        = (FMAX - F1) / (F1 - F2)
      D2        = (FMAX - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      GOTO 999
*
**          1 - S T   P O I N T,   I N T E R S E C T I O N  WITH  Fmin
*
  400 KPP       = KPP + 1
      PP(1,KPP) = P1(1)
      PP(2,KPP) = P1(2)
      PP(3,KPP) = P1(3)
      KPP       = KPP + 1
      D1        = (FMIN - F1) / (F1 - F2)
      D2        = (FMIN - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      GOTO 999
*
**          1 - S T   P O I N T,   I N T E R S E C T I O N  WITH  Fmax
*
  500 KPP       = KPP + 1
      PP(1,KPP) = P1(1)
      PP(2,KPP) = P1(2)
      PP(3,KPP) = P1(3)
      KPP       = KPP + 1
      D1        = (FMAX - F1) / (F1 - F2)
      D2        = (FMAX - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      GOTO 999
*
**           I N T E R S E C T I O N   W I T H   Fmin, Fmax
*
  600 KPP       = KPP + 1
      D1        = (FMIN - F1) / (F1 - F2)
      D2        = (FMIN - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      KPP       = KPP + 1
      D1        = (FMAX - F1) / (F1 - F2)
      D2        = (FMAX - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      GOTO 999
*
**           I N T E R S E C T I O N   W I T H   Fmax, Fmin
*
  700 KPP       = KPP + 1
      D1        = (FMAX - F1) / (F1 - F2)
      D2        = (FMAX - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      KPP       = KPP + 1
      D1        = (FMIN - F1) / (F1 - F2)
      D2        = (FMIN - F2) / (F1 - F2)
      PP(1,KPP) = D2*P1(1) - D1*P2(1)
      PP(2,KPP) = D2*P1(2) - D1*P2(2)
      PP(3,KPP) = D2*P1(3) - D1*P2(3)
      GOTO 999
*
  999 RETURN
      END
+DECK,  IHFBOX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHFBOX(RMIN,RMAX,ANG,DRFACE)
************************************************************************
*                                                                      *
*     IHFBOX                                     Date:    12.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Draw forward faces of surrounding box & axes           *
*                                                                      *
*     References: IHAXIV, IGAXIS                                       *
*                                                                      *
*     Input: RMIN(3) - MIN -                                           *
*            RMAX(3) -       MAX scope                                 *
*            ANG     - angle between X and Y axis                      *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
************************************************************************
      REAL              RMIN(3),RMAX(3),AV(3,8),R(3,8),FDUMMY(1)
      DOUBLE PRECISION  RAD,COSA,SINA
      INTEGER           ICODES(3),IFACE1(4),IFACE2(4)
      EXTERNAL          DRFACE
      DATA              IFACE1/1,2,6,5/,IFACE2/2,3,7,6/
*-
      RAD    = ATAN(1.D0)*4./180.
      COSA   = COS(RAD*ANG)
      SINA   = SIN(RAD*ANG)
      CALL IHAXIV(RMIN,RMAX,ANG,AV,IX1,IX2,IY1,IY2,IZ1,IZ2)
      DO 10 I=1,8
        R(1,I) = AV(1,I) + AV(2,I)*COSA
        R(2,I) = AV(2,I)*SINA
        R(3,I) = AV(3,I)
  10  CONTINUE
*
**          D R A W   F O R W A R D   F A C E S
*
      ICODES(1) = 0
      ICODES(2) = 0
      ICODES(3) = 0
      CALL DRFACE(ICODES,R,4,IFACE1,FDUMMY)
      CALL DRFACE(ICODES,R,4,IFACE2,FDUMMY)
*
      END
+DECK,  IHIMPF, T=FORT.
* Revision 1.2  2002/04/05 13:20:05  couet
* - The variable KSURF was initialized but never used
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHIMPF(FUN,RMIN,RMAX,NX,NY,NZ,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHIMPF                                     Date:    22.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 12.01.92     *
*                                                         11.09.92     *
*                                                         25.08.93     *
*     Function: Draw implicit function FUN(X,Y,Z) = 0 in cartesian     *
*               coordinates using hidden surface removal algorithm     *
*               "Painter".                                             *
*                                                                      *
*     Input: FUN      - external routine FUN(X,Y,Z)                    *
*            RMIN(3)  - min scope coordinates                          *
*            RMAX(3)  - max scope coordinates                          *
*            NX       - number of steps along X                        *
*            NY       - number of steps along Y                        *
*            NZ       - number of steps along Z                        *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - 1                                         *
*                ICODES(2) - 1                                         *
*                ICODES(3) - 1                                         *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function (lightness)             *
*                                                                      *
*            CHOPT - options: 'BF' - from BACK to FRONT                *
*                             'FB' - from FRONT to BACK                *
*                                                                      *
************************************************************************
+CDE, HCMCTR.
+CDE, HCTNOR.
      PARAMETER         (FDEL = 0.)
      REAL              RMIN(3),RMAX(3)
      REAL              P(3,8),PF(8),PN(3,8),T(3)
      INTEGER           ICODES(3)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
*-
**          D E F I N E   O R D E R   O F   D R A W I N G
*
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b') THEN
        INCRX  =+1
        INCRY  =+1
        INCRZ  =+1
      ELSE
        INCRX  =-1
        INCRY  =-1
        INCRZ  =-1
      END IF
      IF (TNORM(1,3) .LT. 0.)           INCRX =-INCRX
      IF (TNORM(2,3) .LT. 0.)           INCRY =-INCRY
      IF (TNORM(3,3) .LT. 0.)           INCRZ =-INCRZ
      IX1    = 1
      IY1    = 1
      IZ1    = 1
      IF (INCRX .EQ. -1)                IX1   = NX
      IF (INCRY .EQ. -1)                IY1   = NY
      IF (INCRZ .EQ. -1)                IZ1   = NZ
      IX2    = NX - IX1 + 1
      IY2    = NY - IY1 + 1
      IZ2    = NZ - IZ1 + 1
      DX     = (RMAX(1)-RMIN(1)) / NX
      DY     = (RMAX(2)-RMIN(2)) / NY
      DZ     = (RMAX(3)-RMIN(3)) / NZ
*
**          D R A W   F U N C T I O N
*
      DO 530 IZ=IZ1,IZ2,INCRZ
        Z1     = (IZ-1)*DZ + RMIN(3)
        Z2     = Z1 + DZ
        P(3,1) = Z1
        P(3,2) = Z1
        P(3,3) = Z1
        P(3,4) = Z1
        P(3,5) = Z2
        P(3,6) = Z2
        P(3,7) = Z2
        P(3,8) = Z2
        DO 520 IY=IY1,IY2,INCRY
          Y1     = (IY-1)*DY + RMIN(2)
          Y2     = Y1 + DY
          P(2,1) = Y1
          P(2,2) = Y1
          P(2,3) = Y2
          P(2,4) = Y2
          P(2,5) = Y1
          P(2,6) = Y1
          P(2,7) = Y2
          P(2,8) = Y2
          IF (INCRX .EQ.+1) THEN
            X2    = RMIN(1)
            PF(2) = FUN(X2,Y1,Z1)
            PF(3) = FUN(X2,Y2,Z1)
            PF(6) = FUN(X2,Y1,Z2)
            PF(7) = FUN(X2,Y2,Z2)
          ELSE
            X1    = RMAX(1)
            PF(1) = FUN(X1,Y1,Z1)
            PF(4) = FUN(X1,Y2,Z1)
            PF(5) = FUN(X1,Y1,Z2)
            PF(8) = FUN(X1,Y2,Z2)
          END IF
          DO 510 IX=IX1,IX2,INCRX
            ICODES(1) = IX
            ICODES(2) = IY
            ICODES(3) = IZ
            IF (INCRX .EQ.+1) THEN
              X1     = X2
              X2     = X2 + DX
              PF(1)  = PF(2)
              PF(4)  = PF(3)
              PF(5)  = PF(6)
              PF(8)  = PF(7)
              PF(2)  = FUN(X2,Y1,Z1)
              PF(3)  = FUN(X2,Y2,Z1)
              PF(6)  = FUN(X2,Y1,Z2)
              PF(7)  = FUN(X2,Y2,Z2)
            ELSE
              X2     = X1
              X1     = X1 - DX
              PF(2)  = PF(1)
              PF(3)  = PF(4)
              PF(6)  = PF(5)
              PF(7)  = PF(8)
              PF(1)  = FUN(X1,Y1,Z1)
              PF(4)  = FUN(X1,Y2,Z1)
              PF(5)  = FUN(X1,Y1,Z2)
              PF(8)  = FUN(X1,Y2,Z2)
            END IF
            IF (PF(1) .GE. -FDEL)       GOTO 110
            IF (PF(2) .GE. -FDEL)       GOTO 120
            IF (PF(3) .GE. -FDEL)       GOTO 120
            IF (PF(4) .GE. -FDEL)       GOTO 120
            IF (PF(5) .GE. -FDEL)       GOTO 120
            IF (PF(6) .GE. -FDEL)       GOTO 120
            IF (PF(7) .GE. -FDEL)       GOTO 120
            IF (PF(8) .GE. -FDEL)       GOTO 120
            GOTO 510
  110       IF (PF(2) .LT. -FDEL)       GOTO 120
            IF (PF(3) .LT. -FDEL)       GOTO 120
            IF (PF(4) .LT. -FDEL)       GOTO 120
            IF (PF(5) .LT. -FDEL)       GOTO 120
            IF (PF(6) .LT. -FDEL)       GOTO 120
            IF (PF(7) .LT. -FDEL)       GOTO 120
            IF (PF(8) .LT. -FDEL)       GOTO 120
            GOTO 510
  120       P(1,1) = X1
            P(1,2) = X2
            P(1,3) = X2
            P(1,4) = X1
            P(1,5) = X1
            P(1,6) = X2
            P(1,7) = X2
            P(1,8) = X1
*
**          F I N D   G R A D I E N T S
*
            IF (IX .EQ. 1) THEN
              PN(1,1) = (PF(2) - PF(1)) / DX
              PN(1,4) = (PF(3) - PF(4)) / DX
              PN(1,5) = (PF(6) - PF(5)) / DX
              PN(1,8) = (PF(7) - PF(8)) / DX
            ELSE
              PN(1,1) = (PF(2) - FUN(X1-DX,Y1,Z1)) / (DX + DX)
              PN(1,4) = (PF(3) - FUN(X1-DX,Y2,Z1)) / (DX + DX)
              PN(1,5) = (PF(6) - FUN(X1-DX,Y1,Z2)) / (DX + DX)
              PN(1,8) = (PF(7) - FUN(X1-DX,Y2,Z2)) / (DX + DX)
            END IF
            IF (IX .EQ. NX) THEN
              PN(1,2) = (PF(2) - PF(1)) / DX
              PN(1,3) = (PF(3) - PF(4)) / DX
              PN(1,6) = (PF(6) - PF(5)) / DX
              PN(1,7) = (PF(7) - PF(8)) / DX
            ELSE
              PN(1,2) = (FUN(X2+DX,Y1,Z1) - PF(1)) / (DX + DX)
              PN(1,3) = (FUN(X2+DX,Y2,Z1) - PF(4)) / (DX + DX)
              PN(1,6) = (FUN(X2+DX,Y1,Z2) - PF(5)) / (DX + DX)
              PN(1,7) = (FUN(X2+DX,Y2,Z2) - PF(8)) / (DX + DX)
            END IF
*           F I N D   Y - G R A D I E N T
            IF (IY .EQ. 1) THEN
              PN(2,1) = (PF(4) - PF(1)) / DY
              PN(2,2) = (PF(3) - PF(2)) / DY
              PN(2,5) = (PF(8) - PF(5)) / DY
              PN(2,6) = (PF(7) - PF(6)) / DY
            ELSE
              PN(2,1) = (PF(4) - FUN(X1,Y1-DY,Z1)) / (DY + DY)
              PN(2,2) = (PF(3) - FUN(X2,Y1-DY,Z1)) / (DY + DY)
              PN(2,5) = (PF(8) - FUN(X1,Y1-DY,Z2)) / (DY + DY)
              PN(2,6) = (PF(7) - FUN(X2,Y1-DY,Z2)) / (DY + DY)
            END IF
            IF (IY .EQ. NY) THEN
              PN(2,3) = (PF(3) - PF(2)) / DY
              PN(2,4) = (PF(4) - PF(1)) / DY
              PN(2,7) = (PF(7) - PF(6)) / DY
              PN(2,8) = (PF(8) - PF(5)) / DY
            ELSE
              PN(2,3) = (FUN(X2,Y2+DY,Z1) - PF(2)) / (DY + DY)
              PN(2,4) = (FUN(X1,Y2+DY,Z1) - PF(1)) / (DY + DY)
              PN(2,7) = (FUN(X2,Y2+DY,Z2) - PF(6)) / (DY + DY)
              PN(2,8) = (FUN(X1,Y2+DY,Z2) - PF(5)) / (DY + DY)
            END IF
*           F I N D   Z - G R A D I E N T
            IF (IZ .EQ. 1) THEN
              PN(3,1) = (PF(5) - PF(1)) / DZ
              PN(3,2) = (PF(6) - PF(2)) / DZ
              PN(3,3) = (PF(7) - PF(3)) / DZ
              PN(3,4) = (PF(8) - PF(4)) / DZ
            ELSE
              PN(3,1) = (PF(5) - FUN(X1,Y1,Z1-DZ)) / (DZ + DZ)
              PN(3,2) = (PF(6) - FUN(X2,Y1,Z1-DZ)) / (DZ + DZ)
              PN(3,3) = (PF(7) - FUN(X2,Y2,Z1-DZ)) / (DZ + DZ)
              PN(3,4) = (PF(8) - FUN(X1,Y2,Z1-DZ)) / (DZ + DZ)
            END IF
            IF (IZ .EQ. NZ) THEN
              PN(3,5) = (PF(5) - PF(1)) / DZ
              PN(3,6) = (PF(6) - PF(2)) / DZ
              PN(3,7) = (PF(7) - PF(3)) / DZ
              PN(3,8) = (PF(8) - PF(4)) / DZ
            ELSE
              PN(3,5) = (FUN(X1,Y1,Z2+DZ) - PF(1)) / (DZ + DZ)
              PN(3,6) = (FUN(X2,Y1,Z2+DZ) - PF(2)) / (DZ + DZ)
              PN(3,7) = (FUN(X2,Y2,Z2+DZ) - PF(3)) / (DZ + DZ)
              PN(3,8) = (FUN(X1,Y2,Z2+DZ) - PF(4)) / (DZ + DZ)
            END IF
            FSURF = 0.
            CALL IHMCUB(FSURF,P,PF,PN,NNOD,NTRIA,XYZ,GRAD,ITRIA)
            IF (NTRIA .EQ. 0)   GOTO 510
            DO 410 I=1,NNOD
              CALL IHWTON(XYZ(1,I),XYZN(1,I))
              CALL IHLUMI(GRAD(1,I),W)
              GRAD(1,I) = W
  410       CONTINUE
            CALL IHZDEP(XYZN,NTRIA,ITRIA,DTRIA,ABCD,IORDER)
            IF (NTRIA .EQ. 0)   GOTO 510
            INCR  = 1
            IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')       INCR =-1
            I1    = 1
            IF (INCR .EQ. -1)           I1 = NTRIA
            I2    = NTRIA - I1 + 1
            DO 420 I=I1,I2,INCR
              K      = IORDER(I)
              T(1)   = GRAD(1,IABS(ITRIA(1,K)))
              T(2)   = GRAD(1,IABS(ITRIA(2,K)))
              T(3)   = GRAD(1,IABS(ITRIA(3,K)))
              CALL DRFACE(ICODES,XYZ,3,ITRIA(1,K),T)
  420       CONTINUE
  510     CONTINUE
  520   CONTINUE
  530 CONTINUE
      END
+DECK,  IHISO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:49  mclareni
* Higz

      SUBROUTINE IHISO(NS,S,NX,NY,NZ,X,Y,Z,F,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHISO                                      Date:    21.07.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 22.08.93     *
*                                                                      *
*     Function: Draw set of isosurfaces for a scalar function          *
*               defined on a grid.                                     *
*                                                                      *
*     Input: NS          - number of isosurfaces                       *
*            S(*)        - isosurface values                           *
*            NX          - number of slices along X                    *
*            NY          - number of slices along Y                    *
*            NZ          - number of slices along Z                    *
*            X(*)        - slices along X                              *
*            Y(*)        - slices along Y                              *
*            Z(*)        - slices along Z                              *
*            F(NX,NY,NZ) - function values                             *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(1) - isosurface number                           *
*              ICODES(2) - isosurface number                           *
*              ICODES(3) - isosurface number                           *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function (lightness)             *
*                                                                      *
*            CHOPT - options: 'BF' - from BACK to FRONT                *
*                             'FB' - from FRONT to BACK                *
*                                                                      *
************************************************************************
+CDE, HCMCTR.
      CHARACTER*(*)     CHOPT
      EXTERNAL          DRFACE
      REAL              S(*),X(*),Y(*),Z(*)
      REAL              P0(3),P1(3),P2(3),P3(3),F(NX,NY,NZ),T(3)
      REAL              P(3,8),PF(8),PN(3,8)
      INTEGER           IND(3,8),ICODES(3)
      DATA              IND/0,0,0, 1,0,0, 1,0,1, 0,0,1,
     &                      0,1,0, 1,1,0, 1,1,1, 0,1,1/
*-
      NSURF  = NS
      IF (NSURF .GT. NISO) THEN
        WRITE(*,*) 'IHISO: Warning: No. of isosurfaces great then',NISO
        WRITE(*,*) 'IHISO: Increase parameter NISO in COMMON /HCMCTR/'
      END IF
      IOPT   = 2
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')     IOPT = 1
*
**          F I N D   X - , Y - , Z - C R I T I C A L
**          This logic works for parallel projection only.
**          For central projection another logic should be implemented.
*
      P0(1)  = X(1)
      P0(2)  = Y(1)
      P0(3)  = Z(1)
      CALL IHWTON(P0,P0)
      P1(1)  = X(NX)
      P1(2)  = Y(1)
      P1(3)  = Z(1)
      CALL IHWTON(P1,P1)
      P2(1)  = X(1)
      P2(2)  = Y(NY)
      P2(3)  = Z(1)
      CALL IHWTON(P2,P2)
      P3(1)  = X(1)
      P3(2)  = Y(1)
      P3(3)  = Z(NZ)
      CALL IHWTON(P3,P3)
      IXCRIT = NX
      IYCRIT = NY
      IZCRIT = NZ
      IF (P1(3) .LT. P0(3))     IXCRIT = 1
      IF (P2(3) .LT. P0(3))     IYCRIT = 1
      IF (P3(3) .LT. P0(3))     IZCRIT = 1
*
**          L O O P   A L O N G   G R I D
**          This logic works for both (parallel & central) projections.
*
      INCRX  = 1
      INCRY  = 1
      INCRZ  = 1
  110 IF (INCRZ .GE. 0) THEN
        IF (IOPT .EQ. 1)        IZ1 = 1
        IF (IOPT .EQ. 1)        IZ2 = IZCRIT-1
        IF (IOPT .EQ. 2)        IZ1 = IZCRIT
        IF (IOPT .EQ. 2)        IZ2 = NZ - 1
      ELSE
        IF (IOPT .EQ. 1)        IZ1 = NZ - 1
        IF (IOPT .EQ. 1)        IZ2 = IZCRIT
        IF (IOPT .EQ. 2)        IZ1 = IZCRIT-1
        IF (IOPT .EQ. 2)        IZ2 = 1
      END IF
      DO 530 IZ=IZ1,IZ2,INCRZ
  120   IF (INCRY .GE. 0) THEN
          IF (IOPT .EQ. 1)      IY1 = 1
          IF (IOPT .EQ. 1)      IY2 = IYCRIT-1
          IF (IOPT .EQ. 2)      IY1 = IYCRIT
          IF (IOPT .EQ. 2)      IY2 = NY - 1
        ELSE
          IF (IOPT .EQ. 1)      IY1 = NY - 1
          IF (IOPT .EQ. 1)      IY2 = IYCRIT
          IF (IOPT .EQ. 2)      IY1 = IYCRIT-1
          IF (IOPT .EQ. 2)      IY2 = 1
        END IF
        DO 520 IY=IY1,IY2,INCRY
  130     IF (INCRX .GE. 0) THEN
            IF (IOPT .EQ. 1)    IX1 = 1
            IF (IOPT .EQ. 1)    IX2 = IXCRIT-1
            IF (IOPT .EQ. 2)    IX1 = IXCRIT
            IF (IOPT .EQ. 2)    IX2 = NX - 1
          ELSE
            IF (IOPT .EQ. 1)    IX1 = NX - 1
            IF (IOPT .EQ. 1)    IX2 = IXCRIT
            IF (IOPT .EQ. 2)    IX1 = IXCRIT-1
            IF (IOPT .EQ. 2)    IX2 = 1
          END IF
          DO 510 IX=IX1,IX2,INCRX
            NNOD   = 0
            NTRIA  = 0
            IREADY = 0
            DO 400 ISURF=1,NSURF
              FSURF = S(ISURF)
              IF (F(IX,  IY,  IZ)   .GE. FSURF) GOTO 210
              IF (F(IX+1,IY,  IZ)   .GE. FSURF) GOTO 220
              IF (F(IX,  IY+1,IZ)   .GE. FSURF) GOTO 220
              IF (F(IX+1,IY+1,IZ)   .GE. FSURF) GOTO 220
              IF (F(IX,  IY,  IZ+1) .GE. FSURF) GOTO 220
              IF (F(IX+1,IY,  IZ+1) .GE. FSURF) GOTO 220
              IF (F(IX,  IY+1,IZ+1) .GE. FSURF) GOTO 220
              IF (F(IX+1,IY+1,IZ+1) .GE. FSURF) GOTO 220
              GOTO 400
  210         IF (F(IX+1,IY,  IZ)   .LT. FSURF) GOTO 220
              IF (F(IX,  IY+1,IZ)   .LT. FSURF) GOTO 220
              IF (F(IX+1,IY+1,IZ)   .LT. FSURF) GOTO 220
              IF (F(IX,  IY,  IZ+1) .LT. FSURF) GOTO 220
              IF (F(IX+1,IY,  IZ+1) .LT. FSURF) GOTO 220
              IF (F(IX,  IY+1,IZ+1) .LT. FSURF) GOTO 220
              IF (F(IX+1,IY+1,IZ+1) .LT. FSURF) GOTO 220
              GOTO 400
*
**          P R E P A R E   C U B E   ( P A R A L L E P I P E D )
*
  220        IF (IREADY .NE.0)                  GOTO 310
             IREADY = 1
             DO 300 I=1,8
                KX     = IX + IND(1,I)
                KY     = IY + IND(2,I)
                KZ     = IZ + IND(3,I)
                P(1,I) = X(KX)
                P(2,I) = Y(KY)
                P(3,I) = Z(KZ)
                PF(I)  = F(KX,KY,KZ)
*           F I N D   X - G R A D I E N T
                IF (KX .EQ. 1) THEN
                  PN(1,I) = (F(2,KY,KZ)-F(1,KY,KZ))/(X(2)-X(1))
                ELSE IF (KX .EQ. NX) THEN
                  PN(1,I) = (F(KX,KY,KZ)-F(KX-1,KY,KZ))/(X(KX)-X(KX-1))
                ELSE
                  D1     = X(KX) - X(KX-1)
                  D2     = X(KX+1) - X(KX)
                  IF (D1 .EQ. D2) THEN
                    PN(1,I) = (F(KX+1,KY,KZ)-F(KX-1,KY,KZ))/(D1+D1)
                  ELSE
                    DF1     = F(KX,KY,KZ) - F(KX-1,KY,KZ)
                    DF2     = F(KX+1,KY,KZ) - F(KX,KY,KZ)
                    PN(1,I) = (DF1*D2*D2+DF2*D1*D1)/(D1*D2*D2+D2*D1*D1)
                  END IF
                END IF
*           F I N D   Y - G R A D I E N T
                IF (KY .EQ. 1) THEN
                  PN(2,I) = (F(KX,2,KZ)-F(KX,1,KZ))/(Y(2)-Y(1))
                ELSE IF (KY .EQ. NY) THEN
                  PN(2,I) = (F(KX,KY,KZ)-F(KX,KY-1,KZ))/(Y(KY)-Y(KY-1))
                ELSE
                  D1     = Y(KY) - Y(KY-1)
                  D2     = Y(KY+1) - Y(KY)
                  IF (D1 .EQ. D2) THEN
                    PN(2,I) = (F(KX,KY+1,KZ)-F(KX,KY-1,KZ))/(D1+D1)
                  ELSE
                    DF1    = F(KX,KY,KZ) - F(KX,KY-1,KZ)
                    DF2    = F(KX,KY+1,KZ) - F(KX,KY,KZ)
                    PN(2,I) = (DF1*D2*D2+DF2*D1*D1)/(D1*D2*D2+D2*D1*D1)
                  END IF
                END IF
*           F I N D   Z - G R A D I E N T
                IF (KZ .EQ. 1) THEN
                  PN(3,I) = (F(KX,KY,2)-F(KX,KY,1))/(Z(2)-Z(1))
                ELSE IF (KZ .EQ. NZ) THEN
                  PN(3,I) = (F(KX,KY,KZ)-F(KX,KY,KZ-1))/(Z(KZ)-Z(KZ-1))
                ELSE
                  D1     = Z(KZ) - Z(KZ-1)
                  D2     = Z(KZ+1) - Z(KZ)
                  IF (D1 .EQ. D2) THEN
                    PN(3,I) = (F(KX,KY,KZ+1)-F(KX,KY,KZ-1))/(D1+D1)
                  ELSE
                    DF1    = F(KX,KY,KZ) - F(KX,KY,KZ-1)
                    DF2    = F(KX,KY,KZ+1) - F(KX,KY,KZ)
                    PN(3,I) = (DF1*D2*D2+DF2*D1*D1)/(D1*D2*D2+D2*D1*D1)
                  END IF
                END IF
  300         CONTINUE
*
**          F I N D   S E T   O F   T R I A N G L E S
*
  310         CALL IHMCUB(S(ISURF),P,PF,PN,KNOD,KTRIA,
     &                    XYZ(1,NNOD+1),GRAD(1,NNOD+1),ITRIA(1,NTRIA+1))
              DO 330 I=NTRIA+1,NTRIA+KTRIA
                DO 320 J=1,3
                  IBASE = NNOD
                  IF (ITRIA(J,I) .LT. 0)        IBASE =-NNOD
                  ITRIA(J,I) = ITRIA(J,I) + IBASE
  320           CONTINUE
                IATTR(I) = ISURF
  330         CONTINUE
              NNOD   = NNOD + KNOD
              NTRIA  = NTRIA + KTRIA
  400       CONTINUE
*
**          D E P T H   S O R T,   D R A W I N G
*
            IF (NTRIA .EQ. 0)   GOTO 510
            DO 410 I=1,NNOD
              CALL IHWTON(XYZ(1,I),XYZN(1,I))
              CALL IHLUMI(GRAD(1,I),W)
              GRAD(1,I) = W
  410       CONTINUE
            CALL IHZDEP(XYZN,NTRIA,ITRIA,DTRIA,ABCD,IORDER)
            IF (NTRIA .EQ. 0)   GOTO 510
            INCR  = 1
            IF (IOPT .EQ. 1)            INCR =-1
            I1    = 1
            IF (INCR .EQ. -1)           I1 = NTRIA
            I2    = NTRIA - I1 + 1
            DO 420 I=I1,I2,INCR
              K      = IORDER(I)
              T(1)   = GRAD(1,IABS(ITRIA(1,K)))
              T(2)   = GRAD(1,IABS(ITRIA(2,K)))
              T(3)   = GRAD(1,IABS(ITRIA(3,K)))
              ICODES(1) = IATTR(K)
              ICODES(2) = IATTR(K)
              ICODES(3) = IATTR(K)
              CALL DRFACE(ICODES,XYZ,3,ITRIA(1,K),T)
  420       CONTINUE
  510     CONTINUE
          INCRX  =-INCRX
          IF (INCRX .LT. 0)     GOTO 130
  520   CONTINUE
        INCRY  =-INCRY
        IF (INCRY .LT. 0)       GOTO 120
  530 CONTINUE
      INCRZ  =-INCRZ
      IF (INCRZ .LT. 0)         GOTO 110
      END
+DECK,  IHLEGC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHLEGC(ANG,NX,NY,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHLEGC                                     Date:    17.09.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 15.04.93     *
*                                                                      *
*     Function: Draw stack of lego-plots in cartesian coordinates      *
*                                                                      *
*     References: IHWZN                                                *
*                                                                      *
*     Input: ANG      - angle between X ang Y                          *
*            NX       - number of cells along X                        *
*            NY       - number of cells along Y                        *
*                                                                      *
*            FUN(IX,IY,NV,XY,V,T) - external routine                   *
*              IX     - X number of the cell                           *
*              IY     - Y number of the cell                           *
*              NV     - number of values for given cell                *
*              XY(2,4)- coordinates of the cell corners                *
*              V(NV)  - cell values                                    *
*              T(4,NV)- additional function (for example: temperature) *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this line                  *
*                ICODES(1) - IX                                        *
*                ICODES(2) - IY                                        *
*                ICODES(3) - IV                                        *
*                ICODES(4) - side: 1-face,2-right,3-back,4-left,       *
*                                  5-bottom, 6-top                     *
*                XYZ(3,*)  - coordinates of nodes                      *
*                NP        - number of nodes                           *
*                IFACE(NP) - face                                      *
*                T(4)   - additional function (here Z-coordinate)      *
*                                                                      *
*            CHOPT - options: 'BF' - from BACK to FRONT                *
*                             'FB' - from FRONT to BACK                *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
+CDE, PNVMAX.
      REAL              XY(2,4),XYZ(3,8),V(NVMAX),TT(4,NVMAX),TFACE(4)
      INTEGER           ICODES(4),IFACE(4),IVIS(4)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
*-
      RAD    = ATAN(1.)*4./180.
      SINA   = SIN(ANG*RAD)
      COSA   = COS(ANG*RAD)
*
**          F I N D   T H E   M O S T   L E F T   P O I N T
*
      I1     = 1
      IF (TN(1,1) .LT. 0.)                      I1 = 2
      IF (TN(1,1)*COSA+TN(2,1)*SINA .LT. 0.)    I1 = 5 - I1
*
**          D E F I N E   O R D E R   O F   D R A W I N G
*
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b') THEN
        INCRX  =-1
        INCRY  =-1
      ELSE
        INCRX  =+1
        INCRY  =+1
      END IF
      IF (I1.EQ.1 .OR. I1.EQ.2)                 INCRX =-INCRX
      IF (I1.EQ.2 .OR. I1.EQ.3)                 INCRY =-INCRY
      IX1    = 1
      IY1    = 1
      IF (INCRX .LT. 0)                         IX1 = NX
      IF (INCRY .LT. 0)                         IY1 = NY
      IX2    = NX - IX1 + 1
      IY2    = NY - IY1 + 1
*
**          F I N D   V I S I B I L I T Y   O F   S I D E S
*
      IVIS(1) = 0
      IVIS(2) = 0
      IVIS(3) = 0
      IVIS(4) = 0
      CALL IHWZN(0.,1.,0.,ZN)
      IF (ZN .LT. 0.)                           IVIS(1) = 1
      IF (ZN .GT. 0.)                           IVIS(3) = 1
      CALL IHWZN(SINA,COSA,0.,ZN)
      IF (ZN .GT. 0.)                           IVIS(2) = 1
      IF (ZN .LT. 0.)                           IVIS(4) = 1
*
**          D R A W   S T A C K   O F   L E G O - P L O T S
*
      DO 320 IY=IY1,IY2,INCRY
        DO 310 IX=IX1,IX2,INCRX
          CALL FUN(IX,IY,NV,XY,V,TT)
          IF (NV.LT.2 .OR. NV.GT.NVMAX) GOTO 310
          ICODES(1) = IX
          ICODES(2) = IY
          DO 110 I=1,4
            XYZ(1,I)   = XY(1,I) + XY(2,I)*COSA
            XYZ(2,I)   = XY(2,I)*SINA
            XYZ(1,I+4) = XYZ(1,I)
            XYZ(2,I+4) = XYZ(2,I)
  110     CONTINUE
*           D R A W   S T A C K
          DO 140 IV=1,NV-1
            DO 120 I=1,4
              XYZ(3,I)   = V(IV)
              XYZ(3,I+4) = V(IV+1)
  120       CONTINUE
            IF (V(IV) .EQ. V(IV+1))     GOTO 140
            ICODES(3) = IV
            DO 130 I=1,4
              IF (IVIS(I) .EQ. 0)       GOTO 130
              K1     = I
              K2     = I + 1
              IF (I .EQ. 4)             K2 = 1
              ICODES(4) = K1
              IFACE(1)  = K1
              IFACE(2)  = K2
              IFACE(3)  = K2 + 4
              IFACE(4)  = K1 + 4
              TFACE(1)  = TT(K1,IV)
              TFACE(2)  = TT(K2,IV)
              TFACE(3)  = TT(K2,IV+1)
              TFACE(4)  = TT(K1,IV+1)
              CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
  130       CONTINUE
  140     CONTINUE
*           D R A W   B O T T O M   F A C E
          CALL IHWZN(0.,0.,1.,ZN)
          IF (ZN .LT. 0.) THEN
            ICODES(3) = 1
            ICODES(4) = 5
            DO 210 I=1,4
              XYZ(3,I) = V(1)
              IFACE(I) = 5 - I
              TFACE(I) = TT(5-I,1)
  210       CONTINUE
            CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
          END IF
*           D R A W   T O P   F A C E
          IF (ZN .GT. 0.) THEN
            ICODES(3) = NV - 1
            ICODES(4) = 6
            DO 220 I=1,4
              IFACE(I) = I + 4
              TFACE(I) = TT(I,NV)
  220       CONTINUE
            CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
          END IF
  310   CONTINUE
  320 CONTINUE
      RETURN
      END
+DECK,  IHLEGP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHLEGP(IORDR,NA,NB,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHLEGP                                     Date:    04.11.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 03.03.93     *
*                                                                      *
*     Function: Draw stack of lego-plots in polar coordinates          *
*                                                                      *
*     References: IHWPHI, IHWVR1, IHWVR2, IHWZN                        *
*                                                                      *
*     Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R)         *
*            NA    - number of steps along 1st variable                *
*            NB    - number of steps along 2nd variable                *
*                                                                      *
*            FUN(IA,IB,NV,AB,V,TT) - external routine                  *
*              IA      - cell number for 1st variable                  *
*              IB      - cell number for 2nd variable                  *
*              NV      - number of values for given cell               *
*              AB(2,4) - coordinates of the cell corners               *
*              V(NV)   - cell values                                   *
*              TT(4,*) - additional function                           *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - IA                                        *
*                ICODES(2) - IB                                        *
*                ICODES(3) - IV                                        *
*                ICODES(4) - side: 1-internal,2-right,3-external,4-left*
*                                  5-bottom, 6-top                     *
*              XYZ(3,*)  - coordinates of nodes                        *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
*            CHOPT       - options: 'BF' - from BACK to FRONT          *
*                                   'FB' - from FRONT to BACK          *
*                                                                      *
************************************************************************
+CDE, HCPHI.
+CDE, PNVMAX.
      REAL              AB(2,4),XYZ(3,8),V(NVMAX),TT(4,NVMAX),TFACE(4)
      INTEGER           ICODES(4),IFACE(4),IVIS(6)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
*-
      IF (IORDR .EQ. 0) THEN
        JR     = 1
        JPHI   = 2
        NR     = NA
        NPHI   = NB
      ELSE
        JR     = 2
        JPHI   = 1
        NR     = NB
        NPHI   = NA
      END IF
      IF (NPHI .GT. NPMAX)                              GOTO 998
      RAD    = ATAN(1.)*4./180.
      IOPT   = 2
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')     IOPT = 1
*
**       P R E P A R E   P H I   A R R A Y
**       F I N D    C R I T I C A L   S E C T O R S
*
      KPHI   = NPHI
      IF (IORDR .EQ. 0)                 IA = NR
      IF (IORDR .NE. 0)                 IB = NR
      DO 10 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,NV,AB,V,TT)
        IF (I .EQ. 1)                   APHI(1)   = AB(JPHI,1)
        APHI(I)   = (APHI(I) + AB(JPHI,1))/2.
        APHI(I+1) = AB(JPHI,3)
   10 CONTINUE
      CALL IHWPHI(IOPT,KPHI,APHI,IPHI1,IPHI2)
*
**      E N C O D E   V I S I B I L I T Y   O F   S I D E S
**      A N D   O R D E R   A L O N G   R
*
      DO 20 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,NV,AB,V,TT)
        CALL IHWVR1(IOPT,AB(JPHI,1)*RAD,AB(JPHI,3)*RAD,APHI(I))
   20 CONTINUE
*
**       D R A W   S T A C K   O F   L E G O - P L O T S
*
      INCR   = 1
      IPHI   = IPHI1
  100 IF (IPHI .GT. NPHI)               GOTO 300
*       D E C O D E   V I S I B I L I T Y   O F   S I D E S
      CALL IHWVR2(APHI(IPHI),
     &            IVIS(1),IVIS(2),IVIS(3),IVIS(4),IVIS(5),IVIS(6),INCRR)
      IR1    = 1
      IF (INCRR .LT. 0)                 IR1 = NR
      IR2    = NR - IR1 + 1
*        D R A W   L E G O S   F O R   S E C T O R
      DO 290 IR=IR1,IR2,INCRR
        IF (IORDR .EQ. 0) THEN
          IA     = IR
          IB     = IPHI
        ELSE
          IA     = IPHI
          IB     = IR
        END IF
        CALL FUN(IA,IB,NV,AB,V,TT)
        IF (NV.LT.2 .OR. NV.GT.NVMAX)   GOTO 290
        ICODES(1) = IA
        ICODES(2) = IB
        DO 210 I=1,4
          J          = I
          IF (IORDR.NE.0 .AND. I.EQ.2)  J = 4
          IF (IORDR.NE.0 .AND. I.EQ.4)  J = 2
          XYZ(1,J)   = AB(JR,I)*COS(AB(JPHI,I)*RAD)
          XYZ(2,J)   = AB(JR,I)*SIN(AB(JPHI,I)*RAD)
          XYZ(1,J+4) = XYZ(1,J)
          XYZ(2,J+4) = XYZ(2,J)
  210   CONTINUE
*        D R A W   S T A C K
        DO 240 IV=1,NV-1
          DO 220 I=1,4
            XYZ(3,I)   = V(IV)
            XYZ(3,I+4) = V(IV+1)
  220     CONTINUE
          IF (V(IV) .GE. V(IV+1))       GOTO 240
          ICODES(3) = IV
          DO 230 I=1,4
            IF (IVIS(I) .EQ. 0)         GOTO 230
            K1     = I-1
            IF (I .EQ. 1)               K1 = 4
            K2     = I
            IF (XYZ(1,K1).EQ.XYZ(1,K2) .AND.
     &          XYZ(2,K1).EQ.XYZ(2,K2)) GOTO 230
            IFACE(1) = K1
            IFACE(2) = K2
            IFACE(3) = K2 + 4
            IFACE(4) = K1 + 4
            TFACE(1) = TT(K1,IV)
            TFACE(2) = TT(K2,IV)
            TFACE(3) = TT(K2,IV+1)
            TFACE(4) = TT(K1,IV+1)
            ICODES(4)= I
            CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
  230     CONTINUE
  240   CONTINUE
*           D R A W   B O T T O M   F A C E
        IF (IVIS(5) .NE. 0) THEN
          ICODES(3) = 1
          ICODES(4) = 5
          DO 250 I=1,4
            XYZ(3,I) = V(1)
            IFACE(I) = 5 - I
            TFACE(I) = TT(5-I,1)
  250     CONTINUE
          CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
        END IF
*           D R A W   T O P   F A C E
        IF (IVIS(6) .NE. 0) THEN
          ICODES(3) = NV - 1
          ICODES(4) = 6
          DO 260 I=1,4
            IFACE(I) = I + 4
            TFACE(I) = TT(I,NV)
  260     CONTINUE
          CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
        END IF
  290 CONTINUE
*        N E X T   P H I
  300 IPHI   = IPHI + INCR
      IF (IPHI .EQ. 0)                  IPHI = KPHI
      IF (IPHI .GT. KPHI)               IPHI = 1
      IF (IPHI .NE. IPHI2)              GOTO 100
      IF (INCR) 310,999,320
  310 INCR   = 0
      GOTO 100
  320 INCR   =-1
      IPHI   = IPHI1
      GOTO 300
*
  998 WRITE(*,*) 'IHLEGP: too many PHI sectors'
  999 RETURN
      END
+DECK,  IHLEGR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHLEGR(IORDR,NA,NB,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHLEGR                                     Date:    04.11.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 31.03.93     *
*                                                                      *
*     Function: Draw stack of lego-plots in cylindrical coordinates    *
*                                                                      *
*     References: IHWPHI, IHWVR1, IHWVR2, IHWZN                        *
*                                                                      *
*     Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z)         *
*            NA    - number of steps along 1st variable                *
*            NPHI  - number of steps along 2nd variable                *
*                                                                      *
*            FUN(IA,IB,NV,AB,V,TT) - external routine                  *
*              IA      - cell number for 1st variable                  *
*              IB      - cell number for 2nd variable                  *
*              NV      - number of values for given cell               *
*              AB(2,4) - coordinates of the cell corners               *
*              V(NV)   - cell values                                   *
*              TT(4,*) - additional function                           *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - IA                                        *
*                ICODES(2) - IB                                        *
*                ICODES(3) - IV                                        *
*                ICODES(4) - side: 1,2,3,4 - ordinary sides            *
*                                  5-bottom,6-top                      *
*              XYZ(3,*)  - coordinates of nodes                        *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
*            CHOPT       - options: 'BF' - from BACK to FRONT          *
*                                   'FB' - from FRONT to BACK          *
*                                                                      *
************************************************************************
+CDE, HCPHI.
+CDE, PNVMAX.
      REAL              AB(2,4),XYZ(3,8),V(NVMAX),TT(4,NVMAX),TFACE(4)
      REAL              COSPHI(4),SINPHI(4)
      INTEGER           ICODES(4),IFACE(4),IVIS(6)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
*-
      IF (IORDR .EQ. 0) THEN
        JZ     = 1
        JPHI   = 2
        NZ     = NA
        NPHI   = NB
      ELSE
        JZ     = 2
        JPHI   = 1
        NZ     = NB
        NPHI   = NA
      END IF
      IF (NPHI .GT. NPMAX)              GOTO 998
      RAD    = ATAN(1.)*4./180.
      IOPT   = 2
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')     IOPT = 1
*
**       P R E P A R E   P H I   A R R A Y
**       F I N D    C R I T I C A L   S E C T O R S
*
      KPHI   = NPHI
      IF (IORDR .EQ. 0)                 IA = NZ
      IF (IORDR .NE. 0)                 IB = NZ
      DO 10 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,NV,AB,V,TT)
        IF (I .EQ. 1)                   APHI(1)   = AB(JPHI,1)
        APHI(I)   = (APHI(I) + AB(JPHI,1))/2.
        APHI(I+1) = AB(JPHI,3)
   10 CONTINUE
      CALL IHWPHI(IOPT,KPHI,APHI,IPHI1,IPHI2)
*
**      E N C O D E   V I S I B I L I T Y   O F   S I D E S
**      A N D   O R D E R   A L O N G   R
*
      DO 20 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,NV,AB,V,TT)
        CALL IHWVR1(IOPT,AB(JPHI,1)*RAD,AB(JPHI,3)*RAD,APHI(I))
   20 CONTINUE
*
**       F I N D   O R D E R   A L O N G   Z
*
      INCRZ  = 1
      IZ1    = 1
      CALL IHWZN(0.,0.,1.,Z)
      IF ((Z.LE.0. .AND. IOPT.EQ.1) .OR. (Z.GT.0. .AND. IOPT.EQ.2)) THEN
        INCRZ  =-1
        IZ1    = NZ
      END IF
      IZ2    = NZ - IZ1 + 1
*
**       D R A W   S T A C K   O F   L E G O - P L O T S
*
      INCR   = 1
      IPHI   = IPHI1
  100 IF (IPHI .GT. NPHI)               GOTO 400
*       D E C O D E   V I S I B I L I T Y   O F   S I D E S
      CALL IHWVR2(APHI(IPHI),
     &    IVIS(5),IVIS(2),IVIS(6),IVIS(4),IVIS(1),IVIS(3),IDUMMY)
      DO 300 IZ=IZ1,IZ2,INCRZ
        IF (IORDR .EQ. 0) THEN
          IA     = IZ
          IB     = IPHI
        ELSE
          IA     = IPHI
          IB     = IZ
        END IF
        CALL FUN(IA,IB,NV,AB,V,TT)
        IF (NV.LT.2 .OR. NV.GT.NVMAX)   GOTO 300
        ICODES(1) = IA
        ICODES(2) = IB
        DO 210 I=1,4
          J          = I
          IF (IORDR.NE.0 .AND. I.EQ.2)  J = 4
          IF (IORDR.NE.0 .AND. I.EQ.4)  J = 2
          COSPHI(J)  = COS(AB(JPHI,I)*RAD)
          SINPHI(J)  = SIN(AB(JPHI,I)*RAD)
          XYZ(3,J)   = AB(JZ,I)
          XYZ(3,J+4) = AB(JZ,I)
  210   CONTINUE
*        D R A W   S T A C K
        DO 240 IV=1,NV-1
          DO 220 I=1,4
            XYZ(1,I)   = V(IV)*COSPHI(I)
            XYZ(2,I)   = V(IV)*SINPHI(I)
            XYZ(1,I+4) = V(IV+1)*COSPHI(I)
            XYZ(2,I+4) = V(IV+1)*SINPHI(I)
  220     CONTINUE
          IF (V(IV) .GE. V(IV+1))       GOTO 240
          ICODES(3) = IV
          DO 230 I=1,4
            IF (IVIS(I) .EQ. 0)           GOTO 230
            K1        = I
            K2        = I - 1
            IF (I .EQ. 1)                 K2 = 4
            IFACE(1)  = K1
            IFACE(2)  = K2
            IFACE(3)  = K2 + 4
            IFACE(4)  = K1 + 4
            TFACE(1)  = TT(K1,IV)
            TFACE(2)  = TT(K2,IV)
            TFACE(3)  = TT(K2,IV+1)
            TFACE(4)  = TT(K1,IV+1)
            ICODES(4) = I
            CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
  230     CONTINUE
  240   CONTINUE
*        D R A W   B O T T O M   F A C E
        IF (IVIS(5).NE.0 .AND. V(1).GT.0.) THEN
          ICODES(3) = 1
          ICODES(4) = 5
          DO 250 I=1,4
            XYZ(1,I) = V(1)*COSPHI(I)
            XYZ(2,I) = V(1)*SINPHI(I)
            IFACE(I) = I
            TFACE(I) = TT(I,1)
  250     CONTINUE
          CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
        END IF
*        D R A W   T O P   F A C E
        IF (IVIS(6).NE.0 .AND. V(NV).GT.0.) THEN
          ICODES(3) = NV - 1
          ICODES(4) = 6
          DO 260 I=1,4
            IFACE(I) = 5 - I + 4
            TFACE(I) = TT(5-I,NV)
  260     CONTINUE
          CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
        END IF
  300 CONTINUE
*        N E X T   P H I
  400 IPHI   = IPHI + INCR
      IF (IPHI .EQ. 0)                  IPHI = KPHI
      IF (IPHI .GT. KPHI)               IPHI = 1
      IF (IPHI .NE. IPHI2)              GOTO 100
      IF (INCR) 410,999,420
  410 INCR   = 0
      GOTO 100
  420 INCR   =-1
      IPHI   = IPHI1
      GOTO 400
*
  998 WRITE(*,*) 'IHLEGR: too many PHI sectors'
  999 RETURN
      END
+DECK,  IHLEGS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHLEGS(IPSDR,IORDR,NA,NB,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHLEGS                                     Date:    11.11.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 13.04.93     *
*                                                                      *
*     Function: Draw stack of lego-plots spheric coordinates           *
*                                                                      *
*     References: IHWPHI, IHWTH, IHWZN                                 *
*                                                                      *
*     Input: IPSDR - pseudo-rapidity flag                              *
*            IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA) *
*            NA    - number of steps along 1st variable                *
*            NB    - number of steps along 2nd variable                *
*                                                                      *
*            FUN(IA,IB,NV,AB,V,TT) - external routine                  *
*              IA      - cell number for 1st variable                  *
*              IB      - cell number for 2nd variable                  *
*              NV      - number of values for given cell               *
*              AB(2,4) - coordinates of the cell corners               *
*              V(NV)   - cell values                                   *
*              TT(4,*) - additional function                           *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - IA                                        *
*                ICODES(2) - IB                                        *
*                ICODES(3) - IV                                        *
*                ICODES(4) - side: 1,2,3,4 - ordinary sides            *
*                                  5-bottom,6-top                      *
*              XYZ(3,*)  - coordinates of nodes                        *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
*            CHOPT       - options: 'BF' - from BACK to FRONT          *
*                                   'FB' - from FRONT to BACK          *
*                                                                      *
************************************************************************
+CDE, HCPHI.
+CDE, PNVMAX.
      REAL              AB(2,4),XYZ(3,8),V(NVMAX)
      REAL              TT(4,NVMAX),TFACE(4)
      REAL              COSTH(4),SINTH(4),COSPHI(4),SINPHI(4)
      INTEGER           ICODES(4),IFACE(4),IVIS(6)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
*-
      IF (IORDR .EQ. 0) THEN
        JTH    = 1
        JPHI   = 2
        NTH    = NA
        NPHI   = NB
      ELSE
        JTH    = 2
        JPHI   = 1
        NTH    = NB
        NPHI   = NA
      END IF
      IF (NTH  .GT. NPMAX)              GOTO 997
      IF (NPHI .GT. NPMAX)              GOTO 998
      RAD    = ATAN(1.)*4./180.
      IOPT   = 2
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')     IOPT = 1
*
**       P R E P A R E   P H I   A R R A Y
**       F I N D    C R I T I C A L   P H I   S E C T O R S
*
      KPHI   = NPHI
      MTH    = NTH/2
      IF (MTH .EQ. 0)                   MTH = 1
      IF (IORDR .EQ. 0)                 IA = MTH
      IF (IORDR .NE. 0)                 IB = MTH
      DO 10 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,NV,AB,V,TT)
        IF (I .EQ. 1)                   APHI(1)   = AB(JPHI,1)
        APHI(I)   = (APHI(I) + AB(JPHI,1))/2.
        APHI(I+1) = AB(JPHI,3)
   10 CONTINUE
      CALL IHWPHI(IOPT,KPHI,APHI,IPHI1,IPHI2)
*
**       P R E P A R E   T H E T A   A R R A Y
*
      IF (IORDR .EQ. 0)                 IB = 1
      IF (IORDR .NE. 0)                 IA = 1
      DO 20 I=1,NTH
        IF (IORDR .EQ. 0)               IA = I
        IF (IORDR .NE. 0)               IB = I
        CALL FUN(IA,IB,NV,AB,V,TT)
        IF (I .EQ. 1)                   APHI(1) = AB(JTH,1)
        APHI(I)   = (APHI(I) + AB(JTH,1))/2.
        APHI(I+1) = AB(JTH,3)
   20 CONTINUE
*
**       D R A W   S T A C K   O F   L E G O - P L O T S
*
      KTH    = NTH
      INCR   = 1
      IPHI   = IPHI1
  100 IF (IPHI .GT. NPHI)               GOTO 500
*        F I N D    C R I T I C A L   T H E T A   S E C T O R S
      IF (IORDR .EQ. 0) THEN
        IA     = MTH
        IB     = IPHI
      ELSE
        IA     = IPHI
        IB     = MTH
      END IF
      CALL FUN(IA,IB,NV,AB,V,TT)
      PHI    = (AB(JPHI,1) + AB(JPHI,3)) / 2.
      CALL IHWTH(IOPT,PHI,KTH,APHI,ITH1,ITH2)
      INCRTH = 1
      ITH    = ITH1
  200 IF (ITH .GT. NTH)                 GOTO 400
      IF (IORDR .EQ. 0)                 IA = ITH
      IF (IORDR .NE. 0)                 IB = ITH
      CALL FUN(IA,IB,NV,AB,V,TT)
      IF (NV.LT.2 .OR. NV.GT.NVMAX)     GOTO 400
*        D E F I N E   V I S I B I L I T Y   O F   S I D E S
      DO 300 I=1,6
        IVIS(I) = 0
  300 CONTINUE
      PHI1   = RAD * AB(JPHI,1)
      PHI2   = RAD * AB(JPHI,3)
      TH1    = RAD * AB(JTH,1)
      TH2    = RAD * AB(JTH,3)
      CALL IHWZN(SIN(PHI1),-COS(PHI1),0.,ZN)
      IF (ZN .GT. 0.)                   IVIS(2) = 1
      CALL IHWZN(-SIN(PHI2),COS(PHI2),0.,ZN)
      IF (ZN .GT. 0.)                   IVIS(4) = 1
      PHI    = (PHI1 + PHI2) / 2.
      CALL IHWZN(-COS(PHI)*COS(TH1),-SIN(PHI)*COS(TH1),SIN(TH1),ZN)
      IF (ZN .GT. 0.)                   IVIS(1) = 1
      CALL IHWZN(COS(PHI)*COS(TH2),SIN(PHI)*COS(TH2),-SIN(TH2),ZN)
      IF (ZN .GT. 0.)                   IVIS(3) = 1
      TH     = (TH1 + TH2) / 2.
      IF (IPSDR .EQ. 1)                               TH = RAD * 90.
      CALL IHWZN(COS(PHI)*SIN(TH),SIN(PHI)*SIN(TH),COS(TH),ZN)
      IF (ZN .LT. 0.)                   IVIS(5) = 1
      IF (ZN .GT. 0.)                   IVIS(6) = 1
*        D R A W   S T A C K
      ICODES(1) = IA
      ICODES(2) = IB
      DO 310 I=1,4
        J          = I
        IF (IORDR.NE.0 .AND. I.EQ.2)    J = 4
        IF (IORDR.NE.0 .AND. I.EQ.4)    J = 2
        COSTH(J)  = COS(RAD*AB(JTH,I))
        SINTH(J)  = SIN(RAD*AB(JTH,I))
        COSPHI(J) = COS(RAD*AB(JPHI,I))
        SINPHI(J) = SIN(RAD*AB(JPHI,I))
  310 CONTINUE
      DO 350 IV=1,NV-1
        IF (IPSDR .EQ. 1) THEN
          DO 320 I=1,4
            XYZ(1,I)   = V(IV)   * COSPHI(I)
            XYZ(2,I)   = V(IV)   * SINPHI(I)
            XYZ(3,I)   = V(IV)   * COSTH(I) / SINTH(I)
            XYZ(1,I+4) = V(IV+1) * COSPHI(I)
            XYZ(2,I+4) = V(IV+1) * SINPHI(I)
            XYZ(3,I+4) = V(IV+1) * COSTH(I) / SINTH(I)
  320     CONTINUE
        ELSE
          DO 330 I=1,4
            XYZ(1,I)   = V(IV)   * SINTH(I) * COSPHI(I)
            XYZ(2,I)   = V(IV)   * SINTH(I) * SINPHI(I)
            XYZ(3,I)   = V(IV)   * COSTH(I)
            XYZ(1,I+4) = V(IV+1) * SINTH(I) * COSPHI(I)
            XYZ(2,I+4) = V(IV+1) * SINTH(I) * SINPHI(I)
            XYZ(3,I+4) = V(IV+1) * COSTH(I)
  330     CONTINUE
        END IF
        IF (V(IV) .GE. V(IV+1))         GOTO 350
        ICODES(3) = IV
        DO 340 I=1,4
          IF (IVIS(I) .EQ. 0)           GOTO 340
          K1        = I - 1
          IF (I .EQ. 1)                 K1 = 4
          K2        = I
          IFACE(1)  = K1
          IFACE(2)  = K2
          IFACE(3)  = K2 + 4
          IFACE(4)  = K1 + 4
          TFACE(1)  = TT(K1,IV)
          TFACE(2)  = TT(K2,IV)
          TFACE(3)  = TT(K2,IV+1)
          TFACE(4)  = TT(K1,IV+1)
          ICODES(4) = I
          CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
  340   CONTINUE
  350 CONTINUE
*        D R A W   B O T T O M   F A C E
      IF (IVIS(5).NE.0 .AND. V(1).GT.0.) THEN
        ICODES(3) = 1
        ICODES(4) = 5
        DO 360 I=1,4
          IF (IPSDR .EQ. 1) THEN
            XYZ(1,I) = V(1) * COSPHI(I)
            XYZ(2,I) = V(1) * SINPHI(I)
            XYZ(3,I) = V(1) * COSTH(I) / SINTH(I)
          ELSE
            XYZ(1,I) = V(1) * SINTH(I) * COSPHI(I)
            XYZ(2,I) = V(1) * SINTH(I) * SINPHI(I)
            XYZ(3,I) = V(1) * COSTH(I)
          ENDIF
          IFACE(I) = 5 - I
          TFACE(I) = TT(5-I,1)
  360   CONTINUE
        CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
      END IF
*        D R A W   T O P   F A C E
      IF (IVIS(6).NE.0 .AND. V(NV).GT.0.) THEN
        ICODES(3) = NV - 1
        ICODES(4) = 6
        DO 370 I=1,4
          IFACE(I) = I+4
          TFACE(I) = TT(I+4,NV)
  370   CONTINUE
        CALL DRFACE(ICODES,XYZ,4,IFACE,TFACE)
      END IF
*        N E X T   T H E T A
  400 ITH    = ITH + INCRTH
      IF (ITH .EQ. 0)                   ITH = KTH
      IF (ITH .GT. KTH)                 ITH = 1
      IF (ITH .NE. ITH2)                GOTO 200
      IF (INCRTH) 410,500,420
  410 INCRTH = 0
      GOTO 200
  420 INCRTH =-1
      ITH    = ITH1
      GOTO 400
*        N E X T   P H I
  500 IPHI   = IPHI + INCR
      IF (IPHI .EQ. 0)                  IPHI = KPHI
      IF (IPHI .GT. KPHI)               IPHI = 1
      IF (IPHI .NE. IPHI2)              GOTO 100
      IF (INCR) 510,999,520
  510 INCR   = 0
      GOTO 100
  520 INCR   =-1
      IPHI   = IPHI1
      GOTO 500
*
  997 WRITE(*,*) 'IHLEGS: too many THETA sectors'
      GOTO 999
  998 WRITE(*,*) 'IHLEGS: too many PHI sectors'
      GOTO 999
  999 RETURN
      END
+DECK,  IHLIGH, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHLIGH(NL,YL,XSCR,YSCR,ZSCR,IREP)
************************************************************************
*                                                                      *
*     IHLIGH                                     Date:    11.10.91     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Set light source                                       *
*                                                                      *
*     Input: NL   - source number: -1 off all light sources            *
*                                   0 set diffused light               *
*            YL   - intensity of the light source                      *
*            XSCR \                                                    *
*            YSCR  - direction of the light (in respect of the screen) *
*            ZSCR /                                                    *
*                                                                      *
*     Output: IREP   - reply : 0 - O.K.                                *
*                             -1 - error in light sources definition:  *
*                                  negative intensity                  *
*                                  source number greater than max      *
*                                  light source is placed at origin    *
*                                                                      *
************************************************************************
+CDE, HCLIGH.
*-
      IREP   = 0
      IF (NL) 100,200,300
**          S W I T C H   O F F   L I G H T S
  100 LOFF   = 1
      YDL    = 0.
      DO 110 I=1,LLIGHT
        YLS(I) = 0.
  110 CONTINUE
      GOTO 999
**          S E T   D I F F U S E D   L I G H T
  200 IF (YL .LT. 0.)                   GOTO 996
      YDL    = YL
      GOTO 400
**          S E T   L I G H T   S O U R C E
  300 IF (NL .GT. LLIGHT)               GOTO 997
      IF (YL .LT. 0.)                   GOTO 997
      S      = SQRT(XSCR*XSCR+YSCR*YSCR+ZSCR*ZSCR)
      IF (S .EQ. 0.)                    GOTO 998
      YLS(NL) = YL
      VLS(1,NL) = XSCR/S
      VLS(2,NL) = YSCR/S
      VLS(3,NL) = ZSCR/S
*           C H E C K   L I G H T S
  400 LOFF   = 0
      IF (YDL .NE. 0)                   GOTO 999
      DO 410 I=1,LLIGHT
        IF (YLS(I) .NE. 0.)             GOTO 999
  410 CONTINUE
      LOFF   = 1
      GOTO 999
*
  996 WRITE(*,*) 'IHLIGH: negative light intensity'
      IREP   =-1
      GOTO 999
  997 WRITE(*,*) 'IHLIGH: illegal light source number'
      IREP   =-1
      GOTO 999
  998 WRITE(*,*) 'IHLIGH: light source is placed at origin'
      IREP   =-1
      GOTO 999
  999 RETURN
      END
+DECK,  IHLUMI, T=FORT.
* Revision 1.3  1996/09/25 15:02:14  couet
* *** empty log message ***
* Revision 1.2  1996/09/25 14:58:22  couet
* - Protection added to prevent division by 0
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHLUMI(ANORM,FLUM)
************************************************************************
*                                                                      *
*     IHLUMI                                     Date:    11.10.91     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find surface luminosity at given point                 *
*                                                                      *
*                                          --                          *
*     Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi)   *
*                                          --                          *
*                                                                      *
*             B1     = VN(3)*VL(2) - VN(2)*VL(3)                       *
*             B2     = VN(1)*VL(3) - VN(3)*VL(1)                       *
*             B3     = VN(2)*VL(1) - VN(1)*VL(2)                       *
*             B4     = VN(1)*VL(1) + VN(2)*VL(2) + VN(3)*VL(3)         *
*             VR(1)  = VN(3)*B2 - VN(2)*B3 + VN(1)*B4                  *
*             VR(2)  =-VN(3)*B1 + VN(1)*B3 + VN(2)*B4                  *
*             VR(3)  = VN(2)*B1 - VN(1)*B2 + VN(3)*B4                  *
*             S      = SQRT(VR(1)*VR(1)+VR(2)*VR(2)+VR(3)*VR(3))       *
*             VR(1)  = VR(1)/S                                         *
*             VR(2)  = VR(2)/S                                         *
*             VR(3)  = VR(3)/S                                         *
*             COSR   = VR(1)*0. + VR(2)*0. + VR(3)*1.                  *
*                                                                      *
*     References: IHWTON                                               *
*                                                                      *
*     Input: ANORM(3) - surface normal at given point                  *
*                                                                      *
*     Output: FLUM - luminosity                                        *
*                                                                      *
************************************************************************
+CDE, HCLIGH.
      REAL              ANORM(3),VN(3),VL(3)
*-
      FLUM   = 0.
      IF (LOFF .NE. 0) RETURN
*
**          T R A N S F E R   N O R M A L  T O   SCREEN COORDINATES
*
      CALL IHWWNN(ANORM,VN)
      S      = SQRT(VN(1)*VN(1)+VN(2)*VN(2)+VN(3)*VN(3))
      IF (VN(3) .LT. 0.)                S =-S
      IF (S.NE.0.) THEN
         VN(1)  = VN(1)/S
         VN(2)  = VN(2)/S
         VN(3)  = VN(3)/S
      ELSE
         RETURN
      ENDIF
*
**          F I N D   L U M I N O S I T Y
*
      FLUM   = YDL*QA
      DO 100 I=1,LLIGHT
        IF (YLS(I) .LE. 0.)             GOTO 100
        VL(1)  = VLS(1,I)
        VL(2)  = VLS(2,I)
        VL(3)  = VLS(3,I)
        COSN   = VL(1)*VN(1) + VL(2)*VN(2) + VL(3)*VN(3)
        IF (COSN .LT. 0.)               GOTO 100
        COSR   = VN(2)*(VN(3)*VL(2)-VN(2)*VL(3))
     &          -VN(1)*(VN(1)*VL(3)-VN(3)*VL(1)) + VN(3)*COSN
        IF (COSR .LE. 0.)               COSR = 0.
        FLUM   = FLUM + YLS(I)*(QD*COSN + QS*COSR**NQS)
  100 CONTINUE
*
      END
+DECK,  IHMC00, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHMC00(K1,K2,K3,K4,K5,K6,NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC00                                     Date:    20.07.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consideration of trivial cases: 1,2,5,8,9,11,14        *
*                                                                      *
*     Input: K1,...,K6 - edges intersected with isosurface             *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IE(6),IT(3,4,4)
      DATA              IT/1,2,3,   0,0,0,   0,0,0,  0,0,0,
     &                     1,2,-3, -1,3,4,   0,0,0,  0,0,0,
     &                     1,2,-3, -1,3,-4, -1,4,5,  0,0,0,
     &                     1,2,-3, -1,3,-4, -4,6,-1, 4,5,-6/
*-
**          S E T   N O D E S   &   N O R M A L E S
*
      IE(1)  = K1
      IE(2)  = K2
      IE(3)  = K3
      IE(4)  = K4
      IE(5)  = K5
      IE(6)  = K6
      NNOD   = 6
      IF (IE(6) .EQ. 0)          NNOD = 5
      IF (IE(5) .EQ. 0)          NNOD = 4
      IF (IE(4) .EQ. 0)          NNOD = 3
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**         S E T   T R I A N G L E S
*
      NTRIA  = NNOD - 2
      CALL IHMCTT(NTRIA,IT(1,1,NTRIA),ITRIA)
      RETURN
      END
+DECK,  IHMC03, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:50  mclareni
* Higz

      SUBROUTINE IHMC03(NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC03                                     Date:    10.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consider case No 3                                     *
*                                                                      *
*     Input: see common HCMCUB                                         *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IE(6),IT1(3,2),IT2(3,4)
      DATA              IE/4,9,1, 2,11,3/
      DATA              IT1/1,2,3, 4,5,6/
      DATA              IT2/1,2,-5, -1,5,6, 5,-2,4, -4,2,3/
*-
**          S E T   N O D E S   &   N O R M A L E S
*
      NNOD   = 6
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**          F I N D   C O N F I G U R A T I O N
*
      F0     = (F8(1)*F8(3)-F8(2)*F8(4)) / (F8(1)+F8(3)-F8(2)-F8(4))
      IF (F0.GE.0. .AND. F8(1).GE.0.)   GOTO 100
      IF (F0.LT.0. .AND. F8(1).LT.0.)   GOTO 100
      NTRIA  = 2
      CALL IHMCTT(NTRIA,IT1,ITRIA)
      GOTO 999
*
**          N O T   S E P A R A T E D   F R O N T   F A C E
*
  100 NTRIA  = 4
      CALL IHMCTT(NTRIA,IT2,ITRIA)
      GOTO 999
*
  999 RETURN
      END
+DECK,  IHMC04, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMC04(NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC04                                     Date:    10.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consider case No 4                                     *
*                                                                      *
*     Input: see common HCMCUB                                         *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IE(6),IT1(3,2),IT2(3,6)
      DATA              IE/4,9,1, 7,11,6/
      DATA              IT1/1,2,3, 4,5,6/
      DATA              IT2/1,2,4, 2,3,6, 3,1,5, 4,5,1, 5,6,3, 6,4,2/
*-
**          S E T   N O D E S   &   N O R M A L E S
*
      NNOD   = 6
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**          I S   T H E R E   S U R F A C E   P E N E T R A T I O N ?
*
      CALL IHMCX(F8(1),F8(2),F8(3),F8(4),F8(5),F8(6),F8(7),F8(8),IREP)
      IF (IREP .EQ. 0) THEN
        NTRIA  = 2
        CALL IHMCTT(NTRIA,IT1,ITRIA)
      ELSE
        NTRIA  = 6
        CALL IHMCTT(NTRIA,IT2,ITRIA)
      END IF
      RETURN
      END
+DECK,  IHMC06, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMC06(NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC06                                     Date:    10.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consider case No 6                                     *
*                                                                      *
*     Input: see common HCMCUB                                         *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IE(7),IT1(3,5),IT2(3,3),IT3(3,7)
      DATA              IE/2,4,9,10, 6,7,11/
      DATA              IT1/6,7,-1, -6,1,2, 6,2,3, 6,3,-4, -6,4,5/
      DATA              IT2/1,2,-3, -1,3,4, 5,6,7/
      DATA              IT3/6,7,-1, -6,1,2, 6,2,3, 6,3,-4, -6,4,5,
     &                      1,7,-5, -1,5,4/
*-
**          S E T   N O D E S   &   N O R M A L E S
*
      NNOD   = 7
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**          F I N D   C O N F I G U R A T I O N
*
      F0     = (F8(2)*F8(7)-F8(6)*F8(3)) / (F8(2)+F8(7)-F8(6)-F8(3))
      IF (F0.GE.0. .AND. F8(2).GE.0.)   GOTO 100
      IF (F0.LT.0. .AND. F8(2).LT.0.)   GOTO 100
*
**          I S   T H E R E   S U R F A C E   P E N E T R A T I O N ?
*
      CALL IHMCX(F8(3),F8(2),F8(6),F8(7),F8(4),F8(1),F8(5),F8(8),IREP)
      IF (IREP .EQ. 1) THEN
        NTRIA = 7
        CALL IHMCTT(NTRIA,IT3,ITRIA)
      ELSE
        NTRIA = 3
        CALL IHMCTT(NTRIA,IT2,ITRIA)
      END IF
      GOTO 999
*
**          N O T   S E P A R A T E D   R I G T H   F A C E
*
  100 NTRIA  = 5
      CALL IHMCTT(NTRIA,IT1,ITRIA)
      GOTO 999
*
  999 RETURN
      END
+DECK,  IHMC07, T=FORT.
* Revision 1.2  2002/05/16 15:29:27  couet
* - During the conversion to C++ (for ROOT), two bugs have been found
*   (and fixed) in the fortran code.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMC07(NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC07                                     Date:    13.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consider case No 7                                     *
*                                                                      *
*     Input: see common HCMCUB                                         *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IE(9),IT(3,9,9)
      DATA              IE/3,12,4, 1,10,2, 11,6,7/
      DATA              IT/
     & 1,2,3, 4,5,6, 7,8,9, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
     & 1,2,3, 4,9,-7, -4,7,6, 9,4,-5, -9,5,8, 0,0,0,0,0,0,0,0,0,0,0,0,
     & 4,5,6, 8,3,-1, -8,1,7, 3,8,-9, -3,9,2, 0,0,0,0,0,0,0,0,0,0,0,0,
     &-10,2,3, 10,3,-1, -10,1,7, 10,7,-6, -10,6,4,
     &                           10,4,-5, -10,5,8, 10,8,9, 10,9,-2,
     & 7,8,9, 2,5,-6, -2,6,1, 5,2,-3, -5,3,4, 0,0,0,0,0,0,0,0,0,0,0,0,
     &-10,1,2, 10,2,-3, -10,3,4, 10,4,5, 10,5,-8,
     &                          -10,8,9, 10,9,-7, -10,7,6, 10,6,-1,
     & 10,2,3, 10,3,-4, -10,4,5, 10,5,-6, -10,6,1,
     &                           10,1,-7, -10,7,8, 10,8,-9, -10,9,2,
     & 1,7,6, -4,2,3, -4,9,-2, -9,4,-5, -9,5,8, 0,0,0,0,0,0,0,0,0,0,0,0,
     &-1,9,2, 1,2,3, 1,3,-4, 6,-1,4, 6,4,5,
     &              6,-5,7, -7,5,8, 7,8,9, 7,-9,1/
*-
**          S E T   N O D E S   &   N O R M A L E S
*
      NNOD   = 9
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**          F I N D   C O N F I G U R A T I O N
*
      F1     = (F8(3)*F8(6)-F8(2)*F8(7)) / (F8(3)+F8(6)-F8(2)-F8(7))
      F2     = (F8(3)*F8(8)-F8(4)*F8(7)) / (F8(3)+F8(8)-F8(4)-F8(7))
      F3     = (F8(3)*F8(1)-F8(2)*F8(4)) / (F8(3)+F8(1)-F8(2)-F8(4))
      ICASE  = 1
      IF (F1.GE.0. .AND. F8(3).LT.0.)   ICASE = ICASE + 1
      IF (F1.LT.0. .AND. F8(3).GE.0.)   ICASE = ICASE + 1
      IF (F2.GE.0. .AND. F8(3).LT.0.)   ICASE = ICASE + 2
      IF (F2.LT.0. .AND. F8(3).GE.0.)   ICASE = ICASE + 2
      IF (F3.GE.0. .AND. F8(3).LT.0.)   ICASE = ICASE + 4
      IF (F3.LT.0. .AND. F8(3).GE.0.)   ICASE = ICASE + 4
      NTRIA  = 5
      GOTO (100,400,400,200,400,200,200,300),ICASE
  100 NTRIA  = 3
      GOTO 400
*
**          F I N D   A D D I T I O N A L   P O I N T
*
  200 NNOD   = 10
      NTRIA  = 9
      CALL IHMCMP(9,XYZ,GRAD,IT(1,1,ICASE),XYZ(1,NNOD),GRAD(1,NNOD))
      GOTO 400
*
**          I S   T H E R E   S U R F A C E   P E N E T R A T I O N ?
*
  300 CALL IHMCX(F8(4),F8(3),F8(7),F8(8),F8(1),F8(2),F8(6),F8(5),IREP)
      IF (IREP .NE. 2)                  GOTO 400
CCC      CALL IHMCTT(NTRIA,IT8,ITRIA)
      NTRIA = 9
      ICASE = 9
*
**          S E T   T R I A N G L E S
*
  400 CALL IHMCTT(NTRIA,IT(1,1,ICASE),ITRIA)
      RETURN
      END
+DECK,  IHMC10, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMC10(NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC10                                     Date:    10.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consider case No 10                                    *
*                                                                      *
*     Input: see common HCMCUB                                         *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IE(8),IT(3,8,6)
      DATA              IE/1,3,12,9, 5,7,11,10/
      DATA              IT/
     & 1,2,-3, -1,3,4, 5,6,-7, -5,7,8, 0,0,0,   0,0,0, 0,0,0,   0,0,0,
     & 9,1,2,   9,2,3, 9,3,4,   9,4,5, 9,5,6,   9,6,7, 9,7,8,   9,8,1,
     & 9,1,2,   9,4,1, 9,3,4,   9,6,3, 9,5,6,   9,8,5, 9,7,8,   9,2,7,
     & 1,2,-7, -1,7,8, 5,6,-3, -5,3,4, 0,0,0,   0,0,0, 0,0,0,   0,0,0,
     & 1,2,-7, -1,7,8, 2,3,-6, -2,6,7, 3,4,-5, -3,5,6, 4,1,-8, -4,8,5,
     & 1,2,-3, -1,3,4, 2,7,-6, -2,6,3, 7,8,-5, -7,5,6, 8,1,-4, -8,4,5/
*-
**          S E T   N O D E S   &   N O R M A L E S
*
      NNOD   = 8
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**          F I N D   C O N F I G U R A T I O N
*
      F1     = (F8(1)*F8(6)-F8(2)*F8(5)) / (F8(1)+F8(6)-F8(2)-F8(5))
      F2     = (F8(4)*F8(7)-F8(3)*F8(8)) / (F8(4)+F8(7)-F8(3)-F8(8))
      ICASE  = 1
      IF (F1 .GE. 0.)                   ICASE = ICASE + 1
      IF (F2 .GE. 0.)                   ICASE = ICASE + 2
      IF (ICASE.EQ.1 .OR. ICASE.EQ.4)   GOTO 100
*
**         D I F F E R E N T    T O P   A N D   B O T T O M
*
      NNOD   = 9
      NTRIA  = 8
      CALL IHMCMP(8,XYZ,GRAD,IT(1,1,ICASE),XYZ(1,NNOD),GRAD(1,NNOD))
      GOTO 200
*
**          I S   T H E R E   S U R F A C E   P E N E T R A T I O N ?
*
  100 CALL IHMCX(F8(1),F8(2),F8(6),F8(5),F8(4),F8(3),F8(7),F8(8),IREP)
      NTRIA = 4
      IF (IREP .EQ. 0)                  GOTO 200
**          "B O T T L E   N E C K"
      NTRIA = 8
      IF (ICASE .EQ. 1)                 ICASE = 5
      IF (ICASE .EQ. 4)                 ICASE = 6
*
**          S E T   T R I A N G L E S
*
  200 CALL IHMCTT(NTRIA,IT(1,1,ICASE),ITRIA)
      RETURN
      END
+DECK,  IHMC12, T=FORT.
* Revision 1.2  2002/05/16 15:29:28  couet
* - During the conversion to C++ (for ROOT), two bugs have been found
*   (and fixed) in the fortran code.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMC12(NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC12                                     Date:    10.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consider case No 12                                    *
*                                                                      *
*     Input: see common HCMCUB                                         *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IE(8),IT(3,8,6)
      DATA              IE/3,12,4, 1,9,8,6,2/
      DATA              IT/
     & 1,2,3,  4,5,-6, -4,6,8,  6,7,8,  0,0,0,  0,0,0,  0,0,0,  0,0,0,
     &-9,1,2,  9,2,-3, -9,3,4, 9,4,-5, -9,5,6, 9,6,-7, -9,7,8, 9,8,-1,
     &9,1,-2,  -9,2,6, 9,6,-7, -9,7,8, 9,8,-4, -9,4,5, 9,5,-3, -9,3,1,
     & 3,4,5,  1,2,-6, -1,6,8,  6,7,8,  0,0,0,  0,0,0,  0,0,0,  0,0,0,
     & 7,8,6,  6,8,-1, -6,1,2, 3,1,-8, -3,8,4,  3,4,5, 3,5,-6, -3,6,2,
     & 7,8,6,  6,8,-4, -6,4,5, 3,4,-8, -3,8,1,  3,1,2, 3,2,-6, -3,6,5/
*-
**          S E T   N O D E S   &   N O R M A L E S
*
      NNOD   = 8
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**          F I N D   C O N F I G U R A T I O N
*
      F1     = (F8(1)*F8(3)-F8(2)*F8(4)) / (F8(1)+F8(3)-F8(2)-F8(4))
      F2     = (F8(1)*F8(8)-F8(4)*F8(5)) / (F8(1)+F8(8)-F8(4)-F8(5))
      ICASE  = 1
      IF (F1 .GE. 0.)                   ICASE = ICASE + 1
      IF (F2 .GE. 0.)                   ICASE = ICASE + 2
      IF (ICASE.EQ.1 .OR. ICASE.EQ.4)   GOTO 100
*
**          F I N D   A D D I T I O N A L   P O I N T
*
      NNOD   = 9
      NTRIA  = 8
      CALL IHMCMP(8,XYZ,GRAD,IT(1,1,ICASE),XYZ(1,NNOD),GRAD(1,NNOD))
      GOTO 200
*
**          I S   T H E R E   S U R F A C E   P E N E T R A T I O N ?
*
  100 CALL IHMCX(F8(1),F8(2),F8(3),F8(4),F8(5),F8(6),F8(7),F8(8),IREP)
      NTRIA  = 4
      IF (IREP .NE. 1)                  GOTO 200
**          "B O T T L E   N E C K"
      NTRIA = 8
      IF (ICASE .EQ. 1)                 ICASE = 5
      IF (ICASE .EQ. 4)                 ICASE = 6
*
**          S E T   T R I A N G L E S
*
  200 CALL IHMCTT(NTRIA,IT(1,1,ICASE),ITRIA)
      RETURN
      END
+DECK,  IHMC13, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMC13(NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMC13                                     Date:    13.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Consider case No 13                                    *
*                                                                      *
*     Input: see common HCMCUB                                         *
*                                                                      *
*     Output: the same as for IHMCUB                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*),FF(8)
      INTEGER           ITRIA(3,*)
      INTEGER           IE(12),IFACE(4,6),IROTA(8,12),IWHAT(8)
      INTEGER           IT1(3,4), IT2(3,4), IT3(3,6), IT4(3,6)
      INTEGER           IT5(3,10),IT6(3,10),IT7(3,12)
      INTEGER           IT8(3,6), IT9(3,10),IT10(3,10)
      DATA              IROTA/
     & 1,2,3,4,5,6,7,8, 1,5,6,2,4,8,7,3, 1,4,8,5,2,3,7,6,
     & 3,7,8,4,2,6,5,1, 3,2,6,7,4,1,5,8, 3,4,1,2,7,8,5,6,
     & 6,7,3,2,5,8,4,1, 6,5,8,7,2,1,4,3, 6,2,1,5,7,3,4,8,
     & 8,4,3,7,5,1,2,6, 8,5,1,4,7,6,2,3, 8,7,6,5,4,3,2,1/
      DATA              IWHAT/63,62,54,26,50,9,1,0/
      DATA              IE/1,2,3,4,5,6,7,8,9,10,11,12/
      DATA              IFACE/
     & 1,2,3,4, 5,6,7,8, 1,2,6,5, 2,6,7,3, 4,3,7,8, 1,5,8,4/
      DATA              IT1/1,2,10, 9,5,8, 6,11,7, 3,4,12/
      DATA              IT2/5,6,10, 1,4,9, 2,11,3, 7,8,12/
      DATA              IT3/10,12,-3, -10,3,2, 12,10,-1, -12,1,4,
     &                      9,5,8, 6,11,7/
      DATA              IT4/11,9,-1, -11,1,2, 9,11,-3, -9,3,4,
     &                      5,6,10, 7,8,12/
      DATA              IT5/13,2,-11, -13,11,7, 13,7,-6, -13,6,10,
     & 13,10,1, 13,1,-4, -13,4,12, 13,12,-3, -13,3,2, 5,8,9/
      DATA              IT6/13,2,-10, -13,10,5, 13,5,-6, -13,6,11,
     & 13,11,3, 13,3,-4, -13,4,9, 13,9,-1, -13,1,2, 12,7,8/
      DATA              IT7/13,2,-11, -13,11,7, 13,7,-6,  -13,6,10,
     &                      13,10,-5, -13,5,8,  13,8,-9,  -13,9,1,
     &                      13,1,-4,  -13,4,12, 13,12,-3, -13,3,2/
      DATA              IT8/-3,8,12, 3,-2,-8, -2,5,-8, 2,10,-5,
     &                       7,6,11, 1,4,9/
      DATA              IT9/7,12,-3, -7,3,11, 11,3,2, 6,11,-2, -6,2,10,
     & 6,10,5, 7,6,-5, -7,5,8, 7,8,12, 1,4,9/
      DATA              IT10/9,1,-10, -9,10,5, 9,5,8, 4,9,-8, -4,8,12,
     & 4,12,3, 1,4,-3, -1,3,2, 1,2,10, 7,6,11/
*-
      NNOD   = 0
      NTRIA  = 0
*
**         F I N D   C O N F I G U R A T I O N   T Y P E
*
      DO 130 NR=1,12
        K      = 0
        INCR   = 1
        DO 110 NF=1,6
          F1     = F8(IROTA(IFACE(1,NF),NR))
          F2     = F8(IROTA(IFACE(2,NF),NR))
          F3     = F8(IROTA(IFACE(3,NF),NR))
          F4     = F8(IROTA(IFACE(4,NF),NR))
          IF ((F1*F3-F2*F4)/(F1+F3-F2-F4) .GE. 0.)      K = K + INCR
          INCR   = INCR + INCR
  110   CONTINUE
        DO 120 I=1,8
          IF (K .NE. IWHAT(I))          GOTO 120
          ICASE  = I
          KR     = NR
          GOTO 200
  120   CONTINUE
  130 CONTINUE
      WRITE(*,*) 'IHMC13: configuration is not found'
      GOTO 999
*
**          R O T A T E   C U B E
*
  200 IF (ICASE.EQ.1 .OR. ICASE.EQ.8)   GOTO 300
      DO 220 N=1,8
        K      = IROTA(N,KR)
        FF(N)  = F8(K)
        DO 210 I=1,3
          XYZ(I,N)  = P8(I,K)
          GRAD(I,N) = G8(I,K)
  210   CONTINUE
  220 CONTINUE
      DO 240 N=1,8
        F8(N)  = FF(N)
        DO 230 I=1,3
          P8(I,N) = XYZ(I,N)
          G8(I,N) = GRAD(I,N)
  230   CONTINUE
  240 CONTINUE
*
**          S E T   N O D E S   &   N O R M A L E S
*
 300  NNOD   = 12
      CALL IHMCPP(NNOD,IE,XYZ,GRAD)
*
**          V A R I O U S   C O N F I G U R A T I O N S
*
      GOTO (410,430,450,480,470,460,440,420), ICASE
  410 NTRIA  = 4
      CALL IHMCTT(NTRIA,IT1,ITRIA)
      GOTO 999
  420 NTRIA  = 4
      CALL IHMCTT(NTRIA,IT2,ITRIA)
      GOTO 999
  430 NTRIA  = 6
      CALL IHMCTT(NTRIA,IT3,ITRIA)
      GOTO 999
  440 NTRIA  = 6
      CALL IHMCTT(NTRIA,IT4,ITRIA)
      GOTO 999
  450 NNOD   = 13
      NTRIA  = 10
      CALL IHMCMP(9,XYZ,GRAD,IT5,XYZ(1,NNOD),GRAD(1,NNOD))
      CALL IHMCTT(NTRIA,IT5,ITRIA)
      GOTO 999
  460 NNOD   = 13
      NTRIA  = 10
      CALL IHMCMP(9,XYZ,GRAD,IT6,XYZ(1,NNOD),GRAD(1,NNOD))
      CALL IHMCTT(NTRIA,IT6,ITRIA)
      GOTO 999
  470 NNOD   = 13
      NTRIA  = 12
      CALL IHMCMP(12,XYZ,GRAD,IT7,XYZ(1,NNOD),GRAD(1,NNOD))
      CALL IHMCTT(NTRIA,IT7,ITRIA)
      GOTO 999
**          I S   T H E R E   S U R F A C E   P E N E T R A T I O N ?
  480 CALL IHMCX(F8(3),F8(4),F8(1),F8(2),F8(7),F8(8),F8(5),F8(6),IREP)
      GOTO (481,482,483), IREP+1
  481 NTRIA  = 6
      CALL IHMCTT(NTRIA,IT8,ITRIA)
      GOTO 999
  482 NTRIA  = 10
      CALL IHMCTT(NTRIA,IT9,ITRIA)
      GOTO 999
  483 NTRIA  = 10
      CALL IHMCTT(NTRIA,IT10,ITRIA)
      GOTO 999
*
  999 RETURN
      END
+DECK,  IHMCMP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMCMP(NNOD,XYZ,GRAD,IT,PXYZ,PGRAD)
************************************************************************
*                                                                      *
*     IHMCMP                                     Date:    15.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find meadle point of a polygon                         *
*                                                                      *
*     Input: NNOD      - number of nodes in the polygon                *
*            XYZ(3,*)  - node coordinates                              *
*            GRAD(3,*) - node normalies                                *
*            IT(3,*)   - division of the polygons into triangles       *
*                                                                      *
*     Output: PXYZ(3)  - meadle point coordinates                      *
*             PGRAD(3) - meadle point normale                          *
*                                                                      *
************************************************************************
      REAL              XYZ(3,*),GRAD(3,*),PXYZ(3),PGRAD(3),P(3),G(3)
      INTEGER           IT(3,*)
*-
      DO 100 I=1,3
        P(I)   = 0.
        G(I)   = 0.
  100 CONTINUE
      DO 220 N=1,NNOD
        K      = IT(3,N)
        IF (K .LT. 0)   K =-K
        DO 210 I=1,3
          P(I)  = P(I) + XYZ(I,K)
          G(I)  = G(I) + GRAD(I,K)
  210   CONTINUE
  220 CONTINUE
      DO 300 I=1,3
        PXYZ(I)  = P(I) / NNOD
        PGRAD(I) = G(I) / NNOD
  300 CONTINUE
      RETURN
      END
+DECK,  IHMCPP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHMCPP(NNOD,IE,XYZ,GRAD)
************************************************************************
*                                                                      *
*     IHMCPP                                     Date:    15.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find nodes and normales                                *
*                                                                      *
*     Input: NNOD  - number of nodes                                   *
*            IE(*) - edges which have section node                     *
*                                                                      *
*     Output: XYZ(3,*)  - nodes                                        *
*             GRAD(3,*) - node normales (not normalized)               *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      REAL              XYZ(3,*),GRAD(3,*)
      INTEGER           IE(*),IEDGE(2,12)
      DATA              IEDGE/
     & 1,2, 2,3, 3,4, 4,1, 5,6, 6,7, 7,8, 8,5, 1,5, 2,6, 3,7, 4,8/
*-
      DO 200 N=1,NNOD
        K      = IE(N)
        IF (K .LT. 0)           K =-K
        N1     = IEDGE(1,K)
        N2     = IEDGE(2,K)
        T      = F8(N1) / (F8(N1)-F8(N2))
        DO 100 I=1,3
          XYZ(I,N)  = (P8(I,N2)-P8(I,N1))*T + P8(I,N1)
          GRAD(I,N) = (G8(I,N2)-G8(I,N1))*T + G8(I,N1)
  100   CONTINUE
  200 CONTINUE
      RETURN
      END
+DECK,  IHMCTT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHMCTT(NTRIA,IT,ITRIA)
************************************************************************
*                                                                      *
*     IHMCTT                                     Date:    15.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Set triangles                                          *
*               (if parameter IALL=1, all edges will be visible)       *
*                                                                      *
*     Input: NTRIA   - number of triagles                              *
*            IT(3,*) - triangles                                       *
*                                                                      *
*     Output: ITRIA(3,*) - triangles                                   *
*                                                                      *
************************************************************************
      INTEGER           IT(3,*),ITRIA(3,*)
*-
      DO 200 N=1,NTRIA
        DO 100 I=1,3
          K      = IT(I,N)
*         IF (K .LT. 0)         K =-K
          ITRIA(I,N) = K
  100   CONTINUE
  200 CONTINUE
      RETURN
      END
+DECK,  IHMCUB, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHMCUB(FISO,P,F,G,NNOD,NTRIA,XYZ,GRAD,ITRIA)
************************************************************************
*                                                                      *
*     IHMCUB                                     Date:    09.07.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Topological decider for "Matching Cubes" algorithm     *
*               Find set of triangles aproximating the isosurface      *
*               F(x,y,z)=Fiso inside the cube (improved version)       *
*                                                                      *
*     Input: FISO   - function value for isosurface                    *
*            P(3,8) - cube vertexes                                    *
*            F(8)   - function values at the vertexes                  *
*            G(3,8) - function gradients at the vertexes               *
*                                                                      *
*     Output: NNOD       - number of nodes     (maximum 13)            *
*             NTRIA      - number of triangles (maximum 12)            *
*             XYZ(3,*)   - nodes                                       *
*             GRAD(3,*)  - node normales       (not normalized)        *
*             ITRIA(3,*) - triangles                                   *
*                                                                      *
************************************************************************
+CDE, HCMCUB.
      PARAMETER         (DEL = 0.0001)
      REAL              P(3,*),F(*),G(3,*),XYZ(3,*),GRAD(3,*)
      INTEGER           ITRIA(3,*),IROTA(8,24),IWHAT(21),ITR(3)
      DATA              IROTA/
     & 1,2,3,4,5,6,7,8, 2,3,4,1,6,7,8,5,
     & 3,4,1,2,7,8,5,6, 4,1,2,3,8,5,6,7,
     & 6,5,8,7,2,1,4,3, 5,8,7,6,1,4,3,2,
     & 8,7,6,5,4,3,2,1, 7,6,5,8,3,2,1,4,
     & 2,6,7,3,1,5,8,4, 6,7,3,2,5,8,4,1,
     & 7,3,2,6,8,4,1,5, 3,2,6,7,4,1,5,8,
     & 5,1,4,8,6,2,3,7, 1,4,8,5,2,3,7,6,
     & 4,8,5,1,3,7,6,2, 8,5,1,4,7,6,2,3,
     & 5,6,2,1,8,7,3,4, 6,2,1,5,7,3,4,8,
     & 2,1,5,6,3,4,8,7, 1,5,6,2,4,8,7,3,
     & 4,3,7,8,1,2,6,5, 3,7,8,4,2,6,5,1,
     & 7,8,4,3,6,5,1,2, 8,4,3,7,5,1,2,6/
      DATA              IWHAT/
     & 1,3,5,65,50,67,74,51,177,105,113,58,165,178,
     & 254,252,250,190,205,188,181/
*-
      NNOD   = 0
      NTRIA  = 0
*
**         F I N D   C O N F I G U R A T I O N   T Y P E
*
      DO 100 I=1,8
        F8(I)  = F(I) - FISO
  100 CONTINUE
      DO 130 IR=1,24
        K      = 0
        INCR   = 1
        DO 110 I=1,8
          IF (F8(IROTA(I,IR)) .GE. 0.)  K = K + INCR
          INCR   = INCR + INCR
  110   CONTINUE
        IF (K.EQ.0 .OR. K.EQ.255)       GOTO 999
        DO 120 I=1,21
          IF (K .NE. IWHAT(I))          GOTO 120
          ICASE  = I
          IRT    = IR
          GOTO 200
  120   CONTINUE
  130 CONTINUE
*
**         R O T A T E   C U B E
*
  200 DO 210 I=1,8
        K      = IROTA(I,IRT)
        F8(I)  = F(K) - FISO
        P8(1,I)= P(1,K)
        P8(2,I)= P(2,K)
        P8(3,I)= P(3,K)
        G8(1,I)= G(1,K)
        G8(2,I)= G(2,K)
        G8(3,I)= G(3,K)
  210 CONTINUE
*
**          V A R I O U S   C O N F I G U R A T I O N S
*
      N = 0
      GOTO (301,302,303,304,305,306,307,308,309,310,311,312,313,314,
     &      301,302,303,304,305,306,307),ICASE
*
  301 CALL IHMC00(1, 4, 9, 0, 0, 0, NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 400
  302 CALL IHMC00(2, 4, 9,10, 0, 0, NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 400
  303 CALL IHMC03(NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 400
  304 CALL IHMC04(NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 400
  305 CALL IHMC00(6, 2, 1, 9, 8, 0, NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 400
  306 CALL IHMC06(NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 400
  307 CALL IHMC07(NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 400
  308 CALL IHMC00(2, 4, 8, 6, 0, 0, NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 500
  309 CALL IHMC00(1, 4,12, 7, 6,10, NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 500
  310 CALL IHMC10(NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 500
  311 CALL IHMC00(1, 4, 8, 7,11,10, NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 500
  312 CALL IHMC12(NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 500
  313 CALL IHMC13(NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 500
  314 CALL IHMC00(1, 9,12, 7, 6, 2, NNOD,NTRIA,XYZ,GRAD,ITRIA)
      GOTO 500
*
**          I F   N E E D E D ,   I N V E R T   T R I A N G L E S
*
  400 IF (NTRIA .EQ. 0)         GOTO 999
      IF (ICASE .LE. 14)        GOTO 500
      DO 410 I=1,NTRIA
        I1     = IABS(ITRIA(1,I))
        I2     = IABS(ITRIA(2,I))
        I3     = IABS(ITRIA(3,I))
        IF (ITRIA(3,I) .LT. 0)  I1 =-I1
        IF (ITRIA(2,I) .LT. 0)  I3 =-I3
        IF (ITRIA(1,I) .LT. 0)  I2 =-I2
        ITRIA(1,I) = I1
        ITRIA(2,I) = I3
        ITRIA(3,I) = I2
  410 CONTINUE
*
**          R E M O V E   V E R Y   S M A L L   T R I A N G L E S
*
  500 N      = N + 1
  510 IF (N .GT. NTRIA)         GOTO 999
      DO 520 I=1,3
        I1     = I
        I2     = I + 1
        IF (I .EQ. 3)           I2 = 1
        K1     = IABS(ITRIA(I1,N))
        K2     = IABS(ITRIA(I2,N))
        IF (ABS(XYZ(1,K1)-XYZ(1,K2)) .GT. DEL)  GOTO 520
        IF (ABS(XYZ(2,K1)-XYZ(2,K2)) .GT. DEL)  GOTO 520
        IF (ABS(XYZ(3,K1)-XYZ(3,K2)) .GT. DEL)  GOTO 520
        I3     = I - 1
        IF (I .EQ. 1)           I3 = 3
        GOTO 530
  520 CONTINUE
      GOTO 500
*           R E M O V E   T R I A N G L E
  530  DO 540 I=1,3
       ITR(I)     = ITRIA(I,N)
       ITRIA(I,N) = ITRIA(I,NTRIA)
  540 CONTINUE
      NTRIA = NTRIA - 1
      IF (NTRIA .EQ. 0)                 GOTO 999
      IF (ITR(I2)*ITR(I3) .GT. 0)       GOTO 510
*          C O R R E C T   O T H E R   T R I A N G L E S
      IF (ITR(I2) .LT. 0) THEN
        K1     =-ITR(I2)
        K2     =-IABS(ITR(I3))
      END IF
      IF (ITR(I3) .LT. 0) THEN
        K1     =-ITR(I3)
        K2     =-IABS(ITR(I1))
      END IF
      DO 560 J=1,NTRIA
        DO 550 I=1,3
          IF (ITRIA(I,J) .NE. K2)       GOTO 550
          I2     = IABS(ITRIA(1,J))
          IF (I .NE. 3)                 I2 = IABS(ITRIA(I+1,J))
          IF (I2 .EQ. K1)               ITRIA(I,J) =-ITRIA(I,J)
          GOTO 560
  550   CONTINUE
  560 CONTINUE
      GOTO 510
*
  999 RETURN
      END
+DECK,  IHMCX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:52  mclareni
* Higz

      SUBROUTINE IHMCX(A00,A10,A11,A01,B00,B10,B11,B01,IREP)
************************************************************************
*                                                                      *
*     IHMCX                                      Date:    11.08.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Check for sursafe penetration ("bottle neck")          *
*                                                                      *
*     Input: A00,A10,A11,A01 - vertex values for 1st face              *
*            B00,B10,B11,B01 - vertex values for opposite face         *
*                                                                      *
*     Output: IREP - 1,2 - there is surface penetration                *
*                    0   - there is not surface penetration            *
*                                                                      *
************************************************************************
      IREP   = 0
      A      = (A11-A01)*(B00-B10) - (A00-A10)*(B11-B01)
      IF (A .EQ. 0.)                    GOTO 999
      B      = A01*(B00-B10)-(A11-A01)*B00-(A00-A10)*B01+A00*(B11-B01)
      C      = A00*B01 - A01*B00
      D      = B*B-4*A*C
      IF (D .LE. 0.)                    GOTO 999
      D      = SQRT(D)
      IF (ABS(-B+D) .GT. ABS(2*A))      GOTO 999
      S1     = (-B+D) / (2*A)
      IF (S1.LT.0. .OR. S1.GT.1.)       GOTO 999
      IF (ABS(-B-D) .GT. ABS(2*A))      GOTO 999
      S2     = (-B-D) / (2*A)
      IF (S2.LT.0. .OR. S2.GT.1.)       GOTO 999
*
**          C A S E   N O   4 ?
*
      IPOSA = 0
      IF (A00 .GE. 0)                   IPOSA = IPOSA + 1
      IF (A01 .GE. 0)                   IPOSA = IPOSA + 2
      IF (A10 .GE. 0)                   IPOSA = IPOSA + 4
      IF (A11 .GE. 0)                   IPOSA = IPOSA + 8
      IF (IPOSA.EQ.6 .OR. IPOSA.EQ.9)   GOTO 100
      IREP   = 1
      GOTO 999
*
**          N O T   C A S E   N O   4
*
  100 S0     = (A00-A01) / (A00+A11-A10-A01)
      IF (S1.GE.S0 .AND. S2.LT.S0)      GOTO 999
      IF (S1.LT.S0 .AND. S2.GE.S0)      GOTO 999
      IREP   = 1
      IF (S1 .GE. S0)                   IREP = 2
*
**          C A S E S   N O   10, 13 ?
*
      IPOSB = 0
      IF (B00 .GE. 0)                   IPOSB = IPOSB + 1
      IF (B01 .GE. 0)                   IPOSB = IPOSB + 2
      IF (B10 .GE. 0)                   IPOSB = IPOSB + 4
      IF (B11 .GE. 0)                   IPOSB = IPOSB + 8
      IF (IPOSB.NE.6 .AND. IPOSB.NE.9)  GOTO 999
      S0     = (B00-B01) / (B00+B11-B10-B01)
      IF (IPOSA .NE. IPOSB)             GOTO 200
**          C A S E   N O   10
      IF (IREP.EQ.1 .AND. S1.GT.S0)     GOTO 999
      IF (IREP.EQ.2 .AND. S1.LT.S0)     GOTO 999
      IREP   = 0
      GOTO 999
**          C A S E   N O   13
  200 IF (IREP.EQ.1 .AND. S1.LT.S0)     GOTO 999
      IF (IREP.EQ.2 .AND. S1.GT.S0)     GOTO 999
      IREP   = 0
      GOTO 999
*
  999 RETURN
      END
+DECK,  IHPFF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHPFF(N,P,F)
************************************************************************
*                                                                      *
*     IHPFF                                      Date:    09.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Fill polygon with fuction values at vertexes           *
*                                                                      *
*     References: IHERAN                                               *
*                                                                      *
*     Input: N      - number of vertexes                               *
*            P(3,*) - polygon                                          *
*            F(*)   - function values at nodes                         *
*                                                                      *
*     Errors: - illegal number of vertexes in polygon                  *
*             - illegal call of IHPFF: no levels                       *
*                                                                      *
************************************************************************
+CDE, HCLEVL.
      REAL              P(3,*),F(*),X(12),Y(12),P3(3,12)
*-
      IF (N .LT. 3)             GOTO 997
      IF (NLEV .EQ. 0)          GOTO 998
      NP     = N
      NL     = NLEV
      IF (NL .LT. 0)            NL =-NL
      FMIN   = F(1)
      FMAX   = F(1)
      DO 100 I=2,NP
        IF (FMIN .GT. F(I))     FMIN = F(I)
        IF (FMAX .LT. F(I))     FMAX = F(I)
  100 CONTINUE
      FUNMIN = FUNLEV(1) - 1.
      IF (FMIN .LT. FUNMIN)     FUNMIN = FMIN - 1.
      FUNMAX = FUNLEV(NL) + 1.
      IF (FMAX .GT. FUNMAX)     FUNMAX = FMAX + 1.
*
**          F I N D   A N D   D R A W   S U B P O L Y G O N S
*
      F2     = FUNMIN
      DO 300 ILEV=1,NL+1
*           S E T   L E V E L   L I M I T S
        F1     = F2
        IF (ILEV .EQ. NL+1) THEN
          F2     = FUNMAX
        ELSE
          F2     = FUNLEV(ILEV)
        END IF
        IF (FMAX .LT. F1)       GOTO 999
        IF (FMIN .GT. F2)       GOTO 300
*           F I N D   S U B P O L Y G O N
        K      = 0
        DO 210 I=1,NP
          I1 = I
          I2 = I + 1
          IF (I .EQ. NP)          I2 = 1
          CALL IHERAN(P(1,I1),P(1,I2),F(I1),F(I2),F1,F2,K,P3)
  210   CONTINUE
*           D R A W   S U B P O L Y G O N
        IF (K .LT. 3)           GOTO 300
        DO 220 I=1,K
          X(I) = P3(1,I)
          Y(I) = P3(2,I)
  220   CONTINUE
        ICOL   = ICLEV(ILEV)
        CALL ISFACI(ICOL)
        CALL ISFAIS(1)
        CALL IFA(K,X,Y)
  300 CONTINUE
      GOTO 999
*
  997 WRITE (*,*) 'IHPFF: illegal number of vertexes in polygon'
      GOTO 999
  998 WRITE (*,*) 'IHPFF: illegal call of IHPFF: no levels'
      GOTO 999
  999 RETURN
      END
+DECK,  IHPROP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHPROP(QQA,QQD,QQS,NNQS,IREP)
************************************************************************
*                                                                      *
*     IHPROP                                     Date:    11.10.91     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Set surface property coefficients                      *
*                                                                      *
*     Input: QQA  - diffusion coefficient for diffused light  [0.,1.]  *
*            QQD  - diffusion coefficient for direct light    [0.,1.]  *
*            QQS  - diffusion coefficient for reflected light [0.,1.]  *
*            NNCS - power coefficient for reflected light     (.GE.1)  *
*                                                                      *
*                                          --                          *
*     Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi)   *
*                                          --                          *
*                                                                      *
*     Output: IREP   - reply : 0 - O.K.                                *
*                             -1 - error in cooefficients              *
*                                                                      *
************************************************************************
+CDE, HCLIGH.
*-
      IREP   = 0
      IF (QQA.LT.0. .OR. QQA.GT.1.)             GOTO 998
      IF (QQA.LT.0. .OR. QQA.GT.1.)             GOTO 998
      IF (QQA.LT.0. .OR. QQA.GT.1.)             GOTO 998
      IF (NNQS .LT. 1)                          GOTO 998
      QA     = QQA
      QD     = QQD
      QS     = QQS
      NQS    = NNQS
      GOTO 999
*
  998 WRITE(*,*) 'IHPROP: error in coefficients'
      IREP   =-1
  999 RETURN
      END
+DECK,  IHPVIE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHPVIE(RMIN,RMAX,P,PSI,IREP)
************************************************************************
*                                                                      *
*     IHPVIE                                     Date:    13.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Set view direction using eye point                     *
*                                                                      *
*     References: IHWV01, IHWV02                                       *
*                                                                      *
*     Input: RMIN(3) - MIN -                                           *
*            RMAX(3) -       MAX scope                                 *
*                                                                      *
*            P(3)    - eye point                                       *
*            PSI     - rotation in screen plane                        *
*                                                                      *
*     Output: IREP   - reply :-1 - error in min-max                    *
*                             -2 - error in eye point                  *
*                                                                      *
*     Errors: error in min-max scope                                   *
*                                                                      *
************************************************************************
+CDE, HCTNOR.
+CDE, HCSCRN.
      REAL              RMIN(3),RMAX(3),P(3),CENTRE(3),SCALE(3)
      DOUBLE PRECISION  DRAD,C1,S1,C2,S2,C3,S3
      DOUBLE PRECISION  DDXX,DDYY,DDZZ,S,SS
*-
      DRAD    = DATAN(1.D0)*4./180.
*
**          F I N D   C E N T E R   O F   S C O P E   A N D
**          S C A L E   F A C T O R S
*
      CALL IHWV01(RMIN,RMAX,SCALE,CENTRE,IREP)
      IF (IREP .LT. 0)                  GOTO 997
*
**          S E T   T R A N S F O R M A T I O N   M A T R I X E S
*
      DDXX   = P(1) - CENTRE(1)
      DDYY   = P(2) - CENTRE(2)
      DDZZ   = P(3) - CENTRE(3)
      S      = DSQRT(DDXX*DDXX + DDYY*DDYY)
      SS     = DSQRT(DDXX*DDXX + DDYY*DDYY+ DDZZ*DDZZ)
      IF (SS .EQ. 0.)                   GOTO 998
      C1     = 1.
      S1     = 0.
      C2     = 1.
      S2     = 0.
      IF (S .EQ. 0.)                    GOTO 200
      C1     = DDXX / S
      S1     = DDYY / S
      C2     = DDZZ / SS
      S2     = S / SS
  200 C3     = DCOS(PSI*DRAD)
      S3     = DSIN(PSI*DRAD)
      CALL IHWV02(SCALE,CENTRE,C1,S1,C2,S2,C3,S3,TNORM,TBACK)
      C3     = 1.
      S3     = 0.
      CALL IHWV02(SCALE,CENTRE,C1,S1,C2,S2,C3,S3,TN,TB)
      RETURN
*
  997 WRITE(*,*) 'IHPVIE: error in min-max scope'
      IREP   =-1
      RETURN
  998 WRITE(*,*) 'IHPVIE: error in eye point'
      IREP   =-2
      END
+DECK,  IHRCLE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHRCLE()
************************************************************************
*                                                                      *
*     IHRCLE                                     Date:    16.05.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Clear screen ("RASTER SCREEN")                         *
*                                                                      *
************************************************************************
+CDE, HCRAST.
*-
      NW     = (NXRAST*NYRAST + NBW - 1) / NBW
      DO 200 I=1,NW
        IRAST(JRAST+I) = 0
  200 CONTINUE
      IFRAST = 1
      RETURN
      END
+DECK,  IHRFIL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHRFIL(NN,XY)
************************************************************************
*                                                                      *
*     IHRFIL                                     Date:    14.05.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Fill a polygon including border ("RASTER SCREEN")      *
*                                                                      *
*     Input: NN      - number of polygon nodes                         *
*            XY(2,*) - polygon nodes                                   *
*                                                                      *
************************************************************************
+CDE, HCRAST.
      PARAMETER         (LMAX=12)
      REAL              XY(2,*)
      INTEGER           YMIN,YMAX,X,Y,XX,YY,DX,DY,SIGNDX,T,STEP,YSCAN
      INTEGER           XX1,XX2
      INTEGER           X1(LMAX+2),Y1(LMAX+2),X2(LMAX),Y2(LMAX)
      INTEGER           XCUR(LMAX),XNEX(LMAX),TEST(LMAX),XSCAN(2,LMAX)
*-
**          T R A N S F E R   T O   S C R E E N   C O O R D I N A T E S
*
      IF (IFRAST .NE. 1)                GOTO 999
      N      = NN
      DO 100 I=1,N
        X1(I)  = NXRAST * ((XY(1,I)-XRAST)/DXRAST) - 0.01
        Y1(I)  = NYRAST * ((XY(2,I)-YRAST)/DYRAST) - 0.01
  100   CONTINUE
      X1(N+1) = X1(1)
      Y1(N+1) = Y1(1)
*
**          F I N D   Y - M I N   A N D   Y - M A X
**          S E T   R I G H T   E D G E   O R I E N T A T I O N
*
      YMIN   = Y1(1)
      YMAX   = Y1(1)
      DO 200 I=1,N
        IF (YMIN  .GT. Y1(I))           YMIN  = Y1(I)
        IF (YMAX  .LT. Y1(I))           YMAX  = Y1(I)
        IF (Y1(I) .LE. Y1(I+1)) THEN
          X2(I)  = X1(I+1)
          Y2(I)  = Y1(I+1)
        ELSE
          X2(I)  = X1(I)
          Y2(I)  = Y1(I)
          X1(I)  = X1(I+1)
          Y1(I)  = Y1(I+1)
        END IF
  200   CONTINUE
      IF (YMIN .GE. NYRAST)             GOTO 999
      IF (YMAX .LT. 0)                  GOTO 999
      IF (YMAX .GE. NYRAST)             YMAX = NYRAST - 1
*
**          S O R T   L I N E S
*
      DO 250 I=1,N-1
        IF (Y1(I+1) .GE. Y1(I))         GOTO 250
        Y      = Y1(I+1)
        K      = 1
        DO 210 J=I-1,1,-1
          IF (Y .LT. Y1(J))             GOTO 210
          K      = J + 1
          GOTO 220
  210     CONTINUE
  220   X      = X1(I+1)
        XX     = X2(I+1)
        YY     = Y2(I+1)
        DO 230 J=I,K,-1
          X1(J+1) = X1(J)
          Y1(J+1) = Y1(J)
          X2(J+1) = X2(J)
          Y2(J+1) = Y2(J)
  230     CONTINUE
        X1(K) = X
        Y1(K) = Y
        X2(K) = XX
        Y2(K) = YY
  250   CONTINUE
*
**          S E T   I N I T I A L   V A L U E S
*
      DO 300 I=1,N
        XCUR(I) = X1(I)
        DY      = Y2(I) - Y1(I)
        DX      = X2(I) - X1(I)
        SIGNDX  = 1
        IF (DX .LT. 0)                  SIGNDX =-1
        IF (DX .LT. 0)                  DX =-DX
        IF (DX .LE. DY) THEN
          T       =-(DY+1)/2 + DX
          IF (T .LT. 0) THEN
            TEST(I) = T
            XNEX(I) = XCUR(I)
          ELSE
            TEST(I) = T - DY
            XNEX(I) = XCUR(I) + SIGNDX
          END IF
        ELSE IF (DY .NE. 0) THEN
          STEP    = (DX-1)/(DY+DY) + 1
          TEST(I) = STEP*DY - (DX+1)/2 - DX
          XNEX(I) = XCUR(I) + SIGNDX*STEP
        END IF
  300   CONTINUE
*
**          L O O P   O N   S C A N   L I N E S
*
      NSTART   = 1
      DO 700 YSCAN=YMIN,YMAX
        NX     = 0
        NXA    = 0
        NXB    = LMAX + 1
        DO 440 I=NSTART,N
          IF (Y1(I) .GT. YSCAN)         GOTO 500
          IF (Y2(I) .GT. YSCAN)         GOTO 410
          IF (I .EQ. NSTART)            NSTART = NSTART + 1
          IF (Y2(I) .NE. YSCAN)         GOTO 440
          NXB     = NXB - 1
          IF (X2(I) .GE. XCUR(I)) THEN
           XSCAN(1,NXB) = XCUR(I)
           XSCAN(2,NXB) = X2(I)
          ELSE
           XSCAN(1,NXB) = X2(I)
           XSCAN(2,NXB) = XCUR(I)
          END IF
          GOTO 440
*
**          S T O R E   C U R R E N T  X
**          P R E P A R E   X   F O R   N E X T   S C A N - L I N E
*
  410     NXA    = NXA + 1
          DY     = Y2(I) - Y1(I)
          DX     = X2(I) - X1(I)
          IF (DX .GE. 0) THEN
            SIGNDX = 1
            XSCAN(1,NXA) = XCUR(I)
            XSCAN(2,NXA) = XNEX(I)
            IF(XSCAN(1,NXA).NE.XSCAN(2,NXA)) XSCAN(2,NXA)=XSCAN(2,NXA)-1
          ELSE
            DX     =-DX
            SIGNDX =-1
            XSCAN(1,NXA) = XNEX(I)
            XSCAN(2,NXA) = XCUR(I)
            IF(XSCAN(1,NXA).NE.XSCAN(2,NXA)) XSCAN(1,NXA)=XSCAN(1,NXA)+1
          END IF
          XCUR(I) = XNEX(I)
          IF (DX .GT. DY)               GOTO 430
          TEST(I) = TEST(I) + DX
          IF (TEST(I) .LT. 0)           GOTO 440
          TEST(I) = TEST(I) - DY
          XNEX(I) = XNEX(I) + SIGNDX
          GOTO 440
  430     STEP   = DX/DY
          T      = TEST(I) + STEP*DY
          IF (T .GE. 0) THEN
            TEST(I) = T - DX
            XNEX(I) = XNEX(I) + SIGNDX*STEP
          ELSE
            TEST(I) = T + DY - DX
            XNEX(I) = XNEX(I) + SIGNDX*(STEP+1)
          END IF
  440     CONTINUE
*
**          S O R T   P O I N T S   A L O N G   X
*
  500   IF (YSCAN .LT. 0)                       GOTO 700
        IBASE  = YSCAN*NXRAST
        IF (NXA .LT. 2)                         GOTO 540
        DO 520 I=1,NXA-1
          DO 510 J=I,1,-1
            IF (XSCAN(1,J+1) .GE. XSCAN(1,J))   GOTO 520
            X            = XSCAN(1,J+1)
            XSCAN(1,J+1) = XSCAN(1,J)
            XSCAN(1,J)   = X
            X            = XSCAN(2,J+1)
            XSCAN(2,J+1) = XSCAN(2,J)
            XSCAN(2,J)   = X
  510       CONTINUE
  520     CONTINUE
        DO 530 I=1,NXA,2
          NX     = NX  + 1
          XSCAN(1,NX) = XSCAN(1,I)
          X           = XSCAN(2,I+1)
          IF (XSCAN(2,I) .GT. X)                X = XSCAN(2,I)
          XSCAN(2,NX) = X
  530     CONTINUE
*
  540   IF (NXB .GT. LMAX)                      GOTO 600
        DO 550 I=NXB,LMAX,1
          NX     = NX  + 1
          XSCAN(1,NX) = XSCAN(1,I)
          XSCAN(2,NX) = XSCAN(2,I)
  550     CONTINUE
*
**          C O N C A N T I N A T E   A N D   F I L L
*
  600   IF (NX .EQ. 0)                          GOTO 700
        XX1    = XSCAN(1,NX)
        XX2    = XSCAN(2,NX)
        NX     = NX - 1
        K      = 1
  610   IF (K .GT. NX)                          GOTO 630
        IF (XSCAN(1,K) .GT. XX2+1)              GOTO 620
        IF (XSCAN(2,K) .LT. XX1-1)              GOTO 620
        IF (XSCAN(1,K) .LT. XX1)                XX1 = XSCAN(1,K)
        IF (XSCAN(2,K) .GT. XX2)                XX2 = XSCAN(2,K)
        XSCAN(1,K) = XSCAN(1,NX)
        XSCAN(2,K) = XSCAN(2,NX)
        NX     = NX - 1
        GOTO 610
  620   K      = K + 1
        GOTO 610
  630   IF (XX1 .LT. 0)                         XX1 = 0
        IF (XX2 .GE. NXRAST)                    XX2 = NXRAST - 1
        NBIT   = XX2 - XX1 + 1
        KBIT   = IBASE + XX1
        IW     = KBIT / NBW
        IB     = KBIT - IW*NBW + 1
        IW     = IW + JRAST + 1
        NB     = NBW - IB + 1
        IF (NB .GT. NBIT)                       NB = NBIT
        IRAST(IW) = IOR(IRAST(IW),MASK(JMASK(NB)+IB))
        NBIT   = NBIT - NB
        IF (NBIT .EQ. 0)                        GOTO 600
        DO 640 WHILE (NBIT .GT. NBW)
          IW        = IW + 1
          IRAST(IW) = MASK(LMASK)
          NBIT      = NBIT - NBW
  640   CONTINUE
        IW        = IW + 1
        IRAST(IW) = IOR(IRAST(IW),MASK(JMASK(NBIT)+1))
        GOTO 600
  700   CONTINUE
*
  999 RETURN
      END
+DECK,  IHRINI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHRINI(XMIN,YMIN,XMAX,YMAX,NX,NY,IBUF)
************************************************************************
*                                                                      *
*     IHRINI                                     Date:    14.05.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Initialise hidden lines removal algorithm              *
*               "RASTER SCREEN"                                        *
*                                                                      *
*     References: IHRCLE                                               *
*                                                                      *
*     Input: XMIN - Xmin in the normalized coordinate system           *
*            YMIN - Ymin in the normalized coordinate system           *
*            XMAX - Xmax in the normalized coordinate system           *
*            YMAX - Ymax in the normalized coordinate system           *
*            NX   - number of pixels along X                           *
*            NY   - number of pixels along Y                           *
*            IBUF(NX*NY/4) - buffer for raster                         *
*                                                                      *
************************************************************************
+CDE, HCRAST.
      INTEGER           IBUF(*)
*-
      NXRAST = NX
      NYRAST = NY
      XRAST  = XMIN
      DXRAST = XMAX - XMIN
      YRAST  = YMIN
      DYRAST = YMAX - YMIN
      JRAST  = LOCF(IBUF(1)) - LOCF(IRAST(1))
*
**          S E T   M A S K S
*
      K      = 0
      DO 100 I=1,NBW
        JMASK(I) = K
        K        = K + NBW - I + 1
        MASK(I)  = 2**(I-1)
  100 CONTINUE
      J      = NBW
      DO 130 NB=2,NBW
        DO 120 IB=1,NBW-NB+1
          K      = 0
          DO 110 I=IB,IB+NB-1
            K      = IOR(K,MASK(I))
  110     CONTINUE
          J       = J + 1
          MASK(J) = K
  120   CONTINUE
  130 CONTINUE
*
**          C L E A R   R A S T E R   S C R E E N
*
      CALL IHRCLE()
      RETURN
      END
+DECK,  IHRLIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHRLIN(P1,P2,NTMAX,NT,T)
************************************************************************
*                                                                      *
*     IHRLIN                                     Date:    14.05.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find visible part of a line ("RASTER SCREEN")          *
*                                                                      *
*     Input: P1(2) - 1st point of the line                             *
*            P2(2) - 2nd point of the line                             *
*            NTMAX - max allowed number of visible segments            *
*                                                                      *
*     Output: NT     - number of visible segments of the line          *
*             T(2,*) - visible segments                                *
*                                                                      *
************************************************************************
+CDE, HCRAST.
      REAL      P1(2),P2(2),T(2,*)
      INTEGER   X1,Y1,X2,Y2,DX,DY,DX2,DY2
*-
      IF (IFRAST .NE. 1) THEN
        NT     = 1
        T(1,1) = 0.
        T(2,1) = 1.
        GOTO 999
      END IF
      X1     = NXRAST * ((P1(1)-XRAST)/DXRAST) - 0.01
      Y1     = NYRAST * ((P1(2)-YRAST)/DYRAST) - 0.01
      X2     = NXRAST * ((P2(1)-XRAST)/DXRAST) - 0.01
      Y2     = NYRAST * ((P2(2)-YRAST)/DYRAST) - 0.01
      IFINVE = 0
      IF (Y1 .GT. Y2) THEN
        IFINVE = 1
        IW     = X1
        X1     = X2
        X2     = IW
        IW     = Y1
        Y1     = Y2
        Y2     = IW
      END IF
      NT     = 0
      IVIS   = 0
      IF (Y1 .GE. NYRAST)                       GOTO 999
      IF (Y2 .LT. 0)                            GOTO 999
      IF (X1.GE.NXRAST .AND. X2.GE.NXRAST)      GOTO 999
      IF (X1.LT.0 .AND. X2.LT.0)                GOTO 999
*
**          S E T   I N I T I A L   V A L U E S
*
      INCRX  =+1
      DX     = X2 - X1
      IF (DX .LT. 0) THEN
        DX     =-DX
        INCRX  =-1
      END IF
      DY     = Y2 - Y1
      DX2    = DX + DX
      DY2    = DY + DY
      IF (DY .GT. DX)                   GOTO 200
*
**          D X   . G T .   D Y
*
      DT     = 1. / (DX+1)
      DDTT   = 0.5*DT
      TCUR   =-DT
      TT     =-(DX + DY2)
      IY     = Y1
      KB     = IY*NXRAST + X1 - INCRX
      DO 120 IX=X1,X2,INCRX
        KB     = KB + INCRX
        TCUR   = TCUR + DT
        TT     = TT + DY2
        IF (TT .GE. 0) THEN
          IY     = IY + 1
          TT     = TT - DX2
          KB     = KB + NXRAST
        END IF
        IF (IY .LT. 0)                  GOTO 110
        IF (IY .GE. NYRAST)             GOTO 110
        IF (IX .LT. 0)                  GOTO 110
        IF (IX .GE. NXRAST)             GOTO 110
        IW     = KB / NBW
        IB     = KB - IW*NBW + 1
        IF(IAND(IRAST(JRAST+IW+1),MASK(IB)) .NE. 0)     GOTO 110
        IF (IVIS .GT. 0)                GOTO 120
        IVIS   = 1
        NT     = NT + 1
*       T(1,NT)= TCUR - DDTT
        T(1,NT)= TCUR
        GOTO 120
  110   IF (IVIS .EQ. 0)                GOTO 120
        IVIS   = 0
*       T(2,NT)= TCUR + DDTT
        T(2,NT)= TCUR
        IF (NT .EQ. NTMAX)              GOTO 300
  120 CONTINUE
      IF (IVIS .GT. 0)                  T(2,NT)= TCUR + DT + DDTT
      GOTO 300
*
**          D Y   . G T .   D X
*
  200 DT     = 1. / (DY+1)
      DDTT   = 0.5*DT
      TCUR   =-DT
      TT     =-(DY + DX2)
      IX     = X1
      IF (Y2 .GE. NYRAST)               Y2 = NYRAST - 1
      KB     = (Y1-1)*NXRAST + IX
      DO 220 IY=Y1,Y2
        KB     = KB + NXRAST
        TCUR   = TCUR + DT
        TT     = TT + DX2
        IF (TT .GE. 0) THEN
          IX     = IX + INCRX
          TT     = TT - DY2
          KB     = KB + INCRX
        END IF
        IF (IY .LT. 0)                  GOTO 210
        IF (IX .LT. 0)                  GOTO 210
        IF (IX .GE. NXRAST)             GOTO 210
        IW     = KB / NBW
        IB     = KB - IW*NBW + 1
        IF (IAND(IRAST(JRAST+IW+1),MASK(IB)) .NE. 0)     GOTO 210
        IF (IVIS .GT. 0)                GOTO 220
        IVIS   = 1
        NT     = NT + 1
*       T(1,NT)= TCUR - DDTT
        T(1,NT)= TCUR
        GOTO 220
  210   IF (IVIS .EQ. 0)                GOTO 220
        IVIS   = 0
*       T(2,NT)= TCUR + DDTT
        T(2,NT)= TCUR
        IF (NT .EQ. NTMAX)              GOTO 300
  220 CONTINUE
      IF (IVIS .GT. 0)                  T(2,NT)= TCUR + DT
      GOTO 300
*
**          C H E C K   D I R E C T I O N   O F   P A R A M E T E R
*
  300 IF (NT .EQ. 0)                    GOTO 999
      DT     = DT*1.1
      IF (T(1,1) .LE. DT)               T(1,1)  = 0.
      IF (T(2,NT) .GE. 1.-DT)           T(2,NT) = 1.
      IF (IFINVE .EQ. 0)                GOTO 999
      DO 310 I=1,NT
        T1     = T(1,I)
        T2     = T(2,I)
        T(1,I) = 1. - T2
        T(2,I) = 1. - T1
  310 CONTINUE
      GOTO 999
*
  999 RETURN
      END
+DECK,  IHROFF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHROFF()
************************************************************************
*                                                                      *
*     IHROFF                                     Date:    16.05.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Switch OFF "RASTER SCREEN" algorithm                   *
*                                                                      *
************************************************************************
+CDE, HCRAST.
*-
      IFRAST = 0
      END
+DECK,  IHSDRL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHSDRL(R1,R2)
************************************************************************
*                                                                      *
*     IHSDRL                                     Date:    06.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 13.09.90     *
*                                                         10.01.92     *
*                                                         06.11.92     *
*     Function: Find visible parts of line (draw line)                 *
*                                                                      *
*     Input: R1(3)  - 1-st point of the line                           *
*            R2(3)  - 2-nd point of the line                           *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
      REAL              R1(3),R2(3)
*-
      X1     = TN(1,1)*R1(1)+TN(2,1)*R1(2)+TN(3,1)*R1(3)+TN(4,1)
      X2     = TN(1,1)*R2(1)+TN(2,1)*R2(2)+TN(3,1)*R2(3)+TN(4,1)
      Y1     = TN(1,2)*R1(1)+TN(2,2)*R1(2)+TN(3,2)*R1(3)+TN(4,2)
      Y2     = TN(1,2)*R2(1)+TN(2,2)*R2(2)+TN(3,2)*R2(3)+TN(4,2)
      Z1     = TN(1,3)*R1(1)+TN(2,3)*R1(2)+TN(3,3)*R1(3)+TN(4,3)
      Z2     = TN(1,3)*R2(1)+TN(2,3)*R2(2)+TN(3,3)*R2(3)+TN(4,3)
      IFBACK = 0
      IF (X1 .LT. X2)                   GOTO 10
      IFBACK = 1
      WW     = X1
      X1     = X2
      X2     = WW
      WW     = Y1
      Y1     = Y2
      Y2     = WW
      WW     = Z1
      Z1     = Z2
      Z2     = WW
   10 NT     = 0
      I1     = (X1-X0)/DX + 1.5
      I2     = (X2-X0)/DX + 1.5
      X1     = X0 + (I1-1)*DX
      X2     = X0 + (I2-1)*DX
      IF (I1 .EQ. I2)                   GOTO 140
*
**          F I N D   V I S I B L E   P A R T S   O F   T H E   L I N E
*
      DI     = I2 - I1
      DY     = (Y2-Y1) / DI
      DT     = 1. / DI
      IV     =-1
      DO 120 I=I1,I2-1
         YY1  = Y1 + DY*(I-I1)
         YY2  = YY1 + DY
         YY1U = YY1 - U(1,I)
         YY1D = YY1 - D(1,I)
         YY2U = YY2 - U(2,I)
         YY2D = YY2 - D(2,I)
         TT   = DT*(I-I1)
*           A N A L I S E   L E F T   S I D E
         ICASE1 = 1
         IF (YY1U .GT. 0.) ICASE1 = 0
         IF (YY1D .LT. 0.) ICASE1 = 2
         GOTO (20 ,30 ,20 ), ICASE1+1
   20    IF (IV .GT. 0) GOTO 40
         IV      = +1
         NT      = NT + 1
         T(1,NT) = TT
         GOTO 40
   30    IF (IV .LT. 0) GOTO 40
         IV      = -1
         T(2,NT) = TT
         GOTO 40
*           A N A L I S E   R I G H T   S I D E
   40    ICASE2  = 1
         IF (YY2U .GT. 0.) ICASE2 = 0
         IF (YY2D .LT. 0.) ICASE2 = 2
         ICASE = ICASE1*3 + ICASE2
         GOTO (110,50 ,60 , 70 ,110,80 , 90 ,100,110), ICASE+1
   50    IV      = -1
         T(2,NT) = TT + DT*(YY1U/(YY1U-YY2U))
         GOTO 110
   60    T(2,NT) = TT + DT*(YY1U/(YY1U-YY2U))
         NT      = NT + 1
         T(1,NT) = TT + DT*(YY1D/(YY1D-YY2D))
         GOTO 110
   70    IV      = +1
         NT      = NT + 1
         T(1,NT) = TT + DT*(YY1U/(YY1U-YY2U))
         GOTO 110
   80    IV      = +1
         NT      = NT + 1
         T(1,NT) = TT + DT*(YY1D/(YY1D-YY2D))
         GOTO 110
   90    T(2,NT) = TT + DT*(YY1D/(YY1D-YY2D))
         NT      = NT + 1
         T(1,NT) = TT + DT*(YY1U/(YY1U-YY2U))
         GOTO 110
  100    IV      = -1
         T(2,NT) = TT + DT*(YY1D/(YY1D-YY2D))
         GOTO 110
  110    IF (NT+1 .GE. NTMAX) GOTO 130
  120 CONTINUE
  130 IF (IV .GT. 0)                    T(2,NT) = 1.
      GOTO 180
*
**          V E R T I C A L   L I N E
*
  140 NT     = 1
      T(1,1) = 0.
      T(2,1) = 1.
      IF (Y2 .GT. Y1)                   GOTO 150
      IF (Y2 .EQ. Y1)                   GOTO 200
      IFBACK = 1 - IFBACK
      YY     = Y1
      Y1     = Y2
      Y2     = YY
  150 UU     = U(1,I1)
      DD     = D(1,I1)
      IF (I1 .EQ. 1)                    GOTO 160
      IF (UU .LT. U(2,I1-1))            UU = U(2,I1-1)
      IF (DD .GT. D(2,I1-1))            DD = D(2,I1-1)
*           F I N D   V I S I B L E   P A R T   O F   L I N E
  160 IF (Y1.GE.UU .OR. Y2.LE.DD)       GOTO 180
      IF (Y1.GE.DD .AND. Y2.LE.UU)      GOTO 200
      NT     = 0
      IF (DD .LE. Y1)                   GOTO 170
      NT     = NT + 1
      T(1,NT)= 0.
      T(2,NT)= (DD-Y1) / (Y2-Y1)
  170 IF (UU .GE. Y2)                   GOTO 180
      NT     = NT + 1
      T(1,NT)= (UU-Y1) / (Y2-Y1)
      T(2,NT)= 1.
*
  180 IF (IFBACK .EQ. 0)                RETURN
      IF (NT .EQ. 0)                    RETURN
      DO 190 I=1,NT
         T(1,I) = 1. - T(1,I)
         T(2,I) = 1. - T(2,I)
  190 CONTINUE
      RETURN
*
  200 NT     = 0
      END
+DECK,  IHSINI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHSINI(XMIN,XMAX)
************************************************************************
*                                                                      *
*     IHSINI                                     Date:    07.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Initialise "MOVING SCREEN" method                      *
*                                                                      *
*     Input: XMIN - left boundary                                      *
*            XMAX - right boundary                                     *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
*-
      X0     = XMIN
      DX     = (XMAX-XMIN) / NSLIC
      DO 100 I=1,NSLIC
        U(1,I) =-999.
        U(2,I) =-999.
        D(1,I) =+999.
        D(2,I) =+999.
  100   CONTINUE
      RETURN
      END
+DECK,  IHSMDF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:53  mclareni
* Higz

      SUBROUTINE IHSMDF(R1,R2)
************************************************************************
*                                                                      *
*     IHSMDF                                     Date:    07.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Modify SCREEN                                          *
*                                                                      *
*     Input: R1(3) - 1-st point of the line                            *
*            R2(3) - 2-nd point of the line                            *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
      REAL              R1(3),R2(3)
*-
      X1     = TN(1,1)*R1(1)+TN(2,1)*R1(2)+TN(3,1)*R1(3)+TN(4,1)
      X2     = TN(1,1)*R2(1)+TN(2,1)*R2(2)+TN(3,1)*R2(3)+TN(4,1)
      Y1     = TN(1,2)*R1(1)+TN(2,2)*R1(2)+TN(3,2)*R1(3)+TN(4,2)
      Y2     = TN(1,2)*R2(1)+TN(2,2)*R2(2)+TN(3,2)*R2(3)+TN(4,2)
      IF (X1 .LT. X2)                   GOTO 100
      WW     = X1
      X1     = X2
      X2     = WW
      WW     = Y1
      Y1     = Y2
      Y2     = WW
  100 I1     = (X1-X0)/DX + 1.5
      I2     = (X2-X0)/DX + 1.5
      IF (I1 .EQ. I2)                   GOTO 999
*
**          M O D I F Y   B O U N D A R I E S   OF THE SCREEN
*
      DY     = (Y2-Y1) / (I2-I1)
      DO 200 I=I1,I2-1
        YY1    = Y1 + DY*(I-I1)
        YY2    = YY1 + DY
        IF (D(1,I) .GT. YY1)            D(1,I) = YY1
        IF (D(2,I) .GT. YY2)            D(2,I) = YY2
        IF (U(1,I) .LT. YY1)            U(1,I) = YY1
        IF (U(2,I) .LT. YY2)            U(2,I) = YY2
  200   CONTINUE
*
  999 RETURN
      END
+DECK,  IHSURC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHSURC(ANG,NX,NY,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHSURC                                     Date:    10.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Draw surface in cartesian coordinate system            *
*                                                                      *
*     Input: ANG      - angle between X ang Y                          *
*            NX       - number of steps along X                        *
*            NY       - number of steps along Y                        *
*                                                                      *
*            FUN(IX,IY,F,T) - external routine                         *
*              IX     - X number of the cell                           *
*              IY     - Y number of the cell                           *
*              F(3,4) - face which corresponds to the cell             *
*              T(4)   - additional function (for example: temperature) *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - IX                                        *
*                ICODES(2) - IY                                        *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
*            CHOPT - options: 'BF' - from BACK to FRONT                *
*                             'FB' - from FRONT to BACK                *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
      REAL              F(3,4),XYZ(3,4),TT(4)
      INTEGER           IFACE(4),ICODES(2)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
      DATA              IFACE/1,2,3,4/
*-
      RAD    = ATAN(1.)*4./180.
      SINA   = SIN(ANG*RAD)
      COSA   = COS(ANG*RAD)
*
**          F I N D   T H E   M O S T   L E F T   P O I N T
*
      I1     = 1
      IF (TN(1,1) .LT. 0.)                      I1 = 2
      IF (TN(1,1)*COSA+TN(2,1)*SINA .LT. 0.)    I1 = 5 - I1
*
**          D E F I N E   O R D E R   O F   D R A W I N G
*
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b') THEN
        INCRX  =-1
        INCRY  =-1
      ELSE
        INCRX  =+1
        INCRY  =+1
      END IF
      IF (I1.EQ.1 .OR. I1.EQ.2)         INCRX =-INCRX
      IF (I1.EQ.2 .OR. I1.EQ.3)         INCRY =-INCRY
      IX1    = 1
      IY1    = 1
      IF (INCRX .LT. 0)                 IX1 = NX
      IF (INCRY .LT. 0)                 IY1 = NY
      IX2    = NX - IX1 + 1
      IY2    = NY - IY1 + 1
*
**          D R A W   S U R F A C E
*
      DO 120 IY=IY1,IY2,INCRY
        DO 110 IX=IX1,IX2,INCRX
          CALL FUN(IX,IY,F,TT)
          DO 100 I=1,4
            XYZ(1,I) = F(1,I) + F(2,I)*COSA
            XYZ(2,I) = F(2,I)*SINA
            XYZ(3,I) = F(3,I)
  100     CONTINUE
          ICODES(1)= IX
          ICODES(2)= IY
          CALL DRFACE(ICODES,XYZ,4,IFACE,TT)
  110   CONTINUE
  120 CONTINUE
      RETURN
      END
+DECK,  IHSURP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHSURP(IORDR,NA,NB,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHSURP                                     Date:    06.10.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 26.03.93     *
*                                                                      *
*     Function: Draw surface in polar coordinates                      *
*                                                                      *
*     References: IHWPHI, IHWZN                                        *
*                                                                      *
*     Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R)         *
*            NA    - number of steps along 1st variable                *
*            NB    - number of steps along 2nd variable                *
*                                                                      *
*            FUN(IA,IB,F,T) - external routine                         *
*              IA     - cell number for 1st variable                   *
*              IB     - cell number for 2nd variable                   *
*              F(3,4) - face which corresponds to the cell             *
*                F(1,*) - A                                            *
*                F(2,*) - B                                            *
*                F(3,*) - Z                                            *
*              T(4)   - additional function (for example: temperature) *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - IA                                        *
*                ICODES(2) - IB                                        *
*              XYZ(3,*)  - coordinates of nodes                        *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
*            CHOPT       - options: 'BF' - from BACK to FRONT          *
*                                   'FB' - from FRONT to BACK          *
*                                                                      *
************************************************************************
+CDE, HCPHI.
      REAL              F(3,4),XYZ(3,4),TT(4),TTT(4)
      INTEGER           IFACE(4),ICODES(2)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
      DATA              IFACE/1,2,3,4/
*-
      IF (IORDR .EQ. 0) THEN
        JR     = 1
        JPHI   = 2
        NR     = NA
        NPHI   = NB
      ELSE
        JR     = 2
        JPHI   = 1
        NR     = NB
        NPHI   = NA
      END IF
      IF (NPHI .GT. NPMAX)                              GOTO 998
      RAD    = ATAN(1.)*4./180.
      IOPT   = 2
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')     IOPT = 1
*
**       P R E P A R E   P H I   A R R A Y
**       F I N D    C R I T I C A L   S E C T O R S
*
      KPHI   = NPHI
      IF (IORDR .EQ. 0)                 IA = NR
      IF (IORDR .NE. 0)                 IB = NR
      DO 10 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,F,TT)
        IF (I .EQ. 1)                   APHI(1) = F(JPHI,1)
        APHI(I)   = (APHI(I) + F(JPHI,1))/2.
        APHI(I+1) = F(JPHI,3)
   10 CONTINUE
      CALL IHWPHI(IOPT,KPHI,APHI,IPHI1,IPHI2)
*
**       D R A W   S U R F A C E
*
      INCR   = 1
      IPHI   = IPHI1
  100 IF (IPHI .GT. NPHI)               GOTO 300
*        F I N D   O R D E R   A L O N G   R
      IF (IORDR .EQ. 0) THEN
        IA     = NR
        IB     = IPHI
      ELSE
        IA     = IPHI
        IB     = NR
      END IF
      CALL FUN(IA,IB,F,TT)
      PHI    = RAD * ((F(JPHI,1) + F(JPHI,3))/2.)
      CALL IHWZN(COS(PHI),SIN(PHI),0.,Z)
      INCRR  = 1
      IR1    = 1
      IF ((Z.LE.0. .AND. IOPT.EQ.1) .OR. (Z.GT.0. .AND. IOPT.EQ.2)) THEN
        INCRR  =-1
        IR1    = NR
      END IF
      IR2    = NR - IR1 + 1
*        D R A W   S U R F A C E   F O R   S E C T O R
      DO 200 IR=IR1,IR2,INCRR
        IF (IORDR .EQ. 0)               IA = IR
        IF (IORDR .NE. 0)               IB = IR
        CALL FUN(IA,IB,F,TT)
        DO 210 I=1,4
          J          = I
          IF (IORDR.NE.0 .AND. I.EQ.2)  J = 4
          IF (IORDR.NE.0 .AND. I.EQ.4)  J = 2
          XYZ(1,J) = F(JR,I)*COS(F(JPHI,I)*RAD)
          XYZ(2,J) = F(JR,I)*SIN(F(JPHI,I)*RAD)
          XYZ(3,J) = F(3,I)
          TTT(J)   = TT(I)
  210   CONTINUE
        ICODES(1) = IA
        ICODES(2) = IB
        CALL DRFACE(ICODES,XYZ,4,IFACE,TTT)
  200 CONTINUE
*        N E X T   P H I
  300 IPHI   = IPHI + INCR
      IF (IPHI .EQ. 0)                  IPHI = KPHI
      IF (IPHI .GT. KPHI)               IPHI = 1
      IF (IPHI .NE. IPHI2)              GOTO 100
      IF (INCR) 310,999,320
  310 INCR   = 0
      GOTO 100
  320 INCR   =-1
      IPHI   = IPHI1
      GOTO 300
*
  998 WRITE(*,*) 'IHSURP: too many PHI sectors'
  999 RETURN
      END
+DECK,  IHSURR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHSURR(IORDR,NA,NB,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHSURR                                     Date:    04.11.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 31.03.93     *
*                                                                      *
*     Function: Draw surface in cylindrical coordinates                *
*                                                                      *
*     References: IHWPHI, IHWZN                                        *
*                                                                      *
*     Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z)         *
*            NA    - number of steps along 1st variable                *
*            NB    - number of steps along 2nd variable                *
*                                                                      *
*            FUN(IA,IB,F,T) - external routine                         *
*              IA     - cell number for 1st variable                   *
*              IB     - cell number for 2nd variable                   *
*              F(3,4) - face which corresponds to the cell             *
*                F(1,*) - A                                            *
*                F(2,*) - B                                            *
*                F(3,*) - R                                            *
*              T(4)   - additional function (for example: temperature) *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - IA                                        *
*                ICODES(2) - IB                                        *
*              XYZ(3,*)  - coordinates of nodes                        *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
*            CHOPT       - options: 'BF' - from BACK to FRONT          *
*                                   'FB' - from FRONT to BACK          *
*                                                                      *
************************************************************************
+CDE, HCPHI.
      REAL              F(3,4),XYZ(3,4),TT(4),TTT(4)
      INTEGER           IFACE(4),ICODES(2)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
      DATA              IFACE/1,2,3,4/
*-
      IF (IORDR .EQ. 0) THEN
        JZ     = 1
        JPHI   = 2
        NZ     = NA
        NPHI   = NB
      ELSE
        JZ     = 2
        JPHI   = 1
        NZ     = NB
        NPHI   = NA
      END IF
      IF (NPHI .GT. NPMAX)                              GOTO 998
      RAD    = ATAN(1.)*4./180.
      IOPT   = 2
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')     IOPT = 1
*
**       P R E P A R E   P H I   A R R A Y
**       F I N D    C R I T I C A L   S E C T O R S
*
      KPHI   = NPHI
      IF (IORDR .EQ. 0)                 IA = NZ
      IF (IORDR .NE. 0)                 IB = NZ
      DO 10 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,F,TT)
        IF (I .EQ. 1)                   APHI(1) = F(JPHI,1)
        APHI(I)   = (APHI(I) + F(JPHI,1))/2.
        APHI(I+1) = F(JPHI,3)
   10 CONTINUE
      CALL IHWPHI(IOPT,KPHI,APHI,IPHI1,IPHI2)
*
**       F I N D   O R D E R   A L O N G   Z
*
      INCRZ  = 1
      IZ1    = 1
      CALL IHWZN(0.,0.,1.,Z)
      IF ((Z.LE.0. .AND. IOPT.EQ.1) .OR. (Z.GT.0. .AND. IOPT.EQ.2)) THEN
        INCRZ  =-1
        IZ1    = NZ
      END IF
      IZ2    = NZ - IZ1 + 1
*
**       D R A W   S U R F A C E
*
      INCR   = 1
      IPHI   = IPHI1
  100 IF (IPHI .GT. NPHI)               GOTO 400
      DO 300 IZ=IZ1,IZ2,INCRZ
        IF (IORDR .EQ. 0) THEN
          IA     = IZ
          IB     = IPHI
        ELSE
          IA     = IPHI
          IB     = IZ
        END IF
        CALL FUN(IA,IB,F,TT)
        DO 200 I=1,4
          J          = I
          IF (IORDR.EQ.0 .AND. I.EQ.2)  J = 4
          IF (IORDR.EQ.0 .AND. I.EQ.4)  J = 2
          XYZ(1,J) = F(3,I)*COS(F(JPHI,I)*RAD)
          XYZ(2,J) = F(3,I)*SIN(F(JPHI,I)*RAD)
          XYZ(3,J) = F(JZ,I)
          TTT(J)   = TT(I)
  200   CONTINUE
        ICODES(1) = IA
        ICODES(2) = IB
        CALL DRFACE(ICODES,XYZ,4,IFACE,TTT)
  300 CONTINUE
*        N E X T   P H I
  400 IPHI   = IPHI + INCR
      IF (IPHI .EQ. 0)                  IPHI = KPHI
      IF (IPHI .GT. KPHI)               IPHI = 1
      IF (IPHI .NE. IPHI2)              GOTO 100
      IF (INCR) 410,999,420
  410 INCR   = 0
      GOTO 100
  420 INCR   =-1
      IPHI   = IPHI1
      GOTO 400
*
  998 WRITE(*,*) 'IHSURR: too many PHI sectors'
  999 RETURN
      END
+DECK,  IHSURS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHSURS(IPSDR,IORDR,NA,NB,FUN,DRFACE,CHOPT)
************************************************************************
*                                                                      *
*     IHSURS                                     Date:    07.11.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 12.04.93     *
*                                                                      *
*     Function: Draw surface in spheric coordinates                    *
*                                                                      *
*     References: IHWPHI, IHWTH                                        *
*                                                                      *
*     Input: IPSDR - pseudo-rapidity flag                              *
*            IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA) *
*            NA    - number of steps along 1st variable                *
*            NB    - number of steps along 2nd variable                *
*                                                                      *
*            FUN(IA,IB,F,T) - external routine                         *
*              IA     - cell number for 1st variable                   *
*              IB     - cell number for 2nd variable                   *
*              F(3,4) - face which corresponds to the cell             *
*                F(1,*) - A                                            *
*                F(2,*) - B                                            *
*                F(3,*) - R                                            *
*              T(4)   - additional function (for example: temperature) *
*                                                                      *
*            DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing  *
*              ICODES(*) - set of codes for this face                  *
*                ICODES(1) - IA                                        *
*                ICODES(2) - IB                                        *
*              XYZ(3,*)  - coordinates of nodes                        *
*              NP        - number of nodes in face                     *
*              IFACE(NP) - face                                        *
*              T(NP)     - additional function                         *
*                                                                      *
*            CHOPT       - options: 'BF' - from BACK to FRONT          *
*                                   'FB' - from FRONT to BACK          *
*                                                                      *
************************************************************************
+CDE, HCPHI.
      REAL              F(3,4),XYZ(3,4),TT(4),TTT(4)
      INTEGER           IFACE(4),ICODES(2)
      CHARACTER*(*)     CHOPT
      EXTERNAL          FUN,DRFACE
      DATA              IFACE/1,2,3,4/
*-
      IF (IORDR .EQ. 0) THEN
        JTH    = 1
        JPHI   = 2
        NTH    = NA
        NPHI   = NB
      ELSE
        JTH    = 2
        JPHI   = 1
        NTH    = NB
        NPHI   = NA
      END IF
      IF (NTH  .GT. NPMAX)                              GOTO 997
      IF (NPHI .GT. NPMAX)                              GOTO 998
      RAD    = ATAN(1.)*4./180.
      IOPT   = 2
      IF (CHOPT(1:1).EQ.'B' .OR. CHOPT(1:1).EQ.'b')     IOPT = 1
*
**       P R E P A R E   P H I   A R R A Y
**       F I N D    C R I T I C A L   P H I   S E C T O R S
*
      KPHI   = NPHI
      MTH    = NTH/2
      IF (MTH .EQ. 0)                   MTH = 1
      IF (IORDR .EQ. 0)                 IA = MTH
      IF (IORDR .NE. 0)                 IB = MTH
      DO 10 I=1,NPHI
        IF (IORDR .EQ. 0)               IB = I
        IF (IORDR .NE. 0)               IA = I
        CALL FUN(IA,IB,F,TT)
        IF (I .EQ. 1)                   APHI(1)   = F(JPHI,1)
        APHI(I)   = (APHI(I) + F(JPHI,1))/2.
        APHI(I+1) = F(JPHI,3)
   10 CONTINUE
      CALL IHWPHI(IOPT,KPHI,APHI,IPHI1,IPHI2)
*
**       P R E P A R E   T H E T A   A R R A Y
*
      IF (IORDR .EQ. 0)                 IB = 1
      IF (IORDR .NE. 0)                 IA = 1
      DO 20 I=1,NTH
        IF (IORDR .EQ. 0)               IA = I
        IF (IORDR .NE. 0)               IB = I
        CALL FUN(IA,IB,F,TT)
        IF (I .EQ. 1)                   APHI(1) = F(JTH,1)
        APHI(I)   = (APHI(I) + F(JTH,1))/2.
        APHI(I+1) = F(JTH,3)
   20 CONTINUE
*
**       D R A W   S U R F A C E
*
      KTH    = NTH
      INCR   = 1
      IPHI   = IPHI1
  100 IF (IPHI .GT. NPHI)               GOTO 500
*        F I N D    C R I T I C A L   T H E T A   S E C T O R S
      IF (IORDR .EQ. 0) THEN
        IA     = MTH
        IB     = IPHI
      ELSE
        IA     = IPHI
        IB     = MTH
      END IF
      CALL FUN(IA,IB,F,TT)
      PHI    = (F(JPHI,1) + F(JPHI,3)) / 2.
      CALL IHWTH(IOPT,PHI,KTH,APHI,ITH1,ITH2)
      INCRTH = 1
      ITH    = ITH1
  200 IF (ITH .GT. NTH)                 GOTO 400
      IF (IORDR .EQ. 0)                 IA = ITH
      IF (IORDR .NE. 0)                 IB = ITH
      CALL FUN(IA,IB,F,TT)
      IF (IPSDR .EQ. 1) THEN
        DO 310 I=1,4
          J          = I
          IF (IORDR.NE.0 .AND. I.EQ.2)  J = 4
          IF (IORDR.NE.0 .AND. I.EQ.4)  J = 2
          XYZ(1,J) = F(3,I) * COS(F(JPHI,I)*RAD)
          XYZ(2,J) = F(3,I) * SIN(F(JPHI,I)*RAD)
          XYZ(3,J) = F(3,I) * COS(F(JTH,I)*RAD) / SIN(F(JTH,I)*RAD)
          TTT(J)   = TT(I)
  310   CONTINUE
      ELSE
        DO 320 I=1,4
          J          = I
          IF (IORDR.NE.0 .AND. I.EQ.2)  J = 4
          IF (IORDR.NE.0 .AND. I.EQ.4)  J = 2
          XYZ(1,J) = F(3,I) * SIN(F(JTH,I)*RAD) * COS(F(JPHI,I)*RAD)
          XYZ(2,J) = F(3,I) * SIN(F(JTH,I)*RAD) * SIN(F(JPHI,I)*RAD)
          XYZ(3,J) = F(3,I) * COS(F(JTH,I)*RAD)
          TTT(J)   = TT(I)
  320   CONTINUE
      END IF
      ICODES(1) = IA
      ICODES(2) = IB
      CALL DRFACE(ICODES,XYZ,4,IFACE,TTT)
*        N E X T   T H E T A
  400 ITH    = ITH + INCRTH
      IF (ITH .EQ. 0)                   ITH = KTH
      IF (ITH .GT. KTH)                 ITH = 1
      IF (ITH .NE. ITH2)                GOTO 200
      IF (INCRTH) 410,500,420
  410 INCRTH = 0
      GOTO 200
  420 INCRTH =-1
      ITH    = ITH1
      GOTO 400
*        N E X T   P H I
  500 IPHI   = IPHI + INCR
      IF (IPHI .EQ. 0)                  IPHI = KPHI
      IF (IPHI .GT. KPHI)               IPHI = 1
      IF (IPHI .NE. IPHI2)              GOTO 100
      IF (INCR) 510,999,520
  510 INCR   = 0
      GOTO 100
  520 INCR   =-1
      IPHI   = IPHI1
      GOTO 500
*
  997 WRITE(*,*) 'IHSURS: too many THETA sectors'
      GOTO 999
  998 WRITE(*,*) 'IHSURS: too many PHI sectors'
      GOTO 999
  999 RETURN
      END
+DECK,  IHSVIE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHSVIE(RMIN,RMAX,PHI,THETA,PSI,IREP)
************************************************************************
*                                                                      *
*     IHSVIE                                     Date:    13.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Set view direction (in spherical coordinates)          *
*                                                                      *
*     References: IHWV01, IHWV02                                       *
*                                                                      *
*     Input: RMIN(3) - MIN -                                           *
*            RMAX(3) -       MAX scope                                 *
*                                                                      *
*            PHI     - longitude                                       *
*            THETA   - latitude (angle between +Z and view direction)  *
*            PSI     - rotation in screen plane                        *
*                                                                      *
*     Output: IREP   - reply (-1 if error in min-max)                  *
*                                                                      *
*     Errors: error in min-max scope                                   *
*                                                                      *
************************************************************************
+CDE, HCTNOR.
+CDE, HCSCRN.
      REAL              RMIN(3),RMAX(3),CENTRE(3),SCALE(3)
      DOUBLE PRECISION  DRAD,C1,S1,C2,S2,C3,S3
*-
      DRAD    = DATAN(1.D0)*4./180.
*
**          F I N D   C E N T E R   O F   S C O P E   A N D
**          S C A L E   F A C T O R S
*
      CALL IHWV01(RMIN,RMAX,SCALE,CENTRE,IREP)
      IF (IREP .LT. 0)                  GOTO 998
*
**          S E T   T R A N S F O R M A T I O N   M A T R I X E S
*
      C1     = DCOS(PHI*DRAD)
      S1     = DSIN(PHI*DRAD)
      C2     = DCOS(THETA*DRAD)
      S2     = DSIN(THETA*DRAD)
      C3     = DCOS(PSI*DRAD)
      S3     = DSIN(PSI*DRAD)
      CALL IHWV02(SCALE,CENTRE,C1,S1,C2,S2,C3,S3,TNORM,TBACK)
      C3     = 1.
      S3     = 0.
      CALL IHWV02(SCALE,CENTRE,C1,S1,C2,S2,C3,S3,TN,TB)
      RETURN
*
  998 WRITE(*,*) 'IHSVIE: error in min-max scope'
      END
+DECK,  IHWLIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWLIN(NP,F,T)
************************************************************************
*                                                                      *
*     IHWLIN                                     Date:    10.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find level lines for face                              *
*                                                                      *
*     Input: NP      - number of nodes                                 *
*            F(3,NP) - face                                            *
*            T(NP)   - additional function                             *
*                                                                      *
*     Error: number of points for line .NE. 2                          *
*                                                                      *
************************************************************************
+CDE, HCLEVL.
+CDE, HCLINE.
      REAL              F(3,*),T(*)
*-
      NLINES = 0
      IF (NLEV .EQ. 0)                  GOTO 999
      NL     = NLEV
      IF (NL .LT. 0)                    NL =-NL
*           F I N D   Tmin   A N D   Tmax
      TMIN   = T(1)
      TMAX   = T(1)
      DO 100 I=2,NP
        IF (T(I) .LT. TMIN)             TMIN = T(I)
        IF (T(I) .GT. TMAX)             TMAX = T(I)
  100   CONTINUE
      IF (TMIN .GE. FUNLEV(NL))         GOTO 999
      IF (TMAX .LE. FUNLEV(1))          GOTO 999
*
**          F I N D   L E V E L S   L I N E S
*
      DO 340 IL=1,NL
        IF (TMIN .GE. FUNLEV(IL))       GOTO 340
        IF (TMAX .LE. FUNLEV(IL))       GOTO 999
        IF (NLINES .GE. LLINES)         GOTO 999
        NLINES   = NLINES + 1
        ILLEVL(NLINES) = IL
        K    = 0
        DO 330 I=1,NP
          I1     = I
          I2     = I + 1
          IF (I .EQ. NP)                I2 = 1
          D1     = T(I1) - FUNLEV(IL)
          D2     = T(I2) - FUNLEV(IL)
          IF (D1 .EQ. 0.)               GOTO 310
          IF (D1*D2 .LT. 0.)            GOTO 320
          GOTO 330
  310     K      = K + 1
          PLINES(1,K,NLINES) = F(1,I1)
          PLINES(2,K,NLINES) = F(2,I1)
          PLINES(3,K,NLINES) = F(3,I1)
          IF (K .EQ. 1)                 GOTO 330
          GOTO 340
  320     K      = K + 1
          D1     = D1 / (T(I2)-T(I1))
          D2     = D2 / (T(I2)-T(I1))
          PLINES(1,K,NLINES) = D2*F(1,I1) - D1*F(1,I2)
          PLINES(2,K,NLINES) = D2*F(2,I1) - D1*F(2,I2)
          PLINES(3,K,NLINES) = D2*F(3,I1) - D1*F(3,I2)
          IF (K .EQ. 1)                 GOTO 330
          GOTO 340
  330   CONTINUE
        IF (K .NE. 2) THEN
          WRITE(*,*) 'IHWLIN: number of points for line .NE. 2'
          NLINES = NLINES - 1
        END IF
  340 CONTINUE
*
  999 RETURN
      END
+DECK,  IHWPHI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWPHI(IOPT,KPHI,APHI,IPHI1,IPHI2)
************************************************************************
*                                                                      *
*     IHWPHI                                     Date:    29.03.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find critical PHI sectors                              *
*                                                                      *
*     Input: IOPT    - options: 1 - from BACK to FRONT 'BF'            *
*                               2 - from FRONT to BACK 'FB'            *
*            KPHI    - number of phi sectors                           *
*            APHI(*) - PHI separatrices                                *
*                                                                      *
*     Output: IPHI1  - initial sector                                  *
*             IPHI2  - final sector                                    *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
      REAL              APHI(*)
      INTEGER           IPHI(2)
*-
      RAD    = ATAN(1.)*4./180.
      IF (APHI(KPHI+1) .EQ. APHI(1)) APHI(KPHI+1) = APHI(KPHI+1) + 360.
      DPHI   = ABS(APHI(KPHI+1) - APHI(1))
      IF (DPHI .NE. 360.) THEN
        APHI(KPHI+2) = (APHI(1) + APHI(KPHI+1))/2. + 180.
        APHI(KPHI+3) = APHI(1) + 360.
        KPHI   = KPHI + 2
      END IF
*
**       F I N D   C R I T I C A L   S E C T O R S
*
      K      = 0
      DO 100 I=1,KPHI
        PHI1   = RAD*APHI(I)
        PHI2   = RAD*APHI(I+1)
        X1     = TN(1,1)*COS(PHI1) + TN(2,1)*SIN(PHI1)
        X2     = TN(1,1)*COS(PHI2) + TN(2,1)*SIN(PHI2)
        IF (X1.GE.0. .AND. X2.GT.0.) GOTO 100
        IF (X1.LE.0. .AND. X2.LT.0.) GOTO 100
        K      = K + 1
        IF (K .EQ. 3)           GOTO 998
        IPHI(K)= I
  100 CONTINUE
      IF (K .NE. 2)             GOTO 998
*
**       F I N D   O R D E R   O F   C R I T I C A L   S E C T O R S
*
      PHI1   = RAD * (APHI(IPHI(1)) + APHI(IPHI(1)+1)) / 2.
      PHI2   = RAD * (APHI(IPHI(2)) + APHI(IPHI(2)+1)) / 2.
      Z1     = TN(1,3)*COS(PHI1) + TN(2,3)*SIN(PHI1)
      Z2     = TN(1,3)*COS(PHI2) + TN(2,3)*SIN(PHI2)
      IF ((Z1.LE.Z2 .AND. IOPT.EQ.1).OR.(Z1.GT.Z2 .AND. IOPT.EQ.2)) THEN
        IPHI1 = IPHI(1)
        IPHI2 = IPHI(2)
      ELSE
        IPHI1 = IPHI(2)
        IPHI2 = IPHI(1)
      END IF
      GOTO 999
*
  998 WRITE(*,*)
     &  'IHWPHI: Something strange: num. of critical sectors .NE. 2'
      IPHI1  = 1
      IPHI2  = 2
  999 RETURN
      END
+DECK,  IHWTH, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWTH(IOPT,PHI,KTH,ATH,ITH1,ITH2)
************************************************************************
*                                                                      *
*     IHWTH                                      Date:    07.04.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find critical THETA sectors for given PHI sector       *
*                                                                      *
*     Input: IOPT        - options: 1 - from BACK to FRONT 'BF'        *
*                                   2 - from FRONT to BACK 'FB'        *
*            PHI         - PHI sector                                  *
*            KTH         - number of THETA sectors                     *
*            ATH(*)      - THETA separatrices                          *
*                                                                      *
*     Output: ITH1  - initial sector                                   *
*             ITH2  - final sector                                     *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
      REAL              ATH(*)
      INTEGER           ITH(2)
*-
      RAD    = ATAN(1.)*4./180.
      DTH    = ABS(ATH(KTH+1) - ATH(1))
      IF (DTH .NE. 360.) THEN
        ATH(KTH+2) = (ATH(1) + ATH(KTH+1))/2. + 180.
        ATH(KTH+3) = ATH(1) + 360.
        KTH   = KTH + 2
      END IF
*
**       F I N D   C R I T I C A L   S E C T O R S
*
      COSPHI = COS(PHI*RAD)
      SINPHI = SIN(PHI*RAD)
      K      = 0
      DO 100 I=1,KTH
        TH1    = RAD*ATH(I)
        TH2    = RAD*ATH(I+1)
        CALL IHWZN(COS(TH1)*COSPHI,COS(TH1)*SINPHI,-SIN(TH1),Z1)
        CALL IHWZN(COS(TH2)*COSPHI,COS(TH2)*SINPHI,-SIN(TH2),Z2)
        IF (Z1.GE.0. .AND. Z2.GT.0.) GOTO 100
        IF (Z1.LE.0. .AND. Z2.LT.0.) GOTO 100
        K      = K + 1
        IF (K .EQ. 3)           GOTO 998
        ITH(K)= I
  100 CONTINUE
      IF (K .NE. 2)             GOTO 998
*
**       F I N D   O R D E R   O F   C R I T I C A L   S E C T O R S
*
      TNCONS = TN(1,3)*COS(PHI*RAD) + TN(2,3)*SIN(PHI*RAD)
      TH1    = RAD * (ATH(ITH(1)) + ATH(ITH(1)+1)) / 2.
      TH2    = RAD * (ATH(ITH(2)) + ATH(ITH(2)+1)) / 2.
      Z1     = TNCONS*SIN(TH1) + TN(3,3)*COS(TH1)
      Z2     = TNCONS*SIN(TH2) + TN(3,3)*COS(TH2)
      IF ((Z1.LE.Z2 .AND. IOPT.EQ.1).OR.(Z1.GT.Z2 .AND. IOPT.EQ.2)) THEN
        ITH1 = ITH(1)
        ITH2 = ITH(2)
      ELSE
        ITH1 = ITH(2)
        ITH2 = ITH(1)
      END IF
      GOTO 999
*
  998 WRITE(*,*)
     &  'IHWTH: Something strange: num. of critical sectors .NE. 2'
      ITH1   = 1
      ITH2   = 2
  999 RETURN
      END
+DECK,  IHWTON, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWTON(PW,PN)
************************************************************************
*                                                                      *
*     IHWTON                                     Date:    14.10.91     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Transfer point from world to normalized coordinates    *
*                                                                      *
*     Input: PW(3) - point in world coordinate system                  *
*            PN(3) - point in normalized coordinate system             *
*                                                                      *
************************************************************************
+CDE, HCTNOR.
      REAL PW(3),PN(3)
*-
      X      = PW(1)
      Y      = PW(2)
      Z      = PW(3)
      PN(1)  = TNORM(1,1)*X + TNORM(2,1)*Y + TNORM(3,1)*Z + TNORM(4,1)
      PN(2)  = TNORM(1,2)*X + TNORM(2,2)*Y + TNORM(3,2)*Z + TNORM(4,2)
      PN(3)  = TNORM(1,3)*X + TNORM(2,3)*Y + TNORM(3,3)*Z + TNORM(4,3)
      END
+DECK,  IHWV01, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWV01(RMIN,RMAX,SCALE,CENTER,IREP)
************************************************************************
*                                                                      *
*     IHWV01                                     Date:    13.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 08.01.92     *
*                                                                      *
*     Function: Find centre of a MIN-MAX scope and scale factors       *
*                                                                      *
*     Input: RMIN(3) - MIN -                                           *
*            RMAX(3) -       MAX scope                                 *
*                                                                      *
*     Output: SCALE(3)  - scale factors                                *
*             CENTER(3) - centre                                       *
*             IREP      - reply (-1 if error in min-max)               *
*                                                                      *
************************************************************************
      REAL              RMIN(3),RMAX(3),SCALE(3),CENTER(3)
*-
      IREP   = 0
      SQRT3  = SQRT(3.)/2.
      DO 100 I=1,3
        IF (RMIN(I) .GE. RMAX(I))       GOTO 998
        SCALE(I)  = (RMAX(I)-RMIN(I)) * SQRT3
        CENTER(I) = (RMAX(I)+RMIN(I)) / 2.
  100 CONTINUE
      GOTO 999
*
  998 IREP   =-1
  999 RETURN
      END
+DECK,  IHWV02, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWV02(S,C,COSPHI,SINPHI,COSTHE,SINTHE,COSPSI,SINPSI,
     &                  TNORM,TBACK)
************************************************************************
*                                                                      *
*     IHWV02                                     Date:    13.08.90     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised: 07.01.92     *
*                                                                      *
*     Function: Define view direction (in spherical coordinates)       *
*               Compute transformation matrix from world coordinates   *
*               to normalised coordinates (-1 to +1)                   *
*                                                                      *
*     Input: S(3)    - scale factors                                   *
*            C(3)    - centre of scope                                 *
*            COSPHI  - longitude COS                                   *
*            SINPHI  - longitude SIN                                   *
*            COSTHE  - latitude COS (angle between +Z and view direc.) *
*            SINTHE  - latitude SIN                                    *
*            COSPSI  - screen plane rotation angle COS                 *
*            SINPSI  - screen plane rotation angle SIN                 *
*                                                                      *
************************************************************************
      REAL              S(3),C(3),TNORM(4,3),TBACK(4,3)
      DOUBLE PRECISION  SCALEX,SCALEY,SCALEZ,ROTA(4,4),TRAN(4,4)
      DOUBLE PRECISION  COSPHI,SINPHI,COSTHE,SINTHE,COSPSI,SINPSI
      DOUBLE PRECISION  C1,S1,C2,S2,C3,S3
*-
      SCALEX = S(1)
      SCALEY = S(2)
      SCALEZ = S(3)
*
**          S E T   T R A N S L A T I O N   M A T R I X
*
      TRAN(1,1) = 1./SCALEX
      TRAN(2,1) = 0.
      TRAN(3,1) = 0.
      TRAN(4,1) =-C(1)/SCALEX
*
      TRAN(1,2) = 0.
      TRAN(2,2) = 1./SCALEY
      TRAN(3,2) = 0.
      TRAN(4,2) =-C(2)/SCALEY
*
      TRAN(1,3) = 0.
      TRAN(2,3) = 0.
      TRAN(3,3) = 1./SCALEZ
      TRAN(4,3) =-C(3)/SCALEZ
*
      TRAN(1,4) = 0.
      TRAN(2,4) = 0.
      TRAN(3,4) = 0.
      TRAN(4,4) = 1.
*
**          S E T    R O T A T I O N   M A T R I X
*
* ( C(PSI) S(PSI) 0)   (1      0          0 )   ( C(90+PHI) S(90+PHI) 0)
* (-S(PSI) C(PSI) 0) * (0  C(THETA) S(THETA)) * (-S(90+PHI) C(90+PHI) 0)
* (   0      0    1)   (0 -S(THETA) C(THETA))   (     0           0   1)
*
      C1     = COSPSI
      S1     = SINPSI
      C2     = COSTHE
      S2     = SINTHE
      C3     =-SINPHI
      S3     = COSPHI
*
      ROTA(1,1) = C1*C3 - S1*C2*S3
      ROTA(2,1) = C1*S3 + S1*C2*C3
      ROTA(3,1) = S1*S2
      ROTA(4,1) = 0.
*
      ROTA(1,2) =-S1*C3 - C1*C2*S3
      ROTA(2,2) =-S1*S3 + C1*C2*C3
      ROTA(3,2) = C1*S2
      ROTA(4,2) = 0.
*
      ROTA(1,3) = S2*S3
      ROTA(2,3) =-S2*C3
      ROTA(3,3) = C2
      ROTA(4,3) = 0.
*
      ROTA(1,4) = 0.
      ROTA(2,4) = 0.
      ROTA(3,4) = 0.
      ROTA(4,4) = 1.
*
**          F I N D   T R A N S F O R M A T I O N   M A T R I X
*
      DO 220 I=1,3
        DO 210 K=1,4
          TNORM(K,I) = ROTA(1,I)*TRAN(K,1) +
     +                 ROTA(2,I)*TRAN(K,2) +
     +                 ROTA(3,I)*TRAN(K,3) +
     +                 ROTA(4,I)*TRAN(K,4)
  210     CONTINUE
  220   CONTINUE
*
**          S E T   B A C K   T R A N S L A T I O N   M A T R I X
*
      TRAN(1,1) = SCALEX
      TRAN(4,1) = C(1)
*
      TRAN(2,2) = SCALEY
      TRAN(4,2) = C(2)
*
      TRAN(3,3) = SCALEZ
      TRAN(4,3) = C(3)
*
**          F I N D   B A C K   T R A N S F O R M A T I O N
*
      DO 320 I=1,3
        DO 310 K=1,4
          TBACK(K,I) = TRAN(1,I)*ROTA(1,K) +
     +                 TRAN(2,I)*ROTA(2,K) +
     +                 TRAN(3,I)*ROTA(3,K) +
     +                 TRAN(4,I)*ROTA(4,K)
  310     CONTINUE
  320   CONTINUE
      RETURN
      END
+DECK,  IHWVR1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWVR1(IOPT,PHI1,PHI2,VAL)
************************************************************************
*                                                                      *
*     IHWVR1                                     Date:    20.04.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Encode side visibilities and order along R for sector  *
*                                                                      *
*     References: IHWZN                                                *
*                                                                      *
*     Input: IOPT - options: 1 - from BACK to FRONT 'BF'               *
*                            2 - from FRONT to BACK 'FB'               *
*            PHI1 - 1st phi of sector                                  *
*            PHI2 - 2nd phi of sector                                  *
*                                                                      *
*     Output: VAL - encoded value                                      *
*                                                                      *
************************************************************************
      EQUIVALENCE       (Q,K)
*-
      K      = 0
      CALL IHWZN(0.,0.,1.,ZN)
      IF (ZN .GT. 0.)                           K = K + 64
      IF (ZN .LT. 0.)                           K = K + 32
      CALL IHWZN(-SIN(PHI2),COS(PHI2),0.,ZN)
      IF (ZN .GT. 0.)                           K = K + 16
      CALL IHWZN(SIN(PHI1),-COS(PHI1),0.,ZN)
      IF (ZN .GT. 0.)                           K = K + 4
      PHI    = (PHI1 + PHI2) / 2.
      CALL IHWZN(COS(PHI),SIN(PHI),0.,ZN)
      IF (ZN .GT. 0.)                           K = K + 8
      IF (ZN .LT. 0.)                           K = K + 2
      IF ((ZN.LE.0. .AND. IOPT.EQ.1) .OR.
     &    (ZN.GT.0. .AND. IOPT.EQ.2))           K = K + 1
      VAL    = Q
      END
+DECK,  IHWVR2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWVR2(VAL,IV1,IV2,IV3,IV4,IV5,IV6,IR)
************************************************************************
*                                                                      *
*     IHWVR2                                     Date:    31.03.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Decode side visibilities and order along R for sector  *
*                                                                      *
*     Input: VAL - encoded value                                       *
*                                                                      *
*     Output: IV1 ... IV6  - visibility of the sides                   *
*             IR           - increment along R                         *
*                                                                      *
************************************************************************
      EQUIVALENCE       (Q,K)
      INTEGER           IVIS(6)
*-
      Q      = VAL
      NUM    = 128
      DO 100 I=1,6
        IVIS(I) = 0
        NUM     = NUM / 2
        IF (K .LT. NUM)         GOTO 100
        K       = K - NUM
        IVIS(I) = 1
  100 CONTINUE
      IR     = 1
      IF (K .EQ. 1)             IR  = -1
      IV1    = IVIS(6)
      IV2    = IVIS(5)
      IV3    = IVIS(4)
      IV4    = IVIS(3)
      IV5    = IVIS(2)
      IV6    = IVIS(1)
      END
+DECK,  IHWWNN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWWNN(PW,PN)
************************************************************************
*                                                                      *
*     IHWWNN                                     Date:    17.01.92     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Transfer vector of NORMAL from word to normalized      *
*               coodinates                                             *
*                                                                      *
*     Input: PW(3) - vector of NORMAL in word coordinate system        *
*            PN(3) - vector of NORMAL in normalized coordinate system  *
*                                                                      *
************************************************************************
+CDE, HCTNOR.
      REAL              PW(3),PN(3)
*-
      X      = PW(1)
      Y      = PW(2)
      Z      = PW(3)
      A1     = TNORM(1,1)
      A2     = TNORM(2,1)
      A3     = TNORM(3,1)
      B1     = TNORM(1,2)
      B2     = TNORM(2,2)
      B3     = TNORM(3,2)
      C1     = TNORM(1,3)
      C2     = TNORM(2,3)
      C3     = TNORM(3,3)
      PN(1)  = X*(B2*C3-B3*C2) + Y*(B3*C1-B1*C3) + Z*(B1*C2-B2*C1)
      PN(2)  = X*(C2*A3-C3*A2) + Y*(C3*A1-C1*A3) + Z*(C1*A2-C2*A1)
      PN(3)  = X*(A2*B3-A3*B2) + Y*(A3*B1-A1*B3) + Z*(A1*B2-A2*B1)
      RETURN
      END

+DECK,  IHWZN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHWZN(X,Y,Z,ZN)
************************************************************************
*                                                                      *
*     IHWZN                                      Date:    20.04.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Find Z component of NORMAL in normalized coordinates   *
*                                                                      *
*     Input: X - X-component of NORMAL                                 *
*            Y - Y-component of NORMAL                                 *
*            Z - Z-component of NORMAL                                 *
*                                                                      *
*     Output: ZN - Z-component of NORMAL in normalized coordinates     *
*                                                                      *
************************************************************************
+CDE, HCSCRN.
*-
      ZN     = X*(TN(2,1)*TN(3,2)-TN(3,1)*TN(2,2)) +
     &         Y*(TN(3,1)*TN(1,2)-TN(1,1)*TN(3,2)) +
     &         Z*(TN(1,1)*TN(2,2)-TN(2,1)*TN(1,2))
      RETURN
      END
+DECK,  IHZDEP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:54  mclareni
* Higz

      SUBROUTINE IHZDEP(XYZ,NFACE,IFACE,DFACE,ABCD,IORDER)
************************************************************************
*                                                                      *
*     IHZDEP                                     Date:    26.07.93     *
*     Author: E. Chernyaev (IHEP/Protvino)       Revised:              *
*                                                                      *
*     Function: Z-depth algorithm for set of triangles                 *
*                                                                      *
*     Input: XYZ(3,*)   - nodes                                        *
*            NFACE      - number of triangular faces                   *
*            IFACE(3,*) - faces (triangles)                            *
*                                                                      *
*     Arrays: DFACE(6,*) - array for min-max scopes                    *
*             ABCD(4,*)  - array for face plane equations              *
*                                                                      *
*     Output: IORDER(*) - face order                                   *
*                                                                      *
************************************************************************
      PARAMETER         (DEL = 0.0001)
      INTEGER           IFACE(3,*),IORDER(*),NN(3),KK(3)
      REAL              XYZ(3,*),DFACE(6,*),ABCD(4,*)
      REAL              V(3,2),ABCDN(4),ABCDK(4)
      EQUIVALENCE       (N1,NN(1)),(N2,NN(2)),(N3,NN(3))
      EQUIVALENCE       (K1,KK(1)),(K2,KK(2)),(K3,KK(3))
*-
**          S E T   I N I T I A L   O R D E R
**          I G N O R E   V E R Y   S M A L L   F A C E S
**          S E T   M I N - M A X   S C O P E S
**          S E T   F A C E   P L A N E   E Q U A T I O N S
*
      NF     = 0
      DO 130 N=1,NFACE
        I1     = IABS(IFACE(1,N))
        I2     = IABS(IFACE(2,N))
        I3     = IABS(IFACE(3,N))
*           A R E A   T E S T
        IF (ABS(XYZ(1,I2)-XYZ(1,I1)).LE.DEL .AND.
     &      ABS(XYZ(2,I2)-XYZ(2,I1)).LE.DEL .AND.
     &      ABS(XYZ(3,I2)-XYZ(3,I1)).LE.DEL)    GOTO 130
        IF (ABS(XYZ(1,I3)-XYZ(1,I2)).LE.DEL .AND.
     &      ABS(XYZ(2,I3)-XYZ(2,I2)).LE.DEL .AND.
     &      ABS(XYZ(3,I3)-XYZ(3,I2)).LE.DEL)    GOTO 130
        IF (ABS(XYZ(1,I1)-XYZ(1,I3)).LE.DEL .AND.
     &      ABS(XYZ(2,I1)-XYZ(2,I3)).LE.DEL .AND.
     &      ABS(XYZ(3,I1)-XYZ(3,I3)).LE.DEL)    GOTO 130
*           P R O J E C T I O N   T E S T
        IF (ABS(XYZ(1,I2)-XYZ(1,I1)).LE.DEL .AND.
     &      ABS(XYZ(2,I2)-XYZ(2,I1)).LE.DEL .AND.
     &      ABS(XYZ(1,I3)-XYZ(1,I2)).LE.DEL .AND.
     &      ABS(XYZ(2,I3)-XYZ(2,I2)).LE.DEL .AND.
     &      ABS(XYZ(1,I1)-XYZ(1,I3)).LE.DEL .AND.
     &      ABS(XYZ(2,I1)-XYZ(2,I3)).LE.DEL)    GOTO 130
        NF     = NF + 1
        IORDER(NF) = N
*           F I N D   M I N - M A X
        DO 110 I=1,3
          WMIN = XYZ(I,I1)
          WMAX = XYZ(I,I1)
          IF (WMIN .GT. XYZ(I,I2))      WMIN = XYZ(I,I2)
          IF (WMAX .LT. XYZ(I,I2))      WMAX = XYZ(I,I2)
          IF (WMIN .GT. XYZ(I,I3))      WMIN = XYZ(I,I3)
          IF (WMAX .LT. XYZ(I,I3))      WMAX = XYZ(I,I3)
          DFACE(I,N)   = WMIN
          DFACE(I+3,N) = WMAX
  110   CONTINUE
*          F I N D   F A C E   E Q U A T I O N
        DO 120 I=1,3
          V(I,1) = XYZ(I,I2) - XYZ(I,I1)
          V(I,2) = XYZ(I,I3) - XYZ(I,I2)
  120   CONTINUE
        A      = (V(2,1)*V(3,2) - V(3,1)*V(2,2))
        B      = (V(3,1)*V(1,2) - V(1,1)*V(3,2))
        C      = (V(1,1)*V(2,2) - V(2,1)*V(1,2))
        Q      = SQRT(A*A+B*B+C*C)
        IF (C .LT. 0.)                  Q =-Q
        A      = A / Q
        B      = B / Q
        C      = C / Q
        ABCD(1,N) = A
        ABCD(2,N) = B
        ABCD(3,N) = C
        ABCD(4,N) =-(A*XYZ(1,I1) + B*XYZ(2,I1) + C*XYZ(3,I1))
  130 CONTINUE
      NFACE  = NF
      IF (NF .LE. 1)                    GOTO 999
*
**          S O R T   T R I A N G L E S   A L O N G   Z - M I N
*
      DO 220 ICUR=2,NFACE
        K      = IORDER(ICUR)
        ZCUR   = DFACE(3,K)
        DO 210 ITST=ICUR-1,1,-1
          K      = IORDER(ITST)
          IF (ZCUR .LT. DFACE(3,K))     GOTO 220
          K      = IORDER(ITST)
          IORDER(ITST) = IORDER(ITST+1)
          IORDER(ITST+1) = K
  210   CONTINUE
  220 CONTINUE
*
**          Z - D E P T H   A L G O R I T H M
*
      KFACE  = NFACE
  300 IF (KFACE .EQ. 1)                 GOTO 900
      NF     = IORDER(KFACE)
      IF (NF .LT. 0)                    NF =-NF
      ABCDN(1) = ABCD(1,NF)
      ABCDN(2) = ABCD(2,NF)
      ABCDN(3) = ABCD(3,NF)
      ABCDN(4) = ABCD(4,NF)
      N1       = IABS(IFACE(1,NF))
      N2       = IABS(IFACE(2,NF))
      N3       = IABS(IFACE(3,NF))
*
**          I N T E R N A L   L O O P
*
      DO 800 K=KFACE-1,1,-1
        KF     = IORDER(K)
        IF (KF .LT. 0)                  KF =-KF
        IF (DFACE(6,NF) .GT. DFACE(3,KF)+DEL)   GOTO 400
        IF (IORDER(K) .GT. 0)                   GOTO 900
        GOTO 800
*
**          M I N - M A X   T E S T
*
  400   IF (DFACE(1,KF) .GE. DFACE(4,NF)-DEL)   GOTO 800
        IF (DFACE(4,KF) .LE. DFACE(1,NF)+DEL)   GOTO 800
        IF (DFACE(2,KF) .GE. DFACE(5,NF)-DEL)   GOTO 800
        IF (DFACE(5,KF) .LE. DFACE(2,NF)+DEL)   GOTO 800
*
**          K F   B E F O R E   N F ?
*
        K1       = IABS(IFACE(1,KF))
        K2       = IABS(IFACE(2,KF))
        K3       = IABS(IFACE(3,KF))
        IF (ABCDN(1)*XYZ(1,K1)+ABCDN(2)*XYZ(2,K1)+
     &      ABCDN(3)*XYZ(3,K1)+ABCDN(4) .LT. -DEL)      GOTO 500
        IF (ABCDN(1)*XYZ(1,K2)+ABCDN(2)*XYZ(2,K2)+
     &      ABCDN(3)*XYZ(3,K2)+ABCDN(4) .LT. -DEL)      GOTO 500
        IF (ABCDN(1)*XYZ(1,K3)+ABCDN(2)*XYZ(2,K3)+
     &      ABCDN(3)*XYZ(3,K3)+ABCDN(4) .LT. -DEL)      GOTO 500
        GOTO 800
*
**          N F    A F T E R    K F ?
*
  500   ABCDK(1) = ABCD(1,KF)
        ABCDK(2) = ABCD(2,KF)
        ABCDK(3) = ABCD(3,KF)
        ABCDK(4) = ABCD(4,KF)
        IF (ABCDK(1)*XYZ(1,N1)+ABCDK(2)*XYZ(2,N1)+
     &      ABCDK(3)*XYZ(3,N1)+ABCDK(4) .GT. DEL)       GOTO 600
        IF (ABCDK(1)*XYZ(1,N2)+ABCDK(2)*XYZ(2,N2)+
     &      ABCDK(3)*XYZ(3,N2)+ABCDK(4) .GT. DEL)       GOTO 600
        IF (ABCDK(1)*XYZ(1,N3)+ABCDK(2)*XYZ(2,N3)+
     &      ABCDK(3)*XYZ(3,N3)+ABCDK(4) .GT. DEL)       GOTO 600
        GOTO 800
*
**          E D G E   B Y   E D G E   T E S T
**          K F - E D G E S   A G A I N S T   N F
*
  600   DO 610 I=1,3
          I1      = KK(I)
          I2      = KK(1)
          IF (I .NE. 3)                 I2 = KK(I+1)
          CALL IHZTST(DEL,XYZ,I1,I2,NN,ABCDN,IREP)
          IF (IREP) 700,610,800
  610   CONTINUE
**          N F - E D G E S   A G A I N S T   K F
        DO 620 I=1,3
          I1      = NN(I)
          I2      = NN(1)
          IF (I .NE. 3)                 I2 = NN(I+1)
          CALL IHZTST(DEL,XYZ,I1,I2,KK,ABCDK,IREP)
          IF (IREP) 800,620,700
  620   CONTINUE
        GOTO 800
*
**          C H A N G E   F A C E   O R D E R
*
  700   KF     = IORDER(K)
        DO 710 I=K+1,KFACE
          IORDER(I-1) = IORDER(I)
  710   CONTINUE
        IORDER(KFACE) =-KF
        IF (KF .GT. 0)                  GOTO 300
*        WRITE(*,*) 'IHZDEP: loop'
        GOTO 900
  800 CONTINUE
*
**          N E X T   F A C E
*
  900 IF (IORDER(KFACE) .LT. 0)         IORDER(KFACE) =-IORDER(KFACE)
      KFACE  = KFACE - 1
      IF (KFACE .GT. 0)                 GOTO 300
*
  999 RETURN
      END
+DECK,  IHZTST, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:55  mclareni
* Higz

      SUBROUTINE IHZTST(DEL,XYZ,I1,I2,IFACE,ABCD,IREP)
************************************************************************
*                                                                      *
*     IHZTST                                     Date:    18.03.90     *
*     Author: E. Chernyaev (IHEP)                Revised: 30.07.93     *
*                                                                      *
*     Function: Test edge against face (triangle)                      *
*                                                                      *
*     Input: DEL      - precision                                      *
*            XYZ(3,*) - nodes                                          *
*            I1       - 1-st node of edge                              *
*            I2       - 2-nd node of edge                              *
*            IFACE(3) - triangular face                                *
*            ABCD(4)  - face plane                                     *
*                                                                      *
*     Output: IREP:-1 - edge under face                                *
*                   0 - no decision                                    *
*                  +1 - edge before face                               *
*                                                                      *
************************************************************************
      REAL              XYZ(3,*),ABCD(4),D(3),DELTA(3),T(2)
      INTEGER           IFACE(3)
      EQUIVALENCE       (DX,DELTA(1)),(DY,DELTA(2)),(DZ,DELTA(3))
*-
      IREP   = 0
*
**          F I N D   I N T E R S E C T I O N   P O I N T S
*
      DX     = XYZ(1,I2) - XYZ(1,I1)
      DY     = XYZ(2,I2) - XYZ(2,I1)
      DZ     = XYZ(3,I2) - XYZ(3,I1)
      IF (ABS(DX).LE.DEL .AND. ABS(DY).LE.DEL)  GOTO 999
      IXY    = 1
      IF (ABS(DY) .GT. ABS(DX))                 IXY = 2
      A      = DY
      B      =-DX
      C      =-(A*XYZ(1,I1) + B*XYZ(2,I1))
      D(1)   = A*XYZ(1,IFACE(1)) + B*XYZ(2,IFACE(1)) + C
      D(2)   = A*XYZ(1,IFACE(2)) + B*XYZ(2,IFACE(2)) + C
      D(3)   = A*XYZ(1,IFACE(3)) + B*XYZ(2,IFACE(3)) + C
      K      = 0
      DO 100 I=1,3
        K1     = I
        K2     = I + 1
        IF (I .EQ. 3)                           K2 = 1
        IF (D(K1).GE.0. .AND. D(K2).GE.0.)      GOTO 100
        IF (D(K1).LT.0. .AND. D(K2).LT.0.)      GOTO 100
        D1     = D(K1) / (D(K1) - D(K2))
        D2     = D(K2) / (D(K1) - D(K2))
        XY     = D1*XYZ(IXY,IFACE(K2)) - D2*XYZ(IXY,IFACE(K1))
        K      = K + 1
        T(K)   = (XY-XYZ(IXY,I1)) / DELTA(IXY)
        IF (K .EQ. 2)                           GOTO 200
  100 CONTINUE
      GOTO 999
*
**          C O M P A R E   Z - D E P T H
*
  200 TMIN   = AMIN1(T(1),T(2))
      TMAX   = AMAX1(T(1),T(2))
      IF (TMIN.GT.1. .OR. TMAX.LT.0)            GOTO 999
      IF (TMIN .LT. 0.)                         TMIN = 0.
      IF (TMAX .GT. 1.)                         TMAX = 1.
      TMID   = (TMIN + TMAX) / 2.
      X      = DX*TMID + XYZ(1,I1)
      Y      = DY*TMID + XYZ(2,I1)
      Z      = DZ*TMID + XYZ(3,I1)
      DD     = ABCD(1)*X + ABCD(2)*Y + ABCD(3)*Z + ABCD(4)
      IF (DD .GT. DEL)                          GOTO 997
      IF (DD .LT.-DEL)                          GOTO 998
      GOTO 999
*
  997 IREP   =+1
      GOTO 999
  998 IREP   =-1
      GOTO 999
  999 RETURN
      END
+PATCH, IGOLD.
+DECK,  GOLCLO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:47  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE GOLCLO
+CDE, GOLDEN.
+CDE, HIMETA.
      DIMENSION PAR(2)
      INTEGER UNLINKF
      DATA PAR /0.0, 0.0/
*
      IF (FILOPN) THEN
         CALL GOLWRI(MA,PAR,' ')
         CALL GOLWRI(SP,0,' ')
*
+SELF, IF=MSDOS, IF=-XIOPAK, IF=-CIPACK.
         IF (BIMODE) THEN
            LAST = LBUF - IPOINT + 1
            IF (LAST .LT. 13) LAST = LAST + LBUF
            L1 = LAST
            L2 = 0
            IF (LAST .GT. 256) THEN
               L1 = LAST/2
               L2 = LAST - L1
            END IF
            CALL MFOTIB(SS)
            CALL MFOTIB(L1-2)
            CALL MPUTBF('DEFAULT.SYM',11)
            IF (IPOINT .LE. LBUF) CHMBUF(IPOINT:LBUF) = ' '
            IPOINT = IPOINT + L1 - 11 - 2
            IF (L2 .GT. 0) THEN
               CALL MFOTIB(SS)
               CALL MFOTIB(L2-2)
               CALL MPUTBF('DEFAULT.SYM',11)
            END IF
            CALL MOUTBF
         END IF
+SELF, IF=MSDOS, IF=XIOPAK,CIPACK.
         IF (BIMODE) THEN
            CALL MOUTBF
+SELF, IF=MSDOS, IF=XIOPACK.
            CALL XCLOSE(LUNG)
+SELF, IF=MSDOS, IF=CIPACK.
            CALL CICLOS(LUNG)
            IF (FRADEL) then
               ISTAT = UNLINKF(chmeta)
            END IF
         ELSE
+SELF, IF=MSDOS.
            IF (FRADEL) THEN
               CLOSE(LUNG(1),STATUS='DELETE')
            ELSE
               CLOSE(LUNG(1),STATUS='KEEP')
            END IF
+SELF, IF=MSDOS, IF=XIOPAK,CIPACK.
         END IF
+SELF, IF=MSDOS.
         FILOPN = .FALSE.
      END IF
      END
+SELF.
+DECK,  GOLINI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:47  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE GOLINI(LUN,FILNAM,CHOPT)
*.
*...  GOLINI(LUN,MODE) - OPEN META-FILE ACOORDING 'CHOPT'
*.06/11/91 03:28pm  by Fine V.E. from JINR LCTA fine@main2.jinr.dubna.su
*.
*.   LUN   - LOGICAL UNIT FOR META-FILE OUTPUT
*.   FILNAM  - CHARACTER STRING CONTAINS FILE NAME
*.   CHOPT   = 'ASCII' - ASCII FORMAT OF META-FILE TO EDIT IN THE FUTURE
*.       = 'BINARY'- FASTER AND COMPACT, BUT UNCHANGED.
*.       =  SOME OTHER EQUAL 'BINARY'
*.
+CDE, GOLDEN.
+CDE, HIMETA.
      CHARACTER*(*) CHOPT,FILNAM
      CHARACTER HOMEBK*44, HIGZTL*17
      CHARACTER CHAR
      DIMENSION PAR(2)
+CDE, HIVERS.

      DATA M_OPEN /.FALSE./
     +       HOMEBK /'102758  Copyright (C) Golden Software 1987. '/
     +       HIGZTL /'Produced by HIGZ '/
*
      BIMODE = .TRUE.
      IF (CHOPT .EQ. 'ASCII') BIMODE = .FALSE.
*
+SELF, IF=MSDOS, IF=-CIPACK.
      LUNG(1) = LUN
+SELF, IF=MSDOS.
      IF (BIMODE) THEN
+SELF, IF=MSDOS, IF=-XIOPAK, IF=-CIPACK.
         OPEN (LUNG(1),file=FILNAM(:LENOCC(FILNAM)) , ACCESS='DIRECT',
     +   RECL=LBUF)
+SELF, IF=MSDOS, IF=XIOPAK.
         i = ixopen(lung,filnam(:lenocc(filnam)),'w')
+SELF, IF=MSDOS, IF=CIPACK.
         call ciopen(lung,'w',filnam(:lenocc(filnam)),i)
         LUN = LUNG(1)
+SELF, IF=MSDOS.
         NREC = 1
         CALL VFILL(BUFFER,LBUF/4,0)
         IPOINT = 1
*
         LTIT = LENOCC(HOMEBK)+LENOCC(HIGZTL)+LENOCC(CHVERS)
         CALL MPUTBF(HOMEBK//HIGZTL//CHVERS,LTIT)
         IPOINT = 257
      ELSE
         OPEN (LUNG(1),file=FILNAM(:LENOCC(FILNAM)))
      END IF
      FILOPN = .TRUE.
      CALL GOLWRI(SS,0,SYMFIL(:LENOCC(SYMFIL)))
      PAR(1) = 0.0001*SCMETA/2.54
      PAR(2) = 0.0001*SCMETA/2.54
      CALL GOLWRI(SC,PAR,' ')
      FRADEL = .TRUE.
      END
+SELF.
+DECK,  GOLWRI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE GOLWRI(JOB,PAR,CHARS)
*.
*...  GOLWRI(JOB,PAR,CHAR)  - WRITE TO META-FILE ONE PRIMITIVE COMMAND
*.
*.    JOB  - CODE OF COMMAND
*.    PAR  - ARRAY CONTANED PARAMETERS OF COMMAND
*.    CHAR - STRING PARAMETER
*
*. 06/11/91 03:47pm by Fine V.E. from JINR LCTA
*.
+CDE, GOLDEN.
+CDE, HIMETA.
      DIMENSION PAR(4)
      CHARACTER*(*) CHARS
      EQUIVALENCE (PEN,IPEN)

      IF (JOB .GT. NJOB .OR. JOB .LE. 0 .OR. .NOT. FILOPN ) RETURN
*
      PEN = PAR(1)
      IF (JOB .EQ. SP) THEN
         IF (IPEN .EQ. 0) THEN
            LOCK = .TRUE.
         ELSE
            LOCK = .FALSE.
*--
*--   CHANGE BLACK AND WHITE
*
            IF (IPEN .EQ. 7) IPEN = 0
         END IF
      END IF
      IF (.NOT. LOCK .OR. JOB .EQ. SC .OR. JOB .EQ. SS) THEN
         IF (FRADEL .AND. (JOB .EQ. PS .OR. JOB .EQ. PA)) THEN
            FRADEL = .FALSE.
         END IF
*--
*--   DO
*
         IF (BIMODE) THEN
            CALL MFOTIB(JOB)
            GO TO (10,10,10,20,10,40,50), JOB
*
   10       CONTINUE
            CALL MFOTRB(PAR(1))
            CALL MFOTRB(PAR(2))
            GO TO 140
*
   20       CONTINUE
            DO 30 I=1,4
               CALL MFOTRB(PAR(I))
   30       CONTINUE
   40       CONTINUE
            LCH = LENOCC(CHARS)
            CALL MFOTIB(LCH)
            CALL MPUTBF(CHARS,LCH)
            GO TO 140
*
   50       CONTINUE
            CALL MFOTIB(IPEN)
         ELSE
            GO TO (60 ,70 ,80 ,90 ,100,110,120), JOB
   60       WRITE (LUNG(1),10000) 'PA',PAR(1),PAR(2)
            GO TO 140
   70       WRITE (LUNG(1),10000) 'MA',PAR(1),PAR(2)
            GO TO 140
   80       WRITE (LUNG(1),10000) 'TR',PAR(1),PAR(2)
            GO TO 140
   90       CONTINUE
            WRITE(LUNG(1),10100) 'PS',(PAR(i),i=1,4),CHARS
            GO TO 140
  100       CONTINUE
            WRITE(LUNG(1),10200) 'SC',PAR(1),PAR(2)
            GO TO 140
  110       CONTINUE
            WRITE(LUNG(1),10300) 'SS ',CHARS
            GO TO 140
  120       WRITE(LUNG(1),10400) 'SP ',IPEN
  130       CONTINUE
         END IF
      END IF
*
  140 CONTINUE
10000 FORMAT(A,1X,F6.0,1x,f6.0)
10100 FORMAT(A,1X,3f7.0,G12.3,' "',A,'"')
10200 FORMAT(A,1X,F10.6,1x,f10.6)
10300 format(a,'"',A,'"')
10400 FORMAT(A,I3)
      END
+SELF.
+DECK,  ICLRWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE ICLRWK(IWKID,ICOFL)
      ENTRY      GCLRWK(IWKID,ICOFL)
+CDE, HIKERN.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIMETA.
      CHARACTER CHPTNO*8
      DIMENSION RVAL(2)
*
      IF(GFLAG)THEN
         IF(IWKID.EQ.0)THEN
            DO 20 I=1,INOPWK
               IF(NODRFL(I))GOTO 20
               ISAVE = IWKNB
               IWKNB = I
               CALL IGQWK(ILOPWK(I),'MXDS',RVAL)
               IF((REDIT.NE.0).AND.(REDIT.NE.1.))THEN
                  CALL IGCLES
               ELSE
                  CALL IGSG(I)
                  CALL WINPOP
                  CALL SETPAT(0)
                  CALL COLOR(IOFCOL)
                  ICURCI(I)=0
                  CALL COLOR(IOFCOL)
                  call setlin(1)
C
                  IXSAVE(I) = -1.0
                  IYSAVE(I) = -1.0
C
                  IF (ILOPWK(I) .NE. IDMETA) then
                     IER = CLEAR()
                  ELSE
                     IF (IWTYL(I) .EQ. ISURF) THEN
*
* Automatic naming of the meta-file of the picture
*
                        WRITE (CHPTNO,10000) IPICNM
                        IPICNM=IPICNM+1
                        NLAST=LENOCC(CHPTNO)
                        NFIRST=1
   10                   IF(CHPTNO(NFIRST:NFIRST).EQ.' ')THEN
                           NFIRST=NFIRST+1
                           GOTO 10
                        ENDIF
                        CALL GOLCLO
                        CHMETA = ' '
+SELF, IF=MSDOS, IF=ZEBRA.
                        IF (ZFLAG) CALL IZPICT(chmeta,'G')
+SELF, IF=MSDOS.
                        IF (chmeta .EQ. ' ') THEN
                           chmeta='META'//CHPTNO(NFIRST:NLAST)//'.PLT'
                        ELSE
                           chmeta = chmeta(1:LENOCC(chmeta))//'.PLT'
                        END IF
                        LOCK = .FALSE.
                        SYMFIL = 'DEFAULT.SYM'
                        CALL GOLINI(LUNMET(I),chmeta,'BINARY')
                     END IF
                  END IF
                  IF(IFAIS.GT.1)CALL SETPAT(IFASI)
               ENDIF
   20       CONTINUE
         ELSE
            IWT=IGIWTY(IWKID)
            IF(IWT.LE.0)GOTO 40
            CALL IGQWK(IWKID,'MXDS',RVAL)
            IF((REDIT.NE.0).AND.(REDIT.NE.1.))THEN
               CALL IGCLES
            ELSE
               I=IGIWIN(IWKID)
               CALL IGSG(I)
               CALL WINPOP
               CALL SETPAT(0)
               CALL COLOR(IOFCOL)
               ICURCI(I)=0
               CALL COLOR(IOFCOL)
               call setlin(1)
               IXSAVE(I) = -1.0
               IYSAVE(I) = -1.0
               IF (ILOPWK(I) .NE. IDMETA) then
                  IER = CLEAR()
               ELSE
                  IF (IWTYL(I) .EQ. ISURF) THEN
*
* Automatic naming of the meta-file of the picture
*
                     WRITE (CHPTNO,10000) IPICNM
                     IPICNM=IPICNM+1
                     NLAST=LENOCC(CHPTNO)
                     NFIRST=1
   30                IF(CHPTNO(NFIRST:NFIRST).EQ.' ')THEN
                        NFIRST=NFIRST+1
                        GOTO 30
                     ENDIF
C===
                     CALL GOLCLO
                     CHMETA = ' '
+SELF, IF=MSDOS, IF=ZEBRA.
                     IF (ZFLAG) CALL IZPICT(chmeta,'G')
+SELF, IF=MSDOS.
                     IF (chmeta .EQ. ' ') THEN
                        chmeta='META'//CHPTNO(NFIRST:NLAST)//'.PLT'
                     ELSE
                        chmeta = chmeta(1:LENOCC(chmeta))//'.PLT'
                     END IF
C===
                     LOCK = .FALSE.
                     SYMFIL = 'DEFAULT.SYM'
                     CALL GOLINI(LUNMET(I),chmeta,'BINARY')
                  END IF
               END IF
               IF(IFAIS.GT.1)CALL SETPAT(IFASI)
            ENDIF
         ENDIF
      ENDIF
   40 CONTINUE
+SELF, IF=MSDOS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZCLRD
+SELF, IF=MSDOS.
10000 FORMAT(I5)
      END
+SELF.
+DECK,  IMFUWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE IMFUWK(ITY)
+CDE, HIATT.
+CDE, HIKERN.
+CDE, HIMETA.
      DIMENSION PAR(2)
      IF (ITY .EQ. ISURF) THEN
         DY=RDWYMA-RDWYMI
         DX=RDWXMA-RDWXMI
*
         IF(DY.GT.DX)THEN
            PAR(1)=(RDVXMA)/DX
         ELSE
            PAR(1)=(RDVYMA)/DY
         ENDIF
         PAR(2) = PAR(1)/SCMETA
         SCMETA = PAR(1)
         PAR(1) = PAR(2)
         CALL GOLWRI(SC,PAR,' ')
      END IF
      END
+SELF.
+DECK,  MFOTIB, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE MFOTIB(IVAL)
+CDE, GOLDEN.
*
      CALL MPUTBF(char(ival),1)
      END
+SELF.
+DECK,  MFOTRB, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE MFOTRB(VAL)
+CDE, GOLDEN.
      CHARACTER*4 CWORK
      EQUIVALENCE (CWORK, WORK)
*
      WORK = VAL
      CALL MPUTBF(CWORK,4)
      END
+SELF.
+DECK,  MOUTBF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE MOUTBF
+CDE, GOLDEN.
+SELF, IF=MSDOS, IF=XIOPAK.
      CALL XOTBYF(LUNG,CHMBUF(:IPOINT-1),IPOINT-1)
+SELF, IF=MSDOS, IF=CIPACK.
      CALL CIPUT(LUNG,CHMBUF(:IPOINT-1),IPOINT-1,ISTAT)
      IF (ISTAT .LT. 0) GO TO 10
+SELF, IF=MSDOS, IF=-XIOPAK, IF=-CIPACK.
      Write (LUNG(1), err=10 , rec=NREC) BUFFER
      CALL VFILL(BUFFER,LBUF/4,0)
+SELF, IF=MSDOS.
      NREC = NREC + 1
      RETURN
+SELF, IF=MSDOS, IF=-XIOPAK.
   10 CONTINUE
      CALL IGERR('META FILE WRITE FAULT','MOUTBF')
+SELF, IF=MSDOS.
      END
+SELF.
+DECK,  MPUTBF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:48  mclareni
* Higz
+SELF, IF=MSDOS.

      SUBROUTINE MPUTBF(CHARST,LCH)
+CDE, GOLDEN.
      CHARACTER*(*)  CHARST
*
      IF (LCH .LE. 0 .OR. LCH .GT. LENOCC(CHARST)) RETURN
      DO 10  I=1,LCH
         IF (IPOINT .EQ. LBUF+1) THEN
            CALL MOUTBF
            IPOINT = 1
         END IF
         CHMBUF(IPOINT:IPOINT) = CHARST(I:I)
         IPOINT = IPOINT + 1
   10 CONTINUE
      END
+SELF.
+PATCH, IGKS.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
SRCS_F=	iacwk.F iclks.F iclrwk.F iclwk.F idawk.F ifa.F igsa.F \ @@\
	igsg.F igsgn.F iopks.F iopwk.F ipl.F ipm.F irqlc.F irqst.F \ @@\
	ischh.F ischup.F isclip.F iscr.F iselnt.F isfaci.F isfais.F \ @@\
	isfasi.F isln.F islwsc.F ismk.F ismksc.F isplci.F ispmci.F \ @@\
	istxal.F istxci.F istxfp.F isvp.F iswkvp.F iswkwn.F iswn.F \ @@\
	itx.F iuwk.F

SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  IACWK, T=FORT.
* Revision 1.2  1996/06/05 10:20:28  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IACWK(IWKID)
*.===========>
*.
*.   This routine actives a workstation .
*.
*. _Input parameters:
*.
*.  INTEGER IWKID : Workstation identifier .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
*.______________________________________
*
      IF(IWKID.EQ.0)THEN
         CALL IGERR('Workstation identifier equal 0','IACWK')
         RETURN
      ENDIF
      DO 10 I=1,INOPWK
         IF(ILOPWK(I).EQ.IWKID)THEN
            ACWKFL(I)=.TRUE.
            GOTO 20
         ENDIF
 10   CONTINUE
      CALL IGERR('Workstation is not open','IACWK')
      RETURN
 20   CONTINUE
+SELF, IF=GKS, IF=PSCRIPT.
*
      IF(IGIWTY(IWKID).LT.0)THEN
         PFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         RETURN
      ENDIF
+SELF, IF=GKS, IF=GKS.
*
      CALL GACWK(IWKID)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ICLKS, T=FORT.
* Revision 1.2  1996/06/05 10:20:30  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ICLKS
*.===========>
*.
*.   This routine closes the graphic package .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
*.______________________________________
*
+SELF, IF=GKS, IF=GKS.
      IF(GFLAG)CALL GCLKS
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ICLRWK, T=FORT.
* Revision 1.2  1996/06/05 10:20:31  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ICLRWK(WKID,COFL)
*.===========>
*.
*.   This routine clears the WKID workstation .
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  INTEGER COFL : Control flag .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
+CDE, HIMETA.
      INTEGER WKID,COFL
*.______________________________________
*
      IF(IGIWTY(WKID).LT.0)GOTO 20
      IF(GFLAG)THEN
         CALL IGSG(0)
         IF(WKID.NE.0)THEN
            IF((REDIT.NE.0).AND.(REDIT.NE.1.))THEN
               CALL IGCLES
            ELSE
               CALL GCLRWK(WKID,COFL)
            ENDIF
         ELSE
            DO 10 I=1,INOPWK
               IF(IGIWTY(ILOPWK(I)).LT.0)GOTO 10
               IF(ILOPWK(I).EQ.1.AND..NOT.TEKACT)GO TO 10
               IF((REDIT.NE.0).AND.(REDIT.NE.1.))THEN
                  CALL IGCLES
               ELSE
                  CALL GCLRWK(ILOPWK(I),COFL)
               ENDIF
   10       CONTINUE
         ENDIF
         CALL IGSGN
      ENDIF
   20 CONTINUE
+SELF, IF=GKS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZCLRD
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ICLWK, T=FORT.
* Revision 1.2  1996/06/05 10:20:31  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ICLWK(IWKID)
*.===========>
*.
*.   This routine closes the IWKID workstation .
*.
*. _Input parameters:
*.
*.  INTEGER IWKID : Workstation identifier .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=GKS, IF=PSCRIPT.
+CDE, HIPOST.
+SELF, IF=GKS.
+CDE, HIMETA.
*.______________________________________
*
      IF(IWKID.EQ.IDMETA.AND.FILOPN)FILOPN=.FALSE.
+SELF, IF=GKS, IF=PSCRIPT.
      IF(IGIWTY(IWKID).LT.0)THEN
         CALL IPEND
         GOTO 30
      ENDIF
+SELF, IF=GKS, IF=GKS.
      CALL IGSG(0)
      CALL GCLWK(IWKID)
+SELF, IF=GKS.
*
*              Update the open-workstation list
*
   30 CONTINUE
      DO 50 I=1,INOPWK
         IF(ILOPWK(I).EQ.IWKID)THEN
            INOPWK=INOPWK-1
            DO 40 J=I,INOPWK
               ILOPWK(J) = ILOPWK(J+1)
               IWTYL(J)  = IWTYL(J+1)
+SELF, IF=GKS, IF=PSCRIPT.
               IF (IWTYL(J).LT.0) IPSI = J
+SELF, IF=GKS.
               ACWKFL(J) = ACWKFL(J+1)
   40       CONTINUE
            RETURN
         ENDIF
   50 CONTINUE
*
      END
+SELF.
+DECK,  IDAWK, T=FORT.
* Revision 1.2  1996/06/05 10:20:32  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IDAWK(IWKID)
*.===========>
*.
*.   This routine deactives the IWKID workstation .
*.
*. _Input parameters:
*.
*.  INTEGER IWKID : Workstation identifier .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
*.______________________________________
*
      DO 10 I=1,INOPWK
         IF(ILOPWK(I).EQ.IWKID.AND.ACWKFL(I))THEN
            ACWKFL(I)=.FALSE.
            GOTO 20
         ENDIF
 10   CONTINUE
      CALL IGERR('Workstation is not active','IDAWK')
      RETURN
 20   CONTINUE
+SELF, IF=GKS, IF=PSCRIPT.
*
      IF(IGIWTY(IWKID).LT.0)THEN
         PFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         RETURN
      ENDIF
+SELF, IF=GKS, IF=GKS.
*
      CALL GDAWK(IWKID)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IFA, T=FORT.
* Revision 1.2  1996/06/05 10:20:32  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IFA(N,X,Y)
*.===========>
*.
*.   This routine draws a fill area .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
      DIMENSION X(*),Y(*)
*.______________________________________
*
      IF(N.LT.3)THEN
         CALL IGERR('Invalid number of points','IFA')
         RETURN
      ENDIF
*
      IF(IFAIS.EQ.3.AND.IFASI.GE.100)THEN
         CALL IGFA(N,X,Y)
      ELSE
         IF(GFLAG)THEN
            CALL IGSG(0)
            CALL GFA(N,X,Y)
         ENDIF
      ENDIF
+SELF, IF=GKS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZFA(N,X,Y)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IGSA, T=FORT.
* Revision 1.3  1998/01/30 15:22:28  couet
* - APOLLO version removed
* Revision 1.2  1996/06/05 10:20:33  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IGSA(IIWK)
*.===========>
*.
*.   IGSA switches a raster terminal from graphics to alpha mode.
*. The terminal must be an activated HIGZ workstation.This is done by
*. prompting the user who should respond by typing RETURN or any
*. character string followed by return.
*.
*..==========>
+SELF, IF=GKS, IF=GKSGRAL,ATCGKS, IF=IBM,VAX,SUN,ALLIANT.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIMETA.
+SELF, IF=GKS, IF=GKSGRAL, IF=NEWLIB.
      INTEGER      ATTYPE,ATTVAL
      CHARACTER*80 ISTR
      INTEGER      IB(1)
      LOGICAL      FIRST/.TRUE./
      SAVE         FIRST
      REAL         RX(1)
+SELF, IF=GKS, IF=GKSGRAL,ATCGKS, IF=IBM,VAX,SUN,ALLIANT.
      COMMON/QUEST/IQUEST(100)
      LOGICAL INTRAC
*.______________________________________
*
      IF(GRFLAG)THEN
         GRFLAG=.FALSE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=1
         IF(IQUEST(100).EQ.-1)THEN
            IQUEST(100)=0
         ENDIF
         IF(INTRAC(DUMMY))THEN
+SELF, IF=GKS, IF=GKSGRAL, IF=IBM,VAX,ALLIANT, IF=-ATCGKS, IF=-NEWLIB.
            IF(TEKACT)CALL GCGTOA(IWK)
+SELF, IF=GKS, IF=GKSGRAL, IF=NEWLIB.
            IF(TEKACT)THEN
*
*          hold graphic to look at
*          wait for enter
*          ignore 1. entry (in alpha window)
*
               IF (IWTYPE.EQ.5003.OR.IWTYPE.EQ.5005) THEN
                  IF(.NOT.FIRST) THEN
                     CALL ASREAD(ATTYPE,ATTVAL,ICOUNT)
                     IB(1) = 2
                     CALL GK5XAO (200, 1,IB, 1,RX,RX,IB   ,IB   )
                  END IF
                  FIRST = .FALSE.
               END IF
*
*     send window switch sequence for FALCO (7878)
*
               IF (IWTYPE.EQ.7878) THEN
                  CALL GKC1AS(105,1,IB)
                  CALL GKC1AW
                  CALL ERASC1
               END IF
*
*     CLEAR ALPHA WINDOW FOR IPS-ATARI
*
               IF (IWTYPE.EQ.4703.OR.IWTYPE.EQ.4713) THEN
                  CALL ERASD3
               END IF
            ENDIF
+SELF, IF=GKS, IF=ATCGKS, IF=VAX,SUN.
            IF(TEKACT)CALL GUESC001(IWK,0)
+SELF, IF=GKS, IF=GKSGRAL,ATCGKS, IF=IBM,VAX,SUN,ALLIANT.
         ENDIF
      ENDIF
+SELF, IF=GKS, IF=PLOT10GKS, IF=IBM.
+CDE, HIATT.
+CDE, HIFLAG.
      COMMON/QUEST/IQUEST(100)
      CHARACTER*80 REPLY
      INTEGER WKID,LSTRI
      INTEGER T4107
      PARAMETER (IPG=301400,IMAC=301401,T4107=410700)
      LOGICAL INTRAC
      DATA PGSW/Z18/
*.______________________________________
*
*
*
      IF(GRFLAG)THEN
         GRFLAG=.FALSE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=1
         CALL GUWK(IWK,0)
         IF(IQUEST(100).EQ.-1)THEN
            IQUEST(100)=0
         ELSE
            CALL GRQST(IWK,1,IST,LSTRI,REPLY)
         ENDIF
         IF(INTRAC(DUMMY))THEN
            IF(IWTYPE.EQ.IMAC)THEN
               CALL HWRASC(1,PGSW)
               CALL HWRASC(1,PGSW)
            ELSEIF(IWTYPE.EQ.IPG)THEN
               CALL HWRASC(1,PGSW)
            ELSEIF(IWTYPE.EQ.T4107)THEN
               CALL HWRASC(1,27)
               CALL HWRASC(1,37)
               CALL HWRASC(1,33)
               CALL HWRASC(1,49)
            ENDIF
            CALL HTIMEO(500)
         ENDIF
      ENDIF
+SELF, IF=GKS, IF=UNIGKS, IF=IBM.
*
*              W.Wojcik, CCIN2P3/Lyon 19/06/87 (WOJCIK at FRCPN11)
*
+CDE, HIATT.
+CDE, HIFLAG.
*
      CHARACTER*20 REPLY
      PARAMETER (LIFN=2,LRFN=1,LCFN=4,LDTR=4)
      DIMENSION IFN(LIFN)
      DIMENSION RFN(LRFN)
      CHARACTER*(LCFN) CFN
      CHARACTER*80 DTR(LDTR)
*
*
      IF (GRFLAG) THEN
         GRFLAG=.FALSE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=1
*
*              Test if GKS is open...
*
         CALL GQOPS(IFLG)
         IF (IFLG.EQ.0) GO TO 99
*
         CALL GQWKC(IWK,IERR,ICONID,IWTYPE)
*
*              GKS not in proper state
*
         IF (IERR.EQ. 7) GOTO 99
*
*              Specified workstation id is not valid
*
         IF (IERR.EQ.20) GOTO 99
*
*              Specified workstation is not open
*
         IF (IERR.EQ.25) GOTO 99
*
         CALL GUWK(IDID,0)
*
         IFN(1)=IDID
         IFN(2)=3
         RFN(1)=3.
         CFN='BELL'
*
         CALL GPREC(LIFN,IFN,LRFN,RFN,LCFN,CFN,LDTR,DTR)
         CALL GESC(11,LDTR,DTR)
*
         CALL GRQST(IWK,1,IERR,LREPLY,REPLY)
*
         IFN(1)=IDID
         IFN(2)=1
         RFN(1)=1.
         CFN='IGSA'
*
         CALL GPREC(LIFN,IFN,LRFN,RFN,LCFN,CFN,LDTR,DTR)
         CALL GESC(11,LDTR,DTR)
*
      ENDIF
*
+SELF, IF=GKS, IF=DECGKS, IF=VAX.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIMETA.
+CDE, HILUN.
      COMMON/QUEST/IQUEST(100)
      LOGICAL INTRAC
      CHARACTER*1 BSLASH
*.______________________________________
*
      IF(GRFLAG)THEN
         GRFLAG=.FALSE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=1
         IF(IQUEST(100).EQ.-1)THEN
            IQUEST(100)=0
         ENDIF
         IF(INTRAC(DUMMY))THEN
           IWK=IIWK
           IF(IWK.EQ.0)IWK=IDID
           IF(IQUEST(100).EQ.-1)THEN
              IQUEST(100)=0
           ENDIF
           IF(IWK.NE.0) THEN
             IF((IWK.EQ.13).OR.(IWK.EQ.14).OR.
     +          (IWK.EQ.16).OR.(IWK.EQ.17)) THEN
+SELF, IF=GKS, IF=-BSLASH, IF=DECGKS, IF=VAX.
                BSLASH = '\'
+SELF, IF=GKS, IF=BSLASH, IF=DECGKS, IF=VAX.
                BSLASH = '\\'
+SELF, IF=GKS, IF=DECGKS, IF=VAX.
                WRITE(LUNOUT,'(1X,A2)') CHAR(27)//BSLASH
             ELSEIF ((IWK.EQ.72).OR.(IWK.EQ.82)) THEN
                WRITE(LUNOUT,'(1X,A1)') CHAR(24)
             ENDIF
           ENDIF
*
         ENDIF
      ENDIF
+SELF, IF=GKS.
*
   99 END
+SELF.
+DECK,  IGSG, T=FORT.
* Revision 1.4  1998/01/30 15:22:29  couet
* - APOLLO version removed
* Revision 1.3  1998/01/28 14:34:31  couet
* - GGDM driver removed
* Revision 1.2  1996/06/05 10:20:34  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IGSG(IIWK)
*.===========>
*.
*.   IGSG switches a raster terminal from alpha to graphics mode .
*. The terminal must be an activated HIGZ workstation .
*.
*..==========> (O.Couet)
+SELF, IF=GKS, IF=GKSGRAL,ATCGKS, IF=IBM,VAX,SUN,ALLIANT.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIMETA.
+SELF, IF=GKS, IF=GKSGRAL, IF=NEWLIB.
      INTEGER      WKID
      INTEGER      ATTYPE,ATTVAL
      CHARACTER*80 ISTR
      INTEGER      IB(1)
      REAL         RX(1)
+SELF, IF=GKS, IF=GKSGRAL,ATCGKS, IF=IBM,VAX,SUN,ALLIANT.
*.______________________________________
*
      IF(.NOT.GRFLAG)THEN
         GRFLAG=.TRUE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=1
+SELF, IF=GKS, IF=GKSGRAL, IF=IBM,VAX,ALLIANT, IF=-ATCGKS, IF=-NEWLIB.
         IF(TEKACT)CALL GCATOG(IWK)
+SELF, IF=GKS, IF=GKSGRAL, IF=NEWLIB.
         IF(TEKACT)THEN
*
*           switch from alpha to graphic window
*
            IF (IWTYPE.EQ.5003.OR.IWTYPE.EQ.5005) THEN
               IB(1) = 1
               CALL GK5XAO (200, 1,IB, 1,RX,RX,IB   ,IB   )
            END IF
*
*           treatment for FALCO (7878)
*
            IF (IWTYPE.EQ.7878) THEN
               CALL GKC1AS(106,1,IB)
               CALL GKC1AW
            ENDIF
         ENDIF
+SELF, IF=GKS, IF=ATCGKS, IF=VAX,SUN.
         IF(TEKACT)CALL GUESC001(IWK,1)
+SELF, IF=GKS, IF=GKSGRAL,ATCGKS, IF=IBM,VAX,SUN,ALLIANT.
      ENDIF
+SELF, IF=GKS, IF=PLOT10GKS, IF=IBM.
+CDE, HIATT.
+CDE, HIFLAG.
      INTEGER T4107
      PARAMETER (IPG=301400,IMAC=301401,T4107=410700)
      DATA ESC/Z1B/,GS/Z1D/
*.______________________________________
*
      IF(.NOT.GRFLAG)THEN
         GRFLAG=.TRUE.
         IF(IWTYPE.EQ.IMAC)THEN
            CALL HWRAS(1,ESC)
            CALL HWRAS(1,GS)
         ELSEIF(IWTYPE.EQ.IPG)THEN
            CALL HWRAS(1,ESC)
            CALL HWRAS(1,GS)
         ELSEIF(IWTYPE.EQ.T4107)THEN
            CALL HWRASC(1,27)
            CALL HWRASC(1,37)
            CALL HWRASC(1,33)
            CALL HWRASC(1,48)
         ENDIF
      ENDIF
+SELF, IF=GKS, IF=UNIGKS, IF=IBM.
* W.WOJCIK, CCIN2P3/LYON 19/06/87 (WOJCIK AT FRCPN11)
+CDE, HIATT.
+CDE, HIFLAG.
*
      PARAMETER (LIFN=2,LRFN=1,LCFN=4,LDTR=4)
      DIMENSION IFN(LIFN)
      DIMENSION RFN(LRFN)
      CHARACTER*(LCFN) CFN
      CHARACTER*80 DTR(LDTR)
*
      CHARACTER*80 MSG
      INTEGER NTLUN,NSEQ
*
      DATA NTLUN,NSEQ/88,1/
*
      IF (.NOT.GRFLAG) THEN
         GRFLAG=.TRUE.
*
* TEST IF GKS IS OPEN...
         IWK=IIWK
         IF(IWK.EQ.0)IWK=1
         CALL GQOPS(IFLG)
         IF (IFLG.EQ.0) GO TO 99
*
         CALL GQWKC(IWK,IERR,ICONID,IWTYPE)
* GKS NOT IN PROPER STATE
         IF (IERR.EQ. 7) GO TO 99
* SPECIFIED WORKSTATION ID IS NOT VALID
         IF (IERR.EQ.20) GO TO 99
* SPECIFIED WORKSTATION IS NOT OPEN
         IF (IERR.EQ.25) GO TO 99
*
         IF (NSEQ .EQ. 1) THEN
            MSG='FI FT00F001 TERM'
            IF (NTLUN .GT. 9) THEN
               WRITE(MSG(6:7),FMT='(I2)') NTLUN
            ELSE
               WRITE(MSG(7:7),FMT='(I1)') NTLUN
            ENDIF
            CALL VMCMS(MSG,IRC)
         ENDIF
         READ(UNIT=NTLUN,FMT='(A)',END=11) MSG
         GO TO 22
   11    NSEQ = NSEQ + 1
         MSG='FI FT00F001 TERM'
         IF (NTLUN .GT. 9) THEN
            WRITE(MSG(6:7),FMT='(I2)') NTLUN
         ELSE
            WRITE(MSG(7:7),FMT='(I1)') NTLUN
         ENDIF
         IF (NSEQ .GT. 99) THEN
            WRITE(MSG(9:11),FMT='(I3)') NSEQ
         ELSE IF (NSEQ .GT. 9) THEN
            WRITE(MSG(10:11),FMT='(I2)') NSEQ
         ELSE
            WRITE(MSG(11:11),FMT='(I1)') NSEQ
         ENDIF
         CALL VMCMS(MSG,IRC)
   22    IRC=IOSCLR()
*
         IFN(1)=IWK
         IFN(2)=2
         RFN(1)=2.
         CFN='IGSG'
*
         CALL GPREC(LIFN,IFN,LRFN,RFN,LCFN,CFN,LDTR,DTR)
         CALL GESC(11,LDTR,DTR)
*
      ENDIF
+SELF, IF=GKS, IF=DECGKS, IF=VAX.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIMETA.
+CDE, HILUN.
*.______________________________________
*
      IF(.NOT.GRFLAG)THEN
         GRFLAG=.TRUE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=1
         IF(IWK.NE.0) THEN
           IF((IWK.EQ.13).OR.(IWK.EQ.14).OR.
     +        (IWK.EQ.16).OR.(IWK.EQ.17)) THEN
              WRITE(LUNOUT,'(1X,A4)') CHAR(27)//'[2J'
           ELSEIF ((IWK.EQ.72).OR.(IWK.EQ.82)) THEN
              WRITE(LUNOUT,'(1X,A4)') CHAR(27)//'[2J'
           ENDIF
         ENDIF
*
      ENDIF
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IGSGN, T=FORT.
* Revision 1.2  1996/06/05 10:20:35  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IGSGN
*.===========>
*.
*.   IGSGN send escape characters to clear workstation (T4107)
*. The terminal must be an activated HIGZ workstation .
*.
*..==========> (O.Couet)
+SELF, IF=GKS, IF=PLOT10GKS, IF=IBM.
+CDE, HIATT.
+CDE, HIFLAG.
      INTEGER T4107
      PARAMETER (T4107=410700)
      DIMENSION N(3),M(32)
      DATA N/31,27,12/
      DATA M/32*22/
*.______________________________________
*
      CALL IGSG(0)
      IF(IWTYPE.EQ.T4107)THEN
         CALL HWRASC(3,N)
         DO 10 I=1,8
            CALL HWRASC(32,M)
  10     CONTINUE
      ENDIF
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IOPKS, T=FORT.
* Revision 1.28  2002/05/22 09:18:43  couet
* - 1.28/07
* Revision 1.27  2002/05/16 15:32:14  couet
* - 1.28/06
* Revision 1.26  2002/04/04 10:23:19  couet
* - 1.28/05
* Revision 1.25  2002/03/18 16:25:11  couet
* - 1.28/04
* Revision 1.24  2001/12/07 15:52:29  couet
* - 1.28/03
* Revision 1.23  2001/11/23 16:09:32  couet
* - 1.28/02
* Revision 1.22  2001/10/17 14:42:57  couet
* - 1.28/01
* Revision 1.21  2001/10/08 16:18:09  couet
* - 1.28/00
* Revision 1.20  2001/05/31 08:08:40  couet
* - 1.27/03
* Revision 1.19  2000/08/29 14:04:08  couet
* - 1.27/02
* Revision 1.18  2000/07/14 15:19:04  couet
* - 1.27/01
* Revision 1.17  2000/04/03 15:41:42  couet
* - 1.27/00
* Revision 1.16  1999/10/20 14:16:58  couet
* - 1.26/04
* Revision 1.15  1999/10/13 12:35:39  couet
* - 1.26/03
* Revision 1.14  1999/10/06 14:05:30  couet
* - 1.26/02
* Revision 1.13  1999/06/21 16:48:40  couet
* - 1.26/01
* Revision 1.12  1999/05/06 06:59:34  couet
* - version 1.26/00 to tag the following bug fixe in x11int.c:
*  "MapNotify is not supported by all the X11 emulators (problem on Mac !!!)"
* Revision 1.11  1999/01/07 15:31:31  couet
* - 1.25/05
* Revision 1.10  1998/12/07 13:45:27  couet
* - 1.25/04
* Revision 1.9  1998/11/16 11:15:13  couet
* *** empty log message ***
* Revision 1.8  1998/11/16 11:13:49  couet
* - 1.25/03
* Revision 1.7  1998/11/13 10:52:34  couet
* - 1.25/02
* Revision 1.6  1998/05/26 09:23:00  couet
* - 1.25/01
* Revision 1.5  1998/04/09 13:08:14  couet
* - new version
* Revision 1.4  1997/01/30 10:55:15  couet
* - version 1.23/09
* Revision 1.3  1996/06/05 10:20:35  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.2  1996/04/11 15:22:09  cernlib
* Correct title handling
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IOPKS(ERRFIL)
*.===========>
*.
*.   This routine opens the HIGZ kernel system .
*.
*. _Input parameters:
*.
*.  INTEGER ERRFIL : LUN for error file .
*.
*..==========> (O.Couet)
+CDE, HILUN.
+CDE, HIVERS.
      CHARACTER*16 TCARD
      INTEGER ERRFIL,IASF(13)
      DATA IASF/13*1/
*.______________________________________
*
      CALL UHTOC(
     + 40HVERSION  1.28/07   22/05/02
+SELF, IF=GKS, IF=-CRAY.
     +,4,TCARD,16)
+SELF, IF=GKS, IF=CRAY.
     +,8,TCARD,16)
+SELF, IF=GKS.
      CHVERS = TCARD(9:16)
*
      LUNERR=ERRFIL
+SELF, IF=GKS, IF=GKSGRAL,DECGKS,UNIGKS,ATCGKS.
      IBUFA=0
      CALL GOPKS(ERRFIL,IBUFA)
+SELF, IF=GKS, IF=GKSBX.
      CALL GOPKS(ERRFIL,-1)
+SELF, IF=GKS, IF=PLOT10GKS,MGKS.
      CALL GOPKS(ERRFIL)
+SELF, IF=GKS, IF=-MGKS.
      CALL GSASF(IASF)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IOPWK, T=FORT.
* Revision 1.2  1996/06/05 10:20:36  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IOPWK(WKID,CONID,WTYPE)
*.===========>
*.
*.   This routine opens an HIGZ workstation .
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  INTEGER CONID : Connection identifier .
*.  INTEGER WTYPE : Workstation type .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
+SELF, IF=GKS, IF=UNIGKS.
+CDE, HILUN.
      CHARACTER*80 MSG
+SELF, IF=GKS, IF=SUNGKS.
      LOGICAL OPENED
+SELF, IF=GKS.
      INTEGER WKID,CONID,WTYPE
*.______________________________________
*
*
      IF(WKID.EQ.0)THEN
         CALL IGERR('Workstation identifier equal 0','IOPWK')
         RETURN
      ENDIF
      INOPWK=INOPWK+1
      ILOPWK(INOPWK)=WKID
      IWTYL(INOPWK)=WTYPE
      ACWKFL(INOPWK)=.FALSE.
      ICONID=CONID
+SELF, IF=GKS, IF=PSCRIPT.
*
*              PostScript Metafile
*
      IF(WTYPE.LT.0)THEN
         CALL IPINIT(WKID,ABS(CONID),WTYPE)
         RETURN
      ENDIF
*
+SELF, IF=GKS, IF=PLOT10GKS, IF=GKS, IF=-IBM.
      IF(WKID.LT.2)THEN
         CALL HGTCID('TT',IERROR,ICONID)
      ENDIF
+SELF, IF=GKS, IF=GKS, IF=UNIGKS.
*
*              Is the workstation available ?
*
      I=1
      CALL GQEWK(I,IERR,NUMB,IWTYP)
      MSG= ' HIGZ    -  ERROR XXX IN GQEWK CALL'
      WRITE(UNIT=MSG(19:21),FMT='(I3)') IERR
      IF(IERR.NE.0)GOTO 20
*
      DO 10 I=1,NUMB
         CALL GQEWK(I,IERR,N,IWTYP)
         IF(IERR.NE.0)GOTO 20
         IF(WTYPE.EQ.IWTYP)GOTO 30
   10 CONTINUE
*
      MSG= ' HIGZ    -  WORKSTATION XXXXXX NOT AVAILABLE'
      WRITE(UNIT=MSG(25:30),FMT='(I6)') WTYPE
   20 WRITE(UNIT=LUNERR,FMT='(A)') MSG
      CALL GECLKS
      STOP 12
*
*              Is the workstation 'OUTIN' ?
*
   30 CALL GQWKCA(WTYPE,IERR,ICAT)
      IF (ICAT.NE.2) THEN
         MSG= ' HIGZ    -  WORKSTATION XXXXXX NOT OUTIN CATEGORY'
         WRITE(UNIT=MSG(25:30),FMT='(I6)') WTYPE
         WRITE(UNIT=LUNERR,FMT='(A)') MSG
         CALL GECLKS
         STOP 12
      ENDIF
*
+SELF, IF=GKS, IF=SUNGKS.
      IF(WTYPE.EQ.3)THEN
         INQUIRE(ICONID,OPENED=OPENED)
         IF(.NOT.OPENED)OPEN(ICONID,FILE='SunGKS.moasc')
      ELSEIF(WTYPE.EQ.6)THEN
         INQUIRE(ICONID,OPENED=OPENED)
         IF(.NOT.OPENED)OPEN(ICONID,FILE='SunGKS.hpgl')
      ELSEIF(WTYPE.EQ.7)THEN
         INQUIRE(ICONID,OPENED=OPENED)
         IF(.NOT.OPENED)OPEN(ICONID,FILE='SunGKS.postscript')
      ELSEIF(WTYPE.EQ.8)THEN
         INQUIRE(ICONID,OPENED=OPENED)
         IF(.NOT.OPENED)OPEN(ICONID,FILE='SunGKS.cgmo')
      ELSEIF(WTYPE.EQ.10)THEN
         INQUIRE(ICONID,OPENED=OPENED)
         IF(.NOT.OPENED)OPEN(ICONID,FILE='SunGKS.mobin')
      ENDIF
+SELF, IF=GKS, IF=GKS.
      IF(GFLAG)THEN
         CALL GOPWK(WKID,ICONID,WTYPE)
         CALL GQCF(WTYPE,IERR,INBCOL,ICOLA,NPCI)
      ENDIF
+SELF, IF=GKS, IF=GKS, IF=DECGKS.
      IF(GFLAG.AND.WTYPE.GE.200
     +        .AND.WTYPE.LE.100000) CALL GSWKVP(WKID,0.,0.2,0.,0.2)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IPL, T=FORT.
* Revision 1.2  1996/06/05 10:20:37  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IPL(N,X,Y)
*.===========>
*.
*.   This routine draws a polyline . The line type from 12 to 15 are independent
*. from the underlaying basic graphics package .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points in the polyline .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*),XX(2),YY(2)
      DIMENSION XDOT(2),YDOT(2)
      LOGICAL ZSAV
      EQUIVALENCE (XOLD,XX(1)),(XNEW,XX(2))
      EQUIVALENCE (YOLD,YY(1)),(YNEW,YY(2))
      DATA XLSTEP,SMIN/0.2,0.0002/
*.______________________________________
*
      IF(N.LT.2)THEN
         CALL IGERR('Invalid number of points','IPL')
         RETURN
      ENDIF
*
      IF((ILN.GE.12).AND.(GFLAG.OR.PFLAG))THEN
         CALL IGSG(0)
         ZSAV=ZFLAG
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         NTSAV=INTR
         RATIO1=(RVXMAX-RVXMIN)/(RWXMAX-RWXMIN)
         RATIO2=(RVYMAX-RVYMIN)/(RWYMAX-RWYMIN)
         RWX1=RWXMIN
         RWY1=RWYMIN
         RVX1=RVXMIN
         RVY1=RVYMIN
         RVX2=RVXMAX
         RVY2=RVYMAX
         XLSTEP=RBSL
         SMIN=0.001*XLSTEP
         CALL ISELNT(0)
         ILNS=ILN
         CALL ISLN(1)
         IF((XLSTEP.LE.0.).OR.(XLSTEP.GT.1))XLSTEP=0.01
*
*              Possibly dashed lines drawn
*
   10    MODE=1
         IDOT=0
         SRES=XLSTEP
*
         DO 90  I=2,N
            XOLD=RATIO1*(X(I-1)-RWX1)+RVX1
            YOLD=RATIO2*(Y(I-1)-RWY1)+RVY1
*
            DXSTEP=RATIO1*(X(I)-RWX1)+RVX1-XOLD
            DYSTEP=RATIO2*(Y(I)-RWY1)+RVY1-YOLD
            ADX=ABS(DXSTEP)
            ADY=ABS(DYSTEP)
            IF(ADX.LE.SMIN)THEN
               STEP=ADY
               DSX=0.
               DSY=SIGN(1.,DYSTEP)
               GOTO 20
            ENDIF
            IF(ADY.LE.SMIN)THEN
               STEP=ADX
               DSX=SIGN(1.,DXSTEP)
               DSY=0.
               GOTO 20
            ENDIF
            STEP=SQRT(DXSTEP*DXSTEP+DYSTEP*DYSTEP)
            DSX=DXSTEP/STEP
            DSY=DYSTEP/STEP
   20       IF(STEP.LE.0.)GO TO 90
            DRES=STEP
*
   30       ST=SRES
            IF(ST.GT.DRES)ST=DRES
            SRES=SRES-ST
            DRES=DRES-ST
            XNEW=XOLD+ST*DSX
            YNEW=YOLD+ST*DSY
*
            IF(ICLIP.EQ.1)THEN
               ICL=IGCLIP(XX,YY,RVX1,RVX2,RVY1,RVY2)
               IF(ICL.EQ.0)GOTO 80
            ENDIF
*
            GO TO (40 ,40 ,50 ,60 ,70 ),ILNS-10
*
*              Dashed line _ _ _ _ _ _ _
*
   40       CONTINUE
            IF(MODE.NE.0)THEN
+SELF, IF=GKS, IF=PSCRIPT.
               IF(PFLAG)CALL IZPL(2,XX,YY)
+SELF, IF=GKS.
               IF(GFLAG)CALL GPL(2,XX,YY)
            ENDIF
            GO TO 80
*
*              Dash-dot line _._._._._.
*
   50       IF(MODE.EQ.0)GO TO 70
+SELF, IF=GKS, IF=PSCRIPT.
            IF(PFLAG)CALL IZPL(2,XX,YY)
+SELF, IF=GKS.
            IF(GFLAG)CALL GPL(2,XX,YY)
            GO TO 80
*
*              Dot-blank  . . . . . . .
*
   60       IF(MODE.EQ.0)GO TO 80
*
*              Dotted line  ............
*
   70       IF (SRES.LT.0.5*XLSTEP) IDOT=IDOT+1
            IF (IDOT.NE.1) GOTO 80
            XDOT(1)=XNEW-(0.5*XLSTEP-SRES)*DSX
            YDOT(1)=YNEW-(0.5*XLSTEP-SRES)*DSY
            MTS=IMK
            MCOL=IPMCI
            RMSC=RMKSC
            CALL ISMKSC(RLWSC)
            CALL ISMK(1)
            CALL ISPMCI(IPLCI)
            IF(GFLAG)CALL IPM(1,XDOT,YDOT)
+SELF, IF=GKS, IF=PSCRIPT.
            IF(PFLAG)CALL IZPM(1,XDOT,YDOT)
+SELF, IF=GKS.
            CALL ISMKSC(RMSC)
            CALL ISMK(MTS)
            CALL ISPMCI(MCOL)
*
   80       XOLD=XNEW
            YOLD=YNEW
            IF(SRES.LE.SMIN)THEN
               IDOT=0
               SRES=XLSTEP
               MODE=MODE+1
               IF(MODE.EQ.2)MODE=0
            ENDIF
            IF(DRES.GT.SMIN)GO TO 30
   90    CONTINUE
         CALL ISELNT(NTSAV)
         CALL ISLN(ILNS)
         ZFLAG=ZSAV
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      ELSE
         IF(GFLAG)THEN
            CALL IGSG(0)
            CALL GPL(N,X,Y)
         ENDIF
      ENDIF
+SELF, IF=GKS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZPL(N,X,Y)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IPM, T=FORT.
* Revision 1.2  1996/06/05 10:20:37  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IPM(N,X,Y)
*.===========>
*.
*.   This routines draws markers .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of markers .
*.  REAL X(N) : Markers X coordinates .
*.  REAL Y(N) : Markers Y coordinates .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*)
*.______________________________________
*
      IF(N.LT.1)THEN
         CALL IGERR('Invalid number of points','IPM')
         RETURN
      ENDIF
*
      IF(GFLAG.OR.PFLAG)THEN
         CALL IGSG(0)
         IF(IMK.LT.20)THEN
            IF(.NOT.GFLAG)GOTO 20
            CALL GPM(N,X,Y)
         ELSE
            CALL IGPM(N,X,Y,IMK)
         ENDIF
      ENDIF
*
   20 CONTINUE
+SELF, IF=GKS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZPM(N,X,Y)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IRQLC, T=FORT.
* Revision 1.3  1998/01/30 15:22:30  couet
* - APOLLO version removed
* Revision 1.2  1996/06/05 10:20:38  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IRQLC(WKID,LCN,ISTAT,TNR,XLOC,YLOC)
*.===========>
*.
*.   This routine returns the graphic cursor position in WC space in
*. XLOC and YLOC . The same position in the NDC space is available in
*. RQUEST(11) and RQUEST(12) . The normalization tranformation number
*. is returned in TNR . After a call to IRQLC the window coordinates are
*. available in RQUEST(20), RQUEST(21), RQUEST(22), and RQUEST(23). The
*. viewport coordinates are available in RQUEST(30), RQUEST(31),
*  RQUEST(32), and RQUEST(33). This routine computed the XLOC and YLOC
*. value according to value of the REDIT factor, but the value of
*. RQUEST(11) and RQUEST(12) do not care about the value of REDIT. The
*. REDIT factor is usefull for the graphics editor and the menu mode of
*. KUIP.
*.   The values of XLOC and YLOC are computed with the parameters stored
*. in the NT storage (HINT) if ZEBRA is not used, or if there no
*. displayed picture. If an HIGZ picture is displayed, only the NT
*. existing in this picture are used to compute the values of XLOC and
*. YLOC.
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  INTEGER LCN  : Input device number .
*.                 If LCN>10 then LCN=10*IPET+LNDNR
*.
*. _Output parameters:
*.
*.  INTEGER ISTAT : Return status: 0=BREAK, 1=OK .
*.  INTEGER TNR : Normalization transformation number .
*.  REAL XLOC YLOC : Cursor position in WC space .
*.
*..==========> (O.Couet)
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=GKS, IF=-ZEBRA.
+CDE, HIQUES.
+SELF, IF=GKS, IF=-NTC.
+CDE, HINT.
+SELF, IF=GKS.
+CDE, HILOC.
+CDE, HIATT.
+SELF, IF=GKS, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=GKS, IF=MAIL.
+CDE, HIFLAG.
+SELF, IF=GKS.
      INTEGER WKID,TNR
      CHARACTER*80 STR(4)
+SELF, IF=GKS, IF=SUNGKS.
      DIMENSION IA(10),RA(10)
      CHARACTER*1 CA
+SELF, IF=GKS.
*.______________________________________
*
+SELF, IF=GKS, IF=MAIL.
*
*              MAIL option
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(3I3)') 555,WKID,LCN
         CALL IMWRIT(1)
         READ (5,'(2I5,2E16.7)') ISTAT,TNR,XLOC,YLOC
         CALL IMWRIT(5)
         RETURN
      ENDIF
*
+SELF, IF=GKS.
      CALL IGSG(0)
      LCDNR=MOD(LCN,10)
      IPET=1
      LOCDEV=1
+SELF, IF=GKS, IF=-SUNGKS.
      LSTR=0
+SELF, IF=GKS, IF=SUNGKS.
      IF (IPET.LE.3) THEN
         IA(1)=1
         CALL GPREC(1,IA,0,RA,0,0,CA,4,IERR,LSTR,STR)
      ELSEIF (IPET.EQ.4) THEN
         IA(1)=1
         IA(2)=0
         IA(3)=0
         IA(4)=0
         IA(5)=1
         IA(6)=1
         IA(7)=0
         RA(1)=1
         CALL GPREC(7,ID1,1,RD1,0,0,CA,4,IERR,LSTR,STR)
      ELSEIF (IPET.EQ.5) THEN
         IA(1)=0
         IA(2)=1
         IA(3)=0
         IA(4)=0
         IA(5)=0
         IA(6)=1
         IA(7)=1
         IA(8)=0
         RA(1)=1
         CALL GPREC(8,ID1,1,RD1,0,0,CA,4,IERR,LSTR,STR)
      ENDIF
+SELF, IF=GKS, IF=ATCGKS.
      CALL GPREC(0,,0,,0,,CA,4,IERR,LSTR,STR)
+SELF, IF=GKS, IF=DECGKS.
      CALL GINLC(WKID,LOCDEV,0,OLDXP,OLDYP,IPET
     +,          RDVXMI,RDVXMA,RDVYMI,RDVYMA,LSTR,STR)
      LCDNR=LOCDEV
+SELF, IF=GKS, IF=-DECGKS.
      CALL GINLC(WKID,LOCDEV,0,OLDXP,OLDYP,IPET,0.,RMDSX,0.,RMDSY,
     +           LSTR,STR)
+SELF, IF=GKS.
      CALL GRQLC(WKID,LCDNR,ISTAT,TNR,RQUEST(11),RQUEST(12))
      IF(ISTAT.EQ.0)THEN
         RQUEST(11)=OLDXP
         RQUEST(12)=OLDYP
         RETURN
      ENDIF
      OLDXP=RQUEST(11)
      OLDYP=RQUEST(12)
*
      SCALE=1.
      IF(REDIT.NE.0.)SCALE=REDIT
*
      RQUEST(20)=0.
      RQUEST(21)=1.
      RQUEST(22)=0.
      RQUEST(23)=1.
      RQUEST(30)=0.
      RQUEST(31)=1.
      RQUEST(32)=0.
      RQUEST(33)=1.
      TNR=0
      XLOC=(RQUEST(11)+RDWXMI*REDIT)/SCALE
      YLOC=(RQUEST(12)+RDWYMI*REDIT)/SCALE
+SELF, IF=GKS, IF=ZEBRA.
*
*             There is displayed picture
*
      IF(LPICD.GT.0)THEN
         IPRIOO=IQ(LDNT0+3)
         NBNT=IQ(LPICD+8)-1
         LN=LQ(LDNT0)
         DO 10 I=1,NBNT
            IAWV=LDF+IQ(LN+2)
            IPRION=IQ(LN+3)
            RQUEST(20)=Q(IAWV)
            RQUEST(21)=Q(IAWV+1)
            RQUEST(22)=Q(IAWV+2)
            RQUEST(23)=Q(IAWV+3)
            RQUEST(30)=Q(IAWV+4)
            RQUEST(31)=Q(IAWV+5)
            RQUEST(32)=Q(IAWV+6)
            RQUEST(33)=Q(IAWV+7)
            IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +         (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +         (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +         (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
               IF(IPRION.GT.IPRIOO)THEN
                  XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +                 -RQUEST(30))
     +                 /(RQUEST(31)-RQUEST(30)))
     +                 *(RQUEST(21)-RQUEST(20))
     +                +RQUEST(20)
                  YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +                 -RQUEST(32))
     +                 /(RQUEST(33)-RQUEST(32)))
     +                 *(RQUEST(23)-RQUEST(22))
     +                 +RQUEST(22)
                  TNR=IQ(LN+1)
                  IPRIOO=IPRION
               ENDIF
            ENDIF
            LN=LQ(LN)
            IF(LN.EQ.0)RETURN
   10    CONTINUE
         RETURN
      ENDIF
+SELF, IF=GKS, IF=-NTC.
*
*             The computing of XLOC and YLOC in done with the parameters
*             stored in HINT.
*
      NBNT=NTSTOR(1)
      IPRIOO=NT0PRI
      DO 20 I=1,NBNT
         NNT=NTSTOR(2*I)
         CALL IZGNT(NNT,IFIND,IAWV,IPRION,IHPRIO)
         RQUEST(20)=WNVPST(IAWV)
         RQUEST(21)=WNVPST(IAWV+1)
         RQUEST(22)=WNVPST(IAWV+2)
         RQUEST(23)=WNVPST(IAWV+3)
         RQUEST(30)=WNVPST(IAWV+4)
         RQUEST(31)=WNVPST(IAWV+5)
         RQUEST(32)=WNVPST(IAWV+6)
         RQUEST(33)=WNVPST(IAWV+7)
         IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +      (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +      (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +      (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
            IF(IPRION.GT.IPRIOO)THEN
               XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +              -RQUEST(30))
     +              /(RQUEST(31)-RQUEST(30)))
     +              *(RQUEST(21)-RQUEST(20))
     +             +RQUEST(20)
               YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +              -RQUEST(32))
     +              /(RQUEST(33)-RQUEST(32)))
     +              *(RQUEST(23)-RQUEST(22))
     +              +RQUEST(22)
               TNR=NNT
               IPRIOO=IPRION
            ENDIF
         ENDIF
   20 CONTINUE
+SELF, IF=GKS, IF=NTC.
      IPRIOO = NT0PRI
      IEND   = IGNNXT(1)
   30 IF(IEND.EQ.0)THEN
         CALL IGNGET(NNT,IPRION,IHPRIO
     +,              RQUEST(20),RQUEST(21),RQUEST(22),RQUEST(23)
     +,              RQUEST(30),RQUEST(31),RQUEST(32),RQUEST(33),I3D)
         IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +      (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +      (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +      (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
            IF(IPRION.GT.IPRIOO)THEN
               XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +              -RQUEST(30))
     +              /(RQUEST(31)-RQUEST(30)))
     +              *(RQUEST(21)-RQUEST(20))
     +             +RQUEST(20)
               YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +              -RQUEST(32))
     +              /(RQUEST(33)-RQUEST(32)))
     +              *(RQUEST(23)-RQUEST(22))
     +              +RQUEST(22)
               ITNRI=NNT
               IPRIOO=IPRION
            ENDIF
         ENDIF
         IEND = IGNNXT(0)
         GOTO 30
      ENDIF
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IRQST, T=FORT.
* Revision 1.2  1996/06/05 10:20:39  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IRQST(IWKID,ISTD,ISTAT,L,STR)
*.===========>
*.
*.   This routine returns a character string typed on the keyboard .
*. An initialise string is done with the parameters RQUEST(81),
*. RQUEST(82), RQUEST(91), and RQUEST(92) given via the QUEST COMMON
*. if IWKID is less than 0, Otherwise the initialise string is not done
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  INTEGER ISTD : Locator device .
*.
*. _Output parameters:
*.
*.  INTEGER ISTAT : Return status : 0=BREAK, 1=OK .
*.  INTEGER L : Number of characters returned .
*.  CHARACTER STR : Character string returned .
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+SELF, IF=GKS, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=GKS, IF=MAIL.
+CDE, HIFLAG.
+SELF, IF=GKS.
      CHARACTER*(*) STR
+SELF, IF=GKS, IF=GKS.
      CHARACTER*80 STRGKS(4)
+SELF, IF=GKS, IF=SUNGKS.
      DIMENSION IA(10), RA(10)
      CHARACTER CA*1
+SELF, IF=GKS.
*.______________________________________
*
+SELF, IF=GKS, IF=MAIL.
*
*              MAIL option
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(3I3)') 556,ABS(IWKID),ISTD
         CALL IMWRIT(1)
         READ (5,'(2I5,A)') ISTAT,L,STR
         CALL IMWRIT(5)
         RETURN
      ENDIF
*
+SELF, IF=GKS.
      CALL IGSG(0)
      IF(IWKID.LT.0)THEN
         IIWKID=ABS(IWKID)
      ELSE
         IIWKID=IWKID
         GOTO 10
      ENDIF
      ILEN=LENOCC(STR)
      INIPOS=MAX(1,ILEN)
+SELF, IF=GKS, IF=GKS, IF=-SUNGKS.
      CALL GINST(IIWKID,1,ILEN,STR,1
     +,          RQUEST(81),RQUEST(82),RQUEST(91),RQUEST(92)
     +,          32,INIPOS,0,STRGKS)
+SELF, IF=GKS, IF=GKS, IF=SUNGKS.
      IA(1)=1
      CALL GPREC(1,IA,0,RA,0,0,CA,4,IERR,LSTGKS,STRGKS)
      CALL GINST(IIWKID,1,ILEN,STR,1
     +,          RQUEST(81),RQUEST(82),RQUEST(91),RQUEST(92)
     +,          32,INIPOS,LSTGKS,STRGKS)
+SELF, IF=GKS, IF=GKS.
 10   STR=' '
      CALL GRQST(IIWKID,ISTD,ISTAT,L,STR)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISCHH, T=FORT.
* Revision 1.2  1996/06/05 10:20:39  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISCHH(CHH)
*.===========>
*.
*.   This routine sets the character heigh .
*.
*. _Input parameters:
*.
*.  INTEGER CHH : Character heigh .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(CHH.EQ.RCHH)RETURN
      RCHH=CHH
      IF(GFLAG)CALL GSCHH(CHH)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ICHHCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISCHUP, T=FORT.
* Revision 1.2  1996/06/05 10:20:40  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:44  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISCHUP(CHUX,CHUY)
*.===========>
*.
*.   This routine sets the character up vector . This vector gives the text
*. inclination .
*.
*. _Input parameters:
*.
*.  REAL CHUX,CHUY : Character up vector coordinates .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF((CHUX.EQ.RCHUX).AND.(CHUY.EQ.RCHUY))RETURN
      RCHUX=CHUX
      RCHUY=CHUY
      IF(GFLAG)CALL GSCHUP(CHUX,CHUY)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF((RCHUX.EQ.0.).AND.(RCHUY.EQ.1.))THEN
         RANGLE=0.
      ELSEIF((RCHUX.EQ.-1.).AND.(RCHUY.EQ.0.))THEN
         RANGLE=90.
      ELSEIF((RCHUX.EQ.0.).AND.(RCHUY.EQ.-1.))THEN
         RANGLE=180.
      ELSEIF((RCHUX.EQ.1.).AND.(RCHUY.EQ.0.))THEN
         RANGLE=270.
      ELSE
         RANGLE=((ACOS(RCHUX/SQRT(RCHUX**2+RCHUY**2))*180.)
     +           /3.14159)-90.
         IF(RCHUY.LT.0.)RANGLE=180.-RANGLE
         IF(ABS(RANGLE).LE.0.01)RANGLE=0.
      ENDIF
      IF(GLFLAG)CALL IZATT(IANGCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISCLIP, T=FORT.
* Revision 1.2  1996/06/05 10:20:41  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISCLIP(CLSW)
*.===========>
*.
*.   This routine sets the window (in the world space) clipping on or off .
*.
*. _Input parameters:
*.
*.  INTEGER CLSW : Clipping indicator .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      INTEGER CLSW
*.______________________________________
*
+SELF, IF=GKS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZSCLI(CLSW)
+SELF, IF=GKS.
      IF(CLSW.EQ.ICLIP)RETURN
      ICLIP=CLSW
      IF(GFLAG)CALL GSCLIP(CLSW)
*
      END
+SELF.
+DECK,  ISCR, T=FORT.
* Revision 1.2  1996/06/05 10:20:41  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISCR(IWKID,ICI,CR,CG,CB)
*.===========>
*.
*.   This routine sets the color representation .
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  INTEGER CI : Color index .
*.  REAL CR : Red .
*.  REAL CG : Green .
*.  REAL CB : Blue .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HILUT.
*.______________________________________
*
      I=MIN(NBCLUT-1,ABS(ICI))+1
      REDLUT(I)=CR
      GRNLUT(I)=CG
      BLULUT(I)=CB
      CALL IGSG(0)
      IF(GFLAG)CALL GSCR(IWKID,ICI,CR,CG,CB)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZSCOR(IWKID,ICI,CR,CG,CB)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISELNT, T=FORT.
* Revision 1.2  1996/06/05 10:20:42  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISELNT(NT)
*.===========>
*.
*.   This routine selects the transformation number NT and its priority
*. becomes the highest .
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalization transformation number (0<=NT<NBNTMX).
*.
*..==========> (O.Couet)
+SELF, IF=GKS, IF=-NTC.
+CDE, HINT.
+SELF, IF=GKS.
+CDE, HIFLAG.
+CDE, HIATT.
*.______________________________________
*
      SCALE=1.
      IF(REDIT.NE.0.)SCALE=REDIT
*
+SELF, IF=GKS, IF=-NTC.
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
*              Transformation No 0
*
      IF(NT.EQ.0)THEN
         NT0PRI=IHPRIO+1
         RWXMIN=0.
         RWYMIN=0.
         RWXMAX=1.
         RWYMAX=1.
         RVXMIN=0.
         RVYMIN=0.
         RVXMAX=1.
         RVYMAX=1.
         IF(GFLAG)THEN
            CALL GSWN(1,RWXMIN,RWXMAX,RWYMIN,RWYMAX)
            CALL GSVP(1,RVXMIN*SCALE-(RDWXMI*REDIT)
     +,                 RVXMAX*SCALE-(RDWXMI*REDIT)
     +,                 RVYMIN*SCALE-(RDWYMI*REDIT)
     +,                 RVYMAX*SCALE-(RDWYMI*REDIT))
            CALL GSELNT(1)
         ENDIF
         GOTO 10
      ENDIF
*
*              NT exits in the main transformation storage
*
      IF(IFIND.NE.0)THEN
         RWXMIN=WNVPST(IAWV)
         RWYMIN=WNVPST(IAWV+2)
         RWXMAX=WNVPST(IAWV+1)
         RWYMAX=WNVPST(IAWV+3)
         RVXMIN=WNVPST(IAWV+4)
         RVYMIN=WNVPST(IAWV+6)
         RVXMAX=WNVPST(IAWV+5)
         RVYMAX=WNVPST(IAWV+7)
         NTSTOR(IFIND)=IHPRIO+1
         IF(GFLAG)THEN
            CALL GSWN(1,RWXMIN,RWXMAX,RWYMIN,RWYMAX)
            CALL GSVP(1,RVXMIN*SCALE-(RDWXMI*REDIT)
     +,                 RVXMAX*SCALE-(RDWXMI*REDIT)
     +,                 RVYMIN*SCALE-(RDWYMI*REDIT)
     +,                 RVYMAX*SCALE-(RDWYMI*REDIT))
            CALL GSELNT(1)
         ENDIF
*
*              NT does not exit in the main transformation storage
*
      ELSE
         RWXMIN=0.
         RWYMIN=0.
         RWXMAX=1.
         RWYMAX=1.
         RVXMIN=0.
         RVYMIN=0.
         RVXMAX=1.
         RVYMAX=1.
         IF(GFLAG)THEN
            CALL GSWN(1,RWXMIN,RWXMAX,RWYMIN,RWYMAX)
            CALL GSVP(1,RVXMIN*SCALE-(RDWXMI*REDIT)
     +,                 RVXMAX*SCALE-(RDWXMI*REDIT)
     +,                 RVYMIN*SCALE-(RDWYMI*REDIT)
     +,                 RVYMAX*SCALE-(RDWYMI*REDIT))
            CALL GSELNT(1)
         ENDIF
         NBNT=NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISELNT')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2)=NT
         NTSTOR(2*NBNT+3)=IHPRIO+1
         WNVPST(8*NBNT+1)=0.
         WNVPST(8*NBNT+2)=1.
         WNVPST(8*NBNT+3)=0.
         WNVPST(8*NBNT+4)=1.
         WNVPST(8*NBNT+5)=0.
         WNVPST(8*NBNT+6)=1.
         WNVPST(8*NBNT+7)=0.
         WNVPST(8*NBNT+8)=1.
         NTSTOR(1)=NTSTOR(1)+1
      ENDIF
   10 CONTINUE
*
+SELF, IF=GKS, IF=NTC.
      IF(IGNSCU(NT).EQ.0)CALL IGNCRE(NT)
      CALL IGNGET(I0,I1,IHPRIO
     +,           RWXMIN,RWXMAX,RWYMIN,RWYMAX
     +,           RVXMIN,RVXMAX,RVYMIN,RVYMAX,I3D)
      CALL IGNSPR(IHPRIO+1)
      IF(GFLAG)THEN
         CALL GSWN(1,RWXMIN,RWXMAX,RWYMIN,RWYMAX)
         CALL GSVP(1,RVXMIN*SCALE-(RDWXMI*REDIT)
     +,              RVXMAX*SCALE-(RDWXMI*REDIT)
     +,              RVYMIN*SCALE-(RDWYMI*REDIT)
     +,              RVYMAX*SCALE-(RDWYMI*REDIT))
         CALL GSELNT(1)
      ENDIF
      IF(I3D.NE.0)CALL IGSVIE
*
+SELF, IF=GKS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZSELN(NT)
+SELF, IF=GKS.
      INTR=NT
      CALL ISCLIP(ICLIP)
*
      END
+SELF.
+DECK,  ISFACI, T=FORT.
* Revision 1.2  1996/06/05 10:20:43  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISFACI(ICOLI)
*.===========>
*.
*.   This routine sets the fill area color index .
*.
*. _Input parameters:
*.
*.  INTEGER COLI : Fill area color index .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(ICOLI.EQ.IFACI)RETURN
      IFACI=ICOLI
      IF(GFLAG)CALL GSFACI(ICOLI)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFACCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISFAIS, T=FORT.
* Revision 1.2  1996/06/05 10:20:43  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISFAIS(INTS)
*.===========>
*.
*.   This routine sets the fill area interior style .
*.
*. _Input parameters:
*.
*.  INTEGER INTS : Interior style .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(INTS.EQ.IFAIS)RETURN
      IF((INTS.LT.0).OR.(INTS.GT.3))THEN
         CALL IGERR('Fill area interior style must be > -1 and < 4'
     +,             'ISFAIS')
         RETURN
      ENDIF
      IFAIS=INTS
+SELF, IF=GKS, IF=MGKS.
      IF(GFLAG.AND.(IFAIS.LE.1))CALL GSFAIS(INTS)
+SELF, IF=GKS, IF=-MGKS.
      IF(GFLAG)CALL GSFAIS(INTS)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFAICO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISFASI, T=FORT.
* Revision 1.2  1996/06/05 10:20:44  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISFASI(ISTYL)
*.===========>
*.
*.   This routine sets the fill area style index .
*.
*. _Input parameters:
*.
*.  INTEGER ISTYL : Style index .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(ISTYL.EQ.IFASI)RETURN
      IFASI=ISTYL
+SELF, IF=GKS, IF=MGKS.
      IF(GFLAG.AND.(IFASI.GE.2).AND.(IFASI.LE.3))CALL GSFAIS(IFASI)
+SELF, IF=GKS, IF=-MGKS.
      IF(GFLAG)CALL GSFASI(ISTYL)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFASCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISLN, T=FORT.
* Revision 1.2  1996/06/05 10:20:44  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISLN(LTYPE)
*.===========>
*.
*.   This routine sets the line type .
*.
*. _Input parameters:
*.
*.  INTEGER LTYPE : Line type .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(LTYPE.EQ.ILN)RETURN
      ILN=LTYPE
      IF(GFLAG)CALL GSLN(LTYPE)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ILNCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISLWSC, T=FORT.
* Revision 1.2  1996/06/05 10:20:54  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:45  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISLWSC(WIDTH)
*.===========>
*.
*.   The routine sets the line width scale factor .
*.
*. _Input parameters:
*.
*.  REAL LWIDTH : Line width .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(WIDTH.EQ.RLWSC)RETURN
      RLWSC=WIDTH
      IF(GFLAG)CALL GSLWSC(WIDTH)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ILWSCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISMK, T=FORT.
* Revision 1.2  1996/06/05 10:20:55  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISMK(MTYPE)
*.===========>
*.
*.   This routine sets the marker type .
*.
*. _Input parameters:
*.
*.  INTEGER MTYPE : Marker type .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(MTYPE.EQ.IMK.OR.MTYPE.GT.31)RETURN
      IMK=MTYPE
      IF(GFLAG)CALL GSMK(MTYPE)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IMKCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISMKSC, T=FORT.
* Revision 1.2  1996/06/05 10:20:55  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISMKSC(RMSCF)
*.===========>
*.
*.  This routine sets the marker scale factor .
*.
*. _Input parameters:
*.
*.  REAL MSCF : Marker scale factor .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(RMSCF.EQ.RMKSC)RETURN
      RMKSC=RMSCF
+SELF, IF=GKS, IF=-MGKS.
      IF(GFLAG)CALL GSMKSC(RMSCF)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IMKSCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISPLCI, T=FORT.
* Revision 1.2  1996/06/05 10:20:56  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISPLCI(ICOLI)
*.===========>
*.
*.   This routine sets the polyline color index .
*.
*. _Input parameters:
*.
*.  INTEGER COLI : Color index .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(ICOLI.EQ.IPLCI)RETURN
      IPLCI=ICOLI
      IF(GFLAG)CALL GSPLCI(ICOLI)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IPLCCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISPMCI, T=FORT.
* Revision 1.2  1996/06/05 10:20:57  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISPMCI(ICOLI)
*.===========>
*.
*.   This routine sets the polymarker color index .
*.
*. _Input parameters:
*.
*.  INTEGER COLI : Color index .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(ICOLI.EQ.IPMCI)RETURN
      IPMCI=ICOLI
      IF(GFLAG)CALL GSPMCI(ICOLI)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IPMCCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISTXAL, T=FORT.
* Revision 1.2  1996/06/05 10:20:57  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISTXAL(JTXALH,JTXALV)
*.===========>
*.
*.   This routine sets the text alignment .
*.
*. _Input parameters:
*.
*.  INTEGER TXALH : Horizontal alignment .
*.  INTEGER TXALV : Vertical alignment .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF((JTXALH.EQ.ITXALH).AND.(JTXALV.EQ.ITXALV))RETURN
      ITXALH=JTXALH
      ITXALV=JTXALV
      IF(GFLAG)CALL GSTXAL(JTXALH,JTXALV)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      ITXALG=10*JTXALH+JTXALV
      IF(GLFLAG)CALL IZATT(ITXACO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISTXCI, T=FORT.
* Revision 1.2  1996/06/05 10:20:59  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISTXCI(ICOLI)
*.===========>
*.
*.   This routine sets the text color index .
*.
*. _Input parameters:
*.
*.  INTEGER COLI : Color index .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF(ICOLI.EQ.ITXCI)RETURN
      ITXCI=ICOLI
      IF(GFLAG)CALL GSTXCI(ICOLI)
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ITXCCO)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISTXFP, T=FORT.
* Revision 1.3  1998/01/30 15:22:31  couet
* - APOLLO version removed
* Revision 1.2  1996/06/05 10:21:00  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
* SUN Version available
      SUBROUTINE ISTXFP(JFONT,JPREC)
*.===========>
*.
*.   This routine sets the text font and precision .
*.
*. _Input parameters:
*.
*.  INTEGER FONT : Text font .
*.  INTEGER PREC : Text precision .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+SELF, IF=GKS, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=GKS.
+CDE, HIFLAG.
*.______________________________________
*
      IF((JFONT.EQ.IFONT).AND.(JPREC.EQ.IPREC))RETURN
      IFONT=JFONT
      IPREC=JPREC
+SELF, IF=GKS, IF=ZEBRA,MAIL.
      IFTPR=10*JFONT+ISIGN(1,JFONT)*JPREC
      IF(GLFLAG)CALL IZATT(ITXFCO)
+SELF, IF=GKS.
      IF((JFONT.EQ.0).AND.(JPREC.EQ.2))RETURN
      IF(GFLAG)CALL GSTXFP(JFONT,JPREC)
*
      END
+SELF.
+DECK,  ISVP, T=FORT.
* Revision 1.2  1996/06/05 10:21:01  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISVP(NT,XX1,XX2,YY1,YY2)
*.===========>
*.
*.   This routine sets the transformation normalisation viewport NT .
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalization transformation number (0<=NT<NBNTMX).
*.  REAL X1,Y1 : X,Y down left corner viewport coordinates .
*.  REAL X2,Y2 : X,Y right up corner viewport coordinates .
*.
*..==========> (O.Couet)
+SELF, IF=GKS, IF=-NTC.
+CDE, HINT.
+SELF, IF=GKS.
+CDE, HIFLAG.
+CDE, HIATT.
*.______________________________________
*
*              Verify the viewport parameters
*
      X1 = XX1
      X2 = XX2
      Y1 = YY1
      Y2 = YY2
      IF((X1.LT.0).OR.(X1.GT.1)
     +            .OR.
     +   (X2.LT.0).OR.(X2.GT.1)
     +            .OR.
     +   (Y1.LT.0).OR.(Y1.GT.1)
     +            .OR.
     +   (Y2.LT.0).OR.(Y2.GT.1)
     +            .OR.
     +   (Y1.GE.Y2).OR.(X1.GE.X2))THEN
         CALL IGERR('Invalid viewport definition','ISVP')
         RETURN
      ENDIF
      IF(NT.EQ.0)RETURN
*
      SCALE = 1.
      IF(REDIT.NE.0.)SCALE = REDIT
+SELF, IF=GKS, IF=-NTC.
*
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
*              NT exits in the main transformation storage
*
      IF(IFIND.NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF(GFLAG)THEN
               CALL GSVP(1
     +,                  X1*SCALE-(RDWXMI*REDIT)
     +,                  X2*SCALE-(RDWXMI*REDIT)
     +,                  Y1*SCALE-(RDWYMI*REDIT)
     +,                  Y2*SCALE-(RDWYMI*REDIT))
            ENDIF
            RVXMIN = X1
            RVYMIN = Y1
            RVXMAX = X2
            RVYMAX = Y2
         ENDIF
         WNVPST(IAWV+4) = X1
         WNVPST(IAWV+5) = X2
         WNVPST(IAWV+6) = Y1
         WNVPST(IAWV+7) = Y2
*
*              NT does not exit in the main transformation storage
*
      ELSE
         NBNT=NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISVP')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2) = NT
         WNVPST(8*NBNT+1) = 0.
         WNVPST(8*NBNT+2) = 1.
         WNVPST(8*NBNT+3) = 0.
         WNVPST(8*NBNT+4) = 1.
         WNVPST(8*NBNT+5) = X1
         WNVPST(8*NBNT+6) = X2
         WNVPST(8*NBNT+7) = Y1
         WNVPST(8*NBNT+8) = Y2
         NTSTOR(1)        = NTSTOR(1)+1
      ENDIF
+SELF, IF=GKS, IF=NTC.
      IF(IGNSCU(NT).NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF(GFLAG)THEN
               CALL GSVP(1
     +,                  X1*SCALE-(RDWXMI*REDIT)
     +,                  X2*SCALE-(RDWXMI*REDIT)
     +,                  Y1*SCALE-(RDWYMI*REDIT)
     +,                  Y2*SCALE-(RDWYMI*REDIT))
            ENDIF
            RVXMIN = X1
            RVYMIN = Y1
            RVXMAX = X2
            RVYMAX = Y2
         ENDIF
      ELSE
         CALL IGNCRE(NT)
      ENDIF
      CALL IGNSVP(X1,X2,Y1,Y2)
+SELF, IF=GKS.
      END
+SELF.
+DECK,  ISWKVP, T=FORT.
* Revision 1.2  1996/06/05 10:21:02  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISWKVP(WKID,X1,X2,Y1,Y2)
*.===========>
*.
*.   This routine sets the workstation transformation viewport .
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  REAL X1,Y1 : X,Y down left corner viewport coordinates .
*.  REAL X2,Y2 : X,Y right up corner viewport coordinates .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
      INTEGER WKID
*.______________________________________
*
      RDVXMI=X1
      RDVXMA=X2
      RDVYMI=Y1
      RDVYMA=Y2
      IF(IGIWTY(WKID).LT.0)RETURN
*
+SELF, IF=GKS, IF=GKS.
      IF(GFLAG)CALL GSWKVP(WKID,X1,X2,Y1,Y2)
+SELF, IF=GKS.
*
       END
+SELF.
+DECK,  ISWKWN, T=FORT.
* Revision 1.2  1996/06/05 10:21:03  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISWKWN(WKID,X1,X2,Y1,Y2)
*.===========>
*.
*.   This routine sets the workstation transformation window .
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  REAL X1,Y1 : X,Y down left corner window coordinates .
*.  REAL X2,Y2 : X,Y right up corner window coordinates .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
      INTEGER WKID
*.______________________________________
*
      IF((X1.LT.0).OR.(X1.GT.1)
     +            .OR.
     +   (X2.LT.0).OR.(X2.GT.1)
     +            .OR.
     +   (Y1.LT.0).OR.(Y1.GT.1)
     +            .OR.
     +   (Y2.LT.0).OR.(Y2.GT.1))THEN
         CALL IGERR('Bad window or viewport size','ISWKWN')
         RETURN
      ENDIF
*
      RDWXMI=X1
      RDWXMA=X2
      RDWYMI=Y1
      RDWYMA=Y2
      IF(IGIWTY(WKID).LT.0)RETURN
*
+SELF, IF=GKS, IF=GKS.
      IF(GFLAG)CALL GSWKWN(WKID,X1,X2,Y1,Y2)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ISWN, T=FORT.
* Revision 1.2  1996/06/05 10:21:04  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ISWN(NT,XX1,XX2,YY1,YY2)
*.===========>
*.
*.   This routine sets the window coordinates of the transformation NT .
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalization transformation number (0<=NT<NBNTMX).
*.  REAL X1,Y1 : X,Y down left corner window coordinates in WC space .
*.  REAL X2,Y2 : X,Y right up corner window coordinates in WC space .
*.
*..==========> (O.Couet)
+SELF, IF=GKS, IF=-NTC.
+CDE, HINT.
+SELF, IF=GKS.
+CDE, HIFLAG.
+CDE, HIATT.
*.______________________________________
*
      IF(NT.EQ.0)RETURN
*
      X1 = XX1
      X2 = XX2
      Y1 = YY1
      Y2 = YY2
*
+SELF, IF=GKS, IF=-NTC.
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
*              NT exits in the main transformation storage
*
      IF(IFIND.NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF(GFLAG)CALL GSWN(1,X1,X2,Y1,Y2)
            RWXMIN = X1
            RWYMIN = Y1
            RWXMAX = X2
            RWYMAX = Y2
         ENDIF
         WNVPST(IAWV)   = X1
         WNVPST(IAWV+1) = X2
         WNVPST(IAWV+2) = Y1
         WNVPST(IAWV+3) = Y2
*
*              NT does not exit in the main transformation storage
*
      ELSE
         NBNT = NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISWN')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2) = NT
         WNVPST(8*NBNT+1) = X1
         WNVPST(8*NBNT+2) = X2
         WNVPST(8*NBNT+3) = Y1
         WNVPST(8*NBNT+4) = Y2
         WNVPST(8*NBNT+5) = 0.
         WNVPST(8*NBNT+6) = 1.
         WNVPST(8*NBNT+7) = 0.
         WNVPST(8*NBNT+8) = 1.
         NTSTOR(1)        = NTSTOR(1)+1
      ENDIF
+SELF, IF=GKS, IF=NTC.
      IF(IGNSCU(NT).NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF(GFLAG)CALL GSWN(1,X1,X2,Y1,Y2)
            RWXMIN = X1
            RWYMIN = Y1
            RWXMAX = X2
            RWYMAX = Y2
         ENDIF
      ELSE
         CALL IGNCRE(NT)
      ENDIF
      CALL IGNSWN(X1,X2,Y1,Y2)
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  ITX, T=FORT.
* Revision 1.2  1996/06/05 10:21:04  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE ITX(X,Y,CHARS)
*.===========>
*.
*.   This routine draws a text at the position X,Y .
*.
*. _Input parameters:
*.
*.  REAL X,Y : Position of the text .
*.  CHARACTER CHARS : Text .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
      CHARACTER*(*) CHARS
      CHARACTER*1 CHOPT
      LOGICAL ZFSAV,PFSAV
*.______________________________________
*
      ILEN=LENOCC(CHARS)
      IF(ILEN.EQ.0)RETURN
      IF(GFLAG)THEN
         CALL IGSG(0)
         IF((IFONT.EQ.0.AND.IPREC.EQ.2).OR.
     +      (IFONT.LT.0.AND.IFONT.GT.-25.AND.IPREC.EQ.1))THEN
            IF((ITXALH.EQ.0).OR.(ITXALH.EQ.1))CHOPT='L'
            IF(ITXALH.EQ.2)THEN
               CHOPT = 'C'
            ELSEIF(ITXALH.EQ.3)THEN
               CHOPT = 'R'
            ELSE
               CHOPT = 'L'
            ENDIF
            IF((ITXALV.EQ.2).OR.(ITXALV.EQ.1))THEN
               YY = Y-RCHH*COS((3.14159/180.)*RANGLE)
               XX = X+RCHH*SIN((3.14159/180.)*RANGLE)
            ELSEIF(ITXALV.EQ.3)THEN
               YY = Y-(RCHH/2.)*COS((3.14159/180.)*RANGLE)
               XX = X+(RCHH/2.)*SIN((3.14159/180.)*RANGLE)
            ELSE
               YY = Y
               XX = X
            ENDIF
            ZFSAV  = ZFLAG
            ZFLAG  = .FALSE.
            PFSAV  = PFLAG
            PFLAG  = .FALSE.
            GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
            CALL IGTEXT(XX,YY,CHARS,RCHH,RANGLE,CHOPT)
            ZFLAG  = ZFSAV
            PFLAG  = PFSAV
            GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
         ELSE
            CALL GTX(X,Y,CHARS(1:ILEN))
         ENDIF
      ENDIF
+SELF, IF=GKS, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZTX(X,Y,CHARS(1:ILEN))
+SELF, IF=GKS.
*
      END
+SELF.
+DECK,  IUWK, T=FORT.
* Revision 1.2  1996/06/05 10:21:05  cernlib
* Move pilot.h before the ifdef for GKS
* Revision 1.1.1.1  1996/02/14 13:10:46  mclareni
* Higz

+SELF, IF=GKS.
      SUBROUTINE IUWK(IWKID,IRFLG)
*.===========>
*.
*.   Update workstation IWKID. Send all buffered output to the
*. screen and process pending changes in the view.
*.
*. _Input parameters:
*.
*.  INTEGER IWKID : Workstation identifier (0= all workstation)
*.  INTEGER IRFLG : Regeneration flag:
*.                 0 = postpone update workstation (GKS only)
*.                 1 = refresh entire display
*.                 2 = update current view
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
*.______________________________________
*
      IF(IWKID.NE.0)THEN
         IF(IGIWTY(IWKID).GT.0.AND.GFLAG)CALL GUWK(IWKID,IRFLG)
      ELSE
         DO 10 I=1,INOPWK
            IF(IGIWTY(ILOPWK(I)).GT.0.AND.GFLAG)
     +         CALL GUWK(ILOPWK(I),IRFLG)
   10    CONTINUE
      ENDIF
*
      END
+SELF.
+PATCH, IG3.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
SRCS_F=	 iatr3.F ifa3.F igbrik.F igcone.F igcyl.F igsphe.F \ @@\
	igtcop.F igtini.F igtmul.F igtnor.F igtor.F igtran.F igtref.F \ @@\
	igtrot.F igtsca.F igttra.F ipl3.F ipm3.F ipm3id.F isvp3.F \ @@\
	iswn3.F itx3.F

SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  IATR3, T=FORT.
* Revision 1.3  1998/01/28 11:21:46  couet
* - is in fact used. but should not be. Need a closer look to remove it
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IATR3(X,Y,Z,XX,YY,ZZ,TEXT)
+CDE, HIATT.
      CHARACTER*(*) TEXT
      IF (IDIM.EQ.3) THEN
+SELF, IF=PHIGS.
         CALL PATR3(X,Y,Z,XX,YY,ZZ,TEXT)
+SELF.
      ENDIF
*
      END
+DECK,  IFA3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IFA3(N,X,Y,Z)
+CDE, HIATT.
+CDE, HIGRAF.
+CDE, HI3D.
      DIMENSION X(*),Y(*),Z(*)
      IF (IDIM.EQ.3) THEN
+SELF, IF=PHIGS.
         CALL PFA3(N,X,Y,Z)
+SELF.
      ELSE
         NGRAF = N
         IF(N.GT.NPMAX)THEN
           CALL IGERR('Too many points','IFA3')
           NGRAF = NPMAX
         ENDIF
         DO 10 I=1,NGRAF
            XGRAF(I) = AWNX*X(I)+BWNX*Y(I)+CWNX*Z(I)+DWNX
            YGRAF(I) = AWNY*X(I)+BWNY*Y(I)+CWNY*Z(I)+DWNY
            ZGRAF(I) = AWNZ*X(I)+BWNZ*Y(I)+CWNZ*Z(I)+DWNZ
   10    CONTINUE
         IF (IZBUF.NE.0) THEN
+SELF, IF=ZBUF.
            CALL IHZFIL(IFACI,NGRAF,XGRAF,YGRAF,ZGRAF)
+SELF.
         ELSE
            CALL IFA(NGRAF,XGRAF,YGRAF)
         ENDIF
      ENDIF
*
      END
+DECK,  IFAF3, T=FORT.
* Revision 1.1  1999/10/20 14:12:57  couet
* - ifaf3.F needed in ig3
* Higz

      subroutine ifaf3(n,x,y,z,f)
************************************************************************
*
************************************************************************
      real x(*),y(*),z(*),f(*),p(3)
      real xx(30),yy(30),zz(30)
*-
      do i=1,n
        p(1) = x(i)
        p(2) = y(i)
        p(3) = z(i)
        call ihwton(p,p)
        xx(i) = p(1)
        yy(i) = p(2)
        zz(i) = p(3)
      end do

*      znorm = (xx(3)-xx(1))*(yy(4)-yy(2)) - (xx(4)-xx(2))*(yy(3)-yy(1))
*      if (znorm .le. 0) return

      call ihzsha(n,xx,yy,zz,f)
      end

+DECK,  IGBRIK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IGBRIK(LIGHT,T,DX,DY,DZ)
************************************************************************
*                                                                      *
* Name: IGBRIK                                     Date:    10.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Draw 3D box                                                *
*                                                                      *
************************************************************************
      INTEGER IFACE(4,6)
      REAL    T(4,3),P(3,8),ANORM(3,6),AN(3)
      REAL    X(4),Y(4),Z(4),F(4)
      DATA    IFACE /1,2,6,5,    2,3,7,6,    3,4,8,7,   4,1,5,8,
     +               4,3,2,1,    5,6,7,8/
      DATA    ANORM /0.,-1.,0.,  1.,0.,0.,  0.,1.,0.,  -1.,0.,0.,
     +               0.,0.,-1.,  0.,0.,1./
*-
**       S E T   V E R T I C E S
*
      P(1,1) = 0.
      P(2,1) = 0.
      P(1,2) = DX
      P(2,2) = 0.
      P(1,3) = DX
      P(2,3) = DY
      P(1,4) = 0.
      P(2,4) = DY
      DO 100 I=1,4
        P(3,I)   = 0.
        P(1,I+4) = P(1,I)
        P(2,I+4) = P(2,I)
        P(3,I+4) = DZ
  100 CONTINUE
*
**      T R A N S F O R M   V E R T I C E S
*
      DO 200 I=1,8
        CALL IGTRAN(P(1,I),T,P(1,I))
  200 CONTINUE
*
**      D R A W   F A C E S
*
      DO 320 I=1,6
        DO 310 K=1,4
          N    = IFACE(K,I)
          X(K) = P(1,N)
          Y(K) = P(2,N)
          Z(K) = P(3,N)
  310   CONTINUE
        IF (LIGHT .NE. 0) THEN
          CALL IGTNOR(ANORM(1,I),T,AN)
          CALL IHLUMI(AN,F(1))
          F(2) = F(1)
          F(3) = F(1)
          F(4) = F(1)
          CALL IFAF3(4,X,Y,Z,F)
        ELSE
          CALL IFA3(4,X,Y,Z)
        END IF
  320 CONTINUE
      END
+DECK,  IGCONE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IGCONE(LIGHT,T,H,R1,R2,NSTEP)
************************************************************************
*                                                                      *
* Name: IGCONE                                     Date:    10.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Draw cone                                                  *
*                                                                      *
************************************************************************
      PARAMETER (NMAX=72)
      REAL      T(4,3),P1(3,NMAX+1),P2(3,NMAX+1)
      REAL      X(NMAX),Y(NMAX),Z(NMAX),F(NMAX),ANORM(3)
*-
      IF (NSTEP.LT.3 .OR. NSTEP.GT.NMAX) RETURN
      ANG = ATAN(1.)*8. / NSTEP
*
**       S E T   V E R T I C E S
*
      DO 100 I=1,NSTEP+1
        IF (I.EQ.1 .OR. I.EQ.NSTEP+1) THEN
          COSA   = 1.
          SINA   = 0.
        ELSE
          COSA   = COS((I-1)*ANG)
          SINA   = SIN((I-1)*ANG)
        END IF
        P1(1,I) = R1*COSA
        P1(2,I) = R1*SINA
        P1(3,I) = 0.
        P2(1,I) = R2*COSA
        P2(2,I) = R2*SINA
        P2(3,I) = H
  100 CONTINUE
*
**      T R A N S F O R M   V E R T I C E S
*
      DO 200 I=1,NSTEP+1
        CALL IGTRAN(P1(1,I),T,P1(1,I))
        CALL IGTRAN(P2(1,I),T,P2(1,I))
  200 CONTINUE
*
**      D R A W   L O W E R   F A C E
*
      IF (R1 .NE. 0.) THEN
        IF (LIGHT .NE. 0) THEN
          ANORM(1) = 0.
          ANORM(2) = 0.
          ANORM(3) =-1.
          CALL IGTNOR(ANORM,T,ANORM)
          CALL IHLUMI(ANORM,F(1))
        END IF
        DO 310 I=1,NSTEP
          X(I) = P1(1,NSTEP+1-I)
          Y(I) = P1(2,NSTEP+1-I)
          Z(I) = P1(3,NSTEP+1-I)
          IF (LIGHT .NE. 0) F(I) = F(1)
  310   CONTINUE
        IF (LIGHT .NE. 0) THEN
          CALL IFAF3(NSTEP,X,Y,Z,F)
        ELSE
          CALL IFA3(NSTEP,X,Y,Z)
        END IF
      END IF
*
**      D R A W   U P P E R   F A C E
*
      IF (R1 .NE. 0.) THEN
        IF (LIGHT .NE. 0) THEN
          ANORM(1) = 0.
          ANORM(2) = 0.
          ANORM(3) = 1.
          CALL IGTNOR(ANORM,T,ANORM)
          CALL IHLUMI(ANORM,F(1))
        END IF
        DO 320 I=1,NSTEP
          X(I) = P2(1,I)
          Y(I) = P2(2,I)
          Z(I) = P2(3,I)
          IF (LIGHT .NE. 0) F(I) = F(1)
  320   CONTINUE
        IF (LIGHT .NE. 0) THEN
          CALL IFAF3(NSTEP,X,Y,Z,F)
        ELSE
          CALL IFA3(NSTEP,X,Y,Z)
        END IF
      END IF
*
**      D R A W   S I D E   F A C E S
*
      DO 400 I=1,NSTEP
        X(1) = P1(1,I)
        Y(1) = P1(2,I)
        Z(1) = P1(3,I)
        X(2) = P1(1,I+1)
        Y(2) = P1(2,I+1)
        Z(2) = P1(3,I+1)
        X(3) = P2(1,I+1)
        Y(3) = P2(2,I+1)
        Z(3) = P2(3,I+1)
        X(4) = P2(1,I)
        Y(4) = P2(2,I)
        Z(4) = P2(3,I)
        IF (LIGHT .NE. 0) THEN
          ANORM(1) = COS((I-1)*ANG)
          ANORM(2) = SIN((I-1)*ANG)
          ANORM(3) = 0.
          CALL IGTNOR(ANORM,T,ANORM)
          CALL IHLUMI(ANORM,F(1))
          F(4) = F(1)
          ANORM(1) = COS(I*ANG)
          ANORM(2) = SIN(I*ANG)
          ANORM(3) = 0.
          CALL IGTNOR(ANORM,T,ANORM)
          CALL IHLUMI(ANORM,F(2))
          F(3) = F(2)
          CALL IFAF3(4,X,Y,Z,F)
        ELSE
          CALL IFAF3(4,X,Y,Z)
        END IF
  400 CONTINUE
      END
+DECK,  IGCYL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IGCYL(LIGHT,T,H,R,NSTEP)
************************************************************************
*                                                                      *
* Name: IGCYL                                      Date:    10.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Draw cylinder                                              *
*                                                                      *
************************************************************************
      REAL T(4,3)
      CALL IGCONE(LIGHT,T,H,R,R,NSTEP)
      END
+DECK,  IGSPHE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IGSPHE(LIGHT,T,R,N1,N2)
************************************************************************
*                                                                      *
* Name: IGSPHE                                     Date:    10.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Draw sphere                                                *
*                                                                      *
************************************************************************
      REAL T(4,3),P(3,4),ANORM(3,4),X(4),Y(4),Z(4),F(4)
*-
      IF (N1.LT.2 .OR. N2.LT.3) RETURN
      RAD   = ATAN(1.)*4./180.
      THETA = RAD*180./N1
      PHI   = RAD*360./N2
      DO 400 ITHETA=1,N1
        COST1 = COS((ITHETA-1)*THETA)
        SINT1 = SIN((ITHETA-1)*THETA)
        COST2 = COS(ITHETA*THETA)
        SINT2 = SIN(ITHETA*THETA)
        IF (ITHETA .EQ. 1) THEN
          COST1 = 1.
          SINT1 = 0.
        END IF
        IF (ITHETA .EQ. N1) THEN
          COST2 =-1.
          SINT2 = 0.
        END IF
        DO 300 IPHI=1,N2
          COSP1 = COS((IPHI-1)*PHI)
          SINP1 = SIN((IPHI-1)*PHI)
          COSP2 = COS(IPHI*PHI)
          SINP2 = SIN(IPHI*PHI)
          IF (IPHI .EQ. 1) THEN
            COSP1 = 1.
            SINP1 = 0.
          END IF
          IF (IPHI .EQ. N2) THEN
            COSP2 = 1.
            SINP2 = 0.
          END IF
*
**      F I N D   N O R M A L  E S
*
          ANORM(1,1) = SINT1*COSP1
          ANORM(2,1) = SINT1*SINP1
          ANORM(3,1) = COST1

          ANORM(1,2) = SINT2*COSP1
          ANORM(2,2) = SINT2*SINP1
          ANORM(3,2) = COST2

          ANORM(1,3) = SINT2*COSP2
          ANORM(2,3) = SINT2*SINP2
          ANORM(3,3) = COST2

          ANORM(1,4) = SINT1*COSP2
          ANORM(2,4) = SINT1*SINP2
          ANORM(3,4) = COST1
*
**      F I N D   C O O R D I N A T E S   O F   V E R T I C E S
*
          DO 120 I=1,4
            DO 110 K=1,3
              P(K,I) = ANORM(K,I)*R
  110       CONTINUE
            CALL IGTRAN(P(1,I),T,P(1,I))
  120     CONTINUE
*
**      D R A W   F A C E
*
          DO 200 I=1,4
            X(I) = P(1,I)
            Y(I) = P(2,I)
            Z(I) = P(3,I)
            IF (LIGHT .NE. 0) THEN
              CALL IGTNOR(ANORM(1,I),T,ANORM(1,I))
              CALL IHLUMI(ANORM(1,I),F(I))
            END IF
  200     CONTINUE
          IF (LIGHT .NE. 0)  THEN
            CALL IFAF3(4,X,Y,Z,F)
          ELSE
            CALL IFA3(4,X,Y,Z)
          END IF
  300   CONTINUE
  400 CONTINUE
      END
+DECK,  IGTCOP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IGTCOP(T1,T2)
************************************************************************
*                                                                      *
* Name: IGTCOP                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Copy transformation matrix T1 to transformation matrix T2  *
*                                                                      *
************************************************************************
      REAL T1(4,3),T2(4,3)
*-
      DO 200 K=1,4
        DO 100 I=1,3
          T2(K,I) = T1(K,I)
  100   CONTINUE
  200 CONTINUE
      END
+DECK,  IGTINI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IGTINI(T)
************************************************************************
*                                                                      *
* Name: IGTINI                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Initialize matrix T by the identity transformation         *
*                                                                      *
************************************************************************
      REAL T(4,3)
*-
      DO 200 I=1,3
        DO 100 K=1,4
          T(K,I) = 0.
  100   CONTINUE
        T(I,I) = 1.
  200 CONTINUE
      END
+DECK,  IGTMUL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:42  mclareni
* Higz

      SUBROUTINE IGTMUL(T1,T2,T)
************************************************************************
*                                                                      *
* Name: IGTMUL                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Multiply two transformation matrixes                       *
*                                                                      *
************************************************************************
      REAL T1(4,3),T2(4,3),T(4,3)
      DOUBLE PRECISION DT1(4,4),DT2(4,3)
*-
      DO 120 I=1,4
        DO 110 K=1,3
          DT1(I,K) = T1(I,K)
          DT2(I,K) = T2(I,K)
  110   CONTINUE
        DT1(I,4) = 0.
  120 CONTINUE
      DT1(4,4) = 1.
*
      DO 220 I=1,4
        DO 210 K=1,3
          T(I,K) = DT1(I,1)*DT2(1,K) + DT1(I,2)*DT2(2,K) +
     +             DT1(I,3)*DT2(3,K) + DT1(I,4)*DT2(4,K)
  210   CONTINUE
  220 CONTINUE
      END
+DECK,  IGTNOR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IGTNOR(ANORM1,T,ANORM2)
************************************************************************
*                                                                      *
* Name: IGTNOR                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Transform normal ANORM1 to normal ANORM2 using matrix T    *
*                                                                      *
************************************************************************
      REAL ANORM1(3),ANORM2(3),T(4,3)
      DOUBLE PRECISION X,Y,Z,A1,A2,A3,B1,B2,B3,C1,C2,C3
*-
      X  = ANORM1(1)
      Y  = ANORM1(2)
      Z  = ANORM1(3)
      A1 = T(1,1)
      A2 = T(2,1)
      A3 = T(3,1)
      B1 = T(1,2)
      B2 = T(2,2)
      B3 = T(3,2)
      C1 = T(1,3)
      C2 = T(2,3)
      C3 = T(3,3)
      ANORM2(1) = X*(B2*C3-B3*C2) + Y*(B3*C1-B1*C3) + Z*(B1*C2-B2*C1)
      ANORM2(2) = X*(C2*A3-C3*A2) + Y*(C3*A1-C1*A3) + Z*(C1*A2-C2*A1)
      ANORM2(3) = X*(A2*B3-A3*B2) + Y*(A3*B1-A1*B3) + Z*(A1*B2-A2*B1)
      END
+DECK,  IGTOR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IGTOR(LIGHT,T,R1,R2,N1,N2)
************************************************************************
*                                                                      *
* Name: IGTOR                                      Date:    10.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Draw torus                                                 *
*                                                                      *
************************************************************************
      REAL T(4,3),P(3,4),ANORM(3,4),X(4),Y(4),Z(4),F(4)
*-
      IF (N1.LT.3 .OR. N2.LT.3) RETURN
      RAD   = ATAN(1.)*4./180.
      A     = RAD*360./N1
      B     = RAD*360./N2
      DO 400 I1=1,N1
        COSA1 = COS((I1-1)*A)
        SINA1 = SIN((I1-1)*A)
        COSA2 = COS(I1*A)
        SINA2 = SIN(I1*A)
        IF (I1 .EQ. 1) THEN
          COSA1 = 1.
          SINA1 = 0.
        END IF
        IF (I1 .EQ. N1) THEN
          COSA2 = 1.
          SINA2 = 0.
        END IF
        DO 300 I2=1,N2
          COSB1 = COS((I2-1)*B)
          SINB1 = SIN((I2-1)*B)
          COSB2 = COS(I2*B)
          SINB2 = SIN(I2*B)
          IF (I2 .EQ. 1) THEN
            COSB1 = 1.
            SINB1 = 0.
          END IF
          IF (I2 .EQ. N2) THEN
            COSB2 = 1.
            SINB2 = 0.
          END IF
*
**      F I N D   N O R M A L  E S
*
          ANORM(1,1) = COSA1*COSB1
          ANORM(2,1) = SINA1*COSB1
          ANORM(3,1) = SINB1

          ANORM(1,2) = COSA2*COSB1
          ANORM(2,2) = SINA2*COSB1
          ANORM(3,2) = SINB1

          ANORM(1,3) = COSA2*COSB2
          ANORM(2,3) = SINA2*COSB2
          ANORM(3,3) = SINB2

          ANORM(1,4) = COSA1*COSB2
          ANORM(2,4) = SINA1*COSB2
          ANORM(3,4) = SINB2
*
**      F I N D   C O O R D I N A T E S   O F   V E R T I C E S
*
          P(1,1) = ANORM(1,1)*R2 + R1*COSA1
          P(2,1) = ANORM(2,1)*R2 + R1*SINA1
          P(3,1) = ANORM(3,1)*R2

          P(1,2) = ANORM(1,2)*R2 + R1*COSA2
          P(2,2) = ANORM(2,2)*R2 + R1*SINA2
          P(3,2) = ANORM(3,2)*R2

          P(1,3) = ANORM(1,3)*R2 + R1*COSA2
          P(2,3) = ANORM(2,3)*R2 + R1*SINA2
          P(3,3) = ANORM(3,3)*R2

          P(1,4) = ANORM(1,4)*R2 + R1*COSA1
          P(2,4) = ANORM(2,4)*R2 + R1*SINA1
          P(3,4) = ANORM(3,4)*R2
          DO 100 I=1,4
            CALL IGTRAN(P(1,I),T,P(1,I))
  100     CONTINUE
*
**      D R A W   F A C E
*
          DO 200 I=1,4
            X(I) = P(1,I)
            Y(I) = P(2,I)
            Z(I) = P(3,I)
            IF (LIGHT .NE. 0) THEN
              CALL IGTNOR(ANORM(1,I),T,ANORM(1,I))
              CALL IHLUMI(ANORM(1,I),F(I))
            END IF
  200     CONTINUE
          IF (LIGHT .NE. 0)  THEN
            CALL IFAF3(4,X,Y,Z,F)
          ELSE
            CALL IFA3(4,X,Y,Z)
          END IF
  300   CONTINUE
  400 CONTINUE
      END
+DECK,  IGTRAN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IGTRAN(P1,T,P2)
************************************************************************
*                                                                      *
* Name: IGTRAN                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Transform point P1 to point P2 using matrix T              *
*                                                                      *
************************************************************************
      REAL P1(3),P2(3),T(4,3)
      DOUBLE PRECISION P(3)
*-
      P(1) = P1(1)
      P(2) = P1(2)
      P(3) = P1(3)
      DO 100 I=1,3
        P2(I) = T(1,I)*P(1) + T(2,I)*P(2) + T(3,I)*P(3) + T(4,I)
  100 CONTINUE
      END
+DECK,  IGTREF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IGTREF(P,ANORM,T)
************************************************************************
*                                                                      *
* Name: IGTREF                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Add to matrix T the reflection in a plane going though     *
*           point P and whose normal is equal to ANORM                 *
*                                                                      *
************************************************************************
      REAL P(3),ANORM(3),T(4,3)
      DOUBLE PRECISION A,B,C,D,S,DT1(4,4),DT2(4,3)
*-
      A      = ANORM(1)
      B      = ANORM(2)
      C      = ANORM(3)
      S      = DSQRT(A*A+B*B+C*C)
      SS     = S
      IF (SS .EQ. 0.) GOTO 999
      A      = A/S
      B      = B/S
      C      = C/S
      D      = -(A*P(1)+B*P(2)+C*P(3))
*
      DT2(1,1) = -A*A + B*B + C*C
      DT2(2,1) = -2*A*B
      DT2(3,1) = -2*A*C
      DT2(4,1) = -2*A*D
*
      DT2(1,2) = -2*A*B
      DT2(2,2) = A*A - B*B + C*C
      DT2(3,2) = -2*B*C
      DT2(4,2) = -2*B*D
*
      DT2(1,3) = -2*A*C
      DT2(2,3) = -2*B*C
      DT2(3,3) = A*A + B*B - C*C
      DT2(4,3) = -2*C*D
      DO 120 I=1,4
*
        DO 110 K=1,3
          DT1(I,K) = T(I,K)
  110   CONTINUE
        DT1(I,4) = 0.
  120 CONTINUE
      DT1(4,4) = 1.
*
      DO 220 I=1,4
        DO 210 K=1,3
          T(I,K) = DT1(I,1)*DT2(1,K) + DT1(I,2)*DT2(2,K) +
     +             DT1(I,3)*DT2(3,K) + DT1(I,4)*DT2(4,K)
  210   CONTINUE
  220 CONTINUE
*
  999 RETURN
      END
+DECK,  IGTROT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IGTROT(ANG,P1,P2,T)
************************************************************************
*                                                                      *
* Name: IGTROT                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Add to matrix T the rotation though ANG (counterclockwise) *
*           around an axis P1->P2                                      *
*                                                                      *
************************************************************************
      REAL P1(3),P2(3),T(4,3)
      DOUBLE PRECISION DX,DY,DZ,CX,CY,CZ,S,RAD,COSA,SINA
      DOUBLE PRECISION DT1(4,4),DT2(4,3)
*-
      DX     = P1(1)
      DY     = P1(2)
      DZ     = P1(3)
      CX     = P2(1) - P1(1)
      CY     = P2(2) - P1(2)
      CZ     = P2(3) - P1(3)
      S      = DSQRT(CX*CX + CY*CY + CZ*CZ)
      SS     = S
      IF (SS .EQ. 0.) GOTO 999
      CX     = CX / S
      CY     = CY / S
      CZ     = CZ / S
      RAD    = DATAN(1.0D+00)*4./180.0
      COSA   = DCOS(ANG*RAD)
      SINA   = DSIN(ANG*RAD)
*
      DT2(1,1) = COSA + (1.-COSA)*CX*CX
      DT2(2,1) =        (1.-COSA)*CX*CY - SINA*CZ
      DT2(3,1) =        (1.-COSA)*CX*CZ + SINA*CY
      DT2(4,1) = DX - DT2(1,1)*DX - DT2(2,1)*DY - DT2(3,1)*DZ
*
      DT2(1,2) =        (1.-COSA)*CY*CX + SINA*CZ
      DT2(2,2) = COSA + (1.-COSA)*CY*CY
      DT2(3,2) =        (1.-COSA)*CY*CZ - SINA*CX
      DT2(4,2) = DY - DT2(1,2)*DX - DT2(2,2)*DY - DT2(3,2)*DZ
*
      DT2(1,3) =        (1.-COSA)*CZ*CX - SINA*CY
      DT2(2,3) =        (1.-COSA)*CZ*CY + SINA*CX
      DT2(3,3) = COSA + (1.-COSA)*CZ*CZ
      DT2(4,3) = DZ - DT2(1,3)*DX - DT2(2,3)*DY - DT2(3,3)*DZ
*
      DO 120 I=1,4
        DO 110 K=1,3
          DT1(I,K) = T(I,K)
  110   CONTINUE
        DT1(I,4) = 0.
  120 CONTINUE
      DT1(4,4) = 1.
*
      DO 220 I=1,4
        DO 210 K=1,3
          T(I,K) = DT1(I,1)*DT2(1,K) + DT1(I,2)*DT2(2,K) +
     +             DT1(I,3)*DT2(3,K) + DT1(I,4)*DT2(4,K)
  210   CONTINUE
  220 CONTINUE
*
  999 RETURN
      END
+DECK,  IGTSCA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IGTSCA(SX,SY,SZ,T)
************************************************************************
*                                                                      *
* Name: IGTSCA                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Add to matrix T the scaling transformation with factors    *
*           SX, SY, SZ                                                 *
*                                                                      *
************************************************************************
      REAL T(4,3)
*-
      DO 100 I=1,4
        T(I,1) = T(I,1) * SX
        T(I,2) = T(I,2) * SY
        T(I,3) = T(I,3) * SZ
  100 CONTINUE
      END
+DECK,  IGTTRA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IGTTRA(DX,DY,DZ,T)
************************************************************************
*                                                                      *
* Name: IGTTRA                                     Date:    04.12.95   *
* Author: E.Chernyaev (IHEP/Protvino)              Revised:            *
*                                                                      *
* Function: Add to matrix T the translation by DX, DY, DZ              *
*                                                                      *
************************************************************************
      REAL T(4,3)
*-
      T(4,1) = T(4,1) + DX
      T(4,2) = T(4,2) + DY
      T(4,3) = T(4,3) + DZ
      END
+DECK,  IPL3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IPL3(N,X,Y,Z)
+CDE, HIATT.
+CDE, HIGRAF.
+CDE, HI3D.
      DIMENSION X(*),Y(*),Z(*)
      IF (IDIM.EQ.3) THEN
+SELF, IF=PHIGS.
         CALL PPL3(N,X,Y,Z)
+SELF.
      ELSE
         NGRAF = 0
         DO 20 I=1,N
            NGRAF        = NGRAF+1
            XGRAF(NGRAF) = AWNX*X(I)+BWNX*Y(I)+CWNX*Z(I)+DWNX
            YGRAF(NGRAF) = AWNY*X(I)+BWNY*Y(I)+CWNY*Z(I)+DWNY
            ZGRAF(NGRAF) = AWNZ*X(I)+BWNZ*Y(I)+CWNZ*Z(I)+DWNZ
            IF(NGRAF.EQ.NPMAX.OR.I.EQ.N)THEN
               IF (IZBUF.NE.0) THEN
+SELF, IF=ZBUF.
                  DO 10 J=2,NGRAF
                     CALL IHZLIN(IPLCI,XGRAF(J-1),YGRAF(J-1),ZGRAF(J-1)
     +,                                XGRAF(J)  ,YGRAF(J)  ,ZGRAF(J) )
   10             CONTINUE
+SELF.
               ELSE
                  CALL IPL(NGRAF,XGRAF,YGRAF)
               ENDIF
               XGRAF(1) = XGRAF(NGRAF)
               YGRAF(1) = YGRAF(NGRAF)
               ZGRAF(1) = ZGRAF(NGRAF)
               NGRAF    = 1
            ENDIF
   20    CONTINUE
      ENDIF
*
      END
+DECK,  IPM3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IPM3(N,X,Y,Z)
+CDE, HIATT.
+CDE, HIGRAF.
+CDE, HI3D.
      DIMENSION X(*),Y(*),Z(*)
      IF (IDIM.EQ.3) THEN
+SELF, IF=PHIGS.
         CALL PPM3(N,X,Y,Z)
+SELF.
      ELSE
         NGRAF=0
         DO 10 I=1,N
            NGRAF        = NGRAF+1
            XGRAF(NGRAF) = AWNX*X(I)+BWNX*Y(I)+CWNX*Z(I)+DWNX
            YGRAF(NGRAF) = AWNY*X(I)+BWNY*Y(I)+CWNY*Z(I)+DWNY
            ZGRAF(NGRAF) = AWNZ*X(I)+BWNZ*Y(I)+CWNZ*Z(I)+DWNZ
            IF(NGRAF.EQ.NPMAX.OR.I.EQ.N)THEN
               CALL IPM(NGRAF,XGRAF,YGRAF)
               NGRAF = 0
            ENDIF
   10    CONTINUE
      ENDIF
*
      END
+DECK,  IPM3ID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE IPM3ID(N,X,Y,Z,LEVEL,ID)
+CDE, HIATT.
+CDE, HIGRAF.
+CDE, HIHIST.
+CDE, HI3D.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*),Z(*),ID(*)
      DIMENSION IDD(NPMAX)
      EQUIVALENCE (XWORK(1),IDD(1))
*
      IF (IDIM.EQ.3) THEN
+SELF, IF=PHIGS.
         CALL PPM3(N,X,Y,Z)
+SELF.
      ELSE
         NGRAF = 0
         DO 10 I=1,N
            NGRAF        = NGRAF+1
            XGRAF(NGRAF) = AWNX*X(I)+BWNX*Y(I)+CWNX*Z(I)+DWNX
            YGRAF(NGRAF) = AWNY*X(I)+BWNY*Y(I)+CWNY*Z(I)+DWNY
            ZGRAF(NGRAF) = AWNZ*X(I)+BWNZ*Y(I)+CWNZ*Z(I)+DWNZ
            IDD(NGRAF)   = ID(I)
            IF(NGRAF.EQ.NPMAX.OR.I.EQ.N)THEN
               CALL IPM(NGRAF,XGRAF,YGRAF)
               IF(ZFLAG)CALL IGADID(LEVEL,NGRAF,IDD)
               NGRAF = 0
            ENDIF
   10    CONTINUE
      ENDIF
*
      END
+DECK,  ISVP3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE ISVP3(NT,X1,X2,Y1,Y2)
*.===========>
*.
*. Define the 3D viewport (in 2D world coordinates)
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalisation transformation number.
*.  REAL X1,X2,Y1,Y2 : 3D viewport.
*.
*..==========> (O.Couet)
+SELF, IF=NTC,X11.
*
      IF ( X2.LE.X1 .OR. Y2.LE.Y1 ) THEN
         CALL IGERR ('Invalid 3D viewport definition','ISVP3')
         RETURN
      ENDIF
*
      IF ( IGNSCU(NT) .EQ. 0 ) CALL IGNCRE (NT)
      CALL IGNS3V (X1,X2,Y1,Y2)
+SELF.
      END
+DECK,  ISWN3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE ISWN3(NT,X1,X2,Y1,Y2,Z1,Z2,PHI,THETA,PSI,CHOPT)
*.===========>
*.
*. Define the 3D window
*.
*. _Input parameters:
*.
*.  INTEGER NT : Normalisation transformation number.
*.  REAL X1,X2,Y1,Y2,Z1,Z2 : 3D volume.
*.  REAL PHI,THETA,PSI : 3D vue angles.
*.  CHARACTER CHOPT : Options.
*.
*..==========> (O.Couet)
      CHARACTER*(*) CHOPT
*.______________________________________
*
+SELF, IF=NTC,X11.
*
      IF ( X2.LE.X1. OR. Y2.LE.Y1. OR. Z2.LE.Z1 ) THEN
         CALL IGERR ('Invalid 3D window definition','ISWN3')
         RETURN
      ENDIF
*
      IF ( IGNSCU(NT) .EQ. 0 ) CALL IGNCRE(NT)
      CALL IGNS3W (X1,X2,Y1,Y2,Z1,Z2,PHI,THETA,PSI)
+SELF.
      END
+DECK,  ITX3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:43  mclareni
* Higz

      SUBROUTINE ITX3(X,Y,Z,TEXT)
+CDE, HI3D.
      CHARACTER*(*) TEXT
      X2 = AWNX*X+BWNX*Y+CWNX*Z+DWNX
      Y2 = AWNY*X+BWNY*Y+CWNY*Z+DWNY
      Z2 = AWNZ*X+BWNZ*Y+CWNZ*Z+DWNZ
      CALL ITX(X2,Y2,TEXT)
*
      END
+PATCH, IG.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
DoIncludePackage(higz)
#include "pilot.h"

SRCS_F=	ica.F igadid.F igarc.F igarc1.F igarc2.F igarc3.F \ @@\
	igarc4.F igasci.F igaxi0.F igaxi1.F igaxi2.F igaxi3.F igaxi4.F \ @@\
	igaxis.F igbox.F igcell.F igchwk.F igcles.F igcli1.F igclip.F \ @@\
	igcolm.F igconv.F igdate.F igdwk.F igelli.F igend.F igerr.F \ @@\
	igfa.F igfbox.F iggfin.F iggif.F ighatc.F ighcx.F ighcxy.F \ @@\
	ighis1.F ighist.F ighr01.F ightor.F iginit.F igiwin.F igiwty.F \ @@\
	iglbl.F iglev.F igloc.F igloc2.F igm100.F igmess.F \ @@\
	igmetn.F igparf.F igpave.F igphst.F igpick.F igpid.F \ @@\
	igpie.F igpkfa.F igpkpl.F igpkpm.F igpm.F igpxmp.F igq.F \ @@\
	igqwk.F igrap1.F igrap2.F igraph.F igrtoh.F \ @@\
	igset.F igset1.F igsrap.F igsse.F igstr.F igsvie.F igtab1.F \ @@\
	igtab2.F igtab3.F igtab4.F igtab5.F igtab6.F igtabl.F igtcch.F \ @@\
	igterm.F igtext.F igwkty.F igxmes.F igzset.F iml.F ipm4id.F \ @@\
	ipmid.F

#if !defined(CERNLIB_DI3000)
SRCS_F := $(SRCS_F) igmeta.F igrng.F
#endif

#if defined(CERNLIB_X11)
SRCS_F := $(SRCS_F) igobj.F igrsiz.F
#endif


SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  ICA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE ICA(X1,X2,Y1,Y2,NX,NY,IV,CHOPT)
*.===========>
*.
*.   Draws a CELL array
*.
*. _Input parameters:
*.
*.  REAL X1,Y1 : Left down corner (in WC).
*.  REAL X2,Y2 : Right up corner (in WC).
*.  INTEGER NX,NY : Array dimensions
*.  INTEGER IV(NX,NY) : Array to be drawn (array of colors)
*.  CHARACTER CHOPT : Option
*.                    'P' Pixel precision (IXCA is called).
*.
*..==========> (O.Couet)
+SELF, IF=X11.
+CDE, HIATT.
+SELF.
      CHARACTER*(*) CHOPT
      DIMENSION IV(NX,NY)
*.______________________________________
*
+SELF, IF=X11.
+CDE, HIWCDC.
+SELF.
*
      IF(INDEX(CHOPT,'P').NE.0)THEN
+SELF, IF=X11.
         DO 10 IWKNB=1,INOPWK
            IF(NODRFL(IWKNB))GOTO 10
            CALL IGSG(IWKNB)
            IX1 = IXWCDC(X1)
            IX2 = IXWCDC(X2)
            IY1 = IYWCDC(Y1)
            IY2 = IYWCDC(Y2)
            CALL IXCA(IX1,IX2,IY1,IY2,NX,NY,IV)
   10    CONTINUE
+SELF.
      ELSE
         CALL IGSET('FAIS',1.)
         CALL IGSET('BORD',0.)
         DX   = (X2-X1)/NX
         DY   = (Y2-Y1)/NY
         X1B  = X1
         X2B  = X1+DX
*
         DO 30 I = 1, NX
            Y1B  = Y1
            Y2B  = Y1+DY
            ICOL = IV(I,1)
            CALL ISFACI(ICOL)
            DO 20 J = 2, NY
               IF(IV(I,J).EQ.ICOL)THEN
                  Y2B = Y2B+DY
               ELSE
                  CALL IGBOX(X1B,X2B,Y1B,Y2B)
                  ICOL = IV(I,J)
                  CALL ISFACI(ICOL)
                  Y1B  = Y2B
                  Y2B  = Y2B+DY
               ENDIF
   20       CONTINUE
            CALL IGBOX(X1B,X2B,Y1B,Y2B)
            X1B = X2B
            X2B = X2B+DX
   30    CONTINUE
      ENDIF
*
      END
+DECK,  IGADID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IGADID(LEVEL,N,ID)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HICODE.
      DIMENSION ID(*)
*.______________________________________
*
      IF(LPICT.LT.0)RETURN
      IF(IZPUSH(N+1,0,0,'IGADID').NE.0)RETURN
      CALL IZSTCC(IMIDCO,INTPTR)
      IQ(LHI+INTPTR)=LEVEL
      DO 10 I=1,N
         IQ(LHI+INTPTR+I)=ID(I)
   10 CONTINUE
      CALL IZINCI(N+1)
*
      END
+DECK,  IGARC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IGARC(X,Y,R1,R2,PHI1,PHI2)
*.===========>
*.
*.   This routine draws an arc . If R1 not equal R2 the area between the two
*. arcs of radius R1 and R2 is filled according to the fill area interior style
*. index and the fill area style index .
*.
*. _Input parameters:
*.
*.  REAL X,Y : Center of the arc .
*.  REAL R1 : First radius .
*.  REAL R2 : Second radius .
*.  REAL PHI1 : First angle in degrees.
*.  REAL PHI2 : Second angle in degrees.
*.
*..==========> (O.Couet R.Nierhaus)
+CDE, HIFLAG.
*.______________________________________
*
      PHI1R=(3.14159*PHI1)/180.
      PHI2R=(3.14159*PHI2)/180.
      IF(GFLAG.OR.PFLAG)THEN
         PHI3=PHI2R
         IF(PHI1R.EQ.0..AND.PHI3.EQ.0.)PHI3=2.*3.14159
         IF(R1.EQ.R2)THEN
            CALL IGARC1(X,Y,R1,PHI1R,PHI3)
         ELSEIF(R1.EQ.0.)THEN
            IF(PHI1R.EQ.0..AND.PHI2R.EQ.0.)THEN
               CALL IGARC2(X,Y,R2)
            ELSE
               CALL IGARC3(X,Y,R2,PHI1R,PHI3)
            ENDIF
         ELSEIF(R1.GT.R2)THEN
            CALL IGARC4(X,Y,R2,R1,PHI1R,PHI3)
         ELSE
            CALL IGARC4(X,Y,R1,R2,PHI1R,PHI3)
         ENDIF
      ENDIF
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZARC(X,Y,R1,R2,PHI1,PHI2)
+SELF.
*
      END
+DECK,  IGARC1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IGARC1(XC,YC,R,PHI1,PHI2)
*.===========>
*.
*.   Underlaying routine for IGARC .
*.
*..==========> (O.Couet R.Nierhaus)
+CDE, HIGRAF.
+CDE, HIFLAG.
      LOGICAL ZFSAV
      PARAMETER (PI=3.1415926,PI2=2*PI)
*.______________________________________
*

      ANGLE=PHI2-PHI1
      IF(ANGLE.LT.0.)ANGLE=PI2+ANGLE
      NPOINT=INT(99.*ANGLE/PI2+.5)
      NPOINT=MAX(1,NPOINT)
      DELTA=ANGLE/FLOAT(NPOINT)
      XX=COS(PHI1)
      YY=SIN(PHI1)
      TCOS=COS(DELTA)
      TSIN=SIN(DELTA)
      NPOINT=NPOINT+1
      DO 10 I=1,NPOINT
         XGRAF(I)=XC+R*XX
         YGRAF(I)=YC+R*YY
         XXX=XX*TCOS-YY*TSIN
         YY=XX*TSIN+YY*TCOS
         XX=XXX
   10 CONTINUE
      ZFSAV=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL IPL(NPOINT,XGRAF,YGRAF)
      ZFLAG=ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGARC2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:32  mclareni
* Higz

      SUBROUTINE IGARC2(XC,YC,R)
*.===========>
*.
*.   Underlaying routine for IGARC .
*.
*..==========> (O.Couet R.Nierhaus)
+CDE, HIGRAF.
+CDE, HIATT.
+CDE, HIFLAG.
      LOGICAL ZFSAV
*.______________________________________
*
      NPOINT = 99
      DELTA  = 2.*3.14159/FLOAT(NPOINT)
      XX     = 1.
      YY     = 0.
      TCOS   = COS(DELTA)
      TSIN   = SIN(DELTA)
*
      DO 10 I=1,NPOINT
         XGRAF(I) = XC+R*XX
         YGRAF(I) = YC+R*YY
         XXX      = XX*TCOS-YY*TSIN
         YY       = XX*TSIN+YY*TCOS
         XX       = XXX
   10 CONTINUE
*
      ZFSAV  = ZFLAG
      ZFLAG  = .FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      CALL IFA(NPOINT,XGRAF,YGRAF)
*
      IF((IBORD.NE.0).AND.(IFAIS.NE.0))THEN
         NPOINT        = NPOINT+1
         XGRAF(NPOINT) = XGRAF(1)
         YGRAF(NPOINT) = YGRAF(1)
         CALL IPL(NPOINT,XGRAF,YGRAF)
      ENDIF
*
      ZFLAG  = ZFSAV
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGARC3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:32  mclareni
* Higz

      SUBROUTINE IGARC3(XC,YC,R,PHI1,PHI2)
*.===========>
*.
*.   Underlaying routine for IGARC .
*.
*..==========> (O.Couet R.Nierhaus)
+CDE, HIGRAF.
+CDE, HIATT.
+CDE, HIFLAG.
      LOGICAL ZFSAV
      PARAMETER (PI=3.1415926,PI2=2*PI)
*.______________________________________
*
      ANGLE = PHI2-PHI1
      IF (ANGLE.LT.0.) ANGLE = PI2+ANGLE
      NPOINT = INT(99.*ANGLE/PI2+.5)
      NPOINT = MAX(1,NPOINT)
      DELTA  = ANGLE/FLOAT(NPOINT)
      XX     = COS(PHI1)
      YY     = SIN(PHI1)
      TCOS   = COS(DELTA)
      TSIN   = SIN(DELTA)
*
      XGRAF(1) = XC
      YGRAF(1) = YC
      DO 10 I=2,NPOINT+2
         XGRAF(I) = XC+R*XX
         YGRAF(I) = YC+R*YY
         XXX      = XX*TCOS-YY*TSIN
         YY       = XX*TSIN+YY*TCOS
         XX       = XXX
   10 CONTINUE
*
      ZFSAV  = ZFLAG
      ZFLAG  = .FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      CALL IFA(NPOINT+2,XGRAF,YGRAF)
*
      IF((IBORD.NE.0).AND.(IFAIS.NE.0))THEN
         NPL = NPOINT+3
         IF (NPL.LE.NPMAX) THEN
            XGRAF(NPL) = XGRAF(1)
            YGRAF(NPL) = YGRAF(1)
            CALL IPL(NPL,XGRAF,YGRAF)
         ELSE
            CALL IGERR('Too many points','IGARC')
         ENDIF
      ENDIF
*
      ZFLAG  = ZFSAV
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGARC4, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:32  mclareni
* Higz

      SUBROUTINE IGARC4(XC,YC,R1,R2,PHI1,PHI2)
*.===========>
*.
*.   Underlaying routine for IGARC .
*.
*..==========> (O.Couet R.Nierhaus)
+CDE, HIGRAF.
+CDE, HIFLAG.
+CDE, HIATT.
      LOGICAL ZFSAV
      PARAMETER (PI=3.1415926,PI2=2*PI)
      PARAMETER (EPSIL=0.0001)
*.______________________________________
*
      ANGLE = PHI2-PHI1
      IF (ANGLE.LT.0.) ANGLE=PI2+ANGLE
      NPOINT = INT((99./2.-1)*ANGLE/PI2+.5)
      NPOINT = MAX(1,NPOINT)
      DELTA  = ANGLE/FLOAT(NPOINT)
      XX     = COS(PHI1)
      YY     = SIN(PHI1)
      TCOS   = COS(DELTA)
      TSIN   = SIN(DELTA)
*
      DO 10 I=1,NPOINT+1
         XGRAF(I)            = XC+R1*XX
         YGRAF(I)            = YC+R1*YY
         XGRAF(2*NPOINT+3-I) = XC+R2*XX
         YGRAF(2*NPOINT+3-I) = YC+R2*YY
         XXX                 = XX*TCOS-YY*TSIN
         YY                  = XX*TSIN+YY*TCOS
         XX                  = XXX
   10 CONTINUE
*
      ZFSAV  = ZFLAG
      ZFLAG  = .FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      CALL IFA(2*NPOINT+2,XGRAF,YGRAF)
*
      IF ((IBORD.NE.0).AND.(IFAIS.NE.0)) THEN
         IF (ABS(XGRAF(1)-XGRAF(NPOINT+1)).GT.EPSIL.OR.
     +       ABS(YGRAF(1)-YGRAF(NPOINT+1)).GT.EPSIL) THEN
            NPL = 2*NPOINT+3
            IF (NPL.LE.NPMAX) THEN
               XGRAF(NPL) = XGRAF(1)
               YGRAF(NPL) = YGRAF(1)
               CALL IPL(NPL,XGRAF,YGRAF)
            ELSE
               CALL IGERR('Too many points','IGARC')
            ENDIF
         ELSE
            CALL IPL(NPOINT+1,XGRAF,YGRAF)
            CALL IPL(NPOINT+1,XGRAF(NPOINT+2),YGRAF(NPOINT+2))
         ENDIF
      ENDIF
*
      ZFLAG  = ZFSAV
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGASCI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:32  mclareni
* Higz

      INTEGER FUNCTION IGASCI(CC)
*.===========>
*.
*. Return the ASCII code of the printable characters
*.
*..==========> (O.Couet)
      CHARACTER*1 CC
+SELF, IF=IBM.
      DIMENSION IEB(95)
      DATA IEB /
     + 64, 90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
     +240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
     +124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
     +215,216,217,226,227,228,229,230,231,232,233,173,224,189, 95,109,
     +121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
     +151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161/
+SELF.
*.______________________________________
*
      IC=ICHAR(CC)
+SELF, IF=IBM.
      IGASCI=32
      DO 10 I=1,95
         IF(IEB(I).EQ.IC)THEN
            IGASCI=31+I
            RETURN
         ENDIF
   10 CONTINUE
+SELF, IF=-IBM.
      IGASCI=IC
+SELF.
*
      END
+DECK,  IGAXI0, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:32  mclareni
* Higz

      SUBROUTINE IGAXI0(A1,A2,NAA,BL,BH,NB,BWID)
*.==========>
*.
*.  Get reasonable values for tick marks & ensure they are
*. not plotted beyond allowed limits
*.
*. _Input parameters:
*.
*.  REAL A1,A2 : Old WMIN,WMAX .
*.  REAL BL,BH : New WMIN,WMAX .
*.  INTEGER NAA : Old NDIV .
*.  INTEGER NB : New NDIV .
*.
*..=========>
      CALL IGAXI3(A1,A2,NAA,BL,BH,NB,BWID)
      ATEST=BWID*0.0001
      IF(ABS(BL-A1).GE.ATEST)THEN
         BL=BL+BWID
         NB=NB-1
      ENDIF
      IF(ABS(BH-A2).GE.ATEST)THEN
         BH=BH-BWID
         NB=NB-1
      ENDIF
*
      END
+DECK,  IGAXI1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGAXI1(X,Y,CFI,SFI,XT,YT,U,V)
*.==========>
*.
*.   Underlaying routine IGAXIS .
*.
*..=========>
      U=CFI*X-SFI*Y+XT
      V=SFI*X+CFI*Y+YT
*
      END


+DECK,  IGAXI2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGAXI2(LABEL,ISTA,IEND)
*.===========>
*.
*.   Find start (ISTA) and end (IEND) of a label (LABEL).
*.
*..==========> (C.E.Vandoni)
      CHARACTER*(*) LABEL
*.______________________________________
*
      IEND=LENOCC(LABEL)
      DO 10 I=1,IEND
         KK=I
         ISTA=INDEX('1234567890-+.',LABEL(I:I))
         IF(ISTA.NE.0)GOTO 20
   10 CONTINUE
      CALL IGERR('Attempt to draw a blank label','IGAXIS')
   20 ISTA=KK
*
      END
+DECK,  IGAXI3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGAXI3(A1,A2,NAA,BL,BH,NB,BWID)
*.==========>
*.
*.   Adjust binsiz
*.
*..=========>
      AL=MIN(A1,A2)
      AH=MAX(A1,A2)
      IF(AL.EQ.AH)AH=AL+1.
*
*              IF NAA .EQ. -1 , program uses bwid input from
*              calling routine
*
      IF(NAA.EQ.-1)GOTO 80
   10 NA=MAX(NAA,2)
      IF(NA.LT.1)NA=1
*
*              Get nominal bin width in expon form
*
   20 AWID=(AH-AL)/FLOAT(NA)
      JLOG=LOG10(AWID)
      IF(AWID.LE.1.0)JLOG=JLOG-1
      SIGFIG=AWID*(10.00**(-JLOG))
*
*              Round mantissa up to 1, 2, 2.5, 5, or 10
*
      IF(SIGFIG.GT.1.0)GOTO 30
      SIGRND=1.0
      GOTO 70
   30 IF(SIGFIG.GT.2.0)GOTO 40
      SIGRND=2.0
      GOTO 70
   40 IF(SIGFIG.GT.2.5)GOTO 50
      SIGRND=2.5
      GOTO 70
   50 IF(SIGFIG.GT.5.0)GOTO 60
      SIGRND=5.0
      GOTO 70
   60 SIGRND=1.0
      JLOG=JLOG + 1
   70 CONTINUE
      BWID=SIGRND*10.0**JLOG
      GOTO 90
*
*              Get new bounds from new width BWID
*
   80 IF(BWID.LE.0.)GOTO 10
   90 CONTINUE
      ALB=AL/BWID
      LWID=ALB
      IF(ALB.LT.0.0)LWID=LWID-1
      BL=SIGRND*FLOAT(LWID)*10.**JLOG
      ALB=AH/BWID+1.00001
      KWID=ALB
      IF(ALB.LT.0.0)KWID=KWID-1
      BH=SIGRND*FLOAT(KWID)*10.**JLOG
      NB=KWID-LWID
      IF(NAA.GT.5)GOTO 100
      IF(NAA.EQ.-1)RETURN
*
*              Request for one bin is difficult case
*
      IF(NAA.GT.1.OR.NB.EQ.1)RETURN
      BWID=BWID*2.0
      NB=1
      RETURN
  100 IF(2*NB.NE.NAA)RETURN
      NA=NA+1
      GOTO 20
*
      END
+DECK,  IGAXI4, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGAXI4(A1,A2,NAA,BL,BH,NB,BWID)
*.==========>
*.
*.   This routine adjusts the bining of the axis
*.   in order to have integer value for labelling.
*.
*. _Input parameters:
*.
*.  REAL A1,A2 : Old WMIN,WMAX .
*.  REAL BL,BH : New WMIN,WMAX .
*.  INTEGER NAA : Old NDIV (primary divisions)
*.  INTEGER NB : New NDIV .
*.
*..=========>
*
      BWID=ABS(A2-A1)/NAA
      IF(BWID.LE.1.)THEN
         BWID=1.
         BL=INT(A1)
      ELSE
         IWID=INT(BWID/5)+1
         BWID=5.*IWID
         BL=INT(A1/BWID)*BWID
*
*     We determine BL to have one tick mark at 0
*     if there are negative labels.
*
         IF(A1.LT.0.)THEN
            IC=0
   10       IC=IC+1
            RBL=BL/BWID
            IBL=INT(BL/BWID)
            IF(((RBL-IBL).NE.0.).AND.(IC.LE.IWID))THEN
              BL=BL-5.
              GOTO 10
            ENDIF
         ENDIF
      ENDIF
      BH=INT(A2)
*
      NB=0
      XB=BL
   20 XB=XB+BWID
      IF(XB.LE.BH)THEN
         NB=NB+1
         GOTO 20
      ENDIF
*
      BH=XB-BWID
*
   99 RETURN
      END


+DECK,  IGAXIS, T=FORT.
* Revision 1.6  1999/10/06 13:51:58  couet
* - Some optimisations to draw intermediate labels in log scale on vertical axis
* are commented. They produce a wrong labels alignment. The reason why they have
* been put there have not been found i.e. every things looks fine without these
* lines. Nevertheless they are just commented. A test in the PAW suite will be
* added to cover this part of code.
* Revision 1.5  1998/12/01 15:48:25  couet
* - Clean up: commented lines of code removed
* Revision 1.4  1998/01/27 14:06:11  couet
* *** empty log message ***
* Revision 1.3  1996/05/08 14:44:19  couet
* - The test XMIN-XMAX < EPSIL to see if the axis is vertival
*   was wrong because XMIN-MAX can be small (<EPSIL) but the axis
*   horizontal. So the test XMIN=XMAX is put back.
* Revision 1.2  1996/04/18 08:40:05  couet
* FLEXE was not initialized
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGAXIS(RXMI,RXMA,RYMI,RYMA,RWMI,RWMA,NNDI,CHOPT)
*.==============>
*.
*.   Draws an axis and/or stores it in the data structure,
*. according to the option selected by IGZSET.
*.
*. _Input parameters:
*.
*.  REAL RXMI      : X origin coordinate in WC space.
*.  REAL RXMA      : X end axis coordinate in WC space.
*.  REAL RYMI      : Y origin coordinate in WC space.
*.  REAL RYMA      : Y end axis coordinate in WC space.
*.  REAL RWMI      : Lowest value for the tick mark
*.                   labels written on the axis.
*.  REAL RWMA      : Highest value for the tick mark labels
*.                   written on the axis.
*.  INTEGER NNDI    : Number of divisions.
*.
*.       NNDI=N1 + 100*N2 + 10000*N3
*.       N1=number of 1st divisions.
*.       N2=number of 2nd divisions.
*.       N3=number of 3rd divisions.
*.           e.g.:
*.           NNDI=0 --> no tick marks.
*.           NNDI=2 --> 2 divisions, one tick mark in the middle
*.                      of the axis.
*.
*.  CHARACTER CHOPT :  Options (see bellow).
*.
*.       CHOPT='G': loGarithmic scale, default is linear.
*.       CHOPT='B': Blank axis. Useful to superpose axis.
*.       CHOPT='A': An arrow is drawn at the end(WMAX) of the axis.
*.
*. Orientation of tick marks on axis.
*. ----------------------------------
*.
*.   Tick marks are normally drawn on the positive side of the axis,
*.   however, if X0=X1, then negative.
*.
*.       CHOPT='+': tick marks are drawn on Positive side. (default)
*.       CHOPT='-': tick mark are drawn on the negative side.
*.       i.e: '+-' --> tick marks are drawn on both sides of the axis.
*.       CHOPT='U': Unlabeled axis, default is labeled.
*.
*. Position of labels on axis.
*. ---------------------------
*.
*.   Labels are normally drawn on side opposite to tick marks.
*.   However:
*.
*.       CHOPT='=': on Equal side
*.
*. Orientation of labels on axis.
*. ------------------------------
*.
*.   Labels are normally drawn parallel to the axis.
*.   However if X0=X1, then Orthogonal
*.           if Y0=Y1, then Parallel
*.
*.       CHOPT='P': Parallel to the axis
*.       CHOPT='O': Orthogonal to the axis (Top to Down).
*.       CHOPT='0': Orthogonal to the axis (Down to Top).
*.
*. Position of labels on tick marks.
*. ---------------------------------
*.
*.   Labels are centered on tick marks.
*.   However , if X0=X1, then they are right adjusted.
*.
*.       CHOPT='R': labels are Right adjusted on tick mark.
*.                    (default is centered)
*.       CHOPT='L': labels are Left adjusted on tick mark.
*.       CHOPT='C': labels are Centered on tick mark.
*.       CHOPT='M': In the Middle of the divisions.
*.       CHOPT='V': Tick mark are drawn verticaly
*.
*. Direction of labels.
*. --------------------
*.
*.   Default is RIGHT
*.
*.       CHOPT='Y': Down
*.
*. Format of labels.
*. -----------------
*.
*.   Blank characters are stripped, and then the
*.   label is correctly aligned. the dot, if last
*.   character of the string, is also stripped, unless
*.
*.       CHOPT='.' Dot obligatory
*.
*.   In the following, we have some parameters, like
*.   tick marks length and characters height (in percentage
*.   of the length of the axis (WC))
*.   The default values are as follows:
*.
*.   Primary tick marks: 3.0 %
*.   Secondary tick marks: 1.5 %
*.   Third order tick marks: .75 %
*.
*.   Length of the arrow: 3.0 %
*.   Width of the arrow: .75 %
*.
*.   Characters height for labels: 2%
*.   Characters spacing (related to height): 40%
*.
*.   Labels offset: 4.0 %
*.
*. Type of labels.
*. ---------------
*.
*.   Labels are normally numeric. However, alphanumeric labels
*.   can be drawn. The value are stored in HILABS (see IGLBL)
*.
*.       CHOPT='T': Alphanumeric labels .
*.
*. Optional grid.
*. --------------
*.
*.       CHOPT='W': cross-Wire
*.
*. Intrinsic parameters.
*. ---------------------
*.
*.       CHOPT='S': Tick marks Size
*.       CHOPT='H': Labels Height
*.       CHOPT='D': Distance labels-axis
*.
*. Axis bining optimization.
*. -------------------------
*.
*.   By default the axis bining is optimized .
*.
*.       CHOPT='N': No bining optimization
*.       CHOPT='I': Integer labelling
*.
*.       CHOPT='X': The axis is not drawn, and the number of divisions,
*.                  the smallest and bigest labels are returned
*.
*.============> (O.Couet C.E.Vandoni N.Cremel-Somon)
+CDE, HIFLAG.
+CDE, HIATT.
+CDE, HILABS.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF.
      COMMON /AXSIZ/ CHAXSZ
      LOGICAL ZFSAV
      LOGICAL FLEXE,FLEXPO,FLEXNE,INTLOG
      DIMENSION ATICK (3), NN(3),XPL(4),YPL(4)
      DIMENSION IOPT(25)
      EQUIVALENCE (IOPTG,IOPT(1))  , (IOPTB,IOPT(2))
      EQUIVALENCE (IOPTA,IOPT(3))  , (IOPTV,IOPT(4))
      EQUIVALENCE (IOPTPL,IOPT(5)) , (IOPTN,IOPT(6))
      EQUIVALENCE (IOPTU,IOPT(7))  , (IOPTP,IOPT(8))
      EQUIVALENCE (IOPTO,IOPT(9))  , (IOPTR,IOPT(10))
      EQUIVALENCE (IOPTL,IOPT(11)) , (IOPTC,IOPT(12))
      EQUIVALENCE (IOPTEQ,IOPT(13)), (IOPTDO,IOPT(14))
      EQUIVALENCE (IOPTH,IOPT(15)) , (IOPTD,IOPT(16))
      EQUIVALENCE (IOPTY,IOPT(17)) , (IOPTT,IOPT(18))
      EQUIVALENCE (IOPTW,IOPT(19)) , (IOPTS,IOPT(20))
      EQUIVALENCE (IOPTNN,IOPT(21)), (IOPTI,IOPT(22))
      EQUIVALENCE (IOPTM,IOPT(23)) , (IOPT0,IOPT(24))
      EQUIVALENCE (IOPTX,IOPT(25))
      CHARACTER*(*) CHOPT
      CHARACTER*32 LABEL
      CHARACTER*8 CODED
      CHARACTER*36 CHTEMP
*     Set the labels precision
      PARAMETER(NCAR=5)
      DATA EPSIL /0.00001/
*.______________________________________
*
      XMIN=RXMI
      XMAX=RXMA
      YMIN=RYMI
      YMAX=RYMA
      WMIN=RWMI
      WMAX=RWMA
      NDIV=NNDI
*
      CALL UOPTC(CHOPT,'GBAV+-UPORLC=.HDYTWSNIM0X',IOPT)
+SELF, IF=MAIL.
      CHOPTM=CHOPT
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZAXIS(XMIN,XMAX,YMIN,YMAX,WMIN,WMAX,NDIV,IOPT)
+SELF.
      IF((.NOT.GFLAG).AND.(.NOT.PFLAG))RETURN
      ZFSAV=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
*              Set the grid lenght
*
      IGRITY=ILN
      GRIL1=0.
      IF(IOPTW.NE.0)THEN
         GRILEN=RAWL
         GRIL1=GRILEN
      ENDIF
*
*              Determine number of divisions 1, 2 and 3
*
      N     = NDIV
      N3A   = N/10000
      N     = N-N3A*10000
      N2A   = N/100
      N1A   = N-N2A*100
      NN(3) = MAX(N3A,1)
      NN(2) = MAX(N2A,1)*NN(3)
      NN(1) = MAX(N1A,1)*NN(2)+1
      LOOP  = NN(1)
*
*              Axis bining optimization is ignored if:
*                - the first and the last label are equal
*                - the number of divisions is 0
*                - less than 1 primary division is requested
*                - logarithmic scale is requested
*
      IF((WMIN.EQ.WMAX).OR.(NDIV.EQ.0).OR.
     +   (N1A.LE.1).OR.(IOPTG.NE.0))THEN
         IOPTNN = 1
         IOPTI  = 0
      ENDIF
*
*              Axis bining optimization
*
      IF(((WMAX-WMIN).LT.1.).AND.(IOPTI.NE.0))THEN
         CALL IGERR('Option "I" not available','IGAXIS')
         IOPTI=0
      ENDIF
      IF(IOPTNN.EQ.0.OR.IOPTI.NE.0)THEN
*
* Primary divisions optimization
*
*    The optimization provide by IGAXI0 is better than the one provide
* by IGAXI4. When integer labelling is required, IGAXI0 is invoke first
* and only if the result is not an integer labelling, IGAXI4 is invoked.
*
         CALL IGAXI0(WMIN,WMAX,N1A,BL,BH,NB,BWID)
         IF(IOPTI.NE.0)THEN
            IF(BL.NE.FLOAT(INT(BL)).OR.BWID.NE.FLOAT(INT(BWID)))THEN
               CALL IGAXI4(WMIN,WMAX,N1A,BL,BH,NB,BWID)
            ENDIF
         ENDIF
         IF((WMIN-BL).GT.EPSIL)THEN
            BL = BL+BWID
            NB = NB-1
         ENDIF
         IF((BH-WMAX).GT.EPSIL)THEN
            BH = BH-BWID
            NB = NB-1
         ENDIF
         IF(XMAX.EQ.XMIN)THEN
            RTYW  = (YMAX-YMIN)/(WMAX-WMIN)
            XXMIN = XMIN
            XXMAX = XMAX
            YYMIN = RTYW*(BL-WMIN)+YMIN
            YYMAX = RTYW*(BH-WMIN)+YMIN
         ELSE
            RTXW  = (XMAX-XMIN)/(WMAX-WMIN)
            XXMIN = RTXW*(BL-WMIN)+XMIN
            XXMAX = RTXW*(BH-WMIN)+XMIN
            IF(YMAX.EQ.YMIN)THEN
               YYMIN = YMIN
               YYMAX = YMAX
            ELSE
               ALFA  = (YMAX-YMIN)/(XMAX-XMIN)
               BETA  = (YMIN*XMAX-YMAX*XMIN)/(XMAX-XMIN)
               YYMIN = ALFA*XXMIN+BETA
               YYMAX = ALFA*XXMAX+BETA
            ENDIF
         ENDIF
         WMIN = BL
         WMAX = BH
*
* Secondary divisions optimization
*
         NB2 = N2A
         IF(IOPTNN.EQ.0.AND.N2A.GT.1.AND.BWID.GT.0.)THEN
            CALL IGAXI0(WMIN,WMIN+BWID,N2A,BL2,BH2,NB2,BWID2)
         ENDIF
*
* Tertiary divisions optimization
*
         NB3 = N3A
         IF(IOPTNN.EQ.0.AND.N3A.GT.1.AND.BWID2.GT.0.)THEN
            CALL IGAXI0(BL2,BL2+BWID2,N3A,BL3,BH3,NB3,BWID3)
         ENDIF
*
         N1AOLD = N1A
         NN1OLD = NN(1)
         N1A    = NB
         NN(3)  = MAX(NB3,1)
         NN(2)  = MAX(NB2,1)*NN(3)
         NN(1)  = MAX(N1A,1)*NN(2)+1
         LOOP   = NN(1)
      ENDIF
*
*              Coordinates are normalized
*
      RATIO1 = (RVXMAX-RVXMIN)/(RWXMAX-RWXMIN)
      RATIO2 = (RVYMAX-RVYMIN)/(RWYMAX-RWYMIN)
      X0     = RATIO1*(XMIN-RWXMIN)+RVXMIN
      X1     = RATIO1*(XMAX-RWXMIN)+RVXMIN
      Y0     = RATIO2*(YMIN-RWYMIN)+RVYMIN
      Y1     = RATIO2*(YMAX-RWYMIN)+RVYMIN
      IF(XMIN.NE.XMAX)THEN
         GRILEN = RATIO2*(GRIL1-RWYMIN)+RVYMIN-Y0
      ELSE
         GRILEN = RATIO1*(GRIL1-RWXMIN)+RVXMIN-X0
      ENDIF
      IF((IOPTNN.EQ.0).OR.(IOPTI.NE.0))THEN
         XX0 = RATIO1*(XXMIN-RWXMIN)+RVXMIN
         XX1 = RATIO1*(XXMAX-RWXMIN)+RVXMIN
         YY0 = RATIO2*(YYMIN-RWYMIN)+RVYMIN
         YY1 = RATIO2*(YYMAX-RWYMIN)+RVYMIN
         IF(XMIN.NE.XMAX)THEN
            GRILEN = RATIO2*(GRIL1-RWYMIN)+RVYMIN-YY0
         ELSE
            GRILEN = RATIO1*(GRIL1-RWXMIN)+RVXMIN-XX0
         ENDIF
      ENDIF
*
      IF((X0.EQ.X1).AND.(Y0.EQ.Y1))THEN
         CALL IGERR('Length of axis is zero','IGAXIS')
         GOTO 220
      ENDIF
*
*              Return WMIN, WMAX and the number of primary divisions
*
      IF(IOPTX.NE.0)THEN
         RWMI = WMIN
         RWMA = WMAX
         NNDI = N1A
         GOTO 220
      ENDIF
*
      ICTR   = INTR
      CHSIZ  = RCHH
      CHUPXV = RCHUX
      CHUPYV = RCHUY
      IALH   = ITXALH
      IALV   = ITXALV
      ILNV   = ILN
      ICLIPV = ICLIP
*
      CALL ISCLIP(0)
      CALL ISELNT(0)
      CALL ISLN(1)
*
      TICK   = .03
      ARROL  = 0.03
      ARROW  = 0.0075
      CHEI   = .02
      OFFSEL = .04
*
      FLEXE  = .FALSE.
*
*              Calculate length of axis
*
      AXLEN = SQRT((X1-X0)*(X1-X0)+(Y1-Y0)*(Y1-Y0))
      IF(AXLEN.EQ.0)THEN
         CALL IGERR('Length of axis is zero','IGAXIS')
         GOTO 210
      ENDIF
      IF((IOPTNN.EQ.0).OR.(IOPTI.NE.0))THEN
         AXLENN = SQRT((XX1-XX0)*(XX1-XX0)+(YY1-YY0)*(YY1-YY0))
         AXLEN0 = SQRT((XX0-X0)*(XX0-X0)+(YY0-Y0)*(YY0-Y0))
         AXLEN1 = SQRT((X1-XX1)*(X1-XX1)+(Y1-YY1)*(Y1-YY1))
         IF(AXLENN.LT.EPSIL)THEN
            IOPTNN = 1
            IOPTI  = 0
            WMIN   = RWMI
            WMAX   = RWMA
            N1A    = N1AOLD
            NN(1)  = NN1OLD
            LOOP   = NN(1)
         ENDIF
      ENDIF
*
*              Calculate cosine of angle
*
      PHI    = ATAN2((Y1-Y0),(X1-X0))
      COSFI  = COS(PHI)
      SINFI  = SIN(PHI)
      ACOSFI = ABS(COSFI)
      ASINFI = ABS(SINFI)
      IF(ACOSFI.LE.EPSIL)THEN
         ACOSFI = 0.
         COSFI  = 0.
      ENDIF
      IF(ASINFI.LE.EPSIL)THEN
         ASINFI = 0.
         SINFI  = 0.
      ENDIF
      RATIO3 = (ASINFI*RATIO1)+(ACOSFI*RATIO2)
      IF(IOPTV.NE.0)RATIO3 = RATIO2
*
*              MSIDE positive, tick marks on positive side
*              MSIDE negative, tick marks on negative side
*              MSIDE zero, tick marks on both sides
*              Default is positive except for vertical axis
*
      MSIDE=1
      IF((X0.EQ.X1).AND.(Y1.GT.Y0))MSIDE=-1
      IF(IOPTPL.EQ.1)MSIDE=1
      IF(IOPTN.EQ.1)MSIDE=-1
      IF((IOPTPL+IOPTN).EQ.2)MSIDE=0
*
      LSIDE=-MSIDE
      IF(IOPTEQ.EQ.1)LSIDE=MSIDE
      IF((IOPTPL+IOPTN).EQ.2)THEN
         LSIDE=-1
         IF(IOPTEQ.EQ.1)LSIDE=1
      ENDIF
      XLSIDE=LSIDE
      XMSIDE=MSIDE
*
*              Tick marks size
*
      SITIC=SIGN(1.0,XMSIDE)
      IF((IOPTS.EQ.1).AND.(RTMS.GT.0))THEN
         TMS=RATIO3*RTMS
         ATICK(1)=SITIC*TMS
      ELSE
         ATICK(1)=SITIC*TICK*AXLEN
      ENDIF
*
      ATICK(2)=ATICK(1)/2.
      ATICK(3)=ATICK(2)/2.
*
*              Arrow size
*
      ARROLE=ARROL*AXLEN
      ARROWI=ARROW*AXLEN
*
*              Set the side of the grid
*
      IF((X0.EQ.X1).AND.(Y1.GT.Y0))THEN
         SIWIR=-1
      ELSE
         SIWIR=1
      ENDIF
*
*              Draw the axis if needed...
*
      RLWSCS=RLWSC
      CALL ISLWSC(1.)
      IF(IOPTB.EQ.0)THEN
         XPL(1)=X0
         XPL(2)=X1
         YPL(1)=Y0
         YPL(2)=Y1
         CALL IPL(2,XPL,YPL)
      ENDIF
*
*              Draw the arrow if needed...
*
      IF(IOPTA.NE.0)THEN
         XPL(1)=X1
         XPL(4)=X1
         YPL(1)=Y1
         YPL(4)=Y1
         P=AXLEN-ARROLE
         CALL IGAXI1 (P,-ARROWI,COSFI,SINFI,X0,Y0,XPL(2),YPL(2))
         CALL IGAXI1 (P,ARROWI,COSFI,SINFI,X0,Y0,XPL(3),YPL(3))
         CALL IPL(4,XPL,YPL)
      ENDIF
      CALL ISLWSC(RLWSCS)
*
*              Now the line have the text color (ticks marks)
*
      IPLCIS=IPLCI
      CALL ISPLCI(ITXCI)
*
*              No bining
*
      IF(NDIV.EQ.0)GOTO 210
      IF(WMIN.EQ.WMAX)THEN
         CALL IGERR('WMIN=WMAX (cf. HIGZ doc.)','IGAXIS')
         GOTO 210
      ENDIF
*
*              Labels preparation:
*
*              Now determine character height
*              (if LOGICAL AXFLAG=.TRUE. then we take the same
*              size than for the previous axe, stocked in
*              CHAXSZ (COMMON /AXSIZ/).
*
      IF(.NOT.AXFLAG)THEN
         IF((IOPTH.EQ.0).OR.(RALH.LT.0)) THEN
            CHHEI=CHEI*AXLEN
         ELSE
            IF(X0.NE.X1) THEN
               CHHEI=RATIO3*RALH
            ELSE
               CHHEI=RATIO2*RALH
            ENDIF
         ENDIF
         CHAXSZ=CHHEI
      ELSE
         CHHEI=CHAXSZ
      ENDIF
      CALL ISCHH (CHHEI)
*
*              Now determine the labels orientation in case of overlaps
*              (with alphanumeric labels for horizontal axis).
*
      IF(IOPT0.EQ.0.AND.IOPTO.EQ.0.AND.IOPTY.EQ.0)THEN
         IF(IOPTT.NE.0.AND.YMIN.EQ.YMAX)THEN
            BINWDH = 0.9*(AXLEN/FLOAT(N1A))
            TEXTW  = 0.
            DO 10 I=1,NHILAB
               CALL IGTEXT(0.,0.,HILABS(I),CHHEI,TEXTW,'S')
               IF(TEXTW.GT.BINWDH)THEN
                  IOPT0 = 1
                  IOPTR = 1
                  IOPTC = 0
                  IOPTL = 0
                  GOTO 20
               ENDIF
   10       CONTINUE
         ENDIF
      ENDIF
*
*              Now determine orientation of labels on axis
*
   20 IF(COSFI.GT.0.)THEN
         CALL ISCHUP(-SINFI,COSFI)
      ELSE
         CALL ISCHUP(SINFI,-COSFI)
      ENDIF
      IF(X0.EQ.X1)  CALL ISCHUP(0.,1.)
      IF(IOPTV.NE.0)CALL ISCHUP(0.,1.)
      IF(IOPTP.NE.0)CALL ISCHUP(-SINFI,COSFI)
      IF(IOPTO.NE.0)CALL ISCHUP(COSFI,SINFI)
      IF(IOPT0.NE.0)CALL IGSET('TANG',90.)
*
*              Now determine text alignment
*
      IALX=2
      IALY=0
      IF(X0.EQ.X1)IALX=3
      IF(Y0.NE.Y1)IALY=3
      IF(IOPTC.EQ.1)IALX=2
      IF(IOPTR.EQ.1)IALX=3
      IF(IOPTL.EQ.1)IALX=1
      CALL ISTXAL(IALX,IALY)
*
*              Position of labels in Y
*
      SILAB=SIGN(1.0,XLSIDE)
      IF((IOPTD.EQ.1).AND.(RALD.GE.0))THEN
         ALD=RATIO3*RALD
         YLAB=SILAB*ALD
      ELSE
         IF(IOPTG.EQ.0)THEN
            YLAB=SILAB*OFFSEL*AXLEN
         ELSE
            YLAB=SILAB*OFFSEL*AXLEN*1.3
         ENDIF
      ENDIF
*
*              Draw the linear tick marks if needed...
*
      IF(IOPTG.EQ.0)THEN
         IF(NDIV.NE.0)THEN
            IF((IOPTNN.NE.0).AND.(IOPTI.EQ.0))THEN
               DXTICK=AXLEN/(LOOP-1.)
            ELSE
               DXTICK=AXLENN/(LOOP-1.)
            ENDIF
            DO 30 K=0,LOOP-1
               L=3
               IF(MOD(K,NN(3)).EQ.0)L=2
               IF(MOD(K,NN(2)).EQ.0)L=1
               XTICK=K*DXTICK
               YTICK=0.
               IF(MSIDE.EQ.0)YTICK=YTICK-ATICK(L)
               IF((IOPTNN.NE.0).AND.(IOPTI.EQ.0))THEN
                  CALL IGAXI1(XTICK,YTICK,COSFI,SINFI,X0,Y0
     +                        ,XPL(2),YPL(2))
                  CALL IGAXI1(XTICK,ATICK(L),COSFI,SINFI,X0,Y0
     +                        ,XPL(1),YPL(1))
               ELSE
                  CALL IGAXI1(XTICK,YTICK,COSFI,SINFI,XX0,YY0
     +                        ,XPL(2),YPL(2))
                  CALL IGAXI1(XTICK,ATICK(L),COSFI,SINFI,XX0,YY0
     +                        ,XPL(1),YPL(1))
               ENDIF
               IF(IOPTV.NE.0)THEN
                  IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                     IF(MSIDE.NE.0)THEN
                        XPL(1)=XPL(2)
                        IF(COSFI.GT.0)THEN
                           YPL(1)=YPL(2)+ATICK(L)
                        ELSE
                           YPL(1)=YPL(2)-ATICK(L)
                        ENDIF
                     ELSE
                        XML=(XPL(1)+XPL(2))/2.
                        YML=(YPL(1)+YPL(2))/2.
                        XPL(1)=XML
                        XPL(2)=XML
                        YPL(1)=YML+ATICK(L)
                        YPL(2)=YML-ATICK(L)
                     ENDIF
                  ENDIF
               ENDIF
               IF(ABS(XPL(2)-X0).LT.EPSIL.AND.
     +            ABS(YPL(2)-Y0).LT.EPSIL.AND.
     +            IOPTA.NE.0)GOTO 30
               IF(ABS(XPL(2)-X1).LT.EPSIL.AND.
     +            ABS(YPL(2)-Y1).LT.EPSIL.AND.
     +            IOPTA.NE.0)GOTO 30
               CALL IPL(2,XPL,YPL)
*
               IF(IOPTW.NE.0)THEN
                  IF(L.EQ.1)THEN
                     IF((IOPTNN.NE.0).AND.(IOPTI.EQ.0))THEN
                        CALL IGAXI1(XTICK,0.,COSFI
     +                              ,SINFI,X0,Y0
     +                              ,XPL(2),YPL(2))
                        CALL IGAXI1(XTICK,SIWIR*GRILEN
     +                              ,COSFI,SINFI,X0,Y0
     +                              ,XPL(1),YPL(1))
                     ELSE
                        CALL IGAXI1(XTICK,0.,COSFI
     +                              ,SINFI,XX0,YY0
     +                              ,XPL(2),YPL(2))
                        CALL IGAXI1(XTICK,SIWIR*GRILEN
     +                              ,COSFI,SINFI,XX0,YY0
     +                              ,XPL(1),YPL(1))
                     ENDIF
                     CALL ISLN(IGRITY)
                     CALL IPL(2,XPL,YPL)
                     CALL ISLN(1)
                  ENDIF
               ENDIF
*
   30       CONTINUE
*
            XTICK0=0.
            XTICK1=XTICK
*
            IF(((IOPTNN.EQ.0).OR.(IOPTI.NE.0)).AND.(AXLEN0.NE.0))THEN
               LOOP0=INT(AXLEN0/DXTICK)
               DO 40 K=0,LOOP0
                  L=3
                  IF(MOD(K,NN(3)).EQ.0)L=2
                  IF(MOD(K,NN(2)).EQ.0)L=1
                  YTICK0=0.
                  IF(MSIDE.EQ.0)YTICK0=YTICK0-ATICK(L)
                  CALL IGAXI1(XTICK0,YTICK0,COSFI,SINFI,XX0,YY0
     +                        ,XPL(2),YPL(2))
                  CALL IGAXI1(XTICK0,ATICK(L),COSFI,SINFI,XX0,YY0
     +                        ,XPL(1),YPL(1))
                  IF(IOPTV.NE.0)THEN
                     IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                        IF(MSIDE.NE.0)THEN
                           XPL(1)=XPL(2)
                           IF(COSFI.GT.0)THEN
                              YPL(1)=YPL(2)+ATICK(L)
                           ELSE
                              YPL(1)=YPL(2)-ATICK(L)
                           ENDIF
                        ELSE
                           XML=(XPL(1)+XPL(2))/2.
                           YML=(YPL(1)+YPL(2))/2.
                           XPL(1)=XML
                           XPL(2)=XML
                           YPL(1)=YML+ATICK(L)
                           YPL(2)=YML-ATICK(L)
                        ENDIF
                     ENDIF
                  ENDIF
                  CALL IPL(2,XPL,YPL)
*
                  IF(IOPTW.NE.0)THEN
                     IF(L.EQ.1)THEN
                        CALL IGAXI1(XTICK0,0.
     +                             ,COSFI,SINFI,XX0,YY0
     +                             ,XPL(2),YPL(2))
                        CALL IGAXI1(XTICK0,SIWIR*GRILEN
     +                             ,COSFI,SINFI,XX0,YY0
     +                             ,XPL(1),YPL(1))
                        CALL ISLN(IGRITY)
                        CALL IPL(2,XPL,YPL)
                        CALL ISLN(1)
                     ENDIF
                  ENDIF
*
                  XTICK0=XTICK0-DXTICK
   40          CONTINUE
            ENDIF
*
            IF(((IOPTNN.EQ.0).OR.(IOPTI.NE.0)).AND.(AXLEN1.NE.0))THEN
               LOOP1=INT(AXLEN1/DXTICK)
               DO 50 K=0,LOOP1
                  L=3
                  IF(MOD(K,NN(3)).EQ.0)L=2
                  IF(MOD(K,NN(2)).EQ.0)L=1
                  YTICK1=0.
                  IF(MSIDE.EQ.0)YTICK1=YTICK1-ATICK(L)
                  CALL IGAXI1(XTICK1,YTICK1,COSFI,SINFI,XX0,YY0
     +                        ,XPL(2),YPL(2))
                  CALL IGAXI1(XTICK1,ATICK(L),COSFI,SINFI,XX0,YY0
     +                        ,XPL(1),YPL(1))
                  IF(IOPTV.NE.0)THEN
                     IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                        IF(MSIDE.NE.0)THEN
                           XPL(1)=XPL(2)
                           IF(COSFI.GT.0)THEN
                              YPL(1)=YPL(2)+ATICK(L)
                           ELSE
                              YPL(1)=YPL(2)-ATICK(L)
                           ENDIF
                        ELSE
                           XML=(XPL(1)+XPL(2))/2.
                           YML=(YPL(1)+YPL(2))/2.
                           XPL(1)=XML
                           XPL(2)=XML
                           YPL(1)=YML+ATICK(L)
                           YPL(2)=YML-ATICK(L)
                        ENDIF
                     ENDIF
                  ENDIF
                  CALL IPL(2,XPL,YPL)
*
                  IF(IOPTW.NE.0)THEN
                     IF(L.EQ.1)THEN
                        CALL IGAXI1(XTICK1,0.
     +                             ,COSFI,SINFI,XX0,YY0
     +                             ,XPL(2),YPL(2))
                        CALL IGAXI1(XTICK1,SIWIR*GRILEN
     +                             ,COSFI,SINFI,XX0,YY0
     +                             ,XPL(1),YPL(1))
                        CALL ISLN(IGRITY)
                        CALL IPL(2,XPL,YPL)
                        CALL ISLN(1)
                     ENDIF
                  ENDIF
*
                  XTICK1=XTICK1+DXTICK
   50          CONTINUE
            ENDIF
         ENDIF
      ENDIF
*
*              Draw the numeric labels if needed...
*
      IF(IOPTU.EQ.0)THEN
         IF(IOPTG.EQ.0)THEN
            IF(N1A.NE.0)THEN
*
*              Spacing of labels
*
               IF((WMIN.EQ.WMAX).OR.(NDIV.EQ.0))THEN
                  CALL IGERR('WMIN=WMAX or NDIV=0 (cf. HIGZ doc.)'
     +            ,'IGAXIS')
                  GOTO 210
               ENDIF
               WLAB=WMIN
               DWLAB=(WMAX-WMIN)/FLOAT(N1A)
               IF((IOPTNN.NE.0).AND.(IOPTI.EQ.0))THEN
                  DXLAB=AXLEN/(N1A)
               ELSE
                  DXLAB=AXLENN/(N1A)
               ENDIF
*
*              Here we have to decide what format to generate
*              (for numeric labels only)
*
               IF(IOPTT.EQ.0)THEN
*
*              Test the magnitude, decide format
*
                  FLEXE=.FALSE.
                  NEXE=0
                  FLEXPO=.FALSE.
                  FLEXNE=.FALSE.
                  WW=MAX(ABS(WMIN),ABS(WMAX))
*
*              First case : (WMAX-WMIN)/N1A less than 0.001
*              (0.001 precision of 5 (NCAR) characters). Then we use x 10 n
*              format. If AF >=0 x10 n cannot be used
*
                  IF((ABS(WMAX-WMIN)/N1A).LT.0.00099)THEN
                     AF    = LOG10(WW)+EPSIL
                     IF(AF.GE.0.)GOTO 60
                     FLEXE = .TRUE.
                     NEXE  = INT(AF)
                     IEXE  = IABS(NEXE)
                     WLAB  = WLAB*(10.**IEXE)
                     DWLAB = DWLAB*(10.**IEXE)
                     IF1   = NCAR
                     IF2   = NCAR-2
                     GOTO 110
                  ENDIF
*
   60             IF(WW.GE.1.)THEN
                     AF=LOG10(WW)
                  ELSE
                     AF=LOG10(WW*0.0001)
                  ENDIF
                  AF=AF+EPSIL
                  NF=AF+1.0
                  IF(NF.GT.NCAR)FLEXPO=.TRUE.
                  IF(NF.LT.(-NCAR))FLEXNE=.TRUE.
*
*              Use x 10 n format.
*
                  IF(FLEXPO)THEN
                     FLEXE=.TRUE.
   70                IF(WW.GT.(10**(NCAR-1)))THEN
                        NEXE=NEXE+1
                        WW=WW/10.
                        WLAB=WLAB/10.
                        DWLAB=DWLAB/10.
                        GOTO 70
                     ENDIF
                  ENDIF
*
                  IF(FLEXNE)THEN
                     FLEXE=.TRUE.
                     RNE=1./10.**(NCAR-2)
   80                IF(WW.LT.RNE)THEN
                        NEXE=NEXE-1
                        WW=WW*10.
                        WLAB=WLAB*10.
                        DWLAB=DWLAB*10.
                        GOTO 80
                     ENDIF
                  ENDIF
*
                  NA=0
                  DO 90  I=NCAR-1,1,-1
                     ECAR=10**I
                     IF(ABS(WW).LT.ECAR)NA=NCAR-I
   90             CONTINUE
                  NDYN=N1A
  100             IF(NDYN.NE.0)THEN
                     IF((ABS((WMAX-WMIN)/NDYN).LE.0.999).AND.
     +                  (NA.LT.(NCAR-2)))THEN
                        NA=NA+1
                        NDYN=NDYN/10
                        GOTO 100
                     ENDIF
                  ENDIF
*
*              FORTRAN 77 internal write
*
                  IF2 = NA
                  IF1 = MAX(NF+NA,NCAR)+1
*
  110             IF(MIN(WMIN,WMAX).LT.0.)IF1 = IF1+1
                  IF1 = MIN(IF1,32)
*
* In some cases, IF1 and IF2 are too small....
*
  120             IF(DWLAB.lt.10.**FLOAT(-IF2))THEN
                     IF1 = IF1+1
                     IF2 = IF2+1
                     GOTO 120
                  ENDIF
*
                  WRITE (CODED,'(2H(F,I2,1H.,I2,1H))') IF1,IF2
*
               ENDIF
*
*              Here we draw labels
*
               IF(IOPTM.NE.0)THEN
                  ILOOP=N1A-1
               ELSE
                  ILOOP=N1A
               ENDIF
               DO 150 K=0,ILOOP
                  XLAB=DXLAB*K
                  IF(IOPTM.NE.0)THEN
                     XLAB=XLAB+(DXLAB/2.)
                  ENDIF
*
                  IF(IOPTT.EQ.0)THEN
                     WRITE(LABEL,CODED)WLAB
                     WLAB=WLAB+DWLAB
*
*              Here we eliminate the blanks around the label.
*
                     CALL IGAXI2(LABEL,ISTA,IEND)
*
*              Here we check if '.' is preceded by a number.
*
                     CHTEMP=' '
                     IF(LABEL(ISTA:ISTA).EQ.'.')
     +                  CHTEMP='0'//LABEL(ISTA:IEND)
                     IF(LABEL(ISTA:ISTA+1).EQ.'-.')
     +                  CHTEMP='-0'//LABEL(ISTA+1:IEND)
                     IF(CHTEMP.NE.' ')THEN
                        LABEL=CHTEMP
                        ISTA=1
                        IEND=LENOCC(LABEL)
                     ENDIF
*
*              Here we eliminate the non significiant 0 after '.'
*
  130                IF(LABEL(IEND:IEND).EQ.'0')THEN
                        IEND=IEND-1
                        GOTO 130
                     ENDIF
*
*              Here we eliminate the dot, unless dot is forced.
*
                     IF(LABEL(IEND:IEND).EQ.'.')THEN
                        IF(IOPTDO.EQ.0)IEND=IEND-1
                     ENDIF
                  ENDIF
*
*              Here we generate labels (numeric or alphanumeric).
*
                  IF((IOPTNN.NE.0).AND.(IOPTI.EQ.0))THEN
                     CALL IGAXI1 (XLAB,YLAB,COSFI,SINFI,X0,Y0,XX,YY)
                  ELSE
                     CALL IGAXI1 (XLAB,YLAB,COSFI,SINFI,XX0,YY0,XX,YY)
                  ENDIF
                  IF((Y0.EQ.Y1).AND.(IOPTO.EQ.0).AND.(IOPT0.EQ.0))THEN
                     IF(LSIDE.LT.0)THEN
                        YY=YY-CHHEI
                     ENDIF
                  ENDIF
                  IF(IOPTV.NE.0)THEN
                     IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                        IF((IOPTNN.NE.0).AND.(IOPTI.EQ.0))THEN
                           CALL IGAXI1 (XLAB,0.,COSFI,SINFI,X0,Y0,XX,YY)
                        ELSE
                           CALL IGAXI1 (XLAB,0.,COSFI,SINFI,XX0,YY0,XX,
     +                     YY)
                        ENDIF
                        IF(COSFI.GT.0)THEN
                           YY=YY+YLAB
                           XX=XX+((FLOAT(IEND-ISTA+1)*RCHH)/2)*SINFI
                        ELSE
                           YY=YY-YLAB
                           XX=XX-((FLOAT(IEND-ISTA+1)*RCHH)/2)*SINFI
                        ENDIF
                     ENDIF
                  ENDIF
                  IF((IOPTY.EQ.0).OR.(X0.EQ.X1))THEN
                     IF(IOPTT.EQ.0)THEN
                        IF(ISTA.GT.IEND)THEN
                           CHTEMP=' '
                        ELSE
                           CHTEMP=LABEL(ISTA:IEND)
                        ENDIF
                        CALL ITX(XX,YY,CHTEMP)
                     ELSE
                        IF(K+1.GT.NHILAB)THEN
                           CHTEMP=' '
                        ELSE
                           CHTEMP=HILABS(K+1)
                        ENDIF
                        CALL ITX(XX,YY,CHTEMP)
                     ENDIF
                  ELSE
*
*              Text alignment is down
*
                     IF(IOPTT.EQ.0)THEN
                        LNLEN=IEND-ISTA+1
                     ELSE
                        IF(K+1.GT.NHILAB)THEN
                           LNLEN=0
                        ELSE
                           LNLEN=LENOCC(HILABS(K+1))
                        ENDIF
                     ENDIF
                     DO 140 L=1,LNLEN
                        IF(IOPTT.EQ.0)THEN
                           CHTEMP=LABEL(ISTA+L-1:ISTA+L-1)
                        ELSE
                           IF(LNLEN.EQ.0)THEN
                              CHTEMP=' '
                           ELSE
                              CHTEMP=HILABS(K+1)(L:L)
                           ENDIF
                        ENDIF
                        CALL ITX(XX,YY,CHTEMP)
                        YY=YY-(CHHEI*1.3)
  140                CONTINUE
                  ENDIF
  150          CONTINUE
*
*                Here we use the format x 10 ** n
*
               IF(FLEXE.AND.IOPTT.EQ.0.AND.NEXE.NE.0) THEN
                  WRITE(LABEL,'(I3)')NEXE
                  IF(X0.NE.X1)THEN
                     XFCT=XLAB
                     YFCT=YLAB-3*CHHEI
                  ELSE
                     XFCT=XLAB+3*CHHEI
                     YFCT=YLAB
                  ENDIF
                  CALL IGAXI2(LABEL,ISTA,IEND)
                  DEXPY=CHHEI
                  IF((NEXE.LE.0).OR.(Y0.EQ.Y1))THEN
                     DEXPX=2*CHHEI
                  ELSE
                     DEXPX=CHHEI
                  ENDIF
                  IF(COSFI.GT.0)THEN
                     XEXP=XFCT+DEXPX
                     YEXP=YFCT+DEXPY
                  ELSE
                     XEXP=XFCT-DEXPX
                     YEXP=YFCT-DEXPY
                  ENDIF
                  IF(X0.EQ.X1)THEN
                     IF(Y0.LT.Y1)THEN
                        XEXP=XFCT+0.5*DEXPX
                        YEXP=YFCT-DEXPY
                     ELSE
                        XEXP=XFCT-DEXPX
                        YEXP=YFCT+DEXPY
                     ENDIF
                  ENDIF
                  IF((IOPTNN.NE.0).AND.(IOPTI.EQ.0))THEN
                     CALL IGAXI1 (XFCT,YFCT,COSFI,SINFI,X0,Y0,XX,YY)
                     CALL IGAXI1 (XEXP,YEXP,COSFI,SINFI,X0,Y0 ,XEXPT,
     +               YEXPT)
                  ELSE
                     CALL IGAXI1 (XFCT,YFCT,COSFI,SINFI,XX0,YY0,XX,YY)
                     CALL IGAXI1 (XEXP,YEXP,COSFI,SINFI,XX0,YY0 ,XEXPT,
     +               YEXPT)
                  ENDIF
                  IF(NEXE.NE.1)THEN
                     XX = XX-(IEND-ISTA)*(CHHEI*0.5)
                     CALL ITX(XX,YY,'x 10')
                     CALL ISCHH (CHHEI*0.8)
                     CHTEMP=LABEL(ISTA:IEND)
                     IF(X0.EQ.X1.AND.IOPTL.NE.0)XEXPT=XX+3.5*CHHEI
                     CALL ITX(XEXPT,YEXPT,CHTEMP)
                     CALL ISCHH (CHHEI)
                  ELSE
                     CALL ITX(XX,YY,'x 10')
                  ENDIF
               ENDIF
*
            ENDIF
         ENDIF
      ENDIF
*
*              Log axis
*
      IF(IOPTG.NE.0)THEN
         IF(NDIV.NE.0)THEN
            IF((WMIN.EQ.WMAX).OR.(NDIV.EQ.0)) THEN
               CALL IGERR('WMIN=WMAX or NDIV=0 (cf. HIGZ doc.)'
     +                   ,'IGAXIS')
               GOTO 210
            ENDIF
            IF(WMIN.LE.0.)  THEN
               CALL IGERR('Negative logarithmic axis','IGAXIS')
               GOTO 210
            ENDIF
            IF(WMAX.LE.0.)    THEN
               CALL IGERR('Negative logarithmic axis','IGAXIS')
               GOTO 210
            ENDIF
            XMNLOG = LOG10(WMIN)
            IF(XMNLOG.GT.0.)THEN
               XMNLOG = XMNLOG+1.E-6
            ELSE
               XMNLOG = XMNLOG-1.E-6
            ENDIF
            X00    = 0.
            X11    = AXLEN
            H2     = LOG10(WMAX)
            H2SAV  = H2
            IF(H2.GT.0.)THEN
               H2 = H2+1.E-6
            ELSE
               H2 = H2-1.E-6
            ENDIF
            IH1    = IFIX(XMNLOG)
            IH2    = 1+IFIX(H2)
            NBININ = IH2-IH1+1
            AXMUL  = (X11-X00)/(H2SAV-XMNLOG)
*
*              If:
*                  a) The number of decades is less than two.
*                           and
*                  b) 1 =< WMIN and WMAX =<10000
*                           and
*                  c) There is no labels overlap.
*              then some intermediate label are drawn (INTLOG=.TRUE).
*
            INTLOG = .FALSE.
            IF(LOG10(WMAX/WMIN).LT.2..AND.
     +         WMIN.GE.0.01.AND.WMAX.LE.10000.)INTLOG = .TRUE.
            SMALD = (LOG10(1./0.9)/LOG10(WMAX/WMIN))*AXLEN
            IF(XMIN.EQ.XMAX.AND.SMALD.LE.CHHEI)INTLOG = .FALSE.
            IF(YMIN.EQ.YMAX)THEN
               TEXTW  = 0.
               CALL IGTEXT(0.,0.,'0.01',CHHEI,TEXTW,'S')
               IF(0.5*TEXTW.GT.SMALD)INTLOG = .FALSE.
            ENDIF
*
*              Plot decade and intermediate tick marks
*
            I    = IH1-2
            NLAB = IH1
            IF ((XMNLOG.GT.0.).AND.
     +         ((XMNLOG-FLOAT(IH1)).GT.0.)) NLAB = NLAB+1
            DO 190 J=1,NBININ
*
*              Plot decade
*
               I = I+1
               R = FLOAT(I)
               IF(Y0.EQ.Y1.AND.J.EQ.1)YLAB=YLAB-CHHEI*0.65
               XONE=X00+AXMUL*(R-XMNLOG)
               IF(X00.GT.XONE) GOTO 160
               IF(XONE.GT.X11) GOTO 200
               XTWO=XONE
               Y=0.
               IF(MSIDE.EQ.0)Y=Y-ATICK(1)
               CALL IGAXI1(XONE,Y,COSFI,SINFI,X0,Y0,XPL(2),YPL(2))
               CALL IGAXI1(XTWO,ATICK(1),COSFI,SINFI,X0,Y0
     +                     ,XPL(1),YPL(1))
               IF(IOPTV.NE.0)THEN
                  IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                     IF(MSIDE.NE.0)THEN
                        XPL(1)=XPL(2)
                        IF(COSFI.GT.0)THEN
                           YPL(1)=YPL(2)+ATICK(1)
                        ELSE
                           YPL(1)=YPL(2)-ATICK(1)
                        ENDIF
                     ELSE
                        XML=(XPL(1)+XPL(2))/2.
                        YML=(YPL(1)+YPL(2))/2.
                        XPL(1)=XML
                        XPL(2)=XML
                        YPL(1)=YML+ATICK(1)
                        YPL(2)=YML-ATICK(1)
                     ENDIF
                  ENDIF
               ENDIF
               CALL IPL(2,XPL,YPL)
*
               IF(IOPTW.NE.0)THEN
                  CALL IGAXI1(XONE,0.,COSFI,SINFI,X0,Y0,XPL(2),YPL(2))
                  CALL IGAXI1(XONE,SIWIR*GRILEN,COSFI,SINFI,X0,Y0
     +                        ,XPL(1),YPL(1))
                  CALL ISLN(IGRITY)
                  CALL IPL(2,XPL,YPL)
                  CALL ISLN(1)
               ENDIF
*
               IF(IOPTU.EQ.0) THEN
*
*              Here we generate labels (numeric only).
*
                  IF(INTLOG)THEN
                     RLAB = 10.**FLOAT(NLAB)
                     CALL IZRTOC(RLAB,LABEL)
                     CALL IGAXI2(LABEL,ISTA,IEND)
                     IF(LABEL(IEND:IEND).EQ.'.')IEND = IEND-1
                  ELSE
                     WRITE(LABEL,'(I3)')NLAB
                     CALL IGAXI2(LABEL,ISTA,IEND)
                  ENDIF
                  DEXPY=CHHEI
                  IF(NLAB.GT.0)THEN
                     DEXPX=1.25*CHHEI
                  ELSE
                     DEXPX=2.25*CHHEI
                  ENDIF
                  IF(COSFI.GT.0)THEN
                     XEXP=XONE+DEXPX
                     YEXP=YLAB+DEXPY
                  ELSE
                     XEXP=XONE-DEXPX
                     YEXP=YLAB-DEXPY
                  ENDIF
                  IF(Y0.EQ.Y1.AND.NLAB.LT.0)XEXP=XONE+0.5*DEXPX
                  IF(X0.EQ.X1)THEN
                     IF(Y0.LT.Y1)THEN
                        XEXP=XONE+0.5*DEXPX
                        YEXP=YLAB-DEXPY
                     ELSE
                        XEXP=XONE-DEXPX
                        YEXP=YLAB+DEXPY
                     ENDIF
                  ENDIF
                  CALL IGAXI1 (XONE,YLAB,COSFI,SINFI,X0,Y0,XX,YY)
                  CALL IGAXI1 (XEXP,YEXP,COSFI,SINFI,X0,Y0,XEXPT,YEXPT)
                  IF((Y0.EQ.Y1).AND.(IOPTO.EQ.0).AND.(IOPT0.EQ.0))THEN
                     IF(LSIDE.LT.0)THEN
                        YY=YY-CHHEI
                        YEXPT=YEXPT-CHHEI
                     ENDIF
                  ENDIF
                  IF(IOPTV.NE.0)THEN
                     IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                        XEXPT=XX+0.5*DEXPX
                        YEXPT=YY+DEXPY
                     ENDIF
                  ENDIF
                  IF(X0.EQ.X1.AND.IOPTL.NE.0)XEXPT=XX+2.*CHHEI
                  IF(N1A.EQ.0)GOTO 210
                  KMOD=NBININ/N1A
                  IF(KMOD.EQ.0)KMOD=1000000
                  IF((NBININ.LE.N1A)
     +                    .OR.(J.EQ.1)
     +                    .OR.(J.EQ.NBININ)
     +                    .OR.((NBININ.GT.N1A)
     +                    .AND.(MOD(J,KMOD).EQ.0)))THEN
                     IF((NLAB.NE.0).AND.(NLAB.NE.1))THEN
                        IF(INTLOG)THEN
                           CHTEMP=LABEL(ISTA:IEND)
                           CALL ITX(XX,YY,CHTEMP)
                        ELSE
                           XX = XX-(IEND-ISTA)*(CHHEI*0.5)
                           CALL ITX(XX,YY,'10')
                           CALL ISCHH (CHHEI*0.8)
                           CHTEMP=LABEL(ISTA:IEND)
                           CALL ITX(XEXPT,YEXPT,CHTEMP)
                           CALL ISCHH (CHHEI)
                        ENDIF
                     ENDIF
                     IF(NLAB.EQ.0)CALL ITX(XX,YY,'1')
                     IF(NLAB.EQ.1)CALL ITX(XX,YY,'10')
                  ENDIF
                  NLAB=NLAB+1
               ENDIF
  160          CONTINUE
*
               DO 180 K=2,9
*
*              Plot intermediate tick marks
*
                  XONE=X00+AXMUL*(LOG10(FLOAT(K))+FLOAT(I)-XMNLOG)
                  IF(X00.GT.XONE) GOTO 180
                  IF(XONE.GT.X11) GOTO 200
                  Y=0.
                  IF(MSIDE .NE. 0) GOTO 170
                  Y=Y-ATICK(2)
  170             CONTINUE
                  XTWO=XONE
                  CALL IGAXI1(XONE,Y,COSFI,SINFI
     +                       ,X0,Y0,XPL(2),YPL(2))
                  CALL IGAXI1(XTWO,ATICK(2),COSFI,SINFI,X0,Y0
     +                       ,XPL(1),YPL(1))
                  IF(IOPTV.NE.0)THEN
                     IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                        IF(MSIDE.NE.0)THEN
                           XPL(1)=XPL(2)
                           IF(COSFI.GT.0)THEN
                              YPL(1)=YPL(2)+ATICK(2)
                           ELSE
                              YPL(1)=YPL(2)-ATICK(2)
                           ENDIF
                        ELSE
                           XML=(XPL(1)+XPL(2))/2.
                           YML=(YPL(1)+YPL(2))/2.
                           XPL(1)=XML
                           XPL(2)=XML
                           YPL(1)=YML+ATICK(2)
                           YPL(2)=YML-ATICK(2)
                        ENDIF
                     ENDIF
                  ENDIF
                  IDN=N1A*2
                  IF((NBININ.LE.IDN).OR.
     +              ((NBININ.GT.IDN).AND.(K.EQ.5)))THEN
                     CALL IPL(2,XPL,YPL)
*
* Draw the intermediate LOG labels if requested
*
                     IF(INTLOG.AND.IOPTU.EQ.0)THEN
                        RLAB=FLOAT(K)*(10.**FLOAT(NLAB-1))
                        CALL IZRTOC(RLAB,CHTEMP)
                        LNLEN=LENOCC(CHTEMP)
                        IF(CHTEMP(LNLEN:LNLEN).EQ.'.')LNLEN=LNLEN-1
                        CALL IGAXI1 (XONE,YLAB,COSFI,SINFI,X0,Y0,XX,YY)
CCC                        IF((X0.EQ.X1).AND.(IOPTP.EQ.0))THEN
CCC                           IF(LSIDE.LT.0)THEN
CCC                              IF(NLAB.EQ.0)THEN
CCC                                 NCH=1
CCC                              ELSE
CCC                                 NCH=2
CCC                              ENDIF
CCC                              XX=XX+NCH*CHHEI
CCC                           ENDIF
CCC                        ENDIF
                        IF((Y0.EQ.Y1).AND.(IOPTO.EQ.0)
     +                               .AND.(IOPT0.EQ.0))THEN
                           IF(LSIDE.LT.0)THEN
                              YY=YY-CHHEI
                           ENDIF
                        ENDIF
                        IF(IOPTV.NE.0)THEN
                           IF((X0.NE.X1).AND.(Y0.NE.Y1))THEN
                              CALL IGAXI1(XONE,YLAB,COSFI,SINFI,X0,Y0
     +,                                   XX,YY)
                              IF(COSFI.GT.0)THEN
                                 YY=YY+YLAB
                              ELSE
                                 YY=YY-YLAB
                              ENDIF
                           ENDIF
                        ENDIF
                        CALL ITX(XX,YY,CHTEMP(1:LNLEN))
                     ENDIF
*
* Draw the intermediate LOG grid if only three decades are requested
*
                     IF(IOPTW.NE.0.AND.NBININ.LE.5)THEN
                        CALL IGAXI1(XONE,0.,COSFI,SINFI,X0,Y0,XPL(2)
     +,                             YPL(2))
                        CALL IGAXI1(XONE,SIWIR*GRILEN,COSFI,SINFI,X0,Y0
     +,                             XPL(1),YPL(1))
                        CALL ISLN(IGRITY)
                        CALL IPL(2,XPL,YPL)
                        CALL ISLN(1)
                     ENDIF
*
                  ENDIF
  180          CONTINUE
  190       CONTINUE
  200       CONTINUE
         ENDIF
      ENDIF
*
  210 CONTINUE
      CALL ISELNT(ICTR)
      CALL ISCHH(CHSIZ)
      CALL ISCHUP(CHUPXV,CHUPYV)
      CALL ISTXAL(IALH,IALV)
      CALL ISLN(ILNV)
      CALL ISPLCI(IPLCIS)
      CALL ISCLIP(ICLIPV)
  220 ZFLAG=ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGBOX, T=FORT.
* Revision 1.2  1996/09/25 14:57:17  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGBOX(X1,X2,Y1,Y2)
*.===========>
*.
*.   This routine draws a boxe. The boxe is drawn according to the
*.   current fill area attributes .
*.
*. _Input parameters:
*.
*.  REAL X1,Y1 : Left down corner (in WC) .
*.  REAL X2,Y2 : Right up corner (in WC) .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+SELF, IF=-GL, IF=-X11, IF=-FALCO.
+CDE, HIATT.
      DIMENSION X(5),Y(5)
+SELF.
      LOGICAL ZFSAV,PFSAV
*.______________________________________
*
      ZFSAV=ZFLAG
      PFSAV=PFLAG
      ZFLAG=.FALSE.
      PFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
+SELF, IF=GL,X11,FALCO,MACMPW.
      CALL IKBOX(X1,X2,Y1,Y2)
+SELF, IF=-GL, IF=-X11, IF=-FALCO, IF=-MACMPW.
      X(1)=X1
      X(2)=X2
      X(3)=X2
      X(4)=X1
      X(5)=X1
      Y(1)=Y1
      Y(2)=Y1
      Y(3)=Y2
      Y(4)=Y2
      Y(5)=Y1
      ILNOLD=ILN
      IF(GFLAG.OR.PFLAG)THEN
         IF(IFAIS.NE.0)THEN
            CALL IFA(4,X,Y)
         ENDIF
         IF(IFAIS.EQ.0.OR.IBORD.NE.0)THEN
            CALL ISLN(1)
            CALL IPL(5,X,Y)
            CALL ISLN(ILNOLD)
         ENDIF
      ENDIF
+SELF.
      ZFLAG=ZFSAV
      PFLAG=PFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
+SELF, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZBOX(X1,X2,Y1,Y2)
+SELF.
*
      END
+DECK,  IGCELL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      REAL FUNCTION IGCELL(NX,NY,V,I,J,IOPT)
*.==========>
*.
*.   Returns the value of cell defined by I and J according to the
*. value of NPAR PAR and CHOPT given to IGTABL. If IOPT=1 the content
*. of the cell I,J is returned, if IOPT=2 the error on the cell I,J is
*. returned. The data can come from an HBOOK histogram (IPACK=1), from
*. an HIGZ picture (IPACK=2) or from a FORTRAN array (IPACK=0).
*.
*..=========> (O.Couet)
+CDE, HIPACK.
+CDE, HIPAW.
      DIMENSION V(NX,1)
      REAL IGHCXY
*.___________________________________________
*
*
*              Get the content of the cell I,J (IOPT=1)
*
      IF (IOPT.EQ.1) THEN
         IF (IPACK.EQ.1) THEN
            IGCELL = IGHCXY(INT(V(1,1)),I,J,1)
         ELSEIF (IPACK.EQ.2) THEN
            IF (IDIM1.NE.0) THEN
               IGCELL = Q(INT(V(1,1))+I)
            ELSE
               IGCELL = Q(INT(V(1,1))+(J-1)*NX+I)
            ENDIF
         ELSE
            IF (IDIM1.NE.0) THEN
               IGCELL = V(I,1)
            ELSE
               IGCELL = V(I,J)
            ENDIF
         ENDIF
*
* Adjust the content to ZHIGH and ZLOW
*
         IF( ZHIGH.GT.ZLOW) THEN
            IF (IGCELL.GT.ZHIGH) IGCELL = ZHIGH
            IF (IGCELL.LT.ZLOW) IGCELL = ZLOW
         ENDIF
      ENDIF
*
*              Get the error on the cell I,J (IOPT=2)
*
      IF (IOPT.EQ.2) THEN
         IF (IPACK.EQ.1) THEN
            IGCELL = IGHCXY(INT(V(1,1)),I,J,2)
         ELSEIF (IPACK.EQ.2) THEN
            IF (IDIM1.NE.0) THEN
               IGCELL = SQRT(ABS(Q(INT(V(1,1))+I)))
            ELSE
               IGCELL = SQRT(ABS(Q(INT(V(1,1))+(J-1)*NX+I)))
            ENDIF
         ELSE
            IF (IDIM1.NE.0) THEN
               IGCELL = SQRT(ABS(V(I,1)))
            ELSE
               IGCELL = SQRT(ABS(V(I,J)))
            ENDIF
         ENDIF
      ENDIF
*
*              LOG scale is required
*
      IF (ILOG.NE.0) THEN
         IF (IGCELL.GT.0.) THEN
            IGCELL = LOG10(IGCELL)
         ELSE
            IGCELL = ZLOW
         ENDIF
      ENDIF
*
      END
+DECK,  IGCHWK, T=FORT.
* Revision 1.5  1998/01/30 15:22:16  couet
* - APOLLO version removed
* Revision 1.4  1998/01/28 14:34:20  couet
* - GGDM driver removed
* Revision 1.3  1997/10/23 12:29:53  mclareni
* NT mods
* Revision 1.2  1996/09/25 14:57:18  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGCHWK(IWTYP,IX,IY,IW,IH)
*.===========>
*.
*.  This routine allows to change the workstation type parameters
*. in the file higz_windows.dat.
*.
*..==========>
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF.
      CHARACTER*64    UHOME
      CHARACTER*128   TNAME
      LOGICAL         INIT,OPND,EXIST1
      SAVE            INIT,LUHOME,UHOME
      CHARACTER*48    CHWKTY(10)
+SELF, IF=-KERNEL,MSDOS.
      CHARACTER*80    FILEN
+SELF, IF=CRAY.
      INTEGER         GETENV
+SELF, IF=X11, IF=IBM, IF=-IBMMVS.
      CHARACTER*3 CHLUN
+SELF.
      DATA            INIT   /.FALSE./
      DATA            LUHOME /0/
      DATA            UHOME  /' '/
*.______________________________________
*
+SELF, IF=KERNEL, IF=-MSDOS.
      LUNWIN=20
      DO 10 I=20,99
         INQUIRE(UNIT=I,OPENED=OPND)
         IF(.NOT.OPND)THEN
            LUNWIN=I
            OPND=.TRUE.
            GOTO 20
         ENDIF
   10 CONTINUE
+SELF, IF=-KERNEL, IF=GKS,DI3000.
      LUNWIN=0
      OPND=.FALSE.
+SELF.
*
      IF(.NOT.OPND)RETURN
*
+SELF, IF=IBM.
   20 FILEN='/HIGZWIN DATA A'
+SELF, IF=-IBM, IF=-IPSC.
   20 FILEN='higz_windows.dat'
+SELF, IF=IPSC.
   20 FILEN='higz_windows'
+SELF, IF=-IBM.
*
      INQUIRE(FILE=FILEN,EXIST=EXIST1)
      IF(.NOT.EXIST1)THEN
*
         IF (.NOT.INIT) THEN
+SELF, IF=UNIX,CRAY.
            UHOME=' '
            CALL GETENVF('HOME',UHOME)
+SELF, IF=VAX.
            UHOME='SYS$LOGIN:'
+SELF, IF=-IBM.
            LUHOME=LENOCC(UHOME)
+SELF, IF=-VAX, IF=-IBM.
         IF (UHOME(LUHOME:LUHOME) .NE. '/'
+SELF, IF=-VAX, IF=-IBM, IF=WINNT.
     *       .OR. UHOME(LUHOME:LUHOME) .NE. '\'
+SELF, IF=-VAX, IF=-IBM.
     *                      ) THEN
              LUHOME=LUHOME+1
              UHOME(LUHOME:LUHOME)='/'
         ENDIF
+SELF, IF=-IBM.
            INIT=.TRUE.
         ENDIF
*
         TNAME = FILEN
         FILEN = UHOME(1:LUHOME)//TNAME
      ENDIF
+SELF.
*
   30 INQUIRE(FILE=FILEN,EXIST=EXIST1)
      IF(EXIST1)THEN
         OPEN(UNIT=LUNWIN,FILE=FILEN,FORM='FORMATTED',STATUS='OLD'
     +,       IOSTAT=ISTA)
      ELSE
         RETURN
      ENDIF
*
      DO 40 I=1,10
         READ(LUNWIN,'(A)')CHWKTY(I)
   40 CONTINUE
      CLOSE(LUNWIN)
      OPEN(UNIT=LUNWIN,FILE=FILEN,FORM='FORMATTED',STATUS='UNKNOWN'
     +, IOSTAT=ISTA)
      WRITE(CHWKTY(IWTYP), '(1X,I4.4,1X,I4.4,1X,I4.4,1X,I4.4)')IX,IY,
     +IW,IH
      DO 50 I=1,10
         WRITE(LUNWIN,'(A)',ERR=999)CHWKTY(I)
   50 CONTINUE
      CLOSE(LUNWIN)
*
  999 END
+DECK,  IGCLES, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      SUBROUTINE IGCLES
*.===========>
*.
*.   This routine clears the editing space
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(3),Y(3)
      LOGICAL ZFS,GFS,PFS
*.______________________________________
*
      CALL IZSAV
      ZFS=ZFLAG
      GFS=GFLAG
      PFS=PFLAG
      ZFLAG=.FALSE.
      PFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
*
      ICLIPS=ICLIP
      REDITS=REDIT
      CALL IGSRAP(0.)
      CALL ISCLIP(0)
      CALL ISELNT(0)
*
      CALL IGQWK(1,'MXDS',X)
      X2CL=MIN(X(1)/X(2),1.)*REDITS
      Y2CL=MIN(X(2)/X(1),1.)*REDITS
      X(1)=0.
      X(2)=X2CL
      X(3)=X2CL
      Y(1)=Y2CL
      Y(2)=Y2CL
      Y(3)=0.
      CALL IGSET('BORD',0.)
      CALL ISFACI(0)
      CALL ISFAIS(1)
      CALL ISLN(1)
      CALL ISPLCI(1)
      CALL IGBOX(0.,X2CL,0.,Y2CL)
      CALL IPL(3,X,Y)
*
      CALL IGSRAP(REDITS)
      CALL ISCLIP(ICLIPS)
      CALL IZSET
      ZFLAG=ZFS
      PFLAG=PFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFS
*
      END

+DECK,  IGCLI1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:33  mclareni
* Higz

      FUNCTION IGCLI1(X,Y,XCL1,XCL2,YCL1,YCL2)
*.===========>
*.
*.   Compute the endpoint codes for IGCLIP.
*.
*..==========> (O.Couet)
      IGCLI1=0
      ICODE=0
      IF(X.LT.XCL1)CALL SBIT1(ICODE,1)
      IF(X.GT.XCL2)CALL SBIT1(ICODE,2)
      IF(Y.LT.YCL1)CALL SBIT1(ICODE,3)
      IF(Y.GT.YCL2)CALL SBIT1(ICODE,4)
      IGCLI1=ICODE
*
      END

+DECK,  IGCLIP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      FUNCTION IGCLIP(X,Y,XCLIPL,XCLIPR,YCLIPB,YCLIPT)
*.===========>
*.
*.   Clipping routine: Cohen Sutherland algorithm.
*. If IGCLIP=0 the segment is outside the boundary.
*.
*. _Input parameters:
*.
*.  REAL X(2),Y(2) : Segment coordinates
*.  REAL XCLIPL,XCLIPR,YCLIPB,YCLIPT : Clipping boundary
*.
*. _Output parameters:
*.
*.  REAL X(2),Y(2) : New segment coordinates
*.
*. If IQUEST(50).NE.0 after a call to this function, the
*. line has been clipped.
*.
*..==========> (O.Couet)
+CDE, HIQUES.
      DIMENSION X(2),Y(2)
      PARAMETER (P=10000.)
*.______________________________________
*
      IGCLIP=0
*
      DO 10 I=1,2
         IF(ABS(XCLIPL-X(I)).LE.ABS((XCLIPR-XCLIPL)/P))X(I)=XCLIPL
         IF(ABS(XCLIPR-X(I)).LE.ABS((XCLIPR-XCLIPL)/P))X(I)=XCLIPR
         IF(ABS(YCLIPB-Y(I)).LE.ABS((YCLIPT-YCLIPB)/P))Y(I)=YCLIPB
         IF(ABS(YCLIPT-Y(I)).LE.ABS((YCLIPT-YCLIPB)/P))Y(I)=YCLIPT
   10 CONTINUE
*
*              Compute the first endpoint codes.
*
      ICODE1=IGCLI1(X(1),Y(1),XCLIPL,XCLIPR,YCLIPB,YCLIPT)
      ICODE2=IGCLI1(X(2),Y(2),XCLIPL,XCLIPR,YCLIPB,YCLIPT)
*
      IQUEST(50)=0
   20 IF((ICODE1+ICODE2).EQ.0)GOTO 30
      IQUEST(50)=1
*
*              The line lies entirely outside the clipping boundary
*
      IF(IAND(ICODE1,ICODE2).NE.0)THEN
         IGCLIP=0
         RETURN
      ENDIF
*
*              The line is subdivide into several parts
*
      IC=ICODE1
      IF(IC.EQ.0)IC=ICODE2
      IF(JBIT(IC,1).NE.0)THEN
         YT=Y(1)+(Y(2)-Y(1))*(XCLIPL-X(1))/(X(2)-X(1))
         XT=XCLIPL
      ENDIF
      IF(JBIT(IC,2).NE.0)THEN
         YT=Y(1)+(Y(2)-Y(1))*(XCLIPR-X(1))/(X(2)-X(1))
         XT=XCLIPR
      ENDIF
      IF(JBIT(IC,3).NE.0)THEN
         XT=X(1)+(X(2)-X(1))*(YCLIPB-Y(1))/(Y(2)-Y(1))
         YT=YCLIPB
      ENDIF
      IF(JBIT(IC,4).NE.0)THEN
         XT=X(1)+(X(2)-X(1))*(YCLIPT-Y(1))/(Y(2)-Y(1))
         YT=YCLIPT
      ENDIF
      IF(IC.EQ.ICODE1)THEN
         X(1)=XT
         Y(1)=YT
         ICODE1=IGCLI1(XT,YT,XCLIPL,XCLIPR,YCLIPB,YCLIPT)
      ELSE
         X(2)=XT
         Y(2)=YT
         ICODE2=IGCLI1(XT,YT,XCLIPL,XCLIPR,YCLIPB,YCLIPT)
      ENDIF
      GOTO 20
   30 IGCLIP=1
*
      END
+DECK,  IGCOLM, T=FORT.
* Revision 1.2  2002/04/04 10:18:20  couet
* - new routine IGCOL1 allowing to modify the number of axis divisions on
*   the axis color palette
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGCOLM(X1I,X2I,Y1I,Y2I,IC1,IC2,ZMIN,ZMAX,CHOPT)
+CDE, HIATT.
      CHARACTER*(*) CHOPT
      CHARACTER*8 CHOPAX
      DIMENSION IC2(*),IOPT(9)
      EQUIVALENCE (IOPTC,IOPT(1)),(IOPTB,IOPT(2))
      EQUIVALENCE (IOPTA,IOPT(3)),(IOPTH,IOPT(4))
      EQUIVALENCE (IOPTP,IOPT(5)),(IOPTG,IOPT(6))
      EQUIVALENCE (IOPTL,IOPT(7)),(IOPTR,IOPT(8))
      EQUIVALENCE (IOPTT,IOPT(9))
      DIMENSION LUT(8)
      COMMON /HICOLM/ NDIVZ
      DATA NDIVZ /10/
      DATA LUT /0,5,7,3,6,2,4,1/
*.______________________________________
*
      CALL UOPTC(CHOPT,'CBAHPGLRT',IOPT)
      X1 = X1I
      X2 = X2I
      Y1 = Y1I
      Y2 = Y2I
*
      IF(IOPTL.NE.0)THEN
         IF(INBCOL.GT.8)THEN
            IC1=8
            IC2(1)=INBCOL
         ELSE
            IC1=0
            IC2(1)=7
         ENDIF
      ENDIF
*
      IF(X1.EQ.X2.OR.Y1.EQ.Y2)THEN
         XX = 0.01*(RWXMAX-RWXMIN)
         X1 = RWXMAX+XX
         X2 = RWXMAX+4.*XX
         Y1 = RWYMIN
         Y2 = RWYMAX
      ENDIF
*
      IF(IOPTP.NE.0)THEN
         N=IC1
      ELSE
         N=IC2(1)-IC1+1
      ENDIF
      DY=(Y2-Y1)/FLOAT(N)
      DX=(X2-X1)/FLOAT(N)
*
*              Draw the levels with colors
*
      IF(IOPTC.NE.0)THEN
         CALL IGSET('BORD',0.)
         CALL IGSET('PLCI',1.)
         CALL IGSET('FAIS',1.)
         DO 10 I=1,N
            IF(IOPTP.NE.0)THEN
               ICOL=IC2(I)
            ELSE
               ICOL=IC1+I-1
            ENDIF
            IF(ICOL.LE.7.AND.IOPTP.EQ.0)THEN
               CALL ISFACI(LUT(ICOL+1))
            ELSE
               CALL ISFACI(ICOL)
            ENDIF
            IF(IOPTH.NE.0)THEN
               CALL IGBOX(X1+DX*FLOAT(I-1),X1+DX*FLOAT(I),Y1,Y2)
            ELSE
               CALL IGBOX(X1,X2,Y1+DY*FLOAT(I-1),Y1+DY*FLOAT(I))
            ENDIF
   10    CONTINUE
         CALL IGSET('BORD',0.)
         CALL IGSET('FAIS',0.)
         CALL IGBOX(X1,X2,Y1,Y2)
      ENDIF
*
*              Draw the levels with boxes
*
      IF(IOPTB.NE.0)THEN
         IF(IOPTH.NE.0)THEN
            YS=(Y2-Y1)/(2.*FLOAT(N))
            XS=DX/(2.*FLOAT(N))
         ELSE
            XS=(X2-X1)/(2.*FLOAT(N))
            YS=DY/(2.*FLOAT(N))
         ENDIF
         DO 20 I=1,N
            ST=FLOAT(N-I)
            IF(IOPTH.NE.0)THEN
               CALL IGBOX(X1+DX*FLOAT(I-1)+ST*XS,X1+DX*FLOAT(I)-ST*XS
     +,                   Y1+ST*YS,Y2-ST*YS)
            ELSE
               CALL IGBOX(X1+ST*XS,X2-ST*XS
     +,                   Y1+DY*FLOAT(I-1)+ST*YS,Y1+DY*FLOAT(I)-ST*YS)
            ENDIF
   20    CONTINUE
      ENDIF
*
*              Draw the axis
*
      IF(IOPTA.NE.0)THEN
         IF(IOPTH.NE.0)THEN
            CALL IGSET('TMSI',Y2-Y1)
            IF(IOPTG.NE.0)THEN
               IF(ZMAX.GT.0.)THEN
                  ZMING = ZMIN
                  IF(ZMIN.LE.0.)ZMING = 0.001*ZMAX
                  IF(IOPTT.NE.0)THEN
                     CHOPAX = '-DHSG'
                     XX1    = X1
                     XX2    = X2
                     YY1    = Y2
                     YY2    = Y2
                  ELSE
                     CHOPAX = 'DHSG'
                     XX1    = X1
                     XX2    = X2
                     YY1    = Y1
                     YY2    = Y1
                  ENDIF
               ENDIF
            ELSE
               IF(IOPTT.NE.0)THEN
                  CHOPAX = '-DHS'
                  XX1    = X1
                  XX2    = X2
                  YY1    = Y2
                  YY2    = Y2
               ELSE
                  CHOPAX = 'DHS'
                  XX1    = X1
                  XX2    = X2
                  YY1    = Y1
                  YY2    = Y1
               ENDIF
            ENDIF
         ELSE
            CALL IGSET('TMSI',X2-X1)
            IF(IOPTG.NE.0)THEN
               IF(ZMAX.GT.0.)THEN
                  ZMING = ZMIN
                  IF(ZMIN.LE.0.)ZMING = 0.001*ZMAX
                  IF(IOPTR.NE.0)THEN
                     CHOPAX = 'DHSGR'
                     XX1    = X2
                     XX2    = X2
                     YY1    = Y1
                     YY2    = Y2
                  ELSE
                     CHOPAX = 'DHS+GL'
                     XX1    = X2
                     XX2    = X2
                     YY1    = Y1
                     YY2    = Y2
                  ENDIF
               ENDIF
            ELSE
               IF(IOPTR.NE.0)THEN
                  CHOPAX = 'DHSR'
                  XX1    = X1
                  XX2    = X1
                  YY1    = Y1
                  YY2    = Y2
               ELSE
                  CHOPAX = 'DHS+L'
                  XX1    = X2
                  XX2    = X2
                  YY1    = Y1
                  YY2    = Y2
               ENDIF
            ENDIF
         ENDIF
         IF (NDIVZ.LT.0) THEN
            CHOPAX(8:8) = 'N'
            NDIV = -NDIVZ
         ELSE
            NDIV = NDIVZ
         ENDIF
         CALL IGAXIS(XX1,XX2,YY1,YY2,ZMIN,ZMAX,NDIV,CHOPAX)
      ENDIF
*
      END

      SUBROUTINE IGCOL1(NDIVZI)
      COMMON /HICOLM/ NDIVZ
      NDIVZ = MOD(NDIVZI,100)
      END
+DECK,  IGCONV, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGCONV(N,X,Y)
*.===========>
*.
*. Convert X and Y coordinates from X1 to X2 2D repere
*.
*..==========> (O.Couet)
+CDE, HICONV.
      DIMENSION X(*),Y(*)
*.______________________________________
*
      DO 10 I=1,N
         X(I)=((X(I)-X1MIN)*(X2MAX-X2MIN))/(X1MAX-X1MIN)+X2MIN
         Y(I)=((Y(I)-Y1MIN)*(Y2MAX-Y2MIN))/(Y1MAX-Y1MIN)+Y2MIN
  10  CONTINUE
      END
+DECK,  IGDATE, T=FORT.
* Revision 1.4  1998/11/06 16:30:38  couet
* - Should pass Y2K without problems ...
* Revision 1.3  1998/01/30 15:22:17  couet
* - APOLLO version removed
* Revision 1.2  1997/03/14 14:23:14  mclareni
* WNT mods
* Revision 1.1.1.1.2.1  1997/01/21 11:25:27  mclareni
* All mods for Winnt 96a on winnt branch
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGDATE(CHDT)
*.===========>
*.
*.   Gives the date
*.
*. _Output parameters:
*.
*.  CHARACTER CHDT : Date
*.
*..==========> (O.Couet)
      COMMON /SLATE/ ISL(40)
      CHARACTER*8 DAYDAT,DAYTIM
      CHARACTER*(*) CHDT
*.______________________________________
*
      CALL DATIME(ID,IT)
      IYEAR  = ISL(1)
      IMONTH = ISL(2)
      IDAY   = ISL(3)
      IHOUR  = ISL(4)
      IMIN   = ISL(5)
*
      CHDT = ' '
      WRITE (CHDT(1:4),'(I4.4)') IYEAR
      CHDT(5:5) = '/'
      WRITE (CHDT(6:7),'(I2.2)') IMONTH
      CHDT(8:8) = '/'
      WRITE (CHDT(9:10),'(I2.2)') IDAY
      WRITE (CHDT(14:15),'(I2.2)') IHOUR
      CHDT(16:16) = '.'
      WRITE (CHDT(17:18),'(I2.2)') IMIN
*
      END
+DECK,  IGDWK, T=FORT.
* Revision 1.4  1998/01/30 15:22:17  couet
* - APOLLO version removed
* Revision 1.3  1998/01/28 14:34:21  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:19  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGDWK(IWKTY)
*.===========>
*.
*.   This routine returns the default workstation type.
*.
*..==========> (O.Couet)
+SELF, IF=MSDOS.
      CHARACTER*16 CHTMP
+SELF, IF=DECGKS, IF=VAX.
      CHARACTER*12 STRING
      INCLUDE '($SSDEF)'
+SELF, IF=DECGKS, IF=DECS.
      CHARACTER*12 STRING
+SELF.
*.______________________________________
*
+SELF, IF=SGI,HPUX,IBMRT,SUN,DECS, IF=GKSGRAL, IF=-GKSIBM.
      IWKTY = 32120
+SELF, IF=IBMRT, IF=GKSIBM.
      IWKTY = 6
+SELF, IF=BATCH.
      IWKTY = 1
+SELF, IF=GL,X11,MACMPW, IF=-MSDOS.
      IWKTY = 1
+SELF, IF=MSDOS, IF=NDP.
      IWKTY = VIDEO_CONFIGURATION(VIDEO_SYSTEM)
      IF(IWKTY .GE. 18) THEN
        CALL GETENVF('SVGA_MODE',CHTMP)
        IF(CHTMP .NE. ' ')THEN
            READ(CHTMP,*,ERR = 5) I
            IWKTY = I
        ENDIF
      ENDIF
    5 CONTINUE
+SELF, IF=MSDOS, IF=-NDP.
      IWKTY = 18
+SELF, IF=FALCO, IF=-KERNEL.
      IWKTY = 7878
+SELF, IF=SUN, IF=SUNGKS.
      IWKTY = 4
+SELF, IF=VAX, IF=GKSGRAL, IF=-ATCGKS.
      IWKTY = 7878
+SELF, IF=VAX, IF=ATCGKS.
      IWKTY = 2602
+SELF, IF=SUN, IF=ATCGKS.
      IWKTY = 5350
+SELF, IF=VAX, IF=DECGKS, IF=-WINDOWS.
      IF (SS$_NORMAL.EQ.LIB$SYS_TRNLOG('GKS$WSTYPE',LENGTH,STRING)) THEN
        IF(STRING(1:2).EQ.'%X')  THEN
          READ(STRING(3:LENGTH),'(Z8)') IWKTY
        ELSE
          READ(STRING(1:LENGTH),*) IWKTY
        ENDIF
      ELSE
        IWKTY = 14
      ENDIF
+SELF, IF=VAX, IF=DECGKS, IF=WINDOWS.
      IWKTY = 211
+SELF, IF=DECGKS, IF=DECS.
      CALL GETENV('GKS3Dwstype',STRING)
      LENGTH = LENOCC(STRING)
      IF(LENGTH.GT.0)THEN
        READ(STRING(1:LENGTH),*)IWKTY
      ELSE
        IWKTY=211
      ENDIF
      IWKTY = IWKTY
+SELF, IF=VAX, IF=-GKSGRAL, IF=-DECGKS, IF=-ATCGKS, IF=GKS.
      IWKTY = 301400
+SELF, IF=IBM,AIX370,ALLIANT, IF=GKSGRAL, IF=-NEWLIB.
      IWKTY = 7878
+SELF, IF=GKSGRAL, IF=NEWLIB.
      IWKTY = 5003
+SELF, IF=IBM,AIX370, IF=-GKSGRAL, IF=GKS.
      IWKTY = 301400
+SELF, IF=DI3000, IF=IBM.
      IWKTY = 1
+SELF, IF=DI3000, IF=-IBM.
      IWKTY = 1
+SELF, IF=GKSBX.
      IWKTY = 8811
+SELF, IF=PHIGS.
      IWKTY = 8887
+SELF.
*
      END
+DECK,  IGELLI, T=FORT.
* Revision 1.3  1999/06/21 16:45:21  couet
* -  An ellipse with FAIS.NE.0, had an axis drawn.
* Revision 1.2  1998/03/20 15:46:06  couet
* - The ELLIPSE command always draw the ellipse with the first angle equal to
*   zero even if a non zero value is given.
*         null 0 10 0 10
*         ellipse 5 5 4 2 90 270
*   Some improvements have also be done in the ELLIPSE drawing:
*       nul 0 10 0 10 ; elli 5 5 2 4 1 360 30
*       set bord 1
*       nul 0 10 0 10 ; elli 5 5 2 4 1 360 30
*       set fais 1
*       set faci 2
*       nul 0 10 0 10 ; elli 5 5 2 4 1 360 30
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGELLI(XCI,YCI,RXI,RYI,PHIMIN,PHIMAI,THETA)
*.===========>
*.
*.  Draw an ellipse in the current NT
*.  (original code: Ellipse macro from Michael Kelsey)
*.
*.  Draws an ellipse in the current normalization transformation.
*.  The parameter THETA rotates the ellipse major and minor axes
*.  (RX and RY) relative to the coordinates by the given angle.
*.
*. _Input parameters:
*.
*.  REAL XC     :  X coord of centre.
*.  REAL YC     :  Y coord of centre.
*.  REAL RX     :  X radius of ellipse.
*.  REAL RY     :  Y radius of ellipse.
*.  REAL PHIMIN :  Minimum angle (degrees).
*.  REAL PHIMAX :  Maximum angle (degrees).
*.  REAL THETA  :  Rotation of axes of (degrees).
*.
*..==========>
+CDE, HIGRAF.
+CDE, HIATT.
      PARAMETER (PI=3.1415926)
*.______________________________________
*
      XC = XCI
      YC = YCI
      RX = RXI
      RY = RYI
      IF (RY.EQ.0.) RY = RX
*
      PHIMAX = PHIMAI
      IF (PHIMAX.GT.360.) PHIMAX = MOD(PHIMAX,360.)
      NP   = INT(PHIMAX-PHIMIN)+1
      DPHI = (PHIMAX-PHIMIN)/NP
*
      DO 10 I=1,NP
         PHI      = (PI/180.)*(I*DPhi+PHIMIN)
         XGRAF(I) = RX*COS(Phi)
         YGRAF(I) = RY*SIN(Phi)
   10 CONTINUE
*
      If (THETA.NE.0) THEN
         TH = THETA*PI/180.
         Do 20 I=1,NP
            X        = XGRAF(I)
            Y        = YGRAF(I)
            XGRAF(I) = X*COS(Th)-Y*SIN(Th)
            YGRAF(I) = X*SIN(Th)+Y*COS(Th)
   20    CONTINUE
      ENDIF
*
      DO 30 I=1,NP
         XGRAF(I) = XGRAF(I)+XC
         YGRAF(I) = YGRAF(I)+YC
   30 CONTINUE
*
      NPT = NP
      IF (PHIMIN.EQ.0.AND.PHIMAX.EQ.360) THEN
         NPT = NP+1
         XGRAF(NPT) = XGRAF(1)
         YGRAF(NPT) = YGRAF(1)
      ELSE
         IF (IFAIS.NE.0.OR.IBORD.NE.0) THEN
            NPT = NP+2
            XGRAF(NPT-1) = XC
            YGRAF(NPT-1) = YC
            XGRAF(NPT) = XGRAF(1)
            YGRAF(NPT) = YGRAF(1)
         ENDIF
      ENDIF
*
      IF (IFAIS.NE.0) CALL IFA(NPT,XGRAF,YGRAF)
*
      IF (IFAIS.EQ.0.OR.IBORD.NE.0) Then
         ILNOLD = ILN
         CALL ISLN(1)
         CALL IPL (NPT,XGRAF,YGRAF)
         CALL ISLN(ILNOLD)
      ENDIF
*
      END
+DECK,  IGEND, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGEND
*.===========>
*.
*.   This routine end an HIGZ cession .
*.
*..==========> (O.Couet)
+SELF, IF=GKS.
+CDE, HIATT.
+SELF, IF=DI3000.
+CDE, DI3SEG.
+SELF, IF=DI3000.
+CDE, DI3DEV.
+SELF, IF=DI3000.
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
+SELF.
*.______________________________________
*
+SELF, IF=FALCO.
      CALL IGSA(0)
+SELF, IF=GKS.
      INOP=INOPWK
      DO 10 I=1,INOP
         CALL IGQWK(ILOPWK(I),'ACTI',RVAL)
         IF(RVAL.NE.0.)THEN
            CALL IDAWK(ILOPWK(I))
         ENDIF
         CALL ICLWK(ILOPWK(I))
  10  CONTINUE
+SELF, IF=DI3000.
      IF (ENTRY_FLAG) CALL JUPDAT
      IF (SEGOPN) THEN
         CALL JCLOSE
         SEGOPN = .FALSE.
      ENDIF
      DO 10 I=0,MAXDEV
         IF (DEVICES(I).NE.0) THEN
            IF (DEVICES(I).EQ.2) THEN
               IF (I.GT.0) CALL IGSG(I)
               CALL JDEVOF(I)
            ENDIF
            CALL JDEND(I)
            DEVICES(I) = 0
         ENDIF
   10 CONTINUE
+SELF.
      CALL ICLKS
+SELF, IF=ZEBRA,MAIL.
      CALL IZEND
+SELF.
      CALL IGINIT(-1)
*
      END
+DECK,  IGERR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGERR(ERRTEX,RNAME)
*.===========>
*.
*.   This prints on the screen the error message (ERRTEX) and
*. the routine name (RNAME). This routine sets also IQUEST(1)
*. to 1. If RNAME equal ' ' only a warning is printed and
*. IQUEST(1) is sets to 0.
*.
*. _Input parameters:
*.
*.  INTEGER ERRTEX : Error text .
*.  CHARACTER RNAME : Routine name .
*.
*..==========> (O.Couet)
+CDE, HILUN.
+CDE, HIQUES.
      CHARACTER*(*) RNAME,ERRTEX
      CHARACTER*80 CHTEXT
      LOGICAL OPND
      SAVE IFIRST
      DATA IFIRST /1/
*.___________________________________________
*
      IF(IFIRST.NE.0.AND.LUNERR.NE.LUNOUT)THEN
         INQUIRE(UNIT=LUNERR,OPENED=OPND)
         IF(.NOT.OPND)THEN
+SELF, IF=IBM.
            OPEN(LUNERR,FILE='/HIGZ ERR',
     +           FORM='FORMATTED',STATUS='UNKNOWN')
+SELF, IF=-IBM.
            OPEN(LUNERR,FILE='higz.err',
     +           FORM='FORMATTED',STATUS='UNKNOWN')
+SELF.
         ENDIF
      ENDIF
      IFIRST=0
      CALL IGSA(0)
      NR=LENOCC(RNAME)
      NE=LENOCC(ERRTEX)
      IF(NR.GT.1)THEN
         CHTEXT=' ***** ERROR in '//RNAME(1:NR)//' : '//ERRTEX(1:NE)
         NC=NE+NR+20
         IQUEST(1)=1
      ELSE
         CHTEXT=' *** '//ERRTEX(1:NE)
         NC=NE+6
         IQUEST(1)=0
      ENDIF
*
      WRITE(LUNERR,'(A)')CHTEXT(1:NC)
*
      END
+DECK,  IGFA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGFA(N,X,Y)
*.===========>
*.
*.   This routine draws a fill area with HIGZ hatch style.
*. The convention for the Hatch is the following:
*.
*.            CALL ISFAIS(3)
*.            CALL ISFASI(ijk)
*.
*.    i (1-9) : specify the space between each hatch
*.              1 = 1/2mm  9 = 6mm
*.
*.    j (0-9) : specify angle between 0 and 90 degrees
*.
*.              0 = 0
*.              1 = 10
*.              2 = 20
*.              3 = 30
*.              4 = 45
*.              5 = Not drawn
*.              6 = 60
*.              7 = 70
*.              8 = 80
*.              9 = 90
*.
*.    k (0-9) : specify angle between 90 and 180 degrees
*.              0 = 180
*.              1 = 170
*.              2 = 160
*.              3 = 150
*.              4 = 135
*.              5 = Not drawn
*.              6 = 120
*.              7 = 110
*.              8 = 100
*.              9 = 90
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*)
      DIMENSION ANG1(10),ANG2(10)
      LOGICAL ZFSAV,MFSAV
      DATA ANG1 /  0., 10., 20., 30., 45.,5., 60., 70., 80., 90./
      DATA ANG2 /180.,170.,160.,150.,135.,5.,120.,110.,100., 90./
*.______________________________________
*
      ZFSAV=ZFLAG
      MFSAV=MFLAG
      ZFLAG=.FALSE.
      MFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      IDSPA=INT(IFASI/100)
      IANG2=INT((IFASI-100*IDSPA)/10)
      IANG1=MOD(IFASI,10)
      DY=0.003*FLOAT(IDSPA)
      IANG1=IANG1+1
      IANG2=IANG2+1
      IF(ANG1(IANG1).NE.5.)CALL IGHATC(DY,ANG1(IANG1),N,X,Y)
      IF(ANG2(IANG2).NE.5.)CALL IGHATC(DY,ANG2(IANG2),N,X,Y)
*
      ZFLAG=ZFSAV
      MFLAG=MFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGFBOX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGFBOX(X1,X2,Y1,Y2,X3,X4,Y3,Y4)
*.===========>
*.
*.   This routine draws a frame boxe . The frame is drawn according to the
*. current fill area attributes .
*.
*. _Input parameters:
*.
*.  INTEGER X1,Y1 : Left down corner coordinates of the inside boxe
*.                  of the frame .
*.  INTEGER X2,Y2 : Right up corner coordinates of the inside boxe
*.                  of the frame .
*.  INTEGER X3,Y3 : Left down corner coordinates of the outside boxe
*.                  of the frame .
*.  INTEGER X4,Y4 : Right up corner coordinates of the outside boxe
*.                  of the frame .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HIATT.
      DIMENSION X(12),Y(12)
      INTEGER ILNSAV
      LOGICAL ZFSAV
*.______________________________________
*
      IF(X1 .LE. X2)THEN
         XIN1 = X1
         XIN2 = X2
      ELSE
         XIN1 = X2
         XIN2 = X1
      ENDIF
      IF(X3.LE.X4)THEN
         XIN3 = X3
         XIN4 = X4
      ELSE
         XIN3 = X4
         XIN4 = X3
      ENDIF
      X(1)=XIN1
      X(2)=XIN1
      X(3)=XIN2
      X(4)=XIN2
      X(5)=XIN1
      X(6)=XIN1
      X(7)=XIN3
      X(8)=XIN3
      X(9)=XIN4
      X(10)=XIN4
      X(11)=XIN3
      X(12)=XIN3
*
      Y(1)=(Y1+Y2)/2
      Y(2)=Y2
      Y(3)=Y2
      Y(4)=Y1
      Y(5)=Y1
      Y(6)=Y(1)
      Y(7)=Y(1)
      Y(8)=Y3
      Y(9)=Y3
      Y(10)=Y4
      Y(11)=Y4
      Y(12)=Y(1)
      IF(GFLAG.OR.PFLAG)THEN
         ZFSAV=ZFLAG
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         IF(IFAIS.NE.0)CALL IFA(12,X,Y)
         IF((IFAIS.EQ.0).OR.(IBORD.NE.0))THEN
            ILNSAV=ILN
            CALL ISLN(1)
            CALL IPL(6,X,Y)
            CALL IPL(6,X(7),Y(7))
            CALL ISLN(ILNSAV)
         ENDIF
         ZFLAG=ZFSAV
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZFBOX(X1,X2,Y1,Y2,X3,X4,Y3,Y4)
+SELF.
*
      END
+DECK,  IGGFIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGGFIN(IFINO)
*.===========>
*.
*.   Get a Free INdex in the color table for stacked legos.
*.
*..==========> (O.Couet)
+CDE, HIHID.
+CDE, HILUT.
      SAVE IFIN
      DATA IFIN /7/
*.______________________________________
*
      IFINO1=IFIN
   10 IFINO1=IFINO1+1
      IF(IFINO1.GT.NBCLUT)THEN
         IFINO1=7
         GOTO 10
      ENDIF
      IF(IFINO1.EQ.ISTCOT)GOTO 10
      IF(IFINO1.EQ.ISTCOB)GOTO 10
      DO 20 I=1,NIDS+1
         IF(IFINO1.EQ.ISTCOL(I))GOTO 10
         IF(IFINO1.EQ.ISTCO2(I))GOTO 10
   20 CONTINUE
      IFIN=IFINO1
      IFINO=IFINO1
*
      END
+DECK,  IGGIF, T=FORT.
* Revision 1.4  2000/08/29 14:01:43  couet
* - An error message in printed when this routine is not used in the X11
*   version of HIGZ.
* Revision 1.3  1998/11/16 11:11:24  couet
* - ixdogif can scale pictures
* Revision 1.2  1996/02/19 16:17:05  couet
* The include file containing the inline functions IXWCDC and IYWCDC was
* missing in the IGGIF routine.
* Revision 1.1.1.1  1996/02/14 13:10:41  mclareni
* Higz

      SUBROUTINE IGGIF(IWKID,X,Y,CHNAME,CHOPT)
*.==============>
*.
*.   Generate/load a GIF file with/in the current X11 window.
*.
*. _Input parameters:
*.
*.  CHARACTER CHNAME : GIF file name.
*.
*.============> (O.Couet)
+SELF, IF=GIF.
+CDE, HIATT.
+SELF.
      CHARACTER*(*) CHNAME,CHOPT
*.______________________________________
*
+SELF, IF=GIF.
+CDE, HIWCDC.
+SELF, IF=GIF.
      ILEN = LENOCC(CHNAME)
      CALL IXSAVWI
      IW    = IWINID(IGIWIN(IWKID))
      CALL IXSELWI(IW)
      IWKNB = IGIWIN(IWKID)
*
      IF (INDEX(CHOPT,'M').NE.0) THEN
         IX = INT(X)
         IY = INT(Y)
         CALL IXDOGIF(IX,IY,ILEN,CHNAME(1:ILEN))
      ENDIF
*
      IF (INDEX(CHOPT,'L').NE.0) THEN
         IX = IXWCDC(X)
         IY = IYWCDC(Y)
         CALL IXLDGIF(IX,IY,ILEN,CHNAME(1:ILEN))
      ENDIF
*
      CALL IXSETWI
+SELF, IF=-GIF.
      CALL IGERR('Only HIGZ/X11 can do GIF files','IGGIF')
+SELF.
*
      END
+DECK,  IGHATC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGHATC(DY,ANGLE,N,XP,YP)
*.===========>
*.
*.    This routine draw hatches inclined with the
*. angle ANGLE and spaced of DY in normalized device
*. coordinates in the surface defined by N,XP,YP.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      PARAMETER (PI = 3.1415926,EPSIL=0.0001)
      DIMENSION XLI(100),XLH(2),YLH(2),XP(N),YP(N),XT(2),YT(2)
      DOUBLE PRECISION XT, YT, A, B, XI, XIP, XIN
      REAL LL
      LOGICAL ZSAV
*.___________________________________________
*
      RATIO1=(RVXMAX-RVXMIN)/(RWXMAX-RWXMIN)
      RATIO2=(RVYMAX-RVYMIN)/(RWYMAX-RWYMIN)
      RVX=RVXMIN
      RVY=RVYMIN
      RVX2=RVXMAX
      RVY2=RVYMAX
      RWX=RWXMIN
      RWY=RWYMIN
*
      IPLCIS=IPLCI
      ILNS=ILN
      RLWSAV=RLWSC
      CALL ISPLCI(IFACI)
      CALL ISLN(1)
      CALL ISLWSC(1.)
      ZSAV=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      ANGR=PI*(180-ANGLE)/180.
      SINA=SIN(ANGR)
      COSA=COS(ANGR)
      IF(ABS(COSA).LE.EPSIL)COSA=0.
      IF(ABS(SINA).LE.EPSIL)SINA=0.
      SINB=-SINA
      COSB=COSA
*
*              Search YMIN and YMAX
*
      YMIN=1.
      YMAX=0.
      DO 10 I=1,N
         X=RATIO1*(XP(I)-RWXMIN)+RVXMIN
         Y=RATIO2*(YP(I)-RWYMIN)+RVYMIN
         YROT=SINA*X+COSA*Y
         IF(YROT.GT.YMAX)YMAX=YROT
         IF(YROT.LT.YMIN)YMIN=YROT
   10 CONTINUE
      YMAX=FLOAT(INT(YMAX/DY))*DY
*
      NTSAV=INTR
      CALL ISELNT(0)
*
      DO 70 YCUR=YMAX,YMIN,-DY
         NBI=0
         DO 20 I=2,N+1
            I2=I
            I1=I-1
            IF(I.EQ.N+1)I2=1
            X1=RATIO1*(XP(I1)-RWX)+RVX
            Y1=RATIO2*(YP(I1)-RWY)+RVY
            X2=RATIO1*(XP(I2)-RWX)+RVX
            Y2=RATIO2*(YP(I2)-RWY)+RVY
            XT(1)=COSA*X1-SINA*Y1
            YT(1)=SINA*X1+COSA*Y1
            XT(2)=COSA*X2-SINA*Y2
            YT(2)=SINA*X2+COSA*Y2
*
*              Line segment parallel to oy
*
            IF(XT(1).EQ.XT(2))THEN
               IF(YT(1).LT.YT(2))THEN
                  YI=YT(1)
                  YIP=YT(2)
               ELSE
                  YI=YT(2)
                  YIP=YT(1)
               ENDIF
               IF((YI.LE.YCUR).AND.(YCUR.LT.YIP))THEN
                  NBI=NBI+1
                  XLI(NBI)=XT(1)
               ENDIF
               GOTO 20
            ENDIF
*
*              Line segment parallel to ox
*
            IF(YT(1).EQ.YT(2))THEN
               IF(YT(1).EQ.YCUR)THEN
                  NBI=NBI+1
                  XLI(NBI)=XT(1)
                  NBI=NBI+1
                  XLI(NBI)=XT(2)
               ENDIF
               GOTO 20
            ENDIF
*
*              Other line segment
*
            A=(YT(1)-YT(2))/(XT(1)-XT(2))
            B=(YT(2)*XT(1)-XT(2)*YT(1))/(XT(1)-XT(2))
            IF(XT(1).LT.XT(2))THEN
               XI=XT(1)
               XIP=XT(2)
            ELSE
               XI=XT(2)
               XIP=XT(1)
            ENDIF
            XIN=(YCUR-B)/A
            IF ((XI.LE.XIN).AND.(XIN.LT.XIP).AND.
     +          (MIN(YT(1),YT(2)).LE.YCUR).AND.
     +          (YCUR.LT.MAX(YT(1),YT(2))))THEN
               NBI=NBI+1
               XLI(NBI)=XIN
            ENDIF
   20    CONTINUE
*
*              Sorting of the x coordinates intersections
*
         INV=0
         M=NBI-1
   30    CONTINUE
         DO 40 I=1,M
            IF(XLI(I+1).LT.XLI(I))THEN
               INV=INV+1
               LL=XLI(I)
               XLI(I)=XLI(I+1)
               XLI(I+1)=LL
            ENDIF
   40    CONTINUE
         M=M-1
         IF(INV.EQ.0)GOTO 50
         INV=0
         GOTO 30
*
*              Draw the hatches
*
   50    IF(MOD(NBI,2).NE.0)GOTO 70
*
         DO 60 I=1,NBI,2
            XLH(1)=COSB*XLI(I)-SINB*YCUR
            YLH(1)=SINB*XLI(I)+COSB*YCUR
            XLH(2)=COSB*XLI(I+1)-SINB*YCUR
            YLH(2)=SINB*XLI(I+1)+COSB*YCUR
*
* Clipping on the current viewport
*
            IF(IGCLIP(XLH,YLH,RVX,RVX2,RVY,RVY2).NE.0)THEN
               CALL IPL(2,XLH,YLH)
            ENDIF
   60    CONTINUE
   70 CONTINUE
*
      CALL ISELNT(NTSAV)
      CALL ISPLCI(IPLCIS)
      CALL ISLN(ILNS)
      CALL ISLWSC(RLWSAV)
      ZFLAG=ZSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      END
+DECK,  IGHCX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      REAL FUNCTION IGHCX(LSCAT,ICX)
*.==========>
*.           Returns the value of bin number icx
*..=========> ( R.Brun )
+CDE, HIPAW.
      PARAMETER(KNBIT=1,KCON1=9)
*.___________________________________________
*
      NB            = IQ(LSCAT+KNBIT)
      IF(NB.LE.0)NB = 32
      NW            = 32/NB
      IF(NW.NE.1)THEN
         L1    = ICX*NB
         NBITH = 32-MOD(32,NB)
         L2    = MOD(L1,NBITH)+1
         L1    = LSCAT+KCON1+L1/NBITH
         IGHCX = JBYT(IQ(L1),L2,NB)
      ELSE
         IGHCX = Q(LSCAT+KCON1+ICX)
      ENDIF
*
      END
+DECK,  IGHCXY, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      REAL FUNCTION IGHCXY(LSCAT,ICX,ICY,IOPT)
*.==========>
*.
*.   Returns the value of cell defined by ICX and ICY if IOPT=1. Returns
*. the error associated with the cell defined by ICX and ICY if IOPT=2.
*.
*..=========> (O.Couet)
+CDE, HIPAW.
+CDE, HIPACK.
      PARAMETER(KNBIT=1,KCON2=3,KCON1=9)
*.___________________________________________
*
      NB = IQ(LSCAT+KNBIT)
      IF (NB.LE.0) NB = 32
      NW = 32/NB
*
      IF (IDIM1.NE.0) THEN
*
*              1D histos
*
         IF (NW.NE.1) THEN
            L1     = ICX*NB
            NBITH  = 32-MOD(32,NB)
            L2     = MOD(L1,NBITH)+1
            L1     = LSCAT+KCON1+L1/NBITH
            IGHCXY = JBYT(IQ(L1),L2,NB)
         ELSE
            IGHCXY = Q(LSCAT+KCON1+ICX)
         ENDIF
*
* If IOPT=2, then get error
*
         IF(IOPT.EQ.2) THEN
            LW = LQ(LSCAT)
            IF (LW.NE.0) THEN
*
* Error is packed in histogram
*
               IGHCXY = SQRT(Q(LW+ICX))
            ELSE
*
* Error must be calculated as SQRT contents
*
               IGHCXY = SQRT(ABS(IGHCXY))
            ENDIF
         ENDIF
      ELSE
*
*              2D histos
*
* First get contents
*
         J  = (NCY-ICY+1)*(NCX+2)
         L2 = ICX+J
         L1 = L2/NW+LSCAT+KCON2
         IF (NW.NE.1) THEN
            L2     = (NW-1-MOD(L2,NW))*NB +1
            IGHCXY = JBYT(IQ(L1),L2,NB)
         ELSE
            IGHCXY = Q(L1)
         ENDIF
*
* If IOPT=2, then get error
*
         IF(IOPT.EQ.2) THEN
            LW = LQ(LSCAT)
            IF (LW.NE.0) THEN
*
* Error is packed in histogram
*
               IOFF = (ICY-1)*NCX+ICX
               IGHCXY = SQRT(Q(LW+IOFF))
            ELSE
*
* Error must be calculated as SQRT contents
*
               IGHCXY = SQRT(ABS(IGHCXY))
            ENDIF
         ENDIF
      ENDIF
*
      END
+DECK,  IGHIS1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:34  mclareni
* Higz

      SUBROUTINE IGHIS1(N,IOPTG,IOPTX,IOPTY)
*.===========>
*.
*.   Take the LOG10 of XWORK and YWORK according to the value of
*. IOPT and put it in XWORKL and YWORKL.
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of channels in XWORK and in YWORK.
*.  INTEGER IOPT : IGHIST options.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIHIST.
*.______________________________________
*
      DO 10 I=1,N
         XWORKL(I)=XWORK(I)
         YWORKL(I)=YWORK(I)
         IF(IOPTG.NE.0.AND.IOPTX.NE.0)THEN
            IF(XWORKL(I).GT.0.)THEN
               XWORKL(I)=LOG10(XWORKL(I))
            ELSE
               XWORKL(I)=RWXMIN
            ENDIF
         ENDIF
         IF(IOPTG.NE.0.AND.IOPTY.NE.0)THEN
            IF(YWORKL(I).GT.0.)THEN
               YWORKL(I)=LOG10(YWORKL(I))
            ELSE
               YWORKL(I)=RWYMIN
            ENDIF
         ENDIF

   10 CONTINUE
*
      END
+DECK,  IGHIST, T=FORT.
* Revision 1.2  2001/10/08 16:12:45  couet
* - When a HIST/PLOT command (in PAW) is performed with the option S with
*   markers or lines, if the 2nd bin of the histogram is outside the plot
*   frame, the 1st bin is clipped too even if it is inside. The following
*   PAW macro illustrate the problem:
*   v/cr a(5) r 1 0 1 0.5 1
*   set mtyp 20
*   1d 100 ' ' 5 0. 5.
*   put/cont 100 a
*   null 0. 5. .1 1.5
*   h/pl 100 s
*   h/pl 100 sp
*   h/pl 100 sl
*   Some "clipping code" in IGHIST was causing this problem. This code was
*   not necessary since the clipping is correctly handled elsewhere in HIGZ
*   for all the basic primitives. So this code has been commented and it now
*   works. For the time being we leave the commented code in the routine in
*   case some unwanted side effects would appear. We do not have find any for
*   the time being.
* Revision 1.1.1.1  1996/02/14 13:10:35  mclareni
* Higz

      SUBROUTINE IGHIST(N,X,Y,CHOPT)
*.===========>
*.
*.   Draws all sorts of 1 dimensional graphs :
*. - statistical graphs (histogram, bars or columns charts,
*. - smoothed curved obtained with spline functions.
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of channels in X or in Y.
*.  REAL X(N) or X(2) : X coordinates or (XMIN,XMAX) (WC space).
*.  REAL Y(N) or Y(2) : Y coordinates or (YMIN,YMAX) (WC space).
*.  CHARACTER*(*) CHOPT : Option.
*.
*.  CHOPT='R' :  Graph is drawn horizontaly, parallel to X axis.
*.               (default is vertically, parallel to Y axis)
*.               If option R is selected the user must give:
*.                 2 values for Y (Y(1)=YMIN and Y(2)=YMAX)
*.                 N values for X, one for each channel.
*.               Otherwise the user must give:
*.                 N values for Y, one for each channel.
*.                 2 values for X (X(1)=XMIN and X(2)=XMAX)
*.
*.  CHOPT='L' :  A simple polyline beetwen every points is drawn
*.
*.  CHOPT='H' :  An Histogram with equidistant bins is drawn
*.               as a polyline.
*.
*.  CHOPT='F' :  An histogram with equidistant bins is drawn
*.               as a fill area. Contour is not drawn unless
*.               CHOPT='H' is also selected..
*.
*.  CHOPT='N' :  Non equidistant bins (default is equidistant)
*.               If N is the number of channels array X and Y
*.               must be dimensionned as follow:
*.               If option R is not selected (default) then
*.               the user must give:
*.                 (N+1) values for X (limits of channels).
*.                  N values for Y, one for each channel.
*.               Otherwise the user must give:
*.                 (N+1) values for Y (limits of channels).
*.                  N values for X, one for each channel.
*.
*.  CHOPT='F1':  Idem as 'F' except that fill area is no more
*.               reparted arround axis X=0 or Y=0 .
*.
*.  CHOPT='C' :  A smooth Curve is drawn.
*.
*.  CHOPT='*' :  A Star is plotted at the center of each bin.
*.
*.  CHOPT='P' :  Idem with the current marker
*.
*.  CHOPT='B' :  A Bar chart with equidistant bins is drawn as fill
*.               areas (Contours are drawn).
*.
*.  CHOPT='GX':  LOGX
*.
*.  CHOPT='GY':  LOGY
*.
*.  CHOPT='Z' :  The vectors X and Y are taken into PAWC at the
*.               adresses IQUEST(81) and IQUEST(82)
*.
*.  CHOPT='K' :  Data are pacKed like in HBOOK. In this case, Y is
*.               at the adress IQUEST(82) in PAWC. Note that with
*.               this option exclude option N and option R. This
*.               option is usefull with very big histograms (>100000
*.               bins). Such histo cannot be stored in pictures.
*.
*..==========> (O.Couet N.Cremel-Somon)
+CDE, HIPAW.
+CDE, HIFLAG.
+CDE, HIATT.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF.
+CDE, HIHIST.
+SELF, IF=-MGKS.
      PARAMETER (NPMAX=204,NPMXFA=99)
+SELF, IF=MGKS.
      PARAMETER (NPMAX=204,NPMXFA=204)
+SELF.
      DIMENSION X(*),Y(*)
      CHARACTER*(*) CHOPT
      CHARACTER*8 CHOPA
      REAL IGHCX
      EQUIVALENCE (LXADR,L2NTLA),(LYADR,LDNTLA)
      LOGICAL ZFSAV,FRSTFA
      DIMENSION IOPT(14)
      EQUIVALENCE (IOPTH ,IOPT(1)) , (IOPTF ,IOPT(2))
      EQUIVALENCE (IOPTC ,IOPT(3)) , (IOPTST,IOPT(4))
      EQUIVALENCE (IOPTR ,IOPT(5)) , (IOPT1,IOPT(6))
      EQUIVALENCE (IOPTB ,IOPT(7)) , (IOPTN,IOPT(8))
      EQUIVALENCE (IOPTL ,IOPT(9)) , (IOPTP,IOPT(10))
      EQUIVALENCE (IOPTA ,IOPT(11)), (IOPTG ,IOPT(12))
      EQUIVALENCE (IOPTX ,IOPT(13)), (IOPTY ,IOPT(14))
*.______________________________________
*
      IQUEST(1)=0
      IF(N.LE.0)THEN
         CALL IGERR(' Number of points is invalid','IGHIST')
         RETURN
      ENDIF
*
      CALL UOPTC(CHOPT,'HFC*R1BNLPAGXY',IOPT)
*
*              If necessary the adresses of the vectors are saved in
*              a link area.
*
      IFIRST = 1
      ILAST  = N
      IOPTZ  = 0
      IOPTK  = 0
      IF(INDEX(CHOPT,'Z').NE.0)THEN
         LXADR  = IQUEST(81)
         LYADR  = IQUEST(82)
         IOPTZ  = 1
      ENDIF
      IF(INDEX(CHOPT,'K').NE.0)THEN
         LYADR  = IQUEST(82)
         IFIRST = IQUEST(83)
         ILAST  = IQUEST(84)
         IOPTK  = 1
      ENDIF
      NBINS     = ILAST-IFIRST+1
*
+SELF, IF=MAIL.
      CHOPTM = CHOPT
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG.AND.IOPTK.EQ.0)CALL IZHIST(N,X,Y,IOPT,IOPTZ)
+SELF.
      IF((.NOT.GFLAG).AND.(.NOT.PFLAG))RETURN
      ZFSAV  = ZFLAG
      ZFLAG  = .FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
*              Draw the Axis with a fixed number of division: 510
*
      IF(IOPTA.NE.0)THEN
         ILNOLD = ILN
         IFAOLD = IFAIS
         CALL ISLN(1)
         CALL ISFAIS(0)
         CALL IGBOX(RWXMIN,RWXMAX,RWYMIN,RWYMAX)
         CALL ISLN(ILNOLD)
         CALL ISFAIS(IFAOLD)
         AXFLAG = .FALSE.
         CHOPA  = ' '
         RWMIN  = RWXMIN
         RWMAX  = RWXMAX
         IF(IOPTG.NE.0.AND.IOPTX.NE.0)THEN
            RWMIN = 10**RWXMIN
            RWMAX = 10**RWXMAX
            CHOPA = 'G'
         ENDIF
         CALL IGAXIS(RWXMIN,RWXMAX,RWYMIN,RWYMIN,RWMIN,RWMAX,510,CHOPA)
         AXFLAG = .TRUE.
         CHOPA  = ' '
         RWMIN  = RWYMIN
         RWMAX  = RWYMAX
         IF(IOPTG.NE.0.AND.IOPTY.NE.0)THEN
            RWMIN = 10**RWYMIN
            RWMAX = 10**RWYMAX
            CHOPA = 'G'
         ENDIF
         CALL IGAXIS(RWXMIN,RWXMIN,RWYMIN,RWYMAX,RWMIN,RWMAX,510,CHOPA)
         AXFLAG = .FALSE.
      ENDIF
*
*              Min-Max scope
*
      IF(IOPTR.EQ.0)THEN
         IF(IOPTZ.NE.0)THEN
            WMIN = Q(LXADR)
            WMAX = Q(LXADR+1)
         ELSE
            WMIN = X(1)
            WMAX = X(2)
         ENDIF
      ELSE
         IF(IOPTZ.NE.0)THEN
            WMIN = Q(LYADR)
            WMAX = Q(LYADR+1)
         ELSE
            WMIN = Y(1)
            WMAX = Y(2)
         ENDIF
      ENDIF
      IF(IOPTN.EQ.0)DELTA = (WMAX-WMIN)/NBINS
*
*              Draw the Histogram with a Fill Area
*
      IF((IOPTF.NE.0).AND.(IOPTC.EQ.0))THEN
         FRSTFA = .TRUE.
         IF(IOPTR.EQ.0)THEN
            XWORK(1) = WMIN
            IF(IOPT1.EQ.0)THEN
               YWORK(1) = MAX(0.,RWYMIN)
            ELSE
               YWORK(1) = RWYMIN
            ENDIF
            NPT = 2
            DO 10 J=IFIRST,ILAST
               IF(IOPTN.EQ.0)THEN
                  XWORK(NPT)   = XWORK(NPT-1)
                  XWORK(NPT+1) = WMIN+((J-IFIRST+1)*DELTA)
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     XJ1 = Q(LXADR+J)
                     XJ  = Q(LXADR+J-1)
                  ELSE
                     XJ1 = X(J+1)
                     XJ  = X(J)
                  ENDIF
                  IF(XJ1.LT.XJ)THEN
                     IF(J.NE.ILAST)THEN
                        CALL IGERR('X must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('X must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     XWORK(NPT)   = Q(LXADR+J-1)
                     XWORK(NPT+1) = Q(LXADR+J)
                  ELSE
                     XWORK(NPT)   = X(J)
                     XWORK(NPT+1) = X(J+1)
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  YWORK(NPT)   = Q(LYADR+J-1)
                  YWORK(NPT+1) = Q(LYADR+J-1)
               ELSEIF(IOPTK.NE.0)THEN
                  YWORK(NPT)   = IGHCX(LYADR,J)
                  YWORK(NPT+1) = IGHCX(LYADR,J)
               ELSE
                  YWORK(NPT)   = Y(J)
                  YWORK(NPT+1) = Y(J)
               ENDIF
               NPT = NPT+2
               IF(J.EQ.ILAST)THEN
                  XWORK(NPT) = XWORK(NPT-1)
                  YWORK(NPT) = YWORK(1)
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IFA(NPT,XWORKL,YWORKL)
                  IF(IBORD.NE.0)THEN
                     IF(.NOT.FRSTFA)YWORKL(1) = YLAST
                     CALL IPL(NPT-1,XWORKL,YWORKL)
                  ENDIF
                  GOTO 10
               ENDIF
               IF(NPT.GE.NPMXFA)THEN
                  XWORK(NPT) = XWORK(NPT-1)
                  YWORK(NPT) = YWORK(1)
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IFA(NPT,XWORKL,YWORKL)
                  IF(IBORD.NE.0)THEN
                     IF(.NOT.FRSTFA)YWORKL(1) = YLAST
                     CALL IPL(NPT-1,XWORKL,YWORKL)
                     FRSTFA = .FALSE.
                  ENDIF
                  YLAST    = YWORKL(NPT-1)
                  XWORK(1) = XWORK(NPT)
                  NPT      = 2
               ENDIF
   10       CONTINUE
         ELSE
            YWORK(1) = WMIN
            IF(IOPT1.EQ.0)THEN
               XWORK(1) = MAX(0.,RWXMIN)
            ELSE
               XWORK(1) = RWXMIN
            ENDIF
            NPT = 2
            DO 20  J=IFIRST,ILAST
               IF(IOPTN.EQ.0)THEN
                  YWORK(NPT)   = YWORK(NPT-1)
                  YWORK(NPT+1) = WMIN+((J-IFIRST+1)*DELTA)
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     YJ1 = Q(LYADR+J)
                     YJ  = Q(LYADR+J-1)
                  ELSE
                     YJ1 = Y(J+1)
                     YJ  = Y(J)
                  ENDIF
                  IF(YJ1.LT.YJ)THEN
                     IF(J.NE.ILAST)THEN
                        CALL IGERR('Y must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('Y must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     YWORK(NPT)   = Q(LYADR+J-1)
                     YWORK(NPT+1) = Q(LYADR+J)
                  ELSE
                     YWORK(NPT)   = Y(J)
                     YWORK(NPT+1) = Y(J+1)
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  XWORK(NPT)   = Q(LXADR+J-1)
                  XWORK(NPT+1) = Q(LXADR+J-1)
               ELSE
                  XWORK(NPT)   = X(J)
                  XWORK(NPT+1) = X(J)
               ENDIF
               NPT = NPT+2
               IF(J.EQ.ILAST)THEN
                  YWORK(NPT) = YWORK(NPT-1)
                  XWORK(NPT) = XWORK(1)
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IFA(NPT,XWORKL,YWORKL)
                  IF(IBORD.NE.0)THEN
                     IF(.NOT.FRSTFA)YWORKL(1) = YLAST
                     CALL IPL(NPT-1,XWORKL,YWORKL)
                  ENDIF
                  GOTO 20
               ENDIF
               IF(NPT.GE.NPMXFA)THEN
                  YWORK(NPT) = YWORK(NPT-1)
                  XWORK(NPT) = XWORK(1)
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IFA(NPT,XWORKL,YWORKL)
                  IF(IBORD.NE.0)THEN
                     IF(.NOT.FRSTFA)YWORKL(1) = YLAST
                     CALL IPL(NPT-1,XWORKL,YWORKL)
                     FRSTFA = .FALSE.
                  ENDIF
                  YLAST    = YWORKL(NPT-1)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 2
               ENDIF
   20       CONTINUE
         ENDIF
      ENDIF
*
*              Draw a standard Histogram (default)
*
      IF((IOPTH.NE.0).OR.(CHOPT.EQ.' '))THEN
         IF(IOPTR.EQ.0)THEN
            XWORK(1) = WMIN
            YWORK(1) = MAX(0.,RWYMIN)
            YWMIN    = YWORK(1)
            NPT      = 2
            DO 30  I=IFIRST,ILAST
               IF(IOPTN.EQ.0)THEN
                  XWORK(NPT)   = XWORK(NPT-1)
                  XWORK(NPT+1) = WMIN+((I-IFIRST+1)*DELTA)
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     XI1 = Q(LXADR+I)
                     XI  = Q(LXADR+I-1)
                  ELSE
                     XI1 = X(I+1)
                     XI  = X(I)
                  ENDIF
                  IF(XI1.LT.XI)THEN
                     IF(I.NE.ILAST)THEN
                        CALL IGERR('X must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('X must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     XWORK(NPT)   = Q(LXADR+I-1)
                     XWORK(NPT+1) = Q(LXADR+I)
                  ELSE
                     XWORK(NPT)   = X(I)
                     XWORK(NPT+1) = X(I+1)
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  YWORK(NPT)   = Q(LYADR+I-1)
                  YWORK(NPT+1) = Q(LYADR+I-1)
               ELSEIF(IOPTK.NE.0)THEN
                  YWORK(NPT)   = IGHCX(LYADR,I)
                  YWORK(NPT+1) = IGHCX(LYADR,I)
               ELSE
                  YWORK(NPT)   = Y(I)
                  YWORK(NPT+1) = Y(I)
               ENDIF
               NPT = NPT+2
               IF(I.EQ.ILAST)THEN
                  XWORK(NPT) = XWORK(NPT-1)
                  YWORK(NPT) = YWMIN
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IPL(NPT,XWORKL,YWORKL)
                  GOTO 30
               ENDIF
               IF(NPT.GE.NPMAX)THEN
                  CALL IGHIS1(NPT-1,IOPTG,IOPTX,IOPTY)
                  CALL IPL(NPT-1,XWORKL,YWORKL)
                  XWORK(1) = XWORK(NPT-1)
                  YWORK(1) = YWORK(NPT-1)
                  NPT      = 2
               ENDIF
   30       CONTINUE
         ELSE
            YWORK(1) = WMIN
            XWORK(1) = MAX(0.,RWXMIN)
            XWMIN    = XWORK(1)
            NPT      = 2
            DO 40  I=IFIRST,ILAST
               IF(IOPTN.EQ.0)THEN
                  YWORK(NPT)   = YWORK(NPT-1)
                  YWORK(NPT+1) = WMIN+((I-IFIRST+1)*DELTA)
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     YI1 = Q(LYADR+I)
                     YI  = Q(LYADR+I-1)
                  ELSE
                     YI1 = Y(I+1)
                     YI  = Y(I)
                  ENDIF
                  IF(YI1.LT.YI)THEN
                     IF(I.NE.ILAST)THEN
                        CALL IGERR('Y must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('Y must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     YWORK(NPT)   = Q(LYADR+I-1)
                     YWORK(NPT+1) = Q(LYADR+I)
                  ELSE
                     YWORK(NPT)   = Y(I)
                     YWORK(NPT+1) = Y(I+1)
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  XWORK(NPT)   = Q(LXADR+I-1)
                  XWORK(NPT+1) = Q(LXADR+I-1)
               ELSE
                  XWORK(NPT)   = X(I)
                  XWORK(NPT+1) = X(I)
               ENDIF
               NPT = NPT+2
               IF(I.EQ.ILAST)THEN
                  YWORK(NPT) = YWORK(NPT-1)
                  XWORK(NPT) = XWMIN
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IPL(NPT,XWORKL,YWORKL)
                  GOTO 40
               ENDIF
               IF(NPT.GE.NPMAX)THEN
                  CALL IGHIS1(NPT-1,IOPTG,IOPTX,IOPTY)
                  CALL IPL(NPT-1,XWORKL,YWORKL)
                  XWORK(1) = XWORK(NPT-1)
                  YWORK(1) = YWORK(NPT-1)
                  NPT      = 2
               ENDIF
   40       CONTINUE
         ENDIF
      ENDIF
*
*              Draw the histogram with a smooth Curve. The computing
*              of the smoothing is done by the routine IGRAP1
*
      IF(IOPTC.NE.0)THEN
         IF(IOPTF.EQ.0)THEN
            ITYPS = 1
         ELSE
            IF(IOPT1.EQ.0)THEN
               ITYPS = 2
            ELSE
               ITYPS = 3
            ENDIF
         ENDIF
         IF(IOPTR.EQ.0)THEN
            NPT = 0
            DO 50  I=IFIRST,ILAST
               NPT = NPT+1
               IF(IOPTN.EQ.0)THEN
                  XWORK(NPT) = WMIN+(I-IFIRST)*DELTA+0.5*DELTA
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     XI1 = Q(LXADR+I)
                     XI  = Q(LXADR+I-1)
                  ELSE
                     XI1 = X(I+1)
                     XI  = X(I)
                  ENDIF
                  IF(XI1.LT.XI)THEN
                     IF(I.NE.ILAST)THEN
                        CALL IGERR('X must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('X must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     XWORK(NPT) = Q(LXADR+I-1)+
     +                           (Q(LXADR+I)-Q(LXADR+I-1))/2.
                  ELSE
                     XWORK(NPT) = X(I)+(X(I+1)-X(I))/2.
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  YWORK(NPT) = Q(LYADR+I-1)
               ELSEIF(IOPTK.NE.0)THEN
                  YWORK(NPT) = IGHCX(LYADR,I)
               ELSE
                  YWORK(NPT) = Y(I)
               ENDIF
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               IF((YWORKL(NPT).LT.RWYMIN).OR.(YWORKL(NPT).GT.RWYMAX))
     +         THEN
                  IF(NPT.GT.2)THEN
                     CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                     CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
                  ENDIF
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
                  GOTO 50
               ENDIF
               IF(NPT.GE.50)THEN
                  CALL IGHIS1(50,IOPTG,IOPTX,IOPTY)
                  CALL IGRAP1(XWORKL,YWORKL,50,ITYPS)
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
               ENDIF
   50       CONTINUE
            IF(NPT.GT.1)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
            ENDIF
         ELSE
            ITYPS = ITYPS+10
            NPT   = 0
            DO 60  I=IFIRST,ILAST
               NPT = NPT+1
               IF(IOPTN.EQ.0)THEN
                  YWORK(NPT) = WMIN+(I-IFIRST)*DELTA+0.5*DELTA
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     YI1 = Q(LYADR+I)
                     YI  = Q(LYADR+I-1)
                  ELSE
                     YI1 = Y(I+1)
                     YI  = Y(I)
                  ENDIF
                  IF(YI1.LT.YI)THEN
                     IF(I.NE.ILAST)THEN
                        CALL IGERR('Y must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('Y must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     YWORK(NPT) = Q(LYADR+I-1)+
     +                           (Q(LYADR+I)-Q(LYADR+I-1))/2.
                  ELSE
                     YWORK(NPT) = Y(I)+(Y(I+1)-Y(I))/2.
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  XWORK(NPT) = Q(LXADR+I-1)
               ELSE
                  XWORK(NPT) = X(I)
               ENDIF
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               IF((XWORKL(NPT).LT.RWXMIN).OR.(XWORKL(NPT).GT.RWXMAX))
     +         THEN
                  IF(NPT.GT.2)THEN
                     CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                     CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
                  ENDIF
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
                  GOTO 60
               ENDIF
               IF(NPT.GE.50)THEN
                  CALL IGHIS1(50,IOPTG,IOPTX,IOPTY)
                  CALL IGRAP1(XWORKL,YWORKL,50,ITYPS)
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
               ENDIF
   60       CONTINUE
            IF(NPT.GT.1)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
            ENDIF
         ENDIF
      ENDIF
*
*              Draw the histogram with a simple line
*
      IOPTPK = 0
      IF((IOPTST.NE.0).OR.(IOPTP.NE.0))IOPTPK=1
      IF((IOPTPK.NE.0).OR.(IOPTL.NE.0))THEN
         IMKOLD = IMK
         IF(IOPTST.NE.0)CALL ISMK(3)
         WMINST = WMIN+DELTA/2.
         IF(IOPTR.EQ.0)THEN
            NPT = 0
            DO 70  I=IFIRST,ILAST
               NPT = NPT+1
               IF(IOPTN.EQ.0)THEN
                  XWORK(NPT) = WMINST+(I-IFIRST)*DELTA
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     XI1 = Q(LXADR+I)
                     XI  = Q(LXADR+I-1)
                  ELSE
                     XI1 = X(I+1)
                     XI  = X(I)
                  ENDIF
                  IF(XI1.LT.XI)THEN
                     IF(I.NE.ILAST)THEN
                        CALL IGERR('X must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('X must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     XWORK(NPT) = Q(LXADR+I-1)+
     +                           (Q(LXADR+I)-Q(LXADR+I-1))/2.
                  ELSE
                     XWORK(NPT) = X(I)+(X(I+1)-X(I))/2.
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  YWORK(NPT) = Q(LYADR+I-1)
               ELSEIF(IOPTK.NE.0)THEN
                  YWORK(NPT) = IGHCX(LYADR,I)
               ELSE
                  YWORK(NPT) = Y(I)
               ENDIF
CCC               IF((YWORK(NPT).LT.RWYMIN).OR.(YWORK(NPT).GT.RWYMAX))
CCC     +         THEN
CCC                  IF(NPT.GT.2)THEN
CCC                     IF(IOPTPK.NE.0)THEN
CCC                        CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
CCC                        CALL IPM(NPT,XWORKL,YWORKL)
CCC                     ENDIF
CCC                     IF(IOPTL.NE.0)THEN
CCC                        CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
CCC                        CALL IPL(NPT,XWORKL,YWORKL)
CCC                     ENDIF
CCC                  ENDIF
CCC                  XWORK(1) = XWORK(NPT)
CCC                  YWORK(1) = YWORK(NPT)
CCC                  NPT      = 1
CCC                  GOTO 70
CCC               ENDIF
               IF(NPT.GE.50)THEN
                  IF(IOPTPK.NE.0)THEN
                     CALL IGHIS1(50,IOPTG,IOPTX,IOPTY)
                     CALL IPM(50,XWORKL,YWORKL)
                  ENDIF
                  IF(IOPTL.NE.0)THEN
                     CALL IGHIS1(50,IOPTG,IOPTX,IOPTY)
                     CALL IPL(50,XWORKL,YWORKL)
                  ENDIF
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
               ENDIF
   70       CONTINUE
            IF(IOPTPK.NE.0.AND.NPT.GT.0)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IPM(NPT,XWORKL,YWORKL)
            ENDIF
            IF(IOPTL.NE.0.AND.NPT.GT.1)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IPL(NPT,XWORKL,YWORKL)
            ENDIF
         ELSE
            NPT = 0
            DO 80  I=IFIRST,ILAST
               NPT = NPT+1
               IF(IOPTN.EQ.0)THEN
                  YWORK(NPT) = WMINST+(I-IFIRST)*DELTA
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     YI1 = Q(LYADR+I)
                     YI  = Q(LYADR+I-1)
                  ELSE
                     YI1 = Y(I+1)
                     YI  = Y(I)
                  ENDIF
                  IF(YI1.LT.YI)THEN
                     IF(I.NE.ILAST)THEN
                        CALL IGERR('Y must be in increasing order'
     +                  ,'IGHIST')
                     ELSE
                        CALL IGERR('Y must have N+1 values with '
     +                  //'option N' ,'IGHIST')
                     ENDIF
                     GOTO 110
                  ENDIF
                  IF(IOPTZ.NE.0)THEN
                     YWORK(NPT) = Q(LYADR+I-1)+
     +                           (Q(LYADR+I)-Q(LYADR+I-1))/2.
                  ELSE
                     YWORK(NPT) = Y(I)+(Y(I+1)-Y(I))/2.
                  ENDIF
               ENDIF
               IF(IOPTZ.NE.0)THEN
                  XWORK(NPT) = Q(LXADR+I-1)
               ELSE
                  XWORK(NPT) = X(I)
               ENDIF
CCC               IF((XWORK(NPT).LT.RWXMIN).OR.(XWORK(NPT).GT.RWXMAX))
CCC     +         THEN
CCC                  IF(NPT.GT.2)THEN
CCC                     IF(IOPTPK.NE.0)THEN
CCC                        CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
CCC                        CALL IPM(NPT,XWORKL,YWORKL)
CCC                     ENDIF
CCC                     IF(IOPTL.NE.0)THEN
CCC                        CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
CCC                        CALL IPL(NPT,XWORKL,YWORKL)
CCC                     ENDIF
CCC                  ENDIF
CCC                  XWORK(1) = XWORK(NPT)
CCC                  YWORK(1) = YWORK(NPT)
CCC                  NPT      = 1
CCC                  GOTO 80
CCC               ENDIF
               IF(NPT.GE.50)THEN
                  IF(IOPTPK.NE.0)THEN
                     CALL IGHIS1(50,IOPTG,IOPTX,IOPTY)
                     CALL IPM(50,XWORKL,YWORKL)
                  ENDIF
                  IF(IOPTL.NE.0)THEN
                     CALL IGHIS1(50,IOPTG,IOPTX,IOPTY)
                     CALL IPL(50,XWORKL,YWORKL)
                  ENDIF
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
               ENDIF
   80       CONTINUE
            IF(IOPTPK.NE.0.AND.NPT.GT.0)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IPM(NPT,XWORKL,YWORKL)
            ENDIF
            IF(IOPTL.NE.0.AND.NPT.GT.1)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IPL(NPT,XWORKL,YWORKL)
            ENDIF
         ENDIF
         CALL ISMK(IMKOLD)
      ENDIF
*
*              Draw the histogram as a bar chart
*
      IF(IOPTB.NE.0)THEN
         IF(IOPTN.EQ.0)THEN
            OFFS = DELTA*RBOF
            DBAR = DELTA*RBWD
         ELSE
            IF(IOPTR.EQ.0)THEN
               IF(IOPTZ.NE.0)THEN
                  OFFS = (Q(LXADR+1)-Q(LXADR))*RBOF
                  DBAR = (Q(LXADR+1)-Q(LXADR))*RBWD
               ELSE
                  OFFS = (X(2)-X(1))*RBOF
                  DBAR = (X(2)-X(1))*RBWD
               ENDIF
            ELSE
               IF(IOPTZ.NE.0)THEN
                  OFFS = (Q(LYADR+1)-Q(LYADR))*RBOF
                  DBAR = (Q(LYADR+1)-Q(LYADR))*RBWD
               ELSE
                  OFFS = (Y(2)-Y(1))*RBOF
                  DBAR = (Y(2)-Y(1))*RBWD
               ENDIF
            ENDIF
         ENDIF
         IBOLD = IBORD
         CALL IGSET('BORD',1.)
         IF(IOPTR.EQ.0)THEN
            XLOW  = WMIN+OFFS
            XHIGH = WMIN+OFFS+DBAR
            IF(IOPT1.EQ.0)THEN
               YLOW = MAX(0.,RWYMIN)
            ELSE
               YLOW = RWYMIN
            ENDIF
            DO 90  I=IFIRST,ILAST
               IF(IOPTZ.NE.0)THEN
                  YHIGH    = Q(LYADR+I-1)
               ELSEIF(IOPTK.NE.0)THEN
                  YHIGH    = IGHCX(LYADR,I)
               ELSE
                  YHIGH    = Y(I)
               ENDIF
               XWORK(1) = XLOW
               YWORK(1) = YLOW
               XWORK(2) = XHIGH
               YWORK(2) = YHIGH
               CALL IGHIS1(2,IOPTG,IOPTX,IOPTY)
               CALL IGBOX(XWORKL(1),XWORKL(2),YWORKL(1),YWORKL(2))
               IF(IOPTN.EQ.0)THEN
                  XLOW  = XLOW+DELTA
                  XHIGH = XHIGH+DELTA
               ELSE
                  IF(I.LT.ILAST)THEN
                     IF(IOPTZ.NE.0)THEN
                        XI1 = Q(LXADR+I)
                        XI  = Q(LXADR+I-1)
                     ELSE
                        XI1 = X(I+1)
                        XI  = X(I)
                     ENDIF
                     IF(XI1.LT.XI)THEN
                        CALL IGERR('X must be in increasing order'
     +                  ,'IGHIST')
                        GOTO 110
                     ENDIF
                     IF(IOPTZ.NE.0)THEN
                        OFFS  = (Q(LXADR+I+1)-Q(LXADR+I))*RBOF
                        DBAR  = (Q(LXADR+I+1)-Q(LXADR+I))*RBWD
                        XLOW  = Q(LXADR+I)+OFFS
                        XHIGH = Q(LXADR+I)+OFFS+DBAR
                     ELSE
                        OFFS  = (X(I+2)-X(I+1))*RBOF
                        DBAR  = (X(I+2)-X(I+1))*RBWD
                        XLOW  = X(I+1)+OFFS
                        XHIGH = X(I+1)+OFFS+DBAR
                     ENDIF
                  ENDIF
               ENDIF
   90       CONTINUE
         ELSE
            YLOW  = WMIN+OFFS
            YHIGH = WMIN+OFFS+DBAR
            IF(IOPT1.EQ.0)THEN
               XLOW = MAX(0.,RWXMIN)
            ELSE
               XLOW = RWXMIN
            ENDIF
            DO 100 I=IFIRST,ILAST
               IF(IOPTZ.NE.0)THEN
                  XHIGH = Q(LXADR+I-1)
               ELSE
                  XHIGH = X(I)
               ENDIF
               XWORK(1) = XLOW
               YWORK(1) = YLOW
               XWORK(2) = XHIGH
               YWORK(2) = YHIGH
               CALL IGHIS1(2,IOPTG,IOPTX,IOPTY)
               CALL IGBOX(XWORKL(1),XWORKL(2),YWORKL(1),YWORKL(2))
               CALL IGBOX(XLOW,XHIGH,YLOW,YHIGH)
               IF(IOPTN.EQ.0)THEN
                  YLOW  = YLOW+DELTA
                  YHIGH = YHIGH+DELTA
               ELSE
                  IF(I.LT.ILAST)THEN
                     IF(IOPTZ.NE.0)THEN
                        YI1 = Q(LYADR+I)
                        YI  = Q(LYADR+I-1)
                     ELSE
                        YI1 = Y(I+1)
                        YI  = Y(I)
                     ENDIF
                     IF(YI1.LT.YI)THEN
                        CALL IGERR('Y must be in increasing order'
     +                  ,'IGHIST')
                        GOTO 110
                     ENDIF
                     IF(IOPTZ.NE.0)THEN
                        OFFS  = (Q(LYADR+I+1)-Q(LYADR+I))*RBOF
                        DBAR  = (Q(LYADR+I+1)-Q(LYADR+I))*RBWD
                        YLOW  = Q(LYADR+I)+OFFS
                        YHIGH = Q(LYADR+I)+OFFS+DBAR
                     ELSE
                        OFFS  = (Y(I+2)-Y(I+1))*RBOF
                        DBAR  = (Y(I+2)-Y(I+1))*RBWD
                        YLOW  = Y(I+1)+OFFS
                        YHIGH = Y(I+1)+OFFS+DBAR
                     ENDIF
                  ENDIF
               ENDIF
  100       CONTINUE
         ENDIF
         CALL IGSET('BORD',FLOAT(IBOLD))
      ENDIF
*
  110 ZFLAG  = ZFSAV
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGHR01, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:35  mclareni
* Higz

      REAL FUNCTION IGHR01(RN1,RN2,HUEI)
      HUE=HUEI
      IF(HUE.GT.360.)HUE=HUE-360.
      IF(HUE.LT.0.)HUE=HUE+360.
      IF(HUE.LT.60.)THEN
         IGHR01=RN1+(RN2-RN1)*HUE/60.
      ELSEIF(HUE.LT.180.)THEN
         IGHR01=RN2
      ELSEIF(HUE.LT.240.)THEN
         IGHR01=RN1+(RN2-RN1)*(240.-HUE)/60.
      ELSE
         IGHR01=RN1
      ENDIF
      END

+DECK,  IGHTOR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:35  mclareni
* Higz

      SUBROUTINE IGHTOR(RHI,RLI,RSI,R,G,B)
*.===========>
*.
*.   Convert HLS to RGB
*.
*..==========> (O.Couet)
      REAL IGHR01
*.______________________________________
*
      RH=MAX(MIN(RHI,360.),0.)
      RL=MAX(MIN(RLI,1.),0.)
      RS=MAX(MIN(RSI,1.),0.)
*
      IF(RL.LE.0.5)THEN
         RM2=RL*(1.+RS)
      ELSE
         RM2=RL+RS-RL*RS
      ENDIF
*
      RM1=2.*RL-RM2
*
      IF(RS.EQ.0.)THEN
         R=RL
         G=RL
         B=RL
      ELSE
         R=IGHR01(RM1,RM2,RH+120.)
         G=IGHR01(RM1,RM2,RH)
         B=IGHR01(RM1,RM2,RH-120.)
      ENDIF
*
      END
+DECK,  IGINIT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:35  mclareni
* Higz

      SUBROUTINE IGINIT(NWORDS)
*.===========>
*.
*.   This routine initializes HIGZ .
*.
*. _Input parameters:
*.
*.  INTEGER NWORDS : Minimal space in the ZEBRA HIGZ division .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
+CDE, HILUN.
+CDE, HIATT.
+CDE, HIMET2.
+CDE, HIMETA.
+CDE, HIMENU.
+SELF, IF=-NTC, IF=-X11.
+CDE, HINT.
+SELF.
+CDE, HILOC.
+CDE, HILUT.
+CDE, HIHID.
+CDE, HILABS.
+SELF, IF=X11.
+CDE, HIKERN.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=DI3000.
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
+SELF.
*.______________________________________
*
      LUNIN  = 5
      LUNOUT = 6
      LUNERR = 6
*
+SELF, IF=ZEBRA.
      IF(NWORDS.GE.0)CALL IZINIT(NWORDS)
+SELF.
*
*              Flags initialisation
*
* ZFLAG  = If .TRUE. the ZEBRA mode is on
* GFLAG  = If .TRUE. the graphic is on
* CFLAG  = If .TRUE. in the pictures, the attributes are stored
*          only if necessary
* MFLAG  = Mail flag (telnetg)
* PFLAG  = If .TRUE. PostScript or LaTeX metafile is active
* TFLAG  = If .TRUE. LaTeX metafile, if .FALSE. PostScript metafile
* GLFLAG = GLobal flag. If .TRUE. the IZ routines must be called
* GRFLAG = Graphic flag (used by IGSG and IGSA)
* ASFLAG = Automatic picture saving flag
* AXFLAG = Axis flag (usefull for IGHIST and IGRAPH)
* REDIT  = Editing factor
*
+SELF, IF=BATCH.
      ZFLAG  = .TRUE.
      GFLAG  = .FALSE.
+SELF, IF=-BATCH.
      ZFLAG  = .FALSE.
      GFLAG  = .TRUE.
+SELF.
      CFLAG  = .TRUE.
      PFLAG  = .FALSE.
      TFLAG  = .FALSE.
      MFLAG  = .FALSE.
      GRFLAG = .FALSE.
      ASFLAG = .FALSE.
      AXFLAG = .FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
      REDIT  = 0.
+SELF, IF=MAIL.
*
*            MAIL option initialisation
*
      CHCTRL = '``'
      CHEOR  = '@'
      CHMAIL = ' '
+SELF.
*
* METDEF = Default metafile type
* IDMETA = Metafile identifier used by IGMETA
* CHMETA = Current metafile name
* ITGKS  = Identifier of the underlaying Graphical Kernel System used
*
      IFUSER = 0
+SELF, IF=GKSGRAL, IF=-SUNGKS,-ATCGKS,-GKSIBM.
      ITGKS  = 1
      METDEF = 4
      IDMETA = 2
+SELF, IF=PLOT10GKS.
      ITGKS  = 2
      METDEF = 300018
      IDMETA = 2
+SELF, IF=MGKS.
      ITGKS  = 3
      METDEF = 300018
      IDMETA = 2
+SELF, IF=UNIGKS.
      ITGKS  = 5
      METDEF = 1
      IDMETA = 2
+SELF, IF=SUNGKS.
      ITGKS  = 6
      METDEF = 3
      IDMETA = 2
+SELF, IF=GKSIBM.
      ITGKS  = 7
      METDEF = 3
      IDMETA = 2
+SELF, IF=DI3000.
      ITGKS  = 11
      METDEF = 0
      IDMETA = 0
      CALL VZERO(DEVICES,MAXDEV+1)
+SELF, IF=KERNEL,FALCO,BATCH, IF=-MSDOS.
      ITGKS  = 12
      METDEF = -111
      IDMETA = 2
+SELF, IF=DECGKS.
      ITGKS  = 13
      METDEF = 2
      IDMETA = 2
+SELF, IF=ATCGKS.
      ITGKS  = 14
      METDEF = 10120
      IDMETA = 2
+SELF, IF=PHIGS, IF=-KERNEL, IF=-FALCO.
      ITGKS  = 15
      METDEF = 80795
      IDMETA = 2
+SELF, IF=GKSBX.
      ITGKS  = 16
      METDEF = -111
      IDMETA = 2
+SELF, IF=MSDOS.
      IPICNM = 0
      ISURF  = 18
      METDEF = ISURF
      ITGKS  = 16
      IDMETA = 2
      SCMETA = 20.0
+SELF.
      CHMETA = ' '
      TEKACT = .TRUE.
      METACT = .FALSE.
      FILOPN = .FALSE.
      XMFACT = 0.01
      YMFACT = 0.01
*
*              Attributes initialisation
*
      IDID   = 1
      ICLIP  = 1
      IFAISI = 0
+SELF, IF=-DI3000.
      IFASI  = 1
+SELF, IF=DI3000.
      IFASI  = 0
+SELF.
      ILN    = 1
      RLWSC  = 1.0
      RBSL   = 0.01
      IMK    = 1
      RMKSC  = 1.0
      IPLCI  = 1
      IPMCI  = 1
      IFACI  = 1
      ITXALH = 0
      ITXALV = 0
      ITXALG = 0
      RCHH   = 0.28
      RCHUX  = 0.0
      RCHUY  = 1.0
      RANGLE = 0.0
      ITXCI  = 1
      IFONT  = 0
      IPREC  = 2
      IFTPR  = 2
      IBORD  = 0
      INPASS = 1
      RCSHIF = 0.02
      RALH   = 0.018
      RALD   = 0.013
      RTMS   = 0.019
      RBOF   = 0.25
      RBWD   = 0.5
      RAWL   = 0.0
      INLINE = 40
      INBCOL = 8
      IDIM   = 2
*
*              Axis Alphanumeric Labels initialisation
*
      DO 10 I=1,MAXLAB
         HILABS(I) = ' '
   10 CONTINUE
*
*              Initialise workstations parameters
*
* INOPWK = Number of opened workstations
* ILOPWK = List of the workstation IDs of the opened workstations
* IWTYL  = List of the workstation types of the opened workstations
* ACWKFL = List of flags. If TRUE the workstation is active
* XWKSIZ = X size of the workstation
* YWKSIZ = Y size of the workstation
* XWKR   = Workstation ratio on X
* YWKR   = Workstation ratio on Y
* XWKWn  = X worksation window value
* YWKWn  = Y worksation window value
* XWKVn  = X worksation viewport value
* YWKVn  = Y worksation viewport value
* IWINID = Workstation window ID
*
      INOPWK = 0
      DO 20 I=1,10
         ILOPWK(I) = 0
         IWTYL(I)  = 0
         ACWKFL(I) = .FALSE.
         XWKSIZ(I) = 0.
         YWKSIZ(I) = 0.
         IWINID(I) = 0
         XWKR(I)   = 1.
         YWKR(I)   = 1.
         XWKW1(I)  = 0.
         YWKW1(I)  = 0.
         XWKV1(I)  = 0.
         YWKV1(I)  = 0.
         XWKW2(I)  = 1.
         YWKW2(I)  = 1.
         XWKV2(I)  = 1.
         YWKV2(I)  = 1.
   20 CONTINUE
*
      IPICT  = 1
      NT0PRI = 1
*
*              Default Normalisation Transformation
*
      INTR   = 0
      RWXMIN = 0.
      RWXMAX = 1.
      RWYMIN = 0.
      RWYMAX = 1.
      RVXMIN = 0.
      RVXMAX = 1.
      RVYMIN = 0.
      RVYMAX = 1.
      RDWXMI = 0.
      RDWYMI = 0.
      RDWXMA = 1.
      RDWYMA = 1.
*
*              Initialisation for IRQLC
*
      OLDXP = 0.
      OLDYP = 0.
*
*              Initialisation for IGMENU
*
      XPOS(1)=RDWXMA-0.21
      XPOS(2)=RDWXMA-0.01
      YPOS(1)=RDWYMA-0.71
      YPOS(2)=RDWYMA-0.01
+SELF, IF=GKS, IF=-MGKS.
      DO 30 I=1,100
         ISEGM(I)=0
   30 CONTINUE
+SELF, IF=DI3000.
      DO 30 I=1,100
         ISEGM(I)=0
   30 CONTINUE
+SELF.
*
*              Initialisation of the NT transformation storage
*
+SELF, IF=-NTC, IF=-X11.
      NTSTOR(1)=0
+SELF, IF=NTC,X11.
      CALL IGNINT
+SELF.
*
*              Initialisation of the number of stacked legos plots
*
      NIDS=0
*
*              Initialise the color table
*
      REDLUT(1)=1.
      REDLUT(2)=0.
      REDLUT(3)=1.
      REDLUT(4)=0.
      REDLUT(5)=0.
      REDLUT(6)=1.
      REDLUT(7)=1.
      REDLUT(8)=0.
      GRNLUT(1)=1.
      GRNLUT(2)=0.
      GRNLUT(3)=0.
      GRNLUT(4)=1.
      GRNLUT(5)=0.
      GRNLUT(6)=1.
      GRNLUT(7)=0.
      GRNLUT(8)=1.
      BLULUT(1)=1.
      BLULUT(2)=0.
      BLULUT(3)=0.
      BLULUT(4)=0.
      BLULUT(5)=1.
      BLULUT(6)=0.
      BLULUT(7)=1.
      BLULUT(8)=1.
      DCOL=1./(NBCLUT-9)
      DO 60 I=9,NBCLUT
         GREY=1.-DCOL*(I-9)
         REDLUT(I)=GREY
         GRNLUT(I)=GREY
         BLULUT(I)=GREY
   60 CONTINUE
*
      END
+DECK,  IGIWIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:35  mclareni
* Higz

      FUNCTION IGIWIN(IWKID)
*.===========>
*.   IG Inquire Workstation INdex
*..==========>
+CDE, HIATT.
      IGIWIN=0
      DO 10 I=1,INOPWK
         IF(IWKID.EQ.ILOPWK(I))THEN
            IGIWIN=I
            RETURN
         ENDIF
   10 CONTINUE
*
      END
+DECK,  IGIWTY, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:35  mclareni
* Higz

      FUNCTION IGIWTY(IWKID)
*.===========>
*.
*.   This function return the workstation type of the workstation
*. identified by IWKID .
*.
*. _Input parameters:
*.
*.  INTEGER IWKID : Workstation identifier .
*.
*..==========> (O.Couet)
+CDE, HIATT.
      PARAMETER (NBWKOP=10)
*.______________________________________
*
      IGIWTY=0
      DO 10 I=1,NBWKOP
         IF(IWKID.EQ.ILOPWK(I))THEN
            IGIWTY=IWTYL(I)
            RETURN
         ENDIF
   10 CONTINUE
*
      END
+DECK,  IGLBL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

      SUBROUTINE IGLBL(NLBL,CHLBL)
*.==========>
*.
*.   To change the alphanumeric label of the axis.
*.
*. _Input parameters:
*.
*. INTEGER NLBL : Number of alphanumeric labels in CHLBL
*. CHARACTER CHLBL : New value of the alphanumeric labels
*.
*..=========> (O.Couet)
+CDE, HIFLAG.
+CDE, HILABS.
      CHARACTER*(*) CHLBL(*)
*._____________________________
*
      IF(NLBL.LE.0.OR.NLBL.GT.MAXLAB)THEN
         CALL IGERR('Wrong number of labels','IGLBL')
         RETURN
      ENDIF
*
      NHILAB = NLBL
      DO 10 I=1,NLBL
         HILABS(I) = CHLBL(I)
   10 CONTINUE
      DO 20 I=NLBL+1,MAXLAB
         HILABS(I) = ' '
   20 CONTINUE
*
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZLBL
+SELF.
*
      END
+DECK,  IGLEV, T=FORT.
* Revision 1.2  2002/03/18 14:18:08  couet
* - The number of divisions when IHCSPE is called, must be positive.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

      SUBROUTINE IGLEV(N,WMINI,WMAXI,ICOLOR,CHOPT)
*.===========>
*.
*.   This routines allows to initialize the level for the
*. IH routines set. It can initialize the levels along the
*. Z axis (CHOPT='A') or with a palette of colors (CHOPT='C')
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of levels
*.  REAL WMINI : minimum value on Z axis
*.  REAL WMAXI : maximum value on Z axis
*.  INTEGER ICOLOR : Array containing the palette
*.  CHARACTER : Option ('A' or 'C'). The two options
*.              are exclusive.
*.
*..==========> (O.Couet)
+CDE, HIGRAF.
      CHARACTER*(*) CHOPT
      DIMENSION ICOLOR(*)
*.______________________________________
*
      NDIVZ=N
      WMIN=WMINI
      WMAX=WMAXI
*
*              Initialize the levels on the Z axis
*
      IF(INDEX(CHOPT,'A').NE.0)THEN
         IF(NDIVZ.LT.0)THEN
            CALL IGAXIS(-1.,1.,-1.,1.,WMIN,WMAX,-NDIVZ,'XN')
         ELSE
            CALL IGAXIS(-1.,1.,-1.,1.,WMIN,WMAX,NDIVZ,'X')
         ENDIF
         CALL IHCSPE(ABS(NDIVZ),WMIN,WMAX,1,0,IREP)
      ENDIF
*
*              Initialize the colour levels
*
      IF(INDEX(CHOPT,'C').NE.0)THEN
         IF(NDIVZ.GE.NPMAX)THEN
            CALL IGERR('Too many levels','IGLEV')
            RETURN
         ENDIF
         DZ = (WMAX-WMIN)/FLOAT(NDIVZ)
         DO 10 I=1,NDIVZ-1
            YGRAF(I)=WMIN+DZ*FLOAT(I)
   10    CONTINUE
         CALL IHCLEV(NDIVZ-1,YGRAF,ICOLOR,IREP)
      ENDIF
*
      END
+DECK,  IGLOC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

* No more special case for DI3000
      SUBROUTINE IGLOC(ICURS,NT,IBN,XNDC,YNDC,XWC,YWC)
*.===========>
*.
*.   This routine returns the locator coordinates in the NDC space and in
*. the WC space. If REDIT.NE.0 Or REDIT.NE.1 the XNDC and YNDC value are
*. always returns like REDIT=1 or 0 but the XWC and YWC values are computed
*. according to the value of REDIT.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIQUES.
*.______________________________________
*
      CALL IRQLC(IDID,ICURS,ISTA,NNT,PX,PY)
      NT=NNT
      IBN=ISTA
      XWC=PX
      YWC=PY
      XNDC=RQUEST(11)
      YNDC=RQUEST(12)
*
      END


+DECK,  IGLOC2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

      SUBROUTINE IGLOC2(IWKID,NT,XLOC1,YLOC1,XLOC2,YLOC2,ISTAT,CHOPT)
*.===========>
*.
*.   This routine returns the graphic cursor position in WC space of
*.   2 points (XLOC1,YLOC1) AND (XLOC2,YLOC2) and the corresponding
*.   normalize transformation number NT.
*.   Rubber_banding option is used to visualize the area (box) delimited
*.   by the 2 points.
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  CHARACTER CHOPT : Option flags
*.            CHOPT = ' ' NT is an output parameter
*.            CHOPT = 'P' NT is an input parameter
*.            CHOPT = 'L' Rubberbanding Line
*.
*. _Output parameters:
*.
*.  INTEGER NT : Normalization transformation number .
*.  REAL XLOC1 YLOC1 : Cursor position in WC space of first point .
*.  REAL XLOC2 YLOC2 : Cursor position in WC space of second point .
*.  INTEGER ISTAT : Return status: 0=BREAK, 1=OK .
*.
*..==========> (R.Brun)
      CHARACTER*(*) CHOPT
*.______________________________________
*
      IF(INDEX(CHOPT,'P').NE.0)CALL ISELNT(NT)
      CALL IRQLC(IWKID,1,ISTAT,NT,XLOC1,YLOC1)
      IF(ISTAT.EQ.0)RETURN
*
      IPET=51
      IF(INDEX(CHOPT,'L').NE.0)THEN
         IPET=41
      ENDIF
      CALL IRQLC(IWKID,IPET,ISTAT,NT2,XLOC2,YLOC2)
      IF(NT2.NE.NT)NT=0
*
      END

+DECK,  IGM100, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

      LOGICAL FUNCTION IGM100(METAFL)
*
      IGM100=.FALSE.
+SELF, IF=GKSGRAL.
      IF(METAFL.EQ.12201.OR.METAFL.EQ.12202.OR.METAFL.EQ.101.OR.
     +  (METAFL.GE.4011.AND.METAFL.LE.4230).OR.
     +  (METAFL.GE.14401.AND.METAFL.LE.14420))IGM100=.TRUE.
+SELF, IF=ATCGKS.
      IF((METAFL.GE.10100.AND.METAFL.LE.10300).OR.
     +   (METAFL.GE.1500.AND.METAFL.LE.1505).OR.
     +   (METAFL.GE.1900.AND.METAFL.LE.1905).OR.
     +   (METAFL.GE.5300.AND.METAFL.LE.5350).OR.
     +   (METAFL.GE.6300.AND.METAFL.LE.6307))IGM100=.TRUE.
+SELF.
*
      END
+DECK,  IGMESS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

      SUBROUTINE IGMESS(N,CHMESS,CHTIT,CHOPT)
+SELF, IF=X11.
+CDE, HIKERN.
+SELF.
      CHARACTER*(*) CHMESS(N),CHTIT,CHOPT
      CHARACTER*12 CODED
*.______________________________________
*
+SELF, IF=-X11.
      WRITE (CODED,'(''('',I2,''(X,A,/))'')') N
      IF(INDEX(CHOPT,'P').NE.0)WRITE (6,CODED)
     +              (CHMESS(I)(1:LENOCC(CHMESS(I))+1),I=1,N)
+SELF, IF=X11.
*
      IF(INDEX(CHOPT,'T').NE.0)THEN
         WRITE (CODED,'(''('',I2,''(X,A,/))'')') N
         IF(INDEX(CHOPT,'P').NE.0)WRITE (6,CODED)
     +                (CHMESS(I)(1:LENOCC(CHMESS(I))+1),I=1,N)
         RETURN
      ENDIF
*
      LENMAX=LENOCC(CHMESS(1))
      DO 10 I=2,N
         IF(LENOCC(CHMESS(I)).GT.LENMAX)LENMAX=LENOCC(CHMESS(I))
   10 CONTINUE
      CALL IGXMES(0,0,LENMAX,N,CHMESS,CHTIT,CHOPT)
*
+SELF.
*
      END
+DECK,  IGMETA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

+SELF, IF=-DI3000.
      SUBROUTINE IGMETA (IIUNIT,METAFL)
*.==========>
*.
*.   To open, activate, deactivate and close metafile or screen
*.
*..=========>
+CDE, HIMETA.
+CDE, HIMET2.
+CDE, HIFLAG.
+SELF, IF=-DI3000, IF=ATCGKS.
      CHARACTER*24 METAFILE
+SELF, IF=-DI3000.
*._____________________________
*
      IUNIT = IIUNIT
      IF(IIUNIT.EQ.999)IUNIT = 0
*
*              Output to screen and metafile
*
      IWKID=1
      IF (IUNIT.GT.0) THEN
         GFLAG=.TRUE.
         IF (.NOT.TEKACT) THEN
            CALL IACWK(IWKID)
            TEKACT=.TRUE.
         ENDIF
         IF (.NOT. METACT) THEN
            IF (.NOT. FILOPN) THEN
               IF(METAFL.NE.0)THEN
                  IWT=METAFL
               ELSE
                  IWT=METDEF
               ENDIF
+SELF, IF=-DI3000, IF=ATCGKS.
            IF(CHMETA.EQ.' ') THEN
               IF(IWT.EQ.10100)THEN
                  METAFILE='cgmb.met'
               ELSEIF(IWT.EQ.10110)THEN
                  METAFILE='cgmc.met'
               ELSEIF(IWT.EQ.10120)THEN
                  METAFILE='cgmt.met'
               ELSEIF(IWT.GE.1500.AND.IWT.LE.1505)THEN
                  METAFILE='talaris.higz'
               ELSEIF(IWT.GE.1900.AND.IWT.LE.1905)THEN
                  METAFILE='postscr.higz'
               ELSEIF(IWT.GE.5300.AND.IWT.LE.5350)THEN
                  METAFILE='x11.higz'
               ELSEIF(IWT.GE.6300.AND.IWT.LE.6307)THEN
                  METAFILE='imagen.higz'
               ELSE
                  METAFILE='printer.higz'
               ENDIF
            ELSE
               METAFILE=CHMETA
            ENDIF
            CALL GUESC050(IUNIT,METAFILE)
+SELF, IF=-DI3000.
               CALL IOPWK (IDMETA,IUNIT,IWT)
+SELF, IF=-DI3000, IF=-MSDOS.
               FILOPN = .TRUE.
+SELF, IF=-DI3000, IF=MSDOS.
               IF(IWT.NE.METDEF)FILOPN = .TRUE.
+SELF, IF=-DI3000.
            ENDIF
            CALL IACWK(IDMETA)
            METACT = .TRUE.
         ENDIF
         RETURN
      ENDIF
*
*              Output to screen only
*
      IF(IUNIT.EQ.0)THEN
         CALL IGQWK(IWKID,'OPEN',RVAL)
         IF(RVAL.NE.0.)THEN
            GFLAG=.TRUE.
            IF (.NOT.TEKACT) THEN
               CALL IACWK(IWKID)
               TEKACT = .TRUE.
            ENDIF
         ENDIF
         IF (METACT) THEN
            CALL IDAWK(IDMETA)
            METACT = .FALSE.
         ENDIF
         IF(IIUNIT.EQ.999)THEN
            CALL ICLWK(IDMETA)
            FILOPN=.FALSE.
         ENDIF
         RETURN
      ENDIF
*
*              Output to metafile file only
*
      IF (TEKACT) THEN
         CALL IDAWK(IWKID)
         TEKACT = .FALSE.
      ENDIF
      IF (.NOT. METACT) THEN
         IF (.NOT. FILOPN) THEN
            IF(METAFL.NE.0)THEN
               IWT=METAFL
            ELSE
               IWT=METDEF
            ENDIF
+SELF, IF=-DI3000, IF=ATCGKS.
            IF(CHMETA.EQ.' ') THEN
               IF(IWT.EQ.10100)THEN
                  METAFILE='cgmb.met'
               ELSEIF(IWT.EQ.10110)THEN
                  METAFILE='cgmc.met'
               ELSEIF(IWT.EQ.10120)THEN
                  METAFILE='cgmt.met'
               ELSEIF(IWT.GE.1500.AND.IWT.LE.1505)THEN
                  METAFILE='talaris.higz'
               ELSEIF(IWT.GE.1900.AND.IWT.LE.1905)THEN
                  METAFILE='postscr.higz'
               ELSEIF(IWT.GE.5300.AND.IWT.LE.5350)THEN
                  METAFILE='x11.higz'
               ELSEIF(IWT.GE.6300.AND.IWT.LE.6307)THEN
                  METAFILE='imagen.higz'
               ELSE
                  METAFILE='printer.higz'
               ENDIF
            ELSE
                  METAFILE=CHMETA
            ENDIF
            CALL GUESC050(-IUNIT,METAFILE)
+SELF, IF=-DI3000.
            CALL IOPWK (IDMETA,-IUNIT,IWT)
+SELF, IF=-DI3000, IF=-MSDOS.
            FILOPN = .TRUE.
+SELF, IF=-DI3000, IF=MSDOS.
            IF(IWT.NE.METDEF)FILOPN = .TRUE.
+SELF, IF=-DI3000.
         ENDIF
         CALL IACWK(IDMETA)
         METACT = .TRUE.
         IF(IWT.LT.0)GFLAG=.FALSE.
      ENDIF
*
      END
+SELF.
+DECK,  IGMETN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

      SUBROUTINE IGMETN(CHNAME)
*.===========>
*.
*.  Set the metafile name
*.
*..==========>
+CDE, HIMETA.
      CHARACTER*(*) CHNAME
      CHMETA = CHNAME
      END
+DECK,  IGOBJ, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

+SELF, IF=X11.
      SUBROUTINE IGOBJ(IX,IY,NBLEV,IPID,CHPID)
*.===========>
*.
*.   This routine return to KUIP/Motif the object picked
*. on the HIGZ/X11 graphics window.
*.
*. _Input parameters:
*.
*.  INTEGER IX,IY : Cursor position
*.  INTEGER NBLEV : Window number
*.
*. _Output parameters:
*.
*.  INTEGER NBLEV : Number of level in the pick path
*.  INTEGER IPID(NBLEV) : Integer ID.
*.  CHARACTER CHPID(NBLEV) : Character ID. CHPID(1)=Class name
*.
*..==========>
      CHARACTER*(*) CHPID(*)
      DIMENSION IPID(*)
*.______________________________________
*
      X     = FLOAT(IX)
      Y     = FLOAT(IY)
      IWIN  = NBLEV
      NBLEV = 0
      CALL IZPICT(' ','QO')
      CALL IRQLC(1,99,ISTAT,NT,X,Y)
      CALL IGPICK(NT,X,Y,NBLEV,CHPID,IPID,' ')
*
      IF(NBLEV.EQ.0)THEN
         NT2 = 0
   10    IF (NT2.NE.NT) THEN
            CALL ISELNT(NT2)
            X = FLOAT(IX)
            Y = FLOAT(IY)
            CALL IRQLC(1,99,ISTAT,NTT,X,Y)
            IF (NTT.EQ.NT2) THEN
               CALL IGPICK(NT2,X,Y,NBLEV,CHPID,IPID,' ')
               IF (NBLEV.NE.0) RETURN
            ENDIF
         ENDIF
         NT2 = IZGNNT(NT2)
         IF (NT2.GE.0) GOTO 10
         NBLEV    = 1
         CHPID(1) = 'win'
         IPID(1)  = IWIN
      ENDIF
*
      END
+SELF.
+DECK,  IGPARF, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:36  mclareni
* Higz

      SUBROUTINE IGPARF(IARCH,CHOPT)
+SELF, IF=PHIGS.
+CDE, HIATT.
+SELF.
      CHARACTER*(*) CHOPT
+SELF, IF=PHIGS.
      IF (IDIM.NE.3) RETURN
*
      IF (CHOPT.EQ.'S') THEN
         CALL PSCNRS (2,2)
         CALL POPARF (1,IARCH)
         CALL PARAST (1)
         CALL PCLARF (1)
      ENDIF
*
      IF (CHOPT.EQ.'D') THEN
         CALL PSCNRS(1,1)
         CALL POPARF (1,IARCH)
         CALL PDASAR(1)
         CALL PCLARF (1)
      ENDIF
*
      IF (CHOPT.EQ.'R') THEN
         CALL PSCNRS(2,2)
         CALL POPARF (1,IARCH)
         CALL PQSID(IN,IERR,INUM,ISTRID)
         ISTCNT=101
         DO 10 I=1,INUM
            CALL PQSID(I,IERR,INUM,ISTRID)
            IF (ISTRID.GT.ISTCNT) ISTCNT=ISTRID
   10    CONTINUE
         ISTCNT=ISTCNT+1
         CALL PRAST (1)
         CALL PCLARF(1)
      ENDIF
+SELF.
      END
+DECK,  IGPAVE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGPAVE(X1I,X2I,Y1I,Y2I,DZ,ISBOX,ISFRAM,CHOPT)
*.==============>
*.
*.   Draw a paving-block (box with 3D effect). Useful for slides.
*. ISBOX (ISFRAM) may be 1000+ICOLOR where ICOLOR is the color index
*. of the box (frame), or 2000+IPAT where IPAT is the pattern index of
*. the box (frame), otherwise the style index.
*. If ISBOX(ISFRAM)=0, only the box contour is drawn with the current
*. polyline attributes.
*. By default the Top and the Right frame are drawn. CHOPT='TR'.
*.
*. _Input parameters:
*.
*.  REAL X1I : X bottom left corner of box
*.  REAL X2I : X top right corner of box
*.  REAL Y1I : Y bottom left corner of box
*.  REAL Y2I : Y top right corner of box
*.  REAL DZ : Box width
*.  INTEGER ISBOX : Box style
*.  INTEGER ISFRAM : Frame style' I D=5
*.  CHARACTER CHOPT : Character option
*.            CHOPT='T' Top frame
*.            CHOPT='B' Bottom frame
*.            CHOPT='R' Right frame
*.            CHOPT='L' Left frame
*.            CHOPT='-' Negative sense
*.            CHOPT='S' Shadow
*.            CHOPT='P' Cut the shadow
*.            CHOPT='K' Key
*.            CHOPT='D' Delete (usefull for IGMENU)
*.
*.============> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION IOPT(9)
      EQUIVALENCE (IOPTT,IOPT(1)),(IOPTB,IOPT(2))
      EQUIVALENCE (IOPTL,IOPT(3)),(IOPTR,IOPT(4))
      EQUIVALENCE (IOPTM,IOPT(5)),(IOPTS,IOPT(6))
      EQUIVALENCE (IOPTP,IOPT(7)),(IOPTK,IOPT(8))
      EQUIVALENCE (IOPTD,IOPT(9))
      CHARACTER*(*) CHOPT
      DIMENSION X(4),Y(4)
      LOGICAL ZFSAV
*.______________________________________
*
      CALL UOPTC(CHOPT,'TBLR-SPKD',IOPT)
      IF(CHOPT.EQ.' ')THEN
         IOPTT=1
         IOPTR=1
      ELSE
         IF((IOPTT+IOPTR+IOPTL+IOPTB).GE.3
     +.OR.  (IOPTL+IOPTR).EQ.2
     +.OR.  (IOPTT+IOPTB).EQ.2      )THEN
            CALL IGERR('Incompatible options, default is taken'
     +,                'IGPAVE')
            IOPTT=1
            IOPTR=1
            IOPTB=0
            IOPTL=0
            IOPTM=0
         ENDIF
      ENDIF
*
*              Sort the PAVE coordinates.
*
      IF (X1I.GT.X2I) THEN
         X1 = X2I
         X2 =X 1I
      ELSE
         X1 = X1I
         X2 = X2I
      ENDIF
      IF (Y1I.GT.Y2I) THEN
         Y1 = Y2I
         Y2 = Y1I
      ELSE
         Y1 = Y1I
         Y2 = Y2I
      ENDIF
*
*              Store the PAVE inside the current picture.
*              The sorted coordinates are stored otherwise picking
*              is impossible.
*
+SELF, IF=ZEBRA.
      IF(GLFLAG)CALL IZPAVE(X1,X2,Y1,Y2,DZ,ISBOX,ISFRAM,IOPT)
+SELF.
      IF((.NOT.GFLAG).AND.(.NOT.PFLAG))RETURN
      ZFSAV  = ZFLAG
      ZFLAG  = .FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
*              Save the context
*
      IBORDS = IBORD
      IFACIS = IFACI
      IFAISS = IFAIS
      IFASIS = IFASI
*
*              Delete a Paving-Block
*
      IF(IOPTD.NE.0)THEN
         CALL ISFACI(0)
         CALL ISPLCI(0)
         CALL ISFAIS(1)
         CALL ISLN(1)
         CALL IGSET('BORD',1.)
         GOTO 20
      ENDIF
*
*              Draw the inside of the box
*
      IF(ISBOX.EQ.0)THEN
         CALL ISFAIS(0)
         GOTO 10
      ENDIF
      IF(ISBOX.LT.1000)THEN
         CALL ISFAIS(3)
         CALL ISFASI(ISBOX)
         GOTO 10
      ENDIF
      IF(ISBOX.GE.1000.AND.ISBOX.LT.2000)THEN
         CALL ISFAIS(1)
         CALL ISFACI(ISBOX-1000)
         GOTO 10
      ENDIF
      IF(ISBOX.GE.2000)THEN
         CALL ISFAIS(2)
         CALL ISFASI(ISBOX-2000)
      ENDIF
   10 CALL IGSET('BORD',0.)
   20 CALL IGBOX(X1,X2,Y1,Y2)
      IF(IOPTD.NE.0)GOTO 30
*
*              Draw the frame
*
      IF(DZ.LE.0.)GOTO 40
      IF(ISFRAM.EQ.ISBOX)GOTO 30
      IF(ISFRAM.EQ.0)THEN
         CALL ISFAIS(0)
         GOTO 30
      ENDIF
      IF(ISFRAM.LT.1000)THEN
         CALL ISFAIS(3)
         CALL ISFASI(ISFRAM)
         CALL ISFACI(1)
         GOTO 30
      ENDIF
      IF(ISFRAM.GE.1000.AND.ISFRAM.LT.2000)THEN
         CALL ISFAIS(1)
         CALL ISFACI(ISFRAM-1000)
         GOTO 30
      ENDIF
      IF(ISFRAM.GE.2000)THEN
         CALL ISFAIS(2)
         CALL ISFASI(ISFRAM-2000)
      ENDIF
*
   30 DZ2=0.5*DZ
      IF(IOPTM.NE.0)THEN
         M = -1
      ELSE
         M = 1
      ENDIF
      IF(IOPTS.NE.0)THEN
         IS = 1
      ELSE
         IS = 0
      ENDIF
      IF(IOPTK.NE.0)THEN
         IS    = 0
         M     = 1
         IOPTP = 0
         IOPTS = 0
         K     = -2
      ELSE
         K = 0
      ENDIF
*
* Top side
*
      IF(IOPTT.NE.0.OR.IOPTK.NE.0)THEN
         IF(IOPTL.NE.0.AND.IOPTK.EQ.0)M=-1
         X(1)=X1+IS*M*DZ2
         X(2)=X1+M*DZ2+K*DZ2
         X(3)=X2+M*DZ2
         X(4)=X2+IS*M*DZ2
         Y(1)=Y2
         Y(2)=Y2+DZ2
         Y(3)=Y2+DZ2
         Y(4)=Y2
         IF(IOPTP.NE.0)THEN
            IF(M.GT.0)THEN
               X(3)=X2
            ELSE
               X(2)=X1
            ENDIF
         ENDIF
         IF(IOPTT.NE.0.OR.IOPTD.NE.0)CALL IFA(4,X,Y)
         IF(IOPTS.EQ.0)CALL IPL(4,X,Y)
         M=1
      ENDIF
*
* Bottom side
*
      IF(IOPTB.NE.0.OR.IOPTK.NE.0)THEN
         IF(IOPTL.NE.0.AND.IOPTK.EQ.0)M=-1
         X(1)=X1+IS*M*DZ2
         X(2)=X1+M*DZ2+K*DZ2
         X(3)=X2+M*DZ2
         X(4)=X2+IS*M*DZ2
         Y(1)=Y1
         Y(2)=Y1-DZ2
         Y(3)=Y1-DZ2
         Y(4)=Y1
         IF(IOPTP.NE.0)THEN
            IF(M.GT.0)THEN
               X(3)=X2
            ELSE
               X(2)=X1
            ENDIF
         ENDIF
         IF(IOPTB.NE.0.OR.IOPTD.NE.0)CALL IFA(4,X,Y)
         IF(IOPTS.EQ.0)CALL IPL(4,X,Y)
         M=-1
      ENDIF
*
* Left side
*
      IF(IOPTL.NE.0.OR.IOPTK.NE.0)THEN
         X(1)=X1
         X(2)=X1-DZ2
         X(3)=X1-DZ2
         X(4)=X1
         Y(1)=Y1+IS*M*DZ2
         Y(2)=Y1+M*DZ2
         Y(3)=Y2+M*DZ2-K*DZ2
         Y(4)=Y2+IS*M*DZ2
         IF(IOPTP.NE.0)THEN
            IF(M.GT.0)THEN
               Y(3)=Y2
            ELSE
               Y(2)=Y1
            ENDIF
         ENDIF
         IF(IOPTL.NE.0.OR.IOPTD.NE.0)CALL IFA(4,X,Y)
         IF(IOPTS.EQ.0)CALL IPL(4,X,Y)
      ENDIF
*
* Right side
*
      IF(IOPTR.NE.0.OR.IOPTK.NE.0)THEN
         X(1)=X2
         X(2)=X2+DZ2
         X(3)=X2+DZ2
         X(4)=X2
         Y(1)=Y1+IS*M*DZ2
         Y(2)=Y1+M*DZ2
         Y(3)=Y2+M*DZ2-K*DZ2
         Y(4)=Y2+IS*M*DZ2
         IF(IOPTP.NE.0)THEN
            IF(M.GT.0)THEN
               Y(3)=Y2
            ELSE
               Y(2)=Y1
            ENDIF
         ENDIF
         IF(IOPTR.NE.0.OR.IOPTD.NE.0)CALL IFA(4,X,Y)
         IF(IOPTS.EQ.0)CALL IPL(4,X,Y)
      ENDIF
      IF(IOPTD.NE.0)GOTO 50
*
*              Draw boundary of the box
*
   40 CALL ISFAIS(0)
      CALL IGSET('BORD',1.)
      CALL IGBOX(X1,X2,Y1,Y2)
*
*              Restore the context
*
   50 CALL IGSET('BORD',FLOAT(IBORDS))
      CALL ISFACI(IFACIS)
      CALL ISFAIS(IFAISS)
      CALL ISFASI(IFASIS)
      ZFLAG  = ZFSAV
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGPHST, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGPHST(RMIN,RMAX,THETA,PHI,UP,CHOPT)
********************************************************************
*     Initalises (start) PHIGS and sets the structure id
*     sphere_id - structure id
*     NEW - to delelte or not to delete
********************************************************************
*
+SELF, IF=PHIGS.
+CDE, HIATT.
      CHARACTER*(*)  CHOPT
      REAL RMIN(3),RMAX(3)
      PARAMETER (PI=3.14159)
      INTEGER         NSNO
      REAL           V(4,4)
      COMMON /NAMESET/ NSNO
*.______________________________________
*
      IF (IDIM.EQ.3) THEN
         RTHETA=THETA/180.*PI
         RPHI=PHI/180.*PI
         RUP=UP/180.*PI
         IF (CHOPT.NE.'S') THEN
            CALL IGPARF(12,'D')
            CALL POPST (101)
            CALL PADS (1,1)
            CALL PSVWI (1)
            CALL PLB (0)
            CALL PSIS (1)
* Set label to locate the transformation matrix
            CALL PLB   (1)
* Set global matrix transformation
            SLX=(RMAX(1)-RMIN(1))
            SLY=(RMAX(2)-RMIN(2))
            SLZ=(RMAX(3)-RMIN(3))
            SLTX=-RMIN(1)/SLX
            SLTY=-RMIN(2)/SLY
            SLTZ=-RMIN(3)/SLZ
            MIDX=0.0
            MIDY=0.0
            MIDZ=0.0
            CALL PBLTM3
     +      (MIDX,MIDY,MIDZ,SLTX,SLTY,SLTZ,0.0,0.0,0.0,
     +      1/SLX,1/SLY,1/SLZ,IERR,V)
            CALL PSLMT3(V,0)
* Set default attributes
            CALL PSMKSC(.5)
            CALL PSMK(1)
            CALL PSPLCI(1)
* Set annotation text attributes
            CALL PSTXFN(-3)
            CALL PSTXCI(1)
            CALL PSATCH(.009)
            CALL PSCHXP(1.)
            CALL PSATCU(0.,1.)
            CALL PSATP(0)
* Set edge attributes
            CALL PLB (2)
            CALL PSEDFG (PON)
            CALL PCLST
            NSNO=3
         ELSE
            CALL IGPARF(12,'R')
         ENDIF
      ENDIF
+SELF.
      END
+DECK,  IGPICK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGPICK(NT,XLOC,YLOC,NBLEV,CHPID,IPID,CHOPT)
*.===========>
*.
*.  See the help in the HIGZ manual
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HICODE.
+CDE, HIPICK.
      PARAMETER (PI=3.14159265,DEGRAD=PI/180.)
      CHARACTER*(*) CHOPT
      CHARACTER*(*) CHPID(*)
      CHARACTER*80 TX_STR
      DIMENSION TX_PX(4),TX_PY(4)
      DIMENSION IPID(*)
      LOGICAL LOPICK,LOLVL
*.______________________________________
*
      IF(LPICD.LE.0)THEN
         IF(LPICT.GT.0)THEN
            LPICD = LPICT
            LDNT0 = LHNT0
            LDI   = LHI
            LDF   = LHF
            LDC   = LHC
         ELSE
            NBLEV = 0
            RETURN
         ENDIF
      ENDIF
*
*              Compute in LNDECO the bank adress of NT
*
      LN     = LQ(LPICD-1)
      LNDECO = 0
      DO 111 I=1,IQ(LPICD+8)
         IF(LN.EQ.0)GOTO 222
         IF(IQ(LN+1).EQ.NT)THEN
            LNDECO = LN
            GOTO 222
         ENDIF
         LN=LQ(LN)
  111 CONTINUE
      RETURN
  222 CONTINUE
*
      LIDECO     = LDI
      LFDECO     = LDF
      LCDECO     = LDC
*
      IAW        = IQ(LNDECO+2)
      DX         = (Q(LFDECO+IAW+1)-Q(LFDECO+IAW))/200.
      DY         = (Q(LFDECO+IAW+3)-Q(LFDECO+IAW+2))/200.
*
      IREPTR     = IQ(LNDECO+4)
      NBLEV      = 0
      ICLEV      = 999
      LOPICK     = .FALSE.
      LOLVL      = .FALSE.
      CHLVL      = ' '
      IPILVL     = 0
*
* IQUEST(60) --> Adress
* IQUEST(61) --> Type
*
      IQUEST(60) = 0
      IQUEST(61) = 0
*
*              Scan the LNDECO bank
*
    1 IREPTR=IREPTR-1
      IF(IREPTR.EQ.9)RETURN
      IADRI=MOD(IQ(LNDECO+IREPTR),1000000)
*
      GOTO (1,1,30,40,1
     +,     60,70,80,90,100,110,120,130,140,150,160,170,180,1
     +,     200,210,220,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
     +,     1,1,1
     +,     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
     +,     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
     +      ),INT(IQ(LNDECO+IREPTR)/1000000)
*
*              Primitive ID with NAME
*
   30 IF(.NOT.LOPICK)GOTO 1
      IF(IQ(LIDECO+IADRI).GE.ICLEV)GOTO 1
      ICLEV = IQ(LIDECO+IADRI)
      IF(ICLEV.GT.NBLEV)NBLEV=ICLEV
      IPID(ICLEV) = IQ(LIDECO+IADRI+1)
      CALL UHTOC(IQ(LCDECO+IQ(LIDECO+IADRI+2)),4,CHLVL2,LEVLEN)
      CHPID(ICLEV) = CHLVL2(1:LEN(CHPID(ICLEV)))
      IF(ICLEV.EQ.1)THEN
         IF(LOLVL)THEN
            NBLEV        = NBLEV+1
            IPID(NBLEV)  = IPILVL
            CHPID(NBLEV) = CHLVL(1:LEN(CHPID(NBLEV)))
         ENDIF
         RETURN
      ENDIF
      GOTO 1
*
*              Primitive ID without NAME
*
   40 IF(.NOT.LOPICK)GOTO 1
      IF(IQ(LIDECO+IADRI).GE.ICLEV)GOTO 1
      ICLEV = IQ(LIDECO+IADRI)
      IF(ICLEV.GT.NBLEV)NBLEV=ICLEV
      IPID(ICLEV) = IQ(LIDECO+IADRI+1)
      IF(ICLEV.EQ.1)THEN
         IF(LOLVL)THEN
            NBLEV        = NBLEV+1
            IPID(NBLEV)  = IPILVL
            CHPID(NBLEV) = CHLVL(1:LEN(CHPID(NBLEV)))
         ENDIF
         RETURN
      ENDIF
      GOTO 1
*
*              Histograms
*
   60 IF(LOPICK)GOTO 1
      IADRF  = IQ(LIDECO+IADRI)
      NBINS  = IQ(LIDECO+IADRI+1)
      ICHOPT = IQ(LIDECO+IADRI+2)
*
* Non equidistant bins
*
      IF(JBIT(ICHOPT,8).NE.0)THEN
      ELSE
*
* Equidistant bins
*
         X1    = Q(LFDECO+IADRF)
         X2    = Q(LFDECO+IADRF+1)
         XLOCH = XLOC
         YLOCH = YLOC
         IF(JBIT(ICHOPT,12).NE.0)THEN
            IF(JBIT(ICHOPT,13).NE.0)XLOCH = 10**XLOC
            IF(JBIT(ICHOPT,14).NE.0)YLOCH = 10**YLOC
         ENDIF
         IF(XLOCH.GE.X1.AND.XLOCH.LE.X2)THEN
            N      = NBINS*((XLOCH-X1)/(X2-X1))
            IF(YLOCH.LE.Q(LFDECO+IADRF+2+N))THEN
               LOLVL  = .TRUE.
               IPILVL = N+1
               CHLVL  = 'BIN'
               GOTO 500
            ENDIF
         ENDIF
      ENDIF
      GOTO 1
*
*              Polymarker with one point
*
   70 IF(LOPICK)GOTO 1
      GOTO 1
*
*              Polyline with two points
*
   80 IF(LOPICK)GOTO 1
      IP = IGPKPL(XLOC,YLOC,2,Q(LFDECO+IADRI),Q(LFDECO+IADRI+2),DX,DY)
      IF(IP.NE.0)GOTO 500
      GOTO 1
*
*              Polyline
*
   90 IF(LOPICK)GOTO 1
      IADRF = IQ(LIDECO+IADRI)
      N  = IQ(LIDECO+IADRI+1)
      IP = IGPKPL(XLOC,YLOC,N,Q(LFDECO+IADRF),Q(LFDECO+IADRF+N),DX,DY)
      IF(IP.NE.0)GOTO 500
      GOTO 1
*
*              Polymarker
*
  100 IF(LOPICK)GOTO 1
      IADRF = IQ(LIDECO+IADRI)
      N  = IQ(LIDECO+IADRI+1)
      IP = IGPKPM(XLOC,YLOC,N,Q(LFDECO+IADRF),Q(LFDECO+IADRF+N),DX,DY)
      IF(IP.NE.0)THEN
         IF(INT(IQ(LNDECO+IREPTR+1)/1000000).EQ.IMIDCO)THEN
            IADRID=MOD(IQ(LNDECO+IREPTR+1),1000000)
            ICLEV = IQ(LIDECO+IADRID)
            IF(ICLEV.GT.NBLEV)NBLEV=ICLEV
            IPID(ICLEV) = IQ(LIDECO+IADRID+IP)
            CHPID(ICLEV)='POINT'
         ENDIF
         GOTO 500
      ENDIF
      GOTO 1
*
*              Fill area
*
  110 IF(LOPICK)GOTO 1
      IADRF = IQ(LIDECO+IADRI)
      N     = IQ(LIDECO+IADRI+1)
      IP    = IGPKFA(XLOC,YLOC,N,Q(LFDECO+IADRF),Q(LFDECO+IADRF+N))
      IF(IP.NE.0)GOTO 500
      GOTO 1
*
*              Text (ITX)
*
  120 IF(LOPICK)GOTO 1
      ITAIND = 0
      TX_HGT = -99999.
      ITX_AL = -99999
      TX_WD  = 0.
  121 ITAIND = ITAIND + 1
      IF(ITAIND.EQ.9)THEN
* Could not locate all the text attributes !
         GOTO 1
      ENDIF

      IF( (INT(IQ(LNDECO+IREPTR-ITAIND)/1000000).EQ.ICHHCO)
     +    .AND.(TX_HGT.EQ.-99999.))
     +    TX_HGT = Q(LFDECO+ MOD(IQ(LNDECO+IREPTR-ITAIND),1000000))

      IF( (INT(IQ(LNDECO+IREPTR-ITAIND)/1000000).EQ.ITXACO)
     +    .AND.(ITX_AL.EQ.-99999))
     +    ITX_AL = MOD(IQ(LNDECO+IREPTR-ITAIND),100000)

      IF((ITX_AL.EQ.-99999).OR.(TX_HGT.EQ.-99999.))GOTO 121
      IADRC  = IQ(LIDECO+IADRI+1)
      ITX_CN = IQ(LIDECO+IADRI+2)
      CALL UHTOC(IQ(LCDECO+IADRC),4,TX_STR,ITX_CN)
      TX_STR = TX_STR(1:ITX_CN)
      TX_WD  = ITX_CN * TX_HGT
      XPOS   = Q(LFDECO+IQ(LIDECO+IADRI))
      YPOS   = Q(LFDECO+IQ(LIDECO+IADRI)+1)

      IF(ITX_AL.LT.20)XMIN = XPOS
      IF((ITX_AL.GE.20).AND.(ITX_AL.LT.30))XMIN = XPOS - (TX_WD/2.)
      IF(ITX_AL.GE.30)XMIN = XPOS - TX_WD
      ITX_AL = MOD(ITX_AL,10)
      IF(ITX_AL.EQ.0)YMIN = YPOS
      IF((ITX_AL.EQ.1).OR.(ITX_AL.EQ.2))YMIN = YPOS - TX_HGT
      IF(ITX_AL.EQ.3)YMIN = YPOS - (TX_HGT/2.)
      XMAX = XMIN + TX_WD
      YMAX = YMIN + TX_HGT
      I = IREPTR
  122 I = I - 1
      IF( (INT(IQ(LNDECO+I)/1000000).EQ.3).OR.(I.EQ.9))THEN
* Could not find angle attribute for a text primitive!
         GOTO 1
      ENDIF
      IF(INT(IQ(LNDECO+I)/1000000).NE.IANGCO)GOTO 122
      I        = MOD(IQ(LNDECO+I),1000000)
      TX_ANG   = Q(LFDECO+I)
      TX_PX(1) = XMIN
      TX_PY(1) = YMIN
      TX_PX(2) = XMAX
      TX_PY(2) = YMIN
      TX_PX(3) = XMAX
      TX_PY(3) = YMAX
      TX_PX(4) = XMIN
      TX_PY(4) = YMAX
      DO 123 I = 1,4
         TX_PX(I) = (-XPOS) + TX_PX(I)
         TX_PY(I) = (-YPOS) + TX_PY(I)
         XTEMP = COS(DEGRAD*TX_ANG) * TX_PX(I) + (-SIN(DEGRAD*TX_ANG))
     +           * TX_PY(I)
         YTEMP = SIN(DEGRAD*TX_ANG) * TX_PX(I) + COS(DEGRAD*TX_ANG) *
     +           TX_PY(I)
         TX_PY(I) = YTEMP
         TX_PX(I) = XTEMP
         TX_PY(I) = TX_PY(I) + YPOS
         TX_PX(I) = TX_PX(I) + XPOS
  123 CONTINUE
      IP = 0
      IP = IGPKFA(XLOC,YLOC,4,TX_PX(1),TX_PY(1))
      IF(IP.NE.0)THEN
         RQUEST(70) = TX_PX(1)
         RQUEST(71) = TX_PX(2)
         RQUEST(72) = TX_PX(3)
         RQUEST(73) = TX_PX(4)
         RQUEST(74) = TX_PY(1)
         RQUEST(75) = TX_PY(2)
         RQUEST(76) = TX_PY(3)
         RQUEST(77) = TX_PY(4)
         GOTO 500
      ENDIF
      GOTO 1
*
*              Boxe
*
  130 IF(LOPICK)GOTO 1
      IF(XLOC.GE.Q(LFDECO+IADRI)  .AND.
     +   XLOC.LE.Q(LFDECO+IADRI+1).AND.
     +   YLOC.GE.Q(LFDECO+IADRI+2).AND.
     +   YLOC.LE.Q(LFDECO+IADRI+3))GOTO 500
      GOTO 1
*
*              Frame box
*
  140 IF(LOPICK)GOTO 1
      IF( ((XLOC.GE.Q(LFDECO+IADRI))    .AND.
     +     (XLOC.LE.Q(LFDECO+IADRI+1))  .AND.
     +     (YLOC.GE.Q(LFDECO+IADRI+2))  .AND.
     +     (YLOC.LE.Q(LFDECO+IADRI+3))) .AND.

     +     ((XLOC.LE.Q(LFDECO+IADRI+4)) .OR.
     +     (XLOC.GE.Q(LFDECO+IADRI+5))  .OR.
     +     (YLOC.LE.Q(LFDECO+IADRI+6))  .OR.
     +     (YLOC.GE.Q(LFDECO+IADRI+7))) ) GOTO 500
      GOTO 1
*
*              Arc
*
  150 IF(LOPICK)GOTO 1
      SCALX  = XLOC - Q(LFDECO+IADRI)
      SCALY  = YLOC - Q(LFDECO+IADRI+1)
      PMAG   = SQRT(SCALX**2 + SCALY**2)
      ANGLOC = ACOS( SCALX / PMAG)
      ANGLOC = (180.0/PI)*ANGLOC
      IF(SCALY.LT.0.0)ANGLOC = 360. - ANGLOC

      IF((Q(LFDECO+IADRI+2).EQ.Q(LFDECO+IADRI+3)).AND.
     +(ABS(PMAG-Q(LFDECO+IADRI+2)).LT. 0.05))
     +PMAG = Q(LFDECO+IADRI+2)

      IF(((PMAG.GE.Q(LFDECO+IADRI+2)).AND.
     +    (PMAG.LE.Q(LFDECO+IADRI+3))).OR.
     +   ((PMAG.LE.Q(LFDECO+IADRI+2)).AND.
     +    (PMAG.GE.Q(LFDECO+IADRI+3))))THEN
         PHMIN = Q(LFDECO+IADRI+4)
         PHMAX = Q(LFDECO+IADRI+5)
         IF(PHMAX.GT.PHMIN)THEN
            IF( (ANGLOC.GE.PHMIN).AND.(ANGLOC.LE.PHMAX))GOTO 500
         ELSE
            IF(((ANGLOC.GE.0.).AND.(ANGLOC.LE.PHMAX)).OR.
     +         ((ANGLOC.LE.360.).AND.(ANGLOC.GT.PHMIN)))GOTO 500
         ENDIF
      ENDIF
      GOTO 1
*
*              Axis
*
  160 IF(LOPICK)GOTO 1
      IADRF=IQ(LIDECO+IADRI)
      IP=IGPKPL(XLOC,YLOC,2,Q(LFDECO+IADRF),Q(LFDECO+IADRF+2)
     +,         1.5*DX,1.5*DY)
      IF(IP.NE.0)GOTO 500
      GOTO 1
*
*              Software characters
*
  170 IF(LOPICK)GOTO 1
      IADRF=IQ(LIDECO+IADRI)
      IADRC  = IQ(LIDECO+IADRI+1)
      ITX_CN = IQ(LIDECO+IADRI+2)
      CALL UHTOC(IQ(LCDECO+IADRC),4,TX_STR,ITX_CN)
      TX_STR = TX_STR(1:ITX_CN)
      TX_HGT = Q(LFDECO+IADRF+2)
      TX_ANG = Q(LFDECO+IADRF+3)
      CALL IGTEXT(0.,0.,TX_STR,TX_HGT,TX_WD,'S')
      IGTOP = 1
      DO 171 I=1,3
         IF(JBIT(IQ(LIDECO+IADRI+3),I).NE.0)
     +   IGTOP = I
 171  CONTINUE

      IF(IGTOP.EQ.1)THEN
         ALOFF = 0.
      ELSEIF(IGTOP.EQ.2)THEN
         ALOFF = TX_WD / 2.
      ELSE
         ALOFF = TX_WD
      ENDIF
      XPOS = Q(LFDECO+IADRF)
      YPOS = Q(LFDECO+IADRF+1)
      TX_PY(1) = Q(LFDECO+IADRF+1)
      TX_PY(2) = Q(LFDECO+IADRF+1)
      TX_PY(3) = Q(LFDECO+IADRF+1)+TX_HGT
      TX_PY(4) = Q(LFDECO+IADRF+1)+TX_HGT
      TX_PX(1) = Q(LFDECO+IADRF) - ALOFF
      TX_PX(2) = Q(LFDECO+IADRF) + TX_WD - ALOFF
      TX_PX(3) = Q(LFDECO+IADRF) + TX_WD - ALOFF
      TX_PX(4) = Q(LFDECO+IADRF) - ALOFF
*
      DO 172 I = 1,4
         TX_PX(I) = (-XPOS) + TX_PX(I)
         TX_PY(I) = (-YPOS) + TX_PY(I)
         XTEMP = COS(DEGRAD*TX_ANG) * TX_PX(I) + (-SIN(DEGRAD*TX_ANG))
     +           * TX_PY(I)
         YTEMP = SIN(DEGRAD*TX_ANG) * TX_PX(I) + COS(DEGRAD*TX_ANG) *
     +           TX_PY(I)
         TX_PY(I) = YTEMP
         TX_PX(I) = XTEMP
         TX_PY(I) = TX_PY(I) + YPOS
         TX_PX(I) = TX_PX(I) + XPOS
 172  CONTINUE
      IP = 0
      IP = IGPKFA(XLOC,YLOC,4,TX_PX(1),TX_PY(1))
      IF(IP.NE.0)THEN
         RQUEST(70) = TX_PX(1)
         RQUEST(71) = TX_PX(2)
         RQUEST(72) = TX_PX(3)
         RQUEST(73) = TX_PX(4)
         RQUEST(74) = TX_PY(1)
         RQUEST(75) = TX_PY(2)
         RQUEST(76) = TX_PY(3)
         RQUEST(77) = TX_PY(4)
         GOTO 500
      ENDIF
      GOTO 1
*
*              Multiline
*
  180 IF(LOPICK)GOTO 1
      GOTO 1
*
*              Table
*
  200 IF(LOPICK)GOTO 1
      IF(XLOC.GE.Q(LFDECO+IAW)  .AND.
     +   XLOC.LE.Q(LFDECO+IAW+1).AND.
     +   YLOC.GE.Q(LFDECO+IAW+2).AND.
     +   YLOC.LE.Q(LFDECO+IAW+3))GOTO 500
      GOTO 1
*
*              Graph
*
  210 IF(LOPICK)GOTO 1
      IADRF  = IQ(LIDECO+IADRI)
      N      = IQ(LIDECO+IADRI+1)
      ICHOPT = IQ(LIDECO+IADRI+2)
      IF(JBIT(ICHOPT,12).NE.0)THEN
         IP = IGPKFA(XLOC,YLOC,N,Q(LFDECO+IADRF),Q(LFDECO+IADRF+N))
      ELSE
         IP = IGPKPL(XLOC,YLOC,N,Q(LFDECO+IADRF),Q(LFDECO+IADRF+N)
     +,              DX,DY)
      ENDIF
      IF(IP.NE.0)GOTO 500
      GOTO 1
*
*              Pave
*
  220 IF(LOPICK)GOTO 1
      IADRF = IQ(LIDECO+IADRI)
      IF(XLOC.GE.Q(LFDECO+IADRF)  .AND.
     +   XLOC.LE.Q(LFDECO+IADRF+1).AND.
     +   YLOC.GE.Q(LFDECO+IADRF+2).AND.
     +   YLOC.LE.Q(LFDECO+IADRF+3))GOTO 500
      GOTO 1
*
  500 LOPICK     = .TRUE.
      IQUEST(60) = IREPTR
      IQUEST(61) = INT(IQ(LNDECO+IREPTR)/1000000)
      IQUEST(62) = IADRI
      IQUEST(63) = IADRF
      IQUEST(64) = NBLEV
      RQUEST(80) = XLOC
      RQUEST(81) = YLOC
      GOTO 1
*
      END
+DECK,  IGPID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGPID(ILEVI,CHPID,IPID,CHOPT)
*.===========>
*.
*.  This routine allows to put primitives identifiers
*. in the HIGZ data structure.
*.
*. _Input parameters:
*.
*.  INTEGER ILEVI   : Level number
*.  CHARACTER CHPID : Primitives name
*.  INTEGER IPID    : Primitives identifier
*.  CHARACTER CHOPT : Option
*.                    CHOPT=' ' the level becomes LEVEL
*.                    CHOPT='U' one level Up
*.                    CHOPT='D' one level Down
*.                    CHOPT='S' Same level
*.
*..==========> (O.Couet)
+SELF, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=ZEBRA.
+CDE, HIFLAG.
+SELF, IF=ZEBRA.
+CDE, HIPICK.
+SELF, IF=ZEBRA.
      CHARACTER*(*) CHPID,CHOPT
      DIMENSION IOPT(3)
      EQUIVALENCE (IOPTU,IOPT(1)),(IOPTD,IOPT(2))
      EQUIVALENCE (IOPTS,IOPT(3))
*.______________________________________
*
      IF(.NOT.ZFLAG)RETURN
      CALL UOPTC(CHOPT,'UDS',IOPT)
*
      ILEV               = ILEVI
      IF(IOPTU.NE.0)ILEV = INBLEV-1
      IF(IOPTD.NE.0)ILEV = INBLEV+1
      IF(IOPTS.NE.0)ILEV = INBLEV
*
      IF(LPICT.LT.0)RETURN
      IF(ILEV.GT.INBLEV+1)THEN
         CALL IGERR('Invalid level number','IGPID')
         RETURN
      ENDIF
      INBLEV     = ILEV
      IQ(LHNT+5) = INBLEV
      ILEN       = MIN(LENOCC(CHPID),LEVLEN)
      IF(ILEN.GT.0)THEN
         IF(IZPUSH(3,0,LEVLEN/2,'IGPID').NE.0)RETURN
         CALL IZSTCC(IPICO1,INTPTR)
         IQ(LHI+INTPTR)   = ILEV
         IQ(LHI+INTPTR+1) = IPID
         IQ(LHI+INTPTR+2) = ISTPTR
         CALL IZINCI(3)
         CHLVL            = ' '
         CHLVL(1:ILEN)    = CHPID(1:ILEN)
         CALL UCTOH(CHLVL,IQ(LHC+ISTPTR),4,LEVLEN)
         CALL IZINCS(LEVLEN/2)
      ELSE
         IF(IZPUSH(2,0,0,'IGPID').NE.0)RETURN
         CALL IZSTCC(IPICO2,INTPTR)
         IQ(LHI+INTPTR)   = ILEV
         IQ(LHI+INTPTR+1) = IPID
         CALL IZINCI(2)
      ENDIF
+SELF.
*
      END
+DECK,  IGPIE, T=FORT.
* Revision 1.2  2001/05/31 07:33:59  couet
* - The variable TXT was too small (12). Now it is 32.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGPIE(X,Y,R,N,V,CHOPT,IAO,IAS,IAC)
*.===========>
*.
*.   To draw a PIE chart
*.
*..==========> (R.Nierhaus)
+CDE, HIATT.
+CDE, HILABS.
      DIMENSION V(1),IAO(1),IAS(1),IAC(1)
      CHARACTER*(*) CHOPT
      CHARACTER*12 TEXT
      CHARACTER*32 TXT
      DIMENSION PHI(51),JAS(50),IOPT(8)
      INTEGER SI
      EQUIVALENCE (IOPTO,IOPT(1)),(IOPTS,IOPT(2))
      EQUIVALENCE (IOPTC,IOPT(3)),(IOPTN,IOPT(4))
      EQUIVALENCE (IOPTP,IOPT(5)),(IOPTL,IOPT(6))
      EQUIVALENCE (IOPTH,IOPT(7)),(IOPTR,IOPT(8))
      DATA JAS/111,222,333,444,433,233,211,388,
     +         390,215,225,235,245,265,275,35*550/
*.______________________________________
*
      IF (N.LT.2.OR.N.GT.50) THEN
         CALL IGERR('Wrong number of values','IGPIE')
         RETURN
      ENDIF
      CALL UOPTC(CHOPT,'OSCNPLHR',IOPT)
      IF(IOPTS.EQ.0.AND.IOPTC.EQ.0)IOPTS=2
      IF(IOPTP.NE.0)IOPTN=0
      IF(IOPTL.NE.0)THEN
         IF(NHILAB.LT.N)THEN
            CALL IGERR('Not enough labels defined','IGPIE')
            IOPTL=0
         ENDIF
         IOPTN=0
         IOPTP=0
      ENDIF
      S=0.
      DO 10 I=1,N
         S=S+V(I)
   10 CONTINUE
      F=2.*3.14159/S
      PHI(1)=0.
      DO 70  I=1,N
         PHI(I+1)=PHI(I)+F*V(I)
         PHI1=.5*(PHI(I)+PHI(I+1))
         IF (IOPTS.EQ.1) THEN
            JIABS=IABS(IAS(I))
            IS=JIABS/1000-1
            SI=MOD(JIABS,1000)
            IF(IAS(I).LT.0)SI=-SI
            IF (IS.LT.0) THEN
               CALL ISFAIS(3)
            ELSE
               CALL ISFAIS(IS)
            ENDIF
            IF(SI.NE.0)CALL ISFASI(SI)
         ELSEIF(IOPTS.EQ.2)THEN
            CALL ISFAIS(3)
            CALL ISFASI(JAS(I))
         ENDIF
         IF (IOPTC.NE.0) THEN
            CALL ISFACI(IAC(I))
         ENDIF
         IF (IOPTO.NE.0) THEN
            IF (IAO(I).EQ.0) THEN
               ALPHA=(180./3.14159)*PHI(I)
               BETA =(180./3.14159)*PHI(I+1)
               CALL IGARC(X,Y,0.,R,ALPHA,BETA)
            ELSE
               XX=X+.01*FLOAT(IAO(I))*R*COS(PHI1)
               YY=Y+.01*FLOAT(IAO(I))*R*SIN(PHI1)
               ALPHA=(180./3.14159)*PHI(I)
               BETA =(180./3.14159)*PHI(I+1)
               CALL IGARC(XX,YY,0.,R,ALPHA,BETA)
            ENDIF
         ELSE
            ALPHA=(180./3.14159)*PHI(I)
            BETA =(180./3.14159)*PHI(I+1)
            CALL IGARC(X,Y,0.,R,ALPHA,BETA)
         ENDIF
*
         RR=R
         IF (IOPTO.NE.0) RR=R*(1.+.01*FLOAT(IAO(I)))
         IF(IOPTN.NE.0)THEN
            VAL=V(I)
            WRITE(TEXT,'(G12.6)')VAL
         ELSEIF(IOPTP.NE.0)THEN
            VAL=100.*V(I)/S+.0000001
            WRITE(TEXT,'(F5.1)')VAL
         ELSEIF(IOPTL.NE.0)THEN
            TXT=HILABS(I)
            GO TO 60
         ELSE
            GO TO 70
         ENDIF
         DO 20 J=1,12
            IF(TEXT(J:J).NE.' ')THEN
               I1=J
               GO TO 30
            ENDIF
   20    CONTINUE
         I1=12
   30    CONTINUE
         DO 40 J=12,I1,-1
            IF(TEXT(J:J).EQ.' '.OR.TEXT(J:J).EQ.'0')GO TO 40
            I2=J
            IF(TEXT(J:J).EQ.'.')I2=I2-1
            GO TO 50
   40    CONTINUE
   50    CONTINUE
         IF(I2.LT.I1)I2=I1
         TXT=TEXT(I1:I2)
   60    IF(IOPTH.NE.0)THEN
            H=RCHH
         ELSE
            H=R/15.
            IF(N.GT.10)H=H/2.
         ENDIF
         TS=0.
         CALL IGTEXT(0.,0.,TXT,H,TS,'S')
         IF(IOPTR.NE.0)THEN
            CALL IGSET('TANG',(ALPHA+BETA)/2.)
            CALL IGSET('TXAL',3.)
            XX=X+COS(PHI1)*(1.05*RR+0.5*H)
            YY=Y+SIN(PHI1)*(1.05*RR+0.5*H)
         ELSE
            CALL IGSET('TANG',0.)
            CALL IGSET('TXAL',20.)
            XX=X+COS(PHI1)*(1.05*RR+0.5*TS)
            YY=Y+SIN(PHI1)*(1.05*RR+0.5*H) -0.5*H
         ENDIF
         CALL IGSET('CHHE',H)
         CALL ITX(XX,YY,TXT)
   70 CONTINUE
*
      END
+DECK,  IGPKFA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      FUNCTION IGPKFA(XCUR,YCUR,N,XP,YP)
*.===========>
*.
*.   This function decides if a given fill area is picked or not .
*. If picked IGPKFA=1
*. If not picked IGPKFA=0
*.
*. _Input parameters:
*.
*.  REAL XCUR : X coordinate of the cursor
*.  REAL YCUR : Y coordinate of the cursor
*.  INTEGER N : Number of point in the fill area
*.  REAL XP(N) YP(N) : Fill area coordinates
*.
*..==========> (O.Couet)
+CDE, HIGRAF.
      DIMENSION XP(*),YP(*)
*.______________________________________
*
      IGPKFA=0
      NBI=0
*
      DO 10 I=2,N+1
         I2=I
         I1=I-1
         IF(I.EQ.N+1)I2=1
*
*              Line segment parallel to oy
*
         IF(XP(I1).EQ.XP(I2))THEN
            IF(YP(I1).LT.YP(I2))THEN
               YI=YP(I1)
               YIP=YP(I2)
            ELSE
               YI=YP(I2)
               YIP=YP(I1)
            ENDIF
            IF((YI.LT.YCUR).AND.(YCUR.LT.YIP))THEN
               NBI=NBI+1
               IF(NBI.GT.NPMAX)GOTO 70
               XGRAF(NBI)=XP(I1)
            ENDIF
            GOTO 10
         ENDIF
*
*              Line segment parallel to ox
*
         IF(YP(I1).EQ.YP(I2))THEN
            IF(YP(I1).EQ.YCUR)THEN
               NBI=NBI+1
               IF(NBI.GT.NPMAX)GOTO 70
               XGRAF(NBI)=XP(I1)
               NBI=NBI+1
               IF(NBI.GT.NPMAX)GOTO 70
               XGRAF(NBI)=XP(I2)
            ENDIF
            GOTO 10
         ENDIF
*
*              Other line segment
*
         A=(YP(I1)-YP(I2))/(XP(I1)-XP(I2))
         B=(YP(I2)*XP(I1)-XP(I2)*YP(I1))/(XP(I1)-XP(I2))
         IF(XP(I1).LT.XP(I2))THEN
            XI=XP(I1)
            XIP=XP(I2)
         ELSE
            XI=XP(I2)
            XIP=XP(I1)
         ENDIF
         XIN=(YCUR-B)/A
         IF((XI.LT.XIN).AND.(XIN.LT.XIP))THEN
            NBI=NBI+1
            IF(NBI.GT.NPMAX)GOTO 70
            XGRAF(NBI)=XIN
         ENDIF
   10 CONTINUE
*
*              Sorting of the x coordinates intersections
*
      INV=0
      M=NBI-1
   20 CONTINUE
      DO 30 I=1,M
         IF(XGRAF(I+1).LT.XGRAF(I))THEN
            INV=INV+1
            RLL=XGRAF(I)
            XGRAF(I)=XGRAF(I+1)
            XGRAF(I+1)=RLL
         ENDIF
   30 CONTINUE
      M=M-1
      IF(INV.EQ.0)GOTO 40
      INV=0
      GOTO 20
*
*              Place of the x cursor coordinates
*
   40 NB=0
      DO 50 I=1,NBI
         IF(XCUR.LT.XGRAF(I))GOTO 60
         NB=NB+1
   50 CONTINUE
   60 IF(MOD(NB,2).NE.0)THEN
         IGPKFA=1
      ENDIF
      GOTO 999
*
   70 CALL IGERR('Too many points','IGPKFA')
*
  999 END
+DECK,  IGPKPL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      FUNCTION IGPKPL (XCUR,YCUR,N,XP,YP,DX,DY)
*.===========>
*.
*.   This routine decides if a given polyline is picked or not .
*. If picked IGPKPL=1
*. If not picked IGPKPL=0
*.
*. _Input parameters:
*.
*.  REAL XCUR : X coordinate of the cursor
*.  REAL YCUR : Y coordinate of the cursor
*.  INTEGER N : Number of point in the polyline
*.  REAL XP(N) YP(N) : Polyline coordinates
*.  REAL DX DY : Picking box. If a point is inside
*.               this box, it is picked
*.
*..==========> (O.Couet)
      DIMENSION XP(*),YP(*)
*.______________________________________
*
      NM=N-1
      IGPKPL=0
      BM=YCUR-DY
      BP=YCUR+DY
      AM=XCUR-DX
      AP=XCUR+DX
      DO 10 I=1,NM
         I1=I
         I2=I+1
*
*              Line segment parallel to oy
*
         IF(XP(I1).EQ.XP(I2))THEN
            IF((AM.LE.XP(I1)).AND.(XP(I2).LE.AP))THEN
               IF(YP(I1).LE.YP(I2))THEN
                  YI=YP(I1)
                  YIP=YP(I2)
               ELSE
                  YI=YP(I2)
                  YIP=YP(I1)
               ENDIF
               IF((YI.LE.YCUR).AND.(YCUR.LE.YIP))THEN
                  IGPKPL=1
                  RETURN
               ENDIF
            ENDIF
            GOTO 10
         ENDIF
*
*              Line segment paralel to ox
*
         IF(YP(I1).EQ.YP(I2))THEN
            IF((BM.LE.YP(I1)).AND.(YP(I1).LE.BP))THEN
               IF(XP(I1).LE.XP(I2))THEN
                  XI=XP(I1)
                  XIP=XP(I2)
               ELSE
                  XI=XP(I2)
                  XIP=XP(I1)
               ENDIF
               IF((XI.LE.XCUR).AND.(XCUR.LE.XIP))THEN
                  IGPKPL=1
                  RETURN
               ENDIF
            ENDIF
            GOTO 10
         ENDIF
*
*              Other line segment
*
         A=(YP(I1)-YP(I2))/(XP(I1)-XP(I2))
         B=(YP(I2)*XP(I1)-XP(I2)*YP(I1))/(XP(I1)-XP(I2))
         IF(XP(I1).LE.XP(I2))THEN
            XI=XP(I1)
            XIP=XP(I2)
         ELSE
            XI=XP(I2)
            XIP=XP(I1)
         ENDIF
         IF((XI.LE.XCUR).AND.(XCUR.LE.XIP))THEN
            AA=A*XCUR+B
            IF((BM.LE.AA).AND.(AA.LE.BP))THEN
               IGPKPL=1
               RETURN
            ENDIF
         ENDIF
         IF(YP(I1).LE.YP(I2))THEN
            YI=YP(I1)
            YIP=YP(I2)
         ELSE
            YI=YP(I2)
            YIP=YP(I1)
         ENDIF
         IF((YI.LE.YCUR).AND.(YCUR.LE.YIP))THEN
            BB=(YCUR-B)/A
            IF((AM.LE.BB).AND.(BB.LE.AP))THEN
               IGPKPL=1
               RETURN
            ENDIF
         ENDIF
   10 CONTINUE
*
      END
+DECK,  IGPKPM, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      FUNCTION IGPKPM(XCUR,YCUR,N,XP,YP,DX,DY)
*.===========>
*.
*.   This function decides if a given polymarker is picked or not .
*. If picked IGPKPM=The picked point adress
*. If not picked IGPKPM=0
*.
*. _Input parameters:
*.
*.  REAL XCUR : X coordinate of the cursor
*.  REAL YCUR : Y coordinate of the cursor
*.  INTEGER N : Number of point in the polymarker
*.  REAL XP(N) YP(N) : Polymarker coordinates
*.  REAL DX DY : Picking box. If a point is inside
*.               this box, it is picked
*.
*..==========> (O.Couet)
      DIMENSION XP(*),YP(*)
*.______________________________________
*
      IGPKPM=0
*
      DO 10 I=1,N
         IF((ABS(XP(I)-XCUR).LE.DX).AND.(ABS(YP(I)-YCUR).LE.DY))THEN
            IGPKPM=I
            RETURN
         ENDIF
   10 CONTINUE
*
      END
+DECK,  IGPM, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGPM(N,X,Y,ITYPE)
*.===========>
*.
*.   This routines draws markers 20 to 31.
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of markers .
*.  REAL X(N) : Markers X coordinates .
*.  REAL Y(N) : Markers Y coordinates .
*.  INTEGER ITYPE : Markers type.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*)
      LOGICAL ZFSAV,PFSAV
      CHARACTER*3 CHARS(12)
      REAL MKSIZE
      DATA CHARS/'"0 ','"1 ','"2 ','"3 ','"<0','"<1','"<2','"<3',
     +           '"C ','"4 ','"<4','"<*'/
*.______________________________________
*
      IF(ITYPE.LT.20.OR.ITYPE.GT.31)RETURN
      ZFSAV = ZFLAG
      ZFLAG = .FALSE.
      PFSAV = PFLAG
      IF(.NOT.TFLAG)PFLAG=.FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
      NTSAV  = INTR
      IPS    = INPASS
      INPASS = 1
      ITXCIS = ITXCI
      CALL ISTXCI(IPMCI)
      MKSIZE = RMKSC*0.009
      SF     = MKSIZE/2.
      DO 10 I=1,N
         IF(X(I).GT.RWXMAX.OR.X(I).LT.RWXMIN.OR.
     +      Y(I).GT.RWYMAX.OR.Y(I).LT.RWYMIN)GOTO 10
         XV = (((RVXMAX-RVXMIN)*(X(I)-RWXMIN))/(RWXMAX-RWXMIN))+RVXMIN
         YV = (((RVYMAX-RVYMIN)*(Y(I)-RWYMIN))/(RWYMAX-RWYMIN))+RVYMIN
         YV = YV-SF
         CALL ISELNT(0)
         CALL IGTEXT(XV,YV,CHARS(ITYPE-19),MKSIZE,0.,'C')
         CALL ISELNT(NTSAV)
   10 CONTINUE
      CALL ISTXCI(ITXCIS)
      INPASS = IPS
      ZFLAG  = ZFSAV
      PFLAG  = PFSAV
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGPXMP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGPXMP(IPX,IX,IY,CHOPT)
*.==============>
*.
*.   X11 Pixmap manipulation.
*.
*. _Input parameters:
*.
*.  INTEGER IPX : Pixmap identifier (input or output see CHOPT).
*.  INTEGER IX,IY : Pixmap size or position (see CHOPT).
*.  CHARACTER CHOPT : Character option.
*.            CHOPT='O' Open pixmap. IPX is an output parameter
*.                      IX is the width and IY the height.
*.            CHOPT='R' Remove pixmap. IPX is an input parameter.
*.            CHOPT='D' Display pixmap. (IX,IY) is the position
*.                      where the pixpmap has to be displayed.
*.                      IPX is an input parameter.
*.            CHOPT='C' Close the current opened pixmap.
*.            CHOPT='S' Save the region of the current window at
*.                      the position (IX,IY) in preopen pixmap IPX.
*.            CHOPT='E' Erase (clear) the pixmap IPX.
*.            CHOPT='W' Write the pixmap IPX into the file 'higz.bm'.
*.                      IX is the width and IY the height. IPX is an
*.                      input parameter.
*.
*.============> (O.Couet)
+SELF, IF=X11.
      DIMENSION IOPT(7)
      EQUIVALENCE (IOPTO,IOPT(1)),(IOPTR,IOPT(2))
      EQUIVALENCE (IOPTD,IOPT(3)),(IOPTC,IOPT(4))
      EQUIVALENCE (IOPTS,IOPT(5)),(IOPTE,IOPT(6))
      EQUIVALENCE (IOPTW,IOPT(7))
      CHARACTER*(*) CHOPT
*.______________________________________
*
      CALL UOPTC(CHOPT,'ORDCSEW',IOPT)
*
      IF (IOPTO.NE.0) IPX=IXOPNPX(IX,IY)
      IF (IOPTC.NE.0) CALL IXCLPX
      IF (IOPTS.NE.0) CALL IXWIPX(IPX,IX,IY)
      IF (IOPTD.NE.0) CALL IXCPPX(IPX,IX,IY)
      IF (IOPTR.NE.0) CALL IXRMPX(IPX)
      IF (IOPTE.NE.0) CALL IXCLRPX(IPX)
      IF (IOPTW.NE.0) CALL IXWRPX(IPX,IX,IY,7,'higz.bm')
+SELF.
*
      END
+DECK,  IGQ, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGQ(PNAME,RVAL)
*.===========>
*.
*.   This routine inquire the primitive attribute PNAME to the value VAL .
*.
*. _Input parameters:
*.
*.  CHARACTER PNAME : Parameter name .
*.
*.   PNAME='FAIS' RVAL=Fill Area Interior Style (0,1,2,3)
*.   PNAME='FASI' RVAL=Fill Area Style Index
*.   PNAME='LTYP' RVAL=Line TYPe
*.   PNAME='BASL' RVAL=BAsic Segment Length
*.   PNAME='LWID' RVAL=Line WIDth
*.   PNAME='MTYP' RVAL=Marker TYPe
*.   PNAME='MSCF' RVAL=Marker SCale Factor
*.   PNAME='PLCI' RVAL=PolyLine Color Index
*.   PNAME='PMCI' RVAL=PolyMarker Color Index
*.   PNAME='FACI' RVAL=Fill Area Color Index
*.   PNAME='TXCI' RVAL=TeXt Color Index
*.   PNAME='TXAL' RVAL(1)=Alignment horizontal
*.                RVAL(2)=Alignment vertical
*.   PNAME='CHHE' RVAL=CHaracter HEight)
*.   PNAME='TANG' RVAL=Text ANGle
*.   PNAME='TXFP' RVAL(1)=TeXt Font
*.                RVAL(2)=TeXt Precision
*.   PNAME='TMSI' RVAL=Tick Marks SIze (in WC)
*.   PNAME='LASI' RVAL=LAbels SIze (in WC)
*.   PNAME='LAOF' RVAL=LAbels OFfset
*.   PNAME='PASS' RVAL=IGTEXT Width
*.   PNAME='CSHI' RVAL=IGTEXT Shift
*.   PNAME='BORD' RVAL=Border for IGBOX, IGFBOX and IGARC (0=No , 1=Yes)
*.   PNAME='BARO' RVAL=IGHIST or IGRAPH BAR charts Offset (%)
*.   PNAME='BARW' RVAL=IGHIST or IGRAPH BAR charts Width (%)
*.   PNAME='AWLN' RVAL=Axis Wire LeNght
*.   PNAME='DIME' RVAL=2D or 3D
*.   PNAME='NCOL' RVAL=Number of entry in the COLor map.
*.   PNAME='RGB ' RVAL=R G B values
*.   PNAME='CLIP' RVAL=Clipping mode: 1.=on 0.=off
*.
*. _Output parameters:
*.
*.  REAL RVAL : Parameter value .
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HILUT.
+SELF, IF=GL.
+CDE, HIKERN.
+SELF.
      CHARACTER*(*) PNAME
      DIMENSION RVAL(*)
+SELF, IF=GL.
      INTEGER*2 IR,IG,IB
+SELF.
*.______________________________________
*
      IF(PNAME(1:4).EQ.'FAIS')THEN
         RVAL(1)=FLOAT(IFAIS)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'FASI')THEN
         RVAL(1)=FLOAT(IFASI)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LTYP')THEN
         RVAL(1)=FLOAT(ILN)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BASL')THEN
         RVAL(1)=RBSL
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LWID')THEN
         RVAL(1)=RLWSC
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'MTYP')THEN
         RVAL(1)=IMK
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'MSCF')THEN
         RVAL(1)=RMKSC
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'PLCI')THEN
         RVAL(1)=FLOAT(IPLCI)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'PMCI')THEN
         RVAL(1)=FLOAT(IPMCI)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'FACI')THEN
         RVAL(1)=FLOAT(IFACI)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TXCI')THEN
         RVAL(1)=FLOAT(ITXCI)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TXAL')THEN
         RVAL(1)=FLOAT(ITXALH)
         RVAL(2)=FLOAT(ITXALV)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'CHHE')THEN
         RVAL(1)=RCHH
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TANG')THEN
         RVAL(1)=RANGLE
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TXFP')THEN
         RVAL(1)=FLOAT(IFONT)
         RVAL(2)=FLOAT(IPREC)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TMSI')THEN
         RVAL(1)=RTMS
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LASI')THEN
         RVAL(1)=RALH
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LAOF')THEN
         RVAL(1)=RALD
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'PASS')THEN
         RVAL(1)=FLOAT(INPASS)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'CSHI')THEN
         RVAL(1)=RCSHIF
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BORD')THEN
         RVAL(1)=FLOAT(IBORD)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BARO')THEN
         RVAL(1)=RBOF
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BARW')THEN
         RVAL(1)=RBWD
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'AWLN')THEN
         RVAL(1)=RAWL
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'DIME')THEN
         RVAL(1)=FLOAT(IDIM)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'NCOL')THEN
         RVAL(1)=FLOAT(INBCOL)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'RGB ')THEN
         I=RVAL(1)+1
         IF(I.LE.NBCLUT)THEN
            RVAL(2)=REDLUT(I)
            RVAL(3)=GRNLUT(I)
            RVAL(4)=BLULUT(I)
         ELSE
            RVAL(2)=1.
            RVAL(3)=1.
            RVAL(4)=1.
         ENDIF
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'CLIP')THEN
         RVAL(1)=FLOAT(ICLIP)
         RETURN
      ENDIF
      CALL IGERR('Unavailable option','IGQ')
*
      END
+DECK,  IGQWK, T=FORT.
* Revision 1.3  1998/01/28 14:34:22  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:20  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:37  mclareni
* Higz

      SUBROUTINE IGQWK(IWKID,PNAME,RVAL)
*.===========>
*.
*.   This routine returns in VAL the values of the parameters
*. asked in PNAME.
*.
*. _Input parameters:
*.
*.  INTEGER IWKID   : Workstation identifier.
*.  CHARACTER PNAME : Parameter name .
*.
*. _Output parameters:
*.
*.  REAL RVAL : Parameter value .
*.
*. +-------+---------------------------------------+-------------+
*. | PNAME |            RVAL Description           | RVAL Lenght |
*. +-------+---------------------------------------+-------------+
*. |'MXDS' |  Maximal display surface (XMAX YMAX)  |      2      |
*. +-------+---------------------------------------+-------------+
*. |'NTNB' |  Current NT number (NT)               |      1      |
*. +-------+---------------------------------------+-------------+
*. |'NTWN' |  Current window parameter             |      4      |
*. +-------+---------------------------------------+-------------+
*. |'NTVP' |  Current viewport parameter           |      4      |
*. +-------+---------------------------------------+-------------+
*. |'DVOL' |  Display volume in 3D  (obsolete)     |      3      |
*. +-------+---------------------------------------+-------------+
*. |'ACTI' |  1. if IWKID is active 0. if not      |      1      |
*. +-------+---------------------------------------+-------------+
*. |'OPEN' |  1. if IWKID is open 0. if not        |      1      |
*. +-------+---------------------------------------+-------------+
*. |'NBWK' |  Number and list of open workstations |     11      |
*. +-------+---------------------------------------+-------------+
*. |'2BUF' |  Double buffer value (X11 only)       |      1      |
*. +-------+---------------------------------------+-------------+
*. |'HWCO' |  Number of COlours suported by the    |      1      |
*. |       |  HardWare. If 2 it is a B&W screen.   |             |
*. +-------+---------------------------------------+-------------+
*. |'WIID' |  Return the window identifier associa-|      1      |
*. |       |  -ted to the workstation ID IWKID.    |             |
*. +-------+---------------------------------------+-------------+
*.
*..==========> (O.Couet)
+SELF, IF=KERNEL.
+CDE, HIKERN.
+SELF, IF=KERNEL,FALCO.
+CDE, HIQUES.
+SELF, IF=PSCRIPT.
+CDE, HIPOST.
+SELF.
+CDE, HIATT.
+SELF, IF=MSDOS.
+CDE, HIMETA.
+SELF.
      CHARACTER*(*) PNAME
      DIMENSION RVAL(*)
+SELF, IF=DECGKS.
      REAL*4 RDUMMY(4),VIEW(4)
+SELF.
*.______________________________________
*
      IF(PNAME(1:4).EQ.'MXDS')THEN
+SELF, IF=KERNEL,BATCH.
         RMDSX=1.
         RMDSY=1.
+SELF, IF=KERNEL,FALCO.
         IF(INOPWK.EQ.0)RETURN
         I=IGIWIN(IWKID)
         IF(I.EQ.0)THEN
            IQUEST(1)=1
            GOTO 20
         ENDIF
         IDTY=IGIWTY(IWKID)
+SELF, IF=PSCRIPT.
         IF(IDTY.LT.0)THEN
            IF(LOPRNG)THEN
               RVAL(1)=XPSR
               RVAL(2)=YPSR
            ELSE
               RVAL(1)=XWKSIZ(IPSI)
               RVAL(2)=YWKSIZ(IPSI)
            ENDIF
            RETURN
         ENDIF
+SELF, IF=GL, IF=-MSDOS.
         CALL IGSG(I)
         CALL GETORI(IQUEST(10),IQUEST(11))
         CALL GETSIZ(IXX,IYY)
         CALL RESHAP
         CALL ORTHO2(0.,FLOAT(IXX-1),0.,FLOAT(IYY-1))
         XWKSIZ(I)=FLOAT(IXX)
         YWKSIZ(I)=FLOAT(IYY)
+SELF, IF=MSDOS.
         CALL IGSG(I)
         IF(ILOPWK(I).NE.IDMETA)THEN
         ELSE
            XWKSIZ(I)=10000.0
            YWKSIZ(I)=10000.0
         ENDIF
+SELF, IF=FALCO.
         ITY = IGIWTY(IWKID)
         IF(ITY.EQ.7878.OR.ITY.EQ.7879)THEN
            IQUEST(10) = 128000
            XWKSIZ(I)  = 128000.
            IF(ITY.EQ.7878)THEN
               IQUEST(11) = 100000
               YWKSIZ(I)  = 100000.
            ELSE
               IQUEST(11) = 101120
               YWKSIZ(I)  = 101120.
            ENDIF
            GOTO 10
         ENDIF
+SELF, IF=X11.
         CALL IXGETGE(IWINID(I),WINSIZ(1),WINSIZ(2),WINSIZ(3),WINSIZ(4))
         IQUEST(10)=WINSIZ(1)
         IQUEST(11)=WINSIZ(2)
         XWKSIZ(I)=FLOAT(WINSIZ(3))
         YWKSIZ(I)=FLOAT(WINSIZ(4))
+SELF, IF=MACMPW.
         CALL IMGETGE(IWINID(I),WINSIZ(1),WINSIZ(2),WINSIZ(3),WINSIZ(4))
         IQUEST(10)=WINSIZ(1)
         IQUEST(11)=WINSIZ(2)
         XWKSIZ(I)=FLOAT(WINSIZ(3))
         YWKSIZ(I)=FLOAT(WINSIZ(4))
+SELF, IF=PHIGS.
         CALL PQDSP(IGIWTY(IWKID),IERR,IDC,RMDSX,RMDSY,ILX,ILY)
+SELF, IF=KERNEL,FALCO.
   10    CONTINUE
         RMDSX=XWKSIZ(I)
         RMDSY=YWKSIZ(I)
         WKMAX(I)=MAX(RMDSX,RMDSY)
         CALL IGSRAP(REDIT)
   20    CONTINUE
+SELF, IF=MGKS,PLOT10GKS,UNIGKS.
         IERR=0
         CALL GQMDS(IGIWTY(IWKID),IERR,IDC,RMDSX,RMDSY,ILX,ILY)
+SELF, IF=GKSGRAL,ATCGKS,GKSBX.
         CALL GQDSP(IGIWTY(IWKID),IERR,IDC,RMDSX,RMDSY,ILX,ILY)
+SELF, IF=DECGKS.
         IF(MOD(IGIWTY(IWKID),256).LT.200)THEN
            CALL GQDSP(IGIWTY(IWKID),IERR,IDC,RMDSX,RMDSY,ILX,ILY)
         ELSE
            CALL GQWKT(1,IERR,ISTATE,RDUMMY,RDUMMY,VIEW,RDUMMY)
            RMDSX=VIEW(2)-VIEW(1)
            RMDSY=VIEW(4)-VIEW(3)
         ENDIF
+SELF, IF=UNIGKS.
         IF (IERR.EQ.31) THEN
            RMDSX=1.
            RMDSY=1.
         ENDIF
+SELF.
         RVAL(1)=RMDSX
         RVAL(2)=RMDSY
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'NTNB')THEN
         RVAL(1)=FLOAT(INTR)
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'NTWN')THEN
         RVAL(1)=RWXMIN
         RVAL(2)=RWXMAX
         RVAL(3)=RWYMIN
         RVAL(4)=RWYMAX
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'NTVP')THEN
         RVAL(1)=RVXMIN
         RVAL(2)=RVXMAX
         RVAL(3)=RVYMIN
         RVAL(4)=RVYMAX
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'DVOL')THEN
         CALL IGERR('Obsolete option','IGQWK')
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'ACTI')THEN
         RVAL(1)=0.
         DO 30 I=1,INOPWK
            IF(IWKID.EQ.ILOPWK(I))THEN
               IF(ACWKFL(I))RVAL(1)=1.
               RETURN
            ENDIF
   30    CONTINUE
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'OPEN')THEN
         RVAL(1)=0.
         DO 40 I=1,INOPWK
            IF(IWKID.EQ.ILOPWK(I))THEN
               RVAL(1)=1.
               RETURN
            ENDIF
   40    CONTINUE
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'NBWK')THEN
         RVAL(1)=FLOAT(INOPWK)
         DO 50 I=1,INOPWK
            RVAL(I+1)=FLOAT(ILOPWK(I))
   50    CONTINUE
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'2BUF')THEN
+SELF, IF=X11.
         IWIN=IWINID(IGIWIN(IWKID))
         IVAL=IXQ2BUF(IWIN)
         RVAL(1)=FLOAT(IVAL)
+SELF, IF=-X11.
         RVAL(1)=0.
+SELF.
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'HWCO')THEN
         RVAL(1) = 8.
+SELF, IF=FALCO.
         ITY     = IGIWTY(IWKID)
         IF(ITY.EQ.7878.OR.ITY.EQ.7879)THEN
            RVAL(1) = 2.
            RETURN
         ENDIF
+SELF, IF=X11.
         CALL IXGETPL(NPLAN)
         RVAL(1) = 2.**FLOAT(NPLAN)
+SELF.
         RETURN
      ENDIF
*
      IF(PNAME(1:4).EQ.'WIID')THEN
         RVAL(1) = FLOAT(IWINID(IGIWIN(IWKID)))
         RETURN
      ENDIF
*
      CALL IGERR('Unavailable option','IGQWK')
*
      END
+DECK,  IGRAP1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

      SUBROUTINE IGRAP1(X,Y,N,IITYP)
*.===========>
*.
*.   Underlaying routine for IGHIST  Based on the CERN GD3 routine TVIPTE
*.
*.     Author - Marlow etc.   Modified by - P. Ward     Date -  3.10.1973
*.
*.   This routine draws a smooth tangentially continuous curve through
*. the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I))
*. the curve is approximated by a polygonal arc of short vectors .
*. the data points can represent open curves, P(1).NE.P(N) or closed
*. curves P(2).EQ.P(N) . If a tangential discontinuity at P(I) is
*. required , then set P(I)=P(I+1) . loops are also allowed .
*.
*. Reference Marlow and Powell,Harwell report No.R.7092.1972
*. MCCONALOGUE,Computer Journal VOL.13,NO4,NOV1970PP392 6
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of data points.
*.  REAL X(N) : Abscissa
*.  REAL Y(N) : Ordinate
*.
*.
*. XDELT is the accuracy required in constructing the curve.
*. if it is zero then the routine calculates a value other-
*. wise it uses this value. (default is 0.0)
*.
*.     JIPTE=0   No coordinate transformation
*.          =1   Transformation for graph in  X  direction
*.          =2   Transformation for graph in  Y  direction
*.          =3   Transformation for contour plotting  (make square)
*.     KIPTE .LT. 0  Set JIPTE as GD3 routines wish
*.           .GE. 0  Set JIPTE=KIPTE  (set by user)
*.
*. ITYP has different value according to CHOPT in IGHIST:
*.
*.     CHOPT='S'     ITYP=1
*.     CHOPT='SA'    ITYP=2
*.     CHOPT='SA1'   ITYP=3
*.     CHOPT='RS'    ITYP=11
*.     CHOPT='RSA'   ITYP=12
*.     CHOPT='RSA1'  ITYP=13
*.
*..==========>
+CDE, HIPAW.
+CDE, HIATT.
      DIMENSION X(N),Y(N)
      LOGICAL FLGIC,FLGIS,LOPTX
      EQUIVALENCE (LX,LSTACK(9)),(LY,LSTACK(10))
*.______________________________________
*
      NPMAX  = N*10
      N2     = NPMAX-2
      IBKSIZ = N2
      CALL MZNEED(IXHIGZ,2*NPMAX+25,'G')
      IF (IQUEST(11).LT.0) THEN
         CALL IGERR('IGRAP1','Not enough space in memory')
         RETURN
      ENDIF
      IF(LX.NE.0)CALL MZDROP(IXHIGZ,LX,' ')
      IF(LY.NE.0)CALL MZDROP(IXHIGZ,LY,' ')
      CALL MZBOOK(IXHIGZ,LX,LX,1,'TMPX',0,0,NPMAX,3,0)
      CALL MZBOOK(IXHIGZ,LY,LY,1,'TMPY',0,0,NPMAX,3,0)
*
*     Decode the type of curve according to
*     CHOPT of IGHIST.
*     ('S', 'SA', 'SA1' ,'XS', 'XSA', or 'XSA1')
*
      ITYP  = IITYP
      IF(ITYP.GE.1000)ITYP=ITYP-1000
      LOPTX = .FALSE.
      JTYP  = ITYP-10
      IF(JTYP.GT.0)THEN
         KTYP  = JTYP
         LOPTX = .TRUE.
      ELSE
         KTYP = ITYP
      ENDIF
      IF(KTYP.EQ.3)THEN
         XORG = RWXMIN
         YORG = RWYMIN
      ELSE
         XORG = MAX(0.,RWXMIN)
         YORG = MAX(0.,RWYMIN)
      ENDIF
*
      MAXIT = 20
      DELT  = 0.00055
*
*          Scale data to the range 0-RATSIG in X, 0-1 in Y
*          where RATSIG is the ratio between the number of changes
*          of sign in Y divided by the number of changes of sign in X
*
      SXMIN = X(1)
      SXMAX = X(1)
      SYMIN = Y(1)
      SYMAX = Y(1)
      SIX   = 1.
      SIY   = 1.
      DO 10 I=2,N
         IF(I.GT.2)THEN
            IF((X(I)-X(I-1))*(X(I-1)-X(I-2)).LT.0.)SIX=SIX+1.
            IF((Y(I)-Y(I-1))*(Y(I-1)-Y(I-2)).LT.0.)SIY=SIY+1.
         ENDIF
         IF(X(I).LT.SXMIN)SXMIN=X(I)
         IF(X(I).GT.SXMAX)SXMAX=X(I)
         IF(Y(I).LT.SYMIN)SYMIN=Y(I)
         IF(Y(I).GT.SYMAX)SYMAX=Y(I)
   10 CONTINUE
      ICLOSE = 0
      DX1N   = ABS(X(N)-X(1))
      DY1N   = ABS(Y(N)-Y(1))
      CLO    = 0.01
      IF(DX1N.LT.CLO*(SXMAX-SXMIN).AND.DY1N.LT.CLO*(SYMAX-SYMIN))
     +        ICLOSE = 1
      IF(SXMIN.EQ.SXMAX)THEN
         XRAT = 1.
      ELSE
         IF(SIX.GT.1.)THEN
            RATSIG = SIY/SIX
         ELSE
            RATSIG = 20.
         ENDIF
         XRAT = RATSIG/(SXMAX-SXMIN)
      ENDIF
      IF(SYMIN.EQ.SYMAX)THEN
         YRAT = 1.
      ELSE
         YRAT = 1./(SYMAX-SYMIN)
      ENDIF
*
      Q(LX+1) = X(1)
      Q(LY+1) = Y(1)
      DO 20 I=1,N
         X(I) = (X(I)-SXMIN)*XRAT
         Y(I) = (Y(I)-SYMIN)*YRAT
   20 CONTINUE
*
*              IFIN is minus one if we must draw a straight line from P(K-1)
*              to P(K). IFIN is one if the last call to IPL has .LT. N2
*              points. IFIN is zero otherwise. NPT counts the X and Y
*              coordinates in work . When NPT=N2 a call to IPL is made.
*
      IFIN = 0
      NPT  = 1
      K    = 1
*
*              Convert coordinates back to original system
*
*
*              Separate the set of data points into arcs P(K-1),P(K).
*              Calculate the direction cosines. first consider whether
*              there is a continuous tangent at the endpoints.
*
      IF(ICLOSE.NE.0)GO TO 30
      IF(X(1).NE.X(N).OR.Y(1).NE.Y(N))GOTO 40
      IF(X(N-1).EQ.X(N).AND.Y(N-1).EQ.Y(N))GOTO 40
      IF(X(1).EQ.X(2).AND.Y(1).EQ.Y(2))GOTO 40
   30 FLGIC = .FALSE.
      FLGIS = .TRUE.
*
*              FLGIC is true if the curve is open and false if it is closed.
*              FLGIS is true in the main loop, but is false if there is
*              a deviation from the main loop.
*
      KM=N-1
*
*              Calculate direction cosines at P(1) using P(N-1),P(1),P(2).
*
      GOTO 100
   40 FLGIC = .TRUE.
      FLGIS = .FALSE.
*
*              Skip excessive consecutive equal points.
*
   50 IF(K.GE.N)GOTO 380
      K=K+1
      IF(X(K).EQ.X(K-1).AND.Y(K).EQ.Y(K-1))GOTO 50
   60 KM=K-1
      IF(K-N)90,70,380
   70 IF(FLGIC)GOTO 80
*
*              Calculate direction cosines at P(n) using P(N-1),P(N),P(2).
*
      KP=2
      GOTO 130
   80 IF(FLGIS)GOTO 150
*
*              Draw a straight line from P(K-1) to P(K).
*
      IFIN=-1
      GOTO 170
*
*              Test whether P(K) is a cusp.
*
   90 IF(X(K).EQ.X(K+1).AND.Y(K).EQ.Y(K+1))GOTO 80
  100 KP=K+1
      GOTO 130
*
*              Branch if the next section of the curve begins at a cusp.
*
  110 IF(.NOT.FLGIS)GOTO 50
*
*              Carry forward the direction cosines from the previous arc.
*
  120 CO=CT
      SO=ST
      K=K+1
      GOTO 60
*
*              Calculate the direction cosines at P(K).  If K=1 then
*              N-1 is used for K-1. If K=N then 2 is used for K+1.
*              direction cosines at P(K) obtained from P(K-1),P(K),P(K+1).
*
  130 DX1 = X(K)-X(KM)
      DY1 = Y(K)-Y(KM)
      DK1 = DX1**2+DY1**2
      DX2 = X(KP)-X(K)
      DY2 = Y(KP)-Y(K)
      DK2 = DX2**2+DY2**2
      CTU = DX1*DK2+DX2*DK1
      STU = DY1*DK2+DY2*DK1
      XNT = CTU**2+STU**2
      IF(XNT.GT.1.E-25)GOTO 140
*
*              If both ctu and stu are zero,then default.This can
*              occur when P(K)=P(K+1). I.E. A loop.
*
      CTU = DY1
      STU =-DX1
      XNT = DK1
*
*              Normalise direction cosines.
*
  140 CT = CTU/SQRT(XNT)
      ST = STU/SQRT(XNT)
      IF(FLGIS)GOTO 160
*
*              Direction cosines at P(K-1) obtained from P(K-1),P(K),P(K+1).
*
      W3    = 2.*(DX1*DY2-DX2*DY1)
      CO    = CTU+W3*DY1
      SO    = STU-W3*DX1
      XNT   = 1./SQRT(CO**2+SO**2)
      CO    = CO*XNT
      SO    = SO*XNT
      FLGIS = .TRUE.
      GOTO 170
*
*              Direction cosines at P(K) obtained from P(K-2),P(K-1),P(K).
*
  150 W3    = 2.*(DX1*DY2-DX2*DY1)
      CT    = CTU-W3*DY2
      ST    = STU+W3*DX2
      XNT   = 1./SQRT(CT**2+ST**2)
      CT    = CT*XNT
      ST    = ST*XNT
      FLGIS = .FALSE.
      GOTO 170
  160 IF(K.LE.1)GOTO 120
*
*              For the arc between P(K-1) and P(K) with direction cosines CO,
*              SO and CT,ST respectively, calculate the coefficients of the
*              parametric cubic represented by X(T) and Y(T) where
*              X(T)=XA*T**3 + XB*T**2 + CO*T + XO
*              Y(T)=YA*T**3 + YB*T**2 + SO*T + YO
*
  170 XO = X(K-1)
      YO = Y(K-1)
      DX = X(K)-XO
      DY = Y(K)-YO
*
*              Initialise the values of X(TI),Y(TI) in XT and YT respectively.
*
      XT = XO
      YT = YO
      IF(IFIN.LT.0)GOTO 350
      C  = DX**2+DY**2
      A  = CO+CT
      B  = SO+ST
      R  = DX*A+DY*B
      T  = C*6./(SQRT(R**2+2.*(7.-CO*CT-SO*ST)*C)+R)
      XA = (A*T-2.*DX)/T**3
      XB = (3.*DX-(CO+A)*T)/T**2
      YA = (B*T-2.*DY)/T**3
      YB = (3.*DY-(SO+B)*T)/T**2
*
*              If the curve is close to a straight line then use a straight
*              line between (XO,YO) and (XT,YT).
*
      IF(.75*MAX(ABS(DX*SO-DY*CO),ABS(DX*ST-DY*CT)).LE.DELT)GOTO 340
*
*              Calculate a set of values 0.EQ.T(0).LTCT(1).LT. ... .LT.T(M)=TC
*              such that polygonal arc joining X(T(J)),Y(T(J)) (J=0,1,..M)
*              is within the required accuracy of the curve
*
      TJ = 0.
      U1 = YA*XB-YB*XA
      U2 = YB*CO-XB*SO
      U3 = SO*XA-YA*CO
*
*              Given T(J), calculate T(J+1). The values of X(T(J)),
*              Y(T(J)) T(J) are contained in XT,YT and TJ respectively.
*
  180 S  = T-TJ
      IW = -2
*
*              Define IW here later.
*
      P1 = (2.*U1)*TJ-U3
      P2 = (U1*TJ-U3)*3.*TJ+U2
      P3 = 3.*TJ*YA+YB
      P4 = (P3+YB)*TJ+SO
      P5 = 3.*TJ*XA+XB
      P6 = (P5+XB)*TJ+CO
*
*              Test D(TJ,THETA). A is set to (Y(TJ+S)-Y(TJ))/S.B is
*              set to (X(TJ+S)-X(TJ))/S.
*
      CC  = 0.8209285
      ERR = 0.1209835
  190 IW  = IW-2
  200 A   = (S*YA+P3)*S+P4
      B   = (S*XA+P5)*S+P6
*
*              Set Z to PSI(D/DELTA)-CC.
*
      W1 = -S*(S*U1+P1)
      W2 = S**2*U1-P2
      W3 = 1.5*W1+W2
*
*              Set the estimate of (THETA-TJ)/S.Then set the numerator
*              of the expression (EQUATION 4.4)/S. Then set the square
*              of D(TJ,TJ+S)/DELT. Then replace Z by PSI(D/DELT)-CC.
*
      STH = 0.5+SIGN(W1,W3)/(3.4*ABS(W1)+5.2*ABS(W3))
      Z   = S*STH*(S-S*STH)*(W1*STH+W1+W2)
      Z   = Z**2/((A**2+B**2)*(DELT**2))
      Z   = (Z+2.642937)*Z/((.3715652*Z+3.063444)*Z+.2441889)-CC
*
*              Branch if Z has been calculated
*
      IF(IW.GT.0)GOTO 250
      IF(Z.GT.ERR)GOTO 240
      GOTO 220
  210 IW=IW-2
  220 IF(IW+2)230,190,290
*
*              Last part of arc.
*
  230 XT = X(K)
      YT = Y(K)
      S  = 0.
      GOTO 300
*
*              Z(S). find a value of S where 0.LE.S.LE.SB such that
*              ABS(Z(S)).LT.ERR
*
  240 KP=0
      C=Z
      SB=S
  250 CALL IGRAP2(KP,0.,SB,ERR,S,Z,MAXIT)
      IF(KP-2)260,210,370
  260 IF(IW)270,280,200
*
*              Set Z=Z(S) for S=0.
*
  270 Z=-CC
      IW=0
      GOTO 250
*
*              Set Z=Z(S) for S=SB.
*
  280 Z=C
      IW=1
      GOTO 250
*
*              Update TJ,XT and YT.
*
  290 XT=XT+S*B
      YT=YT+S*A
      TJ=S+TJ
  300 NPT=NPT+1
*
*              Convert coordinates to original system
*
      Q(LX+NPT)=SXMIN+XT/XRAT
      Q(LY+NPT)=SYMIN+YT/YRAT
*
*              If a fill area must be drawn and if the banks LX and
*              LY are too small they are enlarged in order to draw
*              the filled area in one go.
*
      IF(NPT.LT.IBKSIZ)THEN
         GOTO 320
      ELSE
         IF(IITYP.GE.1000)THEN
            CALL MZPUSH(IXHIGZ,LX,0,N2,' ')
            CALL MZPUSH(IXHIGZ,LY,0,N2,' ')
            IBKSIZ = IBKSIZ+N2
            GOTO 320
         ELSE
            IF(KTYP.GT.1)THEN
               CALL MZPUSH(IXHIGZ,LX,0,N2,' ')
               CALL MZPUSH(IXHIGZ,LY,0,N2,' ')
               IBKSIZ = IBKSIZ+N2
               GOTO 320
            ENDIF
         ENDIF
      ENDIF
*
*              Draw the graph
*
  310 CONTINUE
      IF(IITYP.GE.1000)THEN
         CALL IFA(NPT,Q(LX+1),Q(LY+1))
         IF(IBORD.NE.0)CALL IPL(NPT,Q(LX+1),Q(LY+1))
      ELSE
         IF(KTYP.GT.1)THEN
            IF(.NOT.LOPTX)THEN
               Q(LX+NPT+1)=Q(LX+NPT)
               Q(LX+NPT+2)=Q(LX+1)
               Q(LY+NPT+1)=YORG
               Q(LY+NPT+2)=YORG
            ELSE
               Q(LX+NPT+1)=XORG
               Q(LX+NPT+2)=XORG
               Q(LY+NPT+1)=Q(LY+NPT)
               Q(LY+NPT+2)=Q(LY+1)
            ENDIF
            CALL IFA(NPT+2,Q(LX+1),Q(LY+1))
         ENDIF
         CALL IPL(NPT,Q(LX+1),Q(LY+1))
      ENDIF
      NPT=1
      Q(LX+NPT)=SXMIN+XT/XRAT
      Q(LY+NPT)=SYMIN+YT/YRAT
  320 IF(IFIN)360,330,390
  330 IF(S)110,110,180
*
*              Draw a straight line between (XO,YO) and (XT,YT)
*
  340 IFIN=-1
  350 XT=XT+DX
      YT=YT+DY
      GOTO 300
  360 IFIN=0
      GOTO 110
  370 CALL IGERR('Attempt to plot outside plot limits'
     +,'IGRAPH')
      GOTO 230
*
*              Prepare to clear out remaining short vectors before returning
*
  380 IFIN=1
      IF(NPT.GT.1)GOTO 310
*
*              Convert coordinates back to original system
*
  390 DO 400 I=1,N
         X(I)=SXMIN+X(I)/XRAT
         Y(I)=SYMIN+Y(I)/YRAT
  400 CONTINUE
*
      CALL MZDROP(IXHIGZ,LX,' ')
      CALL MZDROP(IXHIGZ,LY,' ')
      LX = 0
      LY = 0
*
      END
+DECK,  IGRAP2, T=FORT.
* Revision 1.2  1997/11/24 15:29:51  couet
* - protection added against possible division by 0
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

      SUBROUTINE IGRAP2(K,AZ,BZ,E2,X,Y,MAXIT)
*.===========>
*.
*.   Underlaying routine for IGHIST
*. This subroutine finds a real zero of the continuous real
*. function Y(X) in a given interval (A,B). See accompanying
*. notes for details of the argument list and calling sequence
*.
*.        Modified by - P. Ward     Date - 24. 8.1973
*.
*..==========>
*
      SAVE A,B,J1,IT,YA,YTEST,Y1,X1,J3,J2,H
*.______________________________________
*
      IF(K.GT.0) GOTO 30
*
*              Calculate Y(X) at X=AZ.
*
      A=AZ
      B=BZ
      X=A
      J1=1
      IT=1
   10 K=J1
   20 RETURN
*
*              Test whether Y(X) is sufficiently small.
*
   30 IF(ABS(Y).GT.E2)GOTO 50
   40 K=2
      GOTO 20
   50 GOTO(60,70,100,170),J1
*
*              Calculate Y(X) at X=BZ.
*
   60 YA=Y
      X=B
      J1=2
      GOTO 20
*
*              Test whether the signs of Y(AZ) and Y(BZ) are different.
*              if not, begin the binary subdivision.
*
   70 IF(YA*Y.LT.0.)GOTO 120
      X1=A
      Y1=YA
      J1=3
      H=B-A
      J2=1
   80 X2=A+0.5*H
      J3=1
*
*              Check whether (MAXIT) function values have been calculated.
*
   90 IT=IT+1
      IF(IT.GE.MAXIT)GOTO 10
      X=X2
      GOTO 20
*
*              Test whether a bracket has been found .
*              If not,continue the search
*
  100 IF(YA*Y.LT.0.)GOTO 120
      IF(J3.GE.J2)GOTO 110
      A=X
      YA=Y
      X2=X+H
      J3=J3+1
      GOTO 90
  110 A=X1
      YA=Y1
      H=0.5*H
      J2=2.*J2
      GOTO 80
*
*              The first bracket has been found.calculate the next X by the
*              secant method based on the bracket.
*
  120 B=X
      YB=Y
      J1=4
  130 IF(ABS(YA).LE.ABS(YB))GOTO 140
      X1=A
      Y1=YA
      X=B
      Y=YB
      GOTO 150
  140 X1=B
      Y1=YB
      X=A
      Y=YA
*
*              Use the secant method based on the function values Y1 and Y.
*              check that X2 is inside the interval (A,B).
*
  150 IF (Y.EQ.Y1) GOTO 160
      X2=X-Y*(X-X1)/(Y-Y1)
      X1=X
      Y1=Y
      YTEST=0.5*MIN(ABS(YA),ABS(YB))
      IF((X2-A)*(X2-B).LT.0.)GOTO 90
*
*              Calculate the next value of X by bisection . Check whether
*              the maximum accuracy has been achieved.
*
  160 X2=0.5*(A+B)
      YTEST=0.
      IF((X2-A)*(X2-B))90,40,40
*
*              Revise the bracket (A,B).
*
  170 IF(YA*Y.GE.0.)GOTO 180
      B=X
      YB=Y
      GOTO 190
  180 A=X
      YA=Y
*
*              Use YTEST to decide the method for the next value of X.
*
  190 IF(YTEST.LE.0.)GOTO 130
      IF(ABS(Y)-YTEST)150,150,160
*
      END
+DECK,  IGRAPH, T=FORT.
* Revision 1.2  2001/10/17 14:36:57  couet
* - The WORK buffers were too small and the follwoing macro didn't not
*   work for more that 101 points:
*   vec/del *
*   n = [1]
*   vec/cr time([n])
*   vec/cr etime([n]) r [n]*0.0
*   vec/cr y([n]) r
*   vec/cr ey([n]) r [n]*0.7
*   do i = 1, [n]
*     vec/input time([i]) [i]
*     vec/input y([i]) $eval(3.0+0.01*[i])
*   enddo
*   null -10 160 0 10
*   hplot/errors time y etime ey [n] 20 0.1 3
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

      SUBROUTINE IGRAPH(N,X,Y,CHOPT)
*.===========>
*.
*.   Draws one dimensional graphs. The aspect of the graph is done
*. according to the value of the CHOPT.
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of channels in X or in Y.
*.  REAL X(N) or X(2) : X coordinates or (XMIN,XMAX) (WC space).
*.  REAL Y(N) or Y(2) : Y coordinates or (YMIN,YMAX) (WC space).
*.  CHARACTER*(*) CHOPT : Option.
*.
*.  CHOPT='L' :  A simple polyline beetwen every points is drawn
*.
*.  CHOPT='F' :  A fill area is drawn ('CF' draw a smooth fill area)
*.
*.  CHOPT='A' :  Axis are drawn around the graph
*.
*.  CHOPT='C' :  A smooth Curve is drawn
*.
*.  CHOPT='*' :  A Star is plotted at each point
*.
*.  CHOPT='P' :  Idem with the current marker
*.
*.  CHOPT='B' :  A Bar chart is drawn at each point
*.
*.  CHOPT='1' :  YLOW=RWYMIN
*.
*.  CHOPT='GX':  LOGX
*.
*.  CHOPT='GY':  LOGY
*.
*.  CHOPT='Z' :  The vectors X and Y are taken into PAWC at the
*.               adresses IQUEST(81) and IQUEST(82)
*.
*..==========> (O.Couet N.Cremel-Somon)
+CDE, HIPAW.
+CDE, HIFLAG.
+CDE, HIATT.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF.
+CDE, HIHIST.
      PARAMETER (NPMAX=1004)
      DIMENSION X(*),Y(*)
      CHARACTER*(*) CHOPT
      CHARACTER*8 CHOPA
      EQUIVALENCE (LXADR,L2NTLA),(LYADR,LDNTLA)
      LOGICAL ZFSAV
      DIMENSION IOPT(12)
      EQUIVALENCE (IOPTL ,IOPT(1)) , (IOPTA ,IOPT(2))
      EQUIVALENCE (IOPTC ,IOPT(3)) , (IOPTST,IOPT(4))
      EQUIVALENCE (IOPTP ,IOPT(5)) , (IOPTB ,IOPT(6))
      EQUIVALENCE (IOPTR ,IOPT(7)) , (IOPT1 ,IOPT(8))
      EQUIVALENCE (IOPTG ,IOPT(9)) , (IOPTX ,IOPT(10))
      EQUIVALENCE (IOPTY ,IOPT(11)), (IOPTF ,IOPT(12))
*.______________________________________
*
      IQUEST(1)=0
      IF(N.LE.0)THEN
         CALL IGERR(' Number of points is invalid','IGRAPH')
         RETURN
      ENDIF
*
      CALL UOPTC(CHOPT,'LAC*PBR1GXYF',IOPT)
*
*              If no "drawing" option is selected and if CHOPT<>' '
*              nothing is done.
*
      IF(IOPTL+IOPTF+IOPTC+IOPTST+IOPTP+IOPTB.EQ.0)THEN
         IF(CHOPT.EQ.' ')THEN
            IOPTL=1
         ELSE
            RETURN
         ENDIF
      ENDIF
*
*              If necessary the adresses of the vectors are saved in
*              a link area.
*
      IF(INDEX(CHOPT,'Z').NE.0)THEN
         LXADR = IQUEST(81)
         LYADR = IQUEST(82)
         IOPTZ = 1
      ELSE
         IOPTZ = 0
      ENDIF
*
+SELF, IF=MAIL.
      CHOPTM=CHOPT
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZGRAP(N,X,Y,IOPT,IOPTZ)
+SELF.
      IF((.NOT.GFLAG).AND.(.NOT.PFLAG))RETURN
      ZFSAV  = ZFLAG
      ZFLAG  = .FALSE.
      GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      IOPTCF = 0
      IF((IOPTC.NE.0).AND.(IOPTF.NE.0))THEN
         IOPTCF = 1
         IOPTF  = 0
      ENDIF
*
*              Draw the Axis with a fixed number of division: 510
*
      IF(IOPTA.NE.0)THEN
         ILNOLD = ILN
         IFAOLD = IFAIS
         CALL ISLN(1)
         CALL ISFAIS(0)
         CALL IGBOX(RWXMIN,RWXMAX,RWYMIN,RWYMAX)
         CALL ISLN(ILNOLD)
         CALL ISFAIS(IFAOLD)
         AXFLAG = .FALSE.
         CHOPA  = ' '
         RWMIN  = RWXMIN
         RWMAX  = RWXMAX
         IF(IOPTG.NE.0.AND.IOPTX.NE.0)THEN
            RWMIN = 10**RWXMIN
            RWMAX = 10**RWXMAX
            CHOPA = 'G'
         ENDIF
         CALL IGAXIS(RWXMIN,RWXMAX,RWYMIN,RWYMIN,RWMIN,RWMAX,510,CHOPA)
         AXFLAG = .TRUE.
         CHOPA  = ' '
         RWMIN  = RWYMIN
         RWMAX  = RWYMAX
         IF(IOPTG.NE.0.AND.IOPTY.NE.0)THEN
            RWMIN = 10**RWYMIN
            RWMAX = 10**RWYMAX
            CHOPA = 'G'
         ENDIF
         CALL IGAXIS(RWXMIN,RWXMIN,RWYMIN,RWYMAX,RWMIN,RWMAX,510,CHOPA)
         AXFLAG = .FALSE.
      ENDIF
*
*              Draw the graph with a polyline or a fill area
*              beetwen every point
*
      IF((IOPTL.NE.0).OR.(IOPTF.NE.0))THEN
         IF(IOPTZ.NE.0)THEN
            XWORK(1) = Q(LXADR)
            YWORK(1) = Q(LYADR)
            X1       = Q(LXADR)
            XN       = Q(LXADR+N-1)
            Y1       = Q(LYADR)
            YN       = Q(LYADR+N-1)
         ELSE
            XWORK(1) = X(1)
            YWORK(1) = Y(1)
            X1       = X(1)
            XN       = X(N)
            Y1       = Y(1)
            YN       = Y(N)
         ENDIF
         NLOOP = N
         IF(IOPTF.NE.0.AND.(XN.NE.X1.OR.YN.NE.Y1))NLOOP = NLOOP+1
         NPT = 1
         DO 10 I=1,NLOOP
            NPT = NPT+1
            IF(I.GT.N)THEN
               XWORK(NPT) = XWORK(1)
               YWORK(NPT) = YWORK(1)
            ELSE
               IF(IOPTZ.NE.0)THEN
                  XWORK(NPT) = Q(LXADR+I-1)
                  YWORK(NPT) = Q(LYADR+I-1)
               ELSE
                  XWORK(NPT) = X(I)
                  YWORK(NPT) = Y(I)
               ENDIF
            ENDIF
            IF(NPT.EQ.NPMAX.OR.I.EQ.NLOOP)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               IF(IOPTR.NE.0)THEN
                  IF(IOPTF.NE.0)THEN
                     CALL IFA(NPT,YWORKL,XWORKL)
                     IF(IBORD.NE.0)CALL IPL(NPT,YWORKL,XWORKL)
                  ELSE
                     CALL IPL(NPT,YWORKL,XWORKL)
                  ENDIF
               ELSE
                  IF(IOPTF.NE.0)THEN
                     CALL IFA(NPT,XWORKL,YWORKL)
                     IF(IBORD.NE.0)CALL IPL(NPT,XWORKL,YWORKL)
                  ELSE
                     CALL IPL(NPT,XWORKL,YWORKL)
                  ENDIF
               ENDIF
               XWORK(1) = XWORK(NPT)
               YWORK(1) = YWORK(NPT)
               NPT      = 1
            ENDIF
   10    CONTINUE
      ENDIF
*
*              Draw the graph with a smooth Curve. The computing
*              of the smoothing is done by the routine IGRAP1
*
      IF(IOPTC.NE.0)THEN
         IF(IOPTZ.NE.0)THEN
            X1 = Q(LXADR)
            XN = Q(LXADR+N-1)
            Y1 = Q(LYADR)
            YN = Q(LYADR+N-1)
         ELSE
            X1 = X(1)
            XN = X(N)
            Y1 = Y(1)
            YN = Y(N)
         ENDIF
         ITYPS = 1
         NLOOP = N
         IF(IOPTCF.NE.0)THEN
            ITYPS = ITYPS+1000
            IF(XN.NE.X1.OR.YN.NE.Y1)NLOOP = NLOOP+1
         ENDIF
         IF(IOPTR.EQ.0)THEN
            NPT = 0
            DO 20 I=1,NLOOP
               NPT = NPT+1
               IF(I.GT.N)THEN
                  XWORK(NPT) = XWORK(1)
                  YWORK(NPT) = YWORK(1)
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     XWORK(NPT) = Q(LXADR+I-1)
                     YWORK(NPT) = Q(LYADR+I-1)
                  ELSE
                     XWORK(NPT) = X(I)
                     YWORK(NPT) = Y(I)
                  ENDIF
               ENDIF
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               IF(YWORKL(NPT).LT.RWYMIN.OR.YWORKL(NPT).GT.RWYMAX)THEN
                  IF(NPT.GT.2)THEN
                     CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                     CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
                  ENDIF
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT=1
                  GOTO 20
               ENDIF
               IF(NPT.GE.NPMAX)THEN
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
               ENDIF
   20       CONTINUE
            IF(NPT.GT.1)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
            ENDIF
         ELSE
            ITYPS = ITYPS+10
            NPT   = 0
            DO 30 I=1,NLOOP
               NPT=NPT+1
               IF(I.GT.N)THEN
                  XWORK(NPT) = XWORK(1)
                  YWORK(NPT) = YWORK(1)
               ELSE
                  IF(IOPTZ.NE.0)THEN
                     XWORK(NPT) = Q(LXADR+I-1)
                     YWORK(NPT) = Q(LYADR+I-1)
                  ELSE
                     XWORK(NPT) = X(I)
                     YWORK(NPT) = Y(I)
                  ENDIF
               ENDIF
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               IF(XWORKL(NPT).LT.RWXMIN.OR.XWORKL(NPT).GT.RWXMAX)THEN
                  IF(NPT.GT.2)THEN
                     CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                     CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
                  ENDIF
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT=1
                  GOTO 30
               ENDIF
               IF(NPT.GE.NPMAX)THEN
                  CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
                  CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
                  XWORK(1) = XWORK(NPT)
                  YWORK(1) = YWORK(NPT)
                  NPT      = 1
               ENDIF
   30       CONTINUE
            IF(NPT.GT.1)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               CALL IGRAP1(XWORKL,YWORKL,NPT,ITYPS)
            ENDIF
         ENDIF
      ENDIF
*
*              Draw the graph with a '*' on every points
*
      IF(IOPTST.NE.0)THEN
         IMKOLD = IMK
         CALL ISMK(3)
         NPT = 0
         DO 40 I=1,N
            NPT = NPT+1
            IF(IOPTZ.NE.0)THEN
               XWORK(NPT) = Q(LXADR+I-1)
               YWORK(NPT) = Q(LYADR+I-1)
            ELSE
               XWORK(NPT) = X(I)
               YWORK(NPT) = Y(I)
            ENDIF
            IF(NPT.EQ.NPMAX.OR.I.EQ.N)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               IF(IOPTR.NE.0)THEN
                  CALL IPM(NPT,YWORKL,XWORKL)
               ELSE
                  CALL IPM(NPT,XWORKL,YWORKL)
               ENDIF
               NPT = 0
            ENDIF
   40    CONTINUE
         CALL ISMK(IMKOLD)
      ENDIF
*
*              Draw the graph with the current polymarker on
*              every points
*
      IF(IOPTP.NE.0)THEN
         NPT = 0
         DO 50 I=1,N
            NPT = NPT+1
            IF(IOPTZ.NE.0)THEN
               XWORK(NPT) = Q(LXADR+I-1)
               YWORK(NPT) = Q(LYADR+I-1)
            ELSE
               XWORK(NPT) = X(I)
               YWORK(NPT) = Y(I)
            ENDIF
            IF(NPT.EQ.NPMAX.OR.I.EQ.N)THEN
               CALL IGHIS1(NPT,IOPTG,IOPTX,IOPTY)
               IF(IOPTR.NE.0)THEN
                  CALL IPM(NPT,YWORKL,XWORKL)
               ELSE
                  CALL IPM(NPT,XWORKL,YWORKL)
               ENDIF
               NPT = 0
            ENDIF
   50    CONTINUE
      ENDIF
*
*              Draw the graph as a bar chart
*
      IF(IOPTB.NE.0)THEN
         IF(IOPTR.EQ.0)THEN
            IF(IOPTZ.NE.0)THEN
               BXMIN = VMIN(Q(LXADR),N)
               BXMAX = VMAX(Q(LXADR),N)
            ELSE
               BXMIN = VMIN(X,N)
               BXMAX = VMAX(X,N)
            ENDIF
            BDELTA = (BXMAX-BXMIN)/N
         ELSE
            IF(IOPTZ.NE.0)THEN
               BYMIN = VMIN(Q(LYADR),N)
               BYMAX = VMAX(Q(LYADR),N)
            ELSE
               BYMIN = VMIN(Y,N)
               BYMAX = VMAX(Y,N)
            ENDIF
            BDELTA = (BYMAX-BYMIN)/N
         ENDIF
         DBAR  = BDELTA*RBWD*0.5
         IBOLD = IBORD
         CALL IGSET('BORD',1.)
         IF(IOPTR.EQ.0)THEN
            DO 60 I=1,N
               IF(IOPTZ.NE.0)THEN
                  XLOW  = Q(LXADR+I-1)-DBAR
                  XHIGH = Q(LXADR+I-1)+DBAR
                  YHIGH = Q(LYADR+I-1)
               ELSE
                  XLOW  = X(I)-DBAR
                  XHIGH = X(I)+DBAR
                  YHIGH = Y(I)
               ENDIF
               IF(IOPT1.EQ.0)THEN
                  YLOW = MAX(0.,RWYMIN)
               ELSE
                  YLOW = RWYMIN
               ENDIF
               XWORK(1) = XLOW
               YWORK(1) = YLOW
               XWORK(2) = XHIGH
               YWORK(2) = YHIGH
               CALL IGHIS1(2,IOPTG,IOPTX,IOPTY)
               CALL IGBOX(XWORKL(1),XWORKL(2),YWORKL(1),YWORKL(2))
   60       CONTINUE
         ELSE
            DO 70 I=1,N
               IF(IOPTZ.NE.0)THEN
                  XHIGH = Q(LXADR+I-1)
                  YLOW  = Q(LYADR+I-1)-DBAR
                  YHIGH = Q(LYADR+I-1)+DBAR
               ELSE
                  XHIGH = X(I)
                  YLOW  = Y(I)-DBAR
                  YHIGH = Y(I)+DBAR
               ENDIF
               XLOW     = MAX(0.,RWXMIN)
               XWORK(1) = XLOW
               YWORK(1) = YLOW
               XWORK(2) = XHIGH
               YWORK(2) = YHIGH
               CALL IGHIS1(2,IOPTG,IOPTX,IOPTY)
               CALL IGBOX(XWORKL(1),XWORKL(2),YWORKL(1),YWORKL(2))
   70       CONTINUE
         ENDIF
         CALL IGSET('BORD',FLOAT(IBOLD))
      ENDIF
*
      ZFLAG=ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGRNG, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

+SELF, IF=-DI3000.
      SUBROUTINE IGRNG(XSIZI,YSIZI)
*.==========>
*.
*.   This routines returns the screen range and map the workstation
*. window on the whole screen. If the screen is not a square a part
*. of the NDC space is not visible .
*.
*. _Input parameters:
*.
*.  REAL XSIZ YSIZ : Screen range .
*.
*..=========>
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIMETA.
+CDE, HIFLAG.
+SELF, IF=-DI3000, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=-DI3000, IF=PSCRIPT.
+CDE, HIPOST.
+SELF, IF=-DI3000, IF=DECGKS.
      REAL*4 RDUMMY(4),VIEW(4)
+SELF, IF=-DI3000.
      DIMENSION RVAL(2)
*.______________________________________
*
      XSIZ=XSIZI
      YSIZ=YSIZI
+SELF, IF=-DI3000, IF=MAIL.
*
*              Mail option
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,2E16.7)') 201,XSIZ,YSIZ
         CALL IMWRIT(1)
         READ (5,'(5E15.6)') XYTWN,DXWN,DYWN,XNCM,YNCM
         CALL IMWRIT(5)
         MFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL ISWN(1,0.,XSIZ,0.,YSIZ)
         CALL ISVP(1,DXWN,XNCM+DXWN,DYWN,YNCM+DYWN)
         CALL ISELNT(1)
         RQUEST(11)=XYTWN
         RQUEST(12)=DXWN
         RQUEST(13)=DYWN
         RQUEST(14)=XNCM
         RQUEST(15)=YNCM
         MFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         RETURN
      ENDIF
+SELF, IF=-DI3000.
*
      IF(XSIZ.LT.0..OR.YSIZ.LT.0.)THEN
         CALL IGERR('X size and Y size must be positive','IGRNG')
         RETURN
      ENDIF
*
*              Initialise parameters
*
      RVAL(1)=1.
      RVAL(2)=1.
      XWKWN=1.
      YWKWN=1.
      IWKID=1
*
*              If output on metafile
*
      IF (METACT.OR.PFLAG) THEN
         IERR=0
+SELF, IF=-DI3000, IF=MGKS,PLOT10GKS,UNIGKS.
         CALL GQMDS(IWTYPE,IERR,IDC,RVAL(1),RVAL(2),ILX,ILY)
+SELF, IF=-DI3000, IF=GKSGRAL,DECGKS,ATCGKS,GKSBX.
         CALL GQDSP(IWTYPE,IERR,IDC,RVAL(1),RVAL(2),ILX,ILY)
+SELF, IF=-DI3000, IF=ATCGKS.
         IF(IERR.EQ.22)THEN
+SELF, IF=-DI3000, IF=GKSGRAL,DECGKS, IF=-ATCGKS.
         IF(IERR.EQ.31)THEN
+SELF, IF=-DI3000, IF=GKSGRAL,DECGKS,ATCGKS.
            RVAL(1)=1.
            RVAL(2)=1.
         ENDIF
+SELF, IF=-DI3000.
         XWKWN=MIN(1.,RVAL(1)/RVAL(2))
         YWKWN=MIN(1.,RVAL(2)/RVAL(1))
+SELF, IF=-DI3000, IF=PSCRIPT.
         IF(PFLAG)CALL IPRNG(XSIZ,YSIZ)
+SELF, IF=-DI3000.
      ENDIF
*
*              If output on screen
*
      IF(TEKACT)THEN
         IERR=0
+SELF, IF=-DI3000, IF=MGKS,PLOT10GKS,UNIGKS.
         CALL GQMDS(IWTYPE,IERR,IDC,RVAL(1),RVAL(2),ILX,ILY)
+SELF, IF=-DI3000, IF=GKSGRAL,ATCGKS,GKSBX.
         CALL GQDSP(IWTYPE,IERR,IDC,RVAL(1),RVAL(2),ILX,ILY)
+SELF, IF=-DI3000, IF=ATCGKS.
         IF(IERR.EQ.22)THEN
+SELF, IF=-DI3000, IF=GKSGRAL, IF=-ATCGKS.
         IF(IERR.EQ.31)THEN
+SELF, IF=-DI3000, IF=GKSGRAL,ATCGKS.
            RVAL(1)=1.
            RVAL(2)=1.
         ENDIF
+SELF, IF=-DI3000, IF=KERNEL,DECGKS,PHIGS,FALCO.
         CALL IGQWK(IWKID,'MXDS',RVAL)
+SELF, IF=-DI3000.
*
         XWKWN=MIN(1.,RVAL(1)/RVAL(2))
         YWKWN=MIN(1.,RVAL(2)/RVAL(1))
         CALL ISWKWN(IWKID,0.,XWKWN,0.,YWKWN)
+SELF, IF=-DI3000, IF=-DECGKS.
         CALL ISWKVP(IWKID,0.,RVAL(1),0.,RVAL(2))
+SELF, IF=-DI3000, IF=X11.
         DO 10 I=1,INOPWK
            IWKL = ILOPWK(I)
            CALL IGQWK(IWKL,'MXDS',RVAL)
            CALL ISWKWN(IWKL,0.,XWKWN,0.,YWKWN)
            CALL ISWKVP(IWKL,0.,RVAL(1),0.,RVAL(2))
            CALL IKUWK(IWKL)
            XMARG=0.
            YMARG=0.
            IF(RVAL(1).GT.XWKV2(I))XMARG = (RVAL(1)-XWKV2(I))/2.
            IF(RVAL(2).GT.YWKV2(I))YMARG = (RVAL(2)-YWKV2(I))/2.
            IF(XMARG.NE.0..OR.YMARG.NE.0.)THEN
               CALL ISWKVP(IWKL,XMARG,XWKV2(I)+XMARG
     +,                         YMARG,YWKV2(I)+YMARG)
               CALL IKUWK(IWKL)
            ENDIF
   10    CONTINUE
+SELF, IF=-DI3000.
      ENDIF
*
*              Transformation no 1 : cm <---> espace ecran
*
      IF (XSIZ.LT.YSIZ) THEN
         XNCM=YWKWN*XSIZ/YSIZ
         YNCM=YWKWN
         DXWN=(XWKWN-XNCM)/2.
         IF(DXWN.LT.0.)THEN
            XNCM=XWKWN
            DXWN=0.
            YNCM=XWKWN*YSIZ/XSIZ
            DYWN=(YWKWN-YNCM)/2.
            XYTWN=XWKWN/XSIZ
         ELSE
            DYWN=0.
            XYTWN=YWKWN/YSIZ
         ENDIF
      ELSE
         XNCM=XWKWN
         YNCM=XWKWN*YSIZ/XSIZ
         DYWN=(YWKWN-YNCM)/2.
         IF(DYWN.LT.0.)THEN
            YNCM=YWKWN
            DYWN=0.
            XNCM=YWKWN*XSIZ/YSIZ
            DXWN=(XWKWN-XNCM)/2.
            XYTWN=YWKWN/YSIZ
         ELSE
            DXWN=0.
            XYTWN=XWKWN/XSIZ
         ENDIF
      ENDIF
+SELF, IF=-DI3000, IF=PSCRIPT.
*
      IF(PFLAG)THEN
         XVS1=DXWN
         XVS2=XNCM+DXWN
         YVS1=DYWN
         YVS2=YNCM+DYWN
      ENDIF
+SELF, IF=-DI3000.
*
      CALL ISWN(1,0.,XSIZ,0.,YSIZ)
      CALL ISVP(1,DXWN,XNCM+DXWN,DYWN,YNCM+DYWN)
      CALL ISELNT(1)
+SELF, IF=-DI3000, IF=-SUNGKS, IF=-ATCGKS.
      IF (METACT) THEN
         CALL ISWKWN (IDMETA,DXWN,XNCM+DXWN,DYWN,YNCM+DYWN)
         CALL ISWKVP (IDMETA,0., XSIZ*XMFACT,0.,YSIZ*YMFACT)
         CALL IUWK   (IDMETA,1)
      ENDIF
+SELF, IF=-DI3000.
*
      RQUEST(11)=XYTWN
      RQUEST(12)=DXWN
      RQUEST(13)=DYWN
      RQUEST(14)=XNCM
      RQUEST(15)=YNCM
*
      END
+SELF.
+DECK,  IGRSIZ, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

+SELF, IF=X11.
      SUBROUTINE IGRSIZ(IWKID)
*.===========>
*.
*.  Resize the X11 window and display the current
*.  picture if it exists.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIQUES.
      CHARACTER*(32) CHTEMP
*.______________________________________
*
      IW=IWINID(IGIWIN(IWKID))
      CALL IXRSIZ(IW)
      CALL IZPICT(CHTEMP,'R')
      IF(CHTEMP.NE.' ')THEN
         DO 10 I=1,INOPWK
            CALL IGQWK(ILOPWK(I),'ACTI',RQUEST(40+I))
            IF(ILOPWK(I).NE.IWKID)THEN
               CALL IDAWK(ILOPWK(I))
            ELSE
               CALL IACWK(IWKID)
            ENDIF
   10    CONTINUE
         CALL IZPICT(CHTEMP,'D')
         DO 20 I=1,INOPWK
            IF(RQUEST(40+I).EQ.0.)THEN
               CALL IDAWK(ILOPWK(I))
            ELSE
               CALL IACWK(ILOPWK(I))
            ENDIF
   20    CONTINUE
         CALL IXSAVWI
         CALL IXSELWI(IW)
         CALL IXUPDWI(1)
         CALL IXSETWI
      ENDIF
*
      END
+SELF.
+DECK,  IGRTOH, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

      SUBROUTINE IGRTOH(RED,GREEN,BLUE,RHUE,RLIGHT,RSATUR)
*.===========>
*.
*.   Convert RGB to HSL
*.
*..==========> (L.Roberts)
      REAL RNORM, GNORM, BNORM, MINVAL, MAXVAL, MSUM, MDIFF
*.______________________________________
*
      MINVAL = MIN (RED, GREEN, BLUE)
      MAXVAL = MAX (RED, GREEN, BLUE)
*
      RNORM = 0.0
      GNORM = 0.0
      BNORM = 0.0
      MDIFF = MAXVAL - MINVAL
      MSUM = MAXVAL + MINVAL
      IF(MAXVAL .NE. MINVAL)THEN
         RNORM = (MAXVAL - RED) / MDIFF
         GNORM = (MAXVAL - GREEN) / MDIFF
         BNORM = (MAXVAL - BLUE) / MDIFF
      ENDIF
*
      RLIGHT = MSUM / 2.0
*
      IF (MAXVAL.EQ.MINVAL)THEN
         RSATUR = 0.0
         RHUE = 0.0
         GOTO 30
      ENDIF
*
      IF (RLIGHT .LE. 0.5) RSATUR = MDIFF / MSUM
      IF (RLIGHT .GT. 0.5) RSATUR = MDIFF / (2.0 - MSUM)
*
      IF (RED .EQ. MAXVAL) RHUE = 60.0 * (6.0 + BNORM - GNORM)
      IF (GREEN .EQ. MAXVAL) RHUE = 60.0 * (2.0 + RNORM - BNORM)
      IF (BLUE .EQ. MAXVAL) RHUE = 60.0 * (4.0 + GNORM - RNORM)
*
   30 IF (RHUE .GT. 360.0) RHUE = RHUE - 360.0
*
      END
+DECK,  IGSET, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

      SUBROUTINE IGSET(PNAME,RVAL)
*.===========>
*.
*.   This routine sets the parameter PNAME to the value VAL .
*.
*. _Input parameters:
*.
*.  CHARACTER PNAME : Parameter name .
*.  REAL RVAL : Parameter value .
*.
*.   PNAME='FAIS' VAL=Fill Area Interior Style (0,1,2,3)
*.   PNAME='FASI' VAL=Fill Area Style Index
*.   PNAME='LTYP' VAL=Line TYPe
*.   PNAME='BASL' VAL=BAsic Segment Length
*.   PNAME='LWID' VAL=Line WIDth
*.   PNAME='MTYP' VAL=Marker TYPe
*.   PNAME='MSCF' VAL=Marker SCale Factor
*.   PNAME='PLCI' VAL=PolyLine Color Index
*.   PNAME='PMCI' VAL=PolyMarker Color Index
*.   PNAME='FACI' VAL=Fill Area Color Index
*.   PNAME='TXCI' VAL=TeXt Color Index
*.   PNAME='TXAL' VAL=10*(alignment horizontal) + (alignment vertical)
*.   PNAME='CHHE' VAL=CHaracter HEight)
*.   PNAME='TANG' VAL=Text ANGle
*.   PNAME='TXFP' VAL=10*(TeXt Font) + (TeXt Precision)
*.   PNAME='TMSI' VAL=Tick Marks SIze (in WC)
*.   PNAME='LASI' VAL=LAbels SIze (in WC)
*.   PNAME='LAOF' VAL=LAbels OFfset
*.   PNAME='PASS' VAL=IGTEXT Width
*.   PNAME='CSHI' VAL=IGTEXT Shift
*.   PNAME='BORD' VAL=Border for IGBOX, IGFBOX and IGARC (0=No , 1=Yes)
*.   PNAME='BARO' VAL=IGHIST or IGRAPH BAR charts Offset (%)
*.   PNAME='BARW' VAL=IGHIST or IGRAPH BAR charts Width (%)
*.   PNAME='AWLN' VAL=Axis Wire LeNght
*.   PNAME='NLIN' VAL=Number of lines for 3D shapes.
*.
*.   PNAME='*'    All the default values are reset
*.   PNAME='PICT' VAL=Starting number for automatic naming of RZ pictures
*.   PNAME='AURZ' VAL=Automatic saving of pictures
*.   PNAME='SHOW' Shows the current values of the IGSET parameters
*.   PNAME='DIME' VAL=2D or 3D
*.   PNAME='NCOL' VAL=Number of entry in the COLor map.
*.   PNAME='DRMD' VAL=Drawing mode: 1.=copy 2.=xor
*.   PNAME='SYNC' VAL=Synchronise the graphics in X11 1.=yes 0.=no
*.   PNAME='CLIP' VAL=Clipping mode: 1.=on 0.=off
*.   PNAME='2BUF' VAL=10*(WKID)+(double buffer mode: 1.=on 0.=off)
*.   PNAME='ZBUF' VAL=Z-buffer mode: 1.=on 0.=off
*.
*.                How to add an HIGZ attribute:
*.
*.    .In HIATT: add a variable to store the attribute and
*.     supress one word in REAATT, if the attribute is REAL,
*.     or in INTATT if the attribute is INTEGER.
*.
*.    .In HIATNB: increment by one NBRATT, if the attribute is REAL,
*.     or NBIATT if the attribute is INTEGER.
*.
*.    .In HIATNM: add the IGSET name of the attribute in CHRATT,
*.     if the attribute is REAL, or in CHIATT, if the attribute
*.     is INTEGER.
*.
*.    .In HIFLAT: add a variable to store the attribute flag and
*.     supress one word in KRFLAG, if the attribute is REAL,
*.     or in KIFLAG if the attribute is INTEGER
*.
*.    .In HICODE: add a parameter to store the attribute code IATTCO.
*.     ( 49 < IATTCO < 80, if the attribute is REAL)
*.     ( 79 < IATTCO < 110 if the attribute is INTEGER)
*.
*.    .Modify IGSET to take care about this attribute.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HICODE.
+CDE, HILUN.
+CDE, HILUT.
      CHARACTER*4 PNAME
      CHARACTER*6 PZNAME
      CHARACTER*30 COMM
      REAL IGSET1
*.______________________________________
*
      VAL=RVAL
      IF(PNAME(1:4).EQ.'FAIS')THEN
         CALL ISFAIS(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'FASI')THEN
         CALL ISFASI(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LTYP')THEN
         CALL ISLN(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BASL')THEN
         VAL=IGSET1(VAL)
         RBSL=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IBSLCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LWID')THEN
         VAL=IGSET1(VAL)
         CALL ISLWSC(VAL)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'MTYP')THEN
         CALL ISMK(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'MSCF')THEN
         VAL=IGSET1(VAL)
         CALL ISMKSC(VAL)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'PLCI')THEN
         VAL=IGSET1(VAL)
         CALL ISPLCI(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'PMCI')THEN
         VAL=IGSET1(VAL)
         CALL ISPMCI(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'FACI')THEN
         VAL=IGSET1(VAL)
         CALL ISFACI(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TXCI')THEN
         VAL=IGSET1(VAL)
         CALL ISTXCI(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TXAL')THEN
         VAL=IGSET1(VAL)
         ITXA1=NINT(VAL/10.)
         ITXA2=NINT(VAL-10*ITXA1)
         CALL ISTXAL(ITXA1,ITXA2)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'CHHE')THEN
         VAL=IGSET1(VAL)
         CALL ISCHH(VAL)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TANG')THEN
         CALL ISCHUP(COS(((VAL+90.)*3.14159)/180.)
     +,              SIN(((VAL+90.)*3.14159)/180.))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TXFP')THEN
         CALL ISTXFP(INT(VAL/10.)
     +,              ABS(INT(VAL-10*INT(VAL/10.))))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'TMSI')THEN
         IF(VAL.EQ.RTMS)RETURN
         RTMS=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(ITMSCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LASI')THEN
         VAL=IGSET1(VAL)
         IF(VAL.EQ.RALH)RETURN
         RALH=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IALHCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'LAOF')THEN
         IF(VAL.EQ.RALD)RETURN
         RALD=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IALDCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'PASS')THEN
         VAL=IGSET1(VAL)
         IF(INT(VAL).EQ.INPASS)RETURN
         INPASS=INT(VAL)
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IGTWCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'CSHI')THEN
         VAL=IGSET1(VAL)
         IF(VAL.EQ.RCSHIF)RETURN
         RCSHIF=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IGTSCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BORD')THEN
         IF(INT(VAL).EQ.IBORD)RETURN
         IF(VAL.LT.0.)VAL=0.
         IF(VAL.GT.1.)VAL=1.
         IBORD=INT(VAL)
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IBORCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BARO')THEN
         IF(ABS(VAL).GT.1.)THEN
            CALL IGERR('BARO must verify -1. < "BARO" < 1.','IGSET')
            RETURN
         ENDIF
         RBOF=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IBOFCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'BARW')THEN
         VAL=IGSET1(VAL)
         IF((VAL.GT.1.).OR.(VAL.LT.0.))THEN
            CALL IGERR('BARW must verify 0. < "BARW" < 1.','IGSET')
            RETURN
         ENDIF
         RBWD=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IBWDCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'NLIN')THEN
         IF(INT(VAL).EQ.INLINE)RETURN
         INLINE=INT(IGSET1(VAL))
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(INLICO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'PICT')THEN
         VAL=IGSET1(VAL)
         IPICT=INT(VAL)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'DIME')THEN
         IF((VAL.NE.2.).AND.(VAL.NE.3.))THEN
            CALL IGERR('DIME = 2 or DIME = 3','IGSET')
            RETURN
         ENDIF
         IDIM=INT(VAL)
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'AURZ')THEN
         VAL=IGSET1(VAL)
         IF(VAL.NE.0.)THEN
            ASFLAG=.TRUE.
         ELSE
            ASFLAG=.FALSE.
         ENDIF
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'AWLN')THEN
         RAWL=VAL
+SELF, IF=ZEBRA,MAIL.
         IF(GLFLAG)CALL IZATT(IAWLCO)
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'NCOL')THEN
         VAL=IGSET1(VAL)
         IF(VAL.LE.0.)VAL=8.
         INBCOL=INT(VAL)
         IF(INBCOL.LE.NBCLUT.AND.INBCOL.GT.8)THEN
            DCOL=1./(INBCOL-8)
            DO 10 I=8,INBCOL
               GREY=1.-DCOL*(I-8)
               CALL ISCR(1,I,GREY,GREY,GREY)
   10       CONTINUE
         ENDIF
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'DRMD')THEN
+SELF, IF=X11.
         CALL IXDRMDE(INT(VAL))
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'SYNC')THEN
+SELF, IF=X11.
         CALL IXSYNC(INT(VAL))
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'CLIP')THEN
         CALL ISCLIP(INT(VAL))
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'2BUF')THEN
+SELF, IF=X11.
         IWID2B = INT(VAL/10.)
         IF(IWID2B.EQ.0)THEN
            I2BUF = MOD(INT(VAL),10)
            CALL IXS2BUF(999,I2BUF)
            RETURN
         ENDIF
         ITY    = IGIWTY(IWID2B)
         IF(ITY.GT.0)THEN
            IF(ITY.EQ.7878.OR.ITY.EQ.7879)RETURN
            I2BUF = MOD(INT(VAL),10)
            IWIN  = IWINID(IGIWIN(IWID2B))
            CALL IXS2BUF(IWIN,I2BUF)
         ENDIF
+SELF.
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'ZBUF')THEN
         IZBUF = INT(VAL)
         RETURN
      ENDIF
      IF(PNAME(1:1).EQ.'*')THEN
         CALL ISFAIS(0)
         CALL ISFASI(1)
         CALL ISLN(1)
         CALL ISLWSC(1.)
         CALL ISMK(1)
         CALL ISMKSC(1.)
         CALL ISPLCI(1)
         CALL ISPMCI(1)
         CALL ISFACI(1)
         CALL ISTXAL(0,0)
         CALL ISCHH(0.28)
         CALL ISCHUP(0.,1.)
         CALL ISTXCI(1)
         CALL ISTXFP(0,2)
         CALL ISCLIP(1)
         IBORD=0
         INPASS=1
         RCSHIF=0.02
         RALH=0.018
         RALD=0.013
         RTMS=0.019
         RBSL=0.01
         RBOF=0.25
         RBWD=0.5
         RAWL=0.0
         IDIM=2
         INLINE=40
         INBCOL=8
         IZBUF=0
         RETURN
      ENDIF
      IF(PNAME(1:4).EQ.'SHOW')THEN
         CALL IGSA(0)
         WRITE(LUNOUT,10100)
         WRITE(LUNOUT,10000)
         WRITE(LUNOUT,10200)
         WRITE(LUNOUT,10300)
         WRITE(LUNOUT,10200)
         PZNAME='FAIS '
         COMM='Fill area interior style'
         WRITE(LUNOUT,10400) PZNAME,IFAIS,0,COMM
         PZNAME='FASI '
         COMM='Fill area style index'
         WRITE(LUNOUT,10400) PZNAME,IFASI,1,COMM
         PZNAME='LTYP '
         COMM='Line type'
         WRITE(LUNOUT,10400) PZNAME,ILN,1,COMM
         PZNAME='BASL '
         COMM='Basic segment length (NDC)'
         WRITE(LUNOUT,10500) PZNAME,RBSL,0.01,COMM
         PZNAME='LWID '
         COMM='Line width'
         WRITE(LUNOUT,10500) PZNAME,RLWSC,1.,COMM
         PZNAME='MTYP '
         COMM='Marker type'
         WRITE(LUNOUT,10400) PZNAME,IMK,1,COMM
         PZNAME='MSCF '
         COMM='Marker scale factor'
         WRITE(LUNOUT,10500) PZNAME,RMKSC,1.,COMM
         PZNAME='PLCI '
         COMM='Polyline color index'
         WRITE(LUNOUT,10400) PZNAME,IPLCI,1,COMM
         PZNAME='PMCI '
         COMM='Polymarker color index'
         WRITE(LUNOUT,10400) PZNAME,IPMCI,1,COMM
         PZNAME='FACI '
         COMM='Fill area color index'
         WRITE(LUNOUT,10400) PZNAME,IFACI,1,COMM
         PZNAME='TXCI '
         COMM='Text color index'
         WRITE(LUNOUT,10400) PZNAME,ITXCI,1,COMM
         PZNAME='TXAL '
         COMM='Text alignment'
         WRITE(LUNOUT,10600) PZNAME,ITXALH,ITXALV,0,0,COMM
         PZNAME='CHHE '
         COMM='Character height'
         WRITE(LUNOUT,10500) PZNAME,RCHH,0.28,COMM
         PZNAME='TANG '
         COMM='Text angle'
         ANGLE=((ACOS(RCHUX/SQRT(RCHUX**2+RCHUY**2))*180.)
     +           /3.14159)-90.
         IF(RCHUY.LT.0)ANGLE=360.-ANGLE
         WRITE(LUNOUT,10500) PZNAME,ANGLE,0.,COMM
         PZNAME='TXFP '
         COMM='Text font and precision'
         WRITE(LUNOUT,10600) PZNAME,IFONT,IPREC,0,2,COMM
         PZNAME='PICT '
         COMM='Current automatic number'
         WRITE(LUNOUT,10400) PZNAME,IPICT,1,COMM
         PZNAME='BORD '
         COMM='Border flag'
         WRITE(LUNOUT,10400) PZNAME,IBORD,0,COMM
         PZNAME='PASS '
         COMM='Number of pass in IGTEXT'
         WRITE(LUNOUT,10400) PZNAME,INPASS,1,COMM
         PZNAME='CSHI '
         COMM='IGTEXT shift'
         WRITE(LUNOUT,10500) PZNAME,RCSHIF,0.02,COMM
         PZNAME='LASI '
         COMM='Label axis size'
         WRITE(LUNOUT,10500) PZNAME,RALH,0.018,COMM
         PZNAME='LAOF '
         COMM='Label axis offset'
         WRITE(LUNOUT,10500) PZNAME,RALD,0.013,COMM
         PZNAME='TMSI '
         COMM='Tick marks size'
         WRITE(LUNOUT,10500) PZNAME,RTMS,0.019,COMM
         PZNAME='AWLN '
         COMM='Axis wire lenght'
         WRITE(LUNOUT,10500) PZNAME,RAWL,0.,COMM
         PZNAME='BARO '
         COMM='Offset of IGHIST (IGRAPH) bars'
         WRITE(LUNOUT,10500) PZNAME,RBOF,0.25,COMM
         PZNAME='BARW '
         COMM='Width of IGHIST (IGRAPH) bars'
         WRITE(LUNOUT,10500) PZNAME,RBWD,0.5,COMM
         PZNAME='NCOL '
         COMM='Number of COLors'
         WRITE(LUNOUT,10400) PZNAME,INBCOL,8,COMM
         PZNAME='CLIP '
         COMM='Clipping mode'
         WRITE(LUNOUT,10400) PZNAME,ICLIP,1,COMM
         PZNAME='NLIN '
         COMM='Number of line for 3D shapes'
         WRITE(LUNOUT,10400) PZNAME,INLINE,40,COMM
         PZNAME='AURZ '
         COMM='Automatic saving flag'
         I=0
         IF(ASFLAG)I=1
         WRITE(LUNOUT,10400) PZNAME,I,0,COMM
         PZNAME='DIME '
         COMM='Dimension used (2D or 3D)'
         WRITE(LUNOUT,10400) PZNAME,IDIM,2,COMM
         PZNAME='ZBUF '
         COMM='Z-Buffer (1=on or 0=off)'
         WRITE(LUNOUT,10400) PZNAME,IZBUF,0,COMM
         WRITE(LUNOUT,10200)
         RETURN
      ENDIF
      CALL IGERR('Unavailable option','IGSET')
*
10000 FORMAT(1X,'|',24X,'IGSET : Current values in use',24X,'|')
10100 FORMAT(1X,'+',77(1H-),'+')
10200 FORMAT(1X,'+',13(1H-),'+',15(1H-),'+',15(1H-),'+',31(1H-),'+')
10300 FORMAT(1X,'|  Parameter  | Current value | Default value '
     +,      '|          Explanation          |')
10400 FORMAT(' |',4X,A,'   |',I8,'       | ',I8
     +,'      | ',A,'|')
10500 FORMAT(' |',4X,A,'   |   ',F9.3,'   |    ',F9.3
     +,'  | ',A,'|')
10600 FORMAT(' |',4X,A,'   |',I8,I3,'    | ',I8,I3
     +,'   | ',A,'|')
*
      END
+DECK,  IGSET1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

      REAL FUNCTION IGSET1(VALUE)
*.===========>
*.
*.   Underlaying for IGSET
*.
*. _Input parameters:
*.
*.  REAL VALUE : Parameter value .
*.
*..==========> (O.Couet)
      RVALUE=VALUE
      IGSET1=RVALUE
      IF(RVALUE.LT.0)THEN
         CALL IGERR('Warning: Negative value (ABS is taken)','IGSET')
         IGSET1=ABS(RVALUE)
      ENDIF
*
      END

+DECK,  IGSRAP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:38  mclareni
* Higz

      SUBROUTINE IGSRAP(R)
*.===========>
*.
*.   This routine allows to change the REDIT factor.
*.
*. _Input parameters:
*.
*.  REAL R : New REDIT factor (If R.GE.0)
*.
*. _Output parameters:
*.
*.  REAL R : Current REDIT factor (If R.LT.0)
*.
*..==========> (O.Couet)
+SELF, IF=KERNEL, IF=-BATCH.
+CDE, HIKERN.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=MAIL.
+CDE, HIFLAG.
+SELF.
+CDE, HIATT.
*.______________________________________
*
+SELF, IF=MAIL.
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,E16.7)') 558,R
         CALL IMWRIT(1)
         IF(R.LT.0)READ (5,'(E16.7)') R
         CALL IMWRIT(5)
         RETURN
      ENDIF
+SELF.
*
      IF(R.LT.0)THEN
         R=REDIT
         RETURN
      ELSE
         REDIT=R
         IF(REDIT.EQ.1.)REDIT=0.
      ENDIF
+SELF, IF=KERNEL, IF=-BATCH.
*
      DO 10 I=1,INOPWK
         WKSC(I)=REDIT
         IF(WKSC(I).LE.0)WKSC(I)=1.
         WKSC(I)=WKSC(I)*WKMAX(I)
+SELF, IF=X11.
         CALL IKUWK(ILOPWK(I))
+SELF, IF=KERNEL, IF=-BATCH.
   10 CONTINUE
+SELF.
*
      END
+DECK,  IGSSE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGSSE(ERRFIL,WTYPE)
*.===========>
*.
*.   This routine initializes the standart graphic package environment .
*.
*. _Input parameters:
*.
*.  INTEGER ERRFIL : Error file LUN .
*.  INTEGER WTYPE : Workstation type .
*.
*. The screen size is returned in IQUEST(11) and IQUEST(12) .
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIFLAG.
+CDE, HIATT.
+CDE, HIMETA.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=MSDOS.
+CDE, HIKERN.
+SELF, IF=DI3000.
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
      DIMENSION LIST(4)
      REAL MAXDIM(4)
      LOGICAL PHYS
+SELF.
      INTEGER ERRFIL,WKID,CONID,WTYPE
      LOGICAL ZFSAV
      DIMENSION RVAL(2)
*.______________________________________
*
+SELF, IF=MAIL.
*
*              Mail option
*
      IF((WTYPE.LT.0)   .AND.(WTYPE.NE.-111).AND.
     +   (WTYPE.NE.-112).AND.(WTYPE.NE.-113))THEN
         GFLAG=.FALSE.
         ZFLAG=.FALSE.
         PFLAG=.FALSE.
         MFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         WRITE (CHMAIL,'(I3,I5,I10)') 100,ERRFIL,-WTYPE
         CALL IMWRIT(1)
         READ (5,'(2E16.7)') RQUEST(11),RQUEST(12)
         CALL IMWRIT(5)
         RETURN
      ENDIF
+SELF.
*
      GFLAG =.TRUE.
      ZFSAV =ZFLAG
      ZFLAG =.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      IQUEST(100)=-1
+SELF, IF=ATCGKS.
      CALL KNOMSG
+SELF.
      IWTYPE=IABS(WTYPE)
      IF(IWTYPE.LE.0)TEKACT=.FALSE.
      IDTY=IWTYPE
+SELF, IF=DI3000.
      IDID=IWTYPE
      WKID=IWTYPE
+SELF, IF=-DI3000.
      WKID=1
+SELF.
      CALL IOPKS(ERRFIL)
+SELF, IF=DECGKS.
      CONID=0
+SELF, IF=KERNEL,FALCO,PHIGS,GKSBX.
      CONID=1
+SELF, IF=GKSGRAL,UNIGKS,PLOT10GKS,MGKS,ATCGKS, IF=-GKSIBM.
      CONID=1
+SELF, IF=GKSIBM.
      CONID=-1
+SELF, IF=GKSGRAL, IF=IBM.
      IF(WTYPE.LT.0)CONID=101
+SELF, IF=GKSGRAL, IF=ALLIANT.
      IF(WTYPE.GT.0)CONID=6
+SELF, IF=GKSGRAL, IF=NEWLIB.
      IF (WTYPE.GT.470000) THEN
          CONID=MOD(WTYPE,100)
          WTYPE=WTYPE/100
      ENDIF
      IF (WTYPE.EQ.7878) CONID=11
      IF (WTYPE.EQ.13001.OR.WTYPE.EQ.13002) CONID=101
      IWTYPE=WTYPE
      IDTY=IWTYPE
+SELF, IF=SUNGKS.
      IF(IWTYPE.EQ.3.OR.IWTYPE.EQ.6.OR.IWTYPE.EQ.7.OR.
     +   IWTYPE.EQ.8.OR.IWTYPE.EQ.10)CONID=9
      IF(IWTYPE.EQ.4)CONID=0
+SELF, IF=-DI3000.
      IF(IWTYPE.GT.0)THEN
         CALL IOPWK(WKID,CONID,IWTYPE)
         CALL IACWK(WKID)
         CALL IGQWK(WKID,'MXDS',RVAL)
         IF((RMDSX.LT.0).OR.(RMDSY.LT.0))THEN
            CALL IGERR('Invalid workstation type','IGSSE')
            RETURN
         ENDIF
      ENDIF
      RDVXMI=0.
      RDVYMI=0.
      RDVXMA=RMDSX
      RDVYMA=RMDSY
      IF(IWTYPE.GT.0)THEN
         GRFLAG=.TRUE.
         RQUEST(11)=RMDSX
         RQUEST(12)=RMDSY
+SELF, IF=MSDOS.
         ISTEP  = 4
         IXLOCO = 0
         IYLOCO = 0
         MOUSE  = .FALSE.
         IF(INIT_MOUSE().GT.0)MOUSE=.TRUE.
         RDWXMI = 0.0
         RDWYMI = 0.0
         IF(WINSIZ(3).GE.WINSIZ(4))THEN
            RDWXMA = 1.0
            RDWYMA = RMDSY/RMDSX
         ELSE
            RDWYMA = 1.0
            RDWXMA = RMDSX/RMDSY
         ENDIF
+SELF, IF=-DI3000.
         CALL ISWKWN(1,RDWXMI,RDWXMA,RDWYMI,RDWYMA)
         CALL ISWKVP(1,RDVXMI,RDVXMA,RDVYMI,RDVYMA)
      ENDIF
+SELF, IF=DI3000.
      CONID=1
      CALL IOPWK(WKID,CONID,IWTYPE)
      CALL IACWK(WKID)
*
*              Determine if the device is capable of physical sizing and
*              the physical size of the viewport
*
      IF (WKID.NE.0) THEN
         CALL JIQDIM(WKID,PHYS,MAXDIM)
         RDVXMI=MAXDIM(1)
         RDVXMA=MAXDIM(2)
         RDVYMI=MAXDIM(3)
         RDVYMA=MAXDIM(4)
      ELSE
         CALL JIQDEV(WKID,20,LIST)
         RDVXMI=FLOAT(LIST(1))
         RDVXMA=FLOAT(LIST(2))
         RDVYMI=FLOAT(LIST(3))
         RDVYMA=FLOAT(LIST(4))
      ENDIF
*
*              Set the orientation of the maximums returned since not all
*              devices refer to the lower left as x0phy, y0phy and upper right
*              as x1phy, y1phy.
*
      IF (RDVXMI.GT.RDVXMA) THEN
         TEMP=RDVXMI
         RDVXMI=RDVXMA
         RDVXMA=TEMP
      ENDIF
      IF (RDVYMI .GT. RDVYMA) THEN
         TEMP=RDVYMI
         RDVYMI=RDVYMA
         RDVYMA=TEMP
      ENDIF
*
*              Maximum display surface size
*
      RMDSX=RDVXMA-RDVXMI
      RMDSY=RDVYMA-RDVYMI
      GRFLAG=.TRUE.
      RQUEST(11)=RDVXMA
      RQUEST(12)=RDVYMA
*
      CALL JASPEK(WKID, RATIO)
      IF (RATIO .LE. 1.0) THEN
         RDWXMI=0.0
         RDWXMA=1.0
         RDWYMI=0.0
         RDWYMA=RATIO
      ELSE
         RDWXMI=0.0
         RDWXMA=1.0/RATIO
         RDWYMI=0.0
         RDWYMA=1.0
      ENDIF
      CALL ISWKWN(WKID,RDWXMI,RDWXMA,RDWYMI,RDWYMA)
      IF(WKID.NE.0)CALL ISWKVP(WKID,RDVXMI,RDVXMA,RDVYMI,RDVYMA)
*
      IF((RDVXMA.LE.0).OR.(RDVYMA.LE.0))THEN
         CALL IGERR('Bad workstation type','IGSSE')
         RETURN
      ENDIF
*
      CALL JDCOLR(0)
      CALL JDINTE(16383)
      CALL JDLSTY(0)
      CALL JDLWID(16383)
      CALL JDPEN(0)
      CALL JDPEDG(0)
      CALL JDPINT(0)
      CALL JDPIDX(0,0)
      IF(WKID.NE.0)CALL JPFSIM(WKID,1)
      CALL JDMARK(IMK)
      CALL JWCLIP(ICLIP.EQ.1)
+SELF, IF=GKS.
*
      CALL GSCHH(RCHH)
      CALL GSCHUP(RCHUX,RCHUY)
      CALL GSTXAL(ITXALH,ITXALV)
      CALL GSFAIS(IFAIS)
      CALL GSMK(IMK)
      CALL GSLN(ILN)
      CALL GSLWSC(RLWSC)
      CALL GSPLCI(IPLCI)
      CALL GSPMCI(IPMCI)
      CALL GSFACI(IFACI)
      CALL GSTXCI(ITXCI)
      CALL GSCLIP(ICLIP)
+SELF, IF=GKS, IF=-MGKS.
      CALL GSFASI(IFASI)
      CALL GSMKSC(RMKSC)
+SELF, IF=KERNEL,SUNGKS,GKSBX.
*
*              Initialize the begining of the color table
*
      GRFLAG=.FALSE.
      IF(IWTYPE.GT.0)THEN
         CALL IGSG(1)
         CALL ISCR(WKID,0,1.,1.,1.)
         CALL ISCR(WKID,1,0.,0.,0.)
         CALL ISCR(WKID,2,1.,0.,0.)
         CALL ISCR(WKID,3,0.,1.,0.)
         CALL ISCR(WKID,4,0.,0.,1.)
         CALL ISCR(WKID,5,1.,1.,0.)
         CALL ISCR(WKID,6,1.,0.,1.)
         CALL ISCR(WKID,7,0.,1.,1.)
+SELF, IF=MSDOS.
         CALL ISCR(WKID, 7,0.0,0.0,0.0)
         CALL ISCR(WKID, 8,0.5,0.5,0.5)
         CALL ISCR(WKID, 9,0.0,0.5,0.5)
         CALL ISCR(WKID,10,0.5,0.0,0.0)
         CALL ISCR(WKID,11,0.0,0.5,0.0)
         CALL ISCR(WKID,12,0.0,0.0,0.5)
         CALL ISCR(WKID,13,0.5,0.5,0.0)
         CALL ISCR(WKID,14,1.0,0.0,0.5)
         CALL ISCR(WKID,15,0.0,1.0,1.0)
+SELF, IF=KERNEL,SUNGKS,GKSBX.
      ENDIF
+SELF.
      ZFLAG =ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGSTR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGSTR(ISTID,CHOPT)
*.===========>
*.
*.  This routine allows to manage PHIGS structures. If HIGZ
*. is build without PHIGS, it just do nothing.
*.
*. _Input parameters:
*.
*.  INTEGER IST : Structure identifier
*.  CHARACTER CHOPT : Option
*.
*.      'O' open structure ISTID
*.      'N' open structure with name set
*.      'C' close structure
*.      'E' append structure ISTID in the current opened structure
*.      'D' delete all structures
*.      'P' post the structure on the active workstations
*.
*..==========> (O.Couet)
      CHARACTER*(*) CHOPT
+SELF, IF=PHIGS.
+CDE, HIATT.
+CDE, HIPHIG.
      DIMENSION IOPT(6)
      EQUIVALENCE (IOPTO,IOPT(1)),(IOPTN,IOPT(2))
      EQUIVALENCE (IOPTC,IOPT(3)),(IOPTE,IOPT(4))
      EQUIVALENCE (IOPTD,IOPT(5)),(IOPTP,IOPT(6))
      COMMON /NAMESET/ NSNO
*.______________________________________
*
      CALL UOPTC(CHOPT,'ONCEDP',IOPT)
*
      IF(IDIM.NE.3)RETURN
*
*              Open a new structure ISTID
*
      IF(IOPTO.NE.0)THEN
         CALL POPST(ISTID)
         LOSTOP=.TRUE.
      ENDIF
*
*              Close the current opened structure (ISTID not used)
*
      IF(IOPTC.NE.0)THEN
         CALL PCLST
         LOSTOP=.FALSE.
      ENDIF
*
*              Extend the current opened structure with the stucture ISTID
*
      IF (IOPTE.NE.0) THEN
         CALL PEXST(ISTID)
      ENDIF
*
*              Open structure with name set
*
      IF (IOPTN.NE.0) THEN
         CALL POPST(ISTID)
         CALL PADS(1,NSNO)
         NSNO=NSNO+1
         LOSTOP=.TRUE.
      ENDIF
*
*              Post structure
*
      IF(IOPTP.NE.0)THEN
         DO 10 I=1,INOPWK
            IF(IGIWTY(ILOPWK(I)).GT.0.AND.ACWKFL(I))THEN
               CALL PPOST(ILOPWK(I),ISTID,1.)
            ENDIF
   10    CONTINUE
      ENDIF
*
*              Delete all structures
*
      IF(IOPTD.NE.0)THEN
         CALL PDAS
         LOSTEX=.FALSE.
      ENDIF
*
+SELF.
      END
+DECK,  IGSVIE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGSVIE
*.===========>
*.
*.   This routine computes the 3D transformation according to
*. the current 3D window and viewport. This routine is called
*. by ISELNT.
*.
*..==========> (O.Couet)
+CDE, HI3D.
+CDE, HCTNOR.
+SELF, IF=ZBUF.
+CDE, HIATT.
+SELF.
      DIMENSION RMIN(3),RMAX(3)
*.______________________________________
*
+SELF, IF=ZBUF.
+CDE, HIWCDC.
+SELF.
      CALL IGNG3D(W3X1,W3X2,W3Y1,W3Y2,W3Z1,W3Z2
     +,           PHI,THETA,PSI
     +,           V3X1,V3X2,V3Y1,V3Y2)
      RMIN(1) = W3X1
      RMIN(2) = W3Y1
      RMIN(3) = W3Z1
      RMAX(1) = W3X2
      RMAX(2) = W3Y2
      RMAX(3) = W3Z2
+SELF, IF=ZBUF.
      IF (IZBUF.NE.0) THEN
         IWKNB=1
         IZX = IXWCDC(V3X2)-IXWCDC(V3X1)
         IZY = IYWCDC(V3Y1)-IYWCDC(V3Y2)
         IZZ = MAX(IZX,IZY)
         CALL IHZINI(IZX,IZY,IZZ)
         CALL IHZWRD(V3X1,V3Y1,-1.,V3X2,V3Y2,1.)
         IFIRST = 1
      ENDIF
+SELF.
      CALL IHSVIE(RMIN,RMAX,PHI,THETA,PSI,IREP)
      COEFX   = (V3X2-V3X1)/2.
      AWNX    = COEFX*TNORM(1,1)
      BWNX    = COEFX*TNORM(2,1)
      CWNX    = COEFX*TNORM(3,1)
      DWNX    = COEFX+TNORM(4,1)+V3X1
      COEFY   = (V3Y2-V3Y1)/2.
      AWNY    = COEFY*TNORM(1,2)
      BWNY    = COEFY*TNORM(2,2)
      CWNY    = COEFY*TNORM(3,2)
      DWNY    = COEFY+TNORM(4,2)+V3Y1
      AWNZ    = TNORM(1,3)
      BWNZ    = TNORM(2,3)
      CWNZ    = TNORM(3,3)
      DWNZ    = TNORM(4,3)
*
      END
+DECK,  IGTAB1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      INTEGER FUNCTION IGTAB1(ELEV1,ICONT1,X1,Y1,ELEV2,ICONT2,X2,Y2
     +,                       XARR,YARR,ITARR,NCONT)
*.===========>
*.
*. Fill the matrix XARR YARR for Contour Plot
*.
*..==========> (O.Couet)
+CDE, HICONT.
      DIMENSION XARR(*),YARR(*),ITARR(*)
      LOGICAL VERT
*.______________________________________
*
      IF(X1.EQ.X2)THEN
         VERT=.TRUE.
         TLEN=Y2-Y1
      ELSE
         VERT=.FALSE.
         TLEN=X2-X1
      ENDIF
*
      N=ICONT1+1
      TDIF=ELEV2-ELEV1
      I=1
      ICOUNT=0
   10 IF(N.GT.ICONT2.OR.I.GT.102)GOTO 20
      ELEV=N*DZ/NCONT +ZMIN
      DIFF=ELEV-ELEV1
      PDIF=DIFF/TDIF
      XLEN=TLEN*PDIF
      IF(VERT)THEN
         XARR(I)=X1
         YARR(I)=Y1+XLEN
      ELSE
         XARR(I)=X1+XLEN
         YARR(I)=Y1
      ENDIF
      ITARR(I)=N
      ICOUNT=ICOUNT+1
      I=I+2
      N=N+1
      GOTO 10
   20 IGTAB1=ICOUNT
*
      END
+DECK,  IGTAB2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGTAB2(IA,IB,F,T)
+CDE, HIPACK.
+CDE, HIHID.
+CDE, HICONT.
      DIMENSION F(3,4),T(4),IXADD(4),IYADD(4)
      REAL IGCELL
      DATA IXADD /0,1,1,0/
      DATA IYADD /0,0,1,1/
*
      IXT   = IA+IXFCHA(1)-1
      IYT   = IB+IYFCHA(1)-1
*
      XSTP2 = XSTP/2.
      YSTP2 = YSTP/2.
      IF(ILOGX.NE.0)THEN
         XLAB1L  = LOG10(XLAB1)
         XLAB2L  = LOG10(XLAB2)
         XVAL1L  = LOG10(XVAL1)
         XVAL2L  = LOG10(XVAL2)
      ELSE
         XLAB1L  = XLAB1
         XLAB2L  = XLAB2
         XVAL1L  = XVAL1
         XVAL2L  = XVAL2
      ENDIF
      IF(ILOGY.NE.0)THEN
         YLAB1L  = LOG10(YLAB1)
         YLAB2L  = LOG10(YLAB2)
         YVAL1L  = LOG10(YVAL1)
         YVAL2L  = LOG10(YVAL2)
      ELSE
         YLAB1L  = YLAB1
         YLAB2L  = YLAB2
         YVAL1L  = YVAL1
         YVAL2L  = YVAL2
      ENDIF
*
      DO 10 I=1,4
         IXA = IXADD(I)
         IYA = IYADD(I)
*
*              Compute the cell position in cartesian coordinates
*              and compute the LOG if necessary
*
         F(1,I) = XLAB1+XSTP2+FLOAT(IA-1+IXA)*XSTP
         F(2,I) = YLAB1+YSTP2+FLOAT(IB-1+IYA)*YSTP
         IF(ILOGX.NE.0)THEN
            F(1,I) = LOG10(F(1,I))
         ENDIF
         IF(ILOGY.NE.0)THEN
            F(2,I) = LOG10(F(2,I))
         ENDIF
*
*              Transform the cell position in the required coordinate system
*
         IF(ISYS.EQ.2)THEN
            F(1,I) = 360.*(F(1,I)-XVAL1L)/(XVAL2L-XVAL1L)
            F(2,I) = (F(2,I)-YLAB1L)/(YLAB2L-YLAB1L)
         ELSEIF(ISYS.EQ.3)THEN
            F(1,I) = 360.*(F(1,I)-XVAL1L)/(XVAL2L-XVAL1L)
         ELSEIF(ISYS.EQ.4)THEN
            F(1,I) = 360.*(F(1,I)-XVAL1L)/(XVAL2L-XVAL1L)
            F(2,I) = 180.*(F(2,I)-YVAL1L)/(YVAL2L-YVAL1L)
         ELSEIF(ISYS.EQ.5)THEN
            F(1,I) = 360.*(F(1,I)-XVAL1L)/(XVAL2L-XVAL1L)
            F(2,I) = (180.-2.*DANG)*(F(2,I)-YVAL1L)/(YVAL2L-YVAL1L)+DANG
         ENDIF
*
*              Get the content of the table. If the X index (ICX) is
*              greater than the X size of the table (NCX), that's mean
*              IGTABL tried to close the surface and in this case the
*              first channel should be used.
*
         ICX               = IXT+IXA
         IF(ICX.GT.NCX)ICX = 1
         IF(IPACK.NE.0)THEN
            F(3,I) = IGCELL(NCX,NCY,REFWRD(1),ICX,IYT+IYA,1)
         ELSE
            F(3,I) = IGCELL(NCX,NCY,REFWRD(IADRES(1)+1),ICX,IYT+IYA,1)
         ENDIF
*
*              The colors on the surface can represent the content or
*              the errors.
*
         IF (IOPTER.NE.0) THEN
            IF(IPACK.NE.0)THEN
               T(I) = IGCELL(NCX,NCY,REFWRD(1),ICX,IYT+IYA,2)
            ELSE
               T(I) = IGCELL(NCX,NCY,REFWRD(IADRES(1)+1),ICX,IYT+IYA,2)
            ENDIF
         ELSE
            T(I) = F(3,I)
         ENDIF
   10 CONTINUE
*
*              LOGZ is required...
*
      IF(IDRGR.EQ.3)THEN
         DO 20 I=1,4
            IF(ILOG.NE.0.AND.ZMAXST.GT.0.)THEN
               F(3,I) = LOG10(ZMAXST)
            ELSE
               F(3,I) = ZMAXST
            ENDIF
   20    CONTINUE
      ENDIF
*
      IF(ISYS.GE.3)THEN
         DO 30 I=1,4
            F(3,I) = ((1.-RINRAD)*((F(3,I)-ZMIN)/(ZMAX-ZMIN)))+RINRAD
   30    CONTINUE
      ENDIF
*
      END
+DECK,  IGTAB3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGTAB3(IA,IB,NV,AB,VV,T)
+CDE, HIPACK.
+CDE, HICONT.
+CDE, HIHID.
      DIMENSION AB(2,4),VV(*),T(4,*)
      REAL IGCELL
*
      IXT = IA+IXFCHA(1)-1
      IYT = IB+IYFCHA(1)-1
*
*              Compute the cell position in cartesian coordinates
*              and compute the LOG if necessary
*
      AB(1,1) = XLAB1+(FLOAT(IA)-1.+RLEGBO)*XSTP
      AB(1,2) = AB(1,1)+XSTP*RLEGBW
      AB(2,1) = YLAB1+(FLOAT(IB)-1.+RLEGBO)*YSTP
      AB(2,3) = AB(2,1)+YSTP*RLEGBW
      IF(ILOGX.NE.0)THEN
         AB(1,1) = LOG10(AB(1,1))
         AB(1,2) = LOG10(AB(1,2))
         XLAB1L  = LOG10(XLAB1)
         XLAB2L  = LOG10(XLAB2)
         XVAL1L  = LOG10(XVAL1)
         XVAL2L  = LOG10(XVAL2)
      ELSE
         XLAB1L  = XLAB1
         XLAB2L  = XLAB2
         XVAL1L  = XVAL1
         XVAL2L  = XVAL2
      ENDIF
      IF(ILOGY.NE.0)THEN
         AB(2,1) = LOG10(AB(2,1))
         AB(2,3) = LOG10(AB(2,3))
         YLAB1L  = LOG10(YLAB1)
         YLAB2L  = LOG10(YLAB2)
         YVAL1L  = LOG10(YVAL1)
         YVAL2L  = LOG10(YVAL2)
      ELSE
         YLAB1L  = YLAB1
         YLAB2L  = YLAB2
         YVAL1L  = YVAL1
         YVAL2L  = YVAL2
      ENDIF
*
*              Transform the cell position in the required coordinate system
*
      IF(ISYS.EQ.2)THEN
         AB(1,1) = 360.*(AB(1,1)-XVAL1L)/(XVAL2L-XVAL1L)
         AB(1,2) = 360.*(AB(1,2)-XVAL1L)/(XVAL2L-XVAL1L)
         AB(2,1) = (AB(2,1)-YLAB1L)/(YLAB2L-YLAB1L)
         AB(2,3) = (AB(2,3)-YLAB1L)/(YLAB2L-YLAB1L)
      ELSEIF(ISYS.EQ.3)THEN
         AB(1,1) = 360.*(AB(1,1)-XVAL1L)/(XVAL2L-XVAL1L)
         AB(1,2) = 360.*(AB(1,2)-XVAL1L)/(XVAL2L-XVAL1L)
      ELSEIF(ISYS.EQ.4)THEN
         AB(1,1) = 360.*(AB(1,1)-XVAL1L)/(XVAL2L-XVAL1L)
         AB(1,2) = 360.*(AB(1,2)-XVAL1L)/(XVAL2L-XVAL1L)
         AB(2,1) = 180.*(AB(2,1)-YVAL1L)/(YVAL2L-YVAL1L)
         AB(2,3) = 180.*(AB(2,3)-YVAL1L)/(YVAL2L-YVAL1L)
      ELSEIF(ISYS.EQ.5)THEN
         AB(1,1) = 360.*(AB(1,1)-XVAL1L)/(XVAL2L-XVAL1L)
         AB(1,2) = 360.*(AB(1,2)-XVAL1L)/(XVAL2L-XVAL1L)
         AB(2,1) = (180.-2.*DANG)*(AB(2,1)-YVAL1L)/(YVAL2L-YVAL1L)+DANG
         AB(2,3) = (180.-2.*DANG)*(AB(2,3)-YVAL1L)/(YVAL2L-YVAL1L)+DANG
      ENDIF
*
*              Complete the cell coordinates
*
      AB(2,2) = AB(2,1)
      AB(1,3) = AB(1,2)
      AB(1,4) = AB(1,1)
      AB(2,4) = AB(2,3)
*
*              Get the content of the table, and loop on the
*              stack if necessary.
*
      IL=ILOG
      ILOG=0
      VV(1)=ZMIN
      IF(IPACK.NE.0)THEN
         VV(2)=IGCELL(NCX,NCY,REFWRD(1),IXT,IYT,1)
      ELSE
         VV(2)=IGCELL(NCX,NCY,REFWRD(IADRES(1)+1),IXT,IYT,1)
      ENDIF
      IF(NIDS.NE.0)THEN
         DO 10 I=2,NIDS+1
            IXT=IA+IXFCHA(I)-1
            IYT=IB+IYFCHA(I)-1
            IF(IPACK.NE.0)THEN
               VV(I+1)=IGCELL(NCX,NCY,REFWRD(I),IXT,IYT,1)+VV(I)
            ELSE
               VV(I+1)=IGCELL(NCX,NCY,REFWRD(IADRES(I)+1),IXT,IYT,1)
     +                       +VV(I)
            ENDIF
            VV(I+1)=MAX(ZMIN,VV(I+1))
   10    CONTINUE
      ENDIF
*
      NV=NIDS+2
      ILOG=IL
      DO 20  I=2,NV
         IF(ILOG.NE.0)THEN
            VV(I)=MAX(ZMIN,LOG10(VV(I)))
         ELSE
            VV(I)=MAX(ZMIN,VV(I))
         ENDIF
   20 CONTINUE
*
      IF(ILOG.EQ.0)THEN
   30    I=3
   40    IF(I.LE.NV)THEN
            IF(VV(I).LT.VV(I-1))THEN
               VV(I-1)=VV(I)
               GOTO 30
            ENDIF
            I=I+1
            GOTO 40
         ENDIF
      ENDIF
*
*              For cylindrical, spherical and pseudo-rapidity, the content
*              is mapped onto the radius
*
      IF(ISYS.GE.3)THEN
         DO 50  I=1,NV
            VV(I)=((1.-RINRAD)*((VV(I)-ZMIN)/(ZMAX-ZMIN)))+RINRAD
   50    CONTINUE
      ENDIF
*
      DO 70 I=1,NV
         DO 60 J=1,4
            T(J,I)=VV(I)
   60    CONTINUE
   70 CONTINUE
*
      END
+DECK,  IGTAB4, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGTAB4(RMIN,RMAX,RBACK)
*.===========>
*.
*.  Set the correct window size for lego and surface plots.
*   And draw the background if necessary.
*.
*. _Input parameters:
*.
*.  REAL RMIN(3), RMAX(3) : 3D coordinates of the box.
*.  REAL RBACK : Background colour
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HCTNOR.
+CDE, HIGRAF.
      DIMENSION RMIN(*),RMAX(*)
      DIMENSION SMAX(2)
*.______________________________________
*
      DO 20 I=1,2
         SMAX(I) = TNORM(4,I)
         DO 10 K=1,3
            IF (TNORM(K,I) .LT. 0.) THEN
               SMAX(I) = SMAX(I) + TNORM(K,I)*RMIN(K)
            ELSE
               SMAX(I) = SMAX(I) + TNORM(K,I)*RMAX(K)
            ENDIF
   10    CONTINUE
   20 CONTINUE
      CALL ISWN(INTR,-SMAX(1),SMAX(1),-SMAX(2),SMAX(2))
      CALL ISELNT(INTR)
*
*              Draw the background if necessary
*
      IF(RBACK.GE.1000.)THEN
         R1=-1.
         R2=-1.
         R3=-1.
         XGRAF(2)=-SMAX(1)
         XGRAF(3)=-SMAX(1)
         XGRAF(5)=+SMAX(1)
         XGRAF(6)=+SMAX(1)
         YGRAF(1)=-SMAX(2)
         YGRAF(4)=+SMAX(2)
         YGRAF(2)=+SMAX(2)
         YGRAF(3)=-SMAX(2)
         YGRAF(6)=+SMAX(2)
         YGRAF(5)=-SMAX(2)
         DO 30 I=1,8
            X=((1.-R1)*RMIN(1)+(R1+1.)*RMAX(1))/2.
            Y=((1.-R2)*RMIN(2)+(R2+1.)*RMAX(2))/2.
            Z=((1.-R3)*RMIN(3)+(R3+1.)*RMAX(3))/2.
            XX=TNORM(1,1)*X+TNORM(2,1)*Y+TNORM(3,1)*Z+TNORM(4,1)
            YY=TNORM(1,2)*X+TNORM(2,2)*Y+TNORM(3,2)*Z+TNORM(4,2)
            IF(ABS(XX-XGRAF(2)).LE.0.0001)THEN
               IF(YGRAF(2).GE.YY)YGRAF(2)=YY
               IF(YGRAF(3).LE.YY)YGRAF(3)=YY
            ENDIF
            IF(ABS(XX-XGRAF(6)).LE.0.0001)THEN
               IF(YGRAF(6).GE.YY)YGRAF(6)=YY
               IF(YGRAF(5).LE.YY)YGRAF(5)=YY
            ENDIF
            IF(ABS(YY-YGRAF(1)).LE.0.0001)XGRAF(1)=XX
            IF(ABS(YY-YGRAF(4)).LE.0.0001)XGRAF(4)=XX
            R1=-R1
            IF(MOD(I,2).EQ.0)R2=-R2
            IF(I.GE.4)R3=1
   30    CONTINUE
*
         IFACS = IFACI
         CALL ISFAIS(1)
         ICOL=INT(RBACK-100.*FLOAT(INT(RBACK/100.)))
         CALL ISFACI(ICOL)
         CALL IFA(6,XGRAF,YGRAF)
         CALL ISFACI(IFACS)
      ENDIF
*
      END
+DECK,  IGTAB5, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGTAB5(RMIN,RMAX,ANG,PAR)
*.===========>
*.
*.  Draw the axis for lego and surface plots.
*.
*. _Input parameters:
*.
*.   REAL RMIN(3) : MIN axis labels
*.   REAL RMAX(3) : MAX axis labels
*.   REAL ANG : Angle between X and Y axis
*.   REAL PAR(14) : Axis Parameters
*.                      PAR(1)  =  NDVX
*.                      PAR(2)  =  NDVY
*.                      PAR(3)  =  NDVZ
*.                      PAR(4)  =  XCOL
*.                      PAR(5)  =  YCOL
*.                      PAR(6)  =  ZCOL
*.                      PAR(7)  =  XTIC
*.                      PAR(8)  =  YTIC
*.                      PAR(9)  =  ZTIC
*.                      PAR(10) =  VSIZ
*.                      PAR(11) =  VFON
*.                      PAR(12) =  XVAL
*.                      PAR(13) =  YVAL
*.                      PAR(14) =  ZVAL
*.                      PAR(15) =  XLOG
*.                      PAR(16) =  YLOG
*.                      PAR(17) =  ZLOG
*.
*.   After a call to this routine, the axis position are returned
*.   in RQUEST(70-81).
*.
*..==========> (O.Couet)
+CDE, HIPACK.
+CDE, HIHID.
+CDE, HIATT.
+CDE, HIQUES.
+CDE, HIATNB.
+CDE, HISAVE.
      DIMENSION PAR(*)
      CHARACTER*8       CHOPAX,CHOPAY,CHOPAZ
      REAL              RMIN(3),RMAX(3),AV(3,8),R(3,8)
      REAL              X1(3),X2(3),Y1(3),Y2(3),Z1(3),Z2(3)
      DOUBLE PRECISION  RAD,COSA,SINA
      DATA EPSIL /0.001/
*.______________________________________
*
      IF(ISYS.GT.1)RETURN
*
      RAD    = ATAN(1.D0)*4./180.
      COSA   = COS(ANG*RAD)
      SINA   = SIN(ANG*RAD)
      CALL IHAXIV(RMIN,RMAX,ANG,AV,IX1,IX2,IY1,IY2,IZ1,IZ2)
      DO 10 I=1,8
         R(1,I) = AV(1,I) + AV(2,I)*COSA
         R(2,I) = AV(2,I)*SINA
         R(3,I) = AV(3,I)
   10 CONTINUE
      CALL IHWTON(R(1,IX1),X1)
      CALL IHWTON(R(1,IX2),X2)
      CALL IHWTON(R(1,IY1),Y1)
      CALL IHWTON(R(1,IY2),Y2)
      CALL IHWTON(R(1,IZ1),Z1)
      CALL IHWTON(R(1,IZ2),Z2)
*
*              Initialize the axis options
*
      IF(X1(1).GT.X2(1))THEN
         CHOPAX = 'SDHV=+'
      ELSE
         CHOPAX = 'SDHV=-'
      ENDIF
      IF(Y1(1).GT.Y2(1))THEN
         CHOPAY = 'SDHV=+'
      ELSE
         CHOPAY = 'SDHV=-'
      ENDIF
      CHOPAZ = 'SDH+='
*
*              Option LOG is required ?
*
      IF(PAR(15).NE.0.)CHOPAX(8:8) = 'G'
      IF(PAR(16).NE.0.)CHOPAY(8:8) = 'G'
      IF(PAR(17).NE.0.)CHOPAZ(8:8) = 'G'
*
*              Initialize the number of division. If the
*              number of divisions is negative, option 'N'
*              is required.
*
      NDIVX = INT(PAR(1)+0.1)
      NDIVY = INT(PAR(2)+0.1)
      NDIVZ = INT(PAR(3)+0.1)
      IF(NDIVX.LT.0)THEN
         NDIVX       = ABS(NDIVX)
         CHOPAX(7:7) = 'N'
      ENDIF
      IF(NDIVY.LT.0)THEN
         NDIVY       = ABS(NDIVY)
         CHOPAY(7:7) = 'N'
      ENDIF
      IF(NDIVZ.LT.0)THEN
         NDIVZ       = ABS(NDIVZ)
         CHOPAZ(7:7) = 'N'
      ENDIF
*
*              Axis attributes setting
*              The variables SCALE allows to rescale the VSIZ
*              in order to have the same label size for all angles.
*
      SCALEX = (RWXMAX-RWXMIN)/2.
      SCALEY = (RWYMAX-RWYMIN)/2.
      CALL IGSET('LWID',1.)
      CALL IGSET('PLCI',1.)
      CALL IGSET('TXFP',PAR(11))
      CALL IGSET('LASI',PAR(10)*SCALEY)
*
*              X axis drawing
*
      IF(ABS(X1(1)-X2(1)).GE.EPSIL.OR.ABS(X1(2)-X2(2)).GT.EPSIL)THEN
         CALL IGSET('TXCI',PAR(4)+0.1)
         CALL IGSET('TMSI',PAR(7)*SCALEY)
         CALL IGSET('LAOF',PAR(13)*SCALEY)
         IF(PAR(15).NE.0.)THEN
            BMIN=10**RMIN(1)
            BMAX=10**RMAX(1)
         ELSE
            BMIN=RMIN(1)
            BMAX=RMAX(1)
         ENDIF
         CALL IGAXIS(X1(1),X2(1),X1(2),X2(2),BMIN,BMAX,NDIVX,CHOPAX)
         RQUEST(70) = ((WNVPSV(2)-WNVPSV(1))/(RWXMAX-RWXMIN))
     +                *(X1(1)-RWXMIN)+WNVPSV(1)
         RQUEST(71) = ((WNVPSV(2)-WNVPSV(1))/(RWXMAX-RWXMIN))
     +                *(X2(1)-RWXMIN)+WNVPSV(1)
         RQUEST(72) = ((WNVPSV(4)-WNVPSV(3))/(RWYMAX-RWYMIN))
     +                *(X1(2)-RWYMIN)+WNVPSV(3)
         RQUEST(73) = ((WNVPSV(4)-WNVPSV(3))/(RWYMAX-RWYMIN))
     +                *(X2(2)-RWYMIN)+WNVPSV(3)
      ENDIF
*
*              Y axis drawing
*
      IF(ABS(Y1(1)-Y2(1)).GE.EPSIL.OR.ABS(Y1(2)-Y2(2)).GT.EPSIL)THEN
         CALL IGSET('TXCI',PAR(5)+0.1)
         CALL IGSET('TMSI',PAR(8)*SCALEY)
         CALL IGSET('LAOF',PAR(12)*SCALEY)
         IF(ABS(Z1(1)-Z2(1)).LT.EPSIL.AND. ABS(Z1(2)-Z2(2)).LT.EPSIL)
     +   CHOPAY='SDH+=N'
         IF(IDIM1.NE.0)THEN
            CHOPAY='V=+UN'
            NDIVY=0
         ENDIF
         IF(ABS(Y1(1)-Y2(1)).LT.EPSIL)THEN
            Y2(1)=Y1(1)
            CALL IGSET('LAOF',PAR(14))
         ENDIF
         IF(PAR(16).NE.0.)THEN
            BMIN=10**RMIN(2)
            BMAX=10**RMAX(2)
         ELSE
            BMIN=RMIN(2)
            BMAX=RMAX(2)
         ENDIF
         CALL IGAXIS(Y1(1),Y2(1),Y1(2),Y2(2),BMIN,BMAX,NDIVY,CHOPAY)
         RQUEST(74) = ((WNVPSV(2)-WNVPSV(1))/(RWXMAX-RWXMIN))
     +                *(Y1(1)-RWXMIN)+WNVPSV(1)
         RQUEST(75) = ((WNVPSV(2)-WNVPSV(1))/(RWXMAX-RWXMIN))
     +                *(Y2(1)-RWXMIN)+WNVPSV(1)
         RQUEST(76) = ((WNVPSV(4)-WNVPSV(3))/(RWYMAX-RWYMIN))
     +                *(Y1(2)-RWYMIN)+WNVPSV(3)
         RQUEST(77) = ((WNVPSV(4)-WNVPSV(3))/(RWYMAX-RWYMIN))
     +                *(Y2(2)-RWYMIN)+WNVPSV(3)
      ENDIF
*
*              Z axis drawing
*
      IF(ABS(Z1(1)-Z2(1)).GE.EPSIL.OR.ABS(Z1(2)-Z2(2)).GT.EPSIL)THEN
         CALL IGSET('TXCI',PAR(5)+0.1)
         CALL IGSET('TMSI',PAR(9)*SCALEX)
         CALL IGSET('LAOF',PAR(14)*SCALEX)
         IF(PAR(17).NE.0.)THEN
            BMIN=10**RMIN(3)
            BMAX=10**RMAX(3)
         ELSE
            BMIN=RMIN(3)
            BMAX=RMAX(3)
         ENDIF
         CALL IGAXIS(Z1(1),Z2(1),Z1(2),Z2(2),BMIN,BMAX,NDIVZ,CHOPAZ)
         RQUEST(78) = ((WNVPSV(2)-WNVPSV(1))/(RWXMAX-RWXMIN))
     +                *(Z1(1)-RWXMIN)+WNVPSV(1)
         RQUEST(79) = ((WNVPSV(2)-WNVPSV(1))/(RWXMAX-RWXMIN))
     +                *(Z2(1)-RWXMIN)+WNVPSV(1)
         RQUEST(80) = ((WNVPSV(4)-WNVPSV(3))/(RWYMAX-RWYMIN))
     +                *(Z1(2)-RWYMIN)+WNVPSV(3)
         RQUEST(81) = ((WNVPSV(4)-WNVPSV(3))/(RWYMAX-RWYMIN))
     +                *(Z2(2)-RWYMIN)+WNVPSV(3)
      ENDIF
*
      CALL ISLN(1)
      END
+DECK,  IGTAB6, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGTAB6(IX,IY,FACE,T)
************************************************************************
*                                                                      *
*     Function: Find part of surface with luminosity in the corners    *
*               This routine is used for Gouraud shading               *
*                                                                      *
************************************************************************
+CDE, HIPACK.
+CDE, HIHID.
      REAL      FACE(3,4),T(4)
      REAL      F(3,4,3,3),X(4,3,3),Y(4,3,3),Z(4,3,3)
      REAL      AN(3,3,3),BN(3,2,2)
      INTEGER   INCRX(3),INCRY(3)
*-
      IPHI = 1
      RAD  = ATAN(1.)*4./180.
*
**          Find real cell indexes
*
      IXT = IX + IXFCHA(1) - 1
      IYT = IY + IYFCHA(1) - 1
*
**          Find increments of neighboring cells
*
      INCRX(1) =-1
      INCRX(2) = 0
      INCRX(3) =+1
      IF (IXT .EQ. 1)           INCRX(1) = 0
      IF (IXT .EQ. NCX-1)       INCRX(3) = 0
      INCRY(1) =-1
      INCRY(2) = 0
      INCRY(3) =+1
      IF (IYT .EQ. 1)           INCRY(1) = 0
      IF (IYT .EQ. NCY-1)       INCRY(3) = 0
*
**          Find neighboring faces
*
      DO 120 J=1,3
        DO 110 I=1,3
          CALL IGTAB2(IX+INCRX(I),IY+INCRY(J),F(1,1,I,J),T)
  110   CONTINUE
  120 CONTINUE
*
**         Set face
*
      DO 220 K=1,4
        DO 210 I=1,3
          FACE(I,K) = F(I,K,2,2)
  210   CONTINUE
  220 CONTINUE
*
**         Find coordinates and normales
*
      DO 330 J=1,3
        DO 320 I=1,3
          DO 310 K=1,4
* Polar
            IF (ISYS.EQ.2) THEN
              PHI      = F(IPHI,K,I,J)*RAD
              R        = F(3-IPHI,K,I,J)
              X(K,I,J) = R*COS(PHI)
              Y(K,I,J) = R*SIN(PHI)
              Z(K,I,J) = F(3,K,I,J)
* Cylindrical
            ELSE IF (ISYS.EQ.3) THEN
              PHI      = F(IPHI,K,I,J)*RAD
              R        = F(3,K,I,J)
              X(K,I,J) = R*COS(PHI)
              Y(K,I,J) = R*SIN(PHI)
              Z(K,I,J) = F(3-IPHI,K,I,J)
* Spherial
            ELSE IF (ISYS.EQ.4) THEN
              PHI      = F(IPHI,K,I,J)*RAD
              TH       = F(3-IPHI,K,I,J)*RAD
              R        = F(3,K,I,J)
              X(K,I,J) = R*SIN(TH)*COS(PHI)
              Y(K,I,J) = R*SIN(TH)*SIN(PHI)
              Z(K,I,J) = R*COS(TH)
* Pseudo ..
            ELSE IF (ISYS.EQ.5) THEN
              PHI      = F(IPHI,K,I,J)*RAD
              TH       = F(3-IPHI,K,I,J)*RAD
              R        = F(3,K,I,J)
              X(K,I,J) = R*COS(PHI)
              Y(K,I,J) = R*SIN(PHI)
              Z(K,I,J) = R*COS(TH)/SIN(TH)
* Carthesian
            ELSE
              X(K,I,J) = F(1,K,I,J)
              Y(K,I,J) = F(2,K,I,J)
              Z(K,I,J) = F(3,K,I,J)
            END IF
  310     CONTINUE
          X1 = X(3,I,J) - X(1,I,J)
          X2 = X(4,I,J) - X(2,I,J)
          Y1 = Y(3,I,J) - Y(1,I,J)
          Y2 = Y(4,I,J) - Y(2,I,J)
          Z1 = Z(3,I,J) - Z(1,I,J)
          Z2 = Z(4,I,J) - Z(2,I,J)
          AN(1,I,J) = (Y1*Z2 - Y2*Z1)
          AN(2,I,J) = (Z1*X2 - Z2*X1)
          AN(3,I,J) = (X1*Y2 - X2*Y1)
          S = SQRT(AN(1,I,J)*AN(1,I,J)+
     +             AN(2,I,J)*AN(2,I,J)+
     +             AN(3,I,J)*AN(3,I,J))
          AN(1,I,J) = AN(1,I,J) / S
          AN(2,I,J) = AN(2,I,J) / S
          AN(3,I,J) = AN(3,I,J) / S
  320   CONTINUE
  330 CONTINUE
*
**          Find average normales
*
      DO 430 J=1,2
        DO 420 I=1,2
          DO 410 K=1,3
            BN(K,I,J) = AN(K,I,J)+AN(K,I+1,J)+AN(K,I+1,J+1)+AN(K,I,J+1)
  410     CONTINUE
  420   CONTINUE
  430 CONTINUE
*
**          Set luminosity
*
      CALL IHLUMI(BN(1,1,1),T(1))
      CALL IHLUMI(BN(1,2,1),T(2))
      CALL IHLUMI(BN(1,2,2),T(3))
      CALL IHLUMI(BN(1,1,2),T(4))
*
      END
+DECK,  IGTABL, T=FORT.
* Revision 1.5  1998/12/07 13:38:31  couet
* - It is now possible to set the size of the characters in case of
*    option 'T' and 'C' (in percent of the bin heigh).
* Revision 1.4  1998/12/02 15:18:36  couet
* - Text is drawn bigger with T option
* Revision 1.3  1998/12/01 15:48:28  couet
* - Clean up: commented lines of code removed
* Revision 1.2  1996/08/06 15:14:11  couet
* - When ZMIN = ZMAX for a contour plot with a set of levels, a division
*  by 0 occured.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGTABL(NX,NY,V,NPAR,PAR,CHOPTI)
*.===========>
*.
*.   This routine draws a table according to the value of CHOPT. The PAR input
*. parameter could be specified to change the aspect of the plot (see the des-
*. -cription below).  The position  of the plot on the screen  is given by the
*. viewport of the current  normalization transformation  selected (the window
*. is not used and could be anything).
*.
*. _Input parameters:
*.
*.  INTEGER NX      :  Number of cells in X.
*.  INTEGER NY      :  Number of cells in Y.
*.  REAL V(NX,NY)   :  Contains of the cells.
*.  INTEGER NPAR    :  Number of parameters in PAR
*.  REAL PAR(NPAR)  :  Array of real parameter.
*.                     If PAR(i)=0. or NPAR<i a default value is taken
*.  CHARACTER CHOPT :  Options (see bellow).
*.
*. +-------+---------------------------------------------------------+---------+
*. | CHOPT |                Corresponding values of PAR              | Default |
*. +-------+---------------------------------------------------------+---------+
*. |  'P'  | Points (scatter plot)                                   |         |
*. |       |   PAR(1)  = Marker type                                 |   1.    |
*. |       |   PAR(2)  = Maximum number of random points per cell    |   50.   |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label                   |   IYMIN |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |  'B'  | Boxes                                                   |         |
*. |       |   PAR(1)  = ...                                         |   ...   |
*. |       |   PAR(2)  = ...                                         |   ...   |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label                   |   IYMIN |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |  'R'  | aRrows                                                  |         |
*. |       |   PAR(1)  = ...                                         |   ...   |
*. |       |   PAR(2)  = ...                                         |   ...   |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label                   |   IYMIN |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |  'C'  | Contour plot                                            |         |
*. |       |   PAR(1)  = Nlevel (min=2 max=50)                       |   20.   |
*. |       |   PAR(2)  = 0 use colour to distinguish contours        |   0.    |
*. |       |               the line type use is 1.                   |         |
*. |       |             1.XXX use line style to distinguish contours|         |
*. |       |               The color index used is XXX.              |         |
*. |       |             2.XXX line style and colour are the same for|         |
*. |       |               all contours. The color index used is XXX |         |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label                   |   IYMIN |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. |       |   PAR(11) =   --+                                       |         |
*. |       |     .           |                                       |         |
*. |       |     .           +-> Levels to be drawn                  |         |
*. |       |     .           |                                       |         |
*. |       |   PAR(NPAR) = --+                                       |         |
*. +-------+---------------------------------------------------------+---------+
*. | 'COL' | COLour plot                                             |         |
*. |       |   PAR(1)  = 0 use the standard 8 colours                |   0.    |
*. |       |             1 use versacolor pattern table              |         |
*. |       |   PAR(2)  = ...                                         |         |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label                   |   IYMIN |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |  'T'  | Table (Text)                                            |         |
*. |       |   PAR(1)  = Text size (in % of the bin Y width)         |   0.3   |
*. |       |   PAR(2)  = ...                                         |         |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label                   |   IYMIN |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |  'K'  | Character, the contains is one single character         |         |
*. |       |   PAR(1)  = Text size (in % of the bin Y width)         |   0.3   |
*. |       |   PAR(2)  = ...                                         |         |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label                   |   IYMIN |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |  'L'  | Lego (mode 0)                                           |         |
*. |  'LB' | Lego same as L but take care with BARO and BARW         |         |
*. |  'L1' | Lego with colors (mode 1)                               |         |
*. |  'L2' | Lego with colors (mode 2)                               |         |
*. |       |   PAR(1)  = THETA                                       |   30.   |
*. |       |   PAR(2)  = PHI                                         |   30.   |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label. For 1D histos    |   IYMIN |
*. |       |             PAR(5) is the HMAX of HPLOT                 |         |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |  'S'  | Surface (mode 0)                                        |         |
*. |  'S1' | Surface with colors (mode 1)                            |         |
*. |  'S2' | Surface with colors (mode 2)                            |         |
*. |  'S3' | Surface with line and color contour on top              |         |
*. |  'S4' | Surface with Gouraud shading                            |         |
*. |       |   PAR(1)  = THETA                                       |   30.   |
*. |       |   PAR(2)  = PHI                                         |   30.   |
*. |       |   PAR(3)  = XMIN Minimal X-axis label                   |   IXMIN |
*. |       |   PAR(4)  = XMAX Maximal Y-axis label                   |   IXMAX |
*. |       |   PAR(5)  = YMIN Minimal Y-axis label. For 1D histos    |   IYMIN |
*. |       |             PAR(5) is the HMAX of HPLOT                 |         |
*. |       |   PAR(6)  = YMAX Maximal Y-axis label                   |   IYMAX |
*. |       |   PAR(7)  = ZMIN Minimal Z value                        |   ZMIN  |
*. |       |   PAR(8)  = ZMAX Maximal Z value                        |   ZMAX  |
*. |       |   PAR(9)  = 1000*IXMIN + IXMAX (Usefull for ZOOM)       |   1-NX  |
*. |       |   PAR(10) = 1000*IYMIN + IYMAX (Usefull for ZOOM)       |   1-NY  |
*. +-------+---------------------------------------------------------+---------+
*. |       |   For legos and surfaces :                              |         |
*. |       |   PAR(11) = NDVX if = 0 the 3D axis are not drawn       |  510.   |
*. |       |                  This is used in HPLTAB to draw the     |         |
*. |       |                  contour plot with fill area.           |         |
*. |       |   PAR(12) = NDVY                                        |  510.   |
*. |       |   PAR(13) = NDVZ                                        |  510.   |
*. |       |   PAR(14) = XCOL                                        |    1.   |
*. |       |   PAR(15) = YCOL                                        |    1.   |
*. |       |   PAR(16) = ZCOL if > 1000 the box is filled with ZCOL  |    1.   |
*. |       |   PAR(17) = XTIC                                        |  0.02   |
*. |       |   PAR(18) = YTIC                                        |  0.02   |
*. |       |   PAR(19) = ZTIC                                        |  0.02   |
*. |       |   PAR(20) = VSIZ                                        |  0.02   |
*. |       |   PAR(21) = VFON                                        |    2.   |
*. |       |   PAR(22) = XVAL                                        |  0.02   |
*. |       |   PAR(23) = YVAL                                        |  0.02   |
*. |       |   PAR(24) = ZVAL                                        |  0.04   |
*. |       |   PAR(25) = Color                                       |         |
*. +-------+---------------------------------------------------------+---------+
*. | 'POL' | Polar for LEGO and SURFACE                              |         |
*. +-------+---------------------------------------------------------+---------+
*. | 'CYL' | Cylindrical for LEGO and SURFACE                        |         |
*. +-------+---------------------------------------------------------+---------+
*. | 'SPH' | Spherical for LEGO and SURFACE                          |         |
*. +-------+---------------------------------------------------------+---------+
*. | 'PSD' | Pseudo rapidity for LEGO and SURFACE                    |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'H'  | Data are compacted like in HPLOT. In this case, V is    |         |
*. |       | not the matrix to be drawn but V(1) contains the HBOOK  |         |
*. |       | ZEBRA link to the histogram to be drawn.                |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'I'  | IGTABL is called from IZDNB. In this case, V is not the |         |
*. |       | not the matrix to be drawn but V(1) contains the HIGZ   |         |
*. |       | adress in the picture data structure.                   |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'GX' | loG on X coordinates. A log WC should be defined before |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'GY' | loG on Y coordinates. A log WC should be defined before |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'GZ' | loG on Z coordinates                                    |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'A'  | 2nd vertical axis (legos and Surfaces only)             |         |
*. |       | axis (for the 2D representations)                       |         |
*. +-------+---------------------------------------------------------+---------+
*. |  '+'  | For stacked histogram (legos)                           |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'Z'  | Allows to display the Z scale                           |         |
*. +-------+---------------------------------------------------------+---------+
*. |  'E'  | Draw the errors (with colors)                           |         |
*. +-------+---------------------------------------------------------+---------+
*. | 'FB'  | With LEGO or SURFACE, it suppress the Front-Box         |         |
*. | 'BB'  | With LEGO or SURFACE, it suppress the Back-Box          |         |
*. +-------+---------------------------------------------------------+---------+
*.
*.  Remarks:
*.          If PAR(9)  < 0, IXMIN=-PAR(9)  and IXMAX=IQUEST(60)
*.          If PAR(10) < 0, IYMIN=-PAR(10) and IYMAX=IQUEST(61)
*.          For 1-Dim histograms, PAR(5) is the Y-Scale factor (HMAX of HPLOT)
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATT.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF.
+CDE, HIFLAG.
+CDE, HIPACK.
+CDE, HICONT.
+CDE, HIHID.
+CDE, HILUT.

      PARAMETER       (YDIFF=1.,YLIGH1=10.)
      PARAMETER       (QA=0.15,QD=0.15,QS=0.8,NQS=1)

      EXTERNAL IHDFL1,IHDFR1,IHDFL2,IHDFR2
      EXTERNAL IHDF02,IHDF03,IGTAB2,IGTAB3,IGTAB6
      REAL IGCELL

      CHARACTER*(*) CHOPTI
      DIMENSION PAR(*),V(*)

      PARAMETER (MAXCOL=8,MAXPAT=39)
      PARAMETER (NMAX=500)
      PARAMETER (NRASTX=1000,NRASTY=800)

      DIMENSION XBUF(NMAX),YBUF(NMAX)
      DIMENSION X(4),Y(4),ZC(4),IR(4),XARR(102),YARR(102),ITARR(102)
      DIMENSION LUT(MAXCOL),IPATRN(MAXPAT)
      DIMENSION IOPT(30),IOPT2(16)
      DIMENSION RVAL(4)

      EQUIVALENCE (IOPCOL,IOPT( 1))
      EQUIVALENCE (IOPTP ,IOPT( 2)),(IOPTB ,IOPT( 3))
      EQUIVALENCE (IOPTC ,IOPT( 4)),(IOPTT ,IOPT( 5))
      EQUIVALENCE (IOPTK ,IOPT( 6)),(IOPTL ,IOPT( 7))
      EQUIVALENCE (IOPTS ,IOPT( 8)),(IOPTH ,IOPT( 9))
      EQUIVALENCE (IOPTA ,IOPT(10)),(IOPTPP,IOPT(11))
      EQUIVALENCE (IOPTR ,IOPT(12)),(IOPTS1,IOPT(13))
      EQUIVALENCE (IOPTS2,IOPT(14)),(IOPTL1,IOPT(15))
      EQUIVALENCE (IOPTL2,IOPT(16)),(IOPTGZ,IOPT(17))
      EQUIVALENCE (IOPTGX,IOPT(18)),(IOPTGY,IOPT(19))
      EQUIVALENCE (IOPTBR,IOPT(20)),(IOPTZ ,IOPT(21))
      EQUIVALENCE (IOPTS3,IOPT(22)),(IOPTS4,IOPT(23))
      EQUIVALENCE (IOPPOL,IOPT(24)),(IOPCYL,IOPT(25))
      EQUIVALENCE (IOPSPH,IOPT(26)),(IOPPSD,IOPT(27))
      EQUIVALENCE (IOPTBB,IOPT(28)),(IOPTFB,IOPT(29))
      EQUIVALENCE (IOPTE ,IOPT(30))

      LOGICAL LTEST,ZFSAV

      CHARACTER*80 CHOPT
      CHARACTER*12 CHAT
      CHARACTER*40 CHK

      DIMENSION RSTRS(MAXSTK),RSTGS(MAXSTK),RSTBS(MAXSTK)
      SAVE RSTRS,RSTGS,RSTBS,NBCSAV
      SAVE RSTRBS,RSTGBS,RSTBBS
      SAVE RSTRTS,RSTGTS,RSTBTS
      DATA NBCSAV /0/

      DATA LUT /0,5,7,3,6,2,4,1/
      DATA IPATRN /20,28,36,44,52,64,48,64,72,82,
     +            89,91,95,98,104,105,112,116,126,
     +            131,147,156,159,160,168,174,175,
     +            178,182,184,199,215,221,227,228,
     +            230,235,246,236/
*.______________________________________
*
      IQUEST(1)=0
      IF(NX.LE.0.OR.NY.LT.0)THEN
         CALL IGERR('Invalid array dimension','IGTABL')
         RETURN
      ENDIF
*
*             Determine options
*
      CHOPT=CHOPTI
      IOPCOL=INDEX(CHOPT,'COL')
      IF(IOPCOL.GT.0)CHOPT(IOPCOL:IOPCOL+2)='   '
      IOPPOL=INDEX(CHOPT,'POL')
      IF(IOPPOL.GT.0)CHOPT(IOPPOL:IOPPOL+2)='   '
      IOPCYL=INDEX(CHOPT,'CYL')
      IF(IOPCYL.GT.0)CHOPT(IOPCYL:IOPCYL+2)='   '
      IOPSPH=INDEX(CHOPT,'SPH')
      IF(IOPSPH.GT.0)CHOPT(IOPSPH:IOPSPH+2)='   '
      IOPPSD=INDEX(CHOPT,'PSD')
      IF(IOPPSD.GT.0)CHOPT(IOPPSD:IOPPSD+2)='   '
      IOPTFB=INDEX(CHOPT,'FB')
      IF(IOPTFB.GT.0)CHOPT(IOPTFB:IOPTFB+1)='  '
      IOPTBB=INDEX(CHOPT,'BB')
      IF(IOPTBB.GT.0)CHOPT(IOPTBB:IOPTBB+1)='  '
      IOPTBR=INDEX(CHOPT,'LB')
      IF(IOPTBR.GT.0)CHOPT(IOPTBR:IOPTBR+1)=' L'
      IOPTS1=INDEX(CHOPT,'S1')
      IF(IOPTS1.GT.0)CHOPT(IOPTS1:IOPTS1+1)='  '
      IOPTS2=INDEX(CHOPT,'S2')
      IF(IOPTS2.GT.0)CHOPT(IOPTS2:IOPTS2+1)='  '
      IOPTS3=INDEX(CHOPT,'S3')
      IF(IOPTS3.GT.0)CHOPT(IOPTS3:IOPTS3+1)='  '
      IOPTS4=INDEX(CHOPT,'S4')
      IF(IOPTS4.GT.0)CHOPT(IOPTS4:IOPTS4+1)='  '
      IOPTL1=INDEX(CHOPT,'L1')
      IF(IOPTL1.GT.0)CHOPT(IOPTL1:IOPTL1+1)='  '
      IOPTL2=INDEX(CHOPT,'L2')
      IF(IOPTL2.GT.0)CHOPT(IOPTL2:IOPTL2+1)='  '
      IOPTGZ=INDEX(CHOPT,'GZ')
      IF(IOPTGZ.GT.0)CHOPT(IOPTGZ:IOPTGZ+1)='  '
      IOPTGX=INDEX(CHOPT,'GX')
      IF(IOPTGX.GT.0)CHOPT(IOPTGX:IOPTGX+1)='  '
      IOPTGY=INDEX(CHOPT,'GY')
      IF(IOPTGY.GT.0)CHOPT(IOPTGY:IOPTGY+1)='  '
      IOPTZ=INDEX(CHOPT,'Z')
      IF(IOPTZ.GT.0)CHOPT(IOPTZ:IOPTZ)=' '
      IOPTI=INDEX(CHOPT,'I')
      IF(IOPTI.GT.0)CHOPT(IOPTI:IOPTI)=' '
      IOPTE=INDEX(CHOPT,'E')
      IOPTER=IOPTE
      IF(IOPTE.GT.0)CHOPT(IOPTE:IOPTE)=' '
      CALL UOPTC(CHOPT,'PBCTKLSHA+R',IOPT(2))
      ILEGO = IOPTL+IOPTL1+IOPTL2
      ISURF = IOPTS+IOPTS1+IOPTS2+IOPTS3+IOPTS4
      I3D   = ILEGO+ISURF
      IRAST = 0
*
*              Try to find if a drawing option has been selected
*              if not the option 'P' is selected.
*
      CALL UOPTC(CHOPT,'PBCTKLSR',IOPT2(2))
      IOPT2(1) =IOPCOL
      IOPT2(10)=IOPTS1
      IOPT2(11)=IOPTS2
      IOPT2(12)=IOPTL1
      IOPT2(13)=IOPTL2
      IOPT2(14)=IOPTS3
      IOPT2(15)=IOPTS4
      IOPT2(16)=IOPTE
      DO 10 I=1,16
         IF(IOPT2(I).NE.0)GOTO 20
   10 CONTINUE
      IOPTP=1
   20 CONTINUE
*
*             Initialise the COMMON HIPACK (used by IGCELL)
*
      NCX = NX
      NCY = NY
      IF(IOPTH.NE.0)THEN
         IPACK = 1
      ELSEIF(IOPTI.NE.0)THEN
         IPACK = 2
      ELSE
         IPACK = 0
      ENDIF
      IF(NCY.EQ.0)THEN
         IDIM1 = 1
         NCY   = 1
      ELSE
         IDIM1 = 0
      ENDIF
      ILOG  = 0
      ZLOW  = 0.
      ZHIGH = 0.
      IF(NPAR.GE.8)THEN
         ZLOW  = PAR(7)
         ZHIGH = PAR(8)
      ENDIF
*
      I4AXI = IOPTA
      IF(IOPTBR.NE.0)THEN
         RLEGBO = RBOF
         RLEGBW = RBWD
      ELSE
         RLEGBO = 0.
         RLEGBW = 1.
      ENDIF
+SELF, IF=MAIL.
*
*              Z part and MAIL part
*
      CHOPTM=CHOPTI
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZTABL(NX,NY,V,NPAR,PAR,IOPT)
+SELF.
      IF((.NOT.GFLAG).AND.(.NOT.PFLAG))RETURN
      ZFSAV=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
*              Initialise the LOGX and LOGY option for 3D representations
*
      IF(I3D.NE.0)THEN
         IF(IOPTGX.NE.0)THEN
            ILOGX  = IOPTGX
            IOPTGX = 0
         ELSE
            ILOGX  = 0
         ENDIF
         IF(IOPTGY.NE.0)THEN
            ILOGY  = IOPTGY
            IOPTGY = 0
         ELSE
            ILOGY  = 0
         ENDIF
      ENDIF
*
*             Save the current environment and select
*             a logarithmic or normalized working space.
*
      CALL IZSAV
      X(1)=RVXMIN
      X(2)=RVXMAX
      Y(1)=RVYMIN
      Y(2)=RVYMAX
      IF(IOPTGX.NE.0)THEN
         X(1)=RWXMIN
         X(2)=RWXMAX
      ENDIF
      IF(IOPTGY.NE.0)THEN
         Y(1)=RWYMIN
         Y(2)=RWYMAX
      ENDIF
      CALL ISWN(INTR,X(1),X(2),Y(1),Y(2))
      CALL ISELNT(INTR)
*.______________________________________
*
*              Compute some usefull parameters
*
*   IXMIN = first chanel in X
*   IXMAX = last chanel in X
*   IYMIN = first chanel in Y
*   IYMAX = last chanel in Y
*   NXCHA = number of chanel in X
*   NYCHA = number of chanel in Y
*   XSTP  = step in X
*   YSTP  = step in Y
*   ZMIN  = minimum of the array V(IXMIN:IXMAX,IYMIN:IYMAX)
*   ZMAX  = maximum of the array V(IXMIN:IXMAX,IYMIN:IYMAX)
*   DZ    = difference between ZMAX and ZMIN
*   HMAX  = Margin on top of 1D histos (% of ZMAX)
*   RAD   = Conversion from degrees to radians
*
      IXMIN = 1
      IXMAX = NX
      IF(NPAR.GE.9)THEN
         IF(PAR(9).GT.0.)THEN
            IXMIN = INT(PAR(9)/1000)
            IXMAX = INT(PAR(9)-(1000*IXMIN))
         ELSEIF(PAR(9).LT.0.)THEN
            IXMIN = -PAR(9)
            IXMAX = IQUEST(60)
         ENDIF
      ENDIF
      IF(IDIM1.NE.0)THEN
         IYMIN = 0
         IYMAX = 0
      ELSE
         IYMIN = 1
         IYMAX = NY
         IF(NPAR.GE.10)THEN
            IF(PAR(10).GT.0.)THEN
               IYMIN = INT(PAR(10)/1000)
               IYMAX = INT(PAR(10)-(1000*IYMIN))
            ELSEIF(PAR(10).LT.0.)THEN
               IYMIN = -PAR(10)
               IYMAX = IQUEST(61)
            ENDIF
         ENDIF
      ENDIF
*
* In case of surfaces at least 2 channels are needed
*
      IF(ISURF.NE.0)THEN
         IF(IXMAX.EQ.IXMIN)THEN
            IXMAX=IXMAX+1
            IF(IXMAX.GT.NX)THEN
               IXMAX=NX
               IXMIN=IXMIN-1
            ENDIF
         ENDIF
         IF(IYMAX.EQ.IYMIN)THEN
            IYMAX=IYMAX+1
            IF(IYMAX.GT.NY)THEN
               IYMAX=NY
               IYMIN=IYMIN-1
            ENDIF
         ENDIF
      ENDIF
*
      NXCHA=IXMAX-IXMIN+1
      NYCHA=IYMAX-IYMIN+1
      IF(IXMIN.GT.IXMAX)THEN
         CALL IGERR('PAR(9) is not valid','IGTABL')
         GOTO 450
      ENDIF
      IF(IYMIN.GT.IYMAX.AND.NY.GT.0)THEN
         CALL IGERR('PAR(10) is not valid','IGTABL')
         GOTO 450
      ENDIF
      IF(IOPTGX.NE.0)THEN
         XSTP=(10**RWXMAX-10**RWXMIN)/FLOAT(IXMAX-IXMIN+1)
      ELSE
         XSTP=(RWXMAX-RWXMIN)/FLOAT(IXMAX-IXMIN+1)
      ENDIF
      IF(IOPTGY.NE.0)THEN
         YSTP=(10**RWYMAX-10**RWYMIN)/FLOAT(IYMAX-IYMIN+1)
      ELSE
         YSTP=(RWYMAX-RWYMIN)/FLOAT(IYMAX-IYMIN+1)
      ENDIF
*
* Compute ZMAX and ZMIN
*
      IF(ZHIGH.NE.ZLOW)THEN
         ZMAX=ZHIGH
         ZMIN=ZLOW
      ELSE
         ZMIN=IGCELL(NX,NY,V,IXMIN,IYMIN,1)
         ZMAX=ZMIN
         DO 40 J=IYMIN,IYMAX
            DO 30 I=IXMIN,IXMAX
               Z=IGCELL(NX,NY,V,I,J,1)
               IF(IOPTGZ.NE.0)THEN
                  IF(Z.GT.0)ZMIN=MIN(ZMIN,Z)
               ELSE
                  ZMIN=MIN(ZMIN,Z)
               ENDIF
               ZMAX=MAX(ZMAX,Z)
   30       CONTINUE
   40    CONTINUE
      ENDIF
      IF(IOPTGZ.NE.0)THEN
         IF(ZMAX.GT.0.)THEN
            IF(ZMIN.LE.0.)ZMIN=0.001*ZMAX
            ZLOW=ZMIN
            ZHIGH=ZMAX
            ZMAX=LOG10(ZMAX)
            ZMIN=LOG10(ZMIN)
         ELSE
            CALL IGERR('Negative logarithmic axis','IGTABL')
            GOTO 450
         ENDIF
      ENDIF
      IF(ZMAX.EQ.ZMIN)THEN
         EPS=ABS(ZMAX*0.1)
         IF(EPS.EQ.0)EPS=0.1
         ZMAX=ZMAX+EPS
         ZMIN=ZMIN-EPS
      ENDIF
      DZ=ZMAX-ZMIN
      IF(DZ.LE.0.)THEN
         CALL IGERR('ZMAX < ZMIN','IGTABL')
         GOTO 450
      ENDIF
      RQUEST(11) = ZMIN
      RQUEST(12) = ZMAX
      ILOG  = IOPTGZ
*
      XK=RWXMIN
      YK=RWYMIN
      IF(IOPTGX.NE.0)XK=10**RWXMIN
      IF(IOPTGY.NE.0)YK=10**RWYMIN
*
      HMAX=1.
      IF(IDIM1.NE.0)THEN
         HMAX=1.1
         IF(NPAR.GE.5)THEN
            IF(PAR(5).NE.0.)HMAX=1./PAR(5)
         ENDIF
      ENDIF
*
      RAD = ATAN(1.)*4./180.
*.______________________________________
*
*             Store the stacked histograms parameters
*
      IF(IOPTPP.NE.0)THEN
         NIDS=NIDS+1
         IF(NIDS.EQ.1)THEN
            XLAB1=FLOAT(IXMIN)
            XLAB2=FLOAT(IXMAX)
            YLAB1=FLOAT(IYMIN)
            YLAB2=FLOAT(IYMAX)
            IF(NPAR.GE.6)THEN
               IF(PAR(4).GT.PAR(3))THEN
                  XLAB1=PAR(3)
                  XLAB2=PAR(4)
               ENDIF
               IF(PAR(6).GT.PAR(5))THEN
                  YLAB1=PAR(5)
                  YLAB2=PAR(6)
               ENDIF
            ENDIF
         ENDIF
         IF(NIDS.EQ.10)THEN
            CALL IGERR('Too many stacked histograms','IGTABL')
            NIDS=9
            GOTO 450
         ENDIF
         IF(IPACK.NE.0)THEN
            LSTACK(NIDS)=INT(V(1))
         ELSE
            LSTACK(NIDS)=LOCF(V(1))
         ENDIF
         IXFCHA(NIDS)=IXMIN
         IYFCHA(NIDS)=IYMIN
         IXNCHA(NIDS)=NXCHA
         IYNCHA(NIDS)=NYCHA
         IF(NPAR.GE.25)THEN
            ISTCOL(NIDS)=PAR(25)
         ELSE
            ISTCOL(NIDS)=NIDS
         ENDIF
         GOTO 450
      ENDIF
*.______________________________________
*
*              Draw the table with a density of points (scatter plot)
*
      IF(IOPTP.NE.0)THEN
         FACN=1.
         LTEST=.FALSE.
         IF(ZMAX.GE.50..OR.ZMAX.LT.1.)THEN
            FACN=49./DZ
            LTEST=.TRUE.
         ENDIF
         IPMNUM=0
         DO 80 J=IYMIN,IYMAX
            DO 70 I=IXMIN,IXMAX
               Z=IGCELL(NX,NY,V,I,J,1)-ZMIN
               IF(Z.EQ.0.)GOTO 60
               K=INT(Z*FACN)
               IF(LTEST)K=K+1
               IF(K.GT.0)THEN
                  IF((K+IPMNUM).GE.NMAX)THEN
                     CALL IPM(IPMNUM,XBUF,YBUF)
                     IPMNUM=0
                  ENDIF
                  DO 50 LOOP=1,K
                     XBUF(IPMNUM+LOOP)=(RNDM(LOOP)*XSTP)+XK
                     IF(IOPTGX.NE.0)XBUF(IPMNUM+LOOP)=
     +                              LOG10(XBUF(IPMNUM+LOOP))
                     YBUF(IPMNUM+LOOP)=(RNDM(LOOP)*YSTP)+YK
                     IF(IOPTGY.NE.0)YBUF(IPMNUM+LOOP)=
     +                              LOG10(YBUF(IPMNUM+LOOP))
   50             CONTINUE
                  IPMNUM=IPMNUM+K
               ENDIF
   60          XK=XK+XSTP
   70       CONTINUE
            IF(IOPTGX.NE.0)THEN
               XK=10**RWXMIN
            ELSE
               XK=RWXMIN
            ENDIF
            YK=YK+YSTP
   80    CONTINUE
         IF(IPMNUM.GT.0)CALL IPM(IPMNUM,XBUF,YBUF)
         GOTO 440
      ENDIF
*.______________________________________
*
*              Draw the table with proportional boxes
*
      IF(IOPTB.NE.0)THEN
         XMID=XSTP/2.
         YMID=YSTP/2.
         DO 100 J=IYMIN,IYMAX
            DO 90 I=IXMIN,IXMAX
               Z=IGCELL(NX,NY,V,I,J,1)
               IF(Z.NE.ZMIN)THEN
                  ZRATIO = SQRT((Z-ZMIN)/DZ)
                  XU=(XMID*ZRATIO)+(XK+XMID)
                  XL=2*(XK+XMID)-XU
                  IF(IOPTGX.NE.0)THEN
                     XU=LOG10(XU)
                     XL=LOG10(XL)
                  ENDIF
                  YU=(YMID*ZRATIO)+(YK+YMID)
                  YL=2*(YK+YMID)-YU
                  IF(IOPTGY.NE.0)THEN
                     YU=LOG10(YU)
                     YL=LOG10(YL)
                  ENDIF
                  CALL IGBOX(XL,XU,YL,YU)
               ENDIF
               XK=XK+XSTP
   90       CONTINUE
            IF(IOPTGX.NE.0)THEN
               XK=10**RWXMIN
            ELSE
               XK=RWXMIN
            ENDIF
            YK=YK+YSTP
  100    CONTINUE
         GOTO 440
      ENDIF
*.______________________________________
*
*              Draw the table with arrows
*
      IF(IOPTR.NE.0)THEN
         XRG=RVXMIN
         YRG=RVYMIN
         XLN=RVXMAX-RVXMIN
         YLN=RVYMAX-RVYMIN
         CX=(XLN/NXCHA-0.03)/2.
         CY=(YLN/NYCHA-0.03)/2.
         DN=1.E-30
         CALL ISLN(1)
         DO 130 ID=1,2
            DO 120 J=IYMIN,IYMAX
               DO 110 I=IXMIN,IXMAX
                  IF(I.EQ.IXMIN)THEN
                     DX=IGCELL(NX,NY,V,I+1,J,1)-IGCELL(NX,NY,V,I,J,1)
                  ELSEIF(I.EQ.IXMAX)THEN
                     DX=IGCELL(NX,NY,V,I,J,1)-IGCELL(NX,NY,V,I-1,J,1)
                  ELSE
                     DX=(IGCELL(NX,NY,V,I+1,J,1)-
     +                   IGCELL(NX,NY,V,I-1,J,1))/2
                  ENDIF
                  IF(J.EQ.IYMIN)THEN
                     DY=IGCELL(NX,NY,V,I,J+1,1)-IGCELL(NX,NY,V,I,J,1)
                  ELSEIF(J.EQ.IYMAX)THEN
                     DY=IGCELL(NX,NY,V,I,J,1)-IGCELL(NX,NY,V,I,J-1,1)
                  ELSE
                     DY=(IGCELL(NX,NY,V,I,J+1,1)-
     +                   IGCELL(NX,NY,V,I,J-1,1))/2
                  ENDIF
                  IF(ID.EQ.1)THEN
                     DN=MAX(DN,ABS(DX),ABS(DY))
                  ELSEIF(ID.EQ.2)THEN
                     XC=XRG+XLN*(FLOAT(I-IXMIN+1)-0.5)/NXCHA
                     DXN=CX*DX/DN
                     X1=XC-DXN
                     X2=XC+DXN
                     YC=YRG+YLN*(FLOAT(J-IYMIN+1)-0.5)/NYCHA
                     DYN=CY*DY/DN
                     Y1=YC-DYN
                     Y2=YC+DYN
                     XBUF(1)=X1
                     XBUF(2)=X2
                     YBUF(1)=Y1
                     YBUF(2)=Y2
                     IF(ABS(X2-X1).GT.1.E-2.OR.ABS(Y2-Y1).GT.1.E-2)THEN
                        ANR=0.005*.5*SQRT(2/(DXN**2+DYN**2))
                        SI=ANR*(DXN+DYN)
                        CO=ANR*(DXN-DYN)
                        XBUF(3)=X2-SI
                        YBUF(3)=Y2+CO
                        CALL IPL(3,XBUF,YBUF)
                        XBUF(1)=X2
                        XBUF(2)=X2-CO
                        YBUF(1)=Y2
                        YBUF(2)=Y2-SI
                        CALL IPL(2,XBUF,YBUF)
                     ELSE
                        CALL IPL(2,XBUF,YBUF)
                     ENDIF
                  ENDIF
  110          CONTINUE
  120       CONTINUE
  130    CONTINUE
         GOTO 440
      ENDIF
*.______________________________________
*
*              Draw the table with color levels
*
      IF(IOPCOL.NE.0)THEN
         CALL ISFAIS(1)
         MAXCP=MAXCOL
         IF(INBCOL.GT.8)MAXCP=INBCOL-7
         IF(NPAR.GE.1)THEN
            IF(PAR(1).EQ.1.)THEN
               CALL ISFAIS(2)
               MAXCP=MAXPAT
            ENDIF
         ENDIF
         CALL IGSET('BORD',0.)
         DO 150 J=IYMIN,IYMAX
            DO 140 I=IXMIN,IXMAX
               Z=IGCELL(NX,NY,V,I,J,1)
               ICOL=INT(MAXCP*(Z-ZMIN)/DZ)
               IF(IFAIS.EQ.2)THEN
                  CALL ISFASI(IPATRN(ICOL))
               ELSE
                  IF(ICOL.GT.MAXCP-1)ICOL=MAXCP-1
                  IF(INBCOL.GT.8)THEN
                     CALL ISFACI(ICOL+8)
                  ELSE
                     CALL ISFACI(LUT(ICOL+1))
                  ENDIF
               ENDIF
               XU=XK+XSTP
               XL=XK
               IF(IOPTGX.NE.0)THEN
                  XU=LOG10(XU)
                  XL=LOG10(XL)
               ENDIF
               YU=YK+YSTP
               YL=YK
               IF(IOPTGY.NE.0)THEN
                  YU=LOG10(YU)
                  YL=LOG10(YL)
               ENDIF
               CALL IGBOX(XL,XU,YL,YU)
               XK=XK+XSTP
  140       CONTINUE
            IF(IOPTGX.NE.0)THEN
               XK=10**RWXMIN
            ELSE
               XK=RWXMIN
            ENDIF
            YK=YK+YSTP
  150    CONTINUE
         CALL IGSET('BORD',1.)
         CALL ISFAIS(0)
         CALL ISPLCI(1)
         CALL IGBOX(RWXMIN,RWXMAX,RWYMIN,RWYMAX)
         IF(IOPTZ.NE.0)THEN
            XX=0.01*(RWXMAX-RWXMIN)
            IF(INBCOL.GT.8)THEN
               IC1=8
               IC2=INBCOL
            ELSE
               IC1=0
               IC2=7
            ENDIF
            CALL ISCLIP(0)
            IF(IOPTGZ.NE.0)THEN
               CALL IGCOLM(RWXMAX+XX,RWXMAX+4.*XX,RWYMIN,RWYMAX
     +,                    IC1,IC2,10.**ZMIN,10.**ZMAX,'CAG')
            ELSE
               CALL IGCOLM(RWXMAX+XX,RWXMAX+4.*XX,RWYMIN,RWYMAX
     +,                    IC1,IC2,ZMIN,ZMAX,'CA')
            ENDIF
         ENDIF
         GOTO 440
      ENDIF
*.______________________________________
*
*              Draw the table as a contour plot
*
      IF(IOPTC.NE.0)THEN
         NCONT  = 20
         ILNSAV = ILN
         CALL ISLN(1)
         IF(NPAR.GE.1)THEN
            IF(PAR(1).GE.2..AND.PAR(1).LE.50.)NCONT=INT(PAR(1))
         ENDIF
         ITYPE = 0
         ICOL  = 1
         IF(NPAR.GE.2)THEN
            IF(PAR(2).GE.1..AND.PAR(2).LT.3.)THEN
               ITYPE = INT(PAR(2))
               ICOL  = INT((PAR(2)-ITYPE)*1000.+0.5)
               IF(ICOL.LE.0)ICOL=1
               CALL ISPLCI(ICOL)
               IF(ITYPE.EQ.2)CALL ISLN(ILNSAV)
            ENDIF
         ENDIF
         IF(IXMAX.EQ.IXMIN.OR.IYMAX.EQ.IYMIN)THEN
            CALL IGERR('At least 2 channels are needed in contour',
     +      'IGTABL')
            GOTO 450
         ENDIF
         XSTP=(RWXMAX-RWXMIN)/FLOAT(IXMAX-IXMIN+1)
         YSTP=(RWYMAX-RWYMIN)/FLOAT(IYMAX-IYMIN+1)
         IEND=1
         IF(NPAR.GT.10)THEN
            IEND=NPAR-10
            NCONT=12
            ZMINS=ZMIN
            ZMAXS=ZMAX
         ENDIF
         DO 240 ICONT=1,IEND
            IF(NPAR.GT.10)THEN
               IF(PAR(ICONT+10).GT.ZMAXS.OR.PAR(ICONT+10).LT.ZMINS)THEN
                  CALL IGERR('Z value outside limits','IGTABL')
                  GOTO 450
               ENDIF
               ZMAX=ZMAXS
               ZMIN=PAR(ICONT+10)-(ZMAXS-PAR(ICONT+10))
               IF(ZMIN.LT.ZMINS)THEN
                  ZMIN=ZMINS
                  ZMAX=PAR(ICONT+10)+(PAR(ICONT+10)-ZMINS)
               ENDIF
               ZHIGH=ZMAX
               ZLOW=ZMIN
               DZ=ZMAX-ZMIN
               IF (DZ.EQ.0) THEN
                  CALL IGERR('ZMIN = ZMAX ','IGTABL')
                  GOTO 450
               ENDIF
            ENDIF
            DO 230 J=IYMIN,IYMAX-1
               Y(1)=FLOAT(J-IYMIN)*YSTP+RWYMIN+YSTP/2.
               Y(2)=Y(1)
               Y(3)=FLOAT(J-IYMIN+1)*YSTP+RWYMIN+YSTP/2.
               Y(4)=Y(3)
               DO 220 I=IXMIN,IXMAX-1
                  ZC(1)=IGCELL(NX,NY,V,I,J,1)
                  ZC(2)=IGCELL(NX,NY,V,I+1,J,1)
                  ZC(3)=IGCELL(NX,NY,V,I+1,J+1,1)
                  ZC(4)=IGCELL(NX,NY,V,I,J+1,1)
                  IR(1)=INT((ZC(1)-ZMIN)*NCONT/DZ)
                  IR(2)=INT((ZC(2)-ZMIN)*NCONT/DZ)
                  IR(3)=INT((ZC(3)-ZMIN)*NCONT/DZ)
                  IR(4)=INT((ZC(4)-ZMIN)*NCONT/DZ)
                  IF(IR(1).NE.IR(2).OR.IR(2).NE.IR(3).OR.
     +               IR(3).NE.IR(4).OR.IR(4).NE.IR(1))THEN
                     X(1)=FLOAT(I-IXMIN)*XSTP+RWXMIN+XSTP/2.
                     X(4)=X(1)
                     X(2)=FLOAT(I-IXMIN+1)*XSTP+RWXMIN+XSTP/2.
                     X(3)=X(2)
                     N=LVMIN(ZC,4)
                     LJ=1
                     DO 160 IX=1,4
                        M=MOD(N,4)+1
                        LJ=LJ+2*IGTAB1(ZC(N),IR(N),X(N),Y(N),ZC(M),
     +                  IR(M),X(M),Y(M),XARR(LJ),YARR(LJ),ITARR(LJ),
     +                  NCONT)
                        N=M
  160                CONTINUE
                     N=LVMIN(ZC,4)
                     LJ=2
                     DO 170 IX=1,4
                        IF(N.EQ.1)THEN
                           M=4
                        ELSE
                           M=N-1
                        ENDIF
                        LJ=LJ+2*IGTAB1(ZC(N),IR(N),X(N),Y(N),ZC(M),
     +                  IR(M),X(M),Y(M),XARR(LJ),YARR(LJ),ITARR(LJ),
     +                  NCONT)
                        N=M
  170                CONTINUE
*
* Re-order endpoints
*
                     DO 200 IX=1,LJ-5,2
  180                   IF(ITARR(IX).NE.ITARR(IX+1))THEN
                           XSAVE=XARR(IX+1)
                           YSAVE=YARR(IX+1)
                           ITARS=ITARR(IX+1)
                           DO 190 JX=IX,LJ-5,2
                              XARR(JX+1)=XARR(JX+3)
                              YARR(JX+1)=YARR(JX+3)
                              ITARR(JX+1)=ITARR(JX+3)
  190                      CONTINUE
                           XARR(LJ-2)=XSAVE
                           YARR(LJ-2)=YSAVE
                           ITARR(LJ-2)=ITARS
                           GOTO 180
                        ENDIF
  200                CONTINUE
*
                     DO 210 IX=1,LJ-2,2
                        IF(NPAR.GT.10)THEN
                           IF(ITARR(IX).NE.6)THEN
                              GOTO 210
                           ELSE
                              MODE=MAX(MOD(ICONT,5),1)
                           ENDIF
                        ELSE
                           ICOL=(4*ITARR(IX))/NCONT+1
                           IF(ITYPE.EQ.0)MODE=ICOL
                           IF(ITYPE.EQ.1)THEN
                              MODE=MOD(ICOL,5)
                              IF(MODE.EQ.0)MODE=5
                           ENDIF
                        ENDIF
                        IF(ITYPE.EQ.0)CALL ISPLCI(MODE)
                        IF(ITYPE.EQ.1)CALL ISLN(MODE)
                        CALL IPL(2,XARR(IX),YARR(IX))
  210                CONTINUE
                  ENDIF
  220          CONTINUE
  230       CONTINUE
  240    CONTINUE
         GOTO 440
      ENDIF
*.______________________________________
*
*              Draw the table with the table content (INTEGER)
*
      IF(IOPTT.NE.0)THEN
         XK=RWXMIN+XSTP/2.
         YK=RWYMIN+YSTP/2.
         XK0=XK
         IF(NPAR.GE.2)THEN
            TSIZ=YSTP*PAR(1)
         ELSE
            TSIZ=YSTP*0.3
         ENDIF
         CALL ISCHH(TSIZ)
         CALL ISTXAL(2,3)
         CALL IGSET('TANG',0.)
         DO 260 J=IYMIN,IYMAX
            DO 250 I=IXMIN,IXMAX
               Z=IGCELL(NX,NY,V,I,J,1)
               IC=INT(Z)
               IF(IC.NE.0)THEN
                  CALL IZITOC(IC,CHAT)
                  CALL ITX(XK,YK,CHAT)
               ENDIF
               XK=XK+XSTP
  250       CONTINUE
            XK=XK0
            YK=YK+YSTP
  260    CONTINUE
         GOTO 440
      ENDIF
*.______________________________________
*
*              Draw the table with one character per cell
*
      IF(IOPTK.NE.0)THEN
         CHK='.+23456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*'
         XK=RWXMIN+XSTP/2.
         YK=RWYMIN+YSTP/2.
         XK0=XK
         IF(NPAR.GE.2)THEN
            TSIZ=YSTP*PAR(1)
         ELSE
            TSIZ=YSTP*0.3
         ENDIF
         CALL ISCHH(TSIZ)
         CALL ISTXAL(2,3)
         CALL IGSET('TANG',0.)
         DO 280 J=IYMIN,IYMAX
            DO 270 I=IXMIN,IXMAX
               Z=IGCELL(NX,NY,V,I,J,1)
               IC=NINT(Z+0.5)
               IF(IC.GT.37)IC=37
               IF(IC.GT.0)CALL ITX(XK,YK,CHK(IC:IC))
               XK=XK+XSTP
  270       CONTINUE
            XK=XK0
            YK=YK+YSTP
  280    CONTINUE
         GOTO 440
      ENDIF
*.______________________________________
*
*              3D representations
*
      IF(I3D.LE.0)GOTO 450
      CALL ISCLIP(0)
*
*              Restore the color map if necessary
*
      IF(NBCSAV.NE.0)THEN
         DO 290 I=1,NBCSAV
            CALL ISCR(1,ISTCO2(I),RSTRS(I),RSTGS(I),RSTBS(I))
  290    CONTINUE
         NBCSAV = 0
      ENDIF
      IF(ISTCOB.NE.0)THEN
         CALL ISCR(1,ISTCOB,RSTRBS,RSTGBS,RSTBBS)
         ISTCOB = 0
      ENDIF
      IF(ISTCOT.NE.0)THEN
         CALL ISCR(1,ISTCOT,RSTRTS,RSTGTS,RSTBTS)
         ISTCOT = 0
      ENDIF
*
*              Define the labels on the axis
*
      IF(NIDS.EQ.0)THEN
         XLAB1 = FLOAT(IXMIN)
         XLAB2 = FLOAT(IXMAX)
         YLAB1 = FLOAT(IYMIN)
         YLAB2 = FLOAT(IYMAX)
         IF(NPAR.GE.6)THEN
            IF(PAR(4).GT.PAR(3))THEN
               XLAB1 = PAR(3)
               XLAB2 = PAR(4)
            ENDIF
            IF(PAR(6).GT.PAR(5))THEN
               YLAB1 = PAR(5)
               YLAB2 = PAR(6)
            ENDIF
         ENDIF
         ZMINST = ZMIN
         ZMAXST = ZMAX
         IF(ILOG.NE.0)THEN
            ZMAXST = 10.**ZMAX
            ZMINST = 10.**ZMIN
         ENDIF
         IF(ILOGX.NE.0)THEN
            IF(XLAB2.GT.0.)THEN
               IF(XLAB1.LE.0.)XLAB1 = MIN(XLAB2/1000.,1.)
            ELSE
               ILOGX = 0
            ENDIF
         ENDIF
         IF(ILOGY.NE.0)THEN
            IF(YLAB2.GT.0.)THEN
               IF(YLAB1.LE.0.)YLAB1 = MIN(YLAB2/1000.,1.)
            ELSE
               ILOGY = 0
            ENDIF
         ENDIF
      ENDIF
*
*              Initialize the axis parameter
*
      XBUF(11) = 510.
      XBUF(12) = 510.
      XBUF(13) = 510.
      XBUF(14) = 1.
      XBUF(15) = 1.
      XBUF(16) = 1.
      XBUF(17) = 0.02
      XBUF(18) = 0.02
      XBUF(19) = 0.02
      XBUF(20) = 0.02
      XBUF(21) = 2.
      XBUF(22) = 0.02
      XBUF(23) = 0.02
      XBUF(24) = 0.04
      IF(NPAR.GT.10)THEN
         DO 300 I=11,NPAR
            XBUF(I) = PAR(I)
  300    CONTINUE
      ENDIF
      XBUF(25) = ILOGX
      XBUF(26) = ILOGY
      XBUF(27) = ILOG
*
*              Define the coordinate system
*
*    ISYS  = 1 : Cratesian Coordinate System
*    ISYS  = 2 : Polar Coordinate System
*    ISYS  = 3 : Cylindrical Coordinate System
*    ISYS  = 4 : Spherical Coordinate System
*    ISYS  = 5 : Pseudo rapidity
*    IRAST = 1 : "Raster screen" algorithm must be used
*                for hidden line drawing
*
      ISYS                = 1
      IF(IOPPOL.NE.0)ISYS = 2
      IF(IOPCYL.NE.0)ISYS = 3
      IF(IOPSPH.NE.0)ISYS = 4
      IF(IOPPSD.NE.0)ISYS = 5
      IF((IOPTL+IOPTS+IOPTS3).NE.0.AND.ISYS.GE.2)IRAST = 1
*
*              Define viewing angles
*
      THEDEG = 60.
      PHIDEG = -120.
      PSIDEG = 0.
      IF(NPAR.GE.2)THEN
         THEDEG =  90.-PAR(1)
         PHIDEG = -90.-PAR(2)
      ENDIF
*
      IDRGR = 1
      IF(NPAR.GE.25)THEN
         ISTCOL(NIDS+1) = PAR(25)
      ELSE
         IF(IOPTL.NE.0)THEN
            ISTCOL(NIDS+1) = 1
         ELSE
            ISTCOL(NIDS+1) = 0
         ENDIF
      ENDIF
*
*              Copy the color table in a INTEGER array. The
*              vector ITARR is used normally in the contour plot
*              algorithm so it can be used here without clashes.
*                If NPAR is less than 25 the LUT is used as the
*              color table.
*
      IF(NPAR.GE.25)THEN
         MAXCP = 0
         DO 310 I=25,NPAR
            IF(I.GT.100)THEN
               CALL IGERR('Color table too big','IGTABL')
               GOTO 450
            ENDIF
            ITARR(I-24) = INT(PAR(I))
            MAXCP       = MAXCP+1
  310    CONTINUE
      ELSE
         MAXCP=MAXCOL
         DO 320 I=1,MAXCOL
            ITARR(I)=LUT(I)
  320    CONTINUE
      ENDIF
*
*              If the errors are required and if one of the color
*              option is required, the colors represent the color,
*              so the minimum and maximum of the errors has to be
*              computed.
*
      IF (IOPTER.NE.0) THEN
         IF (IOPTS3+IOPTS1+IOPTS2+IOPTL2.NE.0) THEN
            Z1C = IGCELL(NX,NY,V,1,1,2)
            Z2C = Z1C
            DO 340 J=IYMIN,IXMAX
               DO 330 I=IXMIN,IXMAX
                  ZE = IGCELL(NX,NY,V,I,J,2)
                  IF (ZE.GT.Z2C) Z2C = ZE
                  IF (ZE.LT.Z1C) Z1C = ZE
  330          CONTINUE
  340       CONTINUE
         ENDIF
      ELSE
         Z1C = ZMIN
         Z2C = ZMAX*HMAX
      ENDIF
      RQUEST(11) = Z1C
      RQUEST(12) = Z2C
*
*              Create a buffer used by the "Raster screen" algorithm
*
      IF(IRAST.NE.0)THEN
         IF(IPACK.NE.0)LWV=INT(V(1))
         NWNEED = (NRASTX*NRASTY)/30+1
         CALL MZNEED(IXHIGZ,NWNEED+25,'G')
         IF (IQUEST(11).LT.0) THEN
            CALL IGERR('IGTABL','Not enough space in memory')
            GOTO 450
         ENDIF
         IF(LCG.NE.0)CALL MZDROP(IXHIGZ,LCG,' ')
         CALL MZBOOK(IXHIGZ,LCG,LCG,1,'TEMP',0,0,NWNEED,3,0)
         IF(IPACK.NE.0)V(1)=FLOAT(LWV)
      ENDIF
*
*              Initialise the adress NIDS+1 for IGCELL
*
      IF(IPACK.NE.0)THEN
         REFWRD(NIDS+1)=V(1)
      ELSE
         LSTACK(NIDS+1)=LOCF(V(1))
         IADRES(NIDS+1)=LSTACK(NIDS+1)-LOCF(REFWRD)
      ENDIF
*
* XSTP   = X step
* XSTP   = Y step
* RINRAD = Inner radius for Polar, Cylindrical, and Spherical representations
* DANG   = Delta angle for PSD option
*
      XSTP   = (XLAB2-XLAB1)/FLOAT(NXCHA)
      YSTP   = (YLAB2-YLAB1)/FLOAT(NYCHA)
      RINRAD = 0.5
      DANG   = 10.
*.______________________________________
*
*              Plotting surfaces
*
      IF(ISURF.NE.0)THEN
         IF(IOPTS2.NE.0.OR.IOPTS4.NE.0)IDRGR=0
         IF(IOPTS3.NE.0)IDRGR=3
         IXFCHA(1) = IXMIN
         IYFCHA(1) = IYMIN
         XVAL1     = XLAB1-(IXFCHA(1)-1)*XSTP
         XVAL2     = (NCX-NXCHA-IXFCHA(1)+1)*XSTP+XLAB2
         YVAL1     = YLAB1-(IYFCHA(1)-1)*YSTP
         YVAL2     = (NCY-NYCHA-IYFCHA(1)+1)*YSTP+YLAB2
         XBUF(1)   = -1.
         YBUF(1)   = 1.
         XBUF(2)   = -1.
         YBUF(2)   = 1.
         IF(IOPPOL.NE.0)THEN
            XBUF(3) = ZMIN
            YBUF(3) = ZMAX*HMAX
         ELSEIF(IOPCYL.NE.0)THEN
            IF(ILOGY.NE.0)THEN
               XBUF(3) = LOG10(YLAB1)
               YBUF(3) = LOG10(YLAB2)
            ELSE
               XBUF(3) = YLAB1
               YBUF(3) = YLAB2
            ENDIF
            PSIDEG  = 90.
         ELSEIF(IOPSPH.NE.0)THEN
            XBUF(3) = -1.
            YBUF(3) = 1.
            PSIDEG  = 90.
         ELSEIF(IOPPSD.NE.0)THEN
            XBUF(3) = -1./TAN(DANG*RAD)
            YBUF(3) = 1./TAN(DANG*RAD)
            PSIDEG  = 90.
         ELSE
            IF(ILOGX.NE.0)THEN
               XBUF(1) = LOG10(XLAB1)
               YBUF(1) = LOG10(XLAB2)
            ELSE
               XBUF(1) = XLAB1
               YBUF(1) = XLAB2
            ENDIF
            IF(ILOGY.NE.0)THEN
               XBUF(2) = LOG10(YLAB1)
               YBUF(2) = LOG10(YLAB2)
            ELSE
               XBUF(2) = YLAB1
               YBUF(2) = YLAB2
            ENDIF
            XBUF(3) = ZMIN
            YBUF(3) = ZMAX*HMAX
         ENDIF
         CALL ISWN3(INTR
     +,             XBUF(1),YBUF(1),XBUF(2),YBUF(2),XBUF(3),YBUF(3)
     +,             PHIDEG,THEDEG,PSIDEG,' ')
         CALL ISELNT(INTR)
         CALL IGTAB4(XBUF,YBUF,XBUF(16))
*
* Close the surface in case of non cartesian coordinates.
*
         IF(ISYS.GT.1.AND.IXMIN.EQ.1.AND.IXMAX.EQ.NX)NXCHA = NXCHA+1
*
* Draw the filled contour on top
*
         IF(IOPTS3.NE.0)THEN
            CALL IGLEV(MAXCP,Z1C,Z2C,ITARR,'C')
            IF(IOPPOL.NE.0)THEN
               CALL IHSURP(1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSEIF(IOPCYL.NE.0)THEN
               CALL IHSURR(1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSEIF(IOPSPH.NE.0)THEN
               CALL IHSURS(0,1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSEIF(IOPPSD.NE.0)THEN
               CALL IHSURS(1,1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSE
               CALL IHSURC(90.,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ENDIF
            IDRGR=1
         ENDIF
*
         IF(IRAST.NE.0)THEN
            CALL IHRINI(-1.1,-1.1,1.1,1.1,NRASTX,NRASTY,Q(LCG+1))
         ELSE
            CALL IHSINI(-1.1,1.1)
         ENDIF
*
         IF((IOPTS1+IOPTS2+IOPTS4).NE.0)THEN
            CALL IGLEV(INT(XBUF(13)+0.1),XBUF(3),YBUF(3),0,'A')
            CALL ISPLCI(1)
            IF(ISYS.EQ.1.AND.IOPTBB.EQ.0)
     +         CALL IHBBOX(XBUF,YBUF,90.,IHDFL1)
         ENDIF
*
* Gouraud Shading surface
*
         IF(IOPTS4.NE.0)THEN
* Define light palette
            RVAL(1)=FLOAT(IFACI)
            CALL IGQ('RGB ',RVAL)
            NBCS = INBCOL
            IF(INBCOL.LT.30)CALL IGSET('NCOL',30.)
            NCOL  = MIN(20,INBCOL-8)
            ICOL1 = INBCOL-NCOL+1
            DCOL  = 1./(2.*NCOL)
            CALL IGRTOH(RVAL(2),RVAL(3),RVAL(4),RHUE,RLIGHT,RSATUR)
            DO 350 I=ICOL1,ICOL1+NCOL-1
               CALL IGHTOR(RHUE,.4+FLOAT(I-ICOL1+1)*DCOL,RSATUR,R,G,B)
               CALL ISCR(1,I,R,G,B)
  350       CONTINUE
* Set light sources
            CALL IHLIGH(0,YDIFF, 0.,0.,0.,IREP)
            CALL IHLIGH(1,YLIGH1,1.,1.,1.,IREP)
            CALL IHPROP(QA,QD,QS,NQS,IREP)
            FMIN = YDIFF*QA
            FMAX = YDIFF*QA + (YLIGH1+0.1)*(QD+QS)
            CALL IHCSPE(NCOL,FMIN,FMAX,ICOL1,1,IREP)
            IF(IOPPOL.NE.0)THEN
               CALL IHSURP(1,NXCHA-1,NYCHA-1,IGTAB6,IHDF02,'BF')
            ELSEIF(IOPCYL.NE.0)THEN
               CALL IHSURR(1,NXCHA-1,NYCHA-1,IGTAB6,IHDF02,'BF')
            ELSEIF(IOPSPH.NE.0)THEN
               CALL IHSURS(0,1,NXCHA-1,NYCHA-1,IGTAB6,IHDF02,'BF')
            ELSEIF(IOPPSD.NE.0)THEN
               CALL IHSURS(1,1,NXCHA-1,NYCHA-1,IGTAB6,IHDF02,'BF')
            ELSE
               CALL IHSURC(90.,NXCHA-1,NYCHA-1,IGTAB6,IHDF02,'BF')
            ENDIF
            IF(NBCS.LE.8)CALL IGSET('NCOL',FLOAT(NBCS))
*
* Draw the surface
*
         ELSE
            IF(IOPTS1+IOPTS2.NE.0)THEN
               CALL IGLEV(MAXCP,Z1C,Z2C,ITARR,'C')
            ELSE
               CALL IGLEV(INT(XBUF(13)+0.1),XBUF(3),YBUF(3),0,'A')
            ENDIF
            IF(IOPPOL.NE.0)THEN
               IF(IOPTS+IOPTS3.NE.0)
     +         CALL IHSURP(1,NXCHA-1,NYCHA-1,IGTAB2,IHDFR1,'FB')
               IF(IOPTS1+IOPTS2.NE.0)
     +         CALL IHSURP(1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSEIF(IOPCYL.NE.0)THEN
               IF(IOPTS+IOPTS3.NE.0)
     +         CALL IHSURR(1,NXCHA-1,NYCHA-1,IGTAB2,IHDFR1,'FB')
               IF(IOPTS1+IOPTS2.NE.0)
     +         CALL IHSURR(1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSEIF(IOPSPH.NE.0)THEN
               IF(IOPTS+IOPTS3.NE.0)
     +         CALL IHSURS(0,1,NXCHA-1,NYCHA-1,IGTAB2,IHDFR1,'FB')
               IF(IOPTS1+IOPTS2.NE.0)
     +         CALL IHSURS(0,1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSEIF(IOPPSD.NE.0)THEN
               IF(IOPTS+IOPTS3.NE.0)
     +         CALL IHSURS(1,1,NXCHA-1,NYCHA-1,IGTAB2,IHDFR1,'FB')
               IF(IOPTS1+IOPTS2.NE.0)
     +         CALL IHSURS(1,1,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ELSE
               IF(IOPTS+IOPTS3.NE.0)
     +         CALL IHSURC(90.,NXCHA-1,NYCHA-1,IGTAB2,IHDFL1,'FB')
               IF(IOPTS1+IOPTS2.NE.0)
     +         CALL IHSURC(90.,NXCHA-1,NYCHA-1,IGTAB2,IHDF02,'BF')
            ENDIF
         ENDIF
*
         IF(IOPTS+IOPTS3.NE.0)THEN
            CALL ISPLCI(1)
            IF(ISYS.EQ.1.AND.IOPTBB.EQ.0)
     +         CALL IHBBOX(XBUF,YBUF,90.,IHDFL1)
         ENDIF
         IF(ISYS.EQ.1)THEN
            CALL IHSINI(-1.1,1.1)
            IF(IOPTFB.EQ.0)CALL IHFBOX(XBUF,YBUF,90.,IHDFL2)
         ENDIF
         IF(XBUF(11).NE.0.)CALL IGTAB5(XBUF,YBUF,90.,XBUF(11))
         GOTO 430
      ENDIF
*.______________________________________
*
*              Preparation for stacked legos plot
*
      IXFCHA(NIDS+1)=IXMIN
      IYFCHA(NIDS+1)=IYMIN
      IF(ILOG.NE.0)ZMAXST=10.**ZMAX
      IF(ILOG.NE.0)ZMINST=10.**ZMIN
      IXNCHA(NIDS+1)=NXCHA
      IYNCHA(NIDS+1)=NYCHA
      DO 360 I=1,NIDS
         IF(IXNCHA(I).LT.NXCHA)NXCHA=IXNCHA(I)
         IF(IYNCHA(I).LT.NYCHA)NYCHA=IYNCHA(I)
  360 CONTINUE
*
* Initialise the color indexes for lighting model (option L1 only)
*
      IF(IOPTL1.NE.0)THEN
         IF(INBCOL.LE.2)THEN
            ISTCOT=ISTCOL(NIDS+1)
            ISTCOB=ISTCOL(1)
            DO 370 I=1,NIDS+1
               ISTCO2(I)=ISTCOL(I)
  370       CONTINUE
         ELSE
            NBCSAV = NIDS+1
            DO 380 I=1,NBCSAV
               CALL IGGFIN(ISTCO2(I))
               RVAL(1)   = FLOAT(ISTCO2(I))
               CALL IGQ('RGB ',RVAL)
               RSTRS(I)  = RVAL(2)
               RSTGS(I)  = RVAL(3)
               RSTBS(I)  = RVAL(4)
               RVAL(1)   = FLOAT(ISTCOL(I))
               CALL IGQ('RGB ',RVAL)
               CALL IGRTOH(RVAL(2),RVAL(3),RVAL(4),RHUE,RLIGHT,RSATUR)
               RLIGHT = RLIGHT*0.6
               CALL IGHTOR(RHUE,RLIGHT,RSATUR,RED,GREEN,BLUE)
               CALL ISCR(1,ISTCO2(I),RED,GREEN,BLUE)
               IF(I.EQ.1)THEN
                  CALL IGGFIN(ISTCOB)
                  RVAL(1) = ISTCOB
                  CALL IGQ('RGB ',RVAL)
                  RSTRBS  = RVAL(2)
                  RSTGBS  = RVAL(3)
                  RSTBBS  = RVAL(4)
                  RLIGHT=RLIGHT*1.4
                  CALL IGHTOR(RHUE,RLIGHT,RSATUR,RED,GREEN,BLUE)
                  CALL ISCR(1,ISTCOB,RED,GREEN,BLUE)
               ENDIF
  380       CONTINUE
            CALL IGGFIN(ISTCOT)
            RVAL(1) = ISTCOT
            CALL IGQ('RGB ',RVAL)
            RSTRTS  = RVAL(2)
            RSTGTS  = RVAL(3)
            RSTBTS  = RVAL(4)
            RLIGHT=RLIGHT*1.4
            CALL IGHTOR(RHUE,RLIGHT,RSATUR,RED,GREEN,BLUE)
            CALL ISCR(1,ISTCOT,RED,GREEN,BLUE)
         ENDIF
      ENDIF
*
* Initialise the NIDS first adress for IGCELL
*
      DO 390 I=1,NIDS
         IF(IPACK.NE.0)THEN
            REFWRD(I)=FLOAT(LSTACK(I))
         ELSE
            IADRES(I)=LSTACK(I)-LOCF(REFWRD)
         ENDIF
  390 CONTINUE
*
* Compute the ZMAX value for the complete stack
*
      IF(NIDS.NE.0)THEN
         ZMINST=ZMAXST
         DO 420 J=1,NYCHA
            DO 410 I=1,NXCHA
               Z=0.
               ZLIN=0.
               DO 400 K=1,NIDS+1
                  IXT=IXFCHA(K)+I-1
                  IYT=IYFCHA(K)+J-1
                  IF(IPACK.NE.0)THEN
                     Z1=IGCELL(NCX,NCY,REFWRD(K),IXT,IYT,1)
                  ELSE
                     Z1=IGCELL(NCX,NCY,REFWRD(IADRES(K)+1),IXT,IYT,1)
                  ENDIF
                  Z=Z+Z1
                  IF(ILOG.NE.0)ZLIN=ZLIN+10.**Z1
  400          CONTINUE
               ZMAX=MAX(ZMAX,Z)
               ZMIN=MIN(ZMIN,Z)
               IF(ILOG.NE.0)THEN
                  ZMAXST=MAX(ZMAXST,ZLIN)
                  ZMAX=LOG10(ZMAXST)
                  ZMINST=MIN(ZMINST,ZLIN)
                  ZMIN=LOG10(ZMINST)
               ENDIF
  410       CONTINUE
  420    CONTINUE
      ENDIF
*
* Compute the values (for X and Y axis) on the bin 1 and NC
*
      XVAL1 = XLAB1-(IXFCHA(1)-1)*XSTP
      XVAL2 = (NCX-NXCHA-IXFCHA(1)+1)*XSTP+XLAB2
      YVAL1 = YLAB1-(IYFCHA(1)-1)*YSTP
      YVAL2 = (NCY-NYCHA-IYFCHA(1)+1)*YSTP+YLAB2
*.______________________________________
*
*              Draw the Lego plot
*
      IF(ILEGO.NE.0)THEN
         XBUF(1) = -1.
         YBUF(1) = 1.
         XBUF(2) = -1.
         YBUF(2) = 1.
         IF(ISYS.EQ.2)THEN
            XBUF(3) = ZMIN
            YBUF(3) = ZMAX*HMAX
         ELSEIF(ISYS.EQ.3)THEN
            IF(ILOGY.NE.0)THEN
               XBUF(3) = LOG10(YLAB1)
               YBUF(3) = LOG10(YLAB2)
            ELSE
               XBUF(3) = YLAB1
               YBUF(3) = YLAB2
            ENDIF
            PSIDEG  = 90.
         ELSEIF(ISYS.EQ.4)THEN
            XBUF(3) = -1.
            YBUF(3) = 1.
            PSIDEG  = 90.
         ELSEIF(ISYS.EQ.5)THEN
            XBUF(3) = -1./TAN(DANG*RAD)
            YBUF(3) = 1./TAN(DANG*RAD)
            PSIDEG  = 90.
         ELSE
            IF(ILOGX.NE.0)THEN
               XBUF(1) = LOG10(XLAB1)
               YBUF(1) = LOG10(XLAB2)
            ELSE
               XBUF(1) = XLAB1
               YBUF(1) = XLAB2
            ENDIF
            IF(ILOGY.NE.0)THEN
               XBUF(2) = LOG10(YLAB1)
               YBUF(2) = LOG10(YLAB2)
            ELSE
               XBUF(2) = YLAB1
               YBUF(2) = YLAB2
            ENDIF
            XBUF(3) = ZMIN
            YBUF(3) = ZMAX*HMAX
         ENDIF
*
         CALL IGLEV(INT(XBUF(13)+0.1),XBUF(3),YBUF(3),0,'A')
         CALL ISWN3(INTR
     +,             XBUF(1),YBUF(1),XBUF(2),YBUF(2),XBUF(3),YBUF(3)
     +,             PHIDEG,THEDEG,PSIDEG,' ')
         CALL ISELNT(INTR)
         CALL IGTAB4(XBUF,YBUF,XBUF(16))
*
         IF(IRAST.NE.0)THEN
            CALL IHRINI(-1.1,-1.1,1.1,1.1,NRASTX,NRASTY,Q(LCG+1))
         ELSE
            CALL IHSINI(-1.1,1.1)
         ENDIF
*
         IF((IOPTL1+IOPTL2).NE.0)THEN
            CALL ISPLCI(1)
            IF(ISYS.EQ.1.AND.IOPTBB.EQ.0)
     +         CALL IHBBOX(XBUF,YBUF,90.,IHDFL1)
         ENDIF
         IF(IOPTL2.NE.0)CALL IGLEV(MAXCP,Z1C,Z2C,ITARR,'C')
*
         IF(ISYS.EQ.2)THEN
            IF(IOPTL.NE.0) CALL IHLEGP(1,NXCHA,NYCHA,IGTAB3,IHDFR2,'FB')
            IF(IOPTL1.NE.0)CALL IHLEGP(1,NXCHA,NYCHA,IGTAB3,IHDF03,'BF')
            IF(IOPTL2.NE.0)CALL IHLEGP(1,NXCHA,NYCHA,IGTAB3,IHDF02,'BF')
         ELSEIF(ISYS.EQ.3)THEN
            IF(IOPTL.NE.0) CALL IHLEGR(1,NXCHA,NYCHA,IGTAB3,IHDFR2,'FB')
            IF(IOPTL1.NE.0)CALL IHLEGR(1,NXCHA,NYCHA,IGTAB3,IHDF03,'BF')
            IF(IOPTL2.NE.0)CALL IHLEGR(1,NXCHA,NYCHA,IGTAB3,IHDF02,'BF')
         ELSEIF(ISYS.EQ.4)THEN
            IF(IOPTL.NE.0)
     +        CALL IHLEGS(0,1,NXCHA,NYCHA,IGTAB3,IHDFR2,'FB')
            IF(IOPTL1.NE.0)
     +        CALL IHLEGS(0,1,NXCHA,NYCHA,IGTAB3,IHDF03,'BF')
            IF(IOPTL2.NE.0)
     +        CALL IHLEGS(0,1,NXCHA,NYCHA,IGTAB3,IHDF02,'BF')
         ELSEIF(ISYS.EQ.5)THEN
            IF(IOPTL.NE.0)
     +        CALL IHLEGS(1,1,NXCHA,NYCHA,IGTAB3,IHDFR2,'FB')
            IF(IOPTL1.NE.0)
     +        CALL IHLEGS(1,1,NXCHA,NYCHA,IGTAB3,IHDF03,'BF')
            IF(IOPTL2.NE.0)
     +        CALL IHLEGS(1,1,NXCHA,NYCHA,IGTAB3,IHDF02,'BF')
         ELSE
            IF(IOPTL.NE.0)
     +        CALL IHLEGC(90.,NXCHA,NYCHA,IGTAB3,IHDFL2,'FB')
            IF(IOPTL1.NE.0)
     +        CALL IHLEGC(90.,NXCHA,NYCHA,IGTAB3,IHDF03,'BF')
            IF(IOPTL2.NE.0)
     +        CALL IHLEGC(90.,NXCHA,NYCHA,IGTAB3,IHDF02,'BF')
         ENDIF
*
         IF(IOPTL.NE.0)THEN
            CALL ISPLCI(1)
            IF(ISYS.EQ.1.AND.IOPTBB.EQ.0)
     +         CALL IHBBOX(XBUF,YBUF,90.,IHDFL1)
         ENDIF
         IF(ISYS.EQ.1)THEN
            CALL IHSINI(-1.1,1.1)
            IF(IOPTFB.EQ.0)CALL IHFBOX(XBUF,YBUF,90.,IHDFL2)
         ENDIF
         IF(XBUF(11).NE.0.)CALL IGTAB5(XBUF,YBUF,90.,XBUF(11))
         NIDS = 0
         GOTO 450
      ENDIF
*.______________________________________
*
*              Draw the colour table if required
*
  430 IF(IOPTZ.NE.0)THEN
         XX=0.01*(RWXMAX-RWXMIN)
         CALL ISCLIP(0)
         IF(IOPTGZ.NE.0)THEN
            CALL IGCOLM(RWXMAX+XX,RWXMAX+4.*XX,RWYMIN,RWYMAX
     +,                 MAXCP,ITARR,10.**Z1C,10.**Z2C,'CAPG')
         ELSE
            CALL IGCOLM(RWXMAX+XX,RWXMAX+4.*XX,RWYMIN,RWYMAX
     +,                 MAXCP,ITARR,Z1C,Z2C,'CAP')
         ENDIF
         GOTO 450
      ENDIF
*.______________________________________
*
*              Draw the axis for the 2D representation
*
  440 IF(IOPTA.NE.0)THEN
         CALL ISLN(1)
         CALL ISFAIS(0)
         CALL IGBOX(RWXMIN,RWXMAX,RWYMIN,RWYMAX)
         XLAB1=FLOAT(IXMIN)
         XLAB2=FLOAT(IXMAX)
         YLAB1=FLOAT(IYMIN)
         YLAB2=FLOAT(IYMAX)
         IF(NPAR.GE.6)THEN
            IF(PAR(4).GT.PAR(3))THEN
               XLAB1=PAR(3)
               XLAB2=PAR(4)
            ENDIF
            IF(PAR(6).GT.PAR(5))THEN
               YLAB1=PAR(5)
               YLAB2=PAR(6)
            ENDIF
         ENDIF
         AXFLAG=.FALSE.
         CHOPT=' '
         IF(IOPTGX.NE.0)CHOPT='G'
         CALL IGAXIS(RWXMIN,RWXMAX,RWYMIN,RWYMIN,XLAB1,XLAB2,510,
     +   CHOPT)
         AXFLAG=.TRUE.
         CHOPT=' '
         IF(IOPTGY.NE.0)CHOPT='G'
         CALL IGAXIS(RWXMIN,RWXMIN,RWYMIN,RWYMAX,YLAB1,YLAB2,510,
     +   CHOPT)
         AXFLAG=.FALSE.
      ENDIF
*
* Restore original graphic context
*
  450 IF(IRAST.NE.0)THEN
         CALL MZDROP(IXHIGZ,LCG,' ')
         LCG = 0
      ENDIF
      CALL IZSET
      ZFLAG=ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGTCCH, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:39  mclareni
* Higz

      SUBROUTINE IGTCCH(CHTEXT)
*.===========>
*.
*.   This routine translate the IGTEXT control characters into
*.  IGTEXT printable characters.
*.
*. _Input/Output parameters:
*.
*.  CHARACTER CHTEXT : String to be converted
*.
*..==========> (O.Couet)
      PARAMETER (LENBUF=132)
      CHARACTER*(*) CHTEXT
      CHARACTER*(LENBUF) CHBUF
*.______________________________________
*
      ILEN  = LEN(CHTEXT)
      NCH   = LENOCC(CHTEXT)
      IF(ILEN.GT.LENBUF)GOTO 20
      LMAX  = LENBUF-3
      ICUR  = 1
      CHBUF = ' '
      DO 10 I=1,NCH
         IF(ICUR.GT.LMAX)GOTO 20
         IF     (CHTEXT(I:I).EQ.'<') THEN
            CHBUF(ICUR:) = '"L#'
         ELSEIF (CHTEXT(I:I).EQ.'>') THEN
            CHBUF(ICUR:) = '"G#'
         ELSEIF (CHTEXT(I:I).EQ.'#') THEN
            CHBUF(ICUR:) = '"F#'
         ELSEIF (CHTEXT(I:I).EQ.'$') THEN
            CHBUF(ICUR:) = '"D#'
         ELSEIF (CHTEXT(I:I).EQ.'[') THEN
            CHBUF(ICUR:) = '"M#'
         ELSEIF (CHTEXT(I:I).EQ.']') THEN
            CHBUF(ICUR:) = '"N#'
         ELSEIF (CHTEXT(I:I).EQ.'?') THEN
            CHBUF(ICUR:) = '"H#'
         ELSEIF (CHTEXT(I:I).EQ.'!') THEN
            CHBUF(ICUR:) = '"E#'
         ELSEIF (CHTEXT(I:I).EQ.'&') THEN
            CHBUF(ICUR:) = '"W#'
         ELSEIF (CHTEXT(I:I).EQ.':') THEN
            CHBUF(ICUR:) = '"J#'
         ELSEIF (CHTEXT(I:I).EQ.'%') THEN
            CHBUF(ICUR:) = '"Y#'
         ELSE
            CHBUF(ICUR:ICUR) = CHTEXT(I:I)
            ICUR = ICUR+1
            GOTO 10
         ENDIF
         ICUR = ICUR+3
   10 CONTINUE
      CHTEXT = CHBUF(1:LENOCC(CHBUF))
      RETURN
*
   20 CONTINUE
      CALL IGERR('Length of the input string is too small',
     +           'IGTCCH')
      END
+DECK,  IGTERM, T=FORT.
* Revision 1.3  1996/04/16 08:12:23  couet
* - rearange the #ifdef
* - test on IZBUF was missing (the zbuffer is reactivated)
* Revision 1.2  1996/04/16 07:38:18  couet
* The ZBUFER is temporarly deactivated for PS. It generated some
* 'gr' out of context.
* Revision 1.1.1.1  1996/02/14 13:10:40  mclareni
* Higz

      SUBROUTINE IGTERM
+CDE, HIFLAG.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=ZBUF, IF=PSCRIPT.
+CDE, HIPOST.
+CDE, HILUT.
+CDE, HIATT.
+CDE, HIWCPS.
+SELF, IF=MAIL.
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3)') 559
         CALL IMWRIT(4)
         RETURN
      ENDIF
+SELF, IF=GKS.
      CALL IUWK(0,0)
+SELF, IF=-GKS.
      CALL IUWK(0,1)
+SELF.
      CALL IGSA(0)
+SELF, IF=X11, IF=ZBUF, IF=PSCRIPT.
      IF (PFLAG.AND.IZBUF.NE.0) THEN
         CALL IGNG3D(W3X1,W3X2,W3Y1,W3Y2,W3Z1,W3Z2
     +,              PHI,THETA,PSI
     +,              V3X1,V3X2,V3Y1,V3Y2)
         IXPS1 = IXWCPS(V3X1)
         IXPS2 = IXWCPS(V3X2)
         IYPS1 = IYWCPS(V3Y1)
         IYPS2 = IYWCPS(V3Y2)
         CALL IPPSTR('@')
         CALL IHZPS(0,0,IXPS1,IYPS1,IXPS2,IYPS2,
     +              INBCOL,REDLUT,GRNLUT,BLULUT)
         CALL IPPFST('gr')
      ENDIF
+SELF.
      END
+DECK,  IGTEXT, T=FORT.
* Revision 1.5  1998/09/25 09:24:06  mclareni
* Modifications for the Mklinux port flagged by CERNLIB_PPC
* Revision 1.4  1998/01/30 15:22:19  couet
* - APOLLO version removed
* Revision 1.3  1997/03/14 14:23:15  mclareni
* WNT mods
* Revision 1.2.2.1  1997/01/21 11:25:32  mclareni
* All mods for Winnt 96a on winnt branch
* Revision 1.2  1996/04/02 22:26:07  thakulin
* Add F90 style hex initializers of arrays for EPC Fortran.
* Revision 1.1.1.1  1996/02/14 13:10:40  mclareni
* Higz

      SUBROUTINE IGTEXT(X,Y,KTEXT,SSIZE,ANGLE,CHOPT)
*.===========>
*.
*.   Routine to draw software characters using
*. the H E R S H E Y  character table .
*.
*. N.M. WOLCOTT, J. HILSENRATH
*. A contribution to computer typesetting techniques
*. table of coordinates for HERSHEY'S repertory
*. of occidental type fonts and graphics symbols
*. national bureau of standards
*. special publication No. 424
*. U.S. Government printing office,
*. Washington,  January 1976.
*.
*. Each x or y subcoordinate of each character
*. is packed in 6 bits (HERSHEY VALUE+32)
*. The number of coordinates in a word is
*. machine dependent
*.
*. The program contained in deck HERSHEY
*. is used to generate the table of packed values
*. for a given computer
*. COMDECK HERO20  to be used for machines
*.         with words having 60 bits or more
*. COMDECK HERO12  to be used for machines
*.         with words having 36 bits
*.         and octal representation
*. COMDECK HERO10  to be used for machines
*.         with words having 32 bits
*.         and octal representation
*. COMDECK HERZ8   to be used for machines
*.         with words having 30 bits or more
*.         and hexadecimal representation
*.
*. _Input parameters:
*.
*.  REAL X,Y : Coordinates for beginning of text .
*.  CHARACTER KTEXT : Text .
*.  INTEGER SSIZE : Text size .
*.  REAL ANGLE : The rotation angle in degrees .
*.  CHARACTER CHOPT : Option .
*.
*.                    CHOPT='L'eft .
*.                    CHOPT='R'ight .
*.                    CHOPT='C'enter .
*.                    CHOPT='S' return text length in ANGLE.
*.
*.
*..==========> (R.Brun O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=MAIL.
+CDE, HIMAIL.
+SELF.
      LOGICAL ZFSAV
      CHARACTER*(*) KTEXT,CHOPT
      DIMENSION ITEXT(255),IFORT(73),ISPEC(11)
      EQUIVALENCE(ITEXT(1),IFORT(1)),(ITEXT(74),ISPEC(1))
      DIMENSION XP(40),YP(40),XXP(40),YYP(40),LGREEK(26)
      DIMENSION IOPT(4)
      EQUIVALENCE (IOPT(1),IOPTL),(IOPT(2),IOPTC),(IOPT(3),IOPTR)
      EQUIVALENCE (IOPT(4),IOPTS)
      SAVE IFIRST,IPASS,IGO,IFORT,ISPEC
+SELF, IF=CDC.
      DIMENSION IA(64)
      DIMENSION ISTART(210),IX( 425),IY( 425)
      DIMENSION IX11( 36),IY11( 36)
      EQUIVALENCE (IX11(1),IX(  1)),(IY11(1),IY(  1))
      DIMENSION IX12( 36),IY12( 36)
      EQUIVALENCE (IX12(1),IX( 37)),(IY12(1),IY( 37))
      DIMENSION IX13( 36),IY13( 36)
      EQUIVALENCE (IX13(1),IX( 73)),(IY13(1),IY( 73))
      DIMENSION IX14( 36),IY14( 36)
      EQUIVALENCE (IX14(1),IX(109)),(IY14(1),IY(109))
      DIMENSION IX15( 36),IY15( 36)
      EQUIVALENCE (IX15(1),IX(145)),(IY15(1),IY(145))
      DIMENSION IX16( 36),IY16( 36)
      EQUIVALENCE (IX16(1),IX(181)),(IY16(1),IY(181))
      DIMENSION IX17( 36),IY17( 36)
      EQUIVALENCE (IX17(1),IX(217)),(IY17(1),IY(217))
      DIMENSION IX18( 36),IY18( 36)
      EQUIVALENCE (IX18(1),IX(253)),(IY18(1),IY(253))
      DIMENSION IX19( 36),IY19( 36)
      EQUIVALENCE (IX19(1),IX(289)),(IY19(1),IY(289))
      DIMENSION IX20( 36),IY20( 36)
      EQUIVALENCE (IX20(1),IX(325)),(IY20(1),IY(325))
      DIMENSION IX21( 36),IY21( 36)
      EQUIVALENCE (IX21(1),IX(361)),(IY21(1),IY(361))
      DIMENSION IX22( 29),IY22( 29)
      EQUIVALENCE (IX22(1),IX(397)),(IY22(1),IY(397))
+SELF, IF=CVX,CRAY.
      DIMENSION IA(256)
      DIMENSION ISTART(210),IX( 425),IY( 425)
      DIMENSION IX11( 54),IY11( 54)
      EQUIVALENCE (IX11(1),IX(  1)),(IY11(1),IY(  1))
      DIMENSION IX12( 54),IY12( 54)
      EQUIVALENCE (IX12(1),IX( 55)),(IY12(1),IY( 55))
      DIMENSION IX13( 54),IY13( 54)
      EQUIVALENCE (IX13(1),IX(109)),(IY13(1),IY(109))
      DIMENSION IX14( 54),IY14( 54)
      EQUIVALENCE (IX14(1),IX(163)),(IY14(1),IY(163))
      DIMENSION IX15( 54),IY15( 54)
      EQUIVALENCE (IX15(1),IX(217)),(IY15(1),IY(217))
      DIMENSION IX16( 54),IY16( 54)
      EQUIVALENCE (IX16(1),IX(271)),(IY16(1),IY(271))
      DIMENSION IX17( 54),IY17( 54)
      EQUIVALENCE (IX17(1),IX(325)),(IY17(1),IY(325))
      DIMENSION IX18( 47),IY18( 47)
      EQUIVALENCE (IX18(1),IX(379)),(IY18(1),IY(379))
+SELF, IF=NORD,HPUX.
      DIMENSION IA(256)
      SAVE IA
+SELF, IF=UNIVAC.
      DIMENSION IA(64)
+SELF, IF=NORD,UNIVAC,HPUX.
      DIMENSION ISTART(210),IX( 751),IY( 751)
      DIMENSION IX11( 90),IY11( 90)
      EQUIVALENCE (IX11(1),IX(  1)),(IY11(1),IY(  1))
      DIMENSION IX12( 90),IY12( 90)
      EQUIVALENCE (IX12(1),IX( 91)),(IY12(1),IY( 91))
      DIMENSION IX13( 90),IY13( 90)
      EQUIVALENCE (IX13(1),IX(181)),(IY13(1),IY(181))
      DIMENSION IX14( 90),IY14( 90)
      EQUIVALENCE (IX14(1),IX(271)),(IY14(1),IY(271))
      DIMENSION IX15( 90),IY15( 90)
      EQUIVALENCE (IX15(1),IX(361)),(IY15(1),IY(361))
      DIMENSION IX16( 90),IY16( 90)
      EQUIVALENCE (IX16(1),IX(451)),(IY16(1),IY(451))
      DIMENSION IX17( 90),IY17( 90)
      EQUIVALENCE (IX17(1),IX(541)),(IY17(1),IY(541))
      DIMENSION IX18( 90),IY18( 90)
      EQUIVALENCE (IX18(1),IX(631)),(IY18(1),IY(631))
      DIMENSION IX19( 31),IY19( 31)
      EQUIVALENCE (IX19(1),IX(721)),(IY19(1),IY(721))
+SELF, IF=-CDC, IF=-CVX, IF=-CRAY, IF=-NORD, IF=-UNIVAC, IF=-HPUX.
      DIMENSION IA(256)
      DIMENSION ISTART(210),IX( 751),IY( 751)
      DIMENSION IX11(108),IY11(108)
      EQUIVALENCE (IX11(1),IX(  1)),(IY11(1),IY(  1))
      DIMENSION IX12(108),IY12(108)
      EQUIVALENCE (IX12(1),IX(109)),(IY12(1),IY(109))
      DIMENSION IX13(108),IY13(108)
      EQUIVALENCE (IX13(1),IX(217)),(IY13(1),IY(217))
      DIMENSION IX14(108),IY14(108)
      EQUIVALENCE (IX14(1),IX(325)),(IY14(1),IY(325))
      DIMENSION IX15(108),IY15(108)
      EQUIVALENCE (IX15(1),IX(433)),(IY15(1),IY(433))
      DIMENSION IX16(108),IY16(108)
      EQUIVALENCE (IX16(1),IX(541)),(IY16(1),IY(541))
      DIMENSION IX17(103),IY17(103)
      EQUIVALENCE (IX17(1),IX(649)),(IY17(1),IY(649))
+SELF, IF=IPSC,ALLIANT,MACMPW.
      SAVE IA
      DATA (IX11(I),I=1,50)/
     +'1969C7D6'X,'217DC699'X,'269E79A4'X,'00FDF864'X,'2185E716'X,
     +'0000003F'X,'1C6DA696'X,'2696489E'X,'27663966'X,'0000003F'X,
     +'238266D6'X,'269E79A5'X,'1A6DE864'X,'00000FD9'X,'3FA198D6'X,
     +'0003F8E3'X,'1B69B956'X,'279A485E'X,'1E8649A7'X,'00FD969B'X,
     +'208A5996'X,'1B69A6DD'X,'2692181D'X,'219269E7'X,'3F69B760'X,
     +'19FDD9D6'X,'00000FE7'X,'1A69B796'X,'2692175B'X,'229669E7'X,
     +'1965A6DE'X,'258DF71A'X,'1E8A59A6'X,'0000003F'X,'208E5996'X,
     +'1965A71F'X,'2381F71A'X,'239669A5'X,'3F69B7A0'X,'20FD8817'X,
     +'3F95BFE8'X,'19FD9655'X,'279E6962'X,'19FE2966'X,'279E6962'X,
     +'3F662966'X,'23967A16'X,'1969B75F'X,'1F75B699'X,'3FA27963'X/
      DATA (IX11(I), I=51,108)/
     +'19FD9655'X,'279A58E0'X,'208E59A7'X,'00000FD9'X,'1AFDA696'X,
     +'3F89AFE7'X,'0003F9DA'X,'1AFDA696'X,'3F89AFE7'X,'23967A16'X,
     +'1969B75F'X,'1F75B699'X,'28A27963'X,'00FE88FF'X,'27FD9655'X,
     +'3F9D9FE7'X,'00FE081C'X,'228E4918'X,'1A6DC7A0'X,'00000FDA'X,
     +'27FD9655'X,'3F9DEFD9'X,'1AFDA696'X,'00000FE6'X,'18FD8614'X,
     +'3F828FE0'X,'0003FA28'X,'19FD9655'X,'3F9E7FE7'X,'1969C795'X,
     +'1C699618'X,'279A489E'X,'249A7A28'X,'0003F7A2'X,'19FD9655'X,
     +'279E6962'X,'3F662966'X,'1969C795'X,'1C699618'X,'279A489E'X,
     +'249A7A28'X,'2787F7A2'X,'0000003F'X,'19FD9655'X,'279E6962'X,
     +'3F662966'X,'0003F9E0'X,'1E8A59D6'X,'1B69965B'X,'279A58DD'X,
     +'1B7A2967'X,'00000FD9'X,'19FE0818'X,'00000FE7'X,'1C699655'X,
     +'279A485F'X,'00000FE7'X,'28FE0617'X/
      DATA (IX12(I),I=1,50)/
     +'00000FE0'X,'20FDB594'X,'3F960FDB'X,'0003F96A'X,'27FE7656'X,
     +'00000FD9'X,'3F820617'X,'0003F828'X,'19FD99D6'X,'3F9D9FE7'X,
     +'20FD8817'X,'3F95BFE8'X,'19FD9655'X,'279E6962'X,'19FE2966'X,
     +'279E6962'X,'3F662966'X,'1AFDA696'X,'00000FE6'X,'20FD8817'X,
     +'3FA18FE8'X,'1AFDA696'X,'3F89AFE7'X,'0003F9DA'X,'19FD99D6'X,
     +'3F9D9FE7'X,'27FD9655'X,'3F9D9FE7'X,'1969C795'X,'1C699618'X,
     +'279A489E'X,'249A7A28'X,'2377F7A2'X,'0000003F'X,'00FE081C'X,
     +'27FD9655'X,'3F9DEFD9'X,'20FD8817'X,'00000FE8'X,'18FD8614'X,
     +'3F828FE0'X,'0003FA28'X,'19FD9655'X,'3F9E7FE7'X,'1DFE7657'X,
     +'3F9D9FE3'X,'1969C795'X,'1C699618'X,'279A489E'X,'249A7A28'X/
      DATA (IX12(I), I=51,108)/
     +'0003F7A2'X,'27FD9655'X,'3F9D9FE7'X,'19FD9655'X,'279E6962'X,
     +'3F662966'X,'3F660657'X,'2767F9D9'X,'0000003F'X,'19FE0818'X,
     +'00000FE7'X,'1B699657'X,'2081F79D'X,'259A79FF'X,'3F8218A3'X,
     +'1EFE0816'X,'1A65969B'X,'2696279B'X,'229669E7'X,'00000FDE'X,
     +'19FE7656'X,'00000FE7'X,'17FE0815'X,'1C6DA658'X,'2696485F'X,
     +'00FE9A27'X,'1969D656'X,'217DC699'X,'269E79A4'X,'0003F9E3'X,
     +'18FE0814'X,'3FA18FE8'X,'00FE081C'X,'1A69E79A'X,'268A279E'X,
     +'3F7A28A6'X,'22FDE796'X,'26966FE2'X,'1E8A59E7'X,'1B69965B'X,
     +'3F9E58DD'X,'258DD6D9'X,'229679E6'X,'1A6596DE'X,'0003F69B'X,
     +'20FE081B'X,'3F82181F'X,'27FDA856'X,'3FA1AFE0'X,'0003F9D9'X,
     +'3F628614'X,'1C6DA697'X,'2696489E'X,'20824966'X,'2181F83F'X,
     +'00000FE0'X,'2AA68A54'X,'23967A6A'X/
      DATA (IX13(I),I=1,50)/
     +'1D7A0862'X,'228E4FDC'X,'1B75E7E0'X,'175965D9'X,'0003F5D8'X,
     +'2181F81B'X,'207E0FE0'X,'0003F821'X,'2181F81B'X,'1F821FE0'X,
     +'1F821860'X,'0000003F'X,'3FA18A14'X,'1EFDD759'X,'3F91DFDE'X,
     +'0003F91D'X,'23FE2899'X,'3F8DCFE3'X,'0003F8DC'X,'3F6E56D8'X,
     +'256FF95B'X,'0000003F'X,'1E7E0899'X,'218607DE'X,'1F7E0FDF'X,
     +'218A2860'X,'218A285D'X,'3F81F7E0'X,'1F82185F'X,'2281F79E'X,
     +'0000003F'X,'22860799'X,'1F7E0862'X,'21860FE1'X,'1F79E7E0'X,
     +'1F79E7E3'X,'3F821860'X,'2181F7E1'X,'1E8218A2'X,'0000003F'X,
     +'3F81748F'X,'20C3F816'X,'0000003F'X,'1865C814'X,'1F75B658'X,
     +'27920FE0'X,'23967A28'X,'1F83F821'X,'22860FDE'X,'00FE27BF'X/
      DATA (IX13(I), I=51,108)/
     +'1C79F814'X,'1961865B'X,'20FE071A'X,'279648A1'X,'249A7A28'X,
     +'00000FE0'X,'1769E814'X,'299A283F'X,'2079A5FF'X,'208A6A7F'X,
     +'0000003F'X,'26922814'X,'26A29A68'X,'2387F864'X,'1F863924'X,
     +'1F75C71D'X,'1869C7FF'X,'1C6985D7'X,'1F83F81E'X,'22860FDE'X,
     +'00FE27BF'X,'28A6AA93'X,'208A49A7'X,'165D869E'X,'207D85D6'X,
     +'1C7A0861'X,'2379C6DB'X,'2AAA99E5'X,'0000003F'X,'27FE7655'X,
     +'00000FD9'X,'1DFDA998'X,'1A6DD79E'X,'2485D6DA'X,'228A3FE6'X,
     +'259A6963'X,'00000FE3'X,'258E2815'X,'2BAEAA67'X,'23967A6A'X,
     +'196DD7A2'X,'16555597'X,'1E75B657'X,'00000FE0'X,'1C71D7DC'X,
     +'248E17DD'X,'3F7E18E4'X,'1E7BF75D'X,'20FDF7FF'X,'3F861FE0'X,
     +'238FF8A2'X,'0000003F'X,'2491C71C'X,'3F75DFDC'X,'1F7FF79E'X,
     +'21FE083F'X,'3F8A2FE1'X,'0003F8E3'X/
      DATA (IX14(I),I=1,50)/
     +'2095B81B'X,'20FDD83F'X,'3F7E0FE3'X,'0003F860'X,'206E581B'X,
     +'20FE383F'X,'3F860FDD'X,'0003F7E0'X,'1A99C81A'X,'2083F824'X,
     +'20FDA83F'X,'3F920FDC'X,'0003F9A0'X,'3F9A9993'X,'17FE3A23'X,
     +'00000FE8'X,'3F8A0798'X,'20FE581B'X,'00000FE0'X,'3F697693'X,
     +'18FDD61D'X,'00000FE9'X,'3F8A0798'X,'20FE581B'X,'00000FE0'X,
     +'2181F81B'X,'00FDF821'X,'2181F81B'X,'00000FE0'X,'207E085B'X,
     +'3F7E0861'X,'00FD7A55'X,'1E822919'X,'2281E75D'X,'00000FE4'X,
     +'2281E719'X,'1E8228E3'X,'00000FDC'X,'00FE95D3'X,'17FE0813'X,
     +'00000FE9'X,'17FE95D3'X,'00000FE9'X,'1BFE0818'X,'3F6E5FE5'X,
     +'1D75E81B'X,'238E281E'X,'0003F822'X,'3F82079B'X,'2385F75B'X/
      DATA (IX14(I), I=51,108)/
     +'3F8DD8A3'X,'2385F75B'X,'2183F863'X,'1D7E18E3'X,'0000003F'X,
     +'21FE185B'X,'0003F91C'X,'207DD79B'X,'1F8228E2'X,'3F89EFDD'X,
     +'1D7A089B'X,'238A079D'X,'3F75E822'X,'1DFDF8DB'X,'00000FE3'X,
     +'1F75D7DB'X,'1F8638E1'X,'1F75D7FF'X,'3F8638E1'X,'1E8228DB'X,
     +'238A079D'X,'3F7A08A3'X,'26FE6997'X,'1B75F8A4'X,'1F75B69A'X,
     +'00FE6922'X,'1AFDA696'X,'258E179C'X,'218E59A6'X,'00FDA71E'X,
     +'1F8A4997'X,'1B69A6DD'X,'269227DD'X,'0000003F'X,'26FE6997'X,
     +'1B75F8A4'X,'1F75B69A'X,'00FE6922'X,'259A6697'X,'1B75F8A4'X,
     +'1F75B69A'X,'00FE6922'X,'2086395B'X,'3F91DFE0'X,'24966997'X,
     +'26FDD7E2'X,'1B75F8A4'X,'1F75B69A'X,'00FE6922'X,'1BFDB6D7'X,
     +'2696381E'X,'00000FE6'X,'208607DC'X,'3F820FDF'X,'218A181B'X,
     +'20861FE0'X,'0003F71E'X,'25FDB6D7'X/
      DATA (IX15(I),I=1,50)/
     +'3F99FFDB'X,'00FE081C'X,'15FD5551'X,'207DD698'X,'258E0FE0'X,
     +'3FAEBAA8'X,'1BFDB6D7'X,'2696381E'X,'00000FE6'X,'1A6DD7D7'X,
     +'227DD6DA'X,'269E79A4'X,'00FDF8A4'X,'1AFDA696'X,'258E179C'X,
     +'218E59A6'X,'00FDA71E'X,'26FE6997'X,'1B75F8A4'X,'1F75B69A'X,
     +'00FE6922'X,'1DFDD759'X,'3F96281E'X,'1F8A5998'X,'2379C6DC'X,
     +'229669A5'X,'00FDB71F'X,'2386081B'X,'3F91DFE5'X,'1E71B6D7'X,
     +'26FE68E1'X,'00000FE6'X,'26FE0698'X,'00000FE0'X,'20FDC615'X,
     +'3F920FDC'X,'0003F928'X,'26FE66D8'X,'00000FDB'X,'26FE0698'X,
     +'1969C7A0'X,'0000003F'X,'1BFDB998'X,'3F99BFE6'X,'1A6DD7D6'X,
     +'1E71A659'X,'289E58E0'X,'238A17FF'X,'3FA279A5'X,'1D7E18D7'X/
      DATA (IX15(I), I=51,108)/
     +'3F65A6DC'X,'269E7963'X,'20FE08E5'X,'24965922'X,'1C75F863'X,
     +'00000FDB'X,'1D71A617'X,'2086181F'X,'209A7A3F'X,'0003F75E'X,
     +'1B75F897'X,'1E71B69A'X,'259648A0'X,'1F7E08A4'X,'3F9A48A0'X,
     +'1F8A4958'X,'3F85E75D'X,'1C6DB761'X,'3F96385E'X,'1F7E0898'X,
     +'26FE68E0'X,'1B6DC7E2'X,'228A179C'X,'00FDE7E1'X,'1C6985D6'X,
     +'3F69C75D'X,'248A079C'X,'3F8A59A6'X,'1B657595'X,'1C6DB71C'X,
     +'248E17DD'X,'239669A5'X,'23860821'X,'0003FA25'X,'1D75E81A'X,
     +'3F8E281E'X,'27FD9757'X,'1D7E3966'X,'1F79CFDC'X,'3F9238A1'X,
     +'1E75B658'X,'3F6A0FE6'X,'1CFD7756'X,'217DD6DB'X,'259FF963'X,
     +'299E5924'X,'00000FEA'X,'1B71D697'X,'259A7FDA'X,'3F69D823'X,
     +'1F7E0898'X,'23FE68E0'X,'1F75D7A0'X,'1E8BF922'X,'2175B6DC'X,
     +'3F7A08A2'X,'1B71E818'X,'217DD71B'X/
      DATA (IX16(I),I=1,50)/
     +'259A6963'X,'00FE08A4'X,'23FDA795'X,'17FE6964'X,'00FE9719'X,
     +'1D71B6D7'X,'2696385F'X,'208A4966'X,'3F5DB71E'X,'1B75FA57'X,
     +'1E71B69A'X,'259648A0'X,'00FE18E4'X,'18FDE856'X,'00FE875A'X,
     +'1C6985D6'X,'1D6DB75D'X,'279A489F'X,'00000FE7'X,'1865B755'X,
     +'1F71A658'X,'28A27962'X,'1E822926'X,'00000FDB'X,'2375B657'X,
     +'27A3F9E5'X,'3F6196E5'X,'15FDC914'X,'1B6DA616'X,'1F75B69A'X,
     +'29A26922'X,'0000003F'X,'1761A714'X,'1D6D9617'X,'207E0FDF'X,
     +'289E58E1'X,'00FE69E8'X,'1BFE0818'X,'3F95BFE5'X,'00FE081E'X,
     +'209D9819'X,'2066783F'X,'0000003F'X,'22FDF7D9'X,'24925FE2'X,
     +'1C7A3965'X,'3F96475C'X,'2596475C'X,'1C75F8A4'X,'3F71D75C'X/
      DATA (IX16(I), I=51,108)/
     +'21FE081E'X,'21820FE1'X,'0003F821'X,'23FDE81B'X,'3F91DFE1'X,
     +'0003F91D'X,'3F6E56D8'X,'2386079C'X,'21860823'X,'21820FE3'X,
     +'0003F821'X,'279E6997'X,'20862926'X,'23FDD79F'X,'1E7E0862'X,
     +'1A65969C'X,'00000FDA'X,'2186081E'X,'21820FE0'X,'0003F821'X,
     +'2186081E'X,'20821FE0'X,'00FE0861'X,'3F95B958'X,'1FFDE79B'X,
     +'3F8DEFDF'X,'0003F8DE'X,'22FE185B'X,'3F89DFE2'X,'0003F89D'X,
     +'3F95B958'X,'256FF95B'X,'0000003F'X,'1E79F85A'X,'1E7FF860'X,
     +'1EFE087F'X,'1E82185F'X,'1E7E1860'X,'1EFE183F'X,'1E821FDF'X,
     +'00FE17DE'X,'228A17DB'X,'2287F7E0'X,'22FE07FF'X,'2281F7E1'X,
     +'2285F7E0'X,'22FDF83F'X,'2281FFE1'X,'00FDF862'X,'3F81A5D5'X,
     +'20A7F819'X,'0000003F'X,'217DE795'X,'1657F8A2'X,'1B69A658'X,
     +'269A58DD'X,'3FAEAA27'X,'1E7FFAD5'X/
      DATA (IX17(I),I=1,50)/
     +'3F86285F'X,'20FE0818'X,'3F860FDF'X,'1F83F85F'X,'1C7FF71E'X,
     +'248A183F'X,'20FE487F'X,'1EFD869C'X,'2483F61A'X,'268BFA26'X,
     +'1D7A0FE8'X,'1D7A0FDD'X,'238E283F'X,'3F8E283F'X,'20FE0818'X,
     +'3F820FE0'X,'2183F7E0'X,'20FE17FF'X,'2183F79F'X,'2281EFE2'X,
     +'1B71E83F'X,'2592283F'X,'2281E73F'X,'1C7A0FE4'X,'3F69965A'X,
     +'279A48A0'X,'1E73F9A7'X,'20FE48A0'X,'1969B75E'X,'20FDA618'X,
     +'279A58E2'X,'1BFE6A28'X,'3F96381D'X,'20FDF818'X,'3F85FFE1'X,
     +'28A268E0'X,'27A27967'X,'218E48E5'X,'1B75C75F'X,'196D9619'X,
     +'2075A618'X,'0000003F'X,'218A391A'X,'1D71C760'X,'1E821860'X,
     +'2385F75D'X,'00000FE4'X,'23FE375B'X,'00000FDD'X,'29AABAD7'X/
      DATA (IX17(I), I=51,103)/
     +'1A761926'X,'1A6175D8'X,'299A485D'X,'00FEBAEA'X,'24967A16'X,
     +'1C79F862'X,'1961865B'X,'217DE71B'X,'289E5922'X,'00000FE8'X,
     +'1969C7D9'X,'217DC699'X,'269E79A4'X,'00FDF864'X,'2699A69A'X,
     +'00000FDA'X,'209D9819'X,'0000003F'X,'2681A81A'X,'00000FE0'X,
     +'1D61E818'X,'288E581B'X,'0003F822'X,'239A3897'X,'23963FE2'X,
     +'00FE56BF'X,'1DFE081B'X,'3F8E281E'X,'00FE281E'X,'1D69D797'X,
     +'1D6DDFDE'X,'00FE66FF'X,'1DFE081B'X,'3F8E281E'X,'00FE281E'X,
     +'2182085E'X,'0003F821'X,'2186081E'X,'00000FE0'X,'2182085E'X,
     +'0003F821'X,'00FDC91B'X,'1F7E089D'X,'0003F8A0'X,'2186079C'X,
     +'0003F7A0'X,'00FE471A'X,'1CFE081A'X,'00000FE4'X,'1CFE471A'X,
     +'00000FE4'X,'1DFE081B'X,'3F763FE3'X/
      DATA (IY11(I),I=1,50)/
     +'1D61552A'X,'29A68960'X,'18760968'X,'00FD4515'X,'2951762A'X,
     +'0000003F'X,'1559866A'X,'18595514'X,'29A5F71A'X,'0000003F'X,
     +'1C71452A'X,'268E179D'X,'27A29A68'X,'00000FE5'X,'208A252A'X,
     +'0003FA54'X,'1C75452A'X,'2179C6DB'X,'29A689A3'X,'00FE59E8'X,
     +'145155EA'X,'2689D615'X,'26A29A68'X,'1C75F8A3'X,'3F89F75C'X,
     +'1482952A'X,'00000FD4'X,'195D552A'X,'2079D71B'X,'29A27962'X,
     +'22967A29'X,'1B71D7A0'X,'145155D9'X,'0000003F'X,'2181E6EA'X,
     +'1A6DE821'X,'15514557'X,'289606D7'X,'3F9A8A69'X,'14829529'X,
     +'3F8A2829'X,'1482952A'X,'1A616554'X,'1E81E75C'X,'258A07DE'X,
     +'3FA69A27'X,'1455766B'X,'1C657554'X,'29A26921'X,'3F926A29'X/
      DATA (IY11(I), I=51,108)/
     +'1482952A'X,'1C657554'X,'29A26921'X,'00000FE9'X,'14829529'X,
     +'2079E814'X,'0003FA69'X,'14829528'X,'3F79E814'X,'1455766B'X,
     +'1C657554'X,'29A26921'X,'21926A29'X,'00FE1860'X,'1482952B'X,
     +'3F79E829'X,'00FE9524'X,'289E4528'X,'249E8A69'X,'00000FE2'X,
     +'1482952A'X,'3FA5D822'X,'29829527'X,'00000FE9'X,'1482952C'X,
     +'20A54829'X,'0003FA54'X,'1482952B'X,'3FA54829'X,'195D552B'X,
     +'289A485C'X,'249A8A69'X,'155D9721'X,'0003F514'X,'1482952A'X,
     +'1B616554'X,'3F7DF79D'X,'195D552B'X,'289A485C'X,'249A8A69'X,
     +'155D9721'X,'2B960514'X,'0000003F'X,'1482952A'X,'1A616554'X,
     +'2079E75C'X,'0003FA5E'X,'145155EA'X,'1C6D95D5'X,'238607DD'X,
     +'28A69A26'X,'00000FE6'X,'14829528'X,'00000FD4'X,'289A352B'X,
     +'239A8A69'X,'00000FD4'X,'14829529'X/
      DATA (IY12(I),I=1,50)/
     +'00000FE9'X,'1482952C'X,'20A54829'X,'0003FA54'X,'1482952A'X,
     +'00000FE9'X,'20A5E529'X,'0003F794'X,'1482952A'X,'3FA69814'X,
     +'14829529'X,'3F8A2829'X,'1482952A'X,'1A616554'X,'1E81E75C'X,
     +'258A07DE'X,'3FA69A27'X,'14829527'X,'00000FD4'X,'14829529'X,
     +'3FA69829'X,'14829529'X,'2079E814'X,'0003FA69'X,'1482952A'X,
     +'3FA69814'X,'1482952B'X,'3F79E829'X,'195D552B'X,'289A485C'X,
     +'249A8A69'X,'155D9721'X,'1E7A0514'X,'0000003F'X,'00FE9524'X,
     +'1482952A'X,'3FA5D822'X,'14829529'X,'00000FE9'X,'1482952C'X,
     +'20A54829'X,'0003FA54'X,'1482952B'X,'3FA54829'X,'1E814529'X,
     +'3FA6981E'X,'195D552B'X,'289A485C'X,'249A8A69'X,'155D9721'X/
      DATA (IY12(I), I=51,108)/
     +'0003F514'X,'1482952B'X,'3F514829'X,'1482952A'X,'1B616554'X,
     +'3F7DF79D'X,'20A5E529'X,'29A60514'X,'0000003F'X,'14829528'X,
     +'00000FD4'X,'14557669'X,'296D7554'X,'14557660'X,'3F6D7554'X,
     +'1982952A'X,'2281D6DA'X,'228E4923'X,'1969B760'X,'00000FD9'X,
     +'2982952A'X,'00000FD4'X,'1A82952B'X,'2285F6DA'X,'1F8628E3'X,
     +'00FDA69B'X,'1E8A9A6A'X,'145155DA'X,'2279A5D5'X,'0003FA69'X,
     +'2082962C'X,'3FA69820'X,'00FF0424'X,'2279E6A6'X,'228A69A2'X,
     +'3F69A79E'X,'1082D42A'X,'1961782D'X,'145155D8'X,'1C6D95D5'X,
     +'208A07DD'X,'1F79C6D9'X,'29A268A0'X,'24966A29'X,'0003F9A5'X,
     +'27822525'X,'3F9E8A68'X,'1083042B'X,'2075D830'X,'0003F8E3'X,
     +'3FA605EC'X,'15598669'X,'18595514'X,'227DD71A'X,'28A689E0'X,
     +'00000FE7'X,'124D246C'X,'13450411'X/
      DATA (IY13(I),I=1,50)/
     +'2CA1C615'X,'1851282E'X,'2FB6BA24'X,'2DBAFC30'X,'0003FBEE'X,
     +'1C75C6E5'X,'29A2781B'X,'0003F9E8'X,'1C75C6E5'X,'28A6881B'X,
     +'2DB2AA27'X,'0000003F'X,'3FA605EC'X,'10830427'X,'20410830'X,
     +'0003FC30'X,'10830427'X,'20410830'X,'0003FC30'X,'2085D668'X,
     +'269A08A2'X,'0000003F'X,'14491427'X,'1D6D9616'X,'154D181F'X,
     +'1E71A617'X,'289A48A0'X,'20BEDAE9'X,'289E58E1'X,'30BEEB2A'X,
     +'0000003F'X,'14491427'X,'1D6D9616'X,'154D181F'X,'1E71A617'X,
     +'289A48A0'X,'20BEDAE9'X,'289E58E1'X,'30BEEB2A'X,'0000003F'X,
     +'209DB6F0'X,'29220A5C'X,'0000003F'X,'2179A5AC'X,'259A6963'X,
     +'1E696823'X,'269A58E1'X,'278E08E5'X,'2A9E382A'X,'00FEAAA0'X/
      DATA (IY13(I), I=51,108)/
     +'165D972C'X,'207595D6'X,'1C82A962'X,'175965D9'X,'258A0759'X,
     +'00000FEA'X,'2075856C'X,'20758560'X,'2BA23820'X,'2BA23820'X,
     +'0000003F'X,'269A58AC'X,'1E7E18E5'X,'1D7E07DE'X,'1659765B'X,
     +'1F75B657'X,'1F79E7E0'X,'269A58E1'X,'278A08A5'X,'2A9E282A'X,
     +'00FEAAA0'X,'1B6DC76D'X,'289A379C'X,'259E8A69'X,'1B720863'X,
     +'155155D9'X,'267DC657'X,'27A29A68'X,'0000003F'X,'1982766B'X,
     +'00000FE7'X,'19826668'X,'1C75D71A'X,'1A69965A'X,'258E2819'X,
     +'228E59A6'X,'00000FE2'X,'2592382B'X,'1F863925'X,'1C6DB71D'X,
     +'259648DD'X,'1D7E18E4'X,'1D71B6DC'X,'00000FE0'X,'217DD724'X,
     +'218E4923'X,'2071C75F'X,'227A085F'X,'1D823760'X,'208DD823'X,
     +'217E089E'X,'0000003F'X,'1C924724'X,'208DD81C'X,'237608DD'X,
     +'1D823760'X,'208DD823'X,'0003F8DD'X/
      DATA (IY14(I),I=1,50)/
     +'1A8E36A5'X,'1D822760'X,'208A0822'X,'0003F8A0'X,'2675D9A5'X,
     +'2381E8E0'X,'207A081E'X,'0003F7A0'X,'1E7A56A6'X,'1A8206A5'X,
     +'2081E820'X,'20960825'X,'0003F7A0'X,'208A07AD'X,'2082581B'X,
     +'00000FE0'X,'206976A8'X,'1881D61D'X,'00000FE9'X,'208A07AD'X,
     +'2082581B'X,'00000FE0'X,'209A99A8'X,'17823A23'X,'00000FE8'X,
     +'155155A5'X,'00FDA657'X,'28A689E5'X,'00000FE7'X,'27A29A25'X,
     +'3FB6CAA8'X,'00FF042B'X,'19552427'X,'2EAE789E'X,'00000FF0'X,
     +'19552427'X,'2EAE789E'X,'00000FF0'X,'00FE082D'X,'208295ED'X,
     +'00000FE0'X,'2381D76D'X,'00000FE3'X,'1D8266A8'X,'3F8DD823'X,
     +'2179C6E5'X,'1E863923'X,'0003F6DC'X,'3F91B765'X,'1C6DB725'X/
      DATA (IY14(I), I=51,108)/
     +'3F92481E'X,'1C6DB725'X,'1F7E07DE'X,'239248E0'X,'0000003F'X,
     +'1B8246E5'X,'0003F861'X,'1E79F6E5'X,'2492385F'X,'3F6DB823'X,
     +'1E71B6E5'X,'218E48E1'X,'3F85F79F'X,'1B8246E5'X,'00000FDB'X,
     +'1F79C6E5'X,'1B6DC79F'X,'248E07E0'X,'3F7E08E4'X,'208607A5'X,
     +'1E71B71E'X,'3F9248E1'X,'1E8296EA'X,'1E71B6DC'X,'29A268E1'X,
     +'00FE6A29'X,'1E829529'X,'1E71B6DC'X,'29A268E1'X,'00FE6A29'X,
     +'1B6DC7A9'X,'268E179C'X,'26A29A68'X,'0000003F'X,'1E82952A'X,
     +'1E71B6DC'X,'29A268E1'X,'00FE6A29'X,'1D7E1869'X,'1E71B6DC'X,
     +'29A268E1'X,'00FE6A29'X,'18554527'X,'3F6DB829'X,'2FBAB6EA'X,
     +'1E82FC30'X,'1E71B6DC'X,'29A268E1'X,'00FE6A29'X,'1F82952A'X,
     +'1F71B6DC'X,'00000FE9'X,'13515524'X,'3FA5B814'X,'13515525'X,
     +'2FB1B814'X,'0003FC30'X,'1B829528'X/
      DATA (IY15(I),I=1,50)/
     +'3FA61825'X,'00FE9524'X,'1F8296EF'X,'1F71B6DC'X,'1B71F829'X,
     +'3FA5F71B'X,'1F8296EA'X,'1F71B6DC'X,'00000FE9'X,'2179C6EA'X,
     +'29A689A3'X,'1E8639A8'X,'00FDB6DC'X,'1E8306E9'X,'1E71B6DC'X,
     +'29A268E1'X,'00FE6A29'X,'1E8306EA'X,'1E71B6DC'X,'29A268E1'X,
     +'00FE6A29'X,'218296E6'X,'3F6DB71E'X,'1B6DC7A9'X,'2286079C'X,
     +'29A26963'X,'00FE6A29'X,'29A25527'X,'3F6DB829'X,'29A256EA'X,
     +'1B825A29'X,'00000FE9'X,'1B8296E8'X,'00000FE9'X,'1B8296EB'X,
     +'20A5B829'X,'0003FA5B'X,'1B8296E9'X,'00000FE9'X,'1B8296E8'X,
     +'30C2FB69'X,'0000003F'X,'1B8296E9'X,'3FA6981B'X,'2079C6EB'X,
     +'29A689A3'X,'1B7A2968'X,'1E71B6E0'X,'3FA69A26'X,'1B5D552A'X/
      DATA (IY15(I), I=51,108)/
     +'20C2889E'X,'1B656514'X,'1D81D75C'X,'2796281E'X,'27A29A68'X,
     +'00000FE4'X,'1B6DC7AA'X,'2992075C'X,'2981E6E0'X,'0003FC2D'X,
     +'1E71B6E9'X,'29A27921'X,'208E6A29'X,'155D96DD'X,'3F5D5514'X,
     +'1B6DC768'X,'2086079C'X,'289A48A1'X,'3F9A8A69'X,'17595527'X,
     +'19819658'X,'258E075B'X,'2FB6BA67'X,'00FEEC30'X,'1B6DD7EA'X,
     +'20A6279C'X,'1B6DC7A2'X,'3FC2581D'X,'1B6DD7EA'X,'289A379C'X,
     +'23968A69'X,'145586E0'X,'1E6D8594'X,'0003F8A0'X,'289A26E5'X,
     +'3F967A69'X,'1C8296E9'X,'2181C6DB'X,'238A1821'X,'3FA29A68'X,
     +'16554528'X,'3FA5B829'X,'1F8306EB'X,'28A699E4'X,'226E08A6'X,
     +'27A69A26'X,'00000FE5'X,'2685B6E9'X,'2079B829'X,'3FA689A3'X,
     +'17595528'X,'19819658'X,'217DD6DA'X,'238A08A2'X,'2CAA89A4'X,
     +'3FC30BED'X,'2179C6E9'X,'29A689E4'X/
      DATA (IY16(I),I=1,50)/
     +'1D8239A8'X,'00FDB6DC'X,'1B8296EB'X,'1E8299A1'X,'00FDB6DC'X,
     +'289E4869'X,'239A8A69'X,'1B6DC760'X,'3FC2179C'X,'1E71B6EB'X,
     +'29A27921'X,'208E6A29'X,'00FDB71D'X,'1E8296EA'X,'00FDB6DC'X,
     +'1B6DD7EA'X,'299E479C'X,'1E8A6A29'X,'00000FDB'X,'227DD72B'X,
     +'29A689E5'X,'1D8239A8'X,'2685D6DB'X,'00000FF0'X,'2E75B6E9'X,
     +'1D6E0C30'X,'3FC2EAE0'X,'1F83052B'X,'1E71B6DD'X,'29A689A3'X,
     +'1B7A39A8'X,'0000003F'X,'227DC6EB'X,'28A69A25'X,'28961825'X,
     +'22968A69'X,'00FDB71F'X,'208266E8'X,'3F9A6820'X,'00FE56A2'X,
     +'18924627'X,'2871CA20'X,'0000003F'X,'1682A5A8'X,'1B69A82A'X,
     +'1A65969B'X,'208A179C'X,'248A075C'X,'249669A5'X,'3F9248E3'X/
      DATA (IY16(I), I=51,108)/
     +'1B8206E3'X,'24923820'X,'0003F8E3'X,'1A8256A6'X,'2079E825'X,
     +'0003F861'X,'3F9A06A8'X,'1C6DB725'X,'1F8207DE'X,'2492381E'X,
     +'0003F8E3'X,'176185E9'X,'1D698596'X,'178299E3'X,'289A3759'X,
     +'28A29AAA'X,'00000FE9'X,'1E7DF7A3'X,'2492381E'X,'0003F8E3'X,
     +'1E7DF7A3'X,'2392481E'X,'00FE7963'X,'3F9A06A8'X,'1682A5A5'X,
     +'2059682A'X,'0003FAAA'X,'1682A5A5'X,'2059682A'X,'0003FAAA'X,
     +'2085D668'X,'269A08A2'X,'0000003F'X,'1A6175A5'X,'1A5E079C'X,
     +'1881F720'X,'207DE71A'X,'289A48A1'X,'26824860'X,'26922829'X,
     +'00FEAA68'X,'1A6175A6'X,'1A5E079C'X,'1881F720'X,'207DE71A'X,
     +'289A48A1'X,'26824860'X,'26922829'X,'00FEAA68'X,'2095D769'X,
     +'2652099D'X,'0000003F'X,'145155EB'X,'26A205D5'X,'1865E8A4'X,
     +'1E6585D7'X,'20A26922'X,'29A20A28'X/
      DATA (IY17(I),I=1,50)/
     +'3FA29AAA'X,'218216E8'X,'20AA182A'X,'186E0AAA'X,'15620556'X,
     +'155986E0'X,'1B815620'X,'1A81B659'X,'196E06DA'X,'1A6A06D9'X,
     +'1D71B81B'X,'2075B820'X,'2075C6E0'X,'3F81D6E0'X,'1C8195E8'X,
     +'208E181E'X,'2A9E0AA7'X,'1582AAA0'X,'17560617'X,'185D8818'X,
     +'1C75C660'X,'1C75C660'X,'1D71D760'X,'2285E81D'X,'208A1822'X,
     +'208A285E'X,'228A08A1'X,'238228A1'X,'27A289E6'X,'238289E5'X,
     +'27A289E6'X,'288289E5'X,'3FA289E8'X,'2782A9E8'X,'20AAA82A'X,
     +'239A8A27'X,'1B7608A2'X,'155986DA'X,'1A6D8595'X,'228A075B'X,
     +'27A289A3'X,'0000003F'X,'23860826'X,'20863924'X,'1B6DC79F'X,
     +'248E179C'X,'00000FE4'X,'1D823765'X,'00000FE3'X,'218E6A2B'X/
      DATA (IY17(I), I=51,103)/
     +'1D71C75E'X,'238A17DE'X,'1F8A3924'X,'00FD869D'X,'238E282A'X,
     +'1C75E862'X,'2281F75C'X,'1E8628E3'X,'1F75C71D'X,'00000FE0'X,
     +'1F71A667'X,'279E6921'X,'1C7E1926'X,'00FD965A'X,'1A9A66A6'X,
     +'00000FDA'X,'18924627'X,'0000003F'X,'20AA05A6'X,'00000FD6'X,
     +'2175D5E8'X,'1D8678E7'X,'0003F5DD'X,'2281E769'X,'2281E823'X,
     +'00FE0820'X,'1E8266E5'X,'2079D69D'X,'00FDD6DD'X,'2281E769'X,
     +'2281E823'X,'00FE0820'X,'228256A5'X,'208A39A3'X,'00FE3963'X,
     +'1B6DC723'X,'0003F7DD'X,'239248E3'X,'00000FE3'X,'238E4923'X,
     +'0003F9E5'X,'00FE56A5'X,'2179C6A4'X,'0003F963'X,'2179C6A3'X,
     +'0003F963'X,'00FE0826'X,'20824726'X,'00000FE0'X,'2281E7A6'X,
     +'00000FE2'X,'1E823765'X,'3F89E822'X/
      DATA ISTART/
     +  1,  5,  7, 11, 15, 17, 21, 26, 28, 35, 40, 42, 47, 51, 55,
     + 58, 60, 65, 67, 68, 71, 73, 75, 78, 80, 85, 88, 94, 98,103,
     +105,108,110,113,115,117,119,121,126,128,130,133,135,137,143,
     +144,146,148,151,153,155,160,162,165,168,170,174,179,181,185,
     +189,191,192,195,204,206,209,210,215,222,225,229,230,233,236,
     +239,248,257,260,267,273,278,288,296,298,304,311,319,325,329,
     +333,338,341,344,347,350,352,354,356,357,360,363,364,366,368,
     +370,373,374,376,380,382,385,388,390,394,397,401,405,409,413,
     +417,419,424,427,429,432,434,435,439,442,446,450,454,456,460,
     +462,465,467,470,472,475,477,482,489,493,498,502,507,511,517,
     +519,523,525,530,533,539,543,546,550,554,556,560,565,568,573,
     +578,580,581,584,591,594,597,598,602,608,611,614,615,618,621,
     +624,632,640,643,650,663,682,691,696,698,703,709,713,715,717,
     +719,722,725,728,731,734,736,738,740,741,743,745,746,748,750/
*
      DATA NBIT,NBITCH,NBITMX/32,8,30/
+SELF, IF=CDC.
      DATA IX11/
     +O"41373432313132343726",O"00773741444647474644",
     +O"00000000774141363426",O"46454442363433323226",
     +O"00000000774731434546",O"46474746454340463326",
     +O"00000077313233364144",O"00007743437750314326",
     +O"47464441363332334526",O"00773132333641444647",
     +O"33323233354042454626",O"41444647474644414035",
     +O"00000000007732333540",O"00000077473177354726",
     +O"46444135333232333626",O"31313233364245464747",
     +O"36424546464543373432",O"00000000000000000077",
     +O"31313234374043454626",O"43454646454340373432",
     +O"00000000007732333640",O"77453377504077304027",
     +O"47474645423177313125",O"47474645423177424546",
     +O"00000000007731424546",O"31323335374345475026",
     +O"77504745433735333231",O"47464543403177313125",
     +O"00000077314043454647",O"77423277473277323226",
     +O"00000000000000774732",O"77423277473277323226",
     +O"31323335374345475026",O"50504745433735333231",
     +O"00000000000077504377",O"77473177474777313125"/
      DATA IX12/
     +O"00000000000077404034",O"32333436404243444430",
     +O"00000000000000007732",O"77473677314777313125",
     +O"00000077463277323226",O"77405077403077303024",
     +O"00000000000000775050",O"77474777473177313125",
     +O"34323130303132343625",O"44464750504746444236",
     +O"00000000000000773642",O"47474645423177313125",
     +O"00000000007731424546",O"34323130303132343625",
     +O"44464750504746444236",O"00000000774741773642",
     +O"47474645423177313125",O"00007747407731424546",
     +O"33323131333642454726",O"33364245474746454335",
     +O"00000000000000007731",O"00000077473177404030",
     +O"47464441373432313125",O"00000000000000007747",
     +O"00000077405077403027",O"77454077334077332624",
     +O"00000000000000774552",O"00000077314777473126",
     +O"00007740507740403027",O"77473177473177314726",
     +O"77453377504077304027",O"47474645423177313125",
     +O"47474645423177424546",O"00000000007731424546",
     +O"00000077463277323226",O"77503077504077304027"/
      DATA IX13/
     +O"77423277473277323226",O"00000000000000774732",
     +O"77473177473177314726",O"77473177474777313125",
     +O"34323130303132343625",O"44464750504746444236",
     +O"00000000774335773642",O"00000000000077404034",
     +O"77473677314777313125",O"00000077504077304027",
     +O"77405077403077303024",O"00000000000000775050",
     +O"77474777473177313125",O"77473177433577473127",
     +O"34323130303132343625",O"44464750504746444236",
     +O"00000000000000773642",O"77473177474777313125",
     +O"47474645423177313125",O"00000000007731424546",
     +O"47317747317731403127",O"00000000000000000077",
     +O"00000077473177404030",O"40403736353332313127",
     +O"77404142434546474777",O"32313132333677404026",
     +O"42454647474645423633",O"00000000000000007736",
     +O"00000077473177473126",O"34333231302777404025",
     +O"00775150474645444137",O"41373432313132353126",
     +O"00007747434647474644",O"77503077503077404024",
     +O"00000000000077404034",O"46424236363232363632"/
      DATA IX14/
     +O"00000000007736424246",O"46454677424277363626",
     +O"33323131333642454747",O"45433533317747454335",
     +O"32313133364245474746",O"00000000000000773233",
     +O"77404140374077404033",O"77503277404777324126",
     +O"00000000000000774731",O"00000000007730503024",
     +O"46454442363433323227",O"41403740774040444546",
     +O"00000000000000007740",O"43454751525251505124",
     +O"42434477343536404142",O"27262627313335363740",
     +O"00000000000000772730",O"40374077404140374033",
     +O"00000000000000774041",O"37404177404140374033",
     +O"00000000773740414140",O"00000000007750305024",
     +O"77443577363677353531",O"00000000000000774435",
     +O"77433477434377424231",O"00000000000000774334",
     +O"45337745337733453330",O"00000000000000000077",
     +O"41414037363637404231",O"41424241403737407737",
     +O"77403737404142424135",O"42403736363740414137",
     +O"00000000000000000077",O"37374041424241403631",
     +O"37363637404141407741",O"77404141403736363743"/
      DATA IX15/
     +O"36404142424140373741",O"00000000000000000077",
     +O"40607740267740272217",O"00000000000000000077",
     +O"37353331303031344024",O"43454750504744407740",
     +O"42414077363740774041",O"00000000000077423677",
     +O"31303031333436374024",O"47454442414077403432",
     +O"00000077404446475050",O"51464240772732364024",
     +O"40424651774036322777",O"00000000000000000077",
     +O"46505151504644424024",O"37414344444341774144",
     +O"30323437773735343435",O"37407740363432302727",
     +O"00774236774241407736",O"40424446475051525223",
     +O"40373027262627303236",O"43363433333436404141",
     +O"00000000775252514745",O"00000077314777473125",
     +O"32333536363577324630",O"42424377464441353332",
     +O"00000077434546464543",O"53535251474543424025",
     +O"31333536424345475152",O"36353331272625252627",
     +O"00000000000000007740",O"44434137353434353734",
     +O"36367735357737414344",O"77414177404077373777",
     +O"00000000774343774242",O"77353577344444343434"/
      DATA IX16/
     +O"41774040773737773636",O"00007743437742427741",
     +O"40773540774045334033",O"00007741407737407743",
     +O"40774340774033454033",O"00007737407741407735",
     +O"40407740443246344032",O"77444077344077324077",
     +O"00000000000000774640",O"27774350437746514623",
     +O"00000000000000007750",O"40774540337742403630",
     +O"00000000000000007740",O"30773530357732273223",
     +O"00000000000000007751",O"40774540337742403630",
     +O"00000000000000007740",O"00773740414140374033",
     +O"00000077404140374033",O"77374041414037404133",
     +O"00000000000077275125",O"42403635353640424431",
     +O"00000000000000007744",O"36404243434240363431",
     +O"00000000000000007734",O"00000000000077512723",
     +O"00000077512777404023",O"00000077512777512723",
     +O"77334577453377404030",O"43434240363535364033",
     +O"00000000000000774042",O"00000000007740403633",
     +O"77433542434341373533",O"41407741434341373533",
     +O"00000000773537414343",O"00007744344177414133"/
      DATA IX17/
     +O"37404243424037353633",O"00000000007742367735",
     +O"43424036353536404233",O"00000000007735364042",
     +O"00000077433577374333",O"37414343413735353733",
     +O"77414343413735353777",O"43424036353640424333",
     +O"00000000007736404243",O"33353742444677464627",
     +O"00774644423735333232",O"45434136343277323226",
     +O"00773234364143454646",O"33323233353742444627",
     +O"00000000774644423735",O"33353742444677464627",
     +O"00774644423735333232",O"33353742444546463227",
     +O"00774644423735333232",O"77443577404041434533",
     +O"46773537424445464627",O"37353332323335374244",
     +O"00000000000077464442",O"46454340363377333327",
     +O"00000000000000007746",O"77404077374041403734",
     +O"40414177404142414033",O"00000000000000773436",
     +O"77463777334577333327",O"00000000000077404034",
     +O"40373532302577252521",O"77535352504543407740",
     +O"46454340363377333327",O"00000000000000007746",
     +O"42373533323233353727",O"00773742444647474644"/
      DATA IX18/
     +O"45434136343277323226",O"00773234364143454646",
     +O"33353742444677464627",O"00774644423735333232",
     +O"77454240363577353531",O"43363433343742454630",
     +O"00773334374245464645",O"77443577454341404033",
     +O"46774643413634333327",O"00000000000000007746",
     +O"00000077404677403230",O"77444077344077343025",
     +O"00000000000000774450",O"00000077334677463330",
     +O"31323436404677403230",O"00000000000000000077",
     +O"77463377463377334630",O"36343231313233353726",
     +O"43424137775047454340",O"00000000007750474645",
     +O"77313233343537414327",O"40774043454647474543",
     +O"34353741434445454442",O"00000000000000007733",
     +O"40414140373534323027",O"00007735364046475077",
     +O"36343332323335374227",O"37374042444545444240",
     +O"00000000007746444240",O"77413635353742444530",
     +O"77454341363433333541",O"46774643403737404230",
     +O"42424136343333343742",O"00000000000077363741",
     +O"77323435353432302726",O"77424546464442403634"/
      DATA IX19/
     +O"34333334343331272625",O"43454646454443413735",
     +O"00007750454341404041",O"77434240363535364032",
     +O"35374345464777313527",O"77444342413736347734",
     +O"77324077463635333130",O"41373533333477273526",
     +O"51474544444547774543",O"00000000000000007752",
     +O"45464777323334353227",O"00000000007732354043",
     +O"43774643403737404230",O"36427744423735353640",
     +O"77364042424135333334",O"41373534333334364030",
     +O"00774042444546464543",O"27774645444377323625",
     +O"00000000000077513431",O"46454341373534333327",
     +O"77273334364042444546",O"36343332323335375127",
     +O"00774143444545444240",O"00775035323077364126",
     +O"35333335353432302726",O"00000077474746444237",
     +O"37343231303031333525",O"36404244465050474542",
     +O"00000000000000007733",O"47507747454335333127",
     +O"00000000007730313345",O"33333230262577344424",
     +O"51504644423735333232",O"00000000000000000077",
     +O"35333130272730323424",O"50474543414037407737"/
      DATA IX20/
     +O"00000000000077464750",O"77453377453377404030",
     +O"00000000000077404036",O"40314740774047314031",
     +O"00000000000000000077",O"44444577424277373731",
     +O"77454435343436434545",O"34353742444545443534",
     +O"00000000007734353534",O"41404077414177404036",
     +O"00000000000000774041",O"77443577414377364033",
     +O"00000000000000774435",O"00000000007733453330",
     +O"41414040434341403634",O"00007740414140407743",
     +O"40414244464747464627",O"36374041424377353637",
     +O"00000077323231313234",O"41404077404141404036",
     +O"00000000000000774041",O"40404177404141404036",
     +O"00000000000077404141",O"00000000007745334530",
     +O"77433677373777363633",O"00000000000000774336",
     +O"77423577424277414133",O"00000000000000774235",
     +O"45337745337745334530",O"00000000000000000077",
     +O"36377741403636374132",O"36404141373677404177",
     +O"36774140773637414140",O"00774137363640417737",
     +O"42417737404242413733",O"42403737414277403777"/
      DATA IX21/
     +O"42773740774241373740",O"00773741424240377741",
     +O"40517740317740322725",O"00000000000000000077",
     +O"26257742424137363625",O"46464543353332323130",
     +O"36377753257753525047",O"00000000007741424137",
     +O"77414077374077404030",O"34377734363740774137",
     +O"40774441774442414077",O"44407730323677303234",
     +O"35364077504642775046",O"43434240773536407735",
     +O"00000000007743424077",O"77404077404077404030",
     +O"40774137774140773740",O"42403677424140773637",
     +O"45444240773334364077",O"34364077444240363477",
     +O"47464442407732313132",O"40774442403634774647",
     +O"40773230303132333536",O"33774650504746454342",
     +O"00000000007745434035",O"77413777414077374030",
     +O"47504745475050464340",O"33353435374143444345",
     +O"40353230303133313031",O"00000000000000000077",
     +O"35343435404142434432",O"43413735353640414140",
     +O"00000000000000007744",O"00000077354377433533",
     +O"32354144465152535327",O"51464441353230272730"/
      DATA IX22/
     +O"00000000000077535352",O"34363741424445475026",
     +O"41373634333130303133",O"00000077505047454442",
     +O"41373432313132343731",O"00773741444647474644",
     +O"00000077324646323232",O"00000000774047314031",
     +O"00000077404640324032",O"50434540333530364030",
     +O"00000000000000774042",O"43454377424346434227",
     +O"00000000000077453277",O"77434240363577404033",
     +O"00000000000077424036",O"35333577363532353627",
     +O"00000000000077463377",O"77434240363577404033",
     +O"00000000000077424036",O"00007740414140404136",
     +O"00000077404141404036",O"00007740414140404136",
     +O"00000000000077344433",O"00007742403737404235",
     +O"00007736404141403634",O"00000000000077443432",
     +O"00000077443477404032",O"00000077443477443432",
     +O"77354377433577404033"/
      DATA IY11/
     +O"51515045403530252452",O"00772424253035404550",
     +O"00000000775124273052",O"30262524242526303152",
     +O"00000000775151373432",O"46434136353434242452",
     +O"00000077454750515150",O"00007751244042422452",
     +O"41363433333435242452",O"00774547505151504643",
     +O"46423530252424252752",O"34353742434650515150",
     +O"00000000007742373534",O"00000077242440512452",
     +O"40363534333127252452",O"42454750515150474542",
     +O"24242527313334353640",O"00000000000000000077",
     +O"32333640414140363352",O"50454033272524242527",
     +O"00000000007746505151",O"77424240512440512451",
     +O"32302625242440512452",O"45424037363640363534",
     +O"00000000007751515047",O"34312725242425273153",
     +O"77444650515150464441",O"34312725242440512452",
     +O"00000077515150464441",O"40363640242440512451",
     +O"00000000000000775151",O"77363640242440512450",
     +O"34312725242425273153",O"41444650515150464441",
     +O"00000000000077414140",O"77363640512440512453"/
      DATA IY12/
     +O"00000000000077512444",O"44475051515047442450",
     +O"00000000000000007742",O"77513540422440512452",
     +O"00000077515140512447",O"40512440512440512454",
     +O"00000000000000775124",O"77512440512440512453",
     +O"50464441343127252453",O"25273134414446505151",
     +O"00000000000000772424",O"33302625242440512452",
     +O"00000000007737373635",O"50464441343127252453",
     +O"25273134414446505151",O"00000000775345402424",
     +O"32302625242440512452",O"00007751364036363534",
     +O"34333127252424252752",O"50515150464341403735",
     +O"00000000000000007746",O"00000077242440512450",
     +O"43465051515046432453",O"00000000000000007724",
     +O"00000077512440512451",O"40512440512440512454",
     +O"00000000000000775124",O"00000077512440512452",
     +O"00007736244051362451",O"77515140242440512452",
     +O"77424240512440512451",O"32302625242440512452",
     +O"45424037363640363534",O"00000000007751515047",
     +O"00000077242440512447",O"77515140512440512451"/
      DATA IY13/
     +O"40363640242440512451",O"00000000000000775151",
     +O"77515140242440512452",O"77363640512440512453",
     +O"50464441343127252453",O"25273134414446505151",
     +O"00000000773636402424",O"00000000000077512444",
     +O"77513540422440512452",O"00000077512440512451",
     +O"40512440512440512454",O"00000000000000775124",
     +O"77512440512440512453",O"77515140363640242451",
     +O"50464441343127252453",O"25273134414446505151",
     +O"00000000000000772424",O"77242440512440512453",
     +O"33302625242440512452",O"00000000007737373635",
     +O"51514024244051362451",O"00000000000000000077",
     +O"00000077242440512450",O"51332725242425273151",
     +O"77332725242425273140",O"42403533323140512452",
     +O"31323335404243444443",O"00000000000000007731",
     +O"00000077245140512452",O"42413733323240512453",
     +O"00773232333741424343",O"24242527323642515152",
     +O"00007751514236322725",O"77515140404040513054",
     +O"00000000000077602044",O"42424646424236363246"/
      DATA IY14/
     +O"00000000007732323636",O"31302740552040552052",
     +O"34333127252424252730",O"37363433314042403735",
     +O"44454650515150464240",O"00000000000000774645",
     +O"77475051504740422445",O"40353540602040602053",
     +O"00000000000000774343",O"00000000007751402754",
     +O"30262524242526303151",O"50515047404237353432",
     +O"00000000000000007747",O"23212020212223222154",
     +O"30242240565450343025",O"55565760605755535044",
     +O"00000000000000775756",O"51504740333435343345",
     +O"00000000000000774750",O"50515040333435343345",
     +O"00000000775554525047",O"00000000007751402754",
     +O"40202040602040602047",O"00000000000000776060",
     +O"40202040602040602047",O"00000000000000776060",
     +O"46464042424041353150",O"00000000000000000077",
     +O"35333130262422212047",O"36343230272523214037",
     +O"40575553515046444240",O"60575654525047454341",
     +O"00000000000000000077",O"35333130262422212047",
     +O"36343230272523214037",O"40575553515046444240"/
      DATA IY15/
     +O"60575654525047454341",O"00000000000000000077",
     +O"51104051344047333360",O"00000000000000000077",
     +O"45464645434136322654",O"46464543413632264043",
     +O"52474340524743404345",O"00000000000077525240",
     +O"40353127262627313454",O"27262627313440524542",
     +O"00000077524542403531",O"40353025404035302554",
     +O"53504340405350434040",O"00000000000000000077",
     +O"36374143454646454254",O"26262731333537403736",
     +O"37363637403735333127",O"47424042454646454341",
     +O"00775252405247424052",O"50464336343333343555",
     +O"33344041434547505151",O"46373431272524252731",
     +O"00000000774750515150",O"00000077473140473153",
     +O"34353534323140463150",O"45434240313232313132",
     +O"00000077424243454646",O"37414344454544434053",
     +O"45454443353433333435",O"35343333343537414344",
     +O"00000000000000007740",O"41434444434137353444",
     +O"42364041374034343537",O"40433540433540433540",
     +O"00000000774137404236",O"40433540343444443444"/
      DATA IY16/
     +O"35404335404335404335",O"00007743354043354043",
     +O"35404235403243433245",O"00007742404042404042",
     +O"43403643404635354645",O"00007736404036404036",
     +O"32404032453636453246",O"40454040454040364040",
     +O"00000000000000773640",O"40404540334042403655",
     +O"00000000000000007740",O"30403530354032273250",
     +O"00000000000000007751",O"40404540334042403655",
     +O"00000000000000007740",O"27404350434046514650",
     +O"00000000000000007750",O"00773231272524252645",
     +O"00000077475051504745",O"77555452504750515045",
     +O"00000000000077602053",O"56534742363125222047",
     +O"00000000000000007760",O"56534742363125222047",
     +O"00000000000000007760",O"00000000000077404055",
     +O"00000077404040512755",O"00000077434340353555",
     +O"77433540433540463250",O"36414344434136343345",
     +O"00000000000000773334",O"00000000007744333545",
     +O"77444440363433333445",O"37374037363433333445",
     +O"00000000774344444340",O"00007741413340443345"/
      DATA IY17/
     +O"44444341373636373345",O"00000000007733334043",
     +O"41434443413634333345",O"00000000007741373637",
     +O"00000077333340443345",O"33333436373736343345",
     +O"77374043444443403740",O"36343334364041403645",
     +O"00000000007744444341",O"36343333343640513352",
     +O"00774650515150464341",O"36343333343640512451",
     +O"00774650515150464341",O"46434136343333343651",
     +O"00000000774650515150",O"36343333343640512452",
     +O"00774650515150464341",O"36343333343537414151",
     +O"00774650515150464341",O"77333340513025242447",
     +O"36405760605756533352",O"51504643413634333334",
     +O"00000000000077465051",O"37343333343740512452",
     +O"00000000000000007751",O"77513340242324252444",
     +O"57543340242324252445",O"00000000000000776060",
     +O"77514140453340512450",O"00000000000077512444",
     +O"37343333343740513357",O"77513734333334374051",
     +O"37343333343740513352",O"00000000000000007751",
     +O"51515046434136343352",O"00773333343641434650"/
      DATA IY18/
     +O"36343333343640603351",O"00774650515150464341",
     +O"36343333343640603352",O"00774650515150464341",
     +O"77333334364140513346",O"42414036343333343651",
     +O"00774650515150464543",O"77333340515150452447",
     +O"33404550515150453352",O"00000000000000007751",
     +O"00000077513340513350",O"40513340513340513353",
     +O"00000000000000775133",O"00000077513340513351",
     +O"60605755513340513350",O"00000000000000000077",
     +O"77515140333340513351",O"51515046434036343353",
     +O"36343333403336424550",O"00000000007751515046",
     +O"40605042363327252452",O"35403535343331262424",
     +O"47505151504745424036",O"00000000000000007744",
     +O"51444035343333343652",O"00007760555140363340",
     +O"51504744413634333351",O"25273133354043465051",
     +O"00000000007727252424",O"40414036343333343550",
     +O"77465051515046444241",O"31403131302726252447",
     +O"57555351474543403533",O"00000000000077566060",
     +O"40514236343333353752",O"77604540353333343642"/
      DATA IY19/
     +O"50464336343333353752",O"24253033404345505151",
     +O"00007742403633302624",O"77454751515046423345",
     +O"41403433333440513351",O"77505151504342414041",
     +O"77513340512625242450",O"50515147443740603353",
     +O"47515150464233404246",O"00000000000000007745",
     +O"40363340514641333351",O"00000000007751504643",
     +O"31403131302726252450",O"43424042424137353332",
     +O"77606057555452504644",O"51515047444136343351",
     +O"00773333343540434650",O"36405146413340513353",
     +O"00000000000077333334",O"43465051515047444151",
     +O"77604136343333343540",O"51504744413634333353",
     +O"00773334354043465051",O"00773333343640513352",
     +O"51474436343333353752",O"00000077333642465051",
     +O"51515047454237353453",O"46413533333540434650",
     +O"00000000000000007760",O"35334060605635333351",
     +O"00000000007760565340",O"36343333353740602453",
     +O"33364346505151504643",O"00000000000000000077",
     +O"50515150454237343353",O"42455051515045414045"/
      DATA IY20/
     +O"00000000000077333437",O"77464640404040463350",
     +O"00000000000077453242",O"50343450403044443047",
     +O"00000000000000000077",O"33323240522640522650",
     +O"40424136343231313233",O"44454646454442403534",
     +O"00000000007744444343",O"44444340403340403343",
     +O"00000000000000774343",O"40363640453240453246",
     +O"00000000000000774141",O"00000000007746403250",
     +O"37404037363433333445",O"00007743434444434036",
     +O"35323026262730302751",O"50464335312740514743",
     +O"00000077515050515252",O"44444340363637373643",
     +O"00000000000000774343",O"43444440363637373643",
     +O"00000000000077474543",O"00000000007746403250",
     +O"40262640522640522645",O"00000000000000775252",
     +O"40262640522640522645",O"00000000000000775252",
     +O"46464042424041353150",O"00000000000000000077",
     +O"32274036343230272645",O"40373634323040373440",
     +O"46404441405046444241",O"00775251504644424051",
     +O"32274036343230272646",O"40373634323040373440"/
      DATA IY21/
     +O"46404441405046444241",O"00775251504644424051",
     +O"46244046354045353551",O"00000000000000000077",
     +O"46504027252424252753",O"36313027273031364244",
     +O"51504050504050464442",O"00000000007750515252",
     +O"40524140524140413350",O"25304025263033405252",
     +O"33402530402526303340",O"31334033323240333131",
     +O"35343340333232403331",O"40353433404035334040",
     +O"00000000007740353340",O"40434140363440312750",
     +O"25405252405247405247",O"30273040302725403027",
     +O"34353431403435343140",O"42413640353534353540",
     +O"40424241364042414042",O"43404242414242404241",
     +O"43405047454750504746",O"50405047454750504746",
     +O"00000000007750504750",O"40525240524740524750",
     +O"33354042424346505047",O"32333026252526303332",
     +O"47505046434242403533",O"00000000000000000077",
     +O"40414344444341404046",O"44434136343333343637",
     +O"00000000000000007744",O"00000077433540433545",
     +O"35343435364143465053",O"37424344444342413736"/
      DATA IY22/
     +O"00000000000077303235",O"34353641424343424052",
     +O"36414243434240373534",O"00000077403735343435",
     +O"47474644413734323147",O"00773131323437414446",
     +O"00000077323246463246",O"00000000773044443047",
     +O"00000077264052402646",O"35414743474135352750",
     +O"00000000000000772735",O"42403640434240363551",
     +O"00000000000077404040",O"40363532353640463345",
     +O"00000000000077353335",O"42403640434240363551",
     +O"00000000000077404040",O"40424346434240453245",
     +O"00000000000077434543",O"00007737353333343443",
     +O"00000077434344444343",O"00007747454343444443",
     +O"00000000000077453245",O"00007745434136343244",
     +O"00007745434136343243",O"00000000000077404046",
     +O"00000077404040443446",O"00000077424240363646",
     +O"77423640423640433545"/
      DATA ISTART/
     +  1,  3,  4,  6,  8,  9, 11, 14, 15, 19, 22, 23, 26, 28, 30,
     + 32, 33, 36, 37, 38, 40, 41, 42, 44, 45, 48, 50, 53, 55, 58,
     + 59, 61, 62, 64, 65, 66, 67, 68, 71, 72, 73, 75, 76, 77, 80,
     + 81, 82, 83, 85, 86, 87, 90, 91, 93, 95, 96, 98,101,102,104,
     +106,107,108,110,115,116,118,119,122,126,128,130,131,133,135,
     +137,142,147,149,153,156,159,164,168,169,172,176,180,183,185,
     +187,190,192,194,196,198,199,200,201,202,204,206,207,208,209,
     +210,212,213,214,216,217,219,221,222,224,226,228,230,232,234,
     +236,237,240,242,243,245,246,247,249,251,253,255,257,258,260,
     +261,263,264,266,267,269,270,273,277,279,282,284,287,289,292,
     +293,295,296,299,301,304,306,308,310,312,313,315,318,320,323,
     +326,327,328,330,334,336,338,339,341,344,346,348,349,351,353,
     +355,359,363,365,369,376,386,391,394,395,398,401,403,404,405,
     +406,408,410,412,414,416,417,418,419,420,421,422,423,424,425/
*
      DATA NBIT,NBITCH,NBITMX/60,6,60/
+SELF, IF=IBM,VAX,AIX370.
      DATA IX11/
     +Z1969C7D6,Z217DC699,Z269E79A4,Z00FDF864,Z2185E716,Z0000003F,
     +Z1C6DA696,Z2696489E,Z27663966,Z0000003F,Z238266D6,Z269E79A5,
     +Z1A6DE864,Z00000FD9,Z3FA198D6,Z0003F8E3,Z1B69B956,Z279A485E,
     +Z1E8649A7,Z00FD969B,Z208A5996,Z1B69A6DD,Z2692181D,Z219269E7,
     +Z3F69B760,Z19FDD9D6,Z00000FE7,Z1A69B796,Z2692175B,Z229669E7,
     +Z1965A6DE,Z258DF71A,Z1E8A59A6,Z0000003F,Z208E5996,Z1965A71F,
     +Z2381F71A,Z239669A5,Z3F69B7A0,Z20FD8817,Z3F95BFE8,Z19FD9655,
     +Z279E6962,Z19FE2966,Z279E6962,Z3F662966,Z23967A16,Z1969B75F,
     +Z1F75B699,Z3FA27963,Z19FD9655,Z279A58E0,Z208E59A7,Z00000FD9,
     +Z1AFDA696,Z3F89AFE7,Z0003F9DA,Z1AFDA696,Z3F89AFE7,Z23967A16,
     +Z1969B75F,Z1F75B699,Z28A27963,Z00FE88FF,Z27FD9655,Z3F9D9FE7,
     +Z00FE081C,Z228E4918,Z1A6DC7A0,Z00000FDA,Z27FD9655,Z3F9DEFD9,
     +Z1AFDA696,Z00000FE6,Z18FD8614,Z3F828FE0,Z0003FA28,Z19FD9655,
     +Z3F9E7FE7,Z1969C795,Z1C699618,Z279A489E,Z249A7A28,Z0003F7A2,
     +Z19FD9655,Z279E6962,Z3F662966,Z1969C795,Z1C699618,Z279A489E,
     +Z249A7A28,Z2787F7A2,Z0000003F,Z19FD9655,Z279E6962,Z3F662966,
     +Z0003F9E0,Z1E8A59D6,Z1B69965B,Z279A58DD,Z1B7A2967,Z00000FD9,
     +Z19FE0818,Z00000FE7,Z1C699655,Z279A485F,Z00000FE7,Z28FE0617/
      DATA IX12/
     +Z00000FE0,Z20FDB594,Z3F960FDB,Z0003F96A,Z27FE7656,Z00000FD9,
     +Z3F820617,Z0003F828,Z19FD99D6,Z3F9D9FE7,Z20FD8817,Z3F95BFE8,
     +Z19FD9655,Z279E6962,Z19FE2966,Z279E6962,Z3F662966,Z1AFDA696,
     +Z00000FE6,Z20FD8817,Z3FA18FE8,Z1AFDA696,Z3F89AFE7,Z0003F9DA,
     +Z19FD99D6,Z3F9D9FE7,Z27FD9655,Z3F9D9FE7,Z1969C795,Z1C699618,
     +Z279A489E,Z249A7A28,Z2377F7A2,Z0000003F,Z00FE081C,Z27FD9655,
     +Z3F9DEFD9,Z20FD8817,Z00000FE8,Z18FD8614,Z3F828FE0,Z0003FA28,
     +Z19FD9655,Z3F9E7FE7,Z1DFE7657,Z3F9D9FE3,Z1969C795,Z1C699618,
     +Z279A489E,Z249A7A28,Z0003F7A2,Z27FD9655,Z3F9D9FE7,Z19FD9655,
     +Z279E6962,Z3F662966,Z3F660657,Z2767F9D9,Z0000003F,Z19FE0818,
     +Z00000FE7,Z1B699657,Z2081F79D,Z259A79FF,Z3F8218A3,Z1EFE0816,
     +Z1A65969B,Z2696279B,Z229669E7,Z00000FDE,Z19FE7656,Z00000FE7,
     +Z17FE0815,Z1C6DA658,Z2696485F,Z00FE9A27,Z1969D656,Z217DC699,
     +Z269E79A4,Z0003F9E3,Z18FE0814,Z3FA18FE8,Z00FE081C,Z1A69E79A,
     +Z268A279E,Z3F7A28A6,Z22FDE796,Z26966FE2,Z1E8A59E7,Z1B69965B,
     +Z3F9E58DD,Z258DD6D9,Z229679E6,Z1A6596DE,Z0003F69B,Z20FE081B,
     +Z3F82181F,Z27FDA856,Z3FA1AFE0,Z0003F9D9,Z3F628614,Z1C6DA697,
     +Z2696489E,Z20824966,Z2181F83F,Z00000FE0,Z2AA68A54,Z23967A6A/
      DATA IX13/
     +Z1D7A0862,Z228E4FDC,Z1B75E7E0,Z175965D9,Z0003F5D8,Z2181F81B,
     +Z207E0FE0,Z0003F821,Z2181F81B,Z1F821FE0,Z1F821860,Z0000003F,
     +Z3FA18A14,Z1EFDD759,Z3F91DFDE,Z0003F91D,Z23FE2899,Z3F8DCFE3,
     +Z0003F8DC,Z3F6E56D8,Z256FF95B,Z0000003F,Z1E7E0899,Z218607DE,
     +Z1F7E0FDF,Z218A2860,Z218A285D,Z3F81F7E0,Z1F82185F,Z2281F79E,
     +Z0000003F,Z22860799,Z1F7E0862,Z21860FE1,Z1F79E7E0,Z1F79E7E3,
     +Z3F821860,Z2181F7E1,Z1E8218A2,Z0000003F,Z3F81748F,Z20C3F816,
     +Z0000003F,Z1865C814,Z1F75B658,Z27920FE0,Z23967A28,Z1F83F821,
     +Z22860FDE,Z00FE27BF,Z1C79F814,Z1961865B,Z20FE071A,Z279648A1,
     +Z249A7A28,Z00000FE0,Z1769E814,Z299A283F,Z2079A5FF,Z208A6A7F,
     +Z0000003F,Z26922814,Z26A29A68,Z2387F864,Z1F863924,Z1F75C71D,
     +Z1869C7FF,Z1C6985D7,Z1F83F81E,Z22860FDE,Z00FE27BF,Z28A6AA93,
     +Z208A49A7,Z165D869E,Z207D85D6,Z1C7A0861,Z2379C6DB,Z2AAA99E5,
     +Z0000003F,Z27FE7655,Z00000FD9,Z1DFDA998,Z1A6DD79E,Z2485D6DA,
     +Z228A3FE6,Z259A6963,Z00000FE3,Z258E2815,Z2BAEAA67,Z23967A6A,
     +Z196DD7A2,Z16555597,Z1E75B657,Z00000FE0,Z1C71D7DC,Z248E17DD,
     +Z3F7E18E4,Z1E7BF75D,Z20FDF7FF,Z3F861FE0,Z238FF8A2,Z0000003F,
     +Z2491C71C,Z3F75DFDC,Z1F7FF79E,Z21FE083F,Z3F8A2FE1,Z0003F8E3/
      DATA IX14/
     +Z2095B81B,Z20FDD83F,Z3F7E0FE3,Z0003F860,Z206E581B,Z20FE383F,
     +Z3F860FDD,Z0003F7E0,Z1A99C81A,Z2083F824,Z20FDA83F,Z3F920FDC,
     +Z0003F9A0,Z3F9A9993,Z17FE3A23,Z00000FE8,Z3F8A0798,Z20FE581B,
     +Z00000FE0,Z3F697693,Z18FDD61D,Z00000FE9,Z3F8A0798,Z20FE581B,
     +Z00000FE0,Z2181F81B,Z00FDF821,Z2181F81B,Z00000FE0,Z207E085B,
     +Z3F7E0861,Z00FD7A55,Z1E822919,Z2281E75D,Z00000FE4,Z2281E719,
     +Z1E8228E3,Z00000FDC,Z00FE95D3,Z17FE0813,Z00000FE9,Z17FE95D3,
     +Z00000FE9,Z1BFE0818,Z3F6E5FE5,Z1D75E81B,Z238E281E,Z0003F822,
     +Z3F82079B,Z2385F75B,Z3F8DD8A3,Z2385F75B,Z2183F863,Z1D7E18E3,
     +Z0000003F,Z21FE185B,Z0003F91C,Z207DD79B,Z1F8228E2,Z3F89EFDD,
     +Z1D7A089B,Z238A079D,Z3F75E822,Z1DFDF8DB,Z00000FE3,Z1F75D7DB,
     +Z1F8638E1,Z1F75D7FF,Z3F8638E1,Z1E8228DB,Z238A079D,Z3F7A08A3,
     +Z26FE6997,Z1B75F8A4,Z1F75B69A,Z00FE6922,Z1AFDA696,Z258E179C,
     +Z218E59A6,Z00FDA71E,Z1F8A4997,Z1B69A6DD,Z269227DD,Z0000003F,
     +Z26FE6997,Z1B75F8A4,Z1F75B69A,Z00FE6922,Z259A6697,Z1B75F8A4,
     +Z1F75B69A,Z00FE6922,Z2086395B,Z3F91DFE0,Z24966997,Z26FDD7E2,
     +Z1B75F8A4,Z1F75B69A,Z00FE6922,Z1BFDB6D7,Z2696381E,Z00000FE6,
     +Z208607DC,Z3F820FDF,Z218A181B,Z20861FE0,Z0003F71E,Z25FDB6D7/
      DATA IX15/
     +Z3F99FFDB,Z00FE081C,Z15FD5551,Z207DD698,Z258E0FE0,Z3FAEBAA8,
     +Z1BFDB6D7,Z2696381E,Z00000FE6,Z1A6DD7D7,Z227DD6DA,Z269E79A4,
     +Z00FDF8A4,Z1AFDA696,Z258E179C,Z218E59A6,Z00FDA71E,Z26FE6997,
     +Z1B75F8A4,Z1F75B69A,Z00FE6922,Z1DFDD759,Z3F96281E,Z1F8A5998,
     +Z2379C6DC,Z229669A5,Z00FDB71F,Z2386081B,Z3F91DFE5,Z1E71B6D7,
     +Z26FE68E1,Z00000FE6,Z26FE0698,Z00000FE0,Z20FDC615,Z3F920FDC,
     +Z0003F928,Z26FE66D8,Z00000FDB,Z26FE0698,Z1969C7A0,Z0000003F,
     +Z1BFDB998,Z3F99BFE6,Z1A6DD7D6,Z1E71A659,Z289E58E0,Z238A17FF,
     +Z3FA279A5,Z1D7E18D7,Z3F65A6DC,Z269E7963,Z20FE08E5,Z24965922,
     +Z1C75F863,Z00000FDB,Z1D71A617,Z2086181F,Z209A7A3F,Z0003F75E,
     +Z1B75F897,Z1E71B69A,Z259648A0,Z1F7E08A4,Z3F9A48A0,Z1F8A4958,
     +Z3F85E75D,Z1C6DB761,Z3F96385E,Z1F7E0898,Z26FE68E0,Z1B6DC7E2,
     +Z228A179C,Z00FDE7E1,Z1C6985D6,Z3F69C75D,Z248A079C,Z3F8A59A6,
     +Z1B657595,Z1C6DB71C,Z248E17DD,Z239669A5,Z23860821,Z0003FA25,
     +Z1D75E81A,Z3F8E281E,Z27FD9757,Z1D7E3966,Z1F79CFDC,Z3F9238A1,
     +Z1E75B658,Z3F6A0FE6,Z1CFD7756,Z217DD6DB,Z259FF963,Z299E5924,
     +Z00000FEA,Z1B71D697,Z259A7FDA,Z3F69D823,Z1F7E0898,Z23FE68E0,
     +Z1F75D7A0,Z1E8BF922,Z2175B6DC,Z3F7A08A2,Z1B71E818,Z217DD71B/
      DATA IX16/
     +Z259A6963,Z00FE08A4,Z23FDA795,Z17FE6964,Z00FE9719,Z1D71B6D7,
     +Z2696385F,Z208A4966,Z3F5DB71E,Z1B75FA57,Z1E71B69A,Z259648A0,
     +Z00FE18E4,Z18FDE856,Z00FE875A,Z1C6985D6,Z1D6DB75D,Z279A489F,
     +Z00000FE7,Z1865B755,Z1F71A658,Z28A27962,Z1E822926,Z00000FDB,
     +Z2375B657,Z27A3F9E5,Z3F6196E5,Z15FDC914,Z1B6DA616,Z1F75B69A,
     +Z29A26922,Z0000003F,Z1761A714,Z1D6D9617,Z207E0FDF,Z289E58E1,
     +Z00FE69E8,Z1BFE0818,Z3F95BFE5,Z00FE081E,Z209D9819,Z2066783F,
     +Z0000003F,Z22FDF7D9,Z24925FE2,Z1C7A3965,Z3F96475C,Z2596475C,
     +Z1C75F8A4,Z3F71D75C,Z21FE081E,Z21820FE1,Z0003F821,Z23FDE81B,
     +Z3F91DFE1,Z0003F91D,Z3F6E56D8,Z2386079C,Z21860823,Z21820FE3,
     +Z0003F821,Z279E6997,Z20862926,Z23FDD79F,Z1E7E0862,Z1A65969C,
     +Z00000FDA,Z2186081E,Z21820FE0,Z0003F821,Z2186081E,Z20821FE0,
     +Z00FE0861,Z3F95B958,Z1FFDE79B,Z3F8DEFDF,Z0003F8DE,Z22FE185B,
     +Z3F89DFE2,Z0003F89D,Z3F95B958,Z256FF95B,Z0000003F,Z1E79F85A,
     +Z1E7FF860,Z1EFE087F,Z1E82185F,Z1E7E1860,Z1EFE183F,Z1E821FDF,
     +Z00FE17DE,Z228A17DB,Z2287F7E0,Z22FE07FF,Z2281F7E1,Z2285F7E0,
     +Z22FDF83F,Z2281FFE1,Z00FDF862,Z3F81A5D5,Z20A7F819,Z0000003F,
     +Z217DE795,Z1657F8A2,Z1B69A658,Z269A58DD,Z3FAEAA27,Z1E7FFAD5/
      DATA IX17/
     +Z3F86285F,Z20FE0818,Z3F860FDF,Z1F83F85F,Z1C7FF71E,Z248A183F,
     +Z20FE487F,Z1EFD869C,Z2483F61A,Z268BFA26,Z1D7A0FE8,Z1D7A0FDD,
     +Z238E283F,Z3F8E283F,Z20FE0818,Z3F820FE0,Z2183F7E0,Z20FE17FF,
     +Z2183F79F,Z2281EFE2,Z1B71E83F,Z2592283F,Z2281E73F,Z1C7A0FE4,
     +Z3F69965A,Z279A48A0,Z1E73F9A7,Z20FE48A0,Z1969B75E,Z20FDA618,
     +Z279A58E2,Z1BFE6A28,Z3F96381D,Z20FDF818,Z3F85FFE1,Z28A268E0,
     +Z27A27967,Z218E48E5,Z1B75C75F,Z196D9619,Z2075A618,Z0000003F,
     +Z218A391A,Z1D71C760,Z1E821860,Z2385F75D,Z00000FE4,Z23FE375B,
     +Z00000FDD,Z29AABAD7,Z1A761926,Z1A6175D8,Z299A485D,Z00FEBAEA,
     +Z24967A16,Z1C79F862,Z1961865B,Z217DE71B,Z289E5922,Z00000FE8,
     +Z1969C7D9,Z217DC699,Z269E79A4,Z00FDF864,Z2699A69A,Z00000FDA,
     +Z209D9819,Z0000003F,Z2681A81A,Z00000FE0,Z1D61E818,Z288E581B,
     +Z0003F822,Z239A3897,Z23963FE2,Z00FE56BF,Z1DFE081B,Z3F8E281E,
     +Z00FE281E,Z1D69D797,Z1D6DDFDE,Z00FE66FF,Z1DFE081B,Z3F8E281E,
     +Z00FE281E,Z2182085E,Z0003F821,Z2186081E,Z00000FE0,Z2182085E,
     +Z0003F821,Z00FDC91B,Z1F7E089D,Z0003F8A0,Z2186079C,Z0003F7A0,
     +Z00FE471A,Z1CFE081A,Z00000FE4,Z1CFE471A,Z00000FE4,Z1DFE081B,
     +Z3F763FE3/
      DATA IY11/
     +Z1D61552A,Z29A68960,Z18760968,Z00FD4515,Z2951762A,Z0000003F,
     +Z1559866A,Z18595514,Z29A5F71A,Z0000003F,Z1C71452A,Z268E179D,
     +Z27A29A68,Z00000FE5,Z208A252A,Z0003FA54,Z1C75452A,Z2179C6DB,
     +Z29A689A3,Z00FE59E8,Z145155EA,Z2689D615,Z26A29A68,Z1C75F8A3,
     +Z3F89F75C,Z1482952A,Z00000FD4,Z195D552A,Z2079D71B,Z29A27962,
     +Z22967A29,Z1B71D7A0,Z145155D9,Z0000003F,Z2181E6EA,Z1A6DE821,
     +Z15514557,Z289606D7,Z3F9A8A69,Z14829529,Z3F8A2829,Z1482952A,
     +Z1A616554,Z1E81E75C,Z258A07DE,Z3FA69A27,Z1455766B,Z1C657554,
     +Z29A26921,Z3F926A29,Z1482952A,Z1C657554,Z29A26921,Z00000FE9,
     +Z14829529,Z2079E814,Z0003FA69,Z14829528,Z3F79E814,Z1455766B,
     +Z1C657554,Z29A26921,Z21926A29,Z00FE1860,Z1482952B,Z3F79E829,
     +Z00FE9524,Z289E4528,Z249E8A69,Z00000FE2,Z1482952A,Z3FA5D822,
     +Z29829527,Z00000FE9,Z1482952C,Z20A54829,Z0003FA54,Z1482952B,
     +Z3FA54829,Z195D552B,Z289A485C,Z249A8A69,Z155D9721,Z0003F514,
     +Z1482952A,Z1B616554,Z3F7DF79D,Z195D552B,Z289A485C,Z249A8A69,
     +Z155D9721,Z2B960514,Z0000003F,Z1482952A,Z1A616554,Z2079E75C,
     +Z0003FA5E,Z145155EA,Z1C6D95D5,Z238607DD,Z28A69A26,Z00000FE6,
     +Z14829528,Z00000FD4,Z289A352B,Z239A8A69,Z00000FD4,Z14829529/
      DATA IY12/
     +Z00000FE9,Z1482952C,Z20A54829,Z0003FA54,Z1482952A,Z00000FE9,
     +Z20A5E529,Z0003F794,Z1482952A,Z3FA69814,Z14829529,Z3F8A2829,
     +Z1482952A,Z1A616554,Z1E81E75C,Z258A07DE,Z3FA69A27,Z14829527,
     +Z00000FD4,Z14829529,Z3FA69829,Z14829529,Z2079E814,Z0003FA69,
     +Z1482952A,Z3FA69814,Z1482952B,Z3F79E829,Z195D552B,Z289A485C,
     +Z249A8A69,Z155D9721,Z1E7A0514,Z0000003F,Z00FE9524,Z1482952A,
     +Z3FA5D822,Z14829529,Z00000FE9,Z1482952C,Z20A54829,Z0003FA54,
     +Z1482952B,Z3FA54829,Z1E814529,Z3FA6981E,Z195D552B,Z289A485C,
     +Z249A8A69,Z155D9721,Z0003F514,Z1482952B,Z3F514829,Z1482952A,
     +Z1B616554,Z3F7DF79D,Z20A5E529,Z29A60514,Z0000003F,Z14829528,
     +Z00000FD4,Z14557669,Z296D7554,Z14557660,Z3F6D7554,Z1982952A,
     +Z2281D6DA,Z228E4923,Z1969B760,Z00000FD9,Z2982952A,Z00000FD4,
     +Z1A82952B,Z2285F6DA,Z1F8628E3,Z00FDA69B,Z1E8A9A6A,Z145155DA,
     +Z2279A5D5,Z0003FA69,Z2082962C,Z3FA69820,Z00FF0424,Z2279E6A6,
     +Z228A69A2,Z3F69A79E,Z1082D42A,Z1961782D,Z145155D8,Z1C6D95D5,
     +Z208A07DD,Z1F79C6D9,Z29A268A0,Z24966A29,Z0003F9A5,Z27822525,
     +Z3F9E8A68,Z1083042B,Z2075D830,Z0003F8E3,Z3FA605EC,Z15598669,
     +Z18595514,Z227DD71A,Z28A689E0,Z00000FE7,Z124D246C,Z13450411/
      DATA IY13/
     +Z2CA1C615,Z1851282E,Z2FB6BA24,Z2DBAFC30,Z0003FBEE,Z1C75C6E5,
     +Z29A2781B,Z0003F9E8,Z1C75C6E5,Z28A6881B,Z2DB2AA27,Z0000003F,
     +Z3FA605EC,Z10830427,Z20410830,Z0003FC30,Z10830427,Z20410830,
     +Z0003FC30,Z2085D668,Z269A08A2,Z0000003F,Z14491427,Z1D6D9616,
     +Z154D181F,Z1E71A617,Z289A48A0,Z20BEDAE9,Z289E58E1,Z30BEEB2A,
     +Z0000003F,Z14491427,Z1D6D9616,Z154D181F,Z1E71A617,Z289A48A0,
     +Z20BEDAE9,Z289E58E1,Z30BEEB2A,Z0000003F,Z209DB6F0,Z29220A5C,
     +Z0000003F,Z2179A5AC,Z259A6963,Z1E696823,Z269A58E1,Z278E08E5,
     +Z2A9E382A,Z00FEAAA0,Z165D972C,Z207595D6,Z1C82A962,Z175965D9,
     +Z258A0759,Z00000FEA,Z2075856C,Z20758560,Z2BA23820,Z2BA23820,
     +Z0000003F,Z269A58AC,Z1E7E18E5,Z1D7E07DE,Z1659765B,Z1F75B657,
     +Z1F79E7E0,Z269A58E1,Z278A08A5,Z2A9E282A,Z00FEAAA0,Z1B6DC76D,
     +Z289A379C,Z259E8A69,Z1B720863,Z155155D9,Z267DC657,Z27A29A68,
     +Z0000003F,Z1982766B,Z00000FE7,Z19826668,Z1C75D71A,Z1A69965A,
     +Z258E2819,Z228E59A6,Z00000FE2,Z2592382B,Z1F863925,Z1C6DB71D,
     +Z259648DD,Z1D7E18E4,Z1D71B6DC,Z00000FE0,Z217DD724,Z218E4923,
     +Z2071C75F,Z227A085F,Z1D823760,Z208DD823,Z217E089E,Z0000003F,
     +Z1C924724,Z208DD81C,Z237608DD,Z1D823760,Z208DD823,Z0003F8DD/
      DATA IY14/
     +Z1A8E36A5,Z1D822760,Z208A0822,Z0003F8A0,Z2675D9A5,Z2381E8E0,
     +Z207A081E,Z0003F7A0,Z1E7A56A6,Z1A8206A5,Z2081E820,Z20960825,
     +Z0003F7A0,Z208A07AD,Z2082581B,Z00000FE0,Z206976A8,Z1881D61D,
     +Z00000FE9,Z208A07AD,Z2082581B,Z00000FE0,Z209A99A8,Z17823A23,
     +Z00000FE8,Z155155A5,Z00FDA657,Z28A689E5,Z00000FE7,Z27A29A25,
     +Z3FB6CAA8,Z00FF042B,Z19552427,Z2EAE789E,Z00000FF0,Z19552427,
     +Z2EAE789E,Z00000FF0,Z00FE082D,Z208295ED,Z00000FE0,Z2381D76D,
     +Z00000FE3,Z1D8266A8,Z3F8DD823,Z2179C6E5,Z1E863923,Z0003F6DC,
     +Z3F91B765,Z1C6DB725,Z3F92481E,Z1C6DB725,Z1F7E07DE,Z239248E0,
     +Z0000003F,Z1B8246E5,Z0003F861,Z1E79F6E5,Z2492385F,Z3F6DB823,
     +Z1E71B6E5,Z218E48E1,Z3F85F79F,Z1B8246E5,Z00000FDB,Z1F79C6E5,
     +Z1B6DC79F,Z248E07E0,Z3F7E08E4,Z208607A5,Z1E71B71E,Z3F9248E1,
     +Z1E8296EA,Z1E71B6DC,Z29A268E1,Z00FE6A29,Z1E829529,Z1E71B6DC,
     +Z29A268E1,Z00FE6A29,Z1B6DC7A9,Z268E179C,Z26A29A68,Z0000003F,
     +Z1E82952A,Z1E71B6DC,Z29A268E1,Z00FE6A29,Z1D7E1869,Z1E71B6DC,
     +Z29A268E1,Z00FE6A29,Z18554527,Z3F6DB829,Z2FBAB6EA,Z1E82FC30,
     +Z1E71B6DC,Z29A268E1,Z00FE6A29,Z1F82952A,Z1F71B6DC,Z00000FE9,
     +Z13515524,Z3FA5B814,Z13515525,Z2FB1B814,Z0003FC30,Z1B829528/
      DATA IY15/
     +Z3FA61825,Z00FE9524,Z1F8296EF,Z1F71B6DC,Z1B71F829,Z3FA5F71B,
     +Z1F8296EA,Z1F71B6DC,Z00000FE9,Z2179C6EA,Z29A689A3,Z1E8639A8,
     +Z00FDB6DC,Z1E8306E9,Z1E71B6DC,Z29A268E1,Z00FE6A29,Z1E8306EA,
     +Z1E71B6DC,Z29A268E1,Z00FE6A29,Z218296E6,Z3F6DB71E,Z1B6DC7A9,
     +Z2286079C,Z29A26963,Z00FE6A29,Z29A25527,Z3F6DB829,Z29A256EA,
     +Z1B825A29,Z00000FE9,Z1B8296E8,Z00000FE9,Z1B8296EB,Z20A5B829,
     +Z0003FA5B,Z1B8296E9,Z00000FE9,Z1B8296E8,Z30C2FB69,Z0000003F,
     +Z1B8296E9,Z3FA6981B,Z2079C6EB,Z29A689A3,Z1B7A2968,Z1E71B6E0,
     +Z3FA69A26,Z1B5D552A,Z20C2889E,Z1B656514,Z1D81D75C,Z2796281E,
     +Z27A29A68,Z00000FE4,Z1B6DC7AA,Z2992075C,Z2981E6E0,Z0003FC2D,
     +Z1E71B6E9,Z29A27921,Z208E6A29,Z155D96DD,Z3F5D5514,Z1B6DC768,
     +Z2086079C,Z289A48A1,Z3F9A8A69,Z17595527,Z19819658,Z258E075B,
     +Z2FB6BA67,Z00FEEC30,Z1B6DD7EA,Z20A6279C,Z1B6DC7A2,Z3FC2581D,
     +Z1B6DD7EA,Z289A379C,Z23968A69,Z145586E0,Z1E6D8594,Z0003F8A0,
     +Z289A26E5,Z3F967A69,Z1C8296E9,Z2181C6DB,Z238A1821,Z3FA29A68,
     +Z16554528,Z3FA5B829,Z1F8306EB,Z28A699E4,Z226E08A6,Z27A69A26,
     +Z00000FE5,Z2685B6E9,Z2079B829,Z3FA689A3,Z17595528,Z19819658,
     +Z217DD6DA,Z238A08A2,Z2CAA89A4,Z3FC30BED,Z2179C6E9,Z29A689E4/
      DATA IY16/
     +Z1D8239A8,Z00FDB6DC,Z1B8296EB,Z1E8299A1,Z00FDB6DC,Z289E4869,
     +Z239A8A69,Z1B6DC760,Z3FC2179C,Z1E71B6EB,Z29A27921,Z208E6A29,
     +Z00FDB71D,Z1E8296EA,Z00FDB6DC,Z1B6DD7EA,Z299E479C,Z1E8A6A29,
     +Z00000FDB,Z227DD72B,Z29A689E5,Z1D8239A8,Z2685D6DB,Z00000FF0,
     +Z2E75B6E9,Z1D6E0C30,Z3FC2EAE0,Z1F83052B,Z1E71B6DD,Z29A689A3,
     +Z1B7A39A8,Z0000003F,Z227DC6EB,Z28A69A25,Z28961825,Z22968A69,
     +Z00FDB71F,Z208266E8,Z3F9A6820,Z00FE56A2,Z18924627,Z2871CA20,
     +Z0000003F,Z1682A5A8,Z1B69A82A,Z1A65969B,Z208A179C,Z248A075C,
     +Z249669A5,Z3F9248E3,Z1B8206E3,Z24923820,Z0003F8E3,Z1A8256A6,
     +Z2079E825,Z0003F861,Z3F9A06A8,Z1C6DB725,Z1F8207DE,Z2492381E,
     +Z0003F8E3,Z176185E9,Z1D698596,Z178299E3,Z289A3759,Z28A29AAA,
     +Z00000FE9,Z1E7DF7A3,Z2492381E,Z0003F8E3,Z1E7DF7A3,Z2392481E,
     +Z00FE7963,Z3F9A06A8,Z1682A5A5,Z2059682A,Z0003FAAA,Z1682A5A5,
     +Z2059682A,Z0003FAAA,Z2085D668,Z269A08A2,Z0000003F,Z1A6175A5,
     +Z1A5E079C,Z1881F720,Z207DE71A,Z289A48A1,Z26824860,Z26922829,
     +Z00FEAA68,Z1A6175A6,Z1A5E079C,Z1881F720,Z207DE71A,Z289A48A1,
     +Z26824860,Z26922829,Z00FEAA68,Z2095D769,Z2652099D,Z0000003F,
     +Z145155EB,Z26A205D5,Z1865E8A4,Z1E6585D7,Z20A26922,Z29A20A28/
      DATA IY17/
     +Z3FA29AAA,Z218216E8,Z20AA182A,Z186E0AAA,Z15620556,Z155986E0,
     +Z1B815620,Z1A81B659,Z196E06DA,Z1A6A06D9,Z1D71B81B,Z2075B820,
     +Z2075C6E0,Z3F81D6E0,Z1C8195E8,Z208E181E,Z2A9E0AA7,Z1582AAA0,
     +Z17560617,Z185D8818,Z1C75C660,Z1C75C660,Z1D71D760,Z2285E81D,
     +Z208A1822,Z208A285E,Z228A08A1,Z238228A1,Z27A289E6,Z238289E5,
     +Z27A289E6,Z288289E5,Z3FA289E8,Z2782A9E8,Z20AAA82A,Z239A8A27,
     +Z1B7608A2,Z155986DA,Z1A6D8595,Z228A075B,Z27A289A3,Z0000003F,
     +Z23860826,Z20863924,Z1B6DC79F,Z248E179C,Z00000FE4,Z1D823765,
     +Z00000FE3,Z218E6A2B,Z1D71C75E,Z238A17DE,Z1F8A3924,Z00FD869D,
     +Z238E282A,Z1C75E862,Z2281F75C,Z1E8628E3,Z1F75C71D,Z00000FE0,
     +Z1F71A667,Z279E6921,Z1C7E1926,Z00FD965A,Z1A9A66A6,Z00000FDA,
     +Z18924627,Z0000003F,Z20AA05A6,Z00000FD6,Z2175D5E8,Z1D8678E7,
     +Z0003F5DD,Z2281E769,Z2281E823,Z00FE0820,Z1E8266E5,Z2079D69D,
     +Z00FDD6DD,Z2281E769,Z2281E823,Z00FE0820,Z228256A5,Z208A39A3,
     +Z00FE3963,Z1B6DC723,Z0003F7DD,Z239248E3,Z00000FE3,Z238E4923,
     +Z0003F9E5,Z00FE56A5,Z2179C6A4,Z0003F963,Z2179C6A3,Z0003F963,
     +Z00FE0826,Z20824726,Z00000FE0,Z2281E7A6,Z00000FE2,Z1E823765,
     +Z3F89E822/
      DATA ISTART/
     +  1,  5,  7, 11, 15, 17, 21, 26, 28, 35, 40, 42, 47, 51, 55,
     + 58, 60, 65, 67, 68, 71, 73, 75, 78, 80, 85, 88, 94, 98,103,
     +105,108,110,113,115,117,119,121,126,128,130,133,135,137,143,
     +144,146,148,151,153,155,160,162,165,168,170,174,179,181,185,
     +189,191,192,195,204,206,209,210,215,222,225,229,230,233,236,
     +239,248,257,260,267,273,278,288,296,298,304,311,319,325,329,
     +333,338,341,344,347,350,352,354,356,357,360,363,364,366,368,
     +370,373,374,376,380,382,385,388,390,394,397,401,405,409,413,
     +417,419,424,427,429,432,434,435,439,442,446,450,454,456,460,
     +462,465,467,470,472,475,477,482,489,493,498,502,507,511,517,
     +519,523,525,530,533,539,543,546,550,554,556,560,565,568,573,
     +578,580,581,584,591,594,597,598,602,608,611,614,615,618,621,
     +624,632,640,643,650,663,682,691,696,698,703,709,713,715,717,
     +719,722,725,728,731,734,736,738,740,741,743,745,746,748,750/
*
      DATA NBIT,NBITCH,NBITMX/32,8,30/
+SELF, IF=NORD,HPUX.
      DATA IX11/
     +3132343726B,4137343231B,4647474644B,0077374144B,4141363426B,
     +0000000077B,3433323226B,4645444236B,4731434546B,0000000077B,
     +4340463326B,4647474645B,3233364144B,0000007731B,7750314326B,
     +0000774343B,3332334526B,4746444136B,3641444647B,0077313233B,
     +4042454626B,3332323335B,4644414035B,4144464747B,7732333540B,
     +3177354726B,0000007747B,3232333626B,4644413533B,4245464747B,
     +3131323336B,4543373432B,3642454646B,0000000077B,4043454626B,
     +3131323437B,4340373432B,4345464645B,7732333640B,4077304027B,
     +7745337750B,3177313125B,4747464542B,3177424546B,4747464542B,
     +7731424546B,4345475026B,3132333537B,3735333231B,7750474543B,
     +3177313125B,4746454340B,4043454647B,0000007731B,3277323226B,
     +7742327747B,0000774732B,3277323226B,7742327747B,4345475026B,
     +3132333537B,3735333231B,5050474543B,0077504377B,4777313125B,
     +7747317747B,0077404034B,4243444430B,3233343640B,0000007732B,
     +4777313125B,7747367731B,3277323226B,0000007746B,3077303024B,
     +7740507740B,0000775050B,3177313125B,7747477747B,3132343625B,
     +3432313030B,4746444236B,4446475050B,0000773642B,3177313125B,
     +4747464542B,7731424546B,3132343625B,3432313030B,4746444236B/
      DATA IX12/
     +4446475050B,4741773642B,0000000077B,3177313125B,4747464542B,
     +7731424546B,0000774740B,3642454726B,3332313133B,4746454335B,
     +3336424547B,0000007731B,3177404030B,0000007747B,3432313125B,
     +4746444137B,0000007747B,5077403027B,0000007740B,4077332624B,
     +7745407733B,0000774552B,4777473126B,0000007731B,7740403027B,
     +0000774050B,3177314726B,7747317747B,4077304027B,7745337750B,
     +3177313125B,4747464542B,3177424546B,4747464542B,7731424546B,
     +3277323226B,0000007746B,4077304027B,7750307750B,3277323226B,
     +7742327747B,0000774732B,3177314726B,7747317747B,4777313125B,
     +7747317747B,3132343625B,3432313030B,4746444236B,4446475050B,
     +4335773642B,0000000077B,0077404034B,4777313125B,7747367731B,
     +4077304027B,0000007750B,3077303024B,7740507740B,0000775050B,
     +3177313125B,7747477747B,3577473127B,7747317743B,3132343625B,
     +3432313030B,4746444236B,4446475050B,0000773642B,4777313125B,
     +7747317747B,3177313125B,4747464542B,7731424546B,7731403127B,
     +4731774731B,0000000077B,3177404030B,0000007747B,3332313127B,
     +4040373635B,4546474777B,7740414243B,3677404026B,3231313233B,
     +4645423633B,4245464747B,0000007736B,3177473126B,0000007747B/
      DATA IX13/
     +2777404025B,3433323130B,4645444137B,0077515047B,3132353126B,
     +4137343231B,4647474644B,0000774743B,3077404024B,7750307750B,
     +0077404034B,3232363632B,4642423636B,7736424246B,4277363626B,
     +4645467742B,3642454747B,3332313133B,7747454335B,4543353331B,
     +4245474746B,3231313336B,0000773233B,4077404033B,7740414037B,
     +4777324126B,7750327740B,0000774731B,7730503024B,3433323227B,
     +4645444236B,4040444546B,4140374077B,0000007740B,5251505124B,
     +4345475152B,3536404142B,4243447734B,3335363740B,2726262731B,
     +0000772730B,4140374033B,4037407740B,0000774041B,4140374033B,
     +3740417740B,3740414140B,0000000077B,7750305024B,3677353531B,
     +7744357736B,0000774435B,4377424231B,7743347743B,0000774334B,
     +7733453330B,4533774533B,0000000077B,3637404231B,4141403736B,
     +3737407737B,4142424140B,4142424135B,7740373740B,3740414137B,
     +4240373636B,0000000077B,4241403631B,3737404142B,4141407741B,
     +3736363740B,3736363743B,7740414140B,4140373741B,3640414242B,
     +0000000077B,7740272217B,4060774026B,0000000077B,3031344024B,
     +3735333130B,4744407740B,4345475050B,3740774041B,4241407736B,
     +0077423677B,3436374024B,3130303133B,4077403432B,4745444241B/
      DATA IX14/
     +4446475050B,0000007740B,2732364024B,5146424077B,4036322777B,
     +4042465177B,0000000077B,4644424024B,4650515150B,4341774144B,
     +3741434444B,3735343435B,3032343777B,3432302727B,3740774036B,
     +4241407736B,0077423677B,5051525223B,4042444647B,2627303236B,
     +4037302726B,3436404141B,4336343333B,5252514745B,0000000077B,
     +4777473125B,0000007731B,3577324630B,3233353636B,4441353332B,
     +4242437746B,4546464543B,0000007743B,4543424025B,5353525147B,
     +4345475152B,3133353642B,2625252627B,3635333127B,0000007740B,
     +3434353734B,4443413735B,7737414344B,3636773535B,4077373777B,
     +7741417740B,4343774242B,0000000077B,4444343434B,7735357734B,
     +3737773636B,4177404077B,7742427741B,0000774343B,4045334033B,
     +4077354077B,7737407743B,0000774140B,4033454033B,4077434077B,
     +7741407735B,0000773740B,3246344032B,4040774044B,4077324077B,
     +7744407734B,0000774640B,7746514623B,2777435043B,0000007750B,
     +7742403630B,4077454033B,0000007740B,7732273223B,3077353035B,
     +0000007751B,7742403630B,4077454033B,0000007740B,4140374033B,
     +0077374041B,4140374033B,0000007740B,4037404133B,7737404141B,
     +0077275125B,3640424431B,4240363535B,0000007744B,4240363431B/
      DATA IX15/
     +3640424343B,0000007734B,0077512723B,2777404023B,0000007751B,
     +2777512723B,0000007751B,3377404030B,7733457745B,3535364033B,
     +4343424036B,0000774042B,7740403633B,4341373533B,7743354243B,
     +4341373533B,4140774143B,3537414343B,0000000077B,4177414133B,
     +0000774434B,4037353633B,3740424342B,7742367735B,3536404233B,
     +4342403635B,7735364042B,3577374333B,0000007743B,3735353733B,
     +3741434341B,3735353777B,7741434341B,3640424333B,4342403635B,
     +7736404243B,4677464627B,3335374244B,3735333232B,0077464442B,
     +3277323226B,4543413634B,4143454646B,0077323436B,3742444627B,
     +3332323335B,4644423735B,0000000077B,4677464627B,3335374244B,
     +3735333232B,0077464442B,4546463227B,3335374244B,3735333232B,
     +0077464442B,4041434533B,7744357740B,4445464627B,4677353742B,
     +3335374244B,3735333232B,0077464442B,3377333327B,4645434036B,
     +0000007746B,4041403734B,7740407737B,4142414033B,4041417740B,
     +0000773436B,4577333327B,7746377733B,0077404034B,2577252521B,
     +4037353230B,4543407740B,7753535250B,3377333327B,4645434036B,
     +0000007746B,3233353727B,4237353332B,4647474644B,0077374244B,
     +3277323226B,4543413634B,4143454646B,0077323436B,4677464627B/
      DATA IX16/
     +3335374244B,3735333232B,0077464442B,3577353531B,7745424036B,
     +3742454630B,4336343334B,4245464645B,0077333437B,4341404033B,
     +7744357745B,3634333327B,4677464341B,0000007746B,4677403230B,
     +0000007740B,4077343025B,7744407734B,0000774450B,4677463330B,
     +0000007733B,4677403230B,3132343640B,0000000077B,3377334630B,
     +7746337746B,3233353726B,3634323131B,5047454340B,4342413777B,
     +7750474645B,3537414327B,7731323334B,4647474543B,4077404345B,
     +4445454442B,3435374143B,0000007733B,3534323027B,4041414037B,
     +4046475077B,0000773536B,3335374227B,3634333232B,4545444240B,
     +3737404244B,7746444240B,3742444530B,7741363535B,3433333541B,
     +7745434136B,3737404230B,4677464340B,3333343742B,4242413634B,
     +0077363741B,3432302726B,7732343535B,4442403634B,7742454646B,
     +3331272625B,3433333434B,4443413735B,4345464645B,4341404041B,
     +0000775045B,3535364032B,7743424036B,4777313527B,3537434546B,
     +3736347734B,7744434241B,3635333130B,7732407746B,3477273526B,
     +4137353333B,4547774543B,5147454444B,0000007752B,3334353227B,
     +4546477732B,7732354043B,3737404230B,4377464340B,3735353640B,
     +3642774442B,4135333334B,7736404242B,3334364030B,4137353433B/
      DATA IX17/
     +4546464543B,0077404244B,4377323625B,2777464544B,0077513431B,
     +3534333327B,4645434137B,4042444546B,7727333436B,3335375127B,
     +3634333232B,4545444240B,0077414344B,3077364126B,0077503532B,
     +3432302726B,3533333535B,4746444237B,0000007747B,3031333525B,
     +3734323130B,5050474542B,3640424446B,0000007733B,4335333127B,
     +4750774745B,7730313345B,2577344424B,3333323026B,3735333232B,
     +5150464442B,0000000077B,2730323424B,3533313027B,4037407737B,
     +5047454341B,0077464750B,3377404030B,7745337745B,0077404036B,
     +4047314031B,4031474077B,0000000077B,4277373731B,4444457742B,
     +3436434545B,7745443534B,4545443534B,3435374244B,7734353534B,
     +4177404036B,4140407741B,0000774041B,4377364033B,7744357741B,
     +0000774435B,7733453330B,4341403634B,4141404043B,4140407743B,
     +0000774041B,4747464627B,4041424446B,4377353637B,3637404142B,
     +3231313234B,0000007732B,4141404036B,4140407740B,0000774041B,
     +4141404036B,4040417740B,0077404141B,7745334530B,3777363633B,
     +7743367737B,0000774336B,4277414133B,7742357742B,0000774235B,
     +7745334530B,4533774533B,0000000077B,3636374132B,3637774140B,
     +3677404177B,3640414137B,3637414140B,3677414077B,3640417737B/
      DATA IX18/
     +0077413736B,4242413733B,4241773740B,4277403777B,4240373741B,
     +4241373740B,4277374077B,4240377741B,0077374142B,7740322725B,
     +4051774031B,0000000077B,4137363625B,2625774242B,3332323130B,
     +4646454335B,7753525047B,3637775325B,7741424137B,4077404030B,
     +7741407737B,3740774137B,3437773436B,4442414077B,4077444177B,
     +3677303234B,4440773032B,4642775046B,3536407750B,3536407735B,
     +4343424077B,7743424077B,4077404030B,7740407740B,4140773740B,
     +4077413777B,4140773637B,4240367742B,3334364077B,4544424077B,
     +4240363477B,3436407744B,7732313132B,4746444240B,3634774647B,
     +4077444240B,3132333536B,4077323030B,4746454342B,3377465050B,
     +7745434035B,4077374030B,7741377741B,5050464340B,4750474547B,
     +4143444345B,3335343537B,3133313031B,4035323030B,0000000077B,
     +4142434432B,3534343540B,3640414140B,4341373535B,0000007744B,
     +4377433533B,0000007735B,5152535327B,3235414446B,3230272730B,
     +5146444135B,0077535352B,4445475026B,3436374142B,3130303133B,
     +4137363433B,5047454442B,0000007750B,3132343731B,4137343231B,
     +4647474644B,0077374144B,4646323232B,0000007732B,4047314031B,
     +0000000077B,4640324032B,0000007740B,3530364030B,5043454033B/
      DATA IX19/
     +0000774042B,4346434227B,4345437742B,0077453277B,3577404033B,
     +7743424036B,0077424036B,3532353627B,3533357736B,0077463377B,
     +3577404033B,7743424036B,0077424036B,4140404136B,0000774041B,
     +4141404036B,0000007740B,4140404136B,0000774041B,0077344433B,
     +3737404235B,0000774240B,4141403634B,0000773640B,0077443432B,
     +3477404032B,0000007744B,3477443432B,0000007744B,3577404033B,
     +7735437743B/
      DATA IY11/
     +3530252452B,5151504540B,3035404550B,0077242425B,5124273052B,
     +0000000077B,2526303152B,3026252424B,5151373432B,0000000077B,
     +3434242452B,4643413635B,4750515150B,0000007745B,4042422452B,
     +0000775124B,3435242452B,4136343333B,5151504643B,0077454750B,
     +2424252752B,4642353025B,4650515150B,3435374243B,7742373534B,
     +2440512452B,0000007724B,3127252452B,4036353433B,5150474542B,
     +4245475051B,3334353640B,2424252731B,0000000077B,4140363352B,
     +3233364041B,2524242527B,5045403327B,7746505151B,2440512451B,
     +7742424051B,2440512452B,3230262524B,3640363534B,4542403736B,
     +7751515047B,2425273153B,3431272524B,5150464441B,7744465051B,
     +2440512452B,3431272524B,5150464441B,0000007751B,2440512451B,
     +4036364024B,0000775151B,2440512450B,7736364024B,2425273153B,
     +3431272524B,5150464441B,4144465051B,0077414140B,2440512453B,
     +7736364051B,0077512444B,5047442450B,4447505151B,0000007742B,
     +2440512452B,7751354042B,5140512447B,0000007751B,2440512454B,
     +4051244051B,0000775124B,2440512453B,7751244051B,3127252453B,
     +5046444134B,4446505151B,2527313441B,0000772424B,2440512452B,
     +3330262524B,7737373635B,3127252453B,5046444134B,4446505151B/
      DATA IY12/
     +2527313441B,5345402424B,0000000077B,2440512452B,3230262524B,
     +4036363534B,0000775136B,2424252752B,3433312725B,4341403735B,
     +5051515046B,0000007746B,2440512450B,0000007724B,5046432453B,
     +4346505151B,0000007724B,2440512451B,0000007751B,2440512454B,
     +4051244051B,0000775124B,2440512452B,0000007751B,4051362451B,
     +0000773624B,2440512452B,7751514024B,2440512451B,7742424051B,
     +2440512452B,3230262524B,3640363534B,4542403736B,7751515047B,
     +2440512447B,0000007724B,2440512451B,7751514051B,2440512451B,
     +4036364024B,0000775151B,2440512452B,7751514024B,2440512453B,
     +7736364051B,3127252453B,5046444134B,4446505151B,2527313441B,
     +3636402424B,0000000077B,0077512444B,2440512452B,7751354042B,
     +2440512451B,0000007751B,2440512454B,4051244051B,0000775124B,
     +2440512453B,7751244051B,3640242451B,7751514036B,3127252453B,
     +5046444134B,4446505151B,2527313441B,0000772424B,2440512453B,
     +7724244051B,2440512452B,3330262524B,7737373635B,4051362451B,
     +5151402424B,0000000077B,2440512450B,0000007724B,2425273151B,
     +5133272524B,2425273140B,7733272524B,3140512452B,4240353332B,
     +4243444443B,3132333540B,0000007731B,5140512452B,0000007724B/
      DATA IY13/
     +3240512453B,4241373332B,3741424343B,0077323233B,3642515152B,
     +2424252732B,4236322725B,0000775151B,4040513054B,7751514040B,
     +0077602044B,4236363246B,4242464642B,7732323636B,2040552052B,
     +3130274055B,2424252730B,3433312725B,4042403735B,3736343331B,
     +5150464240B,4445465051B,0000774645B,4740422445B,7747505150B,
     +2040602053B,4035354060B,0000774343B,7751402754B,2526303151B,
     +3026252424B,4237353432B,5051504740B,0000007747B,2223222154B,
     +2321202021B,5450343025B,3024224056B,5755535044B,5556576060B,
     +0000775756B,3435343345B,5150474033B,0000774750B,3435343345B,
     +5051504033B,5554525047B,0000000077B,7751402754B,2040602047B,
     +4020204060B,0000776060B,2040602047B,4020204060B,0000776060B,
     +4041353150B,4646404242B,0000000077B,2422212047B,3533313026B,
     +2523214037B,3634323027B,5046444240B,4057555351B,5047454341B,
     +6057565452B,0000000077B,2422212047B,3533313026B,2523214037B,
     +3634323027B,5046444240B,4057555351B,5047454341B,6057565452B,
     +0000000077B,4047333360B,5110405134B,0000000077B,4136322654B,
     +4546464543B,3632264043B,4646454341B,4743404345B,5247434052B,
     +0077525240B,2627313454B,4035312726B,3440524542B,2726262731B/
      DATA IY14/
     +4542403531B,0000007752B,4035302554B,4035302540B,5350434040B,
     +5350434040B,0000000077B,4646454254B,3637414345B,3537403736B,
     +2626273133B,3735333127B,3736363740B,4646454341B,4742404245B,
     +5247424052B,0077525240B,3333343555B,5046433634B,4547505151B,
     +3334404143B,2524252731B,4637343127B,4750515150B,0000000077B,
     +3140473153B,0000007747B,3140463150B,3435353432B,3232313132B,
     +4543424031B,4243454646B,0000007742B,4544434053B,3741434445B,
     +3433333435B,4545444335B,3537414344B,3534333334B,0000007740B,
     +4137353444B,4143444443B,4034343537B,4236404137B,3540433540B,
     +4043354043B,4137404236B,0000000077B,3444443444B,4043354034B,
     +4335404335B,3540433540B,4043354043B,0000774335B,3243433245B,
     +3540423540B,4042404042B,0000774240B,4635354645B,4340364340B,
     +4036404036B,0000773640B,3636453246B,3240403245B,4040364040B,
     +4045404045B,0000773640B,4042403655B,4040454033B,0000007740B,
     +4032273250B,3040353035B,0000007751B,4042403655B,4040454033B,
     +0000007740B,4046514650B,2740435043B,0000007750B,2524252645B,
     +0077323127B,5051504745B,0000007747B,4750515045B,7755545250B,
     +0077602053B,3125222047B,5653474236B,0000007760B,3125222047B/
      DATA IY15/
     +5653474236B,0000007760B,0077404055B,4040512755B,0000007740B,
     +4340353555B,0000007743B,3540463250B,7743354043B,4136343345B,
     +3641434443B,0000773334B,7744333545B,3433333445B,7744444036B,
     +3433333445B,3737403736B,4344444340B,0000000077B,3340443345B,
     +0000774141B,3636373345B,4444434137B,7733334043B,3634333345B,
     +4143444341B,7741373637B,3340443345B,0000007733B,3736343345B,
     +3333343637B,4443403740B,7737404344B,4041403645B,3634333436B,
     +7744444341B,3640513352B,3634333334B,5150464341B,0077465051B,
     +3640512451B,3634333334B,5150464341B,0077465051B,3333343651B,
     +4643413634B,4650515150B,0000000077B,3640512452B,3634333334B,
     +5150464341B,0077465051B,3537414151B,3634333334B,5150464341B,
     +0077465051B,3025242447B,7733334051B,5756533352B,3640576060B,
     +3634333334B,5150464341B,0077465051B,3740512452B,3734333334B,
     +0000007751B,2324252444B,7751334024B,2324252445B,5754334024B,
     +0000776060B,3340512450B,7751414045B,0077512444B,3740513357B,
     +3734333334B,3334374051B,7751373433B,3740513352B,3734333334B,
     +0000007751B,4136343352B,5151504643B,3641434650B,0077333334B,
     +3640603351B,3634333334B,5150464341B,0077465051B,3640603352B/
      DATA IY16/
     +3634333334B,5150464341B,0077465051B,4140513346B,7733333436B,
     +3333343651B,4241403634B,5150464543B,0077465051B,5150452447B,
     +7733334051B,5150453352B,3340455051B,0000007751B,3340513350B,
     +0000007751B,3340513353B,4051334051B,0000775133B,3340513351B,
     +0000007751B,3340513350B,6060575551B,0000000077B,3340513351B,
     +7751514033B,4036343353B,5151504643B,3336424550B,3634333340B,
     +7751515046B,3327252452B,4060504236B,3331262424B,3540353534B,
     +4745424036B,4750515150B,0000007744B,3333343652B,5144403534B,
     +5140363340B,0000776055B,3634333351B,5150474441B,4043465051B,
     +2527313335B,7727252424B,3333343550B,4041403634B,5046444241B,
     +7746505151B,2726252447B,3140313130B,4543403533B,5755535147B,
     +0077566060B,3333353752B,4051423634B,3333343642B,7760454035B,
     +3333353752B,5046433634B,4345505151B,2425303340B,3633302624B,
     +0000774240B,5046423345B,7745475151B,3440513351B,4140343333B,
     +4342414041B,7750515150B,2625242450B,7751334051B,3740603353B,
     +5051514744B,4233404246B,4751515046B,0000007745B,4641333351B,
     +4036334051B,7751504643B,2726252450B,3140313130B,4137353332B,
     +4342404242B,5452504644B,7760605755B,4136343351B,5151504744B/
      DATA IY17/
     +3540434650B,0077333334B,3340513353B,3640514641B,0077333334B,
     +5047444151B,4346505151B,3333343540B,7760413634B,3634333353B,
     +5150474441B,4043465051B,0077333435B,3640513352B,0077333334B,
     +3333353752B,5147443634B,3642465051B,0000007733B,4237353453B,
     +5151504745B,3540434650B,4641353333B,0000007760B,5635333351B,
     +3533406060B,7760565340B,3740602453B,3634333335B,5151504643B,
     +3336434650B,0000000077B,4237343353B,5051515045B,5045414045B,
     +4245505151B,0077333437B,4040463350B,7746464040B,0077453242B,
     +3044443047B,5034345040B,0000000077B,2640522650B,3332324052B,
     +3231313233B,4042413634B,4442403534B,4445464645B,7744444343B,
     +3340403343B,4444434040B,0000774343B,3240453246B,4036364045B,
     +0000774141B,7746403250B,3433333445B,3740403736B,4444434036B,
     +0000774343B,2730302751B,3532302626B,2740514743B,5046433531B,
     +5050515252B,0000007751B,3637373643B,4444434036B,0000774343B,
     +3637373643B,4344444036B,0077474543B,7746403250B,2640522645B,
     +4026264052B,0000775252B,2640522645B,4026264052B,0000775252B,
     +4041353150B,4646404242B,0000000077B,3230272645B,3227403634B,
     +3040373440B,4037363432B,5046444241B,4640444140B,4644424051B/
      DATA IY18/
     +0077525150B,3230272646B,3227403634B,3040373440B,4037363432B,
     +5046444241B,4640444140B,4644424051B,0077525150B,4045353551B,
     +4624404635B,0000000077B,2424252753B,4650402725B,3031364244B,
     +3631302727B,4050464442B,5150405050B,7750515252B,4140413350B,
     +4052414052B,3033405252B,2530402526B,2526303340B,3340253040B,
     +3240333131B,3133403332B,3232403331B,3534334033B,4035334040B,
     +4035343340B,7740353340B,3440312750B,4043414036B,5247405247B,
     +2540525240B,2725403027B,3027304030B,3435343140B,3435343140B,
     +3534353540B,4241364035B,4042414042B,4042424136B,4242404241B,
     +4340424241B,4750504746B,4340504745B,4750504746B,5040504745B,
     +7750504750B,4740524750B,4052524052B,4346505047B,3335404242B,
     +2526303332B,3233302625B,4242403533B,4750504643B,0000000077B,
     +4341404046B,4041434444B,3333343637B,4443413634B,0000007744B,
     +3540433545B,0000007743B,4143465053B,3534343536B,4342413736B,
     +3742434444B,0077303235B,4343424052B,3435364142B,4240373534B,
     +3641424343B,3735343435B,0000007740B,3734323147B,4747464441B,
     +3437414446B,0077313132B,3246463246B,0000007732B,3044443047B,
     +0000000077B,4052402646B,0000007726B,4135352750B,3541474347B/
      DATA IY19/
     +0000772735B,4240363551B,4240364043B,0077404040B,3640463345B,
     +4036353235B,0077353335B,4240363551B,4240364043B,0077404040B,
     +4240453245B,4042434643B,0077434543B,3333343443B,0000773735B,
     +4344444343B,0000007743B,4343444443B,0000774745B,0077453245B,
     +4136343244B,0000774543B,4136343243B,0000774543B,0077404046B,
     +4040443446B,0000007740B,4240363646B,0000007742B,3640433545B,
     +7742364042B/
      DATA ISTART/
     +  1,  5,  7, 11, 15, 17, 21, 26, 28, 35, 40, 42, 47, 51, 55,
     + 58, 60, 65, 67, 68, 71, 73, 75, 78, 80, 85, 88, 94, 98,103,
     +105,108,110,113,115,117,119,121,126,128,130,133,135,137,143,
     +144,146,148,151,153,155,160,162,165,168,170,174,179,181,185,
     +189,191,192,195,204,206,209,210,215,222,225,229,230,233,236,
     +239,248,257,260,267,273,278,288,296,298,304,311,319,325,329,
     +333,338,341,344,347,350,352,354,356,357,360,363,364,366,368,
     +370,373,374,376,380,382,385,388,390,394,397,401,405,409,413,
     +417,419,424,427,429,432,434,435,439,442,446,450,454,456,460,
     +462,465,467,470,472,475,477,482,489,493,498,502,507,511,517,
     +519,523,525,530,533,539,543,546,550,554,556,560,565,568,573,
     +578,580,581,584,591,594,597,598,602,608,611,614,615,618,621,
     +624,632,640,643,650,663,682,691,696,698,703,709,713,715,717,
     +719,722,725,728,731,734,736,738,740,741,743,745,746,748,750/
*
      DATA NBIT,NBITCH,NBITMX/32,8,30/
+SELF, IF=UNIVAC.
      DATA IX11/
     +"3132343726,"4137343231,"4647474644,"0077374144,"4141363426,
     +"0000000077,"3433323226,"4645444236,"4731434546,"0000000077,
     +"4340463326,"4647474645,"3233364144,"0000007731,"7750314326,
     +"0000774343,"3332334526,"4746444136,"3641444647,"0077313233,
     +"4042454626,"3332323335,"4644414035,"4144464747,"7732333540,
     +"3177354726,"0000007747,"3232333626,"4644413533,"4245464747,
     +"3131323336,"4543373432,"3642454646,"0000000077,"4043454626,
     +"3131323437,"4340373432,"4345464645,"7732333640,"4077304027,
     +"7745337750,"3177313125,"4747464542,"3177424546,"4747464542,
     +"7731424546,"4345475026,"3132333537,"3735333231,"7750474543,
     +"3177313125,"4746454340,"4043454647,"0000007731,"3277323226,
     +"7742327747,"0000774732,"3277323226,"7742327747,"4345475026,
     +"3132333537,"3735333231,"5050474543,"0077504377,"4777313125,
     +"7747317747,"0077404034,"4243444430,"3233343640,"0000007732,
     +"4777313125,"7747367731,"3277323226,"0000007746,"3077303024,
     +"7740507740,"0000775050,"3177313125,"7747477747,"3132343625,
     +"3432313030,"4746444236,"4446475050,"0000773642,"3177313125,
     +"4747464542,"7731424546,"3132343625,"3432313030,"4746444236/
      DATA IX12/
     +"4446475050,"4741773642,"0000000077,"3177313125,"4747464542,
     +"7731424546,"0000774740,"3642454726,"3332313133,"4746454335,
     +"3336424547,"0000007731,"3177404030,"0000007747,"3432313125,
     +"4746444137,"0000007747,"5077403027,"0000007740,"4077332624,
     +"7745407733,"0000774552,"4777473126,"0000007731,"7740403027,
     +"0000774050,"3177314726,"7747317747,"4077304027,"7745337750,
     +"3177313125,"4747464542,"3177424546,"4747464542,"7731424546,
     +"3277323226,"0000007746,"4077304027,"7750307750,"3277323226,
     +"7742327747,"0000774732,"3177314726,"7747317747,"4777313125,
     +"7747317747,"3132343625,"3432313030,"4746444236,"4446475050,
     +"4335773642,"0000000077,"0077404034,"4777313125,"7747367731,
     +"4077304027,"0000007750,"3077303024,"7740507740,"0000775050,
     +"3177313125,"7747477747,"3577473127,"7747317743,"3132343625,
     +"3432313030,"4746444236,"4446475050,"0000773642,"4777313125,
     +"7747317747,"3177313125,"4747464542,"7731424546,"7731403127,
     +"4731774731,"0000000077,"3177404030,"0000007747,"3332313127,
     +"4040373635,"4546474777,"7740414243,"3677404026,"3231313233,
     +"4645423633,"4245464747,"0000007736,"3177473126,"0000007747/
      DATA IX13/
     +"2777404025,"3433323130,"4645444137,"0077515047,"3132353126,
     +"4137343231,"4647474644,"0000774743,"3077404024,"7750307750,
     +"0077404034,"3232363632,"4642423636,"7736424246,"4277363626,
     +"4645467742,"3642454747,"3332313133,"7747454335,"4543353331,
     +"4245474746,"3231313336,"0000773233,"4077404033,"7740414037,
     +"4777324126,"7750327740,"0000774731,"7730503024,"3433323227,
     +"4645444236,"4040444546,"4140374077,"0000007740,"5251505124,
     +"4345475152,"3536404142,"4243447734,"3335363740,"2726262731,
     +"0000772730,"4140374033,"4037407740,"0000774041,"4140374033,
     +"3740417740,"3740414140,"0000000077,"7750305024,"3677353531,
     +"7744357736,"0000774435,"4377424231,"7743347743,"0000774334,
     +"7733453330,"4533774533,"0000000077,"3637404231,"4141403736,
     +"3737407737,"4142424140,"4142424135,"7740373740,"3740414137,
     +"4240373636,"0000000077,"4241403631,"3737404142,"4141407741,
     +"3736363740,"3736363743,"7740414140,"4140373741,"3640414242,
     +"0000000077,"7740272217,"4060774026,"0000000077,"3031344024,
     +"3735333130,"4744407740,"4345475050,"3740774041,"4241407736,
     +"0077423677,"3436374024,"3130303133,"4077403432,"4745444241/
      DATA IX14/
     +"4446475050,"0000007740,"2732364024,"5146424077,"4036322777,
     +"4042465177,"0000000077,"4644424024,"4650515150,"4341774144,
     +"3741434444,"3735343435,"3032343777,"3432302727,"3740774036,
     +"4241407736,"0077423677,"5051525223,"4042444647,"2627303236,
     +"4037302726,"3436404141,"4336343333,"5252514745,"0000000077,
     +"4777473125,"0000007731,"3577324630,"3233353636,"4441353332,
     +"4242437746,"4546464543,"0000007743,"4543424025,"5353525147,
     +"4345475152,"3133353642,"2625252627,"3635333127,"0000007740,
     +"3434353734,"4443413735,"7737414344,"3636773535,"4077373777,
     +"7741417740,"4343774242,"0000000077,"4444343434,"7735357734,
     +"3737773636,"4177404077,"7742427741,"0000774343,"4045334033,
     +"4077354077,"7737407743,"0000774140,"4033454033,"4077434077,
     +"7741407735,"0000773740,"3246344032,"4040774044,"4077324077,
     +"7744407734,"0000774640,"7746514623,"2777435043,"0000007750,
     +"7742403630,"4077454033,"0000007740,"7732273223,"3077353035,
     +"0000007751,"7742403630,"4077454033,"0000007740,"4140374033,
     +"0077374041,"4140374033,"0000007740,"4037404133,"7737404141,
     +"0077275125,"3640424431,"4240363535,"0000007744,"4240363431/
      DATA IX15/
     +"3640424343,"0000007734,"0077512723,"2777404023,"0000007751,
     +"2777512723,"0000007751,"3377404030,"7733457745,"3535364033,
     +"4343424036,"0000774042,"7740403633,"4341373533,"7743354243,
     +"4341373533,"4140774143,"3537414343,"0000000077,"4177414133,
     +"0000774434,"4037353633,"3740424342,"7742367735,"3536404233,
     +"4342403635,"7735364042,"3577374333,"0000007743,"3735353733,
     +"3741434341,"3735353777,"7741434341,"3640424333,"4342403635,
     +"7736404243,"4677464627,"3335374244,"3735333232,"0077464442,
     +"3277323226,"4543413634,"4143454646,"0077323436,"3742444627,
     +"3332323335,"4644423735,"0000000077,"4677464627,"3335374244,
     +"3735333232,"0077464442,"4546463227,"3335374244,"3735333232,
     +"0077464442,"4041434533,"7744357740,"4445464627,"4677353742,
     +"3335374244,"3735333232,"0077464442,"3377333327,"4645434036,
     +"0000007746,"4041403734,"7740407737,"4142414033,"4041417740,
     +"0000773436,"4577333327,"7746377733,"0077404034,"2577252521,
     +"4037353230,"4543407740,"7753535250,"3377333327,"4645434036,
     +"0000007746,"3233353727,"4237353332,"4647474644,"0077374244,
     +"3277323226,"4543413634,"4143454646,"0077323436,"4677464627/
      DATA IX16/
     +"3335374244,"3735333232,"0077464442,"3577353531,"7745424036,
     +"3742454630,"4336343334,"4245464645,"0077333437,"4341404033,
     +"7744357745,"3634333327,"4677464341,"0000007746,"4677403230,
     +"0000007740,"4077343025,"7744407734,"0000774450,"4677463330,
     +"0000007733,"4677403230,"3132343640,"0000000077,"3377334630,
     +"7746337746,"3233353726,"3634323131,"5047454340,"4342413777,
     +"7750474645,"3537414327,"7731323334,"4647474543,"4077404345,
     +"4445454442,"3435374143,"0000007733,"3534323027,"4041414037,
     +"4046475077,"0000773536,"3335374227,"3634333232,"4545444240,
     +"3737404244,"7746444240,"3742444530,"7741363535,"3433333541,
     +"7745434136,"3737404230,"4677464340,"3333343742,"4242413634,
     +"0077363741,"3432302726,"7732343535,"4442403634,"7742454646,
     +"3331272625,"3433333434,"4443413735,"4345464645,"4341404041,
     +"0000775045,"3535364032,"7743424036,"4777313527,"3537434546,
     +"3736347734,"7744434241,"3635333130,"7732407746,"3477273526,
     +"4137353333,"4547774543,"5147454444,"0000007752,"3334353227,
     +"4546477732,"7732354043,"3737404230,"4377464340,"3735353640,
     +"3642774442,"4135333334,"7736404242,"3334364030,"4137353433/
      DATA IX17/
     +"4546464543,"0077404244,"4377323625,"2777464544,"0077513431,
     +"3534333327,"4645434137,"4042444546,"7727333436,"3335375127,
     +"3634333232,"4545444240,"0077414344,"3077364126,"0077503532,
     +"3432302726,"3533333535,"4746444237,"0000007747,"3031333525,
     +"3734323130,"5050474542,"3640424446,"0000007733,"4335333127,
     +"4750774745,"7730313345,"2577344424,"3333323026,"3735333232,
     +"5150464442,"0000000077,"2730323424,"3533313027,"4037407737,
     +"5047454341,"0077464750,"3377404030,"7745337745,"0077404036,
     +"4047314031,"4031474077,"0000000077,"4277373731,"4444457742,
     +"3436434545,"7745443534,"4545443534,"3435374244,"7734353534,
     +"4177404036,"4140407741,"0000774041,"4377364033,"7744357741,
     +"0000774435,"7733453330,"4341403634,"4141404043,"4140407743,
     +"0000774041,"4747464627,"4041424446,"4377353637,"3637404142,
     +"3231313234,"0000007732,"4141404036,"4140407740,"0000774041,
     +"4141404036,"4040417740,"0077404141,"7745334530,"3777363633,
     +"7743367737,"0000774336,"4277414133,"7742357742,"0000774235,
     +"7745334530,"4533774533,"0000000077,"3636374132,"3637774140,
     +"3677404177,"3640414137,"3637414140,"3677414077,"3640417737/
      DATA IX18/
     +"0077413736,"4242413733,"4241773740,"4277403777,"4240373741,
     +"4241373740,"4277374077,"4240377741,"0077374142,"7740322725,
     +"4051774031,"0000000077,"4137363625,"2625774242,"3332323130,
     +"4646454335,"7753525047,"3637775325,"7741424137,"4077404030,
     +"7741407737,"3740774137,"3437773436,"4442414077,"4077444177,
     +"3677303234,"4440773032,"4642775046,"3536407750,"3536407735,
     +"4343424077,"7743424077,"4077404030,"7740407740,"4140773740,
     +"4077413777,"4140773637,"4240367742,"3334364077,"4544424077,
     +"4240363477,"3436407744,"7732313132,"4746444240,"3634774647,
     +"4077444240,"3132333536,"4077323030,"4746454342,"3377465050,
     +"7745434035,"4077374030,"7741377741,"5050464340,"4750474547,
     +"4143444345,"3335343537,"3133313031,"4035323030,"0000000077,
     +"4142434432,"3534343540,"3640414140,"4341373535,"0000007744,
     +"4377433533,"0000007735,"5152535327,"3235414446,"3230272730,
     +"5146444135,"0077535352,"4445475026,"3436374142,"3130303133,
     +"4137363433,"5047454442,"0000007750,"3132343731,"4137343231,
     +"4647474644,"0077374144,"4646323232,"0000007732,"4047314031,
     +"0000000077,"4640324032,"0000007740,"3530364030,"5043454033/
      DATA IX19/
     +"0000774042,"4346434227,"4345437742,"0077453277,"3577404033,
     +"7743424036,"0077424036,"3532353627,"3533357736,"0077463377,
     +"3577404033,"7743424036,"0077424036,"4140404136,"0000774041,
     +"4141404036,"0000007740,"4140404136,"0000774041,"0077344433,
     +"3737404235,"0000774240,"4141403634,"0000773640,"0077443432,
     +"3477404032,"0000007744,"3477443432,"0000007744,"3577404033,
     +"7735437743/
      DATA IY11/
     +"3530252452,"5151504540,"3035404550,"0077242425,"5124273052,
     +"0000000077,"2526303152,"3026252424,"5151373432,"0000000077,
     +"3434242452,"4643413635,"4750515150,"0000007745,"4042422452,
     +"0000775124,"3435242452,"4136343333,"5151504643,"0077454750,
     +"2424252752,"4642353025,"4650515150,"3435374243,"7742373534,
     +"2440512452,"0000007724,"3127252452,"4036353433,"5150474542,
     +"4245475051,"3334353640,"2424252731,"0000000077,"4140363352,
     +"3233364041,"2524242527,"5045403327,"7746505151,"2440512451,
     +"7742424051,"2440512452,"3230262524,"3640363534,"4542403736,
     +"7751515047,"2425273153,"3431272524,"5150464441,"7744465051,
     +"2440512452,"3431272524,"5150464441,"0000007751,"2440512451,
     +"4036364024,"0000775151,"2440512450,"7736364024,"2425273153,
     +"3431272524,"5150464441,"4144465051,"0077414140,"2440512453,
     +"7736364051,"0077512444,"5047442450,"4447505151,"0000007742,
     +"2440512452,"7751354042,"5140512447,"0000007751,"2440512454,
     +"4051244051,"0000775124,"2440512453,"7751244051,"3127252453,
     +"5046444134,"4446505151,"2527313441,"0000772424,"2440512452,
     +"3330262524,"7737373635,"3127252453,"5046444134,"4446505151/
      DATA IY12/
     +"2527313441,"5345402424,"0000000077,"2440512452,"3230262524,
     +"4036363534,"0000775136,"2424252752,"3433312725,"4341403735,
     +"5051515046,"0000007746,"2440512450,"0000007724,"5046432453,
     +"4346505151,"0000007724,"2440512451,"0000007751,"2440512454,
     +"4051244051,"0000775124,"2440512452,"0000007751,"4051362451,
     +"0000773624,"2440512452,"7751514024,"2440512451,"7742424051,
     +"2440512452,"3230262524,"3640363534,"4542403736,"7751515047,
     +"2440512447,"0000007724,"2440512451,"7751514051,"2440512451,
     +"4036364024,"0000775151,"2440512452,"7751514024,"2440512453,
     +"7736364051,"3127252453,"5046444134,"4446505151,"2527313441,
     +"3636402424,"0000000077,"0077512444,"2440512452,"7751354042,
     +"2440512451,"0000007751,"2440512454,"4051244051,"0000775124,
     +"2440512453,"7751244051,"3640242451,"7751514036,"3127252453,
     +"5046444134,"4446505151,"2527313441,"0000772424,"2440512453,
     +"7724244051,"2440512452,"3330262524,"7737373635,"4051362451,
     +"5151402424,"0000000077,"2440512450,"0000007724,"2425273151,
     +"5133272524,"2425273140,"7733272524,"3140512452,"4240353332,
     +"4243444443,"3132333540,"0000007731,"5140512452,"0000007724/
      DATA IY13/
     +"3240512453,"4241373332,"3741424343,"0077323233,"3642515152,
     +"2424252732,"4236322725,"0000775151,"4040513054,"7751514040,
     +"0077602044,"4236363246,"4242464642,"7732323636,"2040552052,
     +"3130274055,"2424252730,"3433312725,"4042403735,"3736343331,
     +"5150464240,"4445465051,"0000774645,"4740422445,"7747505150,
     +"2040602053,"4035354060,"0000774343,"7751402754,"2526303151,
     +"3026252424,"4237353432,"5051504740,"0000007747,"2223222154,
     +"2321202021,"5450343025,"3024224056,"5755535044,"5556576060,
     +"0000775756,"3435343345,"5150474033,"0000774750,"3435343345,
     +"5051504033,"5554525047,"0000000077,"7751402754,"2040602047,
     +"4020204060,"0000776060,"2040602047,"4020204060,"0000776060,
     +"4041353150,"4646404242,"0000000077,"2422212047,"3533313026,
     +"2523214037,"3634323027,"5046444240,"4057555351,"5047454341,
     +"6057565452,"0000000077,"2422212047,"3533313026,"2523214037,
     +"3634323027,"5046444240,"4057555351,"5047454341,"6057565452,
     +"0000000077,"4047333360,"5110405134,"0000000077,"4136322654,
     +"4546464543,"3632264043,"4646454341,"4743404345,"5247434052,
     +"0077525240,"2627313454,"4035312726,"3440524542,"2726262731/
      DATA IY14/
     +"4542403531,"0000007752,"4035302554,"4035302540,"5350434040,
     +"5350434040,"0000000077,"4646454254,"3637414345,"3537403736,
     +"2626273133,"3735333127,"3736363740,"4646454341,"4742404245,
     +"5247424052,"0077525240,"3333343555,"5046433634,"4547505151,
     +"3334404143,"2524252731,"4637343127,"4750515150,"0000000077,
     +"3140473153,"0000007747,"3140463150,"3435353432,"3232313132,
     +"4543424031,"4243454646,"0000007742,"4544434053,"3741434445,
     +"3433333435,"4545444335,"3537414344,"3534333334,"0000007740,
     +"4137353444,"4143444443,"4034343537,"4236404137,"3540433540,
     +"4043354043,"4137404236,"0000000077,"3444443444,"4043354034,
     +"4335404335,"3540433540,"4043354043,"0000774335,"3243433245,
     +"3540423540,"4042404042,"0000774240,"4635354645,"4340364340,
     +"4036404036,"0000773640,"3636453246,"3240403245,"4040364040,
     +"4045404045,"0000773640,"4042403655,"4040454033,"0000007740,
     +"4032273250,"3040353035,"0000007751,"4042403655,"4040454033,
     +"0000007740,"4046514650,"2740435043,"0000007750,"2524252645,
     +"0077323127,"5051504745,"0000007747,"4750515045,"7755545250,
     +"0077602053,"3125222047,"5653474236,"0000007760,"3125222047/
      DATA IY15/
     +"5653474236,"0000007760,"0077404055,"4040512755,"0000007740,
     +"4340353555,"0000007743,"3540463250,"7743354043,"4136343345,
     +"3641434443,"0000773334,"7744333545,"3433333445,"7744444036,
     +"3433333445,"3737403736,"4344444340,"0000000077,"3340443345,
     +"0000774141,"3636373345,"4444434137,"7733334043,"3634333345,
     +"4143444341,"7741373637,"3340443345,"0000007733,"3736343345,
     +"3333343637,"4443403740,"7737404344,"4041403645,"3634333436,
     +"7744444341,"3640513352,"3634333334,"5150464341,"0077465051,
     +"3640512451,"3634333334,"5150464341,"0077465051,"3333343651,
     +"4643413634,"4650515150,"0000000077,"3640512452,"3634333334,
     +"5150464341,"0077465051,"3537414151,"3634333334,"5150464341,
     +"0077465051,"3025242447,"7733334051,"5756533352,"3640576060,
     +"3634333334,"5150464341,"0077465051,"3740512452,"3734333334,
     +"0000007751,"2324252444,"7751334024,"2324252445,"5754334024,
     +"0000776060,"3340512450,"7751414045,"0077512444,"3740513357,
     +"3734333334,"3334374051,"7751373433,"3740513352,"3734333334,
     +"0000007751,"4136343352,"5151504643,"3641434650,"0077333334,
     +"3640603351,"3634333334,"5150464341,"0077465051,"3640603352/
      DATA IY16/
     +"3634333334,"5150464341,"0077465051,"4140513346,"7733333436,
     +"3333343651,"4241403634,"5150464543,"0077465051,"5150452447,
     +"7733334051,"5150453352,"3340455051,"0000007751,"3340513350,
     +"0000007751,"3340513353,"4051334051,"0000775133,"3340513351,
     +"0000007751,"3340513350,"6060575551,"0000000077,"3340513351,
     +"7751514033,"4036343353,"5151504643,"3336424550,"3634333340,
     +"7751515046,"3327252452,"4060504236,"3331262424,"3540353534,
     +"4745424036,"4750515150,"0000007744,"3333343652,"5144403534,
     +"5140363340,"0000776055,"3634333351,"5150474441,"4043465051,
     +"2527313335,"7727252424,"3333343550,"4041403634,"5046444241,
     +"7746505151,"2726252447,"3140313130,"4543403533,"5755535147,
     +"0077566060,"3333353752,"4051423634,"3333343642,"7760454035,
     +"3333353752,"5046433634,"4345505151,"2425303340,"3633302624,
     +"0000774240,"5046423345,"7745475151,"3440513351,"4140343333,
     +"4342414041,"7750515150,"2625242450,"7751334051,"3740603353,
     +"5051514744,"4233404246,"4751515046,"0000007745,"4641333351,
     +"4036334051,"7751504643,"2726252450,"3140313130,"4137353332,
     +"4342404242,"5452504644,"7760605755,"4136343351,"5151504744/
      DATA IY17/
     +"3540434650,"0077333334,"3340513353,"3640514641,"0077333334,
     +"5047444151,"4346505151,"3333343540,"7760413634,"3634333353,
     +"5150474441,"4043465051,"0077333435,"3640513352,"0077333334,
     +"3333353752,"5147443634,"3642465051,"0000007733,"4237353453,
     +"5151504745,"3540434650,"4641353333,"0000007760,"5635333351,
     +"3533406060,"7760565340,"3740602453,"3634333335,"5151504643,
     +"3336434650,"0000000077,"4237343353,"5051515045,"5045414045,
     +"4245505151,"0077333437,"4040463350,"7746464040,"0077453242,
     +"3044443047,"5034345040,"0000000077,"2640522650,"3332324052,
     +"3231313233,"4042413634,"4442403534,"4445464645,"7744444343,
     +"3340403343,"4444434040,"0000774343,"3240453246,"4036364045,
     +"0000774141,"7746403250,"3433333445,"3740403736,"4444434036,
     +"0000774343,"2730302751,"3532302626,"2740514743,"5046433531,
     +"5050515252,"0000007751,"3637373643,"4444434036,"0000774343,
     +"3637373643,"4344444036,"0077474543,"7746403250,"2640522645,
     +"4026264052,"0000775252,"2640522645,"4026264052,"0000775252,
     +"4041353150,"4646404242,"0000000077,"3230272645,"3227403634,
     +"3040373440,"4037363432,"5046444241,"4640444140,"4644424051/
      DATA IY18/
     +"0077525150,"3230272646,"3227403634,"3040373440,"4037363432,
     +"5046444241,"4640444140,"4644424051,"0077525150,"4045353551,
     +"4624404635,"0000000077,"2424252753,"4650402725,"3031364244,
     +"3631302727,"4050464442,"5150405050,"7750515252,"4140413350,
     +"4052414052,"3033405252,"2530402526,"2526303340,"3340253040,
     +"3240333131,"3133403332,"3232403331,"3534334033,"4035334040,
     +"4035343340,"7740353340,"3440312750,"4043414036,"5247405247,
     +"2540525240,"2725403027,"3027304030,"3435343140,"3435343140,
     +"3534353540,"4241364035,"4042414042,"4042424136,"4242404241,
     +"4340424241,"4750504746,"4340504745,"4750504746,"5040504745,
     +"7750504750,"4740524750,"4052524052,"4346505047,"3335404242,
     +"2526303332,"3233302625,"4242403533,"4750504643,"0000000077,
     +"4341404046,"4041434444,"3333343637,"4443413634,"0000007744,
     +"3540433545,"0000007743,"4143465053,"3534343536,"4342413736,
     +"3742434444,"0077303235,"4343424052,"3435364142,"4240373534,
     +"3641424343,"3735343435,"0000007740,"3734323147,"4747464441,
     +"3437414446,"0077313132,"3246463246,"0000007732,"3044443047,
     +"0000000077,"4052402646,"0000007726,"4135352750,"3541474347/
      DATA IY19/
     +"0000772735,"4240363551,"4240364043,"0077404040,"3640463345,
     +"4036353235,"0077353335,"4240363551,"4240364043,"0077404040,
     +"4240453245,"4042434643,"0077434543,"3333343443,"0000773735,
     +"4344444343,"0000007743,"4343444443,"0000774745,"0077453245,
     +"4136343244,"0000774543,"4136343243,"0000774543,"0077404046,
     +"4040443446,"0000007740,"4240363646,"0000007742,"3640433545,
     +"7742364042/
      DATA ISTART/
     +  1,  5,  7, 11, 15, 17, 21, 26, 28, 35, 40, 42, 47, 51, 55,
     + 58, 60, 65, 67, 68, 71, 73, 75, 78, 80, 85, 88, 94, 98,103,
     +105,108,110,113,115,117,119,121,126,128,130,133,135,137,143,
     +144,146,148,151,153,155,160,162,165,168,170,174,179,181,185,
     +189,191,192,195,204,206,209,210,215,222,225,229,230,233,236,
     +239,248,257,260,267,273,278,288,296,298,304,311,319,325,329,
     +333,338,341,344,347,350,352,354,356,357,360,363,364,366,368,
     +370,373,374,376,380,382,385,388,390,394,397,401,405,409,413,
     +417,419,424,427,429,432,434,435,439,442,446,450,454,456,460,
     +462,465,467,470,472,475,477,482,489,493,498,502,507,511,517,
     +519,523,525,530,533,539,543,546,550,554,556,560,565,568,573,
     +578,580,581,584,591,594,597,598,602,608,611,614,615,618,621,
     +624,632,640,643,650,663,682,691,696,698,703,709,713,715,717,
     +719,722,725,728,731,734,736,738,740,741,743,745,746,748,750/
*
      DATA NBIT,NBITCH,NBITMX/36,6,30/
+SELF, IF=SUN,SGI,IBMRT,DECS,MSDOS,LINUX,CVY,WINNT.
      SAVE IA
+SELF, IF=SUN,SGI,IBMRT,DECS,MSDOS,LINUX,CVY,WINNT, IF=F90,QFEPC,QFMSOFT.
      DATA (IX11(I),I=1,50)/
     +Z'1969C7D6',Z'217DC699',Z'269E79A4',Z'00FDF864',Z'2185E716',
     +Z'0000003F',Z'1C6DA696',Z'2696489E',Z'27663966',Z'0000003F',
     +Z'238266D6',Z'269E79A5',Z'1A6DE864',Z'00000FD9',Z'3FA198D6',
     +Z'0003F8E3',Z'1B69B956',Z'279A485E',Z'1E8649A7',Z'00FD969B',
     +Z'208A5996',Z'1B69A6DD',Z'2692181D',Z'219269E7',Z'3F69B760',
     +Z'19FDD9D6',Z'00000FE7',Z'1A69B796',Z'2692175B',Z'229669E7',
     +Z'1965A6DE',Z'258DF71A',Z'1E8A59A6',Z'0000003F',Z'208E5996',
     +Z'1965A71F',Z'2381F71A',Z'239669A5',Z'3F69B7A0',Z'20FD8817',
     +Z'3F95BFE8',Z'19FD9655',Z'279E6962',Z'19FE2966',Z'279E6962',
     +Z'3F662966',Z'23967A16',Z'1969B75F',Z'1F75B699',Z'3FA27963'/
      DATA (IX11(I), I=51,108)/
     +Z'19FD9655',Z'279A58E0',Z'208E59A7',Z'00000FD9',Z'1AFDA696',
     +Z'3F89AFE7',Z'0003F9DA',Z'1AFDA696',Z'3F89AFE7',Z'23967A16',
     +Z'1969B75F',Z'1F75B699',Z'28A27963',Z'00FE88FF',Z'27FD9655',
     +Z'3F9D9FE7',Z'00FE081C',Z'228E4918',Z'1A6DC7A0',Z'00000FDA',
     +Z'27FD9655',Z'3F9DEFD9',Z'1AFDA696',Z'00000FE6',Z'18FD8614',
     +Z'3F828FE0',Z'0003FA28',Z'19FD9655',Z'3F9E7FE7',Z'1969C795',
     +Z'1C699618',Z'279A489E',Z'249A7A28',Z'0003F7A2',Z'19FD9655',
     +Z'279E6962',Z'3F662966',Z'1969C795',Z'1C699618',Z'279A489E',
     +Z'249A7A28',Z'2787F7A2',Z'0000003F',Z'19FD9655',Z'279E6962',
     +Z'3F662966',Z'0003F9E0',Z'1E8A59D6',Z'1B69965B',Z'279A58DD',
     +Z'1B7A2967',Z'00000FD9',Z'19FE0818',Z'00000FE7',Z'1C699655',
     +Z'279A485F',Z'00000FE7',Z'28FE0617'/
      DATA (IX12(I),I=1,50)/
     +Z'00000FE0',Z'20FDB594',Z'3F960FDB',Z'0003F96A',Z'27FE7656',
     +Z'00000FD9',Z'3F820617',Z'0003F828',Z'19FD99D6',Z'3F9D9FE7',
     +Z'20FD8817',Z'3F95BFE8',Z'19FD9655',Z'279E6962',Z'19FE2966',
     +Z'279E6962',Z'3F662966',Z'1AFDA696',Z'00000FE6',Z'20FD8817',
     +Z'3FA18FE8',Z'1AFDA696',Z'3F89AFE7',Z'0003F9DA',Z'19FD99D6',
     +Z'3F9D9FE7',Z'27FD9655',Z'3F9D9FE7',Z'1969C795',Z'1C699618',
     +Z'279A489E',Z'249A7A28',Z'2377F7A2',Z'0000003F',Z'00FE081C',
     +Z'27FD9655',Z'3F9DEFD9',Z'20FD8817',Z'00000FE8',Z'18FD8614',
     +Z'3F828FE0',Z'0003FA28',Z'19FD9655',Z'3F9E7FE7',Z'1DFE7657',
     +Z'3F9D9FE3',Z'1969C795',Z'1C699618',Z'279A489E',Z'249A7A28'/
      DATA (IX12(I), I=51,108)/
     +Z'0003F7A2',Z'27FD9655',Z'3F9D9FE7',Z'19FD9655',Z'279E6962',
     +Z'3F662966',Z'3F660657',Z'2767F9D9',Z'0000003F',Z'19FE0818',
     +Z'00000FE7',Z'1B699657',Z'2081F79D',Z'259A79FF',Z'3F8218A3',
     +Z'1EFE0816',Z'1A65969B',Z'2696279B',Z'229669E7',Z'00000FDE',
     +Z'19FE7656',Z'00000FE7',Z'17FE0815',Z'1C6DA658',Z'2696485F',
     +Z'00FE9A27',Z'1969D656',Z'217DC699',Z'269E79A4',Z'0003F9E3',
     +Z'18FE0814',Z'3FA18FE8',Z'00FE081C',Z'1A69E79A',Z'268A279E',
     +Z'3F7A28A6',Z'22FDE796',Z'26966FE2',Z'1E8A59E7',Z'1B69965B',
     +Z'3F9E58DD',Z'258DD6D9',Z'229679E6',Z'1A6596DE',Z'0003F69B',
     +Z'20FE081B',Z'3F82181F',Z'27FDA856',Z'3FA1AFE0',Z'0003F9D9',
     +Z'3F628614',Z'1C6DA697',Z'2696489E',Z'20824966',Z'2181F83F',
     +Z'00000FE0',Z'2AA68A54',Z'23967A6A'/
      DATA (IX13(I),I=1,50)/
     +Z'1D7A0862',Z'228E4FDC',Z'1B75E7E0',Z'175965D9',Z'0003F5D8',
     +Z'2181F81B',Z'207E0FE0',Z'0003F821',Z'2181F81B',Z'1F821FE0',
     +Z'1F821860',Z'0000003F',Z'3FA18A14',Z'1EFDD759',Z'3F91DFDE',
     +Z'0003F91D',Z'23FE2899',Z'3F8DCFE3',Z'0003F8DC',Z'3F6E56D8',
     +Z'256FF95B',Z'0000003F',Z'1E7E0899',Z'218607DE',Z'1F7E0FDF',
     +Z'218A2860',Z'218A285D',Z'3F81F7E0',Z'1F82185F',Z'2281F79E',
     +Z'0000003F',Z'22860799',Z'1F7E0862',Z'21860FE1',Z'1F79E7E0',
     +Z'1F79E7E3',Z'3F821860',Z'2181F7E1',Z'1E8218A2',Z'0000003F',
     +Z'3F81748F',Z'20C3F816',Z'0000003F',Z'1865C814',Z'1F75B658',
     +Z'27920FE0',Z'23967A28',Z'1F83F821',Z'22860FDE',Z'00FE27BF'/
      DATA (IX13(I), I=51,108)/
     +Z'1C79F814',Z'1961865B',Z'20FE071A',Z'279648A1',Z'249A7A28',
     +Z'00000FE0',Z'1769E814',Z'299A283F',Z'2079A5FF',Z'208A6A7F',
     +Z'0000003F',Z'26922814',Z'26A29A68',Z'2387F864',Z'1F863924',
     +Z'1F75C71D',Z'1869C7FF',Z'1C6985D7',Z'1F83F81E',Z'22860FDE',
     +Z'00FE27BF',Z'28A6AA93',Z'208A49A7',Z'165D869E',Z'207D85D6',
     +Z'1C7A0861',Z'2379C6DB',Z'2AAA99E5',Z'0000003F',Z'27FE7655',
     +Z'00000FD9',Z'1DFDA998',Z'1A6DD79E',Z'2485D6DA',Z'228A3FE6',
     +Z'259A6963',Z'00000FE3',Z'258E2815',Z'2BAEAA67',Z'23967A6A',
     +Z'196DD7A2',Z'16555597',Z'1E75B657',Z'00000FE0',Z'1C71D7DC',
     +Z'248E17DD',Z'3F7E18E4',Z'1E7BF75D',Z'20FDF7FF',Z'3F861FE0',
     +Z'238FF8A2',Z'0000003F',Z'2491C71C',Z'3F75DFDC',Z'1F7FF79E',
     +Z'21FE083F',Z'3F8A2FE1',Z'0003F8E3'/
      DATA (IX14(I),I=1,50)/
     +Z'2095B81B',Z'20FDD83F',Z'3F7E0FE3',Z'0003F860',Z'206E581B',
     +Z'20FE383F',Z'3F860FDD',Z'0003F7E0',Z'1A99C81A',Z'2083F824',
     +Z'20FDA83F',Z'3F920FDC',Z'0003F9A0',Z'3F9A9993',Z'17FE3A23',
     +Z'00000FE8',Z'3F8A0798',Z'20FE581B',Z'00000FE0',Z'3F697693',
     +Z'18FDD61D',Z'00000FE9',Z'3F8A0798',Z'20FE581B',Z'00000FE0',
     +Z'2181F81B',Z'00FDF821',Z'2181F81B',Z'00000FE0',Z'207E085B',
     +Z'3F7E0861',Z'00FD7A55',Z'1E822919',Z'2281E75D',Z'00000FE4',
     +Z'2281E719',Z'1E8228E3',Z'00000FDC',Z'00FE95D3',Z'17FE0813',
     +Z'00000FE9',Z'17FE95D3',Z'00000FE9',Z'1BFE0818',Z'3F6E5FE5',
     +Z'1D75E81B',Z'238E281E',Z'0003F822',Z'3F82079B',Z'2385F75B'/
      DATA (IX14(I), I=51,108)/
     +Z'3F8DD8A3',Z'2385F75B',Z'2183F863',Z'1D7E18E3',Z'0000003F',
     +Z'21FE185B',Z'0003F91C',Z'207DD79B',Z'1F8228E2',Z'3F89EFDD',
     +Z'1D7A089B',Z'238A079D',Z'3F75E822',Z'1DFDF8DB',Z'00000FE3',
     +Z'1F75D7DB',Z'1F8638E1',Z'1F75D7FF',Z'3F8638E1',Z'1E8228DB',
     +Z'238A079D',Z'3F7A08A3',Z'26FE6997',Z'1B75F8A4',Z'1F75B69A',
     +Z'00FE6922',Z'1AFDA696',Z'258E179C',Z'218E59A6',Z'00FDA71E',
     +Z'1F8A4997',Z'1B69A6DD',Z'269227DD',Z'0000003F',Z'26FE6997',
     +Z'1B75F8A4',Z'1F75B69A',Z'00FE6922',Z'259A6697',Z'1B75F8A4',
     +Z'1F75B69A',Z'00FE6922',Z'2086395B',Z'3F91DFE0',Z'24966997',
     +Z'26FDD7E2',Z'1B75F8A4',Z'1F75B69A',Z'00FE6922',Z'1BFDB6D7',
     +Z'2696381E',Z'00000FE6',Z'208607DC',Z'3F820FDF',Z'218A181B',
     +Z'20861FE0',Z'0003F71E',Z'25FDB6D7'/
      DATA (IX15(I),I=1,50)/
     +Z'3F99FFDB',Z'00FE081C',Z'15FD5551',Z'207DD698',Z'258E0FE0',
     +Z'3FAEBAA8',Z'1BFDB6D7',Z'2696381E',Z'00000FE6',Z'1A6DD7D7',
     +Z'227DD6DA',Z'269E79A4',Z'00FDF8A4',Z'1AFDA696',Z'258E179C',
     +Z'218E59A6',Z'00FDA71E',Z'26FE6997',Z'1B75F8A4',Z'1F75B69A',
     +Z'00FE6922',Z'1DFDD759',Z'3F96281E',Z'1F8A5998',Z'2379C6DC',
     +Z'229669A5',Z'00FDB71F',Z'2386081B',Z'3F91DFE5',Z'1E71B6D7',
     +Z'26FE68E1',Z'00000FE6',Z'26FE0698',Z'00000FE0',Z'20FDC615',
     +Z'3F920FDC',Z'0003F928',Z'26FE66D8',Z'00000FDB',Z'26FE0698',
     +Z'1969C7A0',Z'0000003F',Z'1BFDB998',Z'3F99BFE6',Z'1A6DD7D6',
     +Z'1E71A659',Z'289E58E0',Z'238A17FF',Z'3FA279A5',Z'1D7E18D7'/
      DATA (IX15(I), I=51,108)/
     +Z'3F65A6DC',Z'269E7963',Z'20FE08E5',Z'24965922',Z'1C75F863',
     +Z'00000FDB',Z'1D71A617',Z'2086181F',Z'209A7A3F',Z'0003F75E',
     +Z'1B75F897',Z'1E71B69A',Z'259648A0',Z'1F7E08A4',Z'3F9A48A0',
     +Z'1F8A4958',Z'3F85E75D',Z'1C6DB761',Z'3F96385E',Z'1F7E0898',
     +Z'26FE68E0',Z'1B6DC7E2',Z'228A179C',Z'00FDE7E1',Z'1C6985D6',
     +Z'3F69C75D',Z'248A079C',Z'3F8A59A6',Z'1B657595',Z'1C6DB71C',
     +Z'248E17DD',Z'239669A5',Z'23860821',Z'0003FA25',Z'1D75E81A',
     +Z'3F8E281E',Z'27FD9757',Z'1D7E3966',Z'1F79CFDC',Z'3F9238A1',
     +Z'1E75B658',Z'3F6A0FE6',Z'1CFD7756',Z'217DD6DB',Z'259FF963',
     +Z'299E5924',Z'00000FEA',Z'1B71D697',Z'259A7FDA',Z'3F69D823',
     +Z'1F7E0898',Z'23FE68E0',Z'1F75D7A0',Z'1E8BF922',Z'2175B6DC',
     +Z'3F7A08A2',Z'1B71E818',Z'217DD71B'/
      DATA (IX16(I),I=1,50)/
     +Z'259A6963',Z'00FE08A4',Z'23FDA795',Z'17FE6964',Z'00FE9719',
     +Z'1D71B6D7',Z'2696385F',Z'208A4966',Z'3F5DB71E',Z'1B75FA57',
     +Z'1E71B69A',Z'259648A0',Z'00FE18E4',Z'18FDE856',Z'00FE875A',
     +Z'1C6985D6',Z'1D6DB75D',Z'279A489F',Z'00000FE7',Z'1865B755',
     +Z'1F71A658',Z'28A27962',Z'1E822926',Z'00000FDB',Z'2375B657',
     +Z'27A3F9E5',Z'3F6196E5',Z'15FDC914',Z'1B6DA616',Z'1F75B69A',
     +Z'29A26922',Z'0000003F',Z'1761A714',Z'1D6D9617',Z'207E0FDF',
     +Z'289E58E1',Z'00FE69E8',Z'1BFE0818',Z'3F95BFE5',Z'00FE081E',
     +Z'209D9819',Z'2066783F',Z'0000003F',Z'22FDF7D9',Z'24925FE2',
     +Z'1C7A3965',Z'3F96475C',Z'2596475C',Z'1C75F8A4',Z'3F71D75C'/
      DATA (IX16(I), I=51,108)/
     +Z'21FE081E',Z'21820FE1',Z'0003F821',Z'23FDE81B',Z'3F91DFE1',
     +Z'0003F91D',Z'3F6E56D8',Z'2386079C',Z'21860823',Z'21820FE3',
     +Z'0003F821',Z'279E6997',Z'20862926',Z'23FDD79F',Z'1E7E0862',
     +Z'1A65969C',Z'00000FDA',Z'2186081E',Z'21820FE0',Z'0003F821',
     +Z'2186081E',Z'20821FE0',Z'00FE0861',Z'3F95B958',Z'1FFDE79B',
     +Z'3F8DEFDF',Z'0003F8DE',Z'22FE185B',Z'3F89DFE2',Z'0003F89D',
     +Z'3F95B958',Z'256FF95B',Z'0000003F',Z'1E79F85A',Z'1E7FF860',
     +Z'1EFE087F',Z'1E82185F',Z'1E7E1860',Z'1EFE183F',Z'1E821FDF',
     +Z'00FE17DE',Z'228A17DB',Z'2287F7E0',Z'22FE07FF',Z'2281F7E1',
     +Z'2285F7E0',Z'22FDF83F',Z'2281FFE1',Z'00FDF862',Z'3F81A5D5',
     +Z'20A7F819',Z'0000003F',Z'217DE795',Z'1657F8A2',Z'1B69A658',
     +Z'269A58DD',Z'3FAEAA27',Z'1E7FFAD5'/
      DATA (IX17(I),I=1,50)/
     +Z'3F86285F',Z'20FE0818',Z'3F860FDF',Z'1F83F85F',Z'1C7FF71E',
     +Z'248A183F',Z'20FE487F',Z'1EFD869C',Z'2483F61A',Z'268BFA26',
     +Z'1D7A0FE8',Z'1D7A0FDD',Z'238E283F',Z'3F8E283F',Z'20FE0818',
     +Z'3F820FE0',Z'2183F7E0',Z'20FE17FF',Z'2183F79F',Z'2281EFE2',
     +Z'1B71E83F',Z'2592283F',Z'2281E73F',Z'1C7A0FE4',Z'3F69965A',
     +Z'279A48A0',Z'1E73F9A7',Z'20FE48A0',Z'1969B75E',Z'20FDA618',
     +Z'279A58E2',Z'1BFE6A28',Z'3F96381D',Z'20FDF818',Z'3F85FFE1',
     +Z'28A268E0',Z'27A27967',Z'218E48E5',Z'1B75C75F',Z'196D9619',
     +Z'2075A618',Z'0000003F',Z'218A391A',Z'1D71C760',Z'1E821860',
     +Z'2385F75D',Z'00000FE4',Z'23FE375B',Z'00000FDD',Z'29AABAD7'/
      DATA (IX17(I), I=51,103)/
     +Z'1A761926',Z'1A6175D8',Z'299A485D',Z'00FEBAEA',Z'24967A16',
     +Z'1C79F862',Z'1961865B',Z'217DE71B',Z'289E5922',Z'00000FE8',
     +Z'1969C7D9',Z'217DC699',Z'269E79A4',Z'00FDF864',Z'2699A69A',
     +Z'00000FDA',Z'209D9819',Z'0000003F',Z'2681A81A',Z'00000FE0',
     +Z'1D61E818',Z'288E581B',Z'0003F822',Z'239A3897',Z'23963FE2',
     +Z'00FE56BF',Z'1DFE081B',Z'3F8E281E',Z'00FE281E',Z'1D69D797',
     +Z'1D6DDFDE',Z'00FE66FF',Z'1DFE081B',Z'3F8E281E',Z'00FE281E',
     +Z'2182085E',Z'0003F821',Z'2186081E',Z'00000FE0',Z'2182085E',
     +Z'0003F821',Z'00FDC91B',Z'1F7E089D',Z'0003F8A0',Z'2186079C',
     +Z'0003F7A0',Z'00FE471A',Z'1CFE081A',Z'00000FE4',Z'1CFE471A',
     +Z'00000FE4',Z'1DFE081B',Z'3F763FE3'/
      DATA (IY11(I),I=1,50)/
     +Z'1D61552A',Z'29A68960',Z'18760968',Z'00FD4515',Z'2951762A',
     +Z'0000003F',Z'1559866A',Z'18595514',Z'29A5F71A',Z'0000003F',
     +Z'1C71452A',Z'268E179D',Z'27A29A68',Z'00000FE5',Z'208A252A',
     +Z'0003FA54',Z'1C75452A',Z'2179C6DB',Z'29A689A3',Z'00FE59E8',
     +Z'145155EA',Z'2689D615',Z'26A29A68',Z'1C75F8A3',Z'3F89F75C',
     +Z'1482952A',Z'00000FD4',Z'195D552A',Z'2079D71B',Z'29A27962',
     +Z'22967A29',Z'1B71D7A0',Z'145155D9',Z'0000003F',Z'2181E6EA',
     +Z'1A6DE821',Z'15514557',Z'289606D7',Z'3F9A8A69',Z'14829529',
     +Z'3F8A2829',Z'1482952A',Z'1A616554',Z'1E81E75C',Z'258A07DE',
     +Z'3FA69A27',Z'1455766B',Z'1C657554',Z'29A26921',Z'3F926A29'/
      DATA (IY11(I), I=51,108)/
     +Z'1482952A',Z'1C657554',Z'29A26921',Z'00000FE9',Z'14829529',
     +Z'2079E814',Z'0003FA69',Z'14829528',Z'3F79E814',Z'1455766B',
     +Z'1C657554',Z'29A26921',Z'21926A29',Z'00FE1860',Z'1482952B',
     +Z'3F79E829',Z'00FE9524',Z'289E4528',Z'249E8A69',Z'00000FE2',
     +Z'1482952A',Z'3FA5D822',Z'29829527',Z'00000FE9',Z'1482952C',
     +Z'20A54829',Z'0003FA54',Z'1482952B',Z'3FA54829',Z'195D552B',
     +Z'289A485C',Z'249A8A69',Z'155D9721',Z'0003F514',Z'1482952A',
     +Z'1B616554',Z'3F7DF79D',Z'195D552B',Z'289A485C',Z'249A8A69',
     +Z'155D9721',Z'2B960514',Z'0000003F',Z'1482952A',Z'1A616554',
     +Z'2079E75C',Z'0003FA5E',Z'145155EA',Z'1C6D95D5',Z'238607DD',
     +Z'28A69A26',Z'00000FE6',Z'14829528',Z'00000FD4',Z'289A352B',
     +Z'239A8A69',Z'00000FD4',Z'14829529'/
      DATA (IY12(I),I=1,50)/
     +Z'00000FE9',Z'1482952C',Z'20A54829',Z'0003FA54',Z'1482952A',
     +Z'00000FE9',Z'20A5E529',Z'0003F794',Z'1482952A',Z'3FA69814',
     +Z'14829529',Z'3F8A2829',Z'1482952A',Z'1A616554',Z'1E81E75C',
     +Z'258A07DE',Z'3FA69A27',Z'14829527',Z'00000FD4',Z'14829529',
     +Z'3FA69829',Z'14829529',Z'2079E814',Z'0003FA69',Z'1482952A',
     +Z'3FA69814',Z'1482952B',Z'3F79E829',Z'195D552B',Z'289A485C',
     +Z'249A8A69',Z'155D9721',Z'1E7A0514',Z'0000003F',Z'00FE9524',
     +Z'1482952A',Z'3FA5D822',Z'14829529',Z'00000FE9',Z'1482952C',
     +Z'20A54829',Z'0003FA54',Z'1482952B',Z'3FA54829',Z'1E814529',
     +Z'3FA6981E',Z'195D552B',Z'289A485C',Z'249A8A69',Z'155D9721'/
      DATA (IY12(I), I=51,108)/
     +Z'0003F514',Z'1482952B',Z'3F514829',Z'1482952A',Z'1B616554',
     +Z'3F7DF79D',Z'20A5E529',Z'29A60514',Z'0000003F',Z'14829528',
     +Z'00000FD4',Z'14557669',Z'296D7554',Z'14557660',Z'3F6D7554',
     +Z'1982952A',Z'2281D6DA',Z'228E4923',Z'1969B760',Z'00000FD9',
     +Z'2982952A',Z'00000FD4',Z'1A82952B',Z'2285F6DA',Z'1F8628E3',
     +Z'00FDA69B',Z'1E8A9A6A',Z'145155DA',Z'2279A5D5',Z'0003FA69',
     +Z'2082962C',Z'3FA69820',Z'00FF0424',Z'2279E6A6',Z'228A69A2',
     +Z'3F69A79E',Z'1082D42A',Z'1961782D',Z'145155D8',Z'1C6D95D5',
     +Z'208A07DD',Z'1F79C6D9',Z'29A268A0',Z'24966A29',Z'0003F9A5',
     +Z'27822525',Z'3F9E8A68',Z'1083042B',Z'2075D830',Z'0003F8E3',
     +Z'3FA605EC',Z'15598669',Z'18595514',Z'227DD71A',Z'28A689E0',
     +Z'00000FE7',Z'124D246C',Z'13450411'/
      DATA (IY13(I),I=1,50)/
     +Z'2CA1C615',Z'1851282E',Z'2FB6BA24',Z'2DBAFC30',Z'0003FBEE',
     +Z'1C75C6E5',Z'29A2781B',Z'0003F9E8',Z'1C75C6E5',Z'28A6881B',
     +Z'2DB2AA27',Z'0000003F',Z'3FA605EC',Z'10830427',Z'20410830',
     +Z'0003FC30',Z'10830427',Z'20410830',Z'0003FC30',Z'2085D668',
     +Z'269A08A2',Z'0000003F',Z'14491427',Z'1D6D9616',Z'154D181F',
     +Z'1E71A617',Z'289A48A0',Z'20BEDAE9',Z'289E58E1',Z'30BEEB2A',
     +Z'0000003F',Z'14491427',Z'1D6D9616',Z'154D181F',Z'1E71A617',
     +Z'289A48A0',Z'20BEDAE9',Z'289E58E1',Z'30BEEB2A',Z'0000003F',
     +Z'209DB6F0',Z'29220A5C',Z'0000003F',Z'2179A5AC',Z'259A6963',
     +Z'1E696823',Z'269A58E1',Z'278E08E5',Z'2A9E382A',Z'00FEAAA0'/
      DATA (IY13(I), I=51,108)/
     +Z'165D972C',Z'207595D6',Z'1C82A962',Z'175965D9',Z'258A0759',
     +Z'00000FEA',Z'2075856C',Z'20758560',Z'2BA23820',Z'2BA23820',
     +Z'0000003F',Z'269A58AC',Z'1E7E18E5',Z'1D7E07DE',Z'1659765B',
     +Z'1F75B657',Z'1F79E7E0',Z'269A58E1',Z'278A08A5',Z'2A9E282A',
     +Z'00FEAAA0',Z'1B6DC76D',Z'289A379C',Z'259E8A69',Z'1B720863',
     +Z'155155D9',Z'267DC657',Z'27A29A68',Z'0000003F',Z'1982766B',
     +Z'00000FE7',Z'19826668',Z'1C75D71A',Z'1A69965A',Z'258E2819',
     +Z'228E59A6',Z'00000FE2',Z'2592382B',Z'1F863925',Z'1C6DB71D',
     +Z'259648DD',Z'1D7E18E4',Z'1D71B6DC',Z'00000FE0',Z'217DD724',
     +Z'218E4923',Z'2071C75F',Z'227A085F',Z'1D823760',Z'208DD823',
     +Z'217E089E',Z'0000003F',Z'1C924724',Z'208DD81C',Z'237608DD',
     +Z'1D823760',Z'208DD823',Z'0003F8DD'/
      DATA (IY14(I),I=1,50)/
     +Z'1A8E36A5',Z'1D822760',Z'208A0822',Z'0003F8A0',Z'2675D9A5',
     +Z'2381E8E0',Z'207A081E',Z'0003F7A0',Z'1E7A56A6',Z'1A8206A5',
     +Z'2081E820',Z'20960825',Z'0003F7A0',Z'208A07AD',Z'2082581B',
     +Z'00000FE0',Z'206976A8',Z'1881D61D',Z'00000FE9',Z'208A07AD',
     +Z'2082581B',Z'00000FE0',Z'209A99A8',Z'17823A23',Z'00000FE8',
     +Z'155155A5',Z'00FDA657',Z'28A689E5',Z'00000FE7',Z'27A29A25',
     +Z'3FB6CAA8',Z'00FF042B',Z'19552427',Z'2EAE789E',Z'00000FF0',
     +Z'19552427',Z'2EAE789E',Z'00000FF0',Z'00FE082D',Z'208295ED',
     +Z'00000FE0',Z'2381D76D',Z'00000FE3',Z'1D8266A8',Z'3F8DD823',
     +Z'2179C6E5',Z'1E863923',Z'0003F6DC',Z'3F91B765',Z'1C6DB725'/
      DATA (IY14(I), I=51,108)/
     +Z'3F92481E',Z'1C6DB725',Z'1F7E07DE',Z'239248E0',Z'0000003F',
     +Z'1B8246E5',Z'0003F861',Z'1E79F6E5',Z'2492385F',Z'3F6DB823',
     +Z'1E71B6E5',Z'218E48E1',Z'3F85F79F',Z'1B8246E5',Z'00000FDB',
     +Z'1F79C6E5',Z'1B6DC79F',Z'248E07E0',Z'3F7E08E4',Z'208607A5',
     +Z'1E71B71E',Z'3F9248E1',Z'1E8296EA',Z'1E71B6DC',Z'29A268E1',
     +Z'00FE6A29',Z'1E829529',Z'1E71B6DC',Z'29A268E1',Z'00FE6A29',
     +Z'1B6DC7A9',Z'268E179C',Z'26A29A68',Z'0000003F',Z'1E82952A',
     +Z'1E71B6DC',Z'29A268E1',Z'00FE6A29',Z'1D7E1869',Z'1E71B6DC',
     +Z'29A268E1',Z'00FE6A29',Z'18554527',Z'3F6DB829',Z'2FBAB6EA',
     +Z'1E82FC30',Z'1E71B6DC',Z'29A268E1',Z'00FE6A29',Z'1F82952A',
     +Z'1F71B6DC',Z'00000FE9',Z'13515524',Z'3FA5B814',Z'13515525',
     +Z'2FB1B814',Z'0003FC30',Z'1B829528'/
      DATA (IY15(I),I=1,50)/
     +Z'3FA61825',Z'00FE9524',Z'1F8296EF',Z'1F71B6DC',Z'1B71F829',
     +Z'3FA5F71B',Z'1F8296EA',Z'1F71B6DC',Z'00000FE9',Z'2179C6EA',
     +Z'29A689A3',Z'1E8639A8',Z'00FDB6DC',Z'1E8306E9',Z'1E71B6DC',
     +Z'29A268E1',Z'00FE6A29',Z'1E8306EA',Z'1E71B6DC',Z'29A268E1',
     +Z'00FE6A29',Z'218296E6',Z'3F6DB71E',Z'1B6DC7A9',Z'2286079C',
     +Z'29A26963',Z'00FE6A29',Z'29A25527',Z'3F6DB829',Z'29A256EA',
     +Z'1B825A29',Z'00000FE9',Z'1B8296E8',Z'00000FE9',Z'1B8296EB',
     +Z'20A5B829',Z'0003FA5B',Z'1B8296E9',Z'00000FE9',Z'1B8296E8',
     +Z'30C2FB69',Z'0000003F',Z'1B8296E9',Z'3FA6981B',Z'2079C6EB',
     +Z'29A689A3',Z'1B7A2968',Z'1E71B6E0',Z'3FA69A26',Z'1B5D552A'/
      DATA (IY15(I), I=51,108)/
     +Z'20C2889E',Z'1B656514',Z'1D81D75C',Z'2796281E',Z'27A29A68',
     +Z'00000FE4',Z'1B6DC7AA',Z'2992075C',Z'2981E6E0',Z'0003FC2D',
     +Z'1E71B6E9',Z'29A27921',Z'208E6A29',Z'155D96DD',Z'3F5D5514',
     +Z'1B6DC768',Z'2086079C',Z'289A48A1',Z'3F9A8A69',Z'17595527',
     +Z'19819658',Z'258E075B',Z'2FB6BA67',Z'00FEEC30',Z'1B6DD7EA',
     +Z'20A6279C',Z'1B6DC7A2',Z'3FC2581D',Z'1B6DD7EA',Z'289A379C',
     +Z'23968A69',Z'145586E0',Z'1E6D8594',Z'0003F8A0',Z'289A26E5',
     +Z'3F967A69',Z'1C8296E9',Z'2181C6DB',Z'238A1821',Z'3FA29A68',
     +Z'16554528',Z'3FA5B829',Z'1F8306EB',Z'28A699E4',Z'226E08A6',
     +Z'27A69A26',Z'00000FE5',Z'2685B6E9',Z'2079B829',Z'3FA689A3',
     +Z'17595528',Z'19819658',Z'217DD6DA',Z'238A08A2',Z'2CAA89A4',
     +Z'3FC30BED',Z'2179C6E9',Z'29A689E4'/
      DATA (IY16(I),I=1,50)/
     +Z'1D8239A8',Z'00FDB6DC',Z'1B8296EB',Z'1E8299A1',Z'00FDB6DC',
     +Z'289E4869',Z'239A8A69',Z'1B6DC760',Z'3FC2179C',Z'1E71B6EB',
     +Z'29A27921',Z'208E6A29',Z'00FDB71D',Z'1E8296EA',Z'00FDB6DC',
     +Z'1B6DD7EA',Z'299E479C',Z'1E8A6A29',Z'00000FDB',Z'227DD72B',
     +Z'29A689E5',Z'1D8239A8',Z'2685D6DB',Z'00000FF0',Z'2E75B6E9',
     +Z'1D6E0C30',Z'3FC2EAE0',Z'1F83052B',Z'1E71B6DD',Z'29A689A3',
     +Z'1B7A39A8',Z'0000003F',Z'227DC6EB',Z'28A69A25',Z'28961825',
     +Z'22968A69',Z'00FDB71F',Z'208266E8',Z'3F9A6820',Z'00FE56A2',
     +Z'18924627',Z'2871CA20',Z'0000003F',Z'1682A5A8',Z'1B69A82A',
     +Z'1A65969B',Z'208A179C',Z'248A075C',Z'249669A5',Z'3F9248E3'/
      DATA (IY16(I), I=51,108)/
     +Z'1B8206E3',Z'24923820',Z'0003F8E3',Z'1A8256A6',Z'2079E825',
     +Z'0003F861',Z'3F9A06A8',Z'1C6DB725',Z'1F8207DE',Z'2492381E',
     +Z'0003F8E3',Z'176185E9',Z'1D698596',Z'178299E3',Z'289A3759',
     +Z'28A29AAA',Z'00000FE9',Z'1E7DF7A3',Z'2492381E',Z'0003F8E3',
     +Z'1E7DF7A3',Z'2392481E',Z'00FE7963',Z'3F9A06A8',Z'1682A5A5',
     +Z'2059682A',Z'0003FAAA',Z'1682A5A5',Z'2059682A',Z'0003FAAA',
     +Z'2085D668',Z'269A08A2',Z'0000003F',Z'1A6175A5',Z'1A5E079C',
     +Z'1881F720',Z'207DE71A',Z'289A48A1',Z'26824860',Z'26922829',
     +Z'00FEAA68',Z'1A6175A6',Z'1A5E079C',Z'1881F720',Z'207DE71A',
     +Z'289A48A1',Z'26824860',Z'26922829',Z'00FEAA68',Z'2095D769',
     +Z'2652099D',Z'0000003F',Z'145155EB',Z'26A205D5',Z'1865E8A4',
     +Z'1E6585D7',Z'20A26922',Z'29A20A28'/
      DATA (IY17(I),I=1,50)/
     +Z'3FA29AAA',Z'218216E8',Z'20AA182A',Z'186E0AAA',Z'15620556',
     +Z'155986E0',Z'1B815620',Z'1A81B659',Z'196E06DA',Z'1A6A06D9',
     +Z'1D71B81B',Z'2075B820',Z'2075C6E0',Z'3F81D6E0',Z'1C8195E8',
     +Z'208E181E',Z'2A9E0AA7',Z'1582AAA0',Z'17560617',Z'185D8818',
     +Z'1C75C660',Z'1C75C660',Z'1D71D760',Z'2285E81D',Z'208A1822',
     +Z'208A285E',Z'228A08A1',Z'238228A1',Z'27A289E6',Z'238289E5',
     +Z'27A289E6',Z'288289E5',Z'3FA289E8',Z'2782A9E8',Z'20AAA82A',
     +Z'239A8A27',Z'1B7608A2',Z'155986DA',Z'1A6D8595',Z'228A075B',
     +Z'27A289A3',Z'0000003F',Z'23860826',Z'20863924',Z'1B6DC79F',
     +Z'248E179C',Z'00000FE4',Z'1D823765',Z'00000FE3',Z'218E6A2B'/
      DATA (IY17(I), I=51,103)/
     +Z'1D71C75E',Z'238A17DE',Z'1F8A3924',Z'00FD869D',Z'238E282A',
     +Z'1C75E862',Z'2281F75C',Z'1E8628E3',Z'1F75C71D',Z'00000FE0',
     +Z'1F71A667',Z'279E6921',Z'1C7E1926',Z'00FD965A',Z'1A9A66A6',
     +Z'00000FDA',Z'18924627',Z'0000003F',Z'20AA05A6',Z'00000FD6',
     +Z'2175D5E8',Z'1D8678E7',Z'0003F5DD',Z'2281E769',Z'2281E823',
     +Z'00FE0820',Z'1E8266E5',Z'2079D69D',Z'00FDD6DD',Z'2281E769',
     +Z'2281E823',Z'00FE0820',Z'228256A5',Z'208A39A3',Z'00FE3963',
     +Z'1B6DC723',Z'0003F7DD',Z'239248E3',Z'00000FE3',Z'238E4923',
     +Z'0003F9E5',Z'00FE56A5',Z'2179C6A4',Z'0003F963',Z'2179C6A3',
     +Z'0003F963',Z'00FE0826',Z'20824726',Z'00000FE0',Z'2281E7A6',
     +Z'00000FE2',Z'1E823765',Z'3F89E822'/
+SELF, IF=SUN,SGI,IBMRT,DECS,MSDOS,LINUX,CVY,WINNT, IF=-F90, IF=-QFEPC, IF=-QFMSOFT.
      DATA (IX11(I),I=1,50)/
     +X'1969C7D6',X'217DC699',X'269E79A4',X'00FDF864',X'2185E716',
     +X'0000003F',X'1C6DA696',X'2696489E',X'27663966',X'0000003F',
     +X'238266D6',X'269E79A5',X'1A6DE864',X'00000FD9',X'3FA198D6',
     +X'0003F8E3',X'1B69B956',X'279A485E',X'1E8649A7',X'00FD969B',
     +X'208A5996',X'1B69A6DD',X'2692181D',X'219269E7',X'3F69B760',
     +X'19FDD9D6',X'00000FE7',X'1A69B796',X'2692175B',X'229669E7',
     +X'1965A6DE',X'258DF71A',X'1E8A59A6',X'0000003F',X'208E5996',
     +X'1965A71F',X'2381F71A',X'239669A5',X'3F69B7A0',X'20FD8817',
     +X'3F95BFE8',X'19FD9655',X'279E6962',X'19FE2966',X'279E6962',
     +X'3F662966',X'23967A16',X'1969B75F',X'1F75B699',X'3FA27963'/
      DATA (IX11(I), I=51,108)/
     +X'19FD9655',X'279A58E0',X'208E59A7',X'00000FD9',X'1AFDA696',
     +X'3F89AFE7',X'0003F9DA',X'1AFDA696',X'3F89AFE7',X'23967A16',
     +X'1969B75F',X'1F75B699',X'28A27963',X'00FE88FF',X'27FD9655',
     +X'3F9D9FE7',X'00FE081C',X'228E4918',X'1A6DC7A0',X'00000FDA',
     +X'27FD9655',X'3F9DEFD9',X'1AFDA696',X'00000FE6',X'18FD8614',
     +X'3F828FE0',X'0003FA28',X'19FD9655',X'3F9E7FE7',X'1969C795',
     +X'1C699618',X'279A489E',X'249A7A28',X'0003F7A2',X'19FD9655',
     +X'279E6962',X'3F662966',X'1969C795',X'1C699618',X'279A489E',
     +X'249A7A28',X'2787F7A2',X'0000003F',X'19FD9655',X'279E6962',
     +X'3F662966',X'0003F9E0',X'1E8A59D6',X'1B69965B',X'279A58DD',
     +X'1B7A2967',X'00000FD9',X'19FE0818',X'00000FE7',X'1C699655',
     +X'279A485F',X'00000FE7',X'28FE0617'/
      DATA (IX12(I),I=1,50)/
     +X'00000FE0',X'20FDB594',X'3F960FDB',X'0003F96A',X'27FE7656',
     +X'00000FD9',X'3F820617',X'0003F828',X'19FD99D6',X'3F9D9FE7',
     +X'20FD8817',X'3F95BFE8',X'19FD9655',X'279E6962',X'19FE2966',
     +X'279E6962',X'3F662966',X'1AFDA696',X'00000FE6',X'20FD8817',
     +X'3FA18FE8',X'1AFDA696',X'3F89AFE7',X'0003F9DA',X'19FD99D6',
     +X'3F9D9FE7',X'27FD9655',X'3F9D9FE7',X'1969C795',X'1C699618',
     +X'279A489E',X'249A7A28',X'2377F7A2',X'0000003F',X'00FE081C',
     +X'27FD9655',X'3F9DEFD9',X'20FD8817',X'00000FE8',X'18FD8614',
     +X'3F828FE0',X'0003FA28',X'19FD9655',X'3F9E7FE7',X'1DFE7657',
     +X'3F9D9FE3',X'1969C795',X'1C699618',X'279A489E',X'249A7A28'/
      DATA (IX12(I), I=51,108)/
     +X'0003F7A2',X'27FD9655',X'3F9D9FE7',X'19FD9655',X'279E6962',
     +X'3F662966',X'3F660657',X'2767F9D9',X'0000003F',X'19FE0818',
     +X'00000FE7',X'1B699657',X'2081F79D',X'259A79FF',X'3F8218A3',
     +X'1EFE0816',X'1A65969B',X'2696279B',X'229669E7',X'00000FDE',
     +X'19FE7656',X'00000FE7',X'17FE0815',X'1C6DA658',X'2696485F',
     +X'00FE9A27',X'1969D656',X'217DC699',X'269E79A4',X'0003F9E3',
     +X'18FE0814',X'3FA18FE8',X'00FE081C',X'1A69E79A',X'268A279E',
     +X'3F7A28A6',X'22FDE796',X'26966FE2',X'1E8A59E7',X'1B69965B',
     +X'3F9E58DD',X'258DD6D9',X'229679E6',X'1A6596DE',X'0003F69B',
     +X'20FE081B',X'3F82181F',X'27FDA856',X'3FA1AFE0',X'0003F9D9',
     +X'3F628614',X'1C6DA697',X'2696489E',X'20824966',X'2181F83F',
     +X'00000FE0',X'2AA68A54',X'23967A6A'/
      DATA (IX13(I),I=1,50)/
     +X'1D7A0862',X'228E4FDC',X'1B75E7E0',X'175965D9',X'0003F5D8',
     +X'2181F81B',X'207E0FE0',X'0003F821',X'2181F81B',X'1F821FE0',
     +X'1F821860',X'0000003F',X'3FA18A14',X'1EFDD759',X'3F91DFDE',
     +X'0003F91D',X'23FE2899',X'3F8DCFE3',X'0003F8DC',X'3F6E56D8',
     +X'256FF95B',X'0000003F',X'1E7E0899',X'218607DE',X'1F7E0FDF',
     +X'218A2860',X'218A285D',X'3F81F7E0',X'1F82185F',X'2281F79E',
     +X'0000003F',X'22860799',X'1F7E0862',X'21860FE1',X'1F79E7E0',
     +X'1F79E7E3',X'3F821860',X'2181F7E1',X'1E8218A2',X'0000003F',
     +X'3F81748F',X'20C3F816',X'0000003F',X'1865C814',X'1F75B658',
     +X'27920FE0',X'23967A28',X'1F83F821',X'22860FDE',X'00FE27BF'/
      DATA (IX13(I), I=51,108)/
     +X'1C79F814',X'1961865B',X'20FE071A',X'279648A1',X'249A7A28',
     +X'00000FE0',X'1769E814',X'299A283F',X'2079A5FF',X'208A6A7F',
     +X'0000003F',X'26922814',X'26A29A68',X'2387F864',X'1F863924',
     +X'1F75C71D',X'1869C7FF',X'1C6985D7',X'1F83F81E',X'22860FDE',
     +X'00FE27BF',X'28A6AA93',X'208A49A7',X'165D869E',X'207D85D6',
     +X'1C7A0861',X'2379C6DB',X'2AAA99E5',X'0000003F',X'27FE7655',
     +X'00000FD9',X'1DFDA998',X'1A6DD79E',X'2485D6DA',X'228A3FE6',
     +X'259A6963',X'00000FE3',X'258E2815',X'2BAEAA67',X'23967A6A',
     +X'196DD7A2',X'16555597',X'1E75B657',X'00000FE0',X'1C71D7DC',
     +X'248E17DD',X'3F7E18E4',X'1E7BF75D',X'20FDF7FF',X'3F861FE0',
     +X'238FF8A2',X'0000003F',X'2491C71C',X'3F75DFDC',X'1F7FF79E',
     +X'21FE083F',X'3F8A2FE1',X'0003F8E3'/
      DATA (IX14(I),I=1,50)/
     +X'2095B81B',X'20FDD83F',X'3F7E0FE3',X'0003F860',X'206E581B',
     +X'20FE383F',X'3F860FDD',X'0003F7E0',X'1A99C81A',X'2083F824',
     +X'20FDA83F',X'3F920FDC',X'0003F9A0',X'3F9A9993',X'17FE3A23',
     +X'00000FE8',X'3F8A0798',X'20FE581B',X'00000FE0',X'3F697693',
     +X'18FDD61D',X'00000FE9',X'3F8A0798',X'20FE581B',X'00000FE0',
     +X'2181F81B',X'00FDF821',X'2181F81B',X'00000FE0',X'207E085B',
     +X'3F7E0861',X'00FD7A55',X'1E822919',X'2281E75D',X'00000FE4',
     +X'2281E719',X'1E8228E3',X'00000FDC',X'00FE95D3',X'17FE0813',
     +X'00000FE9',X'17FE95D3',X'00000FE9',X'1BFE0818',X'3F6E5FE5',
     +X'1D75E81B',X'238E281E',X'0003F822',X'3F82079B',X'2385F75B'/
      DATA (IX14(I), I=51,108)/
     +X'3F8DD8A3',X'2385F75B',X'2183F863',X'1D7E18E3',X'0000003F',
     +X'21FE185B',X'0003F91C',X'207DD79B',X'1F8228E2',X'3F89EFDD',
     +X'1D7A089B',X'238A079D',X'3F75E822',X'1DFDF8DB',X'00000FE3',
     +X'1F75D7DB',X'1F8638E1',X'1F75D7FF',X'3F8638E1',X'1E8228DB',
     +X'238A079D',X'3F7A08A3',X'26FE6997',X'1B75F8A4',X'1F75B69A',
     +X'00FE6922',X'1AFDA696',X'258E179C',X'218E59A6',X'00FDA71E',
     +X'1F8A4997',X'1B69A6DD',X'269227DD',X'0000003F',X'26FE6997',
     +X'1B75F8A4',X'1F75B69A',X'00FE6922',X'259A6697',X'1B75F8A4',
     +X'1F75B69A',X'00FE6922',X'2086395B',X'3F91DFE0',X'24966997',
     +X'26FDD7E2',X'1B75F8A4',X'1F75B69A',X'00FE6922',X'1BFDB6D7',
     +X'2696381E',X'00000FE6',X'208607DC',X'3F820FDF',X'218A181B',
     +X'20861FE0',X'0003F71E',X'25FDB6D7'/
      DATA (IX15(I),I=1,50)/
     +X'3F99FFDB',X'00FE081C',X'15FD5551',X'207DD698',X'258E0FE0',
     +X'3FAEBAA8',X'1BFDB6D7',X'2696381E',X'00000FE6',X'1A6DD7D7',
     +X'227DD6DA',X'269E79A4',X'00FDF8A4',X'1AFDA696',X'258E179C',
     +X'218E59A6',X'00FDA71E',X'26FE6997',X'1B75F8A4',X'1F75B69A',
     +X'00FE6922',X'1DFDD759',X'3F96281E',X'1F8A5998',X'2379C6DC',
     +X'229669A5',X'00FDB71F',X'2386081B',X'3F91DFE5',X'1E71B6D7',
     +X'26FE68E1',X'00000FE6',X'26FE0698',X'00000FE0',X'20FDC615',
     +X'3F920FDC',X'0003F928',X'26FE66D8',X'00000FDB',X'26FE0698',
     +X'1969C7A0',X'0000003F',X'1BFDB998',X'3F99BFE6',X'1A6DD7D6',
     +X'1E71A659',X'289E58E0',X'238A17FF',X'3FA279A5',X'1D7E18D7'/
      DATA (IX15(I), I=51,108)/
     +X'3F65A6DC',X'269E7963',X'20FE08E5',X'24965922',X'1C75F863',
     +X'00000FDB',X'1D71A617',X'2086181F',X'209A7A3F',X'0003F75E',
     +X'1B75F897',X'1E71B69A',X'259648A0',X'1F7E08A4',X'3F9A48A0',
     +X'1F8A4958',X'3F85E75D',X'1C6DB761',X'3F96385E',X'1F7E0898',
     +X'26FE68E0',X'1B6DC7E2',X'228A179C',X'00FDE7E1',X'1C6985D6',
     +X'3F69C75D',X'248A079C',X'3F8A59A6',X'1B657595',X'1C6DB71C',
     +X'248E17DD',X'239669A5',X'23860821',X'0003FA25',X'1D75E81A',
     +X'3F8E281E',X'27FD9757',X'1D7E3966',X'1F79CFDC',X'3F9238A1',
     +X'1E75B658',X'3F6A0FE6',X'1CFD7756',X'217DD6DB',X'259FF963',
     +X'299E5924',X'00000FEA',X'1B71D697',X'259A7FDA',X'3F69D823',
     +X'1F7E0898',X'23FE68E0',X'1F75D7A0',X'1E8BF922',X'2175B6DC',
     +X'3F7A08A2',X'1B71E818',X'217DD71B'/
      DATA (IX16(I),I=1,50)/
     +X'259A6963',X'00FE08A4',X'23FDA795',X'17FE6964',X'00FE9719',
     +X'1D71B6D7',X'2696385F',X'208A4966',X'3F5DB71E',X'1B75FA57',
     +X'1E71B69A',X'259648A0',X'00FE18E4',X'18FDE856',X'00FE875A',
     +X'1C6985D6',X'1D6DB75D',X'279A489F',X'00000FE7',X'1865B755',
     +X'1F71A658',X'28A27962',X'1E822926',X'00000FDB',X'2375B657',
     +X'27A3F9E5',X'3F6196E5',X'15FDC914',X'1B6DA616',X'1F75B69A',
     +X'29A26922',X'0000003F',X'1761A714',X'1D6D9617',X'207E0FDF',
     +X'289E58E1',X'00FE69E8',X'1BFE0818',X'3F95BFE5',X'00FE081E',
     +X'209D9819',X'2066783F',X'0000003F',X'22FDF7D9',X'24925FE2',
     +X'1C7A3965',X'3F96475C',X'2596475C',X'1C75F8A4',X'3F71D75C'/
      DATA (IX16(I), I=51,108)/
     +X'21FE081E',X'21820FE1',X'0003F821',X'23FDE81B',X'3F91DFE1',
     +X'0003F91D',X'3F6E56D8',X'2386079C',X'21860823',X'21820FE3',
     +X'0003F821',X'279E6997',X'20862926',X'23FDD79F',X'1E7E0862',
     +X'1A65969C',X'00000FDA',X'2186081E',X'21820FE0',X'0003F821',
     +X'2186081E',X'20821FE0',X'00FE0861',X'3F95B958',X'1FFDE79B',
     +X'3F8DEFDF',X'0003F8DE',X'22FE185B',X'3F89DFE2',X'0003F89D',
     +X'3F95B958',X'256FF95B',X'0000003F',X'1E79F85A',X'1E7FF860',
     +X'1EFE087F',X'1E82185F',X'1E7E1860',X'1EFE183F',X'1E821FDF',
     +X'00FE17DE',X'228A17DB',X'2287F7E0',X'22FE07FF',X'2281F7E1',
     +X'2285F7E0',X'22FDF83F',X'2281FFE1',X'00FDF862',X'3F81A5D5',
     +X'20A7F819',X'0000003F',X'217DE795',X'1657F8A2',X'1B69A658',
     +X'269A58DD',X'3FAEAA27',X'1E7FFAD5'/
      DATA (IX17(I),I=1,50)/
     +X'3F86285F',X'20FE0818',X'3F860FDF',X'1F83F85F',X'1C7FF71E',
     +X'248A183F',X'20FE487F',X'1EFD869C',X'2483F61A',X'268BFA26',
     +X'1D7A0FE8',X'1D7A0FDD',X'238E283F',X'3F8E283F',X'20FE0818',
     +X'3F820FE0',X'2183F7E0',X'20FE17FF',X'2183F79F',X'2281EFE2',
     +X'1B71E83F',X'2592283F',X'2281E73F',X'1C7A0FE4',X'3F69965A',
     +X'279A48A0',X'1E73F9A7',X'20FE48A0',X'1969B75E',X'20FDA618',
     +X'279A58E2',X'1BFE6A28',X'3F96381D',X'20FDF818',X'3F85FFE1',
     +X'28A268E0',X'27A27967',X'218E48E5',X'1B75C75F',X'196D9619',
     +X'2075A618',X'0000003F',X'218A391A',X'1D71C760',X'1E821860',
     +X'2385F75D',X'00000FE4',X'23FE375B',X'00000FDD',X'29AABAD7'/
      DATA (IX17(I), I=51,103)/
     +X'1A761926',X'1A6175D8',X'299A485D',X'00FEBAEA',X'24967A16',
     +X'1C79F862',X'1961865B',X'217DE71B',X'289E5922',X'00000FE8',
     +X'1969C7D9',X'217DC699',X'269E79A4',X'00FDF864',X'2699A69A',
     +X'00000FDA',X'209D9819',X'0000003F',X'2681A81A',X'00000FE0',
     +X'1D61E818',X'288E581B',X'0003F822',X'239A3897',X'23963FE2',
     +X'00FE56BF',X'1DFE081B',X'3F8E281E',X'00FE281E',X'1D69D797',
     +X'1D6DDFDE',X'00FE66FF',X'1DFE081B',X'3F8E281E',X'00FE281E',
     +X'2182085E',X'0003F821',X'2186081E',X'00000FE0',X'2182085E',
     +X'0003F821',X'00FDC91B',X'1F7E089D',X'0003F8A0',X'2186079C',
     +X'0003F7A0',X'00FE471A',X'1CFE081A',X'00000FE4',X'1CFE471A',
     +X'00000FE4',X'1DFE081B',X'3F763FE3'/
      DATA (IY11(I),I=1,50)/
     +X'1D61552A',X'29A68960',X'18760968',X'00FD4515',X'2951762A',
     +X'0000003F',X'1559866A',X'18595514',X'29A5F71A',X'0000003F',
     +X'1C71452A',X'268E179D',X'27A29A68',X'00000FE5',X'208A252A',
     +X'0003FA54',X'1C75452A',X'2179C6DB',X'29A689A3',X'00FE59E8',
     +X'145155EA',X'2689D615',X'26A29A68',X'1C75F8A3',X'3F89F75C',
     +X'1482952A',X'00000FD4',X'195D552A',X'2079D71B',X'29A27962',
     +X'22967A29',X'1B71D7A0',X'145155D9',X'0000003F',X'2181E6EA',
     +X'1A6DE821',X'15514557',X'289606D7',X'3F9A8A69',X'14829529',
     +X'3F8A2829',X'1482952A',X'1A616554',X'1E81E75C',X'258A07DE',
     +X'3FA69A27',X'1455766B',X'1C657554',X'29A26921',X'3F926A29'/
      DATA (IY11(I), I=51,108)/
     +X'1482952A',X'1C657554',X'29A26921',X'00000FE9',X'14829529',
     +X'2079E814',X'0003FA69',X'14829528',X'3F79E814',X'1455766B',
     +X'1C657554',X'29A26921',X'21926A29',X'00FE1860',X'1482952B',
     +X'3F79E829',X'00FE9524',X'289E4528',X'249E8A69',X'00000FE2',
     +X'1482952A',X'3FA5D822',X'29829527',X'00000FE9',X'1482952C',
     +X'20A54829',X'0003FA54',X'1482952B',X'3FA54829',X'195D552B',
     +X'289A485C',X'249A8A69',X'155D9721',X'0003F514',X'1482952A',
     +X'1B616554',X'3F7DF79D',X'195D552B',X'289A485C',X'249A8A69',
     +X'155D9721',X'2B960514',X'0000003F',X'1482952A',X'1A616554',
     +X'2079E75C',X'0003FA5E',X'145155EA',X'1C6D95D5',X'238607DD',
     +X'28A69A26',X'00000FE6',X'14829528',X'00000FD4',X'289A352B',
     +X'239A8A69',X'00000FD4',X'14829529'/
      DATA (IY12(I),I=1,50)/
     +X'00000FE9',X'1482952C',X'20A54829',X'0003FA54',X'1482952A',
     +X'00000FE9',X'20A5E529',X'0003F794',X'1482952A',X'3FA69814',
     +X'14829529',X'3F8A2829',X'1482952A',X'1A616554',X'1E81E75C',
     +X'258A07DE',X'3FA69A27',X'14829527',X'00000FD4',X'14829529',
     +X'3FA69829',X'14829529',X'2079E814',X'0003FA69',X'1482952A',
     +X'3FA69814',X'1482952B',X'3F79E829',X'195D552B',X'289A485C',
     +X'249A8A69',X'155D9721',X'1E7A0514',X'0000003F',X'00FE9524',
     +X'1482952A',X'3FA5D822',X'14829529',X'00000FE9',X'1482952C',
     +X'20A54829',X'0003FA54',X'1482952B',X'3FA54829',X'1E814529',
     +X'3FA6981E',X'195D552B',X'289A485C',X'249A8A69',X'155D9721'/
      DATA (IY12(I), I=51,108)/
     +X'0003F514',X'1482952B',X'3F514829',X'1482952A',X'1B616554',
     +X'3F7DF79D',X'20A5E529',X'29A60514',X'0000003F',X'14829528',
     +X'00000FD4',X'14557669',X'296D7554',X'14557660',X'3F6D7554',
     +X'1982952A',X'2281D6DA',X'228E4923',X'1969B760',X'00000FD9',
     +X'2982952A',X'00000FD4',X'1A82952B',X'2285F6DA',X'1F8628E3',
     +X'00FDA69B',X'1E8A9A6A',X'145155DA',X'2279A5D5',X'0003FA69',
     +X'2082962C',X'3FA69820',X'00FF0424',X'2279E6A6',X'228A69A2',
     +X'3F69A79E',X'1082D42A',X'1961782D',X'145155D8',X'1C6D95D5',
     +X'208A07DD',X'1F79C6D9',X'29A268A0',X'24966A29',X'0003F9A5',
     +X'27822525',X'3F9E8A68',X'1083042B',X'2075D830',X'0003F8E3',
     +X'3FA605EC',X'15598669',X'18595514',X'227DD71A',X'28A689E0',
     +X'00000FE7',X'124D246C',X'13450411'/
      DATA (IY13(I),I=1,50)/
     +X'2CA1C615',X'1851282E',X'2FB6BA24',X'2DBAFC30',X'0003FBEE',
     +X'1C75C6E5',X'29A2781B',X'0003F9E8',X'1C75C6E5',X'28A6881B',
     +X'2DB2AA27',X'0000003F',X'3FA605EC',X'10830427',X'20410830',
     +X'0003FC30',X'10830427',X'20410830',X'0003FC30',X'2085D668',
     +X'269A08A2',X'0000003F',X'14491427',X'1D6D9616',X'154D181F',
     +X'1E71A617',X'289A48A0',X'20BEDAE9',X'289E58E1',X'30BEEB2A',
     +X'0000003F',X'14491427',X'1D6D9616',X'154D181F',X'1E71A617',
     +X'289A48A0',X'20BEDAE9',X'289E58E1',X'30BEEB2A',X'0000003F',
     +X'209DB6F0',X'29220A5C',X'0000003F',X'2179A5AC',X'259A6963',
     +X'1E696823',X'269A58E1',X'278E08E5',X'2A9E382A',X'00FEAAA0'/
      DATA (IY13(I), I=51,108)/
     +X'165D972C',X'207595D6',X'1C82A962',X'175965D9',X'258A0759',
     +X'00000FEA',X'2075856C',X'20758560',X'2BA23820',X'2BA23820',
     +X'0000003F',X'269A58AC',X'1E7E18E5',X'1D7E07DE',X'1659765B',
     +X'1F75B657',X'1F79E7E0',X'269A58E1',X'278A08A5',X'2A9E282A',
     +X'00FEAAA0',X'1B6DC76D',X'289A379C',X'259E8A69',X'1B720863',
     +X'155155D9',X'267DC657',X'27A29A68',X'0000003F',X'1982766B',
     +X'00000FE7',X'19826668',X'1C75D71A',X'1A69965A',X'258E2819',
     +X'228E59A6',X'00000FE2',X'2592382B',X'1F863925',X'1C6DB71D',
     +X'259648DD',X'1D7E18E4',X'1D71B6DC',X'00000FE0',X'217DD724',
     +X'218E4923',X'2071C75F',X'227A085F',X'1D823760',X'208DD823',
     +X'217E089E',X'0000003F',X'1C924724',X'208DD81C',X'237608DD',
     +X'1D823760',X'208DD823',X'0003F8DD'/
      DATA (IY14(I),I=1,50)/
     +X'1A8E36A5',X'1D822760',X'208A0822',X'0003F8A0',X'2675D9A5',
     +X'2381E8E0',X'207A081E',X'0003F7A0',X'1E7A56A6',X'1A8206A5',
     +X'2081E820',X'20960825',X'0003F7A0',X'208A07AD',X'2082581B',
     +X'00000FE0',X'206976A8',X'1881D61D',X'00000FE9',X'208A07AD',
     +X'2082581B',X'00000FE0',X'209A99A8',X'17823A23',X'00000FE8',
     +X'155155A5',X'00FDA657',X'28A689E5',X'00000FE7',X'27A29A25',
     +X'3FB6CAA8',X'00FF042B',X'19552427',X'2EAE789E',X'00000FF0',
     +X'19552427',X'2EAE789E',X'00000FF0',X'00FE082D',X'208295ED',
     +X'00000FE0',X'2381D76D',X'00000FE3',X'1D8266A8',X'3F8DD823',
     +X'2179C6E5',X'1E863923',X'0003F6DC',X'3F91B765',X'1C6DB725'/
      DATA (IY14(I), I=51,108)/
     +X'3F92481E',X'1C6DB725',X'1F7E07DE',X'239248E0',X'0000003F',
     +X'1B8246E5',X'0003F861',X'1E79F6E5',X'2492385F',X'3F6DB823',
     +X'1E71B6E5',X'218E48E1',X'3F85F79F',X'1B8246E5',X'00000FDB',
     +X'1F79C6E5',X'1B6DC79F',X'248E07E0',X'3F7E08E4',X'208607A5',
     +X'1E71B71E',X'3F9248E1',X'1E8296EA',X'1E71B6DC',X'29A268E1',
     +X'00FE6A29',X'1E829529',X'1E71B6DC',X'29A268E1',X'00FE6A29',
     +X'1B6DC7A9',X'268E179C',X'26A29A68',X'0000003F',X'1E82952A',
     +X'1E71B6DC',X'29A268E1',X'00FE6A29',X'1D7E1869',X'1E71B6DC',
     +X'29A268E1',X'00FE6A29',X'18554527',X'3F6DB829',X'2FBAB6EA',
     +X'1E82FC30',X'1E71B6DC',X'29A268E1',X'00FE6A29',X'1F82952A',
     +X'1F71B6DC',X'00000FE9',X'13515524',X'3FA5B814',X'13515525',
     +X'2FB1B814',X'0003FC30',X'1B829528'/
      DATA (IY15(I),I=1,50)/
     +X'3FA61825',X'00FE9524',X'1F8296EF',X'1F71B6DC',X'1B71F829',
     +X'3FA5F71B',X'1F8296EA',X'1F71B6DC',X'00000FE9',X'2179C6EA',
     +X'29A689A3',X'1E8639A8',X'00FDB6DC',X'1E8306E9',X'1E71B6DC',
     +X'29A268E1',X'00FE6A29',X'1E8306EA',X'1E71B6DC',X'29A268E1',
     +X'00FE6A29',X'218296E6',X'3F6DB71E',X'1B6DC7A9',X'2286079C',
     +X'29A26963',X'00FE6A29',X'29A25527',X'3F6DB829',X'29A256EA',
     +X'1B825A29',X'00000FE9',X'1B8296E8',X'00000FE9',X'1B8296EB',
     +X'20A5B829',X'0003FA5B',X'1B8296E9',X'00000FE9',X'1B8296E8',
     +X'30C2FB69',X'0000003F',X'1B8296E9',X'3FA6981B',X'2079C6EB',
     +X'29A689A3',X'1B7A2968',X'1E71B6E0',X'3FA69A26',X'1B5D552A'/
      DATA (IY15(I), I=51,108)/
     +X'20C2889E',X'1B656514',X'1D81D75C',X'2796281E',X'27A29A68',
     +X'00000FE4',X'1B6DC7AA',X'2992075C',X'2981E6E0',X'0003FC2D',
     +X'1E71B6E9',X'29A27921',X'208E6A29',X'155D96DD',X'3F5D5514',
     +X'1B6DC768',X'2086079C',X'289A48A1',X'3F9A8A69',X'17595527',
     +X'19819658',X'258E075B',X'2FB6BA67',X'00FEEC30',X'1B6DD7EA',
     +X'20A6279C',X'1B6DC7A2',X'3FC2581D',X'1B6DD7EA',X'289A379C',
     +X'23968A69',X'145586E0',X'1E6D8594',X'0003F8A0',X'289A26E5',
     +X'3F967A69',X'1C8296E9',X'2181C6DB',X'238A1821',X'3FA29A68',
     +X'16554528',X'3FA5B829',X'1F8306EB',X'28A699E4',X'226E08A6',
     +X'27A69A26',X'00000FE5',X'2685B6E9',X'2079B829',X'3FA689A3',
     +X'17595528',X'19819658',X'217DD6DA',X'238A08A2',X'2CAA89A4',
     +X'3FC30BED',X'2179C6E9',X'29A689E4'/
      DATA (IY16(I),I=1,50)/
     +X'1D8239A8',X'00FDB6DC',X'1B8296EB',X'1E8299A1',X'00FDB6DC',
     +X'289E4869',X'239A8A69',X'1B6DC760',X'3FC2179C',X'1E71B6EB',
     +X'29A27921',X'208E6A29',X'00FDB71D',X'1E8296EA',X'00FDB6DC',
     +X'1B6DD7EA',X'299E479C',X'1E8A6A29',X'00000FDB',X'227DD72B',
     +X'29A689E5',X'1D8239A8',X'2685D6DB',X'00000FF0',X'2E75B6E9',
     +X'1D6E0C30',X'3FC2EAE0',X'1F83052B',X'1E71B6DD',X'29A689A3',
     +X'1B7A39A8',X'0000003F',X'227DC6EB',X'28A69A25',X'28961825',
     +X'22968A69',X'00FDB71F',X'208266E8',X'3F9A6820',X'00FE56A2',
     +X'18924627',X'2871CA20',X'0000003F',X'1682A5A8',X'1B69A82A',
     +X'1A65969B',X'208A179C',X'248A075C',X'249669A5',X'3F9248E3'/
      DATA (IY16(I), I=51,108)/
     +X'1B8206E3',X'24923820',X'0003F8E3',X'1A8256A6',X'2079E825',
     +X'0003F861',X'3F9A06A8',X'1C6DB725',X'1F8207DE',X'2492381E',
     +X'0003F8E3',X'176185E9',X'1D698596',X'178299E3',X'289A3759',
     +X'28A29AAA',X'00000FE9',X'1E7DF7A3',X'2492381E',X'0003F8E3',
     +X'1E7DF7A3',X'2392481E',X'00FE7963',X'3F9A06A8',X'1682A5A5',
     +X'2059682A',X'0003FAAA',X'1682A5A5',X'2059682A',X'0003FAAA',
     +X'2085D668',X'269A08A2',X'0000003F',X'1A6175A5',X'1A5E079C',
     +X'1881F720',X'207DE71A',X'289A48A1',X'26824860',X'26922829',
     +X'00FEAA68',X'1A6175A6',X'1A5E079C',X'1881F720',X'207DE71A',
     +X'289A48A1',X'26824860',X'26922829',X'00FEAA68',X'2095D769',
     +X'2652099D',X'0000003F',X'145155EB',X'26A205D5',X'1865E8A4',
     +X'1E6585D7',X'20A26922',X'29A20A28'/
      DATA (IY17(I),I=1,50)/
     +X'3FA29AAA',X'218216E8',X'20AA182A',X'186E0AAA',X'15620556',
     +X'155986E0',X'1B815620',X'1A81B659',X'196E06DA',X'1A6A06D9',
     +X'1D71B81B',X'2075B820',X'2075C6E0',X'3F81D6E0',X'1C8195E8',
     +X'208E181E',X'2A9E0AA7',X'1582AAA0',X'17560617',X'185D8818',
     +X'1C75C660',X'1C75C660',X'1D71D760',X'2285E81D',X'208A1822',
     +X'208A285E',X'228A08A1',X'238228A1',X'27A289E6',X'238289E5',
     +X'27A289E6',X'288289E5',X'3FA289E8',X'2782A9E8',X'20AAA82A',
     +X'239A8A27',X'1B7608A2',X'155986DA',X'1A6D8595',X'228A075B',
     +X'27A289A3',X'0000003F',X'23860826',X'20863924',X'1B6DC79F',
     +X'248E179C',X'00000FE4',X'1D823765',X'00000FE3',X'218E6A2B'/
      DATA (IY17(I), I=51,103)/
     +X'1D71C75E',X'238A17DE',X'1F8A3924',X'00FD869D',X'238E282A',
     +X'1C75E862',X'2281F75C',X'1E8628E3',X'1F75C71D',X'00000FE0',
     +X'1F71A667',X'279E6921',X'1C7E1926',X'00FD965A',X'1A9A66A6',
     +X'00000FDA',X'18924627',X'0000003F',X'20AA05A6',X'00000FD6',
     +X'2175D5E8',X'1D8678E7',X'0003F5DD',X'2281E769',X'2281E823',
     +X'00FE0820',X'1E8266E5',X'2079D69D',X'00FDD6DD',X'2281E769',
     +X'2281E823',X'00FE0820',X'228256A5',X'208A39A3',X'00FE3963',
     +X'1B6DC723',X'0003F7DD',X'239248E3',X'00000FE3',X'238E4923',
     +X'0003F9E5',X'00FE56A5',X'2179C6A4',X'0003F963',X'2179C6A3',
     +X'0003F963',X'00FE0826',X'20824726',X'00000FE0',X'2281E7A6',
     +X'00000FE2',X'1E823765',X'3F89E822'/
+SELF, IF=SUN,SGI,IBMRT,DECS,MSDOS,LINUX,CVY,WINNT.
      DATA ISTART/
     +  1,  5,  7, 11, 15, 17, 21, 26, 28, 35, 40, 42, 47, 51, 55,
     + 58, 60, 65, 67, 68, 71, 73, 75, 78, 80, 85, 88, 94, 98,103,
     +105,108,110,113,115,117,119,121,126,128,130,133,135,137,143,
     +144,146,148,151,153,155,160,162,165,168,170,174,179,181,185,
     +189,191,192,195,204,206,209,210,215,222,225,229,230,233,236,
     +239,248,257,260,267,273,278,288,296,298,304,311,319,325,329,
     +333,338,341,344,347,350,352,354,356,357,360,363,364,366,368,
     +370,373,374,376,380,382,385,388,390,394,397,401,405,409,413,
     +417,419,424,427,429,432,434,435,439,442,446,450,454,456,460,
     +462,465,467,470,472,475,477,482,489,493,498,502,507,511,517,
     +519,523,525,530,533,539,543,546,550,554,556,560,565,568,573,
     +578,580,581,584,591,594,597,598,602,608,611,614,615,618,621,
     +624,632,640,643,650,663,682,691,696,698,703,709,713,715,717,
     +719,722,725,728,731,734,736,738,740,741,743,745,746,748,750/
*
      DATA NBIT,NBITCH,NBITMX/32,8,30/
+SELF, IF=CVX.
      DATA IX11/
     +'217DC6991969C7D6'X,'00FDF864269E79A4'X,'0000003F2185E716'X,
     +'2696489E1C6DA696'X,'0000003F27663966'X,'269E79A5238266D6'X,
     +'00000FD91A6DE864'X,'0003F8E33FA198D6'X,'279A485E1B69B956'X,
     +'00FD969B1E8649A7'X,'1B69A6DD208A5996'X,'219269E72692181D'X,
     +'000000003F69B760'X,'00000FE719FDD9D6'X,'2692175B1A69B796'X,
     +'1965A6DE229669E7'X,'1E8A59A6258DF71A'X,'000000000000003F'X,
     +'1965A71F208E5996'X,'239669A52381F71A'X,'000000003F69B7A0'X,
     +'3F95BFE820FD8817'X,'279E696219FD9655'X,'279E696219FE2966'X,
     +'000000003F662966'X,'1969B75F23967A16'X,'3FA279631F75B699'X,
     +'279A58E019FD9655'X,'00000FD9208E59A7'X,'3F89AFE71AFDA696'X,
     +'000000000003F9DA'X,'3F89AFE71AFDA696'X,'1969B75F23967A16'X,
     +'28A279631F75B699'X,'0000000000FE88FF'X,'3F9D9FE727FD9655'X,
     +'0000000000FE081C'X,'1A6DC7A0228E4918'X,'0000000000000FDA'X,
     +'3F9DEFD927FD9655'X,'00000FE61AFDA696'X,'3F828FE018FD8614'X,
     +'000000000003FA28'X,'3F9E7FE719FD9655'X,'1C6996181969C795'X,
     +'249A7A28279A489E'X,'000000000003F7A2'X,'279E696219FD9655'X,
     +'000000003F662966'X,'1C6996181969C795'X,'249A7A28279A489E'X,
     +'0000003F2787F7A2'X,'279E696219FD9655'X,'0003F9E03F662966'X/
      DATA IX12/
     +'1B69965B1E8A59D6'X,'1B7A2967279A58DD'X,'0000000000000FD9'X,
     +'00000FE719FE0818'X,'279A485F1C699655'X,'0000000000000FE7'X,
     +'00000FE028FE0617'X,'3F960FDB20FDB594'X,'000000000003F96A'X,
     +'00000FD927FE7656'X,'0003F8283F820617'X,'3F9D9FE719FD99D6'X,
     +'3F95BFE820FD8817'X,'279E696219FD9655'X,'279E696219FE2966'X,
     +'000000003F662966'X,'00000FE61AFDA696'X,'3FA18FE820FD8817'X,
     +'3F89AFE71AFDA696'X,'000000000003F9DA'X,'3F9D9FE719FD99D6'X,
     +'3F9D9FE727FD9655'X,'1C6996181969C795'X,'249A7A28279A489E'X,
     +'0000003F2377F7A2'X,'0000000000FE081C'X,'3F9DEFD927FD9655'X,
     +'00000FE820FD8817'X,'3F828FE018FD8614'X,'000000000003FA28'X,
     +'3F9E7FE719FD9655'X,'3F9D9FE31DFE7657'X,'1C6996181969C795'X,
     +'249A7A28279A489E'X,'000000000003F7A2'X,'3F9D9FE727FD9655'X,
     +'279E696219FD9655'X,'000000003F662966'X,'2767F9D93F660657'X,
     +'000000000000003F'X,'00000FE719FE0818'X,'2081F79D1B699657'X,
     +'3F8218A3259A79FF'X,'1A65969B1EFE0816'X,'229669E72696279B'X,
     +'0000000000000FDE'X,'00000FE719FE7656'X,'1C6DA65817FE0815'X,
     +'00FE9A272696485F'X,'217DC6991969D656'X,'0003F9E3269E79A4'X,
     +'3FA18FE818FE0814'X,'0000000000FE081C'X,'268A279E1A69E79A'X/
      DATA IX13/
     +'000000003F7A28A6'X,'26966FE222FDE796'X,'1B69965B1E8A59E7'X,
     +'258DD6D93F9E58DD'X,'1A6596DE229679E6'X,'000000000003F69B'X,
     +'3F82181F20FE081B'X,'3FA1AFE027FDA856'X,'000000000003F9D9'X,
     +'000000003F628614'X,'2696489E1C6DA697'X,'2181F83F20824966'X,
     +'0000000000000FE0'X,'23967A6A2AA68A54'X,'228E4FDC1D7A0862'X,
     +'175965D91B75E7E0'X,'000000000003F5D8'X,'207E0FE02181F81B'X,
     +'000000000003F821'X,'1F821FE02181F81B'X,'0000003F1F821860'X,
     +'000000003FA18A14'X,'3F91DFDE1EFDD759'X,'000000000003F91D'X,
     +'3F8DCFE323FE2899'X,'000000000003F8DC'X,'256FF95B3F6E56D8'X,
     +'000000000000003F'X,'218607DE1E7E0899'X,'218A28601F7E0FDF'X,
     +'3F81F7E0218A285D'X,'2281F79E1F82185F'X,'000000000000003F'X,
     +'1F7E086222860799'X,'1F79E7E021860FE1'X,'3F8218601F79E7E3'X,
     +'1E8218A22181F7E1'X,'000000000000003F'X,'20C3F8163F81748F'X,
     +'000000000000003F'X,'1F75B6581865C814'X,'23967A2827920FE0'X,
     +'22860FDE1F83F821'X,'0000000000FE27BF'X,'1961865B1C79F814'X,
     +'279648A120FE071A'X,'00000FE0249A7A28'X,'299A283F1769E814'X,
     +'208A6A7F2079A5FF'X,'000000000000003F'X,'26A29A6826922814'X,
     +'1F8639242387F864'X,'1869C7FF1F75C71D'X,'1F83F81E1C6985D7'X/
      DATA IX14/
     +'00FE27BF22860FDE'X,'208A49A728A6AA93'X,'207D85D6165D869E'X,
     +'2379C6DB1C7A0861'X,'0000003F2AAA99E5'X,'00000FD927FE7655'X,
     +'1A6DD79E1DFDA998'X,'228A3FE62485D6DA'X,'00000FE3259A6963'X,
     +'2BAEAA67258E2815'X,'196DD7A223967A6A'X,'1E75B65716555597'X,
     +'0000000000000FE0'X,'248E17DD1C71D7DC'X,'1E7BF75D3F7E18E4'X,
     +'3F861FE020FDF7FF'X,'0000003F238FF8A2'X,'3F75DFDC2491C71C'X,
     +'21FE083F1F7FF79E'X,'0003F8E33F8A2FE1'X,'20FDD83F2095B81B'X,
     +'0003F8603F7E0FE3'X,'20FE383F206E581B'X,'0003F7E03F860FDD'X,
     +'2083F8241A99C81A'X,'3F920FDC20FDA83F'X,'000000000003F9A0'X,
     +'17FE3A233F9A9993'X,'0000000000000FE8'X,'20FE581B3F8A0798'X,
     +'0000000000000FE0'X,'18FDD61D3F697693'X,'0000000000000FE9'X,
     +'20FE581B3F8A0798'X,'0000000000000FE0'X,'00FDF8212181F81B'X,
     +'00000FE02181F81B'X,'3F7E0861207E085B'X,'0000000000FD7A55'X,
     +'2281E75D1E822919'X,'0000000000000FE4'X,'1E8228E32281E719'X,
     +'0000000000000FDC'X,'0000000000FE95D3'X,'00000FE917FE0813'X,
     +'00000FE917FE95D3'X,'3F6E5FE51BFE0818'X,'238E281E1D75E81B'X,
     +'000000000003F822'X,'000000003F82079B'X,'3F8DD8A32385F75B'X,
     +'2183F8632385F75B'X,'0000003F1D7E18E3'X,'0003F91C21FE185B'X/
      DATA IX15/
     +'1F8228E2207DD79B'X,'000000003F89EFDD'X,'238A079D1D7A089B'X,
     +'000000003F75E822'X,'00000FE31DFDF8DB'X,'1F8638E11F75D7DB'X,
     +'3F8638E11F75D7FF'X,'238A079D1E8228DB'X,'000000003F7A08A3'X,
     +'1B75F8A426FE6997'X,'00FE69221F75B69A'X,'258E179C1AFDA696'X,
     +'00FDA71E218E59A6'X,'1B69A6DD1F8A4997'X,'0000003F269227DD'X,
     +'1B75F8A426FE6997'X,'00FE69221F75B69A'X,'1B75F8A4259A6697'X,
     +'00FE69221F75B69A'X,'3F91DFE02086395B'X,'26FDD7E224966997'X,
     +'1F75B69A1B75F8A4'X,'0000000000FE6922'X,'2696381E1BFDB6D7'X,
     +'0000000000000FE6'X,'3F820FDF208607DC'X,'20861FE0218A181B'X,
     +'000000000003F71E'X,'3F99FFDB25FDB6D7'X,'0000000000FE081C'X,
     +'207DD69815FD5551'X,'3FAEBAA8258E0FE0'X,'2696381E1BFDB6D7'X,
     +'0000000000000FE6'X,'227DD6DA1A6DD7D7'X,'00FDF8A4269E79A4'X,
     +'258E179C1AFDA696'X,'00FDA71E218E59A6'X,'1B75F8A426FE6997'X,
     +'00FE69221F75B69A'X,'3F96281E1DFDD759'X,'2379C6DC1F8A5998'X,
     +'00FDB71F229669A5'X,'3F91DFE52386081B'X,'26FE68E11E71B6D7'X,
     +'0000000000000FE6'X,'00000FE026FE0698'X,'3F920FDC20FDC615'X,
     +'000000000003F928'X,'00000FDB26FE66D8'X,'1969C7A026FE0698'X,
     +'000000000000003F'X,'3F99BFE61BFDB998'X,'1E71A6591A6DD7D6'X/
      DATA IX16/
     +'238A17FF289E58E0'X,'000000003FA279A5'X,'3F65A6DC1D7E18D7'X,
     +'20FE08E5269E7963'X,'1C75F86324965922'X,'0000000000000FDB'X,
     +'2086181F1D71A617'X,'0003F75E209A7A3F'X,'1E71B69A1B75F897'X,
     +'1F7E08A4259648A0'X,'000000003F9A48A0'X,'3F85E75D1F8A4958'X,
     +'3F96385E1C6DB761'X,'26FE68E01F7E0898'X,'228A179C1B6DC7E2'X,
     +'0000000000FDE7E1'X,'3F69C75D1C6985D6'X,'3F8A59A6248A079C'X,
     +'1C6DB71C1B657595'X,'239669A5248E17DD'X,'0003FA2523860821'X,
     +'3F8E281E1D75E81A'X,'1D7E396627FD9757'X,'3F9238A11F79CFDC'X,
     +'3F6A0FE61E75B658'X,'217DD6DB1CFD7756'X,'299E5924259FF963'X,
     +'0000000000000FEA'X,'259A7FDA1B71D697'X,'000000003F69D823'X,
     +'23FE68E01F7E0898'X,'1E8BF9221F75D7A0'X,'3F7A08A22175B6DC'X,
     +'217DD71B1B71E818'X,'00FE08A4259A6963'X,'17FE696423FDA795'X,
     +'0000000000FE9719'X,'2696385F1D71B6D7'X,'3F5DB71E208A4966'X,
     +'1E71B69A1B75FA57'X,'00FE18E4259648A0'X,'00FE875A18FDE856'X,
     +'1D6DB75D1C6985D6'X,'00000FE7279A489F'X,'1F71A6581865B755'X,
     +'1E82292628A27962'X,'0000000000000FDB'X,'27A3F9E52375B657'X,
     +'000000003F6196E5'X,'1B6DA61615FDC914'X,'29A269221F75B69A'X,
     +'000000000000003F'X,'1D6D96171761A714'X,'289E58E1207E0FDF'X/
      DATA IX17/
     +'0000000000FE69E8'X,'3F95BFE51BFE0818'X,'0000000000FE081E'X,
     +'2066783F209D9819'X,'000000000000003F'X,'24925FE222FDF7D9'X,
     +'3F96475C1C7A3965'X,'1C75F8A42596475C'X,'000000003F71D75C'X,
     +'21820FE121FE081E'X,'000000000003F821'X,'3F91DFE123FDE81B'X,
     +'000000000003F91D'X,'000000003F6E56D8'X,'218608232386079C'X,
     +'0003F82121820FE3'X,'20862926279E6997'X,'1E7E086223FDD79F'X,
     +'00000FDA1A65969C'X,'21820FE02186081E'X,'000000000003F821'X,
     +'20821FE02186081E'X,'0000000000FE0861'X,'000000003F95B958'X,
     +'3F8DEFDF1FFDE79B'X,'000000000003F8DE'X,'3F89DFE222FE185B'X,
     +'000000000003F89D'X,'256FF95B3F95B958'X,'000000000000003F'X,
     +'1E7FF8601E79F85A'X,'1E82185F1EFE087F'X,'1EFE183F1E7E1860'X,
     +'00FE17DE1E821FDF'X,'2287F7E0228A17DB'X,'2281F7E122FE07FF'X,
     +'22FDF83F2285F7E0'X,'00FDF8622281FFE1'X,'20A7F8193F81A5D5'X,
     +'000000000000003F'X,'1657F8A2217DE795'X,'269A58DD1B69A658'X,
     +'1E7FFAD53FAEAA27'X,'000000003F86285F'X,'3F860FDF20FE0818'X,
     +'1C7FF71E1F83F85F'X,'20FE487F248A183F'X,'2483F61A1EFD869C'X,
     +'1D7A0FE8268BFA26'X,'238E283F1D7A0FDD'X,'000000003F8E283F'X,
     +'3F820FE020FE0818'X,'20FE17FF2183F7E0'X,'2281EFE22183F79F'X/
      DATA IX18/
     +'2592283F1B71E83F'X,'1C7A0FE42281E73F'X,'279A48A03F69965A'X,
     +'20FE48A01E73F9A7'X,'20FDA6181969B75E'X,'1BFE6A28279A58E2'X,
     +'000000003F96381D'X,'3F85FFE120FDF818'X,'27A2796728A268E0'X,
     +'1B75C75F218E48E5'X,'2075A618196D9619'X,'000000000000003F'X,
     +'1D71C760218A391A'X,'2385F75D1E821860'X,'0000000000000FE4'X,
     +'00000FDD23FE375B'X,'1A76192629AABAD7'X,'299A485D1A6175D8'X,
     +'0000000000FEBAEA'X,'1C79F86224967A16'X,'217DE71B1961865B'X,
     +'00000FE8289E5922'X,'217DC6991969C7D9'X,'00FDF864269E79A4'X,
     +'00000FDA2699A69A'X,'0000003F209D9819'X,'00000FE02681A81A'X,
     +'288E581B1D61E818'X,'000000000003F822'X,'23963FE2239A3897'X,
     +'0000000000FE56BF'X,'3F8E281E1DFE081B'X,'0000000000FE281E'X,
     +'1D6DDFDE1D69D797'X,'0000000000FE66FF'X,'3F8E281E1DFE081B'X,
     +'0000000000FE281E'X,'0003F8212182085E'X,'00000FE02186081E'X,
     +'0003F8212182085E'X,'0000000000FDC91B'X,'0003F8A01F7E089D'X,
     +'0003F7A02186079C'X,'0000000000FE471A'X,'00000FE41CFE081A'X,
     +'00000FE41CFE471A'X,'3F763FE31DFE081B'X/
      DATA IY11/
     +'29A689601D61552A'X,'00FD451518760968'X,'0000003F2951762A'X,
     +'185955141559866A'X,'0000003F29A5F71A'X,'268E179D1C71452A'X,
     +'00000FE527A29A68'X,'0003FA54208A252A'X,'2179C6DB1C75452A'X,
     +'00FE59E829A689A3'X,'2689D615145155EA'X,'1C75F8A326A29A68'X,
     +'000000003F89F75C'X,'00000FD41482952A'X,'2079D71B195D552A'X,
     +'22967A2929A27962'X,'145155D91B71D7A0'X,'000000000000003F'X,
     +'1A6DE8212181E6EA'X,'289606D715514557'X,'000000003F9A8A69'X,
     +'3F8A282914829529'X,'1A6165541482952A'X,'258A07DE1E81E75C'X,
     +'000000003FA69A27'X,'1C6575541455766B'X,'3F926A2929A26921'X,
     +'1C6575541482952A'X,'00000FE929A26921'X,'2079E81414829529'X,
     +'000000000003FA69'X,'3F79E81414829528'X,'1C6575541455766B'X,
     +'21926A2929A26921'X,'0000000000FE1860'X,'3F79E8291482952B'X,
     +'0000000000FE9524'X,'249E8A69289E4528'X,'0000000000000FE2'X,
     +'3FA5D8221482952A'X,'00000FE929829527'X,'20A548291482952C'X,
     +'000000000003FA54'X,'3FA548291482952B'X,'289A485C195D552B'X,
     +'155D9721249A8A69'X,'000000000003F514'X,'1B6165541482952A'X,
     +'000000003F7DF79D'X,'289A485C195D552B'X,'155D9721249A8A69'X,
     +'0000003F2B960514'X,'1A6165541482952A'X,'0003FA5E2079E75C'X/
      DATA IY12/
     +'1C6D95D5145155EA'X,'28A69A26238607DD'X,'0000000000000FE6'X,
     +'00000FD414829528'X,'239A8A69289A352B'X,'0000000000000FD4'X,
     +'00000FE914829529'X,'20A548291482952C'X,'000000000003FA54'X,
     +'00000FE91482952A'X,'0003F79420A5E529'X,'3FA698141482952A'X,
     +'3F8A282914829529'X,'1A6165541482952A'X,'258A07DE1E81E75C'X,
     +'000000003FA69A27'X,'00000FD414829527'X,'3FA6982914829529'X,
     +'2079E81414829529'X,'000000000003FA69'X,'3FA698141482952A'X,
     +'3F79E8291482952B'X,'289A485C195D552B'X,'155D9721249A8A69'X,
     +'0000003F1E7A0514'X,'0000000000FE9524'X,'3FA5D8221482952A'X,
     +'00000FE914829529'X,'20A548291482952C'X,'000000000003FA54'X,
     +'3FA548291482952B'X,'3FA6981E1E814529'X,'289A485C195D552B'X,
     +'155D9721249A8A69'X,'000000000003F514'X,'3F5148291482952B'X,
     +'1B6165541482952A'X,'000000003F7DF79D'X,'29A6051420A5E529'X,
     +'000000000000003F'X,'00000FD414829528'X,'296D755414557669'X,
     +'3F6D755414557660'X,'2281D6DA1982952A'X,'1969B760228E4923'X,
     +'0000000000000FD9'X,'00000FD42982952A'X,'2285F6DA1A82952B'X,
     +'00FDA69B1F8628E3'X,'145155DA1E8A9A6A'X,'0003FA692279A5D5'X,
     +'3FA698202082962C'X,'0000000000FF0424'X,'228A69A22279E6A6'X/
      DATA IY13/
     +'000000003F69A79E'X,'1961782D1082D42A'X,'1C6D95D5145155D8'X,
     +'1F79C6D9208A07DD'X,'24966A2929A268A0'X,'000000000003F9A5'X,
     +'3F9E8A6827822525'X,'2075D8301083042B'X,'000000000003F8E3'X,
     +'000000003FA605EC'X,'1859551415598669'X,'28A689E0227DD71A'X,
     +'0000000000000FE7'X,'13450411124D246C'X,'1851282E2CA1C615'X,
     +'2DBAFC302FB6BA24'X,'000000000003FBEE'X,'29A2781B1C75C6E5'X,
     +'000000000003F9E8'X,'28A6881B1C75C6E5'X,'0000003F2DB2AA27'X,
     +'000000003FA605EC'X,'2041083010830427'X,'000000000003FC30'X,
     +'2041083010830427'X,'000000000003FC30'X,'269A08A22085D668'X,
     +'000000000000003F'X,'1D6D961614491427'X,'1E71A617154D181F'X,
     +'20BEDAE9289A48A0'X,'30BEEB2A289E58E1'X,'000000000000003F'X,
     +'1D6D961614491427'X,'1E71A617154D181F'X,'20BEDAE9289A48A0'X,
     +'30BEEB2A289E58E1'X,'000000000000003F'X,'29220A5C209DB6F0'X,
     +'000000000000003F'X,'259A69632179A5AC'X,'269A58E11E696823'X,
     +'2A9E382A278E08E5'X,'0000000000FEAAA0'X,'207595D6165D972C'X,
     +'175965D91C82A962'X,'00000FEA258A0759'X,'207585602075856C'X,
     +'2BA238202BA23820'X,'000000000000003F'X,'1E7E18E5269A58AC'X,
     +'1659765B1D7E07DE'X,'1F79E7E01F75B657'X,'278A08A5269A58E1'X/
      DATA IY14/
     +'00FEAAA02A9E282A'X,'289A379C1B6DC76D'X,'1B720863259E8A69'X,
     +'267DC657155155D9'X,'0000003F27A29A68'X,'00000FE71982766B'X,
     +'1C75D71A19826668'X,'258E28191A69965A'X,'00000FE2228E59A6'X,
     +'1F8639252592382B'X,'259648DD1C6DB71D'X,'1D71B6DC1D7E18E4'X,
     +'0000000000000FE0'X,'218E4923217DD724'X,'227A085F2071C75F'X,
     +'208DD8231D823760'X,'0000003F217E089E'X,'208DD81C1C924724'X,
     +'1D823760237608DD'X,'0003F8DD208DD823'X,'1D8227601A8E36A5'X,
     +'0003F8A0208A0822'X,'2381E8E02675D9A5'X,'0003F7A0207A081E'X,
     +'1A8206A51E7A56A6'X,'209608252081E820'X,'000000000003F7A0'X,
     +'2082581B208A07AD'X,'0000000000000FE0'X,'1881D61D206976A8'X,
     +'0000000000000FE9'X,'2082581B208A07AD'X,'0000000000000FE0'X,
     +'17823A23209A99A8'X,'0000000000000FE8'X,'00FDA657155155A5'X,
     +'00000FE728A689E5'X,'3FB6CAA827A29A25'X,'0000000000FF042B'X,
     +'2EAE789E19552427'X,'0000000000000FF0'X,'2EAE789E19552427'X,
     +'0000000000000FF0'X,'0000000000FE082D'X,'00000FE0208295ED'X,
     +'00000FE32381D76D'X,'3F8DD8231D8266A8'X,'1E8639232179C6E5'X,
     +'000000000003F6DC'X,'000000003F91B765'X,'3F92481E1C6DB725'X,
     +'1F7E07DE1C6DB725'X,'0000003F239248E0'X,'0003F8611B8246E5'X/
      DATA IY15/
     +'2492385F1E79F6E5'X,'000000003F6DB823'X,'218E48E11E71B6E5'X,
     +'000000003F85F79F'X,'00000FDB1B8246E5'X,'1B6DC79F1F79C6E5'X,
     +'3F7E08E4248E07E0'X,'1E71B71E208607A5'X,'000000003F9248E1'X,
     +'1E71B6DC1E8296EA'X,'00FE6A2929A268E1'X,'1E71B6DC1E829529'X,
     +'00FE6A2929A268E1'X,'268E179C1B6DC7A9'X,'0000003F26A29A68'X,
     +'1E71B6DC1E82952A'X,'00FE6A2929A268E1'X,'1E71B6DC1D7E1869'X,
     +'00FE6A2929A268E1'X,'3F6DB82918554527'X,'1E82FC302FBAB6EA'X,
     +'29A268E11E71B6DC'X,'0000000000FE6A29'X,'1F71B6DC1F82952A'X,
     +'0000000000000FE9'X,'3FA5B81413515524'X,'2FB1B81413515525'X,
     +'000000000003FC30'X,'3FA618251B829528'X,'0000000000FE9524'X,
     +'1F71B6DC1F8296EF'X,'3FA5F71B1B71F829'X,'1F71B6DC1F8296EA'X,
     +'0000000000000FE9'X,'29A689A32179C6EA'X,'00FDB6DC1E8639A8'X,
     +'1E71B6DC1E8306E9'X,'00FE6A2929A268E1'X,'1E71B6DC1E8306EA'X,
     +'00FE6A2929A268E1'X,'3F6DB71E218296E6'X,'2286079C1B6DC7A9'X,
     +'00FE6A2929A26963'X,'3F6DB82929A25527'X,'1B825A2929A256EA'X,
     +'0000000000000FE9'X,'00000FE91B8296E8'X,'20A5B8291B8296EB'X,
     +'000000000003FA5B'X,'00000FE91B8296E9'X,'30C2FB691B8296E8'X,
     +'000000000000003F'X,'3FA6981B1B8296E9'X,'29A689A32079C6EB'X/
      DATA IY16/
     +'1E71B6E01B7A2968'X,'000000003FA69A26'X,'20C2889E1B5D552A'X,
     +'1D81D75C1B656514'X,'27A29A682796281E'X,'0000000000000FE4'X,
     +'2992075C1B6DC7AA'X,'0003FC2D2981E6E0'X,'29A279211E71B6E9'X,
     +'155D96DD208E6A29'X,'000000003F5D5514'X,'2086079C1B6DC768'X,
     +'3F9A8A69289A48A1'X,'1981965817595527'X,'2FB6BA67258E075B'X,
     +'0000000000FEEC30'X,'20A6279C1B6DD7EA'X,'3FC2581D1B6DC7A2'X,
     +'289A379C1B6DD7EA'X,'145586E023968A69'X,'0003F8A01E6D8594'X,
     +'3F967A69289A26E5'X,'2181C6DB1C8296E9'X,'3FA29A68238A1821'X,
     +'3FA5B82916554528'X,'28A699E41F8306EB'X,'27A69A26226E08A6'X,
     +'0000000000000FE5'X,'2079B8292685B6E9'X,'000000003FA689A3'X,
     +'1981965817595528'X,'238A08A2217DD6DA'X,'3FC30BED2CAA89A4'X,
     +'29A689E42179C6E9'X,'00FDB6DC1D8239A8'X,'1E8299A11B8296EB'X,
     +'0000000000FDB6DC'X,'239A8A69289E4869'X,'3FC2179C1B6DC760'X,
     +'29A279211E71B6EB'X,'00FDB71D208E6A29'X,'00FDB6DC1E8296EA'X,
     +'299E479C1B6DD7EA'X,'00000FDB1E8A6A29'X,'29A689E5227DD72B'X,
     +'2685D6DB1D8239A8'X,'0000000000000FF0'X,'1D6E0C302E75B6E9'X,
     +'000000003FC2EAE0'X,'1E71B6DD1F83052B'X,'1B7A39A829A689A3'X,
     +'000000000000003F'X,'28A69A25227DC6EB'X,'22968A6928961825'X/
      DATA IY17/
     +'0000000000FDB71F'X,'3F9A6820208266E8'X,'0000000000FE56A2'X,
     +'2871CA2018924627'X,'000000000000003F'X,'1B69A82A1682A5A8'X,
     +'208A179C1A65969B'X,'249669A5248A075C'X,'000000003F9248E3'X,
     +'249238201B8206E3'X,'000000000003F8E3'X,'2079E8251A8256A6'X,
     +'000000000003F861'X,'000000003F9A06A8'X,'1F8207DE1C6DB725'X,
     +'0003F8E32492381E'X,'1D698596176185E9'X,'289A3759178299E3'X,
     +'00000FE928A29AAA'X,'2492381E1E7DF7A3'X,'000000000003F8E3'X,
     +'2392481E1E7DF7A3'X,'0000000000FE7963'X,'000000003F9A06A8'X,
     +'2059682A1682A5A5'X,'000000000003FAAA'X,'2059682A1682A5A5'X,
     +'000000000003FAAA'X,'269A08A22085D668'X,'000000000000003F'X,
     +'1A5E079C1A6175A5'X,'207DE71A1881F720'X,'26824860289A48A1'X,
     +'00FEAA6826922829'X,'1A5E079C1A6175A6'X,'207DE71A1881F720'X,
     +'26824860289A48A1'X,'00FEAA6826922829'X,'2652099D2095D769'X,
     +'000000000000003F'X,'26A205D5145155EB'X,'1E6585D71865E8A4'X,
     +'29A20A2820A26922'X,'000000003FA29AAA'X,'20AA182A218216E8'X,
     +'15620556186E0AAA'X,'1B815620155986E0'X,'196E06DA1A81B659'X,
     +'1D71B81B1A6A06D9'X,'2075C6E02075B820'X,'000000003F81D6E0'X,
     +'208E181E1C8195E8'X,'1582AAA02A9E0AA7'X,'185D881817560617'X/
      DATA IY18/
     +'1C75C6601C75C660'X,'2285E81D1D71D760'X,'208A285E208A1822'X,
     +'238228A1228A08A1'X,'238289E527A289E6'X,'288289E527A289E6'X,
     +'000000003FA289E8'X,'20AAA82A2782A9E8'X,'1B7608A2239A8A27'X,
     +'1A6D8595155986DA'X,'27A289A3228A075B'X,'000000000000003F'X,
     +'2086392423860826'X,'248E179C1B6DC79F'X,'0000000000000FE4'X,
     +'00000FE31D823765'X,'1D71C75E218E6A2B'X,'1F8A3924238A17DE'X,
     +'0000000000FD869D'X,'1C75E862238E282A'X,'1E8628E32281F75C'X,
     +'00000FE01F75C71D'X,'279E69211F71A667'X,'00FD965A1C7E1926'X,
     +'00000FDA1A9A66A6'X,'0000003F18924627'X,'00000FD620AA05A6'X,
     +'1D8678E72175D5E8'X,'000000000003F5DD'X,'2281E8232281E769'X,
     +'0000000000FE0820'X,'2079D69D1E8266E5'X,'0000000000FDD6DD'X,
     +'2281E8232281E769'X,'0000000000FE0820'X,'208A39A3228256A5'X,
     +'0000000000FE3963'X,'0003F7DD1B6DC723'X,'00000FE3239248E3'X,
     +'0003F9E5238E4923'X,'0000000000FE56A5'X,'0003F9632179C6A4'X,
     +'0003F9632179C6A3'X,'0000000000FE0826'X,'00000FE020824726'X,
     +'00000FE22281E7A6'X,'3F89E8221E823765'X/
      DATA ISTART/
     +  1,  3,  4,  6,  8,  9, 11, 14, 15, 19, 22, 23, 26, 28, 30,
     + 32, 33, 36, 37, 38, 40, 41, 42, 44, 45, 48, 50, 53, 55, 58,
     + 59, 61, 62, 64, 65, 66, 67, 68, 71, 72, 73, 75, 76, 77, 80,
     + 81, 82, 83, 85, 86, 87, 90, 91, 93, 95, 96, 98,101,102,104,
     +106,107,108,110,115,116,118,119,122,126,128,130,131,133,135,
     +137,142,147,149,153,156,159,164,168,169,172,176,180,183,185,
     +187,190,192,194,196,198,199,200,201,202,204,206,207,208,209,
     +210,212,213,214,216,217,219,221,222,224,226,228,230,232,234,
     +236,237,240,242,243,245,246,247,249,251,253,255,257,258,260,
     +261,263,264,266,267,269,270,273,277,279,282,284,287,289,292,
     +293,295,296,299,301,304,306,308,310,312,313,315,318,320,323,
     +326,327,328,330,334,336,338,339,341,344,346,348,349,351,353,
     +355,359,363,365,369,376,386,391,394,395,398,401,403,404,405,
     +406,408,410,412,414,416,417,418,419,420,421,422,423,424,425/
*
      DATA NBIT,NBITCH,NBITMX/64,8,60/
+SELF, IF=CRAY.
      DATA IX11/
     +41373432313132343726B,00773741444647474644B,00000000774141363426B,
     +46454442363433323226B,00000000774731434546B,46474746454340463326B,
     +00000077313233364144B,00007743437750314326B,47464441363332334526B,
     +00773132333641444647B,33323233354042454626B,41444647474644414035B,
     +00000000007732333540B,00000077473177354726B,46444135333232333626B,
     +31313233364245464747B,36424546464543373432B,00000000000000000077B,
     +31313234374043454626B,43454646454340373432B,00000000007732333640B,
     +77453377504077304027B,47474645423177313125B,47474645423177424546B,
     +00000000007731424546B,31323335374345475026B,77504745433735333231B,
     +47464543403177313125B,00000077314043454647B,77423277473277323226B,
     +00000000000000774732B,77423277473277323226B,31323335374345475026B,
     +50504745433735333231B,00000000000077504377B,77473177474777313125B,
     +00000000000077404034B,32333436404243444430B,00000000000000007732B,
     +77473677314777313125B,00000077463277323226B,77405077403077303024B,
     +00000000000000775050B,77474777473177313125B,34323130303132343625B,
     +44464750504746444236B,00000000000000773642B,47474645423177313125B,
     +00000000007731424546B,34323130303132343625B,44464750504746444236B,
     +00000000774741773642B,47474645423177313125B,00007747407731424546B/
      DATA IX12/
     +33323131333642454726B,33364245474746454335B,00000000000000007731B,
     +00000077473177404030B,47464441373432313125B,00000000000000007747B,
     +00000077405077403027B,77454077334077332624B,00000000000000774552B,
     +00000077314777473126B,00007740507740403027B,77473177473177314726B,
     +77453377504077304027B,47474645423177313125B,47474645423177424546B,
     +00000000007731424546B,00000077463277323226B,77503077504077304027B,
     +77423277473277323226B,00000000000000774732B,77473177473177314726B,
     +77473177474777313125B,34323130303132343625B,44464750504746444236B,
     +00000000774335773642B,00000000000077404034B,77473677314777313125B,
     +00000077504077304027B,77405077403077303024B,00000000000000775050B,
     +77474777473177313125B,77473177433577473127B,34323130303132343625B,
     +44464750504746444236B,00000000000000773642B,77473177474777313125B,
     +47474645423177313125B,00000000007731424546B,47317747317731403127B,
     +00000000000000000077B,00000077473177404030B,40403736353332313127B,
     +77404142434546474777B,32313132333677404026B,42454647474645423633B,
     +00000000000000007736B,00000077473177473126B,34333231302777404025B,
     +00775150474645444137B,41373432313132353126B,00007747434647474644B,
     +77503077503077404024B,00000000000077404034B,46424236363232363632B/
      DATA IX13/
     +00000000007736424246B,46454677424277363626B,33323131333642454747B,
     +45433533317747454335B,32313133364245474746B,00000000000000773233B,
     +77404140374077404033B,77503277404777324126B,00000000000000774731B,
     +00000000007730503024B,46454442363433323227B,41403740774040444546B,
     +00000000000000007740B,43454751525251505124B,42434477343536404142B,
     +27262627313335363740B,00000000000000772730B,40374077404140374033B,
     +00000000000000774041B,37404177404140374033B,00000000773740414140B,
     +00000000007750305024B,77443577363677353531B,00000000000000774435B,
     +77433477434377424231B,00000000000000774334B,45337745337733453330B,
     +00000000000000000077B,41414037363637404231B,41424241403737407737B,
     +77403737404142424135B,42403736363740414137B,00000000000000000077B,
     +37374041424241403631B,37363637404141407741B,77404141403736363743B,
     +36404142424140373741B,00000000000000000077B,40607740267740272217B,
     +00000000000000000077B,37353331303031344024B,43454750504744407740B,
     +42414077363740774041B,00000000000077423677B,31303031333436374024B,
     +47454442414077403432B,00000077404446475050B,51464240772732364024B,
     +40424651774036322777B,00000000000000000077B,46505151504644424024B,
     +37414344444341774144B,30323437773735343435B,37407740363432302727B/
      DATA IX14/
     +00774236774241407736B,40424446475051525223B,40373027262627303236B,
     +43363433333436404141B,00000000775252514745B,00000077314777473125B,
     +32333536363577324630B,42424377464441353332B,00000077434546464543B,
     +53535251474543424025B,31333536424345475152B,36353331272625252627B,
     +00000000000000007740B,44434137353434353734B,36367735357737414344B,
     +77414177404077373777B,00000000774343774242B,77353577344444343434B,
     +41774040773737773636B,00007743437742427741B,40773540774045334033B,
     +00007741407737407743B,40774340774033454033B,00007737407741407735B,
     +40407740443246344032B,77444077344077324077B,00000000000000774640B,
     +27774350437746514623B,00000000000000007750B,40774540337742403630B,
     +00000000000000007740B,30773530357732273223B,00000000000000007751B,
     +40774540337742403630B,00000000000000007740B,00773740414140374033B,
     +00000077404140374033B,77374041414037404133B,00000000000077275125B,
     +42403635353640424431B,00000000000000007744B,36404243434240363431B,
     +00000000000000007734B,00000000000077512723B,00000077512777404023B,
     +00000077512777512723B,77334577453377404030B,43434240363535364033B,
     +00000000000000774042B,00000000007740403633B,77433542434341373533B,
     +41407741434341373533B,00000000773537414343B,00007744344177414133B/
      DATA IX15/
     +37404243424037353633B,00000000007742367735B,43424036353536404233B,
     +00000000007735364042B,00000077433577374333B,37414343413735353733B,
     +77414343413735353777B,43424036353640424333B,00000000007736404243B,
     +33353742444677464627B,00774644423735333232B,45434136343277323226B,
     +00773234364143454646B,33323233353742444627B,00000000774644423735B,
     +33353742444677464627B,00774644423735333232B,33353742444546463227B,
     +00774644423735333232B,77443577404041434533B,46773537424445464627B,
     +37353332323335374244B,00000000000077464442B,46454340363377333327B,
     +00000000000000007746B,77404077374041403734B,40414177404142414033B,
     +00000000000000773436B,77463777334577333327B,00000000000077404034B,
     +40373532302577252521B,77535352504543407740B,46454340363377333327B,
     +00000000000000007746B,42373533323233353727B,00773742444647474644B,
     +45434136343277323226B,00773234364143454646B,33353742444677464627B,
     +00774644423735333232B,77454240363577353531B,43363433343742454630B,
     +00773334374245464645B,77443577454341404033B,46774643413634333327B,
     +00000000000000007746B,00000077404677403230B,77444077344077343025B,
     +00000000000000774450B,00000077334677463330B,31323436404677403230B,
     +00000000000000000077B,77463377463377334630B,36343231313233353726B/
      DATA IX16/
     +43424137775047454340B,00000000007750474645B,77313233343537414327B,
     +40774043454647474543B,34353741434445454442B,00000000000000007733B,
     +40414140373534323027B,00007735364046475077B,36343332323335374227B,
     +37374042444545444240B,00000000007746444240B,77413635353742444530B,
     +77454341363433333541B,46774643403737404230B,42424136343333343742B,
     +00000000000077363741B,77323435353432302726B,77424546464442403634B,
     +34333334343331272625B,43454646454443413735B,00007750454341404041B,
     +77434240363535364032B,35374345464777313527B,77444342413736347734B,
     +77324077463635333130B,41373533333477273526B,51474544444547774543B,
     +00000000000000007752B,45464777323334353227B,00000000007732354043B,
     +43774643403737404230B,36427744423735353640B,77364042424135333334B,
     +41373534333334364030B,00774042444546464543B,27774645444377323625B,
     +00000000000077513431B,46454341373534333327B,77273334364042444546B,
     +36343332323335375127B,00774143444545444240B,00775035323077364126B,
     +35333335353432302726B,00000077474746444237B,37343231303031333525B,
     +36404244465050474542B,00000000000000007733B,47507747454335333127B,
     +00000000007730313345B,33333230262577344424B,51504644423735333232B,
     +00000000000000000077B,35333130272730323424B,50474543414037407737B/
      DATA IX17/
     +00000000000077464750B,77453377453377404030B,00000000000077404036B,
     +40314740774047314031B,00000000000000000077B,44444577424277373731B,
     +77454435343436434545B,34353742444545443534B,00000000007734353534B,
     +41404077414177404036B,00000000000000774041B,77443577414377364033B,
     +00000000000000774435B,00000000007733453330B,41414040434341403634B,
     +00007740414140407743B,40414244464747464627B,36374041424377353637B,
     +00000077323231313234B,41404077404141404036B,00000000000000774041B,
     +40404177404141404036B,00000000000077404141B,00000000007745334530B,
     +77433677373777363633B,00000000000000774336B,77423577424277414133B,
     +00000000000000774235B,45337745337745334530B,00000000000000000077B,
     +36377741403636374132B,36404141373677404177B,36774140773637414140B,
     +00774137363640417737B,42417737404242413733B,42403737414277403777B,
     +42773740774241373740B,00773741424240377741B,40517740317740322725B,
     +00000000000000000077B,26257742424137363625B,46464543353332323130B,
     +36377753257753525047B,00000000007741424137B,77414077374077404030B,
     +34377734363740774137B,40774441774442414077B,44407730323677303234B,
     +35364077504642775046B,43434240773536407735B,00000000007743424077B,
     +77404077404077404030B,40774137774140773740B,42403677424140773637B/
      DATA IX18/
     +45444240773334364077B,34364077444240363477B,47464442407732313132B,
     +40774442403634774647B,40773230303132333536B,33774650504746454342B,
     +00000000007745434035B,77413777414077374030B,47504745475050464340B,
     +33353435374143444345B,40353230303133313031B,00000000000000000077B,
     +35343435404142434432B,43413735353640414140B,00000000000000007744B,
     +00000077354377433533B,32354144465152535327B,51464441353230272730B,
     +00000000000077535352B,34363741424445475026B,41373634333130303133B,
     +00000077505047454442B,41373432313132343731B,00773741444647474644B,
     +00000077324646323232B,00000000774047314031B,00000077404640324032B,
     +50434540333530364030B,00000000000000774042B,43454377424346434227B,
     +00000000000077453277B,77434240363577404033B,00000000000077424036B,
     +35333577363532353627B,00000000000077463377B,77434240363577404033B,
     +00000000000077424036B,00007740414140404136B,00000077404141404036B,
     +00007740414140404136B,00000000000077344433B,00007742403737404235B,
     +00007736404141403634B,00000000000077443432B,00000077443477404032B,
     +00000077443477443432B,77354377433577404033B/
      DATA IY11/
     +51515045403530252452B,00772424253035404550B,00000000775124273052B,
     +30262524242526303152B,00000000775151373432B,46434136353434242452B,
     +00000077454750515150B,00007751244042422452B,41363433333435242452B,
     +00774547505151504643B,46423530252424252752B,34353742434650515150B,
     +00000000007742373534B,00000077242440512452B,40363534333127252452B,
     +42454750515150474542B,24242527313334353640B,00000000000000000077B,
     +32333640414140363352B,50454033272524242527B,00000000007746505151B,
     +77424240512440512451B,32302625242440512452B,45424037363640363534B,
     +00000000007751515047B,34312725242425273153B,77444650515150464441B,
     +34312725242440512452B,00000077515150464441B,40363640242440512451B,
     +00000000000000775151B,77363640242440512450B,34312725242425273153B,
     +41444650515150464441B,00000000000077414140B,77363640512440512453B,
     +00000000000077512444B,44475051515047442450B,00000000000000007742B,
     +77513540422440512452B,00000077515140512447B,40512440512440512454B,
     +00000000000000775124B,77512440512440512453B,50464441343127252453B,
     +25273134414446505151B,00000000000000772424B,33302625242440512452B,
     +00000000007737373635B,50464441343127252453B,25273134414446505151B,
     +00000000775345402424B,32302625242440512452B,00007751364036363534B/
      DATA IY12/
     +34333127252424252752B,50515150464341403735B,00000000000000007746B,
     +00000077242440512450B,43465051515046432453B,00000000000000007724B,
     +00000077512440512451B,40512440512440512454B,00000000000000775124B,
     +00000077512440512452B,00007736244051362451B,77515140242440512452B,
     +77424240512440512451B,32302625242440512452B,45424037363640363534B,
     +00000000007751515047B,00000077242440512447B,77515140512440512451B,
     +40363640242440512451B,00000000000000775151B,77515140242440512452B,
     +77363640512440512453B,50464441343127252453B,25273134414446505151B,
     +00000000773636402424B,00000000000077512444B,77513540422440512452B,
     +00000077512440512451B,40512440512440512454B,00000000000000775124B,
     +77512440512440512453B,77515140363640242451B,50464441343127252453B,
     +25273134414446505151B,00000000000000772424B,77242440512440512453B,
     +33302625242440512452B,00000000007737373635B,51514024244051362451B,
     +00000000000000000077B,00000077242440512450B,51332725242425273151B,
     +77332725242425273140B,42403533323140512452B,31323335404243444443B,
     +00000000000000007731B,00000077245140512452B,42413733323240512453B,
     +00773232333741424343B,24242527323642515152B,00007751514236322725B,
     +77515140404040513054B,00000000000077602044B,42424646424236363246B/
      DATA IY13/
     +00000000007732323636B,31302740552040552052B,34333127252424252730B,
     +37363433314042403735B,44454650515150464240B,00000000000000774645B,
     +77475051504740422445B,40353540602040602053B,00000000000000774343B,
     +00000000007751402754B,30262524242526303151B,50515047404237353432B,
     +00000000000000007747B,23212020212223222154B,30242240565450343025B,
     +55565760605755535044B,00000000000000775756B,51504740333435343345B,
     +00000000000000774750B,50515040333435343345B,00000000775554525047B,
     +00000000007751402754B,40202040602040602047B,00000000000000776060B,
     +40202040602040602047B,00000000000000776060B,46464042424041353150B,
     +00000000000000000077B,35333130262422212047B,36343230272523214037B,
     +40575553515046444240B,60575654525047454341B,00000000000000000077B,
     +35333130262422212047B,36343230272523214037B,40575553515046444240B,
     +60575654525047454341B,00000000000000000077B,51104051344047333360B,
     +00000000000000000077B,45464645434136322654B,46464543413632264043B,
     +52474340524743404345B,00000000000077525240B,40353127262627313454B,
     +27262627313440524542B,00000077524542403531B,40353025404035302554B,
     +53504340405350434040B,00000000000000000077B,36374143454646454254B,
     +26262731333537403736B,37363637403735333127B,47424042454646454341B/
      DATA IY14/
     +00775252405247424052B,50464336343333343555B,33344041434547505151B,
     +46373431272524252731B,00000000774750515150B,00000077473140473153B,
     +34353534323140463150B,45434240313232313132B,00000077424243454646B,
     +37414344454544434053B,45454443353433333435B,35343333343537414344B,
     +00000000000000007740B,41434444434137353444B,42364041374034343537B,
     +40433540433540433540B,00000000774137404236B,40433540343444443444B,
     +35404335404335404335B,00007743354043354043B,35404235403243433245B,
     +00007742404042404042B,43403643404635354645B,00007736404036404036B,
     +32404032453636453246B,40454040454040364040B,00000000000000773640B,
     +40404540334042403655B,00000000000000007740B,30403530354032273250B,
     +00000000000000007751B,40404540334042403655B,00000000000000007740B,
     +27404350434046514650B,00000000000000007750B,00773231272524252645B,
     +00000077475051504745B,77555452504750515045B,00000000000077602053B,
     +56534742363125222047B,00000000000000007760B,56534742363125222047B,
     +00000000000000007760B,00000000000077404055B,00000077404040512755B,
     +00000077434340353555B,77433540433540463250B,36414344434136343345B,
     +00000000000000773334B,00000000007744333545B,77444440363433333445B,
     +37374037363433333445B,00000000774344444340B,00007741413340443345B/
      DATA IY15/
     +44444341373636373345B,00000000007733334043B,41434443413634333345B,
     +00000000007741373637B,00000077333340443345B,33333436373736343345B,
     +77374043444443403740B,36343334364041403645B,00000000007744444341B,
     +36343333343640513352B,00774650515150464341B,36343333343640512451B,
     +00774650515150464341B,46434136343333343651B,00000000774650515150B,
     +36343333343640512452B,00774650515150464341B,36343333343537414151B,
     +00774650515150464341B,77333340513025242447B,36405760605756533352B,
     +51504643413634333334B,00000000000077465051B,37343333343740512452B,
     +00000000000000007751B,77513340242324252444B,57543340242324252445B,
     +00000000000000776060B,77514140453340512450B,00000000000077512444B,
     +37343333343740513357B,77513734333334374051B,37343333343740513352B,
     +00000000000000007751B,51515046434136343352B,00773333343641434650B,
     +36343333343640603351B,00774650515150464341B,36343333343640603352B,
     +00774650515150464341B,77333334364140513346B,42414036343333343651B,
     +00774650515150464543B,77333340515150452447B,33404550515150453352B,
     +00000000000000007751B,00000077513340513350B,40513340513340513353B,
     +00000000000000775133B,00000077513340513351B,60605755513340513350B,
     +00000000000000000077B,77515140333340513351B,51515046434036343353B/
      DATA IY16/
     +36343333403336424550B,00000000007751515046B,40605042363327252452B,
     +35403535343331262424B,47505151504745424036B,00000000000000007744B,
     +51444035343333343652B,00007760555140363340B,51504744413634333351B,
     +25273133354043465051B,00000000007727252424B,40414036343333343550B,
     +77465051515046444241B,31403131302726252447B,57555351474543403533B,
     +00000000000077566060B,40514236343333353752B,77604540353333343642B,
     +50464336343333353752B,24253033404345505151B,00007742403633302624B,
     +77454751515046423345B,41403433333440513351B,77505151504342414041B,
     +77513340512625242450B,50515147443740603353B,47515150464233404246B,
     +00000000000000007745B,40363340514641333351B,00000000007751504643B,
     +31403131302726252450B,43424042424137353332B,77606057555452504644B,
     +51515047444136343351B,00773333343540434650B,36405146413340513353B,
     +00000000000077333334B,43465051515047444151B,77604136343333343540B,
     +51504744413634333353B,00773334354043465051B,00773333343640513352B,
     +51474436343333353752B,00000077333642465051B,51515047454237353453B,
     +46413533333540434650B,00000000000000007760B,35334060605635333351B,
     +00000000007760565340B,36343333353740602453B,33364346505151504643B,
     +00000000000000000077B,50515150454237343353B,42455051515045414045B/
      DATA IY17/
     +00000000000077333437B,77464640404040463350B,00000000000077453242B,
     +50343450403044443047B,00000000000000000077B,33323240522640522650B,
     +40424136343231313233B,44454646454442403534B,00000000007744444343B,
     +44444340403340403343B,00000000000000774343B,40363640453240453246B,
     +00000000000000774141B,00000000007746403250B,37404037363433333445B,
     +00007743434444434036B,35323026262730302751B,50464335312740514743B,
     +00000077515050515252B,44444340363637373643B,00000000000000774343B,
     +43444440363637373643B,00000000000077474543B,00000000007746403250B,
     +40262640522640522645B,00000000000000775252B,40262640522640522645B,
     +00000000000000775252B,46464042424041353150B,00000000000000000077B,
     +32274036343230272645B,40373634323040373440B,46404441405046444241B,
     +00775251504644424051B,32274036343230272646B,40373634323040373440B,
     +46404441405046444241B,00775251504644424051B,46244046354045353551B,
     +00000000000000000077B,46504027252424252753B,36313027273031364244B,
     +51504050504050464442B,00000000007750515252B,40524140524140413350B,
     +25304025263033405252B,33402530402526303340B,31334033323240333131B,
     +35343340333232403331B,40353433404035334040B,00000000007740353340B,
     +40434140363440312750B,25405252405247405247B,30273040302725403027B/
      DATA IY18/
     +34353431403435343140B,42413640353534353540B,40424241364042414042B,
     +43404242414242404241B,43405047454750504746B,50405047454750504746B,
     +00000000007750504750B,40525240524740524750B,33354042424346505047B,
     +32333026252526303332B,47505046434242403533B,00000000000000000077B,
     +40414344444341404046B,44434136343333343637B,00000000000000007744B,
     +00000077433540433545B,35343435364143465053B,37424344444342413736B,
     +00000000000077303235B,34353641424343424052B,36414243434240373534B,
     +00000077403735343435B,47474644413734323147B,00773131323437414446B,
     +00000077323246463246B,00000000773044443047B,00000077264052402646B,
     +35414743474135352750B,00000000000000772735B,42403640434240363551B,
     +00000000000077404040B,40363532353640463345B,00000000000077353335B,
     +42403640434240363551B,00000000000077404040B,40424346434240453245B,
     +00000000000077434543B,00007737353333343443B,00000077434344444343B,
     +00007747454343444443B,00000000000077453245B,00007745434136343244B,
     +00007745434136343243B,00000000000077404046B,00000077404040443446B,
     +00000077424240363646B,77423640423640433545B/
      DATA ISTART/
     +  1,  3,  4,  6,  8,  9, 11, 14, 15, 19, 22, 23, 26, 28, 30,
     + 32, 33, 36, 37, 38, 40, 41, 42, 44, 45, 48, 50, 53, 55, 58,
     + 59, 61, 62, 64, 65, 66, 67, 68, 71, 72, 73, 75, 76, 77, 80,
     + 81, 82, 83, 85, 86, 87, 90, 91, 93, 95, 96, 98,101,102,104,
     +106,107,108,110,115,116,118,119,122,126,128,130,131,133,135,
     +137,142,147,149,153,156,159,164,168,169,172,176,180,183,185,
     +187,190,192,194,196,198,199,200,201,202,204,206,207,208,209,
     +210,212,213,214,216,217,219,221,222,224,226,228,230,232,234,
     +236,237,240,242,243,245,246,247,249,251,253,255,257,258,260,
     +261,263,264,266,267,269,270,273,277,279,282,284,287,289,292,
     +293,295,296,299,301,304,306,308,310,312,313,315,318,320,323,
     +326,327,328,330,334,336,338,339,341,344,346,348,349,351,353,
     +355,359,363,365,369,376,386,391,394,395,398,401,403,404,405,
     +406,408,410,412,414,416,417,418,419,420,421,422,423,424,425/
*
      DATA NBIT,NBITCH,NBITMX/64,8,60/
+SELF.
      DATA IPASS/0/
*
*       SET OF FORTRAN CHARACTERS (ON ANY KEYBOARD)
*
*     DATA IFORT/1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,1HK,1HL,1HM,1HN
*    +  ,1HO,1HP,1HQ,1HR,1HS,1HT,1HU,1HV,1HW,1HX,1HY,1HZ
*    +  ,1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9
*    +  ,1H.,1H,,1H/,1H(,1H),1H-,1H+,1H=,1H*,1H$,1H /
*
*       SET OF CONTROL CHARACTERS (MAY BE KEYBOARD DEPENDENT)
*
*       ISPEC(1)= !   GOTO NORMAL SCRIPT LEVEL( EXCLAMATION MARK)
*       ISPEC(2)= ?   GOTO SUBSCRIPT (QUESTION MARK)
*       ISPEC(3)  ^   GOTO SUPERSCRIPT (CIRCOMFLEX)
*       ISPEC(4)  >   GOTO UPPER CASE (GREATER THAN)
*       ISPEC(5)  <   GOTO LOWER CASE  (LESS THAN)
*       ISPEC(6)  [   GOTO GREEK (OPEN SQUARE BRACKET)
*       ISPEC(7)  ]   GOTO ROMAN (CLOSE SQUARE BRACKET)
*       ISPEC(8)  &   BACKSPACE ONE CHARACTER (AND)
*       ISPEC(9)  "   GOTO SPECIAL SYMBOLS (QUOTES)
*       ISPEC(10) #   END OF SPECIAL SYMBOLS (NUMBER)
*       ISPEC(11) $   END OF SCAN CHARACTER (DOLLAR)
*
*     DATA ISPEC/1H!,1H?,1H^,1H>,1H<,1H[,1H],1H&,1H",1H#,1H$/
*
*       CORRESPONDENCE BETWEEN GREEK ALPHABET AND ROMAN ALPHABET
*
      DATA LGREEK/1,2,7,4,5,21,3,22,9,9,10,11,12,13,15,16,8,17,18
     +  ,19,20,22,24,14,23,6/
      DATA IFIRST/0/
*.______________________________________
*
+CDE, HIBIT.
      CALL UOPTC(CHOPT,'LCRS',IOPT)
      IF(IOPTL.NE.0)IGO=-1
      IF(IOPTC.NE.0)IGO=0
      IF(IOPTR.NE.0)IGO=1
      IF(IOPTS.NE.0)THEN
         IGO=2
         GOTO 10
      ENDIF
*
+SELF, IF=MAIL.
      CHOPTM=CHOPT
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZTEXT(X,Y,KTEXT,SSIZE,ANGLE,IOPT)
+SELF.
      IF((.NOT.GFLAG).AND.(.NOT.PFLAG))RETURN
*
      ZFSAV=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      IPLCIS=IPLCI
      ILNS=ILN
      RLWSAV=RLWSC
      CALL ISPLCI(ITXCI)
      CALL ISLN(1)
      CALL ISLWSC(1.)
*
   10 XMAX=99999.
      XLMAX=FLOARG(XMAX)
*
      IF(IPASS.EQ.0)THEN
         IF(IFIRST.EQ.0)THEN
            CALL UCTOH('abcdefghijklmnopqrstuvwxyz',IFORT,1,26)
            CALL UCTOH('ABCDEFGHIJKLMNOPQRSTUVWXYZ',IFORT(27),1,26)
            CALL UCTOH('0123456789.,/()-+=*$ ',IFORT(53),1,21)
            CALL UCTOH('!?^><[]&"#$',ISPEC,1,11)
            IFIRST=1
         ENDIF
         IPASS=1
         DO 20 I=1,84
+SELF, IF=-VAX, IF=-DECS, IF=-MSDOS, IF=-LINUX, IF=-PPC, IF=-WINNT.
            LL=JBYT(ITEXT(I),NBIT-NBITCH+1,NBITCH)
+SELF, IF=VAX,DECS,MSDOS,LINUX, IF=-PPC,WINNT.
            LL=MOD(ITEXT(I),256)
+SELF.
            IA(LL+1)=I-26
   20    CONTINUE
      ENDIF
*
      ISPEC(11)=IFORT(46)
      SIZE=FLOARG(SSIZE)
*
*             Unpacks text ,prepare angles and size
*
      IGOP=IGO
      ILEN=LENOCC(KTEXT)
      IF(KTEXT(ILEN:ILEN).EQ.'$')ILEN=ILEN-1
      CALL UCTOH(KTEXT,ITEXT,1,ILEN)
      IF(ANGLE.EQ.0.)THEN
         SI=0.
         CO=1.
      ELSE
         THE=FLOARG(ANGLE)*3.141592/180.
         IF(IGO.GE.2)THE=0.
         SI=SIN(THE)
         CO=COS(THE)
      ENDIF
      XPP=FLOARG(X)
      YPP=FLOARG(Y)
*
*             Set default values
*
   30 NDRAW  = 0
      KL     = 1
      KGREEK = 0
      KSPEC  = 0
      SCALE  = SIZE/21.
      RSCALE = SCALE
      IY0    = 9
      YOFF   = 0.
      WTOT   = 0.
      XW     = 0.
      YW     = 0.
      WDTH   = 0.
*
*             Start loop for each character to be drawn
*
      DO 270 ICHAR=1,ILEN
+SELF, IF=-VAX, IF=-DECS, IF=-MSDOS, IF=-LINUX, IF=-PPC, IF=-WINNT.
         IG=JBYT(ITEXT(ICHAR),NBIT-NBITCH+1,NBITCH)
+SELF, IF=VAX,DECS,MSDOS,LINUX, IF=-PPC,WINNT.
         IG=MOD(ITEXT(ICHAR),256)
+SELF.
         IC=IA(IG+1)
         IBIT=1
         IDIF=1
*
         IF(IC.GT.58)GOTO 260
         IF(IC.EQ.58)GOTO 280
         IF(IC.GT.47)GOTO 150
         IF(IC.EQ.47)GOTO 260
         IF(IC.EQ.46)GOTO 280
         IF(KSPEC.NE.0)GOTO 70
         IF(IC.GT.36)GOTO 50
         IF(IC.GT.26)GOTO 60
         IF(KGREEK.NE.0)GOTO 40
*
*             Roman alphabet
*
         IF(KL.LT.0)THEN
            IF(IC.LE.0)THEN
               ICHR=IC+141
            ELSE
               ICHR=IC+115
            ENDIF
         ELSE
            IF(IC.LE.0)THEN
               ICHR=IC+141
            ELSE
               ICHR=IC+10
            ENDIF
         ENDIF
         GOTO 80
*
*             Greek alphabet
*
   40    IF(KL.LT.0)THEN
            IF(IC.LE.0)THEN
               ICHR=LGREEK(IC+26)+141
            ELSE
               ICHR=LGREEK(IC)+141
            ENDIF
         ELSE
            IF(IC.LE.0)THEN
               ICHR=LGREEK(IC+26)+141
            ELSE
               ICHR=LGREEK(IC)+36
            ENDIF
         ENDIF
         GOTO 80
*
*             Mathematical symbols
*
   50    IF(KL.LT.0)THEN
            IF(IC.LE.0)THEN
               ICHR=191+IC
            ELSE
               ICHR=165+IC
            ENDIF
         ELSE
            IF(IC.LE.0)THEN
               ICHR=86+IC
            ELSE
               ICHR=60+IC
            ENDIF
         ENDIF
         GOTO 80
*
*             Digits  0--->9
*
   60    IF(KL.LT.0)THEN
            IF(IC.LE.0)THEN
               ICHR=IC+105
            ELSE
               ICHR=IC+79
            ENDIF
         ELSE
            IF(IC.LE.0)THEN
               ICHR=IC
            ELSE
               ICHR=IC-26
            ENDIF
         ENDIF
         GOTO 80
*
*             Special symbols
*
   70    IF(KL.LT.0)THEN
            IF(IC.LE.0)THEN
               ICHR=191+IC
            ELSE
               ICHR=165+IC
            ENDIF
         ELSE
            IF(IC.LE.0)THEN
               ICHR=191+IC
            ELSE
               ICHR=60+IC
            ENDIF
         ENDIF
*
*             Define scale and prepare absolute coordinates of vectors
*
   80    IF(ICHR.LE.0)GOTO 260
         IF(ICHR.GT.210)GOTO 260
         IF(KSPEC.EQ.0)GOTO 100
         IF(ICHR.EQ.9.OR.ICHR.EQ.18)GOTO 100
*
*             Redefine scale for special symbols
*
         IW=ISTART(ICHR)
         KYMIN=100
         KYMAX=-100
   90    IBIT=IBIT+6
         IF(IBIT.GE.NBITMX)THEN
            IBIT=1
            IW=IW+1
         ENDIF
*
         KX=JBYT(IX(IW),IBIT,6)-32
         KY=JBYT(IY(IW),IBIT,6)-32
         IF(KX.NE.31)THEN
            IF(KY.GT.KYMAX)KYMAX=KY
            IF(KY.LT.KYMIN)KYMIN=KY
            GOTO 90
         ENDIF
*
         IF(KY.NE.31)GOTO 90
         IY0=KYMAX
         DKY=KYMAX-KYMIN
         IF(DKY.EQ.0)DKY=21
         SCALE=SIZE/DKY
         RSCALE=SCALE
         IBIT=1
*
  100    IW=ISTART(ICHR)
+SELF, IF=CDC,CRAY.
         KX=JBYT(IX(IW),1,6)-32
         KY=JBYT(IY(IW),1,6)-32
+SELF, IF=-CDC, IF=-CRAY.
         KX=MOD(IX(IW),64)-32
         KY=MOD(IY(IW),64)-32
+SELF.
         WDTH=RSCALE*(KY-KX)
         IF(WTOT+WDTH.GT.XLMAX)GOTO 280
         WTOT=WTOT+WDTH
         IF(IGOP.NE.-1)NDRAW=1
         IF(IGOP.NE.-1)GOTO 270
         XW=WDTH*CO
         YW=WDTH*SI
         IX0=KX
         IF((KSPEC.NE.0).AND.(YOFF.NE.0))IY0=KY
         K=0
*
  110    IBIT=IBIT+6
         IDIF=IDIF*64
         IF(IBIT.GE.NBITMX)THEN
            IBIT=1
            IDIF=1
            IW=IW+1
         ENDIF
+SELF, IF=CDC,CRAY.
         KX=JBYT(IX(IW),IBIT,6)-32
         KY=JBYT(IY(IW),IBIT,6)-32
+SELF, IF=-CDC, IF=-CRAY.
         KX=MOD(IX(IW)/IDIF,64)-32
         KY=MOD(IY(IW)/IDIF,64)-32
+SELF.
         IF(KX.NE.31)THEN
            K=K+1
            KX=KX-IX0
            KY=IY0-KY
            XP(K)=KX*RSCALE*CO-(KY*RSCALE+YOFF)*SI+XPP
            YP(K)=KX*RSCALE*SI+(KY*RSCALE+YOFF)*CO+YPP
            GOTO 110
         ENDIF
*
*             Draw part of symbol
*
         IF(INPASS.LE.0)INPASS=1
         IF(MOD(INPASS,2).NE.0)THEN
            CALL IPL(K,XP,YP)
            III=(INPASS-1)/2
         ELSE
            III=INPASS/2
         ENDIF
         DO 140 IPASS=1,III
            DELTA=FLOAT(IPASS)*RCSHIF*SIZE
            DO 120 I=1,K
               XXP(I)=XP(I)-DELTA
               YYP(I)=YP(I)-DELTA
  120       CONTINUE
            CALL IPL(K,XXP,YYP)
            DO 130 I=1,K
               XXP(I)=XP(I)+DELTA
               YYP(I)=YP(I)+DELTA
  130       CONTINUE
            CALL IPL(K,XXP,YYP)
  140    CONTINUE
         NDRAW=NDRAW+1
         IF(KY.NE.31)THEN
            K=0
            GOTO 110
         ENDIF
*
*             Position cursor for next character
*
         XPP=XPP+XW
         YPP=YPP+YW
         GOTO 270
*
*             Control characters
*
  150    L1=IC-47
         GOTO (160,170,180,190,200,210,220,230,240,250),L1
*
*             Normal level of script
*
  160    YOFF=0.
         RSCALE=SCALE
         GOTO 270
*
*             Subscript
*
  170    YOFF=-0.25*SIZE
         RSCALE=0.5*SCALE
         GOTO 270
*
*             Superscript
*
  180    YOFF=0.75*SIZE
         RSCALE=0.5*SCALE
         GOTO 270
*
*             Upper case
*
  190    KL=1
         GOTO 270
*
*             Lower case
*
  200    KL=-1
         GOTO 270
*
*             Greek alphabet
*
  210    KGREEK=1
         GOTO 270
*
*             End of greek alphabet
*
  220    KGREEK=0
         GOTO 270
*
*             Backspace one character
*
  230    IF(NDRAW.LE.0)GOTO 270
         WTOT=WTOT-WDTH
         XPP=XPP-XW
         YPP=YPP-YW
         GOTO 270
*
*             GOTO special symbols
*
  240    KSPEC=1
         GOTO 270
*
*             End of special symbols
*
  250    KSPEC=0
         IY0=9
         SCALE=SIZE/21.
         RSCALE=SCALE
         IF(YOFF.NE.0)RSCALE=0.5*SCALE
         GOTO 270
*
*              Blank space
*
  260    IF(NDRAW.LE.0)GOTO 270
         WDTH=10.*RSCALE
         XW=WDTH*CO
         YW=WDTH*SI
         IF(WTOT+WDTH.GT.XLMAX)GOTO 280
         WTOT=WTOT+WDTH
         XPP=XPP+XW
         YPP=YPP+YW
*
  270 CONTINUE
*
*             Prepare parameters for a second pass if IGO.NE.-1
*
  280 IF(IGOP.EQ.-1)GOTO 310
      IF(IGOP.EQ.0)GOTO 290
      IF(IGOP.EQ.1)GOTO 300
*
*             Return text length in angle
*
      ANGLE=WTOT
      RETURN
*
*             Text is centered on x,y
*
  290 XPP=X-0.5*WTOT*CO
      YPP=Y-0.5*WTOT*SI
      IGOP=-1
      GOTO 30
*
*             Text is rigth adjusted on x,y
*
  300 XPP=X-WTOT*CO
      YPP=Y-WTOT*SI
      IGOP=-1
      GOTO 30
*
  310 CALL ISPLCI(IPLCIS)
      CALL ISLN(ILNS)
      CALL ISLWSC(RLWSAV)
      ZFLAG=ZFSAV
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      END
+DECK,  IGWKTY, T=FORT.
* Revision 1.4  1998/01/30 15:22:22  couet
* - APOLLO version removed
* Revision 1.3  1998/01/28 14:34:23  couet
* - GGDM driver removed
* Revision 1.2  1996/09/25 14:57:21  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:41  mclareni
* Higz

      SUBROUTINE IGWKTY(IWKTY)
*.===========>
*.
*.   This routine get the workstation type on the standard input
*.
*. _Output parameters:
*.
*.  INTEGER IWKTY : Workstation identifier choosen interactively
*.
*..==========> (O.Couet)
+SELF, IF=-BATCH.
+CDE, HIATT.
+SELF, IF=-BATCH.
+CDE, HIQUES.
+SELF, IF=X11,MSDOS.
+CDE, HIKERN.
+SELF, IF=-BATCH.
      CHARACTER*48 CHMESS
      CHARACTER*24 CHREP
+SELF, IF=CCREAD.
      CHARACTER*24 CHCC
+SELF, IF=IBM,AIX370.
      PARAMETER (LUNIN=5,LUNOUT=6)
+SELF, IF=DI3000, IF=VAX.
      CHARACTER*6 DRIVER
      CHARACTER*40 STRING
      INCLUDE '($SSDEF)'
+SELF, IF=DI3000, IF=IBM.
      INTEGER ARGLEN
      CHARACTER*100 ARGS
+SELF, IF=DECGKS, IF=VAX.
      CHARACTER*12 STRING
      INCLUDE '($SSDEF)'
+SELF, IF=DECGKS, IF=DECS.
      CHARACTER*12 STRING
+SELF, IF=X11, IF=IBM, IF=-IBMMVS.
      CHARACTER*3 CHLUN
+SELF, IF=X11.
      CHARACTER*80 CHWKTY(10)
      LOGICAL LOHOST
+SELF, IF=-BATCH.
      SAVE IFIRST
      DATA IFIRST /0/
+SELF.
*.______________________________________
*
+SELF, IF=-BATCH.
      IF(IFIRST.NE.0)THEN
         IWKTY = IDTY
         RETURN
      ELSE
         IFIRST = 1
      ENDIF
+SELF, IF=DI3000, IF=IBM.
      CALL GOPARM(ARGLEN,ARGS)
+SELF.
*
      CALL IGDWK(IWKTY)
      CHMESS = 'Workstation type (?=HELP) <CR>='
      LENC   = LENOCC(CHMESS)+1
      CALL IZITOC(IWKTY,CHMESS(LENC:))
*
+SELF, IF=-BATCH.
      LENC = LENOCC(CHMESS)
+SELF, IF=-IBM, IF=-AIX370, IF=-BATCH.
   10 PRINT 10002, CHMESS(1:LENC)
+SELF, IF=IBM,AIX370.
   10 WRITE (LUNOUT,'('' '',A,'' :'')') CHMESS(1:LENC)
+SELF, IF=-BATCH.
      CHREP = ' '
+SELF, IF=CCREAD.
      CALL IXGETL(LCC,CHCC)
      CHREP = CHCC(1:LCC)
+SELF, IF=-IBM, IF=-BATCH.
      READ 10003, CHREP
+SELF, IF=IBM.
      READ (LUNIN,'(A)',END=20) CHREP
+SELF, IF=-BATCH.
      IF(CHREP.EQ.' ')RETURN
      IF(INDEX(CHREP,'?').NE.0)THEN
         PRINT 10000
+SELF, IF=DI3000, IF=VAX.
         DO 100 I=1,9
           WRITE(DRIVER,'(A2,Z1,A3)') 'YD',I,'DRV'
           IF (SS$_NORMAL.EQ.LIB$SYS_TRNLOG(DRIVER,ICHAR,STRING)) THEN
              IF (STRING(ICHAR-6:ICHAR-4).NE.'DRV')
     +           PRINT 10001, I,STRING(ICHAR-6:ICHAR-4)
           ENDIF
  100    CONTINUE
+SELF, IF=DI3000, IF=IBM.
         CALL TRE0EU(ARGS,ARGLEN)
         I = 1
         J = 1
  100    CONTINUE
            INDX = INDEX(ARGS(J:),'DRV')
            IF (INDX.NE.0) THEN
               PRINT 10001, I,ARGS(J+INDX+2:J+INDX+4)
               I = I+1
               J = J+INDX
               GOTO 100
            ELSE
               PRINT 10001, I,'DI3000 driver menu'
            ENDIF
  200    CONTINUE
+SELF, IF=-BATCH.
         GOTO 10
      ENDIF
+SELF, IF=X11.
      IP     = INDEX(CHREP,'.')
      LOHOST = .FALSE.
      IF(IP.NE.0)THEN
         LOHOST = .TRUE.
         IF(IP+1.GT.LENOCC(CHREP))THEN
            FX11 = ' '
         ELSE
            FX11 = CHREP(IP+1:LENOCC(CHREP))
         ENDIF
         CHREP(IP:) = ' '
      ENDIF
      IF(CHREP(1:1).EQ.'M'.OR.CHREP(1:1).EQ.'m')THEN
         CALL IXSETHN(LENOCC(FX11),FX11(1:LENOCC(FX11)))
         IWKTY = 999
         RETURN
      ENDIF
+SELF, IF=-BATCH.
      CALL IZCTOI(CHREP,IWK)
      IF(IQUEST(1).NE.0)THEN
         PRINT*, ' Invalid workstation type'
         GOTO 10
      ENDIF
      IWKTY = IWK
+SELF, IF=X11.
      IF(LOHOST)THEN
         CALL IKFILE(IWK)
         OPEN(UNIT=LUNWIN,FILE=FILEN,FORM='FORMATTED'
     +,       STATUS='OLD',IOSTAT=ISTA)
         DO 30 I=1,10
            READ(LUNWIN,'(A)')CHWKTY(I)
   30    CONTINUE
         CLOSE(LUNWIN,STATUS='DELETE')
+SELF, IF=X11, IF=IBM, IF=-IBMMVS.
         WRITE(CHLUN,'(I3)')LUNWIN
         FILEN='FILEDEF '//CHLUN//'  CLEAR'
         CALL VMCMS(FILEN,ISTAT)
         FILEN = '/HIGZWIN DATA A'
+SELF, IF=X11.
         OPEN(UNIT=LUNWIN,FILE=FILEN,FORM='FORMATTED'
     +,       STATUS='NEW',IOSTAT=ISTA)
         DO 40 I=1,10
            IF(I.EQ.IWK)CHWKTY(I)(22:)=FX11
            WRITE(LUNWIN,'(A)')CHWKTY(I)(1:LENOCC(CHWKTY(I)))
   40    CONTINUE
         CLOSE(LUNWIN)
+SELF, IF=X11, IF=IBM, IF=-IBMMVS.
         WRITE(CHLUN,'(I3)')LUNWIN
         FILEN = 'FILEDEF '//CHLUN//'  CLEAR'
         CALL VMCMS(FILEN,ISTAT)
         FILEN = '/HIGZWIN DATA A'
+SELF, IF=X11.
      ENDIF
+SELF, IF=-BATCH.
      RETURN
+SELF, IF=IBM.
*
   20 REWIND(LUNIN)
+SELF, IF=-BATCH.
*
10000 FORMAT(' ',/,' List of valid workstation types:',/,
+SELF, IF=-DI3000, IF=-BATCH.
     +'       0:  Alphanumeric terminal',/,
+SELF, IF=GKSGRAL, IF=NEWLIB.
     +'    4714:  X-Terminal'/
     +'    4725:  Workstation/X-Terminal (2 Terminal Mode)'/
     +'    5003:  IBM Graphics Terminal (e.g. 3192 G)',/,
     +'    7878:  Falco Infinity Terminal',/,
     +'  470352:  Atari-Workstation via 7171',/,
     +'  471352:  Atari-Workstation via 7171 (full window)',/,
     +'  470353:  Atari-Workstation via Terminal Server',/,
     +'  471353:  Atari-Workstation via Terminal Server(full window)',/,
     +'    5005:  Macintosh IBM Emulator',/,
     +'    5010:  IBM 3820 Laserprinter LI1  (portrait-format)',/,
     +'    5020:  IBM 3820 Laserprinter LI1  (landscape-format)',/,
     +'    5011:  IBM Matrix-Printer PRINTER2',/,
     +'   13001:  QMS Laserprinter L1  (portrait-Format)',/,
     +'   13002:  QMS Laserprinter L1  (landscape-format)',/,
+SELF, IF=GKSGRAL, IF=-SUNGKS, IF=-ATCGKS, IF=-NEWLIB.
     +'     101:  Tektronix 4010, 4014',/,'     102:  Tektronix 4012',/,
     +'     103:  Tektronix 4014 with enhanced graphics option',/,
     +'     121:  Tektronix 4107, 4207, Pericom MX2000',/,
     +'     122:  Tektronix 4109',/,'     123:  Tektronix 4111',/,
     +'     125:  Tektronix 4113',/,'     127:  Tektronix 4115, Pericom
     +MX8000',/,'    7800:  MG600, MG200',/,'    7878:  Falco, Pericom
     +Graph Pac (old Pericom)',/,'    1020:  VT240',/,'    1030:  VT340'
     +,/,'  8601-6:  Vaxstation GPX',/,' 32120-9:  X-Window',/,
+SELF, IF=DI3000.
     +'      -1:  Alphanumeric terminal',/,
     +'       0:  DI3000 metafile',
+SELF, IF=DECGKS.
     +'       2:  GKSM Output metafile',/,
     +'       7:  CGM Output metafile',/,
     +'      13:  VT240 color',/,
     +'      14:  VT240 monochrome',/,
     +'      16:  VT330 ',/,
     +'      17:  VT340 color',/,
     +'      82:  Tek 4107, 4207, Pericom MX2000',/,
     +'      41:  Vaxstation',/,
     +'     211:  Vaxstation running DECWindows',/,
     +'      38:  LN03 Plus Laser Printer (Assign GKS$CONID)',/,
     +'      72:  Tektronix 4014 Emulators',/,
     +'      61:  Postscript Printers (Assign GKS$CONID)',/,
+SELF, IF=GK2000.
     +'     445:  Vaxstation',/,
     +'     102:  Tektronix 4014 Emulators',/,
     +'     105:  Macintosh Tektronix 4014 Emulator',/,
     +'     191:  Ramtek R25 4014 Emulator',/,
     +'     324:  LN03 Plus Laser Printer',/,
     +'     601:  Talaris Printers',/,
     +'     700:  Postscript Printers',/,
+SELF, IF=SUNGKS, IF=-ATCGKS.
     +'       3:  GKS Metafile Output (ASCII)',/,
     +'       4:  SUN Workstation',/,
     +'       6:  HP-GL Output',/,
     +'       7:  PostScript Output',/,
     +'       8:  CGM Output',/,
     +'      10:  GKS Metafile Output (binary)',/,
+SELF, IF=ATCGKS.
     +'    15nn:  QMS Lasergrafix (TALARIS) 8.5x11',/,
     +'           for TALARIS: Use PRINT/NOFORM/PASSALL <file>',/,
     +'    19nn:  POSTSCRIPT 8.5x11 Printer',/,
     +'    23nn:  Tektronix 4105 Terminals',/,
     +'    2400:  Tektronix 4014 Terminal',/,
     +'    2501:  Tektronix 4010 Terminal',/,
     +'    2502:  C-ITOH Terminals (201,414)',/,
     +'    2503:  Retrographics VT640',/,
     +'    2506:  GRAPHON 140, 230 Terminal',/,
     +'    25nn:  other Tektronix 4010 Types',/,
     +'    2600:  DEC VT125 Terminal',/,
     +'    2602:  DEC VT240 Terminal',/,
     +'    2603:  DEC VT330 Terminal',/,
     +'    2605:  DEC VT340 Color Terminal',/,
     +'    3100:  Tektronix 4107 Terminal',/,
     +'    3102:  Tektronix 4205 Terminal',/,
     +'    3104:  Tektronix 4208 Terminal',/,
     +'    315n:  4107-4208 (software segments)',/,
     +'    4300:  VAXstation II (not in Version 3.2)',/,
     +'    5300:  X-Windows',/,
     +'    5350:  X-Windows with refresh',/,
     +'    63nn:  IMAGEN 8.5x11 Printer',/,
     +'    66nn:  Tektronix 4510 Color Rasterizer',/,
     +'   10100:  Binary Output CG Metafile',/,
     +'   10110:  Character Output CG Metafile',/,
     +'   10120:  Clear Text Output CG Metafile',/,
+SELF, IF=GL,X11,MACMPW, IF=-MSDOS.
     +'    1-10:  Describe in file higz_windows.dat',/,
+SELF, IF=MSDOS, IF=NDP.
     +'       4:   320x200,  4 colors'/
     +'       5:   320x200,  4 colors'/
     +'       6:   640x200,  2 colors'/
     +'      13:   320x200, 16 colors'/
     +'      14:   640x200, 16 colors'/
     +'      15:   640x350,  2 colors'/
     +'      16:   640x350, 16 colors'/
     +'      17:   640x480,  2 colors'/
     +'      18:   640x480, 16 colors'/
     +'      19:   320x200,256 colors'/
     +    /
     +' SuperVGA:   800x600  16 colors:'//
     +'       41:   Tseng chipset            98:   Video Seven       '/
     +'       88:   Paradise                100:   Renaissance GRX   '/
+SELF, IF=MSDOS, IF=-NDP.
     +'      >0:  Graphics option is pre-selected by the'/,
     +'           GO32 environment variable'/
+SELF, IF=X11.
     +'  n.host:  Open the display on host (1 < n < 10)',/,
+SELF, IF=FALCO.
     +'    7878:  FALCO terminal',/,
     +'    7879:  xterm',/,
+SELF, IF=GKSBX.
     +'    8811:  GKSBx-X11',/,
+SELF, IF=PHIGS.
     +'    8887:  GPHIGS-X11',/,'    7176:  GPHIGS-GL',/,
     +'    8384:  GPHIGS-Starbase',/,'    8871:  GPHIGS-Xgl',/,
     +'    7188:  GPEX',/,
+SELF, IF=-BATCH.
     +' ')
+SELF, IF=DI3000.
10001 FORMAT(I8,':  ',A)
+SELF, IF=-IBM, IF=-AIX370, IF=-BATCH.
10002 FORMAT(' ',A,' : ',$)
+SELF, IF=-IBM, IF=-BATCH.
10003 FORMAT(A)
+SELF.
      END
+DECK,  IGXMES, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:41  mclareni
* Higz

      SUBROUTINE IGXMES(IX,IY,NC,N,CHMESS,CHTIT,CHOPT)
+SELF, IF=X11.
+CDE, HIKERN.
+SELF.
      CHARACTER*(*) CHMESS(N),CHTIT,CHOPT
+SELF, IF=X11.
      DIMENSION IOPT(4)
      EQUIVALENCE (IOPT(1) ,IOPTP),(IOPT(2) ,IOPTC)
      EQUIVALENCE (IOPT(3) ,IOPTD),(IOPT(4) ,IOPTL)
      CHARACTER*32 FX11M
      SAVE IOPEN,IDMES,IW,IH,FX11M,ISIZE,NLINE
      DATA IOPEN /0/
      DATA ISIZE /12/
      DATA IH /0/
+SELF.
*.______________________________________
*
+SELF, IF=X11.
      CALL UOPTC (CHOPT,'PCDL',IOPT)
*
*              Print the array CHMESS and open the message
*              window if necessary.
*
      IF(IOPTP.NE.0)THEN
         CALL IXSAVWI
*
* Open the window if necessary
*
         IF(IOPEN.EQ.0)THEN
            NLINE=N
   10       FX11M='-*-courier-bold-r-normal--'
            LONG=LENOCC(FX11M)
            CALL IZITOC(ISIZE,FX11M(LONG+1:))
            LONG=LENOCC(FX11M)+1
            FX11M(LONG:LONG)='*'
            IF(IXSETTF(1,LENOCC(FX11M),FX11M).NE.0)THEN
               IF(ISIZE.EQ.20)THEN
                  CALL IGERR('X11 fonts not available','IGMESS')
                  ISIZE=0
                  RETURN
               ENDIF
               ISIZE=ISIZE+1
               GOTO 10
            ENDIF
+SELF, IF=X11, IF=IBM.
            CALL CLTOU(CHMESS(1))
+SELF, IF=X11.
            CALL IXTXTL(IW,IH,NC,CHMESS(1))
+SELF, IF=X11, IF=IBM.
            CALL CUTOL(CHMESS(1))
+SELF, IF=X11.
            WINSIZ(1) = IX
            WINSIZ(2) = IY
            WINSIZ(3) = IW+10
            WINSIZ(4) = NLINE*(IH+5)+5
            IF(IOPTL.NE.0)WINSIZ(1) = WINSIZ(1)-WINSIZ(3)
            IFLAG=1
            IDMES=IXOPNWI(WINSIZ(1),WINSIZ(2),WINSIZ(3),WINSIZ(4),
     +                    LENOCC(CHTIT),CHTIT,IFLAG)
            IF(IDMES.LT.0)THEN
               CALL IGERR('Can''t open WINDOW','IGMESS')
               RETURN
            ENDIF
            CALL IXS2BUF(IDMES,1)
            CALL IXUPDWI(1)
            IOPEN=1
         ENDIF
*
* Rescale the window if necessary
*
         IF(N.GT.NLINE)THEN
            NLINE = N
            IWW   = IW+10
            IHH   = NLINE*(IH+5)+5
            CALL IXRSCWI(IDMES,IWW,IHH)
         ENDIF
*
* Perform the output
*
         CALL IZSAVA
         CALL IXSELWI(IDMES)
         CALL IXNOCLI(IDMES)
         CALL IXCLRWI
         CALL ISTXAL(0,0)
         CALL ISTXCI(1)
         IF(ISIZE.NE.0)THEN
            IFPX11=IXSETTF(1,LENOCC(FX11M),FX11M)
         ELSE
            RETURN
         ENDIF
         IYT=5+IH
         DO 20 I=1,N
            CALL IXTEXT(0,5,IYT,0.,1.,NC,CHMESS(I))
            IYT=IYT+5+IH
   20    CONTINUE
         CALL IXUPDWI(1)
         CALL IXSETWI
         CALL IZSETA
      ENDIF
*
*              Close the message window.
*
      IF(IOPTC.NE.0.AND.IOPEN.NE.0)THEN
         CALL IXSAVWI
         CALL IXSELWI(IDMES)
         CALL IXCLSWI
         CALL IXUPDWI(1)
         IOPEN=0
         CALL IXSETWI
      ENDIF
*
*              Clear the message window.
*
      IF(IOPTD.NE.0)THEN
         CALL IXSAVWI
         CALL IXSELWI(IDMES)
         CALL IXCLRWI
         CALL IXUPDWI(1)
         CALL IXSETWI
      ENDIF
+SELF.
*
      END
+DECK,  IGZSET, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:41  mclareni
* Higz

      SUBROUTINE IGZSET(CHOPT)
*.===========>
*.
*.   This routine sets the HIGZ working mode.
*.
*. _Input parameters:
*.
*.  CHARACTER CHOPT : Option to be set .
*.
*.                    CHOPT='G'raphics mode ON
*.                    CHOPT='Z'ebra mode ON, 'G' becomes OFF
*.                    CHOPT='X' Zebra mode OFF and leave 'G'
*.                    CHOPT='S'ave the current state of the FLAGS
*.                    CHOPT='R'estore the last state saved
*.                    CHOPT='E'xpand mode: in this mode attributes
*.                           are stored in the pictures without checking
*.                           if the current value is the same. This
*.                           allows to have each primitive with its
*.                           attributes.
*.                    CHOPT='C'ompress (.NOT.'E')
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
      CHARACTER*(*) CHOPT
      DIMENSION IOPT(7)
      EQUIVALENCE (IOPTG,IOPT(1)) , (IOPTZ,IOPT(2))
      EQUIVALENCE (IOPTS,IOPT(3)) , (IOPTR,IOPT(4))
      EQUIVALENCE (IOPTE,IOPT(5)) , (IOPTC,IOPT(6))
      EQUIVALENCE (IOPTX,IOPT(7))
      LOGICAL ZFLAGS,GFLAGS
      SAVE ZFLAGS,GFLAGS
*.______________________________________
*
      CALL UOPTC(CHOPT,'GZSRECX',IOPT)
*
      IF(IOPTE.NE.0)THEN
         CFLAG = .FALSE.
         RETURN
      ENDIF
      IF(IOPTC.NE.0)THEN
         CFLAG = .TRUE.
         RETURN
      ENDIF
*
      IF(IOPTS.NE.0)THEN
         ZFLAGS = ZFLAG
         GFLAGS = GFLAG
         RETURN
      ENDIF
*
      IF(IOPTX.NE.0)THEN
         ZFLAG  = .FALSE.
         GOTO 10
      ENDIF
*
      IF(IOPTR.NE.0)THEN
         IF (ZFLAGS) IOPTZ = 1
         IF (GFLAGS) IOPTG = 1
      ENDIF
*
      GLFLAG = .FALSE.
      GFLAG  = .FALSE.
      ZFLAG  = .FALSE.
*
      IF ((IOPTG.NE.0).AND.(.NOT.MFLAG)) GFLAG = .TRUE.
      IF (IOPTZ.NE.0) ZFLAG = .TRUE.
   10 GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IML, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:41  mclareni
* Higz

      SUBROUTINE IML(N,X,Y)
*.===========>
*.
*.   This routine draws a multiline .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of points in the polyline .
*.  REAL X(N) : X coordinates .
*.  REAL Y(N) : Y coordinates .
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
      DIMENSION X(*),Y(*)
      LOGICAL ZSAV
*.______________________________________
*
      IF(N.LT.2)THEN
         CALL IGERR('Invalid number of points','IML')
         RETURN
      ENDIF
*
      NI=N
      IF(MOD(NI,2).NE.0)THEN
         NI=NI-1
      ENDIF
      NI=NI/2
      IF(GFLAG)THEN
         CALL IGSG(0)
         ZSAV=ZFLAG
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         DO 10 I=1,NI
            CALL IPL(2,X(2*I-1),Y(2*I-1))
   10    CONTINUE
         ZFLAG=ZSAV
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      ENDIF
+SELF, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZML(N,X,Y)
+SELF.
*
      END
+DECK,  IPM4ID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:41  mclareni
* Higz

      SUBROUTINE IPM4ID(N,X,Y,Z,C,CMIN,CMAX,LEVEL,ID)
+CDE, HIATT.
+CDE, HIGRAF.
+CDE, HIHIST.
+CDE, HI3D.
+CDE, HIFLAG.
      DIMENSION X(*),Y(*),Z(*),C(*),ID(*)
      DIMENSION IDD(NPMAX)
      EQUIVALENCE (XWORK(1),IDD(1))
*
      IF(INBCOL.GT.8)THEN
         ICOFF = 8
      ELSE
         ICOFF = 1
      ENDIF
      DC = (CMAX-CMIN)/(INBCOL-ICOFF)
*
      IF (IDIM.EQ.3) THEN
+SELF, IF=PHIGS.
         CALL PPM3(N,X,Y,Z)
+SELF.
      ELSE
         DO 20 IC=ICOFF,INBCOL-1
            NGRAF = 0
            CALL ISPMCI(IC)
            DO 10 I=1,N
               INCOL = INT((C(I)-CMIN)/DC)+ICOFF
               IF(INCOL.EQ.IC)THEN
                  NGRAF        = NGRAF+1
                  XGRAF(NGRAF) = AWNX*X(I)+BWNX*Y(I)+CWNX*Z(I)+DWNX
                  YGRAF(NGRAF) = AWNY*X(I)+BWNY*Y(I)+CWNY*Z(I)+DWNY
                  ZGRAF(NGRAF) = AWNZ*X(I)+BWNZ*Y(I)+CWNZ*Z(I)+DWNZ
                  IDD(NGRAF)   = ID(I)
               ENDIF
               IF(NGRAF.EQ.NPMAX.OR.I.EQ.N)THEN
                  CALL IPM(NGRAF,XGRAF,YGRAF)
                  IF(ZFLAG)CALL IGADID(LEVEL,NGRAF,IDD)
                  NGRAF = 0
               ENDIF
   10       CONTINUE
   20    CONTINUE
      ENDIF
*
      END
+DECK,  IPMID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:41  mclareni
* Higz

      SUBROUTINE IPMID(N,X,Y,LEVEL,ID)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
      DIMENSION X(*),Y(*),ID(*)
*.______________________________________
*
      CALL IPM(N,X,Y)
      IF(ZFLAG)CALL IGADID(LEVEL,N,ID)
*
      END
+PATCH, IFALCO.
+DECK,  IFCLIP, T=FORT.
* Revision 1.2  1996/03/07 17:38:07  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz

      SUBROUTINE IFCLIP(X1,Y1,X2,Y2,FLAG)
+CDE, HIFC2.
      LOGICAL FLAG
      IF (X1.LT.X2) THEN
         IF (X1.LT.XMIN) THEN
            Y1=Y1+(XMIN-X1)*(Y2-Y1)/(X2-X1)
            X1=XMIN
         END IF
         IF (XMAX.LT.X2) THEN
            Y2=Y2-(X2-XMAX)*(Y2-Y1)/(X2-X1)
            X2=XMAX
         END IF
      END IF
      IF (X2.LT.X1) THEN
         IF (X2.LT.XMIN) THEN
            Y2=Y2+(XMIN-X2)*(Y1-Y2)/(X1-X2)
            X2=XMIN
         END IF
         IF (XMAX.LT.X1) THEN
            Y1=Y1-(X1-XMAX)*(Y1-Y2)/(X1-X2)
            X1=XMAX
         END IF
      END IF
      FLAG=.TRUE.
      IF (Y1.LT.YMIN.AND.Y2.LT.YMIN) RETURN
      IF (YMAX.LT.Y1.AND.YMAX.LT.Y2) RETURN
      FLAG=.FALSE.
      IF (Y1.LT.Y2) THEN
         IF (Y1.LT.YMIN) THEN
            X1=X1+(YMIN-Y1)*(X2-X1)/(Y2-Y1)
            Y1=YMIN
         END IF
         IF (YMAX.LT.Y2) THEN
            X2=X2-(Y2-YMAX)*(X2-X1)/(Y2-Y1)
            Y2=YMAX
         END IF
      END IF
      IF (Y2.LT.Y1) THEN
         IF (Y2.LT.YMIN) THEN
            X2=X2+(YMIN-Y2)*(X1-X2)/(Y1-Y2)
            Y2=YMIN
         END IF
         IF (YMAX.LT.Y1) THEN
            X1=X1-(Y1-YMAX)*(X1-X2)/(Y1-Y2)
            Y1=YMAX
         END IF
      END IF
      END
+DECK,  IFCLR, T=FORT.
* Revision 1.2  1996/03/07 17:38:08  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz

      SUBROUTINE IFCLR(IWTYP)
      IF(IWTYP.EQ.7878)THEN
         CALL IFPUT(29)
         CALL IFPUT(27)
         CALL IFPUT(12)
         CALL IFPUT(0)
         CALL IFPUT(31)
         CALL IFPUT(24)
         CALL IFPUT(0)
      ELSEIF(IWTYP.EQ.7879)THEN
         CALL IGSG(0)
         CALL IFPUT(27)
         CALL IFPUT(12)
         CALL IFPUT(0)
         CALL IGSA(0)
      ENDIF
      END
+DECK,  IFDRAW, T=FORT.
* Revision 1.2  1996/03/07 17:38:08  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz

      SUBROUTINE IFDRAW(X,Y)
+CDE, HIFC2.
+CDE, HIFC3.
      LOGICAL FLAG1
      LOGICAL FLAG2,FLAG3
      XS=XL
      YS=YL
      FLAG2=FLAG1
      XL=X
      YL=Y
      FLAG1=X.LT.XMIN.OR.XMAX.LT.X.OR.Y.LT.YMIN.OR.YMAX.LT.Y
      IF (FLAG2.AND.FLAG1) THEN
         IF (XS.LT.XMIN.AND.X.LT.XMIN) RETURN
         IF (XMAX.LT.XS.AND.XMAX.LT.X) RETURN
         IF (YS.LT.YMIN.AND.Y.LT.YMIN) RETURN
         IF (YMAX.LT.YS.AND.YMAX.LT.Y) RETURN
      END IF
      XT=X
      YT=Y
      FLAG3=.FALSE.
      IF (FLAG2.OR.FLAG1) CALL IFCLIP(XS,YS,XT,YT,FLAG3)
      IF (FLAG3) RETURN
      IF (FLAG2) CALL IFMOV6(XS,YS)
      IX=IFIX(FX*(XT-XMIN)+.5)+IXMIN
      IY=IFIX(FY*(YT-YMIN)+.5)+IYMIN
      CALL IFDRW9(IX,IY)
      XD=IX
      YD=IY
      END
+DECK,  IFDRW9, T=FORT.
* Revision 1.2  1996/03/07 17:38:09  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz

      SUBROUTINE IFDRW9(IX,IY)
+CDE, HIFC1.
+CDE, HIFC6.
      DATA IYLL,IXHL,IYXL/-1,-1,-1/
      IF (IX.LT.0) RETURN
      IF (IY.LT.0) RETURN
      IF (131071.LT.IX) RETURN
      IF (ISFL.EQ.0) RETURN
      IXN=IX/128
      IYN=IY/128
      IXH=IXN/32
      IXL=IXN-32*IXH
      IYH=IYN/32
      IYL=IYN-32*IYH
      CALL IFPUT(IYH+32)
      IF (ISCR.EQ.4) THEN
         IYX=4*((IY-128*IYN)/32)+(IX-128*IXN)/32
         IF (IYX.NE.IYXL) CALL IFPUT(IYX+96)
         IF (IYX.NE.IYXL.OR.IYL.NE.IYLL.OR.IXH.NE.IXHL) THEN
            CALL IFPUT(IYL+96)
            IYLL=IYL
         END IF
         IYXL=IYX
      ELSE
         IF (IYL.NE.IYLL.OR.IXH.NE.IXHL) THEN
            CALL IFPUT(IYL+96)
            IYLL=IYL
         END IF
      END IF
      IF (IXH.NE.IXHL) THEN
         CALL IFPUT(IXH+32)
         IXHL=IXH
      END IF
      CALL IFPUT(IXL+64)
      IF (240.LT.IPOUT) THEN
         CALL IFPUT(0)
         CALL IFPUT(29)
         CALL IFPUT(IYH+32)
         CALL IFPUT(IYL+96)
         CALL IFPUT(IXH+32)
         CALL IFPUT(IXL+64)
      END IF
      END
+DECK,  IFINIT, T=FORT.
* Revision 1.2  1996/03/07 17:38:10  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz

      SUBROUTINE IFINIT
+CDE, HIFC1.
+CDE, HIFC6.
+SELF, IF=VAX.
      CALL IFIOI
+SELF.
      ISFL=1
      ISCR=0
      IPOUT=0
      CALL IFVWIN(0.,131071.,0.,100160.)
      CALL IFSWIN(0,131071,0,100160)
      END
+DECK,  IFMOV6, T=FORT.
* Revision 1.2  1996/03/07 17:38:11  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFMOV6(X,Y)
+CDE, HIFC2.
      IX=IFIX(FX*(X-XMIN)+.5)+IXMIN
      IY=IFIX(FY*(Y-YMIN)+.5)+IYMIN
      CALL IFMOV9(IX,IY)
      XD=IX
      YD=IY
      END
+DECK,  IFMOV9, T=FORT.
* Revision 1.2  1996/03/07 17:38:12  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFMOV9(IX,IY)
+CDE, HIFC1.
+CDE, HIFC6.
      MFL=1
      IF (ISFL.NE.0) CALL IFPUT(29)
      CALL IFDRW9(IX,IY)
      END
+DECK,  IFMOVE, T=FORT.
* Revision 1.2  1996/03/07 17:38:13  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFMOVE(X,Y)
+CDE, HIFC2.
+CDE, HIFC3.
      LOGICAL FLAG1
      XL=X
      YL=Y
      FLAG1=X.LT.XMIN.OR.XMAX.LT.X.OR.Y.LT.YMIN.OR.YMAX.LT.Y
      IF (FLAG1) RETURN
      CALL IFMOV6(X,Y)
      END
+DECK,  IFPL, T=FORT.
* Revision 1.2  1996/03/07 17:38:14  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFPL(N,X,Y)
+CDE, HIATT.
      DIMENSION X(*),Y(*)
      XFALCO=(RVXMIN+XRATIO*(X(1)-RWXMIN))
      YFALCO=(RVYMIN+YRATIO*(Y(1)-RWYMIN))
      CALL IFMOVE(XFALCO,YFALCO)
      DO 10 I=2,N
         XFALCO=(RVXMIN+XRATIO*(X(I)-RWXMIN))
         YFALCO=(RVYMIN+YRATIO*(Y(I)-RWYMIN))
         CALL IFDRAW(XFALCO,YFALCO)
   10 CONTINUE
      CALL IFPUT(0)
      END
+DECK,  IFPUT, T=FORT.
* Revision 1.2  1996/03/07 17:38:15  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFPUT(N)
+CDE, HIFC6.
+SELF, IF=IBM,VAX.
      LOGICAL*1 BOUT(256)
+SELF, IF=-IBM, IF=-VAX.
      INTEGER BOUT(256)
+SELF.
      SAVE BOUT
      IPOUT=IPOUT+1
      BOUT(IPOUT)=N
+SELF, IF=IBM.
      IF (N.EQ.127) THEN
*        Ignore deletes
         BOUT(IPOUT)=27
         IPOUT=IPOUT+1
         BOUT(IPOUT)=63
      END IF
+SELF.
*  If Char is <= 0 then we output the line.
      IF (N.GT.0) RETURN
      BOUT(IPOUT)=31
*  If Char = 0 then switch to alpha mode, else just output.
      IF (N.EQ.-1) IPOUT=IPOUT-1
      IF (2.LT.IPOUT) CALL IFPUT1(BOUT,IPOUT)
      BOUT(1)=29
      IPOUT=1
      END
+DECK,  IFPUT1, T=FORT.
* Revision 1.3  1996/03/12 08:29:23  cernlib
* Compile ifput1.F only on VAX and IBM.
* Revision 1.2  1996/03/07 17:38:16  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

+SELF, IF=VAX.
      SUBROUTINE IFPUT1(BOUT,IPOUT)
      LOGICAL*1 BOUT(256)
      INTEGER SYS$ASSIGN,SYS$QIOW,STAT(2)
      N=SYS$QIOW(,%VAL(ICHAN),%VAL(304),
     *%REF(STAT),,,%REF(BOUT),%VAL(IPOUT),,,,)
      RETURN
      ENTRY IFIOI
      N=SYS$ASSIGN('SYS$OUTPUT',ICHAN,,)
      END
+SELF, IF=IBM.
      SUBROUTINE IFPUT1(ICOUNT,BUFF)
      INTEGER BUFF(1)
      INTEGER*2 I1,I3,I4
      INTEGER*4 IT
      LOGICAL*1 LT(4),LBUFF(256)
      EQUIVALENCE (IT,LT(1))
      DO 10 I=1,ICOUNT
         IT=BUFF(I)
         LBUFF(I)=LT(4)
   10 CONTINUE
      I1=2
      I3=ICOUNT
      CALL TIF71(I1,LBUFF,I3,I4)
      ISTAT=I4
      END
+SELF.
+DECK,  IFSCUR, T=FORT.
* Revision 1.2  1996/03/07 17:38:18  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFSCUR(ICHR,XLOC,YLOC)
+CDE, HIFC2.
      CHARACTER*16 STR
      ICHR=0
* Setup to find end of input
      STR=' '
* Put into GIN mode
      CALL IFPUT(27)
      CALL IFPUT(26)
      CALL IFPUT(-1)
      ISIZ=0
* Read the GIN string (Echoing is suppressed)
      READ(*,'(A)',END=99,ERR=99) STR
   10 CONTINUE
* IF <CR> pressed (Note it will be echoed now)
      IF (STR.EQ.' ') THEN
        READ(*,'(A)',END=99,ERR=99) STR(2:)
   20   CONTINUE
      ENDIF
* Find end of input
      ISIZ=INDEX(STR(2:),' ')
      IF (ISIZ.NE.5) RETURN
* Now get workstation Viewport coordinates.
      XLOC=128*(32*MOD(ICHAR(STR(2:2)),32)+MOD(ICHAR(STR(3:3)),32))
      YLOC=128*(32*MOD(ICHAR(STR(4:4)),32)+MOD(ICHAR(STR(5:5)),32))
* Now get Workstation window coordinates.
      XLOC=(XLOC-IXMIN)/FX+XMIN
      YLOC=(YLOC-IYMIN)/FY+YMIN
      ICHR=ICHAR(STR(1:1))
   99 CALL IFPUT(0)
      END
+DECK,  IFSWIN, T=FORT.
* Revision 1.2  1996/03/07 17:38:19  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFSWIN(N1,N2,N3,N4)
+CDE, HIFC2.
      IXMIN=N1
      IXMAX=N2
      IYMIN=N3
      IYMAX=N4
      FX=FLOAT(IXMAX-IXMIN)/(XMAX-XMIN)
      FY=FLOAT(IYMAX-IYMIN)/(YMAX-YMIN)
      END
+DECK,  IFVWIN, T=FORT.
* Revision 1.2  1996/03/07 17:38:19  couet
* IFALCO selection was wrong
* Revision 1.1.1.1  1996/02/14 13:10:31  mclareni
* Higz

      SUBROUTINE IFVWIN(P1,P2,P3,P4)
+CDE, HIFC2.
      XMIN=P1
      XMAX=P2
      YMIN=P3
      YMAX=P4
      FX=FLOAT(IXMAX-IXMIN)/(XMAX-XMIN)
      FY=FLOAT(IYMAX-IYMIN)/(YMAX-YMIN)
      END
+PATCH, IDI3000.
+DECK,  IACWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:27  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IACWK(WKID)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Select a display device
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JDEVON (DEVICE)
*.
*.   Parameters:
*.   -----------
*.     DEVICE                     [ INTEGER; Input ]
*.
*.      - Display device to be selected.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIMETA.
+CDE, HIATT.
      INTEGER WKID
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
+CDE, DI3SEG.
*.______________________________________
*
      IF(WKID.LT.0)THEN
         CALL IGERR('Workstation identifier less than 0','IACWK')
         RETURN
      ENDIF
*
*           Select a display device
*
      IF (DEVICES(WKID).EQ.1) THEN
         IF (SEGOPN) THEN
            CALL JCLOSE
            SEGOPN =.FALSE.
         ENDIF
         CALL JDEVON (WKID)
         DEVICES(WKID) = 2
         INOPWK=INOPWK+1
         IF (WKID.EQ.0) THEN
            METACT = .TRUE.
         ELSE
            TEKACT = .TRUE.
         ENDIF
      ELSE IF (DEVICES(WKID).EQ.0) THEN
         CALL IGERR('Workstation not initialized','IACWK')
      ENDIF
*
      END
+SELF.
+DECK,  ICLKS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:27  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ICLKS
*.===========>
*.
*.   Purpose:
*.   --------
*.     Terminate DI-3000.
*.     User does not need to call this routine, but should call IGEND directly.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, DI3DEV.
*.______________________________________
*
      IF (ENTRY_FLAG) CALL JEND
      ENTRY_FLAG = .FALSE.
*
      END
+SELF.
+DECK,  ICLRWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ICLRWK(WKID,ICOFL)
*.===========>
*.
*.   Purpose:
*.   --------
*.      Force an explicit new frame action on all initalized
*.      display devices
*.
*.   Parameters:
*.   -----------
*.        No parameters
*.        JFRAME may not be called while a segment is OPEN.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIFLAG.
      INTEGER WKID
+CDE, DI3SEG.
*.______________________________________
*
      IF(IGIWTY(WKID).LT.0)GOTO 20
      IF(GFLAG)THEN
         CALL IGSG(0)
         IF(WKID.GE.0)THEN
            IF (SEGOPN) THEN
               CALL JUPDAT
               CALL JCLOSE
               SEGOPN =.FALSE.
            ENDIF
            CALL JFRAME
         ENDIF
      ENDIF
  20  CONTINUE
+SELF, IF=DI3000, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZCLRD
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ICLWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ICLWK(WKID)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Terminate a display device
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JDEND (DEVICE)
*.
*.   Parameters:
*.   -----------
*.     DEVICE                     [ INTEGER; Input ]
*.
*.      - Display device to be terminated.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIMETA.
+CDE, HIATT.
+CDE, HIFLAG.
+SELF, IF=DI3000, IF=PSCRIPT.
+CDE, HIPOST.
+SELF, IF=DI3000.
      INTEGER WKID
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
+CDE, DI3SEG.
*.______________________________________
*
+SELF, IF=DI3000, IF=PSCRIPT.
      IF(IGIWTY(WKID).LT.0)THEN
         CALL IPEND
         GOTO 1
      ENDIF
+SELF, IF=DI3000.
*
      CALL IGSG (0)
 1    IF (SEGOPN) THEN
         CALL JUPDAT
         CALL JCLOSE
         SEGOPN = .FALSE.
      ENDIF
      IF (DEVICES(WKID).NE.0) THEN
         IF (DEVICES(WKID).EQ.2) THEN
            CALL JFRAME
            CALL JDEVOF(WKID)
            INOPWK=INOPWK-1
         ENDIF
         CALL JDEND(WKID)
         DEVICES(WKID) = 0
         IF (WKID.EQ.0) THEN
            METACT = .FALSE.
         ELSE
            TEKACT = .FALSE.
            DO 10 I = 1 , MAXDEV
   10       TEKACT = TEKACT .OR. (DEVICES(I).NE.0)
         ENDIF
      ENDIF
*
      END
+SELF.
+DECK,  IDAWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IDAWK(WKID)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Deselect a display device.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JDEVOF (DEVICE)
*.
*.   Parameters:
*.   -----------
*.     DEVICE                     [ INTEGER; Input ]
*.
*.      - Display device to be deselected.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIMETA.
+CDE, HIFLAG.
+CDE, HIATT.
      INTEGER WKID
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
+CDE, DI3SEG.
*.______________________________________
*
      IF(IGIWTY(WKID).LT.0)THEN
         PFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         RETURN
      ENDIF
C
C     ***** Deselect DEVICE, disabling output to
C     ***** and input from DEVICE
C
      IF (SEGOPN) THEN
         CALL JUPDAT
         CALL JCLOSE
         SEGOPN = .FALSE.
      ENDIF
      IF (DEVICES(WKID).EQ.2) THEN
         CALL JFRAME
         CALL JDEVOF(WKID)
         DEVICES(WKID) = 1
         INOPWK=INOPWK-1
         IF (WKID.EQ.0) THEN
            METACT = .FALSE.
         ELSE
            TEKACT = .FALSE.
            DO 10 I = 1 , MAXDEV
   10       TEKACT = TEKACT .OR. (DEVICES(I).NE.0)
         ENDIF
      ENDIF
*
      END
+SELF.
+DECK,  IFA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IFA(N,X,Y)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Output a polygon.
*.
*.    ***** Define closed area polygon of N points; move to the first point,
*.    ***** contiguous draws through the following points,  and an implicit
*.    ***** draw from the Nth point back to the first point.
*.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JPOLGN (X, Y, N)
*.
*.   Parameters:
*.   -----------
*.
*.     X, Y                       [ REAL; Array; Input ]
*.
*.      - The arrays of world coordinates defining the polygon
*.
*.     N                          [ INTEGER; Input ]
*.
*.      - The number of points in the polygon.  The above parameters
*.        should be DIMENSIONed to at least N in the calling routine
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIFLAG.
+CDE, HIATT.
      REAL X(1),Y(1)
+CDE, DI3SEG.
*.______________________________________
*
      IF(IFAIS.EQ.3.AND.IFASI.GE.100)THEN
         CALL IGFA(N,X,Y)
      ELSE
         IF(GFLAG)THEN
            CALL IGSG(0)
            IF (.NOT. SEGOPN) THEN
               CALL JOPEN
               SEGOPN=.TRUE.
            ENDIF
            CALL JPOLGN (X, Y, N)
         ENDIF
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZFA(N,X,Y)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  IGMETA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IGMETA (IUNIT,METAFL)
*.===========>
*.
*.   To OPEN, activate, deactivate and close metafile or screen
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
      INTEGER WKID
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
*._____________________________
*
*
      WKID = METAFL
      IF (IUNIT.EQ.0) THEN
         CALL IDAWK(WKID)
         IF (WKID.NE.IDID) CALL ICLWK(WKID)
      ELSE IF (IUNIT.EQ.1) THEN
         CALL IOPWK(WKID,0,WKID)
         CALL IACWK(WKID)
      ELSE
         CALL IGERR('Invalid ON/OFF flag (0/1)','IGMETA')
      ENDIF
*
 999  END

+SELF.
+DECK,  IGRNG, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IGRNG(XSIZ,YSIZ)
*.==========>
*.
*.   This routines returns the screen range and map the workstation window
*. on the whole screen. If the screen is not a square a part of the NDC space
*. is not visible .
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Worsktation identifier .
*.  REAL XMAX YMAX : Screen range .
*.
*..=========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIPAW.
+SELF, IF=DI3000, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=DI3000, IF=MAIL.
+CDE, HIFLAG.
+SELF, IF=DI3000.
+CDE, HIATT.
+CDE, HIMETA.
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)

+CDE, DI3SEG.
      INTEGER WKID
      REAL XMAX,YMAX
      INTEGER LIST
      DIMENSION LIST(4)
      REAL MAXDIM(4)
      LOGICAL PHYS
*.______________________________________
*
+SELF, IF=DI3000, IF=MAIL.
*
*              Mail option
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(I3,2E16.7)') 201,XSIZ,YSIZ
         CALL IMWRIT(1)
         READ (5,'(5E15.6)') RQUEST(11),RQUEST(12),RQUEST(13)
     +,                      RQUEST(14),RQUEST(15)
         CALL IMWRIT(5)
         MFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL ISWN(1,0.,XSIZ,0.,YSIZ)
         CALL ISVP(1,RQUEST(12),RQUEST(14)+RQUEST(12)
     +,              RQUEST(13),RQUEST(15)+RQUEST(13))
         CALL ISELNT(1)
         MFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         RETURN
      ENDIF
+SELF, IF=DI3000.
*
      IF(XSIZ.LE.0..OR.YSIZ.LE.0.)THEN
         CALL IGERR('X size and Y size must be positive','IGRNG')
         GO TO 999
      ENDIF
      IF(SEGOPN) THEN
         CALL JCLOSE
         SEGOPN = .FALSE.
      ENDIF
      CALL IUWK(IDID,1)
*
*     Perform calculations for primary workstation (IDID).
*
      IF(TEKACT.OR.METACT)THEN
*
*        DETERMINE IF THE DEVICE IS CAPABLE OF PHYSICAL SIZING AND
*        THE PHYSICAL SIZE OF THE VIEWPORT
*
         WKID = IDID
         IF (WKID.NE.0) THEN
            CALL JIQDIM(WKID,PHYS,MAXDIM)
            XMIN = MAXDIM(1)
            XMAX = MAXDIM(2)
            YMIN = MAXDIM(3)
            YMAX = MAXDIM(4)
         ELSE
            CALL JIQDEV(WKID,20,LIST)
            XMIN = FLOAT(LIST(1))
            XMAX = FLOAT(LIST(2))
            YMIN = FLOAT(LIST(3))
            YMAX = FLOAT(LIST(4))
         ENDIF
*
*        SET THE ORIENTATION OF THE MAXIMUMS RETURNED SINCE NOT ALL
*        DEVICES REFER TO THE LOWER LEFT AS X0PHY, Y0PHY AND UPPER RIGHT
*        AS X1PHY, Y1PHY.
*
         IF (XMIN .GT. XMAX) THEN
            TEMP = XMIN
            XMIN = XMAX
            XMAX = TEMP
         ENDIF
         IF (YMIN .GT. YMAX) THEN
            TEMP = YMIN
            YMIN = YMAX
            YMAX = TEMP
         ENDIF
*
         IF (WKID.NE.0) CALL ISWKVP(WKID,XMIN,XMAX,YMIN,YMAX)
*
*              Ecran horizontal
*
         IF(XMAX.GE.YMAX)THEN
            XWKWN=1.
            YWKWN=YMAX/XMAX
            CALL ISWKWN(WKID,0.,1.,0.,YWKWN)
         ELSE
*
*              Ecran vertical
*
            YWKWN=1.
            XWKWN=XMAX/YMAX
            CALL ISWKWN(WKID,0.,XWKWN,0.,1.)
         ENDIF
      ENDIF
*
*     Perform calculations for secondary workstations.
*
      IF(TEKACT.OR.METACT)THEN
*
*        DETERMINE IF THE DEVICE IS CAPABLE OF PHYSICAL SIZING AND
*        THE PHYSICAL SIZE OF THE VIEWPORT
*
         DO 100 WKID = 0,MAXDEV
            IF ((DEVICES(WKID).NE.0).AND.(DEVICES(WKID).NE.IDID)) THEN
               IF (WKID.NE.0) THEN
                  CALL JIQDIM(WKID,PHYS,MAXDIM)
                  XMINT = MAXDIM(1)
                  XMAXT = MAXDIM(2)
                  YMINT = MAXDIM(3)
                  YMAXT = MAXDIM(4)
               ELSE
                  CALL JIQDEV(WKID,20,LIST)
                  XMINT = FLOAT(LIST(1))
                  XMAXT = FLOAT(LIST(2))
                  YMINT = FLOAT(LIST(3))
                  YMAXT = FLOAT(LIST(4))
               ENDIF
C
C              SET THE ORIENTATION OF THE MAXIMUMS RETURNED SINCE NOT ALL
C              DEVICES REFER TO THE LOWER LEFT AS X0PHY, Y0PHY AND UPPER RIGHT
C              AS X1PHY, Y1PHY.
C
               IF (XMINT .GT. XMAXT) THEN
                  TEMP  = XMINT
                  XMINT = XMAXT
                  XMAXT = TEMP
               ENDIF
               IF (YMINT .GT. YMAXT) THEN
                  TEMP  = YMINT
                  YMINT = YMAXT
                  YMAXT = TEMP
               ENDIF
*
               IF (WKID.NE.0) THEN
                  IF ((XMAXT/XMAX).GE.(YMAXT/YMAX)) THEN
                     CALL ISWKVP(WKID,
     +                  MAX(0.5*(XMAXT-(XMAX/YMAX)*YMAXT),XMINT),
     +                  MIN(0.5*(XMAXT+(XMAX/YMAX)*YMAXT),XMAXT),
     +                  YMINT,YMAXT)
                  ELSE
                     CALL ISWKVP(WKID,XMINT,XMAXT,
     +                  MAX(0.5*(YMAXT-(YMAX/XMAX)*XMAXT),YMINT),
     +                  MIN(0.5*(YMAXT+(YMAX/XMAX)*XMAXT),YMAXT))
                  ENDIF
               ENDIF
*
*              Ecran horizontal
*
               IF(XMAX.GE.YMAX)THEN
                  CALL ISWKWN(WKID,0.,1.,0.,YWKWN)
               ELSE
*
*              Ecran vertical
*
                  CALL ISWKWN(WKID,0.,XWKWN,0.,1.)
               ENDIF
            ENDIF
  100    CONTINUE
      ENDIF
*
*              Transformation no 1 : cm <---> espace ecran
*
      IF (XSIZ.LT.YSIZ) THEN
         XNCM=YWKWN*XSIZ/YSIZ
         YNCM=YWKWN
         DXWN=(XWKWN-XNCM)/2.
         IF(DXWN.LT.0.)THEN
            XNCM=XWKWN
            DXWN=0.
            YNCM=XWKWN*YSIZ/XSIZ
            DYWN=(YWKWN-YNCM)/2.
            XYTWN=XWKWN/XSIZ
         ELSE
            DYWN=0.
            XYTWN=YWKWN/YSIZ
         ENDIF
      ELSE
         XNCM=XWKWN
         YNCM=XWKWN*YSIZ/XSIZ
         DYWN=(YWKWN-YNCM)/2.
         IF(DYWN.LT.0.)THEN
            YNCM=YWKWN
            DYWN=0.
            XNCM=YWKWN*XSIZ/YSIZ
            DXWN=(XWKWN-XNCM)/2.
            XYTWN=YWKWN/YSIZ
         ELSE
            DXWN=0.
            XYTWN=XWKWN/XSIZ
         ENDIF
      ENDIF
*
      CALL ISWN(1,0.,XSIZ,0.,YSIZ)
      CALL ISVP(1,DXWN,XNCM+DXWN,DYWN,YNCM+DYWN)
      CALL ISELNT(1)
      RQUEST(11)=XYTWN
      RQUEST(12)=DXWN
      RQUEST(13)=DYWN
      RQUEST(14)=XNCM
      RQUEST(15)=YNCM
*
 999  END
+SELF.
+DECK,  IGSA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IGSA(IIWK)
*.===========>
*.
*.   Purpose:
*.   --------
*.
*.   IGSA switches a raster terminal from graphics to alpha mode.
*. The terminal must be an activated HIGZ workstation.This is done by
*. prompting the user who should respond by typing RETURN or any
*. character string followed by return.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HILUN.
+CDE, HIATT.
+CDE, HIQUES.
+CDE, HIFLAG.
+CDE, DI3DEV.
*
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
*.______________________________________
*
+SELF, IF=DI3000, IF=IBM.
      INTEGER IDDRV
+SELF, IF=DI3000, IF=VAX.
      LOGICAL START  /.TRUE./
      CHARACTER*6  LOGNAM
      CHARACTER*80 STRING
      INTEGER LENGTH
      CHARACTER*3 DRIVER(MAXDEV)
      SAVE START,DRIVER

      IF (START) THEN
         START=.FALSE.

*        Translate YD%DRV logical names to obtain devices.

         DO 100 I=1,MAXDEV
            WRITE(LOGNAM,'(A2,I1,A3)') 'YD',I,'DRV'
            STATUS = LIB$SYS_TRNLOG(LOGNAM,LENGTH,STRING)
            DRIVER(I) = STRING(LENGTH-6:LENGTH-4)
  100    CONTINUE
      END IF
+SELF, IF=DI3000.
      IF(GRFLAG)THEN
         IF (ENTRY_FLAG) CALL JUPDAT
         GRFLAG=.FALSE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=IDID
         IF(IQUEST(100).EQ.-1)THEN
            IQUEST(100)=0
         ENDIF
         IF (DEVICES(IWK).NE.0) THEN
+SELF, IF=DI3000, IF=VAX.
            IF (DRIVER(IWK).EQ.'COD') THEN
               WRITE(LUNOUT,'(1X,A1)') CHAR(24)
            ELSEIF (
     +         (DRIVER(IWK).EQ.'240').OR.(DRIVER(IWK).EQ.'24Y').OR.
     +         (DRIVER(IWK).EQ.'241').OR.(DRIVER(IWK).EQ.'24Z').OR.
     +         (DRIVER(IWK).EQ.'330').OR.(DRIVER(IWK).EQ.'340')
     +         ) THEN
               WRITE(LUNOUT,'(1X,A2)') CHAR(27)//'\'
            ELSEIF (DRIVER(IWK).EQ.'HDS') THEN
               WRITE(LUNOUT,'(1X,A15)') CHAR(27)//'[?38l'//
     +            CHAR(27)//'='//CHAR(27)//'<'//CHAR(27)//'[?1h'
            ELSEIF (DRIVER(IWK).EQ.'MAC') THEN
               WRITE(LUNOUT,'(1X,A4)') CHAR(27)//'%!2'
            ENDIF
+SELF, IF=DI3000, IF=IBM.
*           Insert proper code here!
+SELF, IF=DI3000.
         ENDIF
      ENDIF
*
      END
+SELF.
+DECK,  IGSG, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IGSG(IIWK)
*.===========>
*.
*.   Purpose:
*.   --------
*.
*.   IGSG switches a raster terminal from alpha to graphics mode .
*.   The terminal must be an activated HIGZ workstation .
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HILUN.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, DI3DEV.
*
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
*.______________________________________
*
+SELF, IF=DI3000, IF=VAX.
      LOGICAL START  /.TRUE./
      CHARACTER*6  LOGNAM
      CHARACTER*80 STRING
      INTEGER LENGTH
      CHARACTER*3 DRIVER(MAXDEV)
      SAVE START,DRIVER

      IF (START) THEN
         START=.FALSE.

*        Translate YD%DRV logical names to obtain devices.

         DO 100 I=1,MAXDEV
            WRITE(LOGNAM,'(A2,I1,A3)') 'YD',I,'DRV'
            STATUS = LIB$SYS_TRNLOG(LOGNAM,LENGTH,STRING)
            DRIVER(I) = STRING(LENGTH-6:LENGTH-4)
  100    CONTINUE
      END IF
+SELF, IF=DI3000.
      IF(.NOT.GRFLAG)THEN
         GRFLAG=.TRUE.
         IWK=IIWK
         IF(IWK.EQ.0)IWK=IDID
         IF (DEVICES(IWK).NE.0) THEN
+SELF, IF=DI3000, IF=VAX.
            IF (DRIVER(IWK).EQ.'COD') THEN
*              Do nothing.
            ELSEIF (
     +         (DRIVER(IWK).EQ.'240').OR.(DRIVER(IWK).EQ.'24Y').OR.
     +         (DRIVER(IWK).EQ.'241').OR.(DRIVER(IWK).EQ.'24Z').OR.
     +         (DRIVER(IWK).EQ.'330').OR.(DRIVER(IWK).EQ.'340')
     +         ) THEN
*              Do nothing.
            ELSEIF (DRIVER(IWK).EQ.'HDS') THEN
               WRITE(LUNOUT,'(1X,A6,$)') CHAR(27)//'[?38h'
            ELSEIF (DRIVER(IWK).EQ.'MAC') THEN
               WRITE(LUNOUT,'(1X,A8,$)') CHAR(27)//'%!0'//
     +            CHAR(27)//'LV0'
            ENDIF
+SELF, IF=DI3000, IF=IBM.
*           Insert proper code here!
+SELF, IF=DI3000.
         ENDIF
      ENDIF
*
      END

+SELF.
+DECK,  IOPKS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IOPKS(ERRFIL)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Initialization is done by IGSSE and will not be repeated.
*.     ***** ***** ***** User *MUST* call IGSSE. ***** ***** *****
*.     This routine further sets the debug log file and graphics level
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JFILES      ! Override default for logical unit
*.     CALL JSETDB      ! Set the DI3000 graphics debugging level
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, DI3DEV.
+CDE, DI3MET.
+CDE, HIVERS.
      CHARACTER*16 TCARD
      INTEGER ERRDEB
      INTEGER ERRFIL
*.______________________________________
*
      CALL UHTOC(
     + 40H CPP_TITLE
+SELF, IF=DI3000, IF=-CRAY.
     +,4,TCARD,16)
+SELF, IF=DI3000, IF=CRAY.
     +,8,TCARD,16)
+SELF, IF=DI3000.
      CHVERS = TCARD(9:16)
*
      IF (.NOT.ENTRY_FLAG) THEN
         CALL JBEGIN
         ENTRY_FLAG = .TRUE.
      ENDIF
      CALL JFILES (1, 0, ERRFIL)
      CALL JSETER (0)

+SELF, IF=DI3000, IF=VAX.
      IF (ICHAR(METNAM(1:1)).EQ.0) METNAM = 'HIGZ.METAFILE'
+SELF, IF=DI3000, IF=IBM.
      IF (ICHAR(METNAM(1:1)).EQ.0) METNAM = 'HIGZ METAFILE'
+SELF, IF=DI3000.
      CALL JFSOPN (3, 0, 0, METNAM)
*
      END
+SELF.
/*    STRASBOURG - A.M. 19/11/99 Useless next line removed ============*/

/* #include "higz/TITLE.higz"                                          */
+DECK,  IOPWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IOPWK(WKID,CONID,WTYPE)
*.===========>
*.
*.   Purpose:
*.   --------
*.   Initialize a display device
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+CDE, HIMETA.
      INTEGER WKID,CONID,WTYPE
      INTEGER*4 MAXDEV
      PARAMETER (MAXDEV = 9)
      INTEGER*4 DEVICES(0:MAXDEV)
      EQUIVALENCE (ILOPWK,DEVICES)
+CDE, DI3SEG.
*.______________________________________
*
      IF(WKID.LT.0)THEN
         CALL IGERR('Workstation identifier less than 0','IOPWK')
         RETURN
      ENDIF
*
*              PostScript Metafile
*
      IF(WTYPE.LT.0)THEN
         CALL IPINIT(WKID,ABS(CONID),WTYPE)
         RETURN
      ENDIF
*
      IF (DEVICES(WKID).EQ.0) THEN
         INOPWK=INOPWK+1
         DEVICES(WKID)=1
         ICONID=CONID
*
         IF (SEGOPN) THEN
            CALL JCLOSE
            SEGOPN =.FALSE.
         ENDIF
         CALL JDINIT (WKID)
         IF (WKID.EQ.0) THEN
            METACT = .TRUE.
         ELSE
            TEKACT = .TRUE.
         ENDIF
      ENDIF
*
      END
+SELF.
+DECK,  IPL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IPL(N,X,Y)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Define a connected sequence of visible lines.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JPOLY (X, Y, N)
*.
*.   Parameters:
*.   -----------
*.     X, Y                       [ REAL; Array; Input ]
*.
*.      - The arrays of world coordinates defining the polyline.
*.
*.     N                          [ INTEGER; Input ]
*.
*.      - The number of points in the connected line sequence.
*.
*.        *NOTE* : The above array parameters must be DIMENSIONed to at
*.        least N in the calling program.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, DI3SEG.
      DIMENSION X(N),Y(N),XX(2),YY(2),XDOT(2),YDOT(2)
      LOGICAL ZSAV
      EQUIVALENCE (XOLD,XX(1)),(XNEW,XX(2))
      EQUIVALENCE (YOLD,YY(1)),(YNEW,YY(2))
      DATA XLSTEP,SMIN/0.2,0.0002/
*.______________________________________
*
      IF(N.LE.1)GOTO 999
      IF((ILN.GE.12).AND.(GFLAG.OR.PFLAG))THEN
         CALL IGSG(0)
         ZSAV=ZFLAG
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         NTSAV=INTR
         RATIO1=(RVXMAX-RVXMIN)/(RWXMAX-RWXMIN)
         RATIO2=(RVYMAX-RVYMIN)/(RWYMAX-RWYMIN)
         RWX1=RWXMIN
         RWY1=RWYMIN
         RVX1=RVXMIN
         RVY1=RVYMIN
         RVX2=RVXMAX
         RVY2=RVYMAX
         XLSTEP=RBSL
         SMIN=0.001*XLSTEP
         CALL ISELNT(0)
         ILNS=ILN
         CALL ISLN(1)
         IF((XLSTEP.LE.0.).OR.(XLSTEP.GT.1))XLSTEP=0.01
*
*              Possibly dashed lines drawn
*
   10    MODE=1
         IDOT=0
         SRES=XLSTEP
*
         DO 90  I=2,N
            XOLD=RATIO1*(X(I-1)-RWX1)+RVX1
            YOLD=RATIO2*(Y(I-1)-RWY1)+RVY1
*
            DXSTEP=RATIO1*(X(I)-RWX1)+RVX1-XOLD
            DYSTEP=RATIO2*(Y(I)-RWY1)+RVY1-YOLD
            ADX=ABS(DXSTEP)
            ADY=ABS(DYSTEP)
            IF(ADX.LE.SMIN)THEN
               STEP=ADY
               DSX=0.
               DSY=SIGN(1.,DYSTEP)
               GOTO 20
            ENDIF
            IF(ADY.LE.SMIN)THEN
               STEP=ADX
               DSX=SIGN(1.,DXSTEP)
               DSY=0.
               GOTO 20
            ENDIF
            STEP=SQRT(DXSTEP*DXSTEP+DYSTEP*DYSTEP)
            DSX=DXSTEP/STEP
            DSY=DYSTEP/STEP
   20       IF(STEP.LE.0.)GO TO 90
            DRES=STEP
*
   30       ST=SRES
            IF(ST.GT.DRES)ST=DRES
            SRES=SRES-ST
            DRES=DRES-ST
            XNEW=XOLD+ST*DSX
            YNEW=YOLD+ST*DSY
*
            IF(ICLIP.EQ.1)THEN
               ICL=IGCLIP(XX,YY,RVX1,RVX2,RVY1,RVY2)
               IF(ICL.EQ.0)GOTO 80
            ENDIF
*
            GO TO (40 ,40 ,50 ,60 ,70 ),ILNS-10
*
*              Dashed line _ _ _ _ _ _ _
*
   40       CONTINUE
            IF (.NOT. SEGOPN) THEN
               CALL JOPEN
               SEGOPN = .TRUE.
            ENDIF
            IF (MODE .NE. 0) THEN
+SELF, IF=DI3000, IF=PSCRIPT.
               IF(PFLAG)CALL IZPL(2,XX,YY)
+SELF, IF=DI3000.
               IF(GFLAG)THEN
                  CALL JMOVE(XX(1),YY(1))
                  CALL JPOLY(XX,YY,2)
               ENDIF
            ENDIF
            GO TO 80
*
*              Dash-dot line _._._._._.
*
   50       IF(MODE.EQ.0)GO TO 70
            IF (.NOT. SEGOPN) THEN
               CALL JOPEN
               SEGOPN=.TRUE.
            ENDIF
+SELF, IF=DI3000, IF=PSCRIPT.
            IF(PFLAG)CALL IZPL(2,XX,YY)
+SELF, IF=DI3000.
            IF(GFLAG)THEN
               CALL JMOVE(XX(1),YY(1))
               CALL JPOLY(XX,YY,2)
            ENDIF
            GO TO 80
*
*              Dot-blank  . . . . . . .
*
   60       IF(MODE.EQ.0)GO TO 80
*
*              Dotted line  ............
*
   70       IF (SRES.LT.0.5*XLSTEP) IDOT=IDOT+1
            IF (IDOT.NE.1) GOTO 80
            XDOT(1) = XNEW - (0.5*XLSTEP-SRES)*DSX
            YDOT(1) = YNEW - (0.5*XLSTEP-SRES)*DSY
            MTS=IMK
            MCOL=IPMCI
            RMSC=RMKSC
            CALL ISMKSC(RLWSC)
            CALL ISMK(1)
            CALL ISPMCI(IPLCI)
            IF(GFLAG)CALL JPMARK(XDOT,YDOT,1)
+SELF, IF=DI3000, IF=PSCRIPT.
            IF(PFLAG)CALL IZPM(1,XDOT,YDOT)
+SELF, IF=DI3000.
            CALL ISMKSC(RMSC)
            CALL ISMK(MTS)
            CALL ISPMCI(MCOL)
*
   80       XOLD=XNEW
            YOLD=YNEW
            IF(SRES.LE.SMIN)THEN
               IDOT=0
               SRES=XLSTEP
               MODE=MODE+1
               IF(MODE.EQ.2)MODE=0
            ENDIF
            IF(DRES.GT.SMIN)GO TO 30
   90    CONTINUE
         CALL ISELNT(NTSAV)
         CALL ISLN(ILNS)
         ZFLAG=ZSAV
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      ELSE
         IF(GFLAG)THEN
            CALL IGSG(0)
            IF (.NOT. SEGOPN) THEN
               CALL JOPEN
               SEGOPN=.TRUE.
            ENDIF
            CALL JMOVE (X(1),Y(1))
            CALL JPOLY (X, Y, N)
         ENDIF
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZPL(N,X,Y)
+SELF, IF=DI3000.
*
  999 END
+SELF.
+DECK,  IPM, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:28  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IPM(N,X,Y)
*.===========>
*.
*.   This routines draws markers .
*.
*. _Input parameters:
*.
*.  INTEGER N : Number of markers .
*.  REAL X(N) : Markers X coordinates .
*.  REAL Y(N) : Markers Y coordinates .
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, DI3SEG.
      REAL X(N),Y(N)
*.______________________________________
*
      IF((N.LE.0).OR.(IMK.GT.31))GOTO 999
*
      IF(GFLAG.OR.PFLAG)THEN
         CALL IGSG(0)
         IF(IMK.LT.20)THEN
            IF(.NOT.GFLAG)GOTO 20
            IF (.NOT. SEGOPN) THEN
               CALL JOPEN
               SEGOPN=.TRUE.
            ENDIF
            CALL JPMARK(X,Y,N)
         ELSE
            CALL IGPM(N,X,Y,IMK)
         ENDIF
      ENDIF
*
   20 CONTINUE
+SELF, IF=DI3000, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZPM(N,X,Y)
+SELF, IF=DI3000.
*
  999 END
+SELF.
+DECK,  IRQLC, T=FORT.
* Revision 1.2  1998/01/30 15:22:11  couet
* - APOLLO version removed
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IRQLC(WKID,LCN,STATUS,TNR,XLOC,YLOC)
*.===========>
*.
*.   This routine returns the graphic cursor position in WC space in
*. XLOC and YLOC . The same position in the NDC space is available in
*. RQUEST(11) and RQUEST(12) . The normalization tranformation number
*. is returned in TNR . After a call to IRQLC the window coordinates
*. are available in RQUEST(20), RQUEST(21), RQUEST(22), and RQUEST(23).
*. The viewport coordinates are available in RQUEST(30), RQUEST(31),
*. RQUEST(32), and RQUEST(33). This routine computed the XLOC and YLOC
*. value according to value of the REDIT factor, but the value of
*. RQUEST(11) and RQUEST(12) do not care about the value of REDIT.
*. The REDIT factor is usefull for the graphics editor and the menu
*. mode of KUIP. The values of XLOC and YLOC are computed with the
*. parameters stored in the NT storage (HINT) if ZEBRA is not used, or
*. if there no displayed picture. If an HIGZ picture is displayed,
*. only the NT existing in this picture are used to compute the values
*. of XLOC and YLOC.
*.
*. _Input parameters:
*.
*.  INTEGER WKID : Workstation identifier .
*.  INTEGER LCN  : Input device number .
*.                 If LCN>10 then LCN=10*IPET+LNDNR
*.  INTEGER STATUS : Return status: 0=BREAK, 1=OK .
*.
*. _Output parameters:
*.
*.  INTEGER TNR : Normalization transformation number .
*.  REAL XLOC YLOC : Cursor position in WC space .
*.
*..==========> (O.Couet)
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HIPAW.
+SELF, IF=DI3000, IF=-ZEBRA.
+CDE, HIQUES.
+SELF, IF=DI3000.
+CDE, HINT.
+CDE, HILOC.
+CDE, HIATT.
+SELF, IF=DI3000, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=DI3000, IF=MAIL.
+CDE, HIFLAG.
+SELF, IF=DI3000.
      INTEGER WKID,LCDNR,STATUS,TNR,NNT
      INTEGER INPFCT,IECHO,IBUTTN
      CHARACTER*80 STR(4)
*.______________________________________
*
+SELF, IF=DI3000, IF=MAIL.
*
*              MAIL option
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(3I3)') 555,WKID,LCN
         CALL IMWRIT(1)
         READ (5,'(2I5,2E16.7)') STATUS,TNR,XLOC,YLOC
         CALL IMWRIT(5)
         RETURN
      ENDIF
+SELF, IF=DI3000.
*
      CALL IGSG(0)
      LCDNR=MOD(LCN,10)
      IPET=1
      LOCDEV=1
      INPFCT=2
      IECHO=1
      LSTR=0
      CALL JPECHO(WKID,INPFCT,LOCDEV,OLDXP,OLDYP)
      CALL JIENAB(WKID,INPFCT,LOCDEV)
      CALL JLOCAT(WKID,LOCDEV,IECHO,IBUTTN,RQUEST(11),RQUEST(12))
      IF(IBUTTN.EQ.3) THEN
         STATUS = 0
      ELSE
         STATUS = 1
      ENDIF
      OLDXP=RQUEST(11)
      OLDYP=RQUEST(12)
*
      SCALE=1.
      IF(REDIT.NE.0.)SCALE=REDIT
*
      RQUEST(20)=0.
      RQUEST(21)=1.
      RQUEST(22)=0.
      RQUEST(23)=1.
      RQUEST(30)=0.
      RQUEST(31)=1.
      RQUEST(32)=0.
      RQUEST(33)=1.
      TNR=0
      XLOC=(RQUEST(11)+RDWXMI*REDIT)/SCALE
      YLOC=(RQUEST(12)+RDWYMI*REDIT)/SCALE
+SELF, IF=DI3000, IF=ZEBRA.
*
*             There is displayed picture
*
      IF(LPICD.GT.0)THEN
         IPRIOO=IQ(LDNT0+3)
         NBNT=IQ(LPICD+8)-1
         LN=LQ(LDNT0)
         DO 10 I=1,NBNT
            IAWV=LDF+IQ(LN+2)
            IPRION=IQ(LN+3)
            RQUEST(20)=Q(IAWV)
            RQUEST(21)=Q(IAWV+1)
            RQUEST(22)=Q(IAWV+2)
            RQUEST(23)=Q(IAWV+3)
            RQUEST(30)=Q(IAWV+4)
            RQUEST(31)=Q(IAWV+5)
            RQUEST(32)=Q(IAWV+6)
            RQUEST(33)=Q(IAWV+7)
            IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +         (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +         (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +         (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
               IF(IPRION.GT.IPRIOO)THEN
                  XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +                 -RQUEST(30))
     +                 /(RQUEST(31)-RQUEST(30)))
     +                 *(RQUEST(21)-RQUEST(20))
     +                +RQUEST(20)
                  YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +                 -RQUEST(32))
     +                 /(RQUEST(33)-RQUEST(32)))
     +                 *(RQUEST(23)-RQUEST(22))
     +                 +RQUEST(22)
                  TNR=IQ(LN+1)
                  IPRIOO=IPRION
               ENDIF
            ENDIF
            LN=LQ(LN)
            IF(LN.EQ.0)RETURN
   10    CONTINUE
         RETURN
      ENDIF
+SELF, IF=DI3000, IF=-NTC.
*
*             The computing of XLOC and YLOC in done with the parameters
*             stored in HINT.
*
      NBNT=NTSTOR(1)
      IPRIOO=NT0PRI
      DO 20 I=1,NBNT
         NNT=NTSTOR(2*I)
         CALL IZGNT(NNT,IFIND,IAWV,IPRION,IHPRIO)
         RQUEST(20)=WNVPST(IAWV)
         RQUEST(21)=WNVPST(IAWV+1)
         RQUEST(22)=WNVPST(IAWV+2)
         RQUEST(23)=WNVPST(IAWV+3)
         RQUEST(30)=WNVPST(IAWV+4)
         RQUEST(31)=WNVPST(IAWV+5)
         RQUEST(32)=WNVPST(IAWV+6)
         RQUEST(33)=WNVPST(IAWV+7)
         IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +      (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +      (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +      (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
            IF(IPRION.GT.IPRIOO)THEN
               XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +              -RQUEST(30))
     +              /(RQUEST(31)-RQUEST(30)))
     +              *(RQUEST(21)-RQUEST(20))
     +             +RQUEST(20)
               YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +              -RQUEST(32))
     +              /(RQUEST(33)-RQUEST(32)))
     +              *(RQUEST(23)-RQUEST(22))
     +              +RQUEST(22)
               TNR=NNT
               IPRIOO=IPRION
            ENDIF
         ENDIF
   20 CONTINUE
+SELF, IF=DI3000, IF=NTC.
      IPRIOO = NT0PRI
      IEND   = IGNNXT(1)
   30 IF(IEND.EQ.0)THEN
         CALL IGNGET(NNT,IPRION,IHPRIO
     +,              RQUEST(20),RQUEST(21),RQUEST(22),RQUEST(23)
     +,              RQUEST(30),RQUEST(31),RQUEST(32),RQUEST(33),I3D)
         IF((RQUEST(30)*SCALE-(RDWXMI*REDIT).LE.RQUEST(11)).AND.
     +      (RQUEST(11).LE.RQUEST(31)*SCALE-(RDWXMI*REDIT)).AND.
     +      (RQUEST(32)*SCALE-(RDWYMI*REDIT).LE.RQUEST(12)).AND.
     +      (RQUEST(12).LE.RQUEST(33)*SCALE-(RDWYMI*REDIT)))THEN
            IF(IPRION.GT.IPRIOO)THEN
               XLOC=((((RQUEST(11)+(RDWXMI*REDIT))/SCALE)
     +              -RQUEST(30))
     +              /(RQUEST(31)-RQUEST(30)))
     +              *(RQUEST(21)-RQUEST(20))
     +             +RQUEST(20)
               YLOC=((((RQUEST(12)+(RDWYMI*REDIT))/SCALE)
     +              -RQUEST(32))
     +              /(RQUEST(33)-RQUEST(32)))
     +              *(RQUEST(23)-RQUEST(22))
     +              +RQUEST(22)
               ITNRI=NNT
               IPRIOO=IPRION
            ENDIF
         ENDIF
         IEND = IGNNXT(0)
         GOTO 30
      ENDIF
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  IRQST, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IRQST(WKID,STDNR,STATUS,L,STR)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Request and return input from a STRING input device.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JKEYBS (DEVICE, PHYDEV, ECHOLV, MAXCHR, STRING, ACTUAL)
*.
*.   Parameters:
*.   -----------
*.     DEVICE
*.      - Currently selected display device
*.
*.     PHYDEV
*.      - Integer defining the physical input device on DEVICE that is to be
*.        used for obtaining KEYBOARD input
*.
*.     ECHOLV
*.      - Echo level for echoing KEYBOARD input (=0 No echo, =1 KEYBOARD string
*.        is displayed, =2 KEYBOARD string is output onto a display DEVICE
*.        other than the display device of DEVICE
*.
*.      MAXCHR
*.       - Maximum number of characters that will fit into the text array
*.         STRING, must be passed from the calling program, max=254
*.
*.      STRING
*.       - The character string returned by the KEYBOARD input function
*.
*.      ACTUAL
*.       - The actual number of characters read in by the KEYBOARD input
*.         function
*.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+SELF, IF=DI3000, IF=MAIL.
+CDE, HIMAIL.
+SELF, IF=DI3000, IF=MAIL.
+CDE, HIFLAG.
+SELF, IF=DI3000.
      INTEGER WKID,STATUS,L
      CHARACTER*(*) STR
      INTEGER DEVICE, PHYDEV, ECHOLV, MAXCHR, ACTUAL, INPFCT
      CHARACTER *254 STRING

      INTEGER NKEYBD
*.______________________________________
*
+SELF, IF=DI3000, IF=MAIL.
*
*              MAIL option
*
      IF(MFLAG)THEN
         WRITE (CHMAIL,'(3I3)') 556,IWKID,ISTD
         CALL IMWRIT(1)
         READ (5,'(2I5,A)') ISTAT,L,STR
         CALL IMWRIT(5)
         RETURN
      ENDIF
+SELF, IF=DI3000.
*
      CALL IGSG(0)
C
C     ***** Enable KEYBOARD device
C
      DEVICE = ABS(WKID)
      CALL JIQDEV(DEVICE,45,NKEYBD)
      IF (NKEYBD.NE.0) THEN

         INPFCT = 4
         PHYDEV = 1
         ECHOLV = 0
         MAXCHR = 254

         CALL JIENAB(DEVICE,INPFCT,PHYDEV)

C        ***** Get STRING from device

         STRING = ' '
         CALL JKEYBS (DEVICE, PHYDEV, ECHOLV, MAXCHR, STRING, ACTUAL)
         L = ACTUAL
         STR = STRING
         STATUS = 1
      ENDIF
*
      END
+SELF.
+DECK,  ISCHH, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISCHH(CHH)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the dimensions of the character box.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JSIZE (CXSIZE, CYSIZE)
*.
*.   Parameters:
*.   -----------
*.     CXSIZE, CYSIZE             [ REAL; Input ]
*.
*.      - The new value for the character box SIZE.
*.        NOTE : Both CXSIZE anC CYSIZE must be greater than 0.0.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
*.______________________________________
*
      RCHH=CHH
      IF (GFLAG) THEN
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JSIZE (CHH,CHH)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ICHHCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISCHUP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISCHUP(CHUX,CHUY)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the current character plane vector text attribute.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JPLANE (CXPLAN, CYPLAN, CZPLAN)
*.
*.   Parameters:
*.   -----------
*.     CXPLAN, CYPLAN, CZPLAN     [ REAL; Input ]
*.
*.      - The character plane vector of subsequent text primitives
*.        within the currently OPEN segment.
*.
*.        *NOTE* : At least one of (CXPLAN, CYPLAN, CZPLAN) must not
*.        be equal to 0.0.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
*.______________________________________
*
      RCHUX=CHUX
      RCHUY=CHUY
      IF (GFLAG) THEN
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JBASE (CHUY, -CHUX, 0.)
         CALL JPLANE (CHUX, CHUY, 0.)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF((RCHUX.EQ.0.).AND.(RCHUY.EQ.1.))THEN
         RANGLE=0.
      ELSEIF((RCHUX.EQ.-1.).AND.(RCHUY.EQ.0.))THEN
         RANGLE=90.
      ELSEIF((RCHUX.EQ.0.).AND.(RCHUY.EQ.-1.))THEN
         RANGLE=180.
      ELSEIF((RCHUX.EQ.1.).AND.(RCHUY.EQ.0.))THEN
         RANGLE=270.
      ELSE
         RANGLE=((ACOS(RCHUX/SQRT(RCHUX**2+RCHUY**2))*180.)
     +           /3.14159)-90.
         IF(RCHUY.LT.0.)RANGLE=180.-RANGLE
         IF(ABS(RANGLE).LE.0.01)RANGLE=0.
      ENDIF
      IF(GLFLAG)CALL IZATT(IANGCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISCLIP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISCLIP(CLSW)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the indicator for clipping at the boundaries of
*.     the normalization transformation viewport.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JWCLIP (LVALUE)
*.
*.   Parameters:
*.   ___________
*.     LVALUE
*.      - Logical flag indicating whether or not subsequent output primitives
*.        are to be clipped to the boundaries of the clipping window on the
*.        viewplane.
*.
*.        LVALUE = .TRUE.    ---> enable window clipping
*.        LVALUE = .FALSE.   ---> disable window clipping
*.
*.      *NOTE* : If window clipping is suppressed and world coordiantes
*.                data exceed the window boundaries, the resultant display
*.                device image is unpredictable and device dependent
*.
*.      *NOTE* : DI-3000 disables clipping by default
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CLSW
*.______________________________________
*
+SELF, IF=DI3000, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZSCLI(CLSW)
+SELF, IF=DI3000.
      IF(CLSW.EQ.ICLIP)RETURN
      ICLIP=CLSW
      IF(GFLAG)THEN
         IF(SEGOPN) THEN
            CALL JCLOSE
            SEGOPN = .FALSE.
         ENDIF
         CALL JWCLIP(CLSW.EQ.1)
      ENDIF
*
      END
+SELF.
+DECK,  ISCR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISCR(IWKID,ICI,CR,CG,CB)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set color primitive attribute.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JCOLOR (CVALUE)
*.
*.   Parameters:
*.   -----------
*.     CVALUE                     [ INTEGER; Input ]
*.
*.      - The new value for the color index.
*.
*.        NOTE : CVALUE must be in the range 0...32767.
*.
*.          0 - "Normal" for the DEVICE
*.          1 -  Red
*.          2 -  Green
*.          3 -  Yellow
*.          4 -  Blue
*.          5 -  Magenta
*.          6 -  Cyan
*.          7 -  White
*.          8 -  Black
*.          9 -  Complement of the "normal" DEVICE color
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIFLAG.
+CDE, HILUT.
      INTEGER CVALUE(1),HUE(1),SAT(1),LIGHT(1)
      INTEGER MAP(0:7)
      DATA MAP / 9, 0, 1, 2, 4, 3, 5, 6 /
*.______________________________________
*
      I=MIN(NBCLUT-1,ABS(ICI))+1
      REDLUT(I)=CR
      GRNLUT(I)=CG
      BLULUT(I)=CB
      CALL IGSG(0)
      IF(GFLAG)THEN
C
C        Perform GKS-->DI3000 mapping for color indices 0-7.
C
         IF((ICI.GE.0).AND.(ICI.LE.7))THEN
            CVALUE(1)=MAP(ICI)
         ELSE
            CVALUE(1)=ICI
         ENDIF
C
C        Transform RGB --> HSL.  Use routine provided by C. O'Reilly.
C
         CALL RGTOHS( CR, CG, CB, HUE, SAT, LIGHT)
         CALL JCOTBL(IWKID,1,CVALUE,HUE,SAT,LIGHT)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZSCOR(IWKID,ICI,CR,CG,CB)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISELNT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISELNT(NT)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Select a normalization transformation as the
*.     transformation.
*.
*.   DI-3000 access:
*.   ---------------
*.     ***** ***** *****
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HINT.
+CDE, HIFLAG.
+CDE, HIATT.
+CDE, DI3SEG.
*.______________________________________
*
      SCALE=1.
      IF(REDIT.NE.0.)SCALE=REDIT
*
+SELF, IF=DI3000, IF=-NTC.
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
*              Transformation No 0
*
      IF(NT.EQ.0)THEN
         NT0PRI=IHPRIO+1
         RWXMIN=0.
         RWYMIN=0.
         RWXMAX=1.
         RWYMAX=1.
         RVXMIN=0.
         RVYMIN=0.
         RVXMAX=1.
         RVYMAX=1.
         IF(GFLAG)THEN
            IF(SEGOPN)THEN
               CALL JCLOSE
               SEGOPN=.FALSE.
            ENDIF
            CALL JWINDO(RWXMIN
     +,                 RWXMAX
     +,                 RWYMIN
     +,                 RWYMAX)
            CALL JVPORT(RVXMIN*SCALE-(RDWXMI*REDIT)
     +,                 RVXMAX*SCALE-(RDWXMI*REDIT)
     +,                 RVYMIN*SCALE-(RDWYMI*REDIT)
     +,                 RVYMAX*SCALE-(RDWYMI*REDIT))
         ENDIF
         GOTO 10
      ENDIF
*
*              NT exits in the main transformation storage
*
      IF(IFIND.NE.0)THEN
         RWXMIN=WNVPST(IAWV)
         RWYMIN=WNVPST(IAWV+2)
         RWXMAX=WNVPST(IAWV+1)
         RWYMAX=WNVPST(IAWV+3)
         RVXMIN=WNVPST(IAWV+4)
         RVYMIN=WNVPST(IAWV+6)
         RVXMAX=WNVPST(IAWV+5)
         RVYMAX=WNVPST(IAWV+7)
         NTSTOR(IFIND)=IHPRIO+1
         IF(GFLAG)THEN
            IF(SEGOPN)THEN
               CALL JCLOSE
               SEGOPN=.FALSE.
            ENDIF
            CALL JWINDO(RWXMIN
     +,                 RWXMAX
     +,                 RWYMIN
     +,                 RWYMAX)
            CALL JVPORT(RVXMIN*SCALE-(RDWXMI*REDIT)
     +,                 RVXMAX*SCALE-(RDWXMI*REDIT)
     +,                 RVYMIN*SCALE-(RDWYMI*REDIT)
     +,                 RVYMAX*SCALE-(RDWYMI*REDIT))
         ENDIF
*
*              NT does not exit in the main transformation storage
*
      ELSE
         RWXMIN=0.
         RWYMIN=0.
         RWXMAX=1.
         RWYMAX=1.
         RVXMIN=0.
         RVYMIN=0.
         RVXMAX=1.
         RVYMAX=1.
         IF(GFLAG)THEN
            IF(SEGOPN)THEN
               CALL JCLOSE
               SEGOPN=.FALSE.
            ENDIF
            CALL JWINDO(RWXMIN
     +,                 RWXMAX
     +,                 RWYMIN
     +,                 RWYMAX)
            CALL JVPORT(RVXMIN*SCALE-(RDWXMI*REDIT)
     +,                 RVXMAX*SCALE-(RDWXMI*REDIT)
     +,                 RVYMIN*SCALE-(RDWYMI*REDIT)
     +,                 RVYMAX*SCALE-(RDWYMI*REDIT))
         ENDIF
         NBNT=NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISELNT')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2)=NT
         NTSTOR(2*NBNT+3)=IHPRIO+1
         WNVPST(8*NBNT+1)=0.
         WNVPST(8*NBNT+2)=1.
         WNVPST(8*NBNT+3)=0.
         WNVPST(8*NBNT+4)=1.
         WNVPST(8*NBNT+5)=0.
         WNVPST(8*NBNT+6)=1.
         WNVPST(8*NBNT+7)=0.
         WNVPST(8*NBNT+8)=1.
         NTSTOR(1)=NTSTOR(1)+1
      ENDIF
*
   10 CONTINUE
+SELF, IF=DI3000, IF=NTC.
      IF(IGNSCU(NT).EQ.0)CALL IGNCRE(NT)
      CALL IGNGET(I0,I1,IHPRIO
     +,           RWXMIN,RWXMAX,RWYMIN,RWYMAX
     +,           RVXMIN,RVXMAX,RVYMIN,RVYMAX,I3D)
      CALL IGNSPR(IHPRIO+1)
      IF(GFLAG)THEN
         IF(SEGOPN)THEN
            CALL JCLOSE
            SEGOPN=.FALSE.
         ENDIF
         CALL JWINDO(RWXMIN
     +,              RWXMAX
     +,              RWYMIN
     +,              RWYMAX)
         CALL JVPORT(RVXMIN*SCALE-(RDWXMI*REDIT)
     +,              RVXMAX*SCALE-(RDWXMI*REDIT)
     +,              RVYMIN*SCALE-(RDWYMI*REDIT)
     +,              RVYMAX*SCALE-(RDWYMI*REDIT))
      ENDIF
      IF(I3D.NE.0)CALL IGSVIE
*
+SELF, IF=DI3000, IF=ZEBRA,PSCRIPT,MAIL, IF=-3D.
      IF(GLFLAG)CALL IZSELN(NT)
+SELF, IF=DI3000.
      INTR=NT
      CALL ISCLIP(ICLIP)
*
      END
+SELF.
+DECK,  ISFACI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISFACI(ICOLI)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the polygon interior color and intensity attributes.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JPIDEX (CCOLOR, CINTEN)
*.
*.   Parameters:
*.   -----------
*.     CCOLOR                     [ INTEGER; Input ]
*.
*.      - The new value for the polygon interior color.
*.
*.        NOTE : CCOLOR must be in the range 0...32767.
*.
*.     CINTEN                     [ INTEGER; Input ]
*.
*.      - The new value for the polygon interior intensity.
*.
*.        NOTE : CINTEN must be in the range 0...32767.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CCOLOR, RANGEC(2)
      INTEGER STYLE
      INTEGER MAP(0:7)
      DATA MAP / 9, 0, 1, 2, 4, 5, 6, 3 /
      DATA RANGEC /0, 32767/
*.______________________________________
*
      IFACI=ICOLI
      IF (GFLAG) THEN
C
C        Perform GKS-->DI3000 mapping for color indices 0-7.
C
         IF((ICOLI.GE.0).AND.(ICOLI.LE.7))THEN
            CCOLOR=MAP(ICOLI)
         ELSE
            CCOLOR=ICOLI
         ENDIF
         IF((CCOLOR.LT.RANGEC(1)).OR.(CCOLOR.GT.RANGEC(2))) CCOLOR=0
         CALL J1IGET (11, STYLE)
         CALL J1IGET (13, CINTEN)
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         IF (STYLE .NE. 1) CALL JPINTR (1)
         CALL JPIDEX (CCOLOR, CINTEN)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFACCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISFAIS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISFAIS(INTS)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the interior style attribute.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JPINTR (CVALUE)
*.
*.   Parameters:
*.   -----------
*.     CVALUE                     [ INTEGER; Input ]
*.
*.      - The new value for the polygon interior style.
*.
*.        NOTE : CVALUE must be in the range 0...32767.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
*.______________________________________
*
      IF((INTS.LT.0).OR.(INTS.GT.3))THEN
         CALL IGERR('Fill area interior style must be > -1 and < 4'
     +,             'ISFAIS')
         RETURN
      ENDIF
      IFAIS=INTS
      IF (GFLAG) THEN
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JPEDGE(0)
         IF (INTS.EQ.0) THEN
            CALL JPINTR(0)
         ELSE
            CALL JPINTR(1)
            IF (INTS.EQ.1) THEN
               CALL ISFASI(47)
            ELSE
               CALL ISFASI(IFASI)
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFAICO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISFASI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISFASI(ISTYL)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the polygon interior style attribute, color
*.     and intensity.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JPINTR (CVALUE)
*.
*.   Parameters:
*.   -----------
*.     CVALUE                     [ INTEGER; Input ]
*.
*.      - The new value for the polygon interior style.
*.        style is reset to CVALUE.
*.
*.        NOTE : CVALUE must be in the range 0...32767.
*.
*.        The styles are:
*.
*.          0 - empty (the polygon is not filled)
*.          1 - the polygon is solid filled using the current
*.              polygon interior index values (JPIDEX).
*.   2..32767 - the index of a device dependent pattern to be
*.              used for filling the polygon.
*.
*.         NOTE : The polygon edge style is set by JPEDGE.
*.
*.         NOTE : JBEGIN sets the deafult interior style to 0.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CVALUE, CCOLOR, STYLE
      INTEGER MAP(20)
      DATA MAP / 44, 43, 45, 46,
     +           41, 35, 42, 36,
     +           32, 31, 33, 34,
     +           29, 23, 30, 24,
     +           20, 19, 21, 22/
*.______________________________________
*
      IFASI=ISTYL
      IF (GFLAG) THEN
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         IF ((ISTYL.LE.-101).AND.(ISTYL.GE.-120)) THEN
            CVALUE = MAP(ABS(ISTYL)-100)
         ELSE
            CVALUE = ABS(MOD(ISTYL,48))
         ENDIF
         CALL J1IGET(11, STYLE)
         IF (STYLE.NE.1) CALL JPINTR(1)
         CALL J1IGET(12, CCOLOR)
         CALL JPIDEX (CCOLOR, CVALUE)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IFASCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISLN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISLN(LTYPE)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the linestyle primitive attribute.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JLSTYL (CVALUE)
*.
*.   Parameters:
*.   -----------
*.     CVALUE                     [ INTEGER; Input ]
*.
*.      - The new value for the linestyle.
*.
*.        NOTE : CVALUE must be in the range 0...32767.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER VALUE
*.______________________________________
*
      ILN=LTYPE
      IF (LTYPE.EQ.1) THEN
         VALUE = 0
      ELSE IF (LTYPE.EQ.2) THEN
         VALUE = 2
      ELSE IF (LTYPE.EQ.3) THEN
         VALUE = 1
      ELSE IF (LTYPE.EQ.4) THEN
         VALUE = 3
      ELSE IF ((LTYPE.GE.12).AND.(LTYPE.LE.15)) THEN
         VALUE = 0
      ELSE
         VALUE = ABS(MOD(LTYPE,32768))
      ENDIF
      IF (GFLAG) THEN
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JLSTYL (VALUE)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ILNCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISLWSC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISLWSC(WIDTH)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the linewidth primitive attribute.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JLWIDE (CVALUE)
*.
*.   Parameters:
*.   -----------
*.     CVALUE                     [ INTEGER; Input ]
*.
*.      - The new value for the linewidth.
*.
*.        *NOTE* : CVALUE must be in the range 0...32767.
*.      Default linewidth = 16383 (midrange)
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CVALUE, MIDRNG, RANGE(2)
      DATA RANGE(1), RANGE(2), MIDRNG /0, 32767, 16383/
*.______________________________________
*
      RLWSC=WIDTH
      IF (GFLAG) THEN
         IF (WIDTH.LE.1.0) THEN
            CVALUE = INT(WIDTH*FLOAT(MIDRNG))
         ELSE
            CVALUE = MIDRNG + INT(0.25*(WIDTH-1.0)*FLOAT(MIDRNG-1))
         ENDIF
         IF (CVALUE.LT.RANGE(1)) THEN
            CVALUE = RANGE(1)
         ELSE IF (CVALUE.GT.RANGE(2)) THEN
            CVALUE = RANGE(2)
         ENDIF
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JLWIDE (CVALUE)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ILWSCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISMK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISMK(MTYPE)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the marker symbol.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JCMARK (CVALUE)
*.
*.   Parameters:
*.   -----------
*.     CVALUE                     [ INTEGER; Input ]
*.
*.     - The new value for the marker symbol.
*.
*.       *NOTE* : CVALUE must be in the range 1...32767.
*.       *NOTE* : The marker SIZE cannot be changed in DI-3000.
*.
*.       Marker numbers 1..5 are the same on all graphics devices:
*.
*.         1 - point or dot       .
*.         2 - plus sign          +
*.         3 - asterisk           *
*.         4 - capital letter     O
*.         5 - capital letter     X
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
*.______________________________________
*
      IMK=MTYPE
      IF (GFLAG) THEN
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JCMARK(MTYPE)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IMKCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISMKSC, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISMKSC(RMSCF)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the marker scale factor.
*.
*.   DI-3000 access:
*.   ---------------
*.     The marker SIZE cannot be changed in DI-3000.
*.     See JCMARK
*.
*.   Parameters:
*.   -----------
*.     No parameters.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
*.______________________________________
*
      IF(RMSCF.EQ.RMKSC)RETURN
*
*           The marker size cannot be changed in DI-3000
*           But this marker size is usefull fo the HIGZ markers
*
      RMKSC=RMSCF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IMKSCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISPLCI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISPLCI(ICOLI)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set color primitive attribute
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JCOLOR (CVALUE)
*.
*.   Parameters:
*.   -----------
*.
*.     CVALUE                     [ INTEGER; Input ]
*.
*.      - The new value for the color index.
*.
*.        NOTE : CVALUE must be in the range 0...32767.
*.
*.        0 - "Nornal" for the device
*.        1 -  Red
*.        2 -  Green
*.        3 -  Yellow
*.        4 -  Blue
*.        5 -  Magenta
*.        6 -  Cyan
*.        7 -  White
*.        8 -  Black
*.        9 -  Complement of the "normal" device color
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CVALUE, RANGE(2)
      INTEGER MAP(0:7)
      DATA MAP / 9, 0, 1, 2, 4, 3, 5, 6 /
      DATA RANGE(1), RANGE(2) /0, 32767/
*.______________________________________
*
      IPLCI=ICOLI
      IF (GFLAG) THEN
C
C        Perform GKS-->DI3000 mapping for color indices 0-7.
C
         IF((ICOLI.GE.0).AND.(ICOLI.LE.7))THEN
            CVALUE=MAP(ICOLI)
         ELSE
            CVALUE=ICOLI
         ENDIF
         IF((CVALUE.LT.RANGE(1)).OR.(CVALUE.GT.RANGE(2))) CVALUE=0
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JCOLOR (CVALUE)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IPLCCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISPMCI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISPMCI(ICOLI)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the polymarker color index.
*.
*.   DI-3000 access:
*.   ---------------
*.     In DI-3000 one sets current/color primitive attribute.
*.     Use JCOLOR as in HIGZ routine ISCR
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CVALUE, RANGE(2)
      INTEGER MAP(0:7)
      DATA MAP / 9, 0, 1, 2, 4, 5, 6, 3 /
      DATA RANGE(1), RANGE(2) /0, 32767/
*.______________________________________
*
      IPMCI=ICOLI
      IF (GFLAG) THEN
C
C        Perform GKS-->DI3000 mapping for color indeces 0-7.
C
         IF((ICOLI.GE.0).AND.(ICOLI.LE.7))THEN
            CVALUE=MAP(ICOLI)
         ELSE
            CVALUE=ICOLI
         ENDIF
         IF((CVALUE.LT.RANGE(1)).OR.(CVALUE.GT.RANGE(2))) CVALUE=0
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JCOLOR (CVALUE)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(IPMCCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISTXAL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISTXAL(JTXALH,JTXALV)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set current character string justification text attribute.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JJUST (CHORIZ, CVERT)
*.
*.   Parameters:
*.   -----------
*.     CHORIZ                     [ INTEGER; Input ]
*.
*.      - The horizontal character string justification of subsequent
*.        text primitives within the currently OPEN segment.
*.
*.        *NOTE* : CHORIZ must be in the range 1 to 3.
*.
*.     CVERT                      [ INTEGER; Input ]
*.
*.      - The vertical character string justification of subsequent
*.        text primitives within the currently OPEN segment.
*.
*.        *NOTE* : CVERT must be in the range 1 to 3.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
      INTEGER CHORIZ, CVERT
+CDE, DI3SEG.
*.______________________________________
*
      ITXALH=JTXALH
      ITXALV=JTXALV
      IF (GFLAG) THEN
*
*        Convert GKS text alignment numbers into DI3000 text alignment numbers.
*
         IF (JTXALH.EQ.0) THEN
            CHORIZ = 1
         ELSE
            CHORIZ = JTXALH
         ENDIF
         IF (JTXALV.EQ.0) THEN
            CVERT = 1
         ELSE IF (JTXALV.EQ.1) THEN
            CVERT = 3
         ELSE IF (JTXALV.EQ.2) THEN
            CVERT = 3
         ELSE IF (JTXALV.EQ.3) THEN
            CVERT = 2
         ELSE IF (JTXALV.EQ.4) THEN
            CVERT = 1
         ELSE IF (JTXALV.EQ.5) THEN
            CVERT = 1
         ENDIF
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JJUST (CHORIZ,CVERT)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      ITXALG=10*JTXALH+JTXALV
      IF(GLFLAG)CALL IZATT(ITXACO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISTXCI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:29  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISTXCI(ICOLI)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the text color index
*.
*.   DI-3000 access:
*.   ---------------
*.     DI-3000 sets current/color primitive attribute.
*.     Use JCOLOR via HIGZ routine ISCR.
*.     CVALUE must be in the range 0...32767
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CVALUE, RANGE(2)
      INTEGER MAP(0:7)
      DATA MAP / 9, 0, 1, 2, 4, 5, 6, 3 /
      DATA RANGE(1), RANGE(2) /0, 32767/
*.______________________________________
*
      ITXCI=ICOLI
      IF (GFLAG) THEN
C
C        Perform GKS-->DI3000 mapping for color indices 0-7.
C
         IF((ICOLI.GE.0).AND.(ICOLI.LE.7))THEN
            CVALUE=MAP(ICOLI)
         ELSE
            CVALUE=ICOLI
         ENDIF
         IF((CVALUE.LT.RANGE(1)).OR.(CVALUE.GT.RANGE(2))) CVALUE=0
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JCOLOR (CVALUE)
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IF(GLFLAG)CALL IZATT(ITXCCO)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISTXFP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISTXFP(JJFONT,JPREC)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set character font text attribute.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JFONT (CVALUE)
*.
*.   Parameters:
*.   -----------
*.     CVALUE                     [ INTEGER; Input ]
*.
*.      - The new value for the character font.
*.
*.        *NOTE* : CVALUE must be in the range 1...32767.
*.            GKS: CFONT  must be in the range 1...30
*.            GKS: CPREC  must be in the range 1...4
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIATT.
+SELF, IF=DI3000, IF=ZEBRA.
+CDE, HICODE.
+SELF, IF=DI3000.
+CDE, HIFLAG.
+CDE, DI3SEG.
      INTEGER CFONT
*.______________________________________
*
      IFONT=JJFONT
      IPREC=JPREC
+SELF, IF=DI3000, IF=ZEBRA,MAIL.
      IFTPR=10*JJFONT+ISIGN(1,JJFONT)*JPREC
      IF(GLFLAG)CALL IZATT(ITXFCO)
+SELF, IF=DI3000.
      IF (JJFONT.LT.0) THEN
         IF (JJFONT.EQ.-1) THEN
            CFONT=1
         ELSEIF (JJFONT.EQ.-2) THEN
            CFONT=3
         ELSEIF (JJFONT.EQ.-3) THEN
            CFONT=5
         ELSEIF (JJFONT.EQ.-4) THEN
            CFONT=7
         ELSEIF (JJFONT.EQ.-5) THEN
            CFONT=6
         ELSEIF (JJFONT.EQ.-6) THEN
            CFONT=8
         ELSEIF (JJFONT.EQ.-101) THEN
            CFONT=2
         ELSEIF (JJFONT.EQ.-102) THEN
            CFONT=4
         ELSEIF (JJFONT.EQ.-103) THEN
            CFONT=6
         ELSEIF (JJFONT.EQ.-104) THEN
            CFONT=8
         ELSEIF (JJFONT.EQ.-105) THEN
            CFONT=6
         ELSEIF (JJFONT.EQ.-106) THEN
            CFONT=8
         ELSEIF (JJFONT.EQ.-107) THEN
            CFONT=11
         ELSEIF (JJFONT.EQ.-108) THEN
            CFONT=12
         ELSEIF (JJFONT.EQ.-109) THEN
            CFONT=15
         ELSEIF (JJFONT.EQ.-110) THEN
            CFONT=17
         ELSEIF (JJFONT.EQ.-201) THEN
            CFONT=1
         ELSEIF (JJFONT.EQ.-202) THEN
            CFONT=3
         ELSEIF (JJFONT.EQ.-203) THEN
            CFONT=5
         ELSEIF (JJFONT.EQ.-204) THEN
            CFONT=7
         ELSE
            CFONT=1
         ENDIF
      ELSEIF ((JJFONT.EQ.0).AND.(JPREC.EQ.2)) THEN
         RETURN
      ELSE
         CFONT=MAX(MOD(JJFONT,32768),1)
      ENDIF
      IF (GFLAG) THEN
         IF (.NOT. SEGOPN) THEN
            CALL JOPEN
            SEGOPN=.TRUE.
         ENDIF
         CALL JFONT (CFONT)
      ENDIF
*
      END
+SELF.
+DECK,  ISVP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISVP(NT,XX1,XX2,YY1,YY2)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Define the boundaries of the virtual coordinate system viewport
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JVPORT (VXMIN, VMAX, VYMIN, VYMAX)
*.
*.   Parameters:
*.   -----------
*.      VXMIN, VXMAX                  [ REAL; Input ]
*.
*.       - The minimum and maximum virtual coordinate system viewport
*.         boundaries in the X-direction
*.
*.      VYMIN, VYMAX                  [ REAL; Input ]
*.
*.       - The minimum and maximum virtual coordinate system viewport
*.         boundaries in the Y-direction
*.
*.         NOTE: One of the two boundary pairs must be equal (-1.0, 1.0)
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HINT.
+CDE, HIFLAG.
+CDE, HIATT.
+CDE, DI3SEG.
*.______________________________________
*
*              Verify the viewport parameters
*
      X1 = XX1
      X2 = XX2
      Y1 = YY1
      Y2 = YY2
      IF((X1.LT.0).OR.(X1.GT.1)
     +            .OR.
     +   (X2.LT.0).OR.(X2.GT.1)
     +            .OR.
     +   (Y1.LT.0).OR.(Y1.GT.1)
     +            .OR.
     +   (Y2.LT.0).OR.(Y2.GT.1)
     +            .OR.
     +   (Y1.GE.Y2).OR.(X1.GE.X2))THEN
         CALL IGERR('Invalid viewport definition','ISVP')
         RETURN
      ENDIF
*
      IF(NT.EQ.0)RETURN
*
      SCALE = 1.
      IF(REDIT.NE.0.)SCALE = REDIT
+SELF, IF=DI3000, IF=-NTC.
*
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
*              NT exits in the main transformation storage
*
      IF(IFIND.NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF(GFLAG)THEN
               IF(SEGOPN) THEN
                  CALL JCLOSE
                  SEGOPN = .FALSE.
               ENDIF
               CALL JVPORT (X1,X2,Y1,Y2)
            ENDIF
            RVXMIN = X1
            RVYMIN = Y1
            RVXMAX = X2
            RVYMAX = Y2
         ENDIF
         WNVPST(IAWV+4) = X1
         WNVPST(IAWV+5) = X2
         WNVPST(IAWV+6) = Y1
         WNVPST(IAWV+7) = Y2
*
*              NT does not exit in the main transformation storage
*
      ELSE
         NBNT = NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISVP')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2) = NT
         WNVPST(8*NBNT+1) = 0.
         WNVPST(8*NBNT+2) = 1.
         WNVPST(8*NBNT+3) = 0.
         WNVPST(8*NBNT+4) = 1.
         WNVPST(8*NBNT+5) = X1
         WNVPST(8*NBNT+6) = X2
         WNVPST(8*NBNT+7) = Y1
         WNVPST(8*NBNT+8) = Y2
         NTSTOR(1)        = NTSTOR(1)+1
      ENDIF
+SELF, IF=DI3000, IF=NTC.
      IF(IGNSCU(NT).NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF(GFLAG)THEN
               IF(SEGOPN) THEN
                  CALL JCLOSE
                  SEGOPN = .FALSE.
               ENDIF
               CALL JVPORT (X1,X2,Y1,Y2)
            ENDIF
            RVXMIN = X1
            RVYMIN = Y1
            RVXMAX = X2
            RVYMAX = Y2
         ENDIF
      ELSE
         CALL IGNCRE(NT)
      ENDIF
      CALL IGNSVP(X1,X2,Y1,Y2)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ISWKVP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISWKVP(WKID,X1,X2,Y1,Y2)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the workstation transformation window.
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JVPORT (VXMIN, VXMAX, VYMIN, VXMAX)
*.
*.        VXMIN, VXMAX     [ REAL; Input ]
*.         - The minimum and maximum virtual coordinate system
*.           vieport boundaries in the X-direction
*.
*.        VYMIN, VYMAX     [ REAL; Input ]
*.         - The minimum and maximum virtual coordinate system
*.           vieport boundaries in the Y-direction
*.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIFLAG.
+CDE, HIATT.
      INTEGER WKID
+CDE, DI3SEG.
*.______________________________________
*
      RDVXMI=X1
      RDVXMA=X2
      RDVYMI=Y1
      RDVYMA=Y2
      IF(IGIWTY(WKID).LT.0)RETURN
*
      IF(GFLAG)THEN
         IF (SEGOPN) THEN
            CALL JCLOSE
            SEGOPN = .FALSE.
         ENDIF
         CALL JDEVVP (WKID, X1, X2, Y1, Y2)
      ENDIF
*
      END
+SELF.
+DECK,  ISWKWN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISWKWN(WKID,X1,X2,Y1,Y2)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the workstation transformation window
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JDEVWN (DSPDEV, VXMIN, VXMAX, VYMIN, VYMAX)
*.
*.        DSPDEV
*.         - The identifer of the display device for
*.           which the device window is being defined
*.
*.        VXMIN, VXMAX
*.         - The minimum and maximum devcie window boundaries
*.           in the X-direction in virtual coordinates.
*.           VXMIN and VXMAX must be in the range:
*.           (-1.0 .le. XMIN .le. XMAX .le 1.0)
*.
*.        VYMIN, VYMAX
*.         - The minimum and maximum devcie window boundaries
*.           in the Y-direction in virtual coordinates.
*.           VYMIN and VYMAX must be in the range:
*.           (-1.0 .le. YMIN .le. YMAY .le 1.0)
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIFLAG.
+CDE, HIATT.
      INTEGER WKID
+CDE, DI3SEG.
*.______________________________________
*
      IF((X1.LT.0.).OR.(X1.GT.1.)
     +            .OR.
     +   (X2.LT.0.).OR.(X2.GT.1.)
     +            .OR.
     +   (Y1.LT.0.).OR.(Y1.GT.1.)
     +            .OR.
     +   (Y2.LT.0.).OR.(Y2.GT.1.))THEN
         CALL IGERR('Bad window or viewport size','ISWKWN')
         RETURN
      ENDIF
*
      RDWXMI=X1
      RDWXMA=X2
      RDWYMI=Y1
      RDWYMA=Y2
      IF(IGIWTY(WKID).LT.0)RETURN
*
      IF(GFLAG)THEN
         IF (SEGOPN) THEN
            CALL JCLOSE
            SEGOPN = .FALSE.
         ENDIF
         CALL JDEVWN (WKID, X1, X2, Y1, Y2)
      ENDIF
*
      END
+SELF.
+DECK,  ISWN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ISWN(NT,XX1,XX2,YY1,YY2)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Set the window coordinates of the transformation NT
*.
*.   DI-3000 access:
*.   ---------------
*.     ***** ***** *****
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HINT.
+CDE, HIFLAG.
+CDE, HIATT.
+CDE, DI3SEG.
*.______________________________________
*
      IF(NT.EQ.0)RETURN
*
      X1 = XX1
      X2 = XX2
      Y1 = YY1
      Y2 = YY2
*
+SELF, IF=DI3000, IF=-NTC.
      CALL IZGNT(NT,IFIND,IAWV,IPRIO,IHPRIO)
*
*              NT exits in the main transformation storage
*
      IF(IFIND.NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF (GFLAG) THEN
               IF(SEGOPN) THEN
                  CALL JCLOSE
                  SEGOPN = .FALSE.
               ENDIF
               CALL JWINDO (X1, X2, Y1, Y2)
            ENDIF
            RWXMIN = X1
            RWYMIN = Y1
            RWXMAX = X2
            RWYMAX = Y2
         ENDIF
         WNVPST(IAWV)   = X1
         WNVPST(IAWV+1) = X2
         WNVPST(IAWV+2) = Y1
         WNVPST(IAWV+3) = Y2
*
*              NT does not exit in the main transformation storage
*
      ELSE
         NBNT=NTSTOR(1)
         IF(NBNT+1.GT.NBNTMX)THEN
            CALL IGERR('Too many normalisation transformation','ISWN')
            RETURN
         ENDIF
         NTSTOR(2*NBNT+2) = NT
         WNVPST(8*NBNT+1) = X1
         WNVPST(8*NBNT+2) = X2
         WNVPST(8*NBNT+3) = Y1
         WNVPST(8*NBNT+4) = Y2
         WNVPST(8*NBNT+5) = 0.
         WNVPST(8*NBNT+6) = 1.
         WNVPST(8*NBNT+7) = 0.
         WNVPST(8*NBNT+8) = 1.
         NTSTOR(1)        = NTSTOR(1)+1
      ENDIF
+SELF, IF=DI3000, IF=NTC.
      IF(IGNSCU(NT).NE.0)THEN
         IF((INTR.EQ.NT).AND.GFLAG)THEN
            IF(GFLAG)THEN
               IF(SEGOPN) THEN
                  CALL JCLOSE
                  SEGOPN = .FALSE.
               ENDIF
               CALL JWINDO (X1, X2, Y1, Y2)
            ENDIF
            RWXMIN = X1
            RWYMIN = Y1
            RWXMAX = X2
            RWYMAX = Y2
         ENDIF
      ELSE
         CALL IGNCRE(NT)
      ENDIF
      CALL IGNSWN(X1,X2,Y1,Y2)
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  ITX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE ITX(X,Y,CHARS)
*.===========>
*.
*.   Purpose:
*.   --------
*.     Output a graphics arts quality text string as an output primnitive
*.
*.   DI-3000 access:
*.   ---------------
*.     CALL JHSTRG (STRING)
*.
*.   Parameters:
*.   -----------
*.     STRING                     [ CHARACTER; Input ]
*.
*.      - The literal string to be output as a graphic arts quality text
*.         primitive.
*.
*.      *NOTE* :  The current position is unchanged when JHSTRG returns
*.                to the calling program.
*.
*..==========> (O.Couet, H.Johnstad, L.Roberts)
+CDE, HIFLAG.
+CDE, HIATT.
      CHARACTER*(*) CHARS
      CHARACTER*1 CHOPT
      LOGICAL ZFSAV,PFSAV
+CDE, DI3SEG.
*.______________________________________
*
      ILEN=LENOCC(CHARS)
      IF(ILEN.EQ.0)RETURN
      IF(GFLAG)THEN
         CALL IGSG(0)
         IF((IFONT.EQ.0.AND.IPREC.EQ.2).OR.
     +      (IFONT.LT.0.AND.IFONT.GT.-25.AND.IPREC.EQ.1))THEN
            IF((ITXALH.EQ.0).OR.(ITXALH.EQ.1))CHOPT='L'
            IF(ITXALH.EQ.2)THEN
               CHOPT = 'C'
            ELSEIF(ITXALH.EQ.3)THEN
               CHOPT = 'R'
            ELSE
               CHOPT = 'L'
            ENDIF
            IF((ITXALV.EQ.2).OR.(ITXALV.EQ.1))THEN
               YY = Y-RCHH*COS((3.14159/180.)*RANGLE)
               XX = X+RCHH*SIN((3.14159/180.)*RANGLE)
            ELSEIF(ITXALV.EQ.3)THEN
               YY = Y-(RCHH/2.)*COS((3.14159/180.)*RANGLE)
               XX = X+(RCHH/2.)*SIN((3.14159/180.)*RANGLE)
            ELSE
               YY = Y
               XX = X
            ENDIF
            ZFSAV  = ZFLAG
            ZFLAG  = .FALSE.
            PFSAV  = PFLAG
            PFLAG  = .FALSE.
            GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
            CALL IGTEXT(XX,YY,CHARS,RCHH,RANGLE,CHOPT)
            ZFLAG  = ZFSAV
            PFLAG  = PFSAV
            GLFLAG = (ZFLAG.OR.PFLAG.OR.MFLAG)
         ELSE
            IF (.NOT. SEGOPN) THEN
               CALL JOPEN
               SEGOPN=.TRUE.
            ENDIF
            CALL JMOVE (X, Y)
            IF (IPREC.EQ.0) THEN
               CALL J1STRG (CHARS (1:ILEN))
            ELSEIF (IPREC.EQ.1) THEN
               CALL J2STRG (CHARS (1:ILEN))
            ELSE
               CALL JHSTRG (CHARS (1:ILEN))
            ENDIF
         ENDIF
      ENDIF
+SELF, IF=DI3000, IF=ZEBRA,PSCRIPT,MAIL.
      IF(GLFLAG)CALL IZTX(X,Y,CHARS(1:ILEN))
+SELF, IF=DI3000.
*
      END
+SELF.
+DECK,  IUWK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE IUWK(IWKID,IRFLG)
      IF (IRFLG.NE.0) CALL JUPDAT
      END
+SELF.
+DECK,  RGTOHS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:30  mclareni
* Higz
+SELF, IF=DI3000.

      SUBROUTINE RGTOHS (RED, GREEN, BLUE, HUE, SATUR, LIGHT)
*.===========>
*.
*.   Convert RGB to HSL
*.
*..==========> (L.Roberts)
C
C
      REAL               RED, GREEN, BLUE
      INTEGER                              HUE, SATUR, LIGHT
C
      REAL RNORM, GNORM, BNORM, MINVAL, MAXVAL, MSUM, MDIFF
      REAL RLIGHT, RHUE, RSATUR
C
C     ***** CONVERT RGB TO HSL
C
C
C           ***** Find the maximum and minimum of the RGB values.
C
      MINVAL = MIN (RED, GREEN, BLUE)
      MAXVAL = MAX (RED, GREEN, BLUE)
C
C           ***** Find the normalized RGB values.
C
      RNORM = 0.0
      GNORM = 0.0
      BNORM = 0.0
      MDIFF = MAXVAL - MINVAL
      MSUM = MAXVAL + MINVAL
      IF (MAXVAL .EQ. MINVAL) GO TO 1000
      RNORM = (MAXVAL - RED) / MDIFF
      GNORM = (MAXVAL - GREEN) / MDIFF
      BNORM = (MAXVAL - BLUE) / MDIFF
C
 1000 CONTINUE
C
C           ***** Calculate the lightness.
C
      RLIGHT = MSUM / 2.0
C
C           ***** If the maximum and minimum RGB values are equal,
C           ***** then the saturation and hue are both 0.
C
      IF (MAXVAL .NE. MINVAL) GO TO 2000
      RSATUR = 0.0
      RHUE = 0.0
      GO TO 3000
C
 2000 CONTINUE
C
C              ***** Calculate the saturation.
C
      IF (RLIGHT .LE. 0.5) RSATUR = MDIFF / MSUM
      IF (RLIGHT .GT. 0.5) RSATUR = MDIFF / (2.0 - MSUM)
C
C              ***** Calculate the hue.
C
      IF (RED .EQ. MAXVAL) RHUE = 60.0 * (2.0 + BNORM - GNORM)
      IF (GREEN .EQ. MAXVAL) RHUE = 60.0 * (4.0 + RNORM - BNORM)
      IF (BLUE .EQ. MAXVAL) RHUE = 60.0 * (6.0 + GNORM - RNORM)
C
 3000 CONTINUE
      IF (RHUE .GT. 360.0) RHUE = RHUE - 360.0
C
      HUE = IFIX(RHUE)
      LIGHT = IFIX(RLIGHT * 32767.0)
      SATUR = IFIX(RSATUR * 32767.0)
C
99999 CONTINUE
C
      RETURN
      END
+SELF.
+PATCH, HIGZCC.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
DoIncludePackage(higz)
#include "pilot.h"

SRCS_C=	igvers.c

#if defined(CERNLIB_FALCO) && !defined(CERNLIB_VAX)
SRCS_C := $(SRCS_C) falint.c
#endif

#if defined(CERNLIB_GIF)
SRCS_C := $(SRCS_C) gifdecode.c gifencode.c imgpickpalette.c
#endif

#if defined(CERNLIB_UNIX) && defined(CERNLIB_CCREAD)
SRCS_C := $(SRCS_C) ixgetl.c
#endif

#if defined(CERNLIB_NTC)
SRCS_C := $(SRCS_C) ntmgt.c
#endif

#if defined(CERNLIB_X11) && !defined(CERNLIB_WINNT)
SRCS_C := $(SRCS_C) rotated.c x11int.c
#endif

#if defined(CERNLIB_TKTCL)
SRCS_C := $(SRCS_C) tkhigz.c
#endif

#if defined(CERNLIB_ZBUF)
SRCS_C := $(SRCS_C) zbuffer.c
#endif

#if defined(CERNLIB_X11)
INCLUDES:= $(INCLUDES) X11Includes
#endif


SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

DefaultCObjectRule(dgks)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  FALINT, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.4  1997/10/23 12:29:51  mclareni
 * NT mods
 *
 * Revision 1.2  1997/03/14 14:22:27  mclareni
 * WNT mods
 *
 * Revision 1.1.1.1.2.1  1997/01/21 11:25:21  mclareni
 * All mods for Winnt 96a on winnt branch
 *
 * Revision 1.1.1.1  1996/02/14 13:10:25  mclareni
 * Higz
 *
 */

+SELF, IF=FALCO, IF=-VAX.
/*CMZ :  1.23/06 22/11/95  10.36.54  by  O.Couet*/
/*-- Author :*/
/*
 * C code for HIGZ/FALCO interface
 */
+SELF, IF=FALCO, IF=-VAX, IF=WINNT.
# include <io.h>
+SELF, IF=FALCO, IF=-VAX, IF=CRAY.
#define ifput1   IFPUT1
+SELF, IF=FALCO, IF=-VAX, IF=QX_SC.
#define ifput1   ifput1_
+SELF, IF=FALCO, IF=-VAX, IF=TKTCL, IF=WINNT,QFMSOFT.
#define ifput1 __stdcall IFPUT1
+SELF, IF=FALCO, IF=-VAX.

static char lbout [256];

void ifput1(bout,ipout)
int *bout;
int *ipout;
      {
      int i;

      for (i=0 ; i < *ipout ; i++)
        lbout[i] = (char)(bout[i]);
      write(1, lbout, *ipout);
}
+SELF.
+DECK,  GIFDECODE, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.1.1.1  1996/02/14 13:10:25  mclareni
 * Higz
 *
 */

+SELF, IF=GIF.
/*CMZ :  1.23/06 30/11/95  10.45.47  by  O.Couet*/
/*-- Author :    O.Couet   30/11/95*/
#include <stdio.h>
#include <string.h>


#define BITS    12                      /* largest code size */
#define TSIZE   4096                    /* tables size */

typedef unsigned char byte;

static int      Prefix[TSIZE];          /* prefix table */
static byte     Suffix[TSIZE];          /* suffix table */
static byte     OutCode[TSIZE];         /* output stack */

static byte     *ptr1,                  /* pointer to GIF array */
                *ptr2;                  /* pointer to PIX array */

static int      CurCodeSize,            /* current number of bits per code */
                CurMaxCode;             /* maximum code, given CurCodeSize */

static long     CurBit;                 /* current bit in GIF image data */

/***************************************************************
 *                                                             *
 ***************************************************************/
static int ReadCode()
{
  static long   b3[3], CurByte;
  static byte   lblk;
  int           shift, nbyte;
  long          OldByte;

  if (CurBit == -1) {
    lblk = 0;
    CurByte = -1;
  }

  CurBit += CurCodeSize;
  OldByte = CurByte;
  CurByte = CurBit/8;
  nbyte   = CurByte - OldByte;
  shift   = 17 + (CurBit%8) - CurCodeSize;
  while (nbyte-- > 0) {
    if (lblk == 0) {
      lblk = *ptr1++;
      if (lblk == 0) return -1;
    }
    b3[0] = b3[1];
    b3[1] = b3[2];
    b3[2] = *ptr1++;
    lblk--;
  }
  return (((b3[0]+0x100*b3[1]+0x10000*b3[2])>>shift) & (CurMaxCode-1));
}

/***************************************************************
 *                                                             *
 ***************************************************************/
static void OutPixel(pix)
                byte pix;
{
  *ptr2++ = pix;
}

/***************************************************************
 *                                                             *
 * Name: GIFinfo                                Date: 03.10.94 *
 *                                                             *
 * Function: Get information on GIF image                      *
 *                                                             *
 * Input: GIFarr[] - compressed image in GIF format            *
 *                                                             *
 * Output: Width    - image width                              *
 *         Height   - image height                             *
 *         Ncols    - number of colors                         *
 *         return   - 0 - if O.K.                              *
 *                    1 - if error                             *
 *                                                             *
 ***************************************************************/
int GIFinfo(GIFarr, Width, Height, Ncols)
      byte *GIFarr;
       int *Width,*Height,*Ncols;
{
  byte          b;

  ptr1 = GIFarr;

  /*   R E A D   H E A D E R   */

  if (strncmp((char *)GIFarr,"GIF87a",6) && strncmp((char *)GIFarr,"GIF89a",6))
  {
    fprintf(stderr,"\nGIFinfo: not a GIF\n");
    return 1;
  }

  ptr1 += 6;

  ptr1 += 2;                            /* screen width ... ignore */
  ptr1 += 2;                            /* screen height ... ignore */

  b         = *ptr1++;
  *Ncols    = 1 << ((b & 7) + 1);
  if ((b & 0x80) == 0) {                /* is there color map? */
    fprintf(stderr,"\nGIFinfo: warning! no color map\n");
    *Ncols = 0;
  }

  ++ptr1;                               /* background color ... ignore */
  b      = *ptr1++;                     /* supposed to be NULL */
  if (b) {
    fprintf(stderr,"\nGIFdecode: bad screen descriptor\n");
    return 1;
  }

  ptr1 += (*Ncols) * 3;                 /* skip color map */

  b      = *ptr1++;                     /* image separator */
  if (b != ',') {
    fprintf(stderr,"\nGIFinfo: no image separator\n");
    return 1;
  }

  ptr1   += 2;                          /* left offset ... ignore */
  ptr1   += 2;                          /* top offset ... ignore */
  b       = *ptr1++;                    /* image width */
  *Width  = b + 0x100*(*ptr1++);
  b       = *ptr1++;                    /* image height */
  *Height = b + 0x100*(*ptr1++);
  return 0;
}

/***************************************************************
 *                                                             *
 * Name: GIFdecode                              Date: 06.10.92 *
 *                                                             *
 * Function: Decode image from GIF array                       *
 *                                                             *
 * Input: GIFarr[] - compressed image in GIF format            *
 *                                                             *
 * Output: PIXarr[] - image (byte per pixel)                   *
 *         Width    - image width                              *
 *         Height   - image height                             *
 *         Ncols    - number of colors                         *
 *         R[]      - red components                           *
 *         G[]      - green components                         *
 *         B[]      - blue components                          *
 *         return   - 0 - if O.K.                              *
 *                    1 - if error                             *
 *                                                             *
 ***************************************************************/
int GIFdecode(GIFarr, PIXarr, Width, Height, Ncols, R, G, B)
        byte *GIFarr,*PIXarr,*R,*G,*B;
         int *Width,*Height,*Ncols;
{
  byte          b,                      /* working variable */
                FinChar;                /* final character */

  int           i,                      /* working variable for loops */
                BitsPixel,              /* number of bits per pixel */
                IniCodeSize,            /* initial number of bits per code */
                ClearCode,              /* reset code */
                EOFCode,                /* end of file code */
                FreeCode,               /* first unused entry */
                CurCode,                /* current code */
                InCode,                 /* input code */
                OldCode,                /* previous code */
                PixMask,                /* mask for pixel */
                OutCount;               /* output stack counter */

  long          Npix;                   /* number of pixels */

  ptr1 = GIFarr;
  ptr2 = PIXarr;

  /*   R E A D   H E A D E R   */
  if (strncmp((char *)GIFarr,"GIF87a",6) && strncmp((char *)GIFarr,"GIF89a",6))
  {
    fprintf(stderr,"\nGIFinfo: not a GIF\n");
    return 1;
  }

  ptr1 += 6;

  ptr1 += 2;                            /* screen width ... ignore */
  ptr1 += 2;                            /* screen height ... ignore */

  b         = *ptr1++;
  BitsPixel = (b & 7) + 1;              /* # of bits per pixel */
  *Ncols    = 1 << BitsPixel;
  PixMask   = (*Ncols) - 1;             /* mask for pixel code */
  if ((b & 0x80) == 0) {                /* is there color map? */
    fprintf(stderr,"\nGIFdecode: warning! no color map\n");
    *Ncols = 0;
  }

  ++ptr1;                               /* background color ... ignore */
  b      = *ptr1++;                     /* supposed to be NULL */
  if (b) {
    fprintf(stderr,"\nGIFdecode: bad screen descriptor\n");
    return 1;
  }

  for (i=0; i<(*Ncols); i++) {          /* global color map */
    R[i] = *ptr1++;
    G[i] = *ptr1++;
    B[i] = *ptr1++;
  }

  b      = *ptr1++;                     /* image separator */
  if (b != ',') {
    fprintf(stderr,"\nGIFdecode: no image separator\n");
    return 1;
  }

  ptr1   += 2;                          /* left offset ... ignore */
  ptr1   += 2;                          /* top offset ... ignore */
  b       = *ptr1++;                    /* image width */
  *Width  = b + 0x100*(*ptr1++);
  b       = *ptr1++;                    /* image height */
  *Height = b + 0x100*(*ptr1++);

  b       = *ptr1++;                    /* local colors, interlace */
  if ((b & 0xc0) != 0) {
    fprintf(stderr,
            "\nGIFdecode: unexpected item (local colors or interlace)\n");
    return 1;
  }

  IniCodeSize = *ptr1++;
  CurCodeSize = ++IniCodeSize;
  CurMaxCode  = (1 << IniCodeSize);
  ClearCode   = (1 << (IniCodeSize - 1));
  EOFCode     = ClearCode + 1;
  FreeCode    = ClearCode + 2;

  /*   D E C O D E    I M A G E   */

  Npix     =(long) (*Width) * (*Height);
  OutCount = 0;
  CurBit   = -1;
  CurCode  = ReadCode();
  while (Npix > 0) {

    if (CurCode < 0) {
      fprintf(stderr,"\nGIFdecode: corrapted GIF (zero block length)\n");
      return 1;
    }

    if (CurCode == EOFCode) {
      fprintf(stderr,"\nGIFdecode: corrapted GIF (unexpected EOF)\n");
      return 1;
    }

    if (CurCode == ClearCode) {         /* clear code ... reset */

      CurCodeSize = IniCodeSize;
      CurMaxCode  = (1 << IniCodeSize);
      FreeCode    = ClearCode + 2;
      OldCode     = CurCode = ReadCode();
      FinChar     = CurCode;
      OutPixel(FinChar);
      Npix--;

    } else {                            /* image code */

      InCode = CurCode;
      if (CurCode >= FreeCode) {
        CurCode = OldCode;
        OutCode[OutCount++] = FinChar;
      }
      while (CurCode > PixMask) {       /* build output pixel chain */
        if (OutCount >= TSIZE) {
          fprintf(stderr,"\nGIFdecode: corrapted GIF (big output count)\n");
          return 1;
        }
      OutCode[OutCount++] = Suffix[CurCode];
      CurCode = Prefix[CurCode];
      }
      FinChar = CurCode;
      OutCode[OutCount++] = FinChar;

      for (i=OutCount-1; i>=0; i--) {   /* put out pixel chain */
        OutPixel(OutCode[i]);
        Npix--;
      }
      OutCount = 0;

      Prefix[FreeCode] = OldCode;       /* build the tables */
      Suffix[FreeCode] = FinChar;
      OldCode = InCode;

      FreeCode++;                       /* move pointer */
      if (FreeCode >= CurMaxCode) {
        if (CurCodeSize < BITS) {
          CurCodeSize++;
          CurMaxCode *= 2;
        }
      }
    }
    CurCode = ReadCode();
  }
  return 0;
}

+SELF.
+DECK,  GIFENCODE, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.1.1.1  1996/02/14 13:10:25  mclareni
 * Higz
 *
 */

+SELF, IF=GIF.
/*CMZ :  1.21/10 04/10/94  14.25.09  by  O.Couet*/
/*-- Author :    E.Chernyaev   19/01/94*/
#include <stdio.h>
#include <stdlib.h>

#ifdef __STDC__
#define ARGS(alist) alist
#else
#define ARGS(alist) ()
#endif

#define BITS     12                     /* largest code size */
#define THELIMIT 4096                   /* NEVER generate this */
#define HSIZE    5003                   /* hash table size */
#define SHIFT    4                      /* shift for hashing */

#define put_byte(A) (*put_b)((byte)(A)); Nbyte++

typedef unsigned char byte;

static long     HashTab [HSIZE];        /* hash table */
static int      CodeTab [HSIZE];        /* code table */

static int      BitsPixel,              /* number of bits per pixel */
                IniCodeSize,            /* initial number of bits per code */
                CurCodeSize,            /* current number of bits per code */
                CurMaxCode,             /* maximum code, given CurCodeSize */
                ClearCode,              /* reset code */
                EOFCode,                /* end of file code */
                FreeCode;               /* first unused entry */

static long      Nbyte;
static void     (*put_b) ARGS((byte));

static void     output ARGS((int));
static void     char_init();
static void     char_out ARGS((int));
static void     char_flush();
static void     put_short ARGS((int));

/***********************************************************************
 *                                                                     *
 * Name: GIFencode                                   Date:    02.10.92 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: GIF compression of the image                              *
 *                                                                     *
 * Input: Width      - image width  (must be >= 8)                     *
 *        Height     - image height (must be >= 8)                     *
 *        Ncol       - number of colors                                *
 *        R[]        - red components                                  *
 *        G[]        - green components                                *
 *        B[]        - blue components                                 *
 *        ScLine[]   - array for scan line (byte per pixel)            *
 *        get_scline - user routine to read scan line:                 *
 *                       get_scline(y, Width, ScLine)                  *
 *        pb         - user routine for "put_byte": pb(b)              *
 *                                                                     *
 * Return: size of GIF                                                 *
 *                                                                     *
 ***********************************************************************/
long GIFencode(Width, Height, Ncol, R, G, B, ScLine, get_scline, pb)
          int  Width, Height, Ncol;
          byte R[], G[], B[], ScLine[];
          void (*get_scline) ARGS((int, int, byte *)), (*pb) ARGS((byte));
{
  long          CodeK;
  int           ncol, i, x, y, disp, Code, K;

  /*   C H E C K   P A R A M E T E R S   */

  if (Width <= 0 || Width > 4096 || Height <= 0 || Height > 4096) {
    fprintf(stderr,
            "\nGIFencode: incorrect image size: %d x %d\n", Width, Height);
    return 0;
  }

  if (Ncol <= 0 || Ncol > 256) {
    fprintf(stderr,"\nGIFencode: wrong number of colors: %d\n", Ncol);
    return 0;
  }

  /*   I N I T I A L I S A T I O N   */

  put_b  = pb;
  Nbyte  = 0;
  char_init();                          /* initialise "char_..." routines */

  /*   F I N D   #   O F   B I T S   P E R    P I X E L   */

  BitsPixel = 1;
  if (Ncol > 2)   BitsPixel = 2;
  if (Ncol > 4)   BitsPixel = 3;
  if (Ncol > 8)   BitsPixel = 4;
  if (Ncol > 16)  BitsPixel = 5;
  if (Ncol > 32)  BitsPixel = 6;
  if (Ncol > 64)  BitsPixel = 7;
  if (Ncol > 128) BitsPixel = 8;

  ncol  = 1 << BitsPixel;
  IniCodeSize = BitsPixel;
  if (BitsPixel <= 1) IniCodeSize = 2;

  /*   W R I T E   H E A D E R  */

  put_byte('G');                        /* magic number: GIF87a */
  put_byte('I');
  put_byte('F');
  put_byte('8');
  put_byte('7');
  put_byte('a');

  put_short(Width);                     /* screen size */
  put_short(Height);

  K  = 0x80;                            /* yes, there is a color map */
  K |= (8-1)<<4;                        /* OR in the color resolution */
  K |= (BitsPixel - 1);                 /* OR in the # of bits per pixel */
  put_byte(K);

  put_byte(0);                          /* background color */
  put_byte(0);                          /* future expansion byte */

  for (i=0; i<Ncol; i++) {              /* global colormap */
    put_byte(R[i]);
    put_byte(G[i]);
    put_byte(B[i]);
  }
  for (; i<ncol; i++) {
    put_byte(0);
    put_byte(0);
    put_byte(0);
  }

  put_byte(',');                        /* image separator */
  put_short(0);                         /* left offset of image */
  put_short(0);                         /* top offset of image */
  put_short(Width);                     /* image size */
  put_short(Height);
  put_byte(0);                          /* no local colors, no interlace */
  put_byte(IniCodeSize);                /* initial code size */

  /*   L W Z   C O M P R E S S I O N   */

  CurCodeSize = ++IniCodeSize;
  CurMaxCode  = (1 << (IniCodeSize)) - 1;
  ClearCode   = (1 << (IniCodeSize - 1));
  EOFCode     = ClearCode + 1;
  FreeCode    = ClearCode + 2;
  output(ClearCode);
  for (y=0; y<Height; y++) {
    (*get_scline)(y, Width, ScLine);
    x     = 0;
    if (y == 0)
      Code  = ScLine[x++];
    while(x < Width) {
      K     = ScLine[x++];              /* next symbol */
      CodeK = ((long) K << BITS) + Code;  /* set full code */
      i     = (K << SHIFT) ^ Code;      /* xor hashing */

      if (HashTab[i] == CodeK) {        /* full code found */
        Code = CodeTab[i];
        continue;
      }
      else if (HashTab[i] < 0 )         /* empty slot */
        goto NOMATCH;

      disp  = HSIZE - i;                /* secondary hash */
      if (i == 0) disp = 1;

PROBE:
      if ((i -= disp) < 0)
        i  += HSIZE;

      if (HashTab[i] == CodeK) {        /* full code found */
        Code = CodeTab[i];
        continue;
      }

      if (HashTab[i] > 0)               /* try again */
        goto PROBE;

NOMATCH:
      output(Code);                     /* full code not found */
      Code = K;

      if (FreeCode < THELIMIT) {
        CodeTab[i] = FreeCode++;        /* code -> hashtable */
        HashTab[i] = CodeK;
      }
      else
        output(ClearCode);
    }
  }
   /*   O U T P U T   T H E   R E S T  */

  output(Code);
  output(EOFCode);
  put_byte(0);                          /* zero-length packet (EOF) */
  put_byte(';');                        /* GIF file terminator */

  return (Nbyte);
}

static unsigned long cur_accum;
static int           cur_bits;
static int           a_count;
static char          accum[256];
static unsigned long masks[] = { 0x0000,
                                 0x0001, 0x0003, 0x0007, 0x000F,
                                 0x001F, 0x003F, 0x007F, 0x00FF,
                                 0x01FF, 0x03FF, 0x07FF, 0x0FFF,
                                 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

/***************************************************************
 *                                                             *
 * Name: output                                 Date: 02.10.92 *
 *                                                             *
 * Function: output GIF code                                   *
 *                                                             *
 * Input: code - GIF code                                      *
 *                                                             *
 ***************************************************************/
static void output(code)
               int code;
{
  /*   O U T P U T   C O D E   */

   cur_accum &= masks[cur_bits];
   if (cur_bits > 0)
     cur_accum |= ((long)code << cur_bits);
   else
     cur_accum = code;
   cur_bits += CurCodeSize;
   while( cur_bits >= 8 ) {
     char_out( (unsigned int) (cur_accum & 0xFF) );
     cur_accum >>= 8;
     cur_bits -= 8;
   }

  /*   R E S E T   */

  if (code == ClearCode ) {
    memset((char *) HashTab, -1, sizeof(HashTab));
    FreeCode = ClearCode + 2;
    CurCodeSize = IniCodeSize;
    CurMaxCode  = (1 << (IniCodeSize)) - 1;
  }

  /*   I N C R E A S E   C O D E   S I Z E   */

  if (FreeCode > CurMaxCode ) {
      CurCodeSize++;
      if ( CurCodeSize == BITS )
        CurMaxCode = THELIMIT;
      else
        CurMaxCode = (1 << (CurCodeSize)) - 1;
   }

  /*   E N D   O F   F I L E :  write the rest of the buffer  */

  if( code == EOFCode ) {
    while( cur_bits > 0 ) {
      char_out( (unsigned int)(cur_accum & 0xff) );
      cur_accum >>= 8;
      cur_bits -= 8;
    }
    char_flush();
  }
}

static void char_init()
{
   a_count = 0;
   cur_accum = 0;
   cur_bits  = 0;
}

static void char_out(c)
                 int c;
{
   accum[a_count++] = c;
   if (a_count >= 254)
      char_flush();
}

static void char_flush()
{
  int i;

  if (a_count == 0) return;
  put_byte(a_count);
  for (i=0; i<a_count; i++) {
    put_byte(accum[i]);
  }
  a_count = 0;
}

static void put_short(word)
                  int word;
{
  put_byte(word & 0xFF);
  put_byte((word>>8) & 0xFF);
}
+SELF.
+DECK,  IGVERS, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.33  2002/05/22 09:18:47  couet
 * - 1.28/07
 *
 * Revision 1.32  2002/05/16 15:32:11  couet
 * - 1.28/06
 *
 * Revision 1.31  2002/04/04 10:21:28  couet
 * - 1.28/05
 *
 * Revision 1.30  2002/03/18 16:23:41  couet
 * - 1.28/04
 *
 * Revision 1.29  2001/12/07 15:52:27  couet
 * - 1.28/03
 *
 * Revision 1.28  2001/11/23 16:09:25  couet
 * - 1.28/02
 *
 * Revision 1.27  2001/10/17 14:42:54  couet
 * - 1.28/01
 *
 * Revision 1.26  2001/10/08 16:18:06  couet
 * - 1.28/00
 *
 * Revision 1.25  2001/05/31 08:08:24  couet
 * - 1.27/03
 *
 * Revision 1.24  2000/08/29 14:04:06  couet
 * - 1.27/02
 *
 * Revision 1.23  2000/07/14 15:18:59  couet
 * - 1.27/01
 *
 * Revision 1.22  2000/04/03 15:41:39  couet
 * - 1.27/00
 *
 * Revision 1.21  1999/10/20 14:16:52  couet
 * - 1.26/04
 *
 * Revision 1.20  1999/10/13 12:35:28  couet
 * - 1.26/03
 *
 * Revision 1.19  1999/10/06 14:05:19  couet
 * - 1.26/02
 *
 * Revision 1.18  1999/06/21 16:48:37  couet
 * - 1.26/01
 *
 * Revision 1.17  1999/05/06 06:59:21  couet
 * - version 1.26/00 to tag the following bug fixe in x11int.c:
 *  "MapNotify is not supported by all the X11 emulators (problem on Mac !!!)"
 *
 * Revision 1.16  1999/01/07 15:31:27  couet
 * - 1.25/05
 *
 * Revision 1.15  1998/12/07 13:45:23  couet
 * - 1.25/04
 *
 * Revision 1.14  1998/11/16 11:13:28  couet
 * - 1.25/03
 *
 * Revision 1.13  1998/11/13 10:52:29  couet
 * - 1.25/02
 *
 * Revision 1.12  1998/11/10 09:27:12  couet
 * - Y2K
 *
 * Revision 1.11  1998/05/26 09:22:54  couet
 * - 1.25/01
 *
 * Revision 1.10  1998/04/09 13:07:38  couet
 * - Compilation date removed from the vidqq string: it was meaningless
 *
 * Revision 1.9  1998/01/27 14:09:15  couet
 * - 1.24/03
 *
 * Revision 1.8  1997/11/24 15:40:34  couet
 * - 1.24/02
 *
 * Revision 1.7  1997/06/20 15:13:41  couet
 * - 1.24/01
 *
 * Revision 1.6  1997/04/22 08:45:14  couet
 * - 1.24/00
 *
 * Revision 1.5  1997/01/30 10:06:19  couet
 * - version ++
 *
 * Revision 1.4  1996/11/20 15:16:01  couet
 * - version++
 *
 * Revision 1.3  1996/04/23 08:36:50  couet
 *
 * Revision 1.2  1996/02/14 15:18:18  couet
 * The version number was not correct in igvers (CMZ corrupted it).
 *
 * Revision 1.1.1.1  1996/02/14 13:10:25  mclareni
 * Higz
 *
 */


static char vidqq[] =
"@(#)HIGZ     1.28/07  22/05/2002  11:30:00";

/*
 *  Return the static version string for HIGZ
 */

char *
igvers()
{
        /* skip the 4 char that contain the "what" string */
        return &vidqq[4];
}
+DECK,  IMGPICKPALETTE, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.5  1998/11/13 13:19:53  couet
 * - removed unused variables.
 *
 * Revision 1.4  1998/11/13 10:49:05  couet
 * - New version of the routine imgpickpalette coming from a C++ version
 *   from Fons Rademakers. This version allows to work on TrueColor
 *   devices. ixdogif in x11int.c has been modified in order to use this
 *   new version of imgpickpalette. Protections have been added in
 *   ixdogif to prevent some crashes when one try to create a gif after
 *   a window resizing or when the program (for example PAW) started
 *   with a workstation type equal to 0. All the static arrays in ixdogif
 *   have been converted into dynamic one.
 *
 * Revision 1.3  1996/03/19 16:10:28  couet
 * The variable "window" is now compared with 0 instead of NULL.
 *
 * Revision 1.2  1996/03/19 15:27:36  couet
 * The variable "window" is now compared with (Window)NULL instead of NULL.
 * Some compilers need this cast.
 *
 * Revision 1.1.1.1  1996/02/14 13:10:26  mclareni
 * Higz
 *
 */

+SELF, IF=GIF.
#include <X11/Xlib.h>
#include <stdio.h>

void CollectImageColors(unsigned long, unsigned long **, int *, int *);
int FindColor(unsigned long, unsigned long *, int);

/******************************************************************************
 *                                                                            *
 * Name: ImgPickPalette                                     Date:    12.11.98 *
 * Author: F.Rademakers                                     Revised:          *
 *         Converted in C by O.Couet                                          *
 *                                                                            *
 * Returns in R G B the ncol colors of the palette used by the image.         *
 * The image pixels are changed to index values in these R G B arrays.        *
 * This produces a colormap with only the used colors (so even on displays    *
 * with more than 8 planes we will be able to create GIF's when the image     *
 * contains no more than 256 different colors). If it does contain more       *
 * colors we will have to use GIFquantize to reduce the number of colors.     *
 * The R G B arrays must be deleted by the caller.                            *
 *                                                                            *
 ******************************************************************************/
void ImgPickPalette(display, image, ncol, R, G, B)
Display *display;
XImage  *image;
int     *ncol, **R, **G, **B;
{
   unsigned long *orgcolors, pixel;
   int      maxcolors, ncolors;
   int      x, y, i, theScr, idx;
   XColor   *xcol;
   Colormap theMap;

/*
 * collect different image colors
 */
   maxcolors = 0;
   ncolors = 0;
   for (x = 0; x < image->width; x++) {
      for (y = 0; y < image->height; y++) {
         pixel = XGetPixel(image, x, y);
         CollectImageColors(pixel, &orgcolors, &ncolors, &maxcolors);
      }
   }

/*
 *  get RGB values belonging to pixels
 */
   xcol = (XColor *) malloc(ncolors*sizeof(XColor));

   for (i = 0; i < ncolors; i++) {
      xcol[i].pixel = orgcolors[i];
      xcol[i].red   = xcol[i].green = xcol[i].blue = 0;
      xcol[i].flags = DoRed || DoGreen || DoBlue;
   }

   theScr  = DefaultScreen(display);
   theMap  = DefaultColormap(display, theScr);

   XQueryColors(display, theMap, xcol, ncolors);

/*
 * create RGB arrays and store RGB's for each color and set number of colors
 * (space must be delete by caller)
 */
   *R = (int *) malloc(ncolors*sizeof(int));
   *G = (int *) malloc(ncolors*sizeof(int));
   *B = (int *) malloc(ncolors*sizeof(int));

   for (i = 0; i < ncolors; i++) {
      (*R)[i] = xcol[i].red;
      (*G)[i] = xcol[i].green;
      (*B)[i] = xcol[i].blue;
   }
   *ncol = ncolors;

/*
 * update image with indices (pixels) into the new RGB colormap
 */
   for (x = 0; x < (int) image->width; x++) {
      for (y = 0; y < (int) image->height; y++) {
         pixel = XGetPixel(image, x, y);
         idx = FindColor(pixel, orgcolors, ncolors);
         XPutPixel(image, x, y, idx);
      }
   }

/*
 *  cleanup
 */
   free(xcol);
   free(orgcolors);
}

/*
 * Collects in orgcolors all different original image colors.
 */
void CollectImageColors(pixel, orgcolors, ncolors, maxcolors)
unsigned long pixel, **orgcolors;
int *ncolors, *maxcolors;
{
  int i;

   if (*maxcolors == 0) {
      *ncolors   = 0;
      *maxcolors = 100;
      *orgcolors  = (unsigned long *) malloc ((*maxcolors)*sizeof(unsigned long));
   }

   for (i = 0; i < *ncolors; i++) {
      if (pixel == (*orgcolors)[i]) return;
   }

   if ((*ncolors) >= (*maxcolors)) {
      *orgcolors = (unsigned long *) realloc(*orgcolors,
                                          (*maxcolors)*2*sizeof(unsigned long));
      *maxcolors *= 2;
   }

   (*orgcolors)[(*ncolors)] = pixel;
   (*ncolors)++;
}

/*
 * Returns index in orgcolors (and new_colors) for pixel.
 */
int FindColor(pixel, orgcolors, ncolors)
unsigned long pixel, *orgcolors;
int ncolors;
{
   int i;
   for (i = 0; i < ncolors; i++)
      if (pixel == orgcolors[i]) return i;

   printf("**** Error: did not find color, should never happen! \n");

   return 0;
}
+SELF.
+DECK,  IMGSCALING, T=CC.
/*
 * $Id: imgscaling.c,v
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.1  1998/11/16 09:36:55  couet
 * - new procedure to scale bitmap images.
 *
 *
 */

+SELF, IF=GIF.
#include <X11/Xlib.h>
#include <stdio.h>

XImage * ImgScaling(Display *, XImage *, int, int);

/******************************************************************************
 *                                                                            *
 * Name: ImgScaling                                         Date:    13.11.98 *
 * Author: O.Couet                                          Revised:          *
 *                                                                            *
 * Transforms an XImage into a other one in a other scale.                    *
 *                                                                            *
 ******************************************************************************/
XImage * ImgScaling(display, image, new_width, new_height)
Display *display;
XImage  *image;
int new_width, new_height;
{
XImage  *new_image;
int old_width, old_height;
float xratio, yratio;
int x, y, xo, yo;
unsigned long pixel;

  new_image = XGetImage( display, RootWindow( display, DefaultScreen(display)),
                         0, 0, new_width, new_height, AllPlanes, ZPixmap);

  old_width  = image->width;
  old_height = image->height;

  xratio = (float)(old_width)/(float)(new_width);
  yratio = (float)(old_height)/(float)(new_height);

  for (x = 0; x < new_width; x++) {
     for (y = 0; y < new_height; y++) {
	xo = (int)(xratio*(float)x);
	yo = (int)(yratio*(float)y);
        pixel = XGetPixel(image, xo, yo);
	XPutPixel(new_image, x, y, pixel);
     }
  }

  return new_image;
}
+SELF.
+DECK,  IXGETL, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.3  1997/09/02 15:30:30  mclareni
 * WINNT corrections
 *
 * Revision 1.2  1997/03/14 14:22:28  mclareni
 * WNT mods
 *
 * Revision 1.1.1.1.2.1  1997/01/21 11:25:22  mclareni
 * All mods for Winnt 96a on winnt branch
 *
 * Revision 1.1.1.1  1996/02/14 13:10:26  mclareni
 * Higz
 *
 */

+SELF, IF=UNIX, IF=CCREAD.
/*CMZ :  1.23/06 22/11/95  10.38.33  by  O.Couet*/
/*-- Author :    O.Couet   30/09/93*/
/*
 * C routine to read a character string on stdin.
 */

#include <stdio.h>
#include <stdlib.h>

+SELF, IF=UNIX, IF=CCREAD, IF=QX_SC.
#define ixgetl ixgetl_
+SELF, IF=UNIX, IF=CCREAD, IF=CRAY.
#define ixgetl IXGETL
+SELF, IF=UNIX, IF=CCREAD, IF=TKTCL, IF=WINNT,MSSTDCALL.
#define ixgetl __stdcall IXGETL
+SELF, IF=UNIX, IF=CCREAD.

#define SMALLBUF_SIZE   200

+SELF, IF=UNIX, IF=CCREAD, IF=-MSSTDCALL.
 void ixgetl(lline, chline)
+SELF, IF=UNIX, IF=CCREAD, IF=MSSTDCALL.
 void ixgetl(lline, len_lline, chline)
 int len_lline;
+SELF, IF=UNIX, IF=CCREAD.

char *chline;
int  *lline;
{
  static char *buf;
  static int bufsize = 0;
  int ch, pos;

  if (bufsize == 0)
    {
      bufsize = 80;
      buf = (char*) calloc(bufsize + 1, sizeof(char));
    }

  for (pos = 0; (ch = getc(stdin)) != EOF && ch != '\n'; buf[pos++] = ch)
    {
      if (pos == bufsize)
        {
          bufsize *= 2;
          buf = (char*) realloc(buf, (bufsize + 1)*sizeof(char));
        }
    }
  buf[pos] = '\0';

  /*  If we have a huge buffer from the last call and now have a
   *  short line, try to dump the excess.
   */
  if (pos <= SMALLBUF_SIZE && bufsize > 5000)
    {
      char *smallbuf;

 if ((smallbuf = (char*)realloc(buf,(SMALLBUF_SIZE+1)*sizeof(char))) != NULL)
        {
          buf = smallbuf;
          bufsize = SMALLBUF_SIZE;
        }
    }

  if (pos == 0 && ch == EOF) {
     *lline = 0;
     chline = '\0';
  } else {
     *lline = pos;
     strcpy (chline, buf);
   }
}
+SELF.
+DECK,  NTMGT, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.2  1997/03/14 14:22:28  mclareni
 * WNT mods
 *
 * Revision 1.1.1.1.2.1  1997/01/21 11:25:22  mclareni
 * All mods for Winnt 96a on winnt branch
 *
 * Revision 1.1.1.1  1996/02/14 13:10:26  mclareni
 * Higz
 *
 */

+SELF, IF=NTC.
/*CMZ :  1.23/06 22/11/95  10.36.05  by  O.Couet*/
/*-- Author : O.Couet*/
/******************************************************************************
 *                                                                            *
 * Dynamic Normalisation Transformation management package.                   *
 *                                                                            *
 * ignint: Initiate the Normalisation Transformation management               *
 * igncre: Create a new Normalisation Transformation                          *
 * ignscu: Set the Current Normalisation Transformation                       *
 * igndel: Delete the Current Normalisation Transformation                    *
 * igngar: Delete the NT with a priority less than Priority                   *
 * ignspr: Set the Priority of the Current Normalisation Transformation       *
 * ignswn: Set the Window of the Current Normalisation Transformation         *
 * ignsvp: Set the Viewport of the Current Normalisation Transformation       *
 * ignnxt: Set the NEXT Normalisation Transformation as the curreny one       *
 * ignget: Get the Current Normalisation Transformation parameters            *
 * igns3w: Set the 3D Window of the Current Normalisation Transformation      *
 * igns3v: Set the 3D Viewport of the Current Normalisation Transformation    *
 * igng3d: Get the Current 3D Normalisation Transformation parameters         *
 *                                                                            *
 ******************************************************************************/

#include <stdlib.h>
#include <stdio.h>

+SELF, IF=NTC, IF=QX_SC.
#define ignint ignint_
#define igncre igncre_
#define igndel igndel_
#define igngar igngar_
#define ignspr ignspr_
#define ignswn ignswn_
#define ignsvp ignsvp_
#define ignget ignget_
#define igns3w igns3w_
#define igns3v igns3v_
#define ignscu ignscu_
#define ignnxt ignnxt_
#define igng3d igng3d_
+SELF, IF=NTC.

+SELF, IF=NTC, IF=QXCAPT.
#define ignint IGNINT
#define igncre IGNCRE
#define igndel IGNDEL
#define igngar IGNGAR
#define ignspr IGNSPR
#define ignswn IGNSWN
#define ignsvp IGNSVP
#define ignget IGNGET
#define igns3w IGNS3W
#define igns3v IGNS3V
#define ignscu IGNSCU
#define ignnxt IGNNXT
#define igng3d IGNG3D
+SELF, IF=NTC.

+SELF, IF=NTC, IF=IBM.
#pragma linkage (ignint ,FORTRAN)
#pragma linkage (igncre ,FORTRAN)
#pragma linkage (igndel ,FORTRAN)
#pragma linkage (igngar ,FORTRAN)
#pragma linkage (ignspr ,FORTRAN)
#pragma linkage (ignswn ,FORTRAN)
#pragma linkage (ignsvp ,FORTRAN)
#pragma linkage (ignget ,FORTRAN)
#pragma linkage (igns3w ,FORTRAN)
#pragma linkage (igns3v ,FORTRAN)
#pragma linkage (ignscu ,FORTRAN)
#pragma linkage (ignnxt ,FORTRAN)
#pragma linkage (igng3d ,FORTRAN)
+SELF, IF=NTC.


typedef struct _NT  NT;
struct _NT {
   int             ID;
   int             Priority;
   float           X1_Window;
   float           X2_Window;
   float           Y1_Window;
   float           Y2_Window;
   float           X1_Viewport;
   float           X2_Viewport;
   float           Y1_Viewport;
   float           Y2_Viewport;
   int             Is_3D;
   float           X1_3D_Window;
   float           X2_3D_Window;
   float           Y1_3D_Window;
   float           Y2_3D_Window;
   float           Z1_3D_Window;
   float           Z2_3D_Window;
   float           X1_3D_Viewport;
   float           X2_3D_Viewport;
   float           Y1_3D_Viewport;
   float           Y2_3D_Viewport;
   float           Phi;
   float           Theta;
   float           Psi;
   int             Perspective;
   NT              *Previous_NT;
   NT              *Next_NT;
};

static NT *NT_Root    = NULL;
static NT *NT_Last    = NULL;
static NT *NT_Current = NULL;
static NT *NT_Save    = NULL;
static int Highest_Priority = 0;

/******************************************************************************
 *                                                                            *
 * Initiate the Normalisation Transformation management                       *
 *                                                                            *
 ******************************************************************************/
 void type_of_call ignint()
 {
    NT_Root                 = (NT *) calloc(1, sizeof(NT));
    NT_Root->ID             = 0;
    NT_Root->Priority       = 1;
    NT_Root->X1_Window      = 0.0;
    NT_Root->X2_Window      = 1.0;
    NT_Root->Y1_Window      = 0.0;
    NT_Root->Y2_Window      = 1.0;
    NT_Root->X1_Viewport    = 0.0;
    NT_Root->X2_Viewport    = 1.0;
    NT_Root->Y1_Viewport    = 0.0;
    NT_Root->Y2_Viewport    = 1.0;
    NT_Root->Is_3D          = 0;
    NT_Root->X1_3D_Window   = 0.0;
    NT_Root->X2_3D_Window   = 1.0;
    NT_Root->Y1_3D_Window   = 0.0;
    NT_Root->Y2_3D_Window   = 1.0;
    NT_Root->Z1_3D_Window   = 0.0;
    NT_Root->Z2_3D_Window   = 1.0;
    NT_Root->X1_3D_Viewport = 0.0;
    NT_Root->X2_3D_Viewport = 1.0;
    NT_Root->Y1_3D_Viewport = 0.0;
    NT_Root->Y2_3D_Viewport = 1.0;
    NT_Root->Phi            = 30.0;
    NT_Root->Theta          = 30.0;
    NT_Root->Psi            = 0.0;
    NT_Root->Perspective    = 0;
    NT_Root->Next_NT        = NT_Root;
    NT_Root->Previous_NT    = NT_Root;
    NT_Current              = NT_Root;
    NT_Last                 = NT_Root;
 }

/******************************************************************************
 *                                                                            *
 * Create a new Normalisation Transformation                                  *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call igncre(ID)
 int *ID;
 {
    NT_Current                 = (NT *) calloc(1, sizeof(NT));
    NT_Current->ID             = *ID;
    NT_Current->Priority       = 1;
    NT_Current->X1_Window      = 0.0;
    NT_Current->X2_Window      = 1.0;
    NT_Current->Y1_Window      = 0.0;
    NT_Current->Y2_Window      = 1.0;
    NT_Current->X1_Viewport    = 0.0;
    NT_Current->X2_Viewport    = 1.0;
    NT_Current->Y1_Viewport    = 0.0;
    NT_Current->Y2_Viewport    = 1.0;
    NT_Current->Is_3D          = 0;
    NT_Current->X1_3D_Window   = 0.0;
    NT_Current->X2_3D_Window   = 1.0;
    NT_Current->Y1_3D_Window   = 0.0;
    NT_Current->Y2_3D_Window   = 1.0;
    NT_Current->Z1_3D_Window   = 0.0;
    NT_Current->Z2_3D_Window   = 1.0;
    NT_Current->X1_3D_Viewport = 0.0;
    NT_Current->X2_3D_Viewport = 1.0;
    NT_Current->Y1_3D_Viewport = 0.0;
    NT_Current->Y2_3D_Viewport = 1.0;
    NT_Current->Phi            = 30.0;
    NT_Current->Theta          = 30.0;
    NT_Current->Psi            = 0.0;
    NT_Current->Perspective    = 0;
    NT_Current->Next_NT        = NT_Root;
    NT_Current->Previous_NT    = NT_Last;

    NT_Last->Next_NT           = NT_Current;
    NT_Root->Previous_NT       = NT_Current;
    NT_Last                    = NT_Current;
 }

/******************************************************************************
 *                                                                            *
 * Set the Current Normalisation Transformation                               *
 *    Returns 1 if NT already exits 0 otherwise                               *
 *                                                                            *
 ******************************************************************************/
 int  type_of_call ignscu(ID)
 int *ID;
 {
    if ( NT_Current->ID == *ID) return 1;
    NT_Save = NT_Current;
    while ( NT_Current->Next_NT != NT_Save) {
       NT_Current = NT_Current->Next_NT;
       if ( NT_Current->ID == *ID) return 1;
    }
    return 0;
 }

/******************************************************************************
 *                                                                            *
 * Delete the Current Normalisation Transformation                            *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call igndel()
 {
    if ( NT_Current == NT_Root) return;
    NT_Save              = NT_Current->Previous_NT;
    NT_Save->Next_NT     = NT_Current->Next_NT;
    NT_Save              = NT_Current->Next_NT;
    NT_Save->Previous_NT = NT_Current->Previous_NT;
    free (NT_Current);
    NT_Current           = NT_Save;
    NT_Last              = NT_Root->Previous_NT;
 }

/******************************************************************************
 *                                                                            *
 * Delete the Normalisation Transformation with a priority less than Priority *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call igngar(Priority)
 int *Priority;
 {
    NT_Current = NT_Root->Next_NT;
    while ( NT_Current != NT_Root) {
       if(NT_Current->Priority < *Priority) {
          igndel();
       } else {
          NT_Current = NT_Current->Next_NT;
       }
    }
 }

/******************************************************************************
 *                                                                            *
 * Set the Priority of the Current Normalisation Transformation               *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call ignspr(Priority)
 int *Priority;
 {
    NT_Current->Priority = *Priority;
    if ( *Priority > Highest_Priority) Highest_Priority = *Priority;
 }

/******************************************************************************
 *                                                                            *
 * Set the Window of the Current Normalisation Transformation                 *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call ignswn(X1_Window, X2_Window, Y1_Window, Y2_Window)
 float *X1_Window;
 float *X2_Window;
 float *Y1_Window;
 float *Y2_Window;
 {
    NT_Current->X1_Window = *X1_Window;
    NT_Current->X2_Window = *X2_Window;
    NT_Current->Y1_Window = *Y1_Window;
    NT_Current->Y2_Window = *Y2_Window;
 }

/******************************************************************************
 *                                                                            *
 * Set the Viewport of the Current Normalisation Transformation               *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call ignsvp(X1_Viewport, X2_Viewport, Y1_Viewport, Y2_Viewport)
 float *X1_Viewport;
 float *X2_Viewport;
 float *Y1_Viewport;
 float *Y2_Viewport;
 {
    NT_Current->X1_Viewport = *X1_Viewport;
    NT_Current->X2_Viewport = *X2_Viewport;
    NT_Current->Y1_Viewport = *Y1_Viewport;
    NT_Current->Y2_Viewport = *Y2_Viewport;
 }

/******************************************************************************
 *                                                                            *
 * Set the NEXT Normalisation Transformation as the current one               *
 * init=1 define the beginning of the loop                                    *
 * init=0 set the next NT current                                             *
 * This routine returns 1 when the loop is finished 0 otherwise               *
 *                                                                            *
 ******************************************************************************/
 int  type_of_call ignnxt(init)
 int *init;
 {
    if ( *init == 1 ) {
       NT_Save = NT_Current;
       return 0;
    } else {
       NT_Current = NT_Current->Next_NT;
       if ( NT_Current == NT_Save ) {
          return 1;
       } else {
          return 0;
       }
    }
 }

/******************************************************************************
 *                                                                            *
 * Get the Current 2D Normalisation Transformation parameters                 *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call ignget(NTID, Priority, H_Priority,
             X1_Window, X2_Window, Y1_Window, Y2_Window,
             X1_Viewport, X2_Viewport, Y1_Viewport, Y2_Viewport, Is_3D)
 int *NTID;
 int *Priority;
 int *H_Priority;
 float *X1_Window;
 float *X2_Window;
 float *Y1_Window;
 float *Y2_Window;
 float *X1_Viewport;
 float *X2_Viewport;
 float *Y1_Viewport;
 float *Y2_Viewport;
 int *Is_3D;
 {
    *H_Priority  = Highest_Priority;
    *NTID        = NT_Current->ID;
    *Priority    = NT_Current->Priority;
    *X1_Window   = NT_Current->X1_Window;
    *X2_Window   = NT_Current->X2_Window;
    *Y1_Window   = NT_Current->Y1_Window;
    *Y2_Window   = NT_Current->Y2_Window;
    *X1_Viewport = NT_Current->X1_Viewport;
    *X2_Viewport = NT_Current->X2_Viewport;
    *Y1_Viewport = NT_Current->Y1_Viewport;
    *Y2_Viewport = NT_Current->Y2_Viewport;
    *Is_3D       = NT_Current->Is_3D;
 }

/******************************************************************************
 *                                                                            *
 * Set the 3D Window of the Current Normalisation Transformation              *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call igns3w(X1_3D_Window, X2_3D_Window,
             Y1_3D_Window, Y2_3D_Window,
             Z1_3D_Window, Z2_3D_Window,
             Phi, Theta, Psi)
 float *X1_3D_Window;
 float *X2_3D_Window;
 float *Y1_3D_Window;
 float *Y2_3D_Window;
 float *Z1_3D_Window;
 float *Z2_3D_Window;
 float *Phi;
 float *Theta;
 float *Psi;
 {
    NT_Current->Is_3D        = 1;
    NT_Current->X1_3D_Window = *X1_3D_Window;
    NT_Current->X2_3D_Window = *X2_3D_Window;
    NT_Current->Y1_3D_Window = *Y1_3D_Window;
    NT_Current->Y2_3D_Window = *Y2_3D_Window;
    NT_Current->Z1_3D_Window = *Z1_3D_Window;
    NT_Current->Z2_3D_Window = *Z2_3D_Window;
    NT_Current->Phi          = *Phi;
    NT_Current->Theta        = *Theta;
    NT_Current->Psi          = *Psi;
 }

/******************************************************************************
 *                                                                            *
 * Set the 3D Viewport of the Current Normalisation Transformation            *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call igns3v(X1_3D_Viewport, X2_3D_Viewport, Y1_3D_Viewport, Y2_3D_Viewport)
 float *X1_3D_Viewport;
 float *X2_3D_Viewport;
 float *Y1_3D_Viewport;
 float *Y2_3D_Viewport;
 {
    NT_Current->Is_3D          = 1;
    NT_Current->X1_3D_Viewport = *X1_3D_Viewport;
    NT_Current->X2_3D_Viewport = *X2_3D_Viewport;
    NT_Current->Y1_3D_Viewport = *Y1_3D_Viewport;
    NT_Current->Y2_3D_Viewport = *Y2_3D_Viewport;
 }

/******************************************************************************
 *                                                                            *
 * Get the Current 3D Normalisation Transformation parameters                 *
 *                                                                            *
 ******************************************************************************/
 void  type_of_call igng3d(X1_3D_Window, X2_3D_Window, Y1_3D_Window, Y2_3D_Window,
             Z1_3D_Window, Z2_3D_Window, Phi, Theta, Psi,
             X1_3D_Viewport, X2_3D_Viewport, Y1_3D_Viewport, Y2_3D_Viewport)
 float *X1_3D_Window;
 float *X2_3D_Window;
 float *Y1_3D_Window;
 float *Y2_3D_Window;
 float *Z1_3D_Window;
 float *Z2_3D_Window;
 float *Phi;
 float *Theta;
 float *Psi;
 float *X1_3D_Viewport;
 float *X2_3D_Viewport;
 float *Y1_3D_Viewport;
 float *Y2_3D_Viewport;
 {
    *X1_3D_Window   = NT_Current->X1_3D_Window;
    *X2_3D_Window   = NT_Current->X2_3D_Window;
    *Y1_3D_Window   = NT_Current->Y1_3D_Window;
    *Y2_3D_Window   = NT_Current->Y2_3D_Window;
    *Z1_3D_Window   = NT_Current->Z1_3D_Window;
    *Z2_3D_Window   = NT_Current->Z2_3D_Window;
    *Phi            = NT_Current->Phi;
    *Theta          = NT_Current->Theta;
    *Psi            = NT_Current->Psi;
    *X1_3D_Viewport = NT_Current->X1_3D_Viewport;
    *X2_3D_Viewport = NT_Current->X2_3D_Viewport;
    *Y1_3D_Viewport = NT_Current->Y1_3D_Viewport;
    *Y2_3D_Viewport = NT_Current->Y2_3D_Viewport;
 }
+SELF.
+DECK,  ROTATED, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.2  1998/01/30 15:22:04  couet
 * - APOLLO version removed
 *
 * Revision 1.1.1.1  1996/02/14 13:10:26  mclareni
 * Higz
 *
 */

+SELF, IF=X11, IF=-WINNT.
/*CMZ :  1.23/06 22/11/95  10.13.12  by  O.Couet*/
/*-- Author :    O.Couet   17/11/93*/
/* ********************************************************************** *
 *
 * xvertext 5.0, Copyright (c) 1993 Alan Richardson (mppa3@uk.ac.sussex.syma)
 *
 * Alignment definition modified by O.Couet.
 * Mods IBM/VM by O.Couet.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both the
 * copyright notice and this permission notice appear in supporting
 * documentation.  All work developed as a consequence of the use of
 * this program should duly acknowledge such use. No representations are
 * made about the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 *
 * ********************************************************************** */

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <stdio.h>
#include <math.h>

/* ************************************************************************ *
 *
 * Header file for the `xvertext 5.0' routines.
 *
 * Copyright (c) 1993 Alan Richardson (mppa3@uk.ac.sussex.syma)
 *
 * ************************************************************************ */

#ifndef _XVERTEXT_INCLUDED_
#define _XVERTEXT_INCLUDED_


#define XV_VERSION      5.0
#define XV_COPYRIGHT \
      "xvertext routines Copyright (c) 1993 Alan Richardson"

/* ---------------------------------------------------------------------- */

/* text alignment */

#define NONE             0
#define TLEFT            1
#define TCENTRE          2
#define TRIGHT           3
#define MLEFT            4
#define MCENTRE          5
#define MRIGHT           6
#define BLEFT            7
#define BCENTRE          8
#define BRIGHT           9

+SELF, IF=X11, IF=-WINNT, IF=VAX.
#define X11R3
+SELF, IF=X11, IF=-WINNT.

/* ---------------------------------------------------------------------- */

/* this shoulf be C++ compliant, thanks to
     vlp@latina.inesc.pt (Vasco Lopes Paulo) */

#if defined(__cplusplus) || defined(c_plusplus)

extern "C" {
float   XRotVersion(char*, int);
void    XRotSetMagnification(float);
void    XRotSetBoundingBoxPad(int);
int     XRotDrawString(Display*, XFontStruct*, float,
                       Drawable, GC, int, int, char*);
int     XRotDrawImageString(Display*, XFontStruct*, float,
                            Drawable, GC, int, int, char*);
int     XRotDrawAlignedString(Display*, XFontStruct*, float,
                              Drawable, GC, int, int, char*, int);
int     XRotDrawAlignedImageString(Display*, XFontStruct*, float,
                                   Drawable, GC, int, int, char*, int);
XPoint *XRotTextExtents(Display*, XFontStruct*, float,
                        int, int, char*, int);
}

#else
+SELF, IF=X11, IF=-WINNT, IF=IBM.
#define XRotDrawString XRDS
#define XRotDrawImageString XRDIS
#define XRotDrawAlignedString XRDAS
#define XRotDrawAlignedImageString XRDAIS
+SELF, IF=X11, IF=-WINNT.
extern float   XRotVersion();
extern void    XRotSetMagnification();
extern void    XRotSetBoundingBoxPad();
extern int     XRotDrawString();
extern int     XRotDrawImageString();
extern int     XRotDrawAlignedString();
extern int     XRotDrawAlignedImageString();
extern XPoint *XRotTextExtents();

#endif /* __cplusplus */

/* ---------------------------------------------------------------------- */

#endif /* _XVERTEXT_INCLUDED_ */

/* ---------------------------------------------------------------------- */

/* Make sure cache size is set */

#ifndef CACHE_SIZE_LIMIT
#define CACHE_SIZE_LIMIT 0
#endif /*CACHE_SIZE_LIMIT */

/* Make sure a cache method is specified */

#ifndef CACHE_XIMAGES
#ifndef CACHE_BITMAPS
#define CACHE_BITMAPS
#endif /*CACHE_BITMAPS*/
#endif /*CACHE_XIMAGES*/

/* ---------------------------------------------------------------------- */

/* Debugging macros */

#ifdef DEBUG
static int debug=1;
#else
static int debug=0;
#endif /*DEBUG*/

#define DEBUG_PRINT1(a) if (debug) printf (a)
#define DEBUG_PRINT2(a, b) if (debug) printf (a, b)
#define DEBUG_PRINT3(a, b, c) if (debug) printf (a, b, c)
#define DEBUG_PRINT4(a, b, c, d) if (debug) printf (a, b, c, d)
#define DEBUG_PRINT5(a, b, c, d, e) if (debug) printf (a, b, c, d, e)

/* ---------------------------------------------------------------------- */

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* ---------------------------------------------------------------------- */

/* A structure holding everything needed for a rotated string */

typedef struct rotated_text_item_template {
    Pixmap bitmap;
    XImage *ximage;

    char *text;
    char *font_name;
    Font fid;
    float angle;
    int align;
    float magnify;

    int cols_in;
    int rows_in;
    int cols_out;
    int rows_out;

    int nl;
    int max_width;
    float *corners_x;
    float *corners_y;

    long int size;
    int cached;

    struct rotated_text_item_template *next;
} RotatedTextItem;

RotatedTextItem *first_text_item=NULL;

/* ---------------------------------------------------------------------- */

/* A structure holding current magnification and bounding box padding */

static struct style_template {
    float magnify;
    int bbx_pad;
} style={
    1.,
    0
    };

/* ---------------------------------------------------------------------- */

static char            *my_strdup();
static char            *my_strtok();

float                   XRotVersion();
void                    XRotSetMagnification();
void                    XRotSetBoundingBoxPad();
int                     XRotDrawString();
int                     XRotDrawImageString();
int                     XRotDrawAlignedString();
int                     XRotDrawAlignedImageString();
XPoint                 *XRotTextExtents();

static XImage          *MakeXImage();
static int              XRotPaintAlignedString();
static int              XRotDrawHorizontalString();
static RotatedTextItem *XRotRetrieveFromCache();
static RotatedTextItem *XRotCreateTextItem();
static void             XRotAddToLinkedList();
static void             XRotFreeTextItem();
static XImage          *XRotMagnifyImage();

/**************************************************************************/
/* Routine to mimic `strdup()' (some machines don't have it)              */
/**************************************************************************/

static char *my_strdup(str)
    char *str;
{
    char *s;

    if(str==NULL) return NULL;

    s=(char *)malloc((unsigned)(strlen(str)+1));
    if(s!=NULL) strcpy(s, str);

    return s;
}

+SELF, IF=X11, IF=-WINNT, IF=IBM.
/**************************************************************************/
/* return uppercase version of a string, but don't change the string      */
/**************************************************************************/
char *LtoU( str )
    char *str;
{
  char *strout;
  if( str != NULL ) {
    char *p;
    strout=my_strdup(str);
    for( p = strout; *p != '\0'; p++ )
      if( islower( *p ) )
        *p = toupper( *p );
  }
  return strout;
}
+SELF, IF=X11, IF=-WINNT.

/**************************************************************************/
/* Routine to replace `strtok' : this one returns a zero length string if */
/* it encounters two consecutive delimiters                               */
/**************************************************************************/

static char *my_strtok(str1, str2)
    char *str1, *str2;
{
    char *ret;
    int i, j, stop;
    static int start, len;
    static char *stext;

    if(str2==NULL) return NULL;

    /* initialise if str1 not NULL */
    if(str1!=NULL) {
        start=0;
        stext=str1;
        len=strlen(str1);
    }

    /* run out of tokens ? */
    if(start>=len) return NULL;

    /* loop through characters */
    for(i=start; i<len; i++) {
        /* loop through delimiters */
        stop=0;
        for(j=0; j<strlen(str2); j++)
        if(stext[i]==str2[j])
        stop=1;

        if(stop) break;
    }

    stext[i]='\0';

    ret=stext+start;

    start=i+1;

    return ret;
}

/**************************************************************************/
/* Return version/copyright information                                   */
/**************************************************************************/

float XRotVersion(str, n)
    char *str;
    int n;
{
    if(str!=NULL) strncpy(str, XV_COPYRIGHT, n);
    return XV_VERSION;
}

/**************************************************************************/
/* Set the font magnification factor for all subsequent operations        */
/**************************************************************************/

void XRotSetMagnification(m)
    float m;
{
    if(m>0.) style.magnify=m;
}

/**************************************************************************/
/* Set the padding used when calculating bounding boxes                   */
/**************************************************************************/

void XRotSetBoundingBoxPad(p)
    int p;
{
    if(p>=0) style.bbx_pad=p;
}

/**************************************************************************/
/*  Create an XImage structure and allocate memory for it                 */
/**************************************************************************/

static XImage *MakeXImage(dpy, w, h)
    Display *dpy;
    int w, h;
{
    XImage *I;
    char *data;

    /* reserve memory for image */
    data=(char *)calloc((unsigned)(((w-1)/8+1)*h), 1);
    if(data==NULL) return NULL;

    /* create the XImage */
    I=XCreateImage(dpy, DefaultVisual(dpy, DefaultScreen(dpy)), 1, XYBitmap,
                   0, data, w, h, 8, 0);
    if(I==NULL) return NULL;

    I->byte_order=I->bitmap_bit_order=MSBFirst;
    return I;
}

/**************************************************************************/
/*  A front end to XRotPaintAlignedString:                                */
/*      -no alignment, no background                                      */
/**************************************************************************/

int XRotDrawString(dpy, font, angle, drawable, gc, x, y, str)
    Display *dpy;
    XFontStruct *font;
    float angle;
    Drawable drawable;
    GC gc;
    int x, y;
    char *str;
{
    return (XRotPaintAlignedString(dpy, font, angle, drawable, gc,
                                   x, y, str, NONE, 0));
}

/**************************************************************************/
/*  A front end to XRotPaintAlignedString:                                */
/*      -no alignment, paints background                                  */
/**************************************************************************/

int XRotDrawImageString(dpy, font, angle, drawable, gc, x, y, str)
    Display *dpy;
    XFontStruct *font;
    float angle;
    Drawable drawable;
    GC gc;
    int x, y;
    char *str;
{
    return(XRotPaintAlignedString(dpy, font, angle, drawable, gc,
                                  x, y, str, NONE, 1));
}

/**************************************************************************/
/*  A front end to XRotPaintAlignedString:                                */
/*      -does alignment, no background                                    */
/**************************************************************************/

int XRotDrawAlignedString(dpy, font, angle, drawable, gc, x, y, text, align)
    Display *dpy;
    XFontStruct *font;
    float angle;
    Drawable drawable;
    GC gc;
    int x, y;
    char *text;
    int align;
{
    return(XRotPaintAlignedString(dpy, font, angle, drawable, gc,
                                  x, y, text, align, 0));
}

/**************************************************************************/
/*  A front end to XRotPaintAlignedString:                                */
/*      -does alignment, paints background                                */
/**************************************************************************/

int XRotDrawAlignedImageString(dpy, font, angle, drawable, gc, x, y, text,
                               align)
    Display *dpy;
    XFontStruct *font;
    float angle;
    Drawable drawable;
    GC gc;
    int x, y;
    char *text;
    int align;
{
    return(XRotPaintAlignedString(dpy, font, angle, drawable, gc,
                                  x, y, text, align, 1));
}

/**************************************************************************/
/*  Aligns and paints a rotated string                                    */
/**************************************************************************/

static int XRotPaintAlignedString(dpy, font, angle, drawable, gc, x, y, text,
                                  align, bg)
    Display *dpy;
    XFontStruct *font;
    float angle;
    Drawable drawable;
    GC gc;
    int x, y;
    char *text;
    int align;
    int bg;
{
    int i;
    GC my_gc;
    int xp, yp;
    float hot_x, hot_y;
    float hot_xp, hot_yp;
    float sin_angle, cos_angle;
    RotatedTextItem *item;
    Pixmap bitmap_to_paint;

    /* return early for NULL/empty strings */
    if(text==NULL)
        return 0;

    if(strlen(text)==0) return 0;

    /* manipulate angle to 0<=angle<360 degrees */
    while(angle<0)
        angle+=360;

    while(angle>=360)
        angle-=360;

    angle*=M_PI/180;

    /* horizontal text made easy */
    if(angle==0. && style.magnify==1.)
        return(XRotDrawHorizontalString(dpy, font, drawable, gc, x, y,
                                        text, align, bg));

    /* get a rotated bitmap */
    item=XRotRetrieveFromCache(dpy, font, angle, text, align);
    if(item==NULL) return (int)NULL;

    /* this gc has similar properties to the user's gc */
    my_gc=XCreateGC(dpy, drawable, NULL, 0);
    XCopyGC(dpy, gc, GCForeground|GCBackground|GCFunction|GCPlaneMask,
            my_gc);

    /* alignment : which point (hot_x, hot_y) relative to bitmap centre
       coincides with user's specified point? */

    /* y position */
    if(align==TLEFT || align==TCENTRE || align==TRIGHT)
        hot_y=(float)item->rows_in/2*style.magnify;
    else if(align==MLEFT || align==MCENTRE || align==MRIGHT)
    {
    /*  Modify by O.Couet to have Bottom alignment without font->descent */
    /*  hot_y=0; */
        hot_y=-((float)item->rows_in/4-(float)font->descent)*style.magnify;
    }
    else if(align==BLEFT || align==BCENTRE || align==BRIGHT)
    {
    /*  Modify by O.Couet to have Bottom alignment without font->descent */
    /*  hot_y=-(float)item->rows_in/2*style.magnify; */
        hot_y=-((float)item->rows_in/2-(float)font->descent)*style.magnify;
    }
    else
        hot_y=-((float)item->rows_in/2-(float)font->descent)*style.magnify;

    /* x position */
    if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
        hot_x=-(float)item->max_width/2*style.magnify;
    else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
        hot_x=0;
    else
        hot_x=(float)item->max_width/2*style.magnify;

    /* pre-calculate sin and cos */
    sin_angle=sin(angle);
    cos_angle=cos(angle);

    /* rotate hot_x and hot_y around bitmap centre */
    hot_xp= hot_x*cos_angle - hot_y*sin_angle;
    hot_yp= hot_x*sin_angle + hot_y*cos_angle;

    /* text background will be drawn using XFillPolygon */
    if(bg) {
        GC depth_one_gc;
        XPoint *xpoints;
        Pixmap empty_stipple;

        /* reserve space for XPoints */
        xpoints=(XPoint *)malloc((unsigned)(4*item->nl*sizeof(XPoint)));
        if(!xpoints) return 1;

        /* rotate corner positions */
        for(i=0; i<4*item->nl; i++) {
            xpoints[i].x=(float)x + ( (item->corners_x[i]-hot_x)*cos_angle +
                                      (item->corners_y[i]+hot_y)*sin_angle);
            xpoints[i].y=(float)y + (-(item->corners_x[i]-hot_x)*sin_angle +
                                      (item->corners_y[i]+hot_y)*cos_angle);
        }

        /* we want to swap foreground and background colors here;
           XGetGCValues() is only available in R4+ */

        empty_stipple=XCreatePixmap(dpy, drawable, 1, 1, 1);

        depth_one_gc=XCreateGC(dpy, empty_stipple, NULL, 0);
        XSetForeground(dpy, depth_one_gc, 0);
        XFillRectangle(dpy, empty_stipple, depth_one_gc, 0, 0, 2, 2);

        XSetStipple(dpy, my_gc, empty_stipple);
        XSetFillStyle(dpy, my_gc, FillOpaqueStippled);

        XFillPolygon(dpy, drawable, my_gc, xpoints, 4*item->nl, Nonconvex,
              CoordModeOrigin);

        /* free our resources */
        free((char *)xpoints);
        XFreeGC(dpy, depth_one_gc);
        XFreePixmap(dpy, empty_stipple);
    }

    /* where should top left corner of bitmap go ? */
    xp=(float)x-((float)item->cols_out/2 +hot_xp);
    yp=(float)y-((float)item->rows_out/2 -hot_yp);

    /* by default we draw the rotated bitmap, solid */
    bitmap_to_paint=item->bitmap;

    /* handle user stippling */
#ifndef X11R3
    {
        GC depth_one_gc;
        XGCValues values;
        Pixmap new_bitmap, inverse;

        /* try and get some GC properties */
        if(XGetGCValues(dpy, gc,
            GCStipple|GCFillStyle|GCForeground|GCBackground|
            GCTileStipXOrigin|GCTileStipYOrigin,
            &values)) {

          /* only do this if stippling requested */
          if((values.fill_style==FillStippled ||
         values.fill_style==FillOpaqueStippled) && !bg) {

         /* opaque stipple: draw rotated text in background colour */
         if(values.fill_style==FillOpaqueStippled) {
             XSetForeground(dpy, my_gc, values.background);
             XSetFillStyle(dpy, my_gc, FillStippled);
             XSetStipple(dpy, my_gc, item->bitmap);
             XSetTSOrigin(dpy, my_gc, xp, yp);
             XFillRectangle(dpy, drawable, my_gc, xp, yp,
                  item->cols_out, item->rows_out);
             XSetForeground(dpy, my_gc, values.foreground);
         }

         /* this will merge the rotated text and the user's stipple */
         new_bitmap=XCreatePixmap(dpy, drawable,
                   item->cols_out, item->rows_out, 1);

                /* create a GC */
                depth_one_gc=XCreateGC(dpy, new_bitmap, NULL, 0);
                XSetForeground(dpy, depth_one_gc, 1);
                XSetBackground(dpy, depth_one_gc, 0);

                /* set the relative stipple origin */
                XSetTSOrigin(dpy, depth_one_gc,
                 values.ts_x_origin-xp, values.ts_y_origin-yp);

                /* fill the whole bitmap with the user's stipple */
                XSetStipple(dpy, depth_one_gc, values.stipple);
                XSetFillStyle(dpy, depth_one_gc, FillOpaqueStippled);
                XFillRectangle(dpy, new_bitmap, depth_one_gc,
                   0, 0, item->cols_out, item->rows_out);

                /* set stipple origin back to normal */
                XSetTSOrigin(dpy, depth_one_gc, 0, 0);

                /* this will contain an inverse copy of the rotated text */
                inverse=XCreatePixmap(dpy, drawable,
                     item->cols_out, item->rows_out, 1);

                /* invert text */
                XSetFillStyle(dpy, depth_one_gc, FillSolid);
                XSetFunction(dpy, depth_one_gc, GXcopyInverted);
                XCopyArea(dpy, item->bitmap, inverse, depth_one_gc,
              0, 0, item->cols_out, item->rows_out, 0, 0);

                /* now delete user's stipple everywhere EXCEPT on text */
                XSetForeground(dpy, depth_one_gc, 0);
                XSetBackground(dpy, depth_one_gc, 1);
                XSetStipple(dpy, depth_one_gc, inverse);
                XSetFillStyle(dpy, depth_one_gc, FillStippled);
                XSetFunction(dpy, depth_one_gc, GXcopy);
                XFillRectangle(dpy, new_bitmap, depth_one_gc,
                               0, 0, item->cols_out, item->rows_out);

                /* free resources */
                XFreePixmap(dpy, inverse);
                XFreeGC(dpy, depth_one_gc);

                /* this is the new bitmap */
                bitmap_to_paint=new_bitmap;
          }
      }
    }
#endif /*X11R3*/

    /* paint text using stipple technique */
    XSetFillStyle(dpy, my_gc, FillStippled);
    XSetStipple(dpy, my_gc, bitmap_to_paint);
    XSetTSOrigin(dpy, my_gc, xp, yp);
    XFillRectangle(dpy, drawable, my_gc, xp, yp,
            item->cols_out, item->rows_out);

    /* free our resources */
    XFreeGC(dpy, my_gc);

    /* stippled bitmap no longer needed */
    if(bitmap_to_paint!=item->bitmap)
      XFreePixmap(dpy, bitmap_to_paint);

#ifdef CACHE_XIMAGES
    XFreePixmap(dpy, item->bitmap);
#endif /*CACHE_XIMAGES*/

    /* if item isn't cached, destroy it completely */
    if(!item->cached)
      XRotFreeTextItem(dpy,item);

    /* we got to the end OK! */
    return 0;
}

/**************************************************************************/
/*  Draw a horizontal string in a quick fashion                           */
/**************************************************************************/

static int XRotDrawHorizontalString(dpy, font, drawable, gc, x, y, text,
                 align, bg)
    Display *dpy;
    XFontStruct *font;
    Drawable drawable;
    GC gc;
    int x, y;
    char *text;
    int align;
    int bg;
{
    GC my_gc;
    int nl=1, i;
    int height;
    int xp, yp;
    char *str1, *str2, *str3;
    char *str2_a="\0", *str2_b="\n\0";
    int dir, asc, desc;
    XCharStruct overall;

    DEBUG_PRINT1("**\nHorizontal text.\n");

    /* this gc has similar properties to the user's gc (including stipple) */
    my_gc=XCreateGC(dpy, drawable, NULL, 0);
    XCopyGC(dpy, gc,
          GCForeground|GCBackground|GCFunction|GCStipple|GCFillStyle|
          GCTileStipXOrigin|GCTileStipYOrigin|GCPlaneMask, my_gc);
    XSetFont(dpy, my_gc, font->fid);

    /* count number of sections in string */
    if(align!=NONE)
      for(i=0; i<strlen(text)-1; i++)
          if(text[i]=='\n')
         nl++;

    /* ignore newline characters if not doing alignment */
    if(align==NONE)
      str2=str2_a;
    else
      str2=str2_b;

    /* overall font height */
    height=font->ascent+font->descent;

    /* y position */
    if(align==TLEFT || align==TCENTRE || align==TRIGHT)
      yp=y+font->ascent;
    else if(align==MLEFT || align==MCENTRE || align==MRIGHT)
    {
    /*  Modify by O.Couet to have Middle alignment without font->descent */
    /*  yp=y-nl*height/2+font->ascent; */
        yp=y-nl*(height-font->descent)/2+font->ascent;
    }
    else if(align==BLEFT || align==BCENTRE || align==BRIGHT)
    {
    /*  Modify by O.Couet to have Bottom alignment without font->descent */
    /*  yp=y-nl*height+font->ascent; */
        yp=y-nl*(height-font->descent)+font->ascent;
    }
    else
      yp=y;

    str1=my_strdup(text);
    if(str1==NULL) return 1;

    str3=my_strtok(str1, str2);

    /* loop through each section in the string */
    do {
+SELF, IF=X11, IF=-WINNT, IF=-IBM.
        XTextExtents(font, str3, strlen(str3), &dir, &asc, &desc,
                     &overall);
+SELF, IF=X11, IF=-WINNT, IF=IBM.
        XTextExtents(font, LtoU(str3), strlen(str3), &dir, &asc, &desc,
                     &overall);
+SELF, IF=X11, IF=-WINNT.

      /* where to draw section in x ? */
      if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
          xp=x;
      else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
          xp=x-overall.rbearing/2;
      else
          xp=x-overall.rbearing;

      /* draw string onto bitmap */
      if(!bg)
          XDrawString(dpy, drawable, my_gc, xp, yp, str3, strlen(str3));
      else
          XDrawImageString(dpy, drawable, my_gc, xp, yp, str3, strlen(str3));

      /* move to next line */
      yp+=height;

      str3=my_strtok((char *)NULL, str2);
    }
    while(str3!=NULL);

    free(str1);
    XFreeGC(dpy, my_gc);

    return 0;
}

/**************************************************************************/
/*   Query cache for a match with this font/text/angle/alignment          */
/*       request, otherwise arrange for its creation                      */
/**************************************************************************/

static RotatedTextItem *XRotRetrieveFromCache(dpy, font, angle, text, align)
    Display *dpy;
    XFontStruct *font;
    float angle;
    char *text;
    int align;
{
    Font fid;
    char *font_name;
    unsigned long name_value;
    RotatedTextItem *item=NULL;
    RotatedTextItem *i1=first_text_item;

    /* get font name, if it exists */
    if(XGetFontProperty(font, XA_FONT, &name_value)) {
      DEBUG_PRINT1("got font name OK\n");
      font_name=XGetAtomName(dpy, name_value);
      fid=0;
    }
#ifdef CACHE_FID
    /* otherwise rely (unreliably?) on font ID */
    else {
      DEBUG_PRINT1("can't get fontname, caching FID\n");
      font_name=NULL;
      fid=font->fid;
    }
#else
    /* not allowed to cache font ID's */
    else {
      DEBUG_PRINT1("can't get fontname, can't cache\n");
      font_name=NULL;
      fid=0;
    }
#endif /*CACHE_FID*/

    /* look for a match in cache */

    /* matching formula:
       identical text;
       identical fontname (if defined, font ID's if not);
       angles close enough (<0.00001 here, could be smaller);
       HORIZONTAL alignment matches, OR it's a one line string;
       magnifications the same */

    while(i1 && !item) {
      /* match everything EXCEPT fontname/ID */
      if(strcmp(text, i1->text)==0 &&
         fabs(angle-i1->angle)<0.00001 &&
         style.magnify==i1->magnify &&
         (i1->nl==1 ||
          ((align==0)?9:(align-1))%3==
            ((i1->align==0)?9:(i1->align-1))%3)) {

          /* now match fontname/ID */
          if(font_name!=NULL && i1->font_name!=NULL) {
         if(strcmp(font_name, i1->font_name)==0) {
             item=i1;
             DEBUG_PRINT1("Matched against font names\n");
         }
         else
             i1=i1->next;
          }
#ifdef CACHE_FID
          else if(font_name==NULL && i1->font_name==NULL) {
         if(fid==i1->fid) {
             item=i1;
             DEBUG_PRINT1("Matched against FID's\n");
                }
         else
                    i1=i1->next;
          }
#endif /*CACHE_FID*/
          else
         i1=i1->next;
      }
      else
          i1=i1->next;
    }

    if(item)
      DEBUG_PRINT1("**\nFound target in cache.\n");
    if(!item)
      DEBUG_PRINT1("**\nNo match in cache.\n");

    /* no match */
    if(!item) {
      /* create new item */
      item=XRotCreateTextItem(dpy, font, angle, text, align);
      if(!item)
          return NULL;

      /* record what it shows */
      item->text=my_strdup(text);

      /* fontname or ID */
      if(font_name!=NULL) {
          item->font_name=my_strdup(font_name);
          item->fid=0;
      }
      else {
          item->font_name=NULL;
          item->fid=fid;
      }

      item->angle=angle;
      item->align=align;
      item->magnify=style.magnify;

      /* cache it */
      XRotAddToLinkedList(dpy, item);
    }

    if(font_name)
      XFree(font_name);

    /* if XImage is cached, need to recreate the bitmap */

#ifdef CACHE_XIMAGES
    {
      GC depth_one_gc;

      /* create bitmap to hold rotated text */
      item->bitmap=XCreatePixmap(dpy, DefaultRootWindow(dpy),
                  item->cols_out, item->rows_out, 1);

      /* depth one gc */
      depth_one_gc=XCreateGC(dpy, item->bitmap, NULL, 0);
      XSetBackground(dpy, depth_one_gc, 0);
      XSetForeground(dpy, depth_one_gc, 1);

      /* make the text bitmap from XImage */
      XPutImage(dpy, item->bitmap, depth_one_gc, item->ximage, 0, 0, 0, 0,
           item->cols_out, item->rows_out);

      XFreeGC(dpy, depth_one_gc);
    }
#endif /*CACHE_XIMAGES*/

    return item;
}

/**************************************************************************/
/*  Create a rotated text item                                            */
/**************************************************************************/

static RotatedTextItem *XRotCreateTextItem(dpy, font, angle, text, align)
    Display *dpy;
    XFontStruct *font;
    float angle;
    char *text;
    int align;
{
    RotatedTextItem *item;
    Pixmap canvas;
    GC font_gc;
    XImage *I_in;
    register int i, j;
    char *str1, *str2, *str3;
    char *str2_a="\0", *str2_b="\n\0";
    int height;
    int byte_w_in, byte_w_out;
    int xp, yp;
    float sin_angle, cos_angle;
    int it, jt;
    float di, dj;
    int ic=0;
    float xl, xr, xinc;
    int byte_out;
    int dir, asc, desc;
    XCharStruct overall;
    int old_cols_in=0, old_rows_in=0;

    /* allocate memory */
    item=(RotatedTextItem *)malloc((unsigned)sizeof(RotatedTextItem));
    if(!item)
      return NULL;

    /* count number of sections in string */
    item->nl=1;
    if(align!=NONE)
      for(i=0; i<strlen(text)-1; i++)
          if(text[i]=='\n')
         item->nl++;

    /* ignore newline characters if not doing alignment */
    if(align==NONE)
      str2=str2_a;
    else
      str2=str2_b;

    /* find width of longest section */
    str1=my_strdup(text);
    if(str1==NULL) return NULL;

    str3=my_strtok(str1, str2);

+SELF, IF=X11, IF=-WINNT, IF=-IBM.
    XTextExtents(font, str3, strlen(str3), &dir, &asc, &desc,
          &overall);
+SELF, IF=X11, IF=-WINNT, IF=IBM.
    XTextExtents(font, LtoU(str3), strlen(str3), &dir, &asc, &desc,
          &overall);
+SELF, IF=X11, IF=-WINNT.

    item->max_width=overall.rbearing;

    /* loop through each section */
    do {
      str3=my_strtok((char *)NULL, str2);

      if(str3!=NULL) {
+SELF, IF=X11, IF=-WINNT, IF=-IBM.
          XTextExtents(font, str3, strlen(str3), &dir, &asc, &desc,
             &overall);
+SELF, IF=X11, IF=-WINNT, IF=IBM.
          XTextExtents(font, LtoU(str3), strlen(str3), &dir, &asc, &desc,
             &overall);
+SELF, IF=X11, IF=-WINNT.
          if(overall.rbearing>item->max_width)
         item->max_width=overall.rbearing;
      }
    }
    while(str3!=NULL);

    free(str1);

    /* overall font height */
    height=font->ascent+font->descent;

    /* dimensions horizontal text will have */
    item->cols_in=item->max_width;
    item->rows_in=item->nl*height;

    /* bitmap for drawing on */
    canvas=XCreatePixmap(dpy, DefaultRootWindow(dpy),
             item->cols_in, item->rows_in, 1);

    /* create a GC for the bitmap */
    font_gc=XCreateGC(dpy, canvas, NULL, 0);
    XSetBackground(dpy, font_gc, 0);
    XSetFont(dpy, font_gc, font->fid);

    /* make sure the bitmap is blank */
    XSetForeground(dpy, font_gc, 0);
    XFillRectangle(dpy, canvas, font_gc, 0, 0,
            item->cols_in+1, item->rows_in+1);
    XSetForeground(dpy, font_gc, 1);

    /* pre-calculate sin and cos */
    sin_angle=sin(angle);
    cos_angle=cos(angle);

    /* text background will be drawn using XFillPolygon */
    item->corners_x=
      (float *)malloc((unsigned)(4*item->nl*sizeof(float)));
    if(!item->corners_x)
      return NULL;

    item->corners_y=
      (float *)malloc((unsigned)(4*item->nl*sizeof(float)));
    if(!item->corners_y)
      return NULL;

    /* draw text horizontally */

    /* start at top of bitmap */
    yp=font->ascent;

    str1=my_strdup(text);
    if(str1==NULL) return NULL;

    str3=my_strtok(str1, str2);

    /* loop through each section in the string */
    do {
+SELF, IF=X11, IF=-WINNT, IF=-IBM.
      XTextExtents(font, str3, strlen(str3), &dir, &asc, &desc,
         &overall);
+SELF, IF=X11, IF=-WINNT, IF=IBM.
      XTextExtents(font, LtoU(str3), strlen(str3), &dir, &asc, &desc,
         &overall);
+SELF, IF=X11, IF=-WINNT.

      /* where to draw section in x ? */
      if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
          xp=0;
      else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
          xp=(item->max_width-overall.rbearing)/2;
      else
            xp=item->max_width-overall.rbearing;

      /* draw string onto bitmap */
      XDrawString(dpy, canvas, font_gc, xp, yp, str3, strlen(str3));

      /* keep a note of corner positions of this string */
      item->corners_x[ic]=((float)xp-(float)item->cols_in/2)*style.magnify;
      item->corners_y[ic]=((float)(yp-font->ascent)-(float)item->rows_in/2)
          *style.magnify;
      item->corners_x[ic+1]=item->corners_x[ic];
      item->corners_y[ic+1]=item->corners_y[ic]+(float)height*style.magnify;
      item->corners_x[item->nl*4-1-ic]=item->corners_x[ic]+
          (float)overall.rbearing*style.magnify;
      item->corners_y[item->nl*4-1-ic]=item->corners_y[ic];
      item->corners_x[item->nl*4-2-ic]=
          item->corners_x[item->nl*4-1-ic];
      item->corners_y[item->nl*4-2-ic]=item->corners_y[ic+1];

      ic+=2;

      /* move to next line */
      yp+=height;

      str3=my_strtok((char *)NULL, str2);
    }
    while(str3!=NULL);

    free(str1);

    /* create image to hold horizontal text */
    I_in=MakeXImage(dpy, item->cols_in, item->rows_in);
    if(I_in==NULL)
      return NULL;

    /* extract horizontal text */
    XGetSubImage(dpy, canvas, 0, 0, item->cols_in, item->rows_in,
          1, XYPixmap, I_in, 0, 0);
    I_in->format=XYBitmap;

    /* magnify horizontal text */
    if(style.magnify!=1.) {
      I_in=XRotMagnifyImage(dpy, I_in);

      old_cols_in=item->cols_in;
      old_rows_in=item->rows_in;
      item->cols_in=(float)item->cols_in*style.magnify;
      item->rows_in=(float)item->rows_in*style.magnify;
    }

    /* how big will rotated text be ? */
    item->cols_out=fabs((float)item->rows_in*sin_angle) +
      fabs((float)item->cols_in*cos_angle) +0.99999 +2;

    item->rows_out=fabs((float)item->rows_in*cos_angle) +
      fabs((float)item->cols_in*sin_angle) +0.99999 +2;

    if(item->cols_out%2==0)
      item->cols_out++;

    if(item->rows_out%2==0)
      item->rows_out++;

    /* create image to hold rotated text */
    item->ximage=MakeXImage(dpy, item->cols_out, item->rows_out);
    if(item->ximage==NULL)
      return NULL;

    byte_w_in=(item->cols_in-1)/8+1;
    byte_w_out=(item->cols_out-1)/8+1;

    /* we try to make this bit as fast as possible - which is why it looks
       a bit over-the-top */

    /* vertical distance from centre */
    dj=0.5-(float)item->rows_out/2;

    /* where abouts does text actually lie in rotated image? */
    if(angle==0 || angle==M_PI/2 ||
       angle==M_PI || angle==3*M_PI/2) {
      xl=0;
      xr=(float)item->cols_out;
      xinc=0;
    }
    else if(angle<M_PI) {
      xl=(float)item->cols_out/2+
          (dj-(float)item->rows_in/(2*cos_angle))/
         tan(angle)-2;
      xr=(float)item->cols_out/2+
          (dj+(float)item->rows_in/(2*cos_angle))/
         tan(angle)+2;
      xinc=1./tan(angle);
    }
    else {
      xl=(float)item->cols_out/2+
          (dj+(float)item->rows_in/(2*cos_angle))/
         tan(angle)-2;
      xr=(float)item->cols_out/2+
          (dj-(float)item->rows_in/(2*cos_angle))/
         tan(angle)+2;

      xinc=1./tan(angle);
    }

    /* loop through all relevent bits in rotated image */
    for(j=0; j<item->rows_out; j++) {

      /* no point re-calculating these every pass */
      di=(float)((xl<0)?0:(int)xl)+0.5-(float)item->cols_out/2;
      byte_out=(item->rows_out-j-1)*byte_w_out;

      /* loop through meaningful columns */
      for(i=((xl<0)?0:(int)xl);
          i<((xr>=item->cols_out)?item->cols_out:(int)xr); i++) {

          /* rotate coordinates */
          it=(float)item->cols_in/2 + ( di*cos_angle + dj*sin_angle);
          jt=(float)item->rows_in/2 - (-di*sin_angle + dj*cos_angle);

            /* set pixel if required */
            if(it>=0 && it<item->cols_in && jt>=0 && jt<item->rows_in)
                if((I_in->data[jt*byte_w_in+it/8] & 128>>(it%8))>0)
                    item->ximage->data[byte_out+i/8]|=128>>i%8;

          di+=1;
      }
      dj+=1;
      xl+=xinc;
      xr+=xinc;
    }
    XDestroyImage(I_in);

    if(style.magnify!=1.) {
      item->cols_in=old_cols_in;
      item->rows_in=old_rows_in;
    }


#ifdef CACHE_BITMAPS

    /* create a bitmap to hold rotated text */
    item->bitmap=XCreatePixmap(dpy, DefaultRootWindow(dpy),
                   item->cols_out, item->rows_out, 1);

    /* make the text bitmap from XImage */
    XPutImage(dpy, item->bitmap, font_gc, item->ximage, 0, 0, 0, 0,
            item->cols_out, item->rows_out);

    XDestroyImage(item->ximage);

#endif /*CACHE_BITMAPS*/

    XFreeGC(dpy, font_gc);
    XFreePixmap(dpy, canvas);

    return item;
}

/**************************************************************************/
/*  Adds a text item to the end of the cache, removing as many items      */
/*      from the front as required to keep cache size below limit         */
/**************************************************************************/

static void XRotAddToLinkedList(dpy, item)
    Display *dpy;
    RotatedTextItem *item;
{

    static long int current_size=0;
    static RotatedTextItem *last=NULL;
    RotatedTextItem *i1=first_text_item, *i2;

#ifdef CACHE_BITMAPS

    /* I don't know how much memory a pixmap takes in the server -
           probably this + a bit more we can't account for */

    item->size=((item->cols_out-1)/8+1)*item->rows_out;

#else

    /* this is pretty much the size of a RotatedTextItem */

    item->size=((item->cols_out-1)/8+1)*item->rows_out +
      sizeof(XImage) + strlen(item->text) +
          item->nl*8*sizeof(float) + sizeof(RotatedTextItem);

    if(item->font_name!=NULL)
      item->size+=strlen(item->font_name);
    else
      item->size+=sizeof(Font);

#endif /*CACHE_BITMAPS */

#ifdef DEBUG
    /* count number of items in cache, for debugging */
    {
      int i=0;

      while(i1) {
          i++;
          i1=i1->next;
      }
      DEBUG_PRINT2("Cache has %d items.\n", i);
      i1=first_text_item;
    }
#endif

    DEBUG_PRINT4("current cache size=%ld, new item=%ld, limit=%ld\n",
          current_size, item->size, CACHE_SIZE_LIMIT*1024);

    /* if this item is bigger than whole cache, forget it */
    if(item->size>CACHE_SIZE_LIMIT*1024) {
      DEBUG_PRINT1("Too big to cache\n\n");
      item->cached=0;
      return;
    }

    /* remove elements from cache as needed */
    while(i1 && current_size+item->size>CACHE_SIZE_LIMIT*1024) {

      DEBUG_PRINT2("Removed %d bytes\n", i1->size);

      if(i1->font_name!=NULL)
          DEBUG_PRINT5("  (`%s'\n   %s\n   angle=%f align=%d)\n",
             i1->text, i1->font_name, i1->angle, i1->align);

#ifdef CACHE_FID
      if(i1->font_name==NULL)
          DEBUG_PRINT5("  (`%s'\n  FID=%ld\n   angle=%f align=%d)\n",
                         i1->text, i1->fid, i1->angle, i1->align);
#endif /*CACHE_FID*/

      current_size-=i1->size;

      i2=i1->next;

      /* free resources used by the unlucky item */
      XRotFreeTextItem(dpy, i1);

      /* remove it from linked list */
      first_text_item=i2;
      i1=i2;
    }

    /* add new item to end of linked list */
    if(first_text_item==NULL) {
      item->next=NULL;
      first_text_item=item;
      last=item;
    }
    else {
      item->next=NULL;
      last->next=item;
      last=item;
    }

    /* new cache size */
    current_size+=item->size;

    item->cached=1;

    DEBUG_PRINT1("Added item to cache.\n");
}

/**************************************************************************/
/*  Free the resources used by a text item                                */
/**************************************************************************/

static void XRotFreeTextItem(dpy, item)
    Display *dpy;
    RotatedTextItem *item;
{
    free(item->text);

    if(item->font_name!=NULL)
      free(item->font_name);

    free((char *)item->corners_x);
    free((char *)item->corners_y);

#ifdef CACHE_BITMAPS
    XFreePixmap(dpy, item->bitmap);
#else
    XDestroyImage(item->ximage);
#endif /* CACHE_BITMAPS */

    free((char *)item);
}

/**************************************************************************/
/* Magnify an XImage using bilinear interpolation                         */
/**************************************************************************/

static XImage *XRotMagnifyImage(dpy, ximage)
    Display *dpy;
    XImage *ximage;
{
    int i, j;
    float x, y;
    float u,t;
    XImage *I_out;
    int cols_in, rows_in;
    int cols_out, rows_out;
    register int i2, j2;
    float z1, z2, z3, z4;
    int byte_width_in, byte_width_out;
    float mag_inv;

    /* size of input image */
    cols_in=ximage->width;
    rows_in=ximage->height;

    /* size of final image */
    cols_out=(float)cols_in*style.magnify;
    rows_out=(float)rows_in*style.magnify;

    /* this will hold final image */
    I_out=MakeXImage(dpy, cols_out, rows_out);
    if(I_out==NULL)
      return NULL;

    /* width in bytes of input, output images */
    byte_width_in=(cols_in-1)/8+1;
    byte_width_out=(cols_out-1)/8+1;

    /* for speed */
    mag_inv=1./style.magnify;

    y=0.;

    /* loop over magnified image */
    for(j2=0; j2<rows_out; j2++) {
      x=0;
      j=y;

      for(i2=0; i2<cols_out; i2++) {
          i=x;

          /* bilinear interpolation - where are we on bitmap ? */
          /* right edge */
          if(i==cols_in-1 && j!=rows_in-1) {
         t=0;
         u=y-(float)j;

         z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
         z2=z1;
         z3=(ximage->data[(j+1)*byte_width_in+i/8] & 128>>(i%8))>0;
         z4=z3;
          }
          /* top edge */
          else if(i!=cols_in-1 && j==rows_in-1) {
         t=x-(float)i;
         u=0;

         z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
         z2=(ximage->data[j*byte_width_in+(i+1)/8] & 128>>((i+1)%8))>0;
         z3=z2;
         z4=z1;
          }
          /* top right corner */
          else if(i==cols_in-1 && j==rows_in-1) {
         u=0;
         t=0;

         z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
         z2=z1;
         z3=z1;
         z4=z1;
          }
          /* somewhere `safe' */
          else {
         t=x-(float)i;
         u=y-(float)j;

         z1=(ximage->data[j*byte_width_in+i/8] & 128>>(i%8))>0;
         z2=(ximage->data[j*byte_width_in+(i+1)/8] & 128>>((i+1)%8))>0;
         z3=(ximage->data[(j+1)*byte_width_in+(i+1)/8] &
             128>>((i+1)%8))>0;
         z4=(ximage->data[(j+1)*byte_width_in+i/8] & 128>>(i%8))>0;
          }

          /* if interpolated value is greater than 0.5, set bit */
          if(((1-t)*(1-u)*z1 + t*(1-u)*z2 + t*u*z3 + (1-t)*u*z4)>0.5)
         I_out->data[j2*byte_width_out+i2/8]|=128>>i2%8;

          x+=mag_inv;
      }
      y+=mag_inv;
    }

    /* destroy original */
    XDestroyImage(ximage);

    /* return big image */
    return I_out;
}

/**************************************************************************/
/* Calculate the bounding box some text will have when painted            */
/**************************************************************************/

XPoint *XRotTextExtents(dpy, font, angle, x, y, text, align)
    Display *dpy;
    XFontStruct *font;
    float angle;
    int x, y;
    char *text;
    int align;
{
    register int i;
    char *str1, *str2, *str3;
    char *str2_a="\0", *str2_b="\n\0";
    int height;
    float sin_angle, cos_angle;
    int nl, max_width;
    int cols_in, rows_in;
    float hot_x, hot_y;
    XPoint *xp_in, *xp_out;
    int dir, asc, desc;
    XCharStruct overall;

    /* manipulate angle to 0<=angle<360 degrees */
    while(angle<0)
        angle+=360;

    while(angle>360)
        angle-=360;

    angle*=M_PI/180;

    /* count number of sections in string */
    nl=1;
    if(align!=NONE)
      for(i=0; i<strlen(text)-1; i++)
          if(text[i]=='\n')
         nl++;

    /* ignore newline characters if not doing alignment */
    if(align==NONE)
      str2=str2_a;
    else
      str2=str2_b;

    /* find width of longest section */
    str1=my_strdup(text);
    if(str1==NULL) return NULL;

    str3=my_strtok(str1, str2);

+SELF, IF=X11, IF=-WINNT, IF=-IBM.
    XTextExtents(font, str3, strlen(str3), &dir, &asc, &desc,
          &overall);
+SELF, IF=X11, IF=-WINNT, IF=IBM.
    XTextExtents(font, LtoU(str3), strlen(str3), &dir, &asc, &desc,
          &overall);
+SELF, IF=X11, IF=-WINNT.

    max_width=overall.rbearing;

    /* loop through each section */
    do {
      str3=my_strtok((char *)NULL, str2);

      if(str3!=NULL) {
+SELF, IF=X11, IF=-WINNT, IF=-IBM.
          XTextExtents(font, str3, strlen(str3), &dir, &asc, &desc,
             &overall);
+SELF, IF=X11, IF=-WINNT, IF=IBM.
          XTextExtents(font, LtoU(str3), strlen(str3), &dir, &asc, &desc,
             &overall);
+SELF, IF=X11, IF=-WINNT.

          if(overall.rbearing>max_width)
         max_width=overall.rbearing;
      }
    }
    while(str3!=NULL);

    free(str1);

    /* overall font height */
    height=font->ascent+font->descent;

    /* dimensions horizontal text will have */
    cols_in=max_width;
    rows_in=nl*height;

    /* pre-calculate sin and cos */
    sin_angle=sin(angle);
    cos_angle=cos(angle);

    /* y position */
    if(align==TLEFT || align==TCENTRE || align==TRIGHT)
        hot_y=(float)rows_in/2*style.magnify;
    else if(align==MLEFT || align==MCENTRE || align==MRIGHT)
      hot_y=0;
    else if(align==BLEFT || align==BCENTRE || align==BRIGHT)
      hot_y=-(float)rows_in/2*style.magnify;
    else
      hot_y=-((float)rows_in/2-(float)font->descent)*style.magnify;

    /* x position */
    if(align==TLEFT || align==MLEFT || align==BLEFT || align==NONE)
      hot_x=-(float)max_width/2*style.magnify;
    else if(align==TCENTRE || align==MCENTRE || align==BCENTRE)
      hot_x=0;
    else
        hot_x=(float)max_width/2*style.magnify;

    /* reserve space for XPoints */
    xp_in=(XPoint *)malloc((unsigned)(5*sizeof(XPoint)));
    if(!xp_in)
      return NULL;

    xp_out=(XPoint *)malloc((unsigned)(5*sizeof(XPoint)));
    if(!xp_out)
      return NULL;

    /* bounding box when horizontal, relative to bitmap centre */
    xp_in[0].x=-(float)cols_in*style.magnify/2-style.bbx_pad;
    xp_in[0].y= (float)rows_in*style.magnify/2+style.bbx_pad;
    xp_in[1].x= (float)cols_in*style.magnify/2+style.bbx_pad;
    xp_in[1].y= (float)rows_in*style.magnify/2+style.bbx_pad;
    xp_in[2].x= (float)cols_in*style.magnify/2+style.bbx_pad;
    xp_in[2].y=-(float)rows_in*style.magnify/2-style.bbx_pad;
    xp_in[3].x=-(float)cols_in*style.magnify/2-style.bbx_pad;
    xp_in[3].y=-(float)rows_in*style.magnify/2-style.bbx_pad;
    xp_in[4].x=xp_in[0].x;
    xp_in[4].y=xp_in[0].y;

    /* rotate and translate bounding box */
    for(i=0; i<5; i++) {
      xp_out[i].x=(float)x + ( ((float)xp_in[i].x-hot_x)*cos_angle +
                ((float)xp_in[i].y+hot_y)*sin_angle);
      xp_out[i].y=(float)y + (-((float)xp_in[i].x-hot_x)*sin_angle +
                ((float)xp_in[i].y+hot_y)*cos_angle);
    }

    free((char *)xp_in);

    return xp_out;
}
+SELF.
+DECK,  TKHIGZ, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.1.1.1  1996/02/14 13:10:26  mclareni
 * Higz
 *
 */

+SELF, IF=TKTCL.
/*CMZ :  1.23/06 22/11/95  10.12.40  by  O.Couet*/
/*-- Author :    O.Couet   22/11/95*/
/*
 * tkHigz.c --
 *
 *    This module implements a widget for higz to draw in.
 *    Several widgets can exist but only one is the active one
 *    and will be used to draw in.
 *    Based on the Square widget.
 *
 * Copyright (c) 1991-1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */

+CDE, CFORTRAN.
#if !defined(VMS) && !defined(_WINDOWS)
+CDE, TKCONFIG.
#endif
+CDE, TK.

/*
 * A data structure of the following type is kept for each higz
 * widget managed by this file:
 */

typedef struct {
    Tk_Window tkwin;    /* Window that embodies the higz.  NULL
                * means window has been deleted but
                * widget record hasn't been cleaned up yet. */
    Display *display;      /* X's token for the window's display. */
    Tcl_Interp *interp;    /* Interpreter associated with widget. */

    /*
     * Information used when displaying widget:
     */

    Tk_3DBorder bgBorder;  /* Used for drawing background. */
    Tk_3DBorder fgBorder;  /* For drawing by higz. */
    int relief;         /* Indicates whether window as a whole is
                * raised, sunken, or flat. */
    GC gc;        /* Graphics context for copying from
                * off-screen pixmap onto screen. */
    int updatePending;     /* Non-zero means a call to HigzDisplay
                * has already been scheduled. */
    int height;         /* The height of the plot window */
    int width;       /* The width of the plot window */
    int higzwin;     /* Higz win id */
} Higz;

/*
 * Information used for argv parsing.
 */

static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_BORDER, "-background", "background", "Background",
      "#cdb79e", Tk_Offset(Higz, bgBorder), TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
      "white", Tk_Offset(Higz, bgBorder), TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_SYNONYM, "-bg", "background", (char *) NULL,
      (char *) NULL, 0, 0},
    {TK_CONFIG_SYNONYM, "-fg", "foreground", (char *) NULL,
      (char *) NULL, 0, 0},
    {TK_CONFIG_BORDER, "-foreground", "foreground", "Foreground",
      "#b03060", Tk_Offset(Higz, fgBorder), TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-foreground", "foreground", "Foreground",
      "black", Tk_Offset(Higz, fgBorder), TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_PIXELS, "-height", "height", "Height",
      "400", Tk_Offset(Higz, height), 0},
    {TK_CONFIG_PIXELS, "-width", "width", "Width",
      "400", Tk_Offset(Higz, width), 0},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
      (char *) NULL, 0, 0}
};

/*
 * Forward declarations for procedures defined later in this file:
 */

static int     HigzConfigure _ANSI_ARGS_((Tcl_Interp *interp,
                Higz *higzPtr, int argc, char **argv,
                int flags));
static void    HigzDestroy _ANSI_ARGS_((ClientData clientData));
static void    HigzDisplay _ANSI_ARGS_((ClientData clientData));
static void    HigzEventProc _ANSI_ARGS_((ClientData clientData,
                XEvent *eventPtr));
static int     HigzWidgetCmd _ANSI_ARGS_((ClientData clientData,
                Tcl_Interp *, int argc, char **argv));

PROTOCCALLSFFUN0(INT,OPENHIGZWINDOW,openhigzwindow);
#define OPENHIGZWINDOW \
      CCALLSFFUN0(OPENHIGZWINDOW,openhigzwindow)

#define SELECTHIGZWINDOW(I) \
      CCALLSFSUB1(SELECTHIGZWINDOW,selecthigzwindow,INT,I)


/*
 * Global variable to keep track of currently active Higz widget
 * (yes we should not do global vars, maybe removed later
 */

static char *  higz_current;


/*
 *--------------------------------------------------------------
 *
 * HigzCmd --
 *
 *    This procedure is invoked to process the "higz" Tcl
 *    command.  It creates a new "higz" widget.
 *
 * Results:
 *    A standard Tcl result.
 *
 * Side effects:
 *    A new widget is created and configured.
 *
 *--------------------------------------------------------------
 */

int
HigzCmd(clientData, interp, argc, argv)
    ClientData clientData; /* Main window associated with
                * interpreter. */
    Tcl_Interp *interp;    /* Current interpreter. */
    int argc;        /* Number of arguments. */
    char **argv;     /* Argument strings. */
{
    Tk_Window main = (Tk_Window) clientData;
    Higz *higzPtr;
    Tk_Window tkwin;

    if (argc < 2) {
      Tcl_AppendResult(interp, "wrong # args:  should be \"",
         argv[0], " pathName ?options?\"", (char *) NULL);
      return TCL_ERROR;
    }

    tkwin = Tk_CreateWindowFromPath(interp, main, argv[1], (char *) NULL);
    if (tkwin == NULL) {
      return TCL_ERROR;
    }
    Tk_SetClass(tkwin, "Higz");

    /*
     * Allocate and initialize the widget record.
     */

    higzPtr = (Higz *) ckalloc(sizeof(Higz));
    higzPtr->tkwin = tkwin;
    higzPtr->display = Tk_Display(tkwin);
    higzPtr->interp = interp;
    higzPtr->bgBorder = NULL;
    higzPtr->fgBorder = NULL;
    higzPtr->relief = TK_RELIEF_FLAT;
    higzPtr->gc = None;
    higzPtr->updatePending = 0;

    Tk_MakeWindowExist( tkwin );

    Tk_CreateEventHandler(higzPtr->tkwin, ExposureMask|StructureNotifyMask,
          HigzEventProc, (ClientData) higzPtr);
    Tcl_CreateCommand(interp, Tk_PathName(higzPtr->tkwin), HigzWidgetCmd,
          (ClientData) higzPtr, (void (*)()) NULL);
    if (HigzConfigure(interp, higzPtr, argc-2, argv+2, 0) != TCL_OK) {
      Tk_DestroyWindow(higzPtr->tkwin);
      return TCL_ERROR;
    }

    ixsdswi( higzPtr->display, Tk_WindowId(higzPtr->tkwin) );
    higzPtr->higzwin = OPENHIGZWINDOW;

    interp->result = Tk_PathName(higzPtr->tkwin);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * HigzWidgetCmd --
 *
 *    This procedure is invoked to process the Tcl command
 *    that corresponds to a widget managed by this module.
 *    See the user documentation for details on what it does.
 *
 * Results:
 *    A standard Tcl result.
 *
 * Side effects:
 *    See the user documentation.
 *
 *--------------------------------------------------------------
 */

static int
HigzWidgetCmd(clientData, interp, argc, argv)
    ClientData clientData;    /* Information about higz widget. */
    Tcl_Interp *interp;       /* Current interpreter. */
    int argc;           /* Number of arguments. */
    char **argv;        /* Argument strings. */
{
    Higz *higzPtr = (Higz *) clientData;
    int result = TCL_OK;
    int length;
    char c;

    if (argc < 2) {
      Tcl_AppendResult(interp, "wrong # args: should be \"",
         argv[0], " option ?arg arg ...?\"", (char *) NULL);
      return TCL_ERROR;
    }
    Tk_Preserve((ClientData) higzPtr);
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'c') && (strncmp(argv[1], "configure", length) == 0)) {
      if (argc == 2) {
          result = Tk_ConfigureInfo(interp, higzPtr->tkwin, configSpecs,
             (char *) higzPtr, (char *) NULL, 0);
      } else if (argc == 3) {
          result = Tk_ConfigureInfo(interp, higzPtr->tkwin, configSpecs,
             (char *) higzPtr, argv[2], 0);
      } else {
          result = HigzConfigure(interp, higzPtr, argc-2, argv+2,
             TK_CONFIG_ARGV_ONLY);
      }
    } else if ((c == 's') && (strncmp(argv[1], "select", length) == 0)) {
      if ( argc != 2 ) {
          Tcl_AppendResult(interp, "wrong # args: should be \"",
             argv[0], " select\"", (char *) NULL);
          goto error;
      }

      if ( higz_current != 0 ) {
         strcpy( interp->result, higz_current );
         free( higz_current );
      }

      higz_current = strdup( Tk_PathName( higzPtr->tkwin ) );
      SELECTHIGZWINDOW( higzPtr->higzwin );

    } else if ((c == 'g') && (strncmp(argv[1], "geometry", length) == 0)) {
      Window   root;
      int   xval, yval;
      unsigned int   wval, hval, border, depth;

      XGetGeometry( higzPtr->display, Tk_WindowId(higzPtr->tkwin),
         &root, &xval, &yval, &wval, &hval, &border, &depth );

      printf( "x=%d y=%d w=%d h=%d b=%d d=%d\n", xval, yval, wval, hval,
         border, depth );
    } else {
      Tcl_AppendResult(interp, "bad option \"", argv[1],
         "\":  must be configure, position, or size", (char *) NULL);
      goto error;
    }
    if (!higzPtr->updatePending) {
      Tk_DoWhenIdle(HigzDisplay, (ClientData) higzPtr);
      higzPtr->updatePending = 1;
    }
    Tk_Release((ClientData) higzPtr);
    return result;

    error:
    Tk_Release((ClientData) higzPtr);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * HigzConfigure --
 *
 *    This procedure is called to process an argv/argc list in
 *    conjunction with the Tk option database to configure (or
 *    reconfigure) a higz widget.
 *
 * Results:
 *    The return value is a standard Tcl result.  If TCL_ERROR is
 *    returned, then interp->result contains an error message.
 *
 * Side effects:
 *    Configuration information, such as colors, border width,
 *    etc. get set for higzPtr;  old resources get freed,
 *    if there were any.
 *
 *----------------------------------------------------------------------
 */

static int
HigzConfigure(interp, higzPtr, argc, argv, flags)
    Tcl_Interp *interp;       /* Used for error reporting. */
    Higz *higzPtr;         /* Information about widget. */
    int argc;           /* Number of valid entries in argv. */
    char **argv;        /* Arguments. */
    int flags;          /* Flags to pass to
                   * Tk_ConfigureWidget. */
{
    if (Tk_ConfigureWidget(interp, higzPtr->tkwin, configSpecs,
          argc, argv, (char *) higzPtr, flags) != TCL_OK) {
      return TCL_ERROR;
    }

    /*
     * Set the background for the window and create a graphics context
     * for use during redisplay.
     */

    Tk_SetWindowBackground(higzPtr->tkwin,
          Tk_3DBorderColor(higzPtr->bgBorder)->pixel);
    if ( higzPtr->gc == None ) {
      XGCValues gcValues;
      gcValues.function = GXcopy;
      gcValues.graphics_exposures = False;
      higzPtr->gc = Tk_GetGC(higzPtr->tkwin,
         GCFunction|GCGraphicsExposures, &gcValues);
    }

    /*
     * Register the desired geometry for the window.  Then arrange for
     * the window to be redisplayed.
     */

    Tk_GeometryRequest(higzPtr->tkwin, higzPtr->width, higzPtr->height);
    if (!higzPtr->updatePending) {
      Tk_DoWhenIdle(HigzDisplay, (ClientData) higzPtr);
      higzPtr->updatePending = 1;
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * HigzEventProc --
 *
 *    This procedure is invoked by the Tk dispatcher for various
 *    events on higzs.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    When the window gets deleted, internal structures get
 *    cleaned up.  When it gets exposed, it is redisplayed.
 *
 *--------------------------------------------------------------
 */

static void
HigzEventProc(clientData, eventPtr)
    ClientData clientData; /* Information about window. */
    XEvent *eventPtr;      /* Information about event. */
{
    Higz *higzPtr = (Higz *) clientData;
    Tk_Window tkwin = higzPtr->tkwin;

#define IGRSIZ(IWKID) \
      CCALLSFSUB1(IGRSIZ,igrsiz,INT,IWKID)

    if (eventPtr->type == Expose) {
      if (!higzPtr->updatePending) {
          Tk_DoWhenIdle(HigzDisplay, (ClientData) higzPtr);
          higzPtr->updatePending = 1;
      }
    } else if (eventPtr->type == ConfigureNotify) {

      Window   root;
      int   xval, yval, wiid;
      unsigned int   wval, hval, border, depth;
      float rval;

      XGetGeometry( higzPtr->display, Tk_WindowId(higzPtr->tkwin),
         &root, &xval, &yval, &wval, &hval, &border, &depth );

      IGRSIZ( higzPtr->higzwin );

      if (!higzPtr->updatePending) {
          Tk_DoWhenIdle(HigzDisplay, (ClientData) higzPtr);
          higzPtr->updatePending = 1;
      }

    } else if (eventPtr->type == DestroyNotify) {
      Tcl_DeleteCommand(higzPtr->interp, Tk_PathName(higzPtr->tkwin));
      higzPtr->tkwin = NULL;
      if (higzPtr->updatePending) {
          Tk_CancelIdleCall(HigzDisplay, (ClientData) higzPtr);
      }
      Tk_EventuallyFree((ClientData) higzPtr, HigzDestroy);
    }
}

/*
 *--------------------------------------------------------------
 *
 * HigzDisplay --
 *
 *    This procedure redraws the contents of a higz window.
 *    It is invoked as a do-when-idle handler, so it only runs
 *    when there's nothing else for the application to do.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Information appears on the screen.
 *
 *--------------------------------------------------------------
 */

static void
HigzDisplay(clientData)
    ClientData clientData; /* Information about window. */
{
    Higz *higzPtr = (Higz *) clientData;
    Tk_Window tkwin = higzPtr->tkwin;
    Drawable d;

    higzPtr->updatePending = 0;
    if (!Tk_IsMapped(tkwin)) {
      return;
    } else {
#ifdef _WINDOWS
#define IXUPDWI(I) \
      CCALLSFSUB1(IXUPDWI,ixupdwi,INT,I)
      IXUPDWI( 1 );
#endif
    }
}

/*
 *----------------------------------------------------------------------
 *
 * HigzDestroy --
 *
 *    This procedure is invoked by Tk_EventuallyFree or Tk_Release
 *    to clean up the internal structure of a higz at a safe time
 *    (when no-one is using it anymore).
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Everything associated with the higz is freed up.
 *
 *----------------------------------------------------------------------
 */

static void
HigzDestroy(clientData)
    ClientData clientData; /* Info about higz widget. */
{
    Higz *higzPtr = (Higz *) clientData;

#define ICLWK(IWK) CCALLSFSUB1(ICLWK,iclwk,INT,IWK)

    ICLWK(higzPtr->higzwin);
    Tk_FreeOptions(configSpecs, (char *) higzPtr, higzPtr->display, 0);
    if (higzPtr->gc != None) {
      Tk_FreeGC(higzPtr->display, higzPtr->gc);
    }
    ckfree((char *) higzPtr);
}
+SELF.
+DECK,  X11INT, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.20  2000/07/08 06:19:30  couet
 * - with an external window as parent, the position of the window created by
 *   ixopnwi was not correct.
 *
 * Revision 1.19  1999/04/01 09:20:24  couet
 * - MapNotify is not supported by all the X11 emulators (problem on Mac !!!)
 *
 * Revision 1.18  1999/01/08 14:07:10  couet
 * - imgscaling prototype only in GIF is selected
 *
 * Revision 1.17  1999/01/08 13:56:56  couet
 * - prototype for imgscaling
 *
 * Revision 1.16  1998/11/16 11:11:17  couet
 * - ixdogif can scale pictures
 *
 * Revision 1.15  1998/11/13 14:13:23  couet
 * - uses image size instead of window size in ixdogif
 *
 * Revision 1.14  1998/11/13 10:49:07  couet
 * - New version of the routine imgpickpalette coming from a C++ version
 *   from Fons Rademakers. This version allows to work on TrueColor
 *   devices. ixdogif in x11int.c has been modified in order to use this
 *   new version of imgpickpalette. Protections have been added in
 *   ixdogif to prevent some crashes when one try to create a gif after
 *   a window resizing or when the program (for example PAW) started
 *   with a workstation type equal to 0. All the static arrays in ixdogif
 *   have been converted into dynamic one.
 *
 * Revision 1.13  1998/11/11 16:23:39  couet
 * - Protection added in ixdogif in case the Visual is TrueColor
 *
 * Revision 1.12  1998/10/28 10:05:37  couet
 * - a printf (debug) has been removed
 *
 * Revision 1.10  1998/01/30 15:22:06  couet
 * - APOLLO version removed
 *
 * Revision 1.9  1997/06/20 15:07:19  couet
 * - protection added in ixdogif in case the output file (gif) cannot be open.
 *
 * Revision 1.8  1997/04/22 08:42:57  couet
 * - The delete option in the WM top left button is disabled because it stopped
 * the application.
 *
 * Revision 1.7  1996/10/16 13:50:50  couet
 * - Remaining defined colors are freed in ixclsds
 *
 * Revision 1.6  1996/04/23 08:36:54  couet
 * - The test on "display" in ixopnds was not correct. In the case of Paw++
 *   the display is set outside the ixopnds routine and in that case the
 *   graphics contexts was not initialized. Now the variable isdisp is tested.
 *
 * Revision 1.5  1996/04/19 16:23:52  maartenb
 * - Use XFreeFontNames() to free fontlist
 *
 * Revision 1.4  1996/04/19 13:23:00  couet
 * - free(fontlist) was misplaced
 *
 * Revision 1.3  1996/04/19 12:10:31  couet
 * - Free fontlist to avoid memory leak
 *
 * Revision 1.2  1996/04/18 14:36:12  couet
 * - ixopnds exit with return code 0 if the display is already open.
 *
 * - Modify the way the fonts are managed to avoid memory leak.
 *
 * Revision 1.1.1.1  1996/02/14 13:10:26  mclareni
 * Higz
 *
 */

+SELF, IF=X11, IF=-WINNT.

/******************************************************************************
 *                                                                            *
 *-- Author : O.Couet                                                         *
 *                                                                            *
 * Fortran interface to X11 window routines for HIGZ                          *
 *                                                                            *
 ******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
#include <fortran.h>
+SELF, IF=X11, IF=-WINNT, IF=VAX.
#include <descrip.h>
#include <lnmdef.h>
#include <types.h>
#include <socket.h>  /* for gethostname()                                     */
#define CADDR_T      /* defined in types.h would be redefined in Xlib.h       */
#include <decw$include/Xlib.h>
#include <decw$include/Xutil.h>
#include <decw$include/Xatom.h>
#include <decw$include/cursorfont.h>
#include <decw$include/keysym.h>
+SELF, IF=X11, IF=-WINNT, IF=IBM.
#include <types.h>
+SELF, IF=X11, IF=-WINNT, IF=-VAX.
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/keysym.h>
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
#define ixclip  IXCLIP
#define ixclrwi IXCLRWI
#define ixclsds IXCLSDS
#define ixclswi IXCLSWI
#define ixflare IXFLARE
#define ixgetge IXGETGE
#define ixgetpl IXGETPL
#define ixgetht IXGETHT
#define ixgetwi IXGETWI
#define ixline  IXLINE
#define ixmarke IXMARKE
#define ixnocli IXNOCLI
#define ixopnds IXOPNDS
#define ixopnwi IXOPNWI
#define ixreqlo IXREQLO
#define ixqptr  IXQPTR
#define ixwarp  IXWARP
#define ixreqst IXREQST
#define ixselwi IXSELWI
#define ixsetco IXSETCO
#define ixsetfc IXSETFC
#define ixsetfs IXSETFS
#define ixsetlc IXSETLC
#define ixsetln IXSETLN
#define ixsetls IXSETLS
#define ixsetmc IXSETMC
#define ixsetms IXSETMS
#define ixsetta IXSETTA
#define ixsettc IXSETTC
#define ixsettf IXSETTF
#define ixtext  IXTEXT
#define ixupdwi IXUPDWI
#define ixbox   IXBOX
#define ixtxtl  IXTXTL
#define ixdrmde IXDRMDE
#define ixsync  IXSYNC
#define ixsethn IXSETHN
#define ixopnpx IXOPNPX
#define ixclpx  IXCLPX
#define ixcppx  IXCPPX
#define ixrmpx  IXRMPX
#define ixwipx  IXWIPX
#define ixclrpx IXCLRPX
#define ixs2buf IXS2BUF
#define ixq2buf IXQ2BUF
#define ixwrpx  IXWRPX
#define ixrsiz  IXRSIZ
#define ixsavwi IXSAVWI
#define ixsetwi IXSETWI
#define ixrscwi IXRSCWI
#define ixmovwi IXMOVWI
#define ixminit IXMINIT
#define ixca    IXCA
+SELF, IF=X11, IF=-WINNT, IF=CRAY, IF=GIF.
#define ixdogif IXDOGIF
#define ixldgif IXLDGIF
+SELF, IF=X11, IF=-WINNT, IF=IBM.
#pragma linkage (ixclip ,FORTRAN)
#pragma linkage (ixclrwi,FORTRAN)
#pragma linkage (ixclsds,FORTRAN)
#pragma linkage (ixclswi,FORTRAN)
#pragma linkage (ixflare,FORTRAN)
#pragma linkage (ixgetge,FORTRAN)
#pragma linkage (ixgetpl,FORTRAN)
#pragma linkage (ixgetht,FORTRAN)
#pragma linkage (ixgetwi,FORTRAN)
#pragma linkage (ixline ,FORTRAN)
#pragma linkage (ixmarke,FORTRAN)
#pragma linkage (ixnocli,FORTRAN)
#pragma linkage (ixopnds,FORTRAN)
#pragma linkage (ixopnwi,FORTRAN)
#pragma linkage (ixreqlo,FORTRAN)
#pragma linkage (ixqptr ,FORTRAN)
#pragma linkage (ixwarp ,FORTRAN)
#pragma linkage (ixreqst,FORTRAN)
#pragma linkage (ixselwi,FORTRAN)
#pragma linkage (ixsetco,FORTRAN)
#pragma linkage (ixsetfc,FORTRAN)
#pragma linkage (ixsetfs,FORTRAN)
#pragma linkage (ixsetlc,FORTRAN)
#pragma linkage (ixsetln,FORTRAN)
#pragma linkage (ixsetls,FORTRAN)
#pragma linkage (ixsetmc,FORTRAN)
#pragma linkage (ixsetms,FORTRAN)
#pragma linkage (ixsetta,FORTRAN)
#pragma linkage (ixsettc,FORTRAN)
#pragma linkage (ixsettf,FORTRAN)
#pragma linkage (ixtext ,FORTRAN)
#pragma linkage (ixupdwi,FORTRAN)
#pragma linkage (ixbox  ,FORTRAN)
#pragma linkage (ixtxtl ,FORTRAN)
#pragma linkage (ixdrmde,FORTRAN)
#pragma linkage (ixsync ,FORTRAN)
#pragma linkage (ixsethn,FORTRAN)
#pragma linkage (ixopnpx,FORTRAN)
#pragma linkage (ixclpx ,FORTRAN)
#pragma linkage (ixcppx ,FORTRAN)
#pragma linkage (ixrmpx ,FORTRAN)
#pragma linkage (ixwipx ,FORTRAN)
#pragma linkage (ixclrpx,FORTRAN)
#pragma linkage (ixs2buf,FORTRAN)
#pragma linkage (ixq2buf,FORTRAN)
#pragma linkage (ixwrpx ,FORTRAN)
#pragma linkage (ixrsiz ,FORTRAN)
#pragma linkage (ixsavwi,FORTRAN)
#pragma linkage (ixsetwi,FORTRAN)
#pragma linkage (ixrscwi,FORTRAN)
#pragma linkage (ixmovwi,FORTRAN)
#pragma linkage (ixminit,FORTRAN)
#pragma linkage (ixca   ,FORTRAN)
#define XRotDrawString XRDS
#define XRotDrawImageString XRDIS
#define XRotDrawAlignedString XRDAS
#define XRotDrawAlignedImageString XRDAIS
+SELF, IF=X11, IF=-WINNT, IF=IBM, IF=GIF.
#pragma linkage (ixdogif,FORTRAN)
#pragma linkage (ixldgif,FORTRAN)
+SELF, IF=X11, IF=-WINNT, IF=QX_SC.
#define ixclip  ixclip_
#define ixclrwi ixclrwi_
#define ixclsds ixclsds_
#define ixclswi ixclswi_
#define ixflare ixflare_
#define ixgetge ixgetge_
#define ixgetpl ixgetpl_
#define ixgetht ixgetht_
#define ixgetwi ixgetwi_
#define ixline  ixline_
#define ixmarke ixmarke_
#define ixnocli ixnocli_
#define ixopnds ixopnds_
#define ixopnwi ixopnwi_
#define ixreqlo ixreqlo_
#define ixqptr  ixqptr_
#define ixwarp  ixwarp_
#define ixreqst ixreqst_
#define ixselwi ixselwi_
#define ixsetco ixsetco_
#define ixsetfc ixsetfc_
#define ixsetfs ixsetfs_
#define ixsetlc ixsetlc_
#define ixsetln ixsetln_
#define ixsetls ixsetls_
#define ixsetmc ixsetmc_
#define ixsetms ixsetms_
#define ixsetta ixsetta_
#define ixsettc ixsettc_
#define ixsettf ixsettf_
#define ixtext  ixtext_
#define ixupdwi ixupdwi_
#define ixbox   ixbox_
#define ixtxtl  ixtxtl_
#define ixdrmde ixdrmde_
#define ixsync  ixsync_
#define ixsethn ixsethn_
#define ixopnpx ixopnpx_
#define ixclpx  ixclpx_
#define ixcppx  ixcppx_
#define ixrmpx  ixrmpx_
#define ixwipx  ixwipx_
#define ixclrpx ixclrpx_
#define ixs2buf ixs2buf_
#define ixq2buf ixq2buf_
#define ixwrpx  ixwrpx_
#define ixrsiz  ixrsiz_
#define ixsavwi ixsavwi_
#define ixsetwi ixsetwi_
#define ixrscwi ixrscwi_
#define ixmovwi ixmovwi_
#define ixminit ixminit_
#define ixca    ixca_
+SELF, IF=X11, IF=-WINNT, IF=QX_SC, IF=GIF.
#define ixdogif ixdogif_
#define ixldgif ixldgif_
+SELF, IF=X11, IF=-WINNT, IF=TKTCL, IF=WINNT.
#define ixclip  __stdcall IXCLIP
#define ixclrwi __stdcall IXCLRWI
#define ixclsds __stdcall IXCLSDS
#define ixclswi __stdcall IXCLSWI
#define ixflare __stdcall IXFLARE
#define ixgetge __stdcall IXGETGE
#define ixgetpl __stdcall IXGETPL
#define ixgetht __stdcall IXGETHT
#define ixgetwi __stdcall IXGETWI
#define ixline  __stdcall IXLINE
#define ixmarke __stdcall IXMARKE
#define ixnocli __stdcall IXNOCLI
#define ixopnds __stdcall IXOPNDS
#define ixopnwi __stdcall IXOPNWI
#define ixreqlo __stdcall IXREQLO
#define ixqptr  __stdcall IXQPTR
#define ixwarp  __stdcall IXWARP
#define ixreqst __stdcall IXREQST
#define ixselwi __stdcall IXSELWI
#define ixsetco __stdcall IXSETCO
#define ixsetfc __stdcall IXSETFC
#define ixsetfs __stdcall IXSETFS
#define ixsetlc __stdcall IXSETLC
#define ixsetln __stdcall IXSETLN
#define ixsetls __stdcall IXSETLS
#define ixsetmc __stdcall IXSETMC
#define ixsetms __stdcall IXSETMS
#define ixsetta __stdcall IXSETTA
#define ixsettc __stdcall IXSETTC
#define ixsettf __stdcall IXSETTF
#define ixtext  __stdcall IXTEXT
#define ixupdwi __stdcall IXUPDWI
#define ixbox   __stdcall IXBOX
#define ixtxtl  __stdcall IXTXTL
#define ixdrmde __stdcall IXDRMDE
#define ixsync  __stdcall IXSYNC
#define ixsethn __stdcall IXSETHN
#define ixopnpx __stdcall IXOPNPX
#define ixclpx  __stdcall IXCLPX
#define ixcppx  __stdcall IXCPPX
#define ixrmpx  __stdcall IXRMPX
#define ixwipx  __stdcall IXWIPX
#define ixclrpx __stdcall IXCLRPX
#define ixs2buf __stdcall IXS2BUF
#define ixq2buf __stdcall IXQ2BUF
#define ixwrpx  __stdcall IXWRPX
#define ixrsiz  __stdcall IXRSIZ
#define ixsavwi __stdcall IXSAVWI
#define ixsetwi __stdcall IXSETWI
#define ixrscwi __stdcall IXRSCWI
#define ixmovwi __stdcall IXMOVWI
#define ixminit __stdcall IXMINIT
#define ixca    __stdcall IXCA
+SELF, IF=X11, IF=-WINNT, IF=TKTCL, IF=WINNT, IF=GIF.
#define ixdogif __stdcall IXDOGIF
#define ixldgif __stdcall IXLDGIF
+SELF, IF=X11, IF=-WINNT.

#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))

#define forever while(1)
#define LNULL 0L

#define MAXWN 20                 /* maximum number of windows                 */
static struct {
  int      open;                 /* 1 if the window is open, 0 if not         */
  int      motif;                /* 1 if the window is a motif window         */
  Drawable motif_window;         /* adress of the Motif window                */
  int      double_buffer;        /* 1 if the double buffer is on, 0 if not    */
  Drawable drawing;              /* drawing area, equal to window or buffer   */
  Drawable window;               /* X11 window                                */
  Drawable buffer;               /* pixmap used for double buffer             */
  int width;                     /* width of the window                       */
  int height;                    /* height of the window                      */
  int clip;                      /* 1 if the clipping is on                   */
  int xclip;                     /* x coordinate of the clipping rectangle    */
  int yclip;                     /* y coordinate of the clipping rectangle    */
  int wclip;                     /* width of the clipping rectangle           */
  int hclip;                     /* height of the clipping rectangle          */
} windows[MAXWN],                /* windows : list of the opened windows      */
  *cws, *tws, *sws;              /* cws : pointer to the current window       */
                                 /* tws : temporary pointer                   */
                                 /* sws : saved window (ixsavwi ixsetwi)      */

Drawable oldwin;                 /* allows to save the current opened window  */
static int ispix = 0;            /* if ispix=1 a pixmap has been opened       */

static XClassHint class_hints = {"higz", "HIGZ"}; /* Class name is HIGZ       */

static Display *display;
static int isdisp = 0;           /* if isdisp=1 the display has been opened   */
static Screen *screen;
static int screen_number;
static char hname[132];          /* host name                                 */
static char vendor[132];         /* output of XServerVendor                   */

static Window (*motif_open) ();  /* external routine to open a motif window   */
static void (*motif_init) ();    /* external routine to init a motif window   */
static void (*motif_close) ();   /* external routine to close a motif window  */

static int external_int = 0;
static Drawable external_window;

static int do_raise = 0;         /* if do_raise =1 cws is raised in ixupdwi   */

/*
 * colors[1]           : foreground also used for b/w screen
 * colors[0]           : background also used for b/w screen
 * colors[2..MAXCOL-1] : colors which can be set by IXSETCO
 */
static int colored;              /* Flag if color screen                      */
static Colormap colormap;        /* Maba's Colormap                           */

#define MAXCOL 256
static struct {
  int defined;
  unsigned long pixel;
  float red;
  float green;
  float blue;
} colors[MAXCOL] = {0, 0, 1., 1., 1.};

/*
 * Primitives Graphic Contexts global for all windows
 */
#define MAXGC 7
static GC gclist[MAXGC];
static GC *gcline = &gclist[0];  /* Polylines                                 */
static GC *gcmark = &gclist[1];  /* Polymarker                                */
static GC *gcfill = &gclist[2];  /* Fill areas                                */
static GC *gctext = &gclist[3];  /* Text                                      */
static GC *gcinvt = &gclist[4];  /* Inverse text                              */
static GC *gcdash = &gclist[5];  /* Dashed lines                              */
static GC *gcpxmp = &gclist[6];  /* Pixmap management                         */

static unsigned long gc_mask = GCForeground | GCBackground;
static XGCValues gc_return;

/*
 * Input echo Graphic Context global for all windows
 */
static GC gcecho;                           /* input echo                     */
static XGCValues gcechov;

static int fill_hollow;                     /* Flag if fill style is hollow   */
static Pixmap fill_pattern = (Pixmap)LNULL; /* Fill pattern                   */
static int current_fasi = 0;                /* Current fill area style index  */
static int text_align = 0;                  /* Align text left, center, right */

/*
 * Text management
 */
#define MAXFONT 4
static struct {
  XFontStruct *id;
  char name[80];                            /* font name                      */
} font[MAXFONT];                            /* list of fonts loaded           */
static XFontStruct *text_font;              /* current font                   */
static int current_font_number = 0;         /* current font number in font[]  */

/*
 * keep style values for line GC
 */
static int line_width = 0;
static int line_style = LineSolid;
static int cap_style  = CapButt;
static int join_style = JoinMiter;
static char dash_list[4];
static int dash_length = 0;
static int dash_offset = 0;

/*
 * event masks
 */
static unsigned long mouse_mask = ButtonPressMask   | ButtonReleaseMask |
                                  EnterWindowMask   | LeaveWindowMask   |
                                  PointerMotionMask | KeyPressMask      |
                                  KeyReleaseMask;
static unsigned long keybd_mask = ButtonPressMask | KeyPressMask |
                                  EnterWindowMask | LeaveWindowMask;

/*
 * last cursor positions
 */
static int xloc  = 0;
static int yloc  = 0;
static int xlocp = 0;
static int ylocp = 0;

/*
 * data to create an invisible cursor
 */
static char null_cursor_bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static Cursor null_cursor = (Cursor)LNULL;

/*
 * data to create fill area interior style
 */
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
#define Hatches_type static unsigned char
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
#define Hatches_type static char
+SELF, IF=X11, IF=-WINNT.

Hatches_type         p1_bits[] = {
   0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55,
   0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55,
   0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55};
Hatches_type         p2_bits[] = {
   0x44, 0x44, 0x11, 0x11, 0x44, 0x44, 0x11, 0x11, 0x44, 0x44, 0x11, 0x11,
   0x44, 0x44, 0x11, 0x11, 0x44, 0x44, 0x11, 0x11, 0x44, 0x44, 0x11, 0x11,
   0x44, 0x44, 0x11, 0x11, 0x44, 0x44, 0x11, 0x11};
Hatches_type         p3_bits[] = {
   0x00, 0x00, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00, 0x44, 0x44,
   0x00, 0x00, 0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11,
   0x00, 0x00, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11};
Hatches_type         p4_bits[] = {
   0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04,
   0x02, 0x02, 0x01, 0x01, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10,
   0x08, 0x08, 0x04, 0x04, 0x02, 0x02, 0x01, 0x01};
Hatches_type         p5_bits[] = {
   0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04,
   0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x01, 0x01,
   0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10};
Hatches_type         p6_bits[] = {
   0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
   0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
   0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44};
Hatches_type         p7_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff};
Hatches_type         p8_bits[] = {
   0x11, 0x11, 0xb8, 0xb8, 0x7c, 0x7c, 0x3a, 0x3a, 0x11, 0x11, 0xa3, 0xa3,
   0xc7, 0xc7, 0x8b, 0x8b, 0x11, 0x11, 0xb8, 0xb8, 0x7c, 0x7c, 0x3a, 0x3a,
   0x11, 0x11, 0xa3, 0xa3, 0xc7, 0xc7, 0x8b, 0x8b};
Hatches_type         p9_bits[] = {
   0x10, 0x10, 0x10, 0x10, 0x28, 0x28, 0xc7, 0xc7, 0x01, 0x01, 0x01, 0x01,
   0x82, 0x82, 0x7c, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x28, 0x28, 0xc7, 0xc7,
   0x01, 0x01, 0x01, 0x01, 0x82, 0x82, 0x7c, 0x7c};
Hatches_type         p10_bits[] = {
   0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xff, 0xff, 0x01, 0x01, 0x01, 0x01,
   0x01, 0x01, 0xff, 0xff, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xff, 0xff,
   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xff};
Hatches_type         p11_bits[] = {
   0x08, 0x08, 0x49, 0x49, 0x2a, 0x2a, 0x1c, 0x1c, 0x2a, 0x2a, 0x49, 0x49,
   0x08, 0x08, 0x00, 0x00, 0x80, 0x80, 0x94, 0x94, 0xa2, 0xa2, 0xc1, 0xc1,
   0xa2, 0xa2, 0x94, 0x94, 0x80, 0x80, 0x00, 0x00};
Hatches_type         p12_bits[] = {
   0x1c, 0x1c, 0x22, 0x22, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x22, 0x22,
   0x1c, 0x1c, 0x00, 0x00, 0xc1, 0xc1, 0x22, 0x22, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x22, 0x22, 0xc1, 0xc1, 0x00, 0x00};
Hatches_type         p13_bits[] = {
   0x01, 0x01, 0x82, 0x82, 0x44, 0x44, 0x28, 0x28, 0x10, 0x10, 0x28, 0x28,
   0x44, 0x44, 0x82, 0x82, 0x01, 0x01, 0x82, 0x82, 0x44, 0x44, 0x28, 0x28,
   0x10, 0x10, 0x28, 0x28, 0x44, 0x44, 0x82, 0x82};
Hatches_type         p14_bits[] = {
   0xff, 0xff, 0x11, 0x10, 0x11, 0x10, 0x11, 0x10, 0xf1, 0x1f, 0x11, 0x11,
   0x11, 0x11, 0x11, 0x11, 0xff, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11,
   0xff, 0xff, 0x01, 0x10, 0x01, 0x10, 0x01, 0x10};
Hatches_type         p15_bits[] = {
   0x22, 0x22, 0x55, 0x55, 0x22, 0x22, 0x00, 0x00, 0x88, 0x88, 0x55, 0x55,
   0x88, 0x88, 0x00, 0x00, 0x22, 0x22, 0x55, 0x55, 0x22, 0x22, 0x00, 0x00,
   0x88, 0x88, 0x55, 0x55, 0x88, 0x88, 0x00, 0x00};
Hatches_type         p16_bits[] = {
   0x0e, 0x0e, 0x11, 0x11, 0xe0, 0xe0, 0x00, 0x00, 0x0e, 0x0e, 0x11, 0x11,
   0xe0, 0xe0, 0x00, 0x00, 0x0e, 0x0e, 0x11, 0x11, 0xe0, 0xe0, 0x00, 0x00,
   0x0e, 0x0e, 0x11, 0x11, 0xe0, 0xe0, 0x00, 0x00};
Hatches_type         p17_bits[] = {
   0x44, 0x44, 0x22, 0x22, 0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x22, 0x22,
   0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11, 0x00, 0x00,
   0x44, 0x44, 0x22, 0x22, 0x11, 0x11, 0x00, 0x00};
Hatches_type         p18_bits[] = {
   0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x22, 0x22,
   0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x00, 0x00,
   0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x00, 0x00};
Hatches_type         p19_bits[] = {
   0xe0, 0x03, 0x98, 0x0c, 0x84, 0x10, 0x42, 0x21, 0x42, 0x21, 0x21, 0x42,
   0x19, 0x4c, 0x07, 0xf0, 0x19, 0x4c, 0x21, 0x42, 0x42, 0x21, 0x42, 0x21,
   0x84, 0x10, 0x98, 0x0c, 0xe0, 0x03, 0x80, 0x00};
Hatches_type         p20_bits[] = {
   0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x44, 0x44,
   0x44, 0x44, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
   0x22, 0x22, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44};
Hatches_type         p21_bits[] = {
   0xf1, 0xf1, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0x1f, 0x01, 0x01,
   0x01, 0x01, 0x01, 0x01, 0xf1, 0xf1, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
   0x1f, 0x1f, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01};
Hatches_type         p22_bits[] = {
   0x8f, 0x8f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0xf8, 0xf8, 0x80, 0x80,
   0x80, 0x80, 0x80, 0x80, 0x8f, 0x8f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
   0xf8, 0xf8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80};
Hatches_type         p23_bits[] = {
   0xAA, 0xAA, 0x55, 0x55, 0x6a, 0x6a, 0x74, 0x74, 0x78, 0x78, 0x74, 0x74,
   0x6a, 0x6a, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0x6a, 0x6a, 0x74, 0x74,
   0x78, 0x78, 0x74, 0x74, 0x6a, 0x6a, 0x55, 0x55};
Hatches_type         p24_bits[] = {
   0x80, 0x00, 0xc0, 0x00, 0xea, 0xa8, 0xd5, 0x54, 0xea, 0xa8, 0xd5, 0x54,
   0xeb, 0xe8, 0xd5, 0xd4, 0xe8, 0xe8, 0xd4, 0xd4, 0xa8, 0xe8, 0x54, 0xd5,
   0xa8, 0xea, 0x54, 0xd5, 0xfc, 0xff, 0xfe, 0xff};
Hatches_type         p25_bits[] = {
   0x80, 0x00, 0xc0, 0x00, 0xe0, 0x00, 0xf0, 0x00, 0xff, 0xf0, 0xff, 0xf0,
   0xfb, 0xf0, 0xf9, 0xf0, 0xf8, 0xf0, 0xf8, 0x70, 0xf8, 0x30, 0xff, 0xf0,
   0xff, 0xf8, 0xff, 0xfc, 0xff, 0xfe, 0xff, 0xff};


#define MAXMK 100
static struct {
  int type;
  int n;
  XPoint xy[MAXMK];
} marker;                        /* point list to draw marker                 */

+SELF, IF=X11, IF=-WINNT, IF=GIF.
XImage * ImgScaling(Display *, XImage *, int, int);
+SELF, IF=X11, IF=-WINNT.

/*
 *    Set input on or off
 */
void
  setinput(inp)
int inp;
{
  XSetWindowAttributes attributes;
  unsigned long attr_mask = 0;

  if( inp == 1 ) {
    attributes.event_mask = mouse_mask | keybd_mask;
    attr_mask |= CWEventMask;
    XChangeWindowAttributes ( display, cws->window, attr_mask, &attributes);
  }
  else {
     attr_mask = 0;
     attributes.event_mask = NoEventMask;
     attr_mask |= CWEventMask;
     XChangeWindowAttributes ( display, cws->window, attr_mask, &attributes);
  }
}


/*
 * set the foreground color in GC
 */
void
  setcolor( gc, ci )
GC gc;
int ci;
{
  if( colored && ( ci < 0 || ci >= MAXCOL || !colors[ci].defined ) )
    {
     ci = 0;
    }
  else if (!colored && ci < 0 )
    {
     ci = 0;
    }
  else if (!colored && ci > 0 )
    {
     ci = 1;
    }

  XSetForeground( display, gc, colors[ci].pixel );

  /* make sure that foreground and background are different */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  if ( XGetGCValues( display, gc, gc_mask, &gc_return) ) {
     if ( gc_return.foreground == gc_return.background )
        XSetBackground( display, gc, colors[!ci].pixel );
  } else {
     printf("**** Error: Cannot get GC values \n");
  }
+SELF, IF=X11, IF=-WINNT.
}


/*
 * return null terminated and blank trimmed string
 */
char*
  string( s, l )
char *s;
int l;
{
  static char str[256];
  int i;

  if( l >= sizeof( str ) )
    l = sizeof( str ) - 1;

  for( i = 0; i < l; i++ )
    str[i] = s[i];
  while( l > 0 && str[l-1] == ' ' )
    l--;

  str[l] = '\0';
  return( str );
}

+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
void ixsgc(gc)
   GC gc;
{
   gclist[0] = *gcline = gc;
   gclist[1] = *gcmark = gc;
   gclist[2] = *gcfill = gc;
   gclist[3] = *gctext = gc;
   gclist[4] = *gcinvt = gc;
   gclist[5] = *gcdash = gc;
   gclist[6] = *gcpxmp = gc;
}

void ixdsdb()
{
     XCopyArea( display, cws->drawing, cws->window,
                *gcpxmp, 0, 0, cws->width, cws->height, 0, 0 );
}
+SELF, IF=X11, IF=-WINNT.

+SELF, IF=X11, IF=-WINNT, IF=IBM.
int isascii(c)
int c;
{
return(isprint(c)||iscntrl(c));
}
+SELF, IF=X11, IF=-WINNT.


/*
 *    Allows to set the DISPLAY and the WINDOW address
 *    from outside HIGZ (ie a MOTIF program).
 */
void
  ixsdswi( dsp , win )
  Display *dsp;
  Window win;
{
   external_int = 1;
   external_window = win;
   display = dsp;
}

/*
 *    Allows KUIP to give to HIGZ the adress of three routines:
 *    1) motif_open  : to open a KUIP motif window
 *    2) motif_init  : to initalize a KUIP motif window (add the callbacks)
 *    3) motif_close : to close a KUIP motif window
 */
void
  ixmotif( dsp , open, init, close)
  Display *dsp;
  Window (*open)();
  void (*init)();
  void (*close)();
{
   display = dsp;
   motif_open  = open;
   motif_init  = init;
   motif_close = close;
}


/*
 *    SUBROUTINE IXMINIT(WID)
 *    INTEGER WID : Window ID
 *
 *    Initialize the Motif windows (add the callbacks)
 */
void
  ixminit(wid)
  int *wid;
{
  if (motif_init != NULL) (*motif_init) (*wid+1);
}


/*
 *    SUBROUTINE IXSETHN(LENHST,HOST)
 *    INTEGER LENHST      : host name length
 *    CHARACTER*(*) HOST  : host name
 *
 *    Set host name (fill global variable hname)
 */
void
  ixsethn( lenhst,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
          fcd_host )
_fcd fcd_host;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
          dsc_host )
struct dsc$descriptor_s *dsc_host;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
          host,lenhost )
char *host;
int lenhost;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
          host )
char *host;
+SELF, IF=X11, IF=-WINNT.
int *lenhst;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *host = _fcdtocp( fcd_host );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *host = dsc_host->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.

strcpy (hname,string( host, *lenhst ));
}


/*
 *    INTEGER FUNCTION IXOPNDS(LENHST,HOST)
 *    INTEGER LENHST      : host name length
 *    CHARACTER*(*) HOST  : host name
 *
 *    Open the display. Return -1 if the opening fails
 */
int
  ixopnds( lenhst,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
          fcd_host )
_fcd fcd_host;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
          dsc_host )
struct dsc$descriptor_s *dsc_host;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
          host, lenhost )
char *host;
int lenhost;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
          host )
char *host;
+SELF, IF=X11, IF=-WINNT.
int *lenhst;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *host = _fcdtocp( fcd_host );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *host = dsc_host->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.
  Pixmap pixmp1,pixmp2;
  XColor fore,back;
  char **fontlist;
  int fontcount;
  int i;
  extern char *getenv();

/*
 *              Try to open the DISPLAY
 */
  if ( !isdisp ) {
     if( display == NULL ) {
+SELF, IF=X11, IF=-WINNT, IF=-VAX.
        if( *lenhst == 0 ) {
           display = XOpenDisplay( getenv( "DISPLAY" ) );
        } else {
           display = XOpenDisplay( string( host, *lenhst ));
        }
+SELF, IF=X11, IF=-WINNT, IF=VAX.
        display = XOpenDisplay( string( host, *lenhst ));
+SELF, IF=X11, IF=-WINNT.
        if( display == NULL ) return( -1 );
     }
  } else {
     return( 0 );
  }

  screen_number = DefaultScreen( display );
  screen        = ScreenOfDisplay( display, screen_number);
  colored       = DisplayPlanes( display, screen_number ) > 1;

  if (colored) colormap = DefaultColormap( display, screen_number);

  /* colors[1].defined = 1; default foreground */
  colors[1].pixel = BlackPixel( display, screen_number );
  /* colors[0].defined = 1; default background */
  colors[0].pixel = WhitePixel( display, screen_number );

/*
 *              Inquire the the XServer Vendor
 */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  strcpy (vendor,XServerVendor(display));
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
  strcpy(vendor,"Microsoft");
+SELF, IF=X11, IF=-WINNT.

/*
 *              Create primitives graphic contexts
 */
  for ( i = 0; i < MAXGC; i++ )
     gclist[i] = XCreateGC( display, RootWindow( display, screen_number ),
                             0, NULL );
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  if ( XGetGCValues( display, *gctext, gc_mask, &gc_return) ) {
     XSetForeground( display, *gcinvt, gc_return.background );
     XSetBackground( display, *gcinvt, gc_return.foreground );
  } else {
     printf("**** Error: Cannot get GC values \n");
  }
+SELF, IF=X11, IF=-WINNT.

/*
 *              Create input echo graphic context
 */
  gcechov.foreground = BlackPixel( display, screen_number );
  gcechov.background = WhitePixel( display, screen_number );
  if(strstr(vendor,"Hewlett")) {
     gcechov.function   = GXxor;
  } else {
     gcechov.function   = GXinvert;
  }
  gcecho = XCreateGC( display, RootWindow( display, screen_number ),
                      GCForeground | GCBackground | GCFunction,
                      &gcechov );
/*
 *              Load a default Font
 */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  for ( i = 0; i < MAXFONT; i++ ) {
     font[i].id = NULL;
     strcpy( font[i].name, " " );
  }
  fontlist = XListFonts( display, "*courier*", 1, &fontcount );
  if ( fontcount != 0 ) {
     font[current_font_number].id = XLoadQueryFont( display, fontlist[0] );
     text_font = font[current_font_number].id;
     strcpy( font[current_font_number].name, "*courier*" );
     current_font_number++;
     XFreeFontNames(fontlist);
  } else {
     printf("No default font loaded \n");
  }
+SELF, IF=X11, IF=-WINNT.
/*
 *              Create a null cursor
 */
  pixmp1 = XCreateBitmapFromData(display,
                                 RootWindow( display, screen_number ),
                                 null_cursor_bits, 16, 16);
  pixmp2 = XCreateBitmapFromData(display,
                                 RootWindow( display, screen_number ),
                                 null_cursor_bits, 16, 16);
  null_cursor = XCreatePixmapCursor(display,pixmp1,pixmp2,&fore,&back,0,0);

  isdisp = 1;
  return( 0 );
}


/*
 *    INTEGER FUNCTION IXOPNWI(X,Y,W,H,LENTIT,TITLE,FLAG)
 *    INTEGER X,Y         : initial window position
 *    INTEGER W,H         : initial window width and height
 *    INTEGER LENTIT      : title length
 *    CHARACTER*(*) TITLE : window title
 *    INTEGER FLAG        : FLAG<>1 allows to open a non MOTIF window
 *                          even if ixmotif has been called.
 *
 *    Open window and returns window number which can be used with IXSELWIN
 *    return -1 if window creation fails
 */
int
  ixopnwi( x, y, w, h, lentit,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
          fcd_title, flag )
_fcd fcd_title;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
          dsc_title, flag )
struct dsc$descriptor_s *dsc_title;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
          title, lentitle, flag )
char *title;
int lentitle;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
          title, flag )
char *title;
+SELF, IF=X11, IF=-WINNT.
int *x, *y;
int *w, *h;
int *lentit;
int *flag;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *title = _fcdtocp( fcd_title );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *title = dsc_title->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.
  XSetWindowAttributes attributes;
  unsigned long attr_mask = 0;
  char long_title[256];
  char host_name[64];
  XWMHints wm_hints;
  XSizeHints size_hints;
  Atom atm[1];
  Status istat;
  int wid;
  int xval, yval;
  unsigned int wval, hval, border, depth;
  Window root;

  if (external_int == 1) {
     XGetGeometry( display, external_window, &root,
                   &xval, &yval, &wval, &hval, &border, &depth );
     xval = 0;
     yval = 0;
  }
  else {
     xval = *x;
     yval = *y;
     wval = *w;
     hval = *h;
  }

/*
 *              Select next free window number
 */
      for ( wid = 0; wid < MAXWN; wid++ )
         if ( !windows[wid].open ) {
            windows[wid].open = 1;
            cws = &windows[wid];
            break;
         }
/*
 *              Create a Motif window
 */
      if (motif_open != NULL && *flag == 0) {
          cws->motif_window = (*motif_open) (wid+1, xval, yval, wval, hval);
          if ( !cws->motif_window ) return( -1 );
          XGetGeometry( display, cws->motif_window, &root,
                        &xval, &yval, &wval, &hval, &border, &depth );
      }

      if ( wid == MAXWN ) return( -1 );
/*
 *              Create window
 */
      attributes.background_pixel = colors[0].pixel;
      attr_mask |= CWBackPixel;
      attributes.border_pixel = colors[1].pixel;
      attr_mask |= CWBorderPixel;
      attributes.event_mask = NoEventMask;
      attr_mask |= CWEventMask;
      attributes.backing_store = Always;
      attr_mask |= CWBackingStore;
      if ( colored ) {
         attributes.colormap = colormap;
         attr_mask |= CWColormap;
      }
      if (motif_open != NULL && *flag == 0) {
         cws->window = XCreateWindow(display, cws->motif_window,
                       xval, yval, wval, hval, 0, CopyFromParent,
                       InputOutput, CopyFromParent,
                       attr_mask, &attributes );
         cws->motif = 1;
      } else {
         if (external_int == 1) {
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
            cws->window = XCreateWindow(display, external_window,
                          xval, yval, wval, hval, 0, CopyFromParent,
                          InputOutput, CopyFromParent,
                          attr_mask, &attributes );
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
            cws->window = external_window;
+SELF, IF=X11, IF=-WINNT.
            external_int = 0;
            cws->motif = 1;
            cws->motif_window = external_window;
         } else {
            cws->motif = 0;
            cws->window = XCreateWindow(display,
                          RootWindow( display, screen_number),
                          xval, yval, wval, hval, 1, CopyFromParent,
                          InputOutput, CopyFromParent,
                          attr_mask, &attributes );
            strcpy( long_title, string( title, *lentit ) );
            if (long_title[0] != '-') {
               strcat( long_title, " @ " );
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
               gethostname( host_name, sizeof( host_name ) );
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
               strcat( long_title, " Win95 ");
+SELF, IF=X11, IF=-WINNT.
               strcat( long_title, host_name );
            } else {
               long_title[0] = ' ';
            }
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
            XStoreName( display, cws->window, long_title );
+SELF, IF=X11, IF=-WINNT.
            XSetIconName( display, cws->window, long_title );
         }
      }
/*
 *              Set window manager hints
 */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
      memset( &wm_hints, 0, sizeof(wm_hints));
      wm_hints.flags = InputHint;
      wm_hints.input = False;  /* don't grab input focus */
      XSetWMHints( display, cws->window, &wm_hints );
+SELF, IF=X11, IF=-WINNT.
/*
 *              Set window size hints
 */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
      memset( &size_hints, 0, sizeof(size_hints));
      size_hints.flags = USPosition | USSize;
      size_hints.x = xval;
      size_hints.y = yval;
      size_hints.width = wval;
      size_hints.height = hval;
      XSetNormalHints( display, cws->window, &size_hints );
+SELF, IF=X11, IF=-WINNT.
/*
 *              Define the position and size of the window
 *              Map the window
 */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
      XMoveWindow( display, cws->window, xval, yval );
      XResizeWindow( display, cws->window, wval, hval );
      XMapWindow( display, cws->window );
/*
 *              Wait until the window is mapped (MapNotify)
 * This is not supported by all the X11 emulators (problem on Mac !!!)
 *
      XSelectInput(display, cws->window, StructureNotifyMask);
      forever {
         XEvent event;
         XNextEvent( display, &event);
         if (event.type == MapNotify) break;
      }
 */
      XFlush( display );
+SELF, IF=X11, IF=-WINNT.
/*
 *              Set the Class Hint
 */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
      XSetClassHint(display, cws->window, &class_hints);
+SELF, IF=X11, IF=-WINNT.
/*
 *              Set Window Manager Protocols
 */
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
      atm[0] = XInternAtom(display, "WM_DELETE_WINDOW", False);
      istat = XSetWMProtocols(display, cws->window, atm, 1);
+SELF, IF=X11, IF=-WINNT.
/*
 *              Initialise the window structure
 */
      cws->drawing        = cws->window;
      cws->buffer         = (Drawable)NULL;
      cws->double_buffer  = (int)NULL;
      cws->clip           = (int)NULL;
      cws->width          = wval;
      cws->height         = hval;

      return( wid );
}

/*
 *    SUBROUTINE IXRSCWI(WID, W, H)
 *    INTEGER WID  : Window identifier.
 *    INTEGER W    : Width
 *    INTEGER H    : Heigth
 *
 *    Rescale the window WID
 */
void
   ixrscwi(wid, w, h)
  int *wid;
  int *w;
  int *h;
{
  int i;

  tws = &windows[*wid];
  if (!tws->open) return;

  XResizeWindow( display, tws->window, *w, *h );

  if( tws->double_buffer ) {
     XFreePixmap(display,tws->buffer);
     tws->buffer = XCreatePixmap(display, RootWindow( display, screen_number),
                   *w, *h, DefaultDepth(display,screen_number));
     for( i = 0; i < MAXGC; i++ ) XSetClipMask( display, gclist[i], None );
     setcolor( *gcpxmp, 0);
     XFillRectangle( display, tws->buffer, *gcpxmp, 0, 0, *w, *h);
     setcolor( *gcpxmp, 1);
     tws->drawing = tws->buffer;
  }
  tws->width  = *w;
  tws->height = *h;
}

/*
 *    SUBROUTINE IXMOVWI(WID, X, Y)
 *    INTEGER WID  : Window identifier.
 *    INTEGER X    : Width
 *    INTEGER Y    : Heigth
 *
 *    Move the window WID
 */
void
   ixmovwi(wid, x, y)
  int *wid;
  int *x;
  int *y;
{
  int i;

  tws = &windows[*wid];
  if (!tws->open) return;

  XMoveWindow( display, tws->window, *x, *y );
}

void
  ix2bon()
{
  int i;

  if (tws->double_buffer) return;
  tws->buffer = XCreatePixmap(display, RootWindow( display, screen_number),
                tws->width, tws->height, DefaultDepth(display,screen_number));
  for( i = 0; i < MAXGC; i++ ) XSetClipMask( display, gclist[i], None );
  XCopyArea( display, tws->window, tws->buffer,
             *gcpxmp, 0, 0, tws->width, tws->height, 0, 0 );
  tws->double_buffer  = 1;
  tws->drawing        = tws->buffer;
  return;
}

void
  ix2boff()
{
  if (!tws->double_buffer) return;
  XFreePixmap(display,tws->buffer);
  tws->double_buffer = 0;
  tws->drawing       = tws->window;
  return;
}

/*
 *    SUBROUTINE IXS2BUF(WID,MODE)
 *    INTEGER WID  : Window identifier.
 *                   999 means all the opened windows.
 *    INTEGER MODE : 1 double buffer is on
 *                   0 double buffer is off
 *
 *    Set the double buffer on/off on window WID.
 */
void
  ixs2buf( wid, mode )
  int *wid;
  int *mode;
{
  int i;

  if ( *wid == 999 ) {
    for ( i = 0; i < MAXWN; i++ ) {
      tws = &windows[i];
      if (tws->open) {
        switch ( *mode ) {
        case 1 :
           ix2bon();
           break;
        default:
           ix2boff();
           break;
        }
      }
    }
  } else {
    tws = &windows[*wid];
    if (!tws->open) return;
    switch ( *mode ) {
    case 1 :
       ix2bon();
       return;
    default:
       ix2boff();
       return;
    }
  }
}

/*
 *    SUBROUTINE IXQ2BUF(WID)
 *    INTEGER WID  : Window identifier.
 *
 *    Query the double buffer value for the window WID.
 */
int
  ixq2buf( wid )
  int *wid;
{
  tws = &windows[*wid];
  if (!tws->open) {
    return -1;
  } else {
    return tws->double_buffer;
  }
}

/*
 *    INTEGER FUNCTION IXOPNPX(W, H)
 *    INTEGER W,H : Width and height of the pixmap.
 *
 *    Open a new pixmap.
 */
int
  ixopnpx(w, h)
int *w, *h;
{
  Drawable pixtemp;
  Window root;
  unsigned int wval, hval;
  int xx, yy, i ;
  unsigned int ww, hh, border, depth;
  wval = *w;
  hval = *h;

  oldwin = cws->drawing;
  pixtemp = XCreatePixmap(display, RootWindow( display, screen_number),
            wval, hval, DefaultDepth(display,screen_number));
  ispix = 1;
  XGetGeometry( display, pixtemp, &root, &xx, &yy, &ww, &hh, &border, &depth );

  for( i = 0; i < MAXGC; i++ )
    XSetClipMask( display, gclist[i], None );

  setcolor( *gcpxmp, 0);
  XFillRectangle( display, pixtemp, *gcpxmp,0 ,0 ,ww ,hh);
  setcolor( *gcpxmp, 1);

  cws->drawing = pixtemp;
  return ( pixtemp );
}


/*
 *    SUBROUTINE IXCLRPX(PIX)
 *    INTEGER PIX : Pixmap address
 *
 *    Clear the pixmap PIX.
 */
void
  ixclrpx(pix )
Drawable *pix;
{
  Window root;
  int xx, yy;
  unsigned int ww, hh, border, depth;
  XGetGeometry( display, *pix, &root, &xx, &yy, &ww, &hh, &border, &depth );
  setcolor( *gcpxmp, 0);
  XFillRectangle( display, *pix, *gcpxmp,0 ,0 ,ww ,hh);
  setcolor( *gcpxmp, 1);
  XFlush( display );
}


/*
 *    SUBROUTINE IXCLPX
 *
 *    Close the current opened pixmap.
 */
void
  ixclpx()
{
  XFlush( display );
  cws->drawing = oldwin;
  ispix = 0;
}


/*
 *    SUBROUTINE IXCPPX(PIX, XPOS, YPOS)
 *    INTEGER PIX : Pixmap address
 *    INTEGER XPOS, YPOS : Pixmap Position
 *
 *    Copy the pixmap PIX at the position XPOS YPOS.
 */
void
  ixcppx(pix, xpos, ypos)
Drawable *pix;
int *xpos, *ypos;
{
  Window root;
  int xx, yy;
  unsigned int ww, hh, border, depth;
  XGetGeometry( display, *pix, &root, &xx, &yy, &ww, &hh, &border, &depth );
  XCopyArea(display,*pix,cws->drawing,*gcpxmp,0,0,ww,hh,*xpos,*ypos);
  XFlush( display );
}


/*
 *    SUBROUTINE IXWRPX(PIX,W,H,LENNAME,PXNAME)
 *    INTEGER PIX : Pixmap address
 *    INTEGER W,H : Width and height of the pixmap.
 *    INTEGER LENNAME     : pixmap name length
 *    CHARACTER*(*) PXNAME: pixmap name
 *
 *    Write the pixmap IPX in the bitmap file PXNAME.
 */
void
  ixwrpx(pix, w, h, lenname,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
          fcd_pxname )
_fcd fcd_pxname;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
          dsc_pxname )
struct dsc$descriptor_s *dsc_pxname;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
          pxname, lenpxname )
char *pxname;
int lenpxname;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
          pxname )
char *pxname;
+SELF, IF=X11, IF=-WINNT.
Drawable *pix;
int *w, *h;
int *lenname;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *pxname = _fcdtocp( fcd_pxname );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *pxname = dsc_pxname->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.
  unsigned int wval, hval;
  wval = *w;
  hval = *h;
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  XWriteBitmapFile(display,string(pxname,*lenname),*pix,wval,hval,-1,-1);
+SELF, IF=X11, IF=-WINNT.
}


/*
 *    SUBROUTINE IXWIPX(PIX, XPOS, YPOS)
 *    INTEGER PIX : Pixmap address
 *    INTEGER XPOS, YPOS : Position in the current window
 *
 *    Copy the area at the position XPOS YPOS in the current
 *    window in the pixmap PIX. The area copied has the size
 *    of the pixmap PIX.
 */
void
  ixwipx(pix, xpos, ypos )
Drawable *pix;
int *xpos, *ypos;
{
  Window root;
  int xx, yy;
  unsigned int ww, hh, border, depth;
  XGetGeometry( display, *pix, &root, &xx, &yy, &ww, &hh, &border, &depth );
  XCopyArea(display,cws->drawing,*pix,*gcpxmp,*xpos,*ypos,ww,hh,0,0);
  XFlush( display );
}


/*
 *    SUBROUTINE IXRMPX(PIX)
 *    INTEGER PIX : Pixmap adress
 *
 *    Remove the pixmap PIX.
 */
void
  ixrmpx(pix)
Drawable *pix;
{
  XFreePixmap(display,*pix);
}


/*
 *    SUBROUTINE IXCLSDS
 *
 *    Delete all windows and close connection
 */
void
  ixclsds()
{
  int Motif = (int)NULL;
  int i;

  if (display == NULL) return;

  for ( i = 0; i < MAXFONT; i++ ) {
    if ( font[i].id ) {
       XFreeFont ( display, font[i].id);
       font[i].id = NULL;
    }
  }

  for ( i = 0; i < MAXWN; i++ ) {
    windows[i].open = 0;
    if ( windows[i].motif ) Motif = 1;
  }

  for ( i = 0; i < MAXCOL; i++ ) {
    if( colors[i].defined == 1 ) {
      colors[i].defined = 0;
      XFreeColors(display, colormap, &colors[i].pixel, 1, (int)NULL);
    }
  }

+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  if(display != NULL && Motif == (int)NULL) XCloseDisplay( display );
+SELF, IF=X11, IF=-WINNT.
  display = NULL;
  cws     = NULL;
  tws     = NULL;
  isdisp  = 0;
}


/*
 *    SUBROUTINE IXCLSWI
 *
 *    Delete current window
 */
void
  ixclswi()
{
  int wid;

  XDestroyWindow( display, cws->window );

  if( cws->double_buffer ) XFreePixmap( display, cws->buffer);

  if (cws->motif && motif_close != NULL) {
      for( wid = 0; wid < MAXWN; wid++ ) {
           if (cws->motif_window == windows[wid].motif_window) {
               (*motif_close) (wid+1);
               break; }
      }
  }

  XFlush( display );

  cws->open = (int)NULL;

  for( wid = 0; wid < MAXWN; wid++ )
    if( windows[wid].open ) {
      cws = &windows[wid];
      return;
    }

+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  ixclsds(); /* no open window left */
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
  IXCLSDS(); /* no open window left */
+SELF, IF=X11, IF=-WINNT.
}


/*
 *    SUBROUTINE IXSELWI(WID)
 *    INTEGER WID : window number returned by IXOPNWI
 *
 *    Select window to which subsequent output is directed
 */
void
  ixselwi( wid )
int *wid;
{
  XRectangle region;
  int i;

  if( *wid < 0 || *wid >= MAXWN || !windows[*wid].open ) return;

  cws = &windows[*wid];

 if ( cws->clip && !ispix && !cws->double_buffer ) {
    region.x      = cws->xclip;
    region.y      = cws->yclip;
    region.width  = cws->wclip;
    region.height = cws->hclip;
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
    for( i = 0; i < MAXGC; i++ )
      XSetClipRectangles( display, gclist[i], 0, 0, &region, 1, YXBanded );
+SELF, IF=X11, IF=-WINNT.
  } else {
    for( i = 0; i < MAXGC; i++ )
      XSetClipMask( display, gclist[i], None );
  }
}


/*
 *    SUBROUTINE IXSAVWI
 *
 *    Save the adress of the current active window
 */
void
  ixsavwi()
{
  sws = cws;
}


/*
 *    SUBROUTINE IXSETWI
 *
 *    Restore the adress of the saved window
 */
void
  ixsetwi()
{
  cws = sws;
}


/*
 *    SUBROUTINE IXGETGE(WID,X,Y,W,H)
 *    INTEGER WID : window identifier
 *    INTEGER X,Y : window position (output)
 *    INTEGER W,H : window size (output)
 *
 *    Return position and size of window wid
 *    if wid < 0 the size of the display is returned
 */
void
   ixgetge( wid, x, y, w, h )
int *wid;
int *x, *y;
unsigned int *w, *h;
{
  Window temp_win;
  if( *wid < 0 ) {
    *x = 0;
    *y = 0;
    *w = DisplayWidth(display,screen_number);
    *h = DisplayHeight(display,screen_number);
  } else {
    Window root;
    unsigned int border, depth;
    unsigned int width, height;

    tws = &windows[*wid];
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
    XGetGeometry(display, tws->window, &root, x, y,
                 &width, &height, &border, &depth);
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
    XGetGeometry(display, tws->drawing, &root, x, y,
                 &width, &height, &border, &depth);
    (void) XTranslateCoordinates (display, tws->window,
                                 RootWindow( display, screen_number),
                                   0, 0, x, y, &temp_win);
+SELF, IF=X11, IF=-WINNT.
    if( width > 0 && height > 0 ) {
      tws->width  = width;
      tws->height = height;
    }
    if( width > 1 && height > 1 ) {
      *w=tws->width-1;
      *h=tws->height-1;
    } else {
      *w=1;
      *h=1;
    }
  }
}


/*
 *    SUBROUTINE IXGETPL(NPLANES)
 *    INTEGER NPLANES     : number of bit planes
 *
 *    Get maximum number of planes
 */
void
   ixgetpl(nplanes)
int *nplanes;
{
   *nplanes = DisplayPlanes( display, screen_number );
}


/*
 *    SUBROUTINE IXRSIZ(WID)
 *    INTEGER WID     : window to be resized
 *
 *    Resize the current window if necessary
 */
void
   ixrsiz(wid)
int *wid;
{
  int i;
  int xval, yval;
  Window root;
  unsigned int wval, hval, border, depth;

  tws = &windows[*wid];

  if( !tws->motif ) return;

  XGetGeometry( display, tws->motif_window, &root,
                &xval, &yval, &wval, &hval, &border, &depth );
  XResizeWindow( display, tws->window, wval, hval );

  if( tws->double_buffer ) {
     XFreePixmap(display,tws->buffer);
     tws->buffer = XCreatePixmap(display, RootWindow( display, screen_number),
                   wval, hval, DefaultDepth(display,screen_number));
     for( i = 0; i < MAXGC; i++ ) XSetClipMask( display, gclist[i], None );
     setcolor( *gcpxmp, 0);
     XFillRectangle( display, tws->buffer, *gcpxmp, 0, 0, wval, hval);
     setcolor( *gcpxmp, 1);
     tws->drawing        = tws->buffer;
  }
  tws->width = wval;
  tws->height = hval;
}


/*
 *    SUBROUTINE IXGETHT(IL,CHHOST)
 *    INTEGER IL           : host name length (output)
 *    CHARACTER*(*) CHHOST : host name (output)
 *
 *    Return the host name given with IGWKTY.
 */
void
   ixgetht (il, chhost)
   int *il;
   char *chhost; /* host name */
{
   *il = strlen (hname);
   strcpy (chhost, hname);
}


/*
 *    SUBROUTINE IXGETWI(WKID,IDG)
 *    INTEGER WKID : Workstation identifier (input)
 *    INTEGER IDG  : Window identifier (output)
 *
 *    Return the X11 window identifier according to the
 *    Window id returned by IXOPNWI.
 */
void
   ixgetwi (wkid, idg)
   int *wkid;
   Window *idg;
{
   *idg = windows[*wkid].window;
}


/*
 *    SUBROUTINE IXCLRWI
 *
 *    Clear current window
 */
void
  ixclrwi()
{

  if ( !ispix && !cws->double_buffer ) {
     XSetWindowBackground( display, cws->drawing, colors[0].pixel );
     XClearWindow( display, cws->drawing );
  } else {
     setcolor( *gcpxmp, 0);
     XFillRectangle( display, cws->drawing, *gcpxmp,
                     0, 0, cws->width, cws->height );
     setcolor( *gcpxmp, 1);
  }
  do_raise = 1;
  XFlush( display );
}


/*
 *    SUBROUTINE IXUPDWI(MODE)
 *    INTEGER MODE : (1) or (11) The window is raised
 *                   (0) or (10) The window is not raised
 *                   (0) or (1)  no synchonisation between client and server
 *                  (10) or (11) synchonisation between client and server
 *
 *    Update display and raise current window to top of stack.
 *    Synchronise client and server once (not permanent).
 *    Copy the pixmap cws->buffer on the window cws-> window
 *    if the double buffer is on.
 */
void
  ixupdwi(mode)
  int *mode;
{
  if ( *mode == 1 || *mode == 11 ) {
     if ( do_raise ) {
        XRaiseWindow( display, cws->window );
        do_raise = 0;
     }
  }
  if ( cws->double_buffer ) {
     XCopyArea( display, cws->drawing, cws->window,
                *gcpxmp, 0, 0, cws->width, cws->height, 0, 0 );
  }
  if ( *mode == 0 || *mode == 1 ) {
    XFlush( display );
  } else {
    XSync( display ,0);
  }
}


/*
 *    SUBROUTINE IXCLIP(WID,X,Y,W,H)
 *    INTEGER WID : Window indentifier
 *    INTEGER X,Y : origin of clipping rectangle
 *    INTEGER W,H : size of clipping rectangle;
 *
 *    Set clipping region for the window wid
 */
void
  ixclip( wid, x, y, w, h )
int *wid;
int *x, *y;
int *w, *h;
{
  XRectangle region;
  int i;

  tws = &windows[*wid];
  tws->xclip = *x;
  tws->yclip = *y;
  tws->wclip = *w;
  tws->hclip = *h;
  tws->clip  = 1;
  if ( cws->clip && !ispix && !cws->double_buffer ) {
    region.x      = cws->xclip;
    region.y      = cws->yclip;
    region.width  = cws->wclip;
    region.height = cws->hclip;
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
    for( i = 0; i < MAXGC; i++ )
      XSetClipRectangles( display, gclist[i], 0, 0, &region, 1, YXBanded );
+SELF, IF=X11, IF=-WINNT.
  }
}


/*
 *    SUBROUTINE IXNOCLI(WID)
 *    INTEGER WID : Window indentifier
 *
 *    Switch off the clipping for the window wid
 */
void
  ixnocli(wid)
int *wid;
{
  int i;

  tws       = &windows[*wid];
  tws->clip = (int)NULL;

  for( i = 0; i < MAXGC; i++ )
    XSetClipMask( display, gclist[i], None );
}


/*
 *    SUBROUTINE IXSETCO(CINDEX,R,G,B)
 *    INTEGER CINDEX : color index
 *    REAL R,G,B     : red, green, blue intensities between 0.0 and 1.0
 *
 *    Set color intensities for given color index
 */
#define BIGGEST_RGB_VALUE 65535

void
  ixsetco( cindex, r, g, b )
int *cindex;
float *r, *g, *b;
{
  XColor xcol;

  if( colored && *cindex >= 0 && *cindex < MAXCOL ) {
    xcol.red   = (unsigned short)( *r * BIGGEST_RGB_VALUE );
    xcol.green = (unsigned short)( *g * BIGGEST_RGB_VALUE );
    xcol.blue  = (unsigned short)( *b * BIGGEST_RGB_VALUE );
    xcol.flags = DoRed || DoGreen || DoBlue;
    if( colors[*cindex].defined == 1 ) {
      colors[*cindex].defined = 0;
      XFreeColors(display, colormap, &colors[*cindex].pixel, 1, (int)NULL);
    }
    if( XAllocColor( display, colormap, &xcol ) != (Status)NULL ) {
      colors[*cindex].defined = 1;
      colors[*cindex].pixel   = xcol.pixel;
      colors[*cindex].red     = *r;
      colors[*cindex].green   = *g;
      colors[*cindex].blue    = *b;
    }
  }
}


void
  ixgetcol( index, r, g, b )
int index; /* input */
float *r, *g, *b; /* output */
{
  *r = colors[index].red;
  *g = colors[index].green;
  *b = colors[index].blue;
  return ;
}


/*
 *    SUBROUTINE IXSETLN(WIDTH)
 *    INTEGER WIDTH : line width in pixels
 *
 *    Set line width
 */
void
  ixsetln( width )
int *width;
{
  if( *width == 1) {
     line_width = 0;
  }
  else {
     line_width = *width;
  }
  XSetLineAttributes( display, *gcline, line_width,
              line_style, cap_style, join_style );
  XSetLineAttributes( display, *gcdash, line_width,
              line_style, cap_style, join_style );
}


/*
 *    SUBROUTINE IXSETLS(N,DASH)
 *    INTEGER N       : length of dash list
 *    INTEGER DASH(N) : dash segment lengths
 *
 *    Set line style:
 *    if N.LE.0 use solid lines
 *    if N.GT.0 use dashed lines described by DASH(N)
 *    e.g. N=4,DASH=(6,3,1,3) gives a dashed-dotted line with dash length 6
 *    and a gap of 7 between dashes
 */
void
  ixsetls( n, dash )
int *n;
int *dash;
{
  if( *n <= 0 ) {
    line_style = LineSolid;
    XSetLineAttributes( display, *gcline, line_width,
              line_style, cap_style, join_style );
  }
  else {
    int i, j;
    dash_length = 0;
    for( i = 0, j = 0; i < sizeof( dash_list ); i++ ) {
      dash_list[i] = dash[j];
      dash_length += dash_list[i];
      if( ++j >= *n ) j = 0;
    }
    dash_offset = 0;
    line_style = LineOnOffDash;
    XSetLineAttributes( display, *gcdash, line_width,
              line_style, cap_style, join_style );
  }
}


/*
 *    SUBROUTINE IXSETLC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCO
 *
 *    Set color index for lines
 */
void
  ixsetlc( cindex )
int *cindex;
{
  setcolor( *gcline, *cindex );
  setcolor( *gcdash, *cindex );
}


/*
 *    SUBROUTINE IXLINE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Draw a line through all points
 */
void
  ixline( n, xy )
int *n;
XPoint *xy;
{
 if ( *n > 1 )
    {
       if( line_style == LineSolid )
         XDrawLines( display, cws->drawing, *gcline, xy, *n, CoordModeOrigin );
       else {
         int i;
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
         XSetDashes( display, *gcdash,
             dash_offset, dash_list, sizeof( dash_list ) );
+SELF, IF=X11, IF=-WINNT.
         XDrawLines( display, cws->drawing, *gcdash, xy, *n, CoordModeOrigin );

         /* calculate length of line to update dash offset */
         for( i = 1; i < *n; i++ ) {
         int dx = xy[i].x - xy[i-1].x;
         int dy = xy[i].y - xy[i-1].y;
         if( dx < 0 ) dx = - dx;
         if( dy < 0 ) dy = - dy;
         dash_offset += dx > dy ? dx : dy;
         }
         dash_offset %= dash_length;
       }
    }
 else
    {
     int px,py;
     px=xy[0].x;
     py=xy[0].y;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
     XDrawPoints(display, cws->drawing,
        line_style == LineSolid ? *gcline : *gcdash,
        xy, *n, CoordModeOrigin );
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
     XDrawPoint(display, cws->drawing,
        line_style == LineSolid ? *gcline : *gcdash, px, py);
+SELF, IF=X11, IF=-WINNT.
    }
  do_raise = 1;
}


/*
 *    SUBROUTINE IXSETMS(TYPE,N,XY)
 *    INTEGER TYPE      : marker type
 *    INTEGER N         : length of marker description
 *    INTEGER*2 XY(2,N) : list of points describing marker shape
 *
 *    Set marker style:
 *    if N.EQ.0 marker is a single point
 *    if TYPE.EQ.0 marker is hollow circle of diameter N
 *    if TYPE.EQ.1 marker is filled circle of diameter N
 *    if TYPE.EQ.2 marker is a hollow polygon describe by line XY
 *    if TYPE.EQ.3 marker is a filled polygon describe by line XY
 *    if TYPE.EQ.4 marker is described by segmented line XY
 *    e.g. TYPE=4,N=4,XY=(-3,0,3,0,0,-3,0,3) sets a plus shape of 7x7 pixels
 */
void
  ixsetms( type, n, xy )
int *type;
int *n;
XPoint *xy;
{
  int i;

  marker.type = *type;
  marker.n = *n < MAXMK ? *n : MAXMK;
  if( marker.type >= 2 )
    for( i = 0; i < marker.n; i++ )
      marker.xy[i] = xy[i];
}


/*
 *    SUBROUTINE IXSETMC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCO
 *
 *    Set color index for markers
 */
void
  ixsetmc( cindex )
int *cindex;
{
  setcolor( *gcmark, *cindex );
}


/*
 *    SUBROUTINE IXMARKE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Draw a marker at each point
 */
void
   ixmarke( n, xy )
int *n;
XPoint *xy;
{
  do_raise = 1;
  if( marker.n <= 0 )
    XDrawPoints( display, cws->drawing, *gcmark, xy, *n, CoordModeOrigin );
  else {
    int r = marker.n / 2;
    int m;

    for( m = 0; m < *n; m++ ) {
      int hollow = 0;

      switch( marker.type ) {
      int i;

      case 0:        /* hollow circle */
      XDrawArc( display, cws->drawing, *gcmark,
          xy[m].x - r, xy[m].y - r, marker.n, marker.n, 0, 360 * 64 );
      break;

      case 1:        /* filled circle */
      XFillArc( display, cws->drawing, *gcmark,
          xy[m].x - r, xy[m].y - r, marker.n, marker.n, 0, 360 * 64 );
      break;

      case 2:        /* hollow polygon */
      hollow = 1;
      case 3:        /* filled polygon */
      for( i = 0; i < marker.n; i++ ) {
        marker.xy[i].x += xy[m].x;
        marker.xy[i].y += xy[m].y;
      }
      if( hollow )
        XDrawLines( display, cws->drawing, *gcmark,
              marker.xy, marker.n, CoordModeOrigin );
      else
        XFillPolygon( display, cws->drawing, *gcmark,
                marker.xy, marker.n, Nonconvex, CoordModeOrigin );
      for( i = 0; i < marker.n; i++ ) {
        marker.xy[i].x -= xy[m].x;
        marker.xy[i].y -= xy[m].y;
      }
      break;

      case 4:        /* segmented line */
      for( i = 0; i < marker.n; i += 2 )
        XDrawLine( display, cws->drawing, *gcmark,
             xy[m].x + marker.xy[i].x, xy[m].y + marker.xy[i].y,
             xy[m].x + marker.xy[i+1].x, xy[m].y + marker.xy[i+1].y );
      break;
      }
    }
  }
}


/*
 *    SUBROUTINE IXSETFS(STYLE,FASI)
 *    INTEGER STYLE : fill area interior style hollow or solid
 *
 *    Set fill area style
 */
void
  ixsetfs( style, fasi )
int *style;
int *fasi;
{

  switch( *style ) {

  case 1:         /* solid */
    fill_hollow = 0;
    XSetFillStyle( display, *gcfill, FillSolid );
    break;

  case 2:         /* pattern */
    fill_hollow = 1;
    break;

  case 3:         /* hatch */
    fill_hollow = 0;
    XSetFillStyle( display, *gcfill, FillStippled );
    if( *fasi != current_fasi ) {
      if( fill_pattern != (Pixmap)NULL ) {
        XFreePixmap( display, fill_pattern );
        fill_pattern = (Pixmap)NULL;
      }
      switch( *fasi ) {
        case 1: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p1_bits, 16, 16);
                break;
        case 2: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p2_bits, 16, 16);
                break;
        case 3: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p3_bits, 16, 16);
                break;
        case 4: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p4_bits, 16, 16);
                break;
        case 5: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p5_bits, 16, 16);
                break;
        case 6: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p6_bits, 16, 16);
                break;
        case 7: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p7_bits, 16, 16);
                break;
        case 8: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p8_bits, 16, 16);
                break;
        case 9: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p9_bits, 16, 16);
                break;
        case 10:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p10_bits, 16, 16);
                break;
        case 11:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p11_bits, 16, 16);
                break;
        case 12:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p12_bits, 16, 16);
                break;
        case 13:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p13_bits, 16, 16);
                break;
        case 14:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p14_bits, 16, 16);
                break;
        case 15:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p15_bits, 16, 16);
                break;
        case 16:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p16_bits, 16, 16);
                break;
        case 17:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p17_bits, 16, 16);
                break;
        case 18:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p18_bits, 16, 16);
                break;
        case 19:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p19_bits, 16, 16);
                break;
        case 20:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p20_bits, 16, 16);
                break;
        case 21:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p21_bits, 16, 16);
                break;
        case 22:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p22_bits, 16, 16);
                break;
        case 23:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p23_bits, 16, 16);
                break;
        case 24:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p24_bits, 16, 16);
                break;
        case 25:fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p25_bits, 16, 16);
                break;
       default: fill_pattern = XCreateBitmapFromData(display,
                RootWindow( display, screen_number), p2_bits, 16, 16);
                break;
      }
      XSetStipple( display, *gcfill, fill_pattern );
      current_fasi = *fasi;
    }
    break;

  default:
    fill_hollow = 1;
  }
}


/*
 *    SUBROUTINE IXSETFC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCO
 *
 *    Set color index for fill areas
 */
void
  ixsetfc( cindex )
int *cindex;
{
  setcolor( *gcfill, *cindex );

  /* invalidate fill pattern */
  if( fill_pattern != (Pixmap)NULL ) {
    XFreePixmap( display, fill_pattern );
    fill_pattern = (Pixmap)NULL;
  }
}


/*
 *    SUBROUTINE IXFLARE(N,XY)
 *    INTEGER N         : number of points
 *    INTEGER*2 XY(2,N) : list of points
 *
 *    Fill area described by polygon
 */
void
  ixflare( n, xy )
int *n;
XPoint *xy;
{
  if( fill_hollow )
    XDrawLines( display, cws->drawing, *gcfill, xy, *n, CoordModeOrigin );

  else {
    XFillPolygon( display, cws->drawing, *gcfill,
                  xy, *n, Nonconvex, CoordModeOrigin );
  }
  do_raise = 1;
}


/*
 *    SUBROUTINE IXSETTA(TXALH,TXALV)
 *    INTEGER TXALH : horizontal text alignment
 *    INTEGER TXALV : vertical text alignment
 */
void
  ixsetta( txalh, txalv )
int *txalh;
int *txalv;
{
  switch ( *txalh ) {

  case 0 :
  case 1 : switch ( *txalv) {
           case 0 : text_align = 7;
                    break;
           case 1 :
           case 2 : text_align = 1;
                    break;
           case 3 : text_align = 4;
                    break;
           }
           break;
  case 2 : switch ( *txalv) {
           case 0 : text_align = 8;
                    break;
           case 1 :
           case 2 : text_align = 2;
                    break;
           case 3 : text_align = 5;
                    break;
           }
           break;
  case 3 : switch ( *txalv) {
           case 0 : text_align = 9;
                    break;
           case 1 :
           case 2 : text_align = 3;
                    break;
           case 3 : text_align = 6;
                    break;
           }
           break;
  }
}


/*
 *    FUNCTION IXSETTF(MODE,LENFNT,FONTNAME)
 *    INTEGER MODE       : loading flag
 *            MODE=0     : search if the font exist
 *            MODE=1     : search the font and load it if it exist
 *    INTEGER LENFNT     : font name length
 *    CHARACTER*(*) FONT : font name
 *
 *    Set text font to specified name. This function returns 0 if
 *    the specified font is found, 1 if not.
 */
int
  ixsettf( mode, lenfnt,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
           fcd_fontname )
_fcd fcd_fontname;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
           dsc_fontname )
struct dsc$descriptor_s *dsc_fontname;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
           fontname, lenfontname )
char *fontname;
int lenfontname;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
           fontname )
char *fontname;
+SELF, IF=X11, IF=-WINNT.
int *mode;
int *lenfnt;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *fontname = _fcdtocp( fcd_fontname );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *fontname = dsc_fontname->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.
  char **fontlist;
  int fontcount;
  int i;

  if ( *mode != 0 ) {
     for ( i = 0; i < MAXFONT; i++ ) {
        if (strcmp(string( fontname, *lenfnt ), font[i].name) == 0) {
           text_font = font[i].id;
           XSetFont( display, *gctext, text_font->fid);
           XSetFont( display, *gcinvt, text_font->fid);
           return(0);
        }
     }
  }

+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  fontlist = XListFonts( display, string( fontname, *lenfnt ), 1, &fontcount);
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
  fontcount =0;
+SELF, IF=X11, IF=-WINNT.

  if ( fontcount != 0 ) {
     if ( *mode != 0 ) {
        if ( font[current_font_number].id )
           XFreeFont ( display, font[current_font_number].id);
        font[current_font_number].id = XLoadQueryFont( display, fontlist[0]);
	text_font = font[current_font_number].id;
        XSetFont( display, *gctext, text_font->fid);
        XSetFont( display, *gcinvt, text_font->fid);
        strcpy (font[current_font_number].name,string( fontname, *lenfnt ));
        current_font_number++;
        if ( current_font_number == MAXFONT ) current_font_number = 0;
     }
     XFreeFontNames(fontlist);
     return(0);
  }
  else {
     return(1);
  }
}


/*
 *    SUBROUTINE IXSETTC(CINDEX)
 *    INTEGER CINDEX : color index defined my IXSETCO
 *
 *    Set color index for text
 */
void
  ixsettc( cindex )
int *cindex;
{
  setcolor( *gctext, *cindex );

+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  if ( XGetGCValues( display, *gctext, gc_mask, &gc_return) ) {
     XSetForeground( display, *gcinvt, gc_return.background );
     XSetBackground( display, *gcinvt, gc_return.foreground );
  } else {
     printf("**** Error: Cannot get GC values \n");
  }
+SELF, IF=X11, IF=-WINNT.
  XSetBackground( display, *gctext, colors[0].pixel );
}


/*
 *    SUBROUTINE IXTEXT(MODE,X,Y,ANGLE,MGN,LENTXT,TEXT)
 *    INTEGER MODE       : drawing mode
 *            MODE=0     : the background is not drawn
 *            MODE=1     : the background is drawn
 *    INTEGER X,Y        : text position
 *    REAL    ANGLE      : text angle
 *    REAL    MGN        : magnification factor
 *    INTEGER LENTXT     : text length
 *    CHARACTER*(*) TEXT : text string
 *
 *    Draw a text string using current font
 */
void
  ixtext( mode, x, y, angle, mgn, lentxt,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
       fcd_text )
_fcd fcd_text;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
       dsc_text )
struct dsc$descriptor_s *dsc_text;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
       text, lentext )
char *text;
int lentext;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
       text )
char *text;
+SELF, IF=X11, IF=-WINNT.
int *mode;
int *x, *y;
float *angle;
float *mgn;
int *lentxt;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *text = _fcdtocp( fcd_text );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *text = dsc_text->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.

+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
  XRotSetMagnification(*mgn);

  switch ( *mode ) {

  case 0 : XRotDrawAlignedString( display, text_font, *angle,
           cws->drawing, *gctext, *x, *y, string(text,*lentxt), text_align );
           break;

  case 1 : XRotDrawAlignedImageString( display, text_font, *angle,
           cws->drawing, *gctext, *x, *y, string(text,*lentxt), text_align );
           break;

  default: break;
  }
  do_raise = 1;
+SELF, IF=X11, IF=-WINNT.
}


/*
 *    SUBROUTINE IXTXTL(IW,IH,LMESS,MESS)
 *    INTEGER IW          : text width
 *    INTEGER IH          : text height
 *    INTEGER LMES        : message length
 *    CHARACTER*(*) MESS  : message
 *
 *    Return the size of a character string
 */
void
  ixtxtl( w, h, lmess,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
       fcd_mess )
_fcd fcd_mess;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
       dsc_mess )
struct dsc$descriptor_s *dsc_mess;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
       mess, lenmess )
char *mess;
int lenmess;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
       mess )
char *mess;
+SELF, IF=X11, IF=-WINNT.
int *lmess;
int *w;
int *h;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *mess = _fcdtocp( fcd_mess );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *mess = dsc_mess->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.
   *w = XTextWidth( text_font, mess, *lmess );
   *h = text_font->ascent;
}


/*
 *    SUBROUTINE IXBOX(X1,X2,Y1,Y2,MODE)
 *    INTEGER X1,Y1 : left down corner
 *    INTEGER X2,Y2 : right up corner
 *    INTEGER MODE : drawing mode
 *
 *            MODE=0 hollow
 *            MODE=1 solid
 *
 *    Draw a box
 */
void
  ixbox( x1, x2, y1, y2, mode)
int *x1, *x2, *y1, *y2;
int *mode;
{
     switch ( *mode ) {

     case 0 : XDrawRectangle( display, cws->drawing, *gcline,
                              min(*x1,*x2), min(*y1,*y2),
                              abs(*x2-*x1), abs(*y2-*y1));
              break;

     case 1 : XFillRectangle( display, cws->drawing, *gcfill,
                              min(*x1,*x2), min(*y1,*y2),
                              abs(*x2-*x1), abs(*y2-*y1));
              break;

     default: break;
     }
  do_raise = 1;
}


/*
 *    SUBROUTINE IXCA(X1,X2,Y1,Y2,NX,NY,IC)
 *    INTEGER X1,Y1 : left down corner
 *    INTEGER X2,Y2 : right up corner
 *    INTEGER NX,NY : array size
 *    INTEGER IC : array
 *
 *    Draw a cell array. The drawing is done with the pixel presicion
 *    if (X2-X1)/NX (or Y) is not a exact pixel number the position of
 *    the top rigth corner may be wrong.
 */
void
  ixca(x1, x2, y1, y2, nx, ny, ic)
int *x1, *x2, *y1, *y2, *nx, *ny;
int ic[];
{
   int i,j,icol,ix,iy,w,h,current_icol;

   current_icol = -1;
   w            = max((*x2-*x1)/(*nx),1);
   h            = max((*y1-*y2)/(*ny),1);
   ix           = *x1;

   for ( i=0; i<*nx; i++ ) {
      iy = *y1-h;
      for ( j=0; j<*ny; j++ ) {
         icol = ic[i+(*nx*j)];
         if(icol != current_icol){
            XSetForeground( display, *gcfill, colors[icol].pixel );
            current_icol = icol;
         }
         XFillRectangle( display, cws->drawing, *gcfill, ix, iy, w, h);
         iy = iy-h;
      }
      ix = ix+w;
   }
}


/*
 *    SUBROUTINE IXDRMDE(MODE)
 *    INTEGER MODE : drawing mode
 *
 *            MODE=1 copy
 *            MODE=2 xor
 *            MODE=3 invert
 *            MODE=4 set the suitable mode for cursor echo accordinf to
 *                   the vendor.
 *
 *    Set the drawing mode
 */
void
  ixdrmde( mode )
  int *mode;
{
  int i;
  switch ( *mode ) {

     case 1 :
     for ( i = 0; i < MAXGC; i++ ) XSetFunction( display, gclist[i], GXcopy);
     break;

     case 2 :
     for ( i = 0; i < MAXGC; i++ ) XSetFunction( display, gclist[i], GXxor);
     break;

     case 3 :
     for ( i = 0; i < MAXGC; i++ ) XSetFunction( display, gclist[i], GXinvert);
     break;

     case 4 :
     if(strstr(vendor,"Hewlett")) {
      for ( i = 0; i < MAXGC; i++ ) XSetFunction( display, gclist[i], GXinvert);
     } else {
      for ( i = 0; i < MAXGC; i++ ) XSetFunction( display, gclist[i], GXxor);
     }
     break;

     default: break;
  }
}


/*
 *    SUBROUTINE IXSYNC(MODE)
 *    INTEGER MODE : synchronisation on/off
 *
 *            MODE=1 on
 *            MODE<>0 off
 *
 *    Set synchronisation on or off
 */
void
  ixsync( mode )
  int *mode;
{
  switch ( *mode ) {

     case 1 :
     XSynchronize(display,1);
     break;

     default:
     XSynchronize(display,0);
     break;
  }
}


/*
 *    SUBROUTINE IXQPTR(IX,IY)
 *
 *    Output parameters:
 *
 *    INTEGER IX : X coordinate of pointer
 *    INTEGER IY : Y coordinate of pointer
 *    (both coordinates are relative to the origin of the root window)
 */
void ixqptr( ix, iy )
int *ix,*iy;
{
   Window idg;

   Window    root_return,child_return;
   int       win_x_return,win_y_return;
   int       root_x_return,root_y_return;
   unsigned int mask_return;

   XQueryPointer(display,cws->window,&root_return,
   &child_return,&root_x_return,&root_y_return,&win_x_return,
   &win_y_return,&mask_return);

   *ix = (int)root_x_return;
   *iy = (int)root_y_return;

}


/*
 *    SUBROUTINE IXWARP(IX,IY)
 *
 *    Input parameters:
 *
 *    INTEGER IX : New X coordinate of pointer
 *    INTEGER IY : New Y coordinate of pointer
 *    (both coordinates are relative to the origin of the current window)
 */
void ixwarp( ix, iy )
int *ix,*iy;
{
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
   XWarpPointer(display,0,cws->window,0,0,0,0,*ix,*iy);
+SELF, IF=X11, IF=-WINNT.
}


/*
 *    INTEGER FUNCTION IXREQLO(MODE,CTYP,X,Y)
 *    INTEGER X,Y : cursor position out moment of button press (output)
 *    INTEGER CTYP : cursor type (input)
 *
 *            CTYP=1 tracking cross
 *            CTYP=2 cross-hair
 *            CTYP=3 rubber circle
 *            CTYP=4 rubber band
 *            CTYP=5 rubber rectangle
 *
 *    INTEGER MODE : input mode
 *
 *            MODE=0 request
 *            MODE=1 sample
 *
 *    Request locator:
 *    return button number  1 = left is pressed
 *                          2 = middle is pressed
 *                          3 = right is pressed
 *         in sample mode:
 *                         11 = left is released
 *                         12 = middle is released
 *                         13 = right is released
 *                         -1 = nothing is pressed or released
 *                         -2 = leave the window
 *                       else = keycode (keyboard is pressed)
 */
int
  ixreqlo( mode, ctyp, x, y )
int *mode, *ctyp, *x, *y;
{
  static Cursor cursor = (Cursor)LNULL;
  XEvent event;
  int button_press;
  int radius;

  setinput(1);

/*
 *   Change the cursor shape
 */
  if( cursor == (Cursor)NULL ) {
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
     XDefineCursor( display, cws->window, null_cursor );
     XSetForeground( display, gcecho, colors[0].pixel );
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
     if( *ctyp > 1 ) {
        XDefineCursor( display, cws->window, null_cursor );
        XSetForeground( display, gcecho, colors[0].pixel );
     } else {
        cursor = XCreateFontCursor( display, XC_crosshair );
        XDefineCursor( display, cws->window, cursor );
     }
+SELF, IF=X11, IF=-WINNT.
  }

/*
 *   Event loop
 */
  button_press = 0;

  while ( button_press == 0 ) {

     switch ( *ctyp ) {

     case 1 : break;

     case 2 : XDrawLine( display, cws->window, gcecho,
                         xloc, 0, xloc, cws->height);
              XDrawLine( display, cws->window, gcecho,
                         0, yloc, cws->width, yloc);
              break;

     case 3 : radius = (int) sqrt((double)((xloc-xlocp)*(xloc-xlocp)+
                                           (yloc-ylocp)*(yloc-ylocp)));
              XDrawArc( display, cws->window, gcecho,
                        xlocp-radius, ylocp-radius,
                        2*radius, 2*radius, 0, 23040);

     case 4 : XDrawLine( display, cws->window, gcecho,
                         xlocp, ylocp, xloc, yloc);
              break;

     case 5 : XDrawRectangle( display, cws->window, gcecho,
                              min(xlocp,xloc), min(ylocp,yloc),
                              abs(xloc-xlocp), abs(yloc-ylocp));
              break;

     default: break;
     }

     while ( XEventsQueued( display, QueuedAlready) > 1) {
        XNextEvent( display, &event);
     }
     XWindowEvent( display, cws->window, mouse_mask, &event );

     switch ( *ctyp ) {

     case 1 : break;

     case 2 : XDrawLine( display, cws->window, gcecho,
                         xloc, 0, xloc, cws->height);
              XDrawLine( display, cws->window, gcecho,
                         0, yloc, cws->width, yloc);
              break;

     case 3 : radius = (int) sqrt((double)((xloc-xlocp)*(xloc-xlocp)+
                                           (yloc-ylocp)*(yloc-ylocp)));
              XDrawArc( display, cws->window, gcecho,
                        xlocp-radius, ylocp-radius,
                        2*radius, 2*radius, 0, 23040);

     case 4 : XDrawLine( display, cws->window, gcecho,
                         xlocp, ylocp, xloc, yloc);
              break;

     case 5 : XDrawRectangle( display, cws->window, gcecho,
                              min(xlocp,xloc), min(ylocp,yloc),
                              abs(xloc-xlocp), abs(yloc-ylocp));
              break;

     default: break;
     }

     xloc = event.xbutton.x;
     yloc = event.xbutton.y;

     switch ( event.type ) {

     case LeaveNotify :
           if( *mode == 0 ) {
              forever {
                 XNextEvent( display, &event);
                 if( event.type == EnterNotify ) break;
              }
           } else {
              button_press = -2;
           }
           break;

     case ButtonPress :
          button_press =  event.xbutton.button ;
          xlocp = event.xbutton.x;
          ylocp = event.xbutton.y;
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
          XUndefineCursor( display, cws->window );
+SELF, IF=X11, IF=-WINNT.
          cursor = (Cursor)NULL;
          break;

     case ButtonRelease :
           if( *mode == 1 ) {
              button_press =  10+event.xbutton.button ;
              xlocp = event.xbutton.x;
              ylocp = event.xbutton.y;
           }
          break;

     case KeyPress :
           if( *mode == 1 ) {
              button_press =  event.xkey.keycode;
              xlocp = event.xbutton.x;
              ylocp = event.xbutton.y;
           }
          break;

     case KeyRelease :
           if( *mode == 1 ) {
              button_press =  -event.xkey.keycode;
              xlocp = event.xbutton.x;
              ylocp = event.xbutton.y;
           }
          break;

     default : break;
     }

     if( *mode == 1 ) {
         if( button_press == 0 )
            button_press = -1;
         break;
     }
  }
  *x = event.xbutton.x;
  *y = event.xbutton.y;
  setinput(0);
  XFlush( display );
  return( button_press );
}


/*
 *    INTEGER FUNCTION IXREQST(X,Y,LEN,TEXT)
 *    INTEGER X,Y        : position where text is displayed
 *    INTEGER LEN        : text length
 *    CHARACTER*(*) TEXT : text displayed (input), edited text (output)
 *
 *    Request string:
 *    text is displayed and can be edited with Emacs-like keybinding
 *    return termination code (0 for ESC, 1 for RETURN)
 */
int
  ixreqst( x, y, len_text,
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
         fcd_text )
_fcd fcd_text;
+SELF, IF=X11, IF=-WINNT, IF=VAX.
         dsc_text )
struct dsc$descriptor_s *dsc_text;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
         text, lentext )
char *text;
int lentext;
+SELF, IF=X11, IF=-WINNT, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
         text )
char *text;
+SELF, IF=X11, IF=-WINNT.
int *len_text;
int *x, *y;
{
+SELF, IF=X11, IF=-WINNT, IF=CRAY.
  char *text = _fcdtocp( fcd_text );
+SELF, IF=X11, IF=-WINNT, IF=VAX.
  char *text = dsc_text->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT.
  static Cursor cursor = (Cursor)LNULL;
  static int percent = 0;  /* bell volume */
  Window focuswindow;
  int focusrevert;
  XEvent event;
  KeySym keysym;
  int key = -1;
  int nt;         /* defined length of text */
  int pt;         /* cursor position in text */

  setinput(1);

  /* change the cursor shape */
  if( cursor == (Cursor)NULL ) {
    XKeyboardState kbstate;
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
    cursor = XCreateFontCursor( display, XC_question_arrow );
    XGetKeyboardControl( display, &kbstate );
    percent = kbstate.bell_percent;
+SELF, IF=X11, IF=-WINNT, IF=TK_WINDOWS.
    cursor = (Cursor) NULL;
    percent = 100;
+SELF, IF=X11, IF=-WINNT.
  }
  if( cursor != (Cursor)NULL )
    XDefineCursor( display, cws->window, cursor );
  for( nt = *len_text; nt > 0 && text[nt-1] == ' '; nt-- );
  pt = nt;
  XGetInputFocus( display, &focuswindow, &focusrevert );
  XSetInputFocus( display, cws->window, focusrevert, CurrentTime );
  while( key < 0 ) {
    char keybuf[8];
    char nbytes;
    int dx;
    int i;
    XDrawImageString( display, cws->window, *gctext,
              *x, *y, text, nt );
    dx = XTextWidth( text_font, text, nt );
    XDrawImageString( display, cws->window, *gctext,
              *x + dx, *y, " ", 1 );
    dx = pt == 0 ? 0 : XTextWidth( text_font, text, pt );
    XDrawImageString( display, cws->window, *gcinvt,
              *x + dx, *y, pt < *len_text ? &text[pt] : " ", 1 );
    XWindowEvent( display, cws->window, keybd_mask, &event );
    switch( event.type ) {
    case ButtonPress:
    case EnterNotify:
      XSetInputFocus( display, cws->window, focusrevert, CurrentTime );
      break;
    case LeaveNotify:
      XSetInputFocus( display, focuswindow, focusrevert, CurrentTime );
      break;
    case KeyPress:
      nbytes = XLookupString( &event.xkey, keybuf, sizeof( keybuf ),
                 &keysym, NULL );
      switch( keysym ) {      /* map cursor keys */
      case XK_Left:
      keybuf[0] = '\002';  /* Control-B */
      nbytes = 1;
      break;
      case XK_Right:
      keybuf[0] = '\006';  /* Control-F */
      nbytes = 1;
      break;
      }
      if( nbytes == 1 ) {
      if( isascii( keybuf[0] ) && isprint( keybuf[0] ) ) {
        /* insert character */
        if( nt < *len_text )
          nt++;
        for( i = nt - 1; i > pt; i-- )
          text[i] = text[i-1];
        if( pt < *len_text ) {
          text[pt] = keybuf[0];
          pt++;
        }
      }
      else
        switch( keybuf[0] ) {
          /* Emacs-like editing keys */

        case '\010':    /* backspace */
        case '\177':    /* delete */
          /* delete backward */
          if( pt > 0 ) {
            for( i = pt; i < nt; i++ )
            text[i-1] = text[i];
            text[nt-1] = ' ';
            nt--;
            pt--;
          }
          break;
        case '\001':    /* ^A */
          /* beginning of line */
          pt = 0;
          break;
        case '\002':    /* ^B */
          /* move backward */
          if( pt > 0 )
            pt--;
          break;
        case '\004':    /* ^D */
          /* delete forward */
          if( pt > 0 ) {
            for( i = pt; i < nt; i++ )
         text[i-1] = text[i];
            text[nt-1] = ' ';
            pt--;
          }
          break;
        case '\005':    /* ^E */
          /* end of line */
          pt = nt;
          break;

        case '\006':    /* ^F */
          /* move forward */
          if( pt < nt )
            pt++;
          break;
        case '\013':    /* ^K */
          /* delete to end of line */
          for( i = pt; i < nt; i++ )
            text[i] = ' ';
          nt = pt;
          break;
        case '\024':    /* ^T */
          /* transpose */
          if( pt > 0 ) {
            char c = text[pt];
            text[pt] = text[pt-1];
            text[pt-1] = c;
          }
          break;
        case '\012':    /* newline */
        case '\015':    /* return */
          key = 1;
          break;
        case '\033':    /* escape */
          key = 0;
          break;

        default:
          XBell( display, percent );
        }
      }
    }
  }
  XSetInputFocus( display, focuswindow, focusrevert, CurrentTime );

  if( cursor != (Cursor)NULL ) {
+SELF, IF=X11, IF=-WINNT, IF=-TK_WINDOWS.
    XUndefineCursor( display, cws->window );
+SELF, IF=X11, IF=-WINNT.
    cursor = (Cursor)LNULL;
  }

  setinput(0);

  return( key );
}

#define MAX_SEGMENT 20
void ixput_image(offset,itran,x0,y0,nx,ny,xmin,ymin,xmax,ymax,image)
             int offset,itran,x0,y0,nx,ny,xmin,ymin,xmax,ymax;
   unsigned char *image;
{
  int           i, n, x, y, xcur, x1, x2, y1, y2;
  unsigned char *jimg, *jbase, icol;
  int           nlines[256];
  XSegment      lines[256][MAX_SEGMENT];

  for (i=0; i<256; i++) nlines[i] = 0;

  x1 = x0 + xmin; y1 = y0 + ny - ymax - 1;
  x2 = x0 + xmax; y2 = y0 + ny - ymin - 1;
  jbase = image + (ymin-1)*nx + xmin;

  for (y=y2; y>=y1; y--) {
    xcur   = x1; jbase += nx;
    for (jimg = jbase, icol = *jimg++, x=x1+1; x<=x2; jimg++, x++) {
      if (icol != *jimg) {
        if (icol != itran) {
          n = nlines[icol]++;
          lines[icol][n].x1 = xcur; lines[icol][n].y1 = y;
          lines[icol][n].x2 = x-1;  lines[icol][n].y2 = y;
          if (nlines[icol] == MAX_SEGMENT) {
            setcolor(*gcline,(int)icol+offset);
            XDrawSegments(display,cws->drawing,*gcline,&lines[icol][0],
              MAX_SEGMENT);
            nlines[icol] = 0;
          }
        }
        icol = *jimg; xcur = x;
      }
    }
    if (icol != itran) {
      n = nlines[icol]++;
      lines[icol][n].x1 = xcur; lines[icol][n].y1 = y;
      lines[icol][n].x2 = x-1;  lines[icol][n].y2 = y;
      if (nlines[icol] == MAX_SEGMENT) {
        setcolor(*gcline,(int)icol+offset);
        XDrawSegments(display,cws->drawing,*gcline,&lines[icol][0],
          MAX_SEGMENT);
        nlines[icol] = 0;
      }
    }
  }

  for (i=0; i<256; i++) {
    if (nlines[i] != 0) {
     setcolor(*gcline,i+offset);
     XDrawSegments(display,cws->drawing,*gcline,&lines[i][0],nlines[i]);
    }
  }
}

+SELF, IF=X11, IF=-WINNT, IF=GIF.
/*
 *    SUBROUTINE IXLDGIF(X0, Y0, LEN, FILE)
 *    INTEGER LEN        : file name length
 *    CHARACTER*(*) FILE : file name
 *    INTEGER X0 Y0      : position
 *
 *    Load the gif a file in the current active window.
 */
void ixldgif (x0, y0, len,
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=CRAY.
          fcd_file )
_fcd fcd_file;
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=VAX.
          dsc_file )
struct dsc$descriptor_s *dsc_file;
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=TK_WINDOWS.
          file, lenfile )
char *file;
int lenfile;
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
          file )
char *file;
+SELF, IF=X11, IF=-WINNT, IF=GIF.
int *len;
int *x0,*y0;
{
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=CRAY.
  char *file = _fcdtocp( fcd_file );
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=VAX.
  char *file = dsc_file->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT, IF=GIF.
  FILE  *fd;
  long  filesize;
  unsigned char *GIFarr, *PIXarr, R[256], G[256], B[256], *j1, *j2, icol;
  int   i, j, k, width, height, ncolor, irep, offset;
  float rr, gg, bb;

  fd = fopen(string(file,*len), "r");
  if (!fd) {
    fprintf(stderr,"ixldgif: unable to open GIF file\n");
    return;
  }

  fseek(fd, 0L, 2);
  filesize = ftell(fd);
  fseek(fd, 0L, 0);

  if (!(GIFarr = (unsigned char *) calloc(filesize+256,1))) {
    fprintf(stderr,"ixldgif: unable to allocate array for gif\n");
    return;
  }

  if (fread(GIFarr, filesize, 1, fd) != 1) {
    fprintf(stderr,"ixldgif: GIF file read failed\n");
    return;
  }

  irep = GIFinfo(GIFarr, &width, &height, &ncolor);
  if (irep != 0) return;

  if (!(PIXarr = (unsigned char *) calloc((long)(width*height),1))) {
    fprintf(stderr,"ixldgif: unable to allocate array for image\n");
    return;
  }

  irep = GIFdecode(GIFarr, PIXarr, &width, &height, &ncolor, R, G, B);
  if (irep != 0) return;

  /*   S E T   P A L E T T E   */

  offset = 8;

  for (i=0; i<ncolor; i++) {
    rr = R[i]/255.;
    gg = G[i]/255.;
    bb = B[i]/255.;
    j = i+offset;
    ixsetco(&j,&rr,&gg,&bb);
  }

  /*  O U T P U T   I M A G E  */

  for (i=1; i<=height/2; i++) {
    j1 = PIXarr + (i-1)*width;
    j2 = PIXarr + (height-i)*width;
    for (k=0; k<width; k++) {
      icol = *j1; *j1++ = *j2; *j2++ = icol;
    }
  }
  ixput_image(offset,-1,*x0,*y0,width,height,0,0,width-1,height-1,PIXarr);
}

typedef unsigned char byte;     /* type used by subroutines to code&decode GIF*/
XImage *image;                  /* temporary unit for GIFencode()             */
FILE *out;                      /* output/input file for animation            */
static int first = 0;

/*
 * subroutines for GIFencode()
 */

void
  get_scline( y, width, scline )
  int y, width;
  byte scline[];
{
int i;
for(i=0;i< width;i++)
        scline[i] = XGetPixel( image, i, y);
}


void
  put_byte( b)
  byte b;
{
 if( ferror(out) == 0) fputc( b, out);
}

/*
 *    SUBROUTINE IXDOGIF( NW, NH, LEN , FILE)
 *    INTEGER NW : New width (if != 0)
 *    INTEGER NH : New height (if != 0)
 *    INTEGER LEN : File name lenght
 *    CHARACTER  FILE : File name
 *
 *    Writes the current window into a GIF file
 *
 *
 */
void
  ixdogif( nw, nh, len,
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=CRAY.
          fcd_file )
_fcd fcd_file;
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=VAX.
          dsc_file )
struct dsc$descriptor_s *dsc_file;
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=TK_WINDOWS.
          file, lenfile )
char *file;
int lenfile;
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=-CRAY, IF=-VAX, IF=-TK_WINDOWS.
          file )
char *file;
+SELF, IF=X11, IF=-WINNT, IF=GIF.
  int *nw, *nh;
  int *len;
{
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=CRAY.
  char *file = _fcdtocp( fcd_file );
+SELF, IF=X11, IF=-WINNT, IF=GIF, IF=VAX.
  char *file = dsc_file->dsc$a_pointer;
+SELF, IF=X11, IF=-WINNT, IF=GIF.

XImage *imgtmp;
byte  *scline;
byte  *r, *g, *b;
int *R, *G, *B;
int ncol, maxcol, i;
char file_name[80];

Window root;
int xx, yy;
unsigned int ww, hh, border, depth;

  if (!display) {
     printf("**** Error: No X11 window opened. \n");
     return;
  }

  XGetGeometry( display, cws->drawing, &root, &xx, &yy, &ww, &hh,
                                       &border, &depth );
  if (ww != cws->width || hh != cws->height) {
     printf("**** Error: Empty window. Nothing to convert. \n");
     return;
  }

  imgtmp = XGetImage( display, cws->drawing, 0, 0,
                      cws->width, cws->height,
                      AllPlanes, ZPixmap);

  if (*nw > 0 && *nh > 0) {
     image = ImgScaling(display, imgtmp, *nw, *nh);
  } else {
     image = imgtmp;
  }

  ImgPickPalette( display, image, &ncol, &R, &G, &B);

  r = (byte *) malloc(256*sizeof(byte));
  g = (byte *) malloc(256*sizeof(byte));
  b = (byte *) malloc(256*sizeof(byte));

  maxcol = 0;
  for(i=0;i<ncol;i++) {
     if (maxcol < R[i] ) maxcol = R[i];
     if (maxcol < G[i] ) maxcol = G[i];
     if (maxcol < B[i] ) maxcol = B[i];
     r[i] = 0; g[i] = 0; b[i] = 0;
  }

  if( maxcol != 0) {
     for( i=0;i<ncol;i++) {
        r[i] = R[i] * 255/maxcol;
        g[i] = G[i] * 255/maxcol;
        b[i] = B[i] * 255/maxcol;
     }
  }

  sprintf( file_name, "%s", string(file, *len));

  out = fopen ( file_name, "w+");

  scline = (byte *) malloc(image->width*sizeof(byte));

  if (out) {
     GIFencode( image->width, image->height,
                ncol, r, g, b, scline, get_scline, put_byte);
     fclose( out );
  } else {
     printf("**** Error: Cannot open file \n");
  }

  XFree(image);
  free(R); free(G); free(B); free(r); free(g); free(b); free(scline);
}
+SELF.
+DECK,  ZBUFFER, T=CC.
/*
 * $Id: higzzz.car602,v 1.4 2005/04/14 11:59:03 tretiak Exp $
 *
 * $Log: higzzz.car602,v $
 * Revision 1.4  2005/04/14 11:59:03  tretiak
 * *** empty log message ***
 *
 * Revision 1.4  1998/09/25 09:23:59  mclareni
 * Modifications for the Mklinux port flagged by CERNLIB_PPC
 *
 * Revision 1.3  1997/03/14 14:22:29  mclareni
 * WNT mods
 *
 * Revision 1.2.2.1  1997/01/21 11:25:23  mclareni
 * All mods for Winnt 96a on winnt branch
 *
 * Revision 1.2  1996/03/08 14:56:19  cernlib
 * Correct ippfst and put_string macro for vms. There was infinite recursion.
 *
 * Revision 1.1.1.1  1996/02/14 13:10:27  mclareni
 * Higz
 *
 */

+SELF, IF=ZBUF.
/*CMZ :  2.07/20 12/12/95  10.19.50  by  O.Couet*/
/*-- Author : O.Couet*/
/***********************************************************************
 *                                                                     *
 * Name: Z-buffer                                    Date:    15.08.95 *
 *                                                   Revised:          *
 * Author: Evgeni Chernyaev (chernaev@mx.ihep.su)                      *
 *                                                                     *
 * Contents (C interface):                                             *
 *     Zbuf_Init       - initialize Z-buffer                           *
 *     Zbuf_Clear      - clear screen                                  *
 *     Zbuf_Clip       - set cliping window                            *
 *     Zbuf_World      - set world min-max scope                       *
 *     Zbuf_Pixel      - draw point                                    *
 *     Zbuf_Line       - draw line                                     *
 *     Zbuf_Fill       - fill area                                     *
 *     Zbuf_Spectr     - set spectrum for Gouraud shading              *
 *     Zbuf_Shade      - fill area using Gouraud shading               *
 *     Zbuf_XFlush     - flush Z-image to X Windows window (HIGZ)      *
 *     Zbuf_Print      - print Z-image on terminal screen (for debug)  *
 *     Zbuf_PostScript - output Z-image to PostScript                  *
 *                                                                     *
 * (FORTRAN interface):                                                *
 *     IREP=IHZINI(NX,NY,NZ)                                           *
 *     CALL IHZCLE(ICOL)                                               *
 *     CALL IHZCLI(XMIN,YMIN,XMAX,YMAX)                                *
 *     CALL IHZWRD(XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX)                      *
 *     CALL IHZPNT(ICOL,X,Y,Z)                                         *
 *     CALL IHZLIN(ICOL,X1,Y1,Z1,X2,Y2,Z2)                             *
 *     CALL IHZFIL(ICOL,N,X,Y,Z)                                       *
 *     CALL IHZSPE(NL,FMIN,FMAX,ICOL)                                  *
 *     CALL IHZSHA(N,X,Y,Z,F)                                          *
 *     CALL IHZTOX(ITRAN,X0,Y0)                                        *
 *     CALL IHZPRN()                                                   *
 *     CALL IHZPS(IFGRAY,IFROTATE,XMIN,YMIN,XMAX,YMAX,NCOL,R,G,B)      *
 *                                                                     *
 ***********************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef __STDC__
#define ARGS(alist) alist
#else
#define ARGS(alist) ()
#endif

typedef unsigned char byte;

/*   F O R T R A N   I N T E R F A C E  -  M A I N   R O U T I N E S*/

+SELF, IF=ZBUF, IF=QX_SC.
#define ihzini ihzini_
#define ihzcle ihzcle_
#define ihzcli ihzcli_
#define ihzwrd ihzwrd_
#define ihzpix ihzpix_
#define ihzlin ihzlin_
#define ihzfil ihzfil_
#define ihzspe ihzspe_
#define ihzsha ihzsha_
#define ihztox ihztox_
#define ihzprn ihzprn_
#define ihzps  ihzps_
#define ippfst ippfst_
+SELF, IF=ZBUF, IF=QXCAPT.
#define ihzini IHZINI
#define ihzcle IHZCLE
#define ihzcli IHZCLI
#define ihzwrd IHZWRD
#define ihzpix IHZPIX
#define ihzlin IHZLIN
#define ihzfil IHZFIL
#define ihzspe IHZSPE
#define ihzsha IHZSHA
#define ihztox IHZTOX
#define ihzprn IHZPRN
#define ihzps  IHZPS
#define ippfst IPPFST
+SELF, IF=ZBUF, IF=IBM.
#pragma linkage (ihzini ,FORTRAN)
#pragma linkage (ihzcle ,FORTRAN)
#pragma linkage (ihzcli ,FORTRAN)
#pragma linkage (ihzwrd ,FORTRAN)
#pragma linkage (ihzpix ,FORTRAN)
#pragma linkage (ihzlin ,FORTRAN)
#pragma linkage (ihzfil ,FORTRAN)
#pragma linkage (ihzspe ,FORTRAN)
#pragma linkage (ihzsha ,FORTRAN)
#pragma linkage (ihztox ,FORTRAN)
#pragma linkage (ihzprn ,FORTRAN)
#define linkage (ihzps  ,FORTRAN)
#define linkage (ippfst ,FORTRAN)
+SELF, IF=ZBUF.


/*   U S E F U L   M A C R O S*/

#define SWAP(A,B,C) C = A; A = B; B = C
#define MIN(A,B)    (A < B ? A : B)
#define MAX(A,B)    (A > B ? A : B)

/*  G L O B A L   V A R I A B L E S   A N D   D E F I N I T I O N S*/

+SELF, IF=ZBUF, IF=VAX,DECS,MSDOS,WINNT,LINUX, IF=-PPC.
#define Z_OFFSET 1       /* offset for short* on int (machine depended) */
#define C_OFFSET 2       /* offset for byte* on int (machine depended) */
+SELF, IF=ZBUF, IF=-VAX, IF=-DECS, IF=-MSDOS, IF=-WINNT, IF=-LINUX, IF=-PPC.
#define Z_OFFSET 0       /* offset for short* on int (machine depended) */
#define C_OFFSET 1       /* offset for byte* on int (machine depended) */
+SELF, IF=ZBUF.
#define MAXSIZE  4096    /* max size of z-screen */
#define LMAX     50      /* max number of edges in polygon */

struct EDGE {
  short x;               /* X of 1st node      & current X        */
  short y;               /* Y of 1st node                         */
  int   z;               /* Z of 1st node      & current Z        */
  int   c;               /* Colour of 1st node & current Colour   */
  short xx;              /* X of 2nd node      & X increment      */
  short yy;              /* Y of 2nd node                         */
  int   zz;              /* Z of 2nd node      & Z increment      */
  int   cc;              /* Colour of 2nd node & Colour increment */
  short test;            /* current parameter                     */
  short dxsign;          /* sign of X increment                   */
};

static int       Zstat = 0;               /* status of z-buffer */

static short     *Zbuf;                   /* z-buffer */
static byte      *Zimg;                   /* image */

static float     XWmin, YWmin, ZWmin,
                 XWmax, YWmax, ZWmax;     /* world min-max scope */
static long      Nalloc=0;                /* size of allocated memory */
static short     Nx, Ny, Nz;              /* z-image size */
static short     Xmin, Ymin, Xmax, Ymax;  /* cliping rectangle */
static int       IXmin, IYmin,
                 IXmax, IYmax;            /* area occupated by image */
static int       IBack=-1;                /* background colour */
static float     Fmin, Fmax;              /* min, max lightness */
static int       Nlevel, FstCol;          /* number of levels, 1st colour */

static struct EDGE edge[LMAX], *jedge[LMAX];
static int       Nedge, xscan[LMAX], zscan[LMAX], cscan[LMAX];

/***********************************************************************
 *                                                                     *
 *                E X T E R N A L   R O U T I N E S                    *
 *                                                                     *
 ***********************************************************************/

void ixput_image ARGS((int,int,int,int,int,int,int,int,int,int,byte*));

+SELF, IF=ZBUF, IF=VAX.
#include <descrip.h>
#define ippfst_vms(s1) \
        do { extern void ippfst(struct dsc$descriptor_s*); \
             struct dsc$descriptor_s s1_dsc; \
             s1_dsc.dsc$b_dtype = DSC$K_DTYPE_T; \
             s1_dsc.dsc$b_class = DSC$K_CLASS_S; \
             s1_dsc.dsc$a_pointer = s1; \
             s1_dsc.dsc$w_length = strlen(s1); \
             ippfst(&s1_dsc); } while(0)
+SELF, IF=ZBUF, IF=-VAX.
#define zippfst(s1) \
        ippfst(s1,strlen(s1))
+SELF, IF=ZBUF.

+SELF, IF=ZBUF, IF=WINNT.
/***********************************************************************
 *             Dummy routine for Windows NT			       *
 ***********************************************************************/
void ixput_image(offset,itran,x0,y0,nx,ny,xmin,ymin,xmax,ymax,image)
             int offset,itran,x0,y0,nx,ny,xmin,ymin,xmax,ymax;
   unsigned char *image;
{
}
+SELF, IF=ZBUF.

/***********************************************************************
 *                                                                     *
 *                I N T E R N A L   R O U T I N E S                    *
 *                                                                     *
 ***********************************************************************
 *                                                                     *
 * Name: Zbuf_WtoS                                   Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Transform coordinates of point from world to screen       *
 *                                                                     *
 * Input:  XW, YW, ZW - world coodinates of point                      *
 * Output: XS, YS, ZS - screen coordinates of point                    *
 *                                                                     *
 ***********************************************************************/
static void Zbuf_WtoS(XW, YW, ZW, XS, YS, ZS)
               float  XW, YW, ZW;
                 int *XS,*YS,*ZS;
{
  int x, y;

  *XS   = ((XW - XWmin)/(XWmax-XWmin)) * Nx;
  *YS   = ((YW - YWmin)/(YWmax-YWmin)) * Ny;
  *ZS   = ((ZW - ZWmin)/(ZWmax-ZWmin)) * Nz * 65536;
  IXmin = MIN(IXmin,*XS); IXmax = MAX(IXmax,*XS);
  IYmin = MIN(IYmin,*YS); IYmax = MAX(IYmax,*YS);
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_FtoC                                   Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Translate function value to colour index                  *
 *                                                                     *
 * Input: F - function value                                           *
 *                                                                     *
 * Output: ICOL - extended colour index                                *
 *                                                                     *
 ***********************************************************************/
static void Zbuf_FtoC(F, ICOL)
                float F;
                 int *ICOL;
{
  *ICOL = (((F - Fmin)/(Fmax - Fmin))*Nlevel + FstCol) * 65536;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_GetEdges                               Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Get edges of the polygon                                  *
 *                                                                     *
 * Input: N              - number of edges                             *
 *        X(*),Y(*),Z(*) - coordinates of nodes                        *
 *        F1(*)          - function values at nodes                    *
 *        ifval          - flag: 1 - copy function values              *
 *                               0 - do not copy                       *
 *                                                                     *
 ***********************************************************************/
static void Zbuf_GetEdges(N, X, Y, Z, F, ifval)
                      int N, ifval;
                   float *X,*Y,*Z,*F;
{
  int i, n;
  int i1, x1, y1, z1, icol1;
  int i2, x2, y2, z2, icol2;
  byte *jcol,*jcol1,*jcol2;

  Nedge = 0;

  /*   C H E C K   N U M B E R   O F   E D G E S   */

  n = N;
  if (n < 0 || n > LMAX) {
    fprintf(stderr,"Zbuf_GetEdges: wrong n. of edges=%d (max=%d)\n",n,LMAX);
    return;
  }

  /*   S K I P   H O R I Z O N T A L   E D G E S   */
  /*   S E T   R I G H T   O R I E N T A T I O N   O F   E D G E S  */

  n = icol1 = icol2 = 0;
  for (i=0; i < N; i++) {
    i1 = i; i2 = i+1; if (i2 == N) i2 = 0;
    Zbuf_WtoS(X[i1], Y[i1], Z[i1], &x1, &y1, &z1);
    if (ifval) Zbuf_FtoC(F[i1], &icol1);
    Zbuf_WtoS(X[i2], Y[i2], Z[i2], &x2, &y2, &z2);
    if (ifval) Zbuf_FtoC(F[i2], &icol2);
    if (y1 == y2)               continue;
    if (y1 < Ymin && y2 < Ymin) continue;
    if (y1 > Ymax && y2 > Ymax) continue;
    if (y2 > y1) {
      edge[n].x  = x1; edge[n].y  = y1; edge[n].z  = z1; edge[n].c  = icol1;
      edge[n].xx = x2; edge[n].yy = y2; edge[n].zz = z2; edge[n].cc = icol2;
    }else{
      edge[n].x  = x2; edge[n].y  = y2; edge[n].z  = z2; edge[n].c  = icol2;
      edge[n].xx = x1; edge[n].yy = y1; edge[n].zz = z1; edge[n].cc = icol1;
    }
    n++;
  }
  Nedge = n;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_MinMax                                 Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Find surrounding box (min-max scope)                      *
 *                                                                     *
 * Output: XMIN,XMAX,YMIN,YMAX - min-max scope                         *
 *                                                                     *
 ***********************************************************************/
static void Zbuf_MinMax(XMIN, XMAX, YMIN, YMAX)
                   int *XMIN,*XMAX,*YMIN,*YMAX;
{
  int       i, xmin, xmax, ymin, ymax;

  xmin = xmax = edge[1].x; ymin = ymax = edge[1].y;
  for (i=0; i<Nedge; i++) {
    if (xmin > edge[i].x)  xmin = edge[i].x;
    if (xmax < edge[i].x)  xmax = edge[i].x;
    if (xmin > edge[i].xx) xmin = edge[i].xx;
    if (xmax < edge[i].xx) xmax = edge[i].xx;
    if (ymin > edge[i].y)  ymin = edge[i].y;
    if (ymax < edge[i].yy) ymax = edge[i].yy;
  }
  *XMIN = xmin; *XMAX = xmax; *YMIN = ymin; *YMAX = ymax;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_SortEdges                              Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Sort edges along Y                                        *
 *                                                                     *
 ***********************************************************************/
static void Zbuf_SortEdges()
{
  int         i, k;
  struct EDGE *jcur;

  for (i=0; i<Nedge;   i++) { jedge[i] = &edge[i]; }
  for (i=0; i<Nedge-1; i++) {
    if (jedge[i+1]->y >= jedge[i]->y) continue;
    for (k=i+1; k>0; k--) {
      if (jedge[k]->y >= jedge[k-1]->y) break;
      SWAP(jedge[k],jedge[k-1],jcur);
    }
  }
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_InitEdges                              Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Initialize edges for polygon filling                      *
 *                                                                     *
 ***********************************************************************/
static void Zbuf_InitEdges()
{
  int i, dx, dy;

  for (i=0; i<Nedge; i++) {
    dx           = edge[i].xx - edge[i].x;
    dy           = edge[i].yy - edge[i].y;
    if (dx < 0) { edge[i].dxsign = -1; dx = -dx;} else { edge[i].dxsign = 1;}
    edge[i].xx = dx;
    if (dx <= dy) {
      edge[i].test  = -(dy+1)/2;
      edge[i].zz    = (edge[i].zz - edge[i].z) / dy;
      edge[i].cc    = (edge[i].cc - edge[i].c) / dy;
    }else{
      edge[i].test  = -dx;
      edge[i].zz    = (edge[i].zz - edge[i].z) / dx;
      edge[i].cc    = (edge[i].cc - edge[i].c) / dx;
    }
  }
}

/***********************************************************************
 *                                                                     *
 *     M A I N   R O U T I N E S   -   C   I N T E R F A C E           *
 *                                                                     *
 ***********************************************************************
 *                                                                     *
 * Name: Zbuf_Init                                   Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Initialize Z-buffer                                       *
 *                                                                     *
 * Input: NX,NY,NZ - dimensions of Z-buffer                            *
 *                                                                     *
 * Return: 0 - O.K.                                                    *
 *         1 - error during initialization                             *
 *                                                                     *
 ***********************************************************************/
int Zbuf_Init(NX, NY, NZ)
         int  NX, NY, NZ;
{
  Zstat = 0;

  /*   C H E C K   P A R A M E T E R S  */

  if (NX <= 0 || NX > MAXSIZE ||
      NY <= 0 || NY > MAXSIZE ||
      NZ <= 0 || NZ > MAXSIZE ) {
    fprintf(stderr,"Zbuf_Init: wrong z-buffer dimensions: %d %d %d\n",
          NX,NY,NZ);
    return 1;
  }

  Nx = NX; Ny = NY; Nz = NZ;
  Xmin = 0;  Ymin = 0; Xmax = Nx - 1; Ymax = Ny - 1;
  IXmin = Xmax+1; IYmin = Ymax+1; IXmax = Xmin-1; IYmax = Ymin-1;

  /*   A L L O C A T E   Z - B U F F E R   */

  if ((long)Nx * (long)Ny > Nalloc) {

    if (Nalloc != 0) {
      free((char *) Zbuf);
      free((char *) Zimg);
    }

    Zbuf = (short *) malloc (Nx*Ny*sizeof(short));
    if (!Zbuf) {
      fprintf(stderr,"Zbuf_Init: can not allocate z-buffer\n");
      return 1;
    }

    Zimg = (byte *) malloc (Nx*Ny*sizeof(byte));
    if (!Zimg) {
      fprintf(stderr,"Zbuf_Init: can not allocate image\n");
      return 1;
    }

    Nalloc = (long)Nx * (long)Ny;
  }

  Zstat = 1;
  return 0;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Clear                                  Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Clear screen                                              *
 *                                                                     *
 * Input: ICOL - background colour                                     *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Clear(ICOL)
            int ICOL;
{
  int y,nx;

  if (!Zstat) return;
  if (IBack != ICOL) {
    memset ((char *)Zbuf, (char)0, Nx*Ny*sizeof(short));
    memset ((char *)Zimg, (char)(ICOL & 0xff), Nx*Ny);
    IBack = ICOL;
  }else{
    IXmin = MAX(IXmin,Xmin); IYmin = MAX(IYmin,Ymin);
    IXmax = MIN(IXmax,Xmax); IYmax = MIN(IYmax,Ymax);
    nx    = IXmax - IXmin + 1;
    for (y=IYmin; y<=IYmax; y++) {
      memset ( (char *)(Zbuf+y*Nx+IXmin), (char)0, nx*sizeof(short));
      memset ( (char *)(Zimg+y*Nx+IXmin), (char)(ICOL & 0xff), nx);
    }
  }
  IXmin = Xmax+1; IYmin = Ymax+1; IXmax = Xmin-1; IYmax = Ymin-1;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Clip                                   Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Set cliping window                                        *
 *                                                                     *
 * Input: XMIN, YMIN, XMAX, YMAX - clipping rectangle                  *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Clip(XMIN, YMIN, XMAX, YMAX)
           int XMIN, YMIN, XMAX, YMAX;
{
  if (!Zstat) return;
  Xmin = MAX(XMIN,0); Xmax = MIN(XMAX,Nx-1);
  Ymin = MAX(YMIN,0); Ymax = MIN(YMAX,Ny-1);
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_World                                  Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Set world min-max scope                                   *
 *                                                                     *
 * Input: XMIN, XMAX, YMIN, YMAX, ZMIN, ZMAX - world min-max scope     *
 *                                                                     *
 ***********************************************************************/
void Zbuf_World(XMIN, YMIN, ZMIN, XMAX, YMAX, ZMAX)
          float XMIN, YMIN, ZMIN, XMAX, YMAX, ZMAX;
{
  float d;

  XWmin = XMIN; YWmin = YMIN; ZWmin = ZMIN;
  XWmax = XMAX; YWmax = YMAX; ZWmax = ZMAX;
  if (XWmin >= XWmax || YWmin >= YWmax || ZWmin >= ZWmax) {
    fprintf(stderr,"Zbuf_World: error in min-max scope\n");
  }
  d = 0.5 * (XWmax-XWmin) / (Nx-1); XWmin -= d; XWmax += d;
  d = 0.5 * (YWmax-YWmin) / (Ny-1); YWmin -= d; YWmax += d;
  d = 0.5 * (ZWmax-ZWmin) / (Nz-1); ZWmin -= d; ZWmax += d;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Point                                  Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Draw point (Z-buffer)                                     *
 *                                                                     *
 * Input: ICOL  - colour                                               *
 *        X,Y,Z - coordinates of the point                             *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Point(ICOL, X, Y, Z)
            int ICOL;
          float X, Y, Z;
{
  int     x, y, z, k;
  byte    *jimg;
  short   *jbuf, zz;

  /*   C H E C K   P A R A M E T E R S   */

  if (!Zstat) return;
  Zbuf_WtoS(X, Y, Z, &x, &y, &z);
  if (x < Xmin || x > Xmax || y < Ymin || y > Ymax) return;

  /*   D R A W   P I X E L   */

  k    = y * Nx + x;
  jimg = Zimg + k;
  jbuf = Zbuf + k;
  zz   = z / 65536;
  if (*jbuf <= zz) { *jbuf = zz; *jimg = ICOL & 0xff; }
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Line                                   Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Draw line (Z-buffer)                                      *
 *                                                                     *
 * Input: ICOL     - colour                                            *
 *        X1,Y1,Z1 - 1st point of the line                             *
 *        X2,Y2,Z2 - 2nd point of the line                             *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Line(ICOL, X1, Y1, Z1, X2, Y2, Z2)
           int ICOL;
         float X1, Y1, Z1, X2, Y2, Z2;
{
  int     x1, y1, z1, x2, y2, z2;
  int     dx, dy, dz, dmax, dxdx, dydy, dxsign;
  int     t, xcur, ycur, zcur, xlim1, xlim2;
  byte    *jimg, icol;
  short   *jbuf, *jend, *jzcur ;

  if (!Zstat) return;

  /*   T R A N S F O R M   C O O R D I N A T E S  */

  icol = ICOL & 0xff;
  if (Y2 > Y1) {
    Zbuf_WtoS(X1, Y1, Z1, &x1, &y1, &z1);
    Zbuf_WtoS(X2, Y2, Z2, &x2, &y2, &z2);
  }else{
    Zbuf_WtoS(X1, Y1, Z1, &x2, &y2, &z2);
    Zbuf_WtoS(X2, Y2, Z2, &x1, &y1, &z1);
  }

  /*   S E T   S O M E   P R E D E F I N I T I O N S   */

  dxsign = x1 > x2 ? -1 : 1;
  dx     = x1 > x2 ? x1 - x2 : x2 - x1;
  dxdx   = dx + dx;
  dy     = y2 - y1;
  dydy   = dy + dy;
  dmax   = MAX(dx,dy);
  t      = -dmax;
  if (dmax > 0) dz = (z2 - z1) / dmax;

  zcur   = z1+65536;
  jzcur  = (short *) &zcur + Z_OFFSET;

  jimg   = Zimg + y1*Nx + x1;
  jbuf   = Zbuf + y1*Nx + x1;
  jend   = Zbuf + y2*Nx + x2;

  /*   I S   L I N E   F U L L Y   I N S I D E   W I N D O W  ?  */

  if (y1 >= Ymin && y2 <= Ymax &&
      x1 >= Xmin && x1 <= Xmax &&
      x2 >= Xmin && x2 <= Xmax) {

    /*   D R A W   P O I N T   */
    if ( dmax == 0) {
      if (z1 < z2) zcur = z2+65536;
      if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
      return;
    }

    /*   D R A W   L I N E   */

    if (dx >= dy) {
      while (jbuf != jend) {
      if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg  = icol; }
      if ((t += dydy) >= 0) { t -= dxdx; jbuf += Nx; jimg += Nx; }
        jbuf += dxsign; jimg += dxsign; zcur += dz;
      }
    }else{
      while (jbuf != jend) {
      if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
      if ((t += dxdx) >= 0) { t -= dydy; jbuf += dxsign; jimg += dxsign; }
        jbuf += Nx; jimg += Nx; zcur += dz;
      }
    }
    if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }

  }else{

    if (y1 > Ymax || y2 < Ymin) return;
    if (x1 < Xmin && x2 < Xmin) return;
    if (x1 > Xmax && x2 > Xmax) return;
    xcur = dxsign*x1;
    ycur = y1;
    if (x2 >= x1) {
      xlim1 = Xmin; xlim2 = Xmax;
    }else{
      xlim1 = -Xmax; xlim2 = -Xmin;
    }

    /*   D R A W   C L I P P E D   L I N E   */

    if (dx >= dy) {
      while (jbuf != jend) {
      if (ycur > Ymax || xcur > xlim2) return;
        if (ycur >= Ymin && xcur >= xlim1)
        if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
      if ((t += dydy) >= 0)
        { t -= dxdx; jbuf += Nx; jimg += Nx; ycur++; }
      jbuf += dxsign; jimg += dxsign; xcur++; zcur += dz;
      }
    }else{
      while (jbuf != jend) {
        if (ycur > Ymax || xcur > xlim2) return;
        if (ycur >= Ymin && xcur >= xlim1)
        if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
      if ((t += dxdx) >= 0)
        { t -= dydy; jbuf += dxsign; jimg += dxsign; xcur++; }
        jbuf += Nx; jimg += Nx; ycur++; zcur += dz;
      }
    }
    if (ycur > Ymax || xcur > xlim2) return;
    if (ycur < Ymin || xcur < xlim1) return;
    if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
  }
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Fill                                   Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Fill area (Z-buffer)                                      *
 *                                                                     *
 * Input: ICOL           - colour                                      *
 *        N              - number of edges                             *
 *        X(*),Y(*),Z(*) - coordinates of nodes                        *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Fill(ICOL, N, X, Y, Z)
          int  ICOL, N;
        float *X,*Y,*Z;
{
  int     i, k, step, istart, nx, xcur, ycur, zcur, dz;
  int     xmin, xmax, ymin, ymax;
  byte    icol,*jimg,*jimg_base;
  short   dx, dy, *jzcur,*jbuf,*jend,*jbuf_base;
  struct EDGE *jcur;

  if (!Zstat) return;

  /*   P R E P A R A T O R Y   S T U F F  */

  Zbuf_GetEdges (N, X, Y, Z, (float *) NULL, 0);
  if (Nedge == 0 ) return;

  Zbuf_MinMax (&xmin, &xmax, &ymin, &ymax);
  if (xmin > Xmax || xmax < Xmin) return;
  if (ymax > Ymax) ymax = Ymax;

  Zbuf_SortEdges();
  Zbuf_InitEdges();

  /*   F I L L  P O L Y G O N :  L O O P   A L O N G   S C A N L I N E S   */

  icol   = ICOL & 0xff;
  jzcur  = (short *) &zcur + Z_OFFSET;
  istart = 0;
  for (ycur=ymin; ycur<=ymax; ycur++) {
    nx = 0;
    /*   P R E P A R E   X   I N T E R S E C T I O N S   */
    for (i=istart; i<Nedge; i++) {
      jcur = jedge[i];
      if (jcur->y  >  ycur) break;
      if (jcur->yy <= ycur) {
        if (i == istart) istart++;
      }else{
        xscan[nx] = jcur->x; zscan[nx] = jcur->z; nx++;
        dx = jcur->xx;
      dy = jcur->yy - jcur->y;
      if (dx <= dy ) {
        jcur->z += jcur->zz;
          if ((jcur->test += dx) >= 0) {
          jcur->test -= dy;
          jcur->x    += jcur->dxsign;
        }
      }else{
          step = dx/dy;
        if ((jcur->test += step*dy) >= 0) {
          jcur->test -= dx;
        }else{
          jcur->test += dy - dx; step++;
        }
        jcur->x += jcur->dxsign * step;
        jcur->z += jcur->zz * step;
      }
      }
    }
    if (ycur < Ymin) continue;

    /*   S O R T   I N T E R S E C T I O N   P O I N T S   A L O N G   X   */
    for (i=0; i<nx-1; i++) {
      if (xscan[i+1] >= xscan[i]) continue;
      for (k=i+1; k>0; k--) {
      if (xscan[k] >= xscan[k-1]) break;
        SWAP(xscan[k],xscan[k-1],xcur);
        SWAP(zscan[k],zscan[k-1],zcur);
      }
    }

    /*   F I L L   S P A N S   */
    jimg_base = Zimg + ycur*Nx;
    jbuf_base = Zbuf + ycur*Nx;
    for (i=0; i<nx; i+=2) {
      if ((xmin = xscan[i])   > Xmax) break;
      if ((xmax = xscan[i+1]) < Xmin) continue;
      if (xmin == xmax) {
        jimg = jimg_base + xmin;
        jbuf = jbuf_base + xmin;
        zcur = MAX(zscan[i],zscan[i+1]);
      if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
      }else{
        zcur = zscan[i];
      dz   = (zscan[i+1] - zcur) / (xmax - xmin);
        if (xmin < Xmin) { zcur += dz * (Xmin-xmin); xmin = Xmin; }
      if (xmax > Xmax) xmax = Xmax;
        jimg = jimg_base + xmin;
        jbuf = jbuf_base + xmin;
      jend = jbuf_base + xmax;
      while (jbuf != jend) {
        if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
        jbuf++; jimg++; zcur += dz;
      }
      if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = icol; }
      }
    }
  }
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Spectr                                 Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Set colour spectrum for Gouraud shading                   *
 *                                                                     *
 * Input: NL   - number of levels                                      *
 *        FMIN - min lightness                                         *
 *        FMAX - max lightness                                         *
 *        ICOL - colour index of 1st level                             *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Spectr(NL, FMIN, FMAX, ICOL)
             int NL, ICOL;
           float FMIN, FMAX;
{
  Nlevel = NL;
  Fmin   = FMIN;
  Fmax   = FMAX + (FMAX-FMIN)*0.001;
  FstCol = ICOL;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Shade                                  Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Gouraud shading (Z-buffer)                                *
 *                                                                     *
 * Input: N              - number of edges                             *
 *        X(*),Y(*),Z(*) - coordinates of nodes                        *
 *        F(*)           - function values (lightness) at nodes        *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Shade(N, X, Y, Z, F)
            int N;
         float *X,*Y,*Z,*F;
{
  int     i, k, step, istart, nx, ccur, xcur, ycur, zcur, dc, dz;
  int     xmin, xmax, ymin, ymax;
  byte    *jccur,*jimg,*jimg_base;
  short   dx, dy, *jzcur,*jbuf, *jend,*jbuf_base;
  struct EDGE *jcur;

  if (!Zstat) return;

  /*   P R E P A R A T O R Y   S T U F F  */

  Zbuf_GetEdges (N, X, Y, Z, F, 1);
  if (Nedge == 0 ) return;

  Zbuf_MinMax (&xmin, &xmax, &ymin, &ymax);
  if (xmin > Xmax || xmax < Xmin) return;
  if (ymax > Ymax) ymax = Ymax;

  Zbuf_SortEdges();
  Zbuf_InitEdges();

  /*   F I L L  P O L Y G O N :  L O O P   A L O N G   S C A N L I N E S   */

  jccur  = (byte *)  &ccur + C_OFFSET;
  jzcur  = (short *) &zcur + Z_OFFSET;
  istart = 0;
  for (ycur=ymin; ycur<=ymax; ycur++) {
    nx = 0;
    /*   P R E P A R E   X   I N T E R S E C T I O N S   */
    for (i=istart; i<Nedge; i++) {
      jcur = jedge[i];
      if (jcur->y  >  ycur) break;
      if (jcur->yy <= ycur) {
        if (i == istart) istart++;
      }else{
        xscan[nx] = jcur->x; zscan[nx] = jcur->z; cscan[nx] = jcur->c; nx++;
        dx = jcur->xx;
      dy = jcur->yy - jcur->y;
      if (dx <= dy ) {
        jcur->z += jcur->zz;
        jcur->c += jcur->cc;
          if ((jcur->test += dx) >= 0) {
          jcur->test -= dy;
          jcur->x    += jcur->dxsign;
        }
      }else{
          step = dx/dy;
        if ((jcur->test += step*dy) >= 0) {
          jcur->test -= dx;
        }else{
          jcur->test += dy - dx; step++;
        }
        jcur->x += jcur->dxsign * step;
        jcur->z += jcur->zz * step;
        jcur->c += jcur->cc * step;
      }
      }
    }
    if (ycur < Ymin) continue;

    /*   S O R T   I N T E R S E C T I O N   P O I N T S   A L O N G   X   */
    for (i=0; i<nx-1; i++) {
      if (xscan[i+1] >= xscan[i]) continue;
      for (k=i+1; k>0; k--) {
      if (xscan[k] >= xscan[k-1]) break;
        SWAP(xscan[k],xscan[k-1],xcur);
        SWAP(zscan[k],zscan[k-1],zcur);
        SWAP(cscan[k],cscan[k-1],ccur);
      }
    }

    /*   F I L L   S P A N S   */
    jimg_base = Zimg + ycur*Nx;
    jbuf_base = Zbuf + ycur*Nx;
    for (i=0; i<nx; i+=2) {
      if ((xmin = xscan[i])   > Xmax) break;
      if ((xmax = xscan[i+1]) < Xmin) continue;
      if (xmin == xmax) {
        jimg = jimg_base + xmin;
        jbuf = jbuf_base + xmin;
        if (zscan[i] > zscan[i+1]) {
        zcur = zscan[i]; ccur = cscan[i];
      }else{
        zcur = zscan[i+1]; ccur = cscan[i+1];
      }
      if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = *jccur; }
      }else{
        zcur = zscan[i];
      dz   = (zscan[i+1] - zcur) / (xmax - xmin);
        ccur = cscan[i];
      dc   = (cscan[i+1] - ccur) / (xmax - xmin);
        if (xmin < Xmin) {
        zcur += dz * (Xmin-xmin); ccur += dc * (Xmin-xmin); xmin = Xmin;
      }
      if (xmax > Xmax) xmax = Xmax;
        jimg = jimg_base + xmin;
        jbuf = jbuf_base + xmin;
      jend = jbuf_base + xmax;
      while (jbuf != jend) {
        if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = *jccur; }
        jbuf++; jimg++; zcur += dz; ccur += dc;
      }
      if (*jbuf <= *jzcur) { *jbuf = *jzcur; *jimg = *jccur; }
      }
    }
  }
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_XFlush                                 Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Flush Z-image to X Windows screen                         *
 *                                                                     *
 * Input: ITRAN  - index of transparent colour, if necessary, or -1    *
 *        X0, Y0 - coordinates of upper-left corner of the image       *
 *                                                                     *
 ***********************************************************************/
void Zbuf_XFlush(ITRAN, X0, Y0)
             int ITRAN, X0, Y0;
{
  IXmin = MAX(IXmin,Xmin); IYmin = MAX(IYmin,Ymin);
  IXmax = MIN(IXmax,Xmax); IYmax = MIN(IYmax,Ymax);
  ixput_image(0,ITRAN,X0,Y0,Nx,Ny,IXmin,IYmin,IXmax,IYmax,Zimg);
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_Print                                  Date:    15.08.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Print contents of z-image to the screen                   *
 *                                                                     *
 ***********************************************************************/
void Zbuf_Print()
{
  int   ix, iy, z;
  short *jbuf;
  byte  *jimg, icol;

  printf("Z-Screen: %d x %d\n",Nx,Ny);

  if (!Zstat) {
    fprintf(stderr,"Zbuf_Print: z-buffer is not initialized\n");
    return;
  }

  for (iy=0; iy<Ny; iy++) {
    jbuf = Zbuf + Nx*(Ny-iy-1);
    jimg = Zimg + Nx*(Ny-iy-1);
    for (ix=0; ix<Nx; ix++) {
      icol = *jimg++;
      z    = *jbuf++;
/*
  if (icol == 0) { printf(" ."); } else { printf("%2d",icol); }
*/
      if (icol == 0) { printf(" ."); } else { printf("%2d",z); }
    }
    printf("\n");
  }
}

/***********************************************************************
 *                                                                     *
 *             O U T P U T   T O   P O S T S C R I P T                 *
 *                                                                     *
 * Output LZW compressed Z-buffer image to PostScript.                 *
 * The code is based on PS_LZWencode.c routine from xwpick-2.21        *
 *                                                                     *
 ***********************************************************************/

static char      s[80];

+SELF, IF=ZBUF, IF=-VAX.
#define put_string   zippfst(&s[0])
+SELF, IF=ZBUF, IF=VAX.
#define put_string   ippfst_vms(&s[0])
+SELF, IF=ZBUF.

/***********************************************************************
 *                                                                     *
 * Name: ASCII85encode                               Date:    05.11.93 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised: 20.04.95 *
 *                                                                     *
 * Function: ASCII85 encode and output byte buffer                     *
 *                                                                     *
 * Input: k   - number of bytes                                        *
 *        Buf - byte buffer                                            *
 *                                                                     *
 ***********************************************************************/
static void ASCII85encode(k, Buf)
                     int  k;
                     byte Buf[];
{
  unsigned long Value;
  int    i, j, n;
  char   *js;

  if (k == 0) return;
  js = s;
  for (j=0; j<k; j+=4) {
    Value = Buf[j]*256*256*256;
    if (j+1 < k) Value += Buf[j+1]*256*256;
    if (j+2 < k) Value += Buf[j+2]*256;
    if (j+3 < k) Value += Buf[j+3];
    if (j == 0) {
      if ( (char) (Value / (85*85*85*85) + 33) == '%') *js++ = ' ';
    }
    for (n=4; n>=0; n--) {
      *(js+n) = Value % 85 + 33;
      Value /= 85;
    }
    if (k-j < 4) {
     js += k-j+1;
    }else{
     js += 5;
    }
  }
  *js = '\0'; put_string;
}

#define BITS           12                       /* largest code size */
#define HSIZE          5003                     /* hash table size */
#define SHIFT          4                        /* shift for hashing */
#define CLEARCODE      256                      /* Clear Code */
#define EOD            257                      /* End Of Data code */
#define PIXS           170000                   /* largest # of pixels */

/***********************************************************************
 *                                                                     *
 * Name: PutCode                                     Date:    05.11.93 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Put out code (LZW encoding)                               *
 *                                                                     *
 * Input: Code - code                                                  *
 *        CodeSize - codesize                                          *
 *                                                                     *
 ***********************************************************************/
static void PutCode(Code, CodeSize)
                int Code, CodeSize;
{
  static int k, PartA, PartB, SizeA, SizeB;
  static int mask[] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F,
                                0x001F, 0x003F, 0x007F, 0x00FF,
                                0x01FF, 0x03FF, 0x07FF, 0x0FFF };
  static byte Accum[56];
  if (Code == -1) {
    k      = 0;
    PartA  = 0;
    SizeA  = 0;
    return;
  }

  PartB = Code;
  SizeB = CodeSize;

  while (SizeB >= 8) {
    SizeB  = SizeA + SizeB - 8;
    Accum[k++] = PartA | (PartB >> SizeB);
    if (k == 56) {
      ASCII85encode(k,Accum);
      k      = 0;
    }
    PartB &= mask[SizeB];
    SizeA  = 0;
    PartA  = 0;
  }

  SizeA = SizeB;
  PartA = PartB << (8-SizeB);
  if (Code == EOD) {
    if (SizeA != 0) Accum[k++] = PartA;
    ASCII85encode(k, Accum);
  }
}

/***********************************************************************
 *                                                                     *
 * Name: EncodeData                                  Date:    27.11.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Lelpel-Ziv Welch encoding of an image                     *
 *                                                                     *
 * Input: Ncol - number of colours                                     *
 *        R[]  - red components                                        *
 *        G[]  - green components                                      *
 *        B[]  - blue components                                      *
 *                                                                     *
 ***********************************************************************/
static void EncodeData(Ncol, R, G, B)
                  int  Ncol;
             float *R,*G,*B;
{
  int    i, k, x, y, disp, Code, K, r, g, b;
  long   CodeK, Npix;
  char   **q,*js;
  int    FreeCode, CurCodeSize, CurMaxCode;
  byte   *ScLine;

  long   HashTab [HSIZE];                       /* hash table */
  int    CodeTab [HSIZE];                       /* code table */

  /*   O U T P U T   P A L E T T E   */

  js = s;
  for (k=0; k<Ncol; k++) {
    r =  R[k] * 256.; r = MAX(r,0); r = MIN(r,255);
    g =  G[k] * 256.; g = MAX(g,0); g = MIN(g,255);
    b =  B[k] * 256.; b = MAX(b,0); b = MIN(b,255);
    sprintf(js,"%02x%02x%02x",r,g,b);
    js += 6;
    if (k % 10 == 9) {
      put_string; js = s;
    }else{
      sprintf(js++," ");
    }
  }
  for (k=Ncol; k<256; k++) {
    sprintf(js,"000000");
    js += 6;
    if (k % 10 == 9) {
      put_string; js = s;
    }else{
      sprintf(js++," ");
    }
  }
  put_string;

  /*   L W Z   C O M P R E S S I O N   */

  PutCode(-1, 0);
  FreeCode    = CLEARCODE + 2;
  CurCodeSize = 9;
  CurMaxCode  = 511;
  memset((char *) HashTab, -1, sizeof(HashTab));
  PutCode(CLEARCODE, CurCodeSize);              /* 1st - clear code */
  Npix = 0;
  for (y=0; y<Ny; y++) {
    ScLine = Zimg + (Ny-1-y)*Nx;
    x     = 0;
    if (y == 0) Code  = ScLine[x++];
    while(x < Nx) {
      K     = ScLine[x++];                      /* next symbol */
      Npix++;
      CodeK = ((long) K << BITS) + Code;        /* set full code */
      k     = (K << SHIFT) ^ Code;              /* xor hashing */

      if (HashTab[k] == CodeK) {                /* full code found */
        Code = CodeTab[k];
        continue;
      }
      else if (HashTab[k] < 0 )                 /* empty slot */
        goto NOMATCH;

      disp  = HSIZE - k;                        /* secondary hash */
      if (k == 0) disp = 1;

PROBE:
      if ((k -= disp) < 0)
        k  += HSIZE;

      if (HashTab[k] == CodeK) {                /* full code found */
        Code = CodeTab[k];
        continue;
      }

      if (HashTab[k] > 0)                       /* try again */
        goto PROBE;

NOMATCH:                                        /* full code not found */
      PutCode(Code, CurCodeSize);
      Code = K;
      if (FreeCode == CurMaxCode) {
        CurCodeSize++;
        CurMaxCode = CurMaxCode*2 + 1;
      }

      if (CurCodeSize <= BITS && Npix <= PIXS) {
        CodeTab[k] = FreeCode++;                /* code -> hashtable */
        HashTab[k] = CodeK;
      }else{
        if (CurCodeSize > BITS) CurCodeSize = BITS;
        PutCode(CLEARCODE, CurCodeSize);
        memset((char *) HashTab, -1, sizeof(HashTab));
        FreeCode    = CLEARCODE + 2;
        CurCodeSize = 9;
        CurMaxCode  = 511;
        Npix = 0;
      }
    }
  }
   /*   O U T P U T   T H E   R E S T  */

  PutCode(Code, CurCodeSize);
  if (FreeCode == CurMaxCode && CurCodeSize != BITS)
    CurCodeSize++;
  PutCode(EOD, CurCodeSize);
  sprintf(s,"~>");                              put_string;
}

/***********************************************************************
 *                                                                     *
 * Name: Zbuf_PostScript                             Date:    26.11.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Function: Output LZW compressed Z-buffer image to PostScript        *
 *                                                                     *
 * Input: IFGRAY   - gray flag: set it when grayscale image is needed  *
 *        IFROTATE - rotation flag: set it for landscape mode          *
 *        XMIN,YMIN,XMAX,YMAX - image dimensions on page (in PS points)*
 *        NCOL     - number of colours                                 *
 *        R[]      - red components                                    *
 *        G[]      - green components                                  *
 *        B[]      - blue components                                   *
 *                                                                     *
 ***********************************************************************/
void Zbuf_PostScript(IFGRAY,IFROTATE,XMIN,YMIN,XMAX,YMAX,NCOL,R,G,B)
                 int IFGRAY,IFROTATE,XMIN,YMIN,XMAX,YMAX,NCOL;
               float *R,*G,*B;
{
  char       **q;

  static char *HeaderEPS[] = {
    "%***********************************************************************",
    "%*                                                                     *",
    "%* Function: Display a Lempel-Ziv Welch (LZW) encoded color image.     *",
    "%*           This is an Encapsulated PostScript file suitable for any  *",
    "%            kind of PostScript printer: Level I/II, color/grayscale...*",
    "%*                                                                     *",
    "%* Author: Evgeni CHERNYAEV (chernaev@vxcern.cern.ch)                  *",
    "%*                                                                     *",
    "%***********************************************************************",
    "gsave",
    "%***********************************************************************",
    "%*                              Image Description                      *",
    "%***********************************************************************",
    NULL,
  };

  static char *CommonPart[] = {
    "/IfColor systemdict /colorimage known {true} {false} ifelse def",
    "GRAYneeded {/IfColor false def} if",
    "/IfLevel2 systemdict /filter known systemdict /setcolorspace known and",
    "  {true} {false} ifelse def",
    "%***********************************************************************",
    "%                               Procedures                             *",
    "%***********************************************************************",
    "userdict /Table known not userdict /StrArray known not or",
    "{/Table 4096 array def /StrArray 10 array def} if",
    "/InLine 71 string def",
    "/BinCodes 112 string def",
    "/CurBit 0 def /FreeCode 258 def /CurCodeSize 9 def /CurMask 511 def",
    "/incr IfColor {3} {1} ifelse def",
    "IfLevel2 not {/setcolorspace null def /filter null def} if",
    "%***********************************************************************",
    "/ReadLine {                     % Read Next Data Line (ASCII85 decode) *",
    "%***********************************************************************",
    "  BinCodes 0 BinCodes 56 56 getinterval putinterval",
    "  currentfile InLine readline pop pop",
    "  InLine 0 get 255 and 32 eq {/kk 1 def} {/kk 0 def} ifelse",
    "  1 1 14 {",
    "    /i exch 1 sub def",
    "    /k i 5 mul kk add def",
    "    /c1 InLine k get 33 sub 255 and def",
    "    /rest c1 1868977 mul",
    "      InLine k 1 add get 33 sub 255 and 614125 mul add",
    "      InLine k 2 add get 33 sub 255 and 7225 mul add",
    "      InLine k 3 add get 33 sub 255 and 85 mul add",
    "      InLine k 4 add get 33 sub 255 and add def",
    "    /k i 4 mul 56 add def",
    "    BinCodes k c1 3 mul rest 16777216 idiv add 255 and put",
    "    /rest rest 16777216 mod def",
    "    BinCodes k 1 add rest 65536 idiv put",
    "    BinCodes k 2 add rest 256 idiv 255 and put",
    "    BinCodes k 3 add rest 255 and put",
    "  } for",
    "} bind def",
    "%***********************************************************************",
    "/ReadCode {                     % Read next code                       *",
    "%***********************************************************************",
    "  /CurByte CurBit 8 idiv def",
    "  /CurCode",
    "    BinCodes CurByte get 8 bitshift",
    "    BinCodes CurByte 1 add get add 8 bitshift",
    "    BinCodes CurByte 2 add get add",
    "    CurCodeSize CurBit 7 and add 24 sub bitshift CurMask and def",
    "  /CurBit CurBit CurCodeSize add dup 448 ge {ReadLine 448 sub} if def",
    "} bind def",
    "%***********************************************************************",
    "/DecodeCode {                   % Decode CurCode                       *",
    "%***********************************************************************",
    "  ReadCode CurCode 256 eq {",
    "    /FreeCode 258 def /CurCodeSize 9 def /CurMask 511 def",
    "    /StrInd -1 def /Lrest 0 def ReadCode",
    "  }{",
    "    L Lrest gt {",
    "      /StrInd StrInd 1 add def /Lrest 65535 def",
    "      StrArray StrInd get null eq {StrArray StrInd 65535 string put} if",
    "      /CurStr StrArray StrInd get def",
    "    } if",
    "    Table FreeCode CurStr 65535 Lrest sub L getinterval",
    "    dup 0 Table OldCode get putinterval",
    "    dup L incr sub Table",
    "      CurCode FreeCode lt {CurCode} {OldCode} ifelse get",
    "    0 incr getinterval putinterval put",
    "    /Lrest Lrest L sub def /FreeCode FreeCode 1 add def",
    "    FreeCode CurMask ge CurCodeSize 12 lt and {",
    "      /CurCodeSize CurCodeSize 1 add def",
    "      /CurMask CurMask 1 bitshift 1 add def",
    "    } if",
    "  } ifelse",
    "  /OldCode CurCode def",
    "  Table CurCode get dup length incr add /L exch def",
    "} bind def",
    "%***********************************************************************",
    "/DisplayImage {          % Display a LZW-encoded color image           *",
    "%***********************************************************************",
    "  /DelX Xmax Xmin sub def",
    "  /DelY Ymax Ymin sub def",
    "  Xmin Ymin translate",
    "  DelX DelY scale",
    "  /Palette currentfile 768 string readhexstring pop def",
    "  currentfile InLine readline pop pop",
    "  IfColor not {",
    "    0 1 255 {",
    "      Palette exch dup /i exch 3 mul def",
    "      Palette i 0 add get 0.299 mul",
    "      Palette i 1 add get 0.587 mul add",
    "      Palette i 2 add get 0.114 mul add cvi put",
    "    } for",
    "    /Palette Palette 0 256 getinterval def",
    "  } if",
    "  /Matr IfRotate",
    "    {[0 colomns rows 0 0 0]} {[colomns 0 0 rows neg 0 rows]} ifelse def",
    "  IfLevel2 {",
    "    [/Indexed IfColor {/DeviceRGB} {/DeviceGray} ifelse 255 Palette]",
    "    setcolorspace",
    "    /infile currentfile /ASCII85Decode filter /LZWDecode filter def",
    "    8 dict",
    "    dup /ImageType 1 put",
    "    dup /Width colomns put",
    "    dup /Height rows put",
    "    dup /BitsPerComponent 8 put",
    "    dup /ImageMatrix Matr put",
    "    dup /Interpolate false put",
    "    dup /Decode [0 255] put",
    "    dup /DataSource infile put image",
    "  }{",
    "    0 1 255 {",
    "      Table exch dup incr mul Palette exch incr getinterval put",
    "    } for",
    "    ReadLine ReadLine",
    "    colomns rows 8 Matr {DecodeCode}",
    "    IfColor {false 3 colorimage} {image} ifelse",
    "  } ifelse",
    "} bind def",
    "%***********************************************************************",
    "%*                              Image decoding                         *",
    "%***********************************************************************",
    "DisplayImage",
    NULL,
  };

  /*   C H E C K   P A R A M E T E R S   */

  if (!Zstat) return;
  if (NCOL <= 0 || NCOL > 256) {
    fprintf(stderr,"Zbuf_PostScript: wrong number of colors: %d\n",NCOL);
    return;
  }

  /*   O U T P U T   H E A D E R   */

  for (q=HeaderEPS;*q; q++) {
    sprintf(s,"%s",*q);                                 put_string;
  }

  /*  I M A G E   D E S C R I P T I O N   */

  sprintf(s,"/colomns %d def /rows %d def",Nx,Ny);      put_string;

  if (IFGRAY) {
    sprintf(s,"/GRAYneeded true def");                  put_string;
  }else{
    sprintf(s,"/GRAYneeded false def");                 put_string;
  }
  if (IFROTATE) {
    sprintf(s,"/IfRotate true def");                    put_string;
  }else{
    sprintf(s,"/IfRotate false def");                   put_string;
  }
  sprintf(s,"/Xmin %d def /Ymin %d def /Xmax %d def /Ymax %d def",
             XMIN,YMIN,XMAX,YMAX);                      put_string;

  /*   O U T P U T   P O S T S C R I P T   C O D E  */

  for (q=CommonPart; *q; q++) {
    sprintf(s,"%s",*q);                                 put_string;
  }

  /*   O U T P U T   E N C O D E D   D A T A   */

  EncodeData(NCOL, R, G, B);

  sprintf(s,"grestore");                                put_string;
}

/***********************************************************************
 *                                                                     *
 *  M A I N   R O U T I N E S   -   F O R T R A N   I N T E R F A C E  *
 *                                                                     *
 ***********************************************************************
 *                                                                     *
 * Name: FORTRAN interface routines                  Date:    15.11.95 *
 * Author: E.Chernyaev (IHEP/Protvino)               Revised:          *
 *                                                                     *
 * Contents: IREP=IHZINI(NX,NY,NZ)                                     *
 *           CALL IHZCLE(ICOL)                                         *
 *           CALL IHZCLI(XMIN,YMIN,XMAX,YMAX)                          *
 *           CALL IHZWRD(XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX)                *
 *           CALL IHZPNT(ICOL,X,Y,Z)                                   *
 *           CALL IHZLIN(ICOL,X1,Y1,Z1,X2,Y2,Z2)                       *
 *           CALL IHZFIL(ICOL,N,X,Y,Z)                                 *
 *           CALL IHZSPE(NL,FMIN,FMAX,ICOL)                            *
 *           CALL IHZSHA(N,X,Y,Z,F)                                    *
 *           CALL IHZTOX(X0,Y0)                                        *
 *           CALL IHZPRN()                                             *
 *           CALL IHZPS(IFGRAY,IFROTATE,XMIN,YMIN,XMAX,YMAX,NCOL,R,G,B)*
 *                                                                     *
 ***********************************************************************/
int type_of_call ihzini(NX, NY, NZ)
      int *NX,*NY,*NZ;
{ return Zbuf_Init(*NX,*NY,*NZ); }

void  type_of_call ihzcle(ICOL)
       int *ICOL;
{ Zbuf_Clear(*ICOL); }

void  type_of_call ihzcli(XMIN, YMIN, XMAX, YMAX)
       int *XMIN,*YMIN,*XMAX,*YMAX;
{ Zbuf_Clip(*XMIN,*YMIN,*XMAX,*YMAX);}

void  type_of_call ihzwrd(XMIN, YMIN, ZMIN, XMAX, YMAX, ZMAX)
     float *XMIN,*YMIN,*ZMIN,*XMAX,*YMAX,*ZMAX;
{ Zbuf_World(*XMIN,*YMIN,*ZMIN,*XMAX,*YMAX,*ZMAX); }

void  type_of_call ihzpnt(ICOL, X, Y, Z)
       int *ICOL;
     float *X,*Y,*Z;
{ Zbuf_Point(*ICOL,*X,*Y,*Z); }

void  type_of_call ihzlin(ICOL, X1, Y1, Z1, X2, Y2, Z2)
       int *ICOL;
     float *X1,*Y1,*Z1,*X2,*Y2,*Z2;
{ Zbuf_Line(*ICOL,*X1,*Y1,*Z1,*X2,*Y2,*Z2); }

void  type_of_call ihzfil(ICOL, N, X, Y, Z)
       int *ICOL,*N;
     float *X,*Y,*Z;
{ Zbuf_Fill(*ICOL,*N, X, Y, Z); }

void  type_of_call ihzspe(NL, FMIN, FMAX, ICOL)
       int *NL,*ICOL;
     float *FMIN,*FMAX;
{ Zbuf_Spectr(*NL,*FMIN,*FMAX,*ICOL); }

void  type_of_call ihzsha(N, X, Y, Z, F)
       int *N;
     float *X,*Y,*Z,*F;
{ Zbuf_Shade(*N, X, Y, Z, F); }

void  type_of_call ihztox(IBACK, X0, Y0)
       int *IBACK,*X0,*Y0;
{ Zbuf_XFlush(*IBACK,*X0,*Y0); }

void ihzprn()
{ Zbuf_Print(); }

void  type_of_call ihzps(IFGRAY, IFROTATE, XMIN, YMIN, XMAX, YMAX, NCOL, R, G, B)
      int *IFGRAY,*IFROTATE,*XMIN,*YMIN,*XMAX,*YMAX,*NCOL;
    float *R,*G,*B;
{ Zbuf_PostScript(*IFGRAY,*IFROTATE,*XMIN,*YMIN,*XMAX,*YMAX,*NCOL, R, G, B); }

/*    E N D   O F   Z - B U F F E R*/
+SELF.
+PATCH, GED.
+DECK,  IMAKEFILE_DGKS_D, T=DATA, IF=DOC.
SRCS_F=	iealpt.F iearc.F iearro.F ieaxis.F iebox.F iecpa.F \ @@\
	iedele.F iefa.F iefbox.F iegrid.F iemaca.F iemaxa.F iemboa.F \ @@\
	iemfaa.F iemfba.F iemhia.F iemopr.F iempla.F iempma.F iemsta.F \ @@\
	iemtxa.F iepave.F iepl.F iepm.F iepop.F iestx.F ietx.F iewin.F \ @@\
	igbord.F igccol.F igcfai.F igclwn.F igex.F igfirs.F iggrid.F \ @@\
	igicol.F igifai.F iginme.F igline.F igplot.F igreq.F izged.F \ @@\
	izpick.F izpiwi.F izpkfa.F izpkpl.F izundo.F

SubdirExtraLibraryTarget(NullParameter,NullParameter,NullParameter,dgks)

VersionFortranObjectRule(dgks,NullParameter,-DCERNLIB_DECGKS)

BuildNamedMakefileTarget(Makefile.dgks,Imakefile.dgks,-DCERNLIB_DECGKS)
+DECK,  IEALPT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE IEALPT(X,Y)
*.===========>
*.
*. Align couple of point if they are very close in X or Y
*.
*..==========> (O.Couet)
+CDE, HIATT.
      PARAMETER (RALGN=0.008)
      DIMENSION X(*),Y(*)
*.______________________________________
*
      DX=(RWXMAX-RWXMIN)*RALGN
      DY=(RWYMAX-RWYMIN)*RALGN
      IF(ABS(X(2)-X(1)).LT.DX)THEN
         X(2)=X(1)
      ENDIF
      IF(ABS(Y(2)-Y(1)).LT.DY)THEN
         Y(2)=Y(1)
      ENDIF
*
      END
+DECK,  IEARC, T=FORT.
* Revision 1.2  1996/09/25 14:56:58  couet
* - GPR driver removed
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE IEARC(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
+CDE, HILOC.
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
   10 IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 10
*
   20 X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      XN=RQUEST(11)
      YN=RQUEST(12)
      NTLOC=IQUEST(10)
*
      IF(IPLACE.EQ.3)GOTO 10
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(ICHOIC.EQ.-1)THEN
         CALL IEMACA(IPLACE,ICHOIC)
         GOTO 20
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 10
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 10
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      CALL IGPLOT(X(1),Y(1))
+SELF, IF=GL,X11.
   30 CALL IGLOC(31,NTLOC,IBN,XNDC,YNDC,X(2),Y(2))
+SELF, IF=-GL, IF=-X11.
   30 CALL IGLOC(41,NTLOC,IBN,XNDC,YNDC,X(2),Y(2))
+SELF.
      IF(IBN.EQ.0)GOTO 10
      CALL IGGRID(X(2),Y(2))
      CALL IEALPT(X(1),Y(1))
      OLDXP=XN
      OLDYP=YN
      IF(NTLOC.NE.INTR)GOTO 30
      CALL IGPLOT(X(2),Y(2))
   40 CALL IGLOC(41,NTLOC,IBN,XNDC,YNDC,X(3),Y(3))
      IF(IBN.EQ.0)THEN
         XC=X(1)
         YC=Y(1)
         R1=SQRT((X(2)-X(1))**2+(Y(2)-Y(1))**2)
         R2=R1
         PHIMIN=0.
         PHIMAX=0.
         GOTO 60
      ELSE
         CALL IGGRID(X(3),Y(3))
         CALL IEALPT(X(2),Y(2))
         OLDXP=XN
         OLDYP=YN
      ENDIF
      IF(NTLOC.NE.INTR)GOTO 40
      CALL IGPLOT(X(3),Y(3))
*
   50 CALL IGLOC(31,NTLOC,IBN,XNDC,YNDC,X(4),Y(4))
      IF(IBN.EQ.0)THEN
         XC=X(1)
         YC=Y(1)
         R1=SQRT((X(2)-X(1))**2+(Y(2)-Y(1))**2)
         R2=R1
         R3=SQRT((X(3)-X(1))**2+(Y(3)-Y(1))**2)
         DELTA = Y(2) - Y(1)
         IF (DELTA .NE. 0) THEN
           DELTA = SIGN(MIN(1.0,ABS(DELTA/R1)),DELTA)
           PHIMIN=(ASIN(DELTA)*180.)/3.1415926
           IF(X(2).LT.X(1)) THEN
             PHIMIN=180-PHIMIN
           ELSE IF(Y(2).LT.Y(1)) THEN
             PHIMIN=PHIMIN+360
           END IF
         ELSE
           PHIMIN = 0.0
         END IF
*
         DELTA = Y(3) - Y(1)
         IF (DELTA .NE. 0) THEN
           DELTA = SIGN(MIN(1.0,ABS(DELTA/R3)),DELTA)
           PHIMAX=(ASIN(DELTA)*180.)/3.1415926
           IF(X(3).LT.X(1)) THEN
             PHIMAX=180-PHIMAX
           ELSE IF(Y(3).LT.Y(1)) THEN
             PHIMAX=PHIMAX+360
           END IF
         ELSE
           PHIMAX = 0.0
         END IF
         GOTO 60
      ELSE
         XC=X(1)
         YC=Y(1)
         R1=SQRT((X(2)-X(1))**2+(Y(2)-Y(1))**2)
         R2=SQRT((X(4)-X(1))**2+(Y(4)-Y(1))**2)
         R3=SQRT((X(3)-X(1))**2+(Y(3)-Y(1))**2)
         DELTA = Y(2) - Y(1)
         IF (DELTA .NE. 0) THEN
           DELTA = SIGN(MIN(1.0,ABS(DELTA/R1)),DELTA)
           PHIMIN=(ASIN(DELTA)*180.)/3.1415926
           IF(X(2).LT.X(1)) THEN
             PHIMIN=180-PHIMIN
           ELSE IF(Y(2).LT.Y(1)) THEN
             PHIMIN=PHIMIN+360
           END IF
         ELSE
           PHIMIN = 0.0
         END IF
*
         DELTA = Y(3) - Y(1)
         IF (DELTA .NE. 0) THEN
           DELTA = SIGN(MIN(1.0,ABS(DELTA/R3)),DELTA)
           PHIMAX=(ASIN(DELTA)*180.)/3.1415926
           IF(X(3).LT.X(1)) THEN
             PHIMAX=180-PHIMAX
           ELSE IF(Y(3).LT.Y(1)) THEN
             PHIMAX=PHIMAX+360
           END IF
         ELSE
           PHIMAX = 0.0
         END IF
         CALL IGGRID(X(4),Y(4))
      ENDIF
*
   60 CALL ISFAIS(ICACFI)
      CALL ISFASI(ICACFS)
      CALL ISFACI(ICACFC)
      CALL ISPLCI(ICACLC)
      CALL IGSET('BORD',FLOAT(ICACBO))
      CALL IGARC(XC,YC,R1,R2,PHIMIN,PHIMAX)
      GOTO 10
*
      END
+DECK,  IEARRO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE IEARRO(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*32 CHVAL(15)
      CHARACTER*12 CHTEMP
      DIMENSION UU(3),VV(3),UU1(3),VV1(3)
*.______________________________________
*
      ICHOIO=0
   10 IPLACE=2
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      NTSAV=INTR
      CALL ISELNT(1)
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 10
*
   20 X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      CALL IGGRID(X(1),Y(1))
      NTLOC=IQUEST(10)
*
   40 IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         CALL ISELNT(NTSAV)
         RETURN
      ENDIF
*
      IF(IPLACE.EQ.3)GOTO 10
*
      IF(ICHOIC.EQ.-1)THEN
         TITLE(3)='ARROW ATTRIBUTES'
         CHITEM(1,3)='Arrow size'
         CHITEM(2,3)='Double arrow'
         CHITEM(3,3)='Filled arrow'
         CHITEM(4,3)='Fill area color'
         CHITEM(5,3)='Line color'
         CHITEM(6,3)='Fill interior style'
         CHITEM(7,3)='Fill style index'
         CHITEM(8,3)='Line type'
         CALL IZRTOC(RCARSI,CHDEF(1))
         CHDEF(2)=CHDOAR
         CHDEF(3)=CHAFL
         CHDEF(4)=CHARFC
         CHDEF(5)=CHARLC
         CHDEF(6)=CHARFI
         CALL IZITOC(ICARFS,CHDEF(7))
         CALL IZITOC(ICARLN,CHDEF(8))
         IPLACE=3
         CALL ISELNT(1)
         CALL IGREQ(299,0,8,IPLACE,ICHOIC,CHVAL)
         ICHOIO=ICHOIC
         ICF=IPLACE
         CALL IZCTOR(CHVAL(1),RCARSI)
         CALL IGFIRS(CHDOAR,CHVAL(2))
         CALL IGFIRS(CHAFL,CHVAL(3))
         CALL IGFIRS(CHARFC,CHVAL(4))
         CALL IGFIRS(CHARLC,CHVAL(5))
         CALL IGFIRS(CHARFI,CHVAL(6))
         ICARFC=IGICOL(CHVAL(4))
         ICARLC=IGICOL(CHVAL(5))
         ICARFI=IGIFAI(CHVAL(6))
         CHTEMP=CHVAL(7)
         CALL IZCTOI(CHTEMP,ICARFS)
         CHTEMP=CHVAL(8)
         CALL IZCTOI(CHTEMP,ICARLN)
         GOTO 20
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 10
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 10
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         CALL ISELNT(NTSAV)
         RETURN
      ENDIF
*
      I=2
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      IF(NTLOC.NE.1)THEN
         I=1
      ENDIF
      CALL ISELNT(1)
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL IGPLOT(X(1),Y(1))
   50 CALL IGLOC(41,NTLOC,IBN,XNDC,YNDC,X(I),Y(I))
      IF(IBN.EQ.1)THEN
         IF(NTLOC.NE.1)GOTO 50
         IF(I.EQ.1)GOTO 51
         CALL IGGRID(X(I),Y(I))
         CALL IEALPT(X(I-1),Y(I-1))
         CALL IGLINE(X(I-1),X(I),Y(I-1),Y(I))
   51    I=I+1
         GOTO 50
      ENDIF
*
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IZSAV
      CALL ISPLCI(0)
      CALL ISLN(1)
      CALL IPL(I-1,X,Y)
      CALL IZSET
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISPLCI(ICARLC)
      CALL ISFACI(ICARFC)
      CALL ISFAIS(ICARFI)
      CALL ISFASI(ICARFS)
      CALL ISLN(ICARLN)
      IF(RCARSI.LE.0.)GOTO 10
      TGAR=0.6
      FSIN=0.
      FCOS=1.
      XL=SQRT((X(I-1)-X(I-2))**2 + (Y(I-1)-Y(I-2))**2)
      IF(XL.GT.0.)THEN
         FSIN=(Y(I-1)-Y(I-2))/XL
         FCOS=(X(I-1)-X(I-2))/XL
      ENDIF
      UU(1)=X(I-2)+(XL-RCARSI)*FCOS-RCARSI*TGAR*FSIN
      UU(3)=X(I-2)+(XL-RCARSI)*FCOS+RCARSI*TGAR*FSIN
      VV(1)=Y(I-2)+(XL-RCARSI)*FSIN+RCARSI*TGAR*FCOS
      VV(3)=Y(I-2)+(XL-RCARSI)*FSIN-RCARSI*TGAR*FCOS
      UU(2)=X(I-1)
      VV(2)=Y(I-1)
      IF(INDEX(CHVAL(3),'Y').NE.0)THEN
         CALL IFA(3,UU,VV)
      ELSE
         CALL IPL(3,UU,VV)
      ENDIF
      IF(INDEX(CHVAL(2),'Y').NE.0)THEN
         TGAR=0.6
         FSIN=0.
         FCOS=1.
         XL=SQRT((X(1)-X(2))**2 + (Y(1)-Y(2))**2)
         IF(XL.GT.0.)THEN
            FSIN=(Y(1)-Y(2))/XL
            FCOS=(X(1)-X(2))/XL
         ENDIF
         UU1(1)=X(2)+(XL-RCARSI)*FCOS-RCARSI*TGAR*FSIN
         UU1(3)=X(2)+(XL-RCARSI)*FCOS+RCARSI*TGAR*FSIN
         VV1(1)=Y(2)+(XL-RCARSI)*FSIN+RCARSI*TGAR*FCOS
         VV1(3)=Y(2)+(XL-RCARSI)*FSIN-RCARSI*TGAR*FCOS
         UU1(2)=X(1)
         VV1(2)=Y(1)
         IF(INDEX(CHVAL(3),'Y').NE.0)THEN
            CALL IFA(3,UU1,VV1)
         ELSE
            CALL IPL(3,UU1,VV1)
         ENDIF
      ENDIF
      IF(INDEX(CHVAL(3),'Y').NE.0)THEN
         X(I-1)=(UU(3)+UU(1))/2.
         Y(I-1)=(VV(3)+VV(1))/2.
         IF(INDEX(CHVAL(2),'Y').NE.0)THEN
            X(1)=(UU1(3)+UU1(1))/2.
            Y(1)=(VV1(3)+VV1(1))/2.
         ENDIF
      ENDIF
      CALL IPL(I-1,X,Y)
   70 CONTINUE
      GOTO 10
*
      END
+DECK,  IEAXIS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE IEAXIS(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
 201  IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 201
*
 203  X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      NTLOC=IQUEST(10)
*
      IF(IPLACE.EQ.3)GOTO 201
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(ICHOIC.EQ.-1)THEN
         CALL IEMAXA(IPLACE,ICHOIC)
         GOTO 203
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 201
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 201
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      CALL IGPLOT(X(1),Y(1))
      CALL IGLOC(41,NTLOC,IBN,XNDC,YNDC,X(2),Y(2))
      IF(IBN.EQ.1)THEN
         IF(NTLOC.NE.INTR)GOTO 202
         CALL IGGRID(X(2),Y(2))
         CALL IEALPT(X,Y)
         CALL IGLINE(X(1),X(2),Y(1),Y(2))
         GOTO 202
      ELSE
         GOTO 201
      ENDIF
*
 202  ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL IZSAV
      CALL ISPLCI(0)
      CALL ISLN(1)
      CALL IPL(2,X,Y)
      CALL IZSET
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NTLOC)
      CALL IGSET('TMSI',RCAXTS)
      CALL IGSET('LASI',RCAXLS)
      CALL IGSET('LAOF',RCAXLO)
      CALL ISLN(ICAXLN)
      CALL ISPLCI(ICAXLC)
      CALL ISTXFP(ICAXLF,ICAXLP)
      CALL IGAXIS(X(1),X(2),Y(1),Y(2),RCAXW1,RCAXW2,ICAXND,CHOPAX)
      GOTO 201
*
      END
+DECK,  IEBOX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE IEBOX(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
 201  IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 201
*
 203  X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      NTLOC=IQUEST(10)
*
      IF(IPLACE.EQ.3)GOTO 201
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(ICHOIC.EQ.-1)THEN
         CALL IEMBOA(IPLACE,ICHOIC)
         GOTO 203
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 201
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 201
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL IGPLOT(X(1),Y(1))
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
 202  CALL IGLOC(51,NTLOC,IBN,XNDC,YNDC,X(2),Y(2))
      IF(NTLOC.NE.INTR)GOTO 202
      CALL IGGRID(X(2),Y(2))
      CALL ISFAIS(ICBOIS)
      CALL ISFASI(ICBOSI)
      CALL ISFACI(ICBOCI)
      CALL IGSET('BORD',FLOAT(ICBOBO))
      CALL IGBOX(X(1),X(2),Y(1),Y(2))
      GOTO 201
*
      END
+DECK,  IECPA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IECPA(ICF,ICHOIO)
*.===========>
*.
*. Change the attributes of an existing primitive
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIGED.
+CDE, HIACA.
+CDE, HIFLAG.
+CDE, HICODE.
      DIMENSION IOPT(30)
      LOGICAL CHOFLA
      CHARACTER*8 SNAME
      CHARACTER*16 CHVALL
      CHARACTER*1 CHAXIS(22),CHHIST(14),CHTEXT(3)
      CHARACTER*80 STR
      CHARACTER*4 CHVAL(15)
      DATA CHAXIS /'G','B','A','V','+','-','U','P','O'
     +,            'R','L','C','=','.','H','D','Y','T'
     +,            'W','S','N','I'/
      DATA CHHIST /'H','F','C','*','R','1','B','N','L'
     +,            'P','A','G','X','Y'/
      DATA CHTEXT /'L','C','R'/
*.______________________________________
*
      ICHOIO=0
   10 IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(IPLACE.EQ.3)GOTO 10
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
      IF(ICHOIC.EQ.-1000)GOTO 10
      IF(ICHOIC.EQ.-1)GOTO 10
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 10
      ENDIF
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 10
      ENDIF
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CHOFLA=.FALSE.
      ICHOPT=0
      CALL IZPICK(NT,SNAME,NPRIM,'N')
      IF(NPRIM.LE.0)GOTO 90
      LN=IZGNTP(NT)
      IF(LN.EQ.0)GOTO 90
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NT)
      IDIAA=IZGADR(LHNT,8)
      IDRAA=IZGADR(LHNT,9)
*
      IPRICO=ABS(IZGCOD(LHNT,NPRIM))
      IF(IPRICO.EQ.IFACO)THEN
         CALL IZSCAN(LHNT,IFAICO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICFAIS=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICFAIS=IQ(LHI+IDIAA+IFAICO-80)
         ENDIF
         CALL IGCFAI(ICFAIS,CHVALL)
         CALL IGFIRS(CHFAIS,CHVALL)
         CALL IZSCAN(LHNT,IFASCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICFASI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICFASI=IQ(LHI+IDIAA+IFASCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IFACCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICFACI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICFACI=IQ(LHI+IDIAA+IFACCO-80)
         ENDIF
         CALL IGCCOL(ICFACI,CHVALL)
         CALL IGFIRS(CHFAC,CHVALL)
         CALL IEMFAA(IPLACE,ICHOIO)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
*
      ELSEIF(IPRICO.EQ.IARCCO)THEN
         CALL IZSCAN(LHNT,IFAICO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICACFI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICACFI=IQ(LHI+IDIAA+IFAICO-80)
         ENDIF
         CALL IGCFAI(ICACFI,CHVALL)
         CALL IGFIRS(CHACIS,CHVALL)
         CALL IZSCAN(LHNT,IFASCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICACFS=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICACFS=IQ(LHI+IDIAA+IFASCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IFACCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICACFC=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICACFC=IQ(LHI+IDIAA+IFACCO-80)
         ENDIF
         CALL IGCCOL(ICACFC,CHVALL)
         CALL IGFIRS(CHACFC,CHVALL)
         CALL IZSCAN(LHNT,IPLCCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICACLC=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICACLC=IQ(LHI+IDIAA+IPLCCO-80)
         ENDIF
         CALL IGCCOL(ICACLC,CHVALL)
         CALL IGFIRS(CHACLC,CHVALL)
         CALL IZSCAN(LHNT,IBORCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICACBO=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICACBO=IQ(LHI+IDIAA+IBORCO-80)
         ENDIF
         IF(ICACBO.EQ.1)THEN
            CHACBO='Yes,No'
         ELSE
            CHACBO='No,Yes'
         ENDIF
         CALL IEMACA(IPLACE,ICHOIO)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(IBORCO,1)
*
      ELSEIF(IPRICO.EQ.IAXICO)THEN
         CALL IZSCAN(LHNT,IPLCCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICAXLC=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICAXLC=IQ(LHI+IDIAA+IPLCCO-80)
         ENDIF
         CALL IGCCOL(ICAXLC,CHVALL)
         CALL IGFIRS(CHAXLC,CHVALL)
         CALL IZSCAN(LHNT,ILNCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICAXLN=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICAXLN=IQ(LHI+IDIAA+ILNCO-80)
         ENDIF
         CALL IZSCAN(LHNT,ITMSCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCAXTS=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCAXTS=Q(LHF+IDRAA+ITMSCO-50)
         ENDIF
         CALL IZSCAN(LHNT,IALHCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCAXLS=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCAXLS=Q(LHF+IDRAA+IALHCO-50)
         ENDIF
         CALL IZSCAN(LHNT,IALDCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCAXLO=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCAXLO=Q(LHF+IDRAA+IALDCO-50)
         ENDIF
         CALL IZSCAN(LHNT,ITXFCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            IFPTEM=IZGADR(LHNT,IPOS)-100000
         ELSE
            IFPTEM=IQ(LHI+IDIAA+ITXFCO-80)
         ENDIF
         ICAXLF=INT(IFPTEM/10)
         ICAXLP=MOD(IFPTEM,10)
         ICHOPT=IACHOP
         STR=' '
         DO 20  I=1,22
            IF(JBIT(ICHOPT,I).NE.0)THEN
               CHOPAX=CHAXIS(I)//STR
               STR=CHOPAX
            ENDIF
   20    CONTINUE
         CALL IEMAXA(IPLACE,ICHOIO)
         CALL UOPTC(CHOPAX,'GBAV+-UPORLC=.HDYTWSNI',IOPT)
         DO 30  I=1,22
            IF(IOPT(I).NE.0)CALL SBIT1(ICHOPT,I)
   30    CONTINUE
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(ITMSCO,1)
         CALL IZCFA(IALHCO,1)
         CALL IZCFA(IALDCO,1)
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(ITXFCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
         CHOFLA=.TRUE.
*
      ELSEIF(IPRICO.EQ.IBXCO)THEN
         CALL IZSCAN(LHNT,IFAICO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICBOIS=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICBOIS=IQ(LHI+IDIAA+IFAICO-80)
         ENDIF
         CALL IGCFAI(ICBOIS,CHVALL)
         CALL IGFIRS(CHBOIS,CHVALL)
         CALL IZSCAN(LHNT,IFASCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICBOSI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICBOSI=IQ(LHI+IDIAA+IFASCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IFACCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICBOCI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICBOCI=IQ(LHI+IDIAA+IFACCO-80)
         ENDIF
         CALL IGCCOL(ICBOCI,CHVALL)
         CALL IGFIRS(CHBOC,CHVALL)
         CALL IZSCAN(LHNT,IBORCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICBOBO=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICBOBO=IQ(LHI+IDIAA+IBORCO-80)
         ENDIF
         CHBOBO='No,Yes'
         IF(ICBOBO.EQ.1)CHBOBO='Yes,No'
         CALL IEMBOA(IPLACE,ICHOIO)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(IBORCO,1)
*
      ELSEIF(IPRICO.EQ.IFBXCO)THEN
         CALL IZSCAN(LHNT,IFAICO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICFBIS=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICFBIS=IQ(LHI+IDIAA+IFAICO-80)
         ENDIF
         CALL IGCFAI(ICFBIS,CHVALL)
         CALL IGFIRS(CHFBIS,CHVALL)
         CALL IZSCAN(LHNT,IFASCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICFBSI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICFBSI=IQ(LHI+IDIAA+IFASCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IFACCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICFBCI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICFBCI=IQ(LHI+IDIAA+IFACCO-80)
         ENDIF
         CALL IGCCOL(ICFBCI,CHVALL)
         CALL IGFIRS(CHFBC,CHVALL)
         CALL IZSCAN(LHNT,IBORCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICFBBO=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICFBBO=IQ(LHI+IDIAA+IBORCO-80)
         ENDIF
         CHFBBO='No,Yes'
         IF(ICFBBO.EQ.1)CHFBBO='Yes,No'
         CALL IEMFBA(IPLACE,ICHOIO)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CALL IZCFA(IBORCO,1)
*
      ELSEIF(IPRICO.EQ.IHISCO)THEN
         CALL IZSCAN(LHNT,IBOFCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCBOF=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCBOF=Q(LHF+IDRAA+IBOFCO-50)
         ENDIF
         CALL IZSCAN(LHNT,IBWDCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCBWD=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCBWD=Q(LHF+IDRAA+IBWDCO-50)
         ENDIF
         CALL IZSCAN(LHNT,ILNCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICHILN=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICHILN=IQ(LHI+IDIAA+ILNCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IPLCCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICHIPC=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICHIPC=IQ(LHI+IDIAA+IPLCCO-80)
         ENDIF
         CALL IGCCOL(ICHIPC,CHVALL)
         CALL IGFIRS(CHHIPC,CHVALL)
         CALL IZSCAN(LHNT,IFAICO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICHIFI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICHIFI=IQ(LHI+IDIAA+IFAICO-80)
         ENDIF
         CALL IGCFAI(ICHIFI,CHVALL)
         CALL IGFIRS(CHHIIS,CHVALL)
         CALL IZSCAN(LHNT,IFASCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICHIFS=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICHIFS=IQ(LHI+IDIAA+IFASCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IFACCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICHIFC=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICHIFC=IQ(LHI+IDIAA+IFACCO-80)
         ENDIF
         CALL IGCCOL(ICHIFC,CHVALL)
         CALL IGFIRS(CHHIFC,CHVALL)
         ICHOPT=IACHOP
         STR=' '
         DO 40 I=1,14
            IF(JBIT(ICHOPT,I).NE.0)THEN
               CHOPHI=CHHIST(I)//STR
               STR=CHOPHI
            ENDIF
   40    CONTINUE
         CALL IEMHIA(IPLACE,ICHOIO)
         CALL UOPTC(CHOPHI,'HFS*R1BNLMA',IOPT)
         DO 50  I=1,11
            IF(IOPT(I).NE.0)CALL SBIT1(ICHOPT,I)
   50    CONTINUE
         CALL IZCFA(IBOFCO,1)
         CALL IZCFA(IBWDCO,1)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
         CALL IZCFA(IFAICO,1)
         CALL IZCFA(IFASCO,1)
         CALL IZCFA(IFACCO,1)
         CHOFLA=.TRUE.
*
      ELSEIF(IPRICO.EQ.IPLCO.OR.IPRICO.EQ.IPL2CO)THEN
         CALL IZSCAN(LHNT,ILNCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICLN=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICLN=IQ(LHI+IDIAA+ILNCO-80)
         ENDIF
         CALL IZSCAN(LHNT,ILWSCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCLWSC=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCLWSC=Q(LHF+IDRAA+ILWSCO-50)
         ENDIF
         CALL IZSCAN(LHNT,IPLCCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICPLCI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICPLCI=IQ(LHI+IDIAA+IPLCCO-80)
         ENDIF
         CALL IGCCOL(ICPLCI,CHVALL)
         CALL IGFIRS(CHPLC,CHVALL)
         CALL IEMPLA(IPLACE,ICHOIO)
         CALL IZCFA(ILNCO,1)
         CALL IZCFA(ILWSCO,1)
         CALL IZCFA(IPLCCO,1)
*
      ELSEIF(IPRICO.EQ.IPMCO.OR.IPRICO.EQ.IPM1CO)THEN
         CALL IZSCAN(LHNT,IMKCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICMK=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICMK=IQ(LHI+IDIAA+IMKCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IMKSCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCMKSC=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCMKSC=Q(LHF+IDRAA+IMKSCO-50)
         ENDIF
         CALL IZSCAN(LHNT,IPMCCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICPMCI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICPMCI=IQ(LHI+IDIAA+IPMCCO-80)
         ENDIF
         CALL IGCCOL(ICPMCI,CHVALL)
         CALL IGFIRS(CHPMC,CHVALL)
         CALL IEMPMA(IPLACE,ICHOIO)
         CALL IZCFA(IMKCO,1)
         CALL IZCFA(IMKSCO,1)
         CALL IZCFA(IPMCCO,1)
*
      ELSEIF(IPRICO.EQ.IGTXCO)THEN
         CALL IZSCAN(LHNT,ITXCCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICSTCI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICSTCI=IQ(LHI+IDIAA+ITXCCO-80)
         ENDIF
         CALL IGCCOL(ICSTCI,CHVALL)
         CALL IGFIRS(CHSTC,CHVALL)
         CALL IZSCAN(LHNT,IGTWCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICSTPA=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICSTPA=IQ(LHI+IDIAA+IGTWCO-80)
         ENDIF
         CALL IZSCAN(LHNT,IGTSCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCSTSH=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCSTSH=Q(LHF+IDRAA+IGTSCO-50)
         ENDIF
         ICHOPT=IACHOP
         STR=' '
         DO 60  I=1,3
            IF(JBIT(ICHOPT,I).NE.0)THEN
               CHOPST=CHTEXT(I)//STR
               STR=CHOPST
            ENDIF
   60    CONTINUE
         CALL IEMSTA(IPLACE,ICHOIO)
         CALL UOPTC(CHOPST,'LCR',IOPT)
         DO 70   I=1,3
            IF(IOPT(I).NE.0)CALL SBIT1(ICHOPT,I)
   70    CONTINUE
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
         CHOFLA=.TRUE.
*
      ELSEIF(IPRICO.EQ.ITXCO)THEN
         CALL IZSCAN(LHNT,ITXCCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ICTXCI=IZGADR(LHNT,IPOS)-100000
         ELSE
            ICTXCI=IQ(LHI+IDIAA+ITXCCO-80)
         ENDIF
         CALL IGCCOL(ICTXCI,CHVALL)
         CALL IGFIRS(CHTXC,CHVALL)
         CALL IZSCAN(LHNT,ICHHCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            RCTXSI=Q(LHF+IZGADR(LHNT,IPOS))
         ELSE
            RCTXSI=Q(LHF+IDRAA+ICHHCO-50)
         ENDIF
         CALL IZSCAN(LHNT,ITXFCO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            IFPTEM=IZGADR(LHNT,IPOS)-100000
         ELSE
            IFPTEM=IQ(LHI+IDIAA+ITXFCO-80)
         ENDIF
         ICTXFT=INT(IFPTEM/10)
         ICTXPR=ABS(MOD(IFPTEM,10))
         CALL IZSCAN(LHNT,ITXACO,IADRAT,-1,IPOS)
         IF(IPOS.NE.0)THEN
            ITATEM=IZGADR(LHNT,IPOS)-100000
         ELSE
            ITATEM=IQ(LHI+IDIAA+ITXACO-80)
         ENDIF
         ICTXAH=INT(ITATEM/10)
         ICTXAV=MOD(ITATEM,10)
         CALL IEMTXA(IPLACE,ICHOIO)
         CALL IZCFA(ITXCCO,1)
         CALL IZCFA(ITXACO,1)
         CALL IZCFA(ICHHCO,1)
         CALL IZCFA(IANGCO,1)
         CALL IZCFA(ITXFCO,1)
         CALL IZCFA(IGTSCO,1)
         CALL IZCFA(IGTWCO,1)
      ENDIF
*
*              Change in the data structure
*
      IF(IQ(LHNT+NPRIM).GT.0)THEN
         IF(CHOFLA)THEN
            IF(IZPUSH(4,0,0,'IECPA').NE.0)GOTO 90
            CALL IZSTCC(INOPCO,INTPTR)
            IQ(LHI+INTPTR)=2
            IQ(LHI+INTPTR+1)=IZGADR(LHNT,NPRIM)
            IQ(LHI+INTPTR+2)=NPRIM
            IQ(LHI+INTPTR+3)=ICHOPT
            CALL IZINCI(4)
            IQ(LHNT+NPRIM)=-(1000000*IZGCOD(LHNT,NPRIM)+ITBPTR-1)
         ELSE
            IF(IZPUSH(3,0,0,'IECPA').NE.0)GOTO 90
            CALL IZSTCC(INOPCO,INTPTR)
            IQ(LHI+INTPTR)=1
            IQ(LHI+INTPTR+1)=IZGADR(LHNT,NPRIM)
            IQ(LHI+INTPTR+2)=NPRIM
            CALL IZINCI(3)
            IQ(LHNT+NPRIM)=-(1000000*IZGCOD(LHNT,NPRIM)+ITBPTR-1)
         ENDIF
      ELSE
         IADRI2=ABS(IZGADR(LHNT,NPRIM))
         IADRI3=IADRI2
   80    IF(IQ(LHNT+IADRI2).LT.0)THEN
            IADRI2=ABS(IZGADR(LHNT,IADRI2))
            IADRI3=IADRI2
            GOTO 80
         ENDIF
         IADRI2=IZGADR(LHNT,IADRI2)
         IF(CHOFLA)THEN
            IF(IZPUSH(4,0,0,'IECPA').NE.0)GOTO 90
            CALL IZSTCC(INOPCO,INTPTR)
            IQ(LHI+INTPTR)=2
            IQ(LHI+INTPTR+1)=IADRI2
            IQ(LHI+INTPTR+2)=IADRI3
            IQ(LHI+INTPTR+3)=ICHOPT
            CALL IZINCI(4)
            IQ(LHNT+IADRI3)=-(1000000*IZGCOD(LHNT,IADRI3)+ITBPTR-1)
         ELSE
            IF(IZPUSH(3,0,0,'IECPA').NE.0)GOTO 90
            CALL IZSTCC(INOPCO,INTPTR)
            IQ(LHI+INTPTR)=1
            IQ(LHI+INTPTR+1)=IADRI2
            IQ(LHI+INTPTR+2)=IADRI3
            CALL IZINCI(3)
            IQ(LHNT+IADRI3)=-(1000000*IZGCOD(LHNT,IADRI3)+ITBPTR-1)
         ENDIF
      ENDIF
*
*              Change on the screen
*
      CALL IZSAV
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      LNDECO=LHNT
      LIDECO=LDI
      LFDECO=LDF
      LCDECO=LDC
      CALL IZDATT(0,NPRIM)
      CALL ISFACI(0)
      CALL ISTXCI(0)
      CALL ISPLCI(0)
      CALL ISPMCI(0)
      CALL ISFAIS(1)
      CALL ISLN(1)
      CALL IZDNB(LHNT,LDI,LDF,LDC,NPRIM,-1)
      CALL IZSET
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      LNDECO=LHNT
      LIDECO=LDI
      LFDECO=LDF
      LCDECO=LDC
      CALL IZDATT(0,NPRIM)
      CALL IZDNB(LHNT,LDI,LDF,LDC,NPRIM,1)
*
   90 ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      GOTO 10
*
      END
+DECK,  IEDELE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEDELE(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
+CDE, HICODE.
+CDE, HIGED.
      CHARACTER*8 SNAME
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
   10 IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(IPLACE.EQ.3)GOTO 10
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
      IF(ICHOIC.EQ.-1000)GOTO 10
      IF(ICHOIC.EQ.-1)GOTO 10
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 10
      ENDIF
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 10
      ENDIF
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IZPICK(NT,SNAME,NPRIM,'N')
      IF(NPRIM.LE.0)GOTO 30
      LN=IZGNTP(NT)
      IF(LN.EQ.0)GOTO 30
      CALL ISELNT(NT)
*
*              Delete on the screen
*
      CALL IZSAV
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      LNDECO=LHNT
      LIDECO=LDI
      LFDECO=LDF
      LCDECO=LDC
      CALL IZDATT(0,NPRIM)
      CALL ISFACI(0)
      CALL ISTXCI(0)
      CALL ISPLCI(0)
      CALL ISPMCI(0)
      CALL ISFAIS(1)
      CALL ISLN(1)
      CALL IZDNB(LHNT,LHI,LHF,LHC,NPRIM,-1)
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
*              Delete in the data structure
*
      IF(IQ(LHNT+NPRIM).GT.0)THEN
         IF(IZPUSH(3,0,0,'IEDELE').NE.0)GOTO 30
         CALL IZSTCC(INOPCO,INTPTR)
         IQ(LHI+INTPTR)=0
         IQ(LHI+INTPTR+1)=IZGADR(LHNT,NPRIM)
         IQ(LHI+INTPTR+2)=NPRIM
         CALL IZINCI(3)
         IQ(LHNT+NPRIM)=-(1000000*IZGCOD(LHNT,NPRIM)+ITBPTR-1)
      ELSE
         IADRI2=ABS(IZGADR(LHNT,NPRIM))
         IADRI3=IADRI2
   20    IF(IQ(LHNT+IADRI2).LT.0)THEN
            IADRI2=ABS(IZGADR(LHNT,IADRI2))
            IADRI3=IADRI2
            GOTO 20
         ENDIF
         IADRI2=IZGADR(LHNT,IADRI2)
         IF(IZPUSH(3,0,0,'IEDELE').NE.0)GOTO 30
         CALL IZSTCC(INOPCO,INTPTR)
         IQ(LHI+INTPTR)=0
         IQ(LHI+INTPTR+1)=IADRI2
         IQ(LHI+INTPTR+2)=IADRI3
         CALL IZINCI(3)
         IQ(LHNT+IADRI3)=-(1000000*IZGCOD(LHNT,IADRI3)+ITBPTR-1)
      ENDIF
*
   30 CALL IZSET
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      GOTO 10
*
      END
+DECK,  IEFA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEFA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
 201  IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 201
*
 203  X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      NTLOC=IQUEST(10)
*
      IF(IPLACE.EQ.3)GOTO 201
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(ICHOIC.EQ.-1)THEN
         CALL IEMFAA(IPLACE,ICHOIC)
         GOTO 203
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 201
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 201
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      I=2
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      CALL IGPLOT(X(1),Y(1))
 202  CALL IGLOC(41,NTLOC,IBN,XNDC,YNDC,X(I),Y(I))
      IF(IBN.EQ.1)THEN
         IF(NTLOC.NE.INTR)GOTO 202
         CALL IGGRID(X(I),Y(I))
         CALL IEALPT(X(I-1),Y(I-1))
         CALL IGLINE(X(I-1),X(I),Y(I-1),Y(I))
         I=I+1
         GOTO 202
      ELSE
         IF(I.LE.3)GOTO 201
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL IZSAV
         CALL IGLINE(X(I-1),X(1),Y(I-1),Y(1))
         CALL ISPLCI(0)
         CALL ISLN(1)
         X(I)=X(1)
         Y(I)=Y(1)
         CALL IPL(I,X,Y)
         CALL IZSET
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL ISFAIS(ICFAIS)
         CALL ISFASI(ICFASI)
         CALL ISFACI(ICFACI)
         CALL IFA(I-1,X,Y)
         GOTO 201
      ENDIF
*
      END
+DECK,  IEFBOX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEFBOX(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
 201  IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 201
*
 203  X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      NTLOC=IQUEST(10)
*
      IF(IPLACE.EQ.3)GOTO 201
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(ICHOIC.EQ.-1)THEN
         CALL IEMFBA(IPLACE,ICHOIC)
         GOTO 203
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 201
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 201
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      CALL IGPLOT(X(1),Y(1))
      CALL IZSAV
*
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISFAIS(0)
      CALL ISFACI(1)
      CALL IGSET('BORD',1.)
      I=2
 202  CALL IGLOC(51,NTLOC,IBN,XNDC,YNDC,X(I),Y(I))
      IF(NTLOC.NE.INTR)GOTO 202
      CALL IGGRID(X(I),Y(I))
      I=I+1
      CALL IGBOX(X(1),X(2),Y(1),Y(2))
 204  CALL IGLOC(1,NTLOC,IBN,XNDC,YNDC,X(I),Y(I))
      IF(NTLOC.NE.INTR)GOTO 204
      CALL IGGRID(X(I),Y(I))
      I=I+1
      CALL IGPLOT(X(3),Y(3))
 205  CALL IGLOC(51,NTLOC,IBN,XNDC,YNDC,X(I),Y(I))
      IF(NTLOC.NE.INTR)GOTO 205
      CALL IGGRID(X(I),Y(I))
      CALL IGBOX(X(3),X(4),Y(3),Y(4))
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      CALL ISFAIS(ICFBIS)
      CALL ISFASI(ICFBSI)
      CALL ISFACI(ICFBCI)
      CALL IGSET('BORD',FLOAT(ICBOBO))
      CALL IGFBOX(X(1),X(2),Y(1),Y(2),X(3),X(4),Y(3),Y(4))
      GOTO 201
*
      END
+DECK,  IEGRID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEGRID
*.===========>
*.
*.   Draws the grid if needed.
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIGED.
*.______________________________________
*
      IF((IXSTEP*IXFACT.EQ.0).OR.(IYSTEP*IYFACT.EQ.0))RETURN
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISMK(1)
      CALL ISPMCI(1)
      XSTDX=(RWXMAX-RWXMIN)/FLOAT(IXSTEP*IXFACT)
      YSTDY=(RWYMAX-RWYMIN)/FLOAT(IYSTEP*IYFACT)
      NBPM=1
      DO 20 I=0,(IXSTEP*IXFACT)
         XPMVAL=RWXMIN+I*XSTDX
         DO 10 J=0,(IYSTEP*IYFACT)
            X(NBPM)=XPMVAL
            Y(NBPM)=RWYMIN+J*YSTDY
            IF(NBPM.EQ.100)THEN
               CALL IPM(NBPM,X,Y)
               NBPM=0
            ENDIF
            NBPM=NBPM+1
   10    CONTINUE
   20 CONTINUE
      CALL IPM(NBPM,X,Y)
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IEMACA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEMACA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*32 CHVAL(5)
*.______________________________________
*
      TITLE(3)='ARC ATTRIBUTES'
      CHITEM(1,3)='Fill area interior style'
      CHITEM(2,3)='Fill area style index'
      CHITEM(3,3)='Arc border'
      CHITEM(4,3)='Line color'
      CHITEM(5,3)='Fill area color'
*
      CHDEF(1)=CHACIS
      CALL IZITOC(ICACFS,CHDEF(2))
      CHDEF(3)=CHACBO
      CHDEF(4)=CHACLC
      CHDEF(5)=CHACFC
*
      IPLACE=3
      CALL IGREQ(270,0,5,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IGFIRS(CHACIS,CHVAL(1))
      ICACFI=IGIFAI(CHVAL(1))
      CALL IZCTOI(CHVAL(2),ICACFS)
      CALL IGFIRS(CHACBO,CHVAL(3))
      IF(CHVAL(3).EQ.'No')THEN
         ICACBO=0
      ELSE
         ICACBO=1
      ENDIF
      CALL IGFIRS(CHACLC,CHVAL(4))
      ICACLC=IGICOL(CHVAL(4))
      CALL IGFIRS(CHACFC,CHVAL(5))
      ICACFC=IGICOL(CHVAL(5))
*
      CALL ISFAIS(ICACFI)
      CALL ISFASI(ICACFS)
      CALL ISFACI(ICACFC)
      CALL ISPLCI(ICACLC)
      CALL IGSET('BORD',FLOAT(ICACBO))
*
      END
+DECK,  IEMAXA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEMAXA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*80 CHVAL(11)
*.______________________________________
*
      TITLE(3)='AXIS ATTRIBUTES'
      CHITEM(1,3)='CHOPT'
      CHITEM(2,3)='WMIN'
      CHITEM(3,3)='WMAX'
      CHITEM(4,3)='Number of divisions'
      CHITEM(5,3)='Tick marks size'
      CHITEM(6,3)='Labels size'
      CHITEM(7,3)='Labels offset'
      CHITEM(8,3)='Axis color'
      CHITEM(9,3)='Axis line type'
      CHITEM(10,3)='Labels font'
      CHITEM(11,3)='Labels precision'
*
      CHDEF(1)=CHOPAX
      CHDEF(2)=' '
      CHDEF(3)=' '
      CHDEF(4)=' '
      CALL IZRTOC(RCAXTS,CHDEF(5))
      CALL IZRTOC(RCAXLS,CHDEF(6))
      CALL IZRTOC(RCAXLO,CHDEF(7))
      CHDEF(8)=CHAXLC
      CALL IZITOC(ICAXLN,CHDEF(9))
      CALL IZITOC(ICAXLF,CHDEF(10))
      CALL IZITOC(ICAXLP,CHDEF(11))
*
      IPLACE=3
      CALL IGREQ(260,0,11,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL CLTOU(CHVAL(1))
      CHOPAX=CHVAL(1)
      CALL IZCTOR(CHVAL(2),X1)
      CALL IZCTOR(CHVAL(3),X2)
      IF(X1.NE.X2)THEN
         RCAXW1=X1
         RCAXW2=X2
      ENDIF
      IF(CHVAL(4).NE.' ')THEN
         CALL IZCTOI(CHVAL(4),ICAXND)
      ENDIF
      CALL IZCTOR(CHVAL(5),RCAXTS)
      CALL IZCTOR(CHVAL(6),RCAXLS)
      CALL IZCTOR(CHVAL(7),RCAXLO)
      CALL IGFIRS(CHAXLC,CHVAL(8))
      ICAXLC=IGICOL(CHVAL(8))
      CALL IZCTOI(CHVAL(9),ICAXLN)
      CALL IZCTOI(CHVAL(10),ICAXLF)
      CALL IZCTOI(CHVAL(11),ICAXLP)
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IGSET('TMSI',RCAXTS)
      CALL IGSET('LASI',RCAXLS)
      CALL IGSET('LAOF',RCAXLO)
      CALL ISLN(ICAXLN)
      CALL ISPLCI(ICAXLC)
      CALL ISTXFP(ICAXLF,ICAXLP)
*
      END
+DECK,  IEMBOA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEMBOA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*80 CHVAL(4)
*.______________________________________
*
      TITLE(3)='BOX ATTRIBUTES'
      CHITEM(1,3)='Box interior style'
      CHITEM(2,3)='Box style index'
      CHITEM(3,3)='Box color index'
      CHITEM(4,3)='Border'
*
      CHDEF(1)=CHBOIS
      CALL IZITOC(ICBOSI,CHDEF(2))
      CHDEF(3)=CHBOC
      CHDEF(4)=CHBOBO
*
      IPLACE=3
      CALL IGREQ(270,0,4,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL IGFIRS(CHBOIS,CHVAL(1))
      ICBOIS=IGIFAI(CHVAL(1))
      CALL IZCTOI(CHVAL(2),ICBOSI)
      CALL IGFIRS(CHBOC,CHVAL(3))
      ICBOCI=IGICOL(CHVAL(3))
      CALL IGFIRS(CHBOBO,CHVAL(4))
      IF(CHVAL(4).EQ.'No')THEN
         ICBOBO=0
      ELSE
         ICBOBO=1
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISFAIS(ICBOIS)
      CALL ISFASI(ICBOSI)
      CALL ISFACI(ICBOCI)
      CALL IGSET('BORD',FLOAT(ICBOBO))
*
      END
+DECK,  IEMFAA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEMFAA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*80 CHVAL(3)
*.______________________________________
*
      TITLE(3)='FILL AREA ATTRIBUTES'
      CHITEM(1,3)='Fill area interior style'
      CHITEM(2,3)='Fill area style index'
      CHITEM(3,3)='Fill area color index'
*
      CHDEF(1)=CHFAIS
      CALL IZITOC(ICFASI,CHDEF(2))
      CHDEF(3)=CHFAC
*
      IPLACE=3
      CALL IGREQ(220,0,3,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL IGFIRS(CHFAIS,CHVAL(1))
      ICFAIS=IGIFAI(CHVAL(1))
      CALL IZCTOI(CHVAL(2),ICFASI)
      CALL IGFIRS(CHFAC,CHVAL(3))
      ICFACI=IGICOL(CHVAL(3))
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISFAIS(ICFAIS)
      CALL ISFASI(ICFASI)
      CALL ISFACI(ICFACI)
*
      END
+DECK,  IEMFBA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEMFBA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*80 CHVAL(4)
*.______________________________________
*
      TITLE(3)='FRAME BOX ATTRIBUTES'
      CHITEM(1,3)='Frame Box interior style'
      CHITEM(2,3)='Frame Box style index'
      CHITEM(3,3)='Frame Box color index'
      CHITEM(4,3)='Frame Box Border'
*
      CHDEF(1)=CHFBIS
      CALL IZITOC(ICFBSI,CHDEF(2))
      CHDEF(3)=CHFBC
      CHDEF(4)=CHFBBO
*
      IPLACE=3
      CALL IGREQ(280,0,4,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL IGFIRS(CHFBIS,CHVAL(1))
      ICFBIS=IGIFAI(CHVAL(1))
      CALL IZCTOI(CHVAL(2),ICFBSI)
      CALL IGFIRS(CHFBC,CHVAL(3))
      ICFBCI=IGICOL(CHVAL(3))
      CALL IGFIRS(CHFBBO,CHVAL(4))
      IF(CHVAL(4).EQ.'No')THEN
         ICFBBO=0
      ELSE
         ICFBBO=1
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISFAIS(ICFBIS)
      CALL ISFASI(ICFBSI)
      CALL ISFACI(ICFBCI)
      CALL IGSET('BORD',FLOAT(ICFBBO))
*
      END
+DECK,  IEMHIA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:22  mclareni
* Higz

      SUBROUTINE IEMHIA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*32 CHVAL(8)
*.______________________________________
*
      TITLE(3)='HISTOGRAM ATTRIBUTES'
      CHITEM(1,3)='CHOPT'
      CHITEM(2,3)='Bars offset'
      CHITEM(3,3)='Bars width'
      CHITEM(4,3)='Histogram line type'
      CHITEM(5,3)='Histogram line color'
      CHITEM(6,3)='Histogram fill color'
      CHITEM(7,3)='Histogram interior style'
      CHITEM(8,3)='Histogram style index'
*
      CHDEF(1)=CHOPHI
      CALL IZRTOC(RCBOF,CHDEF(2))
      CALL IZRTOC(RCBWD,CHDEF(3))
      CALL IZITOC(ICHILN,CHDEF(4))
      CHDEF(5)=CHHIPC
      CHDEF(6)=CHHIFC
      CHDEF(7)=CHHIIS
      CALL IZITOC(ICHIFS,CHDEF(8))
*
      IPLACE=3
      CALL IGREQ(700,0,8,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL CLTOU(CHVAL(1))
      CHOPHI=CHVAL(1)
      CALL IZCTOR(CHVAL(2),RCBOF)
      CALL IZCTOR(CHVAL(3),RCBWD)
      CALL IZCTOI(CHVAL(4),ICHILN)
      CALL IGFIRS(CHHIPC,CHVAL(5))
      ICHIPC=IGICOL(CHVAL(5))
      CALL IGFIRS(CHHIFC,CHVAL(6))
      ICHIFC=IGICOL(CHVAL(6))
      CALL IGFIRS(CHHIIS,CHVAL(7))
      ICHIFI=IGIFAI(CHVAL(7))
      IF(ICHIFI.NE.0.AND.INDEX(CHOPHI,'F').EQ.0)THEN
         CHOPHI=CHOPHI(1:LENOCC(CHOPHI))//'F'
      ENDIF
      CALL IZCTOI(CHVAL(8),ICHIFS)
*
      CALL IGSET('BARO',RCBOF)
      CALL IGSET('BARW',RCBWD)
      CALL ISLN(ICHILN)
      CALL ISPLCI(ICHIPC)
      CALL ISFACI(ICHIFC)
      CALL ISFAIS(ICHIFI)
      CALL ISFASI(ICHIFS)
*
      END
+DECK,  IEMOPR, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEMOPR(ICF,ICHOIO)
*.===========>
*.
*. Move an existing primitive
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HICODE.
+CDE, HIGED.
      CHARACTER*8 SNAME
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
   10 IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(IPLACE.EQ.3)GOTO 10
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
      IF(ICHOIC.EQ.-1000)GOTO 10
      IF(ICHOIC.EQ.-1)GOTO 10
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 10
      ENDIF
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 10
      ENDIF
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IZPICK(NT,SNAME,NPRIM,'N')
      IF(NPRIM.LE.0)GOTO 50
*
      LN=IZGNTP(NT)
      IF(LN.EQ.0)GOTO 50
      CALL ISELNT(NT)
      X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      CALL IGGRID(X(1),Y(1))
   30 CALL IGLOC(41,NTLOC,IBN,XNDC,YNDC,X(2),Y(2))
      IF(IBN.EQ.0)GOTO 50
      IF(NTLOC.NE.INTR)GOTO 30
      CALL IGGRID(X(2),Y(2))
      CALL IEALPT(X,Y)
      DX=X(2)-X(1)
      DY=Y(2)-Y(1)
*
*              Delete on the screen
*
      CALL IZSAV
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      LNDECO=LHNT
      LIDECO=LDI
      LFDECO=LDF
      LCDECO=LDC
      CALL IZDATT(0,NPRIM)
      CALL ISFACI(0)
      CALL ISTXCI(0)
      CALL ISPLCI(0)
      CALL ISPMCI(0)
      CALL ISFAIS(1)
      CALL ISLN(1)
      CALL IZDNB(LHNT,LDI,LDF,LDC,NPRIM,-1)
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
*              Change in the data structure
*
      IF(IQ(LHNT+NPRIM).GT.0)THEN
         IF(IZPUSH(3,2,0,'IEMOPR').NE.0)GOTO 50
         CALL IZSTCC(INOPCO,INTPTR)
         IQ(LHI+INTPTR)=3000000+IFLPTR
         IQ(LHI+INTPTR+1)=IZGADR(LHNT,NPRIM)
         IQ(LHI+INTPTR+2)=NPRIM
         CALL IZINCI(3)
         Q(LHF+IFLPTR)=DX
         Q(LHF+IFLPTR+1)=DY
         CALL IZINCF(2)
         IQ(LHNT+NPRIM)=-(1000000*IZGCOD(LHNT,NPRIM)+ITBPTR-1)
      ELSE
         IADRI2=ABS(IZGADR(LHNT,NPRIM))
         IADRI3=IADRI2
   40    IF(IQ(LHNT+IADRI2).LT.0)THEN
            IADRI2=ABS(IZGADR(LHNT,IADRI2))
            IADRI3=IADRI2
            GOTO 40
         ENDIF
         IADRI2=IZGADR(LHNT,IADRI2)
         IF(IZPUSH(3,2,0,'IEMOPR').NE.0)GOTO 50
         CALL IZSTCC(INOPCO,INTPTR)
         IQ(LHI+INTPTR)=3000000+IFLPTR
         IQ(LHI+INTPTR+1)=IADRI2
         IQ(LHI+INTPTR+2)=IADRI3
         CALL IZINCI(3)
         Q(LHF+IFLPTR)=DX
         Q(LHF+IFLPTR+1)=DY
         CALL IZINCF(2)
         IQ(LHNT+IADRI3)=-(1000000*IZGCOD(LHNT,IADRI3)+ITBPTR-1)
      ENDIF
*
*              Change on the screen
*
      CALL IZSET
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      LNDECO=LHNT
      LIDECO=LDI
      LFDECO=LDF
      LCDECO=LDC
      CALL IZDATT(0,NPRIM)
      CALL IZDNB(LHNT,LDI,LDF,LDC,NPRIM,1)
*
   50 ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      GOTO 10
*
      END
+DECK,  IEMPLA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEMPLA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*80 CHVAL(3)
*.______________________________________
*
      TITLE(3)='POLYLINE ATTRIBUTES'
      CHITEM(1,3)='Polyline style'
      CHITEM(2,3)='Line width scale factor'
      CHITEM(3,3)='Polyline color index'
*
      CALL IZITOC(ICLN,CHDEF(1))
      CALL IZRTOC(RCLWSC,CHDEF(2))
      CHDEF(3)=CHPLC
*
      IPLACE=3
      CALL IGREQ(230,0,3,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL IZCTOI(CHVAL(1),ICLN)
      CALL IZCTOR(CHVAL(2),RCLWSC)
      CALL IGFIRS(CHPLC,CHVAL(3))
      ICPLCI=IGICOL(CHVAL(3))
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISLN(ICLN)
      CALL ISLWSC(RCLWSC)
      CALL ISPLCI(ICPLCI)
*
      END
+DECK,  IEMPMA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEMPMA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*80 CHVAL(3)
*.______________________________________
*
      TITLE(3)='POLYMARKER ATTRIBUTES'
      CHITEM(1,3)='Polymarker type'
      CHITEM(2,3)='Polymarker color index'
      CHITEM(3,3)='Polymarker scale factor'
*
      CALL IZITOC(ICMK,CHDEF(1))
      CHDEF(2)=CHPMC
      CALL IZRTOC(RCMKSC,CHDEF(3))
*
      IPLACE=3
      CALL IGREQ(240,0,3,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL IZCTOI(CHVAL(1),ICMK)
      CALL IGFIRS(CHPMC,CHVAL(2))
      ICPMCI=IGICOL(CHVAL(2))
      CALL IZCTOR(CHVAL(3),RCMKSC)
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISMK(ICMK)
      CALL ISPMCI(ICPMCI)
      CALL ISMKSC(RCMKSC)
*
      END
+DECK,  IEMSTA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEMSTA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*32 CHVAL(7)
*.______________________________________
*
      TITLE(3)='SOFTWARE TEXT'
      CHITEM(1,3)='Text to be drawn'
      CHITEM(2,3)='Text size'
      CHITEM(3,3)='Text angle'
      CHITEM(4,3)='Text shift'
      CHITEM(5,3)='Text color index'
      CHITEM(6,3)='Text pass'
      CHITEM(7,3)='CHOPT'
*
      CHDEF(1)=CCST
      CALL IZRTOC(RCSTSI,CHDEF(2))
      CALL IZRTOC(RCSTAN,CHDEF(3))
      CALL IZRTOC(RCSTSH,CHDEF(4))
      CHDEF(5)=CHSTC
      CALL IZITOC(ICSTPA,CHDEF(6))
      CHDEF(7)=CHOPST
*
      IPLACE=3
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(1)
      CALL IGREQ(1000,0,7,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL IGFIRS(CHSTC,CHVAL(5))
      ICSTCI=IGICOL(CHVAL(5))
      CCST=CHVAL(1)
      CALL IZCTOR(CHVAL(2),RCSTSI)
      CALL IZCTOR(CHVAL(3),RCSTAN)
      CALL IZCTOR(CHVAL(4),RCSTSH)
      CALL IZCTOI(CHVAL(6),ICSTPA)
      CALL CLTOU(CHVAL(7))
      CHOPST=CHVAL(7)
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IGSET('CSHI',RCSTSH)
      CALL IGSET('PASS',FLOAT(ICSTPA))
      CALL ISTXCI(ICSTCI)
*
      END
+DECK,  IEMTXA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEMTXA(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*32 CHVAL(8)
*.______________________________________
*
      TITLE(3)='TEXT'
      CHITEM(1,3)='Text to be drawn'
      CHITEM(2,3)='Text size'
      CHITEM(3,3)='Text angle'
      CHITEM(4,3)='Text font'
      CHITEM(5,3)='Text precision'
      CHITEM(6,3)='Text color'
      CHITEM(7,3)='Horizontal alignment'
      CHITEM(8,3)='Vertical alignment'
*
      CHDEF(1)=CCTX
      CALL IZRTOC(RCTXSI,CHDEF(2))
      CALL IZRTOC(RCTXAN,CHDEF(3))
      CALL IZITOC(ICTXFT,CHDEF(4))
      CALL IZITOC(ICTXPR,CHDEF(5))
      CHDEF(6)=CHTXC
      CALL IZITOC(ICTXAH,CHDEF(7))
      CALL IZITOC(ICTXAV,CHDEF(8))
*
      IPLACE=3
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(1)
      CALL IGREQ(1001,0,8,IPLACE,ICHOIC,CHVAL)
      ICHOIO=ICHOIC
      ICF=IPLACE
*
      CALL IGFIRS(CHTXC,CHVAL(6))
      ICTXCI=IGICOL(CHVAL(6))
      CCTX=CHVAL(1)
      CALL IZCTOR(CHVAL(2),RCTXSI)
      CALL IZCTOR(CHVAL(3),RCTXAN)
      CALL IZCTOI(CHVAL(4),ICTXFT)
      CALL IZCTOI(CHVAL(5),ICTXPR)
      CALL IZCTOI(CHVAL(7),ICTXAH)
      CALL IZCTOI(CHVAL(8),ICTXAV)
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IGSET('TANG',RCTXAN)
      CALL ISCHH(RCTXSI)
      CALL ISTXFP(ICTXFT,ICTXPR)
      CALL ISTXCI(ICTXCI)
      CALL ISTXAL(ICTXAH,ICTXAV)
*
      END
+DECK,  IEPAVE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEPAVE(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*32 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
   10 IPLACE=2
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      NTSAV=INTR
      CALL ISELNT(1)
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 10
*
   20 X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      CALL IGGRID(X(1),Y(1))
      NTLOC=IQUEST(10)
*
   30 IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         CALL ISELNT(NTSAV)
         RETURN
      ENDIF
*
      IF(IPLACE.EQ.3)GOTO 10
*
      IF(ICHOIC.EQ.-1)THEN
         TITLE(3)='PAVING-BLOCK ATTRIBUTES'
         CHITEM(1,3)='Boxe style'
         CHITEM(2,3)='Frame style'
         CHITEM(3,3)='Frame size'
         CHITEM(4,3)='Options'
         CALL IZITOC(ICPBST,CHDEF(1))
         CALL IZITOC(ICPFST,CHDEF(2))
         CALL IZRTOC(RCDZPV,CHDEF(3))
         CHDEF(4)=CHOPPV
         IPLACE=3
         CALL IGREQ(298,0,4,IPLACE,ICHOIC,CHVAL)
         ICHOIO=ICHOIC
         ICF=IPLACE
         CALL IZCTOI(CHVAL(1),ICPBST)
         CALL IZCTOI(CHVAL(2),ICPFST)
         CALL IZCTOR(CHVAL(3),RCDZPV)
         CHOPPV=CHVAL(4)
         GOTO 20
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 10
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 10
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         CALL ISELNT(NTSAV)
         RETURN
      ENDIF
*

      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL IGPLOT(X(1),Y(1))
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
   40 CALL IGLOC(51,NTLOC,IBN,XNDC,YNDC,X(2),Y(2))
      IF(NTLOC.NE.INTR)GOTO 40
      CALL IGGRID(X(2),Y(2))
      CALL IGPAVE(X(1),X(2),Y(1),Y(2),RCDZPV,ICPBST,ICPFST,CHOPPV)
      GOTO 10
*
      END
+DECK,  IEPL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEPL(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
 201  IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 201
 203  X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      NTLOC=IQUEST(10)
*
      IF(IPLACE.EQ.3)GOTO 201
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(ICHOIC.EQ.-1)THEN
         CALL IEMPLA(IPLACE,ICHOIC)
         GOTO 203
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 201
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 201
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      I=2
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      CALL IGPLOT(X(1),Y(1))
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
 202  CALL IGLOC(41,NTLOC,IBN,XNDC,YNDC,X(I),Y(I))
      IF(IBN.EQ.1)THEN
         IF(NTLOC.NE.INTR)GOTO 202
         CALL IGGRID(X(I),Y(I))
         CALL IEALPT(X(I-1),Y(I-1))
         CALL IGLINE(X(I-1),X(I),Y(I-1),Y(I))
         I=I+1
         GOTO 202
      ELSE
         IF(I.LE.2)GOTO 201
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL IZSAV
         CALL IGLINE(X(I-1),X(1),Y(I-1),Y(1))
         CALL ISPLCI(0)
         CALL ISLN(1)
         X(I)=X(1)
         Y(I)=Y(1)
         CALL IPL(I,X,Y)
         CALL IZSET
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         GFLAG=.TRUE.
         CALL ISLN(ICLN)
         CALL ISLWSC(RCLWSC)
         CALL ISPLCI(ICPLCI)
         CALL IPL(I-1,X,Y)
         GOTO 201
      ENDIF
*
      END
+DECK,  IEPM, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEPM(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
 201  IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(ICHOIC.EQ.-1000)GOTO 201
 203  X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
      NTLOC=IQUEST(10)
*
      IF(IPLACE.EQ.3)GOTO 201
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(ICHOIC.EQ.-1)THEN
         CALL IEMPMA(IPLACE,ICHOIC)
         GOTO 203
      ENDIF
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 201
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 201
      ENDIF
*
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NTLOC)
      CALL IGGRID(X(1),Y(1))
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISMK(ICMK)
      CALL ISPMCI(ICPMCI)
      CALL IPM(1,X(1),Y(1))
      I=2
 202  CALL IGLOC(21,NTLOC,IBN,XNDC,YNDC,X(I),Y(I))
      IF(IBN.EQ.1)THEN
         IF(NTLOC.NE.INTR)GOTO 202
         CALL IGGRID(X(I),Y(I))
         CALL IPM(1,X(I),Y(I))
         I=I+1
         GOTO 202
      ELSE
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         GFLAG=.FALSE.
         CALL ISMK(ICMK)
         CALL ISPMCI(ICPMCI)
         CALL ISMKSC(RCMKSC)
         CALL IPM(I-1,X,Y)
         GFLAG=.TRUE.
         GOTO 201
      ENDIF
*
      END
+DECK,  IEPOP, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEPOP(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
+CDE, HIGED.
      CHARACTER*8 SNAME
      CHARACTER*4 CHVAL(15)
*.______________________________________
*
      ICHOIO=0
   10 IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
      IF(IPLACE.EQ.3)GOTO 10
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
      IF(ICHOIC.EQ.-1000)GOTO 10
      IF(ICHOIC.EQ.-1)GOTO 10
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 10
      ENDIF
      IF(ICHOIC.EQ.-3)THEN
         GOTO 10
      ENDIF
      IF(ICHOIC.GE.1)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL IZPICK(NT,SNAME,NPRIM,'N')
      IF(NPRIM.LE.0)GOTO 30
      LN=IZGNTP(NT)
      IF(LN.EQ.0)GOTO 30
      CALL ISELNT(NT)
*
      CALL IZSAV
      LNDECO=LHNT
      LIDECO=LDI
      LFDECO=LDF
      LCDECO=LDC
      CALL IZDATT(0,NPRIM)
      CALL IZDNB(LHNT,LHI,LHF,LHC,NPRIM,1)
      IQ(LHNT+NPRIM)=1000000
*
   30 CALL IZSET
      GOTO 10
*
      END

+DECK,  IESTX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IESTX(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIGED.
+CDE, HIFLAG.
*.______________________________________
*
   10 CALL IEMSTA(IPLACE,ICHOIC)
*
      IF(ICHOIC.EQ.-1000)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
*
      LN=LQ(LPICD-1)
      DO 20 I=1,IQ(LPICD+8)
         IF(LN.EQ.0)GOTO 10
         IF(IQ(LN+1).NE.0.AND.IQ(LN+1).NE.1)THEN
            CALL ISELNT(IQ(LN+1))
         ENDIF
         LN=LQ(LN)
   20 CONTINUE
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(IPLACE.EQ.2)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISELNT(1)
      CALL IGGRID(X(1),Y(1))
      CALL IGSET('CSHI',RCSTSH)
      CALL IGSET('PASS',FLOAT(ICSTPA))
      CALL ISTXCI(ICSTCI)
      CALL IGTEXT(X(1),Y(1),CCST,RCSTSI,RCSTAN,CHOPST)
*
      LN=LQ(LPICD-1)
      DO 30 I=1,IQ(LPICD+8)
         IF(LN.EQ.0)GOTO 10
         IF(IQ(LN+1).NE.0.AND.IQ(LN+1).NE.1)THEN
            CALL ISELNT(IQ(LN+1))
         ENDIF
         LN=LQ(LN)
   30 CONTINUE
      GOTO 10
*
      END
+DECK,  IETX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IETX(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIGED.
+CDE, HIFLAG.
*.______________________________________
*
   10 CALL IEMTXA(IPLACE,ICHOIC)
*
      IF(ICHOIC.EQ.-1000)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      X(1)=RQUEST(13)
      Y(1)=RQUEST(14)
*
      LN=LQ(LPICD-1)
      DO 20 I=1,IQ(LPICD+8)
         IF(LN.EQ.0)GOTO 10
         IF(IQ(LN+1).NE.0.AND.IQ(LN+1).NE.1)THEN
            CALL ISELNT(IQ(LN+1))
         ENDIF
         LN=LQ(LN)
   20 CONTINUE
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(IPLACE.EQ.2)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISELNT(1)
      CALL IGGRID(X(1),Y(1))
      CALL IGSET('TANG',RCTXAN)
      CALL ISCHH(RCTXSI)
      CALL ISTXFP(ICTXFT,ICTXPR)
      CALL ISTXCI(ICTXCI)
      CALL ISTXAL(ICTXAH,ICTXAV)
      CALL ITX(X(1),Y(1),CCTX)
*
      LN=LQ(LPICD-1)
      DO 30 I=1,IQ(LPICD+8)
         IF(LN.EQ.0)GOTO 10
         IF(IQ(LN+1).NE.0.AND.IQ(LN+1).NE.1)THEN
            CALL ISELNT(IQ(LN+1))
         ENDIF
         LN=LQ(LN)
   30 CONTINUE
      GOTO 10
*
      END
+DECK,  IEWIN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IEWIN(ICF,ICHOIO)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIQUES.
+CDE, HIATT.
+CDE, HIGED.
+CDE, HIFLAG.
      CHARACTER*12 CINTR
      CHARACTER*32 CHVAL(5)
      CHARACTER*20 CCEWX1,CCEWX2,CCEWY1,CCEWY2,CCENT
*.______________________________________
*
      ICENT=100
 21   ICENT=ICENT+1
+SELF, IF=-NTC, IF=-X11.
      CALL IZGNT(ICENT,IFIND,IAWV,IPRIO,IHPRIO)
      IF(IFIND.NE.0)GOTO 21
+SELF, IF=NTC,X11.
      IF(IGNSCU(ICENT).NE.0)GOTO 21
+SELF.
      RCEWX1=0.
      RCEWX2=1.
      RCEWY1=0.
      RCEWY2=1.
      CALL IZITOC(ICENT,CCENT)
      CALL IZRTOC(RCEWX1,CCEWX1)
      CALL IZRTOC(RCEWX2,CCEWX2)
      CALL IZRTOC(RCEWY1,CCEWY1)
      CALL IZRTOC(RCEWY2,CCEWY2)
      TITLE(3)='CURRENT WINDOW PARAMETERS'
      CHITEM(1,3)='NT'
      CHITEM(2,3)='XMIN'
      CHITEM(3,3)='XMAX'
      CHITEM(4,3)='YMIN'
      CHITEM(5,3)='YMAX'
      CHDEF(1)=CCENT
      CHDEF(2)=CCEWX1
      CHDEF(3)=CCEWX2
      CHDEF(4)=CCEWY1
      CHDEF(5)=CCEWY2
      IPLACE=3
      CALL IGREQ(310,0,5,IPLACE,ICHOIC,CHVAL)
*
      IF(ICHOIC.EQ.-1000)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(IPLACE.EQ.1)THEN
         ICF=1
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      IF(IPLACE.EQ.2)THEN
         ICF=2
         ICHOIO=ICHOIC
         RETURN
      ENDIF
*
      CALL IZCTOI(CHVAL(1),ICENT)
      CALL IZCTOR(CHVAL(2),RCEWX1)
      CALL IZCTOR(CHVAL(3),RCEWX2)
      CALL IZCTOR(CHVAL(4),RCEWY1)
      CALL IZCTOR(CHVAL(5),RCEWY2)
      X(1)=RQUEST(11)/REDIT
      Y(1)=RQUEST(12)/REDIT
      CALL IGPLOT(X(1),Y(1))
      CALL IGLOC(51,NTLOC,IBN,X(2),Y(2),XWC,YWC)
      IF(IBN.EQ.0)RETURN
*
      X(2)=X(2)/REDIT
      Y(2)=Y(2)/REDIT
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      CALL ISWN(ICENT,RCEWX1,RCEWX2,RCEWY1,RCEWY2)
      CALL IGEX(X(1),X(2))
      CALL IGEX(Y(1),Y(2))
      CALL ISVP(ICENT,X(1),X(2),Y(1),Y(2))
      CALL ISELNT(ICENT)
      CALL IZITOC(ICENT,CINTR)
      CHUSKE(1,2)=CINTR
      IPLACE=2
      CALL IGMENU(0,TITLE(IPLACE)
     +,  XPM(1,IPLACE),XPM(2,IPLACE)
     +,  YPM(1,IPLACE),YPM(2,IPLACE)
     +,  NBU(IPLACE),CHUSKE(1,IPLACE)
     +,  NBITEM(IPLACE),CHITEM(1,IPLACE)
     +,  CHDEF,CHVAL,1,'UTW')
*
      END
+DECK,  IGBORD, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IGBORD(NTB,X1,X2,Y1,Y2,ILNTY)
*.===========>
*.
*.   This routine draws the curent NT border
*.
*..==========> (O.Couet)
+CDE, HIATT.
+CDE, HIFLAG.
      DIMENSION X(5),Y(5)
      LOGICAL ZFS,GFS
*.______________________________________
*
      CALL IZSAV
      NTSAV=INTR
      ZFS=ZFLAG
      GFS=GFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      X(1)=X1
      X(2)=X1
      X(3)=X2
      X(4)=X2
      X(5)=X1
      Y(1)=Y1
      Y(2)=Y2
      Y(3)=Y2
      Y(4)=Y1
      Y(5)=Y1
*
      IF(NTB.EQ.0)THEN
         X(1)=0.
         X(2)=0.
         X(3)=1.
         X(4)=1.
         X(5)=0.
         Y(1)=0.
         Y(2)=(RDWYMA-RDWYMI)*REDIT
         Y(3)=(RDWYMA-RDWYMI)*REDIT
         Y(4)=0.
         Y(5)=0.
      ENDIF
      CALL ISELNT(NTB)
      CALL ISFACI(0)
      CALL ISFAIS(1)
      CALL ISTXFP(0,2)
      CALL IGBOX(X1,X2,Y1,Y2)
      CALL IGAXIS(X1,X2,Y1,Y1,X1,X2,1,'NB')
      CALL IGAXIS(X1,X1,Y1,Y2,Y1,Y2,1,'NB')
      IF(NTB.EQ.NTSAV)THEN
         CALL ISMKSC(2.)
         CALL ISMK(29)
         XP=(X2-X1)/2
         YP=(Y2-Y1)/2
         CALL IPM(1,XP,YP)
      ENDIF
      CALL ISPLCI(1)
      CALL ISLN(ILNTY)
      CALL IPL(5,X,Y)
      CALL IZSET
      CALL ISELNT(NTSAV)
      ZFLAG=ZFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFS
*
      END
+DECK,  IGCCOL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IGCCOL(IVAL,CHVALI)
*.===========>
*.
*.   Convert color index in color name
*.
*..==========> (O.Couet)
      CHARACTER*(*) CHVALI
*.______________________________________
*
      IF(IVAL.EQ.2)CHVALI='Red'
      IF(IVAL.EQ.3)CHVALI='Green'
      IF(IVAL.EQ.4)CHVALI='Blue'
+SELF, IF=-DECGKS.
      IF(IVAL.EQ.0)CHVALI='Black'
      IF(IVAL.EQ.1)CHVALI='White'
      IF(IVAL.EQ.5)CHVALI='Yellow'
      IF(IVAL.EQ.6)CHVALI='Magenta'
      IF(IVAL.EQ.7)CHVALI='Cyan'
+SELF, IF=DECGKS.
      IF(IVAL.EQ.0)CHVALI='White'
      IF(IVAL.EQ.1)CHVALI='Black'
      IF(IVAL.EQ.6)CHVALI='Magenta'
      IF(IVAL.EQ.5)CHVALI='Cyan'
      IF(IVAL.EQ.7)CHVALI='Yellow'
+SELF.
*
      END
+DECK,  IGCFAI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IGCFAI(IVAL,CHVALI)
*.===========>
*.
*..==========> (O.Couet)
      CHARACTER*(*) CHVALI
*.______________________________________
*
      IF(IVAL.EQ.1)CHVALI='Solid'
      IF(IVAL.EQ.0)CHVALI='Hollow'
      IF(IVAL.EQ.2)CHVALI='Pattern'
      IF(IVAL.EQ.3)CHVALI='Hatch'
*
      END
+DECK,  IGCLWN, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:23  mclareni
* Higz

      SUBROUTINE IGCLWN(NTCL)
*.===========>
*.
*.   This routine clears the window NTCL
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIFLAG.
      LOGICAL ZFS,GFS
*.______________________________________
*
      IF(NTCL.EQ.0)THEN
         CALL IGCLES
         RETURN
      ELSE
         CALL IZSAV
         ZFS=ZFLAG
         GFS=GFLAG
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         GFLAG=.TRUE.
*
         CALL ISELNT(NTCL)
         IF(LHNT.EQ.0)RETURN
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
         IWVA=IQ(LHNT+2)
         X1CL=Q(LHF+IWVA)
         X2CL=Q(LHF+IWVA+1)
         Y1CL=Q(LHF+IWVA+2)
         Y2CL=Q(LHF+IWVA+3)
         CALL IGSET('BORD',0.)
         CALL ISFACI(0)
         CALL ISFAIS(1)
         CALL IGBOX(X1CL,X2CL,Y1CL,Y2CL)
         CALL IZSET
         ZFLAG=ZFS
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         GFLAG=GFS
      ENDIF
*
      END
+DECK,  IGEX, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IGEX(X1,X2)
*.===========>
*.
*.   This routine exchange X1 and X2 in order than X2 > X1 .
*.
*..==========> (O.Couet)
      IF(X2.LT.X1)THEN
         XT=X2
         X2=X1
         X1=XT
      ENDIF
*
      END
+DECK,  IGFIRS, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IGFIRS(CHDEF,STRING)
*.===========>
*.
*.   This routine puts the STRING in the first place in CHDEF.
*.
*..==========> (O.Couet)
      CHARACTER*(*) CHDEF,STRING
      CHARACTER*80 CHINT,CHINT2
*.______________________________________
*
      ILEN1=LENOCC(CHDEF)
      ILEN2=LENOCC(STRING)
      I1=INDEX(CHDEF,STRING(1:ILEN2))
      CHINT=' '
      CHINT2=' '
      IF(I1.EQ.1)RETURN
      CHINT=CHDEF(I1:ILEN1)
      II2=LENOCC(CHINT)
      CHINT2=CHDEF(1:I1-2)
      I2=LENOCC(CHINT2)
      CHDEF=CHINT(1:II2)//','//CHINT2(1:I2)
*
      END
+DECK,  IGGRID, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IGGRID(XG,YG)
*.===========>
*.
*. Align a point on the current defined grid.
*. This routine do nothing if no grid is defined.
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIATT.
*.______________________________________
*
      IF((IXSTEP*IXFACT.NE.0).AND.(IYSTEP*IYFACT.NE.0))THEN
         XGDX=(RWXMAX-RWXMIN)/FLOAT(IXSTEP*IXFACT)
         YGDY=(RWYMAX-RWYMIN)/FLOAT(IYSTEP*IYFACT)
         XG=FLOAT(INT((XG+(0.5*XGDX))/XGDX))*XGDX
         YG=FLOAT(INT((YG+(0.5*YGDY))/YGDY))*YGDY
      ENDIF
*
      END
+DECK,  IGICOL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      INTEGER FUNCTION IGICOL(CHVALI)
*.===========>
*.
*.   Convert color name in color index
*.
*..==========> (O.Couet)
      CHARACTER*(*) CHVALI
*.______________________________________
*
      IGICOL=0
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Red')IGICOL=2
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Green')IGICOL=3
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Blue')IGICOL=4
+SELF, IF=-DECGKS.
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Black')IGICOL=0
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'White')IGICOL=1
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Yellow')IGICOL=5
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Magenta')IGICOL=6
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Cyan')IGICOL=7
+SELF, IF=DECGKS.
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'White')IGICOL=0
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Black')IGICOL=1
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Magenta')IGICOL=6
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Cyan')IGICOL=5
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Yellow')IGICOL=7
+SELF.
*
      END
+DECK,  IGIFAI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      INTEGER FUNCTION IGIFAI(CHVALI)
*.===========>
*.
*..==========> (O.Couet)
      CHARACTER*(*) CHVALI
*.______________________________________
*
      IGIFAI=0
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Solid')IGIFAI=1
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Hollow')IGIFAI=0
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Pattern')IGIFAI=2
      IF(CHVALI(1:LENOCC(CHVALI)).EQ.'Hatch')IGIFAI=3
*
      END
+DECK,  IGINME, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IGINME
*.===========>
*.
*.   This routine initialize the menu package and the
*. default primitives attributes of the editor.
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
      LOGICAL ZFS,GFS
*.______________________________________
*
      ZFS=ZFLAG
      GFS=GFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
*
*              Polyline
*
      ICPLCI=1
      ICLN=1
      RCLWSC=1.
      CALL ISPLCI(ICPLCI)
      CALL ISLWSC(RCLWSC)
      CALL ISLN(ICLN)
      CHPLC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
*
*              Fill area
*
      ICFACI=1
      ICFAIS=0
+SELF, IF=GKSGRAL.
      ICFASI=-3
+SELF, IF=-GKSGRAL.
      ICFASI=1
+SELF.
      CALL ISFACI(ICFACI)
      CALL ISFAIS(ICFAIS)
      CALL ISFASI(ICFASI)
      CHFAC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHFAIS='Hollow,Solid,Pattern,Hatch'
*
*              Polymarker
*
      ICPMCI=1
      ICMK=3
      RCMKSC=1.
      CALL ISMKSC(RCMKSC)
      CALL ISPMCI(ICPMCI)
      CALL ISMK(ICMK)
      CHPMC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
*
*              Text
*
      ICTXCI=1
      RCTXAN=0.
      RCTXSI=.5
      ICTXFT=0
      ICTXPR=2
      ICTXCI=1
      ICTXAH=0
      ICTXAV=0
      CALL IGSET('TANG',0.)
      CALL ISCHH(RCTXSI)
      CALL ISTXFP(1,0)
      CALL ISTXCI(ICTXCI)
      CALL ISTXAL(ICTXAH,ICTXAV)
      CCTX=' '
      CHTXC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
*
*              Histogram
*
      CHOPHI='HF'
      RCBOF=0.250
      RCBWD=0.500
      ICHILN=1
      ICHIPC=1
      ICHIFC=1
      ICHIFI=0
+SELF, IF=GKSGRAL.
      ICHIFS=-3
+SELF, IF=-GKSGRAL.
      ICHIFS=1
+SELF.
      CHHIIS='Hollow,Solid,Pattern,Hatch'
      CHHIFC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHHIPC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CALL IGSET('BARO',0.250)
      CALL IGSET('BARW',0.500)
*
*              Software text
*
      RCSTAN=0.
      RCSTSI=.5
      ICSTPA=1
      RCSTSH=0.
      CHOPST='L'
      ICSTCI=1
      CCST=' '
      CALL IGSET('CSHI',RCSTSH)
      CALL IGSET('PASS',FLOAT(ICSTPA))
      CHSTC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
*
*              Boxe
*
      ICBOCI=1
      ICBOIS=0
+SELF, IF=GKSGRAL.
      ICBOSI=-3
+SELF, IF=-GKSGRAL.
      ICBOSI=1
+SELF.
      ICBOBO=1
      CHBOC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHBOIS='Hollow,Solid,Pattern,Hatch'
      CHBOBO='Yes,No'
      CALL IGSET('BORD',1.)
*
*              Frame boxe
*
      ICFBCI=1
      ICFBIS=0
+SELF, IF=GKSGRAL.
      ICFBSI=-3
+SELF, IF=-GKSGRAL.
      ICFBSI=1
+SELF.
      ICFBBO=1
      CHFBC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHFBIS='Hollow,Solid,Pattern,Hatch'
      CHFBBO='Yes,No'
*
*              Arrow
*
      RCARSI=.4
      CHDOAR='No,Yes'
      CHAFL='No,Yes'
      ICARLC=1
      ICARFC=1
      ICARFI=0
+SELF, IF=GKSGRAL.
      ICARFS=-3
+SELF, IF=-GKSGRAL.
      ICARFS=1
+SELF.
      ICARLN=1
      CHARFC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHARLC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHARFI='Hollow,Solid,Pattern,Hatch'
*
*              Pave
*
      ICPBST=0
+SELF, IF=GKSGRAL.
      ICPFST=-3
+SELF, IF=-GKSGRAL.
      ICPFST=1
+SELF.
      RCDZPV=0.5
      CHOPPV='TR'
*
*              Axis
*
      RCAXTS=0.1
      RCAXLS=0.1
      RCAXLO=0.1
      RCAXW1=0.
      RCAXW2=1.
      ICAXND=10
      ICAXLN=1
      ICAXLC=1
      ICAXLF=1
      ICAXLP=0
      CHOPAX=' '
      CHAXLC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
*
*              Arc
*
      ICACFI=0
+SELF, IF=GKSGRAL.
      ICACFS=-3
+SELF, IF=-GKSGRAL.
      ICACFS=1
+SELF.
      ICACBO=1
      ICACLC=1
      ICACFC=1
      CHACIS='Hollow,Solid,Pattern,Hatch'
      CHACLC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHACFC='White,Black,Red,Green,Blue,Magenta,Cyan,Yellow'
      CHACBO='Yes,No'
*
*              Grid
*
      IXSTEP=0
      IYSTEP=0
      IXFACT=1
      IYFACT=1
*
      DO 10 I=1,3
         ICUCHO(I)=0
         ICUMEN(I)=0
 10   CONTINUE
*
      ZFLAG=ZFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFS
      END
+DECK,  IGLINE, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IGLINE(XS,XE,YS,YE)
*.===========>
*.
*.   Draw a line between two points
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
      DIMENSION X(2),Y(2)
      LOGICAL GFS,ZFS
*.______________________________________
*
      GFS=GFLAG
      ZFS=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
*
      CALL IZSAV
      X(1)=XS
      X(2)=XE
      Y(1)=YS
      Y(2)=YE
      CALL ISLN(1)
      CALL ISPLCI(1)
      CALL IPL(2,X,Y)
      CALL IZSET
*
      ZFLAG=ZFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFS
*
      END
+DECK,  IGPLOT, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IGPLOT(X,Y)
*.===========>
*.
*.   Plot a blank point at the position X,Y
*.
*..==========> (O.Couet)
+CDE, HIFLAG.
      LOGICAL ZFS
*.______________________________________
*
      ZFS=ZFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL IZSAV
      CALL ISMK(1)
      CALL ISPMCI(1)
      CALL IPM(1,X,Y)
      CALL IZSET
      ZFLAG=ZFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
      END
+DECK,  IGREQ, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IGREQ(MN,NBUSE,NBI,IPLAC,ICHOIC,CHVAL)
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIGED.
+CDE, HIFLAG.
+CDE, HIATT.
      PARAMETER (CHSIZ=0.025)
      CHARACTER*(*) CHVAL(NBI)
      CHARACTER*8 CHOPT
      LOGICAL ZFS,GFS
*.______________________________________
*
      ZFS=ZFLAG
      GFS=GFLAG
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
*
      IPLACE=IPLAC
      NBITEM(IPLACE)=NBI
      NBU(IPLACE)=NBUSE
      CHOPT=' '
*
      IF(NBU(IPLACE).NE.0)THEN
         INC=1
      ELSE
         INC=0
      ENDIF
*
      IF(IPLACE.EQ.1)THEN
         XPM(1,1)=REDIT+0.005
         XPM(2,1)=1.-0.015
         YPM(2,1)=1.-0.015
         YPM(1,1)=YPM(2,1)-CHSIZ*(NBI+INC)
      ENDIF
      IF(IPLACE.EQ.2)THEN
         XPM(1,2)=XPM(1,1)
         XPM(2,2)=XPM(2,1)
         YPM(2,2)=YPM(1,1)-0.03
         YPM(1,2)=YPM(2,2)-CHSIZ*(NBI+INC)
      ENDIF
      IF(IPLACE.EQ.3)THEN
         XPM(1,3)=0.001
         XPM(2,3)=REDIT-0.015
         YPM(2,3)=YPM(2,1)
         YPM(1,3)=YPM(2,1)-CHSIZ*(NBI+INC)
         IF(YPM(1,3).LT.REDIT+0.005)YPM(1,3)=REDIT+0.005
      ENDIF
*
      DO 10 I=IPLACE+1,3
         IF(ICUMEN(I).NE.0)THEN
            CALL IGMENU(0,TITLE(I)
     +,                 XPM(1,I),XPM(2,I)
     +,                 YPM(1,I),YPM(2,I)
     +,                 NBU(I),CHUSKE(1,I)
     +,                 NBITEM(I),CHITEM(1,I)
     +,                 CHDEF,CHVAL,ICHOI,'EW')
            ICUMEN(I)=0
            ICUCHO(I)=0
         ENDIF
   10 CONTINUE
*
      IF((ICUMEN(IPLACE).EQ.MN))THEN
         CHOPT(1:3)='WT '
      ELSE
         CHOPT(1:3)='DWT'
         ICUMEN(IPLACE)=MN
      ENDIF
      IF(IPLACE.EQ.3)CHOPT(4:4)='P'
      IF(JBIT(ISOF,1).NE.0)CHOPT(5:5)='S'
      IF(JBIT(ISOF,2).NE.0)CHOPT(6:6)='A'
*
      CALL IGMENU(0,TITLE(IPLACE)
     +,XPM(1,IPLACE),XPM(2,IPLACE)
     +,YPM(1,IPLACE),YPM(2,IPLACE)
     +,NBU(IPLACE),CHUSKE(1,IPLACE)
     +,NBITEM(IPLACE),CHITEM(1,IPLACE)
     +,CHDEF,CHVAL,ICHOI,CHOPT)
*
      IF(IPLACE.EQ.3)THEN
         CALL IGMENU(0,TITLE(IPLACE)
     +,              XPM(1,IPLACE),XPM(2,IPLACE)
     +,              YPM(1,IPLACE),YPM(2,IPLACE)
     +,              NBU(IPLACE),CHUSKE(1,IPLACE)
     +,              NBITEM(IPLACE),CHITEM(1,IPLACE)
     +,              CHDEF,CHVAL,ICHOI,'CPRT')
      ELSE
         ICHOI=ICUCHO(IPLACE)
         CALL IGMENU(0,TITLE(IPLACE)
     +,              XPM(1,IPLACE),XPM(2,IPLACE)
     +,              YPM(1,IPLACE),YPM(2,IPLACE)
     +,              NBU(IPLACE),CHUSKE(1,IPLACE)
     +,              NBITEM(IPLACE),CHITEM(1,IPLACE)
     +,              CHDEF,CHVAL,ICHOI,'CHRT')
      ENDIF
*
*              Picked outside the menu
*
      IF(ICHOI.EQ.0)THEN
         ILOOP=IPLACE-1
         DO 30 I=ILOOP,1,-1
            CALL IGMENU(0,TITLE(I)
     + ,                XPM(1,I),XPM(2,I)
     +,                 YPM(1,I),YPM(2,I)
     +,                 NBU(I),CHUSKE(1,I)
     +,                 NBITEM(I),CHITEM(1,I)
     +,                 CHDEF,CHVAL,ICHOI,'CNT')
            IF(ICHOI.NE.0)THEN
               IPLACE=I
               DO 20 J=3,IPLACE+1,-1
                  IF(ICUMEN(J).NE.0)THEN
                     CALL IGMENU(0,TITLE(J)
     +,                          XPM(1,J),XPM(2,J)
     +,                          YPM(1,J),YPM(2,J)
     +,                          NBU(J),CHUSKE(1,J)
     +,                          NBITEM(J),CHITEM(1,J)
     +,                          CHDEF,CHVAL,ICHOI,'EW')
                     ICUMEN(J)=0
                     ICUCHO(J)=0
                  ENDIF
   20          CONTINUE
               ICHOI=ICUCHO(IPLACE)
               CALL IGMENU(0,TITLE(I)
     + ,                   XPM(1,I),XPM(2,I)
     +,                    YPM(1,I),YPM(2,I)
     +,                    NBU(I),CHUSKE(1,I)
     +,                    NBITEM(I),CHITEM(1,I)
     +,                    CHDEF,CHVAL,ICHOI,'TCNH')
               IPLAC=IPLACE
               GOTO 40
            ENDIF
   30    CONTINUE
         IF(ICHOI.EQ.0)THEN
            IPLAC=0
         ENDIF
         GOTO 50
      ENDIF
*
*              Picked into the title bar
*
      IF(ICHOI.EQ.-100)THEN
         ICHOI=-1000
      ENDIF
*
   40 IF(ICHOI.GT.0)ICUCHO(IPLACE)=ICHOI
   50 ICHOIC=ICHOI
*
      IF(ICHOI.LT.0.AND.ICHOI.GT.-100)THEN
         CALL IGMENU(0,TITLE(IPLACE)
     +,              XPM(1,IPLACE),XPM(2,IPLACE)
     +,              YPM(1,IPLACE),YPM(2,IPLACE)
     +,              NBU(IPLACE),CHUSKE(1,IPLACE)
     +,              NBITEM(IPLACE),CHITEM(1,IPLACE)
     +,              CHDEF,CHVAL,ABS(ICHOI),'UT')
      ENDIF
*
      ZFLAG=ZFS
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=GFS
*
      END
+DECK,  IZGED, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IZGED(PNAMEI,CHOPT)
*.===========>
*.
*.   This routine invokes the graphics editor .
*.
*. CHOPT='S': Software character for the menus.
*. CHOPT='A': shAdow mode is used.
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATT.
+CDE, HIFLAG.
+CDE, HIGED.
+CDE, HIATNB.
+CDE, HISVED.
+CDE, HICODE.
      CHARACTER*(*) PNAMEI,CHOPT
      CHARACTER*32 CHVAL(15)
      CHARACTER*20 MERPIC,PRIPIC,SHOPIC,REAPIC,PNAME
      CHARACTER*12 CINTR
      DIMENSION IOPT(2)
      EQUIVALENCE (IOPT(1),IOPTS),(IOPT(2),IOPTA)
      LOGICAL ZFS
      DIMENSION RATVAL(NBRATT)
      EQUIVALENCE (RATVAL(1),RMKSC)
      DIMENSION IATVAL(NBIATT)
      EQUIVALENCE (IATVAL(1),IPLCI)
+CDE, HIATNM.
*.______________________________________
*
      CALL UOPTC(CHOPT,'SA',IOPT)
      PNAME=PNAMEI
*
*              Adressing pictures by number
*
      INUM=IGASCI(PNAME(1:1))
      IF(49.LE.INUM.AND.INUM.LE.57)THEN
         READ (PNAME,'(I15)',ERR=20   ) INUM
         IF(INUM.GT.NBPICT)THEN
            CALL IGERR('Number of pictures is not so big','IZGED')
            RETURN
         ENDIF
         LP=LQ(LHIGZ)
         DO 10     I=1,INUM-1
            LP=LQ(LP)
   10    CONTINUE
         LCH=LQ(LP-4)
         CALL UHTOC(IQ(LCH+1),4,PNAME,IQ(LP+1))
         GOTO 30
   20    CALL IGERR('PNAME must begin with a letter','IZGED')
         RETURN
      ENDIF
   30 CONTINUE
*
      DO 40 I=1,NBIATT
         ISAVED(I)=IATVAL(I)
   40 CONTINUE
      DO 50 I=1,NBRATT
         RSAVED(I)=RATVAL(I)
   50 CONTINUE
*
*              Encoding ISOF
*
      ISOF=0
      IF(IOPTS.NE.0)CALL SBIT1(ISOF,1)
      IF(IOPTA.NE.0)CALL SBIT1(ISOF,2)
*
      WX1S=RDWXMI
      WX2S=RDWXMA
      WY1S=RDWYMI
      WY2S=RDWYMA
      VX1S=RDVXMI
      VX2S=RDVXMA
      VY1S=RDVYMI
      VY2S=RDVYMA
      IF(RMDSX.GE.RMDSY)THEN
         CALL ISWKWN(IDID,0.,1.,0.,RMDSY/RMDSX)
      ELSE
         CALL ISWKWN(IDID,0.,RMDSX/RMDSY,0.,1.)
      ENDIF
      CALL ISWKVP(IDID,0.,RMDSX,0.,RMDSY)
*
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      REDITS=REDIT
      CALL IGSRAP(0.)
      CALL ICLRWK(1,1)
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL IGSRAP(4./5.)
      CALL IGCLES
*
*              Check the validity of the picture name
*
      IF(IZRPIP(PNAME).GT.0)THEN
         CALL IZPICT(PNAME,'DC')
         EDIPIC=PNAME
      ELSE
         IF(PNAME.NE.' ')THEN
            CALL IZPICT(PNAME,'M')
            EDIPIC=PNAME
         ELSE
            CALL IZPICT(EDIPIC,'R')
            IF(EDIPIC.NE.' ')THEN
               CALL IZPICT(EDIPIC,'DC')
            ELSE
               EDIPIC='PICTGED'
               CALL IZPICT(EDIPIC,'M')
               CALL IZPICT(EDIPIC,'C')
            ENDIF
         ENDIF
      ENDIF
*
*              Initialization
*
      CALL IGINME
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
*
*              Put the UNDO vode in all the NT banks
*              to protect the initial contains of the
*              picture
*
      LNT=LQ(LPICT-1)
      DO 60 I=1,IQ(LPICT+8)
         IF(LNT.EQ.0)GOTO 70
         IQ(LNT+IQ(LNT+4))=1000000*IUNDCO
         IQ(LNT+4)=IQ(LNT+4)+1
         IF(LNT.EQ.LHNT)ITBPTR=ITBPTR+1
         LNT=LQ(LNT)
   60 CONTINUE
*
*              Select the NT with the higher priority
*
   70 IHNTR=IQ(IZGNGT(LPICT,IZGHNP(LPICT)-1)+1)
      CALL ISELNT(IHNTR)
*.______________________________________
*
*              Start with the GED menu mode
*
   80 TITLE(1)='MAIN MENU'
      CHITEM(1,1)='|Primitives'
      CHITEM(2,1)='|Windows'
      CHITEM(3,1)='|Pictures'
      CHITEM(4,1)='|Files'
      CHUSKE(1,1)='Exit'
      IPLACE=1
      CALL IGREQ(11,1,4,IPLACE,ICHOIC,CHVAL)
*
   90 CONTINUE
*
      IF(ICHOIC.EQ.-1)GOTO 270
*
      IF(ICHOIC.EQ.-1000)GOTO 80
*
      IF(ICHOIC.EQ.1)GOTO 100
*
      IF(ICHOIC.EQ.2)GOTO 140
*
      IF(ICHOIC.EQ.3)GOTO 220
*
      IF(ICHOIC.EQ.4)GOTO 260
*
      GOTO 80
*.______________________________________
*
*              Primitives Menu
*
  100 TITLE(2)='PRIMITIVES'
      CHITEM(1,2)='Software text'
      CHITEM(2,2)='Text'
      CHITEM(3,2)='Fill area'
      CHITEM(4,2)='Polyline'
      CHITEM(5,2)='Polymarker'
      CHITEM(6,2)='Axis'
      CHITEM(7,2)='Arc'
      CHITEM(8,2)='Box'
      CHITEM(9,2)='Paving-block'
      CHITEM(10,2)='Frame box'
      CHITEM(11,2)='Arrow'
      CHITEM(12,2)='|Change Att.'
      CHITEM(13,2)='|Delete'
      CHITEM(14,2)='|Move'
      CHITEM(15,2)='|Front'
      CHITEM(16,2)='Grid'
      CHUSKE(1,2)='Att.'
      CHUSKE(2,2)='Redr.'
      CHUSKE(3,2)='Undo'
      IPLACE=2
      CALL IGREQ(21,3,16,IPLACE,ICHOIC,CHVAL)
*
  110 CONTINUE
*
      IF(IPLACE.EQ.1)GOTO 90
*
      IF(ICHOIC.EQ.-1)GOTO 100
*
      IF(ICHOIC.EQ.-1000)GOTO 100
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 100
      ENDIF
*
      IF(ICHOIC.EQ.-3)THEN
         CALL IZUNDO
         GOTO 100
      ENDIF
*
      IF(ICHOIC.EQ.1)THEN
         CALL IESTX(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.2)THEN
         CALL IETX(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.3)THEN
         CALL IEFA(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.4)THEN
         CALL IEPL(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.5)THEN
         CALL IEPM(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.6)THEN
         CALL IEAXIS(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.7)THEN
         CALL IEARC(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.8)THEN
         CALL IEBOX(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.9)THEN
         CALL IEPAVE(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.10)THEN
         CALL IEFBOX(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.11)THEN
         CALL IEARRO(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.12)THEN
         CALL IECPA(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.13)THEN
         CALL IEDELE(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.14)THEN
         CALL IEMOPR(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.15)THEN
         CALL IEPOP(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 110
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.16)THEN
         TITLE(3)='GRID ATTRIBUTES'
         CHITEM(1,3)='X Step'
         CHITEM(2,3)='Y Step'
         CHITEM(3,3)='X Factor'
         CHITEM(4,3)='Y Factor'
         CHITEM(5,3)='Grid'
         IPLACE=3
         IF(IXSTEP.EQ.0.AND.IYSTEP.EQ.0)THEN
            IXSTEP=RWXMAX
            IYSTEP=RWYMAX
         ENDIF
         CALL IZITOC(IXSTEP,CHDEF(1))
         CALL IZITOC(IYSTEP,CHDEF(2))
         CALL IZITOC(IXFACT,CHDEF(3))
         CALL IZITOC(IYFACT,CHDEF(4))
         CHDEF(5)='Yes,No'
         CALL IGREQ(217,0,5,IPLACE,ICHOIC,CHVAL)
         IF(IPLACE.EQ.1)GOTO 90
         IF(IPLACE.EQ.2)GOTO 110
         CALL IZCTOI(CHVAL(1),IXSTEP)
         CALL IZCTOI(CHVAL(2),IYSTEP)
         CALL IZCTOI(CHVAL(3),IXFACT)
         CALL IZCTOI(CHVAL(4),IYFACT)
         IF(CHVAL(5).EQ.'No')THEN
            IXFACT=0
            GOTO 100
         ENDIF
         IF(IXSTEP.EQ.0.AND.IYSTEP.NE.0)IXSTEP=IYSTEP
         IF(IXSTEP.NE.0.AND.IYSTEP.EQ.0)IYSTEP=IXSTEP
         IF(IXSTEP.EQ.0.AND.IYSTEP.EQ.0)GOTO 100
         IF(IXFACT.EQ.0.AND.IYFACT.NE.0)IXFACT=IYFACT
         IF(IXFACT.NE.0.AND.IYFACT.EQ.0)IYFACT=IXFACT
         IF(IXFACT.EQ.0.AND.IYFACT.EQ.0)GOTO 100
         CALL IEGRID
      ENDIF
*
      GOTO 100
*.______________________________________
*
*              Windows Menu
*
  140 TITLE(2)='WINDOWS'
      CHITEM(1,2)='|Create'
      CHITEM(2,2)='  '
      CHITEM(3,2)='Select'
      CHITEM(4,2)='Move'
      CHITEM(5,2)='Show'
      CHITEM(6,2)='Push behind'
      CHITEM(7,2)=' '
      CHITEM(8,2)=' '
      CALL IZITOC(INTR,CINTR)
      CHUSKE(1,2)=CINTR
      CHUSKE(2,2)='Redraw'
      IPLACE=2
      CALL IGREQ(31,2,8,IPLACE,ICHOIC,CHVAL)
*
  150 CONTINUE
*
      IF(IPLACE.EQ.1)GOTO 90
*
      IF(ICHOIC.EQ.-1000)GOTO 140
*
      IF(ICHOIC.EQ.-1)GOTO 140
*
      IF(ICHOIC.EQ.-2)THEN
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         CALL IEGRID
         GOTO 140
      ENDIF
*
      IF(ICHOIC.EQ.1)THEN
         CALL IEWIN(ICF,ICHOIC)
         IF(ICHOIC.NE.0)THEN
            IF(ICF.EQ.1)GOTO 90
            IF(ICF.EQ.2)GOTO 150
         ENDIF
      ENDIF
*
      IF(ICHOIC.EQ.2)THEN
      ENDIF
*
      IF(ICHOIC.EQ.3)THEN
         IPLACE=2
  160    CALL IGREQ(31,2,8,IPLACE,ICHOIC,CHVAL)
         IF(IPLACE.EQ.1)GOTO 90
         IF(ICHOIC.NE.0)GOTO 150
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL ISELNT(IQUEST(10))
         CALL IZITOC(IQUEST(10),CINTR)
         CHUSKE(1,2)=CINTR
         IPLACE=2
         CALL IGMENU(0,TITLE(IPLACE)
     +,  XPM(1,IPLACE),XPM(2,IPLACE)
     +,  YPM(1,IPLACE),YPM(2,IPLACE)
     +,  NBU(IPLACE),CHUSKE(1,IPLACE)
     +,  NBITEM(IPLACE),CHITEM(1,IPLACE)
     +,  CHDEF,CHVAL,1,'UWT')
         GOTO 160
      ENDIF
*
      IF(ICHOIC.EQ.4)THEN
  170    IF(INTR.EQ.0)GOTO 140
         INTSAV=INTR
         CALL ISELNT(0)
         IPLACE=2
         CALL IGREQ(31,2,8,IPLACE,ICHOIC,CHVAL)
         IF(IPLACE.EQ.1)THEN
            ZFLAG=.TRUE.
            GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
            CALL ISELNT(INTSAV)
            GOTO 90
         ENDIF
         IF(ICHOIC.NE.0)THEN
            ZFLAG=.TRUE.
            GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
            CALL ISELNT(INTSAV)
            GOTO 150
         ENDIF
         X(1)=RQUEST(13)
         Y(1)=RQUEST(14)
         IPLACE=2
         CALL IGREQ(31,2,8,IPLACE,ICHOIC,CHVAL)
         IF(IPLACE.EQ.1)THEN
            ZFLAG=.TRUE.
            GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
            CALL ISELNT(INTSAV)
            GOTO 90
         ENDIF
         IF(ICHOIC.NE.0)THEN
            ZFLAG=.TRUE.
            GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
            CALL ISELNT(INTSAV)
            GOTO 150
         ENDIF
         X(2)=RQUEST(13)
         Y(2)=RQUEST(14)
         ZFS=ZFLAG
         CALL IGCLWN(INTSAV)
         CALL IGEX(X(1),X(2))
         CALL IGEX(Y(1),Y(2))
         ZFLAG=.TRUE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         CALL ISVP(INTSAV,X(1),X(2),Y(1),Y(2))
         CALL ISELNT(INTSAV)
         ZFLAG=.FALSE.
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         LN=IZGNTP(INTSAV)
         CALL IZDNB(LN,LDI,LDF,LDC,0,0)
         ZFLAG=ZFS
         GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
         GOTO 170
      ENDIF
*
      IF(ICHOIC.EQ.5)THEN
         NGT=0
         LN=IZGNGT(LPICD,NGT)
         DO 190 I=1,IQ(LPICD+8)
            IF(LN.EQ.0)GOTO 140
            IWVA=IQ(LN+2)
            INTN=IQ(LN+1)
            ILNTY=1
            IF(INTN.EQ.INTR)ILNTY=2
            IF(INTN.EQ.0)GOTO 180
            CALL IGBORD(INTN
     +,               Q(LDF+IWVA)
     +,               Q(LDF+IWVA+1)
     +,               Q(LDF+IWVA+2)
     +,               Q(LDF+IWVA+3)
     +,               ILNTY)
  180       NGT=IQ(LN+3)
            LN=IZGNGT(LPICD,NGT)
  190    CONTINUE
      ENDIF
*
      IF(ICHOIC.EQ.6)THEN
         NGT=0
         LN=IZGNGT(LPICD,NGT)
         DO 200 I=1,IQ(LPICD+8)-1
            IF(LN.EQ.0)GOTO 210
            NGT=IQ(LN+3)
            CALL ISELNT(IQ(LN+1))
            LN=IZGNGT(LPICT,NGT)
  200    CONTINUE
  210    IHNTR=IQ(IZGNGT(LPICT,IZGHNP(LPICT)-1)+1)
         CALL IZITOC(IHNTR,CINTR)
         CHUSKE(1,2)=CINTR
         IPLACE=2
         CALL IGMENU(0,TITLE(IPLACE)
     +,  XPM(1,IPLACE),XPM(2,IPLACE)
     +,  YPM(1,IPLACE),YPM(2,IPLACE)
     +,  NBU(IPLACE),CHUSKE(1,IPLACE)
     +,  NBITEM(IPLACE),CHITEM(1,IPLACE)
     +,  CHDEF,CHVAL,1,'UTW')
         CALL ISELNT(IHNTR)
      ENDIF
*
      IF(ICHOIC.EQ.7)THEN
         IPLACE=2
         CALL IGREQ(31,2,8,IPLACE,ICHOIC,CHVAL)
         IF(IPLACE.EQ.1)GOTO 90
         IF(ICHOIC.GE.1)GOTO 150
         LPCOP=LPICD
         LNTCOP=IZGNTP(IQUEST(10))
      ENDIF
*
      GOTO 140
*.______________________________________
*
*              Pictures Menu
*
  220 TITLE(2)='PICTURES'
      CHITEM(1,2)='List'
      CHITEM(2,2)='Protect'
      CHITEM(3,2)='Merge'
      CHITEM(4,2)='Create'
      CHITEM(5,2)='Select'
      CHITEM(6,2)='Next'
      CHITEM(7,2)='Print struct.'
      CHITEM(8,2)='Show'
      CHUSKE(1,2)=EDIPIC
      IPLACE=2
      CALL IGREQ(41,1,8,IPLACE,ICHOIC,CHVAL)
*
  230 CONTINUE
*
      IF(IPLACE.EQ.1)GOTO 90
*
      IF(ICHOIC.EQ.-1.OR.ICHOIC.EQ.-1000)GOTO 220
*
      IF(ICHOIC.EQ.1)THEN
         CALL IZPICT(' ','L')
         GOTO 220
      ENDIF
*
      IF(ICHOIC.EQ.2)THEN
         LNT=LQ(LPICT-1)
         DO 240 I=1,IQ(LPICT+8)
            IF(LNT.EQ.0)GOTO 220
            IQ(LNT+IQ(LNT+4))=1000000*IUNDCO
            IQ(LNT+4)=IQ(LNT+4)+1
            IF(LNT.EQ.LHNT)ITBPTR=ITBPTR+1
            LNT=LQ(LNT)
  240    CONTINUE
      ENDIF
*
      IF(ICHOIC.EQ.3)THEN
         TITLE(3)=' '
         CHITEM(1,3)='Picture Name ?'
         IPLACE=3
         CHDEF(1)=' '
         CALL IGREQ(42,0,1,IPLACE,ICHOIC,MERPIC)
         IF(IPLACE.EQ.1)GOTO 90
         IF(IPLACE.EQ.2)GOTO 230
         IF(IZRPIP(MERPIC).LE.0)GOTO 220
         CALL CLTOU(MERPIC)
         INTSAV=INTR
         CALL ISELNT(0)
         IPLACE=2
         CALL IGREQ(41,1,8,IPLACE,ICHOIC,CHVAL)
         IF(IPLACE.EQ.1)THEN
            CALL ISELNT(INTSAV)
            GOTO 90
         ENDIF
         IF(ICHOIC.NE.0)THEN
            CALL ISELNT(INTSAV)
            GOTO 230
         ENDIF
         X(1)=RQUEST(13)
         Y(1)=RQUEST(14)
         IPLACE=2
         CALL IGREQ(41,1,8,IPLACE,ICHOIC,CHVAL)
         IF(IPLACE.EQ.1)THEN
            CALL ISELNT(INTSAV)
            GOTO 90
         ENDIF
         IF(ICHOIC.NE.0)THEN
            CALL ISELNT(INTSAV)
            GOTO 230
         ENDIF
         X(2)=RQUEST(13)
         Y(2)=RQUEST(14)
         CALL IGEX(X(1),X(2))
         CALL IGEX(Y(1),Y(2))
         CALL IZMERG(MERPIC,X(1),Y(1),X(2)-X(1),' ')
      ENDIF
*
      IF(ICHOIC.EQ.4)THEN
         TITLE(3)=' '
         CHITEM(1,3)='Picture Name ?'
         IPLACE=3
         CHDEF(1)=' '
         CALL IGREQ(42,0,1,IPLACE,ICHOIC,EDIPIC)
         CALL CLTOU(EDIPIC)
         CALL IZPICT(EDIPIC,'M')
         CALL IGCLES
         CALL ISELNT(0)
         GOTO 250
      ENDIF
*
      IF(ICHOIC.EQ.5)THEN
         TITLE(3)=' '
         CHITEM(1,3)='Picture Name ?'
         IPLACE=3
         CHDEF(1)=' '
         CALL IGREQ(42,0,1,IPLACE,ICHOIC,PRIPIC)
         CALL CLTOU(PRIPIC)
         IF(IPLACE.EQ.1)GOTO 90
         IF(IPLACE.EQ.2)GOTO 230
         IF(IZRPIP(PRIPIC).LE.0)GOTO 220
         EDIPIC=PRIPIC
         CALL IZPICT(EDIPIC,'C')
         CALL IGCLES
         CALL IZPICT(EDIPIC,'D')
         GOTO 250
      ENDIF
*
      IF(ICHOIC.EQ.6)THEN
         CALL IGCLES
         CALL IZPICT(' ','N')
         CALL IZPICT(' ','D')
         CALL IZPICT(EDIPIC,'R')
         GOTO 250
      ENDIF
*
      IF(ICHOIC.EQ.7)THEN
         TITLE(3)=' '
         CHITEM(1,3)='Picture Name ?'
         IPLACE=3
         CHDEF(1)=EDIPIC
         CALL IGREQ(42,0,1,IPLACE,ICHOIC,PRIPIC)
         CALL CLTOU(PRIPIC)
         CALL IZPICT(PRIPIC,'P')
         GOTO 220
      ENDIF
*
      IF(ICHOIC.EQ.8)THEN
         TITLE(3)=' '
         CHITEM(1,3)='Picture Name ?'
         IPLACE=3
         CHDEF(1)=' '
         CALL IGREQ(42,0,1,IPLACE,ICHOIC,SHOPIC)
         IF(IPLACE.EQ.1)GOTO 90
         IF(IPLACE.EQ.2)GOTO 230
         IF(IZRPIP(SHOPIC).LE.0)GOTO 220
         CALL CLTOU(SHOPIC)
         CALL IGSRAP(.3)
         CALL IGCLES
         CALL IZPICT(SHOPIC,'D')
         CALL IZPICT(EDIPIC,'C')
         CALL IGSRAP(.8)
         GOTO 220
      ENDIF
*
      GOTO 220
  250 CONTINUE
      CHUSKE(1,2)=EDIPIC(1:LENOCC(EDIPIC))
      IPLACE=2
      CALL IGMENU(0,TITLE(IPLACE),XPM(1,IPLACE),XPM(2,IPLACE),
     +YPM(1,IPLACE),YPM(2,IPLACE),NBU(IPLACE),CHUSKE(1,IPLACE)
     +,NBITEM(IPLACE),CHITEM(1,IPLACE),CHDEF,CHVAL,1,'UTW')
      GOTO 220
*.______________________________________
*
*              Files Menu
*
  260 TITLE(2)='FILES'
      CHITEM(1,2)='Save Picture'
      CHITEM(2,2)='Read Picture'
      IPLACE=2
      CALL IGREQ(51,0,2,IPLACE,ICHOIC,CHVAL)
*
      IF(IPLACE.EQ.1)GOTO 90
*
      IF(ICHOIC.EQ.-1.OR.ICHOIC.EQ.-1000)GOTO 260
*
      IF(ICHOIC.EQ.1)THEN
         CALL IZPIWI(EDIPIC)
         CALL IZOUT(EDIPIC,ICYCLE)
         GOTO 260
      ENDIF
*
      IF(ICHOIC.EQ.2)THEN
         TITLE(3)=' '
         CHITEM(1,3)='Picture Name ?'
         IPLACE=3
         CHDEF(1)=' '
         CALL IGREQ(42,0,1,IPLACE,ICHOIC,REAPIC)
         CALL CLTOU(PRIPIC)
         CALL IZIN(REAPIC,9999)
         GOTO 260
      ENDIF
*
      GOTO 260
*.______________________________________
*
*              End with the Graphics Editor
*
  270 CALL ISWKWN(IDID,WX1S,WX2S,WY1S,WY2S)
      CALL ISWKVP(IDID,VX1S,VX2S,VY1S,VY2S)
      CALL IGSRAP(0.)
      CALL ICLRWK(0,0)
      CALL IGSRAP(REDITS)
      DO 280 I=1,NBIATT
         CALL IGSET(CHIATT(I),FLOAT(ISAVED(I)))
  280 CONTINUE
      DO 290 I=1,NBRATT
         CALL IGSET(CHRATT(I),RSAVED(I))
  290 CONTINUE
      CALL IGSRAP(0.)
      CALL IZPIWI(EDIPIC)
*
      END
+DECK,  IZPICK, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IZPICK(NT,SNAME,NPRIM,CHOPT)
*.===========>
*.
*. This subroutine returns the pathname of a structure .
*.
*. _Input parameters:
*.
*.  INTEGER NT : Transformation number .
*.  CHARACTER CHOPT : Type of object to be picked .
*.
*. _Output parameters:
*.
*.  CHARACTER SNAME : Structure name .
*.  INTEGER NPRIM : Adress of the primitive in the NT bank.
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HICODE.
+CDE, HIATT.
+CDE, HIACA.
+CDE, HIFLAG.
      CHARACTER*(*) SNAME,CHOPT
      DIMENSION IOPT(1)
      DIMENSION X(10),Y(10)
      EQUIVALENCE (IOPTN,IOPT(1))
*.______________________________________
*
      CALL UOPTC (CHOPT,'N',IOPT)
      NPRIM=0
      SNAME=' '
      IF(LPICD.LE.0)GOTO 100
      LPSAV=LPICD
      CALL IZSCPI(LPICD)
*
      IF(IOPTN.NE.0)THEN
         PX=RQUEST(13)
         PY=RQUEST(14)
         NT=IQUEST(10)
         IBN=1
      ELSE
         CALL IGLOC(1,NT,IBN,XNDC,YNDC,PX,PY)
      ENDIF
      IF(IBN.EQ.0)GOTO 100
*
      LN=IZGNTP(NT)
      IF(LN.EQ.0)GOTO 100
      ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      CALL ISELNT(NT)
      IREPTR=9
      IIAA=IZGADR(LHNT,8)
      IRAA=IZGADR(LHNT,9)
*
      TEXTHE=Q(LHF+IRAA+ICHHCO-50)
      IALG=IQ(LHI+IIAA+ITXACO-80)
      IALH=INT(IALG/10.)
      DX=0.
      DY=0.
*
   10 IREPTR=IREPTR+1
      IADRI5=IREPTR
      ICHOPT=-1
      KATT=0
      IF(IREPTR.EQ.IQ(LHNT+4))GOTO 100
      ICOD=IZGCOD(LHNT,IREPTR)
      IADRI=IZGADR(LHNT,IREPTR)
*
      IF(ICOD.LT.0)THEN
         NBNOP=1
         IADRI2=ABS(IZGADR(LHNT,IREPTR))
   20    IF(IQ(LHNT+IADRI2).LT.0)THEN
            NBNOP=NBNOP+1
            IADRI2=ABS(IZGADR(LHNT,IADRI2))
            GOTO 20
         ENDIF
         IADRI2=IZGADR(LHNT,IADRI2)
         DO 40 I=1,NBNOP
            IF(IQ(LHI+IADRI2).EQ.0)GOTO 10
            IF(IZGCOD(LHI,IADRI2).EQ.3)THEN
               IADRI4=IZGADR(LHI,IADRI2)
               DX=DX+Q(LHF+IADRI4)
               DY=DY+Q(LHF+IADRI4+1)
            ENDIF
            IF(IQ(LHI+IADRI2).EQ.1.AND.KATT.EQ.0)THEN
               IADRI5=ABS(IZGADR(LHNT,IQ(LHI+IADRI2+2)))
               CALL IZSCAN(LHNT,IANGCO,IADRI5,-1,IPOS)
               IF(IPOS.EQ.0)GOTO 30
               IRR=IZGADR(LHNT,IPOS)
               CALL IZSCAN(LHNT,ITXACO,IADRI5,-1,IPOS)
               IF(IPOS.EQ.0)GOTO 30
               IALAD=IZGADR(LHNT,IPOS)-100000
               IALH=INT(IALAD/100)
               CALL IZSCAN(LHNT,ICHHCO,IADRI5,-1,IPOS)
               IF(IPOS.EQ.0)GOTO 30
               IACHH=IZGADR(LHNT,IPOS)
               TEXTHE=Q(LHF+IACHH)
   30          KATT=1
            ENDIF
            IF(IQ(LHI+IADRI2).EQ.2.AND.KATT.EQ.0)THEN
               IADRI5=ABS(IZGADR(LHNT,IQ(LHI+IADRI2+2)))
               ICHOPT=IQ(LHI+IADRI2+3)
               KATT=1
            ENDIF
            IADRI2=IQ(LHI+IADRI2+1)
   40    CONTINUE
         IADRI=IADRI2
         ICOD=ABS(ICOD)
      ENDIF
*
      IF(ICOD.EQ.ICHHCO)THEN
         TEXTHE=Q(LHF+IADRI)
      ENDIF
*
      IF(ICOD.EQ.IANGCO)THEN
      ENDIF
*
      IF(ICOD.EQ.ITXACO)THEN
         IALH=INT((IADRI-100000)/100)
      ENDIF
*______________ Polyline
      IF(ICOD.EQ.IPLCO)THEN
         IADRF=IQ(LHI+IADRI)
         N=IQ(LHI+IADRI+1)
         IF(DX.NE.0..OR.DY.NE.0.)THEN
            DO 50 I=0,N-1
               Q(LHF+IADRF+I)=Q(LHF+IADRF+I)+DX
               Q(LHF+IADRF+I+N)=Q(LHF+IADRF+I+N)+DY
   50       CONTINUE
         ENDIF
         IF(IZPKPL(PX,PY,N
     +,  Q(LHF+IADRF),Q(LHF+IADRF+N)).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
         ENDIF
         IF(DX.NE.0..OR.DY.NE.0.)THEN
            DO 60 I=0,N-1
               Q(LHF+IADRF+I)=Q(LHF+IADRF+I)-DX
               Q(LHF+IADRF+I+N)=Q(LHF+IADRF+I+N)-DY
   60       CONTINUE
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Polyline with 2 points
      IF(ICOD.EQ.IPL2CO)THEN
         IADRF=IADRI
         X(1)=Q(LHF+IADRF)+DX
         X(2)=Q(LHF+IADRF+1)+DX
         Y(1)=Q(LHF+IADRF+2)+DY
         Y(2)=Q(LHF+IADRF+3)+DY
         IF(IZPKPL(PX,PY,2,X,Y).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Polymarker
      IF(ICOD.EQ.IPMCO)THEN
         IADRF=IADRI
         S=1
         IF(REDIT.NE.0)THEN
            S=REDIT
         ENDIF
         DX=(S*0.01875*(RQUEST(21)-RQUEST(20)))/(RQUEST(31)-RQUEST(30))
         DY=(S*0.01875*(RQUEST(23)-RQUEST(22)))/(RQUEST(33)-RQUEST(32))
         DO 70 I=1,IQ(LHI+IADRI+1)
            XPMM=Q(LHF+IADRF+I-1)
            YPMM=Q(LHF+IADRF+I+N-1)
            IF(PX.GE.(XPMM-DX).AND.PX.LE.(XPMM+DX)
     +                       .AND.
     +         PY.GE.(YPMM-DY).AND.PY.LE.(YPMM+DY))THEN
               NPRIM=IREPTR
               IADRAT=IADRI5
               DX=0.
               DY=0.
               GOTO 10
            ENDIF
   70    CONTINUE
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Axis
      IF(ICOD.EQ.IAXICO)THEN
         IADRF=IQ(LHI+IADRI)
         X(1)=Q(LHF+IADRF)+DX
         X(2)=Q(LHF+IADRF+1)+DX
         Y(1)=Q(LHF+IADRF+2)+DY
         Y(2)=Q(LHF+IADRF+3)+DY
         IF(IZPKPL(PX,PY,2,X,Y).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
            IF(ICHOPT.NE.-1)THEN
               IACHOP=ICHOPT
            ELSE
               IACHOP=IQ(LHI+IADRI+2)
            ENDIF
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Fill area
      IF(ICOD.EQ.IFACO)THEN
         IADRF=IQ(LHI+IADRI)
         N=IQ(LHI+IADRI+1)
         IF(DX.NE.0..OR.DY.NE.0.)THEN
            DO 80 I=0,N-1
               Q(LHF+IADRF+I)=Q(LHF+IADRF+I)+DX
               Q(LHF+IADRF+I+N)=Q(LHF+IADRF+I+N)+DY
   80       CONTINUE
         ENDIF
         IF(IZPKFA(PX,PY,N
     +,  Q(LHF+IADRF),Q(LHF+IADRF+N)).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
         ENDIF
         IF(DX.NE.0..OR.DY.NE.0.)THEN
            DO 90 I=0,N-1
               Q(LHF+IADRF+I)=Q(LHF+IADRF+I)-DX
               Q(LHF+IADRF+I+N)=Q(LHF+IADRF+I+N)-DY
   90       CONTINUE
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Boxes
      IF(ICOD.EQ.IBXCO)THEN
         IADRF=IADRI
         X(1)=Q(LHF+IADRF)+DX
         X(2)=Q(LHF+IADRF)+DX
         X(3)=Q(LHF+IADRF+1)+DX
         X(4)=Q(LHF+IADRF+1)+DX
         Y(1)=Q(LHF+IADRF+2)+DY
         Y(2)=Q(LHF+IADRF+3)+DY
         Y(3)=Q(LHF+IADRF+3)+DY
         Y(4)=Q(LHF+IADRF+2)+DY
         IF(IZPKFA(PX,PY,4,X,Y).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Text
      IF(ICOD.EQ.ITXCO)THEN
         IADRF=IQ(LHI+IADRI)
         NCHP=IQ(LHI+IADRI+2)
         X(1)=Q(LHF+IADRF)+DX
         Y(1)=Q(LHF+IADRF+1)+DY
         IF(IALH.EQ.2)THEN
            X(1)=Q(LHF+IADRF)-((NCHP/2)*TEXTHE)+DX
         ENDIF
         IF(IALH.EQ.3)THEN
            X(1)=Q(LHF+IADRF)-(NCHP*TEXTHE)+DX
         ENDIF
         X(2)=X(1)
         Y(2)=Y(1)+TEXTHE
         X(3)=X(1)+NCHP*TEXTHE
         Y(3)=Y(2)
         X(4)=X(3)
         Y(4)=Y(1)
         IF(IZPKFA(PX,PY,4,X,Y).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ IGTEXT
      IF(ICOD.EQ.IGTXCO)THEN
         IF(ICHOPT.LT.0)THEN
            ICHOPT=IQ(LHI+IADRI+3)
         ENDIF
         IADRF=IQ(LHI+IADRI)
         NCHP=IQ(LHI+IADRI+2)
         SSIZE=Q(LHF+IADRF+2)
         X(1)=Q(LHF+IADRF)+DX
         Y(1)=Q(LHF+IADRF+1)+DY
         IF(JBIT(ICHOPT,2).NE.0)THEN
            X(1)=Q(LHF+IADRF)-((NCHP/2)*SSIZE)+DX
         ENDIF
         IF(JBIT(ICHOPT,3).NE.0)THEN
            X(1)=Q(LHF+IADRF)-(NCHP*SSIZE)+DX
         ENDIF
         X(2)=X(1)
         Y(2)=Y(1)+SSIZE
         X(3)=X(1)+NCHP*SSIZE
         Y(3)=Y(2)
         X(4)=X(3)
         Y(4)=Y(1)
         IF(IZPKFA(PX,PY,4,X,Y).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
            IACHOP=ICHOPT
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Frame boxes
      IF(ICOD.EQ.IFBXCO)THEN
         IADRF=IADRI
         X(1)=Q(LHF+IADRF)+DX
         X(2)=Q(LHF+IADRF)+DX
         X(3)=Q(LHF+IADRF+1)+DX
         X(4)=Q(LHF+IADRF+1)+DX
         X(5)=Q(LHF+IADRF)+DX
         X(6)=Q(LHF+IADRF+4)+DX
         X(7)=Q(LHF+IADRF+5)+DX
         X(8)=Q(LHF+IADRF+5)+DX
         X(9)=Q(LHF+IADRF+4)+DX
         X(10)=Q(LHF+IADRF+4)+DX
         Y(1)=Q(LHF+IADRF+2)+DY
         Y(2)=Q(LHF+IADRF+3)+DY
         Y(3)=Q(LHF+IADRF+3)+DY
         Y(4)=Q(LHF+IADRF+2)+DY
         Y(5)=Q(LHF+IADRF+2)+DY
         Y(6)=Q(LHF+IADRF+6)+DY
         Y(7)=Q(LHF+IADRF+6)+DY
         Y(8)=Q(LHF+IADRF+7)+DY
         Y(9)=Q(LHF+IADRF+7)+DY
         Y(10)=Q(LHF+IADRF+6)+DY
         IF(IZPKFA(PX,PY,10,X,Y).NE.0)THEN
            NPRIM=IREPTR
            IADRAT=IADRI5
         ENDIF
         DX=0.
         DY=0.
         GOTO 10
      ENDIF
*______________ Histograms
      IF(ICOD.EQ.IHISCO)THEN
         IADRF=IQ(LHI+IADRI)
         NN=2
         IF(JBIT(IQ(LHI+IADRI+2),8).NE.0)THEN
            NN=IQ(LHI+IADRI+1)+1
         ENDIF
         IF(JBIT(IQ(LHI+IADRI+2),5).NE.0)THEN
C            CALL IGHIST(IQ(LIDECO+IADRI+1)
C     +,               Q(LFDECO+IADRF+NN)
C     +,               Q(LFDECO+IADRF)
C     +,               CHOPT)
            DX=0.
            DY=0.
            GOTO 10
         ELSE
C         CALL IGHIST(IQ(LIDECO+IADRI+1)
C     +,            Q(LFDECO+IADRF)
C     +,            Q(LFDECO+IADRF+NN)
C     +,            CHOPT)
            IF(PX.GE.Q(LHF+IADRF).AND.PX.LE.Q(LHF+IADRF+NN-1))THEN
               XINT=(Q(LHF+IADRF+NN-1)-Q(LHF+IADRF)) /IQ(LHI+IADRI+
     +         1)
               INDEX=(PX-Q(LHF+IADRF))/XINT
               IF(Q(LHF+IADRF+NN+INDEX).GE.PY)THEN
                  NPRIM=IREPTR
                  IADRAT=IADRI5
                  IF(ICHOPT.NE.-1)THEN
                     IACHOP=ICHOPT
                  ELSE
                     IACHOP=IQ(LHI+IADRI+2)
                  ENDIF
               ENDIF
            ENDIF
            DX=0.
            DY=0.
            GOTO 10
         ENDIF
      ENDIF
      DX=0.
      DY=0.
      GOTO 10
*
  100 CALL IZSCPI(LPSAV)
*
      END
+DECK,  IZPIWI, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      SUBROUTINE IZPIWI(PNAME)
*.===========>
*.
*.   This routine wipe the picture PNAME after editing.
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HICODE.
      CHARACTER*(*) PNAME
*.______________________________________
*
      CALL IZCOPY(PNAME,'PICWIP','C')
*
*              Delete the trailing attributes codes at the end
*            of each NT bank. This codes are not necessary because
*            there is no primitives after.
*
      CALL IZPICT('PICWIP','C')
      N=IQ(LPICT+8)
      LN=LQ(LPICT-1)
      DO 30 I=1,N
         CALL ISELNT(IQ(LN+1))
   10    IF(ITBPTR.EQ.10)GOTO 20
         IKCODE=IZGCOD(LHNT,ITBPTR-1)
         IF(IKCODE.GE.49)THEN
            IQ(LHNT+ITBPTR-1)=0
            ITBPTR=ITBPTR-1
            IQ(LHNT+4)=ITBPTR
            CALL IZCFA(IKCODE,1)
            GOTO 10
         ELSEIF(IKCODE.EQ.IUNDCO)THEN
            IQ(LHNT+ITBPTR-1)=0
            ITBPTR=ITBPTR-1
            IQ(LHNT+4)=ITBPTR
            GOTO 10
         ENDIF
   20    LN=LQ(LHNT)
         IF(LN.EQ.0)GOTO 40
   30 CONTINUE
*
   40 CALL IZPICT(PNAME,'S')
      CALL IZCOPY('PICWIP',PNAME,'R')
      END
+DECK,  IZPKFA, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      FUNCTION IZPKFA(XCUR,YCUR,N,XP,YP)
*.===========>
*.
*.   This function decides if a given fill area is picked or not .
*. If picked IZPKFA=1
*. If not picked IZPKFA=0
*.
*. _Input parameters:
*.
*.  REAL XCUR : X coordinate of the cursor
*.  REAL YCUR : Y coordinate of the cursor
*.  INTEGER N : Number of point in the fill area
*.  REAL XP(N) YP(N) : Fill area coordinates
*.
*..==========> (O.Couet)
      DIMENSION XLI(100),XP(*),YP(*)
*.______________________________________
*
      IZPKFA=0
      NBI=0
*
      DO 10 I=2,N+1
         I2=I
         I1=I-1
         IF(I.EQ.N+1)I2=1
*
*              Line segment parallel to oy
*
         IF(XP(I1).EQ.XP(I2))THEN
            IF(YP(I1).LT.YP(I2))THEN
               YI=YP(I1)
               YIP=YP(I2)
            ELSE
               YI=YP(I2)
               YIP=YP(I1)
            ENDIF
            IF((YI.LT.YCUR).AND.(YCUR.LT.YIP))THEN
               NBI=NBI+1
               XLI(NBI)=XP(I1)
            ENDIF
            GOTO 10
         ENDIF
*
*              Line segment parallel to ox
*
         IF(YP(I1).EQ.YP(I2))THEN
            IF(YP(I1).EQ.YCUR)THEN
               NBI=NBI+1
               XLI(NBI)=XP(I1)
               NBI=NBI+1
               XLI(NBI)=XP(I2)
            ENDIF
            GOTO 10
         ENDIF
*
*              Other line segment
*
         A=(YP(I1)-YP(I2))/(XP(I1)-XP(I2))
         B=(YP(I2)*XP(I1)-XP(I2)*YP(I1))/(XP(I1)-XP(I2))
         IF(XP(I1).LT.XP(I2))THEN
            XI=XP(I1)
            XIP=XP(I2)
         ELSE
            XI=XP(I2)
            XIP=XP(I1)
         ENDIF
         XIN=(YCUR-B)/A
         IF((XI.LT.XIN).AND.(XIN.LT.XIP))THEN
            NBI=NBI+1
            XLI(NBI)=XIN
         ENDIF
   10 CONTINUE
*
*              Sorting of the x coordinates intersections
*
      INV=0
      M=NBI-1
   20 CONTINUE
      DO 30 I=1,M
         IF(XLI(I+1).LT.XLI(I))THEN
            INV=INV+1
            RLL=XLI(I)
            XLI(I)=XLI(I+1)
            XLI(I+1)=RLL
         ENDIF
   30 CONTINUE
      M=M-1
      IF(INV.EQ.0)GOTO 40
      INV=0
      GOTO 20
*
*              Place of the x cursor coordinates
*
   40 NB=0
      DO 50 I=1,NBI
         IF(XCUR.LT.XLI(I))GOTO 60
         NB=NB+1
   50 CONTINUE
   60 IF(MOD(NB,2).NE.0)THEN
         IZPKFA=1
      ENDIF
*
      END
+DECK,  IZPKPL, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:24  mclareni
* Higz

      FUNCTION IZPKPL (XCUR,YCUR,N,XP,YP)
*.===========>
*.
*.   This routine decides if a given polyline is picked or not .
*. If picked IZPKPL=1
*. If not picked IZPKPL=0
*.
*. _Input parameters:
*.
*.  REAL XCUR : X coordinate of the cursor
*.  REAL YCUR : Y coordinate of the cursor
*.  INTEGER N : Number of point in the polyline
*.  REAL XP(N) YP(N) : Polyline coordinates
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATT.
      DIMENSION XP(*),YP(*)
*.______________________________________
*
      S=1
      IF(REDIT.NE.0)THEN
         S=REDIT
      ENDIF
      DX=(S*0.01875*(RQUEST(21)-RQUEST(20)))/(RQUEST(31)-RQUEST(30))
      DY=(S*0.01875*(RQUEST(23)-RQUEST(22)))/(RQUEST(33)-RQUEST(32))
      NM=N-1
      IZPKPL=0
      BM=YCUR-DY
      BP=YCUR+DY
      AM=XCUR-DX
      AP=XCUR+DX
      DO 10 I=1,NM
         I1=I
         I2=I+1
*
*              Line segment parallel to oy
*
         IF(XP(I1).EQ.XP(I2))THEN
            IF((AM.LE.XP(I1)).AND.(XP(I2).LE.AP))THEN
               IF(YP(I1).LE.YP(I2))THEN
                  YI=YP(I1)
                  YIP=YP(I2)
               ELSE
                  YI=YP(I2)
                  YIP=YP(I1)
               ENDIF
               IF((YI.LE.YCUR).AND.(YCUR.LE.YIP))THEN
                  IZPKPL=1
                  RETURN
               ENDIF
            ENDIF
            GOTO 10
         ENDIF
*
*              Line segment paralel to ox
*
         IF(YP(I1).EQ.YP(I2))THEN
            IF((BM.LE.YP(I1)).AND.(YP(I1).LE.BP))THEN
               IF(XP(I1).LE.XP(I2))THEN
                  XI=XP(I1)
                  XIP=XP(I2)
               ELSE
                  XI=XP(I2)
                  XIP=XP(I1)
               ENDIF
               IF((XI.LE.XCUR).AND.(XCUR.LE.XIP))THEN
                  IZPKPL=1
                  RETURN
               ENDIF
            ENDIF
            GOTO 10
         ENDIF
*
*              Other line segment
*
         A=(YP(I1)-YP(I2))/(XP(I1)-XP(I2))
         B=(YP(I2)*XP(I1)-XP(I2)*YP(I1))/(XP(I1)-XP(I2))
         IF(XP(I1).LE.XP(I2))THEN
            XI=XP(I1)
            XIP=XP(I2)
         ELSE
            XI=XP(I2)
            XIP=XP(I1)
         ENDIF
         IF((XI.LE.XCUR).AND.(XCUR.LE.XIP))THEN
            AA=A*XCUR+B
            IF((BM.LE.AA).AND.(AA.LE.BP))THEN
               IZPKPL=1
               RETURN
            ENDIF
         ENDIF
         IF(YP(I1).LE.YP(I2))THEN
            YI=YP(I1)
            YIP=YP(I2)
         ELSE
            YI=YP(I2)
            YIP=YP(I1)
         ENDIF
         IF((YI.LE.YCUR).AND.(YCUR.LE.YIP))THEN
            BB=(YCUR-B)/A
            IF((AM.LE.BB).AND.(BB.LE.AP))THEN
               IZPKPL=1
               RETURN
            ENDIF
         ENDIF
   10 CONTINUE
*
      END
+DECK,  IZUNDO, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:25  mclareni
* Higz

      SUBROUTINE IZUNDO
*.===========>
*.
*..==========> (O.Couet)
+CDE, HIPAW.
+CDE, HIATT.
+CDE, HICODE.
+CDE, HIFLAG.
*.______________________________________
*
      ZFLAG=.FALSE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
*
   10 IF(ITBPTR.EQ.10)GOTO 30
      IKCODE=IZGCOD(LHNT,ITBPTR-1)
      IF(IKCODE.EQ.IUNDCO)GOTO 30
*
      IF(IKCODE.EQ.1)THEN
         IADRI=IZGADR(LHNT,ITBPTR-1)
         IADRNT=IQ(LHI+IADRI+2)
         IQ(LHNT+IADRNT)=ABS(1000000*IZGCOD(LHNT,IADRNT))
     +                       +IQ(LHI+IADRI+1)
         IQ(LHNT+ITBPTR-1)=0
         ITBPTR=ITBPTR-1
         IQ(LHNT+4)=ITBPTR
         GOTO 20
      ENDIF
*
      IF(IKCODE.GE.50)THEN
         IQ(LHNT+ITBPTR-1)=0
         ITBPTR=ITBPTR-1
         IQ(LHNT+4)=ITBPTR
         CALL IZCFA(IKCODE,1)
         GOTO 10
      ENDIF
*
      IF(IKCODE.LT.50)THEN
         IQ(LHNT+ITBPTR-1)=0
         ITBPTR=ITBPTR-1
         IQ(LHNT+4)=ITBPTR
      ENDIF
*
   20 CALL IGCLWN(INTR)
      CALL IZDNB(LHNT,LDI,LDF,LDC,0,0)
*
   30 ZFLAG=.TRUE.
      GLFLAG=(ZFLAG.OR.PFLAG.OR.MFLAG)
      GFLAG=.TRUE.
      END

+PATCH, EXAMPLES.
+DECK,  HIEX1, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz

      SUBROUTINE HIEX1
*.==========>
*.           Example of basic HIGZ. Polylines and fill areas
*..=========>
*
      COMMON /QUEST/ RQUEST(100)
      DIMENSION XZ(86),YZ(86)
      DATA XZ/
     +   0.6250,0.6875,0.9063,0.7500,0.7500,0.6875,0.6250,0.6875
     +  ,0.7500,0.8750,0.9688,1.0313,1.1563,1.2500,1.3125,1.5000
     +  ,1.6875,1.9375,2.0000,2.1250,2.1875,2.1875,2.2500,2.2500
     +  ,2.4375,2.4375,2.4688,2.5313,2.5313,2.5000,2.6250,2.6250
     +  ,2.7500,2.7188,2.7188,2.7188,2.9375,3.4375,3.7500,4.0625
     +  ,4.1250,4.0625,4.1250,4.1875,4.3125,4.3125,4.3125,4.3438
     +  ,4.3125,4.4375,4.5000,4.4375,4.4375,4.5625,4.5938,4.7188
     +  ,4.7813,4.7500,4.5313,4.5000,4.6250,4.6875,4.7188,4.7500
     +  ,4.8750,4.9625,4.9063,4.7500,4.6875,4.6563,4.3750,3.6875
     +  ,3.0625,2.8125,2.4375,2.0313,1.6563,1.4688,1.3438,1.3750
     +  ,1.4375,1.2500,1.1250,1.0000,0.8750,0.6250/
      DATA YZ/
     +   4.8750,4.6563,4.3750,4.1250,3.8750,3.6250,3.4375,3.3125
     +  ,3.1875,3.1563,3.2188,3.3438,3.5000,3.5938,3.6875,3.5625
     +  ,3.3125,3.0938,2.8438,2.7000,2.2188,1.8750,1.2813,1.0625
     +  ,1.0625,1.8750,2.5000,2.4688,2.1875,1.9688,1.5000,1.2500
     +  ,1.2500,1.5313,2.0625,2.6250,2.5938,2.6563,2.7500,3.0000
     +  ,2.7188,2.1250,1.6563,1.4375,1.4688,1.6250,2.0313,2.3125
     +  ,2.6250,2.3125,2.0625,1.6250,1.5000,1.5000,1.6250,2.0313
     +  ,2.3125,2.5000,2.7500,2.9375,3.2500,3.6250,3.2500,2.8125
     +  ,2.6250,2.6875,3.0625,3.5625,3.8750,4.0625,4.1875,4.1250
     +  ,4.0313,4.0938,4.0625,4.2500,4.4875,4.5000,4.4688,4.6875
     +  ,4.8750,4.7188,4.5250,4.4688,4.7188,4.8750/
      DATA NZ/86/
*
*          Define the size of the Picture in cm
*
      CALL ICLRWK(0,1)
      CALL IGRNG(14.5,14.5)
      R  = RQUEST(11)
      XL = RQUEST(12)
      YB = RQUEST(13)
      CALL IGBOX(0.,14.5,0.,14.5)
      CALL IGTEXT(7.25,13.5,'HIGZ example 1',0.6,0.,'C')
*
*          Define a new Normalization transformation for each new object
*          The viewports are set in the centimeter space defined by IGRNG
*
      CALL ISWN(10,0.,5.,0.,5.)
      CALL ISVP(10,0.5*R+XL,6.5*r+XL,6.5*R+YB,11.5*r+YB)
      CALL ISELNT(10)
      CALL IPL(NZ,XZ,YZ)
*
      CALL ISWN(20,0.,5.,0.,5.)
      CALL ISVP(20,7.5*R+XL,14.*r+XL,6.5*R+YB,11.5*r+YB)
      CALL ISELNT(20)
      CALL ISMK(29)
      CALL IPM(NZ-1,XZ,YZ)
      CALL IPL(NZ  ,XZ,YZ)
*
      CALL ISWN(30,0.,5.,0.,5.)
      CALL ISVP(30,0.5*R+XL,6.5*r+XL,0.5*R+YB,5.5*r+YB)
      CALL ISELNT(30)
      CALL ISFAIS(3)
      CALL ISFASI(256)
      CALL IFA(NZ-1,XZ,YZ)
*
      CALL ISWN(40,0.,5.,0.,5.)
      CALL ISVP(40,7.5*R+XL,14.*r+XL,0.5*R+YB,5.5*r+YB)
      CALL ISELNT(40)
      CALL ISFASI(290)
      CALL IFA(NZ-1,XZ,YZ)
      CALL ISFAIS(0)
      CALL IFA(NZ-1,XZ,YZ)
*
      END
+DECK,  HIEX2, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE HIEX2
*.==========>
*.           Example to plot the table of HIGZ software characters
*..=========>
*
      CHARACTER*6 KD1,KD2
      CHARACTER*45 KDG
      CHARACTER*3 KTEXT
      CHARACTER*1 CHOPT
      DIMENSION XPOS(6),X(5),Y(5)
      DATA KD1/' < < <'/
      DATA KD2/'  [[""'/
      DATA KDG/'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,+-*/=()'/
      DATA XLONG,YTOP/16.,24./
      DATA SIZE,ANGLE/0.3,0./
*
      CALL IGRNG(20.,24.)
      CALL ICLRWK(0,1)
*
      XW = XLONG/12.
      DO 10 I = 1,6
         XPOS(I) = (2*I-1)*XW + 2.5
  10  CONTINUE
*
*              Draw the frame
*
      YLONG  = 46*1.5*SIZE + 5*1.5*SIZE
      X(1)   = XPOS(1) - XW
      X(2)   = XPOS(6) + XW
      X(3)   = X(2)
      X(4)   = X(1)
      X(5)   = X(1)
      Y(1)   = YTOP
      Y(2)   = Y(1)
      Y(3)   = Y(1) - YLONG
      Y(4)   = Y(3)
      Y(5)   = Y(1)
      CALL IPL(5,X,Y)
      DO 20 I = 1,5
         X(1)   = XPOS(I) + XW
         X(2)   = X(1)
         Y(1)   = YTOP
         Y(2)   = Y(1) - YLONG
         CALL IPL(2,X,Y)
  20  CONTINUE
      X(1)   = XPOS(1) - XW
      X(2)   = XPOS(6) + XW
      Y(1)   = YTOP - 5.*SIZE
      Y(2)   = Y(1)
      CALL IPL(2,X,Y)
*
*             Draw box titles
*
      Y1     = YTOP - 2.*SIZE
      Y2     = Y1 - 2.*SIZE
      CHOPT='C'
      CALL IGTEXT(XPOS(1),Y1,'Upper'  ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(1),Y2,'Roman'  ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(2),Y1,'Lower'  ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(2),Y2,'Roman'  ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(3),Y1,'Upper'  ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(3),Y2,'Greek'  ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(4),Y1,'L<OWER' ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(4),Y2,'G<REEK' ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(5),Y1,'U<PPER' ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(5),Y2,'Special',SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(6),Y1,'Lower'  ,SIZE,ANGLE,CHOPT)
      CALL IGTEXT(XPOS(6),Y2,'Special',SIZE,ANGLE,CHOPT)
*
      YP = YTOP - 6.*SIZE
      DO 40 I = 1,45
         YP = YP - 1.5*SIZE
         DO 30 J = 1,6
            KTEXT=KD1(J:J)//KD2(J:J)//KDG(I:I)
            CALL IGTEXT(XPOS(J),YP,KTEXT,SIZE,ANGLE,CHOPT)
  30     CONTINUE
  40  CONTINUE
*
      END
+DECK,  HIEX3, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE HIEX3
*.==========>
*.           Advanced example to draw text
*.           (based on a PAW macro from W.Walk)
*..=========>
*
      DIMENSION X(3),Y(3)
*
      CALL IGRNG(14.6,18.)
      CALL ICLRWK(0,1)
      CALL IGBOX(0.,14.6,0.,18.)
      CALL IGSET('PASS',10.)
      CALL IGSET('CSHI',0.005)
      CALL ISFAIS(1)
      CALL ISTXCI(1)
      CALL ISTXFP(-13,1)
      CALL ISCHH(0.6)
      CALL ISTXAL(2,0)
      CALL ITX(7.3,17.,'Exclusive Toponium Decays')
      CALL ISTXFP(0,2)
      CALL ISFACI(1)
      CALL IGBOX(5.,7.,15.,14.9)
      CALL IGBOX(5.,7.,3.,2.9)
      CALL IGBOX(3.,5.,14.,13.9)
      CALL IGBOX(3.,5.,2.,1.9)
      CALL IGBOX(10.,12.,13.,12.9)
      CALL IGBOX(10.,12.,12.,11.9)
      CALL IGBOX(10.,12.,11.,10.9)
      CALL IGBOX(6.,8.,12.4,12.3)
      CALL ISPLCI(3)
      X(1)=6.
      X(2)=11.
      X(3)=6.
      Y(1)=15.
      Y(2)=13.
      Y(3)=3.
      CALL IPL(3,X,Y)
      Y(2)=12.
      CALL IPL(3,X,Y)
      Y(2)=11.
      CALL IPL(3,X,Y)
      CALL ISPLCI(2)
      X(2)=4.
      Y(2)=14.
      CALL IPL(3,X,Y)
      Y(2)=2.
      CALL IPL(3,X,Y)
      CALL ISPLCI(4)
      X(2)=X(3)
      Y(2)=1.5
      CALL IPL(2,X(2),Y(2))
      X(1)=X(2)-0.2
      X(3)=X(2)+0.2
      Y(1)=Y(2)+0.3
      Y(3)=Y(1)
      CALL IPL(3,X,Y)
      CALL ISTXCI(4)
      CALL IGTEXT(6.,0.5,'e^+!e^-! or [m]^+![m]^-!',0.5,0.,'C')
      CALL IGTEXT(6.,15.2,'2^3!S?1--!',0.5,0.,'C')
      CALL IGTEXT(6.,3.2,'1^3!S?1--!',0.5,0.,'C')
      CALL IGTEXT(11.,13.2,'1^3!P?2++!',0.5,0.,'C')
      CALL IGTEXT(11.,12.2,'1^3!P?1++!',0.5,0.,'C')
      CALL IGTEXT(11.,11.2,'1^3!P?0++!',0.5,0.,'C')
      CALL IGTEXT(7.,12.6,'1^1!P?1+-!',0.5,0.,'C')
      CALL IGTEXT(4.,14.2,'2^1!S?0-+!',0.5,0.,'C')
      CALL IGTEXT(4., 2.2,'1^1!S?0-+!',0.5,0.,'C')
      CALL ISTXCI(6)
      CALL IGTEXT(4.5,15.,'[Q]?2S!',0.5,0.,'R')
      CALL IGTEXT(7.5,2.75,'[Q]?1S! (80 GeV)',0.5,0.,'L')
      CALL IGTEXT(2.5,13.75,'[c]?t!&^,!',0.5,0.,'R')
      CALL IGTEXT(2.5,1.75,'[c]?t!',0.5,0.,'R')
      CALL IGTEXT(12.5,13.,'[h]^2!&?t!',0.5,0.,'L')
      CALL IGTEXT(12.5,12.,'[h]^1!&?t!',0.5,0.,'L')
      CALL IGTEXT(12.5,11.,'[h]^0!&?t!',0.5,0.,'L')
      CALL ISTXCI(3)
      CALL IGTEXT(1.,9.,'E1',0.5,0.,'C')
      CALL ISTXCI(2)
      CALL IGTEXT(3.,9.,'M1',0.5,0.,'C')
      CALL ISTXCI(3)
      CALL IGTEXT(8.8,14.8,'100 MeV',0.4,0.,'L')
      CALL IGTEXT(8.5,6.,'800 MeV',0.4,0.,'L')
      CALL ISTXCI(6)
      CALL IGTEXT(9.4,14.2,'BR 2"Y',0.3,0.,'L')
      CALL IGTEXT(8.9,5.4,'BR 30"Y',0.3,0.,'L')
      CALL IGSET('*',0.)
*
      END
+DECK,  HIEX4, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE HIEX4
*.==========>
*.           Examples of graphs, histograms and pie charts
*..=========>
*
      COMMON /QUEST/ RQUEST(100)
      DIMENSION X(10),Y(10),V(10)
      DATA Y/2.,3.,5.,4.,7.,10.,11.,9.,10.,4./
      DATA X/0.,16.,8*0./
      DATA V/-1.5,1.,2.,4.,4.5,6.,9.,10.,14.,17./
*
      CALL IGRNG(15.,18.)
      R  = RQUEST(11)
      XL = RQUEST(12)
      YB = RQUEST(13)
      CALL ICLRWK(0,1)
      CALL ISTXFP(-13,1)
*
      CALL ISWN(10,0.,18.,-1.,12.)
      CALL ISVP(10,8.*R+XL,14.*R+XL,11.*R+YB,17.*R+YB)
      CALL ISELNT(10)
      CALL ISMK(29)
      CALL IGHIST(10,X,Y,'AHCP')
*
      CALL ISWN(20,0.,18.,0.,12.)
      CALL ISVP(20,R+XL,7.*R+XL,11.*R+YB,17.*R+YB)
      CALL ISELNT(20)
      CALL IGHIST(10,X,Y,'AB')
*
      CALL ISWN(30,-4.,19.,-1.,13.)
      CALL ISVP(30,R+XL,14.*R+XL,R+YB,10.*R+YB)
      CALL ISELNT(30)
      CALL IGAXIS(-3.,19.,1.,1.,-3.,19.,20510,' ')
      CALL IGSET('LASI',0.5)
      CALL IGAXIS(-3.,-3.,1.,12.,1.,12.,510,'H')
      CALL ISMK(21)
      CALL IGRAPH(10,V,Y,'LP')
      CALL ISLN(2)
      CALL IGRAPH(10,V,Y,'C')
      CALL IGSET('*',0.)
*
      END
+DECK,  HIEX5, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE HIEX5
*.==========>
*.           Example using HIGZ and GKS metafiles
*..=========>
*
*
*          Open HIGZ metafile
*          and repeat previous examples
*
      PRINT *,' WRITING HIGZ METAFILE'
      CALL IGZSET('Z')
      CALL IZOPEN(1,'Pictures','higz.rz','AN',1024,ISTAT)
      CALL IZPICT('ZEBRA','M')
      CALL HIEX1
      CALL IZPICT('SOFT-TABLE','M')
      CALL HIEX2
      CALL IZPICT('TOPONIUM','M')
      CALL HIEX3
      CALL IZPICT('GRAPH','M')
      CALL HIEX4
      CALL IZOUT('GRAPH',ICYCLE)
      CALL IGSA (1)
*
*          Open GKS metafile
*          and repeat previous examples
*
      PRINT *,' WRITING GKS METAFILE (BE PATIENT !)'
      CALL IGZSET('G')
      CALL IGMETA(-10,0)
      CALL HIEX1
      CALL HIEX2
      CALL HIEX3
      CALL HIEX4
      CALL IGMETA(0,0)
*
      END
+DECK,  HIEX6, T=FORT.
* Revision 1.1.1.1  1996/02/14 13:10:21  mclareni
* Higz

      SUBROUTINE HIEX6
*.==========>
*.           Example to show how to display pictures in HIGZ files
*.           Invokes the HIGZ editor.
*..=========>
      CHARACTER*10 STR
      DATA ICYCLE/999/
*
*           List contents of the ZEBRA/RZ file
*
      CALL RZLDIR(' ',' ')
*
*           Read some pictures into memory and display
*
      CALL IGSET('AURZ',0.)
      CALL IZIN('ZEBRA',ICYCLE)
      CALL IZPICT('ZEBRA','D')
      CALL IRQST(1,1,ISTAT,NCH,STR)
      CALL IZIN('TOPONIUM',ICYCLE)
      CALL IZPICT('TOPONIUM','D')
      CALL IRQST(1,1,ISTAT,NCH,STR)
*
*           Edit PICT4
*           Select options in the graphics menu
*           For example select the item ARROW in the
*           menu 'PRIMITIVES', select the type of arrow
*           by clicking in the box 'ATTR' and try to superimpose
*           a double-arrow on the picture.
*           Try to change the font and the font size for the top graphs
*           Note that the HIGZ graphics editor can be invoked
*           from PAW (PICTURE/MODIFY command).
*
      CALL IZGED('GRAPH',' ')
*
      END


+DECK,  HIGZEX, T=FORT.
* Revision 1.2  1997/03/14 14:26:04  mclareni
* WNT mods
* Revision 1.1.1.1.2.1  1997/01/21 11:25:16  mclareni
* All mods for Winnt 96a on winnt branch
* Revision 1.1.1.1  1996/02/14 13:10:20  mclareni
* Higz

      PROGRAM HIGZEX
*.==========>
*.
*.           HIGZ TEST PROGRAM
*.
*..=========>
      COMMON/PAWC/H(20000)
      LOGICAL INTRAC
      CHARACTER*80 STR
      CHARACTER*(*) HZFILE
+SELF, IF=IBM, IF=-PSCRIPT.
      PARAMETER (HZFILE='/HIGZ METAFILE')
+SELF, IF=IBM, IF=PSCRIPT.
      PARAMETER (HZFILE='/HIGZ PS')
+SELF, IF=-IBM, IF=-PSCRIPT.
      PARAMETER (HZFILE='higz.metafile')
+SELF, IF=-IBM, IF=PSCRIPT.
      PARAMETER (HZFILE='higz.ps')
+SELF.

*.___________________________________________
*
+SELF, IF=IBM.
      CALL ERRSET(151,999,-1)
+SELF, IF=IBM, IF=X11.
      CALL INITC()
+SELF.
      OPEN(10,FILE=HZFILE,FORM='FORMATTED',STATUS='UNKNOWN')
      CALL MZEBRA(-3)
      CALL MZPAW(20000,' ')
      CALL IGINIT(0)
      IF(.NOT.INTRAC())THEN
         INTER=0
         KWTYPE=0
      ELSE
         CALL IGWKTY(KWTYPE)
         INTER=1
      ENDIF
      CALL IGSSE(6,KWTYPE)
      IF(INTER.EQ.0)GOTO 10
      CALL HIEX1
      CALL IRQST(1,1,ISTAT,NCH,STR)
*
*          Switch to alpha mode. Note that IGSSE has preset the
*          workstation identifier to 1
*
      CALL IGSA (1)
*
      PRINT *, ' Example 1 completed'
      CALL HIEX2
      CALL IRQST(1,1,ISTAT,NCH,STR)
      CALL IGSA (1)
      PRINT *, ' Example 2 completed'
*
      CALL HIEX3
      CALL IRQST(1,1,ISTAT,NCH,STR)
      CALL IGSA (1)
      PRINT *, ' Example 3 completed'
*
      CALL HIEX4
      CALL IRQST(1,1,ISTAT,NCH,STR)
      CALL IGSA (1)
      PRINT *, ' Example 4 completed'
*
  10  CALL HIEX5
      IF(INTER.EQ.0)GOTO 20
      CALL IGSA (1)
      PRINT *, ' Example 5 completed'
*
*          Replay some pictures from the HIGZ metafile
*
      CALL HIEX6
      CALL IGSA (1)
      PRINT *, ' Example 6 completed'
*
  20  CALL IGEND
      END
+PATCH, DOC.
+PATCH, PAMEND.
*- THIS IS THE LAST LINE OF THE PAM FILE higz
