+TITLE.
C GEANT.CAR 3.21/05 26/11/99 11.39.27 CVSTOCAR RESTAURATION 
+PATCH, *GEANT321.
+USE, BLOCK, CDF, CGPACK, FIFACE, FLUKA, GBASE, GCONS, GDRAW, GEOCAD.
+USE, GGEOM, GHEISHA, GHITS, GHROUT, GHUTILS, GIFACE, GIOPA, GKINE.
+USE, GPHYS, GSCAN, GSTRAG, GTRAK, GUSER, GXINT, MIFACE, MIGUTI.
+USE, NEUTRON, PEANUT.
+USE, GPARAL, IF=UNIX.
+USE, GEANT321.
+DECK,  PILOT, IF=GEANT321.
*-- Author :
+USE, F2C, IF=MSDOS,LINUX.
+USE, UNIX, IF=SUN,SGI,DECS,CONVEX,IBMRT,AIX370.
+USE, UNIX, IF=HPUX,APOLLO,IPSC,NEXT.
+USE, IBMALL, IF=IBM,IBMMVS,AIX370.
+USE, DOUBLE, IF=APOLLO,IBMALL,VAX.

+USE, UNIX, IF=WINNT.
+USE, DOUBLE, IF=WINNT.

+USE, DOUBLE, IF=UNIX, IF=-SINGLE.

+USE, BSLASH, IF=UNIX,QMALPH, IF=-BSLASH, IF=-QFMSOFT.

+USE, USRJMP, IF=UNIX.

+USE, HIGZ, IF=BLDLIB.
+USE, CG, IF=BLDLIB.

+USE, MONITOR, IF=BLDLIB.

+USE, FLUKA, IF=BLDLIB.
+USE, COMIS, IF=BLDLIB.
+USE, DZDOC, IF=BLDLIB.
+PATCH, GEANT321.
+KEEP, S_ERRCOM.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_errcom.inc
      COMMON/ERRCOM/ IER(100)
C

+KEEP, S_PRNTFL.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_prntfl.inc
      COMMON/PRNTFL/INBCD,NEWBCD,INBIN,NEWBIN,NPEVT,NEVTP,LPRT,NPRT(10)
                    LOGICAL LPRT,NPRT
C

+KEEP, S_EVENT.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_event.inc
      PARAMETER (MXEVEN=12*MXGKGH)
      COMMON/EVENT / NSIZE,NCUR,NEXT,NTOT,EVE(MXEVEN)
C

+KEEP, S_MAT.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_mat.inc
      COMMON/MAT   / LMAT,
     *               DEN(21),RADLTH(21),ATNO(21),ZNO(21),ABSL(21),
     *               CDEN(21),MDEN(21),X0DEN(21),X1DEN(21),RION(21),
     *               MATID(21),MATID1(21,24),PARMAT(21,10),
     *               IFRAT,IFRAC(21),FRAC1(21,10),DEN1(21,10),
     *               ATNO1(21,10),ZNO1(21,10)
C

+KEEP, S_RESULT.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_result.inc
      COMMON/RESULT/XEND,YEND,ZEND,RCA,RCE,AMAS,NCH,TOF,PX,PY,PZ,
     *              USERW,INTCT,P,EN,EK,AMASQ,DELTN,ITK,NTK,IPART,IND,
     *              LCALO,ICEL,SINL,COSL,SINP,COSP,
     *              XOLD,YOLD,ZOLD,POLD,PXOLD,PYOLD,PZOLD,
     *              XSCAT,YSCAT,ZSCAT,PSCAT,PXSCAT,PYSCAT,PZSCAT
                    REAL NCH,INTCT
C

+KEEP, PAWCT, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* pawct.inc
      INTEGER NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKUIP,IFENCE,LLMAIN,IQQ,LQQ
      REAL WWS,QQ

+KEEP, MPARAM.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mparam.inc
      PARAMETER(MAXPAR=200)
      PARAMETER(MAXNEU=100)

+KEEP, GTVOLU, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gtvolu.inc
      INTEGER NLEVEL,NAMES,NUMBER,LVOLUM,LINDEX,INFROM,NLEVMX,
     +        NLDEV,LINMX
      REAL GTRAN,GRMAT,GONLY,GLX

+KEEP, GTVOL1, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gtvol1.inc
      INTEGER NAMES1,NUMBR1,LVOLU1

+KEEP, GTVDMA, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gtvdma.inc
      INTEGER NVMANY,MANYLE,MANYNA,MANYNU,
     +        NFMANY,MYCOUN,IMYSE
      REAL RAYTRA,VECCOS

+KEEP, GTURSB, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtursb.inc
      INTEGER NUMNDS,IADDI,NUMND2,NNPAR,IISELT
*

+KEEP, GTTRAK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gttrak.inc
      INTEGER NMEC,LMEC,NAMEC,NSTEP ,MAXNST,IGNEXT,INWVOL,ISTOP,MAXMEC
     + ,IGAUTO,IEKBIN,ILOSL, IMULL,INGOTO,NLDOWN,NLEVIN,NLVSAV,ISTORY
     + ,MAXME1,NAMEC1
      REAL  VECT,GETOT,GEKIN,VOUT,DESTEP,DESTEL,SAFETY,SLENG ,STEP
     + ,SNEXT,SFIELD,TOFG  ,GEKRAT,UPWGHT
      REAL POLAR

+KEEP, GTTMED, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gttmed.inc
      INTEGER       NUMED,NATMED,ISVOL,IFIELD,IUPD,ISTPAR,NUMOLD
      REAL          FIELDM,TMAXFD,STEMAX,DEEMAX,EPSIL,STMIN,CFIELD,PREC
      INTEGER       JMIN,NPCKOV,IMCKOV,ITCKOV
      REAL          THRIND,PMIN,DP,DNDL
C

+KEEP, GTSTAK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gtstak.inc
      INTEGER  NJTMAX,NJTMIN,NTSTKP,NTSTKS,NDBOOK,NDPUSH,NJFREE,NJGARB,
     +         NJINVO,LINSAV,LMXSAV,NWSTAK,NWINT,NWREAL,NWTRAC
      INTEGER ISTORD

+KEEP, GTSPEE, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gtspee.inc
      REAL S1,S2,S3,SS1,SS2,SS3,SRAGMX,SRAGMN,
     +     RAINT1,RAINT2,RMIN1,RMIN2,RMAX1,RMAX2
      INTEGER ISCOP,NTIM,NTFLAG,IOLDCU,ITSTCU,ISUBLI,IPORLI
      INTEGER LPASS,JPORJJ,LEP,JSC
*

+KEEP, GTSETS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gtsets.inc
      INTEGER       IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV
C

+KEEP, GTSCAN, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gtscan.inc
      INTEGER MSLIST,NPHI,IPHIMI,IPHIMA,IPHI1,IPHIL,NTETA,MODTET,NSLMAX,
     +        MAXMDT,NSLIST,ISLIST,IPHI,ITETA,ISCUR
      REAL    PHIMIN,PHIMAX,TETMIN,TETMAX,VSCAN,FACTX0,FACTL,
     +        FACTR,SX0,SABS,TETMID,TETMAD
     +       ,SX0S,SX0T,SABSS,SABST,FACTSF
     +       ,DLTPHI,DLTETA,DPHIM1,DTETM1
     +       ,FCX0M1,FCLLM1,FCRRM1

+KEEP, GTSCAL, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gtscal.inc
      INTEGER MXSLNK, ISLINK, LSLAST, LSCAN, LSTEMP, LSPARA, LSERAY
*

+KEEP, GTRAYT, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gtrayt.inc
      INTEGER INTEN,IOMBRA,IXYFLA,NOFLAG
      REAL XLPOS,YLPOS,ZLPOS,XLDIR,YLDIR,ZLDIR,APFLAH,
     +     CCXX,CCYY,CCZZ,BOFLAG,APFLAG,
     +     XCOSXS,YCOSYS,ZCOSZS,VDX,VDY,VDZ,SSLENG,
     +     XPINTS,YPINTS,ZPINTS,FPINTX,FPINTY,FPINTZ,
     +     AROTS,ZROTS,RRR

+KEEP, GTPIXE, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gtpixe.inc
      INTEGER LIMPRE,IFLAPE,ICOLOR,IXXX,IYYY,
     +        ISSEEN,ISCOLO,ISLSTY,ISLWID,ISFILL,
     +        IMAP,JON,NMAP
      REAL UUU,VVV,ZUV,ZNMAP1

+KEEP, GTPHYS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gtphys.inc
      INTEGER IPAIR,ICOMP,IPHOT,IPFIS,IDRAY,IANNI,IBREM,IHADR,IMUNU
     +       ,IDCAY,ILOSS,IMULS,IRAYL,ILABS,ISYNC,ISTRA
      REAL    SPAIR,SLPAIR,ZINTPA,STEPPA,SCOMP,SLCOMP,ZINTCO,STEPCO
     +       ,SPHOT,SLPHOT,ZINTPH,STEPPH,SPFIS,SLPFIS,ZINTPF,STEPPF
     +       ,SDRAY,SLDRAY,ZINTDR,STEPDR,SANNI,SLANNI,ZINTAN,STEPAN
     +       ,SBREM,SLBREM,ZINTBR,STEPBR,SHADR,SLHADR,ZINTHA,STEPHA
     +       ,SMUNU,SLMUNU,ZINTMU,STEPMU,SDCAY,SLIFE ,SUMLIF,DPHYS1
     +       ,SLOSS,SOLOSS,STLOSS,DPHYS2,SMULS,SOMULS,STMULS,DPHYS3
     +       ,SRAYL,SLRAYL,ZINTRA,STEPRA,SLABS,SLLABS,ZINTLA,STEPLA
C

+KEEP, GTPARM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gtparm.inc
      INTEGER IPARAM,MPSTAK,NSPARA,NPGENE
      REAL    PCUTGA,PCUTEL,PCUTNE,PCUTHA,PCUTMU

+KEEP, GTPARA, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gtpara.inc
      INTEGER    BITPHI, BITTET, BITPOT
      LOGICAL    SYMPHI, SYMTEU, SYMTED

+KEEP, GTOPTI, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtopti.inc
      INTEGER IOPTIM

+KEEP, GTCONS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gtcons.inc
      REAL          PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      REAL          EMMU,PMASS,AVO
C

+KEEP, GTNUM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gtnum.inc
      INTEGER      NMATE ,NVOLUM,NROTM,NTMED,NTMULT,NTRACK,NPART
     +            ,NSTMAX,NVERTX,NHEAD,NBIT ,NALIVE,NTMSTO
C

+KEEP, GTMUTR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gtmutr.inc
      INTEGER NCVOLS,NSHIFT,KSHIFT,ICUBE,NAIN,JJJ,NIET,IVOOLD,
     +        IWPOIN,IHPOIN,IVECVO,IOLDSU,ICGP,IPORNT
      REAL    GXMIN,GXMAX,GYMIN,GYMAX,GZMIN,GZMAX,GXXXX,GYYYY,GZZZZ
      REAL    CLIPMI,CLIPMA,ABCD,BMIN,BMAX,CGB,CGB1,GBOOM
      REAL    PORGX,PORGY,PORGZ,POX,POY,POZ,PORMIR,PORMAR

+KEEP, GTLIST, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gtlist.inc
      INTEGER       NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT
     + ,NSTAT,LHSTA,LGET ,LSAVE,LSETS,LPRIN,LGEOM,LVIEW,LPLOT,LSTAT
C

+KEEP, GTLINK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtlink.inc
      INTEGER       JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
C

+KEEP, GCKMAX, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gckmax.inc
      INTEGER MXGKIN
      PARAMETER (MXGKIN=100)
*
* gckmax.inc
*

+KEEP, GCKMAX, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gckmax.inc
*
* gckmax.inc
*
*
+CDE, INCBEG.
     +   gckmax
+CDE, INCEND.

+KEEP, GTKINE, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtkine.inc
      INTEGER       IKINE,ITRA,ISTAK,IVERT,IPART,ITRTYP,NAPART,IPAOLD
      REAL          PKINE,AMASS,CHARGE,TLIFE,VERT,PVERT
C

+KEEP, GTJUMP, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gtjump.inc
      INTEGER       JUDCAY, JUDIGI, JUDTIM, JUFLD , JUHADR, JUIGET,
     +              JUINME, JUINTI, JUKINE, JUNEAR, JUOUT , JUPHAD,
     +              JUSKIP, JUSTEP, JUSWIM, JUTRAK, JUTREV, JUVIEW,
     +              JUPARA
      INTEGER       JMPADR, MAXJMP
*

+KEEP, GTHVIR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gthvir.inc
      INTEGER JVIRT,JVDIV,JCONT2,JCONT

+KEEP, GTHILN, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gthiln.inc
      INTEGER LARECG,JCGOBJ,JCGCOL,JCOUNT,JCLIPS,IMPOIN,IMCOUN,
     +        JSIX,JSIY,JSIZ,JPXC,JPYC,JPZC,ICLIP1,ICLIP2

+KEEP, GTHIL2, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gthil2.inc
      INTEGER LARETT,JTICK,JMYLL,JFIMOT,JFISCA,JFINAM,
     +        JAASS1,JAASS2,JAASS3,JAASS4,
     +        JTICKS,JMYLLS,JMYMOT

+KEEP, GTFLAG, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtflag.inc
      INTEGER       IDEBUG,IDEMIN,IDEMAX,ITEST,IDRUN,IDEVT,IEORUN
     +        ,IEOTRI,IEVENT,ISWIT,IFINIT,NEVENT,NRNDM
C

+KEEP, GTFDIM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gtfdim.inc
      INTEGER NPROC,NMPTOT
      REAL TSEQTO,TOTMBY,TSEQ,TLAT,TNET,X1MIN,X1MAX,
     +     Y1MIN,Y1MAX,Z1MIN,Z1MAX,XCUT,YCUT,ZCUT

+KEEP, GTDRAW, IF=-INCLUDE.
* Revision 1.2  1998/02/06 15:17:29  japost
*  Added the type of three variables (ZZFU,ZZFV,MYISEL).
*   Omission reported by Andrea Dell'Acqua <diceman@mail.cern.ch>, Fri, 6 Feb 1998
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gtdraw.inc
      INTEGER NUMNOD,MAXNOD,NUMND1,LEVVER,LEVHOR,MAXV,IPICK,
     + MLEVV,MLEVH,NWCUT,JNAM,JMOT,JXON,JBRO,JDUP,JSCA,JDVM,JPSM,
     + JNAM1,JMOT1,JXON1,JBRO1,JDUP1,JSCA1,JULEV,JVLEV,
     + LOOKTB,IDRNUM,NGVIEW,ICUTFL,ICUT,NSURF,ISURF,LINATT,LINATP,
     + ITXATT,ITHRZ,IPRJ,ITR3D,IPKHIT,IOBJ,LINBUF,
     + MAXGU,MORGU,MAXGS,MORGS,MAXTU,MORTU,MAXTS,MORTS,
     + IGU,IGS,ITU,ITS,NKVIEW,IDVIEW,
     + NOPEN,IGMR,IPIONS,ITRKOP,IHIDEN,MYISEL
      REAL GRMAT0,GTRAN0,GSIN,GCOS,SINPSI,COSPSI,GTHETA,GPHI,GPSI,
     + GU0,GV0,GSCU,GSCV,CTHETA,CPHI,DCUT,GZUA,GZVA,GZUB,GZVB,GZUC,
     + GZVC,PLTRNX,PLTRNY,DPERS,ZZFU,ZZFV,DDUMMY

+KEEP, GTCUTS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtcuts.inc
      REAL          CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM
     +             ,DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS
C

+KEEP, GTCURS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtcurs.inc
      INTEGER INTFLA
      REAL    SIZD2,FACHV,HALF,SAVPLX,SAVPLY,YPLT,XPLT
*

+KEEP, GCLINK, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gclink.inc
+CDE, GTLINK.
      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
C
*
* gclink.inc
*

+KEEP, GCLINK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gclink.inc
      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
C
*
* gclink.inc
*

+KEEP, GCLINK, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gclink.inc
*
* gclink.inc
*
*
+CDE, INCBEG.
     +   gclink
+CDE, INCEND.

+KEEP, GTBANK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gtbank.inc
      INTEGER IQ,LQ,NZEBRA,IXSTOR,IXDIV,IXCONS,LMAIN,LR1,JCG
      INTEGER KWBANK,KWWORK,IWS
      REAL GVERSN,ZVERSN,FENDQ,WS,Q
C

+KEEP, GTASHO, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gtasho.inc
      REAL         ZMED,AMED,DMED,E0MED,ZSMED,ESMED,ALFA,
     *             STEP,PLIN,PLOG,BE2,PLASM,TRNSMA,
     *             BOSC,AOSC,EOSC,ZOSC,EMEAN,CMGO,EMGO,EMGOMI
      INTEGER      NSMED,IOSC,NOSC,NMGO,NMGOMA
C

+KEEP, AADAT.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* aadat.inc
*                                                                      *
*=== aadat ============================================================*
*                                                                      *
      PARAMETER (IPROM = 100)
      PARAMETER (ITARM = 100)
      COMMON/FKAADA/ENPERN,PLPERN,SIGAA(IPROM,ITARM),SIGNN,TMASS,AAEVNO,
     +             SELAA(IPROM,ITARM),RLASTP(IPROM,ITARM),
     +             MATPRO,MATTAR,LASTM,IPROA,IPROZ,ITARA,ITARZ


+KEEP, AUXPAR.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* auxpar.inc
C***********************************************************************
C     INCLUDE FILE: AUXPAR COPY                   CREATED 11/12/86 BY PA
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX6=1133)
      CHARACTER*8 ANA
      COMMON /FKAUXP/PXA(IDMAX6),PYA(IDMAX6),PZA(IDMAX6),HEPA(IDMAX6),
     *AMA(IDMAX6),ICHA(IDMAX6),IBARA(IDMAX6),            NREA(IDMAX6)
      COMMON /FKAUXC/ANA(IDMAX6)


+KEEP, BALANC.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* balanc.inc
*                                                                     *
*=== balanc ==========================================================*
*                                                                     *
      LOGICAL LRESMP, LEVDIF, LPRDIF
      COMMON /FKBALA/  ETTOT,  PTTOT, PXTTOT, PYTTOT, PZTTOT,
     &                 EINCP,  EINCN, TVGREY, TVGRE0,  TVEUZ,
     &                   EUZ,    PUX,    PUY,    PUZ,  ENUCR, PXNUCR,
     &                PYNUCR, PZNUCR,  EINTR, PXINTR, PYINTR, PZINTR,
     &                  EFRM,  PXFRM,  PYFRM,  PZFRM,   PSEA,
     &                NGREYP, NGREYN,    ICU,    IBU, ICNUCR, IBNUCR,
     &                ICINTR, IBINTR, LRESMP, LEVDIF, LPRDIF


+KEEP, BAMJCM.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* bamjcm.inc
*=== bamjcm ===========================================================*

*                                                                      *
*----------------------------------------------------------------------*
*                                                                      *
*     Bamjcm by A. Ferrari                                             *
*                           included in:                               *
*                                        bamjet                        *
*     When changing kmxjcm dimension look also at verein!!!!!          *
*----------------------------------------------------------------------*
*                                                                      *
      PARAMETER (KMXJCM = 100)
      COMMON /FKBAMJ/  RPX(KMXJCM),  RPY(KMXJCM),   RE(KMXJCM),
     &                KFR1(KMXJCM), KFR2(KMXJCM),   IV(KMXJCM)



+KEEP, BLANK.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant

+KEEP, CAMASS.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* camass.inc
      REAL*4 XMASS(0:11)
      COMMON/CMASS/XMASS
C
C    CALOR random seed

+KEEP, CERRCM.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* cerrcm.inc
      LOGICAL CERRF
      COMMON/CERRCM/CERRF,IERRU

+KEEP, CGCAAN, IF=-INCLUDE, IF=-SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgcaan.inc
      DOUBLE PRECISION RAD,COSI,SINI,COSDA(2),SINDA(2),XYHA(4,2)
      INTEGER          NASTP(2)
      COMMON /CGCAAN/  RAD,COSI,SINI,COSDA,SINDA,XYHA,NASTP
     +                ,IFULL,ATREDG
*
* cgcaan.inc
*

+KEEP, CGCAAN, IF=-INCLUDE, IF=SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgcaan.inc
      REAL             COSDA(2),SINDA(2),XYHA(4,2)
      INTEGER          NASTP(2)
      COMMON /CGCAAN/  RAD,COSI,SINI,COSDA,SINDA,XYHA,NASTP
     +                ,IFULL,ATREDG
*
* cgcaan.inc
*

+KEEP, CGCAAN, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgcaan.inc
*
* cgcaan.inc
*
+CDE, INCBEG.
       +   CGCAAN
+CDE, INCEND.
*

+KEEP, CGCEDG, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgcedg.inc
      PARAMETER (INPART = 30, NTTT = 50)
      COMMON /CGCEDG/ TDEL,NPART,TSTRT(INPART),TEND(INPART),
     +                KX,KY,KZ,NPART2,TSTRT2(INPART),TEND2(INPART),
     +                XA,YA,ZA,XB,YB,ZB,XDELT,YDELT,ZDELT,
     +                ABC(3,2),DEDGE(5),TTT(2,NTTT),ITTT(NTTT)
      REAL AA(3),BB(3),DELTA(3)
      EQUIVALENCE     (AA,XA),(BB,XB),(DELTA,XDELT)
*
* cgcedg.inc
*

+KEEP, CGCEDG, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgcedg.inc
*
* cgcedg.inc
*
+CDE, INCBEG.
       +   CGCEDG.
+CDE, INCEND.
*

+KEEP, CGCFAC, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgcfac.inc
      PARAMETER (LABC=1500)
      COMMON /CGCFAC/ F1(LABC),F2(LABC),F3(LABC),RFMIN(3),RFMAX(3),
     +                AABCD(4),DRFACE(5)
*
* cgcfac.inc
*

+KEEP, CGCFAC, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgcfac.inc
*
* cgcfac.inc
*
+CDE, INCBEG.
       +   CGCFAC.
+CDE, INCEND.
*

+KEEP, CGCTRA, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgctra.inc
      PARAMETER (NTMAX = 3)
      COMMON /CGCTRA/ TSCRN(4,3,NTMAX),TBACK(4,3,NTMAX)
*
* cgctra.inc
*

+KEEP, CGCTRA, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgctra.inc
*
* cgctra.inc
*
+CDE, INCBEG.
       +   CGCTRA.
+CDE, INCEND.
*

+KEEP, CGDELT, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgdelt.inc
      PARAMETER (DELWOR = 2.**13,    DELSCR = 2.**11)
      PARAMETER (DEWOR  = .5/DELWOR, EEWOR  = 1./DELWOR)
      PARAMETER (DESCR  = .5/DELSCR, EESCR  = 1./DELSCR)
*
* cgdelt.inc
*

+KEEP, CGDELT, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgdelt.inc
*
* cgdelt.inc
*
+CDE, INCBEG.
       +   CGDELT.
+CDE, INCEND.
*

+KEEP, CGGPAR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cggpar.inc
      PARAMETER (LCGHEA=3, KCGSIZ=1)
      PARAMETER (          KCGATT=2)
      PARAMETER (          KCGNF =3)
      PARAMETER (LCGFAC=6, KCGAF =1)
      PARAMETER (          KCGAA =2)
      PARAMETER (          KCGBB =3)
      PARAMETER (          KCGCC =4)
      PARAMETER (          KCGDD =5)
      PARAMETER (          KCGNE =6)
      PARAMETER (LCGEDG=7, KCGAE =1)
      PARAMETER (          KCGX1 =2)
      PARAMETER (          KCGY1 =3)
      PARAMETER (          KCGZ1 =4)
      PARAMETER (          KCGX2 =5)
      PARAMETER (          KCGY2 =6)
      PARAMETER (          KCGZ2 =7)
*
* cggpar.inc
*

+KEEP, CGGPAR, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cggpar.inc
*
* cggpar.inc
*
+CDE, INCBEG.
       +   CGGPAR.
+CDE, INCEND.
*

+KEEP, CGHPAR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cghpar.inc
      PARAMETER (I4SIZE = 1)
      PARAMETER (LHHEAD=18,KHSIZE=1)
      PARAMETER (          KHNT  =2)
      PARAMETER (          KHIFWI=3)
      PARAMETER (          KHNXYZ=8)
      PARAMETER (          KHNFAC=9)
      PARAMETER (          KHNEDG=10)
      PARAMETER (          KHJXYZ=11)
      PARAMETER (          KHJFA =12)
      PARAMETER (          KHJPFA=13)
      PARAMETER (          KHJDFA=14)
      PARAMETER (          KHJTRE=15)
      PARAMETER (          KHJSTA=16)
      PARAMETER (          KHJALE=17)
      PARAMETER (          KHJARI=18)
*
* cghpar.inc
*

+KEEP, CGHPAR, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cghpar.inc
*
* cghpar.inc
*
+CDE, INCBEG.
       +   CGHPAR.
+CDE, INCEND.
*

+KEEP, CGXCOM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgxcom.inc
      COMMON /CGXCOM/ IXLUN,NXMAX,NXCUR,NXNODE,NXEDGE,NXFACE
*
* cgxcom.inc
*

+KEEP, CGXCOM, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* cgxcom.inc
*
* cgxcom.inc
*
+CDE, INCBEG.
       +   CGXCOM.
+CDE, INCEND.
*

+KEEP, CMAGIC.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* cmagic.inc
      PARAMETER(NMAGIC=123456789)

+KEEP, CMASS.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* cmass.inc
+CDE, CAMASS.
      DIMENSION PMASS(12)
      EQUIVALENCE(PMASS(1),XMASS(0))

+KEEP, CMSRES.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* cmsres.inc
C***********************************************************************
C     INCLUDE FILE: CMSRES COPY                   CREATED 11/12/86 BY PA
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX5=1133)
      CHARACTER*8 ANR
      COMMON /FKCMSR/PXR(IDMAX5),PYR(IDMAX5),PZR(IDMAX5),HER(IDMAX5),
     *AMR(IDMAX5),ICHR(IDMAX5),IBARR(IDMAX5),            NRER(IDMAX5),
     *NRES
      COMMON /FKCMSC/ANR(IDMAX5)


+KEEP, COMCON.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* comcon.inc
*=== comcon ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     include file: comcon copy                 created 26/11/86 by pa *
*                                                                      *
*     Last change  on  30-oct-92   by   Alfredo Ferrari, INFN - Milan  *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /comcon/ contains information about compounds                    *
*         icompl(imat) = number of materials in a compound             *
*         matnum(i)    = material numbers (compounds consist of the    *
*                        materials)                                    *
*         aocmbc(i)    = atomic densities in barn**-1 cm**-1           *
*                        (Atoms Over Cm times Barn for Compounds)      *
*         cona13(i)    = A^1/3 of the constituents                     *
*         sumzmf(i)    = cumulative z^2 for multiple scattering        *
*         contnt(i)    = partial densities                             *
*         sumacn(i)    = cumulative atom contents of the compounds     *
*         cabinx(i)    = cumulative at.cont.*inelastic cross section   *
*         cabelx(i)    = cumulative at.cont.*  elastic cross section   *
*         anxnor       = total inelastic cross section                 *
*         elxnor       = total   elastic cross section                 *
*----------------------------------------------------------------------*
      COMMON /FKCOMC/ AOCMBC (ICOMAX), CONA13 (ICOMAX), SUMZMF (ICOMAX),
     &                CONTNT (ICOMAX), SUMACN (ICOMAX), CABINX (ICOMAX),
     &                CABELX (ICOMAX), ANXNOR, ELXNOR,  ICOMPL (MXXMDF),
     &                MATNUM (ICOMAX)


+KEEP, COMCONT.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* comcont.inc
      DOUBLE PRECISION AOCMBC, CONTNT, SUMACN, CABINX, CABELX,
     &                 ANXNOR, ELXNOR, CONA13, SUMZMF


+KEEP, CORINC.
* Revision 1.1.1.1  1995/10/24 10:20:37  cernlib
* Geant
* corinc.inc
*                                                                      *
*=== corinc ===========================================================*
*                                                                      *
*----------------------------------------------------------------------*
*                                                                      *
*     Modified by A. Ferrari: be sure that the parameter Inmax is >=   *
*     of the same parameter in the function Nudist                     *
*----------------------------------------------------------------------*
      PARAMETER ( INMAX = 20 )
      COMMON /FKCORI/ XSEA (INMAX),  XASEA (INMAX), FRAINC, ANUAV,
     &                IJTARG (INMAX+1), NSEA


+KEEP, CRANDM, IF=-SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* crandm.inc
      DOUBLE PRECISION RANDC
C

+KEEP, CRANDM, IF=SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* crandm.inc
      REAL RANDC
C

+KEEP, DBLPRC, IF=DOUBLE.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* dblprc.inc
*                                                                     *
*=== dblprc ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      Dblprc: included in any routine                                *
*                                                                     *
*  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  *
*  !!!! O N   M A C H I N E S   W H E R E   T H E   D O U B L E !!!!  *
*  !!!! P R E C I S I O N   I S   N O T   R E Q U I R E D  R E -!!!!  *
*  !!!! M O V E   T H E   D O U B L E   P R E C I S I O N       !!!!  *
*  !!!! S T A T E M E N T,  S E T   K A L G N M = 1   A N D     !!!!  *
*  !!!! C H A N G E   A L L   N U M E R I C A L   C O N S -     !!!!  *
*  !!!! T A N T S   T O   S I N G L E   P R E C I S I O N       !!!!  *
*  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  *
*                                                                     *
*         Kalgnm = real address alignment, 2 for double precision,    *
*                  1 for single precision                             *
*         Anglgb = this parameter should be set equal to the machine  *
*                  "zero" with respect to unit                        *
*         Anglsq = this parameter should be set equal to the square   *
*                  of Anglgb                                          *
*         Axcssv = this parameter should be set equal to the number   *
*                  for which unity is negligible for the machine      *
*                  accuracy                                           *
*         Andrfl = "underflow" of the machine for floating point      *
*                  operation                                          *
*         Avrflw = "overflow"  of the machine for floating point      *
*                  operation                                          *
*         Ainfnt = code "infinite"                                    *
*         Azrzrz = code "zero"                                        *
*         Einfnt = natural logarithm of the code "infinite"           *
*         Ezrzrz = natural logarithm of the code "zero"               *
*         Onemns = 1- of the machine, it is 1 - 2 x Anglgb            *
*         Onepls = 1+ of the machine, it is 1 + 2 x Anglgb            *
*         Csnnrm = maximum tolerable error on cosine normalization,   *
*                  u**2+v**2+w**2: assuming a typical anglgb relative *
*                  error on each component we would get 2xanglgb: use *
*                  4xanglgb to avoid too many normalizations          *
*         Dmxtrn = "infinite" distance for transport (cm)             *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER ( KALGNM = 2 )
      PARAMETER ( ANGLGB = 5.0D-16 )
      PARAMETER ( ANGLSQ = 2.5D-31 )
      PARAMETER ( AXCSSV = 0.2D+16 )
      PARAMETER ( ANDRFL = 1.0D-38 )
      PARAMETER ( AVRFLW = 1.0D+38 )
      PARAMETER ( AINFNT = 1.0D+30 )
      PARAMETER ( AZRZRZ = 1.0D-30 )
      PARAMETER ( EINFNT = +69.07755278982137 D+00 )
      PARAMETER ( EZRZRZ = -69.07755278982137 D+00 )
      PARAMETER ( ONEMNS = 0.999999999999999  D+00 )
      PARAMETER ( ONEPLS = 1.000000000000001  D+00 )
      PARAMETER ( CSNNRM = 2.0D-15 )
      PARAMETER ( DMXTRN = 1.0D+08 )
*
*======================================================================*
*======================================================================*
*=========                                                   ==========*
*=========    M A T H E M A T I C A L   C O N S T A N T S    ==========*
*=========                                                   ==========*
*======================================================================*
*======================================================================*
*                                                                      *
*   Numerical constants:                                               *
*                                                                      *
*         Zerzer = 0                                                   *
*         Oneone = 1                                                   *
*         Twotwo = 2                                                   *
*         Thrthr = 3                                                   *
*         Foufou = 4                                                   *
*         Fivfiv = 5                                                   *
*         Sixsix = 6                                                   *
*         Sevsev = 7                                                   *
*         Eigeig = 8                                                   *
*         Aninen = 9                                                   *
*         Tenten = 10                                                  *
*         Hlfhlf = 1/2                                                 *
*         Onethi = 1/3                                                 *
*         Twothi = 2/3                                                 *
*         Pipipi = Circumference / diameter                            *
*         Eneper = "e", base of natural logarithm                      *
*         Sqrent = square root of "e"                                  *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER ( ZERZER = 0.D+00 )
      PARAMETER ( ONEONE = 1.D+00 )
      PARAMETER ( TWOTWO = 2.D+00 )
      PARAMETER ( THRTHR = 3.D+00 )
      PARAMETER ( FOUFOU = 4.D+00 )
      PARAMETER ( FIVFIV = 5.D+00 )
      PARAMETER ( SIXSIX = 6.D+00 )
      PARAMETER ( SEVSEV = 7.D+00 )
      PARAMETER ( EIGEIG = 8.D+00 )
      PARAMETER ( ANINEN = 9.D+00 )
      PARAMETER ( TENTEN = 10.D+00 )
      PARAMETER ( HLFHLF = 0.5D+00 )
      PARAMETER ( ONETHI = ONEONE / THRTHR )
      PARAMETER ( TWOTHI = TWOTWO / THRTHR )
      PARAMETER ( PIPIPI = 3.1415926535897932270 D+00 )
      PARAMETER ( ENEPER = 2.7182818284590452354 D+00 )
      PARAMETER ( SQRENT = 1.6487212707001281468 D+00 )
*
*======================================================================*
*======================================================================*
*=========                                                   ==========*
*=========       P H Y S I C A L   C O N S T A N T S         ==========*
*=========                                                   ==========*
*======================================================================*
*======================================================================*
*                                                                      *
*   Primary constants:                                                 *
*                                                                      *
*         Clight = speed of light in cm s-1                            *
*         Avogad = Avogadro number                                     *
*         Amelgr = electron mass (g)                                   *
*         Plckbr = reduced Planck constant (erg s)                     *
*         Elccgs = elementary charge (CGS unit)                        *
*         Elcmks = elementary charge (MKS unit)                        *
*         Amugrm = Atomic mass unit (g)                                *
*         Ammumu = Muon mass (amu)                                     *
*                                                                      *
*   Derived constants:                                                 *
*                                                                      *
*         Alpfsc = Fine structure constant  = e^2/(hbar c)             *
*         Amelct = Electron mass (GeV) = 10^-16Amelgr Clight^2 / Elcmks*
*         Amugev = Atomic mass unit (GeV) = 10^-16Amelgr Clight^2      *
*                                           / Elcmks                   *
*         Ammuon = Muon mass (GeV) = Ammumu * Amugev                   *
*         Fscto2 = (Fine structure constant)^2                         *
*         Fscto3 = (Fine structure constant)^3                         *
*         Fscto4 = (Fine structure constant)^4                         *
*         Plabrc = Reduced Planck constant times the light velocity    *
*                  expressed in GeV fm                                 *
*         Rclsel = Classical electron radius (cm) = e^2 / (m_e c^2)    *
*   Conversion constants:                                              *
*         GeVMeV = from GeV to MeV                                     *
*         eMVGeV = from MeV to GeV                                     *
*         Raddeg = from radians to degrees                             *
*         Degrad = from degrees to radians                             *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER ( CLIGHT = 2.99792458         D+10 )
      PARAMETER ( AVOGAD = 6.0221367          D+23 )
      PARAMETER ( AMELGR = 9.1093897          D-28 )
      PARAMETER ( PLCKBR = 1.05457266         D-27 )
      PARAMETER ( ELCCGS = 4.8032068          D-10 )
      PARAMETER ( ELCMKS = 1.60217733         D-19 )
      PARAMETER ( AMUGRM = 1.6605402          D-24 )
      PARAMETER ( AMMUMU = 0.113428913        D+00 )
*     PARAMETER ( ALPFSC = 1.D+00 / 137.035989561D+00 )
*     PARAMETER ( FSCTO2 = ALPFSC * ALPFSC )
*     PARAMETER ( FSCTO3 = FSCTO2 * ALPFSC )
*     PARAMETER ( FSCTO4 = FSCTO3 * ALPFSC )
*    It is important to set the electron mass exactly with the same
*    rounding as in the mass tables, so use the explicit expression
*     PARAMETER ( AMELCT = 1.D-16 * AMELGR * CLIGHT * CLIGHT / ELCMKS )
*    It is important to set the amu mass exactly with the same
*    rounding as in the mass tables, so use the explicit expression
*     PARAMETER ( AMUGEV = 1.D-16 * AMUGRM * CLIGHT * CLIGHT / ELCMKS )
*    It is important to set the muon mass exactly with the same
*    rounding as in the mass tables, so use the explicit expression
*     PARAMETER ( AMMUON = AMMUMU * AMUGEV ELCMKS )
*     PARAMETER ( RCLSEL = ELCCGS * ELCCGS / CLIGHT / CLIGHT / AMELGR )
      PARAMETER ( ALPFSC = 7.2973530791728595 D-03 )
      PARAMETER ( FSCTO2 = 5.3251361962113614 D-05 )
      PARAMETER ( FSCTO3 = 3.8859399018437826 D-07 )
      PARAMETER ( FSCTO4 = 2.8357075508200407 D-09 )
      PARAMETER ( PLABRC = 0.197327053        D+00 )
      PARAMETER ( AMELCT = 0.51099906         D-03 )
      PARAMETER ( AMUGEV = 0.93149432         D+00 )
      PARAMETER ( AMMUON = 0.105658389        D+00 )
      PARAMETER ( RCLSEL = 2.8179409183694872 D-13 )
      PARAMETER ( GEVMEV = 1.0                D+03 )
      PARAMETER ( EMVGEV = 1.0                D-03 )
      PARAMETER ( RADDEG = 180.D+00 / PIPIPI )
      PARAMETER ( DEGRAD = PIPIPI / 180.D+00 )


+KEEP, DBLPRC, IF=SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* dblprc.inc
      IMPLICIT REAL (A-H,O-Z)
      PARAMETER ( KALGNM = 1 )
      PARAMETER ( ANGLGB = 5.0e-16 )
      PARAMETER ( ANGLSQ = 2.5e-31 )
      PARAMETER ( AXCSSV = 0.2e+16 )
      PARAMETER ( ANDRFL = 1.0e-38 )
      PARAMETER ( AVRFLW = 1.0e+38 )
      PARAMETER ( AINFNT = 1.0e+30 )
      PARAMETER ( AZRZRZ = 1.0e-30 )
      PARAMETER ( EINFNT = +69.07755278982137 e+00 )
      PARAMETER ( EZRZRZ = -69.07755278982137 e+00 )
      PARAMETER ( ONEMNS = 0.999999999999999  e+00 )
      PARAMETER ( ONEPLS = 1.000000000000001  e+00 )
      PARAMETER ( CSNNRM = 2.0e-15 )
      PARAMETER ( DMXTRN = 1.0e+08 )
*
      PARAMETER ( ZERZER = 0.e+00 )
      PARAMETER ( ONEONE = 1.e+00 )
      PARAMETER ( TWOTWO = 2.e+00 )
      PARAMETER ( THRTHR = 3.e+00 )
      PARAMETER ( FOUFOU = 4.e+00 )
      PARAMETER ( FIVFIV = 5.e+00 )
      PARAMETER ( SIXSIX = 6.e+00 )
      PARAMETER ( SEVSEV = 7.e+00 )
      PARAMETER ( EIGEIG = 8.e+00 )
      PARAMETER ( ANINEN = 9.e+00 )
      PARAMETER ( TENTEN = 10.e+00 )
      PARAMETER ( HLFHLF = 0.5e+00 )
      PARAMETER ( ONETHI = ONEONE / THRTHR )
      PARAMETER ( TWOTHI = TWOTWO / THRTHR )
      PARAMETER ( PIPIPI = 3.1415926535897932270 e+00 )
      PARAMETER ( ENEPER = 2.7182818284590452354 e+00 )
      PARAMETER ( SQRENT = 1.6487212707001281468 e+00 )
*
      PARAMETER ( CLIGHT = 2.99792458         e+10 )
      PARAMETER ( AVOGAD = 6.0221367          e+23 )
      PARAMETER ( AMELGR = 9.1093897          e-28 )
      PARAMETER ( PLCKBR = 1.05457266         e-27 )
      PARAMETER ( ELCCGS = 4.8032068          e-10 )
      PARAMETER ( ELCMKS = 1.60217733         e-19 )
      PARAMETER ( AMUGRM = 1.6605402          e-24 )
      PARAMETER ( AMMUMU = 0.113428913        e+00 )
*     PARAMETER ( ALPFSC = 1.e+00 / 137.035989561e+00 )
*     PARAMETER ( FSCTO2 = ALPFSC * ALPFSC )
*     PARAMETER ( FSCTO3 = FSCTO2 * ALPFSC )
*     PARAMETER ( FSCTO4 = FSCTO3 * ALPFSC )
*    It is important to set the electron mass exactly with the same
*    rounding as in the mass tables, so use the explicit expression
*     PARAMETER ( AMELCT = 1.e-16 * AMELGR * CLIGHT * CLIGHT / ELCMKS )
*    It is important to set the amu mass exactly with the same
*    rounding as in the mass tables, so use the explicit expression
*     PARAMETER ( AMUGEV = 1.e-16 * AMUGRM * CLIGHT * CLIGHT / ELCMKS )
*    It is important to set the muon mass exactly with the same
*    rounding as in the mass tables, so use the explicit expression
*     PARAMETER ( AMMUON = AMMUMU * AMUGEV ELCMKS )
*     PARAMETER ( RCLSEL = ELCCGS * ELCCGS / CLIGHT / CLIGHT / AMELGR )
      PARAMETER ( ALPFSC = 7.2973530791728595 e-03 )
      PARAMETER ( FSCTO2 = 5.3251361962113614 e-05 )
      PARAMETER ( FSCTO3 = 3.8859399018437826 e-07 )
      PARAMETER ( FSCTO4 = 2.8357075508200407 e-09 )
      PARAMETER ( PLABRC = 0.197327053        e+00 )
      PARAMETER ( AMELCT = 0.51099906         e-03 )
      PARAMETER ( AMUGEV = 0.93149432         e+00 )
      PARAMETER ( AMMUON = 0.105658389        e+00 )
      PARAMETER ( RCLSEL = 2.8179409183694872 e-13 )
      PARAMETER ( GEVMEV = 1.0                e+03 )
      PARAMETER ( EMVGEV = 1.0                e-03 )
      PARAMETER ( RADDEG = 180.e+00 / PIPIPI )
      PARAMETER ( DEGRAD = PIPIPI / 180.e+00 )


+KEEP, DECAYC.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* decayc.inc
C***********************************************************************
C     INCLUDE FILE: DECAYC COPY                   CREATED 12/12/86 BY PA
C     NOTE: SEE ALSO DECAYC2 COPY
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX9=540)
      CHARACTER*8 ZKNAME
      COMMON/FKDECC/ NZK(IDMAX9,3),WT(IDMAX9)
      COMMON/FKDECH/ ZKNAME(IDMAX9)


+KEEP, DECAYC2.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* decayc2.inc
C***********************************************************************
C     INCLUDE FILE: DECAYC2 COPY                   CREATED 12/12/86 BY A
C     NOTE: SEE ALSO DECAYC COPY
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX9=540)
      CHARACTER*8 ZKNAMC
      COMMON /FKDECC/ NZKC(IDMAX9,3),WTC(IDMAX9)
      COMMON/FKDECH/ ZKNAMC(IDMAX9)


+KEEP, DEPNUC.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* depnuc.inc
*                                                                     *
*=== depnuc ==========================================================*
*                                                                     *
      LOGICAL LLASTN, LLAST1
      COMMON /FKDEPN/    EKLAST, AMLAST, PXLAST, PYLAST, PZLAST,
     &                   EKINC , AMINC , PXXINC, PYYINC, PZZINC,
     &                   KTLAST, KTINC , LLASTN, LLAST1


+KEEP, DIMPAR.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* dimpar.inc
*                                                                     *
*=== dimpar ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      DIMPAR: included in any routine                                *
*                                                                     *
*          Mxxrgn = maximum number of regions                         *
*          Mxxmdf = maximum number of media in Fluka                  *
*          Mxxmde = maximum number of media in Emf                    *
*          Mfstck = stack dimension in Fluka                          *
*          Mestck = stack dimension in Emf                            *
*          Nallwp = number of allowed particles                       *
*          Mpdpdx = number of particle types for which EM dE/dx pro-  *
*                   cesses (ion,pair,bremss) have to be computed      *
*          Icomax = maximum number of materials for compounds (equal  *
*                   to the sum of the number of materials for every   *
*                   compound )                                        *
*          Nstbis = number of stable isotopes recorded in common iso- *
*                   top                                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( MXXRGN = 500  )
      PARAMETER ( MXXMDF = 50   )
      PARAMETER ( MXXMDE = 18   )
      PARAMETER ( MFSTCK = 1000 )
      PARAMETER ( MESTCK = 100  )
      PARAMETER ( NALLWP = 39   )
      PARAMETER ( MPDPDX = 8    )
      PARAMETER ( ICOMAX = 120  )
      PARAMETER ( NSTBIS = 304  )


+KEEP, EROPTS, IF=INCLUDE.
* Revision 1.2  1996/07/25 15:01:02  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:33  mclareni
* Add geane321 includes
*      Sequence for conditions to stop tracking
* eropts.inc
      CHARACTER*8     CHOPTI
      LOGICAL         LEEXAC, LELENG, LEONLY, LEPLAN, LEPOIN, LEVOLU
      REAL            ERPLI, ERPLO, ERLENG
      INTEGER         NAMEER, NUMVER, IOVLER
      COMMON /EROPTS/ ERPLI(3,2), ERPLO(3,4,MXPRED), ERLENG(MXPRED),
     +                NAMEER(MXPRED), NUMVER(MXPRED), IOVLER(MXPRED),
     +                LEEXAC, LELENG, LEONLY, LEPLAN, LEPOIN, LEVOLU
      COMMON /EROPTC/CHOPTI
*
* eropts.inc
*
+CDE, INCBEG.
     +    EROPTS
+CDE, INCEND.

+KEEP, EROPTS.
* Revision 1.2  1996/07/25 15:01:02  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:33  mclareni
* Add geane321 includes
*      Sequence for conditions to stop tracking
* eropts.inc
      CHARACTER*8     CHOPTI
      LOGICAL         LEEXAC, LELENG, LEONLY, LEPLAN, LEPOIN, LEVOLU
      REAL            ERPLI, ERPLO, ERLENG
      INTEGER         NAMEER, NUMVER, IOVLER
      COMMON /EROPTS/ ERPLI(3,2), ERPLO(3,4,MXPRED), ERLENG(MXPRED),
     +                NAMEER(MXPRED), NUMVER(MXPRED), IOVLER(MXPRED),
     +                LEEXAC, LELENG, LEONLY, LEPLAN, LEPOIN, LEVOLU
      COMMON /EROPTC/CHOPTI
*
* eropts.inc
*

+KEEP, ERTRIO, IF=INCLUDE.
* Revision 1.2  1996/07/25 15:00:40  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:34  mclareni
* Add geane321 includes
*      Sequence for input-output
* ertrio.inc
      INTEGER          MXPRED
      PARAMETER (MXPRED = 10)
      DOUBLE PRECISION ERDTRP
      REAL             ERRIN, ERROUT, ERTRSP, ERXIN, ERXOUT, ERPIN,
     +                 ERPOUT
      INTEGER          NEPRED, INLIST, ILPRED, IEPRED
      COMMON /ERTRIO/  ERDTRP(5,5,MXPRED), ERRIN(15), ERROUT(15,MXPRED),
     +                 ERTRSP(5,5,MXPRED), ERXIN( 3), ERXOUT( 3,MXPRED),
     +                 ERPIN(3), ERPOUT(3,MXPRED), NEPRED,INLIST,ILPRED,
     +                 IEPRED(MXPRED)
+CDE, EROPTS.


*
* ertrio.inc
*
+CDE, INCBEG.
     +    ERTRIO
+CDE, INCEND.

+KEEP, ERTRIO.
* Revision 1.2  1996/07/25 15:00:40  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:34  mclareni
* Add geane321 includes
*      Sequence for input-output
* ertrio.inc
      INTEGER          MXPRED
      PARAMETER (MXPRED = 10)
      DOUBLE PRECISION ERDTRP
      REAL             ERRIN, ERROUT, ERTRSP, ERXIN, ERXOUT, ERPIN,
     +                 ERPOUT
      INTEGER          NEPRED, INLIST, ILPRED, IEPRED
      COMMON /ERTRIO/  ERDTRP(5,5,MXPRED), ERRIN(15), ERROUT(15,MXPRED),
     +                 ERTRSP(5,5,MXPRED), ERXIN( 3), ERXOUT( 3,MXPRED),
     +                 ERPIN(3), ERPOUT(3,MXPRED), NEPRED,INLIST,ILPRED,
     +                 IEPRED(MXPRED)
+CDE, EROPTS.


*
* ertrio.inc
*

+KEEP, ERWORK, IF=INCLUDE.
* Revision 1.2  1996/07/25 15:01:16  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:34  mclareni
* Add geane321 includes
*      Working sequences for the interface
* erwork.inc
      DOUBLE PRECISION EI, EF, ASDSC
      COMMON /ERWORK/ EI(15), EF(15), ASDSC(5,5),
     +                   XI(3), PPI(3), HI(9),
     +                   XF(3), PF(3),  HF(9),
     +                   CHTR, DEDX2, BACKTR, CUTEK, TLGCM2, TLRAD
*
* erwork.inc
*
+CDE, INCBEG.
     +    ERWORK
+CDE, INCEND.

+KEEP, ERWORK.
* Revision 1.2  1996/07/25 15:01:16  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:34  mclareni
* Add geane321 includes
*      Working sequences for the interface
* erwork.inc
      DOUBLE PRECISION EI, EF, ASDSC
      COMMON /ERWORK/ EI(15), EF(15), ASDSC(5,5),
     +                   XI(3), PPI(3), HI(9),
     +                   XF(3), PF(3),  HF(9),
     +                   CHTR, DEDX2, BACKTR, CUTEK, TLGCM2, TLRAD
*
* erwork.inc
*

+KEEP, EVA0.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* eva0.inc
*                                                                      *
*=== eva0 =============================================================*
*                                                                      *
      COMMON / FKEVA0 / Y0, B0, P0 (1001), P1 (1001), P2 (1001),
     *                FLA (6), FLZ (6), RHO (6), OMEGA (6), EXMASS (6),
     *                CAM2 (130), CAM3 (200), CAM4 (130), CAM5 (200),
     *                T (4,7), RMASS (297), ALPH (297), BET (297),
     *                WAPS (250,11), APRIME (250), IA (6), IZ (6)


+KEEP, EVA1.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* eva1.inc
*                                                                      *
*=== eva1 =============================================================*
*                                                                      *
      COMMON /FKEVA1/ NPART(6),EPART(100,6),COSEVP(3,100,6),HEVSUM


+KEEP, FHEAVY.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* fheavy.inc
*=== fheavy ===========================================================*
*----------------------------------------------------------------------*
*     Last change on 9 March 1993     by Alfredo Ferrari, INFN Milan   *
*     include file: fheavy copy       created 5/4/90 by A. Ferrari     *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /fheavy/ is the storage for heavy secondaries created in the     *
*              nuclear evaporation                                     *
*        npheav     = number of secondaries                            *
*        kheavy(ip) = type of the secondary ip                         *
*                   ( 3 = deuteron, 4 = 3-H, 5 = 3-He, 6 = 4-He,       *
*                     7-12 = "Heavy" fragment specified by Ibheav and  *
*                     Icheav )                                         *
*        cxheav(ip) = direction cosine of the secondary ip             *
*                     with respect to x-axis                           *
*        cyheav(ip) = direction cosine of the secondary ip             *
*                     with respect to y-axis                           *
*        czheav(ip) = direction cosine of the secondary ip             *
*                     with respect to z-axis                           *
*        tkheav(ip) = kinetic energy of secondary ip                   *
*        pheavy(ip) = momentum of the secondary ip                     *
*        wheavy(ip) = weight of the secondary ip                       *
*        amheav(ip) = atomic masses of the six types of evaporated     *
*                     particles                                        *
*        anheav(kp) = name of the kp-type heavy particle               *
*        icheav(kp) = charge of the kp-type heavy particle             *
*        ibheav(kp) = mass number of the kp-type heavy particle        *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*   !!! There is now the possibility to produce up to 6 "heavy" !!!!   *
*   !!! fragments besides the residual nucleus recorded in      !!!!   *
*   !!! Resnuc: they are identified by indeces 7-12, of course  !!!!   *
*   !!! the corresponding physical properties (Z,A,m..) must be !!!!   *
*   !!! updated every time they are produced                    !!!!   *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*----------------------------------------------------------------------*
      PARAMETER ( MXHEAV = 100 )
      CHARACTER*8 ANHEAV
      COMMON / FKHEAV / CXHEAV (MXHEAV), CYHEAV (MXHEAV),
     &                  CZHEAV (MXHEAV), TKHEAV (MXHEAV),
     &                  PHEAVY (MXHEAV), WHEAVY (MXHEAV),
     &                  AMHEAV  ( 12 ) ,
     &                  KHEAVY (MXHEAV), ICHEAV  ( 12 ) ,
     &                  IBHEAV  ( 12 ) , NPHEAV
      COMMON / FKHEAC / ANHEAV  ( 12 )


+KEEP, FHEAVYT.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* fheavyt.inc
      DOUBLE PRECISION CXHEAV, CYHEAV, CZHEAV, TKHEAV, PHEAVY,
     &                 WHEAVY, AMHEAV


+KEEP, FINLSP.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* finlsp.inc
C***********************************************************************
C     INCLUDE FILE: FINLSP COPY                   CREATED 11/12/86 BY PA
C     NOTE: SEE ALSO FILE FINLSP2 COPY
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX7=100)
      COMMON/FKFINL/ CXR(IDMAX7),CYR(IDMAX7),CZR(IDMAX7),
     *ELR(IDMAX7),PLR(IDMAX7),IR,ITR(IDMAX7)


+KEEP, FINLSP2.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* finlsp2.inc
C***********************************************************************
C     INCLUDE FILE:  FINLSP2 COPY               CREATED 11/12/86 BY PA A
C     NOTE: SEE ALSO FILE FINLSP COPY
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX7=100)
      COMMON/FKFINL/CXR(IDMAX7),CYR(IDMAX7),CZR(IDMAX7),
     *EL(IDMAX7),PL(IDMAX7),IR,ITR(IDMAX7)


+KEEP, FINLSP3.
* Revision 1.1.1.1  1995/10/24 10:20:38  cernlib
* Geant
* finlsp3.inc
C***********************************************************************
C     include file:  finlsp3 copy           Created 4/9/89 by A. Ferrari
C     note: see also file finlsp copy and finlsp2
C     changes: none
C     included in the following subroutines or functions:
C                                                         Eventq
C
C     description of the common block(s) and variable(s)
C
C***********************************************************************
      PARAMETER (IDMAX7=100)
      COMMON/FKFINL/CXH(IDMAX7),CYH(IDMAX7),CZH(IDMAX7),
     *ELH(IDMAX7),PLH(IDMAX7),IH,ITH(IDMAX7)


+KEEP, FINPAR.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* finpar.inc
C***********************************************************************
C     INCLUDE FILE: FINPAR COPY                   CREATED 11/12/86 BY PA
C     NOTE: DO NOT FORGET FILE FINPAR2 COPY
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX1=1133)
      CHARACTER*8 ANF
      COMMON /FKFINP/PXF(IDMAX1),PYF(IDMAX1),PZF(IDMAX1),HEP(IDMAX1),
     *AMF(IDMAX1),ICHF(IDMAX1),IBARF(IDMAX1),NREF(IDMAX1)
      COMMON /FKFINC/ ANF(IDMAX1)


+KEEP, FINPAR2.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* finpar2.inc
C***********************************************************************
C     INCLUDE FILE: FINPAR2 COPY                   CREATED 11/12/86 BY A
C     NOTE: DO NOT FORGET FILE FINPAR COPY
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX3=1133)
      CHARACTER*8 ANF
      COMMON /FKFINP/PXF(IDMAX3),PYF(IDMAX3),PZF(IDMAX3),HEF(IDMAX3),
     *AMF(IDMAX3),ICHF(IDMAX3),IBARF(IDMAX3),NREF(IDMAX3)
      COMMON /FKFINC/ ANF(IDMAX3)


+KEEP, FINUC.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* finuc.inc
*=== finuc ============================================================*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990     by Alfredo Ferrari, INFN Milan   *
*     include file: finuc copy                   created 26/11/86 by pa*
*     note: if changed change finuc2 copy also                         *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        np        = number of secondaries                             *
*        kpart(ip) = type of the secondary ip                          *
*        cxr(ip)   = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyr(ip)   = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czr(ip)   = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        tki(ip)   = kinetic energy of secondary ip                    *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXR (MXP), CYR (MXP), CZR (MXP), TKI (MXP),
     &                 PLR (MXP), WEI (MXP), TV, TVCMS, TVRECL, TVHEAV,
     &                 TVBIND, NP0, NP, KPART (MXP)


+KEEP, FINUC2.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* finuc2.inc
*=== finuc2 ===========================================================*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990 by   Alfredo Ferrari, INFN - Milan   *
*     include file: finuc2 copy                  created 26/11/86 by pa*
*     note: if changed change finuc copy also                          *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        irn       = number of secondaries                             *
*        itrn(ip)  = type of the secondary ip                          *
*        cxrn(ip)  = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyrn(ip)  = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czrn(ip)  = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        elr(ip)   = kinetic (or total) energy of secondary ip         *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXRN (MXP), CYRN (MXP), CZRN (MXP), ELR (MXP),
     &                 PLR  (MXP), WEI  (MXP), TV, TVCMS, TVRECL,
     &                 TVHEAV, TVBIND, NP0, IRN, ITRN (MXP)


+KEEP, FINUCT.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* finuct.inc
      DOUBLE PRECISION CXR, CYR, CZR, TKI, PLR, WEI, TV, TVCMS,
     &                 TVRECL, TVHEAV, TVBIND


+KEEP, FORCN.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* forcn.inc
*                                                                      *
*=== forcn ============================================================*
*                                                                      *
      COMMON /FKFORC/ FKEY


+KEEP, GC10EV, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gc10ev.inc
      REAL G10EV,TENEV
      PARAMETER (G10EV=1.0E-8)
      PARAMETER (TENEV=1.E-2)
C
*
* gc10ev.inc
*

+KEEP, GC10EV, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gc10ev.inc
*
* gc10ev.inc
*
*
+CDE, INCBEG.
     +   gc10ev
+CDE, INCEND.

+KEEP, GCASHO, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcasho.inc
      COMMON/GCASHO/ZMED,AMED,DMED,E0MED,ZSMED(50),ESMED(50),ALFA,
     *             STEP,PLIN,PLOG,BE2,PLASM,TRNSMA,
     *             BOSC(50),AOSC(50),EOSC(50),ZOSC(50),EMEAN,
     *             CMGO(2000),EMGO,EMGOMI,
     *             NSMED,IOSC(50),NOSC,NMGO,NMGOMA
C

+KEEP, GCASHO, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcasho.inc
      COMMON/GCASHO/ZMED,AMED,DMED,E0MED,ZSMED(50),ESMED(50),ALFA,
     *             STEP,PLIN,PLOG,BE2,PLASM,TRNSMA,
     *             BOSC(50),AOSC(50),EOSC(50),ZOSC(50),EMEAN,
     *             CMGO(2000),EMGO,EMGOMI,
     *             NSMED,IOSC(50),NOSC,NMGO,NMGOMA
C
+CDE, GTASHO.

+KEEP, GCBANK, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcbank.inc
+CDE, GTBANK.
      PARAMETER (KWBANK=69000,KWWORK=5200)
      COMMON/GCBANK/NZEBRA,GVERSN,ZVERSN,IXSTOR,IXDIV,IXCONS,FENDQ(16)
     +             ,LMAIN,LR1,WS(KWBANK)
      DIMENSION IQ(2),Q(2),LQ(8000),IWS(2)
      EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN),(IWS(1),WS(1))
      EQUIVALENCE (JCG,JGSTAT)
+CDE, GCLINK.
*
* gcbank.inc
*

+KEEP, GCBANK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcbank.inc
      PARAMETER (KWBANK=69000,KWWORK=5200)
      COMMON/GCBANK/NZEBRA,GVERSN,ZVERSN,IXSTOR,IXDIV,IXCONS,FENDQ(16)
     +             ,LMAIN,LR1,WS(KWBANK)
      DIMENSION IQ(2),Q(2),LQ(8000),IWS(2)
      EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN),(IWS(1),WS(1))
      EQUIVALENCE (JCG,JGSTAT)
+CDE, GCLINK.
*
* gcbank.inc
*

+KEEP, GCBANK, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcbank.inc
*
* gcbank.inc
*
*
+CDE, INCBEG.
     +   gcbank
+CDE, INCEND.

+KEEP, GCCURS, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gccurs.inc
+CDE, GTCURS.
      COMMON/GCCURS/INTFLA,SIZD2,FACHV,HALF,SAVPLX,SAVPLY,YPLT,XPLT
*
*
* gccurs.inc
*

+KEEP, GCCURS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gccurs.inc
      COMMON/GCCURS/INTFLA,SIZD2,FACHV,HALF,SAVPLX,SAVPLY,YPLT,XPLT
*
*
* gccurs.inc
*

+KEEP, GCCURS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gccurs.inc
*
* gccurs.inc
*
*
+CDE, INCBEG.
     +   gccurs
+CDE, INCEND.

+KEEP, GCCUTS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gccuts.inc
      COMMON/GCCUTS/CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM
     +             ,DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS(5)
C
*
* gccuts.inc
*

+KEEP, GCCUTS, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gccuts.inc
      COMMON/GCCUTS/CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM
     +             ,DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS(5)
C
+CDE, GTCUTS.
*
* gccuts.inc
*

+KEEP, GCCUTS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gccuts.inc
*
* gccuts.inc
*
*
+CDE, INCBEG.
     +   gccuts
+CDE, INCEND.

+KEEP, GCDLIN.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* gcdlin.inc
      COMMON/GCDLIN/NCWORD(2),JCADNT,JBUF1,JBUF2
      EQUIVALENCE (JBUF1,JCDLST),(JCADNT,JCDFRS)
*

+KEEP, GCDRAW, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcdraw.inc
      COMMON/GCDRAW/NUMNOD,MAXNOD,NUMND1,LEVVER,LEVHOR,MAXV,IPICK,
     + MLEVV,MLEVH,NWCUT,JNAM,JMOT,JXON,JBRO,JDUP,JSCA,JDVM,JPSM,
     + JNAM1,JMOT1,JXON1,JBRO1,JDUP1,JSCA1,JULEV,JVLEV,
     + LOOKTB(16),
     + GRMAT0(10),GTRAN0(3),IDRNUM,GSIN(41),GCOS(41),SINPSI,COSPSI,
     + GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV,NGVIEW,
     + ICUTFL,ICUT,CTHETA,CPHI,DCUT,NSURF,ISURF,
     + GZUA,GZVA,GZUB,GZVB,GZUC,GZVC,PLTRNX,PLTRNY,
     + LINATT,LINATP,ITXATT,ITHRZ,IPRJ,DPERS,ITR3D,IPKHIT,IOBJ,LINBUF,
     + MAXGU,MORGU,MAXGS,MORGS,MAXTU,MORTU,MAXTS,MORTS,
     + IGU,IGS,ITU,ITS,NKVIEW,IDVIEW,
     + NOPEN,IGMR,IPIONS,ITRKOP,IHIDEN,
     + ZZFU,ZZFV,MYISEL,
     + DDUMMY(15)
C
*
* gcdraw.inc
*

+KEEP, GCDRAW, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcdraw.inc
      COMMON/GCDRAW/NUMNOD,MAXNOD,NUMND1,LEVVER,LEVHOR,MAXV,IPICK,
     + MLEVV,MLEVH,NWCUT,JNAM,JMOT,JXON,JBRO,JDUP,JSCA,JDVM,JPSM,
     + JNAM1,JMOT1,JXON1,JBRO1,JDUP1,JSCA1,JULEV,JVLEV,
     + LOOKTB(16),
     + GRMAT0(10),GTRAN0(3),IDRNUM,GSIN(41),GCOS(41),SINPSI,COSPSI,
     + GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV,NGVIEW,
     + ICUTFL,ICUT,CTHETA,CPHI,DCUT,NSURF,ISURF,
     + GZUA,GZVA,GZUB,GZVB,GZUC,GZVC,PLTRNX,PLTRNY,
     + LINATT,LINATP,ITXATT,ITHRZ,IPRJ,DPERS,ITR3D,IPKHIT,IOBJ,LINBUF,
     + MAXGU,MORGU,MAXGS,MORGS,MAXTU,MORTU,MAXTS,MORTS,
     + IGU,IGS,ITU,ITS,NKVIEW,IDVIEW,
     + NOPEN,IGMR,IPIONS,ITRKOP,IHIDEN,
     + ZZFU,ZZFV,MYISEL,
     + DDUMMY(15)
C
+CDE, GTDRAW.
*
* gcdraw.inc
*

+KEEP, GCDRAW, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcdraw.inc
*
* gcdraw.inc
*
*
+CDE, INCBEG.
     +   gcdraw
+CDE, INCEND.

+KEEP, GCFDIM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcfdim.inc
      COMMON/GCFDIM/NPROC,NMPTOT,TSEQTO,TOTMBY,TSEQ,
     +TLAT,TNET,X1MIN,X1MAX,Y1MIN,Y1MAX,Z1MIN,Z1MAX,
     +XCUT,YCUT,ZCUT
C
C

+KEEP, GCFDIM, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcfdim.inc
      COMMON/GCFDIM/NPROC,NMPTOT,TSEQTO,TOTMBY,TSEQ,
     +TLAT,TNET,X1MIN,X1MAX,Y1MIN,Y1MAX,Z1MIN,Z1MAX,
     +XCUT,YCUT,ZCUT
C
+CDE, GTFDIM.
C

+KEEP, GCFLAG, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcflag.inc
      COMMON/GCFLAG/IDEBUG,IDEMIN,IDEMAX,ITEST,IDRUN,IDEVT,IEORUN
     +        ,IEOTRI,IEVENT,ISWIT(10),IFINIT(20),NEVENT,NRNDM(2)
      COMMON/GCFLAX/BATCH, NOLOG
      LOGICAL BATCH, NOLOG
C
*
* gcflag.inc
*

+KEEP, GCFLAG, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcflag.inc
      COMMON/GCFLAG/IDEBUG,IDEMIN,IDEMAX,ITEST,IDRUN,IDEVT,IEORUN
     +        ,IEOTRI,IEVENT,ISWIT(10),IFINIT(20),NEVENT,NRNDM(2)
      COMMON/GCFLAX/BATCH, NOLOG
      LOGICAL BATCH, NOLOG
C
+CDE, GTFLAG.
*
* gcflag.inc
*

+KEEP, GCFLAG, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcflag.inc
*
* gcflag.inc
*
*
+CDE, INCBEG.
     +   gcflag
+CDE, INCEND.

+KEEP, GCGOBJ, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcgobj.inc
      PARAMETER (NTRCG=1)
      PARAMETER (NWB=207,NWREV=100,NWS=1500)
      PARAMETER (C2TOC1=7.7, C3TOC1=2.,TVLIM=1296.)
      COMMON /GCGOBJ/IST,IFCG,ILCG,NTCUR,NFILT,NTNEX,KCGST
     +             ,NCGVOL,IVFUN,IVCLOS,IFACST,NCLAS1,NCLAS2,NCLAS3
      COMMON /CGBLIM/IHOLE,CGXMIN,CGXMAX,CGYMIN,CGYMAX,CGZMIN,CGZMAX
C
*
* gcgobj.inc
*

+KEEP, GCGOBJ, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcgobj.inc
*
* gcgobj.inc
*
*
+CDE, INCBEG.
     +   gcgobj
+CDE, INCEND.

+KEEP, GCHIL2, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gchil2.inc
+CDE, GTHIL2.
      COMMON/GCHIL2/LARETT(2),JTICK,JMYLL,JFIMOT,JFISCA,JFINAM,
     +              JAASS1,JAASS2,
     +              JAASS3,JAASS4,JTICKS,JMYLLS,JMYMOT
*
*
* gchil2.inc
*

+KEEP, GCHIL2, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gchil2.inc
      COMMON/GCHIL2/LARETT(2),JTICK,JMYLL,JFIMOT,JFISCA,JFINAM,
     +              JAASS1,JAASS2,
     +              JAASS3,JAASS4,JTICKS,JMYLLS,JMYMOT
*
*
* gchil2.inc
*

+KEEP, GCHIL2, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gchil2.inc
*
* gchil2.inc
*
*
+CDE, INCBEG.
     +   gchil2
+CDE, INCEND.

+KEEP, GCHILN, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gchiln.inc
+CDE, GTHILN.
      COMMON/GCHILN/LARECG(2), JCGOBJ, JCGCOL, JCOUNT, JCLIPS,
     +              IMPOIN, IMCOUN, JSIX, JSIY, JSIZ,
     +              JPXC, JPYC, JPZC, ICLIP1, ICLIP2
*
*
* gchiln.inc
*

+KEEP, GCHILN, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gchiln.inc
      COMMON/GCHILN/LARECG(2), JCGOBJ, JCGCOL, JCOUNT, JCLIPS,
     +              IMPOIN, IMCOUN, JSIX, JSIY, JSIZ,
     +              JPXC, JPYC, JPZC, ICLIP1, ICLIP2
*
*
* gchiln.inc
*

+KEEP, GCHILN, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gchiln.inc
*
* gchiln.inc
*
*
+CDE, INCBEG.
     +   gchiln
+CDE, INCEND.

+KEEP, GCHVIR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gchvir.inc
      COMMON/GCHVIR/JVIRT,JVDIV,JCONT2,JCONT
C
C

+KEEP, GCHVIR, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gchvir.inc
      COMMON/GCHVIR/JVIRT,JVDIV,JCONT2,JCONT
C
+CDE, GTHVIR.
C

+KEEP, GCJLOC, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcjloc.inc
      COMMON/GCJLOC/NJLOC(2),JTM,JMA,JLOSS,JPROB,JMIXT,JPHOT,JANNI
     +                  ,JCOMP,JBREM,JPAIR,JDRAY,JPFIS,JMUNU,JRAYL
     +                  ,JMULOF,JCOEF,JRANG
C
      INTEGER       NJLOC   ,JTM,JMA,JLOSS,JPROB,JMIXT,JPHOT,JANNI
     +                  ,JCOMP,JBREM,JPAIR,JDRAY,JPFIS,JMUNU,JRAYL
     +                  ,JMULOF,JCOEF,JRANG
C
      COMMON/GCJLCK/NJLCK(2),JTCKOV,JABSCO,JEFFIC,JINDEX,JCURIN
     +                      ,JPOLAR,JTSTRA,JTSTCO,JTSTEN,JTASHO
C
      EQUIVALENCE (JLASTV,JTSTEN)
C
      INTEGER       NJLCK,JTCKOV,JABSCO,JEFFIC,JINDEX,JCURIN
     +                   ,JPOLAR,JLASTV,JTSTRA,JTSTCO,JTSTEN
     +                   ,JTASHO
C
*
* gcjloc.inc
*

+KEEP, GCJLOC, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcjloc.inc
*
* gcjloc.inc
*
*
+CDE, INCBEG.
     +   gcjloc
+CDE, INCEND.

+KEEP, GCJUMP, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcjump.inc
+CDE, GTJUMP.
      PARAMETER    (MAXJMP=30)
      COMMON/GCJUMP/JUDCAY, JUDIGI, JUDTIM, JUFLD , JUHADR, JUIGET,
     +              JUINME, JUINTI, JUKINE, JUNEAR, JUOUT , JUPHAD,
     +              JUSKIP, JUSTEP, JUSWIM, JUTRAK, JUTREV, JUVIEW,
     +              JUPARA
      DIMENSION     JMPADR(MAXJMP)
      EQUIVALENCE  (JMPADR(1), JUDCAY)
*
*
* gcjump.inc
*

+KEEP, GCJUMP, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcjump.inc
      PARAMETER    (MAXJMP=30)
      COMMON/GCJUMP/JUDCAY, JUDIGI, JUDTIM, JUFLD , JUHADR, JUIGET,
     +              JUINME, JUINTI, JUKINE, JUNEAR, JUOUT , JUPHAD,
     +              JUSKIP, JUSTEP, JUSWIM, JUTRAK, JUTREV, JUVIEW,
     +              JUPARA
      DIMENSION     JMPADR(MAXJMP)
      EQUIVALENCE  (JMPADR(1), JUDCAY)
*
*
* gcjump.inc
*

+KEEP, GCJUMP, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcjump.inc
*
* gcjump.inc
*
*
+CDE, INCBEG.
     +   gcjump
+CDE, INCEND.

+KEEP, GCKINE, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gckine.inc
      COMMON/GCKINE/IKINE,PKINE(10),ITRA,ISTAK,IVERT,IPART,ITRTYP
     +      ,NAPART(5),AMASS,CHARGE,TLIFE,VERT(3),PVERT(4),IPAOLD
C
*
* gckine.inc
*

+KEEP, GCKINE, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gckine.inc
      COMMON/GCKINE/IKINE,PKINE(10),ITRA,ISTAK,IVERT,IPART,ITRTYP
     +      ,NAPART(5),AMASS,CHARGE,TLIFE,VERT(3),PVERT(4),IPAOLD
C
+CDE, GTKINE.
*
* gckine.inc
*

+KEEP, GCKINE, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gckine.inc
*
* gckine.inc
*
*
+CDE, INCBEG.
     +   gckine
+CDE, INCEND.

+KEEP, GCKING, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcking.inc
+CDE, GCKMAX.
      COMMON/GCKING/KCASE,NGKINE,GKIN(5,MXGKIN),
     +                           TOFD(MXGKIN),IFLGK(MXGKIN)
      INTEGER       KCASE,NGKINE ,IFLGK,MXPHOT,NGPHOT
      REAL          GKIN,TOFD,XPHOT
C
      PARAMETER (MXPHOT=800)
      COMMON/GCKIN2/NGPHOT,XPHOT(11,MXPHOT)
C
      COMMON/GCKIN3/GPOS(3,MXGKIN)
      REAL          GPOS
C
*
* gcking.inc
*

+KEEP, GCKING, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcking.inc
*
* gcking.inc
*
*
+CDE, INCBEG.
     +   gcking
+CDE, INCEND.

+KEEP, GCLIST, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gclist.inc
      COMMON/GCLIST/NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT
     +       ,NSTAT,LHSTA(20),LGET (20),LSAVE(20),LSETS(20),LPRIN(20)
     +             ,LGEOM(20),LVIEW(20),LPLOT(20),LSTAT(20)
C
*
* gclist.inc
*

+KEEP, GCLIST, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gclist.inc
      COMMON/GCLIST/NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT
     +       ,NSTAT,LHSTA(20),LGET (20),LSAVE(20),LSETS(20),LPRIN(20)
     +             ,LGEOM(20),LVIEW(20),LPLOT(20),LSTAT(20)
C
+CDE, GTLIST.
*
* gclist.inc
*

+KEEP, GCLIST, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gclist.inc
*
* gclist.inc
*
*
+CDE, INCBEG.
     +   gclist
+CDE, INCEND.

+KEEP, GCLUND, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gclund.inc
      COMMON/GCLUND/IFLUND,ECLUND
      INTEGER IFLUND
      REAL ECLUND
C
*
* gclund.inc
*

+KEEP, GCLUND, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gclund.inc
*
* gclund.inc
*
*
+CDE, INCBEG.
     +   gclund
+CDE, INCEND.

+KEEP, GCMATE, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcmate.inc
      COMMON/GCMATE/NMAT,NAMATE(5),A,Z,DENS,RADL,ABSL
C
      INTEGER NMAT,NAMATE
      REAL A,Z,DENS,RADL,ABSL
C
*
* gcmate.inc
*

+KEEP, GCMATE, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcmate.inc
*
* gcmate.inc
*
*
+CDE, INCBEG.
     +   gcmate
+CDE, INCEND.

+KEEP, GCMULO, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcmulo.inc
      COMMON/GCMULO/SINMUL(101),COSMUL(101),SQRMUL(101),OMCMOL,CHCMOL
     +  ,EKMIN,EKMAX,NEKBIN,NEK1,EKINV,GEKA,GEKB,EKBIN(200),ELOW(200)
C
      REAL SINMUL,COSMUL,SQRMUL,OMCMOL,CHCMOL,EKMIN,EKMAX,ELOW,EKINV
      REAL GEKA,GEKB,EKBIN
      INTEGER NEKBIN,NEK1
C
*
* gcmulo.inc
*

+KEEP, GCMULO, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcmulo.inc
*
* gcmulo.inc
*
*
+CDE, INCBEG.
     +   gcmulo
+CDE, INCEND.

+KEEP, GCMUTR, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcmutr.inc
+CDE, GTMUTR.
*
      PARAMETER (MULTRA=50)
      CHARACTER*4 GNASH, GNNVV, GNVNV
      COMMON/GCMUTR/NCVOLS,KSHIFT,NSHIFT,ICUBE,NAIN,JJJ,
     +              NIET,IOLDSU,IVOOLD,IWPOIN,IHPOIN,IVECVO(100),
     +              PORGX,PORGY,PORGZ,POX(15),POY(15),POZ(15),GBOOM,
     +              PORMIR(18),PORMAR(18),IPORNT,
     +              ICGP,CLIPMI(6),CLIPMA(6),
     +              ABCD(4),BMIN(6),BMAX(6),CGB(16000),CGB1(16000),
     +              GXMIN(MULTRA),GXMAX(MULTRA),GYMIN(MULTRA),
     +              GYMAX(MULTRA),GZMIN(MULTRA),GZMAX(MULTRA),
     +              GXXXX(MULTRA),GYYYY(MULTRA),GZZZZ(MULTRA)
*
      COMMON/GCMUTC/   GNASH(MULTRA),GNNVV(MULTRA),GNVNV(MULTRA)
*
*
* gcmutr.inc
*

+KEEP, GCMUTR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcmutr.inc
*
      PARAMETER (MULTRA=50)
      CHARACTER*4 GNASH, GNNVV, GNVNV
      COMMON/GCMUTR/NCVOLS,KSHIFT,NSHIFT,ICUBE,NAIN,JJJ,
     +              NIET,IOLDSU,IVOOLD,IWPOIN,IHPOIN,IVECVO(100),
     +              PORGX,PORGY,PORGZ,POX(15),POY(15),POZ(15),GBOOM,
     +              PORMIR(18),PORMAR(18),IPORNT,
     +              ICGP,CLIPMI(6),CLIPMA(6),
     +              ABCD(4),BMIN(6),BMAX(6),CGB(16000),CGB1(16000),
     +              GXMIN(MULTRA),GXMAX(MULTRA),GYMIN(MULTRA),
     +              GYMAX(MULTRA),GZMIN(MULTRA),GZMAX(MULTRA),
     +              GXXXX(MULTRA),GYYYY(MULTRA),GZZZZ(MULTRA)
*
      COMMON/GCMUTC/   GNASH(MULTRA),GNNVV(MULTRA),GNVNV(MULTRA)
*
*
* gcmutr.inc
*

+KEEP, GCMUTR, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcmutr.inc
*
* gcmutr.inc
*
*
+CDE, INCBEG.
     +   gcmutr
+CDE, INCEND.

+KEEP, GCMZFO, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcmzfo.inc
      COMMON/GCMZFO/IOMATE,IOPART,IOTMED,IOSEJD,IOSJDD,IOSJDH,IOSTAK
     +             ,IOMZFO(13)
C
      INTEGER       IOMATE,IOPART,IOTMED,IOSEJD,IOSJDD,IOSJDH,IOSTAK
     +             ,IOMZFO
C
*
* gcmzfo.inc
*

+KEEP, GCMZFO, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcmzfo.inc
*
* gcmzfo.inc
*
*
+CDE, INCBEG.
     +   gcmzfo
+CDE, INCEND.

+KEEP, GCNMEC, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcnmec.inc
      PARAMETER(NMECA=45,IBLOWN=23)
      CHARACTER*4 CHNMEC(NMECA)
*
* *** Two blank spaces for FISF and CAPF which do not exist
*
* *** The low-neutron cross-sections have to be at the end for the
* *** logics of the routine to work, and they have to start at
* *** IBLOWN
      DATA CHNMEC /
     +     'HADF',  'INEF',  'ELAF',  'NULL',  'NULL',
     +     'HADG',  'INEG',  'ELAG',  'FISG',  'CAPG',
     +     'LOSS',  'PHOT',  'ANNI',  'COMP',  'BREM',
     +     'PAIR',  'DRAY',  'PFIS',  'RAYL',  'MUNU',
     +     'RANG',  'STEP',  'LOWN',  'NABS',  'NELA',
     +     'NINE',  'NINC',  'N,2N',  'N,3N',  'N,NA',
     +     'N2NA',  'N,NP',  'NFIS',  'N,GA',  'N,PR',
     +     'N,DE',  'N,TR',  'N3HE',  'N,AL',  'N,2A',
     +     'N,3A',  'N,2P',  'N,PA',  'NT2A',  'ND2A'/
*

+KEEP, GCNUM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcnum.inc
      COMMON/GCNUM/NMATE ,NVOLUM,NROTM,NTMED,NTMULT,NTRACK,NPART
     +            ,NSTMAX,NVERTX,NHEAD,NBIT
      COMMON /GCNUMX/ NALIVE,NTMSTO
C
*
* gcnum.inc
*

+KEEP, GCNUM, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcnum.inc
      COMMON/GCNUM/NMATE ,NVOLUM,NROTM,NTMED,NTMULT,NTRACK,NPART
     +            ,NSTMAX,NVERTX,NHEAD,NBIT
      COMMON /GCNUMX/ NALIVE,NTMSTO
C
+CDE, GTNUM.
*
* gcnum.inc
*

+KEEP, GCNUM, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcnum.inc
*
* gcnum.inc
*
*
+CDE, INCBEG.
     +   gcnum
+CDE, INCEND.

+KEEP, GCOMIS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcomis.inc
      COMMON/GCOMIS/JUINIT,JUGEOM,JUKINE,JUSTEP,JUOUT,JULAST
      DIMENSION JPCOMS(6)
      EQUIVALENCE (JPCOMS,JUINIT)
*
*
* gcomis.inc
*

+KEEP, GCOMIS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcomis.inc
*
* gcomis.inc
*
*
+CDE, INCBEG.
     +   gcomis
+CDE, INCEND.

+KEEP, GCONSP, IF=-INCLUDE, IF=SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gconsp.inc
      REAL PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      REAL EMMU,PMASS,AVO
*
      PARAMETER (PI=3.14159265358979324)
      PARAMETER (TWOPI=6.28318530717958648)
      PARAMETER (PIBY2=1.57079632679489662)
      PARAMETER (DEGRAD=0.0174532925199432958)
      PARAMETER (RADDEG=57.2957795130823209)
      PARAMETER (CLIGHT=29979245800.)
      PARAMETER (BIG=10000000000.)
      PARAMETER (EMASS=0.00051099906)
      PARAMETER (EMMU=0.105658389)
      PARAMETER (PMASS=0.93827231)
      PARAMETER (AVO=0.60221367)
*
*
* gconsp.inc
*

+KEEP, GCONSP, IF=-INCLUDE, IF=-SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gconsp.inc
      DOUBLE PRECISION PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      DOUBLE PRECISION EMMU,PMASS,AVO
*
      PARAMETER (PI=3.14159265358979324D0)
      PARAMETER (TWOPI=6.28318530717958648D0)
      PARAMETER (PIBY2=1.57079632679489662D0)
      PARAMETER (DEGRAD=0.0174532925199432958D0)
      PARAMETER (RADDEG=57.2957795130823209D0)
      PARAMETER (CLIGHT=29979245800.D0)
      PARAMETER (BIG=10000000000.D0)
      PARAMETER (EMASS=0.0005109990615D0)
      PARAMETER (EMMU=0.105658387D0)
      PARAMETER (PMASS=0.9382723128D0)
      PARAMETER (AVO=0.60221367D0)
*
*
* gconsp.inc
*

+KEEP, GCONSP, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gconsp.inc
*
* gconsp.inc
*
*
+CDE, INCBEG.
     +   gconsp
+CDE, INCEND.

+KEEP, GCONST, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gconst.inc
+CDE, GTCONS.
      COMMON/GCONST/PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      COMMON/GCONSX/EMMU,PMASS,AVO
C
*
* gconst.inc
*

+KEEP, GCONST, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gconst.inc
      COMMON/GCONST/PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
      COMMON/GCONSX/EMMU,PMASS,AVO
C
*
* gconst.inc
*

+KEEP, GCONST, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gconst.inc
*
* gconst.inc
*
*
+CDE, INCBEG.
     +   gconst
+CDE, INCEND.

+KEEP, GCOPTI, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcopti.inc
      COMMON/GCOPTI/ IOPTIM
C
*
* gcopti.inc
*

+KEEP, GCOPTI, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcopti.inc
      COMMON/GCOPTI/ IOPTIM
C
+CDE, GTOPTI.
*
* gcopti.inc
*

+KEEP, GCOPTI, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcopti.inc
*
* gcopti.inc
*
*
+CDE, INCBEG.
     +   gcopti
+CDE, INCEND.

+KEEP, GCPARA, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcpara.inc
+CDE, GTPARA.
      PARAMETER (LSTACK = 5000)
C     BITPOT is for Phi.Or.Tet
C
C ---------------------------------------------------------
      COMMON    /GCPARA/
     +                   EPSIX0 (LSTACK)       ,
     +                   IDRPHI (LSTACK     )  , IDRTET (LSTACK     ),
     +                   IDROUT (LSTACK     )  , JPLOST (LSTACK     ),
     +                   IPHTMP (LSTACK     )  ,
     +                   BITPHI (LSTACK     )  , BITTET (LSTACK     ),
     +                   BITPOT (LSTACK     )  , JJLOST, JJFILL,
     +                                           JENTRY, JEMPTY,
     +                                           EPSMAX,
     +                   JJTEMP, JJWORK        , JJSTK1,
     +                   J1TEMP,                 J1STK1,
     +                   IFOUNP, IFOUNT        , IFNPOT,
     +                                           SYMPHI,
     +                   SYMTEU, SYMTED
C
*
* gcpara.inc
*

+KEEP, GCPARA, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcpara.inc
*
* gcpara.inc
*
*
+CDE, INCBEG.
     +   gcpara
+CDE, INCEND.

+KEEP, GCPARM, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcparm.inc
      COMMON/GCPARM/IPARAM,PCUTGA,PCUTEL,PCUTNE,PCUTHA,PCUTMU
     +             ,NSPARA,MPSTAK,NPGENE
      REAL PACUTS(5)
      EQUIVALENCE (PACUTS(1),PCUTGA)
C
*
* gcparm.inc
*

+KEEP, GCPARM, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcparm.inc
      COMMON/GCPARM/IPARAM,PCUTGA,PCUTEL,PCUTNE,PCUTHA,PCUTMU
     +             ,NSPARA,MPSTAK,NPGENE
      REAL PACUTS(5)
      EQUIVALENCE (PACUTS(1),PCUTGA)
+CDE, GTPARM.
C
*
* gcparm.inc
*

+KEEP, GCPARM, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcparm.inc
*
* gcparm.inc
*
*
+CDE, INCBEG.
     +   gcparm
+CDE, INCEND.

+KEEP, GCPHNR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphnr.inc
C  INRFIN - nonradiative decay mode
      INTEGER IGNRFN
      COMMON /GCPHNR/ IGNRFN(8,MAXELZ)
C
*
* gcphnr.inc
*

+KEEP, GCPHNR, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphnr.inc
*
* gcphnr.inc
*
*
+CDE, INCBEG.
     +   gcphnr
+CDE, INCEND.

+KEEP, GCPHPR, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphpr.inc
C  Probability of radiative decay mode.
      REAL GFLUPR
      COMMON /GCPHPR/ GFLUPR(4,MAXELZ)
C
*
* gcphpr.inc
*

+KEEP, GCPHPR, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphpr.inc
*
* gcphpr.inc
*
*
+CDE, INCBEG.
     +   gcphpr
+CDE, INCEND.

+KEEP, GCPHRD, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphrd.inc
C  GRATE - radiative modes' rates
      INTEGER KSHLS,L1SHLS,L2SHLS,L3SHLS,ISHLS,ISHLUS,ISHLTR
      REAL GPHRAT
      PARAMETER (KSHLS=6)
      PARAMETER (L1SHLS=8)
      PARAMETER (L2SHLS=7)
      PARAMETER (L3SHLS=8)
      PARAMETER (ISHLS=29)
      COMMON / GCPHRD / GPHRAT(ISHLS,MAXELZ),ISHLUS(24,4),ISHLTR(ISHLS)
C
*
* gcphrd.inc
*

+KEEP, GCPHRD, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphrd.inc
*
* gcphrd.inc
*
*
+CDE, INCBEG.
     +   gcphrd
+CDE, INCEND.

+KEEP, GCPHXS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphxs.inc
      INTEGER MAXPOW,MAXINT
      PARAMETER (MAXPOW=4)
      PARAMETER (MAXINT=13)
      CHARACTER*6 CRNGUP
      COMMON /GCPXRN/ CRNGUP(MAXINT,MAXELZ)
      REAL COFS,GPOMIN
      COMMON /GCPXCF/ COFS(MAXPOW,MAXINT,MAXELZ),GPOMIN(MAXELZ)
C
*
* gcphxs.inc
*

+KEEP, GCPHXS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcphxs.inc
*
* gcphxs.inc
*
*
+CDE, INCBEG.
     +   gcphxs
+CDE, INCEND.

+KEEP, GCPHYS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcphys.inc
      COMMON/GCPHYS/IPAIR,SPAIR,SLPAIR,ZINTPA,STEPPA
     +             ,ICOMP,SCOMP,SLCOMP,ZINTCO,STEPCO
     +             ,IPHOT,SPHOT,SLPHOT,ZINTPH,STEPPH
     +             ,IPFIS,SPFIS,SLPFIS,ZINTPF,STEPPF
     +             ,IDRAY,SDRAY,SLDRAY,ZINTDR,STEPDR
     +             ,IANNI,SANNI,SLANNI,ZINTAN,STEPAN
     +             ,IBREM,SBREM,SLBREM,ZINTBR,STEPBR
     +             ,IHADR,SHADR,SLHADR,ZINTHA,STEPHA
     +             ,IMUNU,SMUNU,SLMUNU,ZINTMU,STEPMU
     +             ,IDCAY,SDCAY,SLIFE ,SUMLIF,DPHYS1
     +             ,ILOSS,SLOSS,SOLOSS,STLOSS,DPHYS2
     +             ,IMULS,SMULS,SOMULS,STMULS,DPHYS3
     +             ,IRAYL,SRAYL,SLRAYL,ZINTRA,STEPRA
      COMMON/GCPHLT/ILABS,SLABS,SLLABS,ZINTLA,STEPLA
     +             ,ISYNC
     +             ,ISTRA
*
*
* gcphys.inc
*

+KEEP, GCPHYS, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcphys.inc
      COMMON/GCPHYS/IPAIR,SPAIR,SLPAIR,ZINTPA,STEPPA
     +             ,ICOMP,SCOMP,SLCOMP,ZINTCO,STEPCO
     +             ,IPHOT,SPHOT,SLPHOT,ZINTPH,STEPPH
     +             ,IPFIS,SPFIS,SLPFIS,ZINTPF,STEPPF
     +             ,IDRAY,SDRAY,SLDRAY,ZINTDR,STEPDR
     +             ,IANNI,SANNI,SLANNI,ZINTAN,STEPAN
     +             ,IBREM,SBREM,SLBREM,ZINTBR,STEPBR
     +             ,IHADR,SHADR,SLHADR,ZINTHA,STEPHA
     +             ,IMUNU,SMUNU,SLMUNU,ZINTMU,STEPMU
     +             ,IDCAY,SDCAY,SLIFE ,SUMLIF,DPHYS1
     +             ,ILOSS,SLOSS,SOLOSS,STLOSS,DPHYS2
     +             ,IMULS,SMULS,SOMULS,STMULS,DPHYS3
     +             ,IRAYL,SRAYL,SLRAYL,ZINTRA,STEPRA
      COMMON/GCPHLT/ILABS,SLABS,SLLABS,ZINTLA,STEPLA
     +             ,ISYNC
     +             ,ISTRA
*
+CDE, GTPHYS.
*
* gcphys.inc
*

+KEEP, GCPHYS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:32  cernlib
* Geant
* gcphys.inc
*
* gcphys.inc
*
*
+CDE, INCBEG.
     +   gcphys
+CDE, INCEND.

+KEEP, GCPIXE, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcpixe.inc
      COMMON/GCPIXE/LIMPRE,IFLAPE,ICOLOR,IXXX,IYYY,
     +ISSEEN,ISCOLO,ISLSTY,ISLWID,ISFILL,
     +IMAP,JON,NMAP,UUU,VVV,ZUV,ZNMAP1
C


+KEEP, GCPIXE, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcpixe.inc
      COMMON/GCPIXE/LIMPRE,IFLAPE,ICOLOR,IXXX,IYYY,
     +ISSEEN,ISCOLO,ISLSTY,ISLWID,ISFILL,
     +IMAP,JON,NMAP,UUU,VVV,ZUV,ZNMAP1
C
+CDE, GTPIXE.


+KEEP, GCPMXZ, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcpmxz.inc
      INTEGER MAXELZ
      PARAMETER (MAXELZ=100)
C
*
* gcpmxz.inc
*

+KEEP, GCPMXZ, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcpmxz.inc
*
* gcpmxz.inc
*
*
+CDE, INCBEG.
     +   gcpmxz
+CDE, INCEND.

+KEEP, GCPOLY, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcpoly.inc
      COMMON/GCPOLY/IZSEC,IPSEC
      INTEGER IZSEC,IPSEC
C
*
* gcpoly.inc
*

+KEEP, GCPOLY, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcpoly.inc
*
* gcpoly.inc
*
*
+CDE, INCBEG.
     +   gcpoly
+CDE, INCEND.

+KEEP, GCPOTM, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcpotm.inc
+CDE, INCBEG.
     +   gcpotm
+CDE, INCEND.

+KEEP, GCPUSH, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcpush.inc
      COMMON/GCPUSH/NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ
      INTEGER       NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ
C
*
* gcpush.inc
*

+KEEP, GCPUSH, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcpush.inc
*
* gcpush.inc
*
*
+CDE, INCBEG.
     +   gcpush
+CDE, INCEND.

+KEEP, GCRAYT, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcrayt.inc
      COMMON/GCRAYT/INTEN,IOMBRA,IXYFLA,NOFLAG,
     +XLPOS,YLPOS,ZLPOS,XLDIR,YLDIR,ZLDIR,APFLAH,
     +CCXX(4),CCYY(4),CCZZ(4),BOFLAG,APFLAG,
     +XCOSXS,YCOSYS,ZCOSZS,VDX,VDY,VDZ,SSLENG,
     +XPINTS,YPINTS,ZPINTS,FPINTX,FPINTY,FPINTZ,
     +AROTS(4,4),ZROTS(4,4),RRR(4)
C
C

+KEEP, GCRAYT, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcrayt.inc
      COMMON/GCRAYT/INTEN,IOMBRA,IXYFLA,NOFLAG,
     +XLPOS,YLPOS,ZLPOS,XLDIR,YLDIR,ZLDIR,APFLAH,
     +CCXX(4),CCYY(4),CCZZ(4),BOFLAG,APFLAG,
     +XCOSXS,YCOSYS,ZCOSZS,VDX,VDY,VDZ,SSLENG,
     +XPINTS,YPINTS,ZPINTS,FPINTX,FPINTY,FPINTZ,
     +AROTS(4,4),ZROTS(4,4),RRR(4)
C
+CDE, GTRAYT.
C

+KEEP, GCRZ, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcrz.inc
      COMMON/GCRZ1/NRECRZ,NRGET,NRSAVE,LRGET(20),LRSAVE(20)
      INTEGER      NRECRZ,NRGET,NRSAVE,LRGET    ,LRSAVE
      COMMON/GCRZ2/RZTAGS
      CHARACTER*8 RZTAGS(4)
C
*
* gcrz.inc
*

+KEEP, GCRZ, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcrz.inc
*
* gcrz.inc
*
*
+CDE, INCBEG.
     +   gcrz
+CDE, INCEND.

+KEEP, GCSCAL, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcscal.inc
+CDE, GTSCAL.
      PARAMETER(MXSLNK=100)
      COMMON/GCSCAL/ ISLINK(MXSLNK)
      EQUIVALENCE (LSLAST,ISLINK(MXSLNK))
      EQUIVALENCE (LSCAN ,ISLINK(1)),(LSTEMP,ISLINK(2))
      EQUIVALENCE (LSPARA,ISLINK(3)),(LSERAY,ISLINK(4))
*
*
* gcscal.inc
*

+KEEP, GCSCAL, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcscal.inc
      PARAMETER(MXSLNK=100)
      COMMON/GCSCAL/ ISLINK(MXSLNK)
      EQUIVALENCE (LSLAST,ISLINK(MXSLNK))
      EQUIVALENCE (LSCAN ,ISLINK(1)),(LSTEMP,ISLINK(2))
      EQUIVALENCE (LSPARA,ISLINK(3)),(LSERAY,ISLINK(4))
*
*
* gcscal.inc
*

+KEEP, GCSCAL, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcscal.inc
*
* gcscal.inc
*
*
+CDE, INCBEG.
     +   gcscal
+CDE, INCEND.

+KEEP, GCSCAN, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcscan.inc
+CDE, GTSCAN.
      PARAMETER (MSLIST=32,MAXMDT=3)
      COMMON/GCSCAN/SCANFL,NPHI,PHIMIN,PHIMAX,NTETA,TETMIN,TETMAX,
     +              MODTET,IPHIMI,IPHIMA,IPHI1,IPHIL,NSLMAX,
     +              NSLIST,ISLIST(MSLIST),VSCAN(3),FACTX0,FACTL,
     +              FACTR,IPHI,ITETA,ISCUR,SX0,SABS,TETMID(MAXMDT),
     +              TETMAD(MAXMDT)
     +             ,SX0S,SX0T,SABSS,SABST,FACTSF
     +             ,DLTPHI,DLTETA,DPHIM1,DTETM1
     +             ,FCX0M1,FCLLM1,FCRRM1
      LOGICAL SCANFL
      COMMON/GCSCAC/SFIN,SFOUT
      CHARACTER*80 SFIN,SFOUT
*
*
* gcscan.inc
*

+KEEP, GCSCAN, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcscan.inc
      PARAMETER (MSLIST=32,MAXMDT=3)
      COMMON/GCSCAN/SCANFL,NPHI,PHIMIN,PHIMAX,NTETA,TETMIN,TETMAX,
     +              MODTET,IPHIMI,IPHIMA,IPHI1,IPHIL,NSLMAX,
     +              NSLIST,ISLIST(MSLIST),VSCAN(3),FACTX0,FACTL,
     +              FACTR,IPHI,ITETA,ISCUR,SX0,SABS,TETMID(MAXMDT),
     +              TETMAD(MAXMDT)
     +             ,SX0S,SX0T,SABSS,SABST,FACTSF
     +             ,DLTPHI,DLTETA,DPHIM1,DTETM1
     +             ,FCX0M1,FCLLM1,FCRRM1
      LOGICAL SCANFL
      COMMON/GCSCAC/SFIN,SFOUT
      CHARACTER*80 SFIN,SFOUT
*
*
* gcscan.inc
*

+KEEP, GCSCAN, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcscan.inc
*
* gcscan.inc
*
*
+CDE, INCBEG.
     +   gcscan
+CDE, INCEND.

+KEEP, GCSETF.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* gcsetf.inc
      COMMON/GCADII/NPLACE,NUNIT1,N1,NUNIT2
*
      COMMON/GCADIC/BLKSTR,JVSTR
      CHARACTER*500 BLKSTR
      CHARACTER*80  JVSTR
*

+KEEP, GCSETS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcsets.inc
      COMMON/GCSETS/IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV(20)
C
*
* gcsets.inc
*

+KEEP, GCSETS, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcsets.inc
      COMMON/GCSETS/IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV(20)
C
+CDE, GTSETS.
*
* gcsets.inc
*

+KEEP, GCSETS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcsets.inc
*
* gcsets.inc
*
*
+CDE, INCBEG.
     +   gcsets
+CDE, INCEND.

+KEEP, GCSHNO, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcshno.inc
      PARAMETER ( NSBOX=1,  NSTRD1=2, NSTRD2=3, NSTRAP=4, NSTUBE=5,
     +  NSTUBS=6, NSCONE=7, NSCONS=8, NSSPHE=9, NSPARA=10,NSPGON=11,
     +  NSPCON=12,NSELTU=13,NSHYPE=14,NSGTRA=28, NSCTUB=29 )
*
* gcshno.inc
*

+KEEP, GCSHNO, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcshno.inc
*
* gcshno.inc
*
*
+CDE, INCBEG.
     +   gcshno
+CDE, INCEND.

+KEEP, GCSHPT, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcshpt.inc
C  Shells are numbered from 1 to 24.
C  Shells used:
C               K,L1,L2,L3,M1,M2,M3,M4,M5
C               N1,N2,N3,N4,N5,N6,N7,
C               O1,O2,O3,O4,O5,P1,P2,P3
C   VARIABLES:
C     NSHLST - value of Z for which the shells starts to be present
C     N1ST   - pointer to K shell of a given Z (in ESHELL array)
C     NSHLLS - Number of used shells for a given Z
C     ESHELL - Shells potentials in eV !!!
      INTEGER LENGTH,MAXSHL
      PARAMETER (LENGTH=  1409)
      PARAMETER (MAXSHL=24)
      INTEGER NSHLST,N1ST,NSHLLS
      REAL ESHELL
      DIMENSION NSHLST(MAXSHL),N1ST(MAXELZ),NSHLLS(MAXELZ)
      DIMENSION ESHELL(LENGTH)
      COMMON /GCSHPT/NSHLST,N1ST,NSHLLS,ESHELL
C
*
* gcshpt.inc
*

+KEEP, GCSHPT, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gcshpt.inc
*
* gcshpt.inc
*
*
+CDE, INCBEG.
     +   gcshpt
+CDE, INCEND.

+KEEP, GCSPEE, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcspee.inc
+CDE, GTSPEE.
      COMMON/GCSPEE/S1,S2,S3,SS1,SS2,SS3,LEP,IPORLI,ISUBLI,
     +              SRAGMX,SRAGMN,RAINT1,RAINT2,RMIN1,RMIN2,
     +              RMAX1,RMAX2,JPORJJ,ITSTCU,IOLDCU,ISCOP,
     +              NTIM,NTFLAG,LPASS,JSC
*
*
* gcspee.inc
*

+KEEP, GCSPEE, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcspee.inc
      COMMON/GCSPEE/S1,S2,S3,SS1,SS2,SS3,LEP,IPORLI,ISUBLI,
     +              SRAGMX,SRAGMN,RAINT1,RAINT2,RMIN1,RMIN2,
     +              RMAX1,RMAX2,JPORJJ,ITSTCU,IOLDCU,ISCOP,
     +              NTIM,NTFLAG,LPASS,JSC
*
*
* gcspee.inc
*

+KEEP, GCSPEE, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcspee.inc
*
* gcspee.inc
*
*
+CDE, INCBEG.
     +   gcspee
+CDE, INCEND.

+KEEP, GCSTAK, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcstak.inc
+CDE, GTSTAK.
      PARAMETER (NWSTAK=12,NWINT=11,NWREAL=12,NWTRAC=NWINT+NWREAL+5)
      COMMON /GCSTAK/ NJTMAX, NJTMIN, NTSTKP, NTSTKS, NDBOOK, NDPUSH,
     +                NJFREE, NJGARB, NJINVO, LINSAV(15), LMXSAV(15)
      EQUIVALENCE (ISTORD,NJTMIN)
C
*
* gcstak.inc
*

+KEEP, GCSTAK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcstak.inc
      PARAMETER (NWSTAK=12,NWINT=11,NWREAL=12,NWTRAC=NWINT+NWREAL+5)
      COMMON /GCSTAK/ NJTMAX, NJTMIN, NTSTKP, NTSTKS, NDBOOK, NDPUSH,
     +                NJFREE, NJGARB, NJINVO, LINSAV(15), LMXSAV(15)
      EQUIVALENCE (ISTORD,NJTMIN)
C
*
* gcstak.inc
*

+KEEP, GCSTAK, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcstak.inc
*
* gcstak.inc
*
*
+CDE, INCBEG.
     +   gcstak
+CDE, INCEND.

+KEEP, GCSTRA, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcstra.inc
      PARAMETER (ILTAB=200)
      COMMON /GCSTRA / EMAX,EM(200),SFINT,EPSR(ILTAB),EPSI(ILTAB),
     +  FINT(ILTAB),EMIN,EPPS,BETA2,GAMMA2,WP2,S2,MEEV,EMM(200),
     +  GAMLOG(21),NP,NTAB,IE,NFACT,NICOLL
*
      INTEGER NP,NTAB,IE,NFACT
      REAL    EMAX,EM,SFINT,EPSR,EPSI,FINT,EMIN,EPPS,EMM,GAMLOG
     +        ,BETA2,GAMMA2,WP2,S2,MEEV
*

+KEEP, GCTIME, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctime.inc
      COMMON/GCTIME/TIMINT,TIMEND,ITIME,IGDATE,IGTIME
      INTEGER ITIME,IGDATE,IGTIME
      REAL TIMINT,TIMEND
C
*
* gctime.inc
*

+KEEP, GCTIME, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctime.inc
*
* gctime.inc
*
*
+CDE, INCBEG.
     +   gctime
+CDE, INCEND.

+KEEP, GCTMED, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctmed.inc
      COMMON/GCTMED/NUMED,NATMED(5),ISVOL,IFIELD,FIELDM,TMAXFD,STEMAX
     +      ,DEEMAX,EPSIL,STMIN,CFIELD,PREC,IUPD,ISTPAR,NUMOLD
      COMMON/GCTLIT/THRIND,PMIN,DP,DNDL,JMIN,ITCKOV,IMCKOV,NPCKOV
C
*
* gctmed.inc
*

+KEEP, GCTMED, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctmed.inc
      COMMON/GCTMED/NUMED,NATMED(5),ISVOL,IFIELD,FIELDM,TMAXFD,STEMAX
     +      ,DEEMAX,EPSIL,STMIN,CFIELD,PREC,IUPD,ISTPAR,NUMOLD
      COMMON/GCTLIT/THRIND,PMIN,DP,DNDL,JMIN,ITCKOV,IMCKOV,NPCKOV
C
+CDE, GTTMED.
*
* gctmed.inc
*

+KEEP, GCTMED, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctmed.inc
*
* gctmed.inc
*
*
+CDE, INCBEG.
     +   gctmed
+CDE, INCEND.

+KEEP, GCTRAK, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctrak.inc
+CDE, GTTRAK.
      PARAMETER (MAXMEC=30)
      COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7),NMEC,LMEC(MAXMEC)
     + ,NAMEC(MAXMEC),NSTEP ,MAXNST,DESTEP,DESTEL,SAFETY,SLENG
     + ,STEP  ,SNEXT ,SFIELD,TOFG  ,GEKRAT,UPWGHT,IGNEXT,INWVOL
     + ,ISTOP ,IGAUTO,IEKBIN, ILOSL, IMULL,INGOTO,NLDOWN,NLEVIN
     + ,NLVSAV,ISTORY
      PARAMETER (MAXME1=30)
      COMMON/GCTPOL/POLAR(3), NAMEC1(MAXME1)
C
*
* gctrak.inc
*

+KEEP, GCTRAK, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctrak.inc
      PARAMETER (MAXMEC=30)
      COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7),NMEC,LMEC(MAXMEC)
     + ,NAMEC(MAXMEC),NSTEP ,MAXNST,DESTEP,DESTEL,SAFETY,SLENG
     + ,STEP  ,SNEXT ,SFIELD,TOFG  ,GEKRAT,UPWGHT,IGNEXT,INWVOL
     + ,ISTOP ,IGAUTO,IEKBIN, ILOSL, IMULL,INGOTO,NLDOWN,NLEVIN
     + ,NLVSAV,ISTORY
      PARAMETER (MAXME1=30)
      COMMON/GCTPOL/POLAR(3), NAMEC1(MAXME1)
C
*
* gctrak.inc
*

+KEEP, GCTRAK, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gctrak.inc
*
* gctrak.inc
*
*
+CDE, INCBEG.
     +   gctrak
+CDE, INCEND.

+KEEP, GCUNIT, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcunit.inc
      COMMON/GCUNIT/LIN,LOUT,NUNITS,LUNITS(5)
      INTEGER LIN,LOUT,NUNITS,LUNITS
      COMMON/GCMAIL/CHMAIL
      CHARACTER*132 CHMAIL
C
*
* gcunit.inc
*

+KEEP, GCUNIT, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcunit.inc
*
* gcunit.inc
*
*
+CDE, INCBEG.
     +   gcunit
+CDE, INCEND.

+KEEP, GCURSB, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcursb.inc
      COMMON/GCURSB/NUMNDS,IADDI,NUMND2,NNPAR,IISELT
      COMMON/GCURSC/MOMO
      CHARACTER*4 MOMO
*
*
* gcursb.inc
*

+KEEP, GCURSB, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcursb.inc
      COMMON/GCURSB/NUMNDS,IADDI,NUMND2,NNPAR,IISELT
      COMMON/GCURSC/MOMO
      CHARACTER*4 MOMO
*
+CDE, GTURSB.
*
* gcursb.inc
*

+KEEP, GCURSB, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:31  cernlib
* Geant
* gcursb.inc
*
* gcursb.inc
*
*
+CDE, INCBEG.
     +   gcursb
+CDE, INCEND.

+KEEP, GCVDMA, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcvdma.inc
      COMMON/GCVDMA/NVMANY,MANYLE(20),MANYNA(20,15),
     +MANYNU(20,15),NFMANY,MYCOUN,IMYSE,RAYTRA,VECCOS(3)
C
C

+KEEP, GCVDMA, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant
* gcvdma.inc
      COMMON/GCVDMA/NVMANY,MANYLE(20),MANYNA(20,15),
     +MANYNU(20,15),NFMANY,MYCOUN,IMYSE,RAYTRA,VECCOS(3)
C
+CDE, GTVDMA.
C

+KEEP, GCVOL1, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcvol1.inc
      COMMON/GCVOL1/NLEVL1,NAMES1(15),NUMBR1(15),LVOLU1(15)
C
*
* gcvol1.inc
*

+KEEP, GCVOL1, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcvol1.inc
      COMMON/GCVOL1/NLEVL1,NAMES1(15),NUMBR1(15),LVOLU1(15)
C
+CDE, GTVOL1.
*
* gcvol1.inc
*

+KEEP, GCVOL1, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcvol1.inc
*
* gcvol1.inc
*
*
+CDE, INCBEG.
     +   gcvol1
+CDE, INCEND.

+KEEP, GCVOL2, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcvol2.inc
      COMMON/GCVOL2/NLEVE2,NAMES2(15),NUMB2(15),
     +LVOL2(15),LIND2(15),INFRO2,NLDEV2(15),LINMX2(15),
     +GTRAN2(3,15),GRMAT2(10,15),GONLY2(15),GLX2(15)
      INTEGER NLEVE2,NAMES2,NUMB2,LVOL2,LIND2,INFRO2,NLDEV2,LINMX2
      REAL GTRAN2,GRMAT2,GONLY2,GLX2
C
*
* gcvol2.inc
*

+KEEP, GCVOL2, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcvol2.inc
*
* gcvol2.inc
*
*
+CDE, INCBEG.
     +   gcvol2
+CDE, INCEND.

+KEEP, GCVOLU, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcvolu.inc
      COMMON/GCVOLU/NLEVEL,NAMES(15),NUMBER(15),
     +LVOLUM(15),LINDEX(15),INFROM,NLEVMX,NLDEV(15),LINMX(15),
     +GTRAN(3,15),GRMAT(10,15),GONLY(15),GLX(3)
C
*
* gcvolu.inc
*

+KEEP, GCVOLU, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcvolu.inc
      COMMON/GCVOLU/NLEVEL,NAMES(15),NUMBER(15),
     +LVOLUM(15),LINDEX(15),INFROM,NLEVMX,NLDEV(15),LINMX(15),
     +GTRAN(3,15),GRMAT(10,15),GONLY(15),GLX(3)
C
+CDE, GTVOLU.
*
* gcvolu.inc
*

+KEEP, GCVOLU, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:33  cernlib
* Geant
* gcvolu.inc
*
* gcvolu.inc
*
*
+CDE, INCBEG.
     +   gcvolu
+CDE, INCEND.

+KEEP, GCXLUN, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcxlun.inc
      COMMON/GCXLUN/LUNIT(128)
*
*
* gcxlun.inc
*

+KEEP, GCXLUN, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gcxlun.inc
*
* gcxlun.inc
*
*
+CDE, INCBEG.
     +   gcxlun
+CDE, INCEND.

+KEEP, GFKDIS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* gfkdis.inc
      COMMON/ GFKDIS/ ZINE, ZELA, ZTOT, INT
     +               ,SINE, SELA, FSIG, IFMAT, IGF
C
C

+KEEP, GSECTI, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gsecti.inc
      COMMON/GSECTI/ AIEL(20),AIIN(20),AIFI(20),AICA(20),ALAM,K0FLAG
      INTEGER K0FLAG
      REAL AIEL,AIIN,AIFI,AICA,ALAM
C
*
* gsecti.inc
*

+KEEP, GSECTI, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* gsecti.inc
*
* gsecti.inc
*
*
+CDE, INCBEG.
     +   gsecti
+CDE, INCEND.

+KEEP, GVERSC, IF=-INCLUDE.
* Revision 1.10  1999/11/15 15:30:37  mclareni
* Updated version number to 3.21/13
* Revision 1.9  1999/01/27 14:21:07  mclareni
* Updated version number to 3.21/12
* Revision 1.8  1998/02/11 09:47:00  japost
*   Updated version number to 3.21/11.
* Revision 1.7  1997/11/13 13:04:45  mclareni
* Increase cradle no. to 0.10
* Revision 1.6  1997/10/17 10:26:24  mclareni
* Increase cradle no. to 0.09
* Revision 1.5  1997/06/20 18:40:53  japost
*   Updating the version number after commiting several changes:
*   to gthion, gflufin, ghetun
*   Remaining problem: gdrawp, ghadr?
* Revision 1.4  1997/01/06 17:08:17  cernlib
* Increase cradle no. to 0.07
* Revision 1.3  1996/11/19 11:28:53  ravndal
* *** empty log message ***
* Revision 1.2  1996/04/15 14:10:08  ravndal
* Update cradel number
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* gversc.inc
      GVERSC = 0.13

+KEEP, HADFLG.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* hadflg.inc
*=== hadflg ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 13 september 1991 by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on  1-dec-91     by    Alfredo Ferrari               *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                                         Calumo                       *
*                                         Datesh                       *
*                                         Eventv                       *
*                                         Ferhav                       *
*                                         Hadriv                       *
*                                         Rchanv                       *
*                                                                      *
*                    Ielflg = Flag to control the elastic channel      *
*                             in Hadriv:                               *
*                             -1: elastic channel reduced according    *
*                                 to a rough Pauli blocking factor     *
*                              0: elastic channel fully accounted for  *
*                             +1: elastic channel suppressed           *
*                    Icxflg = Flag to control the charge exchange      *
*                             channel in Hadriv:                       *
*                             -1: ch. ex. channel reduced according    *
*                                 to a rough Pauli blocking factor     *
*                              0: ch. ex. channel fully accounted for  *
*                             +1: ch. ex. channel suppressed           *
*             Innure(1,1,k) = Projectile index for the Hadriv reaction *
*                             k (first entrance channel)               *
*             Innure(2,1,k) = Target index for the Hadriv reaction     *
*                             k (first entrance channel)               *
*             Innure(1,2,k) = Projectile index for the Hadriv reaction *
*                             k (second entrance channel, if any)      *
*             Innure(2,2,k) = Target index for the Hadriv reaction     *
*                             k (second entrance channel, if any)      *
*                             It holds:                                *
*                        Nure (Innure(1,j,k),(Innure(2,j,k)/8+1)) = k  *
*                                                                      *
*----------------------------------------------------------------------*
      PARAMETER ( PPAMXB = 0.6       D+00 )
      PARAMETER ( PAUMXB = 2.D+00 * 0.8 D+00 )
      PARAMETER ( PPAMXM = 0.6       D+00 )
      PARAMETER ( PAUMXM = 2.D+00 * 0.4 D+00 )
*
      COMMON / FKHADF / IELFLG, ICXFLG, IKCHXG (16), INNURE (2,2,16),
     &                  IOLDHD


+KEEP, HADPAR.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* hadpar.inc
C***********************************************************************
C     INCLUDE FILE: HADPAR COPY                   CREATED 11/12/86 BY PA
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX4=1133)
      CHARACTER*8 ANH
      COMMON /FKHADP/PXH(IDMAX4),PYH(IDMAX4),PZH(IDMAX4),HEPH(IDMAX4),
     *AMH(IDMAX4),ICHH(IDMAX4),IBARH(IDMAX4),            NREH(IDMAX4)
      COMMON /FKHADC/ANH(IDMAX4)


+KEEP, HETC5.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* hetc5.inc
*                                                                      *
*=== hetc5 ============================================================*
*                                                                      *
      COMMON /FKHET5/ APR,ZPR,EX,UU,EREC


+KEEP, HETC7.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* hetc7.inc
*                                                                      *
*=== hetc7 ============================================================*
*                                                                      *
      COMMON /FKHET7/ COSKS,SINKS, COSTH,SINTH, COSPHI,SINPHI


+KEEP, HETTP.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* hettp.inc
*                                                                      *
*=== hettp ============================================================*
*                                                                      *
      COMMON /FKHETP/  NHSTP,NBERTP,IOSUB,INSRS


+KEEP, HIGFIS.
* Revision 1.1.1.1  1995/10/24 10:20:39  cernlib
* Geant
* higfis.inc
*=== higfis ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     HIGh energy FISsion common:                                      *
*                                                                      *
*     Created   on   9 april 1993   by   Alfredo Ferrari & Paola Sala  *
*                                             INFN - Milan             *
*     Last change on   11-apr-93    by   Alfredo Ferrari, INFN - Milan *
*                                                                      *
*          Fisinh = logical flag for HE fission                        *
*          Afis(i)= ith fragment mass number just after fission        *
*          Zfis(i)= ith fragment atomic number just after fission      *
*          Ufis(i)= ith fragment excitation energy (MeV) just after    *
*                   fission                                            *
*         Ekfis(i)= ith fragment kinetic(MeV) energy just after fission*
*         Amfis(i)= ith fragment atomic mass (MeV) just after fission  *
*         Ppfis(i)= ith fragment momentum (MeV/c) just after fission   *
*         Atfis(i)= ith fragment mass number after evaporation         *
*         Ztfis(i)= ith fragment atomic number after evaporation       *
*         Utfis(i)= ith fragment excitation energy (MeV) after evapora-*
*                   tion                                               *
*        Recfis(i)= ith fragment kinetic(MeV) energy after evaporation *
*        Atmfis(i)= ith fragment atomic mass (MeV) after evaporation   *
*        Pptfis(i)= ith fragment momentum (MeV/c) after evaporation    *
*          Ebfiss = fission barrier (MeV)                              *
*          Amdiff = Fission fragment kinetic energy (MeV)              *
*            Apr0 = Mass number of the (first) fissioning nucleus      *
*            Zpr0 = Atomic number of the (first) fissioning nucleus    *
*             Uu0 = Excitation energy (MeV) of the (first) fissioning  *
*                   nucleus                                            *
*           Erec0 = Recoil kinetic energy (MeV) of the (first) fissio- *
*                   ning nucleus                                       *
*      Npartf(j,i)= Number of evaporated particle of type j after the  *
*                   evaporation of the ith fragment                    *
*        Hevfis(i)= Evaporated "heavies" kinetic energy (MeV) after the*
*                   evaporation of the ith fragment                    *
*           Nfiss = Number of fission fragments in the stack           *
*                                                                      *
*----------------------------------------------------------------------*
      LOGICAL FISINH
      COMMON / FKHIGF / AFIS  (10), ZFIS  (10), UFIS  (10), EKFIS  (10),
     &                  AMFIS (10), PPFIS (10), COSLFF(3,0:10),
     &                  ATFIS (10), ZTFIS (10), UTFIS (10), RECFIS (10),
     &                  AMTFIS(10), PPTFIS(10), EBFISS, AMDIFF,
     &                  APR0, ZPR0, EREC0, UU0, HEVFIS (0:10),
     &                  NPARTF (6,0:10), NFISS, FISINH
      DIMENSION COSLF0 (3)
      EQUIVALENCE ( COSLF0 (1), COSLFF (1,0) )

+KEEP, INCDEK.
* Revision 1.1.1.1  1995/10/24 10:20:36  cernlib
* Geant

+KEEP, INPDAT.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* inpdat.inc
*=== inpdat ===========================================================*
*----------------------------------------------------------------------*
*     include file: inpdat copy          Created 22/12/86 by PA Aarnio
*     changes: revised 29/3/90 by A. Ferrari
*     included in the following subroutines or functions: not updated
*     N O W   T H E R E   I S   A   C O P Y   O F   I N P D A T
*     (  I N P D A T 2  )   C R E A T E D
*     T O   A V O I D   T O   D I R T Y   T H E   B A M J E T
*     P A R A M E T E R S !!!!!!!!!!!!
*     description of the common block(s) and variable(s)
*----------------------------------------------------------------------*
      COMMON /FKINPD/ A1, B1, B2, B3, BET, AS, B8, AME, DIQ, IMPS(6,6),
     &                IMVE(6,6),  IB08(6,21), IB10(6,21), IA08(6,21),
     &                IA10(6,21), LT, LE, ISU


+KEEP, INPDAT2.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* inpdat2.inc
*=== inpdat2 ==========================================================*
*----------------------------------------------------------------------*
*     include file: inpdat2 copy          created 29/3/90 by A. Ferrari
*     changes: none
*     included in the following subroutines or functions: not updated
*     T H I S   I S   A   C O P Y   O F   I N P D A T   C R E A T E D
*     T O   A V O I D   T O   D I R T Y   T H E   B A M J E T
*     P A R A M E T E R S !!!!!!!!!!!!
*     description of the common block(s) and variable(s)
*----------------------------------------------------------------------*
      COMMON /FKINPD/ A1BAMJ, B1BAMJ, B2BAMJ, B3BAMJ, BETBAM, ASBAMJ,
     &                B8BAMJ, AMEBAM, DIQBAM, IMPS (6,6), IMVE (6,6),
     &                IB08 (6,21), IB10 (6,21), IA08 (6,21),
     &                IA10 (6,21), LTBAMJ, LEBAMJ, ISUBAM


+KEEP, INPFLG.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* inpflg.inc
*                                                                      *
*=== inpflg ===========================================================*
*                                                                      *
      COMMON /FKINPF/ IANG,IFISS,IB0,IGEOM,ISTRAG,KEYDK


+KEEP, IOUNIT.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* iounit.inc
*                                                                     *
*=== iounit ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      Iounit: included in any routine                                *
*                                                                     *
*         lunin  = standard input unit                                *
*         lunout = standard output unit                               *
*         lunerr = standard error unit                                *
*         lunber = input file for bertini nuclear data                *
*         lunech = echo file for pegs dat                             *
*         lunflu = input file for photoelectric edges and X-ray fluo- *
*                  rescence data                                      *
*         lungeo = scratch file for combinatorial geometry            *
*         lunpgs = input file for pegs material data                  *
*         lunran = output file for the final random number seed       *
*         lunxsc = input file for low energy neutron cross sections   *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( LUNIN  = 5  )
      PARAMETER ( LUNOUT = 6  )
      PARAMETER ( LUNERR = 66 )
      PARAMETER ( LUNBER = 22 )
      PARAMETER ( LUNECH = 8  )
      PARAMETER ( LUNFLU = 86 )
      PARAMETER ( LUNGEO = 16 )
      PARAMETER ( LUNPGS = 12 )
      PARAMETER ( LUNRAN = 2  )
      PARAMETER ( LUNXSC = 81 )


+KEEP, ISOTOP.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* isotop.inc
*----------------------------------------------------------------------*
*     include file: isotop          created by A. Ferrari on 23-9-90   *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*        isondx = initial and final indexes in the abuiso and isomnm   *
*                 for a given atomic number                            *
*        isomnm = mass numbers of the isotopes                         *
*        abuiso = natural abundances of the isotopes                   *
*        astlin(1,iz) = "average" A of the stability line versus the   *
*                       atomic number Z                                *
*        astlin(2,iz) = dispersion of A of the stability line versus   *
*                       the atomic number Z                            *
*        zstlin(1,ia) = "average" Z of the stability line versus the   *
*                       mass number A                                  *
*        zstlin(2,ia) = dispersion of Z of the stability line versus   *
*                       the mass number A                              *
*                                                                      *
*----------------------------------------------------------------------*
      COMMON / FKISOT / ABUISO (NSTBIS), ASTLIN (2,100), ZSTLIN (2,260),
     &                  ISOMNM (NSTBIS), ISONDX (2,100)


+KEEP, LABCOS.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* labcos.inc
*                                                                      *
*=== labcos ===========================================================*
*                                                                      *
      COMMON /FKLABC/ COSLBP(3),COSLBR(3)


+KEEP, LIMITS.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* limits.inc
C --- BOUNDARY LIMITS FOR ARGUMENTS OF INTRINSIC FUNCTIONS ---
C --- XL DENOTES LOWER BOUND WHEREAS XU DENOTES UPPER BOUND ---
      COMMON /LIMITS/ EXPXL,EXPXU
C

+KEEP, LUDAT1, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* ludat1.inc
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      INTEGER MSTU,MSTJ
      REAL    PARU,PARJ
      SAVE /LUDAT1/
*
*
* ludat1.inc
*

+KEEP, LUDAT1, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* ludat1.inc
*
* ludat1.inc
*
*
+CDE, INCBEG.
     +    ludat1
+CDE, INCEND.

+KEEP, LUDAT3, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* ludat3.inc
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)
      INTEGER MDCY,MDME,KFDP
      REAL    BRAT
      SAVE /LUDAT3/
*
*
* ludat3.inc
*

+KEEP, LUDAT3, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* ludat3.inc
*
* ludat3.inc
*
*
+CDE, INCBEG.
     +    ludat3
+CDE, INCEND.

+KEEP, LUJETS, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* lujets.inc
      COMMON/LUJETS/N,K(4000,5),P(4000,5),V(4000,5)
      INTEGER N,K
      REAL P,V
      SAVE /LUJETS/
*
*
* lujets.inc
*

+KEEP, LUJETS, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:34  cernlib
* Geant
* lujets.inc
*
* lujets.inc
*
*
+CDE, INCBEG.
     +    lujets
+CDE, INCEND.

+KEEP, MAPA.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* mapa.inc
*----------------------------------------------------------------------*
*     include file: mapa copy                    created 26/11/86 by pa*
*     note: change also mapa2 copy if you touch this file              *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /mapa/ contains the parameters describing the target materials   *
*        matnam = matnam(i)=name of the material number i              *
*        medium = medium(nreg)=material number of the region nreg      *
*        amss   = the atomic weight of the materials                   *
*        aocmbm = atomic densities in barn**-1 cm**-1                  *
*                 (Atoms Over Cm times Barn for Materials)             *
*        ztar   = atomic numbers of the materials                      *
*        rho    = densities of the materials                           *
*        zlin   = inelastic scattering lengths of the materials        *
*                 for beam particles at the average beam energy in cm  *
*        zlel   = elastic scattering lengths of the materials for      *
*                 beam particles at average beam energy in cm          *
*        zlrad  = radiation lengths of the materials in cm             *
*        zul    = inelastic scattering lengths of the materials        *
*                 for neutrons at threshold energy in cm               *
*        mulflg = flags for multiple scattering options                *
*        icomp  = 0 if the material is not a compound                  *
*        mssnum = mass number of the target nucleus, if =< 0 it means  *
*                 that it is in the natural isotopic composition       *
*        nregs  = total number of the regions                          *
*        nmat   = total number of the materials                        *
*        mtbsnm = medium for which inelastic interaction biasing must  *
*                 be done                                              *
*                                                                      *
*                        Mxxrgn = maximum number of regions            *
*                                                                      *
*----------------------------------------------------------------------*
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     &                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     &                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     &                  MULFLG (MXXMDF), ICOMP(MXXMDF), MSSNUM (MXXMDF),
     &                  NREGS, NMAT, MTBSNM


+KEEP, MAPAT.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* mapat.inc

      DOUBLE PRECISION  AOCMBM , AMSS , ZTAR   , RHO    , ZLIN , ZLEL
     &                , ZLRAD  , ZUL


+KEEP, MAPOLL.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* mapoll.inc
      COMMON/MAPOLL/ETA,ETATH,ETAUSD,DEADWT(5),XTRA(10),ITERS,IFR,IFG,
     1ITSTR,NEWNM,NGEOM,NMEM,NMEMR,NMEMG,INALB,NDEAD(5),NPSCL(13)

+KEEP, MCONST.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* mconst.inc
+CDE, MPARAM.
      COMMON/MCONST/NNR,NQ,NGR,NTSTW,MGPREG,MGP1,M1M,NI,NNUC,NCOL

+KEEP, MCRECO.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* mcreco.inc
      COMMON/MCRECO/AMED(3),ZMED(3),ERMED
C

+KEEP, MCROSS.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* mcross.inc
      COMMON/MCROSS/SIGT,SIGTNS,SIGTNA,SIGNES,SIGNIS,SGNISD,SGNISC,
     1SIGN2N,SIGN3N,SIGNNA,SGNN3A,SGN2NA,SIGNNP,SIGNF,SIGNG,SIGNP,
     2SIGND,SIGNT,SGN3HE,SIGNA,SIGN2A,SIGN3A,SIGN2P,SIGNPA,SGNT2A,
     3SGND2A

+KEEP, METLSP.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* metlsp.inc
C***********************************************************************
C     INCLUDE FILE: METLSP COPY                   CREATED 11/12/86 BY PA
C     CHANGES: NONE
C     INCLUDED IN THE FOLLOWING SUBROUTINES OR FUNCTIONS: NOT UPDATED
C
C     DESCRIPTION OF THE COMMON BLOCK(S) AND VARIABLE(S)
C
C***********************************************************************
      PARAMETER (IDMAX2=1133)
      COMMON/FKMETL/ IS,ITS(IDMAX2),CXS(IDMAX2),CYS(IDMAX2),CZS(IDMAX2),
     *ELS(IDMAX2),PLS(IDMAX2)


+KEEP, MGAMMA.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* mgamma.inc
      COMMON/MGAMMA/NAMEXG,MTNG,NMEDG,NCOLG,EG,UG,VG,WG,
     1XG,YG,ZG,WATEG,AGEG

+KEEP, MINPUT.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* minput.inc
      COMMON/MINPUT/NCASE,NSTRT,NMOST,MOSTG,MOSTR,NITS,NPHOTN,
     1 NHEAVY,NSOUR,NSPLT,NKILL,NPAST,NOLEAK,IEBIAS,MEDIA,NMIX,
     2 ISOUR,NGPFS,ISBIAS,INN,IOUT,MGEOM,MGAMMA,MHEAVY,MICROS,
     3 MACROS,MGSCR,MRSCR,MHETC,IPRTNX,IPRTNA,IPRTNE,IPRTPP,IPRTNP,
     4 IPRTGX,IPRTGE,IPRTMX,UINP,VINP,WINP,XSTRT,YSTRT,ZSTRT,WTSTRT,
     5 AGSTRT,ESOUR,TMAX,TCUT,ECUT,ETHERM,TEMP,TOL

+KEEP, MMASS.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mmass.inc
      COMMON/MMASS/ZN,ZP,ZD,ZT,ZHE3,ZA,AN,AP,AD,AT,AHE3,AA

+KEEP, MMICAB.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mmicab.inc
C
      COMMON/ MMICAP / LMAG2,LCISO,LGE2MO,LMOMA,LMOX1,LMOX2,
     +                 LMOX3,LMOX4
      COMMON/ MICPAR / LMIST
      COMMON/ MICFIL / LMIFIL
      COMMON/ MICTMP / LTEMP,NTUNIT,NTNAME,NTMPNI,NTCOMM,NTDATS,NTLIST

+KEEP, MMICAP.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mmicap.inc
C
+CDE, MMICAB.
+CDE, GCBANK.
      DIMENSION LD(1),D(1)
      EQUIVALENCE (D(1),Q(1)),(LD(1),IQ(1))
      CHARACTER*24 DATSTR
      CHARACTER*80 COMMEN
      COMMON/ MICMAT / DATSTR,COMMEN,MATIDS(100,20,2)
C

+KEEP, MNUTRN.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mnutrn.inc
      COMMON/MNUTRN/NAME,NAMEX,E,EOLD,NMED,MEDOLD,NREG,U,V,W,
     + UOLD,VOLD,WOLD,X,Y,Z,XOLD,YOLD,ZOLD,WATE,OLDWT,WTBC,
     + BLZNT,BLZON,AGE,OLDAGE,INEU,ENE(MAXNEU)
      INTEGER BLZNT

+KEEP, MPIFINC.
*CMZ :          02/11/94  13.23.19  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   13/07/94
C   Include the file which defines all the MPI (Message Passing Interface)
C   constants. The name of this file must be "mpif.h" but it will reside
C   in different places on different machines/implementations/sites and
C   the way of including it will also depend on the compiler used.
C   For the Chimp/MPI implementation from EPCC and Sun's Fortran 77. May 1995
C     Ensure that the output filename is something.F  (not something.f)
C     (In CMZ, use  "kuip/set_show/filecase keep" to do this).
+CDE, MPIF.
+KEEP, MPOINT.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mpoint.inc
      COMMON/MPOINT/LMAG1,LFP1,LFP2,LFP3,LFP4,LFP5,LFP6,LFP7,LFP8,
     + LFP9,LFP10,LFP11,LFP12,LFP13,LFP14,LFP140,LFP15,LFP16,LFP17,
     + LFP18,LFP19,LFP20,LFP21,LFP22,LFP23,LFP24,LFP25,LFP26,
     + LFP27,LFP28,LFP29,LFP30,LFP31,LFP32,LFP33,LFP34,LFP35,
     + LFP36,LFP37,LFP38,LFP39,LFP40,LFP41,LFP42,LFP43,LFP44,
     + LFP45,LFP46,LFP47,LFP48,LFP49,LFP50,LFP51,LFP52,LFP53,
     + LFP18A,LFP210

+KEEP, MPSTOR.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mpstor.inc
      PARAMETER(IDNEU  = 1)
      PARAMETER(IDHEVY = 2)
      PARAMETER(IDGAMA = 3)
      COMMON/ MPSTOR / EN(MAXPAR),UN(MAXPAR),VN(MAXPAR),WN(MAXPAR),
     +                 AGEN(MAXPAR),MTN(MAXPAR),AMN(MAXPAR),
     +                 ZMN(MAXPAR),IDN(MAXPAR),
     +                 EP,UP,VP,WP,MTP,AGEP,AMP,ZMP,
     +                 NNEU,NHEVY,NGAMA,NPSTOR

+KEEP, MRECOI.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mrecoi.inc
      COMMON/MRECOI/NAMEXR,MTNR,NZR,NCOLR,AR,ER,UR,VR,WR,XR,YR,ZR,
     1WATER,AGER,ENIR,UNIR,VNIR,WNIR,ENOR,UNOR,VNOR,WNOR,WTNR,QR

+KEEP, MULTIPROX.
*CMZ :          02/11/94  15.23.33  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   20/10/94
C   Variables to store information on the parallel configuration
      integer            nprank, npsize, nevtot, nfirstworker, npleader
      common /multiprox/ nprank, npsize, nevtot, nfirstworker, npleader
C     Descriptions:
C         npsize= number of processors being used
C         nprank= the rank of this processor ( 0 to npsize - 1 )
C         nevtot= total number of events requested (for all procs)
C         the last two are only used in the case that one node reads an event
C         input file, while the rest do the real simulation work
C         nfirstworker= rank of first process to simulate
C         npleader= rank of the process that reads the input
+KEEP, MULTSEEDS.
*CMZ :          13/07/94  11.16.35  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   13/07/94
C     Auxiliary variable for calculating pRNG seeds on different nodes.
      integer            iseeda, iseedb, iseqnc
      common /multseeds/ iseeda, iseedb, iseqnc
+KEEP, MUPSCA.
* Revision 1.1.1.1  1995/10/24 10:20:45  cernlib
* Geant
* mupsca.inc
      COMMON/MUPSCA/ERFGM

+KEEP, MXGKGH.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* mxgkgh.inc
      PARAMETER (MXGKGH=100)

+KEEP, NUCDAT.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* nucdat.inc
*                                                                     *
*=== nucdat ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*     Include file Nucdat                                             *
*                                                                     *
*     Created on 20 april 1990  by            Alfredo Ferrari         *
*                                               INFN Milan            *
*                                                                     *
*     Last change on 09-jun-92                                        *
*                                                                     *
*     Included in the following routines:                             *
*                                                                     *
*            COREVT                                                   *
*            CORRIN                                                   *
*            DISTNU                                                   *
*            DRES                                                     *
*            EVDEEX                                                   *
*            EVENTV                                                   *
*            EVEVAP                                                   *
*            FEREVV                                                   *
*            FERHAV                                                   *
*            INCINI                                                   *
*            NUCEVV                                                   *
*            NUCRIV                                                   *
*            RAKEKV                                                   *
*            RBKEKV                                                   *
*            EVENTQ                                                   *
*            NUCRIN                                                   *
*                                                                     *
*---------------------------------------------------------------------*
      PARAMETER ( AMUAMU = 0.93149432  D+00 )
*     PARAMETER ( AMPROT = 0.9382796   D+00 )
      PARAMETER ( AMPROT = 0.93827231  D+00 )
*     PARAMETER ( AMNEUT = 0.9395731   D+00 )
      PARAMETER ( AMNEUT = 0.93956563  D+00 )
      PARAMETER ( AMELEC = AMELCT )
      PARAMETER ( R0NUCL = 1.12        D+00 )
      PARAMETER ( RCCOUL = 1.7         D+00 )
      PARAMETER ( COULPR = 0.001439965 D+00 )
*     PARAMETER ( FERTHO = 15.73       D-09 )
*     PARAMETER ( EXPEBN = 7.D+00 / 3.D+00  )
*     PARAMETER ( BEXC12 = FERTHO * 65.41634134195703D+00 )
      PARAMETER ( FERTHO = 14.33       D-09 )
      PARAMETER ( EXPEBN = 2.39        D+00 )
      PARAMETER ( BEXC12 = FERTHO * 72.40715579499394D+00 )
      PARAMETER ( AMUC12 = AMUAMU - AMELEC / 2.D+00 - BEXC12 / 12.D+00 )
      PARAMETER ( AMHYDR = AMPROT + AMELEC  )
      PARAMETER ( AMHTON = AMHYDR - AMNEUT  )
      PARAMETER ( AMNTOU = AMNEUT - AMUC12  )
      PARAMETER ( AMUCSQ = AMUC12 * AMUC12 )
      PARAMETER ( EBNDAV = 0.5D+00 * (AMPROT + AMNEUT) - AMUC12 )
*   Gammin : threshold for deexcitation gammas production, set to 1 keV
*   (this means that up to 1 keV of energy unbalancing can occur
*    during an event)
      PARAMETER ( GAMMIN = 1.0D-06 )
      PARAMETER ( GAMNSQ = 2.0D+00 * GAMMIN * GAMMIN )
*   Tvepsi : "epsilon" for excitation energy, set to gammin / 100
      PARAMETER ( TVEPSI = GAMMIN / 100.D+00 )
*
      COMMON /FKNUDA/ AV0WEL,     APFRMX,     AEFRMX,     AEFRMA,
     &                RDSNUC,     V0WELL (2), PFRMMX (2), EFRMMX (2),
     &                EFRMAV (2), AMNUCL (2), AMNUSQ (2), EBNDNG (2),
     &                VEFFNU (2), ESLOPE (2), PKMNNU (2), EKMNNU (2),
     &                PKMXNU (2), EKMXNU (2), EKMNAV (2), EKINAV (2),
     &                EXMNAV (2), EKUPNU (2), EXMNNU (2), EXUPNU (2),
     &                ERCLAV (2), ESWELL (2), FINCUP (2), AMRCAV    ,
     &                AMRCSQ    , ATO1O3    , ZTO1O3    , ELBNDE (0:100)


+KEEP, NUCGEO.
* Revision 1.1.1.1  1995/10/24 10:20:40  cernlib
* Geant
* nucgeo.inc
*=== nucgeo ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     NUClear GEOmetry common:                                         *
*                                                                      *
*     Created on  20  july  1991   by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 24-mar-93     by    Alfredo Ferrari               *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                        BIMSEL                                        *
*                        NUCNUC                                        *
*                        NWISEL                                        *
*                        PHDSET                                        *
*                        PIOABS                                        *
*                        PIONUC                                        *
*                        PRENUC                                        *
*                        PREPRE                                        *
*                        RSTSEL                                        *
*                        SBCOMP                                        *
*                        SIGFER                                        *
*                        UMOFIN                                        *
*                                                                      *
*     Description of the variables (NUCGEO):                           *
*                                                                      *
*                        Radtot = total radius of the nucleus          *
*                        Radiu0 = radius of the nucleus constant       *
*                                 density core                         *
*                        Radiu1 = radius at the nucleus skin depth     *
*                                 end                                  *
*                        Rad1o2 = half density radius of the nucleus   *
*                        Skindp = Skin depth of the nucleus ( where    *
*                                 density decreases linearly with the  *
*                                 radius from rhocen to rhoskn,        *
*                                 Radiu1 = Radiu0 + Skindp and         *
*                                 Rad1o2 = Radiu0 + 1/(2 Omalhl)       *
*                                        x Skindp )                    *
*                                 Rhoskn = Rhocen * Alphal             *
*                        Halodp = Halo depth of the nucleus ( where    *
*                                 density decreases linearly with the  *
*                                 radius from rhoskn to 0,             *
*                                 Radtot = Radiu0 + Skindp + Halodp    *
*                        Alphal = fraction of the central density the  *
*                                 transition from skin to halo occurs  *
*                                 at                                   *
*                        Omalhl = 1 - Alphal                           *
*                        Radskn = Radius at which the density would be *
*                                 zero if the skin depth behaviour is  *
*                                 continued (Radskn = Radiu0 + Skindp  *
*                                 / Omalhl)                            *
*                        Skneff = "effective" skin depth corresponding *
*                                 to Radskn, Skneff = Skindp / Omalhl  *
*                        Radpro = equivalent radius of the projectile  *
*                        Bimptr = "true" impact parameter of the proj- *
*                                 ectile (referred to the centre of    *
*                                 the projectile)                      *
*                        Rimptr = "true" radius of the interaction     *
*                                 point (referred to the centre of     *
*                                 the projectile)                      *
*                    X,Y,Zimptr = "true" position of the interaction   *
*                                 point (referred to the centre of     *
*                                 the projectile)                      *
*                        Rhocen = central density of the nucleus       *
*                        Rhocor = density at the transition point from *
*                                 core to skin                         *
*                        Rhoskn = density at the transition point from *
*                                 skin to halo, Rhoskn = Alphal Rhocen *
*                        Rhoimp = density of the nucleus at the "ef-   *
*                                 fective interaction point"           *
*                        Rhoimt = density of the nucleus at the "true" *
*                                 position of the interaction point    *
*                    Pfr,Ekfcen = Maximum Fermi momentum/energy in the *
*                                 central core                         *
*                    Pfr,Ekfpro = Maximum Fermi momentum/energy at the *
*                                 true interaction point for the proj- *
*                                 ectile (they are computed as for nu- *
*                                 cleons without any reduction factor) *
*                    Pfr,Ekfimp = Maximum Fermi momentum/energy at the *
*                                 "effective" interaction point for    *
*                                 the target nucleon                   *
*                    Pfr,Ekfbim = Maximum Fermi momentum/energy at     *
*                                 r = " effective" impact parameter    *
*                                 (Bimpct) for the nucleon with the    *
*                                 deepest well                         *
*                        Vprwll = well depth for the present projectile*
*                                 at the "true" interaction point      *
*                        Bimpct = "effective" impact parameter of the  *
*                                 projectile (referred to the centre   *
*                                 of the target nucleon)               *
*                        Rimpct = "effective" radius of the interac-   *
*                                 tion point (referred to the centre   *
*                                 of the target nucleon)               *
*                    X,Y,Zimpct = "effective" position of the interac- *
*                                 tion point (referred to the centre   *
*                                 of the target nucleon)               *
*                        Wllred = reduction factor to be applied to    *
*                                 the Ipwell well to get the proper    *
*                                 well for the projectile              *
*                        Clmbbr = Coulomb barrier for the present pro- *
*                                 jectile                              *
*                        Rdclmb = radius corresponding to the Coulomb  *
*                                 barrier at which Coulomb effects are *
*                                 supposed to be overcome by the nuc-  *
*                                 lear potential:                      *
*                                     Rdclmb = Clmbbr / (zZe^2)        *
*                        Bfclmb = correction factor for the impact pa- *
*                                 rameter, for boo such that the actual*
*                                 b =< Rdclmb:                         *
*                                  Bfclmb = sqrt ( 1 - Clmbbr/Ekproj ) *
*                        Bfceff = actual correction factor for the imp-*
*                                 act parameter, b = boo / Bfceff      *
*                                 for boo =< Rdclmb x Bfclmb:          *
*                                        Bfceff = Bfclmb               *
*                                 for boo > Rdclmb x Bfclmb:           *
*                                   Bfceff = 1 / ( x + sqrt (1+x^2) )  *
*                                  x = Clmbbr x Rdclmb / (2 Ekproj boo)*
*                        Ipwell = index of the target nucleon well to  *
*                                 be used in computing the one for the *
*                                 projectile                           *
*                                 ( 1 = proton, 2 = neutron )          *
*                        Itncmx = index of the target nucleon with     *
*                                 largest Fermi momentum               *
*                                 ( 1 = proton, 2 = neutron )          *
*                        Kprin  = particle index of the projectile     *
*                        Ntargt = number of target nucleons (2 at max) *
*                        Knucim = particle index of the target nucleon *
*                                 ( 1 = proton, 8 = neutron )          *
*                        Knuci2 = particle index of the 2nd target     *
*                                 nucleon for absorption on a couple   *
*                                 of nucleons                          *
*                                                                      *
*     Description of the variables (NUCPWI):                           *
*                                                                      *
*                        Almbar = Reduced De Broglie wavelength        *
*                        Bimmax = maximum impact parameter (at oo from *
*                                 the nucleus)                         *
*                        Siggeo = Geometrical cross section summed     *
*                                 over all partial waves (assuming     *
*                                 opacity=1 for any l)                 *
*                                 Siggeo = pi ( Almbar(lmax+1) )^2     *
*                        Lllmax = highest partial wave, it corresponds *
*                                 to: Almbar Lllmax >= Bimmax, where   *
*                                 the >= means that the smallest       *
*                                 integer >= Bimmax / Almbar is used   *
*                        Lllact = partial wave index of the present    *
*                                 interaction                          *
*                                                                      *
*----------------------------------------------------------------------*
      PARAMETER ( PI    = 3.14159265358979322702D+00 )
      PARAMETER ( PISQ  = 9.86960440108935854694D+00 )
      PARAMETER ( SQRT12 = 3.464101615137755D+00  )
*  This is log(11)/(4log(3)), it is ok for alphal = 0.1, bethal = 0.01 )
      PARAMETER ( SKTOHL = 0.5456645846610345D+00 )
*  This is log(99/19)/(4log(3)), it is ok for alphal = 0.05,
*  bethal = 0.01 )
*     PARAMETER ( SKTOHL = 0.3756286198494407D+00 )
*  This is log(99/4)/(4log(3)), it is ok for alphal = 0.2,
*  bethal = 0.01 )
*     PARAMETER ( SKTOHL = 0.7301997078753058D+00 )
*  This is log(99/4)/(4log(3)), it is ok for alphal = 0.02,
*  bethal = 0.001 )
*     PARAMETER ( SKTOHL = 0.7301997078753058D+00 )
      PARAMETER ( RZNUCL = 1.12        D+00 )
      PARAMETER ( RMSPRO = 0.8         D+00 )
      PARAMETER ( R0PROT = RMSPRO / SQRT12  )
      PARAMETER ( ARHPRO = 1.D+00 / 8.D+00 / PI / R0PROT / R0PROT
     &          / R0PROT )
      PARAMETER ( RLLE04 = RZNUCL )
      PARAMETER ( RLLE16 = RZNUCL )
      PARAMETER ( RLGT16 = RZNUCL )
      PARAMETER ( RCLE04 = 0.75D+00 / PI / RLLE04 / RLLE04 / RLLE04 )
      PARAMETER ( RCLE16 = 0.75D+00 / PI / RLLE16 / RLLE16 / RLLE16 )
      PARAMETER ( RCGT16 = 0.75D+00 / PI / RLGT16 / RLGT16 / RLGT16 )
      PARAMETER ( SKLE04 = 1.4D+00 )
      PARAMETER ( SKLE16 = 1.9D+00 )
      PARAMETER ( SKGT16 = 2.4D+00 )
      PARAMETER ( HLLE04 = SKTOHL * SKLE04 )
      PARAMETER ( HLLE16 = SKTOHL * SKLE16 )
      PARAMETER ( HLGT16 = SKTOHL * SKGT16 )
      PARAMETER ( ALPHA0 = 0.1D+00 )
*2    PARAMETER ( ALPHA0 = 0.05D+00 )
*0    PARAMETER ( ALPHA0 = 0.2D+00 )
*3    PARAMETER ( ALPHA0 = 0.02D+00 )
*4    PARAMETER ( ALPHA0 = 0.25D+00 )
      PARAMETER ( OMALH0 = 1.D+00 - ALPHA0 )
      PARAMETER ( GAMSK0 = 0.9D+00 )
*0    PARAMETER ( GAMSK0 = 0.8D+00 )
*2    PARAMETER ( GAMSK0 = 0.9D+00 )
*3    PARAMETER ( GAMSK0 = 0.9D+00 )
*4    PARAMETER ( GAMSK0 = 0.75D+00 )
      PARAMETER ( OMGAS0 = 1.D+00 - GAMSK0 )
      PARAMETER ( POTME0 = 0.6666666666666667D+00 )
      PARAMETER ( POTBA0 = 1.D+00 )
*  This parameter is the Panofsky ratio
      PARAMETER ( PNFRAT = 1.533D+00 )
*  This parameter set the branching ratio for radiative pi- capture
*  at rest in complex nuclei (it is a bit larger than the experimental
*  one to compensate for Pauli blocking etc etc ). This value is
*  for A=oo
      PARAMETER ( RADPIM = 0.035D+00 )
      PARAMETER ( RDPMHL = 14.D+00   )
*  Probability for pi- absorption to have a second proton in the couple
*  of nucleons ( the first one must be a proton )
      PARAMETER ( APMRST = 4.D+00 / 44.D+00 )
*  Probability for pi- absorption to have a second proton in the couple
*  of nucleons ( the first one must be a proton )
      PARAMETER ( APMPRO = 1.D+00 / 6.D+00 )
*  Probability for pi+ absorption to have a proton in the couple
*  of nucleons ( the first one must be a neutron )
      PARAMETER ( APPPRO = 1.D+00 / 6.D+00 )
*  Probability for pi0 absorption to have a p in the couple
*  as first particle
      PARAMETER ( AP0PFS = 0.5D+00 )
*  Probability for pi0 absorption to have a p in the couple
*  as second particle for a p first particle
      PARAMETER ( AP0PFP = 1.D+00 / 3.D+00 )
*  Probability for pi0 absorption to have a p in the couple
*  as second particle for a n first particle
      PARAMETER ( AP0NFP = 2.D+00 / 3.D+00 )
      PARAMETER ( MXSCIN = 50     )
*
      LOGICAL LABRST, LELSTC, LINELS, LCHEXC, LABSRP, LABSTH
*  NUClear Geometry Input data
      COMMON / FKNUGI / RHOTAB (2:260), RHATAB (2:260), ALPTAB (2:260),
     &                  RADTAB (2:260), SKITAB (2:260), HALTAB (2:260),
     &                  SK3TAB (2:260), SK4TAB (2:260), HABTAB (2:260),
     &                  CWSTAB (2:260), EKATAB (2:260), PFATAB (2:260),
     &                  PFRTAB (2:260)
*  NUClear GEOmetry
      COMMON / FKNUGE / RADTOT, RADIU1, RADIU0, RAD1O2, SKINDP, HALODP,
     &                  ALPHAL, OMALHL, RADSKN, SKNEFF, CPARWS, RADPRO,
     &                  RADCOR, RADCO2, RADMAX, BIMPTR, RIMPTR, XIMPTR,
     &                  YIMPTR, ZIMPTR, RHOIMT, EKFPRO, PFRPRO, RHOCEN,
     &                  RHOCOR, RHOSKN, EKFCEN (2), PFRCEN (2), EKFBIM,
     &                  PFRBIM, RHOIMP, EKFIMP, PFRIMP, EKFIM2, PFRIM2,
     &                  VPRWLL, RIMPCT, BIMPCT, XIMPCT, YIMPCT, ZIMPCT,
     &                  XBIMPC, YBIMPC, ZBIMPC, CXIMPC, CYIMPC, CZIMPC,
     &                  SQRIMP, SIGMAP, SIGMAN, SIGMAA, RHORED, R0TRAJ,
     &                  R1TRAJ, SBUSED, SBTOT , SBRES , RHOAVE, EKFAVE,
     &                  PFRAVE, AVEBIN, ACOLL , ZCOLL , RADSIG, OPACTY,
     &                  EKECON, PNUCCO, EKEWLL, PPRWLL, PXPROJ, PYPROJ,
     &                  PZPROJ, EKFERM, PNFRMI, PXFERM, PYFERM, PZFERM,
     &                  EKFER2, PNFRM2, PXFER2, PYFER2, PZFER2, EKFER3
      COMMON / FKNUGE /
     &                  PNFRM3, PXFER3, PYFER3, PZFER3, RHOMEM, EKFMEM,
     &                  BIMMEM, WLLRED, VPRBIM, POTINC, POTOUT, EEXMIN,
     &                  EEXDEL, EEXANY, CLMBBR, RDCLMB, BFCLMB, BFCEFF,
     &                  BNPROJ, BNDNUC, DEBRLM, SK4PAR, UBIMPC, VBIMPC,
     &                  WBIMPC, BNDPOT, SIGMAT, WLLRES, POTBAR, POTMES,
     &                  HHLP   (2), FORTOT (2), BNENRG (3), DEFNUC (2),
     &                  SIGMPR (3), SIGMNU (3), SIGMAB (3), IPWELL,
     &                  ITNCMX, KPRIN , NTARGT, KNUCIM, KNUCI2, KNUCI3,
     &                  IEVPRE, ISFCOL
*  NUClear Partial Waves Informations
      COMMON / FKNUPW / ALMBAR, BIMMAX, SIGGEO, LLLMAX, LLLACT
*  NUClear Geometry Interaction Informations
      COMMON / FKNUII / HOLEXP (MXSCIN), XEXPIN (MXSCIN),
     &                  YEXPIN (MXSCIN), ZEXPIN (MXSCIN),
     &                  RHOEXP, EKFEXP, EHLFIX,
     &                  NHLEXP, NHLFIX, IPRTYP, ISCTYP (MXSCIN),
     &                  NUSCIN, NEXPEM, LABRST, LELSTC, LINELS, LCHEXC,
     &                  LABSRP, LABSTH
      DIMENSION AWSTAB (2:260)
      EQUIVALENCE ( DEFPRO, DEFNUC (1) )
      EQUIVALENCE ( DEFNEU, DEFNUC (2) )
      EQUIVALENCE ( OMALHL, SK3PAR )
      EQUIVALENCE ( ALPHAL, HABPAR )
      EQUIVALENCE ( ALPTAB (2), AWSTAB (2) )
      EQUIVALENCE ( SIGMPE, SIGMPR (1) )
      EQUIVALENCE ( SIGMPC, SIGMPR (2) )
      EQUIVALENCE ( SIGMPI, SIGMPR (3) )
      EQUIVALENCE ( SIGMNE, SIGMNU (1) )
      EQUIVALENCE ( SIGMNC, SIGMNU (2) )
      EQUIVALENCE ( SIGMNI, SIGMNU (3) )
      EQUIVALENCE ( SIGMA2, SIGMAB (1) )
      EQUIVALENCE ( SIGMA3, SIGMAB (2) )
      EQUIVALENCE ( SIGMAS, SIGMAB (3) )


+KEEP, NUCIOD.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* *** Used in /NUCIO under control of PATCHY flag "SINGLE"
* nuciod.inc
      DOUBLE PRECISION TECM,AMASS,PCM,WGT
C

+KEEP, NUCLEV.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* nuclev.inc
*=== nuclev ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     NUClear LEVel common:                                            *
*                                                                      *
*     Created on  10 january 1992  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 26-mar-93     by    Alfredo Ferrari               *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                        BERTTP                                        *
*                        BIMSEL                                        *
*                        NCLVIN                                        *
*                        NCLVGT                                        *
*                        NCLVST                                        *
*                        NUCNUC                                        *
*                        NWISEL                                        *
*                        PFNCLV                                        *
*                        PIOABS                                        *
*                                                                      *
*     Description of the variables (nuclev):                           *
*                                                                      *
*                   paenuc(k,i) = pairing energies (GeV), for i=1 pro- *
*                                 ton pairing energy for Z=k, for i=2  *
*                                 neutron pairing energy for N=k       *
*                   shenuc(k,i) = shell energies (GeV), for i=1 pro-   *
*                                 ton shell energy for Z=k, for i=2    *
*                                 neutron shell energy for N=k         *
*                     defrmi(i) = level spacing at the Fermi level ac- *
*                                 cording to a Fermi gas               *
*                     defmag(i) = extra energy needed to overcome the  *
*                                 gap between the closed shell and the *
*                                 next level for nuclei with magic     *
*                                 numbers of protons or neutrons       *
*                   cumrad(k,i) = sum for j=1,k of 1 /Rj where Ri is   *
*                                 the maximum radius at which can be   *
*                                 found the jth nucleon of type i      *
*                                 (i=1 proton, i=2 neutron)            *
*                        ruspro = maximum radius at which protons can  *
*                                 still be found                       *
*                        rusneu = maximum radius at which neutrons can *
*                                 still be found                       *
*                        juspro = index for flagging that the jth      *
*                                 proton has been already used if      *
*                                 = inuclv                             *
*                        jusneu = index for flagging that the jth      *
*                                 neutron has been already used if     *
*                                 = inuclv                             *
*                        ntapro = number of protons in the target      *
*                        ntaneu = number of neutrons in the target     *
*                        navpro = number of available proton levels in *
*                                 the target                           *
*                        navneu = number of available neutron levels   *
*                                 in the target                        *
*                        nlspro = number of protons in the last level  *
*                        nlsneu = number of neutrons in the last level *
*                        ncopro = number of protons in the core        *
*                        nconeu = number of neutrons in the core       *
*                        nskpro = number of protons in the skin        *
*                        nskneu = number of neutrons in the skin       *
*                        nhapro = number of protons in the halo        *
*                        nhaneu = number of neutrons in the halo       *
*                        nuspro = number of "used" protons             *
*                        nusneu = number of "used" neutrons            *
*                        jmxpro = index  of the highest energy avai-   *
*                                 lable proton                         *
*                        jmxneu = index  of the highest energy avai-   *
*                                 lable neutron                        *
*                        nprnuc = number of presently used nucleons    *
*                                 (max 2)                              *
*                        iprnuc = type of the presently considered     *
*                                 nucleon                              *
*                        jprnuc = index of the presently considered    *
*                                 nucleon                              *
*                        magnum = magic numbers                        *
*                        magpro = last (possibly not filled) proton    *
*                                 shell                                *
*                        magneu = last (possibly not filled) neutron   *
*                                 shell                                *
*                     mgspro(k) = status of the kth proton shell:      *
*                                 -2 not filled but paired             *
*                                 -1 not filled and unpaired           *
*                                  0 filled (paired of course)         *
*                                 +1 originally  filled but now unpai- *
*                                    red                               *
*                     mgsneu(k) = status of the kth neutron shell      *
*                        inuclv = index of the present event           *
*                                                                      *
*----------------------------------------------------------------------*
*  NUClear LEVel
      COMMON / FKNULE / PAENUC (200,2), SHENUC (200,2), DEFRMI (2),
     &                  DEFMAG (2), ENNCLV (160,2), RANCLV (160,2),
     &                  CUMRAD (0:160,2), RUSNUC (2),
     &                  ENPLVL (114), ENNLVL(164), JUSNUC (160,2),
     &                  NTANUC (2), NAVNUC (2), NLSNUC (2), NCONUC (2),
     &                  NSKNUC (2), NHANUC (2), NUSNUC (2), JMXNUC (2),
     &                  IPRNUC (2), JPRNUC (2), MAGNUM (8), MAGNUC (2),
     &                  MGSNUC (8,2), MGSSNC (25,2), NSBSHL (2),
     &                  NPRNUC, INUCLV
      DIMENSION JUSPRO (160), JUSNEU (160), MGSPRO (8), MGSNEU (8),
     &          MGSSPR (19) , MGSSNE (25)
      EQUIVALENCE ( RUSNUC (1), RUSPRO )
      EQUIVALENCE ( RUSNUC (2), RUSNEU )
      EQUIVALENCE ( JUSNUC (1,1), JUSPRO (1) )
      EQUIVALENCE ( JUSNUC (1,2), JUSNEU (1) )
      EQUIVALENCE ( MGSNUC (1,1), MGSPRO (1) )
      EQUIVALENCE ( MGSNUC (1,2), MGSNEU (1) )
      EQUIVALENCE ( MGSSNC (1,1), MGSSPR (1) )
      EQUIVALENCE ( MGSSNC (1,2), MGSSNE (1) )
      EQUIVALENCE ( NTANUC (1), NTAPRO )
      EQUIVALENCE ( NTANUC (2), NTANEU )
      EQUIVALENCE ( NAVNUC (1), NAVPRO )
      EQUIVALENCE ( NAVNUC (2), NAVNEU )
      EQUIVALENCE ( NLSNUC (1), NLSPRO )
      EQUIVALENCE ( NLSNUC (2), NLSNEU )
      EQUIVALENCE ( NCONUC (1), NCOPRO )
      EQUIVALENCE ( NCONUC (2), NCONEU )
      EQUIVALENCE ( NSKNUC (1), NSKPRO )
      EQUIVALENCE ( NSKNUC (2), NSKNEU )
      EQUIVALENCE ( NHANUC (1), NHAPRO )
      EQUIVALENCE ( NHANUC (2), NHANEU )
      EQUIVALENCE ( NUSNUC (1), NUSPRO )
      EQUIVALENCE ( NUSNUC (2), NUSNEU )
      EQUIVALENCE ( JMXNUC (1), JMXPRO )
      EQUIVALENCE ( JMXNUC (2), JMXNEU )
      EQUIVALENCE ( MAGNUC (1), MAGPRO )
      EQUIVALENCE ( MAGNUC (2), MAGNEU )


+KEEP, NUCPAR.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* nucpar.inc
*=== nucpar ===========================================================*
*----------------------------------------------------------------------*
*     Created on 6-9-89 by A. Ferrari                                  *
*                       included in:                                   *
*                                    nucevt                            *
*                                    evxtes                            *
*                                    distnu                            *
*                                    eventq                            *
*----------------------------------------------------------------------*

      PARAMETER (MXPNUC=600)
      CHARACTER*8 ANNU
      COMMON /FKNUPA/  PXNU(MXPNUC),   PYNU(MXPNUC),   PZNU(MXPNUC),
     &                HEPNU(MXPNUC),   AMNU(MXPNUC),   ANNU(MXPNUC),
     &                ICHNU(MXPNUC), IBARNU(MXPNUC),  NRENU(MXPNUC)



+KEEP, NUCSTF.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* nucstf.inc
*=== nucstf ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     NUClear STatement Functions:                                     *
*                                                                      *
*     Created on  14 january 1992  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 04-feb-92     by    Alfredo Ferrari               *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                        FPFRNC                                        *
*                        FRADNC                                        *
*                        FRHINC                                        *
*                        FRHONC                                        *
*                        SBCOMP                                        *
*                                                                      *
*----------------------------------------------------------------------*
*  NUClear STatement Functions: nucleus with a costant core and
*  linearly decreasing skin and halo
*  rho (r):
*     Statement functions:
      RHCORE (R) = RHOCEN
      RHSKIN (R) = RHOCEN * ( RADSKN - R ) / SKNEFF
      RHHALO (R) = RHOSKN * ( RADTOT - R ) / HALODP
*  other
*     RHCORE (R) = RHOCEN
*  Skin with a linear and a cubic term:
*     RHSKIN (R) = RHOCEN * ( ( RADSKN - R ) / SKNEFF + SK3PAR * ( R
*    &           - CPARWS )**3 )
*  Skin with a linear, a cubic and a quartic term:
*     RHSKIN (R) = RHOCEN * ( ( RADSKN - R ) / SKNEFF
*    &           + ( R - CPARWS )**3 * ( SK3PAR + SK4PAR
*    &           * ( R - CPARWS ) ) )
*     RHHALO (R) = RHOCEN * HABPAR * ( RADTOT - R )**1.5D+00
* / r      2
* | 4 pi r' rho (r') dr':
* / 0
*     Statement functions:
      RICORE (R) = 4.D+00 * PI / 3.D+00 * RHOCEN * R**3
      RISKIN (R) = RICORE (RADIU0) + 4.D+00 * PI / 3.D+00 * RHOCEN
     &           * ( RADSKN / SKNEFF * ( R**3 - RADIU0**3 )
     &           - 0.75D+00 * ( R**4 - RADIU0**4 ) / SKNEFF )
      RIHALO (R) = RISKIN (RADIU1) + 4.D+00 * PI / 3.D+00 * RHOSKN
     &           * ( RADTOT / HALODP * ( R**3 - RADIU1**3 )
     &           - 0.75D+00 * ( R**4 - RADIU1**4 ) / HALODP )
*  Other:
*     RICORE (R) = 4.D+00 * PI / 3.D+00 * RHOCEN * R**3
*  Skin with a linear and a cubic term:
*     RISKIN (R) = RICORE (RADIU0) + 4.D+00 * PI / 3.D+00 * RHOCEN
*    &           * ( ( RADSKN / SKNEFF - CPARWS**3 * SK3PAR )
*    &           * ( R**3 - RADIU0**3 ) - 0.75D+00 * ( 1.D+00 / SKNEFF
*    &           - 3.D+00 * SK3PAR * CPARWS**2 ) * ( R**4 - RADIU0**4 )
*    &           - 1.8D+00 * SK3PAR * CPARWS * ( R**5 - RADIU0**5 )
*    &           + 0.5D+00 * SK3PAR * ( R**6 - RADIU0**6 ) )
*  Skin with a linear, a cubic and a quartic term:
*     RISKIN (R) = RICORE (RADIU0) + 4.D+00 * PI / 3.D+00 * RHOCEN
*    &           * ( ( RADSKN / SKNEFF - CPARWS**3 * ( SK3PAR - CPARWS
*    &           * SK4PAR ) ) * ( R**3 - RADIU0**3 ) - 0.75D+00
*    &           * ( 1.D+00 / SKNEFF - CPARWS**2 * ( 3.D+00 * SK3PAR
*    &           - 4.D+00 * SK4PAR * CPARWS ) ) * ( R**4 - RADIU0**4 )
*    &           - 1.8D+00 * CPARWS * ( SK3PAR - 2.D+00 * SK4PAR
*    &           * CPARWS ) * ( R**5 - RADIU0**5 )
*    &           - ( 2.D+00 * SK4PAR * CPARWS - 0.5D+00 * SK3PAR )
*    &           * ( R**6 - RADIU0**6 ) + 3.D+00 / 7.D+00 * SK4PAR
*    &           * ( R**7 - RADIU0**7 ) )
*     RIHALO (R) = RISKIN (RADIU1) + 8.D+00 * PI * RHOCEN
*    &           * HABPAR * ( ( 0.2D+00 * RADTOT**2 - 2.D+00 / 7.D+00
*    &           * RADTOT * HALODP + HALODP**2 / 9.D+00 )
*    &           * ( SQRT (HALODP) )**5 - ( 0.2D+00 * RADTOT**2
*    &           - 2.D+00 / 7.D+00 * RADTOT * ( RADTOT - R )
*    &           + ( RADTOT - R )**2 / 9.D+00 )
*    &           * ( RADTOT - R )**2.5D+00 )
*  r (rho):
*     Statement functions:
      RACORE (RHO) = RADIU0
      RASKIN (RHO) = RADSKN - SKNEFF * RHO / RHOCEN
      RAHALO (RHO) = RADTOT - HALODP * RHO / RHOSKN
*  p_f (rho,i), i=1 proton, 2 neutron:
*     Statement functions:
      PFCORE (RHO,I) = PFRCEN (I)
      PFSKIN (RHO,I) = PFRCEN (I) * (RHO/RHOCEN)**0.3333333333333333D+00
      PFHALO (RHO,I) = PFRCEN (I) * (RHO/RHOCEN)**0.3333333333333333D+00
*  end NUClear STatement Functions


+KEEP, PAPROP.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* paprop.inc
*=== paprop ===========================================================*
*----------------------------------------------------------------------*
*     include file: paprop copy                   created 26/11/86 by p*
*     changes: on  16 december 1992 by Alfredo Ferrari                 *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /paprop/ contains particle properties                            *
*        btype  = literal name of the particle                         *
*        am     = particle mass in gev                                 *
*        ichrge = electric charge of the particle                      *
*        iscore = explanations for the scored distribution             *
*        genpar = names of the generalized particles                   *
*        ijdisc = list of the particle types to be discarded           *
*        thalf  = half life of the particle in sec                     *
*        biasdc = decay biasing factors                                *
*        biasin = inelastic interaction biasing factors                *
*        lhadro = flag for hadrons                                     *
*        jspinp = particle spin (in units of 1/2)                      *
*        lbsdcy = logical flag for biased decay: if .true. the biasing *
*                 factor is used as an upper limit to the decay length *
*        lprbsd = logical flag for biased decay: if .true. the biasing *
*                 factor is applied only to primaries                  *
*        lprbsi = logical flag for inelastic interaction biasing: if   *
*                 .true. the biasing factor is applied only to prima-  *
*                 ries                                                 *
*                                                                      *
*----------------------------------------------------------------------*
      LOGICAL LHADRO, LBSDCY, LPRBSD, LPRBSI
      CHARACTER*8 BTYPE,GENPAR
      COMMON / FKPAPR / AM  (NALLWP), AMDISC (NALLWP), THALF  (NALLWP),
     &               BIASDC (NALLWP), BIASIN (NALLWP), ICHRGE (NALLWP),
     &               ISCORE     (10), IJDISC (NALLWP), LHADRO (NALLWP),
     &               JSPINP (NALLWP), LBSDCY (NALLWP), LPRBSD, LPRBSI
      COMMON / FKCHPR / BTYPE  (NALLWP), GENPAR (30)


+KEEP, PAPROPT.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* papropt.inc
      DOUBLE PRECISION AM, AMDISC, THALF,BIASDC, BIASIN


+KEEP, PAREVT.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* parevt.inc
*                                                                      *
*=== parevt ===========================================================*
*                                                                      *
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 28-3-90 by A. Ferrari, INFN - Milan                   *
*                                                                      *
*     Last change  on  20 april  1992    by    Alfredo Ferrari         *
*                                                                      *
*           included in:                                               *
*                          fluka                                       *
*                          bdnopt                                      *
*                          corevt                                      *
*                          distnu                                      *
*                          epilog                                      *
*                          eventv                                      *
*                          evevap                                      *
*                          evvini                                      *
*                          evxtes                                      *
*                          ferevv                                      *
*                          kaskad                                      *
*                          incini                                      *
*                          nucevv                                      *
*                          pmprab                                      *
*           and in     :                                               *
*                          prenuc                                      *
*                          umofin                                      *
*                          bimsel                                      *
*                          nucnuc                                      *
*                          nwisel                                      *
*                          pioabs                                      *
*                          prepre                                      *
*                          rstsel                                      *
*                                                                      *
*           frdiff = fraction of the total number of events which are  *
*                    diffractive ones                                  *
*           pthdff = momentum threshold for diffractive events         *
*                    diffractive ones                                  *
*           fsprd0 = asymptotic reduction factor for cascade particle  *
*                    energy slope parameter                            *
*           fshpfn = modifying factor for bamjet momentum sharing jet  *
*                    function                                          *
*           rn1gsc = correlation factor between shower and grey part-  *
*                    ticle multiplicities                              *
*           rn2gsc = correlation factor between shower and grey part-  *
*                    ticle multiplicities                              *
*           dpower = power exponent used in the binomial distributions *
*                    for grey particles                                *
*           lpower = flag to signal if dpower is different from the    *
*                    default option (dpower=2)                         *
*           ldiffr = flag for particles undergoing diffractive events  *
*           linctv = flag to switch on/off cascade nucleons and exci-  *
*                    tation energy (it is important for testing the    *
*                    generator                                         *
*           levprt = flag for nuclear evaporation                      *
*           ldeexg = flag for nuclear deexcitation gammas              *
*           lgdhpr = flag for geometry dependent calculations in the   *
*                    preequilibrium part                               *
*           lpreex = flag for explicit treatment of the first inte-    *
*                    ctions in the preequilibrium part                 *
*           lhlfix = flag for "freezing" the hole depth of the holes   *
*                    produced in the explicitly treated interactions   *
*                    in the preequilibrium part                        *
*           lprfix = flag for "freezing" the already sampled particle  *
*                    exciton energy in the preequilibrium part         *
*           lparwv = flag to apply the Heisenberg principle according  *
*                    to the reduced DeBroglie wavelength in the calcu- *
*                    lation of the impact parameter and in computing   *
*                    the particle position after interactions          *
*           ilvmod = flag to select the level density option           *
*                                                                      *
*----------------------------------------------------------------------*
*  30% of events, randomly choosen, are diffractive events!!
*  Now 20% (J. Ranft & A. Ferrari, 25-3-90)
      PARAMETER ( FRDIFF = 0.2D+00 )
      PARAMETER ( PTHDFF = 8.5D+00 )
      PARAMETER ( ETHSEA = 1.0D+00 )

      LOGICAL LDIFFR, LINCTV, LEVPRT, LHEAVY, LDEEXG, LGDHPR, LPREEX,
     &        LHLFIX, LPRFIX, LPARWV, LPOWER
      COMMON / FKPARE / DPOWER, FSPRD0, FSHPFN, RN1GSC, RN2GSC,
     &                  LDIFFR (39),    LPOWER, LINCTV, LEVPRT, LHEAVY,
     &                  LDEEXG, LGDHPR, LPREEX, LHLFIX, LPRFIX, LPARWV,
     &                  ILVMOD


+KEEP, PARNUC.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* parnuc.inc
*=== parnuc ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on  2 august 1991    by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 25-mar-93     by    Alfredo Ferrari               *
*                                                                      *
*     included in :                                                    *
*                                                                      *
*                   Couset                                             *
*                   Nucnuc                                             *
*                   Nwisel                                             *
*                   Phdset                                             *
*                   Phdwll                                             *
*                   Pioabs                                             *
*                   Pionuc                                             *
*                   Pmprab                                             *
*                   Pncset                                             *
*                   Pncset                                             *
*                   Prenuc                                             *
*                   Prepre                                             *
*                   Sbcomp                                             *
*                   Umofin                                             *
*                                                                      *
*----------------------------------------------------------------------*
      PARAMETER ( PIGRK  = PIPIPI )
      PARAMETER ( ALEVEL = 8.D-03 )
*  Standard parameter for central density: it is exactly r0nucl of
*  Parevt
      PARAMETER ( RCNUCL = 1.12D+00 )
*  "Naive" r0 for sigmas
      PARAMETER ( R0SIG  = 1.3D+00 )
*  r0 for sigmas according to Kikuchi & Kawai
      PARAMETER ( R0SIGK = 1.5D+00 )
*  r0 for Coulomb barrier according to Kikuchi & Kawai
      PARAMETER ( RCOULB = 1.5D+00 )
*  Parameter for Coulomb barrier according to Hermes (Evap-5)
      PARAMETER ( COULBH = 0.88235D-03 )
*  Central density in nuclei
      PARAMETER ( RHONU0 = 0.75D+00 / PIGRK / RCNUCL / RCNUCL / RCNUCL )
*  For Taufor, Aefrav & Rhonuc the combinations 1 and 3 are ok. If the
*  Hannes expression for Taufor is used we must use Taufor from
*  combination 3 and Aefrav and Rhonuc from combination 1
*  Combination 3:
*3    PARAMETER ( TAUFOR = 3.0D+00 )
*  Combination 1:
*     PARAMETER ( TAUFOR = 5.0D+00 )
      PARAMETER ( TAUFOR = 10.0D+00 )
*  Thresholds for explicit interactions:
*    Primary projectile:
      PARAMETER ( EKEEXP = 0.03D+00 )
*    Secondary nucleons:
      PARAMETER ( EKREXP = 0.05D+00 )
*    Just for Pauli checks:
      PARAMETER ( EKEMNM = 0.01D+00 )
*
      PARAMETER ( NCPMX = 50 )
      COMMON / FKPARN / EKORI , PXORI , PYORI , PZORI , PTORI ,
     &                  ENNUC  (NCPMX), PNUCL  (NCPMX), EKFNUC (NCPMX),
     &                  XSTNUC (NCPMX), YSTNUC (NCPMX), ZSTNUC (NCPMX),
     &                  PXNUCL (NCPMX), PYNUCL (NCPMX), PZNUCL (NCPMX),
     &                  RSTNUC (NCPMX), RHNUCL (NCPMX), FREEPA (NCPMX),
     &                  CRRPAN (NCPMX), CRRPAP (NCPMX), BSTNUC (NCPMX),
     &                  WLRNUC (NCPMX), BNDGAV, DEFMIN, KPNUCL (NCPMX),
     &                  KRFNUC (NCPMX), KPORI , IBORI , IBNUCL, NPNUC ,
     &                  INUCTS (NCPMX), NNUCTS, ISFNUC (NCPMX)


+KEEP, PART.
* Revision 1.1.1.1  1995/10/24 10:20:41  cernlib
* Geant
* part.inc
*=== part =============================================================*
*----------------------------------------------------------------------*
*     Include file: part copy         Revised on 20-7-90 by A. Ferrari *
*     Note: see also part2 copy and part3 copy                         *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AM   (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AMDISC (IDMAX8), ICH    (IDMAX8), IBAR   (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)


+KEEP, PART2.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* part2.inc
*=== part2 ============================================================*
*----------------------------------------------------------------------*
*     Include file: part2 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part3 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AAM  (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AAMDSC (IDMAX8), IICH   (IDMAX8), IIBAR  (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)


+KEEP, PART2T.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* part2t.inc
      DOUBLE PRECISION AAM, GA, TAU, AAMDSC


+KEEP, PART3.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* part3.inc
*=== part3 ============================================================*
*----------------------------------------------------------------------*
*     Include file: part3 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part2 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAMC
      COMMON / FKPART / AMC  (IDMAX8), GAC    (IDMAX8), TAUC   (IDMAX8),
     &                AMCDSC (IDMAX8), ICHC   (IDMAX8), IBARC  (IDMAX8),
     &                K1C    (IDMAX8), K2C    (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAMC (IDMAX8)


+KEEP, PARTT.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* partt.inc
      DOUBLE PRECISION AM, GA, TAU, AMDISC


+KEEP, PAWC, IF=-INCLUDE, IF=TYPE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* pawc.inc
+CDE, PAWCT.
      COMMON /PAWC/ NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKUIP,IFENCE(5),
     +              LLMAIN, WWS(9989)
      DIMENSION IQQ(2),QQ(2),LQQ(8000)
      EQUIVALENCE (QQ(1),IQQ(1),LQQ(9)),(LQQ(1),LLMAIN)
C
*
* pawc.inc
*

+KEEP, PAWC, IF=-INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* pawc.inc
      COMMON /PAWC/ NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKUIP,IFENCE(5),
     +              LLMAIN, WWS(9989)
      DIMENSION IQQ(2),QQ(2),LQQ(8000)
      EQUIVALENCE (QQ(1),IQQ(1),LQQ(9)),(LQQ(1),LLMAIN)
C
*
* pawc.inc
*

+KEEP, PAWC, IF=INCLUDE.
* Revision 1.1.1.1  1995/10/24 10:20:35  cernlib
* Geant
* pawc.inc
*
* pawc.inc
*
*
+CDE, INCBEG.
     +   pawc
+CDE, INCEND.

+KEEP, PCODAT.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* pcodat.inc
C --- DATA STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DATA KIPART/
     $               1,   3,   4,   2,   5,   6,   8,   7,
     $               9,  12,  10,  13,  16,  14,  15,  11,
     $              35,  18,  20,  21,  22,  26,  27,  33,
     $              17,  19,  23,  24,  25,  28,  29,  34,
     $              35,  35,  35,  35,  35,  35,  35,  35,
     $              35,  35,  35,  35,  30,  31,  32,  35/
C
      DATA IKPART/
     $               1,   4,   2,   3,   5,   6,   8,   7,
     $               9,  11,  16,  10,  12,  14,  15,  13,
     $              25,  18,  26,  19,  20,  21,  27,  28,
     $              29,  22,  23,  30,  31,  45,  46,  47,
     $              24,  32,  48/
C

+KEEP, PCODIM.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* pcodim.inc
C --- DIMENSION STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DIMENSION KIPART(48),IKPART(35)
C

+KEEP, QQUARK.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* qquark.inc
*=== qquark ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on    6 february 1991    by        Alfredo Ferrari       *
*                                                  INFN - Milan        *
*                                                                      *
*     Last change  on  6 february 1991  by       Alfredo Ferrari       *
*                                                                      *
*     Included in the following routines :                             *
*                                                                      *
*                     COREVT                                           *
*                     CORRIN                                           *
*                     HADEVV                                           *
*                     HADEVT                                           *
*                     NUCEVV                                           *
*                     NUCEVT                                           *
*                                                                      *
*     Quark content of particles:                                      *
*          index   quark   el. charge  bar. charge  isospin  isospin3  *
*              1 = u          2/3          1/3        1/2       1/2    *
*             -1 = ubar      -2/3         -1/3        1/2      -1/2    *
*              2 = d         -1/3          1/3        1/2      -1/2    *
*             -2 = dbar       1/3         -1/3        1/2       1/2    *
*              3 = s         -1/3          1/3         0         0     *
*             -3 = sbar       1/3         -1/3         0         0     *
*              4 = c          2/3          1/3         0         0     *
*             -4 = cbar      -2/3         -1/3         0         0     *
*              5 = b         -1/3          1/3         0         0     *
*             -5 = bbar       1/3         -1/3         0         0     *
*              6 = t          2/3          1/3         0         0     *
*             -6 = tbar      -2/3         -1/3         0         0     *
*                                                                      *
*         Mquark = particle quark composition (Paprop numbering)       *
*         Iqechr = electric charge ( in 1/3 unit )                     *
*         Iqbchr = baryonic charge ( in 1/3 unit )                     *
*         Iqichr = isospin ( in 1/2 unit ), z component                *
*         Iqschr = strangeness                                         *
*         Iqcchr = charm                                               *
*         Iquchr = beauty                                              *
*         Iqtchr = ......                                              *
*                                                                      *
*----------------------------------------------------------------------*
      COMMON / FKQUAR / IQECHR (-6:6), IQBCHR (-6:6), IQICHR (-6:6),
     &                  IQSCHR (-6:6), IQCCHR (-6:6), IQUCHR (-6:6),
     &                  IQTCHR (-6:6), MQUARK (3,39)


+KEEP, REAC.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* reac.inc
*=== reac =============================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 10 december 1991  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 10-dec-91     by    Alfredo Ferrari               *
*                                                                      *
*     This is the original common reac of Hadrin                       *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                CALUMV                                                *
*                DATESH                                                *
*                HADRIV                                                *
*                RCHANV                                                *
*                BLKDT3                                                *
*                HADRIN                                                *
*                IEFUN                                                 *
*                SIGINT                                                *
*                CALUMO                                                *
*                RCHANW                                                *
*                                                                      *
*----------------------------------------------------------------------*
      COMMON /FKREAC/ UMO   ( 296), PLABF ( 296), SIIN  ( 296),
     +              WK    (5184), NRK  (2,268), NURE  (30,2)


+KEEP, REDVER.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* redver.inc
*=== redver ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 10 december 1991  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 10-dec-91     by    Alfredo Ferrari               *
*                                                                      *
*     This is the original common redver of Hadrin                     *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                CALUMV                                                *
*                DATESH                                                *
*                HADRIV                                                *
*                RCHANV                                                *
*                BLKDT4                                                *
*                HADRIN                                                *
*                IEFUN                                                 *
*                SIGINT                                                *
*                CALUMO                                                *
*                RCHANW                                                *
*                                                                      *
*----------------------------------------------------------------------*
      COMMON / FKREDV / THRESH (268), IRII (17) , IKII (17) , IEII (17)


+KEEP, RESNUC.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* resnuc.inc
*                                                                     *
*=== resnuc ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*     Include file Resnuc                                             *
*                                                                     *
*     Created on 20 april 1990  by            Alfredo Ferrari         *
*                                               INFN Milan            *
*                                                                     *
*     Last change on  9  march  1993                                  *
*                                                                     *
*     Included in the following routines:                             *
*                                                                     *
*            BDNOPT                                                   *
*            COREVT                                                   *
*            CORRIN                                                   *
*            DISTNU                                                   *
*            DRES                                                     *
*            EVDEEX                                                   *
*            EVENTQ                                                   *
*            EVENTV                                                   *
*            EVEVAP                                                   *
*            FEREVV                                                   *
*            FERHAV                                                   *
*            LOWRES                                                   *
*            NUCEVT                                                   *
*            NUCEVV                                                   *
*            NUCRIN                                                   *
*            NUCRIV                                                   *
*                                                                     *
*---------------------------------------------------------------------*
      LOGICAL LRNFSS
      COMMON /FKRESN/  AMNTAR, AMMTAR, AMNZM1, AMMZM1, AMNNM1, AMMNM1,
     &                   ANOW,   ZNOW, ANCOLL, ZNCOLL,   ERES,  EKRES,
     &                 AMNRES, AMMRES,  PTRES,  PXRES,  PYRES,  PZRES,
     &                 PTRES2,  KTARP,  KTARN, IGREYP, IGREYN,  ICRES,
     &                  IBRES, IEVAPL, IEVAPH, IEVNEU, IEVPRO, IEVDEU,
     &                 IEVTRI, IEV3HE, IEV4HE, IDEEXG,  IBTAR, ICHTAR,
     &                 IOTHER, LRNFSS


+KEEP, S_BLANK.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
*        *** NVE 09-FEB-1988 ***
* s_blank.inc
      PARAMETER (MXGKPV=MXGKGH)
      COMMON /VECUTY/ PV(10,MXGKPV)
C

+KEEP, S_BLANKP.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
*       *** NVE 09-FEB-1988 ***
* s_blankp.inc
      PARAMETER (MXGKPV=MXGKGH)
      COMMON /VECUTY/ PV(10,MXGKPV)
C

+KEEP, S_CONSTS.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* s_consts.inc
      COMMON/CONSTS/ PI,TWPI,PIBTW,MP,MPI,MMU,MEL,MKCH,MK0,SMP,SMPI,
     $               SMU,CT,CTKCH,CTK0,
     $               ML0,MSP,MS0,MSM,MX0,MXM,CTL0,CTSP,CTSM,CTX0,CTXM,
     $               RMASS(35),RCHARG(35)
C
                     REAL MP,MPI,MMU,MEL,MKCH,MK0,
     *                    ML0,MSP,MS0,MSM,MX0,MXM
C

+KEEP, S_COSCOM.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* s_coscom.inc
      COMMON/COSCOM/AA,BB,CC,DD,RR
C

+KEEP, S_CSDAT.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* s_csdat.inc
C --- CROSS-SECTION DATA BY "PCSDAT" 01-FEB-1989 ---
C
      DATA PLAB /
     $  0.00000E+00, 0.10000    , 0.15000    , 0.20000    , 0.25000    ,
     $  0.30000    , 0.35000    , 0.40000    , 0.45000    , 0.50000    ,
     $  0.55000    , 0.60000    , 0.65000    , 0.70000    , 0.75000    ,
     $  0.80000    , 0.85000    , 0.90000    , 0.95000    ,  1.0000    ,
     $   1.1000    ,  1.2000    ,  1.3000    ,  1.4000    ,  1.5000    ,
     $   1.6000    ,  1.8000    ,  2.0000    ,  2.2000    ,  2.4000    ,
     $   2.6000    ,  2.8000    ,  3.0000    ,  4.0000    ,  5.0000    ,
     $   6.0000    ,  8.0000    ,  10.000    ,  20.000    ,  100.00    ,
     $   1000.0    /
      DATA (CSEL( 1,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL( 2,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL( 3,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL( 4,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL( 5,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL( 6,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL( 7,J),J=1,41) /
     $  0.00000E+00,  6.0000    ,  20.000    ,  71.000    ,  155.00    ,
     $   195.00    ,  130.00    ,  78.000    ,  60.000    ,  32.000    ,
     $   23.500    ,  18.500    ,  15.000    ,  12.500    ,  10.000    ,
     $   9.1000    ,  8.6000    ,  8.8000    ,  9.5000    ,  10.600    ,
     $   13.000    ,  15.500    ,  17.100    ,  17.200    ,  16.200    ,
     $   15.000    ,  12.300    ,  10.200    ,  9.0000    ,  8.0000    ,
     $   7.3000    ,  6.8000    ,  6.5000    ,  5.8000    ,  5.4000    ,
     $   5.2000    ,  5.0000    ,  4.9000    ,  3.8000    ,  3.2000    ,
     $   3.5000    /
      DATA (CSEL( 8,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL( 9,J),J=1,41) /
     $  0.00000E+00,  1.0000    ,  3.0000    ,  8.0000    ,  18.000    ,
     $   25.000    ,  27.500    ,  12.300    ,  10.600    ,  11.000    ,
     $   12.500    ,  14.500    ,  17.000    ,  19.400    ,  19.800    ,
     $   16.800    ,  14.000    ,  14.800    ,  20.000    ,  26.100    ,
     $   19.500    ,  15.000    ,  12.800    ,  11.500    ,  10.500    ,
     $   9.8000    ,  8.8000    ,  8.2000    ,  7.8000    ,  7.5000    ,
     $   7.2000    ,  7.0000    ,  6.8000    ,  6.1000    ,  5.7000    ,
     $   5.4000    ,  4.9000    ,  4.6000    ,  4.0000    ,  3.3000    ,
     $   3.5000    /
      DATA (CSEL(10,J),J=1,41) /
     $   10.000    ,  11.200    ,  11.300    ,  11.400    ,  11.500    ,
     $   11.600    ,  11.800    ,  12.000    ,  12.100    ,  12.200    ,
     $   12.300    ,  12.400    ,  12.500    ,  12.500    ,  12.500    ,
     $   12.400    ,  12.300    ,  12.200    ,  12.000    ,  11.800    ,
     $   11.200    ,  11.500    ,  9.9000    ,  9.4000    ,  8.8000    ,
     $   8.4000    ,  7.5000    ,  6.9000    ,  6.3000    ,  5.9000    ,
     $   5.5000    ,  5.2000    ,  5.0000    ,  4.0000    ,  3.5000    ,
     $   3.3000    ,  3.1000    ,  3.1000    ,  3.0000    ,  2.5000    ,
     $   3.0000    /
      DATA (CSEL(11,J),J=1,41) /
     $   10.000    ,  11.200    ,  11.300    ,  11.400    ,  11.500    ,
     $   11.600    ,  11.800    ,  12.000    ,  12.100    ,  12.200    ,
     $   12.300    ,  12.400    ,  12.500    ,  12.500    ,  12.500    ,
     $   12.400    ,  12.300    ,  12.200    ,  12.000    ,  11.800    ,
     $   11.200    ,  11.500    ,  9.9000    ,  9.4000    ,  8.8000    ,
     $   8.4000    ,  7.5000    ,  6.9000    ,  6.3000    ,  5.9000    ,
     $   5.5000    ,  5.2000    ,  5.0000    ,  4.0000    ,  3.5000    ,
     $   3.3000    ,  3.1000    ,  3.1000    ,  3.0000    ,  2.5000    ,
     $   3.0000    /
      DATA (CSEL(12,J),J=1,41) /
     $   160.83    ,  82.800    ,  58.575    ,  43.683    ,  34.792    ,
     $   28.650    ,  24.367    ,  20.917    ,  18.192    ,  16.300    ,
     $   14.608    ,  13.017    ,  12.250    ,  11.700    ,  12.017    ,
     $   14.075    ,  15.842    ,  16.433    ,  16.042    ,  15.008    ,
     $   12.575    ,  10.708    ,  9.2000    ,  8.0167    ,  7.2833    ,
     $   7.0750    ,  6.6333    ,  6.1250    ,  5.6583    ,  5.2750    ,
     $   4.9333    ,  4.6250    ,  4.4583    ,  3.7333    ,  3.3833    ,
     $   3.1833    ,  2.9833    ,  2.7500    ,  2.3667    ,  2.2000    ,
     $   2.6000    /
      DATA (CSEL(13,J),J=1,41) /
     $   300.00    ,  140.00    ,  97.000    ,  70.000    ,  55.000    ,
     $   45.000    ,  37.000    ,  31.000    ,  26.000    ,  23.000    ,
     $   20.000    ,  17.000    ,  15.500    ,  14.500    ,  14.700    ,
     $   18.500    ,  22.000    ,  23.000    ,  22.500    ,  20.700    ,
     $   16.500    ,  14.000    ,  11.500    ,  9.6000    ,  8.6000    ,
     $   8.5000    ,  8.3000    ,  7.6000    ,  7.0000    ,  6.4000    ,
     $   5.9000    ,  5.5000    ,  5.3000    ,  4.4000    ,  4.1000    ,
     $   3.9000    ,  3.7000    ,  3.3000    ,  2.6000    ,  2.5000    ,
     $   3.0000    /
      DATA (CSEL(14,J),J=1,41) /
     $   1100.0    ,  115.00    ,  105.00    ,  100.00    ,  56.000    ,
     $   40.000    ,  27.000    ,  22.000    ,  21.000    ,  20.000    ,
     $   20.000    ,  20.000    ,  20.500    ,  21.000    ,  22.000    ,
     $   23.000    ,  24.000    ,  24.000    ,  24.400    ,  24.500    ,
     $   25.000    ,  25.500    ,  26.000    ,  26.500    ,  27.000    ,
     $   27.000    ,  26.000    ,  23.000    ,  21.500    ,  20.000    ,
     $   19.000    ,  18.000    ,  17.000    ,  13.000    ,  11.500    ,
     $   10.300    ,  9.4000    ,  9.0000    ,  8.8000    ,  7.0000    ,
     $   7.5000    /
      DATA (CSEL(15,J),J=1,41) /
     $   200.00    ,  163.00    ,  141.00    ,  120.00    ,  111.00    ,
     $   99.500    ,  92.500    ,  86.500    ,  82.000    ,  78.000    ,
     $   74.000    ,  71.000    ,  67.500    ,  65.000    ,  62.500    ,
     $   59.700    ,  58.100    ,  56.300    ,  54.700    ,  52.700    ,
     $   50.000    ,  48.400    ,  47.000    ,  46.000    ,  45.200    ,
     $   42.800    ,  39.200    ,  36.300    ,  32.800    ,  30.400    ,
     $   28.100    ,  26.300    ,  24.500    ,  19.250    ,  16.840    ,
     $   14.600    ,  12.340    ,  11.210    ,  8.8500    ,  7.5000    ,
     $   7.5000    /
      DATA (CSEL(16,J),J=1,41) /
     $   4200.0    ,  440.00    ,  420.00    ,  400.00    ,  230.00    ,
     $   160.00    ,  105.00    ,  80.000    ,  62.000    ,  50.000    ,
     $   45.000    ,  41.000    ,  38.000    ,  36.000    ,  35.000    ,
     $   34.000    ,  33.000    ,  32.000    ,  31.500    ,  31.000    ,
     $   30.500    ,  30.000    ,  29.500    ,  29.000    ,  28.500    ,
     $   28.000    ,  26.000    ,  23.000    ,  21.500    ,  20.000    ,
     $   19.000    ,  18.000    ,  17.000    ,  13.000    ,  11.500    ,
     $   10.300    ,  9.4000    ,  9.0000    ,  8.8000    ,  7.0000    ,
     $   7.5000    /
      DATA (CSEL(17,J),J=1,41) /
     $   185.88    ,  133.23    ,  119.37    ,  102.86    ,  93.102    ,
     $   82.752    ,  76.205    ,  71.008    ,  67.366    ,  64.096    ,
     $   60.891    ,  58.501    ,  55.735    ,  53.773    ,  51.839    ,
     $   49.671    ,  48.485    ,  47.045    ,  45.803    ,  44.306    ,
     $   42.623    ,  41.786    ,  41.115    ,  40.630    ,  40.129    ,
     $   38.242    ,  35.233    ,  32.662    ,  29.639    ,  27.573    ,
     $   25.536    ,  23.948    ,  22.356    ,  17.723    ,  15.614    ,
     $   13.653    ,  11.675    ,  10.653    ,  8.6198    ,  7.4464    ,
     $   7.4821    /
      DATA (CSEL(18,J),J=1,41) /
     $   1100.0    ,  115.00    ,  105.00    ,  100.00    ,  56.000    ,
     $   40.000    ,  27.000    ,  22.000    ,  21.000    ,  20.000    ,
     $   20.000    ,  19.067    ,  19.333    ,  19.500    ,  19.833    ,
     $   20.567    ,  21.800    ,  22.900    ,  23.869    ,  23.809    ,
     $   22.161    ,  21.488    ,  19.732    ,  19.433    ,  19.345    ,
     $   19.029    ,  18.121    ,  16.280    ,  15.258    ,  14.280    ,
     $   13.644    ,  12.963    ,  12.316    ,  9.5333    ,  8.4333    ,
     $   7.5728    ,  6.9696    ,  6.7518    ,  6.6175    ,  5.6000    ,
     $   6.1145    /
      DATA (CSEL(19,J),J=1,41) /
     $   157.65    ,  73.701    ,  76.096    ,  68.571    ,  57.305    ,
     $   49.257    ,  43.616    ,  40.024    ,  38.098    ,  36.287    ,
     $   34.674    ,  33.105    ,  31.712    ,  30.685    ,  29.613    ,
     $   28.602    ,  28.336    ,  28.075    ,  27.786    ,  27.215    ,
     $   26.380    ,  26.146    ,  25.108    ,  24.783    ,  24.360    ,
     $   23.219    ,  21.431    ,  20.095    ,  18.382    ,  17.267    ,
     $   16.100    ,  15.175    ,  14.271    ,  11.573    ,  10.305    ,
     $   9.1471    ,  8.0149    ,  7.4349    ,  6.2499    ,  5.8928    ,
     $   6.0774    /
      DATA (CSEL(20,J),J=1,41) /
     $   1100.0    ,  115.00    ,  105.00    ,  100.00    ,  56.000    ,
     $   40.000    ,  27.000    ,  22.000    ,  21.000    ,  20.000    ,
     $   20.000    ,  19.067    ,  19.333    ,  19.500    ,  19.833    ,
     $   20.567    ,  21.800    ,  22.900    ,  23.869    ,  23.809    ,
     $   22.161    ,  21.488    ,  19.732    ,  19.433    ,  19.345    ,
     $   19.029    ,  18.121    ,  16.280    ,  15.258    ,  14.280    ,
     $   13.644    ,  12.963    ,  12.316    ,  9.5333    ,  8.4333    ,
     $   7.5728    ,  6.9696    ,  6.7518    ,  6.6175    ,  5.6000    ,
     $   6.1145    /
      DATA (CSEL(21,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL(22,J),J=1,41) /
     $   1100.0    ,  115.00    ,  105.00    ,  100.00    ,  56.000    ,
     $   40.000    ,  27.000    ,  22.000    ,  21.000    ,  20.000    ,
     $   20.000    ,  19.067    ,  19.333    ,  19.500    ,  19.833    ,
     $   20.567    ,  21.800    ,  22.900    ,  23.869    ,  23.809    ,
     $   22.161    ,  21.488    ,  19.732    ,  19.433    ,  19.345    ,
     $   19.029    ,  18.121    ,  16.280    ,  15.258    ,  14.280    ,
     $   13.644    ,  12.963    ,  12.316    ,  9.5333    ,  8.4333    ,
     $   7.5728    ,  6.9696    ,  6.7518    ,  6.6175    ,  5.6000    ,
     $   6.1145    /
      DATA (CSEL(23,J),J=1,41) /
     $   185.88    ,  133.23    ,  119.37    ,  102.86    ,  93.102    ,
     $   82.752    ,  76.205    ,  71.008    ,  67.366    ,  64.096    ,
     $   60.891    ,  58.104    ,  55.241    ,  53.140    ,  50.934    ,
     $   48.660    ,  47.566    ,  46.585    ,  45.581    ,  44.003    ,
     $   41.134    ,  39.374    ,  36.878    ,  35.523    ,  34.503    ,
     $   32.334    ,  29.365    ,  27.370    ,  24.705    ,  22.921    ,
     $   21.229    ,  19.879    ,  18.559    ,  14.625    ,  12.758    ,
     $   11.041    ,  9.3440    ,  8.5484    ,  6.7104    ,  6.0000    ,
     $   6.1131    /
      DATA (CSEL(24,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL(25,J),J=1,41) /
     $   157.65    ,  73.701    ,  76.096    ,  68.571    ,  57.305    ,
     $   49.257    ,  43.616    ,  40.024    ,  38.098    ,  36.287    ,
     $   34.674    ,  33.105    ,  31.712    ,  30.685    ,  29.613    ,
     $   28.602    ,  28.336    ,  28.075    ,  27.786    ,  27.215    ,
     $   26.380    ,  26.146    ,  25.108    ,  24.783    ,  24.360    ,
     $   23.219    ,  21.431    ,  20.095    ,  18.382    ,  17.267    ,
     $   16.100    ,  15.175    ,  14.271    ,  11.573    ,  10.305    ,
     $   9.1471    ,  8.0149    ,  7.4349    ,  6.2499    ,  5.8928    ,
     $   6.0774    /
      DATA (CSEL(26,J),J=1,41) /
     $   1100.0    ,  115.00    ,  105.00    ,  100.00    ,  56.000    ,
     $   40.000    ,  27.000    ,  22.000    ,  21.000    ,  20.000    ,
     $   20.000    ,  18.133    ,  18.167    ,  18.000    ,  17.667    ,
     $   18.133    ,  19.600    ,  21.800    ,  23.338    ,  23.118    ,
     $   19.323    ,  17.476    ,  13.464    ,  12.367    ,  11.691    ,
     $   11.057    ,  10.242    ,  9.5593    ,  9.0151    ,  8.5591    ,
     $   8.2884    ,  7.9253    ,  7.6311    ,  6.0667    ,  5.3667    ,
     $   4.8456    ,  4.5392    ,  4.5036    ,  4.4351    ,  4.2000    ,
     $   4.7289    /
      DATA (CSEL(27,J),J=1,41) /
     $   1100.0    ,  115.00    ,  105.00    ,  100.00    ,  56.000    ,
     $   40.000    ,  27.000    ,  22.000    ,  21.000    ,  20.000    ,
     $   20.000    ,  18.133    ,  18.167    ,  18.000    ,  17.667    ,
     $   18.133    ,  19.600    ,  21.800    ,  23.338    ,  23.118    ,
     $   19.323    ,  17.476    ,  13.464    ,  12.367    ,  11.691    ,
     $   11.057    ,  10.242    ,  9.5593    ,  9.0151    ,  8.5591    ,
     $   8.2884    ,  7.9253    ,  7.6311    ,  6.0667    ,  5.3667    ,
     $   4.8456    ,  4.5392    ,  4.5036    ,  4.4351    ,  4.2000    ,
     $   4.7289    /
      DATA (CSEL(28,J),J=1,41) /
     $   157.65    ,  73.701    ,  76.096    ,  68.571    ,  57.305    ,
     $   49.257    ,  43.616    ,  40.024    ,  38.098    ,  36.287    ,
     $   34.674    ,  32.708    ,  31.218    ,  30.052    ,  28.707    ,
     $   27.591    ,  27.417    ,  27.615    ,  27.564    ,  26.913    ,
     $   24.891    ,  23.734    ,  20.871    ,  19.677    ,  18.734    ,
     $   17.311    ,  15.563    ,  14.803    ,  13.448    ,  12.615    ,
     $   11.794    ,  11.106    ,  10.474    ,  8.4745    ,  7.4498    ,
     $   6.5350    ,  5.6835    ,  5.3300    ,  4.3406    ,  4.4464    ,
     $   4.7083    /
      DATA (CSEL(29,J),J=1,41) /
     $   143.53    ,  43.935    ,  54.462    ,  51.429    ,  39.407    ,
     $   32.510    ,  27.321    ,  24.532    ,  23.465    ,  22.383    ,
     $   21.566    ,  20.209    ,  19.453    ,  18.825    ,  18.046    ,
     $   17.562    ,  17.802    ,  18.360    ,  18.667    ,  18.519    ,
     $   17.514    ,  17.120    ,  14.985    ,  14.306    ,  13.663    ,
     $   12.753    ,  11.596    ,  11.165    ,  10.287    ,  9.7882    ,
     $   9.2294    ,  8.7539    ,  8.3300    ,  6.9480    ,  6.2234    ,
     $   5.5881    ,  5.0189    ,  4.7733    ,  4.1104    ,  4.3929    ,
     $   4.6905    /
      DATA (CSEL(30,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL(31,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL(32,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSEL(33,J),J=1,41) /
     $   1100.0    ,  115.00    ,  105.00    ,  100.00    ,  56.000    ,
     $   40.000    ,  27.000    ,  22.000    ,  21.000    ,  20.000    ,
     $   20.000    ,  18.133    ,  18.167    ,  18.000    ,  17.667    ,
     $   18.133    ,  19.600    ,  21.800    ,  23.338    ,  23.118    ,
     $   19.323    ,  17.476    ,  13.464    ,  12.367    ,  11.691    ,
     $   11.057    ,  10.242    ,  9.5593    ,  9.0151    ,  8.5591    ,
     $   8.2884    ,  7.9253    ,  7.6311    ,  6.0667    ,  5.3667    ,
     $   4.8456    ,  4.5392    ,  4.5036    ,  4.4351    ,  4.2000    ,
     $   4.7289    /
      DATA (CSEL(34,J),J=1,41) /
     $   143.53    ,  43.935    ,  54.462    ,  51.429    ,  39.407    ,
     $   32.510    ,  27.321    ,  24.532    ,  23.465    ,  22.383    ,
     $   21.566    ,  20.209    ,  19.453    ,  18.825    ,  18.046    ,
     $   17.562    ,  17.802    ,  18.360    ,  18.667    ,  18.519    ,
     $   17.514    ,  17.120    ,  14.985    ,  14.306    ,  13.663    ,
     $   12.753    ,  11.596    ,  11.165    ,  10.287    ,  9.7882    ,
     $   9.2294    ,  8.7539    ,  8.3300    ,  6.9480    ,  6.2234    ,
     $   5.5881    ,  5.0189    ,  4.7733    ,  4.1104    ,  4.3929    ,
     $   4.6905    /
      DATA (CSEL(35,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 1,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 2,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 3,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 4,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 5,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 6,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 7,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.50000    ,  1.2000    ,  1.7000    ,
     $   2.2500    ,  3.0000    ,  3.6000    ,  4.5000    ,  5.4000    ,
     $   6.3000    ,  8.6000    ,  9.0000    ,  10.000    ,  11.500    ,
     $   14.000    ,  17.000    ,  19.500    ,  22.000    ,  24.000    ,
     $   21.500    ,  18.500    ,  19.000    ,  20.500    ,  22.200    ,
     $   23.000    ,  23.300    ,  23.000    ,  21.000    ,  20.500    ,
     $   20.200    ,  20.100    ,  20.000    ,  20.000    ,  20.000    ,
     $   21.000    /
      DATA (CSIN( 8,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN( 9,J),J=1,41) /
     $  0.00000E+00,  3.0000    ,  9.2000    ,  20.500    ,  36.500    ,
     $   45.000    ,  28.000    ,  19.500    ,  15.500    ,  14.200    ,
     $   15.500    ,  17.500    ,  20.000    ,  23.000    ,  26.000    ,
     $   20.000    ,  23.000    ,  26.500    ,  32.000    ,  35.000    ,
     $   28.500    ,  22.000    ,  22.500    ,  23.500    ,  24.000    ,
     $   24.500    ,  26.000    ,  27.500    ,  27.500    ,  27.000    ,
     $   26.500    ,  25.500    ,  25.000    ,  23.000    ,  22.500    ,
     $   22.200    ,  22.000    ,  22.000    ,  21.200    ,  20.700    ,
     $   21.000    /
      DATA (CSIN(10,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.50000    ,  1.5000    ,  2.7000    ,  3.8000    ,  4.8000    ,
     $   6.5000    ,  7.6000    ,  8.4000    ,  9.0000    ,  9.4000    ,
     $   9.8000    ,  10.500    ,  11.000    ,  11.500    ,  11.800    ,
     $   12.200    ,  12.400    ,  12.600    ,  13.200    ,  13.500    ,
     $   13.700    ,  14.000    ,  14.200    ,  14.500    ,  16.400    ,
     $   17.000    /
      DATA (CSIN(11,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.50000    ,  1.5000    ,  2.7000    ,  3.8000    ,  4.8000    ,
     $   6.5000    ,  7.6000    ,  8.4000    ,  9.0000    ,  9.4000    ,
     $   9.8000    ,  10.500    ,  11.000    ,  11.500    ,  11.800    ,
     $   12.200    ,  12.400    ,  12.600    ,  13.200    ,  13.500    ,
     $   13.700    ,  14.000    ,  14.200    ,  14.500    ,  16.400    ,
     $   17.000    /
      DATA (CSIN(12,J),J=1,41) /
     $   266.67    ,  133.33    ,  83.333    ,  57.083    ,  44.500    ,
     $   33.250    ,  24.583    ,  20.833    ,  18.333    ,  16.083    ,
     $   15.625    ,  15.083    ,  14.833    ,  15.083    ,  15.833    ,
     $   17.042    ,  18.958    ,  20.758    ,  22.533    ,  22.825    ,
     $   21.250    ,  18.567    ,  17.767    ,  18.100    ,  19.933    ,
     $   20.783    ,  21.225    ,  21.000    ,  20.558    ,  20.258    ,
     $   20.017    ,  19.767    ,  19.600    ,  19.183    ,  18.850    ,
     $   18.575    ,  18.350    ,  18.175    ,  17.808    ,  17.558    ,
     $   19.250    /
      DATA (CSIN(13,J),J=1,41) /
     $   400.00    ,  200.00    ,  120.00    ,  81.000    ,  62.000    ,
     $   47.000    ,  35.000    ,  28.000    ,  24.000    ,  21.000    ,
     $   19.500    ,  19.000    ,  18.800    ,  19.000    ,  20.000    ,
     $   21.000    ,  23.000    ,  25.000    ,  27.000    ,  27.500    ,
     $   25.500    ,  22.000    ,  20.800    ,  21.000    ,  23.000    ,
     $   24.000    ,  24.000    ,  23.800    ,  23.000    ,  22.500    ,
     $   22.000    ,  21.600    ,  21.400    ,  21.000    ,  20.500    ,
     $   20.200    ,  19.800    ,  19.500    ,  18.600    ,  17.500    ,
     $   20.000    /
      DATA (CSIN(14,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.10000    ,  1.5000    ,
     $   7.0000    ,  12.000    ,  17.000    ,  19.500    ,  20.500    ,
     $   22.000    ,  23.500    ,  24.800    ,  25.800    ,  26.500    ,
     $   27.000    ,  27.500    ,  28.000    ,  30.000    ,  31.000    ,
     $   32.000    ,  32.500    ,  32.500    ,  33.000    ,  33.500    ,
     $   34.000    /
      DATA (CSIN(15,J),J=1,41) /
     $   1500.0    ,  1160.0    ,  310.00    ,  230.00    ,  178.00    ,
     $   153.00    ,  134.00    ,  124.00    ,  113.00    ,  106.00    ,
     $   101.00    ,  96.000    ,  92.000    ,  89.000    ,  87.000    ,
     $   84.000    ,  81.000    ,  78.500    ,  76.500    ,  75.000    ,
     $   72.000    ,  70.000    ,  68.000    ,  64.500    ,  63.000    ,
     $   62.000    ,  61.000    ,  59.500    ,  58.500    ,  56.500    ,
     $   56.500    ,  56.000    ,  55.500    ,  52.000    ,  50.000    ,
     $   48.000    ,  45.000    ,  44.000    ,  39.200    ,  34.500    ,
     $   34.500    /
      DATA (CSIN(16,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.10000    ,  1.5000    ,
     $   7.0000    ,  12.000    ,  17.000    ,  19.500    ,  20.500    ,
     $   22.000    ,  23.500    ,  24.800    ,  25.800    ,  26.500    ,
     $   27.000    ,  27.500    ,  28.000    ,  30.000    ,  31.000    ,
     $   32.000    ,  32.500    ,  32.500    ,  33.000    ,  33.500    ,
     $   34.000    /
      DATA (CSIN(17,J),J=1,41) /
     $   1394.1    ,  948.17    ,  262.43    ,  197.14    ,  149.30    ,
     $   127.25    ,  110.39    ,  101.79    ,  92.834    ,  87.104    ,
     $   83.109    ,  79.099    ,  75.965    ,  73.627    ,  72.161    ,
     $   69.889    ,  67.595    ,  65.595    ,  64.057    ,  63.054    ,
     $   61.377    ,  60.434    ,  59.485    ,  56.970    ,  55.931    ,
     $   55.398    ,  54.827    ,  53.538    ,  52.861    ,  51.247    ,
     $   51.344    ,  50.992    ,  50.644    ,  47.876    ,  46.358    ,
     $   44.887    ,  42.577    ,  41.815    ,  38.180    ,  34.254    ,
     $   34.418    /
      DATA (CSIN(18,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.97815E-01,  1.4577    ,
     $   6.2052    ,  10.112    ,  12.902    ,  14.300    ,  14.688    ,
     $   15.505    ,  16.379    ,  17.554    ,  18.309    ,  18.920    ,
     $   19.389    ,  19.804    ,  20.284    ,  22.000    ,  22.733    ,
     $   23.527    ,  24.097    ,  24.382    ,  24.816    ,  26.800    ,
     $   27.719    /
      DATA (CSIN(19,J),J=1,41) /
     $   1182.4    ,  524.50    ,  167.30    ,  131.43    ,  91.895    ,
     $   75.743    ,  63.184    ,  57.376    ,  52.502    ,  49.313    ,
     $   47.326    ,  44.762    ,  43.222    ,  42.015    ,  41.221    ,
     $   40.244    ,  39.504    ,  39.145    ,  38.860    ,  38.731    ,
     $   37.987    ,  37.814    ,  36.326    ,  34.750    ,  33.953    ,
     $   33.635    ,  33.349    ,  32.938    ,  32.785    ,  32.092    ,
     $   32.373    ,  32.312    ,  32.329    ,  31.261    ,  30.597    ,
     $   30.073    ,  29.228    ,  29.182    ,  27.683    ,  27.107    ,
     $   27.956    /
      DATA (CSIN(20,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.97815E-01,  1.4577    ,
     $   6.2052    ,  10.112    ,  12.902    ,  14.300    ,  14.688    ,
     $   15.505    ,  16.379    ,  17.554    ,  18.309    ,  18.920    ,
     $   19.389    ,  19.804    ,  20.284    ,  22.000    ,  22.733    ,
     $   23.527    ,  24.097    ,  24.382    ,  24.816    ,  26.800    ,
     $   27.719    /
      DATA (CSIN(21,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN(22,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.97815E-01,  1.4577    ,
     $   6.2052    ,  10.112    ,  12.902    ,  14.300    ,  14.688    ,
     $   15.505    ,  16.379    ,  17.554    ,  18.309    ,  18.920    ,
     $   19.389    ,  19.804    ,  20.284    ,  22.000    ,  22.733    ,
     $   23.527    ,  24.097    ,  24.382    ,  24.816    ,  26.800    ,
     $   27.719    /
      DATA (CSIN(23,J),J=1,41) /
     $   1394.1    ,  948.17    ,  262.43    ,  197.14    ,  149.30    ,
     $   127.25    ,  110.39    ,  101.79    ,  92.834    ,  87.104    ,
     $   83.109    ,  78.563    ,  75.292    ,  72.760    ,  70.900    ,
     $   68.467    ,  66.314    ,  64.955    ,  63.746    ,  62.623    ,
     $   59.233    ,  56.946    ,  53.355    ,  49.810    ,  48.090    ,
     $   46.839    ,  45.695    ,  44.863    ,  44.062    ,  42.599    ,
     $   42.684    ,  42.328    ,  42.041    ,  39.508    ,  37.880    ,
     $   36.299    ,  34.075    ,  33.553    ,  29.723    ,  27.600    ,
     $   28.120    /
      DATA (CSIN(24,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN(25,J),J=1,41) /
     $   1182.4    ,  524.50    ,  167.30    ,  131.43    ,  91.895    ,
     $   75.743    ,  63.184    ,  57.376    ,  52.502    ,  49.313    ,
     $   47.326    ,  44.762    ,  43.222    ,  42.015    ,  41.221    ,
     $   40.244    ,  39.504    ,  39.145    ,  38.860    ,  38.731    ,
     $   37.987    ,  37.814    ,  36.326    ,  34.750    ,  33.953    ,
     $   33.635    ,  33.349    ,  32.938    ,  32.785    ,  32.092    ,
     $   32.373    ,  32.312    ,  32.329    ,  31.261    ,  30.597    ,
     $   30.073    ,  29.228    ,  29.182    ,  27.683    ,  27.107    ,
     $   27.956    /
      DATA (CSIN(26,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.95639E-01,  1.4154    ,
     $   5.4104    ,  8.2240    ,  8.8031    ,  9.1000    ,  8.8761    ,
     $   9.0095    ,  9.2576    ,  10.307    ,  10.818    ,  11.341    ,
     $   11.778    ,  12.108    ,  12.569    ,  14.000    ,  14.467    ,
     $   15.054    ,  15.694    ,  16.263    ,  16.632    ,  20.100    ,
     $   21.438    /
      DATA (CSIN(27,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.95639E-01,  1.4154    ,
     $   5.4104    ,  8.2240    ,  8.8031    ,  9.1000    ,  8.8761    ,
     $   9.0095    ,  9.2576    ,  10.307    ,  10.818    ,  11.341    ,
     $   11.778    ,  12.108    ,  12.569    ,  14.000    ,  14.467    ,
     $   15.054    ,  15.694    ,  16.263    ,  16.632    ,  20.100    ,
     $   21.438    /
      DATA (CSIN(28,J),J=1,41) /
     $   1182.4    ,  524.50    ,  167.30    ,  131.43    ,  91.895    ,
     $   75.743    ,  63.184    ,  57.376    ,  52.502    ,  49.313    ,
     $   47.326    ,  44.225    ,  42.549    ,  41.148    ,  39.960    ,
     $   38.822    ,  38.223    ,  38.505    ,  38.549    ,  38.301    ,
     $   35.843    ,  34.326    ,  30.196    ,  27.590    ,  26.112    ,
     $   25.076    ,  24.217    ,  24.264    ,  23.985    ,  23.445    ,
     $   23.713    ,  23.647    ,  23.726    ,  22.892    ,  22.119    ,
     $   21.485    ,  20.726    ,  20.921    ,  19.226    ,  20.454    ,
     $   21.658    /
      DATA (CSIN(29,J),J=1,41) /
     $   1076.5    ,  312.66    ,  119.74    ,  98.571    ,  63.193    ,
     $   49.990    ,  39.579    ,  35.168    ,  32.335    ,  30.417    ,
     $   29.434    ,  27.325    ,  26.514    ,  25.775    ,  25.120    ,
     $   24.711    ,  24.818    ,  25.600    ,  26.106    ,  26.355    ,
     $   25.220    ,  24.760    ,  21.681    ,  20.060    ,  19.044    ,
     $   18.474    ,  18.044    ,  18.301    ,  18.347    ,  18.192    ,
     $   18.557    ,  18.639    ,  18.870    ,  18.769    ,  18.478    ,
     $   18.372    ,  18.302    ,  18.735    ,  18.206    ,  20.207    ,
     $   21.576    /
      DATA (CSIN(30,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN(31,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN(32,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSIN(33,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.95639E-01,  1.4154    ,
     $   5.4104    ,  8.2240    ,  8.8031    ,  9.1000    ,  8.8761    ,
     $   9.0095    ,  9.2576    ,  10.307    ,  10.818    ,  11.341    ,
     $   11.778    ,  12.108    ,  12.569    ,  14.000    ,  14.467    ,
     $   15.054    ,  15.694    ,  16.263    ,  16.632    ,  20.100    ,
     $   21.438    /
      DATA (CSIN(34,J),J=1,41) /
     $   1076.5    ,  312.66    ,  119.74    ,  98.571    ,  63.193    ,
     $   49.990    ,  39.579    ,  35.168    ,  32.335    ,  30.417    ,
     $   29.434    ,  27.325    ,  26.514    ,  25.775    ,  25.120    ,
     $   24.711    ,  24.818    ,  25.600    ,  26.106    ,  26.355    ,
     $   25.220    ,  24.760    ,  21.681    ,  20.060    ,  19.044    ,
     $   18.474    ,  18.044    ,  18.301    ,  18.347    ,  18.192    ,
     $   18.557    ,  18.639    ,  18.870    ,  18.769    ,  18.478    ,
     $   18.372    ,  18.302    ,  18.735    ,  18.206    ,  20.207    ,
     $   21.576    /
      DATA (CSIN(35,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSPIEL( 1,J),J=1,41) /
     $  0.00000E+00,  350.00    ,  580.00    ,  600.00    ,  550.00    ,
     $   450.00    ,  410.00    ,  370.00    ,  340.00    ,  230.00    ,
     $   220.00    ,  205.00    ,  180.00    ,  155.00    ,  145.00    ,
     $   140.00    ,  160.00    ,  195.00    ,  235.00    ,  250.00    ,
     $   270.00    ,  280.00    ,  300.00    ,  300.00    ,  290.00    ,
     $   285.00    ,  265.00    ,  240.00    ,  230.00    ,  222.00    ,
     $   204.00    ,  196.00    ,  190.00    ,  170.00    ,  170.00    ,
     $   160.00    ,  150.00    ,  140.00    ,  120.00    ,  80.000    ,
     $   80.000    /
      DATA (CSPIEL( 2,J),J=1,41) /
     $  0.00000E+00,  700.00    ,  1000.0    ,  1200.0    ,  1300.0    ,
     $   1300.0    ,  1250.0    ,  1250.0    ,  1100.0    ,  1000.0    ,
     $   940.00    ,  740.00    ,  700.00    ,  670.00    ,  660.00    ,
     $   670.00    ,  680.00    ,  700.00    ,  735.00    ,  800.00    ,
     $   810.00    ,  820.00    ,  820.00    ,  810.00    ,  800.00    ,
     $   800.00    ,  700.00    ,  600.00    ,  500.00    ,  470.00    ,
     $   440.00    ,  410.00    ,  380.00    ,  330.00    ,  330.00    ,
     $   330.00    ,  330.00    ,  330.00    ,  285.00    ,  240.00    ,
     $   240.00    /
      DATA (CSPIEL( 3,J),J=1,41) /
     $  0.00000E+00,  1700.0    ,  2200.0    ,  2200.0    ,  1800.0    ,
     $   1300.0    ,  1200.0    ,  900.00    ,  900.00    ,  1000.0    ,
     $   1100.0    ,  1300.0    ,  1400.0    ,  1420.0    ,  1490.0    ,
     $   1560.0    ,  1580.0    ,  1690.0    ,  1795.0    ,  2000.0    ,
     $   2070.0    ,  2140.0    ,  2050.0    ,  2010.0    ,  1970.0    ,
     $   1880.0    ,  1690.0    ,  1500.0    ,  1420.0    ,  1390.0    ,
     $   1350.0    ,  1360.0    ,  1370.0    ,  1280.0    ,  1290.0    ,
     $   1295.0    ,  1250.0    ,  1200.0    ,  1050.0    ,  900.00    ,
     $   900.00    /
      DATA (CSPIIN( 1,J),J=1,41) /
     $  0.00000E+00,  200.00    ,  320.00    ,  500.00    ,  600.00    ,
     $   600.00    ,  590.00    ,  530.00    ,  510.00    ,  470.00    ,
     $   430.00    ,  425.00    ,  420.00    ,  425.00    ,  425.00    ,
     $   430.00    ,  430.00    ,  435.00    ,  435.00    ,  440.00    ,
     $   430.00    ,  430.00    ,  420.00    ,  420.00    ,  420.00    ,
     $   415.00    ,  415.00    ,  410.00    ,  410.00    ,  408.00    ,
     $   406.00    ,  404.00    ,  400.00    ,  380.00    ,  340.00    ,
     $   340.00    ,  340.00    ,  340.00    ,  340.00    ,  340.00    ,
     $   340.00    /
      DATA (CSPIIN( 2,J),J=1,41) /
     $  0.00000E+00,  400.00    ,  800.00    ,  1000.0    ,  1100.0    ,
     $   1200.0    ,  1150.0    ,  1050.0    ,  1000.0    ,  900.00    ,
     $   860.00    ,  860.00    ,  850.00    ,  850.00    ,  840.00    ,
     $   830.00    ,  820.00    ,  810.00    ,  805.00    ,  800.00    ,
     $   800.00    ,  800.00    ,  800.00    ,  800.00    ,  800.00    ,
     $   800.00    ,  800.00    ,  800.00    ,  800.00    ,  780.00    ,
     $   760.00    ,  740.00    ,  720.00    ,  720.00    ,  700.00    ,
     $   690.00    ,  680.00    ,  670.00    ,  665.00    ,  660.00    ,
     $   660.00    /
      DATA (CSPIIN( 3,J),J=1,41) /
     $  0.00000E+00,  1000.0    ,  1900.0    ,  2600.0    ,  2900.0    ,
     $   3000.0    ,  2800.0    ,  2600.0    ,  2500.0    ,  2300.0    ,
     $   2200.0    ,  2000.0    ,  1900.0    ,  1880.0    ,  1860.0    ,
     $   1840.0    ,  1820.0    ,  1810.0    ,  1805.0    ,  1800.0    ,
     $   1780.0    ,  1760.0    ,  1750.0    ,  1740.0    ,  1730.0    ,
     $   1720.0    ,  1710.0    ,  1700.0    ,  1680.0    ,  1660.0    ,
     $   1650.0    ,  1640.0    ,  1630.0    ,  1620.0    ,  1610.0    ,
     $   1605.0    ,  1600.0    ,  1600.0    ,  1550.0    ,  1500.0    ,
     $   1500.0    /
      DATA (CSPNEL( 1,J),J=1,41) /
     $   2100.0    ,  1800.0    ,  1500.0    ,  1050.0    ,  900.00    ,
     $   950.00    ,  800.00    ,  650.00    ,  570.00    ,  390.00    ,
     $   300.00    ,  240.00    ,  230.00    ,  230.00    ,  220.00    ,
     $   220.00    ,  225.00    ,  225.00    ,  240.00    ,  240.00    ,
     $   290.00    ,  330.00    ,  335.00    ,  350.00    ,  355.00    ,
     $   370.00    ,  350.00    ,  330.00    ,  310.00    ,  290.00    ,
     $   270.00    ,  265.00    ,  260.00    ,  230.00    ,  210.00    ,
     $   210.00    ,  200.00    ,  200.00    ,  190.00    ,  180.00    ,
     $   180.00    /
      DATA (CSPNEL( 2,J),J=1,41) /
     $   3800.0    ,  2900.0    ,  1850.0    ,  1550.0    ,  1450.0    ,
     $   1520.0    ,  1460.0    ,  1300.0    ,  1140.0    ,  880.00    ,
     $   700.00    ,  620.00    ,  540.00    ,  560.00    ,  460.00    ,
     $   460.00    ,  470.00    ,  470.00    ,  480.00    ,  480.00    ,
     $   580.00    ,  600.00    ,  610.00    ,  620.00    ,  620.00    ,
     $   620.00    ,  590.00    ,  580.00    ,  460.00    ,  440.00    ,
     $   420.00    ,  400.00    ,  480.00    ,  430.00    ,  380.00    ,
     $   380.00    ,  380.00    ,  380.00    ,  380.00    ,  380.00    ,
     $   380.00    /
      DATA (CSPNEL( 3,J),J=1,41) /
     $   7000.0    ,  6000.0    ,  4500.0    ,  3350.0    ,  2700.0    ,
     $   3000.0    ,  3550.0    ,  3970.0    ,  3280.0    ,  2490.0    ,
     $   2100.0    ,  1510.0    ,  1440.0    ,  1370.0    ,  1370.0    ,
     $   1370.0    ,  1400.0    ,  1400.0    ,  1420.0    ,  1420.0    ,
     $   1440.0    ,  1460.0    ,  1460.0    ,  1450.0    ,  1450.0    ,
     $   1470.0    ,  1400.0    ,  1400.0    ,  1380.0    ,  1370.0    ,
     $   1360.0    ,  1350.0    ,  1340.0    ,  1330.0    ,  1320.0    ,
     $   1310.0    ,  1305.0    ,  1300.0    ,  1300.0    ,  1300.0    ,
     $   1300.0    /
      DATA (CSPNIN( 1,J),J=1,41) /
     $  0.00000E+00,  200.00    ,  400.00    ,  800.00    ,  800.00    ,
     $   550.00    ,  500.00    ,  450.00    ,  430.00    ,  410.00    ,
     $   400.00    ,  390.00    ,  380.00    ,  370.00    ,  370.00    ,
     $   370.00    ,  365.00    ,  365.00    ,  360.00    ,  360.00    ,
     $   360.00    ,  360.00    ,  365.00    ,  370.00    ,  375.00    ,
     $   380.00    ,  400.00    ,  410.00    ,  420.00    ,  430.00    ,
     $   440.00    ,  440.00    ,  440.00    ,  440.00    ,  440.00    ,
     $   440.00    ,  440.00    ,  440.00    ,  440.00    ,  440.00    ,
     $   440.00    /
      DATA (CSPNIN( 2,J),J=1,41) /
     $  0.00000E+00,  400.00    ,  950.00    ,  1050.0    ,  1050.0    ,
     $   980.00    ,  940.00    ,  900.00    ,  860.00    ,  820.00    ,
     $   800.00    ,  780.00    ,  760.00    ,  740.00    ,  740.00    ,
     $   740.00    ,  730.00    ,  730.00    ,  720.00    ,  720.00    ,
     $   720.00    ,  720.00    ,  730.00    ,  740.00    ,  750.00    ,
     $   760.00    ,  800.00    ,  820.00    ,  820.00    ,  820.00    ,
     $   820.00    ,  820.00    ,  820.00    ,  820.00    ,  820.00    ,
     $   820.00    ,  820.00    ,  820.00    ,  820.00    ,  820.00    ,
     $   820.00    /
      DATA (CSPNIN( 3,J),J=1,41) /
     $  0.00000E+00, 0.00000E+00,  500.00    ,  1450.0    ,  1700.0    ,
     $   1800.0    ,  1750.0    ,  1730.0    ,  1720.0    ,  1710.0    ,
     $   1700.0    ,  1690.0    ,  1660.0    ,  1630.0    ,  1630.0    ,
     $   1630.0    ,  1600.0    ,  1600.0    ,  1580.0    ,  1580.0    ,
     $   1580.0    ,  1580.0    ,  1600.0    ,  1630.0    ,  1650.0    ,
     $   1670.0    ,  1760.0    ,  1800.0    ,  1800.0    ,  1800.0    ,
     $   1800.0    ,  1800.0    ,  1800.0    ,  1800.0    ,  1800.0    ,
     $   1800.0    ,  1800.0    ,  1800.0    ,  1800.0    ,  1800.0    ,
     $   1800.0    /
      DATA ELAB /
     $  0.10000E-03, 0.20000E-03, 0.30000E-03, 0.40000E-03, 0.50000E-03,
     $  0.70000E-03, 0.10000E-02, 0.20000E-02, 0.30000E-02, 0.40000E-02,
     $  0.50000E-02, 0.70000E-02, 0.10000E-01, 0.15000E-01, 0.20000E-01,
     $  0.25000E-01, 0.32700E-01/
      DATA CNLWAT /
     $   1.0000    ,  16.000    ,  27.000    ,  56.000    ,  59.000    ,
     $   64.000    ,  91.000    ,  112.00    ,  119.00    ,  127.00    ,
     $   137.00    ,  181.00    ,  207.00    ,  209.00    ,  238.00    /
      DATA (CNLWEL( 1,J),J=1,17) /
     $   6000.0    ,  5500.0    ,  5200.0    ,  4900.0    ,  4800.0    ,
     $   4400.0    ,  4000.0    ,  2900.0    ,  2200.0    ,  1800.0    ,
     $   1400.0    ,  1100.0    ,  900.00    ,  700.00    ,  600.00    ,
     $   560.00    ,  520.00    /
      DATA (CNLWEL( 2,J),J=1,17) /
     $   5400.0    ,  5050.0    ,  4800.0    ,  4600.0    ,  4399.0    ,
     $   4090.0    ,  3700.0    ,  2600.0    ,  1950.0    ,  1600.0    ,
     $   1300.0    ,  900.00    ,  700.00    ,  800.00    ,  1050.0    ,
     $   1250.0    ,  1320.0    /
      DATA (CNLWEL( 3,J),J=1,17) /
     $   5500.0    ,  5150.0    ,  4900.0    ,  4699.0    ,  4490.0    ,
     $   4150.0    ,  3750.0    ,  2790.0    ,  2100.0    ,  1650.0    ,
     $   1300.0    ,  950.00    ,  800.00    ,  860.00    ,  1000.0    ,
     $   1090.0    ,  1080.0    /
      DATA (CNLWEL( 4,J),J=1,17) /
     $   5499.0    ,  4970.0    ,  4450.0    ,  4080.0    ,  3750.0    ,
     $   3380.0    ,  2900.0    ,  2400.0    ,  2380.0    ,  2350.0    ,
     $   2300.0    ,  2100.0    ,  1720.0    ,  1370.0    ,  1200.0    ,
     $   1060.0    ,  870.00    /
      DATA (CNLWEL( 5,J),J=1,17) /
     $   5399.0    ,  4710.0    ,  4180.0    ,  3760.0    ,  3460.0    ,
     $   3150.0    ,  2730.0    ,  2270.0    ,  1850.0    ,  1850.0    ,
     $   2130.0    ,  2330.0    ,  2120.0    ,  1640.0    ,  1310.0    ,
     $   1100.0    ,  1050.0    /
      DATA (CNLWEL( 6,J),J=1,17) /
     $   5099.0    ,  4405.0    ,  3825.0    ,  3455.0    ,  3125.0    ,
     $   2695.0    ,  2350.0    ,  1850.0    ,  1580.0    ,  1820.0    ,
     $   2050.0    ,  2210.0    ,  2000.0    ,  1590.0    ,  1310.0    ,
     $   1120.0    ,  1040.0    /
      DATA (CNLWEL( 7,J),J=1,17) /
     $   6290.0    ,  5960.0    ,  5640.0    ,  5370.0    ,  5150.0    ,
     $   4800.0    ,  4250.0    ,  3150.0    ,  2470.0    ,  2100.0    ,
     $   2230.0    ,  2420.0    ,  2450.0    ,  2050.0    ,  1760.0    ,
     $   1550.0    ,  1330.0    /
      DATA (CNLWEL( 8,J),J=1,17) /
     $   6885.0    ,  6650.0    ,  6350.0    ,  6150.0    ,  6000.0    ,
     $   5700.0    ,  5360.0    ,  4250.0    ,  2800.0    ,  1870.0    ,
     $   1810.0    ,  1820.0    ,  2170.0    ,  2450.0    ,  2150.0    ,
     $   1700.0    ,  1390.0    /
      DATA (CNLWEL( 9,J),J=1,17) /
     $   6600.0    ,  6500.0    ,  6400.0    ,  6249.0    ,  6190.0    ,
     $   5950.0    ,  5520.0    ,  4250.0    ,  2750.0    ,  1900.0    ,
     $   1850.0    ,  1950.0    ,  2340.0    ,  2800.0    ,  2540.0    ,
     $   2100.0    ,  1760.0    /
      DATA (CNLWEL(10,J),J=1,17) /
     $   7400.0    ,  7200.0    ,  6999.0    ,  6840.0    ,  6655.0    ,
     $   6320.0    ,  5820.0    ,  4400.0    ,  2850.0    ,  2000.0    ,
     $   1800.0    ,  1800.0    ,  2150.0    ,  2600.0    ,  2350.0    ,
     $   1950.0    ,  2100.0    /
      DATA (CNLWEL(11,J),J=1,17) /
     $   7900.0    ,  7700.0    ,  7499.0    ,  7390.0    ,  7202.0    ,
     $   6810.0    ,  6360.0    ,  4920.0    ,  3450.0    ,  2600.0    ,
     $   2200.0    ,  1950.0    ,  2300.0    ,  2800.0    ,  2650.0    ,
     $   2250.0    ,  2050.0    /
      DATA (CNLWEL(12,J),J=1,17) /
     $   7900.0    ,  7750.0    ,  7699.0    ,  7590.0    ,  7450.0    ,
     $   7200.0    ,  6850.0    ,  5650.0    ,  4400.0    ,  3700.0    ,
     $   3400.0    ,  2800.0    ,  2700.0    ,  3100.0    ,  3250.0    ,
     $   3100.0    ,  2750.0    /
      DATA (CNLWEL(13,J),J=1,17) /
     $   6100.0    ,  5950.0    ,  5750.0    ,  5599.0    ,  5440.0    ,
     $   5200.0    ,  4800.0    ,  4300.0    ,  5800.0    ,  5750.0    ,
     $   4800.0    ,  3420.0    ,  2650.0    ,  3200.0    ,  3650.0    ,
     $   3500.0    ,  2980.0    /
      DATA (CNLWEL(14,J),J=1,17) /
     $   6100.0    ,  5950.0    ,  5750.0    ,  5599.0    ,  5440.0    ,
     $   5200.0    ,  4800.0    ,  4300.0    ,  5800.0    ,  5750.0    ,
     $   4800.0    ,  3420.0    ,  2650.0    ,  3200.0    ,  3650.0    ,
     $   3500.0    ,  2980.0    /
      DATA (CNLWEL(15,J),J=1,17) /
     $   6600.0    ,  6350.0    ,  6100.0    ,  5899.0    ,  5690.0    ,
     $   5300.0    ,  4850.0    ,  4450.0    ,  5650.0    ,  5700.0    ,
     $   4950.0    ,  3850.0    ,  3050.0    ,  3050.0    ,  3460.0    ,
     $   3650.0    ,  3340.0    /
      DATA (CNLWIN( 1,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00/
      DATA (CNLWIN( 2,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,  1.0000    ,
     $   10.000    ,  50.000    ,  100.00    ,  200.00    ,  300.00    ,
     $   400.00    ,  600.00    ,  700.00    ,  750.00    ,  700.00    ,
     $   700.00    ,  680.00    /
      DATA (CNLWIN( 3,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,
     $   50.000    ,  100.00    ,  260.00    ,  450.00    ,  600.00    ,
     $   700.00    ,  800.00    ,  900.00    ,  940.00    ,  900.00    ,
     $   860.00    ,  820.00    /
      DATA (CNLWIN( 4,J),J=1,17) /
     $   1.0000    ,  80.000    ,  200.00    ,  320.00    ,  400.00    ,
     $   520.00    ,  700.00    ,  1000.0    ,  1120.0    ,  1200.0    ,
     $   1200.0    ,  1200.0    ,  1180.0    ,  1130.0    ,  1100.0    ,
     $   1090.0    ,  1080.0    /
      DATA (CNLWIN( 5,J),J=1,17) /
     $   1.0000    ,  90.000    ,  220.00    ,  340.00    ,  420.00    ,
     $   550.00    ,  720.00    ,  1080.0    ,  1300.0    ,  1400.0    ,
     $   1420.0    ,  1420.0    ,  1380.0    ,  1260.0    ,  1190.0    ,
     $   1150.0    ,  1100.0    /
      DATA (CNLWIN( 6,J),J=1,17) /
     $   1.0000    ,  95.000    ,  225.00    ,  345.00    ,  425.00    ,
     $   555.00    ,  750.00    ,  1150.0    ,  1500.0    ,  1680.0    ,
     $   1700.0    ,  1690.0    ,  1550.0    ,  1360.0    ,  1240.0    ,
     $   1180.0    ,  1120.0    /
      DATA (CNLWIN( 7,J),J=1,17) /
     $   10.000    ,  140.00    ,  260.00    ,  380.00    ,  450.00    ,
     $   600.00    ,  750.00    ,  1200.0    ,  1580.0    ,  1800.0    ,
     $   1820.0    ,  1830.0    ,  1800.0    ,  1750.0    ,  1690.0    ,
     $   1650.0    ,  1620.0    /
      DATA (CNLWIN( 8,J),J=1,17) /
     $   15.000    ,  150.00    ,  300.00    ,  400.00    ,  500.00    ,
     $   650.00    ,  840.00    ,  1500.0    ,  2100.0    ,  2130.0    ,
     $   2140.0    ,  2130.0    ,  2080.0    ,  2000.0    ,  1950.0    ,
     $   1900.0    ,  1860.0    /
      DATA (CNLWIN( 9,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,
     $   150.00    ,  380.00    ,  1000.0    ,  1650.0    ,  2100.0    ,
     $   2100.0    ,  2100.0    ,  2060.0    ,  1950.0    ,  1860.0    ,
     $   1800.0    ,  1740.0    /
      DATA (CNLWIN(10,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,  45.000    ,
     $   180.00    ,  380.00    ,  1050.0    ,  1900.0    ,  2300.0    ,
     $   2300.0    ,  2200.0    ,  2150.0    ,  2000.0    ,  1900.0    ,
     $   1800.0    ,  1750.0    /
      DATA (CNLWIN(11,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,  48.000    ,
     $   190.00    ,  390.00    ,  1080.0    ,  2000.0    ,  2400.0    ,
     $   2400.0    ,  2300.0    ,  2200.0    ,  2100.0    ,  1950.0    ,
     $   1850.0    ,  1800.0    /
      DATA (CNLWIN(12,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,  50.000    ,
     $   200.00    ,  400.00    ,  1100.0    ,  2100.0    ,  2500.0    ,
     $   2500.0    ,  2450.0    ,  2300.0    ,  2100.0    ,  2000.0    ,
     $   1900.0    ,  1850.0    /
      DATA (CNLWIN(13,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,
     $   100.00    ,  350.00    ,  900.00    ,  1400.0    ,  2000.0    ,
     $   2300.0    ,  2380.0    ,  2400.0    ,  2300.0    ,  2250.0    ,
     $   2200.0    ,  2120.0    /
      DATA (CNLWIN(14,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,
     $   100.00    ,  350.00    ,  900.00    ,  1400.0    ,  2000.0    ,
     $   2300.0    ,  2380.0    ,  2400.0    ,  2300.0    ,  2250.0    ,
     $   2200.0    ,  2120.0    /
      DATA (CNLWIN(15,J),J=1,17) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00,  1.0000    ,  10.000    ,
     $   100.00    ,  400.00    ,  950.00    ,  1600.0    ,  2200.0    ,
     $   2550.0    ,  2750.0    ,  2700.0    ,  2600.0    ,  2540.0    ,
     $   2450.0    ,  2360.0    /
      DATA (CSCAP(J),J=1,50) /
     $   6.0000    ,  5.7000    ,  5.5000    ,  5.3000    ,  5.2000    ,
     $   5.1000    ,  5.0000    ,  4.9000    ,  4.8000    ,  4.8000    ,
     $   4.8000    ,  4.8000    ,  4.8000    ,  4.8000    ,  4.8000    ,
     $   4.8000    ,  4.9000    ,  5.0000    ,  5.2000    ,  5.5000    ,
     $   6.0000    ,  6.7000    ,  7.5000    ,  8.5000    ,  10.000    ,
     $   12.000    ,  14.500    ,  19.000    ,  26.500    ,  40.000    ,
     $   75.000    ,  120.00    ,  180.00    ,  260.00    ,  360.00    ,
     $   330.00    ,  60.000    ,  7.0000    ,  9.5000    ,  20.000    ,
     $   75.000    ,  140.00    ,  250.00    ,  360.00    ,  480.00    ,
     $   580.00    ,  590.00    ,  500.00    ,  300.00    ,  100.00    /
      DATA (CSCAP(J),J=51,100) /
     $   200.00    ,  300.00    ,  400.00    ,  470.00    ,  500.00    ,
     $   430.00    ,  100.00    ,  20.000    ,  22.000    ,  40.000    ,
     $   560.00    ,  950.00    ,  1000.0    ,  1000.0    ,  1000.0    ,
     $   990.00    ,  920.00    ,  860.00    ,  790.00    ,  740.00    ,
     $   650.00    ,  600.00    ,  540.00    ,  470.00    ,  440.00    ,
     $   390.00    ,  360.00    ,  340.00    ,  320.00    ,  310.00    ,
     $   280.00    ,  2.0000    ,  2.5000    ,  6.0000    ,  13.000    ,
     $   38.000    ,  65.000    ,  140.00    ,  280.00    ,  300.00    ,
     $   430.00    ,  580.00    ,  650.00    ,  800.00    ,  920.00    ,
     $   1100.0    ,  1250.0    ,  1400.0    ,  1550.0    ,  1700.0    /
      DATA EKFISS /
     $  0.10000E-03, 0.20000E-03, 0.30000E-03, 0.50000E-03, 0.70000E-03,
     $  0.10000E-02, 0.15000E-02, 0.20000E-02, 0.30000E-02, 0.50000E-02,
     $  0.70000E-02, 0.10000E-01, 0.15000E-01, 0.20000E-01, 0.50000E-01,
     $  0.10000    , 0.20000    , 0.30000    , 0.40000    , 0.50000    ,
     $   1000.0    /
      DATA (CSFISS( 1,J),J=1,21) /
     $   2600.0    ,  2300.0    ,  2300.0    ,  2100.0    ,  2000.0    ,
     $   1950.0    ,  1930.0    ,  1900.0    ,  1800.0    ,  1600.0    ,
     $   2100.0    ,  2300.0    , 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSFISS( 2,J),J=1,21) /
     $   1850.0    ,  1400.0    ,  1300.0    ,  1150.0    ,  1100.0    ,
     $   1200.0    ,  1250.0    ,  1300.0    ,  1250.0    ,  1150.0    ,
     $   1600.0    ,  1900.0    , 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSFISS( 3,J),J=1,21) /
     $   1700.0    ,  1650.0    ,  1650.0    ,  1700.0    ,  1700.0    ,
     $   1800.0    ,  1900.0    ,  2000.0    ,  1950.0    ,  1800.0    ,
     $   2150.0    ,  2450.0    , 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00/
      DATA (CSFISS( 4,J),J=1,21) /
     $  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
     $  0.00000E+00,  250.00    ,  550.00    ,  550.00    ,  550.00    ,
     $   550.00    ,  550.00    ,  1000.0    ,  1400.0    ,  1600.0    ,
     $   1500.0    ,  1400.0    ,  1300.0    ,  1200.0    ,  1100.0    ,
     $   1000.0    /
C --- END OF CROSS SECTION DATA STATEMENTS ---
C

+KEEP, S_CSDIM.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* s_csdim.inc
C --- DIMENSION STATEMENTS FOR CROSS SECTION DATA ---
      DIMENSION PLAB(41),CSEL(35,41),CSIN(35,41),CSPIEL(3,41),
     $          CSPIIN(3,41),CSPNEL(3,41),CSPNIN(3,41),
     $          ELAB(17),CNLWAT(15),CNLWEL(15,17),CNLWIN(15,17),
     $          CSCAP(100),EKFISS(21),CSFISS(4,21)
C

+KEEP, S_CURPAR.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* s_curpar.inc
      PARAMETER (MXGKCU=MXGKGH)
      COMMON/CURPAR/WEIGHT(10),DDELTN,IFILE,IRUN,NEVT,NEVENT,SHFLAG,
     *              ITHST,ITTOT,ITLST,IFRND,TOFCUT,CMOM(5),CENG(5),
     *              RS,S,ENP(10),NP,NM,NN,NR,NO,NZ,IPA(MXGKCU),
     *              ATNO2,ZNO2
C

+KEEP, S_DEFCOM.
* Revision 1.1.1.1  1995/10/24 10:20:43  cernlib
* Geant
* s_defcom.inc
+CDE, MXGKGH.
+CDE, S_CONSTS.
+CDE, S_CURPAR.
+CDE, S_RESULT.
+CDE, S_MAT.
+CDE, S_EVENT.
+CDE, S_PRNTFL.
+CDE, S_ERRCOM.
+CDE, S_BLANK.
C

+KEEP, S_GENIO.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_genio.inc
      COMMON/GENIN /TECM,AMASS(18),NPG,KGENEV
      COMMON/GENOUT/PCM(5,18),WGT
C

+KEEP, S_KGINIT.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
*       *** NVE 09-FEB-1988 ***
* s_kginit.inc
C --- INITIALIZATION FLAGS FOR VARIOUS GHEISHA ROUTINES ---
      COMMON /KGINIT/ KGINIT(50)
C

+KEEP, S_NUCIO, IF=-SINGLE.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_nucio.inc
      COMMON/NUCIN /TECM,AMASS(18),NPG,KGENEV
      COMMON/NUCOUT/PCM(5,18),WGT
+CDE, NUCIOD.
C

+KEEP, S_NUCIO.
* Revision 1.1.1.1  1995/10/24 10:20:44  cernlib
* Geant
* s_nucio.inc
      COMMON/NUCIN /TECM,AMASS(18),NPG,KGENEV
      COMMON/NUCOUT/PCM(5,18),WGT
C

+KEEP, SPLIT.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* split.inc
*=== split ============================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     Created on 10 december 1991  by    Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 10-dec-91     by    Alfredo Ferrari               *
*                                                                      *
*     This is the original common split of Hadrin                      *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                CALUMV                                                *
*                DATESH                                                *
*                HADRIV                                                *
*                RCHANV                                                *
*                BLKDT3                                                *
*                HADDEN                                                *
*                CALUMO                                                *
*                RCHANW                                                *
*                                                                      *
*----------------------------------------------------------------------*
      COMMON / FKSPLI  / WT     (460), NZK  (460,3)


+KEEP, TRCOM3, IF=INCLUDE.
* Revision 1.2  1996/07/25 15:01:26  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:35  mclareni
* Add geane321 includes
*      Sequences of the EMC routines
* trcom3.inc
      DOUBLE PRECISION A, B, S, TN, T, COSL, SINL, COSP, SINP, COSL1
      INTEGER          NEW
      COMMON /TRCOM3/ A(5,5), B(5,5), S(15),
     +                TN(3), T(5), COSL, SINL, COSP, SINP, COSL1, NEW
*
* trcom3.inc
*
+CDE, INCBEG.
     +    TRCOM3
+CDE, INCEND.

+KEEP, TRCOM3.
* Revision 1.2  1996/07/25 15:01:26  ravndal
* CMZ to CVS conversion artefact removed
* Revision 1.1  1996/03/06 15:32:35  mclareni
* Add geane321 includes
*      Sequences of the EMC routines
* trcom3.inc
      DOUBLE PRECISION A, B, S, TN, T, COSL, SINL, COSP, SINP, COSL1
      INTEGER          NEW
      COMMON /TRCOM3/ A(5,5), B(5,5), S(15),
     +                TN(3), T(5), COSL, SINL, COSP, SINP, COSL1, NEW
*
* trcom3.inc
*

+KEEP, XSEPAR.
* Revision 1.1.1.1  1995/10/24 10:20:42  cernlib
* Geant
* xsepar.inc
*=== xsepar ===========================================================*
*----------------------------------------------------------------------*
*                                                                      *
*     Xsec Parameters for neutrons and protons:                        *
*                                                                      *
*     Created on  20 september 1991  by  Alfredo Ferrari & Paola Sala  *
*                                                   Infn - Milan       *
*                                                                      *
*     Last change on 20-sep-91     by    Alfredo Ferrari               *
*                                                                      *
*     Included in the following routines:                              *
*                                                                      *
*                        BERRTP                                        *
*                        XSINEU                                        *
*                        XSIPRO                                        *
*                        PREPRE                                        *
*                                                                      *
*----------------------------------------------------------------------*
      COMMON / FKXSEP / AANXSE (100), BBNXSE (100), CCNXSE (100),
     &                  DDNXSE (100), EENXSE (100), ZZNXSE (100),
     &                  EMNXSE (100), XMNXSE (100),
     &                  AAPXSE (100), BBPXSE (100), CCPXSE (100),
     &                  DDPXSE (100), EEPXSE (100), FFPXSE (100),
     &                  ZZPXSE (100), EMPXSE (100), XMPXSE (100)


+PATCH, DOC_INCLUDE_SPECIALS.
+KEEP, INCBEG, IF=INCLUDE, IF=IBM.
* Revision 1.1.1.1  1995/10/24 10:19:49  cernlib
* Geant
* incbeg.inc
#if 0
      INCLUDE '
#endif
+KEEP, INCEND, IF=INCLUDE, IF=IBM.
* Revision 1.1.1.1  1995/10/24 10:19:49  cernlib
* Geant
* incend.inc
#if 0
     +'
#endif
+DECK,  INCSEQ_CRA_D, T=DATA, IF=DOC.
#if defined(CERNLIB_INCLUDE)
#if 0
*CMZ :  3.21/02 29/03/94  15.41.18  by  S.Giani
#endif
#if 0
*-- Author :
#endif
#endif
+PATCH, DOC_CMZX_VERSIONS.
+DECK,  V3_14_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:52  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.32  by  S.Giani
*-- Author :
*
*::>          VERSION  3.14/16   901107 15.26
*
*       See PATCH,HISTORY in file GEANT for description
*       of changes in version 3.14
*

+DECK,  V3_15_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:52  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.32  by  S.Giani
*-- Author :
*
*::>          VERSION  3.15/06   920408 13.09
*
*
*          ************************************************************
*          *                                                          *
*          *                                                          *
*          *                G E A N T   Version  3.15                 *
*          *                                                          *
*          *            O F F I C I A L     R E L E A S E             *
*          *                                                          *
*          *              CERN, Geneva, April 7, 1992                 *
*          *                                                          *
*          *                                                          *
*          *                                                          *
*          ************************************************************
*
*
*::>          VERSION  3.15/05   920401  8.41
*
*
*::>          VERSION  3.15/04   920331  9.42
*
*
*::>          VERSION  3.15/03   920331  8.02
*
*
*::>          VERSION  3.15/02   920327 18.51
*
*
*::>          VERSION  3.15/01   920316 10.20
*
*             Prerelease stamping of 3.15
*
+DECK,  V3_16_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:52  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.32  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/00   07/12/93 14.37.10
*
+DECK,  V3_21_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:52  cernlib
* Geant
*
*
*CMZ :  3.21/04 21/03/95  18.10.03  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/04   21/03/95 18.10.03
*
*
*::>          VERSION  3.21/03   17/10/94 16.00.12
*
*
*::>          VERSION  3.21/02   25/07/94 15.22.26
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 17.04.50
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
+PATCH, DOC_CMZT_VERSIONS.
+DECK,  V3_13_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.13/05   890628 15.01
*
*      See PATCH,HISTORY for the description of version 3.14
*
+DECK,  V3_14_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.14/16   901107 15.23
*
*      See PATCH,HISTORY for the description of version 3.14
*

+DECK,  V3_15_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.15/09   920408 13.02
*
*
*          ************************************************************
*          *                                                          *
*          *                                                          *
*          *                G E A N T   Version  3.15                 *
*          *                                                          *
*          *            O F F I C I A L     R E L E A S E             *
*          *                                                          *
*          *              CERN, Geneva, April 7, 1992                 *
*          *                                                          *
*          *                                                          *
*          *                                                          *
*          ************************************************************
*
*
*::>          VERSION  3.15/08   920401  8.41
*
*
*::>          VERSION  3.15/07   920331  9.42
*
*
*::>          VERSION  3.15/06   920331  8.01
*
*
*::>          VERSION  3.15/05   920329 15.41
*
*
*::>          VERSION  3.15/04   920329 13.45
*
*
*::>          VERSION  3.15/03   920327 18.49
*
*
*::>          VERSION  3.15/02   920316 12.53
*
*
*::>          VERSION  3.15/01   920316 10.18
*
*             Prerelease stamping of 3.15
*
+DECK,  V3_16_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.18  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/00   07/12/93 14.33.29
*
+DECK,  V3_21_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
*
*
*CMZ :  3.21/04 21/03/95  17.58.14  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/04   21/03/95 17.58.14
*
*
*::>          VERSION  3.21/03   17/10/94 16.00.29
*
*
*::>          VERSION  3.21/02   25/07/94 15.24.16
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 16.32.43
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* GEANT 3.21 has a new tracking logic to speed up the search over the
*            volumes positioned inside a given node (Virtual Divisions).
*            The new tracking is initialized by GGCLOS in a completely
*            transparent way and in a negligible amount of time.
*            The GUNEAR and GSORD techniques are automatically disabled
*            and no change in the user code is needed. Anyway, it is
*            still possible to get the old Geant tracking recompiling
*            GEANT and GEANG with the patchy flag OLD.
*            To implement the new logic, the following routines have
*            written or deeply modified: GTNEXT, GGCLOS, GTMEDI, GNEXT,
*            GMEDIA, GINVOL, GVDCAR, GVDRAD, GVDPHI, GVDLIM, GSCVOL.
*                                                               S.Giani.
*
* GEANT 3.21 has a new logic for MANY volumes: the tracking is not
*            based anymore on a step-search, but relies on a algorithm
*            similar to the one used for ONLY volumes (giving then
*            basically the same speed obtained for ONLY). The new logic
*            of MANY allows boolean operations between volumes, clipping
*            of protuding objects, divisions along arbitrary axis,
*            overlaps of 1-D structures to build 2-D or 3-D structures
*            (like honeycombs, spaghetti, etc.). To implement the new
*            logic, the following routines have been written or modified:
*            GTNEXT, GTMEDI, GNEXT, GMEDIA, GTELEC, GTCKOV, GTHADR,
*            GTHION, GTMUON.
*                                                             S.Giani.
*
* GEANT 3.21 contains modifications to GTELEC, GTGAMA, GDRAY in order
*            to exploit the e.m. low energy effects introduced in 3.16
*            without any overhead in performance compared with 3.15.
*            A bug in the delta ray productions is now fixed.
*                                                        Thanks to L.Urban.
*
* GEANT 3.21 provides a ray-tracing as a new visualization tool. The
*            ray-tracing is based on the new Geant tracking and allows
*            the visualization of the boolean operations results.
*            The following routines have been written or modified:
*            GDRACK, GDSTEP, GDNINO, GDOPT, GDRAYT, GDRAW, GDINIT,
*            GTRIG, GTRIGI, GDKINE, GDLUMI, GLIGHT, GFIND, GXDRAW,
*            CDF.
*                                                             S.Giani.
*
* A new GGPERP has been written to cope with almost all the shapes.
*            It is now of general utility both for the Cerenkovs
*            and for the ray-tracing.
*                                               Thanks to R.Jones.
*
* A new set of routines to compute distances to surfaces has been
*            introduced (GVSAFE, GVGRAD, GVPSQR, GVSIGN, GVLONG).
*                                               Thanks to V.Perev.
*
* Important fix in GPHYSI: user words for media were overwriting
*            ILABS, ISYNC and ISTRA.
*                                    Thanks to S.Giani, S.Ravndal.
*
* GXOBJ has been improved to handle DETs as objects of a SET directory
*            in the HITS class.
*                                    Thanks to S.Giani, A.Dellacqua.
*
* GTNINO has been corrected in order to print the mechanism NEXT when
*            crossing boundaries.
*                                    Thanks to S.Giani, M.Maire.
*
* GFMFIN and GFMDIS are the new names for the 316 routines FMUFIN and
*        FMDIST to avoid clashes with the program library. GFMFIN has
*        also been corrected for a 316 bug affecting neutrons.
*                             Thanks to C.Zeitniz,K.Lassila,S.Ravndal.
*
* GINTRP and GINPCO have been corrected to handle sharp edges with no
*        risk of float exception.
*                                Thanks to L.Gibbons.
*
* GGPERP has been corrected in reading the TRAP parameters and a systematic
*        consistency of single precision or double precision variables in
*        the MAX,MIN,MOD operands is provided.
*                                             Thanks to S.Ravndal.
*
* FEREVV and FERHAV are now new from FLUKA.
*                                             Thanks to A.Ferrari.
*
* FEREVV has been adapted to the Geant random numbers generators.
*                                             Thanks to S.Ravndal.
*
* In GRNDMQ the option `SH' is provided to write the seeds ISEED1 and
*         ISEED2 to the event header bank.
*                                             Thanks to S.Ravndal.
*
* In GMORIN,FLINIT and GHEINI the interface messages are removed.
*                                             Thanks to S.Ravndal.
*
* In GGDPAR now PAR(3) is correctly initialized to 1.for slices of
*         a PGON.
*
*
* The seq GCNUM has been added to the deck ERTRGO in Geane.
*
*
*
* G321X and G321M are the new names for the KUIP output of the CDF.
*                                             Thanks to S.Giani.
*
* GMORIN has been modified in order to read correctly xsneut.dat
*          for MSDOS and WINNT as well.
*                                         Thanks to V.Fine.
*
* GEAMON has been modified in order to print Real and CPU Time longer
*          than 999 sec.
*                                         Thanks to R.Brun.
*
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                      Correction cradle 0.01                        *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       29/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* GZINIT and GSCKOV have been corrected (compared with 3.16) in order
*        to initialize correctly the link area for the Zebra pointers
*        of the banks relative to straggling, Cerenkovs, Asho, etc.
*        Four pointers were not seen by Mzlint and, moreover, the link
*        area (containing pointers for straggling, etc.) was initialized
*        only if using Cerenkovs.
*                                   Thanks to M.Verzocchi and R.Brun.
*
* FERHAV in Geanf was provoking a float exception due to a negative sqrt.
*        The problem was fixed thanks to a comparison with the original
*        Fluka code.
*                                   Thanks to B.Slater and S.Giani.
*
* PREPRE has been deoptimized on HP.
*                                   Thanks to A.Kulik.
*
* In GSKINE a pointer was not saved (in the previous versions as well).
*                                   Thanks to A.Dellacqua.
*
* In GTNEXT and GNEXT precision problems are handled more effectively.
*                                   Thanks to P.Ward, C.Markou and S.Giani.
*
* In GTNEXT the blocking of the volume from which particles are exiting
*        has been corrected.
*                                   Thanks to P.Ward.
*
* Problems in the interactive materials, mixtures and media definition
*        have been solved. (Routines GXCONT,GXGEOM). Idem for the 3D
*        Dspec (routine GXDRAW).
*
* In order to handle correctly calls to Gfcoor in phi (for x=0 or y=0)
*        GTMEDI, GMEDIA and GINVOL have been modified.
*                                    Thanks to P.Ward.
*
* In the ray-tracing, GDNINO has been corrected for precision problems.
*                                    Thanks to S.Giani.
*
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                      Correction cradle 0.02                        *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       25/7/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* In GTNEXT precision problems in phi have been solved.
*                                    Thanks to A.Rosowsky and A.Givernaud.
*
* In GDRAY a missing protection for delta ray production was added.
*                                    Thanks to L.Urban.
*
* In GINVOL the variable ingt is corrrectly reset. It was not reset in
*       all the previous versions of GEANT as well.
*                                    Thanks to R.Jones.
*
* GTCKOV, GTHADR, GTHION, GLISUR have been corrected and extended compared
*       with the first implementation in 3.16 for Cerenkov tracking.
*                                    Thanks to R.Jones.
*
* GSKPHO has been fixed for Cerenkov physics compared with the previous
*       version of GEANT (3.16).
*                                    Thanks to S.Bottai.
*
* GFTMAT had a wrong pointer to plot the muon-nucleus cross sections since
*       version 3.16. Now it is fixed.
*                                    Thanks to C.Wiebusch and S.Ravndal.
*
* GFINDS has been restored to the 3.15 functionality.
*                                    Thanks to A.Dellacqua and S.Tonse.
*
* GFANG has been fixed for a special pathological case.
*                                    Thanks to C.Zosi.
*
* GSROTM  has been fixed for a special pathological case.
*                                    Thanks to A.Vlassov.
*
* GDRAYT does not increment ievent anymore.
*                                    Thanks to P.Jacobs.
*
* GLVOLU has been fixed to recompute the pointers of the geometrical tree
*       even if the names and numbers were identical.
*                                    Thanks to R.Jones, T.Noble, S.Ravndal.
*
* GVDRAD has been fixed to compute the scope of tubs.
*                                    Thanks to K.Albiol and S.Giani.
*
* GDSPEC has been fixed to print degrees for the 3-rd parameter of sphe.
*                                    Thanks to S.Ravndal.
*
* GVDPHI has been fixed for a special pathological case (only for volumes
*       with planar surfaces).
*                                    Thanks to M.Kaspar and S.Giani.
*
* GXCONT is changed to handle correctly the variables ievent and nevent.
*                                    Thanks to P.Jacobs.
*
* SVGAM7 in Gheisha has now a protection against the log(0).
*                                    Thanks to D.Heck.
*
* FEREVV and FERHAV have been updated.
*                                    Thanks to A.Ferrari.
*
* In FLUFIN the correct mechanism is given to lmec in case of energy
*       below cut-off.
*                                    Thanks to B.Slater and S.Ravndal.
*
* In NUDISV the array anpowr is saved.
*                                    Thanks to S.Ravndal.
*
* In GMXSEC imed is used instead of nmed.
*                                   Thanks to K.L.Perini.
*
*
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                  Correction version 0.03 = 94b release             *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       18/10/94  Geneva  CH                         *
*                                                                    *
**********************************************************************
*
* In GDCGVW traslation problems have been fixed (graphics).
*                                    Thanks to J.Stepanek, S.Giani.
*
* In GLTRAC nlevel is now initialized to 0 and GTNEXT has been improved
*    further for handling precision problems.
*                                    Thanks to A.Dellacqua.
*
* GDRELX and GTELEC have been corrected for energy deposition problems.
*                                    Thanks to L.Urban.
*
* GSDVT2 has been corrected for divisions in phi.
*                                    Thanks to V.Popov.
*
* GPVOLU and GFMOTH are now able to handle cases where copy number = 1
*    is not defined.
*                                    Thanks to S.Giani, S.Nowak.
*
* GTREVE has been changed in order to avoid the loading of the graphics
*    package if not desired.
*                                    Thanks to S.Giani, I.Bird.
*
* GUPHAD, GUHADR and FLINIT give warnings and conditions for the use of FLUKA.
*                                    Thanks to A.Ferrari.
*
* GVDPHI and GVDCAR have been further improved to compute the scope of pgon.
*                                    Thanks to P.Kent.
*
* GTELEC now computes cross sections for SYNC only if there is mag. field.
*                                    Thanks to M.Maire.
*
* GPCXYZ printing format can now handle bigger dimensions.
*                                    Thanks to S.Ravndal.
*
* GDRMAT and GPRMAT headers are now consistent with GFTMAT. In GPLMAT `STEP'
*    and `RANGE' do not belong anymore to `ALL' as physical processes.
*                                    Thanks to M.Maire, S.Ravndal.
*
* GPHYSI is now setting dray=0 if loss=0. Labs, Sync and Stra can be switched
*    interactively. Decay and Sync are now also defined in vacuum.
*                                    Thanks to M.Maire, S.Ravndal.
*
* In GRNDMQ the ' ' and the 'G' options work now as described in the doc.
*                                    Thanks to S.ONeale, S.Ravndal.
*
* GPART calls GSDK anyhow to give flexibility at run time (for the interactive
*    version). The values relatives to the particles are now updated to
*    Phys.Rev. D50 1173 1994.
*                                    Thanks to S.Ravndal, F.H.Heinsius.
*
* In GDEXCA (Cadint) a bug from 316 is now fixed.
*                                    Thanks to J.Vuoskosky.
*
* GBREME and GSYNC (see the new doc for the meaning of sync=0,1,2,3) have
*    been improved and the two relative mechanism can happen at the same time.
*                                    Thanks to M.Maire.
*
*
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                  Correction version 0.04 = 95a release             *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       28/3/95  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
* In GTCKOV the variable RIN1 is not reset to 0 any longer.
*                                           Thanks to A.Delpozo
*
* In GSTRAC heavy ions have now the correct itrtyp=8.
*                                           Thanks to Yfwang
*
* In GTNEXT the variable SNXT and SNXNEW are compared with BIG1 to cure
*  precision problems.
*                                           Thanks to A.Dellacqua, P.Ward.
*
* In GPVOLU and GPVOLX the variable MOTHER is now declared as CHARACTER*4.
*                                           Thanks to V.Tretyak
*
* In GGCLOS a test on IQUEST(11).le.0 has been changed into IQUEST(11).lt.0.
*                                           Thanks to P.Ward
*
* In GLTRAC nlevel is reset to 0 only if GONLY(NLEVEL).EQ.0.
*                                           Thanks to P.Ward, S.Giani
*
* In GDCGOB a bug on the unit for the angles of spheres has been fixed.
*                                           Thanks to J.Allison
*
* GPRMAT is now protected against floating point exceptions.
*                                           Thanks to R.Ruber
*
* GRNDMQ has been improved storing the seeds.
*                                           Thanks to S.Ravndal.
*
* In GTNINO the time of flight is now updated.
*                                           Thanks to S.Ravndal.
*
* In GXPHYS, GXCS, the interactive facilities have been extended.
*                                           Thanks to M.Maire
*
* GPCXYZ has a corrected format to print.
*                                           Thanks to S.Ravndal
*
* A GUXCS dummy routine has been created to extend the interactive use of COMIS.
*                                           Thanks to M.Maire.
*
* GDPRTR is now able to recognize b/w Xterminals before drawing the tree.
*                                           Thanks to S.Giani, B.Lorazo.
*
* GLVOLU has been corrected in the computation of GTRAN for the slices of
*  divided volumes.
*                                           Thanks to S.Giani.
*
* GXGEOM now allows correctly the definition of the basic shapes interactively.
*                                           Thanks to S.Giani.
*
* GETVER and GINIT are improved to extract and print automatically the version.
*                                           Thanks to M.Maire.
*
* GFTMAT and GPLMAT have been corrected in plotting the cross sections.
*                                           Thanks to S.Ravndal, G.Zholobov.
*
* GLANDZ has been protected against floating point exceptions.
*                                           Thanks to L.Urban, B.Fox.
*
* GLUDKY contains now the time of interaction (Lund).
*                                           Thanks to S.Ravndal, C.Wiebusch.
*
* GPAIRG has been protected against undefined values for the variable X.
*                                           Thanks to L.Urban, H.Ihssen.
*
* GINIT, GFFGO and GTELEC are modified in order to include a new data card,
*  ABAN, which allows to follow the electrons down to the cuts value even
*  when they are not doing physics (ABAN=0) or to propagate them up to the
*  end-point with an optimized algorithm (ABAN=2). The default is ABAN=1
*  (normal 3.21 behaviour).
*                                           Thanks to L.Urban, S.Ravndal.
*
* BRTTP has been protected in case the file flukaaf.dat is not found.
*                                           Thanks to S.Ravndal.
*
* GMORIN has been modified and GMISET has been created in order to interface
*  to the new version of Micap (from Gcalor 1.03.08) which has been introduced
*  in GEANM.
*                                           Thanks to S.Ravndal.
*
* GPRSGG and GBRSGE have been modified to assume constant cross sections
*  above 100 GeV both for pair production and for bremsstrahlung.
*                                           Thanks to G.Battistoni, L.Urban.
*
* GVDPHI has been corrected and improved for the scope computation of tubes,
*  cons and polycons which are rotated and translated at the same time.
*                                           Thanks to S.Giani, J.P.Vialle.

+PATCH, DOC_CMZM_VERSIONS.
+DECK,  V3_16_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:52  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.47  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/00   07/12/93 14.36.37
*
+DECK,  V3_21_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:52  cernlib
* Geant
*
*
*CMZ :  3.21/04 21/03/95  18.11.47  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/04   21/03/95 18.11.47
*
*
*::>          VERSION  3.21/03   17/10/94 15.59.46
*
*
*::>          VERSION  3.21/02   25/07/94 15.19.53
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 17.07.47
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
+PATCH, DOC_CMZH_VERSIONS.
+DECK,  V3_14_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.37  by  S.Giani
*-- Author :
*
*::>          VERSION  3.14/16   901107 15.31
*
*
*      See PATCH,HISTORY for the description of version 3.14
*

+DECK,  V3_15_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.37  by  S.Giani
*-- Author :
*
*::>          VERSION  3.15/05   920408 13.06
*
*
*          ************************************************************
*          *                                                          *
*          *                                                          *
*          *                G E A N T   Version  3.15                 *
*          *                                                          *
*          *            O F F I C I A L     R E L E A S E             *
*          *                                                          *
*          *              CERN, Geneva, April 7, 1992                 *
*          *                                                          *
*          *    The code contained  in this  file comes from the      *
*          *    GHEISHA 8 hadron  shower  generator  program  by      *
*          *    H.Fesefeldt RWTH Aachen.                              *
*          *                                                          *
*          ************************************************************
*
*
*::>          VERSION  3.15/04   920331  8.02
*
*
*::>          VERSION  3.15/03   920329 15.41
*
*
*::>          VERSION  3.15/02   920327 18.51
*
*
*::>          VERSION  3.15/01   920316 10.19
*
*             Prerelease stamping of 3.15
*
+DECK,  V3_16_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.37  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/00   07/12/93 14.35.06
*
+DECK,  V3_21_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :  3.21/04 21/03/95  18.10.55  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/04   21/03/95 18.10.55
*
*
*::>          VERSION  3.21/03   17/10/94 15.27.01
*
*
*::>          VERSION  3.21/02   25/07/94 15.21.40
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 17.06.07
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
+PATCH, DOC_CMZG_VERSIONS.
+DECK,  V3_12_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.25  by  S.Giani
*-- Author :
*
*::>          VERSION  3.12/18   890130  9.40
*
*        Original version 3.12
*
+DECK,  V3_13_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.25  by  S.Giani
*-- Author :
*
*::>          VERSION  3.13/04   890421 10.00
*
*       Cleaning-up of GN..GNO.. routines
*       SAFR1 = 0 protection in GNCONE, GNTUBE
*       New SAFE computation in GNOPGO
*       GMR short circuit in GDAHIT,GDARC,GDCIRC,GDCIRR,GDCIRY,GDCUT,
*        GDLINE and GDRECT
*       Update of documentation in DOCGGEOM
*       Removal of SNXT=BIG in GNEXT
*       Change of Header doc and SNXT=BIG in GNO...,GN.... routines
*       Bug corrected in GNOPAR (return SNXT)
*       Routine GNOPGO corrected for bug in SAFETY computation
*       Routine GGCLOS moved to GEANT Pam
*
*::>          VERSION  3.13/03   890317 16.23
*
*       Routine GNOPGO replaced by new code from R.Nierhaus
*       New routines GNOPG1,etc
**
*::>          VERSION  3.13/02   890313 10.05
*
*       SAVE statements in many routines
*       Mods in GDCXYZ
*

+DECK,  V3_14_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.25  by  S.Giani
*-- Author :
*
*::>          VERSION  3.14/16   901107 15.25
*
*       See PATCH,HISTORY in file GEANT for description
*       of changes in version 3.14
*

+DECK,  V3_15_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.25  by  S.Giani
*-- Author :
*
*::>          VERSION  3.15/08   920408 13.02
*
*
*          ************************************************************
*          *                                                          *
*          *                                                          *
*          *                G E A N T   Version  3.15                 *
*          *                                                          *
*          *            O F F I C I A L     R E L E A S E             *
*          *                                                          *
*          *              CERN, Geneva, April 7, 1992                 *
*          *                                                          *
*          *                                                          *
*          *                                                          *
*          ************************************************************
*
*
*::>          VERSION  3.15/07   920401  8.41
*
*
*::>          VERSION  3.15/06   920331  9.42
*
*
*::>          VERSION  3.15/05   920331  8.01
*
*
*::>          VERSION  3.15/04   920329 15.41
*
*
*::>          VERSION  3.15/03   920329 13.45
*
*
*::>          VERSION  3.15/02   920327 18.50
*
*
*::>          VERSION  3.15/01   920316 10.19
*
*             Prerelease stamping of 3.15
*
+DECK,  V3_16_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.25  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/00   07/12/93 14.34.20
*
+DECK,  V3_21_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:50  cernlib
* Geant
*
*
*CMZ :  3.21/04 21/03/95  18.08.11  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/04   21/03/95 18.08.11
*
*
*::>          VERSION  3.21/03   17/10/94 15.26.31
*
*
*::>          VERSION  3.21/02   25/07/94 15.23.34
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 16.38.21
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
+PATCH, DOC_CMZF_VERSIONS.
+DECK,  V3_16_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:49  cernlib
* Geant
*
*
*CMZ :          29/03/94  15.41.41  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/00   07/12/93 14.39.16
*
************************************************************************
*                                                                      *
*    The GEANT-FLUKA interface                                         *
*                                                                      *
*    Since version  3.15, GEANT  includes an interface  with some      *
*    FLUKA [1,2,3,4,5] routines. This  part has been  updated and      *
*    extended in subsequent releases.                                  *
*                                                                      *
*    FLUKA is  a standalone code with  its own life.  Only  a few      *
*    parts have been included into GEANT, namely the ones dealing      *
*    with hadronic elastic and inelastic interactions.                 *
*                                                                      *
*    The  implementation  of FLUKA  routines  in  GEANT does  not      *
*    include  any change,  apart  from interface  ones and  those      *
*    agreed by the FLUKA authors.  Whenever different options are      *
*    available in  FLUKA, the one  suggested by the  authors have      *
*    been retained.  Nevertheless the results obtained with FLUKA      *
*    routines  inside GEANT  could not  be representative  of the      *
*    full  FLUKA performances,  since  they  generally depend  on      *
*    other parts which are GEANT specific.                             *
*                                                                      *
*    The routines made available  for GEANT have been extensively      *
*    tested  and  are reasonably  robust.   They  usually do  not      *
*    represent the latest FLUKA developments, since the policy is      *
*    to supply  for GEANT  well tested  and reliable  code rather      *
*    than very  recent developments with possibly  better physics      *
*    but also still undetected errors.                                 *
*                                                                      *
*    It is important that GEANT users are aware of the conditions      *
*    at which this code has been kindly made available:                *
*                                                                      *
*     o  relevant   authorship   and   references   about   FLUKA      *
*        [1,2,3,4,5]   should  be   clearly   indicated  in   any      *
*        publication reporting results obtained with this code;        *
*                                                                      *
*     o  the FLUKA authors reserve  the right of publishing about      *
*        the  physical  models  they  developed  and  implemented      *
*        inside FLUKA,  GEANT users  are not supposed  to extract      *
*        from  the  GEANT  -  FLUKA code  the  relevant  routines      *
*        running them standalone for benchmarks;                       *
*                                                                      *
*     o  more generally,  FLUKA routines  contained in  the GEANF      *
*        file are  supposed to  be included  and used  with GEANT      *
*        only:  any other  use must  be authorised  by the  FLUKA      *
*        authors.                                                      *
*                                                                      *
*    [1] A.Fasso, A.Ferrari, J.Ranft, P.R.Sala, G.R.Stevenson and      *
*        J.M.Zazula.  FLUKA92.  In Proceedings of the Workshop on      *
*        Simulating Accelerator Radiation Environments, Santa Fe,      *
*        USA, 11-15 January 1993.                                      *
*                                                                      *
*    [2] A.Fasso, A.Ferrari, J.Ranft, P.R.Sala, G.R.Stevenson and      *
*        J.M.Zazula,  "A  Comparison  of FLUKA  Simulations  with      *
*        measurements   of  Fluence   and  Dose   in  Calorimeter      *
*        Structures", Nuclear  Instruments & Methods A,  332, 459      *
*        (1993), (also CERN divisional report CERN/TIS-RP/93-2/PP      *
*        (1993)).                                                      *
*                                                                      *
*    [3] A.Ferrari  and  P.R.Sala,  "A  New  Model  for  hadronic      *
*        interactions  at  intermediate  energies for  the  FLUKA      *
*        code", presented at the  MC93 Int.  Conf. on Monte-Carlo      *
*        Simulation   in   High-Energy   and   Nuclear   Physics,      *
*        Tallahassee, Florida, 22-26 february (1993), Proceedings      *
*        in press.                                                     *
*                                                                      *
*    [4] P.A.Aarnio, A.Fasso,  A.Ferrari, J.-H.Moehring, J.Ranft,      *
*        P.R.Sala, G.R.Stevenson and J.M.Zazula, "FLUKA: hadronic      *
*        benchmarks and applications", presented at the MC93 Int.      *
*        Conf.  on  Monte-Carlo  Simulation  in  High-Energy  and      *
*        Nuclear  Physics, Tallahassee,  Florida, 22-26  february      *
*        (1993), Proceedings in press.                                 *
*                                                                      *
*    [5] P.A.Aarnio, A.Fasso,  A.Ferrari, J.-H.Moehring, J.Ranft,      *
*        P.R.Sala, G.R.Stevenson and J.M.Zazula, "Electron-photon      *
*        transport: always  so good as we  think? Experience with      *
*        FLUKA", presented at the MC93 Int.  Conf. on Monte-Carlo      *
*        Simulation   in   High-Energy   and   Nuclear   Physics,      *
*        Tallahassee, Florida, 22-26 february (1993), Proceedings      *
*        in press.                                                     *
*                                                                      *
************************************************************************
+DECK,  V3_21_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:49  cernlib
* Geant
*
*
*CMZ :  3.21/04 21/03/95  18.11.33  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/04   21/03/95 18.11.33
*
*
*::>          VERSION  3.21/03   17/10/94 15.26.00
*
*
*::>          VERSION  3.21/02   25/07/94 15.20.37
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 17.07.10
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
*
+PATCH, DOC_CMZE_VERSIONS.
+DECK,  V3_15_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1  1996/03/06 15:31:17  mclareni
* Add geane321 history, CMZ and doc files
*
*
*CMZ :          29/03/94  15.41.49  by  S.Giani
*-- Author :
*
*::>          VERSION  3.15/01   920408 13.09
*
*
*          ************************************************************
*          *                                                          *
*          *                                                          *
*          *                G E A N T   Version  3.15                 *
*          *                                                          *
*          *            O F F I C I A L     R E L E A S E             *
*          *                                                          *
*          *              CERN, Geneva, April 7, 1992                 *
*          *                                                          *
*          *                                                          *
*          *                                                          *
*          ************************************************************
*
*
*::>          VERSION  3.15/00   920319 12.19
*
*             Stamping of the version 3.14/03 as 3.15/00 to prepare
*             for the release.
*
+DECK,  V3_16_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1  1996/03/06 15:31:19  mclareni
* Add geane321 history, CMZ and doc files
*
*
*CMZ :          29/03/94  15.41.49  by  S.Giani
*-- Author :
*
*::>          VERSION  3.16/01   07/12/93 14.35.30
*
+DECK,  V3_21_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1  1996/03/06 15:31:19  mclareni
* Add geane321 history, CMZ and doc files
*
*
*CMZ :  3.21/04 21/03/95  18.11.59  by  S.Giani
*-- Author :
*
*::>          VERSION  3.21/04   21/03/95 18.11.59
*
*
*::>          VERSION  3.21/03   17/10/94 15.23.37
*
*
*::>          VERSION  3.21/02   25/07/94 15.18.32
*
*
*::>          VERSION  3.21/01   28/03/94 16.10.10
*
*
*::>          VERSION  3.21/00   28/02/94 17.17.19
*
**********************************************************************
*                                                                    *
*                       G E A N T   3 . 2 1                          *
*                                                                    *
*                            C E R N                                 *
*                                                                    *
*                       15/3/94  Geneva  CH                          *
*                                                                    *
**********************************************************************
+PATCH, DOC_OBSOLETE.
+DECK,  CSDAT, T=DATA.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:52  cernlib
* Geant
*
*
* *** EXPERIMENTAL CROSS-SECTION DATA ***
PLAB      PI- P/N   PI- P/N   PI+ P/N   PI+ P/N     I  ALL #-SECT.
(GEV/C)   ELASTIC   INELASTIC ELASTIC   INELASTIC   I  IN MB.
------------------------------------------------------------------------
0.        0.        0.        0.        0.        -1.0      -1.0
0.1       1.        3.        6.        0.        -1.0      -1.0
0.15      3.        9.2       20.       0.        -1.0      -1.0
0.2       8.        20.5      71.       0.        -1.0      -1.0
0.25      18.       36.5      155.      0.        -1.0      -1.0
0.3       25.       45.0      195.      0.        -1.0      -1.0
0.35      27.5      28.0      130.      0.        -1.0      -1.0
0.4       12.3      19.5      78.       0.5       -1.0      -1.0
0.45      10.6      15.5      60.       1.2       -1.0      -1.0
0.5       11.0      14.2      32.       1.7       -1.0      -1.0
0.55      12.5      15.5      23.5      2.25      -1.0      -1.0
0.6       14.5      17.5      18.5      3.0       -1.0      -1.0
0.65      17.0      20.0      15.0      3.6       -1.0      -1.0
0.7       19.4      23.0      12.5      4.5       -1.0      -1.0
0.75      19.8      26.0      10.0      5.4       -1.0      -1.0
0.8       16.8      20.0      9.1       6.3       -1.0      -1.0
0.85      14.0      23.0      8.6       8.6       -1.0      -1.0
0.9       14.8      26.5      8.8       9.0       -1.0      -1.0
0.95      20.0      32.0      9.5       10.0      -1.0      -1.0
1.00      26.1      35.0      10.6      11.5      -1.0      -1.0
1.1       19.5      28.5      13.0      14.0      -1.0      -1.0
1.2       15.0      22.0      15.5      17.0      -1.0      -1.0
1.3       12.8      22.5      17.1      19.5      -1.0      -1.0
1.4       11.5      23.5      17.2      22.0      -1.0      -1.0
1.5       10.5      24.0      16.2      24.0      -1.0      -1.0
1.6       9.8       24.5      15.0      21.5      -1.0      -1.0
1.8       8.8       26.0      12.3      18.5      -1.0      -1.0
2.0       8.2       27.5      10.2      19.0      -1.0      -1.0
2.2       7.8       27.5      9.0       20.5      -1.0      -1.0
2.4       7.5       27.0      8.0       22.2      -1.0      -1.0
2.6       7.2       26.5      7.3       23.0      -1.0      -1.0
2.8       7.0       25.5      6.8       23.3      -1.0      -1.0
3.0       6.8       25.0      6.5       23.0      -1.0      -1.0
4.0       6.1       23.0      5.8       21.0      -1.0      -1.0
5.0       5.7       22.5      5.4       20.5      -1.0      -1.0
6.0       5.4       22.2      5.2       20.2      -1.0      -1.0
8.0       4.9       22.0      5.0       20.1      -1.0      -1.0
10.0      4.6       22.0      4.9       20.0      -1.0      -1.0
20.0      4.0       21.2      3.8       20.0      -1.0      -1.0
100.0     3.3       20.7      3.2       20.0      -1.0      -1.0
1000.0    3.5       21.0      3.5       21.0      -1.0      -1.0
PLAB      K-  P/N   K-  P/N   K+  P/N   K+  P/N   K0L P/N   K0L P/N
(GEV/C)   ELASTIC   INELASTIC ELASTIC   INELASTIC ELASTIC   INELASTIC
------------------------------------------------------------------------
0.        300.      400.      10.       0.        100.      300.
0.1       140.      200.      11.2      0.        65.       150.
0.15      97.       120.      11.3      0.        46.       100.
0.2       70.       81.       11.4      0.        35.       70.
0.25      55.       62.       11.5      0.        27.       56.
0.3       45.       47.       11.6      0.        21.       41.
0.35      37.       35.       11.8      0.        18.       30.
0.4       31.       28.       12.       0.        15.       27.5
0.45      26.       24.       12.1      0.        13.       25.
0.5       23.       21.       12.2      0.        11.       22.
0.55      20.       19.5      12.3      0.        9.6       22.5
0.6       17.       19.0      12.4      0.        8.5       21.5
0.65      15.5      18.8      12.5      0.        8.0       21.
0.7       14.5      19.0      12.5      0.        7.6       21.5
0.75      14.7      20.       12.5      0.        8.3       22.5
0.8       18.5      21.       12.4      0.5       9.8       24.5
0.85      22.0      23.       12.3      1.5       10.8      27.
0.9       23.0      25.       12.2      2.7       11.4      29.
0.95      22.5      27.       12.0      3.8       11.0      31.
1.00      20.7      27.5      11.8      4.8       10.3      30.5
1.1       16.5      25.5      11.2      6.5       8.7       27.
1.2       14.0      22.       11.5      7.6       6.0       22.5
1.3       11.5      20.8      9.9       8.4       5.8       21.
1.4       9.6       21.0      9.4       9.0       5.0       21.3
1.5       8.6       23.0      8.8       9.4       4.5       24.
1.6       8.5       24.       8.4       9.8       4.3       25.
1.8       8.3       24.       7.5       10.5      3.9       25.8
2.0       7.6       23.8      6.9       11.0      3.7       25.
2.2       7.0       23.       6.3       11.5      3.5       24.3
2.4       6.4       22.5      5.9       11.8      3.4       23.8
2.6       5.9       22.       5.5       12.2      3.3       23.4
2.8       5.5       21.6      5.2       12.4      3.1       23.
3.0       5.3       21.4      5.0       12.6      3.0       22.6
4.0       4.4       21.       4.0       13.2      2.7       21.4
5.0       4.1       20.5      3.5       13.5      2.4       20.8
6.0       3.9       20.2      3.3       13.7      2.2       20.2
8.0       3.7       19.8      3.1       14.0      2.0       19.8
10.0      3.3       19.5      3.1       14.2      1.8       19.5
20.0      2.6       18.6      3.0       14.5      1.6       19.3
100.0     2.5       17.5      2.5       16.4      1.6       18.5
1000.0    3.0       20.       3.0       17.0      1.8       20.0
PLAB      P   P     P   P     AP  P/N   AP  P/N   N  P      N  P
(GEV/C)   ELASTIC   INELASTIC ELASTIC   INELASTIC ELASTIC   INELASTIC
------------------------------------------------------------------------
0.        1100.     0.        200.      1500.     4200.     0.
0.1       115.      0.        163.      1160.     440.      0.
0.15      105.      0.        141.      310.      420.      0.
0.2       100.      0.        120.      230.      400.      0.
0.25      56.       0.        111.      178.      230.      0.
0.3       40.       0.        99.5      153.      160.      0.
0.35      27.       0.        92.5      134.      105.      0.
0.4       22.       0.        86.5      124.      80.       0.
0.45      21.       0.        82.       113.      62.       0.
0.5       20.       0.        78.       106.      50.       0.
0.55      20.       0.        74.       101.      45.       0.
0.6       20.       0.        71.       96.       41.       0.
0.65      20.5      0.        67.5      92.       38.       0.
0.7       21.0      0.        65.       89.       36.       0.
0.75      22.0      0.        62.5      87.       35.       0.
0.8       23.0      0.        59.7      84.       34.       0.
0.85      24.       0.        58.1      81.       33.       0.
0.9       24.       0.        56.3      78.5      32.       0.
0.95      24.4      0.1       54.7      76.5      31.5      0.1
1.00      24.5      1.5       52.7      75.       31.       1.5
1.1       25.       7.0       50.       72.       30.5      7.0
1.2       25.5      12.       48.4      70.       30.       12.
1.3       26.       17.       47.       68.       29.5      17.
1.4       26.5      19.5      46.       64.5      29.       19.5
1.5       27.       20.5      45.2      63.       28.5      20.5
1.6       27.       22.       42.8      62.       28.       22.
1.8       26.       23.5      39.2      61.       26.       23.5
2.0       23.       24.8      36.3      59.5      23.       24.8
2.2       21.5      25.8      32.8      58.5      21.5      25.8
2.4       20.       26.5      30.4      56.5      20.       26.5
2.6       19.       27.       28.1      56.5      19.       27.
2.8       18.       27.5      26.3      56.       18.       27.5
3.0       17.       28.       24.5      55.5      17.       28.
4.0       13.       30.       19.25     52.       13.       30.
5.0       11.5      31.       16.84     50.       11.5      31.
6.0       10.3      32.       14.60     48.       10.3      32.
8.0       9.4       32.5      12.34     45.       9.4       32.5
10.0      9.0       32.5      11.21     44.       9.0       32.5
20.0      8.80      33.       8.85      39.2      8.8       33.
100.0     7.0       33.5      7.5       34.5      7.0       33.5
1000.0    7.50      34.       7.5       34.5      7.5       34.
PLAB      PI CROSS SECTIONS ON AL, CU, PB
(GEV/C)   AL TOT.   AL INEL.  CU TOT.   CU INEL.  PB TOT.   PB INEL.
------------------------------------------------------------------------
0.        0.        0.        0.        0.        0.        0.
0.1       550.      200.      1100.     400.      2700.     1000.
0.15      900.      320.      1800.     800.      4100.     1900.
0.2       1100.     500.      2200.     1000.     4800.     2600.
0.25      1150.     600.      2400.     1100.     4700.     2900.
0.3       1050.     600.      2500.     1200.     4300.     3000.
0.35      1000.     590.      2400.     1150.     4000.     2800.
0.4       900.      530.      2300.     1050.     3500.     2600.
0.45      850.      510.      2100.     1000.     3400.     2500.
0.5       700.      470.      1900.     900.      3300.     2300.
0.55      650.      430.      1800.     860.      3300.     2200.
0.6       630.      425.      1600.     860.      3300.     2000.
0.65      600.      420.      1550.     850.      3300.     1900.
0.7       580.      425.      1520.     850.      3300.     1880.
0.75      570.      425.      1500.     840.      3350.     1860.
0.8       570.      430.      1500.     830.      3400.     1840.
0.85      590.      430.      1500.     820.      3400.     1820.
0.9       630.      435.      1510.     810.      3500.     1810.
0.95      670.      435.      1540.     805.      3600.     1805.
1.00      690.      440.      1600.     800.      3800.     1800.
1.1       700.      430.      1610.     800.      3850.     1780.
1.2       710.      430.      1620.     800.      3900.     1760.
1.3       720.      420.      1620.     800.      3800.     1750.
1.4       720.      420.      1610.     800.      3750.     1740.
1.5       710.      420.      1600.     800.      3700.     1730.
1.6       700.      415.      1600.     800.      3600.     1720.
1.8       680.      415.      1500.     800.      3400.     1710.
2.0       650.      410.      1400.     800.      3200.     1700.
2.2       640.      410.      1300.     800.      3100.     1680.
2.4       630.      408.      1250.     780.      3050.     1660.
2.6       610.      406.      1200.     760.      3000.     1650.
2.8       600.      404.      1150.     740.      3000.     1640.
3.0       590.      400.      1100.     720.      3000.     1630.
4.0       550.      380.      1050.     720.      2900.     1620.
5.0       510.      340.      1030.     700.      2900.     1610.
6.0       500.      340.      1020.     690.      2900.     1605.
8.0       490.      340.      1010.     680.      2850.     1600.
10.0      480.      340.      1000.     670.      2800.     1600.
20.0      460.      340.      950.      665.      2600.     1550.
100.0     420.      340.      900.      660.      2400.     1500.
1000.0    420.      340.      900.      660.      2400.     1500.
PLAB      P  CROSS SECTIONS ON AL, CU, PB
(GEV/C)   AL TOT.   AL INEL.  CU TOT.   CU INEL.  PB TOT.   PB INEL.
------------------------------------------------------------------------
0.        2100.     0.        3800.     0.        7000.     0.
0.1       2000.     200.      3300.     400.      6000.     0.
0.15      1900.     400.      2800.     950.      5000.     500.
0.2       1850.     800.      2600.     1050.     4800.     1450.
0.25      1700.     800.      2500.     1050.     4400.     1700.
0.3       1500.     550.      2500.     980.      4800.     1800.
0.35      1300.     500.      2400.     940.      5300.     1750.
0.4       1100.     450.      2200.     900.      5700.     1730.
0.45      1000.     430.      2000.     860.      5000.     1720.
0.5       800.      410.      1700.     820.      4200.     1710.
0.55      700.      400.      1500.     800.      3800.     1700.
0.6       630.      390.      1400.     780.      3200.     1690.
0.65      610.      380.      1300.     760.      3100.     1660.
0.7       600.      370.      1300.     740.      3000.     1630.
0.75      590.      370.      1200.     740.      3000.     1630.
0.8       590.      370.      1200.     740.      3000.     1630.
0.85      590.      365.      1200.     730.      3000.     1600.
0.9       590.      365.      1200.     730.      3000.     1600.
0.95      600.      360.      1200.     720.      3000.     1580.
1.00      600.      360.      1200.     720.      3000.     1580.
1.1       650.      360.      1300.     720.      3020.     1580.
1.2       690.      360.      1320.     720.      3040.     1580.
1.3       700.      365.      1340.     730.      3060.     1600.
1.4       720.      370.      1360.     740.      3080.     1630.
1.5       730.      375.      1370.     750.      3100.     1650.
1.6       750.      380.      1380.     760.      3140.     1670.
1.8       750.      400.      1390.     800.      3160.     1760.
2.0       740.      410.      1400.     820.      3200.     1800.
2.2       730.      420.      1280.     820.      3180.     1800.
2.4       720.      430.      1260.     820.      3170.     1800.
2.6       710.      440.      1240.     820.      3160.     1800.
2.8       705.      440.      1220.     820.      3150.     1800.
3.0       700.      440.      1300.     820.      3140.     1800.
4.0       670.      440.      1250.     820.      3130.     1800.
5.0       650.      440.      1200.     820.      3120.     1800.
6.0       650.      440.      1200.     820.      3110.     1800.
8.0       640.      440.      1200.     820.      3105.     1800.
10.0      640.      440.      1200.     820.      3100.     1800.
20.0      630.      440.      1200.     820.      3100.     1800.
100.0     620.      440.      1200.     820.      3100.     1800.
1000.0    620.      440.      1200.     820.      3100.     1800.
EKIN      N  TOTAL AND REACTION CROSS SECTIONS AT LOW ENERGIES
(GEV)     N  P      N  P      N O       N O       N AL      N AL
          TOTAL     INELASTIC TOTAL     INELASTIC TOTAL     INELASTIC
---------------------------------------------------------------------
0.0001    6000.     0.        5400.     0.        5500.     0.
0.0002    5500.     0.        5050.     0.        5150.     0.
0.0003    5200.     0.        4800.     0.        4900.     0.
0.0004    4900.     0.        4600.     0.        4700.     1.
0.0005    4800.     0.        4400.     1.        4500.     10.
0.0007    4400.     0.        4100.     10.       4200.     50.
0.001     4000.     0.        3750.     50.       3850.     100.
0.002     2900.     0.        2700.     100.      3050.     260.
0.003     2200.     0.        2150.     200.      2550.     450.
0.004     1800.     0.        1900.     300.      2250.     600.
0.005     1400.     0.        1700.     400.      2000.     700.
0.007     1100.     0.        1500.     600.      1750.     800.
0.01      900.      0.        1400.     700.      1700.     900.
0.015     700.      0.        1550.     750.      1800.     940.
0.02      600.      0.        1750.     700.      1900.     900.
0.025     560.      0.        1950.     700.      1950.     860.
0.0327    520.      0.        2000.     680.      1900.     820.
EKIN      N  TOTAL AND REACTION CROSS SECTIONS AT LOW ENERGIES
(GEV)     N  FE     N  FE     N NI      N NI      N CU      N CU
          TOTAL     INELASTIC TOTAL     INELASTIC TOTAL     INELASTIC
---------------------------------------------------------------------
0.0001    5500.     1.        5400.     1.        5100.     1.
0.0002    5050.     80.       4800.     90.       4500.     95.
0.0003    4650.     200.      4400.     220.      4050.     225.
0.0004    4400.     320.      4100.     340.      3800.     345.
0.0005    4150.     400.      3880.     420.      3550.     425.
0.0007    3900.     520.      3700.     550.      3250.     555.
0.001     3600.     700.      3450.     720.      3100.     750.
0.002     3400.     1000.     3350.     1080.     3000.     1150.
0.003     3500.     1120.     3150.     1300.     3080.     1500.
0.004     3550.     1200.     3250.     1400.     3500.     1680.
0.005     3500.     1200.     3550.     1420.     3750.     1700.
0.007     3300.     1200.     3750.     1420.     3900.     1690.
0.01      2900.     1180.     3500.     1380.     3550.     1550.
0.015     2500.     1130.     2900.     1260.     2950.     1360.
0.02      2300.     1100.     2500.     1190.     2550.     1240.
0.025     2150.     1090.     2250.     1150.     2300.     1180.
0.0327    1950.     1080.     2150.     1100.     2160.     1120.
EKIN      N  TOTAL AND REACTION CROSS SECTIONS AT LOW ENERGIES
(GEV)     N  ZR     N  ZR     N CD      N CD      N SN      N SN
          TOTAL     INELASTIC TOTAL     INELASTIC TOTAL     INELASTIC
---------------------------------------------------------------------
0.0001    6300.     10.       6900.     15.       6600.     0.
0.0002    6100.     140.      6800.     150.      6500.     0.
0.0003    5900.     260.      6650.     300.      6400.     0.
0.0004    5750.     380.      6550.     400.      6250.     1.
0.0005    5600.     450.      6500.     500.      6200.     10.
0.0007    5400.     600.      6350.     650.      6100.     150.
0.001     5000.     750.      6200.     840.      5900.     380.
0.002     4350.     1200.     5750.     1500.     5250.     1000.
0.003     4050.     1580.     4900.     2100.     4400.     1650.
0.004     3900.     1800.     4000.     2130.     4000.     2100.
0.005     4050.     1820.     3950.     2140.     3950.     2100.
0.007     4250.     1830.     3950.     2130.     4050.     2100.
0.01      4250.     1800.     4250.     2080.     4400.     2060.
0.015     3800.     1750.     4450.     2000.     4750.     1950.
0.02      3450.     1690.     4100.     1950.     4400.     1860.
0.025     3200.     1650.     3600.     1900.     3900.     1800.
0.0327    2950.     1620.     3250.     1860.     3500.     1740.
EKIN      N  TOTAL AND REACTION CROSS SECTIONS AT LOW ENERGIES
(GEV)     N  I      N  I      N BA      N BA      N TA      N TA
          TOTAL     INELASTIC TOTAL     INELASTIC TOTAL     INELASTIC
---------------------------------------------------------------------
0.0001    7400.     0.        7900.     0.        7900.     0.
0.0002    7200.     0.        7700.     0.        7750.     0.
0.0003    7000.     1.        7500.     1.        7700.     1.
0.0004    6850.     10.       7400.     10.       7600.     10.
0.0005    6700.     45.       7250.     48.       7500.     50.
0.0007    6500.     180.      7000.     190.      7400.     200.
0.001     6200.     380.      6750.     390.      7250.     400.
0.002     5450.     1050.     6000.     1080.     6750.     1100.
0.003     4750.     1900.     5450.     2000.     6500.     2100.
0.004     4300.     2300.     5000.     2400.     6200.     2500.
0.005     4100.     2300.     4600.     2400.     5900.     2500.
0.007     4000.     2200.     4250.     2300.     5250.     2450.
0.01      4300.     2150.     4500.     2200.     5000.     2300.
0.015     4600.     2000.     4900.     2100.     5200.     2100.
0.02      4250.     1900.     4600.     1950.     5250.     2000.
0.025     3750.     1800.     4100.     1850.     5000.     1900.
0.0327    3850.     1750.     3850.     1800.     4600.     1850.
EKIN      N  TOTAL AND REACTION CROSS SECTIONS AT LOW ENERGIES
(GEV)     N  PB     N  PB     N BI      N BI      N U       N U
          TOTAL     INELASTIC TOTAL     INELASTIC TOTAL     INELASTIC
---------------------------------------------------------------------
0.0001    6100.     0.        6100.     0.        6600.     0.
0.0002    5950.     0.        5950.     0.        6350.     0.
0.0003    5750.     0.        5750.     0.        6100.     0.
0.0004    5600.     1.        5600.     1.        5900.     1.
0.0005    5450.     10.       5450.     10.       5700.     10.
0.0007    5300.     100.      5300.     100.      5400.     100.
0.001     5150.     350.      5150.     350.      5250.     400.
0.002     5200.     900.      5200.     900.      5400.     950.
0.003     7200.     1400.     7200.     1400.     7250.     1600.
0.004     7750.     2000.     7750.     2000.     7900.     2200.
0.005     7100.     2300.     7100.     2300.     7500.     2550.
0.007     5800.     2380.     5800.     2380.     6600.     2750.
0.01      5050.     2400.     5050.     2400.     5750.     2700.
0.015     5500.     2300.     5500.     2300.     5650.     2600.
0.02      5900.     2250.     5900.     2250.     6000.     2540.
0.025     5700.     2200.     5700.     2200.     6100.     2450.
0.0327    5100.     2120.     5100.     2120.     5700.     2360.
     NEUTRON CAPTURE CROSS SECTIONS AT 65 KEV ENERGY (IN MB).
    Z     1         2         3         4         5         6
---------------------------------------------------------------------
  1 - 6   6.        5.7       5.5       5.3       5.2       5.1
  7 -12   5.0       4.9       4.8       4.8       4.8       4.8
 13 -18   4.8       4.8       4.8       4.8       4.9       5.0
 19 -24   5.2       5.5       6.0       6.7       7.5       8.5
 25 -30   10.0      12.0      14.5      19.0      26.5      40.0
 31 -36   75.0      120.0     180.0     260.0     360.0     330.0
 37 -42   60.0      7.0       9.5       20.0      75.0      140.0
 43 -48   250.0     360.0     480.0     580.0     590.0     500.0
 49 -54   300.0     100.0     200.0     300.0     400.0     470.0
 55 -60   500.0     430.0     100.0     20.0      22.0      40.0
 61 -66   560.0     950.0     1000.0    1000.0    1000.0    990.0
 67 -72   920.0     860.0     790.0     740.0     650.0     600.0
 73 -78   540.0     470.0     440.0     390.0     360.0     340.0
 79 -84   320.0     310.0     280.0     2.0       2.5       6.0
 85 -90   13.0      38.0      65.0      140.0     280.0     300.0
 91 -96   430.0     580.0     650.0     800.0     920.0     1100.0
 97 -100  1250.0    1400.0    1550.0    1700.0
     FISSION CROSS SECTIONS FOR U(233),U(235),U(238),PU(239)
     IN THE ENERGY INTERVALL FROM 100 KEV - 10 MEV
  EK(GEV) U(233)    U(235)    PU(239)   U(238)
 ---------------------------------------------------
  0.0001  2600.     1850.     1700.     0.
  0.0002  2300.     1400.     1650.     0.
  0.0003  2300.     1300.     1650.     0.
  0.0005  2100.     1150.     1700.     0.
  0.0007  2000.     1100.     1700.     0.
  0.001   1950.     1200.     1800.     0.
  0.0015  1930.     1250.     1900.     250.
  0.002   1900.     1300.     2000.     550.
  0.003   1800.     1250.     1950.     550.
  0.005   1600.     1150.     1800.     550.
  0.007   2100.     1600.     2150.     550.
  0.01    2300.     1900.     2450.     550.
  0.015   -1.0      -1.0      -1.0      1000.
  0.02    -1.0      -1.0      -1.0      1400.
  0.05    -1.0      -1.0      -1.0      1600.
  0.1     -1.0      -1.0      -1.0      1500.
  0.2     -1.0      -1.0      -1.0      1400.
  0.3     -1.0      -1.0      -1.0      1300.
  0.4     -1.0      -1.0      -1.0      1200.
  0.5     -1.0      -1.0      -1.0      1100.
 1000.    -1.0      -1.0      -1.0      1000.
END OF DATA
+PATCH, DOC_HISTORY.
+DECK,  GEANE321_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1  1996/03/06 15:31:21  mclareni
* Add geane321 history, CMZ and doc files
*
*
*CMZ :  3.21/02 29/03/94  15.41.49  by  S.Giani
*-- Author :
*
*   V 3.15/02
*     07-04-93 :  new error trasformation routines,
*                 TRSDPT, TRSCPT,  TRPTSD,  TRPTSC added
*                 to go from 1/p ....   to 1/p_t   and viceversa
*                 in both  sd and sc systems
*     07-04-93 : ERTRGO and ERTRCH:  precision checks added
*     16-05-91 : EUFILV modified: NAMV --> CNAMV character*4
*   V 3.14/03
*     02-02-91 : EREXAM2 improved:
*                Transport matrix test added;
*                Random generation of momentum and charge in GUKINE
*                allowed.
*     01-02-91 : effect of energy loss added in TRPRFN
*                (and little bug introduced on 14-12-90 corrected)
*   V 3.14/02
*     24-01-91 : bug corrected in ERMCSC (and log term removed)
                 add fit examples in EREXAM2
*     20-12-90 : CMZ install kumac added
*     19-12-90 : add 2 running examples : P = EREXAM1 and EREXAM2.
*                Mod in ERPROP : EF(1) for low energy
*     18-12-90 : bug in ERLAND : emax must be in kev.
*                       ERTRCH : dedx2*(charge**4)
*                ERMCSC corrected for the log term
*     14-12-90 : TRPRFN modified to improve timing
*   V 3.14/01
*      5-12-90 : doc updated (interface to Geant)
*      3-12-90 : new logic for volume and plane crossing allowing any
*                crossing order . The order of the predicted point in
*                ERXOUT( ,ILPRED) etc... may be different of the order
*                in the input list ERPLO( ,INLIST) etc..The relation
*                is given by the array IEPRED (ILPRED) = INLIST
*     29-11-90 : ERTRGO and ERTRCH rewritten : compute energy loss
*                from the stopping range (bank JRANG) ===> Geane is
*                compatible only with geant3.14
*                MXNSTP = maximum number of steps allowed (1000).
*                zeroed ERXOUT,ERPOUT,ERROUT.
*     27-11-90 : normalize the normal to the plane (routine EUFILP)
*     21-11-90 : change IF=DOUBLE to IF=-SINGLE (standart in Geant3)
*     19-11-90 : changes in ERTRGO,ERTRNT,ERTRCH for use of GTMEDI
*                and GTNEXT  ===> Geane in no more compatible with
*                geant3.11
*      2-11-90 : Integer NEXT  MXPRED
*      4- 9-89 : corrections in ERTRCH and ERTRNT for the case
*                         SNEXT = STEPER
*
*   V 3.13/01  (29-6-89) strictly identical to 3.12
*   V 3.12/04  released on the first september 1988
*
*         version compatible GEANT311 AND GEANT312  :
*         the routine GNEXT must be in the GEANT library
*
+DECK,  GEANX321_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
*
*
* This directory was created from geanx321.car patch history
*CMZ :  3.21/02 29/03/94  15.41.33  by  S.Giani
*-- Author :
*
*                     29-8-1990
*
*          Commands SCAN/SLIST changed to provide a list of SCAN volumes
*          if no argument is given and to delete SCAN bank if a '.' is
*          entered as the only argument. Interactive check of the existence
*          of the volumes entered
+DECK,  H_V_314, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
+CDE, CERNLIB_MACHINE.

C   09-FEB-1988 NVE CERN GENEVA
C               NUMBER OF SUBSCRIPTS OF ARRAY "PCM" CHANGED FROM 1
C               TO 2 IN EQUIVALENCE STATEMENT IN ROUTINE PHASP.
C   17-FEB-1988 NVE CERN GENEVA
C               ALL CALLS TO "RN" CHANGED TO "RNDM" AND WITHIN A DO
C               LOOP THE DUMMY ARGUMENT HAS BEEN SET TO THE LOOP
C               INDEX IN ORDER TO ENABLE COMPILATION WITH OPTIMIZATION
C   25-FEB-1988 NVE CERN GENEVA
C               STATEMENT FUNCTION SEQUENCES "ANPOL" AND "ANPOL" ADDED
C   25-FEB-1988 NVE CERN GENEVA
C               SEQUENCE "ANPOL" INCLUDED IN "STEEQ" AND "STPAIR"
C   26-FEB-1988 NVE CERN GENEVA
C               SEQUENCE "LIMITS" ADDED FOR ARGUMENTS OF INT. FUNCTIONS
C   01-MAR-1988 NVE CERN GENEVA
C               ALL CALLS TO "HSTORY" REMOVED
C   04-MAR-1988 NVE CERN GENEVA
C               +SELF MATERIAL ADDED TO ENABLE SUBROUTINE TIMING
C   16-MAR-1988 NVE CERN GENEVA
C               NEW "SAVE" CARD AND INIT. FOR "PMUL" AND "ANORM"
C               IN CASCADE ROUTINES
C   16-MAR-1988 NVE CERN GENEVA
C               DIMENSION OF "ANORM1" CHANGED FROM (4,60) TO (2,60)
C               IN ROUTINE CASASM
C   16-MAR-1988 NVE CERN GENEVA
C               "REAL*8" AND "REAL*4" REPLACED BY "DOUBLE PRECISION"
C               AND "REAL" RESP. IN ROUTINE "PHASP"
C   16-MAR-1988 NVE CERN GENEVA
C               "REAL*8" REMOVED IN ROUTINE "PDK"
C               FOR DOUBLE PRECISION USE "DPDK"
C   16-MAR-1988 NVE CERN GENEVA
C               "SQRT(A)" REPLACED BY "SQRT(ABS(A))" IN "GENXPT"
C   18-MAR-1988 NVE CERN GENEVA
C               GHEISHA UTILITIES ADDED IN PATCH "GHUTILS"
C   18-MAR-1988 NVE CERN GENEVA
C               NEW PATCHES "TIFACE, TATINA, GIFACE AND CASCAD"
C               ADDED TO BE COMPLETED IN FUTURE
C   29-MAR-1988 NVE CERN GENEVA
C               DECK "VECSUB" CLEANED UP AND ALL "ENTRIES" RE-WRITTEN
C               AND CHANGED TO "SUBROUTINES"
C   29-MAR-1988 NVE CERN GENEVA
C               "DCOS" "DSIN" AND "DSQRT" CHANGED TO "COS" "SIN"
C               AND "SQRT" RESP. IN ROUTINE "PHASP"
C   29-MAR-1988 NVE CERN GENEVA
C               "DPDK" "DLPSOR" AND "DOTES2" PUT IN SEPARATE DECKS
C   29-MAR-1988 NVE CERN GENEVA
C               "REAL*8" CHANGED TO "DOUBLE PRECISION" IN SEQ. /GENIO
C   30-MAR-1988 NVE CERN GENEVA
C               PROTECTIONS AGAINST "EXP()" LIMITS ADDED IN REMAINING
C               CASCADE ROUTINES
C   30-MAR-1988 NVE CERN GENEVA
C               PROTECTIONS AGAINST "DIVISION BY ZERO" ADDED IN
C               ROUTINE "TWOCLU"
C   06-APR-1988 NVE CERN GENEVA
C               "GPGHEI" CHANGED IN ORDER TO MATCH GEANT 3.12
C   07-APR-1988 NVE CERN GENEVA
C               SPECIFIC FUNCTIONS "AMAX1" AND "ALOG" REPLACED BY
C               THEIR GENERIC EQUIVALENTS AND
C               GEOMETRICAL CROSS-SECTIONS FOR NUCLEAR FRAGMENTS ADDED
C               IN ROUTINE "GHESIG"
C   11-APR-1988 NVE CERN GENEVA
C               PROTECTIONS AGAINST "EXP()" LIMITS ADDED IN ROUTINE
C               "CINEMA" AND "ALOG" CALLS CHANGED TO CALLS TO
C               GENERIC FUNCTION "LOG"
C   11-APR-1988 NVE CERN GENEVA
C               PROTECTIONS AGAINST NEGATIVE SQRT ADDED IN
C               ROUTINE "TWOCLU"
C   14-APR-1988 NVE CERN GENEVA
C               ARGUMENT OF "RNDM" SET TO LOOP INDEX
C               IN ROUTINE "NORMAL"
C   22-APR-1988 NVE CERN GENEVA
C               ALL CALLS TO "ALOG" "IABS" "DCOS" AND "DEXP"
C               CHANGED TO THE GENERIC EQUIVALENTS
C   02-MAY-1988 NVE CERN GENEVA
C               ROUTINES "GENXPT" AND "TWOCLU" CORRECTED FOR LOW
C               ENERGY BEHAVIOUR
C   02-MAY-1988 R. BRUN/NVE CERN GENEVA
C               STMT. "GO TO 38" CHANGED TO "GO TO 30" IN ROUTINE
C               "GENXPT" TO PREVENT INFINITE LOOPING
C   02-MAY-1988 NVE CERN GENEVA
C               ALL "IPV(..)" STUFF CHANGED TO NORMAL "PV(..)"
C               IN ROUTINE "ADD"
C   04-MAY-1988 NVE CERN GENEVA
C               FUNCTIONS "RMASS" AND "CHARGE" REPLACED BY ARRAYS
C               "RMASS" AND "RCHARG" RESP. AND PUT INTO COMMON /CONSTS
C               MASSES AND CT VALUES OF PARTICLES UPDATED TO LATEST
C               (= GEANT) VALUES AND INITIALIZED IN ROUTINE "GHEINI"
C   04-MAY-1988 NVE CERN GENEVA
C               DISTINCTION INTRODUCED BETWEEN P AND N TARGET IN ALL
C               "CAS..." ROUTINES AND S AND RS COMPUTED ACCORDINGLY
C               IN THE ROUTINES THEMSELVES
C               THE SAME HAS BEEN DONE IN ROUTINE "TWOB"
C   04-MAY-1988 NVE CERN GENEVA
C               CORRECT MASSES INTRODUCED FOR THE VARIOUS PROCESSES
C               IN THE ABSORBTION AND ANNIHILATION ROUTINES
C   06-MAY-1988 NVE CERN GENEVA
C               EXTRA ARGUMENT "NFL" ADDED IN ROUTINE "CORANH"
C               TO INDICATE TARGET TYPE
C   10-MAY-1988 NVE CERN GENEVA
C               OLD VERSION (GEANT 3.11) OF "GHESIG" RESTORED AND
C               ONLY SLIGHTLY MODIFIED TO INCLUDE GEOMETRICAL X-SECT.
C               OF LIGHT MASS FRAGMENTS
C               THE NEW VERSION OF GHESIG IS CONTAINED IN DECK "GHESIX"
C               ON THIS PAM IN ORDER TO BE INVESTIGATED
C   11-MAY-1988 NVE CERN GENEVA
C               K0/K0 BAR CHOICE REMOVED FROM "GHESIG" TO AVOID
C               UNPHYSICAL RESULTS
C               THE K0/K0 BAR CHOICE IS NOW MADE RIGHT AFTER THE
C               CREATION OF THE K0 IN ROUTINE "GHEISH"
C   11-MAY-1988 NVE CERN GENEVA
C               NUCLEAR MASSES OF D, T AND ALPHA RE-COMPUTED
C               TAKING INTO ACCOUNT BINDING ENERGIES AND NEW VALUES
C               USED IN "GHEINI"
C               THESE NEW VALUES WILL ALSO BE USED IN GEANT AND THEY
C               AGREE WITH PARTICLE DATA 1986
C   11-MAY-1988 NVE CERN GENEVA
C               FLAG "NUCFLG" INTRODUCED IN ROUTINES "CASFRG" AND
C               "GNSLWD" TO INDICATE ACTION TAKEN BY "NUCREC" CALL
C   11-MAY-1988 NVE CERN GENEVA
C               CALL TO "COSCAT" ADDED IN ROUTINE "CASFRG" IN CASE
C               THE "NUCREC" CALL DID NOT GIVE ANY ACTION
C   18-MAY-1988 NVE CERN GENEVA
C               DOUBLE COUNTING OF EDEPS FOR STOPPING PARTICLES
C               FIXED (GHEISH AND GHSTOP) AND NEW STEERING FOR
C               LOW ENERGY NUCLEONS IN "GHEISH"
C   18-MAY-1988 NVE CERN GENEVA
C               BUGS FIXED FOR LOW MOMENTUM AND CALL TO "ATOMAS"
C               REPLACED BY "RMASS" ASSIGNMENTS FOR P, N, D, T AND
C               ALPHA IN ROUTINE "NUCREC"
C   19-MAY-1988 NVE CERN GENEVA
C               MORE ACCURATE VALUES OF MASSES OF D AND ALPHA USED
C               IN ROUTINE "ATOMAS"
C   20-MAY-1988 NVE CERN GENEVA
C               PARTICLE MASSES, CHARGES AND CT VALUES FOR GHEISHA
C               DIRECTLY TAKEN FROM THE GEANT ZEBRA BANKS IN
C               ROUTINE "GHEINI"
C   25-MAY-1988 NVE CERN GENEVA
C               COMMON "/CSDATC" REMOVED AND SEQUENCES "/CSDIM"
C               AND "/CSDAT" INTRODUCED FOR CROSS SECTION DATA IN
C               ORDER TO SAVE MEMORY SPACE
C               THESE SEQUENCES ARE INCLUDED IN ROUTINES "GHESIG"
C               AND "PCSDAT"
C   15-JUN-1988 NVE CERN GENEVA
C               SEQUENCES "PCODIM" AND "PCODAT" INTRODUCED FOR
C               CENTRALISED GEANT/GHEISHA PARTICLE CODE CONVERSION
C               THESE SEQUENCES ARE INCLUDED IN ROUTINES "GHESIG"
C               AND "GHEISH"
C   15-JUN-1988 NVE CERN GENEVA
C               FOLLOWING UNUSED SEQUENCES REMOVED
C               /BEAM  /CALSTR /CBRDK /CMUEL  /CPADE /CQINT  /EQUAT
C               /INPEV /MALARR /MUPAC /PARCOM /SCINT /STEPSI
C   15-JUN-1988 NVE CERN GENEVA
C               ARRAY "IBAR(33)" REMOVED FROM ROUTINE "GHEISH"
C   23-JUN-1988 R.BRUN/NVE CERN GENEVA
C               STMT. "KKPART=KPART" ADDED AT THE BEGINNING OF
C               ROUTINE "GHEISH" TO PREVENT INFINITE LOOP FOR
C               PARTICLE OF ZERO MOMENTUM
C   23-JUN-1988 NVE CERN GENEVA
C               ALL VARIABLES "THENVE" RENAMED TO "RTHNVE" TO MATCH
C               NEW IBM COMPILER (= ANSI STANDARD ?)
C   29-JUN-1988 NVE CERN GENEVA
C               NAME OF ROUTINE "LENGTH" AND RELATED CALLS CHANGED
C               TO "LENGTX" TO AVOID CLASH WITH INTERNAL ROUTINE
C               ON THE CRAY COMPUTER
C   12-JUL-1988 NVE CERN GENEVA
C               INELASTICITY FOR HADRONIC INTERACTIONS RE-CALCULATED
C               AND CHANGES MADE IN ROUTINE "CINEMA" ACCORDINGLY
C   13-JUL-1988 NVE CERN GENEVA
C               IPV(...) STUFF REMOVED AND CALL TO "RNDM" CHANGED
C               TO "RANRES" IN ROUTINE "COSCAT"
C               ALSO PROTECTION FOR "SINT" INCLUDED IN "COSCAT"
C   13-JUL-1988 NVE CERN GENEVA
C               FUNCTION "RANRES" ADDED TO PATCH "GHEISHA"
C   01-AUG-1988 NVE CERN GENEVA
C               BUG FIXED IN PARTICLE DISTRIBUTION IN BACKWARD
C               AND FORWARD HEMISPHERE IN ROUTINE "TWOCLU"
C               THIS ALSO AVOIDS INFINITE LOOPING FOR HIGH MULT.
C   15-AUG-1988 NVE CERN GENEVA
C               SETTING OF MECHANISM "STOP" SUPRESSED IN "GHSTOP"
C               TO AVOID DOUBLE SETTING.
C   16-JAN-1989 NVE CERN GENEVA
C               CONDITIONAL CALL TO "GHEINI" ADDED IN ROUTINE "GHEISH"
C               TO ENSURE PROPER INITIALIZATION IN ALL CASES.
C   19-JAN-1989 NVE CERN GENEVA
C               INITIALIZATION OF IPA(...) ARRAY ADDED IN ROUTINES
C               "GHEISH" AND "GNSLWD" BY "CALL VZERO(IPA(1),100)"
C               TO MATCH THE ROUTINE "GENXPT"
C   31-JAN-1989 NVE CERN GENEVA
C               PRINT STATEMENT IN "EXNU" MADE MORE CLEAR
C   01-FEB-1989 NVE CERN GENEVA
C               PARTICLE CODES ARRAY "IKPART" EXTENDED
C               TO SIZE (35) IN SEQUENCE "PCODIM"
C               AND OMEGA AND ANTI-OMEGA ADDED TO GHEISHA CODES
C               AT POS. 33 AND 34 RESP. IN SEQUENCE "PCODAT"
C               ALSO ARRAYS "RMASS" AND "RCHARG" EXTENDED IN SIZE
C               IN "/CONSTS"
C               OMEGA AND ANTI-OMEGA PARAMETERS ALSO ADDED IN "GHEINI"
C   01-FEB-1989 NVE CERN GENEVA
C               ROUTINES "GHESIG", "GHESIX" AND "GHEISH"
C               UPDATED FOR OMEGA AND ANTI-OMEGA PARTICLES
C               ALSO SIZE OF "CSEL" AND "CSIN" ARRAYS EXTENDED
C               IN "/CSDIM" AND "/CSDAT" UPDATED ACCORDINGLY BY
C               CHANGE IN ROUTINE "PCSDAT" OF PATCH "GHUTILS"
C   02-FEB-1989 NVE CERN GENEVA
C               DECKS "CASXM" "CASX0" "CASOM" "CASAXM" "CASAX0"
C               AND "CASAOM" ADDED TO TREAT THE CASCADES OF
C               XI-, XI0, OMEGA- AND THEIR ANTI-PARTICLES.
C               THE CASCADE ROUTINES FOR THE ANTI-PARTICLES ARE
C               FIXUPS FOR THE MOMENT, BUT CORRECT ROUTINES ARE
C               UNDER DEVELOPMENT.
C   16-FEB-1989 RB CERN GENEVA
C               ALL "RNDM" STUFF REPLACED BY NEW GEANT RANDOM NUMBER
C               GENERATOR "GRNDM"
C   13-MAR-1989 NVE CERN GENEVA
C               ALL CHANGES MADE BY RENE BRUN CHECKED AND SOME
C               SERIOUS MISTAKES FIXED
C   17-MAR-1989 NVE CERN GENEVA
C               CALCULATIONS FOR HADRONIC CROSS SECTIONS RE-DONE
C               AND NEW FUNCTION "GHESIG" ADDED IN PATCH "GIFACE"
C               THE OLD VERSION IS STILL AVAILABLE IN DECK "GHESIX"
C               FOR BACKWARD COMPATIBILITY TESTS
C   20-MAR-1989 NVE CERN GENEVA
C               CORRECT INTERPOLATIONS AND EXTRAPOLATIONS IN
C               ROUTINES "STEEQ" AND "STPAIR"
C               ALSO ALL "ANPOL" AND "ANPOL2" STUFF REMOVED
C   31-MAR-1989 NVE CERN GENEVA
C               PARTICLE MASSES FOR PACKAGES OTHER THAN "GEANT" UPDATED
C               ACCORDING TO PART. DATA 1986 IN ROUTINE "GHEINI"
C   23-MAY-1989 NVE CERN GENEVA
C               "DIMENSION PR(50)" CHANGED TO "DIMENSION PR(*)"
C               IN ROUTINE "ROTES2"
C   29-MAY-1989 R.Brun
C               Protection of all SQRT against <0
C               GRNDM changed to 2 arguments only
C   12-JUN-1989 NVE CERN GENEVA
C               "COST" PROTECTION RESTORED IN "GMUNU"
C   13-JUN-1989 H.FESEFELDT
C               Corrections in GHESIG/GHESIX for ACC40
C               R.B, FCA,F.B
C               Protection in GHESIG for IPART>48
C   29-JUN-1989 RB/NVE CERN GENEVA
C               MASSES UPDATED IN GHEINI ACCORDING TO PART. DATA APR-1988
C               AND PROTECTION AGAINST PRECISION PROBLEMS OF EK AND EDEP
C               IN GHEISH
C   29-JUN-1989 NVE CERN GENEVA
C               MASSES TAKEN FROM GEANT PARTICLE DATA BANKS IN
C               GMUNU, GMUNUI AND GMUSIG
C               AND MASSES TAKEN FROM "RMASS" ARRAY IN ATOMAS
C   29-JUN-1989 RB CERN GENEVA
C               "PDK" AND "DPDK" RENAMED TO "GPDK" AND "GDPDK" RESP.
C               BECAUSE OF CONFLICT WITH NEW CERNLIB ROUTINES
C               AND CALLS IN "PHASP" UPDATED ACCORDINGLY
C   29-JUN-1989 NVE CERN GENEVA
C               OBSOLETE ROUTINE "GHESIX" REMOVED FROM PATCH "GIFACE"
C   04-JUL-1989 NVE CERN GENEVA
C               PROTECTION AGAINST ANNIHILATION PROCESSES INTRODUCED
C               IN "STPAIR"
C   18-AUG-1989 NVE CERN GENEVA
C               PROTECTION FOR NGKINE .GT. 100 ADDED IN "GHEISH"
C               AND ALSO PROTECTIONS ADDED IN "SETTRK"
C   14-SEP-1989 HF RWTH AACHEN
C               CORRECTED IPARM SETTING IN "CINEMA"
C   05-MAR-1990 HF RWTH AACHEN
C               DOUBLE PRECISION RESTORED FOR PHASE SPACE PACKAGE
C               AND PHOTO-FISSION AND ABSORBTION PROCESSES MODIFIED
C   05-MAR-1990 RB CERN GENEVA
C               SOME PROTECTIONS INTRODUCED IN MODIFIED CODE
C   11-MAY-1990 NVE CERN GENEVA
C               MODIFICATIONS OF HF AND RB IMPLEMENTED BY RETAINING
C               THE LOGIC OF GEANH 3.13
C   14-MAY-1990 NVE CERN GENEVA
C               PROTECTION FOR ATAN2 INTRODUCED IN "GMUNU"
C   15-MAY-1990 NVE CERN GENEVA
C               COMPLETE "+KEEP" FOR /NUCIO/ UNDER PATCHY FLAG "SINGLE"
C               AND THIS SEQUENCE INTODUCED IN "NUCREC" AND "PHPNUC"
C   17-MAY-1990 HF RWTH AACHEN/NVE CERN GENEVA
C               DOUBLE INVOKATION OF NUCREC REMOVED FROM "GHEISH"
C               FOR SLOW NEUTRONS WHICH RESULTS IN LONGER PATH
C   18-MAY-1990 RB CERN GENEVA
C               CLEANER CONSTRUCTION TO PUT DOUBLE PRECISION OF
C               /NUCIO UNDER CONTROL OF PATCHY FLAG "SINGLE"
C   20-JUN-1990 RB/NVE CERN GENEVA
C               NEW OPTION IHADR=3 INTRODUCED TO SELECT INVOKATION
C               OF THE NUCRIN PACKAGE FROM "GHEISH" FOR ENERGIES
C               BELOW 5 GEV
C   27-SEP-1990 RB/NVE CERN GENEVA
C               NUCRIN PACKAGE REPLACED BY NEW VERSION OF RB
C               AND PROTECTION AGAINST CRAZY P VALUES ADDED IN "GHEISH"
C   27-SEP-1990 MR/NVE CERN GENEVA
C               CORRECTION FOR THETA=PI IN ROUTINE "DEFS1"
C               AS A RESULT OF THE BUG THE ORIGINAL (HIGH ENERGETIC)
C               PARTICLE MIGHT HAVE GOT LOST IN CASE OF AN INTERACTION
C               AT THE BEGINNING OF A DETECTOR
C   27-SEP-1990 HJT/NVE CERN GENEVA
C               AVOIDING NEGATIVE W2 IN "GMUNU" AND CORRECTIONS MADE FOR
C               'SIG' IN "GMUNUI"
C   27-SEP-1990 NVE CERN GENEVA
C               PRINT MESSAGES WITH CONTACT PERSON REMOVED IN "GHEISH"
C   28-SEP-1990 NVE CERN GENEVA
C               GIFACE AND GHEISH CODE CLEANED FROM UNUSED VARIABLES ETC.
C               AS PROPOSED BY RB
C   25-OCT-1990 NVE CERN GENEVA
C               PROTECTION FOR 'ZINTHA' TO BECOME -0. ADDED IN "GHEISH"
C               TO PREVENT INFINITE LOOP DUE TO PRECISION PROBLEM
C   26-OCT-1990 NVE CERN GENEVA
C               LOCAL ARRAYS INITIALISED IN "PHASP" AND "PHPNUC" TO
C               ENABLE RUNNING IN DYNAMIC COMP. MODE UNDER UNIX
C   29-OCT-1990 NVE CERN GENEVA
C               BUG FIXED FOR DOUBLE PRECISION RANDOM NUMBERS IN "PHPNUC"
C               AND FORMAT FOR DEBUG PRINT CHANGED IN "NUCREC"
C
C ********************************************************************
C ***                                                              ***
C ***  IN CASE OF ANY TROUBLES, COMMENTS OR SUGGESTIONS CONTACT :  ***
C ***                                                              ***
C ***                     NICK VAN EIJNDHOVEN                      ***
C ***                     CERN                                     ***
C ***                     B 595 R-004                              ***
C ***                     CH-1211 GENEVA 23                        ***
C ***                     SWITZERLAND                              ***
C ***                     EUROPE                                   ***
C ***                     TEL. +41-22-7674740 OR CERN BEEP 7294    ***
C ***                     BITNET ADDRESS : NICK@CERNVM.CERN.CH     ***
C ***                                                              ***
C ********************************************************************
+DECK,  V_313, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:47  cernlib
* Geant
+CDE, CERNLIB_MACHINE.

*::>          VERSION  3.13/05   890628 15.01
*        Changes in GTELEC,GTHADR and GTMUON for overstopping tracks.
*        STEP and SLENG correction optimized
*        In COMMON/GCDRAW/ variable IGVIEW changed to IDVIEW
*        Routine GTRMUL recoded
*        DOUBLE precision in GINTCO and protection added.
*        Changes in GNOPG6.
*        Changes in GINME (for spheres,tubes and cones DPP.LE.0)
*        GDINIT called by GXINT
*        Particle data table updated in GPART
*        Tests on boundary conditions for IEKBIN modified in GTGAMA
*        A new user callable routine GBIRK introduced in GPHYS.
*         GBIRK may be called from GUSTEP to compute the Birk
*         correction factors for anorganic scintillators.
*::>          VERSION  3.13/04   890623 12.34
*        New version of GLANDZ and GPOISS by L.Urban
*        GRNDM calling sequence changed
*        Sequence numbers (1-->215) can be initialized
*         with data card RNDM
*                Ex:
*            RNDM  9876  1234534   initializes sequence 1
*            RNDM 45  initilizes sequence 45 with the starting
*                     seed of sequence 45
*        New routine GRANOR (copy of RANNOR for GRNDM)
*::>          VERSION  3.13/03   890425 12.09
*        Update of inline documentation DOCGBASE,DOCGKINE,DOCGTRAK
*        Deck GGCLOS modified and moved from GGEOM to GBASE
*        New deck GHCLOS (called by GGCLOS) in GBASE
*        Deck GEVKEV moved from GTRAK to GCONS
*        New decks GFNDIG,GFNHIT,GRHITS in GHITS
*        Minor bug corrected in GTELEC
*        Control of debug and removal of SNXT=BIG  in GTNEXT
*        Call to GUSTEP removed from GUVIEW
*::>          VERSION  3.13/02   890311 10.45
*        Bug corrected in GPAIRM (COMMON/GCMATE/ overwritten
*        Bug corrected in outines GDRELM and GDRELP
*           (error in AVO changed to AVOGAD)
*        Minor corrections in physics routines
*        SAVE statements added
*        Protection in GHANGL
*        Default changed to GHEISHA instead of TATINA
*          in routines GUPHAD and GUHADR
*        Bug corrected in GHTATI (NAMEC(12) instead of NAMEC(10)
+DECK,  V_314, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:47  cernlib
* Geant
+CDE, CERNLIB_MACHINE.

C
C
C           ************************************************
C           *                                              *
C           *         G E A N T  version  3.14.16          *
C           *                                              *
C           *           Official  R e l e a s e            *
C           *       ==============================         *
C           *                                              *
C           ************************************************
C
C
C
*    The version 3.14 of GEANT is being released. Apart from a few
*    features, reported below, the new version is compatible with the
*    previous version 3.13. Substantial developments have taken place,
*    in particular in the physics and tracking areas.
*
*    In addition to the GEANT team
*     (R.Brun:CERN/CN-AS,  F.Bruyant:CERN/ECP-PI and M.Maire:LAPP),
*    many people have contributed to the new version, especially
*     - a large number of users of the previous version who reported
*       their experience, found bugs and suggested several improvements,
*     - the guinea-pigs of 3.14 who gave us essential comments during
*       our attempt to automatize computation of the tracking parameters.
*                 ** A.Givernaud (UA1), F.Nessi, V.Vercesi(UA2/LHC)
*                 ** The LHC proto collaborations
*     - H.Fesefelt(Aachen) has provided a new version of the GHEISHA
*       package with help from N.Van Eijndhoven (CERN/CN-AS)
*     - H.J Trost from ANL has reported problems in the muon-nuclear
*       interactions routines and provided the relevant corrections.
*     - P.Pedroni (Pavia) has implemented a new interface called
*       by GHEISHA for low-energy hadronic processes (See NUCRIN below).
*     - the contributors to the geometry package:
*            for the introduction of new shapes
*                ELTU by A.Solano (ZEUS)
*                HYPE by M.Corden (ALEPH and SSC)
*                CTUB by A.McPherson (CEBAF)
*            for systematic investigation of problems with the old shapes
*                R.Nierhaus (CERN/CN-AS)
*     - S.Egli (H1) has proposed an automatic optimisation for the
*       geometry at initialisation time.
*     - G.Lynch from Berkeley has investigated the multiple-scattering
*       various strategies and proposed a new algorithm.
*     - A.Rotondi and P.Montagna have proposed a new technique for the
*       fast generation of Vavilov distribution.
*       K.S.Koelbig (CERN/CN-AS) has implemented a new routine GVAVIV
*       based on their work.
*     - J.Salt (CERN/CN-AS) has implemented the graphics interface to the
*       CG package from Serpukhov with the help of E.Chernaev.
*     - The IBM team (C.Guerin, M.Roelisberger) have investigated how
*       to speed-up the program. Their work has been coordinated
*       by F.Carminati (CERN/CN-AS).
*
*     GEANT3.14 documentation
*     =======================
*      The printing of a new manual describing the new version is
*      scheduled for the end of this year. The CERN Program Library
*      will not distribute anymore the old document (version 3.11).
*
*
*     Important notice to GEANT users
*     ===============================
*
*      Following the reorganisation of the CERN research divisions
*      in July 90, R.Brun is now in charge of the Application Software
*      group (AS) in the CN division and F.Bruyant is in charge of the
*      Production support and computers Infrastructure group (PI) in the
*      ECP division. They will nevertheless continue, with M.Maire, to be
*      actively involved in the development of GEANT. Federico Carminati
*      is the coordinator of a simulation software unit in the CN-AS group.
*      Users are strongly recommended to address their questions,etc
*      directly to him (email: FCA@CERNVM.CERN.CH on BITNET). In particular,
*      feedback from users making comparisons with real data will be most
*      appreciated.
*
*      The simulation team is preparing the ground for the next version
*      of GEANT. In view of the proposed new accelerators, the following
*      items are considered with high priority:
*        - Parametrization techniques. A survey of the various methods
*          used in current experiments has been done and the implementation
*          of a new algorithm based on the GSCAN geometry + GFLASH (H1)
*          is in progress.
*        - Improvements in the geometry package. General shape definition,
*          surface based algorithms.
*        - Detector data structure and data base. Interface with CAD systems.
*        - Parallelism (at event level and below).
*
*
*......................................................................
*
* *** Compatibility with version 3.13
*     ===============================
*     - If COMMON blocks GCMULO or/and GCJLOC were included in the
*       user code, the new GEANT sequences GCMULO and GCJLOC must be
*       inserted and the code recompiled.
*     - Initialisation data structures saved with the previous versions
*       cannot be read by the new version, because the binning for
*       the cross-sections and energy loss tables has been changed.
*     - The GCPHYS variables SOLOSS,STLOSS,SOMULS,STMULS are no more
*       defined (see comments below)
*     - The GCTRAK variable IDECAD is replaced by IGAUTO
*
*
* *** MAIN CHANGES IN THE TRACKING PROCEDURES
*     =======================================
*
*    The tracking control routines GTGAMA,GTELEC,GTHADR,GTNEUT,GTMUON
*    have been largely rewritten to reflect the changes to the energy-loss
*    and multiple scattering processes.
*
*
* *** The ENERGY RANGE of the cross section and energy loss tables can
*     be fixed by the user with the new data card :
*             'ERANG'   EKMIN  EKMAX    NKBIN
*     which defines nkbin bins from Ekmin to Ekmax in a logarithmic scale.
*     The default is, as before, 90 bins from 10 Kev to 10 Tev but in
*     logarithmic scale. NKBIN must be 50<NKBIN<200.
*
*     WARNING 1 : as a consequence the common GCMULO has been changed.
*     User applications referencing GCMULO must be recompiled.
*
*     WARNING 2 : as a consequence the ZEBRA data structure JMATE
*     contains now cross-sections and energy loss tables based on the new
*     energy range. Structures saved by previous versions of GEANT cannot
*     be used by the new version.
*
*     WARNING 3 : changing the 'ERANG' data card arguments requires to
*     recreate the initialisation data structures.
*
*     WARNING 4 : for Hadrons, GEANT tabulates the energy-loss tables
*     for a proton-kinetic energy equivalent. As a consequence, the value
*     given for EKMAX must be at least 7 times the maximum kinetic energy
*     of particles to be tracked (ratio proton/pion mass).
*     For LHC/SSC simulations, we recommend ERANG 1.E-5 1.E+5 100
*     The recommended value for NKBIN is 10*LOG10(EKMAX/EKBIN).
*
*
* *** The MEAN STOPPING RANGE of a charged particle (STOPMX) is computed and
*     tabulated as a function of the kinetic energy (routine GRANGI).
*     There are tables for electrons, muons, protons. The others particles are
*     scaled from the proton table.
*     As for the other tabulated quantities, the Stopping Range can be displayed
*     with the routines GPLMAT and/or GPRMAT (keyword 'RANG').
*
*     During the tracking, the MEAN ENERGY LOSS over a given step (DEMEAN) is
*     computed from the difference of the stopping range before and after the
*     transport of the particle.
*
*
* *** ENERGY LOSS STRAGGLING : when ILOSS=2 (default) the Landau/Vavilov
*     fluctuations are applied to the mean energy loss over the step.
*     The VAVILOV distribution has been improved so that the fluctuations are
*     less dependent on the step size.
*
*     ILOSS=1 is now equivalent to ILOSS=3 i.e. restricted fluctuations are
*     applied together with delta-ray production (see routine GLANDZ).
*     The user who wish to inhibit the energy fluctuations must set ILOSS=4
*     The latter option has been kept for debug purpose only.
*
*
* *** MULTIPLE SCATTERING.  The calculation of the step size (SMULS) is new :
*     Bethe criterion taken into account, limitation of step size at low
*     energy (see routine GMULOF).
*
*     New routine GMULTS : depending on the step size the Moliere distribution,
*     or its gaussian approximation, is used.
*
*     The routines GMOLI, GMOLIE (ex Gmol), GMOLS have been slightly modified.
*
*     In the routine GMGAUS (ex Gmuls), we use a new sigma (G. Lynch LBL-28165).
*     The lateral displacement has been deleted. As a consequence the tracking
*     parameter DMAXMS is not used anymore for the control of the step size.
*     DMAXMS.LE.0 forces no multiple scattering at all in the medium.
*
*     New routine GMCOUL : for very small steps single Coulomb scatters are
*     generated instead of Moliere distribution.
*
*     By default (IMULS=1) GEANT will select automatically the algorithm to use
*     (GMCOUL, GMOLIE or GMGAUS).
*
*
* *** NEW ROUTINE GMULOF. The step for energy loss (SLOSS), the step for
*     multiple scattering (SMULS), and the step  for the curvature in a magnetic
*     field (SFIELD) can be precomputed and tabulated, at least for electrons
*     and muons. The routine GMULOF, called from GPHYSI, tabulates:
*                  SMULOF = MIN ( SMULS , SLOSS , SFIELD )
*     which is the effective step due to the "continuous processes".
*     SMULOF can be displayed with the routines GPLMAT/GPRMAT, keyword 'STEP'.
*
*
* *** Multiple scattering and energy loss computations are systematically
*     applied at each step during tracking. Therefore the GCPHYS variables
*     SOLOSS, STLOSS, SOMULS, STMULS are OBSOLETE. However, for backward
*     compatibility with 3.13, STLOSS is set equal to STEP.
*
*
* *** TRACKING PARAMETERS STMIN and DEEMAX.
*
*     The meaning of STMIN is the following : at low energy (below 1 Mev) the
*     multiple scattering condition can induce a very small step SMULOF.
*     On the other hand the Stopping Range is also small. Therefore, if the
*     Stopping Range is smaller than STMIN, the constraint SMULOF is ignored.
*     The exact condition is :
*               IF (SMULOF.LE.STMIN)   SMULOF = MIN ( STOPMX, STMIN )
*     STMIN is no more than an accelerator factor for the stopping particles.
*
*     The DEEMAX parameter remains the main tracking parameter. It governs the
*     precision of the tracking by limitating SMULOF.
*
*
* *** AUTOMATIC COMPUTATION of STMIN and DEEMAX.
*
*     By default Geant3.14 overwrites STMIN and DEEMAX. The STMIN default value
*     correspond to a stopping range of 200 Kev above CUTELE.
*     The default for DEEMAX follows the following algorithm:
*       - For non-sensitive volumes (ISVOL=0) DEEMAX is set to 0.25 for
*         materials with a radiation length x0<2cm
*         and DEEMAX=0.25-0.2/sqrt(x0) for other materials.
*       - For sensitive volumes (ISVOL.NE.0) DEEMAX=0.2/sqrt(x0)
*     These values have been tuned empirically on a variety of setups.
*
*     A new data card 'AUTO' has been implemented :
*     Setting 'AUTO' 1 is equivalent to NO data card, i.e. automatic computation
*     Setting 'AUTO' 0 : NO automatic computation, EXCEPT if STMIN and/or DEEMAX
*     has been given a negative value by the user.
*
*     WARNING : The default values above have been found reasonable for any kind
*     of medium. The unexperienced user is invited to start with automatic
*     computation. Please check the actual parameters by calling GPRINT ('TMED'
*     after the call to GPHYSI.
*
*     We STRONGLY recommend to always run in AUTO mode (default). The AUTO
*     mode makes GEANT a predictive tool if all parameters are automatically
*     computed by the system as opposed to tuning data and Monte Carlo
*     via the tracking parameters.
*
* *** GPHYSI
*     The routine GPHYSI has been improved to include additional protections
*     and to take into account the changes due to the new energy-range tables.
*     It must be noted that is mandatory to always call GPHYSI at the end
*     of the initialisation phase even when initialisation data structures
*     are read from a file.
*
* *** GPIONS
*     This new routine (a complement to GPART) defines a subset of the most
*     common "stable" elements in the nature.
*     GPIONS can be called at the initialisation stage after GPART. It creates
*     particles with GEANT identifiers 61 to 112.
*     GPIONS has been written for the heavy ions experiments in view of an
*     interface with the program FRITIOF which is being developed by
*     P.Gorodetzky (Strasbourg).
*
* *** GDEBUG
*     This new user callable routine from GUSTEP will take the following actions
*     if the flag IDEBUG=1:
*
*     IF(IDEBUG.NE.0) THEN
*       IF((ISWIT(2).EQ.1).OR.(ISWIT(3).EQ.1)) CALL GSXYZ ! store point in JXYZ
*       IF (ISWIT(2).EQ.2) CALL GPCXYZ ! step by step printed debug
*       IF (ISWIT(1).EQ.2) CALL GPGKIN ! list of particles generated during step
*       IF (ISWIT(2).EQ.3) THEN
*          IF(ISWIT(4).EQ.3.AND.CHARGE.EQ.0.)RETURN
*          CALL GDCXYZ    ! interactive drawing of trajectories
*        ENDIF
*     ENDIF
*
* *** New user callable routine GBIRK to take into account BIRK's factors.
*     ====================================================================
*    This new routine is callable from the GUSTEP routine. EDEP=DESTEP
*    if no Birk factors have been given via GSTPAR.
*      SUBROUTINE GBIRK(EDEP)
*
*     *** apply BIRK's saturation law to energy deposition ***
*     *** only organic scintillators implemented in this version MODEL=1
*
*     Note : the material is assumed ideal, which means that impurities
*            and aging effects are not taken into account
*
*     algorithm : edep = destep / (1. + RKB*dedx + C*(dedx)**2)
*
*     the values of RKB and C can be entered via :
*
*     call gstpar(imate,'BIRK1',value) to set the model (value= 1. or 2.)
*     call gstpar(imate,'BIRK2',value) to set RKB
*     call gstpar(imate,'BIRK3',value) to set C
*
*     the basic units of the coefficient are g/(Mev*cm**2)
*     because the de/dx is obtained in Mev/cm
*
*     exp. values from NIM 80 (1970) 239-244 :
*
*     RKB = 0.013  g/mev*cm**2  and  C = 9.6e-6  g**2/(Mev**2)(cm**4)
*
*
*
*
* *** GEANH news
*
*
*     a serious bug in GMUNUI has been reported by
*     Hans-Jochen Trost from ANL:
*       : convert millibarns to cm**2 by a factor 10**-27
*         and obtain therefore NA * 1 millibarn/cm**2 a
*         factor 10 smaller than in the code. Hans has verified
*         that the original code gives to high an energy loss
*         due to muon-nuclear interactions on iron by a fac-
*         tor of about 5-10, comparing to W.Lohmann et al.,
*         CERN 85-03 whose predictions have recently been
*         verified by CCFR data up to 1.2 TeV.
*     Hans has also introduced protections in GMUNU.
*
*    A new version of the GHEISHA package has been introduced by
*     H.Fesefelt (contact him for details).
*
*     The TATINA package is considered obsolete. Default routines
*     GUPHAD/GUHADR call GHEISHA. We are planning to remove the code
*     of TATINA in the coming versions of GEANT.
*
*
* *** NUCRIN: A new model for hadronic showers at low energies
*     ========================================================
*
*
*    NUCRIN (see ref.1) simulates hadron-nucleus ( A > 3) inelastic
*    interactions from a few MeV/c up to about 4.5 GeV/c laboratory
*    momentum of the incoming particle.
*    NUCRIN is automatically called by the GHEISHA routine GHEISH
*    when the flag IHADR=3 (set by data card HADR).
*    It is assumed that these reactions  are the superimposition of three
*    basic processes:
*
*    (a) inelastic collision of the projectile hadron (allowed particles are :
*        p,pbar,n,nbar,pi0,pi+,pi-,k+,k-,k0,k0bar,lamda0,lamda0bar,sigma+,
*        sigma-,sigma0) with a target nucleon in the nucleus.
*        This interaction is simulated,taking into account of the nucleon
*        Fermi momentum,  using HADRIN (see ref.2) program.
*        The corresponding physical model is based on the experimental evidence
*        that, in the selected momentum range,the inelastic cross section shows
*        the typical threshold and resonance behaviour of meson production:
*        the primary hadron-nucleon system is excited to an isobaric state
*        which then decays into hadrons or other resonances.
*
*        If the interacting nucleus is hydrogen,HADRIN can also be used
*        in a separate way to simulate hadron-proton reaction.
*
*    (b) induced intranuclear cascade with resulting proton and neutron
*        emission;
*
*    (c) nuclear evaporation and deexcitation from residual nucleus. At the
*        output the total energy available for these processes is given as
*        "excitation energy".
*
*    The mean excitation and cascade energies and the average multiplicities
*    of cascade particles are parametrized, according to experimental
*    distributions.
*    In each event their value are sampled from gaussian distribution:
*    if they fall in the permitted kinematical region, energy and types of
*    cascade nucleons are calculated and the remaining energy is assigned to
*    the incoming particle.
*    For hadron-nucleon interactions all relevant kinematic variables are
*    Lorentz-trasformed into the target nucleon rest system. If interaction
*    kinetic energy is greater than the total available collision energy
*    a new Fermi momentun is sampled, otherwise an event is generated with
*    HADRIN,in which decays modes of 107 particle and resonances into about
*    450 different channels are tabulated and outgoing particle directions
*    and momenta are chosen to reproduced experimental momentum transfer
*    distributions.
*    Final state particles kinematical variables are transformed back into
*    laboratory system; reaction and sampled event energies are again compared:
*    if their difference is negative, energy is not conserved and generation
*    has to be started once more with a new Fermi momentum sampling or if it
*    is,on the contrary positive, particle momenta and energies are corrected
*    to reach conservation.
*    The sampled events conserve the energy, the momentum, the electric and
*    baryonic charge  and the strangeness.
*    NUCRIN and HADRIN are initialised, by default, before event generation,
*    with a call to subroutines HADDEN and CHANWX which estabilish internal
*    weight tables and decay channels.
*
*    -----------------------------------------------------------------------
*    (1) K. Hanssgen, J. Ranft , Comp. Phys. Comm. 39, 53 (1986)
*    (2) K. Hanssgen, J. Ranft , Comp. Phys. Comm. 39, 37 (1986)
*
*
* *** GEOMETRY PACKAGE: New shapes and many improvements
*     ==================================================
*
*    Automatic optimisation of the geometry structure:
*    A new data card OPTI has been introduced (S.Egli H1).
*      OPTI -1 : disable optimisation
*      OPTI  0 : only volumes GSORDered are optimised (as in 3.13)
*      OPTI  1 : volumes GSORDered are optimised along the axis
*                specified. All the other volumes are automatically
*                optimised along the best axis (1 to 7).
*      OPTI  2 : All volumes are optimised along the best axis.
*                Volumes for which GSORD was called are also optimised.
*      The default value for OPTI is 0.
*      In case OPTI >0, the result of the optimisation is printed.
*      The automatic optimisation is done at initialisation time by
*      a new routine GGORDQ called by GGCLOS.
*
*
*    Most of the geometry routines have been revisited and consolidated.
*    The following new shapes are available.
*
*      'ELTU'    is a cylinder with an elliptical section.
*                It has three parameters: the ellipse semi-axis in X,
*                the ellipse semi-axis in Y and the half length in Z.
*                Given the equation of the conical curve:
*                     X**2/A**2 + Y**2/B**2 = 1,
*                describing the volume,then:       PAR(1) = A
*                                                  PAR(2) = B
*                                                  PAR(3) = DZ
*                ELTU is not divisible.
*
*      'HYPE'    is a hyperbolic tube, ie the inner and outer surfaces
*                are hyperboloids, as would be formed by a system of
*                cylindrical wires which were then rotated
*                tangentially about their centres.  The 4 parameters
*                are the inner and outer radii, the half length in z,
*                and the "stereo angle" theta in degrees, such that
*                the hyperbolic surfaces are given by
*                r**2 = (z*tan(theta))**2 + (r at z=0)**2
*
*      'CTUB'   (for cut tube) is a TUBS whose end planes are not
*               perpendicular to the z axis. It has 11 parameters :
*               the 5 of the TUBS shape plus the components of the normal
*               to the end plane at the lower z (LXL,LYL,LZL) and
*               those at the higher z (LXH,LYH,LZH).
*               DZ means the half length in z for x = y = 0
*
*
*     Bugs have been fixed in the routines GNPCON, GNPGON and GNOPGO.
*
*     The new version of GNOTRP requires an extended parameter array.
*     In addition to the 11 specified parameters (of which 4 are
*     modified in subroutine GSVOLU or GSPOSP), the coefficients of
*     the implicit normalized plane equation for the 6 surfaces
*     of the hexahedron are stored.
*
*     IMPORTANT NOTE concerning the TRAP shape
*     ========================================
*     The Geant documentation describes the Geant shape TRAP as follows:
*
*          TRAP is a general trapezoid, i.e. one for which the
*          faces perpendicular to z are trapezia and their
*          centres are not at the same x, y. It has 11
*          parameters: Dz the half length in z, Th & Phi the
*          polar angles from the centre of the face at z=-Dz
*          to that at z=+Dz, H1 the half length in y  at
*          z=-Dz, LB1 the half length in x at z=-Dz and y=low
*          edge, LH1 the half length in x at z=-Dz and y=
*          high edge, Th1 the angle w.r.t. the y axis from
*          the centre of the low y  edge to the centre of the
*          high y edge, and H2, LB2, LH2, Th2 the
*          corresponding quantities to the 1s but at z=+Dz.
*
*     This seems to describe a general hexahedron with 3 constraints:
*     2 constraints follow from the fact that two faces are "trapezia".
*     (twice 2 edges parallel).
*     The 3rd constaint is that two faces are parallel, namely the "trapezia"
*     faces are both perpendicular to the Z-axis.
*     We will assume that shape TRAP is a hexahedron with 3
*     constraints and direct our attention to the degrees of freedom
*     of such a shape.
*     The shape has 8 vertices and therefore 24 coordinates.
*     If we first consider a volume with 8 vertices and 6 surfaces,
*     but do not make the assumption that the surfaces are plane,
*     we see that this shape has 18 degrees of freedom.
*     We loose 3 coordinates because of the translational invariance
*     of the shape and 3 coordinates because of its rotational
*     invariance.
*     If we now assume that the shape is a hexahedron, that is
*     bounded by plane surfaces, we have 6 constraints, one for each
*     surface, and our hexahedron has 12 degrees of freedom.
*     Considering the 3 constraints mentioned in the beginning,
*     we conclude that our shape trapezohedron has 9 degrees of freedom.
*     It is however described by 11 parameters.
*     Therefore we must either drop our assumption that shape TRAP is
*     a hexahedron, that is bounded by parallel surfaces, or we must
*     request that the user specifies the 11 parameters with certain
*     constraints.
*
*     To check that the user respected the constraints, we check the
*     coplanarity of the faces during the specification phase of shape TRAP.
*     We know the vertex coordinates, and we have the indices to the
*     vertices for each face.
*     Assuming that a face is tetrahedron, we compute its volume.
*     We divide by the surface of the base triangle, and get a measure
*     for the coplanarity of the face, which is actually a distance.
*     A warning message is printed in case of no-coplanar faces.
*
*    GSORD problem
*    =============
*    A bug has been found in GTNEXT (and alike) which is induced by a bug of
*    logic in GSORD/GGORD. User calls to GSORD, with ordering axis 4 (Rxy)
*    or 5 (Rxyz), may cause problems when the ordered contents are such that
*    one can jump from a given content to another one without crossing a
*    content which, along the given axis, occupies a position in between the
*    start and the end contents : e.g. coaxial TUBES with different Z-lengths
*    should not in general be ordered by GSORD along the axis IAX=4 (Rxy).
*    However, part of the information provided by such calls can still be
*    used, in the static context of GTMEDI for instance. Therefore, the
*    following convention has been introduced: If the user is sure that the
*    contents are positioned in such a way that the anomaly mentioned above
*    cannot occur, the call to GSORD can be modified by using IAX=14 (instead
*    of 4), or 15 (instead of 5), in which case the ordering techniques will
*    also be used in the dynamic context of GTNEXT. In case of doubt, the
*    user has better to keep the old code, with IAX=4 or 5.
*
* *** DRAWING PACKAGE: Interface to the CG package
*     ============================================
*
*    An interface to the CG (Combinatorial Geometry) package written
*    at Serpukhov by E.Cernaev et al is now available. The new package
*    is automatically called if the option 'HIDE' is selected. eg.
*
*         CALL GDOPT('HIDE','ON')  in a Fortran program
*         DOPT HIDE ON/OFF  in the interactive version
*
*    This new facility includes a hidden line and surface algorithm
*    which permits nice 3-D views of a detector.
*    In the frequent case of hermetic 4 PI detectors, a facility
*    to remove a box (The Cutting BOX) is also implemented. The Cutting BOX
*    specifies a region of the detector which must be Cut to see inside.
*    A new interactive command CBOX is available to specify the box limits.
*
*    The CG system is part of the GEANG file (See Patches CGCDES,CGPACK)
*    To activate the CG package, +USE,CG,*GEANG.
*
*
* *** The SCAN geometry
*     =================
*   A new Patch,GSCAN has been introduced on a provisional basis in the GEANG
*   file. See discussion about SCAN below.
*
* *** GUPARA: Parametrization interface
*     =================================
*   A new FFREAD data cards PCUT can be used to set parametrization cuts.
*   The first argument of the PCUT card is a integer flag which turns or
*   on off the parametrization mechanism. If the parametrization is turned on
*   and a particle falls below one of the 5 cuts specified by the PCUT card
*   (similar in kind to the cuts specified by the card CUTS), then the
*   routine GUPARA is called and tracking of the particle is abandoned. This
*   mechanism is provided for applying parametrization schemes which
*   replace a particle by a parametrized shower when it falls below
*   a certain threshold.
*
*.............................................................................
*
*
* *** GXINT: Interactive version
*     ==========================
*
*      New menu FORTRAN: CALL,FILE,CLOSE,FORTRAN
*      New menu HISTOGRAM: FILE,LIST,PLOT,DELETE,LEGO,HRIN,HROUT,PUT,GET
*                          ZONE,SET,OPTION,NULL
*      New menu PICTURE: FILE,LIST,DELETE,SCRATCH,PLOT,RENAME,IZOUT,IZIN,IGSET
*      New menu SCAN: PHI,THETA,SLIST,VERTEX,SFACTORS,LSCAN,HSCAN
*      New menu PHYSICS: ANNI,BREM,COMP,DCAY,DRAY,HADR,LOSS,MULS,MUNU,PAIR,
*                        PFIS,PHOT,RAYL,CUTS,PHYSI
*
*      The menus FORTRAN,HISTOGRAM and PICTURE are subsets of the similar
*      menus in the PAW system.
*
*      The menu PHYSICS gives the possibility to modify the run conditions.
*      In case physics conditions are changed (LOSS,DRAY,MULS,CUTS) it is
*      mandatory to call the command PHYSI (which calls GPHYSI) to recompute
*      the cross-section and/or energy loss tables.
*
*      The menu FORTRAN is similar to the FORTRAN menu of PAW. It contains
*      in addition a new very important command FORTRAN which gives the
*      possibility to describe the geometry (UGEOM) in a Fortran routine
*      that can be edited interactively with the local editor and also
*      executed interactively under the control of the Fortran interpreter
*      COMIS.
*
* ***  GEANT >FORTRAN  FNAME
*
*      The routines in the file FNAME will be compiled by COMIS.
*      If routines with names: UGEOM,GUKINE,GUOUT,UGLAST are found,
*      then they will be automatically called by GXINT instead of
*      the routines with the same names compiled with the standard
*      Fortran compiler and linked with the application.
*      The user callable routines from the GEANT library as well as
*      routines from PACKLIB (HBOOK,HPLOT,HIGZ,ZEBRA) may be called
*      from these user routines. All GEANT common blocks may be
*      referenced.
*      In case where the routine UGEOM is called several times,
*      it is important to DROP all the initialisation data structures
*      JVOLUM,JMATE,JTMED,etc already in memory by using the routine GIDROP.
*
*       Example of an interactive session where the routine UGEOM is modified:
*
*         GEANT > Edit ugeom.for
*         GEANT > Fortran ugeom.for
*         GEANT > Call GIDROP
*         GEANT > Call UGEOM
*         GEANT > Dtree
*         GEANT > Edit ugeom.for
*         GEANT > Fortran ugeom.for
*         GEANT > Call GIDROP
*         GEANT > Call UGEOM
*         GEANT > Dtree
*
*      If FNAME='-', calls to user routines is reset and standard
*      routines called instead.
*
* *** Interface to CG
*    The command DOPT has a new option HIDE (DOPT HIDE ON/OFF)
*    Type DOPT without parameters to get the list of all currently
*    available options.
*    When this option is ON, the subsequent graphics commands DCUT/DRAW
*    will invoke the CG system for hidden line/surface removal.
*    This algorithm requires a lot of memory and time. It is recommended
*    to set the visibility attributes (SATT SEEN 0) for many of the
*    volumes in case the command aborts for lake of memory or time.
*    This option can also be used with the view banks mechanism (DOPEN)
*
*    New command CBOX to specify the boundaries of the cutting box.
*
* *** PLMAT
*
*   The existing command PLMAT offers the new possibility to plot
*    various physics parameters (cross-sections, energy-loss tables,etc)
*   in graphics format (via HPLOT) if MECAN=ALLG
*   The Keywords 'STEP' or 'RANG' may also be specified to produce
*   an alphanumeric output of the step-size and energy-range tables.
*
*        PLMAT  IMATE IPART MECAN [ IDM ]
*
*       IMATE      I 'Material number'
*       IPART      I 'Particle number'
*       MECAN      C 'Mechanism'
*       IDM        I 'ID mode option' D=0
*
*
* *** New menu SCAN. The SCAN geometry
*     ================================
*
*    This new menu contains various commands for an interactive interface
*    to the SCAN geometry
*    The SCAN geometry algorithm has been designed as a tool to improve
*    the tracking speed. This new facility still requires substantial
*    developments in view of the new parametrisation algorithms which
*    are developed in collaboration between the CN/AS group and the
*    LEP/HERA/LHC/SSC and other interested groups.
*    The SCAN facility is being introduced in the version 3.14 on a trial
*    basis to familiarise potential users with the concept.
*    The SCAN geometry data structure JSCAN is automatically generated
*    either by calling the GSCAN routine in the PATCH,GSCAN of GEANG
*    or interactively by using the commands in the new menu SCAN.
*    Starting from the normal geometry data structure created by GSVOLU,
*    GSPOS,GSDVN,etc, the detector may be divided into a simpler geometry
*    structure (theta,phi) or (eta,phi).
*    Geantinos are tracked starting from a VERTEX position through
*    the NPHI,NTETA divisions. For each division, the SCAN procedure
*    will insert into the JSCAN data structure the following information
*    for every main detector component specified in the SLIST command
*    in the spherical R direction:
*      Total number of radiation lengths up to entry in each R
*      Total number of absorption lenghts
*      Detector identifier
*    When the interactive command TRIGGER is entered, the number of
*    Geantinos specified as parameter will be tracked. In case the
*    data structure JSCAN is not empty, the program will automatically
*    start with the first PHI,TETA division not yet filled. As the
*    number of Geantinos to be tracked can be very large (depending
*    on the granularity) this gives the possibility to fill the JSCAN
*    data structures in several passes.
*
*
*     New menu SCAN: PHI,TETA,SLIST,VERTEX,SFACTORS,LSCAN,HSCAN
*
* ==>   /SCAN/PHI  NPHI [ PHIMIN PHIMAX ]
*
*        NPHI       I 'Number of PHI divisions' D=90
*        PHIMIN     R 'Minimum PHI in degrees' D=0
*        PHIMAX     R 'Maximum PHI in degrees' D=360
*
*        To specify number of divisions along PHI.
*
*
* ==>   /SCAN/TETA  NTETA TETMIN TETMAX [ DIVTYP ]
*
*        NTETA      I 'Number of TETA divisions' D=90
*        TETMIN     R 'Minimum value of TETA' D=0
*        TETMAX     R 'Maximum value of TETA' D=180
*        DIVTYP     I 'Type of TETA division' D=1 R=1:2
*
*        To specify number of divisions along TETA.
*        If DIVTYP=1 divisions in degrees following the THETA angle.
*        If DIVTYP=2 divisions in pseudo-rapidity ETA.
*
*
* ==>   /SCAN/SLIST  LIST
*
*        LIST       C 'List of master volumes'
*
*        Only boundary crossings of volumes given in LIST
*        will be seen in the SCAN geometry.
*
*
* ==>   /SCAN/VERTEX  VX VY VZ
*
*        VX         R 'Scan vertex origin' D=0
*        VY         R 'Scan vertex origin' D=0
*        VZ         R 'Scan vertex origin' D=0
*
*        All Geantinos tracked will start from position VX,VY,VZ.
*
*
* ==>   /SCAN/SFACTORS  FACTX0 FACTL FACTR
*
*        FACTX0     R 'Scale factor for SX0' D=100
*        FACTL      R 'Scale factor for SL' D=1000
*        FACTR      R 'Scale factor for R' D=100
*
*        Set scale factors for SX0,SL and R. The given scale factors must be
*        such that:
*
*          SX0*FACTX0 < 2**15-1 (32767)
*          SL*FACTL   < 2**10-1 (1023)
*          SR*FACTR   < 2**17-1 (131071)
*
*
* ==>   /SCAN/LSCAN  ID [ VOLUME CHOPT ]
*
*        ID         I 'Lego plot identifier' D=2000
*        VOLUME     C 'Volume name' D='XXXX'
*        CHOPT      C 'List of options' D='OPX' R=' ,O,P,I,X,L'
*
*        Generates and plot a table of physics quantities such as
*        the total number of radiation lengths or interaction lengths
*        in function of the SCAN parameters TETA,PHI.
*
*          CHOPT='O' table is generated at Exit  of VOLUME.
*          CHOPT='I' table is generated at Entry of VOLUME.
*          CHOPT='X' radiation lengths
*          CHOPT='L' Interaction lengths
*          CHOPT='P' Plot the table
*
*        If VOLUME='XXXX' Mother volume is used.
*
*
* ==>   /SCAN/HSCAN  IDPHI [ VOLUME CHOPT ]
*
*        IDPHI      I 'Histogram/phi identifier' D=1000
*        VOLUME     C 'Volume name' D='XXXX'
*        CHOPT      C 'List of options' D='OPX' R=' ,O,P,I,X,L'
*
*        Generates and plot an histogram of physics quantities such as
*        the total number of radiation lengths or interaction lengths
*        in function of the SCAN parameter TETA for a given value of PHI.
*
*          CHOPT='O' histogram is generated at Exit  of VOLUME.
*          CHOPT='I' histogram is generated at Entry of VOLUME.
*          CHOPT='X' radiation lengths
*          CHOPT='L' Interaction lengths
*          CHOPT='P' Plot the histogram
*
*        If VOLUME='XXXX' Mother volume is used.
*        The histogram identifier IDPHI is used to also identify which
*        PHI division to plot. IPHI=MOD(IDPHI,1000).
*        If IPHI=0, then all PHI divisions are generated (not plotted)
*        with histogram identifiers IDPHI+PHI division number.
*
*
*
*
*
*
* ***   New commands FILE,REND,MDIR,CDIR,IN,OUT in the RZ menu.
*       =======================================================
*
*
* ==>   RZ/FILE  LUN FNAME [ CHOPT ]
*
*        LUN        I 'Logical unit number'
*        FNAME      C 'File name'
*        CHOPT      C 'Options' D=' ' R=' ,U,N,I,O'
*
*        Open a GEANT/RZ file. Call GRFILE (See below).
*
*         CHOPT=' ' readonly mode
*         CHOPT='U' update mode
*         CHOPT='N' create new file
*         CHOPT='I' Read all structures from existing file
*         CHOPT='O' Write all structures on file
*
*
* ==>   RZ/OUT  OBJECT [ IDVERS ]
*
*        OBJECT     C 'Structure name'
*        IDVERS     I 'Version number' D=1
*
*        Write data structure identified by OBJECT,IDVERS to RZ file.
*        Call GROUT (See below)
*
*          MATE write JMATE structure
*          TMED write JTMED structure
*          VOLU write JVOLUM structure
*          ROTM write JROTM structure
*          SETS write JSET  structure
*          PART write JPART structure
*          SCAN write JSCAN structure
*          *    write all structures
*
* ==>   RZ/IN  OBJECT [ IDVERS ]
*
*        OBJECT     C 'Structure name'
*        IDVERS     I 'Version number' D=1
*
*        Read data structure identified by OBJECT,IDVERS into memory.
*        Call GRIN (See below)
*
*          MATE read JMATE structure
*          TMED read JTMED structure
*          VOLU read JVOLUM structure
*          ROTM read JROTM structure
*          SETS read JSET  structure
*          PART read JPART structure
*          SCAN read JSCAN structure
*          *    read all structures
*
*
*
*
* *** New routines for direct access I/O in the GIOPA package
*     =======================================================
*
* ==>    SUBROUTINE GRFILE(LUN,CHFILE,CHOPT)
*.
*.           Routine to open a GEANT/RZ data base.
*.
*.           LUN logical unit number associated to the file
*.
*.           CHFILE RZ file name
*.
*.           CHOPT is a character string which may be
*.              'N' To create a new file
*.              'U' to open an existing file for update
*.              ' ' to open an existing file for read only
*.              'Q' The initial allocation (default 1000 records)
*.                  is given in IQUEST(10)
*.              'I' Read all data structures from file to memory
*.              'O' Write all data structures from memory to file
*.
*.           Note:
*.             If options 'I' or 'O' all data structures are read or
*.                written from/to file and the file is closed.
*.             See routine GRMDIR to create subdirectories
*.             See routines GROUT,GRIN to write,read objects
*.
*.
*.
*. ==>    SUBROUTINE GROUT(CHOBJ,IDVERS,CHOPT)
*.
*.           Routine to write GEANT object(s) in the RZ file
*.             at the Current Working Directory (See RZCDIR)
*.           Input is taken from the data structures in memory
*.               (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)
*.
*.           CHOBJ  The type of object to be written:
*.                  MATE write JMATE structure
*.                  TMED write JTMED structure
*.                  VOLU write JVOLUM structure
*.                  ROTM write JROTM structure
*.                  SETS write JSET  structure
*.                  PART write JPART structure
*.                  SCAN write LSCAN structure
*.                  INIT write all initialisation structures
*.
*.           IDVERS is a positive integer which specifies the version
*.               number of the object(s).
*.
*.           CHOPT List of options (none for the time being)
*.
*.        Note that if the cross-sections and energy loss tables
*.           are available in the data structure JMATE, then they are
*.           saved on the data base.
*.
*.
*.        The data structures saved by this routine can be retrieved
*.        with the routine GRIN.
*.
*.        Before calling this routine a RZ data base must have been
*.        created using GRFILE.
*.        The data base must be closed with RZEND.
*.          Ex: if LUN=1 CALL RZEND('LUN1')
*.
*.        The RZ data base can be transported between different
*.        machines in using the ZEBRA RZ utility RZTOFZ.
*.
*.        The interactive version of GEANT provides facilities
*.        to interactively update, create and display objects.
*.
*.          Example.
*.
*.          CALL GRFILE(1,'Geometry.dat','N')
*.          CALL GROUT('VOLU',1,' ')
*.          CALL GROUT('MATE',1,' ')
*.          CALL GROUT('TMED',1,' ')
*.          CALL GROUT('ROTM',1,' ')
*.          CALL GROUT('PART',1,' ')
*.          CALL GROUT('SCAN',1,' ')
*.          CALL GROUT('SETS',1,' ')
*.
*.          The same result can be achieved by:
*.          CALL GRFILE(1,'Geometry.dat','NO')
*.
*.
*.
*. ==>    SUBROUTINE GRIN(CHOBJ,IDVERS,CHOPT)
*.
*.           Routine to read GEANT object(s) fromin the RZ file
*.             at the Current Working Directory (See RZCDIR)
*.           The data structures from disk are read in memory
*.               (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)
*.
*.           CHOBJ  The type of object to be read:
*.                  MATE read JMATE structure
*.                  TMED read JTMED structure
*.                  VOLU read JVOLUM structure
*.                  ROTM read JROTM structure
*.                  SETS read JSET  structure
*.                  PART read JPART structure
*.                  SCAN read LSCAN structure
*.                  INIT read all initialisation structures
*.
*.           IDVERS is a positive integer which specifies the version
*.               number of the object(s).
*.
*.           CHOPT List of options (none for the time being)
*.
*.
*.        The RZ data base has been created via GRFILE/GROUT
*.
*.
*.          Example.
*.
*.          CALL GRFILE(1,'Geometry.dat',' ')
*.          CALL GRIN ('VOLU',1,' ')
*.          CALL GRIN ('MATE',1,' ')
*.          CALL GRIN ('TMED',1,' ')
*.          CALL GRIN ('ROTM',1,' ')
*.          CALL GRIN ('PART',1,' ')
*.          CALL GRIN ('SCAN',1,' ')
*.          CALL GRIN ('SETS',1,' ')
*.
*.          The same result can be achieved by:
*.          CALL GRFILE(1,'Geometry.dat','I')
*.
*.
*.
* ==>     SUBROUTINE GRMDIR(CHDIR,CHOPT)
*.
*.
*.           Routine to create a subdirectory
*.
*.           CHDIR Subdirectory name
*.
*.           CHOPT is a character string which may be
*.              ' ' To create a subdirectory
*.              'S' To create a subdirectory and set the new
*.                  Current Directory to this directory.
*.
*.

+DECK,  V_315, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
+CDE, CERNLIB_MACHINE.

*        Maintenance and support for the GEANT MonteCarlo system
*        are performed by the Simulation Section of the CERN
*        Computing and Networks division. For any problem please
*        contact:
*                        Federico Carminati
*                        CERN-CN
*                        1211 Geneva 23
*                        Tel:        +41 22 767.4959
*                        Telefax:    +41 22 767.7155
*                        E-mail:
*                        BITnet/EARN: FCA@CERNVM
*                        DECnet     : VXCERN::FCA (Node 22.190)
*                        Internet   : fca@cernvm.cern.ch
*        An electronic GEANT discussion list has been set up on CERNVM.
*        To be included in the mailing list it is enough to send the
*        following message:
*       TELL LISTSERV AT CERNVM SUBSCRIBE LGEANT Firstname Lastname Inst
*        People who do not dispose of a TELL (or equivalent) bitnet
*        command should send a mail to LISTSERV@CERNVM containing the
*        only line:
*                   SUBSCRIBE LGEANT Firstname Lastname Inst
*================================= History
*===> 20/NOV/1990
*        Current plans set the release of GEANT 3.15 around the third
*        quarter of 1991.
*===> 27/NOV/1990
*        Correction in GTRACK to set correctly the value of PREC
*        to match machine precision. Thanks to Stephan Egli and
*        M.Maire.
*        Introduced in the 314 correction cradle.
*===> 28/NOV/1990
*        Correction in GNTUBE to avoid square root of a negative
*        number. Thanks to M.Maire
*        Introduced in the 314 correction cradle.
*        Eliminate TOFG=0 from GINIT, already done in GTRIGI
*        Thanks to F.Carminati
*        Introduced in the 314 correction cradle.
*===> 29/NOV/1990
*        UNIX and BSLASH flags correctly set inside *GEANT.
*        Thanks to A.Nathaniel
*        GPMATE now prints also the components in case of
*        mixtures. If NUMB is <0 then materials from 1 to
*        -NUMB are printed. Thanks to Stephan Egli.
*        Corrections in GRGET (obsolete), GGET, GRIN to reset
*        correctly the number in GCNUM. Thanks to Stephan Egli
*        Introduced in the 314 correction cradle.
*===> 30/NOV/1990
*        New version of GNOELT and GNELTU, thanks to Yoshihisa Iga
*        and R.Nierhaus
*        Introduced in the 314 correction cradle.
*        Correction in GTRAK, all mechanisms turned off in the
*        vacuum. Thanks to S.Egli
*        Introduced in the 314 correction cradle.
*===> 03/DEC/1990
*        New routine GXPICK for the interactive version (Command
*        DRAWING/PICK) to pick a point in a detector and return
*        volume/material characteristics. Thanks to S.Egli.
*===> 04/DEC/1990
*        MAXNOD from 2000 to 8000 in GDTR0. Suggestion by S.Egli.
*        Introduced in the 314 correction cradle.
*        Bug corrected in GGCLOS, do not touch ISEARC in case
*        of user search (ISEARC.GT.0). Thanks to D.Ward.
*        Introduced in the 314 correction cradle.
*===> 05/DEC/1990
*        Correction in TWOB, get correctly Tmin and Tmax and
*        their distribution. Thanks to Marko Mikuz.
*        Introduced in the 314 correction cradle.
*===> 06/DEC/1990
*        Correction in TWOCLU and GENXPT to improve energy
*        conservation. Thanks to S.Egli.
*        Introduced in the 314 correction cradle.
*===> 11/DEC/1990
*        Generic function LOG introduced in GHFRAK. Generic
*        functions MAX and MIN introduced in several routines
*        in GGEOM (HYPE) and CGPACK. Generic SIN, COS, ATAN and
*        SQRT introduced in CGPACK. Thanks to Federico Carminati.
*        Introduced in the 314 correction cradle.
*===> 13/DEC/1990
*        GTAU routine to be obsoleted.
*        Supporting link for the LSCAN data structure mispelled
*        in several places. Corrected now. Thanks to Isabel Josa.
*        Introduced in the 314 correction cradle.
*        Unused variable IPOT eliminated from GHFFER.
*        Changes in the interactive part for ATC GKS which does
*        not use FORTRAN unit for metafiles. (routines GXINT and
*        GXGCON). Thanks to W.Koellner
*===> 14/DEC/1990
*        REAL*8 changed to DOUBLE PRECISION in CGPACK.
*        Life of the D+/- mesons was 100 times too short.
*        Thanks to Cheng He Sheng.
*        Introduced in the 314 correction cradle.
*===> 19/DEC/1990
*        Modification in GDRAW and GDSPEC to correct a bug.
*        Modifications in GLVOLU not to print a warning message
*        caused by drawing.
*        Introduced in the 314 correction cradle.
*===> 20/DEC/1990
*        Correction in GRAYLI affecting Rayleigh effect in
*        mixtures.
*        Introduced in the 314 correction cradle.
*        Recode of GRAYLI and GHESIG to be safer with respect
*        to compiler optimization.
*        Thanks to Rafi Yaari.
*===> 8/JAN/1991
*        Corrections in GRGET, GGET, GRIN to set correctly
*        NPART, NTMED, NMATE, NVOLUM. Thanks to Lee Roberts.
*        Introduced in the 314 correction cradle.
*        New meaning for ISVOL. If <0 the material is not a
*        a detector but the tracking parameters are the same
*        as in the case ISVOL>0 (sensitive medium).
*        Thanks to Michel Maire.
*        Introduced in the 314 correction cradle.
*===> 9/JAN/1991
*        TMAXFD not recomputed with IGAUTO=1 if the value given
*        by the user >= 0. Default value reset to 20. instead of
*        60. degrees. Thanks to W.Mueller and M.Maire
*        Introduced in the 314 correction cradle.
*===> 10/JAN/1991
*        Corrections in GPFIS, GPFISI and GPHYSI for the fotofission
*        and fotoabsorbtion (Giant resonance) of photons on Uranium
*        and plutonium. Thanks to Harm Fesefeld.
*        Introduced in the 314 correction cradle.
*        Correction in GPHYSI in case ILOSS=2 and more than one
*        tracking medium with the same material number then a
*        spurious error message was printed. Thanks to Kevin Sparks
*        Introduced in the 314 correction cradle.
*        Corrections in GENXPT, TWOCLU, TWOB, CINEMA and EXNU.
*        Thanks to Harm Fesefeldt.
*        Introduced in the 314 correction cradle.
*===> 11/JAN/1991
*        Correction in GPPART in case of user words. Thanks to Walter
*        Mueller.
*        Introduced in the 314 correction cradle.
*        Correction in GSTMED to protect for EPSIL <=0. Thanks to
*        Michel Lefebvre.
*        Introduced in the 314 correction cradle.
*===> 14/JAN/1991
*        Correction in GRGET to read the banks in the correct
*        division. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*        Improvement of GRIN, GROUT. New global keywords KINE and
*        TRIG can now be used. Thanks to Federico Carminati
*        Introduced in the 314 correction cradle.
*===> 17/JAN/1991
*        Correction in GSVOLU, GSDVN, GSDVN2, GSDVT, GSDVT2 not to
*        use uninitialized LINATT, set by GDINIT. This should take
*        care of the problem of empty drawings. Thanks to Simone Giani.
*        Introduced in the 314 correction cradle.
*        Correction in GPKINE to print correctly user words and vertex
*        information. Thanks to Kevin Sparks.
*        Introduced in the 314 correction cradle.
*        Correction in GPVERT to print correctly user words and vertex
*        information. Thanks to Soren G. Frederiksen.
*        Introduced in the 314 correction cradle.
*===> 18/JAN/1991
*        Max. GCKING stack size parametrized. The actual value of the
*        stack is not changed (100), but can be redefined in the
*        sequence GCKMAX. Important for LHC studies.
*        Thanks to Harm Fesefeldt.
*        Correction in GPRINT to call correctly GPDIGI and GPSETS.
*        Thanks to Michel Maire.
*        Introduced in the 314 correction cradle.
*===> 22/JAN/1991
*        New facilities of DZDOC introduced in the interactive menu.
*        Patchy flag (DZDOC) to assure backward compatibility.
*        Thanks to O.Schaile
*===> 31/JAN/1991
*        New facility using the JUMPT package to call user routines.
*        Patchy flag (USRJMP) to assure bacward compatibility.
*        Thanks to F.Carminati
*===> 05/FEB/1991
*        Correction in GINIT to print the level of the correction
*        cradle applied. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*        Correction Cradle 3.14/06 stamped and released.
*===> 06/FEB/1991
*        Introduction of the AIX370 flag in GEANX and GEANT.
*        Thanks to Roger Howard.
*===> 13/FEB/1991
*        Protection in GTRACK, GFTRAC and GLTRAC, do not update
*        pointers to cross section banks in the vacuum.
*        Thanks to C.Fuglesang, S.Banerjee, M.Maire.
*        Introduced in the 314 correction cradle.
*???>    Backward incompatibility
*        GFDETH returns NAMESH as a character*4 array and
*        GFDETD returns NAMESD as a character*4 array.
*        Thanks to M.Maire.
*===> 14/FEB/1991
*        Mods in GPMATE, GPPART, GPTMED, GSDK, GSMATE, GSMIXT, GSPART,
*        GSTMED, GSROTM, GPROTM
*        to warn against replacement of existing objects. Thanks to
*        Steve O'Neale.
*        Introduced in the 314 correction cradle.
*        Force load of user routines in GINIT.
*        Introduced in the 314 correction cradle.
*===> 15/FEB/1991
*        GSDVN to notify correctly when mother volume does not exists.
*        Thanks to Victor Perevoztchikov.
*        Introduced in the 314 correction cradle.
*===> 20/FEB/1991
*        Correction in GHEINI for the exponent range to be compatible
*        with IEEE machines. Original limits were for IBM/370.
*        Routine LIMDAT eliminated. Thanks to Hans-Jochen Trost.
*        Introduced in the 314 correction cradle.
*???>    Backward incompatibility
*        Parameter NAMATE returned from GFMATE now a CHARACTER*20
*        variable. Thanks to Michel Maire.
*        Monitoring introduced, flag MONITOR. Thanks to F.Carminati.
*        Mods in GXINT, GINIT, GLAST. Routine GEAMON introduced.
*        Introduced in the 314 correction cradle.
*===> 22/FEB/1991
*        GWORK in GINIT was (DUMMY) called without arguments.
*        GUDTIM was (dummy) called as a routine and it is a
*        function. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*        GUVIEW to specify 3rd argument as a character. Thanks to
*        Federico Carminati.
*        Introduced in the 314 correction cradle.
*        Call NUCRIN with the right number of arguments (the last
*        was not used anyway). Thanks to Federico Carminati.
*        Introduced in the 314 correction cradle.
*===> 04/MAR/1991
*        Correction in GMUSIG to avoid division by zero. Thanks to
*        M.Verzocchi.
*        Introduced in the 314 correction cradle.
*===> 20/MAR/1991
*        Corrections in GPRELM, muon e+e- soft radiation. Correction in
*        GDRELM for the ionization energy loss for muons. Thanks to
*        A.Nathaniel. Introduced in the 314 correction cradle.
*===> 21/MAR/1991
*        Correction in GPHYSI to initialise the JMULOF bank even in
*        the case of vacuum. Electron tracking in vacuum was not taking
*        into account the TMAXFD parameter. Correction in GRANGI to set
*        the range to BIG in case of 0 energy loss tabulated in JLOSS.
*        Correction in GPHYSI to switch off all the mechanisms in the
*        vacuum but decay. The corresponding code in GTRACK has been
*        removed. The previous corrections for IUPD in GLTRAC, GFTRAC
*        and GTRACK have been removed as well. Thanks to D.Ward, R.Brun,
*        F.Carminati
*        Introduced in the 314 correction cradle.
*        Corrections in GRANGI and in GTHADR to cure small steps in
*        tracking. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*===> 25/MAR/1991
*???>    Backward incompatibility
*        GFPART returns NAPART as a CHARACTER*20 array. Thanks to R.Rui
*        Introduced in the 314 correction cradle.
*===> 26/MAR/1991
*        GFTMAT will return the correct values for the vacuum, except
*        for hadrons. Thanks to P.Gumplinger.
*        Introduced in the 314 correction cradle.
*        Correction in GPCXYZ when the number of mechanisms is greater
*        than 6. Thanks to Y.Iga.
*        Introduced in the 314 correction cradle.
*===> 27/MAR/1991
*        GDXYZ corrected to use HIGZ generic line types. Thanks to
*        M.Maire.
*        Introduced in the 314 correction cradle.
*        Correction in the CDF for RZ/IN and RZ/OUT. Thanks to
*        F.Carminati.
*        Introduced in the 314 correction cradle.
*===> 04/APR/1991
*        For reasons of speed GKS-type lines are used now in
*        GDCXYZ, GDXYZ. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*===> 18/APR/1991
*        Correction of the logic for TMAXFD. Now is:
*            AUTO 1: 0<TMAXFD<20  --> accepted
*                      TMAXFD>20  --> set to 20
*                      TMAXFD<=0  --> set to 20
*            AUTO 0:   TMAXFD>0   --> accepted
*                      TMAXFD<=0  --> set to 20
*        Thanks to Gerry Lynch.
*        Introduced in the 314 correction cradle.
*        Correction in GMULOF. STMIN=BIG for the vacuum. Thanks
*        to F.Carminati.
*        Introduced in the 314 correction cradle.
*        Correction in GRFILE, GRIN called with IDVERS=0 and not
*        999. Thanks to F.Carminati.
*        Introduced in the 314 correction cradle.
*===> 22/APR/1991
*        Corrections in GPRELA, GMULOF, GPHYSI and GTNEXT. Now
*        STMIN is set to 0. for vacuum independly of the AUTO
*        flag. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*        Format correction in GSDVN. Thanks to Federico Carminati.
*        Introduced in the 314 correction cradle.
*===> 23/APR/1991
*        Correction in GINIT to initialize LIN via IQTTIN if
*        different from 0. Thanks to F.Carminati
*        Introduced in the 314 correction cradle.
*===> 24/APR/1991
*        New routines GPLMAT, GPRMAT, GPGKIN from Michel Maire.
*===> 25/APR/1991
*        geant.metafile is not opened any more by default.
*        The METAFILE command now accepts the metafile name
*        for packages like ATC-GKS which do not use FORTRAN.
*        Thanks to W.Koellner.
*===> 01/MAY/1991
*        Problem corrected in GHEISH for neutron cascade. A neutron
*        undergoing an hadronic reaction could generate two recoil
*        protons. Thanks to Henk den Bok.
*        Introduced in the 314 correction cradle.
*        Correction in GNEXT/GTNEXT. STMIN not used anymore for
*        MANY volumes. Thanks to M.Maire.
*        Introduced in the 314 correction cradle.
*===> 02/MAY/1991
*        Call to NVETIM routine removed from GHEISHA. Thanks to
*        F.Carminati.
*===> 07/MAY/1991
*        RNDM interactive command added to set the random number
*        generator seeds. Thanks to F.Carminati.
*===> 08/MAY/1991
*        New routine GDTRAK introduced to draw a track and delete
*        it from the JXYZ buffer optionally. Thanks to R.Brun,
*        F.Carminati.
*        Important correction in GTGAMA, GTNEUT to avoid problems
*        due to machine precision. When a push is made to cross a
*        volume boundary the condition that the change in coordinate
*        be not negligible is imposed. Thanks to F.Carminati, R.Brun.
*        Introduced in the 314 correction cradle.
*===> 09/MAY/1991
*        Correction in GMGAUS due to G.Lynch. The sigma of the multiple
*        scattering in the gaussian approssimation was too small.
*        Introduced in the 314 correction cradle.
*===> 14/MAY/1991
*        Corrections in GTELEC, GTHADR and GTMUON to introduce the
*        same boundary correction than in GTNEUT, GTGAMA. Thanks to
*        P.Gumplinger.
*        Introduced in the 314 correction cradle.
*        New menu in GXINT to handle FZ files. Thanks to F.Carminati
*===> 17/MAY/1991
*        Correction in GHFHDN to reset to 0. TOFD. Thanks to
*        R.Rui.
*        Introduced in the 314 correction cradle.
*===> 31/MAY/1991
*        Correction in GTRACK to allow PREC to decrease and avoid
*        problems when changing particle and position but not medium.
*        Thanks to R.Spiwoks.
*        Introduced in the 314 correction cradle.
*===>  4/JUN/1991
*        New version of the hidden line removal, thanks to S.Giani.
*        New menu CVOL introduced to cut volumes and new SHIFT
*        command to shift volumes for drawing.
*        Correction in GHEISH. The ENP parameters are reset to 0.
*        at the beginning of every event. Thanks to Henk den Bok.
*        Introduced in the 314 correction cradle.
*===>  5/JUN/1991
*        Correction introduced in GPHYSI. JTM recalculated after
*        bank push. Thanks to K.Sparks.
*        Introduced in the 314 correction cradle.
*===> 11/JUN/1991
*        Correction introduced in GTELEC, GTMUON, GTHADR. When the
*        energy loss is below machine precision, it is recalculated
*        via the De/Dx table. Thanks to H.Fesefeld and Ralf Spiwoks.
*        Introduced in the 314 correction cradle.
*        Booking of the bank IMAT-4 delayed till GPHYSI. Will save some
*        words in case of materials which are not inserted in a tracking
*        medium. Thanks to F.Carminati.
*???>    Backward incompatibility
*        The argument DMAXMS in the calling sequence of GSTMED, unused
*        in 314, will be called STEMAX and will assume the meaning of
*        maximum step allowed for a particle in the given material.
*        This will only affect people running with AUTO 0. In case of
*        automatic computation of the tracking media parameters, this
*        number will be set to BIG (=1.E10).
*        Thanks to F.Carminati, M.Maire.
*===> 12/JUN/1991
*        Corrections in GMUNU to allow the usage of a variable number of
*        energy bins. Corrections in PHASP and GMUSIG for very high
*        energies. Thanks to Hans-Jochen Trost.
*        Introduced in the 314 correction cradle.
*        Correction in GFLTHE to avoid division by 0. Thanks to
*        Roy Bossingham.
*        Introduced in the 314 correction cradle.
*===> 13/JUN/1991
*        Correction in GINPGO and GINPCO to check correctly the PHI
*        limits. Thanks to R.Bossingham.
*        Introduced in the 314 correction cradle.
*===> 19/JUN/1991
*        Correction in GMUNU to calculate correctly the angle of the
*        incoming muon. Thanks to H-J.Trost.
*        Introduced in the 314 correction cradle.
*===> 20/JUN/1991
*        Corrections in GLANDZ for high energy to avoid numerical
*        problems. Thanks to H-J.Trost.
*        Introduced in the 314 correction cradle.
*===> 26/JUN/1991
*        All the routines and the commons of the HADRIN/NUCRIN
*        package have been renamed. All routines begin now with
*        GHF and all commons with GCF. This to avoid interactions
*        with the interface with FLUKA. Thanks to F.Carminati
*===> 28/JUN/1991
*        New algorithm for pushing a view bank. Now push of the
*        max between MORGS and the 25% of the size of the view
*        bank. Thanks to S.Giani.
*===> 17/JUL/1991
*        Common HIATT of HIGZ removed from GXCONT and workstation type
*        retrieved in GXDZ from Workstation ID. Thanks to O.Couet.
*        Modification in GMUSIG to protect against possible division
*        by zero. Thanks to M.Sarris.
*        Correction in GDSHOW to recalculate COSPSI and SINPSI. Thanks
*        to M.Verzocchi.
*        Introduced in the 314 correction cradle.
*===> 18/JUL/1991
*        Correction in GINVOL. When tracking in magnetic
*        field they could return the wrong volume. Thanks to D.Greiner.
*        Introduced in the 314 correction cradle.
*===> 24/JUL/1991
*        Corrections in GRIN to allow tracking after reading a data
*        structure. Thanks to R.Brun.
*        Introduced in the 314 correction cradle.
*        Modifications in GXINT to allow running with the MOTIF
*        user interface. Thanks to R.Brun.
*===> 31/JUL/1991
*        INT=0 suppressed in GHEISH after nuclear fission.
*        Thanks to Kati Lassila.
*===> 01/AUG/1991
*        Protection introduced in GMUSIG. Thanks to Jochen Trost.
*        Introduced in the 314 correction cradle.
*===> 02/AUG/1991
*        Correction in GHSTOP to fix the calculation of the time of
*        flight for stopping particles. Thanks to L.Roberts.
*        Introduced in the 314 correction cradle.
*        Correction in GNPGON not to calculate safety for the inner
*        radius when this is 0. Thanks to Andrei Nomerotsky.
*        Introduced in the 314 correction cradle.
*        Correction in GNOTRP to return the correct SNXT. Thanks to
*        V.Innocente.
*        Introduced in the 314 correction cradle.
*        Correction in GHSTOP not to discard hadrons at rest, they
*        may decay. Thanks to H.Fesefeld.
*        Introduced in the 314 correction cradle.
*        Modifications in GHSTOP and GHEISH to handle user defined
*        particles. Thanks to P.Gumplinger.
*        Introduced in the 314 correction cradle.
*===> 12/AUG/1991
*        Call to GUINTI added in GINTRI to define user commands. Thanks
*        to V.Vercesi.
*        Introduced in the 314 correction cradle.
*===> 21/AUG/1991
*        Modification in GTMED to print a warning when FIELDM .EQ. 0
*        and IFIELD .NE. 0. Thanks to Federico Carminati
*        Modification in GTHADR to set CFLD = BIG in case FIELDM=0.
*        Thanks to V.Vercesi.
*        Introduced in the 314 correction cradle.
*===> 27/AUG/1991
*        Call to C dummy routine to initialise X11 introduced in
*        GXINT for IBM/VM. Thanks to M.Marquina.
*===> 19/SEP/1991
*        Rayleigh effect now the default. IRAYL is set to 1 by default
*        in GINIT. Thanks to M.Maire
*        Changes in the multiple scattering routines. GMOLI1 and GMOLI2
*        suppressed and GMOLIO used instead. Corresponding changes in
*        GMULTS and GMULOF. The code of GMOLS has been put in line inside
*        GMOLIE and GMOLS is obsolete. GPOISS and GMCOUL modified for
*        performance reasons.
*        Gaussian scattering is now generated according to the Rossi
*        gaussian formula and there is no logarithmic term in the
*        sigma of the gaussian. This gives a distribution where the
*        tails are underestimated, but which is consistent over many
*        steps.
*        Moliere and single Coulomb scattering are chosen according to
*        the value of Omega in the Moliere formula.
*        The new meaning of IMULS is the following:
*              IMULS = 0       No multiple scattering
*              IMULS = 1,2     Moliere or single Coulomb scattering
*              IMULS = 3       Gaussian scattering with Rossi formula
*        Thanks to G.Lynch.
*===> 14/OCT/1991
*         New algorithm for calculation of energy loss. The stopping
*         range is now calculated with a parabolical interpolation
*         instead than with a linear one. This gives a dE/dx curve
*         which is a piecewise linear function and not a step function.
*         Thanks to F.Carminati.
*         Modification of GNOPG1 taking care of the case of a particle
*         which is very near to the surface and it may appear inside due
*         to machine precision. This could cause the volume to be skipped.
*         Thanks to R.Nierhaus.
*         Routine GNPGON rewritten for the calculation of SNXT. The
*         previous routine was returning wrong results. Thanks to
*         R.Nierhaus.
*===> 28/OCT/1991
*         Modifications in the routines GFLPHI and GFCOOR. The ordering
*         for TUBS in phi was wrong. Volumes could become invisible.
*         Thanks to F.Carminati.
*         New routine GFVERT introduced. Retrieves the parameters of a
*         vertex. Thanks to F.Carminati.
*===> 29/OCT/1991
*         Modification in NUCREC to zero the whole of the PV array
*         to prevent the use of uninitiated variables. Thanks to
*         F.Ranjard. Introduced in the 3.14 correction cradel.
*===>  1/NOV/1991
*         Useless code commented out in GTRAIN. Thanks to F.Carminati.
*         GNCONE gone to double precision. Thanks to J.Toth.
*===>  5/NOV/1991
*         Variable USERW undefined in the RESULT common now set to
*         UPWGHT from GCTRAK common. Thanks to F.Ranjard.
*         Type declarations for GCSTAK completed. Thanks to M.Battle.
*===>  5/DEC/1991
*         New calculation of the range table. Simpson integration rule
*         used. Modifications in GRANGI, GCOEFF.
*===> 10/DEC/1991
*         Protection introduced against the reading of a pre-315 data
*         structure. The value of STEMAX is set to BIG in this case.
*         Modification in GPHYSI.
*         Better handling of version numbers in I/O operations.
*         Modifications in GPHYSI and GRIN.
*===> 08/JAN/1992
*         Correction in GLANDZ to avoid gaussian distribution for
*         very thin layers. The version of GEANT 3.13 has been
*         used for this. Thanks to F.Carminati and M.Maire.
*         Corrections in GTNEXT, GINVOL and GTMEDI to protect against
*         wrong values of INGOTO when using MANY volumes. Thanks to
*         R.Brun.
*===> 15/JAN/1992
*???>    Backward incompatibility
*         The random numbers seeds are stored at the end of every event
*         in the JRUNG bank at locations 19 and 20. If the JRUNG data
*         structure is read in and the data card RNDM or the interactive
*         command RNDM has not been issued (NRNDM(1), NRNDM(2) <> 0),
*         and if the words 19/20 are not 0, then the random number
*         generator is restarted with these seeds. Thanks to F.Carminati
*         The RNDM command now reads the values of the seeds into
*         NRNDM(1) and NRNDM(2) in common GCFLAG. The values 0 0
*         can be used for the random seeds. These values will not
*         alter the current status of the random number generator,
*         but zeroing the variables  NRNDM(1) and NRNDM(2) will
*         allow them to be reinitialised with the values stored
*         in a data structure read from disk. Thanks to F.Carminati
*         Routine GREND now needs an integer as input. This is to be
*         consistent with GRFILE.
*===> 27/JAN/1992
*         The following changes made to the names of FLUKA routines
*         to avoid clashes with ISAJET. Thanks to L.Roberts.
*        Type          Original name            New name
*        Routine       DECAY                    FKDECA
*        Routine       FLAVOR                   FKFLAV
*        Routine       SIGINT                   FKSIGI
*===> 31/JAN/1992
*        Corrections in GMEDIA in case of many volumes to avoid
*        program crash. Thanks to R.Jones.
*        Change of logics in GRUN. Now if NEVENT is <= 0, no event
*        is processed. Thanks to B.Lockman.
*        Common GCFLAX put in the GCFLAG sequence with the BATCH and
*        NOLOG variable from GXINT. Thanks to B.Cole.
*        Problem corrected in GDECAY. The mass of the particle was
*        altered. If the next particle was the same, the mass was
*        not reset to its correct value. Thanks to S.Tonse.
*        TIMINT is now really the time left after initiatlization
*        as is specified in the documentation and not the time
*        USED for initialization as it was till now.
*        Thanks to V.Ivanov.
*        Corrections in GNPGON. Improvement of code safety under
*        optimization in GNOGO1, GNPGON, GNPCON. Thanks to Y.Iga.
*===>  4/FEB/1992
*        Corrections in GMULOF and GTHADR. SFIELD takes precedence
*        on STMIN in case IFIELD=1 to make sure that the Runge-Kutta
*        approssimation still works. Thanks to R.Hawkings.
*===> 10/FEB/1992
*         Correction in GDRAY to improve the precision in the calculation
*         of the angle. Thanks to F.Carminati & P.Lubrano.
*         Change in GFKINE. The variable TOFG is not updated any more.
*         Thanks to F.Carminati
*         New GMEDIA, GTMEDI, GINVOL to take care of the problems with
*         MANY volumes. Thanks to R.Jones.
*===> 14/FEB/1992
*         Bug corrected in GNPGON when the particle was exactly on the
*         wall of the last Z section. Thanks to V.Palichik.
*===> 17/FEB/1992
*         Updated routines GLUND, GLUNDI and new sequences LUDAT1, LUDAT3,
*         LUJETS. The data cards MSTE, KTYP, PMAS, PWID, IDB have been
*         removed because either obsolete or not aplicable. The new code
*         runs with JETSET 7.3 upward. Thanks to F.Carminati, T.Sjostrand.
*         Update of GLUDKY to work with 7.3. Thanks to F.Carminati.
*===> 23/FEB/1992
*         New subroutine GFIN to handle sequential input. Routine GGET
*         has been maintained for backward compatibility.
*         Thanks to F.Carminati.
*===> 01/MAR/1992
*         New Runge-Kutta integration routine for the tracking in
*         magnetic field. If the result of the stepping is not accurate,
*         the step is divided in 2 parts and the integration repeated
*         and so on. Thanks to V.Perevotchikov.
*===> 05/MAR/1992
*         Correction in GLTRAC. When the particle fetched has an entry
*         in JKINE the correct vertex number is calculated. Thanks to
*         Y.Foka.
*===> 06/MAR/1992
*         Correction in GTELEC. The calculated range may be slightly
*         larger than the maximum allowed range due to precision
*         problems and this was leading to very small negative steps.
*         Thanks to R.Brun.
*===> 08/MAR/1992
*         New GRKUTA, GHELIX, GHELX3 from V.Perevotchikov.
*===> 16/MAR/1992
*          ENERGY renamed to FKENER in FLUKA. Thanks to F.Carminati
*===> 17/MAR/1992
*          VERTEX->FKVERT, ZEROIN->FKZERO, ERROR->FKERRO in FLUKA.
*          Thanks to F.Carminati
*          Corrections in PBANH. Thanks to M.Sasaki.
*===> 19/MAR/1992
*          Corrections in GFIN, GFOUT and GRIN, version 0 is now allowed
*          for a data structure in I/O. Thanks to B.Cole.
*          Modification in GBREME to improve precision for small angles.
*          Thanks to F.Carminati.
*          Inlining of rotation routines in GFTRAC, GINVOL, GTMEDI,
*          GTNEXT, GMEPOS, GMEDIA. Thanks to D.Kryn, F.Carminati.
*          New routines GDLENS, GDPLST and GDPRTR in the drawing package.
*          New version of GDTREE. Thanks to S.Giani.
*          Streamlining of GDTOM, GINROT, GITRAN, GMTOD, GRMTD, GRMUL,
*          GROT, GTRMUL and GTRNSF. Thanks to F.Carminati.
*===> 23/MAR/1992
*???>    Backward incompatibility
*           Tracking medium name in GFTMED changed in CHARACTER variable.
*           Thanks to V.Perevotchikov.
*           IMPULS renamed to FKIMPU
*           DRES   renamed to FKDRES
*           ERUP   renamed to FKERUP in FLUKA. Thanks to F.Carminati.
*===> 24/MAR/1992
*       COSI entry point renamed to FKCOSI
*       POLI             renamed to FKPOLI in FLUKA. Thanks to F.Carminati
*       Changes in GCOMP to increase the precision of the rotation
*       of the scattered photons and electrons in the reference
*       frame of the incoming particle. Thanks to F.Carminati
*       New version of the routines GNOPG1 and GNPGO1. Speed up of
*       a factor two or more achieved. Thanks to F.Carminati,
*       M.Roethlisberger.
*===> 29/MAR/1992
*       Improvement of the routines GMEDIA, GTMEDI and GINVOL. A better
*       use is made of the variable INGOTO. Thanks to R.Jones, F.Carminati.
*===> 01/APR/1992
*       Modification in GTRACK. If a particle tries for more than 5 times
*       consecutively to exit a volume, the precision used for tracking is
*       multiplied by 5 and so on every fifth attempt. Thanks to
*       F.Carminati.
*       Modification in FLUFIN to normalise in double precision the
*       direction cosines given to FLUKA. Thanks to A.Ferrari
*       Modification in GLANDZ to avoid peaks in energy loss for very
*       light materials. Thanks to F.Carminati
*       New routine GETVER to crack the title sequence and to return
*       the correct version number. Thanks to F.Carminati and M.Maire.
+DECK,  V_316, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:19:48  cernlib
* Geant
+CDE, CERNLIB_MACHINE.

*     Correction cradle for version 3.15 of the GEANT Programme
*     and history of the evolution of 3.16.
*               Important !!!
*               =============
*     Only corrections flagged by "Introduced in the 3.15 correction
*     cradle" are applied to 3.15. All the other comments refer
*     to modifications which will appear in the 3.16 version of
*     the program.
********************************************************************
*===> 06/12/93
*           Release of the 3.11 correction cradle.
*===> 02/12/93
*           Correction in GBRELE and GRANGI. Thanks to F.Carminati.
*           Introduced in the 3.15 correction cradle.
*===> 29/11/93
*           Release of the 3.10/00 correction cradle.
*===> 21/10/93
*          Correction in FKDECA and HADEVV to permit the correct
*          treatment of charmed particles decay. Thanks to
*          A.Ferrari. Introduced in the 3.15 correction cradle.
*          Correction in FKDRES to avoid a loop. Thanks to
*          B.Slater and A.Ferrari. Introduced in the 3.15 correction
*          cradle.
*===> 20/10/93
*          Correction in GDRAW to update current pointer to IN
*          bank. Correction in GGPPAR to compute the internal
*          parameters of a TRAP with negative parameters. Thanks
*          to S.Banerjee. Introduced in the 3.15 correction cradle.
*===> 19/10/93
*           Correction in GTNEUT, GTHADR, to allow hadronic decay
*           in the vacuum. Thanks to R.Jones. Introduced in the
*           3.15 correction cradle.
*===> 01/10/93
*           Correction in GNSLWD to avoid numerical problem. Thanks
*           to A.Parri. Introduced in the 3.15 correction cradle.
*===> 15/09/93
*           Release of the 3.09/00 correction cradle.
*===> 13/09/93
*           Correction in GNOCTU, thanks to M.Nessi. Introduced in
*           the 3.15 correction cradle.
*===> 03/09/93
*           Correction in EVENTV to protect square root of a negative
*           number. Thanks to B.Slater and A.Ferrari. Introduced in
*           the 3.15 correction cradle.
*===> 11/08/93
*           New tratment for thin layer, mainly gas, of dE/dx
*           introduced. Thanks to V.Grishin, S.Kotelnikov,
*           K.Lassila-Perini and P.Nevski.
*           All bit manipulation functions replaced by Military
*           Standard functions. Thanks to F.Carminati.
*===> 19/07/93
*           Correction in FLUFIN in order to avoid 0 mechanism
*           number when IHADR=2. Thanks to P.Bloch. Introduced
*           in the 3.15 correction cradle.
*           Correction in GSROTM, NROTM updated when the bank is
*           pushed. Thanks to M.Maire. Introduced in the 3.15
*           correction cradle.
*           Correction in ERTRGO. Thanks to E.Nagy. Introduced
*           in the 3.15 correction cradle.
*===> 07/06/93
*           Release of version 3.08 of the correction cradle.
*           New version of the FLUKA interface introduced. New
*           model for energy straggling introduced (Ermilova&
*           Checkin) and synchrotron radiation. Thanks to K.
*           Lassila-Perini, A.Ferrari&P.Sala et al. and I.
*           Gavrilenko. Please see the documentation for more
*           information.
*           New routine GFANG introduced. It finds the angles
*           Theta and Phi which are used to rotate a vector in
*           the master system of the other. Thanks to F.Carminati
*           New rotine GVROT introduced. It will rotate in full
*           double precision a vector in the reference system of
*           another one. Thanks to F.Carminati
*           Corrections in GRIN/GFIN to calculate correctly the
*           number of rotation matrixes. Thanks to M.Maire.
*           Introduced in the 3.15 correction cradle.
*           Correction in FLUFIN to pass antiprotons to FLUKA when
*           they are 'stopping'. Thanks to A.Ferrari. Introduced in
*           the 3.15 correction cradle.
*===> 27/05/93
*           Corrections in FLUFIN to pass stopping antiprotons,
*           antineutrons and pions to FLUKA for annihilation. The
*           other hadrons are either decayed or (neutral particles)
*           passed to GHEISHA/GHSTOP.
*===> 04/05/93
*           Correction in FDNOPT to properly initialise an
*           array. Thanks to K.Lassila-Perini. Introduced in
*           the 3.15 correction cradle.
*===> 21/04/93
*           New routine from Laszlo Urban for the tracking of
*           ions, GTHION. Ions now have to be given particle
*           type 8. Thanks to L.Urban.
*===> 18/04/93
*           Addition in GPPERP, the sphere has been added. Thanks
*           to R.Jones.
*           Old Hadrin/Nucrin interface deleted. HADR 3 flag has
*           no meaning any more. Warning message introduced in
*           GPHYSI, when IHADR=3 then reset it to 1 and use GHEISHA.
*           Thanks to F.Carminati.
*           Tatina code eliminated from GEANT. Thanks to F.Carminati.
*           Small changes in GSCHIT to avoid integer/floating
*           conversions and to speed-up the code. Thanks to
*           F.Carminati.
*===> 07/04/93
*           Correction in the GPOISS routine to avoid overflows.
*           Thanks to S.Qian. Introduced in the 3.15 correction
*           cradle.
*===> 06/04/93
*           Correction in GNSPHR to avoid floating point overflow.
*           Thanks to S.Ljungfelt. Introduced in the 3.15 correction
*           cradle.
*===> 22/03/93
*           Correction in GEAMON to extend the field for CPU
*           time. Thanks to R.Brun. Introduced in the 3.15
*           correction cradle.
*===> 14/03/93
*           Release of version 3.07 of the correction cradle.
*           Corrections in GZINIT, GPHYSI and GDSHOW. The
*           working space is now allocated via calls to
*           GWORK. GWORK has been modified and it only
*           increases the working space, it never reduces it.
*           Thanks to M.Corden. Introduced in the 3.15
*           correction cradle.
*===> 10/03/93
*           Correction in GFIN/GFOUT to avoid spurious error
*           message. Thanks to M.Maire.
*===> 03/03/93
*           Correction in GLTRAC to improve the precision of
*           the calculation of the kinetic energy. Thanks to
*           C.Zeitnitz. Introduced in the 3.15 correction
*           cradle.
*           Correction in GTRACK to avoid output overflow in
*           format statement. Thanks to M.Corden. Introduced
*           in the 3.15 correction cradle.
*           Correction in GDXYZ to obtain the correct line color
*           for a track. Thanks to M.Corden. Introduced in the
*           3.15 correction cradle.
*===> 02/03/93
*           New treatment of the photoelectric effect introduced.
*           Thanks to J.Chwastowski. Please see documentation for
*           more information.
*===> 01/03/93
*           Changes in GKGEOM to avoid warnings with the new
*           version of KUIP. Thanks to A.Nathaniel. Introduced
*           in the 3.15 correction cradle.
*           Changes in GSDVN2 to support division of spheres
*           in PHI with initial offset. Thanks to F.Carminati.
*           Changes in GMEDIV and GNSPHR to correct precision
*           problems. Thanks to F.Carminati.
*           Introduction of the Cerenkov effect. Thanks to
*           R.Jones. Please see documentation for more
*           details.
*===> 12/02/93
*           Changes in GSDVN to support division in PHI (axis
*           N. 3) of the sphere. Thanks to F.Carminati.
*           Changes in GDRAWS to partially support the drawing
*           of parts of sphere. Thanks to F.Carminati.
*===> 09/02/93
*           Release of version 3.06 of the correction cradle.
*===> 28/01/93
*           Correction in GXINT for compatibility with the KUIP
*           installed with version 93a of the CERN Program Library.
*           Thanks to R.Jones. Introduced in the 3.15 correction
*           cradle.
*===> 27/01/93
*           Correction in GMUNU. Only GHEISHA used to handle the
*           interaction irrespective of the value of IHADR. Thanks
*           to K.Lassila-Perini and G.Battistoni. Introduced in the
*           3.15 correction cradle.
*           Corrections in GGPPAR to handle a tube with negative
*           parameters positioned into a tubes in the general case.
*           Thanks to F.Carminati.
*===> 19/01/93
*           Correction in FLUFIN to make sure that just neutrons
*           are passed to GHEISHA. Thanks to K.Lassila. Introduced
*           in the 3.15 correction cradle.
*===> 21/12/92
*           Option Q(uiet) introduced in GRIN/GROUT. Thanks to
*           M.Maire.
*           New version of GRKUTA protected against 0 fields and
*           improved for precision. Introduced in the 3.15 correction
*           cradle. Thanks to W.Manner.
*===> 15/12/92
*           IQ(JRUNG+29) set to the event sequence number of the
*           last generated event in GTRIGC. Thanks to M.Maire.
*===> 11/12/92
*           Call to LUPART replaced with LU1ENT in GLUDKY. LUPART
*           was an obsolete routine deleted from JETSET 7.3
*           library. Thanks to R.Gomes.
*===> 23/11/92
*           Release of the version 3.05/00 of the correction
*           cradle.
*           Corrections in GRANGI to account for the use of the
*           ERAN card. Thanks to P.Gumplinger. Introduced in the
*           3.15 correction cradle.
*===> 18/11/92
*           Correction in GDRAWS for very thin CTUBes. Thanks to
*           M.Guidal. Introduced in the 3.15 correction cradle.
*           New version of GRKUTA introduced. It will limit the
*           number of iterations and cut steps to prevent looping.
*           Thanks to V.Perevotchikov. Introduced in the 3.15
*           correction cradle.
*===> 11/11/92
*           Correction in GGDSPE to allow repeated division of
*           tubes along R. Thanks to M.Maire. Introduced in the
*           3.15 correction cradle.
*===> 11/11/92
*           Correction in GNPCON when the particle is slightly
*           outside of the last plane in Z. It could happen for
*           precision problems. Thank to C.Georgiopoulos.
*           Introduced in the 3.15 correction cradle.
*           Quiet option introduced in GFIN and GFOUT to suppress
*           printing. Thanks to A.Eisner.
*           Correction in the header of GFIN, GFOUT. Thanks to
*           A.Eisner.
*           Correction to GSNEXT. It now checks the values of the
*           input list. Repeated values or values which are not
*           within the allowed limits are ignored and a warning
*           message is printed. Thanks to F.Luehring.
*===> 04/11/92
*           Modification in GSVOLU. A warning is printed if the same
*           volume name is repeated twice. Thanks to V.Perevoztchikov.
*===> 23/10/92
*           Print statement in GSKING replaced by a WRITE(CHMAIL
*           Thanks to F.Carminati.
*===> 19/10/92
*           Correction in GDRAY to increase the precision of
*           the angle calculation. Thanks to F.Malek.
*           Introduced in the 3.15 correction cradle.
*===> 19/10/92
*           Release of version 3.04 of the correction cradle.
*           Corrections in FEREVV and HADEVV. Thanks to A.Ferrari.
*           Introduced in the 3.15 correction cradle.
*===> 16/10/92
*           Release of version 3.03 of the correction cradle.
*===> 13/10/92
*           Correction in GFIN and GFOUT to handle correctly
*           ZEBRA error conditions. Thanks to H.Uijterwaal.
*           Introduced in the 3.15 correction cradle.
*           Correction in GDECAY to improve precision of rotation
*           of secondaries. Thanks to F.Carminati. Introduced in
*           the 3.15 correction cradle.
*           Correction in FEREVV to avoid square root of negative
*           number. Thanks to A.Ferrari. Introduced in the 3.15
*           correction cradle.
*           Correction in GDRAW to avoid error when traversing the
*           tree. Thanks to F.Carminati. Included in the 3.15
*           correction cradle.
*===> 09/10/92
*           Correction in GXPICT, added definition of a character
*           variable. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*===> 08/10/92
*           Corrections in ERPRDOC, EUFILV and ERTEST to change
*           Hollerith in characters for GEANE. Thanks to V.Innocente.
*           Introduced in the 3.15 correction cradle.
*===> 24/09/92
*           Correction in NUCREL to avoid square root of negative
*           numbers. Thanks to A.Ferrari. Introduced in the 3.15
*           correction cradle.
*===> 23/09/92
*           Correction in GMEDIA. INFR not set going up the tree to
*           avoid problem with user calls of GMEDIA during tracking.
*           Thanks to S.Banerjee. Introduced in the 3.15 correction
*           cradle.
*===> 21/09/92
*           Correction in GRANGI to avoid interpolation of DE/DX
*           beyond 10GeV. Thanks to V.Innocente. Introduced in the
*           3.15 correction cradle.
*===> 16/09/92
*           Correction in GBRELA. Auxiliary integration point for
*           muon dedx table was wrong. Thanks to V.Innocente.
*           Introduced in the 3.15 correction cradle.
*===> 15/09/92
*           Release of version 3.02 of the correction cradle.
*           Correction in GMEDIA, GTMEDI: JVIN not properly
*           initialised. Thanks to F.Carminati. Introduced in
*           the 3.15 correction cradle.
*           Release of version 3.01 of the correction cradle.
*           Correction to GSDVN for a mistype. Thanks to H.Plothow.
*           Introduced in the 3.15 correction cradle.
*           Small mod to GSNGTR for the CRAY. Function DSIGN changed
*           to SIGN. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*           Release of version 3.00 of the correction cradle.
*           Correction in GDECAY. When IDCAY=2 the routine does not
*           produce secondaries. Thanks to R.Jones. Introduced in
*           the 3.15 correction cradle.
*           Corrections in GFIN, GFOUT. Thanks to B.Cole. Introduced
*           in the 3.15 correction cradle.
*===> 14/09/92
*           Correction in GMEDIV, GMEDIA, GINVOL, GTMEDI to
*           improve precision and prevent blocking of volumes.
*           Thanks to F.Carminati, R.Jones. Introduced in the
*           3.15 correction cradle.
*===> 03/09/92
*           GDLADY and GDMISS routines introduced. Thanks to
*           H.Plothow.
*           Correction in GXDRAW for the coordinates of the
*           drawing of the GIRL. Thanks to F.Carminati.
*           Introduced in the 3.15 correction cradle.
*           Correction in GPHSIG, typing mistake in a formula.
*           Thanks to M.Fanti. Introduced in the 3.15 correction
*           cradle.
*===> 02/09/92
*           Corrections in GSDVN, GGPPAR, GGDPAR, GMEDIV, GCENT,
*           GSDVN2, GSDVT, GSDVT2 to allow the division of a TRAP
*           along y. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*           Corrections in GNPGO1 for precision problems. Thanks
*           to K.Lassila. Introduced in the 3.15 correction
*           cradle.
*           Corrections in GGDPAR, GSDVN for the z division of a
*           Polygone. Thanks to F.Carminati. Introduced in the
*           3.15 correction cradle.
*===> 01/09/92
*           Correction in GSDVT for the division of a parallepiped.
*           Thanks to Y.Fisiak. Introduced in the 3.15 correction
*           cradle.
*           Correction in GRKUTA. Helix is used if angle of
*           curvature is too large. In this case step is anyway
*           smaller than STMIN which is under user control.
*           Thanks to H.Plothow and V.Perevotchikov. Introduced
*           in the 3.15 correction cradle.
*===> 26/08/92
*           Correction in GKRZ and CDF for the command RZ/FILE.
*           Record lenght fixed at 1024 in GRFILE cannot be
*           Changed by the user. Thanks to H.Plothow. Introduced
*           in the 3.15 correction cradle.
*           Corrections in GTMEDI, GMEDIA and GINVOL for the case
*           of 'MANY' volumes. Uncleared blocking words found in
*           the tree. Thanks to H.Plothow. Introduced in the 3.15
*           correction cradle.
*===> 25/08/92
*           Correction in GNSPHR. The PHI limits were used
*           incorrectly in calculating the distance to the
*           sphere. This was slowing down calculation but still
*           giving correct results. Thanks to J.Stepanek.
*           Introduced in the 3.15 correction cradle.
*===> 21/08/92
*           Correction in GGORDQ. Incorrect counting of volumes
*           in case of phi ordering and phi division spanning
*           across 0 degrees. Thanks to L.Roberts and F.Carminati.
*           Introduced in the 3.15 correction cradle.
*===> 18/08/92
*           Version 2.00 of the correction cradle released
*           Correction in GDRELP and GDRELM. The shell corrections
*           where underestimated due to a wrong factor introduced
*           translating the original formula from ev to Gev. Thanks
*           to A.Ferrari and K.Lassila-Perini. Introduced in the
*           3.15 correction cradle.
*===> 17/08/92
*           Correction in GCENT in case of general trapezoid sliced
*           in z in a local development structure.
*           Thanks to S.Chekhtman. Introduced in the 3.15 correction
*           cradle.
*           Correction in GHEISH. Time of flight correctly initialised
*           for particles with number > 48. Thanks to A.Eisner.
*           Introduced in the 3.15 correction cradle.
*===> 14/08/92
*           Correction in GGPPAR for boxes with negative parameters
*           in traps. The current code supports correctly boxes with
*           one, two or three negative parameters positioned in a trap
*           not necessarily in the centre. The trap must not be twisted
*           and the ALP1 and ALP2 angles (PAR(7) and PAR(11)) must be
*           equal. This facility must be used with care because the
*           algorithm first maximises Z, then Y and then X. The result
*           may be not quite what is expected in all cases, and the
*           user is invited to check carefully the result. Thanks to
*           H.Plothow. Introduced in the 3.15 correction cradle.
*===> 12/08/92
*           Correction in GINVOL, GTMEDI and GMEDIA to handle correctly
*           the GSNEAR case when LIST(1)=1 and LIST(2)=0, that is when
*           all the volume are separated inside a mother. Optimisation
*           of the routine in case a large number of objects are
*           positioned at the same level and GUNEAR is used. Thanks to
*           R.Jones, M.Lefebvre and M.Pieri. Introduced in the 3.15
*           correction cradle.
*===> 07/08/92
*           Correction in GTNEXT. When the currents step brings
*           the particle on the surface of the next volume, signal
*           IGNEXT=1 to GTxxxx to 'push' into the next volume.
*           This is a genuine bug and some volumes may be lost
*           due to this. Thanks to M.Maire. Introduced in the 3.15
*           correction cradle.
*===> 02/08/92
*           Corrections to the precision in GNOPG1, GNCONE, GNOCON.
*           Thanks to R.Jones. Introduced in the 3.15 correction
*           cradle.
*===> 31/07/92
*           Correction in the printout of GTRACK when max number
*           of steps is reached. Event number and random numbers are
*           printed out as well. Thanks to M.Maire. Introduced in the
*           3.15 correction cradle.
*===> 29/07/92
*           Correction in PIMABS for HPUX only. If variable NT is
*           saved then the routine compiles correctly, otherwise
*           not. Thanks to F.Carminati. Introduced in the 3.15
*           correction cradle.
*           Correction in NIZL. All local variable are saved now.
*           Thanks to F.Carminati. Introduced in the 3.15 correction
*           cradle.
*===> 29/07/92
*           Correction in CDF and in GKDRAW. Minimum angle for the
*           drawing is 0 and not 1. Thanks to H.Plothow. Introduced
*           in the 3.15 correction cradle.
*           Minor update of GXFZ, a character length has been set
*           to 4 to keep KUIP happy. Thanks to F.Carminati. Introduced
*           in the 3.15 correction cradle.
*===> 28/07/92
*           Corrections in GXFZ. Now the array LUNITS is properly
*           updated when a file is closed.
*           Correction in GBRSGE, GBRSGM. Save statement introduced.
*           Thanks to L.Roberts. Introduced in the 3.15 correction
*           cradle.
*           Correction in GINVOL for many volumes. Thanks to S.Giani
*           and R.Jones. Introduced in the 3.15 correction cradle.
*           Correction in GMCOUL to prevent a division by 0. Thanks
*           to M.Maire. Introduced in the 3.15 correction cradle.
*===> 03/06/92
*           Correction in GSNGTR. Double precision variables removed
*           in case of 64 bits machines. Thanks to E.Boehm. Introduced
*           in the 3.15 correction cradle.
*           Correction in the SROTM command. The lower limit for
*           PHI3 is really 0. and not 1. Thanks to E.Boehm. Introduced
*           in the 3.15 correction cradle.
*===> 01/06/92
*           New version of GRKUTA. In fact this is the 3.14 version
*           with the multiple steps algorithm of 3.15 introduced.
*           If the bending angle in one step is too big, then the
*           integration is done in several steps rather than in
*           one. The IMPLICIT REAL*8 in the cradle is to avoid
*           problems with the CRAY in the absence of PATCHY delayed
*           control cards. Thanks to V.Perevotchikov. Introduced in
*           the 3.15 correction cradle.
*===> 25/05/92
*           Sequence GCONSP changed for 32 bits machines. All
*           constants are suffixed with D0 to avoid truncations.
*           Thanks to F.Carminati. Introduced in the 3.15 correction
*           cradle.
*===> 25/05/92
*           Version 1.00 of the correction cradle released
*===> 21/05/92
*          Correction in GHFNUC: TNNUC variable was undefined.
*          Thanks to B.Lund-Jensen.
*          Introduced in the 3.15 correction cradle.
*===> 08/05/92
*          Correction in TWOCLU to avoid infinite looping in some
*          pathological cases. Thanks to L.Roberts.
*          Introduced in the 3.15 correction cradle.
*===> 06/05/92
*          Correction in GNPGO1. Constants changed to double
*          precision to avoid problems on the IBM. Thanks to
*          D.Ward.
*          Introduced in the 3.15 correction cradle.
*===> 28/04/92
*          Correction in GXINT to obtain the correct time in
*          the monitoring routine when running interactively
*          on IBM/VM. Thanks to F.Carminati.
*          Introduced in the 3.15 correction cradle.
*===> 16/04/92
*          Correction in GMULTS. A particle going exactly along
*          the negative direction of the Z axis could be rotated
*          of 180 degrees after multiple scattering. Thanks to
*          P.Gabriel.
*          Introduced in the 3.15 correction cradle.
*===> 15/04/92
*          Correction in GXDRAW. The arguments of DHEAD were
*          fetched with the wrong order. Thanks to F.Videbaek.
*          Introduced in the 3.15 correction cradle.
*          Correction in GPHYSI. Variable NUMOLD is now reset to
*          zero. This may affect people running interactively and
*          using the command PHYSI. Thanks to F.Videbaek.
*          Introduced in the 3.15 correction cradle.
+PATCH, DOC_GHDOC.
+DECK,  BLANK_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**
C**   THE BLANK-COMMON IS USED FOR KINEMATIC-CALCULATIONS WITH THE
C**   VECSUB-ROUTINE (2000 WORDS) AND FOR CERN-HBOOK PLOTTING
C**   SYSTEM. IF THE PLOTS ARE FILLED IN THE MEMORY, DO NOT FORGET
C**   A HISTGO(2000)- STATEMENT IN THE ANALYSIS-ROUTINE.
C**   THE DESY-GEP-HBOOK FACILITY DOESN'T USE THE MEMORY, SO THE
C**   BLANK-COMMON MUST ONLY BE INITIALISED FOR 2000 WORDS.
C**   THE NORMAL FILLING OF THE PV-VECTORS IN KINEMATIC CALCULATIONS
C**   ARE AS FOLLOWS:
C**   PV(1,*) = PX  (OR PX/P)
C**   PV(2,*) = PY  (OR PY/P)
C**   PV(3,*) = PZ  (OR PZ/P)
C**   PV(4,*) = ENERGY
C**   PV(5,*) = MASS (SOMETIMES NEGATIVE)
C**   PV(6,*) = CHARGE
C**   PV(7,*) = TIME OF FLIGHT
C**   PV(8,*) = PARTICLE INDEX (SEE #MASIND)
C**   PV(9,*) = 0.
C**   PV(10,*)= USERWORD
C**
+DECK,  CONSTS_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**
C** IN THE /CONSTS-COMMON ARE SOME PARTICLE CONSTANTS
C**
C**  PI        3.1425927
C**  TWPI      2*PI
C**  PIBTW     PI/2.
C**  MP        MASS OF PROTON
C**  MPI               PION
C**  MMU               MUON
C**  MEL               ELECTRON
C**  MKCH              CHARGED KAON
C**  MK0               NEUTRAL KAON
C**  SMP       SQRT(MP)
C**  SMPI      SQRT(MPI)
C**  SMU       SQRT(MMU)
C**  CT        CT OF PIONS
C**  CTKCH           CHARGED KAON
C**  CTK0            NEUTRAL KAON
C**  ML0       MASS OF LAMBDA
C**  MSP               SIGMA+
C**  MS0               SIGMA0
C**  MSM               SIGMA-
C**  MX0               CHI0
C**  MXM               CHI-
C**  CTL0      CT OF LAMBDA
C**  CTSP            SIGMA+
C**  CTS0            SIGMA0
C**  CTSM            SIGMA-
C**  CTX0            CHI0
C**  CTXM            CHI-
C**
+DECK,  CURPAR_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C** WEIGHT(1)   |  WEIGHTS FROM THE GENERATOR INPUT.
C** .           |  NOT USED IN THE PROGRAM.
C** .           |  TAKEN FROM INPUT-ROUTINES, DEFAULT-VALUES=1.
C** .           |  THE TOTAL WEIGHT IS CALCULATED AS SUM(WEIGHT(I))
C** WEIGHT(10)  |
C**
C** DDELTN         STEPSIZE AS CALCULATED BY STEPPING ROUTINE ALEX.
C**                DELTN IN RESULT-COMMON IS INITIALLY THE SAME, BUT
C**                MAY BE CHANGED DURING THE STEP (INTERACTION,DECAY).
C** IFILE          NUMBER OF INPUT-ROUTINE TO BE CALLED (=0,1,...9)
C**                (FROM INIT)
C** IRUN           RUN-NUMBER (FROM INIT, NOT USED IN PROGRAM)
C** NEVT           EVENT-NUMBER
C** NEVENT         TOTAL NUMBER OF EVENTS TO BE PROCESSED(FROM INIT)
C** SHFLAG         FLAG FOR ELECTROMAGNETIC SHOWERS(FROM INIT)
C**                = 0    EGS
C**                > 0    GHEISHA ELECTROMAGNETIC SHOWER ROUTINES
C**                       WITH ONE-DIMENSIONAL PARAMETRIZATIONS BELOW
C**                       THE CUT-OFF ENERGY CENG(1)
C**                      (DO NOT USE THEM WITHOUT CAREFUL CHECKS)
C** ITHST          THE RUN SHOULD STOP ITHST SECONDS BEFORE END OF
C**                GO-STEP  (FROM CUTS)
C** ITTOT          TOTAL TIME FOR GO-STEP
C** ITLST          REMAINING TIME FOR GO-STEP
C** IFRND          COUNTER FOR USED LOCATIONS IN STACK
C** TOFCUT         TIMING-CUT (IN 1/20. NSEC)  (FROM CUTS)
C** CMOM(1)    |   MOMENTUM CUTS FOR VARIOUS THINKS,
C** CMOM(2)    |   DO NOT CHANGE THEM !!!!!
C** CMOM(3)    |
C** CMOM(4)    |
C** CMOM(5)    |
C** CENG(1)        ENERGY CUT-OFF FOR ELECTROMAGNETIC PARTICLES(CUTS)
C**                BELOW THIS ENERGY PARAMETRIZATIONS ARE USED.
C** CENG(2)        ENERGY CUT-OFF FOR MUON-BREMSSTRAHLUNG.
C**                THESE TWO NUMBERS HAVE BEEN CAREFUL ADJUSTED ACCORDIN
C**                G TO THE DEDX-FORMULA USED IN THE GHEISHA-ELECTRO-
C**                MAGNETIC SHOWER TREATMENT. THUS DO NOT CHANGE THEM
C**                WITHOUT THINKING ABOUT THE CONSEQUENCES.
C** CENG(3)        ENERGY CUT-OFF FOR CHARGED HADRONS(FROM CUTS)
C** CENG(4)        ENERGY CUT-OFF FOR NEUTRAL HADRONS(FROM CUTS)
C** CENG(5)        ENERGY CUT-OFF FOR DELTA-RAYS, BELOW THIS ENERGY
C**                DELTA-ELECTRONS ARE ONLY TRACKED, ABOVE THIS ENERGY
C**                THEY ARE STORED ON THE STACK AND TREATED WITH
C**                THE RESPECTIVE SHOWER ROUTINES (GHEISHA OR EGS).
C** THE FOLLOWING QUANTITIES ARE USED IN NUCLEAR CASCADE-ROUTINES
C**
C** RS             CENTER OF MASS ENERGY
C** S              (CENTER OF MASS ENERGY)**2
C** NP             |
C** NM             |OTHER QUANTITIES USED INTERNALLY IN
C** NN             |CASCADE-ROUTINES
C** NR             |
C** NO             |
C** NZ             |
C** IPA(1)-IPA(200)|
C** ATNO2          ACTUAL ATOMIC NUMBER OF NUCLEUS(FOR COMPOUNDS)
C** ZNO2           ACTUAL CHARGE NUMBER OF NUCLEUS(FOR COMPOUNDS)
C**
+DECK,  ERRCOM_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**
C** THE COMMON /ERRCOM CONTAINS FLAGS AND COUNTERS FOR VARIOUS
C** PURPOSES:
C**
C** IER(1)    ALEX: NUMBER OF TRACKS LEAVING DETECTOR
C** IER(2)    ALEX: STEPPING ERRORS
C** IER(3)    ALEX:
C** IER(4)    ALEX:
C** IER(5)    FINDCE: SUCCESSFUL CALLS
C** IER(6)    NEXCEL: TOTAL CALLS
C** IER(7)    NEXCEL: NEXT CELL FOUND
C** IER(8)    NEXCEL: PREVIOUS CELL FOUND
C** IER(9)    NEXCEL: FIRST CELL OF NEXT CALORIMETER
C** IER(10)   NEXCEL: LAST CELL OF PREVIOUS CALORIMETER
C** IER(11)   NEXCEL: RECOVERY
C** IER(12)   NEXCEL: OUTSIDE DETECTOR
C** IER(13)   CALIM : NUMBER OF GARBAGE COLLECTIONS
C** IER(14)   TRACK : DEDX > AVAILABLE ENERGY
C** IER(15)   MFSTP : NO SETTING OF M.F. PARAMETERS
C** IER(16)   MFSTQ : NO SETTING OF M.F. PARAMETERS
C** IER(17)   SELECT: TRACKS SKIPPED
C** IER(18)
C** IER(19)
C** IER(20)   ASMDK : TOTAL NUMBER OF S-B DECAYS
C** IER(21)   ALODK
C** IER(22)   ASODK
C** IER(23)   ASPDK
C** IER(24)   AXMDK
C** IER(25)   AXODK
C** IER(26)   KCHDK
C** IER(27)   KODKY
C** IER(28)   KOLDKY
C** IER(29)   LODKY
C** IER(30)   MUDKY
C** IER(31)   PIDK
C** IER(32)   PIODKY
C** IER(33)   SMDKY
C** IER(34)   SODKY
C** IER(35)   SPDKY
C** IER(36)   XMDKY
C** IER(37)   XODKY
C** IER(38)
C** IER(39)
C** IER(40)   CASMU : TOTAL NUMBER OF MU NUCLEUS INTERACTIONS
C** IER(41)   INTACT: TOTAL NUMBER OF ELASTIC HADRON NULEUS INTERACTIONS
C** IER(42)   INTACT:   "     "      QUASI-ELASTIC     "       "
C** IER(43)   INTACT:   "     "      INELASTIC         "       "
C** IER(44)
C** IER(45)
C** IER(46)   COSCAT: TOTAL NUMBER OF CALLS
C** IER(47)   TWOB  :
C** IER(48)   TWOCLU:
C** IER(49)   GENXPT:
C** IER(50)   STPAIR:
C** IER(51) > CASCADE-ROUTINES: TOTAL NUMBER OF CALLS
C** IER(52) >    "      "
C** .       >
C** .       >
C** .       >
C** IER(80) >    "      "
C** IER(81)   CAPTUR
C** IER(82)   FISSIO
C** IER(83)   IPFISS
C** IER(84)   KMABS
C** IER(85)   NBANH
C** IER(86)   PBANH
C** IER(87)   PIMABS
C** IER(88)   DELRAY: DELTA-RAYS STORED ON STACK
C** IER(89)   DELRAY: DELTA-RAYS NOT STORED ON STACK
C** IER(90)   GBREMS
C** IER(91)   GPAIR
C** IER(92)   MBREMS
C** IER(93)
C** IER(94)
C** IER(95)
C** IER(96)
C** IER(97)
C** IER(98)
C** IER(99)
C** IER(100)
C**
+DECK,  EVENT_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**
C**  THE /EVENT COMMON IS THE STACK, WHERE ALL PARTICLES PRODUCED
C**  IN A SHOWER ARE STORED. ONE TRACK HAS 12 LOCATIONS .
C**
C**  NSIZE = TOTAL LENGTH OF THE STACK (TO BE SET IN BLOCK-DATA)
C**  NCUR  = POINTER TO THE TRACK WHICH SHOULD BE COPIED NEXT FROM
C**          THE STACK TO THE RESULT-COMMON.
C**  NEXT  = POINTER TO THE LOCATION WHERE THE NEXT PRODUCED TRACK
C**          SHOULD BE STORED.
C**  NTOT  = TOTAL NUMBER OF TRACKS CURRENTLY STORED.
C**
C**  THE TRACK NEXT TO BE COPIED FROM THE STACK THEN LOOKS LIKE
C**
C**  EVENT(NCUR   ) = X
C**  EVENT(NCUR+ 1) = Y
C**  EVENT(NCUR+ 2) = Z
C**  EVENT(NCUR+ 3) = RCA
C**  EVENT(NCUR+ 4) = RCE
C**  EVENT(NCUR+ 5) = MASS
C**  EVENT(NCUR+ 6) = CHARGE
C**  EVENT(NCUR+ 7) = TOF
C**  EVENT(NCUR+ 8) = PX
C**  EVENT(NCUR+ 9) = PY
C**  EVENT(NCUR+10) = PZ
C**  EVENT(NCUR+11) = USERW
C**
C**
+DECK,  MASIND_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**   MASS INDEX FOR ALL PARTICLES CALCULATED FROM MASSES IN BLOCK DATA
C**
C**   PARTICLE                 IPART
C**   -----------------------------------
C**   GAMMA                    1
C**   NEUTRINO                 2
C**   POSITRON                 3
C**   ELEKTRON                 4
C**   MUON +                   5
C**   MUON -                   6
C**   PION +                   7
C**   PION 0                   8
C**   PION -                   9
C**   KAON +                  10
C**   KAON 0 S                11
C**   KAON 0 L                12
C**   KAON -                  13
C**   PROTON                  14
C**   PROTON BAR              15
C**   NEUTRON                 16
C**   NEUTRON BAR             17
C**   LAMBDA                  18
C**   LAMBDA BAR              19
C**   SIGMA +                 20
C**   SIGMA 0                 21
C**   SIGMA -                 22
C**   SIGMA + BAR             23
C**   SIGMA 0 BAR             24
C**   SIGMA - BAR             25
C**   XSI 0                   26
C**   XSI -                   27
C**   XSI 0 BAR               28
C**   XSI - BAR               29
C**   DEUTERONS               30
C**   TRITONS                 31
C**   ALPHAS                  32
C**   NEW PARTICLES           33
+DECK,  MASSES_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**   MASSES  FOR ALL PARTICLES CALCULATED FROM MASSES IN BLOCK DATA
C**
C**   PARTICLE                 MASS (GEV)
C**   -----------------------------------
C**   GAMMA                    0.
C**   NEUTRINO                 0.00001
C**   POSITRON                 0.00051
C**   ELEKTRON                 0.00051
C**   MUON +                   0.106
C**   MUON -                   0.106
C**   PION +                   0.140
C**   PION 0                   0.140
C**   PION -                   0.140
C**   KAON +                   0.494
C**   KAON 0 S                 0.498
C**   KAON 0 L                -0.498
C**   KAON -                   0.494
C**   PROTON                   0.938
C**   PROTON BAR              -0.938
C**   NEUTRON                  0.938
C**   NEUTRON BAR             -0.938
C**   LAMBDA                   1.1156
C**   LAMBDA BAR              -1.1156
C**   SIGMA +                  1.1894
C**   SIGMA 0                  1.1925
C**   SIGMA -                  1.1974
C**   SIGMA + BAR             -1.1894
C**   SIGMA 0 BAR             -1.1925
C**   SIGMA - BAR             -1.1974
C**   XSI 0                    1.3149
C**   XSI -                    1.3213
C**   XSI 0 BAR               -1.3149
C**   XSI - BAR               -1.3213
C**   ALPHAS+FRAGMENTS        UNCHANGED
C**   NEW PARTICLES           UNCHANGED
+DECK,  MAT_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**
C** ALL MATERIAL CONSTANTS ARE PARTLY STORED ON THE COMMON /MAT IN THE
C** BLOCK DATA OR CALCULATED IN THE ROUTINE MATTER.IN PRESENT VERSION
C** THERE MAY BE DEFINED UP TO 20 MATERIALS WITH THE MATERIAL-INDEX
C** NUMBER 'IND' . THIS MATERIAL INDEX NUMBER MUST BE GIVEN FOR
C** EACH CELL OF A CALORIMETER IN THE GEOMETRY INPUT DATA CARDS.
C** (SEE COMMON /CALSTR AND INIT). IND =0 IS ALWAYS INTERPRETED AS
C** VACUUM IN THE PROGRAM.
C
C** DEN   (IND+1) =  DENSITY (GR/CM**3)
C** RADLTH(IND+1) =  RADIATION LENGTH (CM)
C** ATNO  (IND+1) =  ATOMIC NUMBER (AVERAGE VALUE, SEE LATER)
C** ZNO   (IND+1) =  CHARGE NUMBER OF NUCLEUS (AVERAGE VALUE, SEE LATER)
C** ABSL  (IND+1) =  ABSORPTION LENGTH (ONLY USED FOR STEP SIZE
C**                  CALCULATION)
C** CDEN  (IND+1) =  C - PARAMETER IN STERNHEIMERS THEORY
C** MDEN  (IND+1) =  M - PARAMETER IN STERNHEIMERS THEORY
C** X0DEN (IND+1) =  X0- PARAMETER IN STERNHEIMERS THEORY
C** X1DEN (IND+1) =  X1- PARAMETER IN STERNHEIMERS THEORY
C** RION  (IND+1) =  IONISATION POTENTIAL
C** MATID (IND+1)    =  GHEISHA ALPHANUMERIC LABEL (A4)
C** MATID1(IND+1,24) =  EGS ALPHANUMERIC LABEL (24*A1)
C**   10 PARAMETERS DESCRIBING THE MATERIAL AT VARIOUS PLACES
C**   IN THE PROGRAM :
C** PARMAT(IND+1, 1) = X    DE/DX CORRECTION FACTOR FOR LANDAU
C**                         TYPE DISTRIBUTIONS
C** PARMAT(IND+1, 2) = 1.   FOR SOLIDS
C**                  = 2.   FOR FLUIDS
C**                  = 3.   FOE GASEOUS MATERIALS
C** PARMAT(IND+1, 3) = 1.   DELTA-RAY SELECTION : ALL PARTICLES
C**                  = 2.   DELTA-RAY SELECTION : ONLY MUONS
C**                  = 3.   DELTA-RAY SELECTION : MUONS AND ELECTRONS
C**                  = 4.   DELTA-RAY SELECTION : MUONS,ELECTRONS,PIONS
C** PARMAT(IND+1, 4) =      MINIMUM RANGE FOR DELTA-ELECTRONS
C** PARMAT(IND+1, 5) = 1.   FOR ANORGANIC SCINTILLATORS ONLY
C** PARMAT(IND+1, 6) =      SATURATION COEFFICIENT IN BIRK'S LAW
C**                  = 1.   DEFAULT VALUE  SAT=0.010/DENSITY,
C**                  > 1.                  SAT=PARMAT(IND+1,6)-1.
C** PARMAT(IND+1, 7) > 0.   INDUCED HADRON NUCLEAR FISSION
C** PARMAT(IND+1, 8) > 0.  PHOTOABSORBTION AND PHOTOFISSION
C** PARMAT(IND+1, 9) > 0.  NATURAL RADIOACTIVITY
C** PARMAT(IND+1,10) =     CORRECTION FACTOR FOR ENERGY LOSS BY
C**                        NUCLEAR BREAKUP EFFECTS
C**                  = 0.  DEFAULT MODEL DESCRIPTION IS USED.
C**
C**    THE DENSITY, ATOMIC NUMBER AND CHARGE NUMBER , DEFINED ABOVE,
C**    ARE AVERAGE VALUES FOR COMPOUND MATERIALS LIKE BGO.
C**    THESE VALUES ARE USED FOR DE/DX- CALCULATIONS ONLY.
C**
C** ALL MATERIALS MAY BE DEFINED AS COMPOUNDS OR MIXTURES,
C** THE FOLLOWING NUMBERS ARE TAKEN FROM THE EGS DATA FILE,
C** OR, IF NOT GIVEN, CALCULATED.
C** IFRAC(J)      = NUMBER OF COMPOUNDS IN THIS MATERIAL
C** FRAC1(J,I)    = PARTIAL INTERACT.LENGTH OF THE I.TH COMPOUND
C** DEN1 (J,I)    = PARTIAL DENSITY   OF THE I.TH COMPOUND
C** ATNO1(J,I)    = ATOMIC NUMBER     OF THE I.TH COMPOUND
C** ZNO1 (J,I)    = CHARGE NUMBER     OF THE I.TH COMPOUND
C**
C**
+DECK,  RESULT_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:19:51  cernlib
* Geant
*
*
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :
C**
C** THE RESULT COMMON STORES ALL INFORMATION OF THE CURRENT TRACK:
C**
C** XEND    |    START- OR END- COORDINATES OF THE CURRENT STEP.
C** YEND    |
C** ZEND    |
C** RCA          CALO1*1000.+CALO2*1.  |CALO1 AND CALO2 (CELL1 AND
C** RCE          CELL1*1000.+CELL2*1.  |CELL2) ARE THE CALORIMETER
C**                                    |(CELLS), WHERE THIS STEP COMES
C**                                    |FROM AND GOES TO.
C** AMAS         MASS
C** NCH          CHARGE
C** TOF          TIME OF FLIGHT  (IN 1/20 NSEC)
C** PX           PX/P = COSL*COSP
C** PY           PY/P = COSL*SINP
C** PZ           PZ/P = SINL
C** USERW        USERWORD (SEE 'HSTORY')
C** INTCT        INTERACTION/DECAY-COUNTER
C** P            MOMENTUM
C** EN           TOTAL ENERGY
C** EK           KINETIC ENERGY
C** AMASQ        MASS**2
C** DELTN        ACTUAL STEPSIZE  (SEE ALSO DDELTN IN COMMON /CURPAR)
C** ITK          NUMBER OF GENERATOR TRACK (SEE INPUT-ROUTINES)
C** NTK          NUMBER OF TRACK IN SHOWER
C** IPART        PARTICLE INDEX (SEE #MASIND)
C** IND          MATERIAL INDEX (SEE #MATTER)
C** LCALO        CALORIMETER NUMBER (=CALORIMETER1 IN RCA)
C** ICEL         CELL NUMBER        (=CELL1 IN RCE)
C** SINL         SINE OF DIP-ANGLE
C** COSL         COSINE OF DIP-ANGLE
C** SINP         SINE OF NORMAL PHI-ANGLE (WITH RESPECT TO X-AXIS)
C** COSP         COSINE OF NORMAL PHI-ANGLE
C**
+PATCH, DOC_CMZX.
+PATCH, DOC_CMZT.
+PATCH, DOC_CMZM.
+PATCH, DOC_CMZH.
+PATCH, DOC_CMZG.
+PATCH, DOC_CMZF.
+PATCH, DOC_CMZE.
+PATCH, GUSER.
+DECK,  GUDCAY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUDCAY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to decay particles                          *
C.    *                                                                *
C.    *    ==>Called by : GDECAY                                       *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      END
+DECK,  GUDIGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUDIGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to digitize one event                       *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      END
+DECK,  GUDTIM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      FUNCTION GUDTIM(DETREP,HITREP,IW1,DIS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User function called by GCDRIF to return drift time      *
C.    *                                                                *
C.    *    ==>Called by : GCDRIF                                       *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      GUDTIM=0.
      END
+DECK,  GUFLD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUFLD(X,F)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to compute the magnetic field F             *
C.    *       at space point X                                         *
C.    *                                                                *
C.    *    ==>Called by : GHELIX,GRKUTA                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(3),F(3)
C.
C.    ------------------------------------------------------------------
C.
      F(1)=0.
      F(2)=0.
      F(3)=0.
C
      END
+DECK,  GUHADR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUHADR
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to generate one hadronic interaction        *
C.    *                                                                *
C.    *    ==>Called by : GTHADR,GTNEUT                                *
C.    *                                                                *
C.    ******************************************************************
C.
*======================================================================*
*                                                                      *
*   An interface with a part of the FLUKA shower code is available in  *
*   GEANT 3.21. The following conditions and warnings must be taken    *
*   into account when using the FLUKA routines.                        *
*                                                                      *
*======================================================================*
*======================================================================*
*                                                                      *
*                   FFFF   L      U  U  K  K   AA                      *
*                   F      L      U  U  K K   A  A                     *
*                   FFF    L      U  U  KK    AAAA                     *
*                   F      L      U  U  K K   A  A                     *
*                   F      LLLL    UU   K  K  A  A                     *
*                                                                      *
*                   (C) Copyright of the authors                       *
*                                                                      *
*             A. Fasso'*, A. Ferrari#, J. Ranft$, P.R. Sala#           *
*                                                                      *
*               *: CERN, #: INFN -Milan, $: CERN/Frascati              *
*                                                                      *
*                (e-mail: FERRARIA@CERNVM.CERN.CH)                     *
*                                                                      *
*======================================================================*
*                                                                      *
*   - All the rights concerning FLUKA or parts of it are only of the   *
*     authors and are independent from those of the GEANT code         *
*                                                                      *
*   - FLUKA [1-6] is a standalone code capable of simulating the inter-*
*     action and transport of all components of EM and hadronic cas-   *
*     cades up to several TeV. However, only cross sections and        *
*     models for hadronic elastic and inelastic interactions (end 1992 *
*     status) are included in this GEANT version.                      *
*                                                                      *
*   - The most recent FLUKA model [4,6] for nucleon and pion interac-  *
*     tions in the intermediate energy range is not fully implemented  *
*     in GEANT. Only a simplified version, limited to p and n below    *
*     250 MeV, is available in GEANT 3.21. A coarser model is used for *
*     other projectiles in this energy range. However the implemented  *
*     parts should be adequate for most detector simulations and sim-  *
*     ilar applications for which GEANT is generally used. Their accu- *
*     racy could be insufficient for some nuclear physics studies or   *
*     demanding simulations at low energies, where the more sophistic- *
*     ated models [4,6] could be required.                             *
*                                                                      *
*   - The performances of GEANT-FLUKA are therefore not representative *
*     of those of FLUKA standalone and should be referenced as such    *
*     rather than simply GEANT or FLUKA.                               *
*                                                                      *
*   - The authors reserve the right of publishing about the physical   *
*     models developed for FLUKA. Running the FLUKA routines in isol-  *
*     ation for benchmarks (or equivalent use) is not permitted,       *
*     except after consultations or in collaboration with the authors. *
*                                                                      *
*   - The FLUKA routines are supposed to be included and used in       *
*     GEANT only. Any other use must be authorized by the authors.     *
*                                                                      *
*   - References: at least reference [5] should be always quoted when  *
*                 reporting results obtained with GEANT-FLUKA          *
*                                                                      *
* [1] A. Fasso', A. Ferrari, J. Ranft, P. R. Sala, G. R. Stevenson and *
*     J. M. Zazula, "FLUKA92", presented at the workshop on "Simulat-  *
*     ing Accelerator Radiation Environment", SARE, Santa Fe, 11-15    *
*     january (1993), Proceedings in press.                            *
*                                                                      *
* [2] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, Proc. MC93 Int. Conf. *
*     on Monte-Carlo Simulation in High-Energy and Nuclear Physics,    *
*     Tallahassee, Florida, 22-26 february (1993), World Scientific,   *
*     p. 88 (1994).                                                    *
*                                                                      *
* [3] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, ibidem, p. 100 (1994) *
*                                                                      *
* [4] A. Ferrari and P.R. Sala, ibidem, p. 277 (1994).                 *
*                                                                      *
* [5] A. Fasso', A. Ferrari, J. Ranft and P.R. Sala, "FLUKA: present   *
*     status and future developments", presented at the IV Int. Conf.  *
*     on Calorimetry in High Energy Physics, La Biodola (Elba),        *
*     September 19-25 1993, Proceedings in press.                      *
*                                                                      *
* [6] A. Fasso', A. Ferrari, J. Ranft, and P.R. Sala, "FLUKA: Perf-    *
*     ormances and Applications in the Intermediate Energy Range",     *
*     presented at the "Specialists' Meeting on Shielding Aspects of   *
*     Accelerators, Targets & Irradiation Facilities", Arlington,      *
*     April 28-29 1994, Proceedings in press.                          *
*                                                                      *
*======================================================================*
C.
C.    ------------------------------------------------------------------
C.
C          GHEISHA only if IHADR<3 (default)
C
      CALL GHEISH
C
      END
+DECK,  GUIGET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUIGET(NMENU,NCOMD,NPAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine for interactive control of GEANT            *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>, GINCOM                              *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,  GUINME, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUINME(X,SH,P,IYES)
C.
C.    **********************************************
C.    *                                            *
C.    *    USER ROUTINE TO PROVIDE GINME FUNCTION  *
C.    *    FOR ALL USER SHAPES IDENTIFIED BY THE   *
C.    *    SHAPE NUMBER SH. POINT IS GIVEN IN X    *
C.    *    THE PARAMETERS ARE GIVEN IN P. IYES IS  *
C.    *    RETURNED 1 IF POINT IS IN, 0 IF POINT   *
C.    *    IS OUT AND LESS THAN ZERO IF SHAPE      *
C.    *    NUMBER IS NOT SUPPORTED.                *
C.    *                                            *
C.    *    ==>Called by : GINME                    *
C.    *                                            *
C.    **********************************************
C.
      DIMENSION X(3),P(*)
C
      IYES=-1
      END
+DECK,  GUINTI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUINTI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine for interactive version                     *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>,  GINTRI                             *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,  GUKINE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUKINE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Read or Generates Kinematics for primary tracks          *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,  GUNEAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUNEAR(ISEARC, ICALL, X, JNEAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    User search                                                 *
C.    *       ISEARC to identify the given volume                      *
C.    *       ICALL  to identify the calling routine                   *
C.    *              1 GMEDIA like                                     *
C.    *              2 GNEXT like                                      *
C.    *       X      coordinates (+direction for ICALL=2)              *
C.    *       JNEAR  address of default list of neighbours             *
C.    *              (list to be overwriten by user)                   *
C.    *                                                                *
C.    *    Called by : GFTRAC, GINVOL, GTMEDI, GTNEXT, GNEXT, GMEDIA   *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X(*)
C.    ------------------------------------------------------------------
*                                                             END GUNEAR
      END
+DECK,  GUOUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUOUT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each event             *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
C
      END
+DECK,  GUPARA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:47  cernlib
* Geant

      SUBROUTINE GUPARA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called every time a particle falls below    *
C.    *       parametrization threshold. This routine should create    *
C.    *       the parametrization stack, and, when this is full,       *
C.    *       parametrize the shower and track the geantinos.          *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCPARM.
+CDE, GCTMED.
+CDE, GCTRAK.
C.
C.    ------------------------------------------------------------------
C.
*      CALL GSPARA
*
      END
+DECK,  GUPHAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUPHAD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to compute Hadron. inter. probabilities     *
C.    *                                                                *
C.    *    ==>Called by : GTHADR,GTNEUT                                *
C.    *                                                                *
C.    ******************************************************************
C.
*======================================================================*
*                                                                      *
*   An interface with a part of the FLUKA shower code is available in  *
*   GEANT 3.21. The following conditions and warnings must be taken    *
*   into account when using the FLUKA routines.                        *
*                                                                      *
*======================================================================*
*======================================================================*
*                                                                      *
*                   FFFF   L      U  U  K  K   AA                      *
*                   F      L      U  U  K K   A  A                     *
*                   FFF    L      U  U  KK    AAAA                     *
*                   F      L      U  U  K K   A  A                     *
*                   F      LLLL    UU   K  K  A  A                     *
*                                                                      *
*                   (C) Copyright of the authors                       *
*                                                                      *
*             A. Fasso'*, A. Ferrari#, J. Ranft$, P.R. Sala#           *
*                                                                      *
*               *: CERN, #: INFN -Milan, $: CERN/Frascati              *
*                                                                      *
*                (e-mail: FERRARIA@CERNVM.CERN.CH)                     *
*                                                                      *
*======================================================================*
*                                                                      *
*   - All the rights concerning FLUKA or parts of it are only of the   *
*     authors and are independent from those of the GEANT code         *
*                                                                      *
*   - FLUKA [1-6] is a standalone code capable of simulating the inter-*
*     action and transport of all components of EM and hadronic cas-   *
*     cades up to several TeV. However, only cross sections and        *
*     models for hadronic elastic and inelastic interactions (end 1992 *
*     status) are included in this GEANT version.                      *
*                                                                      *
*   - The most recent FLUKA model [4,6] for nucleon and pion interac-  *
*     tions in the intermediate energy range is not fully implemented  *
*     in GEANT. Only a simplified version, limited to p and n below    *
*     250 MeV, is available in GEANT 3.21. A coarser model is used for *
*     other projectiles in this energy range. However the implemented  *
*     parts should be adequate for most detector simulations and sim-  *
*     ilar applications for which GEANT is generally used. Their accu- *
*     racy could be insufficient for some nuclear physics studies or   *
*     demanding simulations at low energies, where the more sophistic- *
*     ated models [4,6] could be required.                             *
*                                                                      *
*   - The performances of GEANT-FLUKA are therefore not representative *
*     of those of FLUKA standalone and should be referenced as such    *
*     rather than simply GEANT or FLUKA.                               *
*                                                                      *
*   - The authors reserve the right of publishing about the physical   *
*     models developed for FLUKA. Running the FLUKA routines in isol-  *
*     ation for benchmarks (or equivalent use) is not permitted,       *
*     except after consultations or in collaboration with the authors. *
*                                                                      *
*   - The FLUKA routines are supposed to be included and used in       *
*     GEANT only. Any other use must be authorized by the authors.     *
*                                                                      *
*   - References: at least reference [5] should be always quoted when  *
*                 reporting results obtained with GEANT-FLUKA          *
*                                                                      *
* [1] A. Fasso', A. Ferrari, J. Ranft, P. R. Sala, G. R. Stevenson and *
*     J. M. Zazula, "FLUKA92", presented at the workshop on "Simulat-  *
*     ing Accelerator Radiation Environment", SARE, Santa Fe, 11-15    *
*     january (1993), Proceedings in press.                            *
*                                                                      *
* [2] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, Proc. MC93 Int. Conf. *
*     on Monte-Carlo Simulation in High-Energy and Nuclear Physics,    *
*     Tallahassee, Florida, 22-26 february (1993), World Scientific,   *
*     p. 88 (1994).                                                    *
*                                                                      *
* [3] P.A. Aarnio, A. Fasso', A. Ferrari, J.-H. Moehring, J. Ranft,    *
*     P.R. Sala, G.R. Stevenson and J.M. Zazula, ibidem, p. 100 (1994) *
*                                                                      *
* [4] A. Ferrari and P.R. Sala, ibidem, p. 277 (1994).                 *
*                                                                      *
* [5] A. Fasso', A. Ferrari, J. Ranft and P.R. Sala, "FLUKA: present   *
*     status and future developments", presented at the IV Int. Conf.  *
*     on Calorimetry in High Energy Physics, La Biodola (Elba),        *
*     September 19-25 1993, Proceedings in press.                      *
*                                                                      *
* [6] A. Fasso', A. Ferrari, J. Ranft, and P.R. Sala, "FLUKA: Perf-    *
*     ormances and Applications in the Intermediate Energy Range",     *
*     presented at the "Specialists' Meeting on Shielding Aspects of   *
*     Accelerators, Targets & Irradiation Facilities", Arlington,      *
*     April 28-29 1994, Proceedings in press.                          *
*                                                                      *
*======================================================================*
C.
C.    ------------------------------------------------------------------
C.
C             GPGHEI for GHEISHA
C
      CALL GPGHEI
      END
+DECK,  GUPLSH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:47  cernlib
* Geant

      FUNCTION GUPLSH(MED0,MED1)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GLISUR                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCTMED.
C.
C.    ------------------------------------------------------------------
C.
*
* *** By default this defines perfect smoothness
      GUPLSH = 1.
C
      END
+DECK,  GUSKIP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUSKIP (ISKIP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   User routine to skip unwanted tracks                         *
C.    *                                                                *
C.    *   Called by : GSSTAK                                           *
C.    *   Author    : F.Bruyant                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
C.    ------------------------------------------------------------------
*
      ISKIP = 0
*                                                             END GUSKIP
      END

+DECK,  GUSTEP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUSTEP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine called at the end of each tracking step     *
C.    *       INWVOL is different from 0 when the track has reached    *
C.    *              a volume boundary                                 *
C.    *       ISTOP is different from 0 if the track has stopped       *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCTMED.
+CDE, GCTRAK.
C.
C.    ------------------------------------------------------------------
C.
      END
+DECK,  GUSWIM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUSWIM(CHARGE,STEP,VECT,VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to control tracking of one track            *
C.    *       in a magnetic field                                      *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTHADR,GTMUON                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCTMED.
      DIMENSION VECT(6),VOUT(6)
C.
C.    ------------------------------------------------------------------
C.
         IF (IFIELD.EQ.3)THEN
            CALL GHELX3(FIELDM*CHARGE,STEP,VECT,VOUT)
         ELSEIF(IFIELD.EQ.2)THEN
            CALL GHELIX(CHARGE,STEP,VECT,VOUT)
         ELSE
            CALL GRKUTA(CHARGE,STEP,VECT,VOUT)
         ENDIF
C
      END
+DECK,  GUTRAK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUTRAK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to control tracking of one track            *
C.    *                                                                *
C.    *    ==>Called by : GTREVE                                       *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
*
      CALL GTRACK
*                                                             END GUTRAK
      END
+DECK,  GUTREV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUTREV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine to control tracking of one event            *
C.    *                                                                *
C.    *    ==>Called by : GTRIG                                        *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      CALL GTREVE
C
      END
+DECK,  GUVIEW, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:46  cernlib
* Geant

      SUBROUTINE GUVIEW(IDS,IVS,ICS,IVIEW)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       User routine for interactive version                     *
C.    *                                                                *
C.    *    ==>Called by : <GXINT>, GINC1                               *
C.    *                                                                *
C.    ******************************************************************
C.
C.
C.    ------------------------------------------------------------------
C.
      CHARACTER*(*) ICS
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=-USRJMP.
      CALL GUSTEP
+SELF, IF=USRJMP.
      CALL JUMPT0(JUSTEP)
+SELF.
      END
+DECK,  GUXCS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:47  cernlib
* Geant

      SUBROUTINE GUXCS
*
*              User routine  to declare addresses of FORTRAN routines
*              and COMMONs  which may be invoked from COMIS routines.
*              Called by GXCS
*
+CDE, GCOMIS.
*
      DIMENSION P(1)
*
*
      END
+PATCH, GTRAK.
+DECK,  GARNDM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:40  cernlib
* Geant

      FUNCTION GARNDM(DUMMY)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       GARNDM = -LOG(RNDM(DUMMY))                               *
C.    *                                                                *
C.    *    ==>Called by : GBREME,GBREMM,GCOMP,GDRAY,GHADRO,GHEISH,     *
C.    *                   GLANDO,GPAIRG,GPAIRM,GRAYL,GLTRAC            *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION RNDM(1)
C.
C.    ------------------------------------------------------------------
C.
      CALL GRNDM(RNDM,1)
      GARNDM=-LOG(RNDM(1))
      END
+DECK,  GDEBUG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:40  cernlib
* Geant

      SUBROUTINE GDEBUG
*
************************************************************************
*             Standard GEANT debug                                     *
*                                                                      *
*          ==>Called by : <USER>,GUSTEP                                *
*             Author    R.Brun  *********                              *
************************************************************************
*
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCTRAK.
*
*             Debug/plot event
      IF(IDEBUG.NE.0) THEN
        IF((ISWIT(2).EQ.1).OR.(ISWIT(3).EQ.1)
     +                    .OR.(ISWIT(2).EQ.4)) CALL GSXYZ
        IF (ISWIT(2).EQ.2) CALL GPCXYZ
        IF (ISWIT(1).EQ.2) CALL GPGKIN
        IF (ISWIT(2).EQ.3) THEN
           IF(ISWIT(4).EQ.3.AND.CHARGE.EQ.0.)RETURN
           CALL GDCXYZ
           CALL IGSA(0)
        ELSEIF(ISWIT(2).EQ.4) THEN
           IF(ISTOP.NE.0) CALL GDTRAK(' ')
        ENDIF
      ENDIF
      END

+DECK,  GEKBIN, T=FORT.
* Revision 1.2  1998/01/21 16:44:37  gunter
* Add protection of iekbin getting too big due to numerical inacurecies
* Revision 1.1.1.1  1995/10/24 10:21:40  cernlib
* Geant

      SUBROUTINE GEKBIN
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to find bin number in kinetic energy table       *
C.    *       stored in ELOW(NEKBIN)                                   *
C.    *                                                                *
C.    *    ==>Called by : GBREME,GBREMM,GCOMP,GDRAY,GHEISH,GPAIRM,     *
C.    *                   GLTRAC,GTELEC,GTHADR,GTMUON                  *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCTRAK.
+CDE, GCMULO.
+CDE, GCKINE.
+CDE, GCONSP.
C.
C.    ------------------------------------------------------------------
C.
      EK=GEKIN
      IF (ITRTYP.EQ.4.OR.ITRTYP.EQ.8) EK=GEKIN*PMASS/AMASS
      IF (EK.LT.ELOW(1)) THEN
         IEKBIN=1
         GEKRAT=0.
      ELSEIF (EK.GE.ELOW(NEK1)) THEN
         IEKBIN=NEKBIN
         GEKRAT=1.
      ELSE
         IEKBIN=GEKA*LOG10(EK) + GEKB
         IF (IEKBIN.GT.NEKBIN ) IEKBIN=NEKBIN
         GEKRAT=(EK-ELOW(IEKBIN))/(ELOW(IEKBIN+1)-ELOW(IEKBIN))
         GEKRAT=MIN(1.,MAX(GEKRAT,0.))
      ENDIF
C
      END
+DECK,  GFINDS, T=FORT.
* Revision 1.2  1999/01/14 15:30:30  japost
*   Fixed the problem described below in the exact manner given:
* Date: Wed, 21 Oct 1998 11:55:47 EDT
* From: "Shawn McKee - (734) 764-4395" <mckee@pooh.physics.lsa.umich.edu>
* Reply-To: cern-heplib@listbox1.cern.ch
* To: cern-heplib@listbox1.cern.ch
* Subject: Problem with using large memory size in GEANT
*   I think I have found a problem in the the gfinds routine in the GTRAK
*   area of GEANT.  When trying to use a ZEBRA memory space larger than
*   16777216 WORDS (4-byte words) my GEANT code would not work correctly.
*   The problem is illustrated with the following FORTRAN code.  The specific
*   point at which things fail is dependent on the machine specific
*   implementation of REAL*4.
*   The basic problem was that "pointers" to memory in ZEBRA should always
*   use INTEGER*4 values to prevent losing precision.  Adding 1 to a large
*   real number and taking the integer value is not the same as taking the
*   integer value of the real and adding 1!  All memory pointers I found
*   correctly used integers, except a code fragment in gfinds.F inside the
*   GTRAK area.  The faulty line was:
*          JAT = JFATTR(JVO)
*   where JFATTR was an inline function:
*      JATTF(JV) = JV + Q(JV+5) + 6
*   The problem is that the right-hand-side(RHS) of the inline function is first
*   "promoted" to REAL*4, added together and then converted back to an integer.
*   This causes an error when the RHS is larger than 16777216 on OpenVMS.
*   The fix is to simply encase the Q() inside INT():
*      JATTF(JV) = JV + INT(Q(JV+5)) + 6
*   Can this fix be added to the current gfinds.F source code?  Thank-you!
*       Shawn McKee
*                                 University of Michigan
*                                 smckee@umich.edu
* ------------------------------------------------------------------------
*   An earlier enquiry about this pinpointed the problem, but was missed
* > From: Bogdan Pawlik <bogdan@FNAL.GOV>
* > Subject: GEANT-3.21.04 : a bug in GFINDS
* > Date: Thursday, April 10, 1997 8:39 PM
* >
* > Dear Sir,
* >   I was having troubles running GEANT with very large
* >   memory ( 20 Mb ) , I was experiencing random crashes.
* >   What I found eventually when debugging problem, was
* >   that cause of this lies in GFINDS where in-line function:
* >
* >         JATTF(JV) = JV + Q(JV+5) + 6
* >   is used to get pointer in JSET structure.
* >    The problem with this instruction is that it is
* >   mixing types i.e.  int = int +float  . This
* >   procedure fails  on SGI IRIX5.3 and also
* >   at OVMS (DEC-APLHA)  for integers above 16777215.
* >   The result is as follow :
* >             int       float   int
* >     SGI    16777216 + 1.0 = 16777216
* >   ALPHA    16777216 + 1.0 = 16777218
* >
* >    instead 16777217 .
* >   The results of this bug are unpredictable ....
* >   from unreliable tracking to crashes.
* >
* >    Running Geant with really large memory becomes
* >   more and more often this days so I think fixing
* >   this problem in GFINDS and possibly in other
* >   places  is important.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GFINDS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Returns the set/volume parameters corresponding to       *
C.    *       the current space point in /GCTRAK/                      *
C.    *       and fill common /GCSETS/                                 *
C.    *                                                                *
C.    *       IHSET  user set identifier                               *
C.    *       IHDET  user detector identifier                          *
C.    *       ISET set number in JSET                                  *
C.    *       IDET   detector number in JS=LQ(JSET-ISET)               *
C.    *       IDTYPE detector type (1,2)                               *
C.    *       NUMBV  detector volume numbers (array of length NVNAME)  *
C.    *       NVNAME number of volume levels                           *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *       Author    R.Brun  *********                              *
C.    *       Modified  V.Perev                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSETS.
+CDE, GCVOLU.
+CDE, GCTMED.
+SELF, IF=DEBUG.
      INTEGER        LNAM(15), LNUM(15)
+SELF.
      JATTF(JV) = JV + INT(Q(JV+5)) + 6
C.
C.    ------------------------------------------------------------------
C.
*
+SELF, IF=DEBUG.
      WRITE(CHMAIL,1000)NLEVEL
      CALL GMAIL (0, 0)
      DO 5 I    = 1,NLEVEL
        WRITE(CHMAIL,1001)NAMES(I),NUMBER(I),LVOLUM(I),LINDEX(I)
        CALL GMAIL (0, 0)
        WRITE(CHMAIL,1002)(GTRAN(J,I),J = 1,3),(GRMAT(J,I),J=1,10)
        CALL GMAIL (0, 0)
    5   CONTINUE
 1000 FORMAT (' DEBUG : GFINDS =',I3)
 1001 FORMAT (5(1X,A4,3I3))
 1002 FORMAT (1X,13F9.4)
      NLEV = NLEVEL
      CALL UCOPY (NAMES (1),LNAM(1),NLEV)
      CALL UCOPY (NUMBER(1),LNUM(1),NLEV)
      NLEVEL    = 0
      CALL GLVOLU (NLEV, LNAM, LNUM, IER)
      IF (IER.NE.0)             STOP
+SELF.
*
      IHSET = 0
      IHDET = 0
      ISET  = 0
      IDET  = 0
      IDTYPE = 0
      NVNAME = 0
*
      DO 10 NLEV = NLEVEL,1,-1
         JVO = LQ(JVOLUM-LVOLUM(NLEV))
         JAT = JATTF(JVO)
         IDET = Q(JAT+8)
         IF(IDET.NE.0) THEN
            NL = NLEV
            GO TO 15
         ENDIF
  10  CONTINUE
      GOTO 99
  15  ISET   = Q(JAT+7)
      IDTYPE = Q(JAT+9)
      IHSET  = IQ(JSET+ISET)
      JS     = LQ(JSET-ISET)
      IHDET  = IQ(JS+IDET)
      JD     = LQ(JS-IDET)
      NVNAME = IQ(JD+2)
      DO 40 I=1,NVNAME
            NAME=IQ(JD+2*I+9)
            NUMBV(I)=0
            DO 30 J=1,NLEVEL
               IF(NAMES(J).EQ.NAME)THEN
                  NUMBV(I)=NUMBER(J)
                  GO TO 40
               ENDIF
  30        CONTINUE
  40  CONTINUE
C
   99 END
+DECK,  GFTRAC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GFTRAC
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GFTRAC                                                 *
C.    *                                                                *
C.    *   Selects next track segment to be processed and extracts from *
C.    *    the stack JTRACK the relevant information to reload commons *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
*
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCVOLU.
+CDE, GCPOLY.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
      REAL      XC(3), XT(3), X0(3)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      SAVE MANY
      DATA  MANY / 0/
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.    ------------------------------------------------------------------
*
* *** Process next track in 'IN current VOlume' chain, if any
*
      IF (NJTMAX.LT.0) THEN
*
*  **   Reactivate parallel tracking if enough space available
*
         IF (NALIVE.LE.NJTMIN) NJTMAX = -NJTMAX
*
*  **   Update common /GCVOLU/ and structure JGPAR if necessary
*
         NLEVEL = NLVSAV
         ISKP   = 1
         DO 9 ILEV = 2,NLDOWN
            IF (ISKP.NE.0) THEN
               IF (LINDEX(ILEV).EQ.LINSAV(ILEV)) GO TO 9
               ISKP = 0
            ENDIF
            JSKLD = LQ(JSKLT-ILEV)
            JSKD  = LQ(JSKLD-LINSAV(ILEV))
            IVO   = IQ(JSKD+2)
            LQ(JGPAR-ILEV) = LQ(JSKD-1)
            IQ(JGPAR+ILEV) = IQ(JSKD+1)
            LVOLUM(ILEV)   = IVO
            NAMES(ILEV)    = IQ(JVOLUM+IVO)
            LINDEX(ILEV)   = LINSAV(ILEV)
            LINMX(ILEV)    = LMXSAV(ILEV)
            JVOM = LQ(JVOLUM-LVOLUM(ILEV-1))
            IF (Q(JVOM+3).GT.0.) THEN
               JIN = LQ(JVOM-LINDEX(ILEV))
               NUMBER(ILEV) = Q(JIN+3)
               GONLY(ILEV)  = Q(JIN+8)
            ELSE
               NUMBER(ILEV) = LINDEX(ILEV)
               GONLY(ILEV)  = GONLY(ILEV-1)
            ENDIF
            IF (LQ(LQ(JVOLUM-IVO)).EQ.0) THEN
               NLDEV(ILEV) = NLDEV(ILEV-1)
            ELSE
               NLDEV(ILEV) = ILEV
            ENDIF
            GTRAN(1,ILEV) = Q(JSKD+3)
            GTRAN(2,ILEV) = Q(JSKD+4)
            GTRAN(3,ILEV) = Q(JSKD+5)
            DO 8 I = 1, 10, 2
               GRMAT(I,ILEV) = Q(JSKD+5+I)
               GRMAT(I+1,ILEV) = Q(JSKD+6+I)
    8       CONTINUE
    9    CONTINUE
* **
         IF (NJINVO.NE.0) GO TO 800
         IFUPD = 0
      ELSE
         IF (NJINVO.NE.0) GO TO 800
         IFUPD = 1
      ENDIF
*
* *** 'IN current VOlume' chain is empty, refill from JSKLT structure
*     Scan brother chains, starting from current one when going up in
*     the skeleton structure
*
   10 INSK  = 1
*
   11 NLEVEL = NLDOWN
      JSKLD  = LQ(JSKLT-NLEVEL)
      NINSK  = LINMX(NLEVEL)
      IDO    = 1
*
   20 IF (IQ(JSKLD+INSK).EQ.0) GO TO 589
      JSKD = LQ(JSKLD-INSK)
      IVO  = IQ(JSKD+2)
      IF (IFUPD.NE.0.AND.NLEVEL.GT.1) THEN
*
*  **   Update common /GCVOLU/ for level NLEVEL
*
         LQ(JGPAR-NLEVEL) = LQ(JSKD-1)
         IQ(JGPAR+NLEVEL) = IQ(JSKD+1)
         LVOLUM(NLEVEL)   = IVO
         NAMES(NLEVEL)    = IQ(JVOLUM+IVO)
         LINDEX(NLEVEL)   = INSK
         JVOM = LQ(JVOLUM-LVOLUM(NLEVEL-1))
         IF (Q(JVOM+3).GT.0.) THEN
            JIN = LQ(JVOM-INSK)
            NUMBER(NLEVEL) = Q(JIN+3)
            GONLY(NLEVEL)  = Q(JIN+8)
         ELSE
            NUMBER(NLEVEL) = INSK
            GONLY(NLEVEL)  = GONLY(NLEVEL-1)
         ENDIF
         IF (LQ(LQ(JVOLUM-IVO)).EQ.0) THEN
            NLDEV(NLEVEL) = NLDEV(NLEVEL-1)
         ELSE
            NLDEV(NLEVEL) = NLEVEL
         ENDIF
         GTRAN(1,NLEVEL) = Q(JSKD+3)
         GTRAN(2,NLEVEL) = Q(JSKD+4)
         GTRAN(3,NLEVEL) = Q(JSKD+5)
         DO 29 I = 1, 10, 2
            GRMAT(I,NLEVEL) = Q(JSKD+5+I)
            GRMAT(I+1,NLEVEL) = Q(JSKD+6+I)
   29    CONTINUE
      ENDIF
*
      JVO  = LQ(JVOLUM-IVO)
      IF (Q(JVO+3).EQ.0.) GO TO 600
      NIN = Q(JVO+3)
*
*  ** Sort-out unsorted-out elements in first non-empty brother chain
*
      LPREV = JSKLD +INSK
      NCUR  = IQ(LPREV)
   50 LCUR = JTRACK +(NCUR-1)*NWTRAC
      IF (IQ(LCUR+2).NE.0) GO TO 600
      NSTO = IQ(LCUR+1)
*
      IPCUR = LCUR +NWINT
C*****  Code Expanded From Routine:  GTRNSF
C
      IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = Q(1+IPCUR) - GTRAN(1,NLEVEL)
         XC(2) = Q(2+IPCUR) - GTRAN(2,NLEVEL)
         XC(3) = Q(3+IPCUR) - GTRAN(3,NLEVEL)
*
      ELSE
         XL11X = Q(1+IPCUR) - GTRAN(1,NLEVEL)
         XL21X = Q(2+IPCUR) - GTRAN(2,NLEVEL)
         XL31X = Q(3+IPCUR) - GTRAN(3,NLEVEL)
         XC(1) = XL11X*GRMAT(1,NLEVEL) + XL21X*GRMAT(2,NLEVEL) + XL31X*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL11X*GRMAT(4,NLEVEL) + XL21X*GRMAT(5,NLEVEL) + XL31X*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL11X*GRMAT(7,NLEVEL) + XL21X*GRMAT(8,NLEVEL) + XL31X*
     1      GRMAT(9,NLEVEL)

      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      IF (NIN.LT.0) GO TO 200
*
*   *   Case with contents defined by Position
*
      JNEAR = LQ(JVO-NIN-1)
      INFROM = IQ(LCUR+11)
      IF (INFROM.GT.0) THEN
         JIN   = LQ(JVO-INFROM)
         IF (LQ(JIN-1).NE.0) JNEAR = LQ(JIN-1)
      ENDIF
      IF (IQ(JNEAR+2).EQ.0) GO TO 300
      ISEARC = Q(JVO+1)
      IF (ISEARC.LT.0) THEN
*
*       Prepare access list when contents have been ordered by GSORD
*
         JSB = LQ(LQ(JVO-NIN-1))
         IAX = Q(JSB+1)
         NSB = Q(JSB+2)
         IF (IAX.LE.3) THEN
            IDIV = LOCATF (Q(JSB+3), NSB, XC(IAX))
         ELSE
            CALL GFCOOR (XC, IAX, CX)
            IDIV = LOCATF (Q(JSB+3), NSB, CX)
         ENDIF
         IF (IDIV.LT.0) IDIV = -IDIV
         IF (IDIV.EQ.0) THEN
            IF (IAX.NE.6) GO TO 300
            IDIV = NSB
         ELSE IF (IDIV.EQ.NSB) THEN
            IF (IAX.NE.6) GO TO 300
         ENDIF
         JSC0 = LQ(JVO-NIN-2)
         NCONT = IQ(JSC0+IDIV)
         IF (NCONT.LE.0) GO TO 300
         JSCV = LQ(JSC0-IDIV)
         ICONT = 1
         GO TO 120
      ELSE
         IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP.
            CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=USRJMP.
            CALL JUMPT4(JUNEAR, ISEARC, 1, XC, JNEAR)
+SELF.
            IF (IQ(JNEAR+1).EQ.0) GO TO 300
         ENDIF
         JNEAR  = JNEAR +1
         NNEAR  = IQ(JNEAR)
         INEAR  = 1
      ENDIF
*
  110 IN = IQ(JNEAR+INEAR)
      IF (IN.GT.0) GO TO 150
      GO TO 190
*
  120 IN = IQ(JSCV+ICONT)
*
*     For each selected content in turn, check if point is in
*
  150 JIN  = LQ(JVO-IN)
      IVOT = Q(JIN+2)
      JVOT = LQ(JVOLUM-IVOT)
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR +5
         NPAR = IQ(JPAR)
         GO TO 175
      ENDIF
*      (normal case)
      NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
*
  175 IROTT  = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
      IF (IROTT.EQ.0) THEN
         XT(1) = XC(1) - Q(JIN+5)
         XT(2) = XC(2) - Q(JIN+6)
         XT(3) = XC(3) - Q(JIN+7)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
      ENDIF
C*****  Code Expanded From Routine:  GITRAN
      CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
      IF (IYES.NE.0) THEN
*
*       Volume found at deeper level
*
         NLDOWN = NLEVEL +1
         LINMX(NLDOWN) = NIN
         JSKL = LQ(JSKLT-NLDOWN)
*
*       Clear skeleton at lowest level if necessary
*
         JOFF = JSKL +IQ(JSKL-3)
         DO 184 ILEV = 1,NLEVEL
            IF (IQ(JOFF+ILEV).EQ.LINDEX(ILEV)) GO TO 184
            DO 182 I = ILEV,NLEVEL
               IQ(JOFF+I) = LINDEX(I)
  182       CONTINUE
            DO 183 I = 1,NIN
               JSK = LQ(JSKL-I)
               IQ(JSK+1) = 0
  183       CONTINUE
            GO TO 185
  184    CONTINUE
*
*       Prepare skeleton for level down if not yet done
*
  185    JSK  = LQ(JSKL-IN)
         IF (IQ(JSK+1).EQ.0) THEN
            LQ(JSK-1) = JPAR
            IQ(JSK+1) = NPAR
            IQ(JSK+2) = IVOT
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL),
     +                   Q(JIN+5), IROTT, Q(JSK+3), Q(JSK+6))
         ENDIF
         GO TO 500
*
      ENDIF
*
  190 IF (ISEARC.LT.0) THEN
         IF (ICONT.EQ.NCONT) GO TO 300
         ICONT = ICONT +1
         GO TO 120
      ELSE
         IF (INEAR.EQ.NNEAR) GO TO 300
         INEAR = INEAR +1
         GO TO 110
      ENDIF
*
*   *   Case with contents defined by division
*
  200 JDIV  = LQ(JVO-1)
      ISH   = Q(JVO+2)
      IAXIS = Q(JDIV+1)
      IVOT  = Q(JDIV+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPAR = 0
      ELSE
*       (case with structure JVOLUM locally developped)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 250
         DO 249 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPAR+1).EQ.0) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
               IF (JPAR.EQ.0) GO TO 250
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV  = IQ(JPAR+1)
               ORIG  =  Q(JPAR+2)
               SDIV  =  Q(JPAR+3)
            ENDIF
  249    CONTINUE
         GO TO 260
      ENDIF
*      (normal case)
  250 NDIV  = Q(JDIV+3)
      ORIG  = Q(JDIV+4)
      SDIV  = Q(JDIV+5)
*
  260 IDT = IDTYP(IAXIS,ISH)
      IF (IDT.EQ.1) THEN
*
*      Division along X, Y or Z axis
*
         XTT = XC(IAXIS)
         IF (ISH.EQ.10) THEN
            IF (IAXIS.NE.3) THEN
               XTT = XTT - Q(LQ(JGPAR-NLEVEL)+IAXIS+4) * XC(3)
               IF (IAXIS.EQ.1) THEN
                  YT  = XC(2) - Q(LQ(JGPAR-NLEVEL)+6) * XC(3)
                  XTT = XTT - Q(LQ(JGPAR-NLEVEL)+4) * YT
               ENDIF
            ENDIF
         ENDIF
         IN = (XTT -ORIG)/SDIV +1
      ELSE IF (IDT.EQ.2) THEN
*
*       Division along R axis
*
         R = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R = SQRT (R)
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IN = (R - ORIG) / SDIV + 1
         ELSE IF (ISH.EQ.7.OR.ISH.EQ.8) THEN
            IPAR = LQ(JGPAR-NLEVEL)
            DR   = 0.5 * (Q(IPAR+4) - Q(IPAR+2)) / Q(IPAR+1)
            RMN  = 0.5 * (Q(IPAR+4) + Q(IPAR+2)) + DR * XC(3)
            DR   = 0.5 * (Q(IPAR+5) - Q(IPAR+3)) / Q(IPAR+1)
            RMX  = 0.5 * (Q(IPAR+5) + Q(IPAR+3)) + DR * XC(3)
            STP  = (RMX - RMN) / NDIV
            IN   = (R - RMN) / STP + 1
         ELSE
            IPAR = LQ(JGPAR-NLEVEL)
            IF (ISH.EQ.12) THEN
               IPT = IPAR + 1
            ELSE
               IPT = IPAR + 2
            ENDIF
            IF (IZSEC.GT.0) THEN
               IPT = IPT + 3 * IZSEC
            ELSE
               NZ  = Q(IPT+2)
               DO 261 IZ = 1, NZ-1
                  IF((XC(3)-Q(IPT+3*IZ))*(XC(3)-Q(IPT+3*IZ+3)).LE.0.)
     +            THEN
                     IZSEC = IZ
                     IPT   = IPT + 3 * IZSEC
                     GO TO 262
                  ENDIF
  261          CONTINUE
               IN  = 0
               GO TO 265
            ENDIF
  262       POR1 = (Q(IPT+3) - XC(3)) / (Q(IPT+3) - Q(IPT))
            POR2 = (XC(3) - Q(IPT)) / (Q(IPT+3) - Q(IPT))
            RMN  = Q(IPT+1) * POR1 + Q(IPT+4) * POR2
            RMX  = Q(IPT+2) * POR1 + Q(IPT+5) * POR2
            IF (ISH.EQ.11) THEN
               NPDV = Q(IPAR+3)
               DPH  = Q(IPAR+2) / NPDV
               IF (IPSEC.LE.0) THEN
                  IF (XC(1).NE.0..OR.XC(2).NE.0.) THEN
                     PHI  = RADDEG * ATAN2 (XC(2), XC(1))
                  ELSE
                     PHI  = 0.0
                  ENDIF
                  PH0  = MOD (PHI-Q(IPAR+1)+360., 360.)
                  IPSEC= PH0/DPH + 1
               ENDIF
               PH   = DEGRAD * (Q(IPAR+1) + (IPSEC - 0.5) * DPH)
               R    = XC(1) * COS(PH) + XC(2) * SIN(PH)
            ENDIF
            STP = (RMX - RMN) / NDIV
            IN  = (R - RMN) / STP + 1
         ENDIF
      ELSE IF (IDT.EQ.3) THEN
*
*       Division along Phi axis
*
         IF (XC(1).NE.0..OR.XC(2).NE.0.) THEN
            PHI = RADDEG * ATAN2 (XC(2), XC(1))
         ELSE
            PHI = 0.
         ENDIF
         IN  = MOD (PHI-ORIG+360., 360.) / SDIV + 1
      ELSE IF (IDT.EQ.4) THEN
*
*       Division along Theta axis
*
         IF (XC(3).NE.0.0) THEN
            RXY  = SQRT (XC(1)**2 + XC(2)**2)
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0)  THET = THET + 180.0
         ELSE
            THET = 90.0
         ENDIF
         IN   = (THET - ORIG) / SDIV + 1
      ENDIF
*
  265 IF (IN.GT.NDIV) IN = 0
      IF (IN.LE.0) GO TO 300
*
      IF (JPAR.NE.0) THEN
         IF (IQ(JPAR-3).GT.1) THEN
            JPAR = LQ(JPAR-IN)
         ELSE
            JPAR = LQ(JPAR-1)
         ENDIF
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
      ELSE
         NPAR = Q(JVOT+5)
         JPAR = JVOT + 6
      ENDIF
*
*      Volume found at deeper level
*
      NLDOWN = NLEVEL +1
      LINMX(NLDOWN) = NDIV
      JSKL = LQ(JSKLT-NLDOWN)
*
*      Clear skeleton at lowest level if necessary
*
      JOFF = JSKL +IQ(JSKL-3)
      DO 269 ILEV = 1,NLEVEL
         IF (IQ(JOFF+ILEV).EQ.LINDEX(ILEV)) GO TO 269
         DO 267 I = ILEV,NLEVEL
            IQ(JOFF+I) = LINDEX(I)
  267    CONTINUE
         DO 268 I = 1,NDIV
            JSK = LQ(JSKL-I)
            IQ(JSK+1) = 0
  268    CONTINUE
         GO TO 270
  269 CONTINUE
*
*       Prepare skeleton at level down if not yet done
*
  270 JSK  = LQ(JSKL-IN)
      IF (IQ(JSK+1).EQ.0) THEN
         LQ(JSK-1) = JPAR
         IQ(JSK+1) = NPAR
         IQ(JSK+2) = IVOT
*
         IF (IDT.EQ.1) THEN
            X0(1) = 0.0
            X0(2) = 0.0
            X0(3) = 0.0
            X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
            IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
               CALL GCENT (IAXIS, X0)
            ENDIF
            IF (GRMAT(10,NLEVEL).EQ.0.0) THEN
               Q(JSK+3) = GTRAN(1,NLEVEL) + X0(1)
               Q(JSK+4) = GTRAN(2,NLEVEL) + X0(2)
               Q(JSK+5) = GTRAN(3,NLEVEL) + X0(3)
               DO 278 I = 1, 10, 2
                  Q(JSK+5+I) = GRMAT(I,NLEVEL)
                  Q(JSK+6+I) = GRMAT(I+1,NLEVEL)
  278          CONTINUE
            ELSE
               CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), X0, 0,
     +                      Q(JSK+3), Q(JSK+6))
            ENDIF
*
         ELSE IF (IDT.EQ.3.OR.IDT.EQ.4) THEN
            IF (IDT.EQ.3) THEN
               PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
               CPHR = COS (PH0)
               SPHR = SIN (PH0)
            ELSE
               PH0  = 0.0
               CPHR = 1.0
               SPHR = 0.0
            ENDIF
            DO 279 I = 1, 3
               Q(JSK+2+I) = GTRAN(I,NLEVEL)
               Q(JSK+5+I) = GRMAT(I,NLEVEL)*CPHR +GRMAT(I+3,NLEVEL)*SPHR
               Q(JSK+8+I) = GRMAT(I+3,NLEVEL)*CPHR -GRMAT(I,NLEVEL)*SPHR
               Q(JSK+11+I)= GRMAT(I+6,NLEVEL)
  279       CONTINUE
            IF (PH0.EQ.0.0.AND.GRMAT(10,NLEVEL).EQ.0.0) THEN
               Q(JSK+15) = 0.0
            ELSE
               Q(JSK+15) = 1.0
            ENDIF
            IF (ISH.EQ.11) IPSEC = 1
*
         ELSE
            Q(JSK+3) = GTRAN(1,NLEVEL)
            Q(JSK+4) = GTRAN(2,NLEVEL)
            Q(JSK+5) = GTRAN(3,NLEVEL)
            DO 281 I = 1, 10, 2
               Q(JSK+5+I) = GRMAT(I,NLEVEL)
               Q(JSK+6+I) = GRMAT(I+1,NLEVEL)
  281       CONTINUE
         ENDIF
*
      ENDIF
      GO TO 500
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
         IF (MANY.EQ.0) THEN
            WRITE (CHMAIL, 1001)
            CALL GMAIL (0 ,0)
            MANY = 1
         ENDIF
      ENDIF
*
      IQ(LCUR+2) = 1
      LPREV = LCUR +1
      GO TO 510
*
*       Move track down in skeleton
*
  500 IQ(LPREV)   = NSTO
      IQ(LCUR+1)  = IQ(JSKL+IN)
*      (reset INFROM to 0)
      IQ(LCUR+11) = 0
      IQ(JSKL+IN) = NCUR
*
  510 IF (NSTO.EQ.0) THEN
         GO TO 600
      ELSE
         NCUR = NSTO
         GO TO 50
      ENDIF
*
  589 IF (IDO.LT.NINSK) THEN
         IDO  = IDO +1
         INSK = INSK +1
         IF (INSK.GT.NINSK) INSK = 1
         IFUPD = 1
         GO TO 20
      ENDIF
*
*  **  No more elements at lowest level, go one level up in skeleton
*
      NLDOWN = NLDOWN -1
      INSK   = LINDEX(NLDOWN)
      IFUPD  = 0
      GO TO 11
*
  600 IF (NLDOWN.GT.NLEVEL) THEN
         IFUPD = 1
         GO TO 10
      ENDIF
*
*  **  Prepare 'IN current VOlume' chain
*
      NJINVO = IQ(JSKLD+INSK)
      IQ(JSKLD+INSK) = 0
*
      IF (NJTMAX.LT.0) THEN
*       (save status of skeleton for later reactivation of // tracking)
         DO 609 I = 2,NLEVEL
            LINSAV(I) = LINDEX(I)
            LMXSAV(I) = LINMX(I)
  609    CONTINUE
      ENDIF
*
* *** Fetch information for next track segment to be processed
*
  800 NCUR   = NJINVO
      LCUR   = JTRACK +(NCUR-1)*NWTRAC
      NJINVO = IQ(LCUR+1)
      NTMULT = IQ(LCUR+3)
      ITRA   = IQ(LCUR+4)
      ISTAK  = IQ(LCUR+5)
      IPART  = IQ(LCUR+6)
      NSTEP  = IQ(LCUR+7)
*free IDECAD = IQ(LCUR+8)
      IEKBIN = IQ(LCUR+9)
      ISTORY = IQ(LCUR+10)
      INFROM = IQ(LCUR+11)
*
      IF (IPART.NE.IPAOLD) THEN
         JPA = LQ(JPART-IPART)
         DO 819 I = 1,5
            NAPART(I) = IQ(JPA+I)
  819    CONTINUE
         ITRTYP = Q(JPA+6)
         AMASS  = Q(JPA+7)
         CHARGE = Q(JPA+8)
         TLIFE  = Q(JPA+9)
         IPAOLD = IPART
         IUPD   = 0
      ENDIF
*
      IPCUR = LCUR +NWINT
      DO 829 I = 1,7
         VECT(I) = Q(IPCUR+I)
  829 CONTINUE
      GEKIN  = Q(IPCUR+8)
      SLENG  = Q(IPCUR+9)
      GEKRAT = Q(IPCUR+10)
      TOFG   = Q(IPCUR+11)
      UPWGHT = Q(IPCUR+12)
*
      GETOT  = GEKIN +AMASS
      SAFETY = 0.
*
      IPCUR = IPCUR +NWREAL
      IF (ITRTYP.EQ.1) THEN
*      Photons
         ZINTPA = Q(IPCUR+1)
         ZINTCO = Q(IPCUR+2)
         ZINTPH = Q(IPCUR+3)
         ZINTPF = Q(IPCUR+4)
         ZINTRA = Q(IPCUR+5)
      ELSE IF (ITRTYP.EQ.2) THEN
*     Electrons
         ZINTBR = Q(IPCUR+1)
         ZINTDR = Q(IPCUR+2)
         ZINTAN = Q(IPCUR+3)
      ELSE IF (ITRTYP.EQ.3) THEN
*     Neutral hadrons
         SUMLIF = Q(IPCUR+1)
         ZINTHA = Q(IPCUR+2)
      ELSE IF (ITRTYP.EQ.4) THEN
*     Charged hadrons
         SUMLIF = Q(IPCUR+1)
         ZINTHA = Q(IPCUR+2)
         ZINTDR = Q(IPCUR+3)
      ELSE IF (ITRTYP.EQ.5) THEN
*     Muons
         SUMLIF = Q(IPCUR+1)
         ZINTBR = Q(IPCUR+2)
         ZINTPA = Q(IPCUR+3)
         ZINTDR = Q(IPCUR+4)
         ZINTMU = Q(IPCUR+5)
      ELSE IF (ITRTYP.EQ.7) THEN
*     Cerenkov photons
         ZINTLA = Q(IPCUR+1)
      ELSE IF (ITRTYP.EQ.8) THEN
*     Ions
         ZINTHA = Q(IPCUR+1)
         ZINTDR = Q(IPCUR+2)
      ENDIF
*
*   *  Reset NUMED
*
      JVO   = LQ(JVOLUM-LVOLUM(NLEVEL))
      NUMED = Q(JVO+4)
*
*     Link selected track segment area to 'garbaged' chain
*
      IQ(LCUR+1) = NJGARB
      NJGARB     = NCUR
*
*     Save skeleton status when parallel tracking is frozen
*
      IF (NJTMAX.LT.0) THEN
         NLVSAV = NLEVEL
         DO 889 ILEV = 2,NLDOWN
            LINSAV(ILEV) = LINDEX(ILEV)
            LMXSAV(ILEV) = LINMX(ILEV)
  889    CONTINUE
      ENDIF
*
 1001 FORMAT (' GFTRAC : Simple NOT-ONLY configuration assumed. OK?')
*                                                             END GFTRAC
      END
+DECK,  GGCKOV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GGCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine is called for each tracking step of a charged   *
C.    *   particle in a radiator. A Poisson-distributed number of      *
C.    *   photons is generated according to the Cherenkov formula,     *
C.    *   distributed evenly along the track segment and uniformly     *
C.    *   azimuth w.r.t. the particle direction. The parameters are    *
C.    *   then transformed into the Master Reference System, and they  *
C.    *   are added to the particle stack.                             *
C.    *                                                                *
C.    *   ==>Called by : GTMUON, GTHADR, GTELEC                        *
C.    *      Authors     R.Jones, F.Carminati ********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCTMED.
+CDE, GCUNIT.
+CDE, GCTRAK.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCONSP.
*
      REAL RPHOT(3)
      LOGICAL ROTATE
      PARAMETER (RFACT=369.81E9)
*
*   ------------------------------------------------------------------
*
* *** See whether we generate at least one photon
*
C     THRIND = GETOT/VECT(7)
C     IF(Q(JINDEX+NPCKOV).LT.THRIND) THEN
C        GO TO 999
C     ELSEIF(Q(JINDEX+1).GE.THRIND) THEN
C        PMIN  = Q(JTCKOV+2)
C        DP    = Q(JTCKOV+NPCKOV+1)-PMIN
C        GE    = Q(JCURIN+NPCKOV)
C        JMIN  = 1
C     ELSE
C        JMIN = 1
C        JMAX = NPCKOV
C  10    JMED = (JMIN+JMAX)/2
C        IF(Q(JINDEX+JMED).LT.THRIND) THEN
C           JMIN = JMED
C        ELSE
C           JMAX = JMED
C        ENDIF
C        IF(JMAX-JMIN.GT.1) GO TO 10
C        RATIO =
C    +   (THRIND-Q(JINDEX+JMIN))/(Q(JINDEX+JMIN+1)-Q(JINDEX+JMIN))
C        RATI1 = 1.-RATIO
C        PMIN  = Q(JTCKOV+JMIN+1)*RATI1+Q(JTCKOV+JMIN+2)*RATIO
C        DP    = Q(JTCKOV+NPCKOV+1)-PMIN
C        GEMIN = Q(JCURIN+JMIN)*RATI1+Q(JCURIN+JMIN+1)*RATIO
C        GE    = Q(JCURIN+NPCKOV)-GEMIN
C     ENDIF
C     DNDL = RFACT*(CHARGE**2)*(DP-GE*THRIND**2)
      IF(ITRTYP.NE.4.AND.ITRTYP.NE.8) CALL GNCKOV
      CALL GPOISS(DNDL*STEP,NGPHOT,1)
      IF(NGPHOT.EQ.0) THEN
         GO TO 999
      ELSEIF(NGPHOT.GT.MXPHOT) THEN
         WRITE(CHMAIL,10000) NGPHOT-MXPHOT
10000   FORMAT(' **** GGCKOV Overflow in the photon stack, ',I10,
     +         ' photons are lost')
         CALL GMAIL(0,0)
         NGPHOT = MXPHOT
      ENDIF
*
* ***  Set up rotation to Particle frame
*
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
*
* ***  Distribute the photons in origin, direction, momentum
      COSMX  = THRIND/Q(JINDEX+NPCKOV)
      SINMX2 = (1.-COSMX)*(1.+COSMX)
      DO 40 J=1,NGPHOT
         CALL GRNDM(RPHOT, 1)
         IF(IGNEXT.NE.0) THEN
            DS=(STEP-PREC)*RPHOT(1)+PREC
         ELSE
            DS = STEP*RPHOT(1)
         ENDIF
         XPHOT(1,J) = VECT(1)-VECT(4)*DS
         XPHOT(2,J) = VECT(2)-VECT(5)*DS
         XPHOT(3,J) = VECT(3)-VECT(6)*DS
         XPHOT(11,J)= TOFG+(STEP-DS)*GETOT/(VECT(7)*CLIGHT)
*
* *** Sample the momentum of the photon
   20    CALL GRNDM(RPHOT, 3)
         PPHOT=PMIN+RPHOT(1)*DP
*
* *** Find in which bin we are
         KMIN = JMIN
         KMAX = NPCKOV
   30    KMED = (KMIN+KMAX)/2
         IF(Q(JTCKOV+1+KMED).LT.PPHOT) THEN
            KMIN = KMED
         ELSE
            KMAX = KMED
         ENDIF
         IF(KMAX-KMIN.GT.1) GOTO 30
         RATIO = (PPHOT-Q(JTCKOV+1+KMIN))/
     +           (Q(JTCKOV+KMIN+2)-Q(JTCKOV+1+KMIN))
         RATI1  = (1.-RATIO)
*
* *** Find the density function value corresponding to the
* *** momentum sampled
         RINDEX = Q(JINDEX+KMIN)*RATI1+Q(JINDEX+KMIN+1)*RATIO
         COST   = THRIND/RINDEX
         SINT2  = (1.-COST)*(1.+COST)
*
* *** Perform hit-and-miss
         IF(RPHOT(2)*SINMX2.GT.SINT2) GO TO 20
         SINT = SQRT(SINT2)
         PHI  = TWOPI*RPHOT(3)
         SINP = SIN(PHI)
         COSP = COS(PHI)
         XPHOT(4,J) = SINT*COSP
         XPHOT(5,J) = SINT*SINP
         XPHOT(6,J) = COST
         XPHOT(7,J) = PPHOT
         XPHOT(8,J) = COST*COSP
         XPHOT(9,J) = COST*SINP
         XPHOT(10,J) = -SINT
*
         IF(ROTATE) THEN
            CALL GDROT(XPHOT(8,J),COSTH,SINTH,COSPH,SINPH)
            CALL GDROT(XPHOT(4,J),COSTH,SINTH,COSPH,SINPH)
         ENDIF
   40 CONTINUE
  999 END
+DECK,  GHELIX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GHELIX (CHARGE, STEP, VECT, VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Performs the tracking of one step in a magnetic field         *
C.    *  The trajectory is assumed to be a helix in a constant field   *
C.    *  taken at the mid point of the step.                           *
C.    *  Parameters:                                                   *
C.    *   input                                                        *
C.    *     STEP =arc length of the step asked                         *
C.    *     VECT =input vector (position,direction cos and momentum)   *
C.    *     CHARGE=  electric charge of the particle                   *
C.    *   output                                                       *
C.    *     VOUT = same as VECT after completion of the step           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSWIM                               *
C.    *       Author    M.Hansroul  *********                          *
C.    *       Modified  S.Egli, S.V.Levonian                           *
C.    *       Modified  V.Perevoztchikov
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION      VECT(7),VOUT(7)
      DIMENSION      XYZ(3),H(4),HXP(3)
      PARAMETER      (IX=1,IY=2,IZ=3,IPX=4,IPY=5,IPZ=6,IPP=7)
      PARAMETER      (SIXTH = 1./6.)
      PARAMETER      (EC=2.9979251E-4)
C.
C.    ------------------------------------------------------------------
C.
C       units are kgauss,centimeters,gev/c
C
      VOUT(IPP) = VECT(IPP)
      IF (CHARGE.EQ.0.)         GO TO 10
      XYZ(1)    = VECT(IX) + 0.5 * STEP * VECT(IPX)
      XYZ(2)    = VECT(IY) + 0.5 * STEP * VECT(IPY)
      XYZ(3)    = VECT(IZ) + 0.5 * STEP * VECT(IPZ)
C
      CALL GUFLD (XYZ, H)

      H2XY = H(1)**2 + H(2)**2
      H(4) = H(3)**2 + H2XY
      IF (H(4).LE.1.E-12)       GO TO 10
      IF (H2XY.LE.1.E-12*H(4))  THEN
         CALL GHELX3 (CHARGE*H(3), STEP, VECT, VOUT)
         GO TO 999
      ENDIF
      H(4) = SQRT(H(4))
      H(1) = H(1)/H(4)
      H(2) = H(2)/H(4)
      H(3) = H(3)/H(4)
      H(4) = H(4)*EC
*
      HXP(1) = H(2)*VECT(IPZ) - H(3)*VECT(IPY)
      HXP(2) = H(3)*VECT(IPX) - H(1)*VECT(IPZ)
      HXP(3) = H(1)*VECT(IPY) - H(2)*VECT(IPX)

      HP = H(1)*VECT(IPX) + H(2)*VECT(IPY) + H(3)*VECT(IPZ)
*
      RHO = -CHARGE*H(4)/VECT(IPP)
      TET = RHO * STEP
      IF (ABS(TET).GT.0.15)     THEN
         SINT = SIN(TET)
         SINTT = (SINT/TET)
         TSINT = (TET-SINT)/TET
         COS1T = 2.*(SIN(0.5*TET))**2/TET
      ELSE
         TSINT = SIXTH*TET**2
         SINTT = (1. - TSINT)
         SINT = TET*SINTT
         COS1T = 0.5*TET
      ENDIF
*
      F1 = STEP * SINTT
      F2 = STEP * COS1T
      F3 = STEP * TSINT * HP
      F4 = -TET*COS1T
      F5 = SINT
      F6 = TET * COS1T * HP

      VOUT(IX) = VECT(IX) + (F1*VECT(IPX) + F2*HXP(1) + F3*H(1))
      VOUT(IY) = VECT(IY) + (F1*VECT(IPY) + F2*HXP(2) + F3*H(2))
      VOUT(IZ) = VECT(IZ) + (F1*VECT(IPZ) + F2*HXP(3) + F3*H(3))

      VOUT(IPX) = VECT(IPX) + (F4*VECT(IPX) + F5*HXP(1) + F6*H(1))
      VOUT(IPY) = VECT(IPY) + (F4*VECT(IPY) + F5*HXP(2) + F6*H(2))
      VOUT(IPZ) = VECT(IPZ) + (F4*VECT(IPZ) + F5*HXP(3) + F6*H(3))

      GO TO 999

   10 CONTINUE
      DO 20 I   = 1,3
         VOUT(I) = VECT(I) + STEP * VECT(I+3)
         VOUT(I+3) = VECT(I+3)
   20 CONTINUE
C
  999 END
+DECK,  GHELX3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GHELX3 (FIELD, STEP, VECT, VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Tracking routine in a constant field oriented            *
C.    *       along axis 3                                             *
C.    *       Tracking is performed with a conventional                *
C.    *       helix step method                                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSWIM                               *
C.    *       Authors    R.Brun, M.Hansroul  *********                 *
C     *       Rewritten  V.Perevoztchikov
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION      VECT(7),VOUT(7),HXP(3)
      PARAMETER      (IX=1,IY=2,IZ=3,IPX=4,IPY=5,IPZ=6,IPP=7)
      PARAMETER      (SIXTH = 1./6.)
      PARAMETER      (EC=2.9979251E-4)
C.
C.    ------------------------------------------------------------------
C.
C       units are kgauss,centimeters,gev/c
C
      VOUT(IPP) = VECT(IPP)
      H4 = FIELD * EC
*
      HXP(1) = - VECT(IPY)
      HXP(2) = + VECT(IPX)

      HP = VECT(IPZ)
*
      RHO = -H4/VECT(IPP)
      TET = RHO * STEP
      IF (ABS(TET).GT.0.15)     THEN
         SINT = SIN(TET)
         SINTT = (SINT/TET)
         TSINT = (TET-SINT)/TET
         COS1T = 2.*(SIN(0.5*TET))**2/TET
      ELSE
         TSINT = SIXTH*TET**2
         SINTT = (1. - TSINT)
         SINT = TET*SINTT
         COS1T = 0.5*TET
      ENDIF
*
      F1 = STEP * SINTT
      F2 = STEP * COS1T
      F3 = STEP * TSINT * HP
      F4 = -TET*COS1T
      F5 = SINT
      F6 = TET * COS1T * HP

      VOUT(IX) = VECT(IX) + (F1*VECT(IPX) + F2*HXP(1))
      VOUT(IY) = VECT(IY) + (F1*VECT(IPY) + F2*HXP(2))
      VOUT(IZ) = VECT(IZ) + (F1*VECT(IPZ) + F3)

      VOUT(IPX) = VECT(IPX) + (F4*VECT(IPX) + F5*HXP(1))
      VOUT(IPY) = VECT(IPY) + (F4*VECT(IPY) + F5*HXP(2))
      VOUT(IPZ) = VECT(IPZ) + (F4*VECT(IPZ) + F6)

C
  999 END
+DECK,  GINVO2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:45  cernlib
* Geant

+SELF, IF=OLD.
      SUBROUTINE GINVOL (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SELF, IF=OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=OLD.
C.
      DIMENSION  X(*)
      REAL       XC(3), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               IDIV = LOCATF (Q(JSB+3), NSB, XC(IAX))
            ELSE
               CALL GFCOOR (XC, IAX, CX)
               IDIV = LOCATF (Q(JSB+3), NSB, CX)
            ENDIF
            IF (IDIV.LT.0) IDIV = -IDIV
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=OLD, IF=-USRJMP.
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=OLD, IF=USRJMP.
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF, IF=OLD.
            ELSEIF (INFR.GT.0) THEN
               JNUP = LQ(LQ(JVO-INFR)-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)

         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480

  450 ISAME = 0

  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+SELF.
+DECK,  GINVOL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

+SELF, IF=-OLD.
      SUBROUTINE GINVOL (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SELF, IF=-OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=-OLD.
+CDE, GCHVIR.
C.
      DIMENSION  X(*)
      REAL       XC(6), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
         ingt=0
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)

         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480

  450 ISAME = 0

  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+SELF.
+DECK,  GLSKLT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GLSKLT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GLSKLT                                                *
C.    *                                                                *
C.    *   Prepares the Skeleton banks for parallel tracking            *
C.    *   Also lifts the stack bank JTRACK                             *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSTAK.
+CDE, GCTRAK.
+CDE, GCVOLU.
C.
      COMMON /GCSKLT/ LOCAL(2), JSK, JSKL, JVOLX
      CHARACTER*12    CFORM
C.
C.    ------------------------------------------------------------------
*
      IF (JSKLT.EQ.0) THEN
*
*  **    Initialize a temporary link area
*
         CALL MZLINT (IXSTOR, '/GCSKLT/', LOCAL, JSK, JVOLX)
         CALL MZFORM ('SKIN', '2I -F', IOSKIN)
         JVOLX = LQ(JVOLUM)
         NLVT  = IQ(JVOLX-1)
*
*  **    Lift the top level bank
*
         CALL MZBOOK (IXCONS, JSKLT, JSKLT, 1, 'SKLT', NLVT, NLVT, 0,
     +                2, 0)
         CALL MZBOOK (IXCONS, JSKL, JSKLT, -1, 'SKLV', 1, 1, 1, 2, 0)
         CALL MZBOOK (IXCONS, JSK, JSKL, -1, 'SKIN', 1, 0, 2, 2, -1)
         JVO  = LQ(JVOLUM-1)
         LQ(JSK-1) = JVO + 6
         IQ(JSK+1) = Q(JVO+5)
         IQ(JSK+2) = 1
*
*  **    Loop over the remaining levels
*
         DO 15 ILEV = 2, NLVT
            NINSK = IQ(JVOLX+ILEV)
            ND    = NINSK + ILEV - 1
            CALL MZBOOK (IXCONS, JSKL, JSKLT,-ILEV,'SKLV', NINSK, NINSK,
     +                   ND, 2, 0)
            DO 10 IN = 1, NINSK
               CALL MZBOOK (IXCONS, JSK, JSKL, -IN, 'SKIN', 1, 0, 15,
     +                      IOSKIN, 1)
   10       CONTINUE
   15    CONTINUE
*
*  **    Now create the Stack bank JTRACK
*
         NWR    = NWTRAC - NWINT
         WRITE (CFORM, 1001) NWINT, NWR
         CALL MZFORM ('TRAC', CFORM, IOTRAC)
         ND     = NWTRAC * NJTMAX
         CALL MZBOOK (IXCONS, JTRACK, JTRACK, 1, 'TRAC', 0, 0, ND,
     +                IOTRAC, -1)
*
         LOCAL(1) = 0
*
      ELSE
*
*  **    Clear the pointers in the skeleton
*
         DO 25 ILEV = 1, NLEVMX
            JSKL = LQ(JSKLT-ILEV)
            DO 20 I = 1, IQ(JSKL-3)
               IQ(JSKL+I) = 0
   20       CONTINUE
   25    CONTINUE
      ENDIF
*
* *** Fill up the skeleton upto NLEVEL
*
      IF (NLEVEL.GT.1) THEN
         DO 60 ILEV = 2, NLEVEL
            JSKL  = LQ(JSKLT-ILEV)
            NINSK = LINMX(ILEV)
            JOFF  = JSKL + IQ(JSKL-3)
            DO 40 IL = 1, ILEV-1
               IF (IQ(JOFF+IL).EQ.LINDEX(IL)) GO TO 40
               DO 30 I = IL, ILEV-1
                  IQ(JOFF+I) = LINDEX(I)
   30          CONTINUE
               DO 35 I = 1, NINSK
                 JSK  = LQ(JSKL-I)
                 IQ(JSK+1) = 0
   35          CONTINUE
               GO TO 45
   40       CONTINUE
   45       JSK  = LQ(JSKL-LINDEX(ILEV))
            IF (IQ(JSK+1).LE.0) THEN
               LQ(JSK-1) = LQ(JGPAR-ILEV)
               IQ(JSK+1) = IQ(JGPAR+ILEV)
               IQ(JSK+2) = LVOLUM(ILEV)
               DO 50 I = 1, 3
                  Q(JSK+2+I) = GTRAN(I,ILEV)
   50          CONTINUE
               DO 55 I = 1, 10
                  Q(JSK+5+I) = GRMAT(I,ILEV)
   55          CONTINUE
            ENDIF
   60    CONTINUE
      ENDIF
*
* *** Initialize pointers
*
      NJFREE = 1
      NJGARB = 0
      NJINVO = 0
      NLDOWN = 1
*
 1001 FORMAT ('/ ',I3,'I ',I3,'F ')
*                                                             END GLSKLT
      END
+DECK,  GLTRAC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GLTRAC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GLTRAC                                                *
C.    *                                                                *
C.    *   Extracts next track from stack JSTAK and prepares commons    *
C.    *    /GCTRAK/, /GCKINE/ and /GCVOLU/                             *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
      DIMENSION RNDM(5)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION P2,GETOTD,GEKIND
      DOUBLE PRECISION PXD,PYD,PZD,ONE,HNORM,DAMASS,PP
+SELF.
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
*
* *** Extract next track from stack JSTAK
*
      IF(ISTORD.EQ.1) THEN
*
* *** User ordering of tracks if requested
         CALL GSTORD
      ENDIF
      ISTAK = IQ(JSTAK+1)
      IQ(JSTAK+1) = ISTAK -1
      JST = JSTAK +NWSTAK*IQ(JSTAK+1) +3
      ITRA   = IQ(JST+1)
      IF (ITRA.LT.0) THEN
         ITRA = -ITRA
      ELSE
*
*        This is a new track. We set to zero the stack number and
*        update the vertex number
         ISTAK = 0
         JK=LQ(JKINE-ITRA)
         IVERT=Q(JK+6)
      ENDIF
      IPART  = IQ(JST+2)
      DO 60 I = 1,3
         VERT(I) = Q(JST+3+I)
        PVERT(I) = Q(JST+6+I)
   60 CONTINUE
      TOFG   = Q(JST+10)
      SAFETY = Q(JST+11)
      UPWGHT = Q(JST+12)
*
* *** Prepare tracking parameters
*
      VECT(1) = VERT(1)
      VECT(2) = VERT(2)
      VECT(3) = VERT(3)
      PXD = PVERT(1)
      PYD = PVERT(2)
      PZD = PVERT(3)
      P2 = PXD**2+PYD**2+PZD**2
      IF(P2.GT.0.) THEN
         PP    = SQRT(P2)
         HNORM = ONE/PP
         VECT(4) = PVERT(1)*HNORM
         VECT(5) = PVERT(2)*HNORM
         VECT(6) = PVERT(3)*HNORM
         VECT(7) = PP
      ELSE
         VECT(4) = 0.
         VECT(5) = 0.
         VECT(6) = 1.
         VECT(7) = 0.
      ENDIF
*
*  ** Reload Particle characteristics, if needed
*
      IF (IPART.NE.IPAOLD) THEN
         JPA = LQ(JPART-IPART)
         DO 90 I = 1,5
            NAPART(I) = IQ(JPA+I)
   90    CONTINUE
         ITRTYP = Q(JPA+6)
         AMASS  = Q(JPA+7)
         CHARGE = Q(JPA+8)
         TLIFE  = Q(JPA+9)
         IUPD   = 0
         IPAOLD = IPART
      ENDIF
*
      DAMASS = AMASS
      GETOTD = SQRT(P2+DAMASS**2)
      GEKIND = GETOTD - DAMASS
      GETOT  = GETOTD
      GEKIN  = GEKIND
*
      IF (ITRTYP.EQ.7) THEN
*
* *** Cerenkov photon. Retrieve polarisation
         JPO = LQ(JSTAK-1)+(ISTAK-1)*3
         POLAR(1) = Q(JPO+1)
         POLAR(2) = Q(JPO+2)
         POLAR(3) = Q(JPO+3)
      ELSE
         CALL GEKBIN
      ENDIF
*
      SLENG  = 0.
      NSTEP  = 0
      NTMSTO = NTMSTO +1
      NTMULT = NTMSTO
      ISTORY = 0
*
*  ** Initialize interaction probabilities
*
      IF (ITRTYP.EQ.1) THEN
*      Gammas
         CALL GRNDM(RNDM,5)
         ZINTPA = -LOG(RNDM(1))
         ZINTCO = -LOG(RNDM(2))
         ZINTPH = -LOG(RNDM(3))
         ZINTPF = -LOG(RNDM(4))
         ZINTRA = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.2) THEN
*       Electrons
         CALL GRNDM(RNDM,3)
         ZINTBR = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
         ZINTAN = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.3) THEN
*       Neutral hadrons
         CALL GRNDM(RNDM,2)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
      ELSE IF (ITRTYP.EQ.4) THEN
*       Charged hadrons
         CALL GRNDM(RNDM,3)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
         ZINTDR = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.5) THEN
*       Muons
         CALL GRNDM(RNDM,5)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTBR = -LOG(RNDM(2))
         ZINTPA = -LOG(RNDM(3))
         ZINTDR = -LOG(RNDM(4))
         ZINTMU = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.7) THEN
*       Cerenkov photons
         CALL GRNDM(RNDM,1)
         ZINTLA = -LOG(RNDM(1))
      ELSE IF (ITRTYP.EQ.8) THEN
*       Ions
         CALL GRNDM(RNDM,2)
         ZINTHA = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
      ENDIF
*
*   * Prepare common /GCVOLU/ and structure JGPAR, if needed
*
      IF (NJTMAX.LE.0) THEN
        IF (GONLY(NLEVEL).EQ.0.) NLEVEL=0
        CALL GMEDIA (VECT, NUMED)
      ENDIF
      INFROM = 0
*                                                             END GLTRAC
      END

+DECK,  GNCKOV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GNCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine calculates the number of Cerenkov photons       *
C.    *   produced per centimeter in the current medium.               *
C.    *                                                                *
C.    *   ==>Called by : GRANGI                                        *
C.    *      Authors     R.Jones, F.Carminati ********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCTMED.
+CDE, GCUNIT.
+CDE, GCTRAK.
+CDE, GCKINE.
+CDE, GCONSP.
*
      PARAMETER (RFACT=369.81E9)
*
*   ------------------------------------------------------------------
*
* *** See whether we generate at least one photon
*
      THRIND = GETOT/VECT(7)
      IF(Q(JINDEX+NPCKOV).LT.THRIND) THEN
         DP   = 0.
         GE   = 0.
      ELSEIF(Q(JINDEX+1).GE.THRIND) THEN
         PMIN = Q(JTCKOV+2)
         DP   = Q(JTCKOV+NPCKOV+1)-PMIN
         GE   = Q(JCURIN+NPCKOV)
         JMIN = 1
      ELSE
         JMIN = 1
         JMAX = NPCKOV
   10    JMED = (JMIN+JMAX)/2
         IF(Q(JINDEX+JMED).LT.THRIND) THEN
            JMIN = JMED
         ELSE
            JMAX = JMED
         ENDIF
         IF(JMAX-JMIN.GT.1) GO TO 10
         RATIO =
     +   (THRIND-Q(JINDEX+JMIN))/(Q(JINDEX+JMIN+1)-Q(JINDEX+JMIN))
         RATI1 = 1.-RATIO
         PMIN  = Q(JTCKOV+JMIN+1)*RATI1+Q(JTCKOV+JMIN+2)*RATIO
         DP    = Q(JTCKOV+NPCKOV+1)-PMIN
         GEMIN = Q(JCURIN+JMIN)*RATI1+Q(JCURIN+JMIN+1)*RATIO
         GE    = Q(JCURIN+NPCKOV)-GEMIN
      ENDIF
      DNDL = RFACT*(CHARGE**2)*(DP-GE*THRIND**2)
 999  END
+DECK,  GPCXYZ, T=FORT.
* Revision 1.2  1999/11/04 15:06:44  japost
*  Better printing for MAXSTEP.   Suggestion: fca
* Revision 1.1.1.1  1995/10/24 10:21:41  cernlib
* Geant

      SUBROUTINE GPCXYZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        Print track and volume parameters at current point      *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCVOLU.
+CDE, GCTRAK.
+CDE, GCNUM.
+CDE, GCUNIT.
      DIMENSION MECNAM(20)
      CHARACTER*4 KUN1,KUN2
      SAVE IEVOLD,NTMOLD
      DATA IEVOLD,NTMOLD/-1,-1/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFINIT(9).EQ.0)THEN
         IFINIT(9)=1
         IEVOLD=-1
         NTMOLD=-1
      ENDIF
C
      NM=NMEC
      IF(NM.EQ.0)THEN
         MECNAM(1)=NAMEC(29)
         NM=1
      ELSE
         DO 10 I=1,NMEC
            MEC=LMEC(I)
            IF(MEC.LE.MAXMEC) THEN
               MECNAM(I)=NAMEC(MEC)
            ELSEIF(MEC-100.LE.MAXME1.AND.MEC-100.GT.0) THEN
               MECNAM(I)=NAMEC1(MEC-100)
            ENDIF
  10     CONTINUE
      ENDIF
C
      IF(IEVENT.EQ.IEVOLD.AND.NTMULT.EQ.NTMOLD)GO TO 20
C
C
      TOFGN=TOFG*1.E+9
      WRITE(CHMAIL,1000)ITRA,ISTAK,NTMULT,(NAPART(I),I=1,5),TOFGN
      CALL GMAIL(0,0)
      WRITE(CHMAIL,1100)
      CALL GMAIL(0,0)
      IEVOLD=IEVENT
      NTMOLD=NTMULT
C
  20  R=SQRT(VECT(1)**2+VECT(2)**2)
      CALL GEVKEV(DESTEP,DESU,KUN1)
      CALL GEVKEV(GEKIN ,GEKU,KUN2)
      NS = 1
      NW = MIN(NS+5,NM)
      WRITE(CHMAIL,2000)(VECT(I),I=1,3),R,NAMES(NLEVEL),NUMBER(NLEVEL)
     +      ,SLENG,STEP,DESU,KUN1,GEKU,KUN2,(MECNAM(I),I=NS,NW)
  30  CALL GMAIL(0,0)
      IF(NM.GT.NW) THEN
         NS = NW + 1
         NW = MIN(NS+5,NM)
         WRITE(CHMAIL,3000) (MECNAM(I),I=NS,NW)
         GOTO 30
      ENDIF
C
 1000 FORMAT(' =====> TRACK ',I4,' STACK NR',I4,' NTMULT=',I10,5X,
     +5A4,5X,'TOFG =',F10.3,' NS')
 1100 FORMAT('       X          Y          Z          R   ',
     +'  NAME  NUMBER',
     +'   SLENG      STEP      DESTEP     GEKIN   MECHANISMS')
 2000 FORMAT(1X,4F11.4,1X,A4,1X,I4,1X,2F10.4,F7.1,A4,F9.3,A4,1X,
     +          6(A4,1X))
 3000 FORMAT(101X,6(A4,1X))
C
      END
+DECK,  GPGKIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:42  cernlib
* Geant

      SUBROUTINE GPGKIN
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        Print kinematics of secondary tracks at the current     *
C.    *        interaction point.                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>,GUSTEP,GDEBUG                         *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKING.
+CDE, GCUNIT.
      CHARACTER*4 UNITK,UNITE,UNITSK,UNITSE
C.
C.    ------------------------------------------------------------------
C.
      SEK=0.
      SET=0.
      DO 10 I=1,NGKINE
         ITY=GKIN(5,I)
         ET=GKIN(4,I)
         TOFDN=TOFD(I)*1.E+9
         JP=LQ(JPART-ITY)
         EK=ET-Q(JP+7)
         SEK=SEK+EK
         SET=SET+ET
         CALL GEVKEV(EK,EKU,UNITK)
         CALL GEVKEV(ET,ETU,UNITE)
         IF(I.LT.NGKINE)THEN
            WRITE(CHMAIL,1000)I,(IQ(JP+J),J=1,4),EKU,UNITK,ETU,UNITE
     +                         ,TOFDN
         ELSE
            CALL GEVKEV(SEK,SEKU,UNITSK)
            CALL GEVKEV(SET,SETU,UNITSE)
            WRITE(CHMAIL,2000)I,(IQ(JP+J),J=1,4),EKU,UNITK,ETU,UNITE
     +                         ,TOFDN,SEKU,UNITSK,SETU,UNITSE
         ENDIF
         CALL GMAIL(0,0)
  10  CONTINUE
*
 1000 FORMAT(4X,'===>',I3,1X,4A4,' EK=',F7.3,A,' ET=',F7.3,A,
     +       ' TOFD=',F10.3,' ns')
 2000 FORMAT(4X,'===>',I3,1X,4A4,' EK=',F7.3,A,' ET=',F7.3,A,
     +       ' TOFD=',F10.3,' ns   SEK=',F7.3,A,' SET=',F7.3,A)
      END
+DECK,  GPJXYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:42  cernlib
* Geant

      SUBROUTINE GPJXYZ(IT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints JXYZ bank for track number IT                     *
C.    *       If IT=0 Prints all track banks                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      I1=1
      I2=NTRACK
      IF(IT.NE.0)I1=IT
      IF(IT.NE.0)I2=IT
      IF(I2.GT.NTRACK)GO TO 99
      IF(I1.LT.1)GO TO 99
      IF(JKINE.LE.0)GO TO 99
      IF(JXYZ.LE.0)GO TO 99
C
      DO 90 I=I1,I2
         JK=LQ(JKINE-I)
         IF(JK.NE.0)THEN
            IPART=Q(JK+5)
            JPA=LQ(JPART-IPART)
            WRITE(CHMAIL,1000)I,(IQ(JPA+L),L=1,4)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,1100)
            CALL GMAIL(0,0)
C
            JX=LQ(JXYZ-I)
            IPOINT=JX+3
            IP=0
  10        NPOINT=Q(IPOINT)
            IF(NPOINT.GT.0)THEN
               IPT=Q(IPOINT+1)
               DO 20 K=1,NPOINT
                  KP=IPOINT+3*K-2
                  IP=IP+1
                  WRITE(CHMAIL,2000)IP,IPT,(Q(KP+L),L=1,3)
                  CALL GMAIL(0,0)
  20           CONTINUE
C
               IPOINT=IPOINT+3.*Q(IPOINT)+2.
               GO TO 10
            ENDIF
         ENDIF
  90  CONTINUE
C
 1000 FORMAT(3X,'JXYZ',3X,'TRACK NUMBER',I5,2X,4A4)
 1100 FORMAT(6X,'POINT',6X,'PART',6X,'X',10X,'Y',10X,'Z')
 2000 FORMAT(4X,I6,6X,I4,2X,F10.4,1X,F10.4,1X,F10.4)
C
  99  RETURN
      END
+DECK,  GRANOR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:42  cernlib
* Geant

      SUBROUTINE GRANOR(A,B)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To generate 2 numbers A and B following a NORMAL         *
C.    *       distribution (mean=0 sigma=1.)                           *
C.    *         Copy of the CERN Library routine RANNOR                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, many GEANT routines                  *
C.    *       Author    F.Carminati *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION RNDM(2)
*
      CALL GRNDM(RNDM,2)
      Y=RNDM(1)
      Z=RNDM(2)
      X=6.283185*Z
      A1=SQRT (-2.0*LOG(Y))
      A=A1*SIN (X)
      B=A1*COS (X)
      RETURN
      END

+DECK,  GRKUTA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:42  cernlib
* Geant

      SUBROUTINE GRKUTA (CHARGE,STEP,VECT,VOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Runge-Kutta method for tracking a particle through a magnetic *
C.    *  field. Uses Nystroem algorithm (See Handbook Nat. Bur. of     *
C.    *  Standards, procedure 25.5.20)                                 *
C.    *                                                                *
C.    *  Input parameters                                              *
C.    *       CHARGE    Particle charge                                *
C.    *       STEP      Step size                                      *
C.    *       VECT      Initial co-ords,direction cosines,momentum     *
C.    *  Output parameters                                             *
C.    *       VOUT      Output co-ords,direction cosines,momentum      *
C.    *  User routine called                                           *
C.    *       CALL GUFLD(X,F)                                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSWIM                               *
C.    *       Authors    R.Brun, M.Hansroul  *********                 *
C.    *                  V.Perevoztchikov (CUT STEP implementation)    *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
+SELF.
      REAL CHARGE, STEP, VECT(*), VOUT(*), F(4)
      REAL XYZT(3), XYZ(3), X, Y, Z, XT, YT, ZT
      DIMENSION SECXS(4),SECYS(4),SECZS(4),HXP(3)
      EQUIVALENCE (X,XYZ(1)),(Y,XYZ(2)),(Z,XYZ(3)),
     +            (XT,XYZT(1)),(YT,XYZT(2)),(ZT,XYZT(3))
*
      PARAMETER (MAXIT = 1992, MAXCUT = 11)
      PARAMETER (EC=2.9979251D-4,DLT=1D-4,DLT32=DLT/32)
      PARAMETER (ZERO=0, ONE=1, TWO=2, THREE=3)
      PARAMETER (THIRD=ONE/THREE, HALF=ONE/TWO)
      PARAMETER (PISQUA=.986960440109D+01)
      PARAMETER      (IX=1,IY=2,IZ=3,IPX=4,IPY=5,IPZ=6)
*.
*.    ------------------------------------------------------------------
*.
*             This constant is for units CM,GEV/C and KGAUSS
*
      ITER = 0
      NCUT = 0
      DO 10 J=1,7
         VOUT(J)=VECT(J)
   10 CONTINUE
      PINV   = EC * CHARGE / VECT(7)
      TL = 0.
      H      = STEP
*
*
   20 REST  = STEP-TL
      IF (ABS(H).GT.ABS(REST)) H = REST
      CALL GUFLD(VOUT,F)
*
*             Start of integration
*
      X      = VOUT(1)
      Y      = VOUT(2)
      Z      = VOUT(3)
      A      = VOUT(4)
      B      = VOUT(5)
      C      = VOUT(6)
*
      H2     = HALF * H
      H4     = HALF * H2
      PH     = PINV * H
      PH2    = HALF * PH
      SECXS(1) = (B * F(3) - C * F(2)) * PH2
      SECYS(1) = (C * F(1) - A * F(3)) * PH2
      SECZS(1) = (A * F(2) - B * F(1)) * PH2
      ANG2 = (SECXS(1)**2 + SECYS(1)**2 + SECZS(1)**2)
      IF (ANG2.GT.PISQUA) GO TO 40
      DXT    = H2 * A + H4 * SECXS(1)
      DYT    = H2 * B + H4 * SECYS(1)
      DZT    = H2 * C + H4 * SECZS(1)
      XT     = X + DXT
      YT     = Y + DYT
      ZT     = Z + DZT
*
*              Second intermediate point
*
      EST = ABS(DXT)+ABS(DYT)+ABS(DZT)
      IF (EST.GT.H) GO TO 30

      CALL GUFLD(XYZT,F)
      AT     = A + SECXS(1)
      BT     = B + SECYS(1)
      CT     = C + SECZS(1)
*
      SECXS(2) = (BT * F(3) - CT * F(2)) * PH2
      SECYS(2) = (CT * F(1) - AT * F(3)) * PH2
      SECZS(2) = (AT * F(2) - BT * F(1)) * PH2
      AT     = A + SECXS(2)
      BT     = B + SECYS(2)
      CT     = C + SECZS(2)
      SECXS(3) = (BT * F(3) - CT * F(2)) * PH2
      SECYS(3) = (CT * F(1) - AT * F(3)) * PH2
      SECZS(3) = (AT * F(2) - BT * F(1)) * PH2
      DXT    = H * (A + SECXS(3))
      DYT    = H * (B + SECYS(3))
      DZT    = H * (C + SECZS(3))
      XT     = X + DXT
      YT     = Y + DYT
      ZT     = Z + DZT
      AT     = A + TWO*SECXS(3)
      BT     = B + TWO*SECYS(3)
      CT     = C + TWO*SECZS(3)
*
      EST = ABS(DXT)+ABS(DYT)+ABS(DZT)
      IF (EST.GT.2.*ABS(H)) GO TO 30

      CALL GUFLD(XYZT,F)
*
      Z      = Z + (C + (SECZS(1) + SECZS(2) + SECZS(3)) * THIRD) * H
      Y      = Y + (B + (SECYS(1) + SECYS(2) + SECYS(3)) * THIRD) * H
      X      = X + (A + (SECXS(1) + SECXS(2) + SECXS(3)) * THIRD) * H
*
      SECXS(4) = (BT*F(3) - CT*F(2))* PH2
      SECYS(4) = (CT*F(1) - AT*F(3))* PH2
      SECZS(4) = (AT*F(2) - BT*F(1))* PH2
      A      = A+(SECXS(1)+SECXS(4)+TWO * (SECXS(2)+SECXS(3))) * THIRD
      B      = B+(SECYS(1)+SECYS(4)+TWO * (SECYS(2)+SECYS(3))) * THIRD
      C      = C+(SECZS(1)+SECZS(4)+TWO * (SECZS(2)+SECZS(3))) * THIRD
*
      EST    = ABS(SECXS(1)+SECXS(4) - (SECXS(2)+SECXS(3)))
     ++        ABS(SECYS(1)+SECYS(4) - (SECYS(2)+SECYS(3)))
     ++        ABS(SECZS(1)+SECZS(4) - (SECZS(2)+SECZS(3)))
*
      IF (EST.GT.DLT .AND. ABS(H).GT.1.E-4) GO TO 30
      ITER = ITER + 1
      NCUT = 0
*               If too many iterations, go to HELIX
      IF (ITER.GT.MAXIT) GO TO 40
*
      TL = TL + H
      IF (EST.LT.(DLT32)) THEN
         H = H*TWO
      ENDIF
      CBA    = ONE/ SQRT(A*A + B*B + C*C)
      VOUT(1) = X
      VOUT(2) = Y
      VOUT(3) = Z
      VOUT(4) = CBA*A
      VOUT(5) = CBA*B
      VOUT(6) = CBA*C
      REST = STEP - TL
      IF (STEP.LT.0.) REST = -REST
      IF (REST .GT. 1.E-5*ABS(STEP)) GO TO 20
*
      GO TO 999
*
**              CUT STEP
   30 NCUT = NCUT + 1
*               If too many cuts , go to HELIX
      IF (NCUT.GT.MAXCUT)       GO TO 40
      H = H*HALF
      GO TO 20
*
**              ANGLE TOO BIG, USE HELIX
   40 F1  = F(1)
      F2  = F(2)
      F3  = F(3)
      F4  = SQRT(F1**2+F2**2+F3**2)
      RHO = -F4*PINV
      TET = RHO * STEP
      IF(TET.NE.0.) THEN
         HNORM = ONE/F4
         F1 = F1*HNORM
         F2 = F2*HNORM
         F3 = F3*HNORM
*
         HXP(1) = F2*VECT(IPZ) - F3*VECT(IPY)
         HXP(2) = F3*VECT(IPX) - F1*VECT(IPZ)
         HXP(3) = F1*VECT(IPY) - F2*VECT(IPX)

         HP = F1*VECT(IPX) + F2*VECT(IPY) + F3*VECT(IPZ)
*
         RHO1 = ONE/RHO
         SINT = SIN(TET)
         COST = TWO*SIN(HALF*TET)**2
*
         G1 = SINT*RHO1
         G2 = COST*RHO1
         G3 = (TET-SINT) * HP*RHO1
         G4 = -COST
         G5 = SINT
         G6 = COST * HP

         VOUT(IX) = VECT(IX) + (G1*VECT(IPX) + G2*HXP(1) + G3*F1)
         VOUT(IY) = VECT(IY) + (G1*VECT(IPY) + G2*HXP(2) + G3*F2)
         VOUT(IZ) = VECT(IZ) + (G1*VECT(IPZ) + G2*HXP(3) + G3*F3)

         VOUT(IPX) = VECT(IPX) + (G4*VECT(IPX) + G5*HXP(1) + G6*F1)
         VOUT(IPY) = VECT(IPY) + (G4*VECT(IPY) + G5*HXP(2) + G6*F2)
         VOUT(IPZ) = VECT(IPZ) + (G4*VECT(IPZ) + G5*HXP(3) + G6*F3)
*
      ELSE
         VOUT(IX) = VECT(IX) + STEP*VECT(IPX)
         VOUT(IY) = VECT(IY) + STEP*VECT(IPY)
         VOUT(IZ) = VECT(IZ) + STEP*VECT(IPZ)
*
      ENDIF
*
  999 END
+DECK,  GRNDM, T=FORT.
* Revision 1.2  1998/03/02 15:33:35  japost
*    A significant error on Linux is corrected:
*     Two lines of grndm were not defined for any system that was not listed.
*   In such a system (and Linux was one) the behavior of grndm was incorrect.
*     A default behavior is now defined for all systems. Any system that has
*   a problem with this behavior (using integer division) must be added to
*   the #ifdef together with IBMALL etc.
* Revision 1.1.1.1  1995/10/24 10:21:42  cernlib
* Geant

      SUBROUTINE GRNDM(RVEC,LEN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To generate a vector RVECV of LEN random numbers         *
C.    *         Copy of the CERN Library routine RANECU                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, many GEANT routines                  *
C.    *       Author    F.Carminati *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=CRAY.
CDIR$ STACK
+SELF.
      DIMENSION RVEC(*)
+SELF, IF=CRAY.
      REAL ISEED, ISEED1, ISEED2, K, C1, C2, IZ
+SELF, IF=IBMALL,IBMRT,APO10K,HPUX,MSDOS,WINNT.
      DOUBLE PRECISION ISEED, ISEED1, ISEED2, K, C1, C2, IZ
+SELF, IF=IBMALL,IBMRT,CRAY,APO10K,HPUX,MSDOS,WINNT.
      PARAMETER (C1=1./53668.,C2=1./52774.)
+SELF.
      PARAMETER  (MAXSEQ=215)
      COMMON / GCRNDM / JSEQ(2), ISEED(2,MAXSEQ)
C
      ISEQ   = JSEQ(1)
      ISEED1 = ISEED(1,ISEQ)
      ISEED2 = ISEED(2,ISEQ)
      DO 100 I= 1, LEN
+SELF, IF=IBMALL,IBMRT,CRAY,APO10K,HPUX,MSDOS,WINNT.
        K = INT(ISEED1*C1)
+SELF, IF=-IBMALL, IF=-IBMRT, IF=-CRAY, IF=-APO10K, IF=-HPUX, IF=-MSDOS, IF=-WINNT.
        K = ISEED1/53668
+SELF.
        ISEED1 = 40014*(ISEED1 - K*53668) - K*12211
        IF (ISEED1 .LT. 0) ISEED1=ISEED1+2147483563
C
+SELF, IF=IBMALL,IBMRT,CRAY,APO10K,HPUX,MSDOS,WINNT.
        K = INT(ISEED2*C2)
+SELF, IF=-IBMALL, IF=-IBMRT, IF=-CRAY, IF=-APO10K, IF=-HPUX, IF=-MSDOS, IF=-WINNT.
        K = ISEED2/52774
+SELF.
        ISEED2 = 40692*(ISEED2 - K*52774) - K* 3791
        IF (ISEED2 .LT. 0) ISEED2=ISEED2+2147483399
C
        IZ = ISEED1 - ISEED2
        IF (IZ .LE. 0)  IZ = IZ + 2147483562
C
        RVEC(I) = IZ * 4.6566128E-10
  100 CONTINUE
      ISEED(1,ISEQ) = ISEED1
      ISEED(2,ISEQ) = ISEED2
      END
+DECK,  GRNDMQ, T=FORT.
* Revision 1.3  1999/01/25 14:42:56  japost
*   Undid previous change - the default must be INTEGER for ISEED, not double
* precision (it is a common shared with grndm.F where this is the case).
* Revision 1.1  1995/10/24 10:21:41  cernlib
* Initial revision

      SUBROUTINE GRNDMQ(IS1,IS2,ISEQ,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To set/retrieve the seed of the random number generator  *
C.    *        Copy of the CERN Library routine RECUSQ                 *
C.    *        Each sequence has a period of 10**9 numbers             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, many GEANT routines                  *
C.    *       Author    R.Brun, F.Carminati  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      CHARACTER*(*) CHOPT
      CHARACTER*12  CCHOPT

+SELF, IF=IBMALL,IBMRT,APO10K,HPUX,MSDOS,WINNT.
      DOUBLE PRECISION ISEED
+SELF, IF=-IBMALL, IF=-IBMRT, IF=-APO10K, IF=-HPUX, IF=-MSDOS, IF=-WINNT, IF=CRAY.
      REAL ISEED
+SELF, IF=-IBMALL, IF=-IBMRT, IF=-APO10K, IF=-HPUX, IF=-MSDOS, IF=-WINNT, IF=-CRAY.
      INTEGER  ISEED
+SELF.
      PARAMETER  (MAXSEQ=215)
      COMMON / GCRNDM / JSEQ(2), ISEED(2,MAXSEQ)
      DIMENSION  LSEQS(2,MAXSEQ)
      DATA LSEQS(1,  1),LSEQS(2,  1 )/      9876,     54321/
      DATA LSEQS(1,  2),LSEQS(2,  2 )/1299961164, 253987020/
      DATA LSEQS(1,  3),LSEQS(2,  3 )/ 669708517,2079157264/
      DATA LSEQS(1,  4),LSEQS(2,  4 )/ 190904760, 417696270/
      DATA LSEQS(1,  5),LSEQS(2,  5 )/1289741558,1376336092/
      DATA LSEQS(1,  6),LSEQS(2,  6 )/1803730167, 324952955/
      DATA LSEQS(1,  7),LSEQS(2,  7 )/ 489854550, 582847132/
      DATA LSEQS(1,  8),LSEQS(2,  8 )/1348037628,1661577989/
      DATA LSEQS(1,  9),LSEQS(2,  9 )/ 350557787,1155446919/
      DATA LSEQS(1, 10),LSEQS(2, 10 )/ 591502945, 634133404/
      DATA LSEQS(1, 11),LSEQS(2, 11 )/1901084678, 862916278/
      DATA LSEQS(1, 12),LSEQS(2, 12 )/1988640932,1785523494/
      DATA LSEQS(1, 13),LSEQS(2, 13 )/1873836227, 508007031/
      DATA LSEQS(1, 14),LSEQS(2, 14 )/1146416592, 967585720/
      DATA LSEQS(1, 15),LSEQS(2, 15 )/1837193353,1522927634/
      DATA LSEQS(1, 16),LSEQS(2, 16 )/  38219936, 921609208/
      DATA LSEQS(1, 17),LSEQS(2, 17 )/ 349152748, 112892610/
      DATA LSEQS(1, 18),LSEQS(2, 18 )/ 744459040,1735807920/
      DATA LSEQS(1, 19),LSEQS(2, 19 )/1983990104, 728277902/
      DATA LSEQS(1, 20),LSEQS(2, 20 )/ 309164507,2126677523/
      DATA LSEQS(1, 21),LSEQS(2, 21 )/ 362993787,1897782044/
      DATA LSEQS(1, 22),LSEQS(2, 22 )/ 556776976, 462072869/
      DATA LSEQS(1, 23),LSEQS(2, 23 )/1584900822,2019394912/
      DATA LSEQS(1, 24),LSEQS(2, 24 )/1249892722, 791083656/
      DATA LSEQS(1, 25),LSEQS(2, 25 )/1686600998,1983731097/
      DATA LSEQS(1, 26),LSEQS(2, 26 )/1127381380, 198976625/
      DATA LSEQS(1, 27),LSEQS(2, 27 )/1999420861,1810452455/
      DATA LSEQS(1, 28),LSEQS(2, 28 )/1972906041, 664182577/
      DATA LSEQS(1, 29),LSEQS(2, 29 )/  84636481,1291886301/
      DATA LSEQS(1, 30),LSEQS(2, 30 )/1186362995, 954388413/
      DATA LSEQS(1, 31),LSEQS(2, 31 )/2141621785,  61738584/
      DATA LSEQS(1, 32),LSEQS(2, 32 )/1969581251,1557880415/
      DATA LSEQS(1, 33),LSEQS(2, 33 )/1150606439, 136325185/
      DATA LSEQS(1, 34),LSEQS(2, 34 )/  95187861,1592224108/
      DATA LSEQS(1, 35),LSEQS(2, 35 )/ 940517655,1629971798/
      DATA LSEQS(1, 36),LSEQS(2, 36 )/ 215350428, 922659102/
      DATA LSEQS(1, 37),LSEQS(2, 37 )/ 786161212,1121345074/
      DATA LSEQS(1, 38),LSEQS(2, 38 )/1450830056,1922787776/
      DATA LSEQS(1, 39),LSEQS(2, 39 )/1696578057,2025150487/
      DATA LSEQS(1, 40),LSEQS(2, 40 )/1803414346,1851324780/
      DATA LSEQS(1, 41),LSEQS(2, 41 )/1017898585,1452594263/
      DATA LSEQS(1, 42),LSEQS(2, 42 )/1184497978,  82122239/
      DATA LSEQS(1, 43),LSEQS(2, 43 )/ 633338765,1829684974/
      DATA LSEQS(1, 44),LSEQS(2, 44 )/ 430889421, 230039326/
      DATA LSEQS(1, 45),LSEQS(2, 45 )/ 492544653,  76320266/
      DATA LSEQS(1, 46),LSEQS(2, 46 )/ 389386975,1314148944/
      DATA LSEQS(1, 47),LSEQS(2, 47 )/1720322786, 709120323/
      DATA LSEQS(1, 48),LSEQS(2, 48 )/1868768216,1992898523/
      DATA LSEQS(1, 49),LSEQS(2, 49 )/ 443210610, 811117710/
      DATA LSEQS(1, 50),LSEQS(2, 50 )/1191938868,1548484733/
      DATA LSEQS(1, 51),LSEQS(2, 51 )/ 616890172, 159787986/
      DATA LSEQS(1, 52),LSEQS(2, 52 )/ 935835339,1231440405/
      DATA LSEQS(1, 53),LSEQS(2, 53 )/1058009367,1527613300/
      DATA LSEQS(1, 54),LSEQS(2, 54 )/1463148129,1970575097/
      DATA LSEQS(1, 55),LSEQS(2, 55 )/1795336935, 434768675/
      DATA LSEQS(1, 56),LSEQS(2, 56 )/ 274019517, 605098487/
      DATA LSEQS(1, 57),LSEQS(2, 57 )/ 483689317, 217146977/
      DATA LSEQS(1, 58),LSEQS(2, 58 )/2070804364, 340596558/
      DATA LSEQS(1, 59),LSEQS(2, 59 )/ 930226308,1602100969/
      DATA LSEQS(1, 60),LSEQS(2, 60 )/ 989324440, 801809442/
      DATA LSEQS(1, 61),LSEQS(2, 61 )/ 410606853,1893139948/
      DATA LSEQS(1, 62),LSEQS(2, 62 )/1583588576,1219225407/
      DATA LSEQS(1, 63),LSEQS(2, 63 )/2102034391,1394921405/
      DATA LSEQS(1, 64),LSEQS(2, 64 )/2005037790,2031006861/
      DATA LSEQS(1, 65),LSEQS(2, 65 )/1244218766, 923231061/
      DATA LSEQS(1, 66),LSEQS(2, 66 )/  49312790, 775496649/
      DATA LSEQS(1, 67),LSEQS(2, 67 )/ 721012176, 321339902/
      DATA LSEQS(1, 68),LSEQS(2, 68 )/1719909107,1865748178/
      DATA LSEQS(1, 69),LSEQS(2, 69 )/1156177430,1257110891/
      DATA LSEQS(1, 70),LSEQS(2, 70 )/ 307561322,1918244397/
      DATA LSEQS(1, 71),LSEQS(2, 71 )/ 906041433, 360476981/
      DATA LSEQS(1, 72),LSEQS(2, 72 )/1591375755, 268492659/
      DATA LSEQS(1, 73),LSEQS(2, 73 )/ 461522398, 227343256/
      DATA LSEQS(1, 74),LSEQS(2, 74 )/2145930725,2020665454/
      DATA LSEQS(1, 75),LSEQS(2, 75 )/1938419274,1331283701/
      DATA LSEQS(1, 76),LSEQS(2, 76 )/ 174405412, 524140103/
      DATA LSEQS(1, 77),LSEQS(2, 77 )/ 494343653,  18063908/
      DATA LSEQS(1, 78),LSEQS(2, 78 )/1025534808, 181709577/
      DATA LSEQS(1, 79),LSEQS(2, 79 )/2048959776,1913665637/
      DATA LSEQS(1, 80),LSEQS(2, 80 )/ 950636517, 794796256/
      DATA LSEQS(1, 81),LSEQS(2, 81 )/1828843197,1335757744/
      DATA LSEQS(1, 82),LSEQS(2, 82 )/ 211109723, 983900607/
      DATA LSEQS(1, 83),LSEQS(2, 83 )/ 825474095,1046009991/
      DATA LSEQS(1, 84),LSEQS(2, 84 )/ 374915657, 381856628/
      DATA LSEQS(1, 85),LSEQS(2, 85 )/1241296328, 698149463/
      DATA LSEQS(1, 86),LSEQS(2, 86 )/1260624655,1024538273/
      DATA LSEQS(1, 87),LSEQS(2, 87 )/ 900676210,1628865823/
      DATA LSEQS(1, 88),LSEQS(2, 88 )/ 697951025, 500570753/
      DATA LSEQS(1, 89),LSEQS(2, 89 )/1007920268,1708398558/
      DATA LSEQS(1, 90),LSEQS(2, 90 )/ 264596520, 624727803/
      DATA LSEQS(1, 91),LSEQS(2, 91 )/1977924811, 674673241/
      DATA LSEQS(1, 92),LSEQS(2, 92 )/1440257718, 271184151/
      DATA LSEQS(1, 93),LSEQS(2, 93 )/1928778847, 993535203/
      DATA LSEQS(1, 94),LSEQS(2, 94 )/1307807366,1801502463/
      DATA LSEQS(1, 95),LSEQS(2, 95 )/1498732610, 300876954/
      DATA LSEQS(1, 96),LSEQS(2, 96 )/1617712402,1574250679/
      DATA LSEQS(1, 97),LSEQS(2, 97 )/1261800762,1556667280/
      DATA LSEQS(1, 98),LSEQS(2, 98 )/ 949929273, 560721070/
      DATA LSEQS(1, 99),LSEQS(2, 99 )/1766170474,1953522912/
      DATA LSEQS(1,100),LSEQS(2,100 )/1849939248,  19435166/
      DATA LSEQS(1,101),LSEQS(2,101 )/ 887262858,1219627824/
      DATA LSEQS(1,102),LSEQS(2,102 )/ 483086133, 603728993/
      DATA LSEQS(1,103),LSEQS(2,103 )/1330541052,1582596025/
      DATA LSEQS(1,104),LSEQS(2,104 )/1850591475, 723593133/
      DATA LSEQS(1,105),LSEQS(2,105 )/1431775678,1558439000/
      DATA LSEQS(1,106),LSEQS(2,106 )/ 922493739,1356554404/
      DATA LSEQS(1,107),LSEQS(2,107 )/1058517206, 948567762/
      DATA LSEQS(1,108),LSEQS(2,108 )/ 709067283,1350890215/
      DATA LSEQS(1,109),LSEQS(2,109 )/1044787723,2144304941/
      DATA LSEQS(1,110),LSEQS(2,110 )/ 999707003, 513837520/
      DATA LSEQS(1,111),LSEQS(2,111 )/2140038663,1850568788/
      DATA LSEQS(1,112),LSEQS(2,112 )/1803100150, 127574047/
      DATA LSEQS(1,113),LSEQS(2,113 )/ 867445693,1149173981/
      DATA LSEQS(1,114),LSEQS(2,114 )/ 408583729, 914837991/
      DATA LSEQS(1,115),LSEQS(2,115 )/1166715497, 602315845/
      DATA LSEQS(1,116),LSEQS(2,116 )/ 430738528,1743308384/
      DATA LSEQS(1,117),LSEQS(2,117 )/1388022681,1760110496/
      DATA LSEQS(1,118),LSEQS(2,118 )/1664028066, 654300326/
      DATA LSEQS(1,119),LSEQS(2,119 )/1767741172,1338181197/
      DATA LSEQS(1,120),LSEQS(2,120 )/1625723550,1742482745/
      DATA LSEQS(1,121),LSEQS(2,121 )/ 464486085,1507852127/
      DATA LSEQS(1,122),LSEQS(2,122 )/ 754082421,1187454014/
      DATA LSEQS(1,123),LSEQS(2,123 )/1315342834, 425995190/
      DATA LSEQS(1,124),LSEQS(2,124 )/ 960416608,2004255418/
      DATA LSEQS(1,125),LSEQS(2,125 )/1262630671, 671761697/
      DATA LSEQS(1,126),LSEQS(2,126 )/  59809238, 103525918/
      DATA LSEQS(1,127),LSEQS(2,127 )/1205644919,2107823293/
      DATA LSEQS(1,128),LSEQS(2,128 )/1615183160,1152411412/
      DATA LSEQS(1,129),LSEQS(2,129 )/1024474681,2118672937/
      DATA LSEQS(1,130),LSEQS(2,130 )/1703877649,1235091369/
      DATA LSEQS(1,131),LSEQS(2,131 )/1821417852,1098463802/
      DATA LSEQS(1,132),LSEQS(2,132 )/1738806466,1529062843/
      DATA LSEQS(1,133),LSEQS(2,133 )/ 620780646,1654833544/
      DATA LSEQS(1,134),LSEQS(2,134 )/1070174101, 795158254/
      DATA LSEQS(1,135),LSEQS(2,135 )/ 658537995,1693620426/
      DATA LSEQS(1,136),LSEQS(2,136 )/2055317555, 508053916/
      DATA LSEQS(1,137),LSEQS(2,137 )/1647371686,1282395762/
      DATA LSEQS(1,138),LSEQS(2,138 )/  29067379, 409683067/
      DATA LSEQS(1,139),LSEQS(2,139 )/1763495989,1917939635/
      DATA LSEQS(1,140),LSEQS(2,140 )/1602690753, 810926582/
      DATA LSEQS(1,141),LSEQS(2,141 )/ 885787576, 513818500/
      DATA LSEQS(1,142),LSEQS(2,142 )/1853512561,1195205756/
      DATA LSEQS(1,143),LSEQS(2,143 )/1798585498,1970460256/
      DATA LSEQS(1,144),LSEQS(2,144 )/1819261032,1306536501/
      DATA LSEQS(1,145),LSEQS(2,145 )/1133245275,     37901/
      DATA LSEQS(1,146),LSEQS(2,146 )/ 689459799,1334389069/
      DATA LSEQS(1,147),LSEQS(2,147 )/1730609912,1854586207/
      DATA LSEQS(1,148),LSEQS(2,148 )/1556832175,1228729041/
      DATA LSEQS(1,149),LSEQS(2,149 )/ 251375753, 683687209/
      DATA LSEQS(1,150),LSEQS(2,150 )/2083946182,1763106152/
      DATA LSEQS(1,151),LSEQS(2,151 )/2142981854,1365385561/
      DATA LSEQS(1,152),LSEQS(2,152 )/ 763711891,1735754548/
      DATA LSEQS(1,153),LSEQS(2,153 )/1581256466, 173689858/
      DATA LSEQS(1,154),LSEQS(2,154 )/2121337132,1247108250/
      DATA LSEQS(1,155),LSEQS(2,155 )/1004003636, 891894307/
      DATA LSEQS(1,156),LSEQS(2,156 )/ 569816524, 358675254/
      DATA LSEQS(1,157),LSEQS(2,157 )/ 626626425, 116062841/
      DATA LSEQS(1,158),LSEQS(2,158 )/ 632086003, 861268491/
      DATA LSEQS(1,159),LSEQS(2,159 )/1008211580, 779404957/
      DATA LSEQS(1,160),LSEQS(2,160 )/1134217766,1766838261/
      DATA LSEQS(1,161),LSEQS(2,161 )/1423829292,1706666192/
      DATA LSEQS(1,162),LSEQS(2,162 )/ 942037869,1549358884/
      DATA LSEQS(1,163),LSEQS(2,163 )/1959429535, 480779114/
      DATA LSEQS(1,164),LSEQS(2,164 )/ 778311037,1940360875/
      DATA LSEQS(1,165),LSEQS(2,165 )/1531372185,2009078158/
      DATA LSEQS(1,166),LSEQS(2,166 )/ 241935492,1050047003/
      DATA LSEQS(1,167),LSEQS(2,167 )/ 272453504,1870883868/
      DATA LSEQS(1,168),LSEQS(2,168 )/ 390441332,1057903098/
      DATA LSEQS(1,169),LSEQS(2,169 )/1230238834,1548117688/
      DATA LSEQS(1,170),LSEQS(2,170 )/1242956379,1217296445/
      DATA LSEQS(1,171),LSEQS(2,171 )/ 515648357,1675011378/
      DATA LSEQS(1,172),LSEQS(2,172 )/ 364477932, 355212934/
      DATA LSEQS(1,173),LSEQS(2,173 )/2096008713,1570161804/
      DATA LSEQS(1,174),LSEQS(2,174 )/1409752526, 214033983/
      DATA LSEQS(1,175),LSEQS(2,175 )/1288158292,1760636178/
      DATA LSEQS(1,176),LSEQS(2,176 )/ 407562666,1265144848/
      DATA LSEQS(1,177),LSEQS(2,177 )/1071056491,1582316946/
      DATA LSEQS(1,178),LSEQS(2,178 )/1014143949, 911406955/
      DATA LSEQS(1,179),LSEQS(2,179 )/ 203080461, 809380052/
      DATA LSEQS(1,180),LSEQS(2,180 )/ 125647866,1705464126/
      DATA LSEQS(1,181),LSEQS(2,181 )/2015685843, 599230667/
      DATA LSEQS(1,182),LSEQS(2,182 )/1425476020, 668203729/
      DATA LSEQS(1,183),LSEQS(2,183 )/1673735652, 567931803/
      DATA LSEQS(1,184),LSEQS(2,184 )/1714199325, 181737617/
      DATA LSEQS(1,185),LSEQS(2,185 )/1389137652, 678147926/
      DATA LSEQS(1,186),LSEQS(2,186 )/ 288547803, 435433694/
      DATA LSEQS(1,187),LSEQS(2,187 )/ 200159281, 654399753/
      DATA LSEQS(1,188),LSEQS(2,188 )/1580828223,1298308945/
      DATA LSEQS(1,189),LSEQS(2,189 )/1832286107, 169991953/
      DATA LSEQS(1,190),LSEQS(2,190 )/ 182557704,1046541065/
      DATA LSEQS(1,191),LSEQS(2,191 )/1688025575,1248944426/
      DATA LSEQS(1,192),LSEQS(2,192 )/1508287706,1220577001/
      DATA LSEQS(1,193),LSEQS(2,193 )/  36721212,1377275347/
      DATA LSEQS(1,194),LSEQS(2,194 )/1968679856,1675229747/
      DATA LSEQS(1,195),LSEQS(2,195 )/ 279109231,1835333261/
      DATA LSEQS(1,196),LSEQS(2,196 )/1358617667,1416978076/
      DATA LSEQS(1,197),LSEQS(2,197 )/ 740626186,2103913602/
      DATA LSEQS(1,198),LSEQS(2,198 )/1882655908, 251341858/
      DATA LSEQS(1,199),LSEQS(2,199 )/ 648016670,1459615287/
      DATA LSEQS(1,200),LSEQS(2,200 )/ 780255321, 154906988/
      DATA LSEQS(1,201),LSEQS(2,201 )/ 857296483, 203375965/
      DATA LSEQS(1,202),LSEQS(2,202 )/1631676846, 681204578/
      DATA LSEQS(1,203),LSEQS(2,203 )/1906971307,1623728832/
      DATA LSEQS(1,204),LSEQS(2,204 )/1541899600,1168449797/
      DATA LSEQS(1,205),LSEQS(2,205 )/1267051693,1020078717/
      DATA LSEQS(1,206),LSEQS(2,206 )/1998673940,1298394942/
      DATA LSEQS(1,207),LSEQS(2,207 )/1914117058,1381290704/
      DATA LSEQS(1,208),LSEQS(2,208 )/ 426068513,1381618498/
      DATA LSEQS(1,209),LSEQS(2,209 )/ 139365577,1598767734/
      DATA LSEQS(1,210),LSEQS(2,210 )/2129910384, 952266588/
      DATA LSEQS(1,211),LSEQS(2,211 )/ 661788054,  19661356/
      DATA LSEQS(1,212),LSEQS(2,212 )/1104640222, 240506063/
      DATA LSEQS(1,213),LSEQS(2,213 )/ 356133630,1676634527/
      DATA LSEQS(1,214),LSEQS(2,214 )/ 242242374,1863206182/
      DATA LSEQS(1,215),LSEQS(2,215 )/ 957935844,1490681416/
C
      CCHOPT = CHOPT
      IF(CCHOPT.EQ.' ') THEN
        IF(ISEQ.GT.215.OR.ISEQ.LT.1) THEN
            ISEED(1,1) = LSEQS(1,1)
            ISEED(2,1) = LSEQS(2,1)
            JSEQ(1)    = 1
        ELSE
            ISEED(1,ISEQ) = LSEQS(1,ISEQ)
            ISEED(2,ISEQ) = LSEQS(2,ISEQ)
            JSEQ(1)    = ISEQ
        END IF
        GO TO 999
      END IF
      IF(INDEX(CHOPT,'S').NE.0) THEN
        IF(ISEQ.GT.0) JSEQ(1) = ISEQ
        IF(IS1.GT.0.AND.IS2.GT.0) THEN
          ISEED(1,JSEQ(1)) = IS1
          ISEED(2,JSEQ(1)) = IS2
        END IF
        IF(INDEX(CHOPT,'H').NE.0) THEN
          IQ(JHEAD+3) = IS1
          IQ(JHEAD+4) = IS2
        END IF
      END IF
      IF(INDEX(CHOPT,'G').NE.0) THEN
        IF(ISEQ.LE.0)THEN
           KSEQ = JSEQ(1)
        ELSE
           KSEQ = ISEQ
        ENDIF
        IS1 = ISEED(1,KSEQ)
        IS2 = ISEED(2,KSEQ)
      END IF
      IF(INDEX(CHOPT,'Q').NE.0) THEN
        IF(ISEQ.GE.1.AND.ISEQ.LE.MAXSEQ) THEN
          IS1 = LSEQS(1,ISEQ)
          IS2 = LSEQS(2,ISEQ)
        ELSE
          IS1 = 0
          IS2 = 0
        END IF
      END IF
C
 999  END
+DECK,  GSKING, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:43  cernlib
* Geant

      SUBROUTINE GSKING (IGK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GSKING (IGK)                                          *
C.    *                                                                *
C.    *   Stores in stack JSTAK either the IGKth track of /GCKING/,    *
C.    *    or the NGKINE tracks when IGK is 0.                         *
C.    *                                                                *
C.    *   Called by : 'User'                                           *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCNUM.
+CDE, GCTRAK.
C.
      COMMON/VTXKIN/NVTX,ITR
      REAL PSTO(3), VSTO(3)
C.
C.    ------------------------------------------------------------------
*
      IF (NGKINE.LE.0) GO TO 999
      IF (IGK.EQ.0) THEN
         N1 = 1
         N2 = NGKINE
      ELSE
         IF (IGK.LT.0.OR.IGK.GT.NGKINE) THEN
            WRITE(CHMAIL,10000) IGK, NGKINE
10000 FORMAT(' GSKING - Abnormal request ',I4,1X,I4)
            CALL GMAIL(0,0)
            GO TO 999
         ENDIF
         N1 = IGK
         N2 = IGK
      ENDIF
*
* *** Save original information from /GCKINE/ and /GCTRAK/
*
      IPASTO = IPART
      TOFSTO = TOFG
      DO 10 I = 1,3
         VSTO(I) = VERT(I)
         PSTO(I) = PVERT(I)
   10 CONTINUE
*
* *** Store required tracks in stack JSTAK
*
      IVSTO = 0
      DO 30 N = N1,N2
         IF (IFLGK(N).LT.0) GO TO 30
         TOFG  = TOFSTO +TOFD(N)
         IPART = GKIN(5,N)
         DO 20 I = 1,3
            VERT(I)  = GPOS(I,N)
            PVERT(I) = GKIN(I,N)
   20    CONTINUE
         IF (IFLGK(N).EQ.1) THEN
            IF (IVSTO.EQ.0) THEN
               IVSTO = 1
               IFLAG = 1
            ELSE
               IFLAG = -NVERTX
            ENDIF
         ELSE
            IFLAG = -IFLGK(N)
         ENDIF
         CALL GSSTAK (IFLAG)
         IF (IFLAG.NE.0) THEN
            IFLGK(N) = ITR
            IFLGK(NGKINE+1) = NVTX
         ENDIF
   30 CONTINUE
*
* *** Restore original information in /GCKINE/ and /GCTRAK/
*
      IPART = IPASTO
      TOFG  = TOFSTO
      DO 40 I = 1,3
         VERT(I)  = VSTO(I)
         PVERT(I) = PSTO(I)
   40 CONTINUE
*                                                             END GSKING
  999 END
+DECK,  GSKPHO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:43  cernlib
* Geant

      SUBROUTINE GSKPHO (IGK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *   Stores in stack JSTAK either the IGKth Cherenkov photon of   *
C.    *   /GCKIN2/, or the NPHOT tracks when IGK is 0.                 *
C.    *                                                                *
C.    *   Called by : 'User'                                           *
C.    *   Authors   : F.Carminati                                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCKING.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCTRAK.
+CDE, GCMZFO.
+CDE, GCSTAK.
+CDE, GCKINE.
*
      PARAMETER (NWPOLA=3)
C.
C.    ------------------------------------------------------------------
C.
*
* *** Make sure the request is reasonable
      IF (NGPHOT.LE.0) GO TO 999
      IF (IGK.EQ.0) THEN
         N1 = 1
         N2 = NGPHOT
      ELSE
         IF (IGK.LT.0.OR.IGK.GT.NGPHOT) THEN
            WRITE(CHMAIL,10000) IGK, NGPHOT
10000 FORMAT(' **** GSKPHO: ',I6,'th photon requested, ',
     + I6,' in stack')
            CALL GMAIL(0,0)
            GO TO 999
         ENDIF
         N1 = IGK
         N2 = IGK
      ENDIF
*
* *** Store photons in stack JSTAK
*
* *** Check that the bank is there and big enough
      IF (JSTAK.EQ.0) THEN
         NDBOOK = NTSTKP*NWSTAK +3
         NDPUSH = NTSTKS*NWSTAK
         CALL MZBOOK (IXCONS,JSTAK,JSTAK,1,'STAK', 1,1,NDBOOK, IOSTAK,3)
         IQ(JSTAK+2) = NTSTKP
      ENDIF
      IF(IQ(JSTAK-2).EQ.0) THEN
         CALL MZPUSH(IXCONS,JSTAK,1,0,'I')
      ENDIF
      IF(LQ(JSTAK-1).EQ.0) THEN
         CALL MZBOOK(IXCONS,JPOLAR,JSTAK,-1,'POLA',0,0,
     +               NTSTKP*NWPOLA,3,-1)
      ENDIF
      MISSNG=IQ(JSTAK+1)+N2-N1+1-IQ(JSTAK+2)
      IF (MISSNG.GT.0) THEN
         CALL MZPUSH (IXCONS, JSTAK, 0, MISSNG*NWSTAK+NDPUSH, 'I')
         IQ(JSTAK+2) = IQ(JSTAK+2) +NTSTKS+MISSNG
      ENDIF
      MSSPOL = IQ(JSTAK+1)+N2-N1+1-IQ(JPOLAR-1)/3
      IF(MSSPOL.GT.0) THEN
         CALL MZPUSH (IXCONS,JPOLAR,0,(NTSTKS+MSSPOL)*NWPOLA, 'I')
      ENDIF
*
* *** Now we can go
      DO 20  NN=N1,N2
         JST = JSTAK  +IQ(JSTAK+1)*NWSTAK +3
         JPO = JPOLAR +IQ(JSTAK+1)*NWPOLA
         IQ(JSTAK+1) = IQ(JSTAK+1) +1
         IF (IQ(JSTAK+3).EQ.0) IQ(JSTAK+3) = IQ(JSTAK+1)
         IF (IQ(JSTAK+1).GT.NSTMAX) NSTMAX = IQ(JSTAK+1)
*
         IQ(JST+1) = -ITRA
         IQ(JST+2) = 50
         IQ(JST+3) = 0
         DO 10 I = 1,3
            Q(JST+3+I) = XPHOT(I  ,NN)
            Q(JST+6+I) = XPHOT(I+3,NN)*XPHOT(7,NN)
            Q(JPO+  I) = XPHOT(I+7,NN)
   10    CONTINUE
         Q(JST+10) = XPHOT(11,NN)
         Q(JST+11) = SAFETY
         Q(JST+12) = UPWGHT
*
         NALIVE = NALIVE +1
   20 CONTINUE
*                                                             END GSKPHO
  999 END
+DECK,  GSSTAK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:43  cernlib
* Geant

      SUBROUTINE GSSTAK (IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GSSTAK (IFLAG)                                        *
C.    *                                                                *
C.    *   Stores in auxiliary stack JSTAK the particle currently       *
C.    *    described in common /GCKINE/.                               *
C.    *                                                                *
C.    *   On request, creates also an entry in structure JKINE :       *
C.    *    IFLAG =                                                     *
C.    *     0 : No entry in JKINE structure required (user)            *
C.    *     1 : New entry in JVERTX / JKINE structures required (user) *
C.    *    <0 : New entry in JKINE structure at vertex -IFLAG (user)   *
C.    *     2 : Entry in JKINE structure exists already (from GTREVE)  *
C.    *                                                                *
C.    *   Called by : GSKING, GTREVE                                   *
C.    *   Author    : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCJLOC.
+CDE, GCMZFO.
+CDE, GCNUM.
+CDE, GCSTAK.
+CDE, GCTRAK.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
*
      COMMON/VTXKIN/NVTX,ITR
      DIMENSION UBUF(1)
      DATA UBUF/0./
C.
C.    ------------------------------------------------------------------
*
      IF (IPART.LE.0.OR.IPART.GT.NPART) THEN
         PRINT *, ' GSSTAK - Unknown particle code, skip track ', IPART
         GO TO 999
      ENDIF
*
* *** Give control to user for track selection
*
+SELF, IF=-USRJMP.
      CALL GUSKIP(ISKIP)
+SELF, IF=USRJMP.
      CALL JUMPT1(JUSKIP,ISKIP)
+SELF.
      IF (ISKIP.NE.0) GO TO 999
*
* *** Check if an entry in JKINE structure is required
*
      IF (IFLAG.EQ.1) THEN
         CALL GSVERT (VERT, ITRA, 0, UBUF, 0, NVTX)
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE IF (IFLAG.LT.0) THEN
         NVTX = -IFLAG
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE
         IF (IFLAG.EQ.0) THEN
*          Store -ITRA in stack for a track without entry in JKINE
            ITR = -ITRA
         ELSE
            ITR = ITRA
         ENDIF
      ENDIF
*
* *** Store information in stack
*
      IF (JSTAK.EQ.0) THEN
         NDBOOK = NTSTKP*NWSTAK +3
         NDPUSH = NTSTKS*NWSTAK
         CALL MZBOOK (IXCONS,JSTAK,JSTAK,1,'STAK', 0,0,NDBOOK, IOSTAK,3)
         IQ(JSTAK+2) = NTSTKP
      ELSE IF (IQ(JSTAK+1).EQ.IQ(JSTAK+2)) THEN
         CALL MZPUSH (IXCONS, JSTAK, 0, NDPUSH, 'I')
         IQ(JSTAK+2) = IQ(JSTAK+2) +NTSTKS
      ENDIF
*
      JST = JSTAK +IQ(JSTAK+1)*NWSTAK +3
      IQ(JSTAK+1) = IQ(JSTAK+1) +1
      IF (IQ(JSTAK+3).EQ.0) IQ(JSTAK+3) = IQ(JSTAK+1)
      IF (IQ(JSTAK+1).GT.NSTMAX)  NSTMAX = IQ(JSTAK+1)
*
      IQ(JST+1)   = ITR
      IQ(JST+2)   = IPART
      IQ(JST+3)   = 0
      DO 90 I = 1,3
         Q(JST+3+I) = VERT(I)
         Q(JST+6+I) = PVERT(I)
   90 CONTINUE
      Q(JST+10) = TOFG
      Q(JST+11) = SAFETY
      Q(JST+12) = UPWGHT
*
      NALIVE = NALIVE +1
*                                                             END GSSTAK
  999 END
+DECK,  GSTORD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:43  cernlib
* Geant

      SUBROUTINE GSTORD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Orders the particles in the stack in ascending order by      *
C.    *   the user word.                                               *
C.    *                                                                *
C.    *   Called by : GLTRAC                                           *
C.    *   Authors   : F.Carminati                                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCSTAK.
+CDE, GCTRAK.
+CDE, GCNUM.
      PARAMETER (NWPOLA=3,ISTPOS=12)
*
* ----------------------------------------------------------------------
*
      JSTPOS = JSTAK+3+ISTPOS
      VALMAX = Q(JSTPOS)
      INDMAX = 1
      NPSTAK = IQ(JSTAK+1)
      DO 10 J=2,IQ(JSTAK+1)
         JSTPOS = JSTPOS+NWSTAK
         VALTST = Q(JSTPOS)
         IF(VALTST.GT.VALMAX) THEN
            VALMAX = VALTST
            INDMAX = J
         ENDIF
   10 CONTINUE
      IF(INDMAX.NE.NPSTAK) THEN
         JSMOVE = JSTAK+3+(INDMAX-1)*NWSTAK
         JSLAST = JSTAK+3+(NPSTAK-1)*NWSTAK
         DO 20 J=1,NWSTAK
            TEMP = Q(JSMOVE+J)
            Q(JSMOVE+J) = Q(JSLAST+J)
            Q(JSLAST+J) = TEMP
   20    CONTINUE
         IF(JPOLAR.NE.0) THEN
            JPMOVE = JPOLAR+(INDMAX-1)*NWPOLA
            JPLAST = JPOLAR+(NPSTAK-1)*NWPOLA
            DO 30 J=1,NWPOLA
               TEMP = Q(JPMOVE+J)
               Q(JPMOVE+J) = Q(JPLAST+J)
               Q(JPLAST+J) = TEMP
   30       CONTINUE
        ENDIF
      ENDIF
      END
+DECK,  GSTRAC, T=FORT.
* Revision 1.2  1996/02/27 10:30:56  ravndal
* Correct interaction length for heavy ions
* Revision 1.1.1.1  1995/10/24 10:21:43  cernlib
* Geant

      SUBROUTINE GSTRAC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       SUBR. GSTRAC                                             *
C.    *                                                                *
C.    *  Stores in stack JTRACK the information for current track      *
C.    *   segment at exit of current Volume/Medium.                    *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCVOLU.
      REAL      XC(3)
C.
C.    ------------------------------------------------------------------
*
* *** Find where in the tracking skeleton to enter the current track
*
      IF (NLEVIN.EQ.NLEVEL) THEN
*       (case when GINVOL has not been called)
         JVO = LQ(JVOLUM-LVOLUM(NLEVIN))
         IF (INGOTO.GT.0) THEN
*
*  **      Point is in content predicted by GTNEXT, go one level down
*
            NLEVIN = NLEVIN +1
            INFROM = 0
            JIN    = LQ(JVO-INGOTO)
            IVOT   = Q(JIN+2)
            LVOLUM(NLEVIN) = IVOT
            LINDEX(NLEVIN) = INGOTO
            LINMX (NLEVIN) = Q(JVO+3)
*
*  **      Prepare the translation and rotation matrices if necessary
*
            JSKL = LQ(JSKLT-NLEVIN)
            IF (NLEVIN.GT.2) THEN
               IOFF = IQ(JSKL-3)
               DO 29 ILEV = 1, NLEVEL
                  IF (IQ(JSKL+IOFF+ILEV).NE.LINDEX(ILEV)) GO TO 30
   29          CONTINUE
            ENDIF
            JSK  = LQ(JSKL-INGOTO)
            IF (IQ(JSK+1).GT.0) GO TO 100
   30       IROTT = Q(JIN+4)
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            GO TO 100
         ELSE
*
*  **      otherwise, go one level up
*
            NLEVIN = NLEVIN -1
*
         ENDIF
*
      ELSE IF (NLEVIN.GT.NLEVEL) THEN
         INFROM = 0
         GO TO 100
*
      ELSE IF (NLEVIN.LT.0) THEN
*       (case when entering a dominant overlaping volume)
         NLEVIN = -NLEVIN
         INFROM = LINDEX(NLEVIN+1)
         GO TO 100
      ENDIF
*
*  **  Track has left current volume, check levels up
*
   80 IF (NLEVIN.EQ.0) GO TO 999
*
      IF (GRMAT(10,NLEVIN).EQ.0.) THEN
         DO 88 I = 1,3
            XC(I) = VECT(I) -GTRAN(I,NLEVIN)
   88    CONTINUE
      ELSE
C       (later, code in line)
         CALL GTRNSF (VECT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN), XC)
      ENDIF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVIN))
      JPAR = LQ(JGPAR-NLEVIN)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.NE.0) THEN
         INFROM = LINDEX(NLEVIN+1)
      ELSE
         NLEVIN = NLEVIN -1
         GO TO 80
      ENDIF
*
* *** Allocate last 'garbaged' area if any, otherwise first 'free' one
*
  100 IF (NJGARB.NE.0) THEN
         NCUR   = NJGARB
         LCUR   = JTRACK +(NCUR-1)*NWTRAC
         NJGARB = IQ(LCUR+1)
      ELSE
         NCUR   = NJFREE
         LCUR   = JTRACK +(NCUR-1)*NWTRAC
         NJFREE = NCUR +1
      ENDIF
*
* *** Link allocated area to relevant chain in JSKLT structure
*
      JSKL = LQ(JSKLT-NLEVIN)
      IQ(LCUR+1) = IQ(JSKL+LINDEX(NLEVIN))
      IQ(JSKL+LINDEX(NLEVIN)) = NCUR
*
* *** Store information for current track segment in stack JTRACK
*
      IQ(LCUR+2) = 0
      IQ(LCUR+3) = NTMULT
      IQ(LCUR+4) = ITRA
      IQ(LCUR+5) = ISTAK
      IQ(LCUR+6) = IPART
      IQ(LCUR+7) = NSTEP
*free IQ(LCUR+8) = IDECAD
      IQ(LCUR+9) = IEKBIN
      IQ(LCUR+10)= ISTORY
      IQ(LCUR+11)= INFROM
*
      IPCUR = LCUR +NWINT
      DO 109 I = 1,7
         Q(IPCUR+I)  = VECT(I)
  109 CONTINUE
      Q(IPCUR+8)  = GEKIN
      Q(IPCUR+9)  = SLENG
      Q(IPCUR+10) = GEKRAT
      Q(IPCUR+11) = TOFG
      Q(IPCUR+12) = UPWGHT
*
      IPCUR = IPCUR +NWREAL
      IF (ITRTYP.EQ.1) THEN
*     Photons
         Q(IPCUR+1) = ZINTPA
         Q(IPCUR+2) = ZINTCO
         Q(IPCUR+3) = ZINTPH
         Q(IPCUR+4) = ZINTPF
         Q(IPCUR+5) = ZINTRA
      ELSE IF (ITRTYP.EQ.2) THEN
*     Electrons
         Q(IPCUR+1) = ZINTBR
         Q(IPCUR+2) = ZINTDR
         Q(IPCUR+3) = ZINTAN
      ELSE IF (ITRTYP.EQ.3) THEN
*     Neutral hadrons
         Q(IPCUR+1) = SUMLIF
         Q(IPCUR+2) = ZINTHA
      ELSE IF (ITRTYP.EQ.4) THEN
*     Charged hadrons
         Q(IPCUR+1) = SUMLIF
         Q(IPCUR+2) = ZINTHA
         Q(IPCUR+3) = ZINTDR
      ELSE IF (ITRTYP.EQ.5) THEN
*     Muons
         Q(IPCUR+1) = SUMLIF
         Q(IPCUR+2) = ZINTBR
         Q(IPCUR+3) = ZINTPA
         Q(IPCUR+4) = ZINTDR
         Q(IPCUR+5) = ZINTMU
      ELSE IF (ITRTYP.EQ.7) THEN
*     Cerenkov photons
         Q(IPCUR+1) = ZINTLA
      ELSE IF (ITRTYP.EQ.8) THEN
*     Ions
         Q(IPCUR+1) = ZINTHA
         Q(IPCUR+2) = ZINTDR
      ENDIF
*
* *** Take care of the skeleton
*
      IF (NLEVIN.GT.NLDOWN) THEN
         NLDOWN = NLEVIN
         JSKL   = LQ(JSKLT-NLDOWN)
*
*  **    Clear skeleton at lowest level if necessary
*
         JOFF   = JSKL + IQ(JSKL-3)
         DO 229 ILEV = 1, NLDOWN-1
            IF (IQ(JOFF+ILEV).EQ.LINDEX(ILEV)) GO TO 229
            NINSK = LINMX(NLDOWN)
            DO 209 IN = 1, NINSK
               JSK  = LQ(JSKL-IN)
               IQ(JSK+1) = 0
  209       CONTINUE
            DO 219 I = ILEV, NLDOWN-1
               IQ(JOFF+I) = LINDEX(I)
  219       CONTINUE
            GO TO 230
  229    CONTINUE
      ENDIF
*
*  ** Fill up the skeleton at NLDOWN
*
  230 IF (NLEVIN.GT.NLEVEL) THEN
         JSKL = LQ(JSKLT-NLDOWN)
         JSK  = LQ(JSKL-LINDEX(NLDOWN))
         IF (IQ(JSK+1).LE.0) THEN
            LQ(JSK-1) = LQ(JGPAR-NLDOWN)
            IQ(JSK+1) = IQ(JGPAR+NLDOWN)
            IQ(JSK+2) = LVOLUM(NLDOWN)
            DO 239 I = 1, 3
               Q(JSK+2+I) = GTRAN(I,NLDOWN)
  239       CONTINUE
            DO 249 I = 1, 10
               Q(JSK+5+I) = GRMAT(I,NLDOWN)
  249       CONTINUE
         ENDIF
*
      ENDIF
*
* *** Update NALIVE and test if tracking stack is full
*
      NALIVE = NALIVE + 1
      IF (NALIVE-IQ(JSTAK+1).GE.NJTMAX) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         NJTMAX = -NJTMAX
         NLVSAV = NLEVEL
         DO 309 I = 2,NLDOWN
            LINSAV(I) = LINDEX(I)
            LMXSAV(I) = LINMX(I)
  309    CONTINUE
      ENDIF
*
 1001 FORMAT (' GSTRAC : Stack JTRACK full. Inhibit parallel tracking')
*                                                             END GSTRAC
  999 END

+DECK,  GSXYZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:43  cernlib
* Geant

      SUBROUTINE GSXYZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store space point VECT in banks JXYZ                     *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    R.Brun, F.Carena  *********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCTRAK.
+CDE, GCPUSH.
+CDE, GCKINE.
C.
C.    ------------------------------------------------------------------
C.
      IF(JXYZ.EQ.0)THEN
C
C               Create mother bank JXYZ
C
         CALL MZBOOK(IXDIV,JXYZ,JXYZ,1,'JXYZ',NCKINE,NCKINE,0,3,0)
         IQ(JXYZ-5)=0
      ENDIF
C
      NXYZ=IQ(JXYZ-2)
      IF(ITRA.GT.NXYZ)THEN
         NPUSH=MAX(10,ITRA-NXYZ)
         CALL MZPUSH(IXDIV,JXYZ,NPUSH,0,'I')
      ENDIF
C
C              Create bank to store points for primary track ITRA
C
      JX=LQ(JXYZ-ITRA)
      IF(JX.EQ.0)THEN
         CALL MZBOOK(IXDIV,JX,JXYZ,-ITRA,'JXYZ',0,0,NCJXYZ,3,0)
         Q(JX+1)=NCJXYZ-2.
         Q(JX+2)=3.
         IQ(JX)=NTMULT
C
C              Check if there is enough space to store current point
C
      ELSE
         NFREE=Q(JX+1)
         IF(NFREE.LE.6)THEN
            CALL MZPUSH(IXDIV,JX,0,NPJXYZ,'I')
            JX=LQ(JXYZ-ITRA)
            Q(JX+1)=Q(JX+1)+NPJXYZ
         ENDIF
C
         IF(NTMULT.NE.IQ(JX))THEN
            IQ(JX)=NTMULT
            IPOINT=JX+Q(JX+2)
            IF(Q(IPOINT).NE.0.) THEN
               Q(JX+2)=Q(JX+2)+3.*Q(IPOINT)+2.
               Q(JX+1)=Q(JX+1)-2.
            ENDIF
         ENDIF
      ENDIF
C
      IPOINT=JX+Q(JX+2)
      JP=IPOINT+3.*Q(IPOINT)+1.
      Q(IPOINT)=Q(IPOINT)+1.
      Q(IPOINT+1)=IPART
      DO 10 I=1,3
  10  Q(JP+I)=VECT(I)
      Q(JX+1)=Q(JX+1)-3.
C
      END
+DECK,  GTCKOV, T=FORT.
*PATCH,GEXAM1.
*CMZ :  3.21/02 29/03/94  15.41.35  by  S.Giani
*DECK, GTCKOV
*CMZ :          12/09/95  11.07.14  by  S.Ravndal
*CMZ :  3.21/04 13/12/94  15.17.13  by  S.Giani
*-- Author :
      SUBROUTINE GTCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine is called to follow the Cherenkov photons       *
C.    *   created during the tracking of charged particles and         *
C.    *   simulate the relevant processes along the way, until either  *
C.    *   the photon is absorbed or exits the detector. Processes      *
C.    *   currently simulated are absorption in-flight, and reflection *
C.    *   /transmission/absorption at a medium boundary. There are two *
C.    *   boundary types: dielectric-metal and dielectric-dielectric.  *
C.    *   For each of these there is a continuum of reflectivity       *
C.    *   and of surface quality from mirror finish to matte. The      *
C.    *   surface model is contained in routine GHSURF.                *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors    F.Carminati, R.Jones ************              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCNUM.
+CDE, GCVOL1.
+CDE, GCUNIT.

+SELF, IF=-OLD.
+CDE, GCVDMA.
+SELF.

*
* ** The following common is in GTMEDI. LSAMVL is set to true if
* ** we did not change volume yet
*
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      DIMENSION R(3),D(3),U(3),QQ(3),vin(3)
      DIMENSION VBOU(3)
      LOGICAL LOLDTR
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (MXPUSH=10)
      SAVE RIN1,EFFIC
C.
C.    ------------------------------------------------------------------
*
* *** Update local pointers if medium has changed
*
      LOLDTR=.FALSE.
      IF(IUPD.EQ.0)THEN
         IUPD  = 1
         JTCKOV = LQ(JTM-3)
         IF(JTCKOV.EQ.0) THEN
*
* *** This Cerenkov photon has crossed into a black medium.
* *** Just absorb it.
            IPROC = 101
            STEP  = 0.
            SLABS = 0.
            ISTOP = 2
            DESTEP = 0.
            GOTO 110
         ENDIF
         NPCKOV = Q(JTCKOV+1)
         JABSCO = LQ(JTCKOV-1)
         JEFFIC = LQ(JTCKOV-2)
         JINDEX = LQ(JTCKOV-3)
         JPOLAR = LQ(JSTAK-1)
      ENDIF
      IF(SLENG.LE.0.) THEN
*
* *** Calculate GEKRAT for the particle
         IF(VECT(7).GE.Q(JTCKOV+NPCKOV+1)) THEN
            GEKRAT=1.
            IEKBIN=NPCKOV-1
         ELSEIF(VECT(7).LT.Q(JTCKOV+2)) THEN
*
* *** Particle below energy threshold ?  Short circuit
* *** This should never happen because the photons are generated
* *** only above threshold
*
*            GEKIN = 0.
*            GETOT = 0.
*            VECT(7)= 0.
*            ISTOP = 2
*            NMEC = 1
*            LMEC(1)= 30
*            GO TO 110

            GEKRAT=0.
            IEKBIN=1
         ELSE
            JMIN = 1
            JMAX = NPCKOV
   10       JMED = (JMIN+JMAX)/2
            IF(Q(JTCKOV+JMED+1).LT.VECT(7)) THEN
               JMIN = JMED
            ELSE
               JMAX = JMED
            ENDIF
            IF(JMAX-JMIN.GT.1) GO TO 10
            IEKBIN = JMIN
            GEKRAT = (VECT(7) - Q(JTCKOV+IEKBIN+1))/
     +      (Q(JTCKOV+IEKBIN+2)-Q(JTCKOV+IEKBIN+1))
         ENDIF
         GEKRT1=1.-GEKRAT
         RIN1=Q(JINDEX+IEKBIN)*GEKRT1+Q(JINDEX+IEKBIN+1)*GEKRAT
         EFFIC=Q(JEFFIC+IEKBIN)*GEKRT1+Q(JEFFIC+IEKBIN+1)*GEKRAT
         STEPLA=Q(JABSCO+IEKBIN)*GEKRT1+Q(JABSCO+IEKBIN+1)*GEKRAT
      ENDIF
*
* *** Compute current step size
*
      IPROC  = 103
      STEP   = STEMAX
*
*  **   Step limitation due to in flight absorbtion ?
*
      IF (ILABS.GT.0) THEN
         SLABS  = STEPLA*ZINTLA
         IF (SLABS.LT.STEP) THEN
            STEP  = SLABS
            IPROC = 101
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      STEPT=0.
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
*
* **    We are going to cross a boundary, so we need to simulate
* **    boundary effects and to know what is on the other side.
* **    For the moment save the current vector in the geometry tree.
*
+SELF, IF=-OLD.
         if(mycoun.gt.1.and.nfmany.gt.0)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF.
            NLEVL1 = NLEVEL
            DO 20   I=1,NLEVEL
               NAMES1(I) = NAMES(I)
               NUMBR1(I) = NUMBER(I)
               LVOLU1(I) = LVOLUM(I)
   20       CONTINUE
*
* *** This is different from the other tracking routines.
* *** We get to the boundary and then we just jump over it
* *** So, linear transport till we are very near the boundary
*
+SELF, IF=-IBM.
            STEP = MAX(SNEXT-PREC,0.)
+SELF, IF=IBM.
            STEP = MAX(SNEXT-2.*PREC,0.)
+SELF.
C
C In case of Cherenkovs beeing near a corner, particle holding is
C prevented by a bigger step size. The value of VBOU is only used to
C calculate the correct surface normal (by GLISUR and GGPERP). The
C tracking of the Cherenkov is still using STEP
C
            IF(SNEXT.GT.0.) THEN
               DO 25 I=1,3
                  VBOU(I)=VECT(I)+SNEXT*VECT(I+3)
   25          CONTINUE
            END IF
C
            IF(STEP.GT.0.) THEN
               DO 30 I=1,3
                  VECT(I)=VECT(I)+STEP*VECT(I+3)
   30          CONTINUE
            ENDIF
            STEPT=STEP
+SELF, IF=-IBM.
            STEP  = SNEXT - STEP + PREC
+SELF, IF=IBM.
            STEP  = SNEXT - STEP + 2.*PREC
+SELF.
            IPROC = 0
            INWVOL= 2
            NMEC =  1
            LMEC(1)=1
         ENDIF
*
*        Update SAFETY in stack companions, if any
*        This may well not work.
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 40 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   40       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      VIN(1) = VECT(1)
      VIN(2) = VECT(2)
      VIN(3) = VECT(3)
      IF (INWVOL.EQ.2) THEN
         NBPUSH = 0
   50    DO 60 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTCKOV: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
               ENDIF
            ENDIF
            VOUT(I) = VECTMP
   60    CONTINUE
         NUMED1=NUMED
         CALL GTMEDI(VOUT,NUMED2)
         LOLDTR=.TRUE.
         IF(NUMED2.LE.0) THEN
            VECT(1) = VOUT(1)
            VECT(2) = VOUT(2)
            VECT(3) = VOUT(3)
            GO TO 110
         ENDIF
         JVO=LQ(JVOLUM-LVOLUM(NLEVEL))
         IF(LSAMVL.AND.Q(JVO+2).NE.12.) THEN
*
* *** In spite of our efforts we have not crossed the boundary
* *** we increase the step size and try again
*
            NBPUSH = NBPUSH + 1
            IF (NBPUSH.LE.MXPUSH) THEN
              STEP = STEP + NBPUSH*PREC
              GOTO 50
            ELSE
              INWVOL = 0
            ENDIF

         ENDIF
         IF(NUMED1.EQ.NUMED2) THEN
*
* *** If we are in the same medium, nothing needs to be done!
*
            VECT(1)=VOUT(1)
            VECT(2)=VOUT(2)
            VECT(3)=VOUT(3)
            IPROC=0
         ELSE
            JTM2 = LQ(JTMED-NUMED2)
            IF(IQ(JTM2-2).GE.3) THEN
               JTCKV2 = LQ(JTM2-3)
            ELSE
               JTCKV2 = 0
            ENDIF
            IF(JTCKV2.GT.0) THEN
               NPCKV2 = Q(JTCKV2+1)
               JABSC2 = LQ(JTCKV2-1)
               JEFFI2 = LQ(JTCKV2-2)
               JINDX2 = LQ(JTCKV2-3)
               IF(VECT(7).GE.Q(JTCKV2+NPCKV2+1)) THEN
                  GEKRT2=1.
                  IEKBI2=NPCKV2-1
               ELSEIF(VECT(7).LT.Q(JTCKV2+2)) THEN
                  GEKRT2=0.
                  IEKBI2=1
               ELSE
                  JMIN = 1
                  JMAX = NPCKV2
   64             JMED = (JMIN+JMAX)/2
                  IF(Q(JTCKV2+JMED+1).LT.VECT(7)) THEN
                     JMIN = JMED
                  ELSE
                     JMAX = JMED
                  ENDIF
                  IF(JMAX-JMIN.GT.1) GO TO 64
                  IEKBI2 = JMIN
                  GEKRT2 = (VECT(7) - Q(JTCKV2+IEKBI2+1))/
     +            (Q(JTCKV2+IEKBI2+2)-Q(JTCKV2+IEKBI2+1))
               ENDIF
               GEKRT1=1.-GEKRT2
               ABSCO2=Q(JABSC2+IEKBI2)*GEKRT1+Q(JABSC2+IEKBI2+1)*GEKRT2
               EFFIC2=Q(JEFFI2+IEKBI2)*GEKRT1+Q(JEFFI2+IEKBI2+1)*GEKRT2
               IF(JINDX2.GT.0) THEN
                 RIN2=Q(JINDX2+IEKBI2)*GEKRT1+Q(JINDX2+IEKBI2+1)*GEKRT2
               ELSE
                 RIN2=0.
               ENDIF
               IPROC = 102
            ELSE
               ISTOP=2
               DESTEP=0
               NMEC = NMEC+1
               LMEC(NMEC)=30
               VECT(1)=VOUT(1)
               VECT(2)=VOUT(2)
               VECT(3)=VOUT(3)
               GOTO 110
            ENDIF
         ENDIF
      ELSE
         DO 70 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   70    CONTINUE
      ENDIF
*
      STEP = STEPT + STEP
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      TOFG = TOFG +STEP*RIN1/CLIGHT
*
* *** Update interaction probabilities
*
      IF (ILABS.GT.0)    ZINTLA = ZINTLA -STEP/STEPLA
*
      IF (IPROC.EQ.0) GO TO 110
      NMEC = NMEC+1
      LMEC(NMEC) = IPROC
*
*  ** Absorbtion in flight ?
*
      IF (IPROC.EQ.101) THEN
         ISTOP=2
         CALL GRNDM(RNDM,1)
         IF(RNDM.LT.EFFIC) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
            DESTEP=VECT(7)
         ELSE
            DESTEP=0.
         ENDIF
*
*  ** Boundary action?
*
      ELSE IF (IPROC.EQ.102) THEN
         IF(JINDX2.EQ.0) THEN
*
* *** Case dielectric -> metal
*
            CALL GRNDM(RNDM,1)
            IF(RNDM.LT.ABSCO2) THEN
*
* *** Photon is absorbed in the next medium
*
               NMEC=NMEC+1
               LMEC(NMEC)=101
               ISTOP = 2
               CALL GRNDM(RNDM,1)
               IF(RNDM.LT.EFFIC2) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
                  DESTEP=VECT(7)
               ELSE
                  DESTEP = 0.
               END IF
               VECT(1) = VOUT(1)
               VECT(2) = VOUT(2)
               VECT(3) = VOUT(3)
               GOTO 110
            ELSE
*
* *** Photon is reflected (no polarization effects)
*
               CALL GLISUR(VECT,VBOU,NUMED1,NUMED2,U,PDOTU,IERR)
               IF (IERR.NE.0) THEN
                  WRITE(CHMAIL,10200) IERR
                  CALL GMAIL(0,0)
                  GO TO 110
               END IF
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   80          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 80
                  ENDIF
               ENDIF
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
               EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL  = 0
            ENDIF
         ELSE
*
*  case dielectric-dielectric:
*
            CALL GLISUR(VECT,VBOU,NUMED1,NUMED2,U,PDOTU,IERR)
            IF (IERR.NE.0) THEN
               WRITE(CHMAIL,10200) IERR
               CALL GMAIL(0,0)
               GO TO 110
            END IF
            EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
            COST1 = -PDOTU
            IF (ABS(COST1).LT.1.) THEN
               SINT1 = SQRT((1-COST1)*(1+COST1))
               SINT2 = SINT1*RIN1/RIN2
            ELSE
               SINT1 = 0.0
               SINT2 = 0.0
            END IF
            IF (SINT2.GE.1) THEN
*
* ***  Simulate total internal reflection
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   90          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 90
                  ENDIF
               ENDIF
*
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL = 0
            ELSE
*
* ***  Calculate amplitude for transmission (Q = P x U)
*
               COST2 = SIGN(1.0,COST1)*SQRT((1-SINT2)*(1+SINT2))
               IF (SINT1.GT.1.E-4) THEN
                  QQ(1) = VECT(5)*U(3) - VECT(6)*U(2)
                  QQ(2) = VECT(6)*U(1) - VECT(4)*U(3)
                  QQ(3) = VECT(4)*U(2) - VECT(5)*U(1)
                  EPERP1 = (POLAR(1)*QQ(1) + POLAR(2)*QQ(2) + POLAR(3)*
     +            QQ(3))
                  ENORM  = SQRT(EPERP1**2+EDOTU**2)
                  EPERP1 = EPERP1/ENORM
                  EPARL1 = EDOTU/ENORM
               ELSE
                  QQ(1) = POLAR(1)
                  QQ(2) = POLAR(2)
                  QQ(3) = POLAR(3)
*
*     Here we follow Jackson's conventions and we set the parallel
*     component = 1 in case of a ray perpendicular to the surface
                  EPERP1 = 0.
                  EPARL1 = 1.
               END IF
               IF(COST1.NE.0.) THEN
                  S1 = RIN1*COST1
                  EPERP2 = 2*S1*EPERP1/(RIN1*COST1+RIN2*COST2)
                  EPARL2 = 2*S1*EPARL1/(RIN2*COST1+RIN1*COST2)
                  E2 = EPERP2**2 + EPARL2**2
                  S2 = RIN2*COST2*E2
                  TCOEF = S2/S1
               ELSE
                  TCOEF = 0.
               ENDIF
               CALL GRNDM(RNDM,1)
               IF (RNDM.GT.TCOEF) THEN
*
* *** Simulate reflection
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=106
*
* *** Restore old volume tree, the photon does not cross the boundary
*
*                 CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
                  CALL GTMEDI(VIN,N)
                  LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
                  NBPUSH = 0
  100             NBPUSH = NBPUSH+1
                  IF(NBPUSH.GT.MXPUSH) THEN
                     WRITE(CHMAIL,10300) NTMULT,NSTEP
                     CALL GMAIL(0,0)
                     ISTOP=1
                     GOTO 110
                  ELSE
                     CALL GINVOL(VECT,ISAME)
                     IF(ISAME.EQ.0) THEN
                        PRECN = NBPUSH*PREC
                        VECT(1) = VECT(1) - PRECN*VECT(4)
                        VECT(2) = VECT(2) - PRECN*VECT(5)
                        VECT(3) = VECT(3) - PRECN*VECT(6)
                        GO TO 100
                     ENDIF
                  ENDIF
*
                  VECT(4) = VECT(4) - 2*PDOTU*U(1)
                  VECT(5) = VECT(5) - 2*PDOTU*U(2)
                  VECT(6) = VECT(6) - 2*PDOTU*U(3)
                  IF(SINT1.GT.1E-4) THEN
                     EPARL2 = RIN2*EPARL2/RIN1-EPARL1
                     EPERP2 = EPERP2-EPERP1
                     E2 = EPERP2**2 + EPARL2**2
                     R(1) = U(1) + PDOTU*VECT(4)
                     R(2) = U(2) + PDOTU*VECT(5)
                     R(3) = U(3) + PDOTU*VECT(6)
                     EABS = SQRT(E2)*SINT1
                     CPARL = EPARL2/EABS
                     CPERP = EPERP2/EABS
                     POLAR(1) = CPARL*R(1) - CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) - CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) - CPERP*QQ(3)
                  ELSEIF(RIN2.GT.RIN1) THEN
*
* *** Case of ray perpendicular to the surface. No change or
* *** an inversion of phase.
                     POLAR(1) = -POLAR(1)
                     POLAR(2) = -POLAR(2)
                     POLAR(3) = -POLAR(3)
                  ENDIF
                  INWVOL = 0
               ELSE
*
* *** Simulate transmission/refraction
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=107
                  VECT(1) = VOUT(1)
                  VECT(2) = VOUT(2)
                  VECT(3) = VOUT(3)
                  IF(SINT1.GT.1E-4) THEN
                     ALPHA = COST1-COST2*(RIN2/RIN1)
                     D(1) = VECT(4) + ALPHA*U(1)
                     D(2) = VECT(5) + ALPHA*U(2)
                     D(3) = VECT(6) + ALPHA*U(3)
                     DABS = SQRT(D(1)**2+D(2)**2+D(3)**2)
                     VECT(4) = D(1)/DABS
                     VECT(5) = D(2)/DABS
                     VECT(6) = D(3)/DABS
                     PDOTU = -COST2
                     R(1) = U(1) - PDOTU*VECT(4)
                     R(2) = U(2) - PDOTU*VECT(5)
                     R(3) = U(3) - PDOTU*VECT(6)
                     EABS = SQRT(E2)
                     CPARL = EPARL2/(EABS*SINT2)
                     CPERP = EPERP2/(EABS*SINT1)
                     POLAR(1) = CPARL*R(1) + CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) + CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) + CPERP*QQ(3)
                  ENDIF
                  GEKRAT = GEKRT2
                  IEKBIN = IEKBI2
                  STEPLA = ABSCO2
                  EFFIC = EFFIC2
                  RIN1 = RIN2
               END IF
            END IF
         END IF
      ENDIF
*                                                             END GTCKOV
  110 IF(LOLDTR) CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
10200  FORMAT(' **** GTCKOV: error from GLISUR = ',I10)
10300  FORMAT(' **** GTCKOV: unable to reflect at NTMULT = ',
     +        I8,' step No. ',I8,' photon abandoned!')
      END
+DECK,  GTELEC, T=FORT.

      SUBROUTINE GTELEC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Electron type track. Computes step size and propagates       *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   ==> Called by : GTRACK                                       *
C.    *       Authors    R.Brun, F.Bruyant, M.Maire L.Urban ********   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCMATE.
+CDE, GCMULO.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCKING.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.

+SELF, IF=-OLD.
+CDE, GCVOLU.
+CDE, GCVDMA.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION DEMEAN,STOPRG,STOPMX,STOPC
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,ZERO
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (ONE=1,ZERO=0.)
      REAL VNEXT(6)
      SAVE IKCUT,STOPC
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      DIMENSION RNDM(3)
      PARAMETER ( TLIM = 0.0002)
      IABAN = NINT(DPHYS1)
*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTELE) GO TO 100
*
* *** Update local pointers if medium or particle code has changed
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JMULOF= LQ(JTM-1)
         IF (CHARGE.LT.0.) THEN
            JBREM = LQ(JMA-9)
            JLOSS = LQ(JMA-1)
            JDRAY = LQ(JMA-11)
            JRANG = LQ(JMA-15)
            JCOEF = LQ(JMA-17)
         ELSE
            JBREM = LQ(JMA-9)  +NEK1
            JLOSS = LQ(JMA-1)  +NEK1
            JDRAY = LQ(JMA-11) +NEK1
            JRANG = LQ(JMA-15) +NEK1
            JCOEF = LQ(JMA-17) +3*NEK1
            JANNI = LQ(JMA-7)
         ENDIF
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
         OMCMOL = Q(JPROB+21)
         CHCMOL = Q(JPROB+25)
         IKCUT  = Q(JMULOF+NEK1+1)
         STOPC  = Q(JMULOF+NEK1+2)
         IF(ISTRA.GT.0) THEN
            JTSTRA = LQ(JMA-19)
            JTSTCO = LQ(JTSTRA-1)
            JTSTEN = LQ(JTSTRA-2)
+SELF, IF=ASHO.
            IF(ISTRA.EQ.2) THEN
               JTASHO = LQ(JMA-20)
            ENDIF
+SELF.
         ENDIF
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
*
*  **   Step limitation due to bremsstrahlung ?
*
      IF (IBREM.GT.0) THEN
         STEPBR = GEKRT1*Q(JBREM+IEKBIN) +GEKRAT*Q(JBREM+IEKBIN+1)
         SBREM  = STEPBR*ZINTBR
         IF (SBREM.LT.STEP) THEN
            STEP  = SBREM
            IPROC = 9
         ENDIF
      ENDIF
*
*  **   Step limitation due to delta-ray production ?
*
      IF (IDRAY.GT.0) THEN
         STEPDR = GEKRT1*Q(JDRAY+IEKBIN) +GEKRAT*Q(JDRAY+IEKBIN+1)
         SDRAY  = STEPDR*ZINTDR
         IF (SDRAY.LT.STEP) THEN
            STEP  = SDRAY
            IPROC = 10
         ENDIF
      ENDIF
*
*  **   Step limitation due to annihilation ?
*
      IF (CHARGE.GT.0.) THEN
         IF (IANNI.GT.0) THEN
            STEPAN = GEKRT1*Q(JANNI+IEKBIN) +GEKRAT*Q(JANNI+IEKBIN+1)
            SANNI  = STEPAN*ZINTAN
            IF (SANNI.LT.STEP) THEN
               STEP  = SANNI
               IPROC = 11
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP = 0.
         GO TO 90
      ENDIF
*
*  **   Step limitation due to energy-loss,multiple scattering
*             or magnetic field ?
*
      IF (JMULOF.NE.0) THEN
         SMULOF  = GEKRT1*Q(JMULOF+IEKBIN) +GEKRAT*Q(JMULOF+IEKBIN+1)
         IF (SMULOF.LT.STEP) THEN
            STEP  = SMULOF
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
* *** Linear transport when no field or very short step
*
         IF (IGNEXT.NE.0) THEN
*
* *** Particle is supposed to cross the boundary during step
*
            DO 20 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTELEC: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   20       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 30 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30       CONTINUE
         ENDIF
      ELSE
*
* *** otherwise, swim particle in magnetic field
*
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP.
   40    CALL GUSWIM (CHARGE, STEP, VECT, VOUT)
+SELF, IF=USRJMP.
   40    CALL JUMPT4(JUSWIM,CHARGE, STEP, VECT, VOUT)
+SELF.
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 50 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   50          CONTINUE
               DO I=1,3
                 IF ((VOUT(I)-VNEXT(I)).GT.EPSIL) GOTO 60
               ENDDO
               INWVOL = 2
               NMEC = NMEC +1
               LMEC(NMEC) = 1
               GOTO 70
   60          CONTINUE
               INEAR = 1
            ENDIF
+SELF, IF=-OLD.
            if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
              nlevel=manyle(nfmany)
              do 99 i=1,nlevel
                names(i)=manyna(nfmany,i)
                number(i)=manynu(nfmany,i)
 99           continue
              call glvolu(nlevel,names,number,ier)
              if(ier.ne.0)print *,'Fatal error in GLVOLU'
              ingoto=0
            endif
+SELF.
*
            CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0) THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 40
               ENDIF
            ENDIF
         ENDIF
*
*
   70    CONTINUE
         DO 80 I = 1,6
            VECT(I) = VOUT(I)
   80    CONTINUE
*
      ENDIF
*
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
*  **  Apply synchrotron radiation if required
*
      IF(ISYNC*IFIELD.NE.0) THEN
         CALL GSYNC
         NMEC = NMEC+1
         LMEC(NMEC) = 108
      ENDIF
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         IF(NGPHOT.NE.0) THEN
            NMEC = NMEC+1
            LMEC(NMEC)=105
         ENDIF
      ENDIF
*
* *** Apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         IF(GEKRAT.LT.0.7) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0.) THEN
            STOPMX = -XCOEF2+SIGN(ONE,XCOEF1)*SQRT(XCOEF2**2 - (XCOEF3-
     +      GEKIN/XCOEF1))
         ELSE
            STOPMX = - (XCOEF3-GEKIN)/XCOEF2
         ENDIF
*
         STOPRG = STOPMX - STEP
         IF (STOPRG.LT.STOPC) THEN
            STEP = MAX(STOPMX - STOPC,ZERO)
            GO TO 100
         ENDIF
*
         LMEC(NMEC) = 3
         IF(XCOEF1.NE.0.) THEN
            DEMEAN=GEKIN-XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            DEMEAN=GEKIN-XCOEF2*STOPRG-XCOEF3
         ENDIF
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +     *STEP
         ENDIF
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
            DEMS = DEMEAN
            CALL GFLUCT (DEMS,DESTEP)
         ENDIF
         DESTEP=MAX(DESTEP,0.)
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTELE)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
*
*        IABAN = 1 does not distinguish between sensitive and
*        non-sensitive volumes, and can stop particles above the CUTE
*
         IF(IABAN.EQ.1) THEN
*
*        STOP electron/positron if range < safety AND no brems
*
           IF(STOPMX.LE.SAFETY) THEN
             IF(SBREM.GT.STOPMX) THEN
*          + condition in case of Cherenkov generation:
*          STOP if E/p >refractive index (i.e. e+/e- is below threshold)
               IF(IMCKOV.EQ.1) THEN
                 THRIND=GETOT/VECT(7)
*****            IF(THRIND.GT.Q(JINDEX+1)) GOTO 100
                 IF(THRIND.GT.Q(JINDEX+1)) GOTO 98
               ELSE
                 GOTO 98
               ENDIF
             ENDIF
           ENDIF
           STOPRG = STOPMX - STEP
           IF (STOPRG.LT.STOPC) THEN
            STEP = MAX(STOPMX - STOPC,ZERO)
            GO TO 98
           ENDIF
         END IF
*
*        IABAN = 2 distinguishes between sensitive and non-sensitive
*        volumes.
*        In sensitive volumes additional tests are applied before
*        the particle is stopped
*
         IF(IABAN.EQ.2) THEN
           IF(ISVOL.LE.0) THEN
             IF(STOPMX.LE.SAFETY) THEN
*
*        test for brems and annihilation only
*
               IF((IBREM.GT.0).AND.(SBREM.LE.STOPMX)) GOTO 97
               IF((CHARGE.GT.0.).AND.(IANNI.GT.0).and.
     +                                 (SANNI.LE.STOPMX)) GOTO 97
               GOTO 98
             END IF
           ELSE
*
*        sensitive volume ---> more tests !!
*        is energy below TLIM (=200 keV ) ?
*
             IF(GEKIN.LE.TLIM) THEN
*
*     range of the particle is the overestimated stopping range here
*
                TOSTOP=STOPMX-STEP*DESTEP/DEMEAN-STOPC
*
*        does the track remain in the actual volume?
*
                IF(TOSTOP.LE.SAFETY) THEN
*
*        is there no delta ray, brems, annihilation ?
*
                  IF((IDRAY.GT.0).AND.(SDRAY.LE.TOSTOP)) GOTO 97
                  IF((IBREM.GT.0).AND.(SBREM.LE.TOSTOP)) GOTO 97
                  IF((CHARGE.GT.0.).AND.(IANNI.GT.0).and.
     +                                   (SANNI.LE.TOSTOP)) GOTO 97
*
*        extra condition in case of Cherenkov generation:
*
                  IF(IMCKOV.EQ.1) THEN
                     THRIND=GETOT/VECT(7)
*
*        continue only if e+/e- below threshold
*
                     IF(THRIND.LT.Q(JINDEX+1)) GOTO 97
                   ELSE
*
*        do not make transport if this estimated range negative...
*
                     IF(TOSTOP.LE.0.) GOTO 98
*
*        estimate final position/direction of the particle
*        from energy loss + multiple scattering
*       ( multiple scattering with path length = range of the particle)
*
                     ALFA=0.18*Z
                     ALFA1=ALFA+1.
                     TGTH2=ALFA*ALFA1/(1.2+ALFA)
                     S=TOSTOP*SQRT(1.+TGTH2)/ALFA1
                     TGTH=SQRT(TGTH2)
                     THET=ATAN(TGTH)
                     IF(THET.Lt.0.) THET=PI-THET
*
*        correct direction
*
                     CT=COS(THET)
                     ST=SQRT(1.-CT*CT)
                     CALL GRNDM(RNDM,1)
                     PHI=TWOPI*RNDM(1)
*
                     D1=ST*COS(PHI)
                     D2=ST*SIN(PHI)
                     D3=CT
                     VMM=SQRT(VECT(4)*VECT(4)+VECT(5)*VECT(5))
                     IF(VMM.NE.0.) THEN
                       PD1=VECT(4)/VMM
                       PD2=VECT(5)/VMM
                       V4=PD1*VECT(6)*D1-PD2*D2+VECT(4)*D3
                       V5=PD2*VECT(6)*D1+PD1*D2+VECT(5)*D3
                       V6=-VMM*D1+VECT(6)*D3
                     ELSE
                       V4=D1
                       V5=D2
                       V6=D3
                     ENDIF
                     VP=1./SQRT(V4*V4+V5*V5+V6*V6)
                     VECT(4)=V4*VP
                     VECT(5)=V5*VP
                     VECT(6)=V6*VP
*
*       transport particle ( assuming FIELD = 0. )
*
                     DO 123 I=1,3
                     VECT(I)=VECT(I)+S*VECT(I+3)
123                  CONTINUE
*
*       put back into GEKIN the original value in order to have
*       a correct DESTEP
*
                  GOTO 98
                END IF
              END IF
            END IF
*++++++++++++++++++++++++++++++++++++++++++++++++++++++
          END IF
97        CONTINUE
        ENDIF
      ENDIF
*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 2
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      TOFG = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IBREM.GT.0)    ZINTBR = ZINTBR -STEP/STEPBR
      IF (IDRAY.GT.0)    ZINTDR = ZINTDR -STEP/STEPDR
      IF (CHARGE.GT.0.) THEN
         IF (IANNI.GT.0) ZINTAN = ZINTAN -STEP/STEPAN
      ENDIF
*
* *** Apply the selected process if any
*
   90 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Bremsstrahlung ?
*
      IF (IPROC.EQ.9) THEN
         CALL GBREME
*
*  **   Delta ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
*
       IF((IPART.EQ.2).OR.((IPART.EQ.3).AND.(GEKIN.GT.2.*DCUTE))) THEN
         CALL GDRAY
       ELSE
         GOTO 98
       ENDIF
*
*  **   Positron annihilation ?
*
      ELSE IF (IPROC.EQ.11) THEN
         CALL GANNI

      ENDIF
      GO TO 999
*
* *** Special treatment for overstopped tracks
*
  98  GEKIN=GEKIN+DESTEP
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      NMEC   = NMEC +1
      LMEC(NMEC) = 30
      IF ((CHARGE.LT.0.).OR.(IANNI.EQ.0)) THEN
         ISTOP = 2
      ELSE
         NMEC = NMEC +1
         LMEC(NMEC) = 11
         CALL GANNIR
      ENDIF
  999 IF(NGPHOT.GT.0) THEN
         IF(ITCKOV.EQ.2.AND.ISTOP.EQ.0) THEN
*
*  The electron has produced Cerenkov photons and it is still alive
*  we put it in the stack and we let the photons to be tracked
            NGKINE = NGKINE+1
            GKIN(1,NGKINE) = VECT(4)*VECT(7)
            GKIN(2,NGKINE) = VECT(5)*VECT(7)
            GKIN(3,NGKINE) = VECT(6)*VECT(7)
            GKIN(4,NGKINE) = GETOT
            GKIN(5,NGKINE) = IPART
            TOFD(NGKINE) = 0.
            ISTOP = 1
c----put position as well
            GPOS(1,NGKINE)=VECT(1)
            GPOS(2,NGKINE)=VECT(2)
            GPOS(3,NGKINE)=VECT(3)
         ENDIF
      ENDIF
      END

+DECK,  GTGAMA, T=FORT.

      SUBROUTINE GTGAMA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Photon track. Computes step size and propagates particle     *
C.    *    through step.                                               *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors    R.Brun, F.Bruyant L.Urban ********             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCMULO.
+CDE, GCTRAK.
+SELF, IF=DEBUG.
+CDE, GCUNIT.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,ZERO
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (ONE=1,ZERO=0)
      PARAMETER (EPCUT=1.022E-3)
*
      IABAN = NINT(DPHYS1)
*
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ?  Short circuit
*
*
      IF (GEKIN.LE.CUTGAM) GOTO 998
*
* *** Update local pointers if medium has changed
*
      IF(IUPD.EQ.0)THEN
         IUPD  = 1
         JPHOT = LQ(JMA-6)
         JCOMP = LQ(JMA-8)
         JPAIR = LQ(JMA-10)
         JPFIS = LQ(JMA-12)
         JRAYL = LQ(JMA-13)
      ENDIF
*
* *** Compute current step size
*
      IPROC  = 103
      STEP   = STEMAX
      GEKRT1 = 1 .-GEKRAT
*
*  **   Step limitation due to pair production ?
*
      IF (GETOT.GT.EPCUT) THEN
         IF (IPAIR.GT.0) THEN
            STEPPA = GEKRT1*Q(JPAIR+IEKBIN) +GEKRAT*Q(JPAIR+IEKBIN+1)
            SPAIR  = STEPPA*ZINTPA
            IF (SPAIR.LT.STEP) THEN
               STEP  = SPAIR
               IPROC = 6
            ENDIF
         ENDIF
      ENDIF
*
*  **   Step limitation due to Compton scattering ?
*
      IF (ICOMP.GT.0) THEN
         STEPCO = GEKRT1*Q(JCOMP+IEKBIN) +GEKRAT*Q(JCOMP+IEKBIN+1)
         SCOMP  = STEPCO*ZINTCO
         IF (SCOMP.LT.STEP) THEN
            STEP  = SCOMP
            IPROC = 7
         ENDIF
      ENDIF
*
*  **   Step limitation due to photo-electric effect ?
*
      IF (GEKIN.LT.0.4) THEN
         IF (IPHOT.GT.0) THEN
            STEPPH = GEKRT1*Q(JPHOT+IEKBIN) +GEKRAT*Q(JPHOT+IEKBIN+1)
            SPHOT  = STEPPH*ZINTPH
            IF (SPHOT.LT.STEP) THEN
               STEP  = SPHOT
               IPROC = 8
            ENDIF
         ENDIF
      ENDIF
*
*  **   Step limitation due to photo-fission ?
*
      IF (JPFIS.GT.0) THEN
         STEPPF = GEKRT1*Q(JPFIS+IEKBIN) +GEKRAT*Q(JPFIS+IEKBIN+1)
         SPFIS  = STEPPF*ZINTPF
         IF (SPFIS.LT.STEP) THEN
            STEP  = SPFIS
            IPROC = 23
         ENDIF
      ENDIF
*
*  **   Step limitation due to Rayleigh scattering ?
*
      IF (IRAYL.GT.0) THEN
         IF (GEKIN.LT.0.01) THEN
            STEPRA = GEKRT1*Q(JRAYL+IEKBIN) +GEKRAT*Q(JRAYL+IEKBIN+1)
            SRAYL  = STEPRA*ZINTRA
            IF (SRAYL.LT.STEP) THEN
               STEP  = SRAYL
               IPROC = 25
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            INWVOL= 2
            IPROC = 0
            NMEC =  1
            LMEC(1)=1
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      IF (INWVOL.EQ.2) THEN
         DO 20 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTGAMA: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
               ENDIF
            ENDIF
            VECT(I) = VECTMP
   20    CONTINUE
      ELSE
         DO 30 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30    CONTINUE
      ENDIF
*
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      TOFG = TOFG +STEP/CLIGHT
*
* *** Update interaction probabilities
*
      IF (GETOT.GT.EPCUT) THEN
         IF (IPAIR.GT.0) ZINTPA = ZINTPA -STEP/STEPPA
      ENDIF
      IF (ICOMP.GT.0)    ZINTCO = ZINTCO -STEP/STEPCO
      IF (GEKIN.LT.0.4) THEN
         IF (IPHOT.GT.0) ZINTPH = ZINTPH -STEP/STEPPH
      ENDIF
      IF (JPFIS.GT.0)    ZINTPF = ZINTPF -STEP/STEPPF
      IF (IRAYL.GT.0) THEN
         IF (GEKIN.LT.0.01) ZINTRA = ZINTRA -STEP/STEPRA
      ENDIF
*
      IF (IPROC.EQ.0) GO TO 999
      NMEC = 1
      LMEC(1) = IPROC
*
*  ** Pair production ?
*
      IF (IPROC.EQ.6) THEN
         CALL GPAIRG
*
*  ** Compton scattering ?
*
      ELSE IF (IPROC.EQ.7) THEN
         CALL GCOMP
*
*  ** Photo-electric effect ?
*
      ELSE IF (IPROC.EQ.8) THEN
*
*
*        IABAN > 0  can stop particles above the CUTE
*
       IF(IABAN.GT.0) THEN
*
*        STOP gamma IF estimated_range(photoelectron) < safety
*
*
*       Calculate range of the photoelectron ( with kin. energy Ephot)
*
        IF(GEKIN.LE.0.001)  THEN
            JCOEF = LQ(JMA-17)
         IF(GEKRAT.LT.0.7) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0.) THEN
            STOPMX = -XCOEF2+SIGN(ONE,XCOEF1)*SQRT(XCOEF2**2 - (XCOEF3-
     +      GEKIN/XCOEF1))
         ELSE
            STOPMX = - (XCOEF3-GEKIN)/XCOEF2
         ENDIF
*
*        DO NOT call GPHOT if this (overestimated) range is smaller
*                than SAFETY
*
         IF (STOPMX.LE.SAFETY) GOTO 998
        ENDIF
*
       ENDIF

         CALL GPHOT
*
*  ** Rayleigh effect ?
*
      ELSE IF (IPROC.EQ.25) THEN
         CALL GRAYL
*
*  ** Photo-fission ?
*
      ELSE IF (IPROC.EQ.23) THEN
         CALL GPFIS
*
      ENDIF
*
         GOTO 999
998      DESTEP = GEKIN
         GEKIN  = 0.
         GETOT  = 0.
         VECT(7)= 0.
         ISTOP  = 2
         NMEC   = 1
         LMEC(1)= 30
  999 END
+DECK,  GTHADR, T=FORT.

      SUBROUTINE GTHADR
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Charged hadron type track. Computes step size and propagates *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *       Authors    R.Brun, F.Bruyant, M.Maire ********           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCMULO.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.

+SELF, IF=-OLD.
+CDE, GCVOLU.
+CDE, GCVDMA.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION GKR,DEMEAN,STOPP,STOPMX,STOPRG,STOPC,EKIPR
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,YCOEF1,YCOEF2,YCOEF3
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (THRESH=0.7,ONE=1)
      REAL VNEXT(6)
      SAVE CFLD,CHARG2,RMASS,CUTPRO,IKCUT,STOPC
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTHAD) GO TO 100
*
* *** Update local pointers if medium has changed
*
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JLOSS = LQ(JMA-3)
         JRANG = LQ(JMA-16) + NEK1
         JCOEF = LQ(JMA-18) + 3*NEK1
         CHARG2 = CHARGE*CHARGE
         RMASS  = PMASS/AMASS
         OMCMOL = Q(JPROB+21)*CHARG2
         CHCMOL = Q(JPROB+25)*ABS(CHARGE)
         CUTPRO = MAX(CUTHAD*RMASS,ELOW(1))
         IKCUT = GEKA*LOG10(CUTPRO) + GEKB
         GKR   = (CUTPRO - ELOW(IKCUT))/(ELOW(IKCUT+1) - ELOW(IKCUT))
         STOPC = (1.-GKR)*Q(JRANG+IKCUT) + GKR*Q(JRANG+IKCUT+1)
         IF (FIELDM.NE.0.) THEN
            CFLD = 3333.*DEGRAD*TMAXFD/ABS(FIELDM*CHARGE)
         ELSE
            CFLD = BIG
         ENDIF
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
         IF(ISTRA.GT.0) THEN
            JTSTRA = LQ(JMA-19)
            JTSTCO = LQ(JTSTRA-1)
            JTSTEN = LQ(JTSTRA-2)
+SELF, IF=ASHO.
            IF(ISTRA.EQ.2) THEN
               JTASHO = LQ(JMA-20)
            ENDIF
+SELF.
         ENDIF
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
*
*  **   Step limitation due to hadron interaction ?
*
      IF (IHADR.GT.0) THEN
+SELF, IF=-USRJMP.
         CALL GUPHAD
+SELF, IF=USRJMP.
         CALL JUMPT0(JUPHAD)
+SELF.
         IF (SHADR.LT.STEP) THEN
            IF (SHADR.LE.0.) SHADR = PREC
            STEP  = SHADR
            IPROC = 12
         ENDIF
      ENDIF
*
*  **   Step limitation due to decay ?
*
      IF (IDCAY.GT.0) THEN
         SDCAY = SUMLIF*VECT(7)/AMASS
         IF (SDCAY.LT.STEP) THEN
            STEP  = SDCAY
            IPROC = 5
         ENDIF
      ENDIF
*
*  ** Step limitation due to delta-ray production ?
*       (Cannot be tabulated easily because dependent on AMASS)
*
      IF (IDRAY.GT.0) THEN
         STEPDR = BIG
         IF (GEKIN.GT.DCUTM) THEN
            GAMASS = GETOT +AMASS
            TMAX   = EMASS*GEKIN*GAMASS/(0.5*AMASS*AMASS+EMASS*GETOT)
            IF (TMAX.GT.DCUTM) THEN
               BET2 = GEKIN*GAMASS/(GETOT*GETOT)
               Y    = DCUTM/TMAX
               SIG  = (1.-Y+BET2*Y*LOG(Y))/DCUTM
*              extra term for spin 1/2
               IF (AMASS.GT.0.9) SIG=SIG+0.5*(TMAX-DCUTM)/(GETOT*GETOT)
               SIG = SIG*Q(JPROB+17)*CHARG2*EMASS/BET2
*
               IF (SIG.GT.0.) THEN
                  STEPDR = 1./SIG
                  SDRAY  = STEPDR*ZINTDR
                  IF (SDRAY.LE.STEP) THEN
                     STEP  = SDRAY
                     IPROC = 10
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP  = 0.
         GO TO 110
      ENDIF
*
*  **   Step limitation due to energy loss (stopping range) ?
*
      IF (ILOSL.GT.0) THEN
         IF(GEKRAT.LT.THRESH) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0) THEN
            STOPP = -XCOEF2+SIGN(ONE,XCOEF1)* SQRT(XCOEF2
     +      **2 -(XCOEF3-GEKIN*RMASS/XCOEF1))
         ELSE
            STOPP = - (XCOEF3-GEKIN*RMASS)/XCOEF2
         ENDIF
         STOPMX = (STOPP - STOPC)/(RMASS*CHARG2)
         IF (STOPMX.LT.MIN(STEP,STMIN)) THEN
            STEP = STOPMX
            IPROC = 0
            IF(STEP.LE.0.)THEN
               GO TO 100
            ENDIF
            GO TO 10
         ENDIF
         EKF = (1. - DEEMAX)*GEKIN*RMASS
         IF (EKF.LT.ELOW(1)) THEN
            EKF = ELOW(1)
         ELSEIF (EKF.GE.ELOW(NEK1)) THEN
            EKF = ELOW(NEK1)*0.99
         ENDIF
         IKF=GEKA*LOG10(EKF)+GEKB
         GKR=(EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
         IF(GKR.LT.THRESH) THEN
            IK1 = MAX(IKF-1,1)
         ELSE
            IK1 = MIN(IKF,NEKBIN-1)
         ENDIF
         IK1 = 3*(IK1-1)+1
         YCOEF1=Q(JCOEF+IK1)
         YCOEF2=Q(JCOEF+IK1+1)
         YCOEF3=Q(JCOEF+IK1+2)
         IF(YCOEF1.NE.0.) THEN
            SLOSP = -YCOEF2+SIGN(ONE,YCOEF1)*SQRT(YCOEF2**2- (YCOEF3-
     +      EKF/YCOEF1))
         ELSE
            SLOSP = - (YCOEF3-EKF)/YCOEF2
         ENDIF
         SLOSP = STOPP - SLOSP
         SLOSS = MAX(STMIN, SLOSP/(RMASS*CHARG2) )
         IF (SLOSS.LT.STEP) THEN
            STEP = SLOSS
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to bending in magnetic field ?
*
      IF (IFIELD.NE.0) THEN
         SFIELD = CFLD*VECT(7)
         SFIELD=MAX(SFIELD, STMIN)
         IF (SFIELD.LT.STEP) THEN
            STEP  = SFIELD
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to multiple scattering ?
*
      IF (IMULL.GT.0) THEN
         SMULS=MIN(2232.*RADL*((VECT(7)**2)/(GETOT*CHARGE))**2,10.*RADL)
         SMULS  = MAX(STMIN, SMULS )
         IF (SMULS.LT.STEP) THEN
            STEP  = SMULS
            IPROC = 0
         ENDIF
      ENDIF
*
   10 CONTINUE
*
*  **   Step limitation due to Cerenkov production ?
*
      IF (IMCKOV.GT.0) THEN
         CALL GNCKOV
         STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         SMULS  = MAX(STMIN, STCKOV)
         IF (SMULS.LT.STEP) THEN
            STEP  = STCKOV
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 20 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   20       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport when no field or very short step
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
         IF (IGNEXT.NE.0) THEN
            DO 30 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTHADR: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   30       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 40 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   40       CONTINUE
         ENDIF
      ELSE
*
* ***   otherwise, swim particle in magnetic field
*
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP.
   50    CALL GUSWIM (CHARGE, STEP, VECT, VOUT)
+SELF, IF=USRJMP.
   50    CALL JUMPT4(JUSWIM, CHARGE, STEP, VECT, VOUT)
+SELF.
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 60 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   60          CONTINUE
               DO I=1,3
                 IF ((VOUT(I)-VNEXT(I)).GT.EPSIL) GOTO 70
               ENDDO
               INWVOL = 2
               NMEC = NMEC +1
               LMEC(NMEC) = 1
               GOTO 80
   70          CONTINUE
               INEAR = 1
            ENDIF
*
+SELF, IF=-OLD.
            if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
              nlevel=manyle(nfmany)
              do 99 i=1,nlevel
                names(i)=manyna(nfmany,i)
                number(i)=manynu(nfmany,i)
 99           continue
              call glvolu(nlevel,names,number,ier)
              if(ier.ne.0)print *,'Fatal error in GLVOLU'
              ingoto=0
            endif
+SELF.
            CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0)THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 50
               ENDIF
            ENDIF
         ENDIF
*
   80    CONTINUE
         DO 90 I = 1,6
            VECT(I) = VOUT(I)
   90    CONTINUE
*
      ENDIF
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*CHARG2*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         IF(NGPHOT.NE.0) THEN
            NMEC=NMEC+1
            LMEC(NMEC)=105
         ENDIF
      ENDIF
*
* *** apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 3
         STOPRG = STOPP - STEP*RMASS*CHARG2
         IF (STOPRG.LE.STOPC) THEN
            STEP = STOPMX
            GO TO 100
         ENDIF
         IF(XCOEF1.NE.0.) THEN
            EKIPR = XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            EKIPR = XCOEF2*STOPRG+XCOEF3
         ENDIF
         DEMEAN=GEKIN - EKIPR/RMASS
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +      *STEP*CHARG2
         ENDIF
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
            DEMS   = DEMEAN/CHARG2
            CALL GFLUCT(DEMS,DESTEP)
            DESTEP = DESTEP*CHARG2
         ENDIF
         DESTEP=MAX(DESTEP,0.)
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTHAD)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
      ENDIF
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 2
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG   = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IHADR.GT.0) ZINTHA = ZINTHA*(1.-STEP/SHADR)
      IF (IDRAY.GT.0) ZINTDR = ZINTDR -STEP/STEPDR
*
      GO TO 110
*
*  **   Special treatment for overstopped tracks
*
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GAMMA  = GETOT/AMASS
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      ISTOP  = 2
      NMEC = NMEC + 1
      LMEC(NMEC) = 30
      IF (IHADR.EQ.0) THEN
         IF (IDCAY.NE.0) THEN
            TOFG = TOFG +0.5*(1+GAMMA)*SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               ISTOP = 4
               NMEC = NMEC + 1
               LMEC(NMEC) = 22
               NGKINE = 0
            ELSE
               NMEC = NMEC + 1
               LMEC(NMEC) = 5
               ISTOP =1
               CALL GDECAY
            ENDIF
         ENDIF
         GO TO 999
      ENDIF
      IPROC = 12
*
* *** apply slected process if any
*
  110 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Hadron interaction ?
*
      IF (IPROC.EQ.12) THEN
+SELF, IF=-USRJMP.
         CALL GUHADR
+SELF, IF=USRJMP.
         CALL JUMPT0(JUHADR)
+SELF.
*   *   Check time cut-off for decays at rest
         IF (LMEC(NMEC).EQ.5) THEN
            TOFG   = TOFG +SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               NGKINE = 0
               ISTOP  = 4
               LMEC(NMEC) = 22
            ENDIF
         ENDIF
*
*  **   Decay ?
*
      ELSE IF (IPROC.EQ.5) THEN
         ISTOP = 1
         CALL GDECAY
*
*  **   Delta-ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
         CALL GDRAY
      ENDIF
  999 IF(NGPHOT.GT.0) THEN
         IF(ITCKOV.EQ.2.AND.ISTOP.EQ.0) THEN
*
*  The hadron has produced Cerenkov photons and it is still alive
*  we put it in the stack and we let the photons to be tracked
            NGKINE = NGKINE+1
            GKIN(1,NGKINE) = VECT(4)*VECT(7)
            GKIN(2,NGKINE) = VECT(5)*VECT(7)
            GKIN(3,NGKINE) = VECT(6)*VECT(7)
            GKIN(4,NGKINE) = GETOT
            GKIN(5,NGKINE) = IPART
            TOFD(NGKINE) = 0.
            ISTOP = 1
c----put position as well
            GPOS(1,NGKINE)=VECT(1)
            GPOS(2,NGKINE)=VECT(2)
            GPOS(3,NGKINE)=VECT(3)
         ENDIF
      ENDIF
      END
+DECK,  GTHION, T=FORT.

      SUBROUTINE GTHION
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Heavy  ion  type track. Computes step size and propagates    *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   The ionisation energy loss is calculated here (mean +        *
C.    *       fluctuations)                                            *
C.    *   The fluctuations are the same for ILOSS=1,2,3 and            *
C.    *       there is no fluctuation for ILOSS=4.                     *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *       Authors    R.Brun, F.Bruyant, M.Maire, L.Urban ***       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCMULO.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.

+SELF, IF=-OLD.
+CDE, GCVOLU.
+CDE, GCVDMA.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION GKR,DEMEAN,STOPP,STOPMX,STOPRG,STOPC,EKIPR
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3,YCOEF1,YCOEF2,YCOEF3
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (THRESH=0.7,ONE=1)
      PARAMETER (TWOTHR=2*ONE/3,AMU=0.9314943)
      PARAMETER (DME=7.84572E-8,CNORM=2.5)
      REAL VNEXT(6)
      DIMENSION RNDM(2)
      SAVE RMASS,CUTPRO,IKCUT,STOPC,FACFLU,CHAR23
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTHAD) GO TO 100
*
* *** Update local pointers if medium has changed
*
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JLOSS = LQ(JMA-3)
         JRANG = LQ(JMA-16) + NEK1
         JCOEF = LQ(JMA-18) + 3*NEK1
         RMASS  = PMASS/AMASS
         CUTPRO = MAX(CUTHAD*RMASS,ELOW(1))
         IKCUT = GEKA*LOG10(CUTPRO) + GEKB
         GKR   = (CUTPRO - ELOW(IKCUT))/(ELOW(IKCUT+1) - ELOW(IKCUT))
         STOPC = (1.-GKR)*Q(JRANG+IKCUT) + GKR*Q(JRANG+IKCUT+1)
         FACFLU = DME*(Z*DENS/A)
         CHAR23 = ONE/CHARGE**TWOTHR
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
      ENDIF
*
* *** Compute energy dependent parameters
*
      GAMASS=GETOT+AMASS
      BET2=GEKIN*GAMASS/(GETOT*GETOT)
      BET=SQRT(BET2)
      W1=1.034-0.1777*EXP(-0.08114*CHARGE)
      W2=BET*CHAR23
      W3=121.4139*W2+0.0378*SIN(190.7165*W2)
      CHARG1=CHARGE*(1.-W1*EXP(-W3))
*
*              the effective charge  CHARG1
*            can be negative only for very low energy and
*     for CHARGE > 20 ( very low energy : T/A < 20 keV/nucleon)
*              in this case short circuit
*
      IF(CHARG1.LT.0.) GOTO 100
      CHARG2=CHARG1**2
*
      OMCMOL=Q(JPROB+21)*CHARG2
      CHCMOL=Q(JPROB+25)*ABS(CHARG1)
      IF(FIELDM.NE.0.) THEN
         CFLD=3333.*DEGRAD*TMAXFD/ABS(FIELDM*CHARG1)
      ELSE
         CFLD=BIG
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
*
*  **   Step limitation due to hadron interaction ?
*
      IF (IHADR.GT.0) THEN
+SELF, IF=-USRJMP.
         CALL GUPHAD
+SELF, IF=USRJMP.
         CALL JUMPT0(JUPHAD)
+SELF.
         IF (SHADR.LT.STEP) THEN
            IF (SHADR.LE.0.) SHADR = PREC
            STEP  = SHADR
            IPROC = 12
         ENDIF
      ENDIF
*
*  ** Step limitation due to delta-ray production ?
*       (Cannot be tabulated easily because dependent on AMASS)
*
      IF (IDRAY.GT.0) THEN
         STEPDR = BIG
         IF (GEKIN.GT.DCUTM) THEN
            TMAX   = EMASS*GEKIN*GAMASS/(0.5*AMASS*AMASS+EMASS*GETOT)
            IF (TMAX.GT.DCUTM) THEN
               Y    = DCUTM/TMAX
               SIG  = (1.-Y+BET2*Y*LOG(Y))/DCUTM
*              extra term for spin 1/2
               IF (AMASS.GT.0.9) SIG=SIG+0.5*(TMAX-DCUTM)/(GETOT*GETOT)
               SIG = SIG*Q(JPROB+17)*CHARG2*EMASS/BET2
*
               IF (SIG.GT.0.) THEN
                  STEPDR = 1./SIG
                  SDRAY  = STEPDR*ZINTDR
                  IF (SDRAY.LE.STEP) THEN
                     STEP  = SDRAY
                     IPROC = 10
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP  = 0.
         GO TO 110
      ENDIF
*
*  **   Step limitation due to energy loss (stopping range) ?
*
      IF (ILOSL.GT.0) THEN
         IF(GEKRAT.LT.THRESH) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0) THEN
            STOPP = -XCOEF2+SIGN(ONE,XCOEF1)* SQRT(XCOEF2
     +      **2 -(XCOEF3-GEKIN*RMASS/XCOEF1))
         ELSE
            STOPP = - (XCOEF3-GEKIN*RMASS)/XCOEF2
         ENDIF
         STOPMX = (STOPP - STOPC)/(RMASS*CHARG2)
         IF (STOPMX.LT.MIN(STEP,STMIN)) THEN
            STEP = STOPMX
            IPROC = 0
            IF(STEP.LE.0.)THEN
               GO TO 100
            ENDIF
            GO TO 10
         ENDIF
         EKF = (1. - DEEMAX)*GEKIN*RMASS
         IF (EKF.LT.ELOW(1)) THEN
            EKF = ELOW(1)
         ELSEIF (EKF.GE.ELOW(NEK1)) THEN
            EKF = ELOW(NEK1)*0.99
         ENDIF
         IKF=GEKA*LOG10(EKF)+GEKB
         GKR=(EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
         IF(GKR.LT.THRESH) THEN
            IK1 = MAX(IKF-1,1)
         ELSE
            IK1 = MIN(IKF,NEKBIN-1)
         ENDIF
         IK1 = 3*(IK1-1)+1
         YCOEF1=Q(JCOEF+IK1)
         YCOEF2=Q(JCOEF+IK1+1)
         YCOEF3=Q(JCOEF+IK1+2)
         IF(YCOEF1.NE.0.) THEN
            SLOSP = -YCOEF2+SIGN(ONE,YCOEF1)*SQRT(YCOEF2**2- (YCOEF3-
     +      EKF/YCOEF1))
         ELSE
            SLOSP = - (YCOEF3-EKF)/YCOEF2
         ENDIF
         SLOSP = STOPP - SLOSP
         SLOSS = MAX(STMIN, SLOSP/(RMASS*CHARG2) )
         IF (SLOSS.LT.STEP) THEN
            STEP = SLOSS
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to energy loss in magnetic field ?
*
      IF (IFIELD.NE.0) THEN
         SFIELD = CFLD*VECT(7)
         SFIELD=MAX(SFIELD, STMIN)
         IF (SFIELD.LT.STEP) THEN
            STEP  = SFIELD
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to multiple scattering ?
*
      IF (IMULL.GT.0) THEN
         SMULS=MIN(2232.*RADL*((VECT(7)**2)/(GETOT*CHARG1))**2,10.*RADL)
         SMULS  = MAX(STMIN, SMULS )
         IF (SMULS.LT.STEP) THEN
            STEP  = SMULS
            IPROC = 0
         ENDIF
      ENDIF
*
   10 CONTINUE
*
*  **   Step limitation due to Cerenkov production ?
*
      IF (IMCKOV.GT.0) THEN
         CALL GNCKOV
         STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         SMULS  = MAX(STMIN, STCKOV)
         IF (SMULS.LT.STEP) THEN
            STEP  = STCKOV
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP   = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 20 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   20       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport when no field or very short step
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
         IF (IGNEXT.NE.0) THEN
            DO 30 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTHION: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   30       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 40 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   40       CONTINUE
         ENDIF
      ELSE
*
* ***   otherwise, swim particle in magnetic field
*
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP.
   50    CALL GUSWIM (CHARG1, STEP, VECT, VOUT)
+SELF, IF=USRJMP.
   50    CALL JUMPT4(JUSWIM, CHARG1, STEP, VECT, VOUT)
+SELF.
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 60 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   60          CONTINUE
               DO I=1,3
                 IF ((VOUT(I)-VNEXT(I)).GT.EPSIL) GOTO 70
               ENDDO
               INWVOL = 2
               NMEC = NMEC +1
               LMEC(NMEC) = 1
               GOTO 80
   70          CONTINUE
               INEAR = 1
            ENDIF
+SELF, IF=-OLD.
            if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
              nlevel=manyle(nfmany)
              do 99 i=1,nlevel
                names(i)=manyna(nfmany,i)
                number(i)=manynu(nfmany,i)
 99           continue
              call glvolu(nlevel,names,number,ier)
              if(ier.ne.0)print *,'Fatal error in GLVOLU'
              ingoto=0
            endif
+SELF.
*
            CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0)THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 50
               ENDIF
            ENDIF
         ENDIF
*
   80    CONTINUE
         DO 90 I = 1,6
            VECT(I) = VOUT(I)
   90    CONTINUE
*
      ENDIF
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*CHARG2*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         NMEC=NMEC+1
         LMEC(NMEC)=105
      ENDIF
*
* *** apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 3
         STOPRG = STOPP - STEP*RMASS*CHARG2
         IF (STOPRG.LE.STOPC) THEN
            STEP = STOPMX
            GO TO 100
         ENDIF
         IF(XCOEF1.NE.0.) THEN
            EKIPR = XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            EKIPR = XCOEF2*STOPRG+XCOEF3
         ENDIF
         DEMEAN=GEKIN - EKIPR/RMASS
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +             *STEP*CHARG2
         ENDIF
*
*        fluctuations : differ from that of 'ordinary' hadrons
*
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
*
*     Charge exchange fluctuations + Gaussian 'Landau' fluctuations
*           (it is the same for ILOSS=1,2,3 !)
*
            SIGMA2=CNORM*CHARG1*(1.-CHARG1/CHARGE)
            SIGMA2=MAX(SIGMA2,0.)
            TA = RMASS*GEKIN
            TAM=TA/AMU
            SIGMA2=SIGMA2+2.+TAM*(2.+TAM)
*
            SIGMA2=FACFLU*CHARG2*STEP*SIGMA2
            IF(SIGMA2.GT.0.0) THEN
                SIGMA=SQRT(SIGMA2)
            ELSE
                SIGMA= 0.0
            END IF
*
*     Check if we are in 'Gaussian' regime ...
*
            CAPPA=(1.+TAM)/(TAM*(2.+TAM)*EMASS)
            CAPPA=0.5*CAPPA**2*FACFLU*CHARG2*STEP
*
*     ... if not , correct SIGMA !

            IF( (CAPPA.LT.10.) .AND. (CAPPA.GT.0.0) ) THEN
               SIGMA=SIGMA/(0.97+0.03*SQRT(10./CAPPA))
            ENDIF
*
            CALL GRNDM(RNDM,2)
            DEFLUC=SIGMA*SIN(TWOPI*RNDM(1))*SQRT(-2.*LOG(RNDM(2)))
            DESTEP=DEMEAN+DEFLUC
         ENDIF
*
*     protection against negative destep
*
         IF(DESTEP.LT.0.) DESTEP=DEMEAN
*                          IF (DESTEP.LT.0.) DESTEP = 0.
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTHAD)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
      ENDIF
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 2
*      check charge dependence ...........!!!!!!!  (later..)
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG   = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IHADR.GT.0) ZINTHA = ZINTHA*(1.-STEP/SHADR)
      IF (IDRAY.GT.0) ZINTDR = ZINTDR -STEP/STEPDR
*
      GO TO 110
*
*  **   Special treatment for overstopped tracks
*
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      ISTOP  = 2
      NMEC = NMEC + 1
      LMEC(NMEC) = 30
      IF (IHADR.EQ.0) GO TO 999
      IPROC = 12
*
* *** apply slected process if any
*
  110 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Hadron interaction ?
*
      IF (IPROC.EQ.12) THEN
+SELF, IF=-USRJMP.
         CALL GUHADR
+SELF, IF=USRJMP.
         CALL JUMPT0(JUHADR)
+SELF.
*   *   Check time cut-off for decays at rest
         IF (LMEC(NMEC).EQ.5) THEN
            TOFG   = TOFG +SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               NGKINE = 0
               ISTOP  = 4
               LMEC(NMEC) = 22
            ENDIF
         ENDIF
*
*  **   Delta-ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
         CALL GDRAY
      ENDIF
  999 END
+DECK,  GTMED2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:45  cernlib
* Geant

+SELF, IF=OLD.
      SUBROUTINE GTMEDI (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Note : For INWVOL = 2, INFROM set to a positive number is    *
C.    *      interpreted by GTMEDI as the number IN of the content     *
C.    *      just left by the current track within the mother volume   *
C.    *      where the point X is assumed to be.                       *
C.    *                                                                *
C.    *   Note : INFROM is set correctly by this routine but it is     *
C.    *      used on entrance only in the case GSNEXT has been called  *
C.    *      by the user. In other words the value of INFROM received  *
C.    *      on entrance is not considered necessarily valid. This     *
C.    *      assumption has been made for safety. A wrong value of     *
C.    *      INFROM can cause wrong tracking.                          *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SELF, IF=OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=OLD.
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
C.
      DIMENSION  X(*)
      REAL       XC(3), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
* *** Check if point is in current volume
*
      INFR = 0
      INGT = 0
      JVIN = 0
*
* *** LSAMVL is a logical variable that indicates whether we are still
* *** in the current volume or not. It is used in GTRACK to detect
* *** precision problems.
      LSAMVL = .TRUE.
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)

      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            LSAMVL = .FALSE.
            NL1 = NLEVEL +1
            LVOLUM(NL1) = IVOT
            NAMES(NL1)  = IQ(JVOLUM+IVOT)
            NUMBER(NL1) = Q(JIN+3)
            LINDEX(NL1) = INGOTO
            LINMX(NL1)  = Q(JVO+3)
            GONLY(NL1)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NL1) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NL1) = NL1
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NL1), GRMAT(1,NL1))
            NLEVEL = NL1
            XC(1) = XT(1)
            XC(2) = XT(2)
            XC(3) = XT(3)
            JVO = JVOT
            INFROM = 0
            GO TO 190
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         LSAMVL = .FALSE.
         INGOTO = 0
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
               INFROM=LINDEX(NLEVEL+1)
            ELSE
               INFROM=0
            ENDIF
            INFR = INFROM
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ELSE
*
*   *      Point in current volume but not in INGOTO. We block the
*   *      corresponding volume
*
         IF (INGOTO.GT.0) THEN
            INGT = INGOTO
            JIN = LQ(JVO-INGOTO)
            IQ(JIN) = IBSET(IQ(JIN),4)
         ENDIF
      ENDIF
*
*   *      Found a volume up the tree which contains our point. We block
*   *      the branch we came up from.
*
      IF(INFR.GT.0) THEN
         JIN=LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
*
*  **   Point is in current volume
*
  190 INGOTO = 0
      NLMIN = NLEVEL
      IF (INWVOL.NE.2) INFROM = 0
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            INFROM = 0
            INFR   = 0
            INGT   = 0
            LSAMVL = .FALSE.
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               CX   = XC(IAX)
            ELSE
               CALL GFCOOR (XC, IAX, CX)
            ENDIF
            IDIV = ABS(LOCATF (Q(JSB+3), NSB, CX))
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=OLD, IF=-USRJMP.
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=OLD, IF=USRJMP.
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF, IF=OLD.
            ELSEIF (INFROM.GT.0) THEN
               JNUP = LQ(LQ(JVO-INFROM)-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF (GONLY(NLEVEL).NE.0.) NLMANY = 0
                  INFROM = 0
                  INGT   = 0
                  INFR   = 0
                  LSAMVL = .FALSE.
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INFR = 0
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INGT = 0
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFROM = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         INFR = INFROM
         JIN = LQ(JVO-INFROM)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GTMEDI
  999 IF(JGSTAT.NE.0) CALL GFSTAT(4)
      END
+SELF.
+DECK,  GTMEDI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:44  cernlib
* Geant

+SELF, IF=-OLD.
      SUBROUTINE GTMEDI (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Note : For INWVOL = 2, INFROM set to a positive number is    *
C.    *      interpreted by GTMEDI as the number IN of the content     *
C.    *      just left by the current track within the mother volume   *
C.    *      where the point X is assumed to be.                       *
C.    *                                                                *
C.    *   Note : INFROM is set correctly by this routine but it is     *
C.    *      used on entrance only in the case GSNEXT has been called  *
C.    *      by the user. In other words the value of INFROM received  *
C.    *      on entrance is not considered necessarily valid. This     *
C.    *      assumption has been made for safety. A wrong value of     *
C.    *      INFROM can cause wrong tracking.                          *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *               S.Giani.                                         *
C.    *                                                                *
C.    *   Modified by S.Giani (1993) to perform the search according   *
C.    *    to the new 'virtual divisions' algorithm and to build the   *
C.    *    stack of the 'possible overlapping volumes' in the case of  *
C.    *    MANY volumes. Any kind of boolean operation is now possible.*
C.    *    Divisions along arbitrary axis are now possible.            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SELF, IF=-OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=-OLD.
+CDE, GCHVIR.
+CDE, GCVDMA.
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
C.
      CHARACTER*4 NAME
      DIMENSION  X(*)
      REAL       XC(6), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
      nvmany=0
      nfmany=0
      new2fl=0
      neufla=0
      if(raytra.eq.1.)then
        JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
        if(ingoto.eq.-1.and.q(jvo+3).lt.0)then
          neufla=1
        elseif(ingoto.eq.0)then
              call ggperp(x,veccos,ierr)
              veccos(1)=-veccos(1)
              veccos(2)=-veccos(2)
              veccos(3)=-veccos(3)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
        endif
      endif
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
* *** Check if point is in current volume
*
      INFR = 0
      INGT = 0
      JVIN = 0
*
* *** LSAMVL is a logical variable that indicates whether we are still
* *** in the current volume or not. It is used in GTRACK to detect
* *** precision problems.
      LSAMVL = .TRUE.
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)

      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 189
      endif
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            LSAMVL = .FALSE.
            NL1 = NLEVEL +1
            LVOLUM(NL1) = IVOT
            NAMES(NL1)  = IQ(JVOLUM+IVOT)
            NUMBER(NL1) = Q(JIN+3)
            LINDEX(NL1) = INGOTO
            LINMX(NL1)  = Q(JVO+3)
            GONLY(NL1)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NL1) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NL1) = NL1
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NL1), GRMAT(1,NL1))
            NLEVEL = NL1
            XC(1) = XT(1)
            XC(2) = XT(2)
            XC(3) = XT(3)
            JVO = JVOT
            INFROM = 0
            if(raytra.eq.1.)then
              call ggperp(x,veccos,ierr)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
            endif
            GO TO 190
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
 189  JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         LSAMVL = .FALSE.
         INGOTO = 0
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
               INFROM=LINDEX(NLEVEL+1)
            ELSE
               INFROM=0
            ENDIF
            INFR = INFROM
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ELSE
*
*   *      Point in current volume but not in INGOTO. We block the
*   *      corresponding volume
*
         IF (INGOTO.GT.0) THEN
            INGT = INGOTO
            JIN = LQ(JVO-INGOTO)
            IQ(JIN) = IBSET(IQ(JIN),4)
         ENDIF
      ENDIF
*
*   *      Found a volume up the tree which contains our point. We block
*   *      the branch we came up from.
*
      IF(INFR.GT.0) THEN
         JIN=LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
*
*  **   Point is in current volume
*
  190 INGOTO = 0
      NLMIN = NLEVEL
      IF (INWVOL.NE.2) INFROM = 0
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            if(raytra.eq.1..and.neufla.eq.1)then
              neufla=0
              call ggperp(x,veccos,ierr)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
            endif
            INFROM = 0
            INFR   = 0
            INGT   = 0
            LSAMVL = .FALSE.
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  new2fl=0
                  IF (GONLY(NLEVEL).NE.0.) THEN
                    NLMANY = 0
                    nvmany = 0
                    nfmany = 0
                  ENDIF
                  INFROM = 0
                  INGT   = 0
                  INFR   = 0
                  LSAMVL = .FALSE.
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INFR = 0
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INGT = 0
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
            nfmany=nvmany+1
         ENDIF
         if(new2fl.eq.0)then
            nvmany=nvmany+1
            manyle(nvmany)=nlevel
            do 401 i = 1,nlevel
              manyna(nvmany,i)=names(i)
              manynu(nvmany,i)=number(i)
 401        continue
         endif
*
*   *   Go up the tree up to a volume with positioned contents
*
         new2fl=-1
  310    INFROM = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         INFR = INFROM
         JIN = LQ(JVO-INFROM)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      if(nlmany.eq.0)then
        nvmany=0
        nfmany=0
      endif
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GTMEDI
  999 IF(JGSTAT.NE.0) CALL GFSTAT(4)
      END
+SELF.
+DECK,  GTMUON, T=FORT.

      SUBROUTINE GTMUON
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Muon track. Computes step size and propagates particle       *
C.    *    through step.                                               *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors     R.Brun, F.Bruyant, M.Maire ********           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCMATE.
+CDE, GCMULO.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCKING.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.

+SELF, IF=-OLD.
+CDE, GCVOLU.
+CDE, GCVDMA.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
      DOUBLE PRECISION DEMEAN,STOPRG,STOPMX,STOPC
      DOUBLE PRECISION ONE,XCOEF1,XCOEF2,XCOEF3
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
      PARAMETER (ONE=1)
      REAL VNEXT(6)
      SAVE IKCUT,STOPC
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? short circuit
*
      IF (GEKIN.LE.CUTMUO) GO TO 100
*
* *** Update local pointers if medium has changed
      IF (IUPD.EQ.0) THEN
         IUPD  = 1
         JLOSS = LQ(JMA-2)
         JBREM = LQ(JMA-9)
         JPAIR = LQ(JMA-10)
         JDRAY = LQ(JMA-11)
         JMUNU = LQ(JMA-14)
         JRANG = LQ(JMA-16)
         JCOEF = LQ(JMA-18)
         JMULOF= LQ(JTM-2)
         IF(IMCKOV.EQ.1) THEN
            JTCKOV = LQ(JTM-3)
            JABSCO = LQ(JTCKOV-1)
            JEFFIC = LQ(JTCKOV-2)
            JINDEX = LQ(JTCKOV-3)
            JCURIN = LQ(JTCKOV-4)
            NPCKOV = Q(JTCKOV+1)
         ENDIF
         OMCMOL= Q(JPROB+21)
         CHCMOL= Q(JPROB+25)
         IKCUT = Q(JMULOF+NEK1+1)
         STOPC = Q(JMULOF+NEK1+2)
         IF(ISTRA.GT.0) THEN
            JTSTRA = LQ(JMA-19)
            JTSTCO = LQ(JTSTRA-1)
            JTSTEN = LQ(JTSTRA-2)
+SELF, IF=ASHO.
            IF(ISTRA.EQ.2) THEN
               JTASHO = LQ(JMA-20)
            ENDIF
+SELF.
         ENDIF
      ENDIF
*
* *** Compute current step size
*
      STEP   = STEMAX
      IPROC  = 103
      GEKRT1 = 1. -GEKRAT
      IEK1   = IEKBIN+NEK1
      IEK2   = IEKBIN+2*NEK1
*
*  **   Step limitation due to bremsstrahlung ?
*
      IF (IBREM.GT.0) THEN
         STEPBR = GEKRT1*Q(JBREM+IEK2) +GEKRAT*Q(JBREM+IEK2+1)
         SBREM  = STEPBR*ZINTBR
         IF (SBREM.LT.STEP) THEN
            STEP  = SBREM
            IPROC = 9
         ENDIF
      ENDIF
*
*  **   Step limitation due to pair production ?
*
      IF (IPAIR.GT.0) THEN
         STEPPA = GEKRT1*Q(JPAIR+IEK1) +GEKRAT*Q(JPAIR+IEK1+1)
         SPAIR  = STEPPA*ZINTPA
         IF (SPAIR.LT.STEP) THEN
            STEP  = SPAIR
            IPROC = 6
         ENDIF
      ENDIF
*
*  **   Step limitation due to decay ?
*
      IF (IDCAY.NE.0) THEN
         SDCAY = SUMLIF*VECT(7)/AMASS
         IF (SDCAY.LT.STEP) THEN
            STEP  = SDCAY
            IPROC = 5
         ENDIF
      ENDIF
*
*  **   Step limitation due to delta-ray ?
*
      IF (IDRAY.GT.0) THEN
         STEPDR = GEKRT1*Q(JDRAY+IEK2) +GEKRAT*Q(JDRAY+IEK2+1)
         SDRAY  = STEPDR*ZINTDR
         IF (SDRAY.LT.STEP) THEN
            STEP  = SDRAY
            IPROC = 10
         ENDIF
      ENDIF
*
*  **   Step limitation due to nuclear interaction ?
*
      IF (IMUNU.GT.0) THEN
         IF(GEKIN.GE.5.)THEN
            STEPMU = GEKRT1*Q(JMUNU+IEKBIN) +GEKRAT*Q(JMUNU+IEKBIN+1)
            SMUNU = STEPMU*ZINTMU
            IF (SMUNU.LT.STEP) THEN
               STEP  = SMUNU
               IPROC = 21
            ENDIF
         ELSE
            STEPMU = BIG
         ENDIF
      ENDIF
*
      IF (STEP.LE.0.) THEN
         STEP = 0.
         GO TO 90
      ENDIF
*
*  **   Step limitation due to energy-loss,multiple scattering
*             or magnetic field ?
*
      IF (JMULOF.NE.0) THEN
         SMULOF  = GEKRT1*Q(JMULOF+IEKBIN) +GEKRAT*Q(JMULOF+IEKBIN+1)
         IF (SMULOF.LT.STEP) THEN
            STEP  = SMULOF
            IPROC = 0
         ENDIF
      ENDIF
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.0.95*SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP  = SNEXT + PREC
            IPROC = 0
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST    = JSTAK + 3 + (IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport when no field or very short step
*
      IF (IFIELD.EQ.0.OR.STEP.LE.PREC) THEN
*
         IF (IGNEXT.NE.0) THEN
            DO 20 I = 1,3
               VECTMP  = VECT(I) +STEP*VECT(I+3)
               IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
                  IF(VECT(I+3).NE.0.) THEN
                     VECTMP =
     +               VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*EPSMAC
                     IF(NMEC.GT.0) THEN
                        IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                     ENDIF
                     NMEC=NMEC+1
                     LMEC(NMEC)=104
+SELF, IF=DEBUG.
                     WRITE(CHMAIL, 10000)
                     CALL GMAIL(0,0)
                     WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                     CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTMUON: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
                  ENDIF
               ENDIF
               VECT(I) = VECTMP
   20       CONTINUE
            INWVOL = 2
            NMEC = NMEC +1
            LMEC(NMEC) = 1
         ELSE
            DO 30 I = 1,3
               VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30       CONTINUE
         ENDIF
      ELSE
*
* ***   otherwise, swim particle in magnetic field
*
         NMEC = NMEC +1
         LMEC(NMEC) = 4
*
+SELF, IF=-USRJMP.
   40    CALL GUSWIM (CHARGE, STEP, VECT, VOUT)
+SELF, IF=USRJMP.
   40    CALL JUMPT4(JUSWIM, CHARGE, STEP, VECT, VOUT)
+SELF.
*
*  ** When near to boundary, take proper action (cut-step,crossing...)
*
         IF(STEP.GE.SAFETY)THEN
            INEAR = 0
            IF (IGNEXT.NE.0) THEN
               DO 50 I = 1,3
                  VNEXT(I+3) = VECT(I+3)
                  VNEXT(I) = VECT(I) +SNEXT*VECT(I+3)
   50          CONTINUE
               DO I=1,3
                 IF ((VOUT(I)-VNEXT(I)).GT.EPSIL) GOTO 60
               ENDDO
               INWVOL = 2
               NMEC = NMEC +1
               LMEC(NMEC) = 1
               GOTO 70
   60          CONTINUE
               INEAR = 1
            ENDIF
+SELF, IF=-OLD.
            if(mycoun.gt.1.and.nfmany.gt.0.and.step.ge.safety)then
              nlevel=manyle(nfmany)
              do 99 i=1,nlevel
                names(i)=manyna(nfmany,i)
                number(i)=manynu(nfmany,i)
 99           continue
              call glvolu(nlevel,names,number,ier)
              if(ier.ne.0)print *,'Fatal error in GLVOLU'
              ingoto=0
            endif
+SELF.
*
            CALL GINVOL (VOUT, ISAME)
            IF (ISAME.EQ.0)THEN
               IF ((INEAR.NE.0).OR.(STEP.LT.EPSIL)) THEN
                  INWVOL = 2
                  NMEC = NMEC +1
                  LMEC(NMEC) = 1
               ELSE
*              Cut step
                  STEP = 0.5*STEP
                  IF (LMEC(NMEC).NE.24) THEN
                     NMEC = NMEC +1
                     LMEC(NMEC) = 24
                  ENDIF
                  GO TO 40
               ENDIF
            ENDIF
         ENDIF
   70    CONTINUE
*
         DO 80 I = 1,6
            VECT(I) = VOUT(I)
   80    CONTINUE
*
      ENDIF
*
* *** Correct the step due to multiple scattering
      IF (IMULL.NE.0) THEN
         STMULS = STEP
         CORR=0.0001*(STEP/RADL)*(GETOT/(VECT(7)*VECT(7)))**2
         IF (CORR.GT.0.25) CORR = 0.25
         STEP  = (1.+CORR)*STEP
      ENDIF
*
      SLENG = SLENG + STEP
*
* *** Generate Cherenkov photons if required
*
      IF(IMCKOV.EQ.1) THEN
         CALL GGCKOV
         IF(NGPHOT.NE.0) THEN
            NMEC=NMEC+1
            LMEC(NMEC)=105
         ENDIF
      ENDIF
*
* *** apply energy loss : find the kinetic energy corresponding
*      to the new stopping range = stopmx - step
*
      IF (ILOSL.NE.0) THEN
         NMEC = NMEC +1
         LMEC(NMEC) = 3
         IF(GEKRAT.LT.0.7) THEN
            I1 = MAX(IEKBIN-1,1)
         ELSE
            I1 = MIN(IEKBIN,NEKBIN-1)
         ENDIF
         I1 = 3*(I1-1)+1
         XCOEF1 = Q(JCOEF+I1)
         XCOEF2 = Q(JCOEF+I1+1)
         XCOEF3 = Q(JCOEF+I1+2)
         IF(XCOEF1.NE.0.) THEN
            STOPMX = -XCOEF2+SIGN(ONE,XCOEF1)*SQRT(XCOEF2**2 - (XCOEF3-
     +      GEKIN/XCOEF1))
         ELSE
            STOPMX = - (XCOEF3-GEKIN)/XCOEF2
         ENDIF
         STOPRG = STOPMX - STEP
         IF (STOPRG.LT.STOPC) THEN
            STEP = STOPMX - STOPC
            GO TO 100
         ENDIF
*
         IF(XCOEF1.NE.0.) THEN
            DEMEAN=GEKIN-XCOEF1*(XCOEF3+STOPRG*(2.*XCOEF2+STOPRG))
         ELSE
            DEMEAN=GEKIN-XCOEF2*STOPRG-XCOEF3
         ENDIF
         IF(DEMEAN.LE.5.*GEKIN*EPSMAC) THEN
            DEMEAN=(GEKRT1*Q(JLOSS+IEKBIN)+GEKRAT*Q(JLOSS+IEKBIN+1))
     +      *STEP
         ENDIF
         IF (ILOSS.EQ.4.OR.IEKBIN.LE.IKCUT+1) THEN
            DESTEP = DEMEAN
         ELSE
            DEMS = DEMEAN
            CALL GFLUCT(DEMS,DESTEP)
         ENDIF
         IF (DESTEP.LT.0.) DESTEP = 0.
         GEKINT = GEKIN -DESTEP
         IF (GEKINT.LE.(1.01*CUTMUO)) GO TO 100
         DESTEL = DESTEP
         GEKIN  = GEKINT
         GETOT  = GEKIN +AMASS
         VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
         CALL GEKBIN
      ENDIF
*
* *** Apply multiple scattering.
*
      IF (IMULL.NE.0) THEN
         NMEC   = NMEC +1
         LMEC(NMEC) = 2
         CALL GMULTS
      ENDIF
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IBREM.GT.0) ZINTBR = ZINTBR -STEP/STEPBR
      IF (IPAIR.GT.0) ZINTPA = ZINTPA -STEP/STEPPA
      IF (IDRAY.GT.0) ZINTDR = ZINTDR -STEP/STEPDR
      IF (IMUNU.GT.0) ZINTMU = ZINTMU -STEP/STEPMU
*
* ***   otherwise, apply the selected process if any
*
   90 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Bremsstrahlung ?
*
      IF (IPROC.EQ.9) THEN
         CALL GBREMM
*
*  **   Pair production ?
*
      ELSE IF (IPROC.EQ.6) THEN
         CALL GPAIRM
*
*  **   Decay ?
*
      ELSE IF (IPROC.EQ.5) THEN
         ISTOP = 1
         CALL GDECAY
*
*  **   Delta-ray ?
*
      ELSE IF (IPROC.EQ.10) THEN
         CALL GDRAY
*
*  **   Nuclear interaction ?
*
      ELSE IF (IPROC.EQ.21) THEN
         CALL GMUNU
      ENDIF
      GO TO 999
*
* *** Special treatment for overstopped tracks
*
  100 DESTEP = GEKIN
      DESTEL = DESTEP
      GEKIN  = 0.
      GETOT  = AMASS
      VECT(7)= 0.
      INWVOL = 0
      NMEC   = NMEC +1
      LMEC(NMEC) = 30
      IF (IDCAY.EQ.0) THEN
         ISTOP = 2
      ELSE
         NMEC   = NMEC +1
         TOFG   = TOFG +SUMLIF/CLIGHT
         SUMLIF = 0.
         IF (TOFG.GE.TOFMAX) THEN
            ISTOP = 4
            LMEC(NMEC) = 22
            GO TO 999
         ENDIF
         LMEC(NMEC) = 5
         ISTOP = 1
         CALL GDECAY
      ENDIF
  999 IF(NGPHOT.GT.0) THEN
         IF(ITCKOV.EQ.2.AND.ISTOP.EQ.0) THEN
*
*  The muon has produced Cerenkov photons and it is still alive
*  we put it in the stack and we let the photons to be tracked
            NGKINE = NGKINE+1
            GKIN(1,NGKINE) = VECT(4)*VECT(7)
            GKIN(2,NGKINE) = VECT(5)*VECT(7)
            GKIN(3,NGKINE) = VECT(6)*VECT(7)
            GKIN(4,NGKINE) = GETOT
            GKIN(5,NGKINE) = IPART
            TOFD(NGKINE) = 0.
            ISTOP = 1
c----put position as well
            GPOS(1,NGKINE)=VECT(1)
            GPOS(2,NGKINE)=VECT(2)
            GPOS(3,NGKINE)=VECT(3)
         ENDIF
      ENDIF
      END
+DECK,  GTNEUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:44  cernlib
* Geant

      SUBROUTINE GTNEUT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Neutral hadron type track. Computes step size and propagates *
C.    *    particle through step.                                      *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors     R.Brun, F.Bruyant  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=DEBUG.
+CDE, GCUNIT.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
C.
C.    ------------------------------------------------------------------
*
* *** Particle below energy threshold ? Special treatment
*
      IF (GEKIN.LE.CUTNEU) THEN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7)= 0.
         ISTOP  = 2
         NMEC = NMEC + 1
         LMEC(NMEC) = 30
         IF (IHADR.EQ.0.AND.AMASS.GT.0.) THEN
            IF (IDCAY.NE.0) THEN
               GAMMA  = GETOT/AMASS
               TOFG = TOFG +GAMMA*SUMLIF/CLIGHT
               SUMLIF = 0.
               IF (TOFG.GE.TOFMAX) THEN
                  ISTOP = 4
                  NMEC = NMEC + 1
                  LMEC(NMEC) = 22
                  NGKINE = 0
               ELSE
                  NMEC = NMEC + 1
                  LMEC(NMEC) = 5
                  ISTOP =1
                  CALL GDECAY
               ENDIF
            ENDIF
            GO TO 999
         ENDIF
         IPROC = 12
         GO TO 40
      ENDIF
*
* *** Compute step size
*
      IPROC  = 103
      STEP   = STEMAX
*
*  **   Step limitation due to hadron interaction ?
*
      IF (IHADR.GT.0) THEN
+SELF, IF=-USRJMP.
         CALL GUPHAD
+SELF, IF=USRJMP.
         CALL JUMPT0(JUPHAD)
+SELF.
         IF (SHADR.LT.STEP) THEN
            IF (SHADR.LE.0.) SHADR = PREC
            STEP  = SHADR
            IPROC = 12
         ENDIF
      ENDIF
*
*  **   Step limitation due to decay ?
*
      IF ((IDCAY.NE.0).AND.(AMASS.GT.0.)) THEN
         SDCAY = SUMLIF*VECT(7)/AMASS
         IF (SDCAY.LT.STEP) THEN
            STEP  = SDCAY
            IPROC = 5
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
            STEP = SNEXT + PREC
            IPROC = 0
            INWVOL = 2
            NMEC = NMEC + 1
            LMEC(NMEC)  = 1
         ENDIF
*
*        Update SAFETY in stack companions, if any
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 10 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   10       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      IF (INWVOL.EQ.2) THEN
         DO 20 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTNEUT: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
               ENDIF
            ENDIF
            VECT(I) = VECTMP
   20    CONTINUE
      ELSE
         DO 30 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   30    CONTINUE
      ENDIF
*
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      SUMLIF = SUMLIF -STEP*AMASS/VECT(7)
      TOFG = TOFG +STEP*GETOT/(VECT(7)*CLIGHT)
      IF (TOFG.GE.TOFMAX) THEN
         ISTOP = 4
         NMEC  = NMEC +1
         LMEC(NMEC) = 22
         GO TO 999
      ENDIF
*
* *** Update interaction probabilities
*
      IF (IHADR.GT.0) ZINTHA = ZINTHA*(1.-STEP/SHADR)
*
* *** apply the selected process if any
*
   40 IF (IPROC.EQ.0) GO TO 999
      NMEC = NMEC +1
      LMEC(NMEC) = IPROC
*
*  **   Hadron interaction ?
*
      IF (IPROC.EQ.12) THEN
+SELF, IF=-USRJMP.
         CALL GUHADR
+SELF, IF=USRJMP.
         CALL JUMPT0(JUHADR)
+SELF.
*          Check time cut-off for decays at rest
         IF (LMEC(NMEC).EQ.5) THEN
            TOFG   = TOFG +SUMLIF/CLIGHT
            SUMLIF = 0.
            IF (TOFG.GE.TOFMAX) THEN
               ISTOP = 4
               LMEC(NMEC) = 22
               NGKINE = 0
            ENDIF
         ENDIF
*
*  **   Decay ?
*
      ELSE IF (IPROC.EQ.5) THEN
         ISTOP = 1
         CALL GDECAY
      ENDIF
*                                                             END GTNEUT
  999 END
+DECK,  GTNEX2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:45  cernlib
* Geant

+SELF, IF=OLD.
      SUBROUTINE GTNEXT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SELF, IF=OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=OLD.
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      REAL      X0(3), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      ISEARC = Q(JVO+1)
      IF (ISEARC.GE.-1) GO TO 120
*
*  ** Contents are ordered by (dynamic) GSORD, select neighbours
*
      JSB = LQ(LQ(JVO-NIN-1))
      IAX = Q(JSB+1)
      NSB = Q(JSB+2)
      IF (IAX.LE.3) THEN
         CX  = XC(IAX)
         INC = SIGN(1., XC(IAX+3))
      ELSE
         CALL GFCOOR (XC, IAX, CX)
         IF (IAX.LE.5) THEN
            DR = XC(1)*XC(4) +XC(2)*XC(5)
            IF (IAX.EQ.5) DR = DR +XC(3)*XC(6)
            INC = SIGN(1., DR)
         ELSE IF (IAX.EQ.6) THEN
            INC = SIGN(1., XC(1)*XC(5)-XC(2)*XC(4))
         ELSE
            INC = SIGN(1., XC(3)*(XC(1)*XC(4)+XC(2)*XC(5))
     +                    -XC(6)*(XC(1)*XC(1)+XC(2)*XC(2)))
         ENDIF
      ENDIF
      IDIV = LOCATF (Q(JSB+3), NSB, CX)
      IF (IDIV.LT.0) IDIV = -IDIV
      IF (IAX.NE.6) THEN
         IF (IDIV.EQ.0) THEN
            IF (INC.LT.0.AND.IAX.LE.3) THEN
               SAFETY = Q(JSB+3) -CX
               GO TO 300
            ENDIF
            IDIV = 1
         ELSE IF (IDIV.EQ.NSB) THEN
            IF (INC.GT.0.AND.IAX.NE.7) THEN
               SAFETY = CX -Q(JSB+2+NSB)
               GO TO 300
            ENDIF
            IDIV = NSB -1
         ELSE
            IF (IAX.NE.7) THEN
               IF (INC.GT.0) THEN
                  SAFETY = CX -Q(JSB+2+IDIV)
               ELSE
                  SAFETY = Q(JSB+3+IDIV) -CX
               ENDIF
            ELSE
               SAFETY = 0.
            ENDIF
         ENDIF
      ELSE IF (IAX.EQ.6) THEN
         IF (IDIV.EQ.0) IDIV = NSB
         SAFETY = 0.
      ENDIF
*
      IDIVL = 0
      IDIVB = 0
      JSC0  = LQ(JVO-NIN-2)
  110 NCONT = IQ(JSC0+IDIV)
*
*  ** Loop over (selected) contents
*
      IF (NCONT.EQ.0) THEN
         IF (IDIV.EQ.IDIVL) GO TO 400
         IDIV = IDIV +INC
         IF (IAX.NE.6) GOTO 110
*      (following statement for IAX=6, when division NSB is empty)
         IF (IDIV.GT.NSB) IDIV = 1
         IF (IDIV.EQ.0) IDIV = NSB
         GO TO 110
      ELSE
         ICONT = 1
         JSCV = LQ(JSC0-IDIV)
         GO TO 140
      ENDIF
*
  120 JNEAR = LQ(JVO-NIN-1)
      IF (ISEARC.GT.0) THEN
+SELF, IF=OLD, IF=-USRJMP.
         CALL GUNEAR (ISEARC, 2, XC, JNEAR)
+SELF, IF=OLD, IF=USRJMP.
         CALL JUMPT4(JUNEAR, ISEARC, 2, XC, JNEAR)
+SELF, IF=OLD.
         IF (IQ(JNEAR+1).EQ.0) GO TO 300
      ELSE
         IF (INFROM.GT.0) THEN
            JIN = LQ(JVO-INFROM)
            IF (LQ(JIN-1).NE.0) THEN
               JNE = LQ(JIN-1)
               IF (IQ(JNE+1).GT.1.OR.IQ(JNE+2).NE.0) JNEAR = JNE
            ENDIF
         ENDIF
      ENDIF
      JNEAR = JNEAR +1
      NNEAR = IQ(JNEAR)
      IF (IQ(JNEAR+1).NE.0) THEN
         INEAR = 1
      ELSE
         INEAR = 2
      ENDIF
*
  130 IN = IQ(JNEAR+INEAR)
      GO TO 150
*
  140 IN = IQ(JSCV+ICONT)
*
  150 IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 180
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
         IF (ISEARC.EQ.-2) THEN
            IF (MOD(IQ(JSC0),2).NE.0) THEN
               IDIVB = IDIV
            ELSE
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVB = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVB = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVB.LT.0) IDIVB = -IDIVB
               IF (IDIVB.EQ.0) THEN
                  IF (IAX.EQ.6) THEN
                     IDIVB = NSB
                  ELSE
                     IDIVB = 1
                  ENDIF
               ELSE IF (IDIVB.EQ.NSB) THEN
                  IF (IAX.NE.6) IDIVB = NSB - 1
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (ISEARC.EQ.-2) THEN
         IF (ICONT.EQ.NCONT) THEN
            IF (IDIVL.EQ.0) THEN
               IF (IDIVB.NE.0) THEN
                  IF (IDIV.EQ.IDIVB) GO TO 300
                  IF (.NOT.BTEST(IQ(JVO),2)) THEN
                     IDIVL = IDIVB
                     GO TO 193
                  ENDIF
               ENDIF
*
*   *         Compute distance to boundary of current volume
*
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
*
*   *         Check wether other pseudo-divisions have to be scanned
*
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVL = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVL = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVL.LT.0) IDIVL = -IDIVL
               IF (IDIVL.EQ.0) THEN
                  IF(IAX.EQ.6)THEN
                     IDIVL=NSB
                  ELSE
                     IDIVL=1
                  ENDIF
               ELSEIF (IDIVL.EQ.NSB)THEN
                  IF(IAX.NE.6)IDIVL=NSB-1
               ENDIF
            ELSE
               IF (IDIV.EQ.IDIVB)   GO TO 400
            ENDIF
  193       IF ((IDIV-IDIVL)*INC.GE.0) GO TO 400
            IDIV = IDIV +INC
            GO TO 110
         ELSE
            ICONT = ICONT +1
            GO TO 140
         ENDIF
      ELSE
         IF (INEAR.EQ.NNEAR) GO TO 300
         INEAR = INEAR +1
         GO TO 130
      ENDIF
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
  400 IF (GONLY(NLEVEL).EQ.0.) THEN
*
* ***   Case of a 'NOT ONLY' volume -> step search
*
         SAFETY = 0.
         EPSI2  = 0.5*EPSIL
         ST     = SNEXT -EPSI2
         IF (ST.LE.0) GO TO 900
         EPSI3  = 10.*EPSIL
         IF (ST.LE.EPSI3) THEN
            NN = 1
         ELSE
            NN = ST/EPSI3 +1
            ST = ST/NN
         ENDIF
*
         NBIN = 0
         SN   = 0.
  420    SN   = SN +ST
         XT(1) = VECT(1) + SN*VECT(4)
         XT(2) = VECT(2) + SN*VECT(5)
         XT(3) = VECT(3) + SN*VECT(6)
*
         INGOTO = 0
         CALL GINVOL (XT, ISAME)
         IF (ISAME.EQ.0) THEN
            IF (ST.LE.EPSI2) GO TO 490
            SN   = SN -ST
            ST   = 0.5*ST
            NBIN = 1
            GO TO 420
         ENDIF
*
         IF (NBIN.NE.0) THEN
            IF (ST.LT.EPSI2) THEN
               ST = EPSI2
            ELSE
               ST = 0.5*ST
            ENDIF
            GO TO 420
         ENDIF
         NN = NN -1
         IF (NN.GT.0) GO TO 420
         GO TO 495
*
  490    IF (SN.LT.SNEXT) THEN
            INGOTO = -1
            SNEXT  = SN
            IGNEXT = 1
            GO TO 900
         ENDIF
*
  495    NLEVIN = NLEVEL
      ENDIF
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNEXT.LT.0.) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
+SELF.
+DECK,  GTNEXT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:44  cernlib
* Geant

+SELF, IF=-OLD.
      SUBROUTINE GTNEXT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *                                                                *
C.    *   Author   : S.Giani (1993)                                    *
C.    *                                                                *
C.    *   This routine is now based on the new 'virtual divisions'     *
C.    *    algorithm to speed up the tracking.                         *
C.    *   The tracking for MANY volumes is not anymore based on a step *
C.    *    search: it is now based on a search through the list of     *
C.    *    'possible overlapping volumes' built by GTMEDI.             *
C.    *    Boolean operations and divisions along arbitrary axis are   *
C.    *     now supported.                                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SELF, IF=-OLD, IF=USRJMP.
+CDE, GCJUMP.
+SELF, IF=-OLD.
+CDE, GCHVIR.
+CDE, GCVDMA.
      DIMENSION NUMTMP(15),NAMTMP(15)
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      CHARACTER*4 NAME
      dimension iarrin(500),cxm(3),xxm(6)
      REAL      X0(6), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      mycoun=0
      myinfr=0
      newfl=0
      manyfl=0
      tsafet=big
      tsnext=big
401   IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      sneold=SNEXT
      nnn=0
      nflag=0
      mmm=0
      snxtot=0.
 111  if(nin.gt.1)then
        if(nnn.gt.0)goto 112
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.eq.4)then
         do 1 i=1,6
          xxm(i)=xc(i)
 1       continue
        endif
        divthi=(chmoth-clmoth)/ndivto
        if(iaxis.le.3)then
          cx=xc(iaxis)
          if(xc(iaxis+3).ge.0.)then
            inc=1
          else
            inc=-1
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.4)then
            dr= xc(1)*xc(4)+xc(2)*xc(5)
*            if(dr.eq.0.)print *,'dr.eq.0.'
            if(dr.ge.0.)then
              inc=1
            else
              inc=-1
            endif
          elseif(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
            dfi=xc(1)*xc(5)-xc(2)*xc(4)
            if(dfi.ge.0)then
              inc=1
            else
              inc=-1
            endif
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
 112    iofset=iq(jvdiv+ivdiv)
        jcont2=jvdiv+iofset+1
        ncont=iq(jcont2)
        if(ncont.eq.0)then
          idmi=iq(jcont2+1)
          idma=iq(jcont2+2)
          llflag=0
        elseif(ncont.eq.1)then
          idmi=iq(jcont2+2)
          idma=iq(jcont2+3)
          in=iq(jcont2+1)
        else
          idmi=iq(jcont2+ncont+1)
          idma=iq(jcont2+ncont+2)
          iii=1
          in=iq(jcont2+iii)
        endif
        if(nnn.eq.0)then
         cxold=cx
         if(inc.gt.0)then
          cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
          if(iaxis.ne.6)then
           safety=min(safety,(cxold-cmin))
          else
           safefi=min(90.,(cxold-cmin))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         else
          cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
          if(iaxis.ne.6)then
           safety=min(safety,(cmax-cxold))
          else
           safefi=min(90.,(cmax-cxold))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         endif
        endif
        if(ncont.eq.0)goto 181
      elseif(nin.eq.1)then
        in=1
      endif
*
  150 if(nin.gt.1.and.ncont.gt.1)then
        in=iq(jcont2+iii)
      endif
      if(nin.gt.0)then
*        if(infrom.gt.0.and.myinfr.eq.0.and.newfl.eq.0)then
*          if(in.eq.infrom)goto 171
*        endif
        jin=lq(jvo-in)
        if(.NOT.BTEST(iq(jin),4))then
        else
          goto 171
        endif
      endif
      if(nin.gt.1)then
        llflag=0
        if(mmm.le.500)then
         do 151 ll=1,mmm
          if(iarrin(ll).eq.in)then
            llflag=1
            goto 171
          endif
 151     continue
        endif
        if(llflag.eq.0)then
          mmm=mmm+1
          if(mmm.le.500)then
            iarrin(mmm)=in
          endif
        endif
      endif
      IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 179
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
 179  if((nin.eq.1).or.(nin.gt.1.and.llflag.eq.0))then
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
      ENDIF
      endif
 171  if(nin.eq.1)then
        goto 300
      elseif(nin.ge.1.and.ncont.gt.1)then
           iii=iii+1
           if(iii.le.ncont)goto 150
      endif
*
*   *         Compute distance to boundary of current volume
*
 181  if(nnn.eq.0)then
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               safe=max(safe,0.)
               if(snxt.le.-prec)snxt=big1
               snxt=max(snxt,0.)
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
      endif
      if(iaxis.eq.4)then
       if(idma.eq.ndivto.and.inc.gt.0)goto 400
        cxm(1)=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
        if(idmi.eq.idma)then
          cxm(2)=cxm(1)+divthi
        else
          cxm(2)=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
        endif
        cxm(3)=20000.
        call gntube(xxm,cxm,3,1,SNEXT,snxnew,safe)
        if(snxnew.lt.0.)snxnew=big1
        snxnew=snxnew+.004
        snxtot=snxtot+snxnew
        if(snxtot.lt.SNEXT)then
          xxm(1)=xxm(1)+snxnew*xxm(4)
          xxm(2)=xxm(2)+snxnew*xxm(5)
          xxm(3)=xxm(3)+snxnew*xxm(6)
          call gfcoor(xxm,iaxis,cxnew)
          xevdiv=((cxnew-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xevdiv
          dr= xxm(1)*xxm(4)+xxm(2)*xxm(5)
*          if(dr.eq.0.)print *,'dr.eq.0.'
          if(dr.ge.0.)then
              inc=1
          else
              inc=-1
          endif
          if((xevdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
              ivdiv=1
          elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
          endif
          nnn=nnn+1
          goto 111
        else
          if(inc.gt.0)then
           cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
           safety=min(safety,(cmax-cxold))
          else
           cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
           safety=min(safety,(cxold-cmin))
          endif
          goto 400
        endif
      endif
          if(nnn.ne.0.and.SNEXT.eq.sneold)goto 199
               x0(1) = xc(1) + SNEXT*xc(4)
               x0(2) = xc(2) + SNEXT*xc(5)
               x0(3) = xc(3) + SNEXT*xc(6)
               x0(4) = xc(4)
               x0(5) = xc(5)
               x0(6) = xc(6)
          if(iaxis.le.3)then
            cx=x0(iaxis)
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          else
            call gfcoor(x0,iaxis,cx)
            if(iaxis.eq.6)then
             if((cx-clmoth).lt.-1.)then
              cx=cx+360.
             elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
             endif
             if(cx.gt.chmoth)then
              cx=chmoth
             elseif(cx.lt.clmoth)then
              cx=clmoth
             endif
            endif
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          endif
 199      if(ievdiv.ge.idmi.and.ievdiv.le.idma)then
            if(inc.gt.0)then
             cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
             if(iaxis.ne.6)then
              safety=min(safety,(cmax-cxold))
             else
              safefi=min(90.,(cmax-cxold))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            else
             cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
             if(iaxis.ne.6)then
              safety=min(safety,(cxold-cmin))
             else
              safefi=min(90.,(cxold-cmin))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            endif
            goto 400
          endif
          if(iaxis.eq.6.or.iaxis.le.3)then
           if(ievdiv.lt.idmi.and.inc.gt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idmi=',idmi,' inc.gt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safety=min(safety,abs(cmax-cxold))
             elseif(iaxis.eq.6)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safefi=min(90.,(cmax-cxold))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           elseif(ievdiv.gt.idma.and.inc.lt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idma=',idma,' inc.lt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safety=min(safety,abs(cxold-cmin))
             elseif(iaxis.eq.6)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safefi=min(90.,(cxold-cmin))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           endif
          endif
          nnn=nnn+1
          sneold=SNEXT
          if(inc.gt.0)then
            if(iaxis.eq.6)then
             if(idma.eq.ndivto.and.(chmoth-clmoth).eq.360.)then
               ivdiv=1
             else
               ivdiv=idma+1
             endif
            else
             ivdiv=idma+1
            endif
          else
            if(iaxis.eq.6)then
             if(idmi.eq.1.and.(chmoth-clmoth).eq.360.)then
               ivdiv=ndivto
             else
               ivdiv=idmi-1
             endif
            else
             ivdiv=idmi-1
            endif
          endif
          goto 111
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         if(raytra.eq.1.)ingoto=-1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      if(nin.eq.1.and.ignext.ne.0)then
        if(q(jin+8).eq.0.)iact=1
      endif
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
 400  if(iswit(9).eq.123456789.and.Q(JVO+3).gt.1.)then
        print *,'n. of checked objects = ',mmm
      endif
      if(myinfr.gt.0)then
        jin=lq(jvo-myinfr)
        iq(jin)=ibclr(iq(jin),4)
        myinfr=0
      endif
      if(gonly(nlevel).eq.0..or.nvmany.ne.0) THEN
         if(safety.lt.tsafet)tsafet=safety
         if(snext.lt.tsnext)then
          mycoun=mycoun+1
          tsnext=snext
          tignex=ignext
          tingot=ingoto
          call gscvol
          if(ingoto.gt.0)then
            iq(jgpar2+nlevel+1)=iq(jgpar+nlevel+1)
            lq(jgpar2-nlevel-1)=lq(jgpar-nlevel-1)
          endif
         endif
         if(gonly(nlevel).eq.0.)then
 404       continue
           if(gonly(nlevel-1).eq.0..or.newfl.eq.0)then
             if(gonly(nlevel-1).ne.0.)newfl=1
             nlevel=nlevel-1
             jvo=lq(jvolum-lvolum(nlevel))
             nin=q(jvo+3)
             if(nin.lt.0)goto 404
             myinfr=lindex(nlevel+1)
             jin=lq(jvo-myinfr)
             iq(jin)=ibset(iq(jin),4)
             ignext=0
             goto 401
           endif
         endif
 403   continue
       if(manyfl.lt.nvmany)then
         manyfl=manyfl+1
         if(manyfl.eq.nfmany)goto 403
         levtmp=manyle(manyfl)
         do 402 i=1,levtmp
          namtmp(i)=manyna(manyfl,i)
          numtmp(i)=manynu(manyfl,i)
 402     continue
         call glvolu(levtmp,namtmp,numtmp,ier)
         if(ier.ne.0)print *,'Fatal error in GLVOLU'
         ignext=0
         goto 401
       endif
       if(tsafet.le.safety)safety=tsafet
       if(tsnext.le.snext)then
         snext=tsnext
         ignext=tignex
         ingoto=tingot
         call gfcvol
         nlevin=nlevel
         if(ingoto.gt.0)then
          iq(jgpar+nlevel+1)=iq(jgpar2+nlevel+1)
          lq(jgpar-nlevel-1)=lq(jgpar2-nlevel-1)
         endif
       endif
      endif
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNXT.EQ.BIG1) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
+SELF.
+DECK,  GTNINO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:44  cernlib
* Geant

      SUBROUTINE GTNINO
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Tracking routine for "GEANTINO" type tracks              *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *       Author    R.Brun, F.Bruyant                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCTMED.
+CDE, GCTRAK.
+SELF, IF=DEBUG.
+CDE, GCUNIT.
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
C.
C.    ------------------------------------------------------------------
C.
      STEP = STEMAX
      IPROC = 103
      CALL GTNEXT
      IF (IGNEXT.NE.0) THEN
         STEP = SNEXT + PREC
         IPROC=0
         INWVOL= 2
         NMEC =  1
         LMEC(1)=1
*
* *** Linear transport
*
         DO 10 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
*                 IF(NMEC.GT.0) THEN
*                    IF(LMEC(NMEC).EQ.32) NMEC=NMEC-1
*                 ENDIF
*                 NMEC=NMEC+1
*                 LMEC(NMEC)=32
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTNINO: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF.
               ENDIF
            ENDIF
            VECT(I) = VECTMP
   10    CONTINUE
      ELSE
         DO 20 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   20    CONTINUE
      ENDIF
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      TOFG = TOFG +STEP/CLIGHT
*
      IF(IPROC.NE.0) THEN
         NMEC=NMEC+1
         LMEC(NMEC)=IPROC
      ENDIF
      END
+DECK,  GTRACK, T=FORT.
* Revision 1.2  1999/11/04 15:26:54  japost
*   Better printing for MAXSTEP
*                                    Suggestion: fca
* Revision 1.1.1.1  1995/10/24 10:21:44  cernlib
* Geant

      SUBROUTINE GTRACK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Controls tracking of current particle,                   *
C.    *        up to end of track for sequential tracking mode, or     *
C.    *        through current volume for parallel tracking mode.      *
C.    *                                                                *
C.    *    ==>Called by : GUTRAK                                       *
C.    *       Authors   : R.Brun, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCPHYS.
+CDE, GCPARM.
+CDE, GCSETS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCNUM.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      DIMENSION CUTS(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      SAVE PRECOR
+SELF, IF=-SINGLE.
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1.E-11)
+SELF.
C.
C.    ------------------------------------------------------------------
      ISTOP = 0
      EPSCUR = EPSMAC
      NSTOUT = 0
      INWOLD = 0
      LSAMVL = .FALSE.
*
* *** Check validity of tracking medium and material parameters
*
   10 IF (NUMED.NE.NUMOLD) THEN
         NUMOLD = NUMED
         IUPD   = 0
         JTM    = LQ(JTMED- NUMED)
         DO 20 I = 1,5
            NATMED(I) = IQ(JTM+I)
   20    CONTINUE
         NMAT     = Q(JTM + 6)
         ISVOL    = Q(JTM + 7)
         IFIELD   = Q(JTM + 8)
         FIELDM   = Q(JTM + 9)
         TMAXFD   = Q(JTM + 10)
         STEMAX   = Q(JTM + 11)
         DEEMAX   = Q(JTM + 12)
         EPSIL    = Q(JTM + 13)
         STMIN    = Q(JTM + 14)
         PRECOR   = MIN(0.1*EPSIL, 0.0010)
         IF (LQ(JTM).EQ.0) THEN
            IF (ISTPAR.NE.0) THEN
               DO 30 I = 1,10
                  CUTS(I) = Q(JTMED+I)
   30          CONTINUE
               DO 40 I = 1,13
                  MECA(1,I) = Q(JTMED+10+I)
   40          CONTINUE
               ILABS = Q(JTMED+10+21)
               ISYNC = Q(JTMED+10+22)
               ISTRA = Q(JTMED+10+23)
               ISTPAR = 0
            ENDIF
         ELSE
            JTMN = LQ(JTM)
            DO 50 I = 1,10
               CUTS(I) = Q(JTMN+I)
   50       CONTINUE
            DO 60 I = 1,13
               MECA(1,I) = Q(JTMN+10+I)
   60       CONTINUE
            ILABS = Q(JTMN+10+21)
            ISYNC = Q(JTMN+10+22)
            ISTRA = Q(JTMN+10+23)
            ISTPAR = 1
         ENDIF
*
         JMA   = LQ(JMATE-NMAT)
         JPROB = LQ(JMA-4)
         JMIXT = LQ(JMA-5)
         DO 70 I = 1,5
            NAMATE(I) = IQ(JMA+I)
   70    CONTINUE
         A    = Q(JMA +6)
         Z    = Q(JMA +7)
         DENS = Q(JMA +8)
         RADL = Q(JMA +9)
         ABSL = Q(JMA +10)
         IF(IQ(JTM-2).GE.3.AND.LQ(JTM-3).NE.0.AND.ITCKOV.NE.0.AND.
     +      LQ(LQ(JTM-3)-3).NE.0.AND.Z.GE.1.) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag.
*
            IMCKOV = 1
         ELSE
            IMCKOV = 0
         ENDIF
*
*
*  **   Update precomputed quantities
*
         IMULL = IMULS
         IF (ILOSS.LE.0) THEN
            DEEMAX = 0.
            ILOSL = 0
         ELSEIF (DEEMAX.GT.0.) THEN
            ILOSL = ILOSS
         ELSE
            ILOSL = 0
         ENDIF
      ENDIF
*
      IF(LSAMVL) THEN
*
*       If now the particle is entering in the same volume where
*       it was exiting from last step, and if it has done this for
*       more than 5 times, we decrease the precision of tracking
         NSTOUT=NSTOUT+1
         IF(MOD(NSTOUT,5).EQ.0) THEN
            EPSCUR=NSTOUT*EPSMAC
*            WRITE(CHMAIL,10000)ITRA,ISTAK,NTMULT,NAPART
*10000          FORMAT(' *** GTRACK *** Boundary loop: track ',
*     +         I4,' stack ',I4,' NTMULT ',I10,1X,5A4)
*            CALL GMAIL(1,0)
*            WRITE (CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
*            CALL GMAIL(0,0)
*            WRITE(CHMAIL,10100) EPSCUR
*10100          FORMAT('                Precision now set to ',G10.3)
*            CALL GMAIL(0,1)
         ENDIF
      ELSE
         NSTOUT = 0
         EPSCUR = EPSMAC
      ENDIF
*
      INWVOL = 1
*
* *** Compute SET and DET number if volume is sensitive
*
      IF (JSET.GT.0) THEN
         IF(ISVOL.GT.0) THEN
            CALL GFINDS
         ELSE
            IHSET = 0
            IHDET = 0
            ISET = 0
            IDET = 0
            IDTYPE = 0
            NVNAME = 0
         ENDIF
      ENDIF
*
*    Clear step dependent variables
*
   80 NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NGPHOT = 0.
      IGNEXT = 0
      INWOLD = INWVOL
      PREC   = MAX(PRECOR,MAX(ABS(VECT(1)),ABS(VECT(2)),
     +                        ABS(VECT(3)),SLENG)*EPSCUR)
*
*     Give control to user at entrance of volume (INWVOL=1)
*
      IF (INWVOL.EQ.1) THEN
+SELF, IF=-USRJMP.
         CALL GUSTEP
+SELF, IF=USRJMP.
         CALL JUMPT0(JUSTEP)
+SELF.
         IF (ISTOP.NE.0) GO TO 999
         INWVOL = 0
      ENDIF
*
* *** Propagate particle up to next volume boundary or end of track
*
      INGOTO = 0
      NLEVIN = NLEVEL
      IF (IPARAM.NE.0) THEN
         IF (GEKIN.LE.PACUTS(ITRTYP)) THEN
            NMEC = NMEC+1
            LMEC(NMEC) = 26
            ISTOP = 2
+SELF, IF=-USRJMP.
            CALL GUPARA
+SELF, IF=USRJMP.
            CALL JUMPT0(JUPARA)
+SELF.
            GO TO 90
         ENDIF
      ENDIF
      IF      (ITRTYP.EQ.1) THEN
         CALL GTGAMA
      ELSE IF (ITRTYP.EQ.2) THEN
         CALL GTELEC
      ELSE IF (ITRTYP.EQ.3) THEN
         CALL GTNEUT
      ELSE IF (ITRTYP.EQ.4) THEN
         CALL GTHADR
      ELSE IF (ITRTYP.EQ.5) THEN
         CALL GTMUON
      ELSE IF (ITRTYP.EQ.6) THEN
         CALL GTNINO
      ELSE IF (ITRTYP.EQ.7) THEN
         CALL GTCKOV
      ELSE IF (ITRTYP.EQ.8) THEN
         CALL GTHION
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(10+ITRTYP)
      STLOSS=STEP
*
*     Check for possible endless loop
*
   90 NSTEP = NSTEP +1
      IF (NSTEP.GT.MAXNST) THEN
         IF (ISTOP.EQ.0) THEN
            ISTOP = 99
            NMEC  = NMEC +1
            LMEC(NMEC) = 30
            WRITE(CHMAIL,10200) MAXNST
            CALL GMAIL(1,0)
            WRITE(CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10300)ITRA,ISTAK,NTMULT,(NAPART(I),I=1,5),
     +      TOFG*1.E9
            CALL GMAIL(0,1)
10200       FORMAT(' *** GTRACK *** More than ',I9,
     +             ' steps, tracking abandoned!')
10250       FORMAT('                IEVENT=',I7,' IDEVT=',I7,
     +             ' Random Seeds = ',I10,2X,I10)
10300       FORMAT('                Track ',I5,' stack ',I5,' NTMULT ',
     +             I7,1X,5A4,1X,'Time of flight ',F10.3,' ns')
         ENDIF
      ENDIF
*
* *** Give control to user at end of each tracking step
*
      SAFETY = SAFETY -STEP
+SELF, IF=-USRJMP.
      CALL GUSTEP
+SELF, IF=USRJMP.
      CALL JUMPT0(JUSTEP)
+SELF.
*
      IF (ISTOP.NE.0) GO TO 999
*
*      Renormalize direction cosines
*
      PMOM = SQRT(VECT(4)**2+VECT(5)**2+VECT(6)**2)
      IF(PMOM.GT.0.) THEN
         CMOD = 1./PMOM
         VECT(4) = VECT(4)*CMOD
         VECT(5) = VECT(5)*CMOD
         VECT(6) = VECT(6)*CMOD
      ENDIF
*
      IF (INWVOL.EQ.0) GO TO 80
*
      IF (NJTMAX.GT.0) THEN
         CALL GSTRAC
         IF (NLEVIN.EQ.0) GO TO 100
         GO TO 999
      ELSE
         IF (NLEVIN.GE.NLEVEL) THEN
            INFROM = 0
         ELSE
            IF (NLEVIN.EQ.0) GO TO 100
            INFROM = LINDEX(NLEVIN+1)
         ENDIF
         IF (NLEVIN.NE.NLEVEL) INGOTO = 0
         NLEVEL = NLEVIN
*
         CALL GTMEDI (VECT, NUMED)
         IF (NUMED.NE.0) THEN
            SAFETY = 0.
            GO TO 10
         ENDIF
      ENDIF
*
*     Track outside setup, give control to user (INWVOL=3)
*
  100 INWVOL = 3
      ISTOP  = 1
      ISET   = 0
      IDET   = 0
      NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NLCUR  = NLEVEL
      NLEVEL = 1
+SELF, IF=-USRJMP.
      CALL GUSTEP
+SELF, IF=USRJMP.
      CALL JUMPT0(JUSTEP)
+SELF.
      NLEVEL = NLCUR
*                                                             END GTRACK
  999 END
+DECK,  GTRAK_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:21:40  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                Introduction to the Tracking package                  *
*                ------------------------------------                  *
*                                                                      *
*                                                                      *
*  THE TRACKING PACKAGE                                                *
*                                                                      *
*  In  the context  of  simulation programs,  'tracking' a  particle   *
* through matter consists of predicting the spatial coordinates of a   *
* set of  points which  define the trajectory  and of  computing the   *
* components  of  the  momentum  at each  point.   This  is  usually   *
* achieved by integrating the  'equations of motion' over successive   *
* steps and applying  corrections when necessary to  account for the   *
* perturbations introduced by the interactions with matter.            *
*  The tracking package contains mainly a subprogram which controls,   *
* and effectively  performs, the transport  of all particles  in the   *
* current  event and  of  the secondary  products  which they  might   *
* possibly generate,  plus some  tools for  storing the  space point   *
* coordinates computed along the corresponding trajectories.           *
*                                                                      *
* THE STEP SIZE                                                        *
*                                                                      *
*  When tracking particles through a complex medium structure one of   *
* the critical tasks is the estimation  'a priori' of the step size.   *
* This is performed automatically by the program.                      *
*  For a particle with given  energy the step size depends primarily   *
* on the properties  of the particle (mass,  charge, lifetime, etc.)   *
* and of  the current medium in  which the particle is  moving.  The   *
* dependence may come either  from (quasi)continuous processes which   *
* usually  impose a  limit to  the interval  of integration  (energy   *
* loss, multiple scattering or bending  in magnetic field) or to the   *
* occurence of  a discrete process which  introduces a discontinuity   *
* in   the   trajectory    (decay,   electromagnetic   or   hadronic   *
* interaction).   In addition  to these  physical effects  there are   *
* constraints of a geometrical nature, the step being limited by the   *
* path length to the medium boundary.                                  *
*  In  practice,  the step  size  depends  ultimately  on a  set  of   *
* tolerances and cuts which should be  optimized by the user for the   *
* given application, such as:                                          *
*                                                                      *
* - the maximum bending angle due to magnetic field permitted in one   *
*   step,                                                              *
* - the maximum fractional energy loss in one step,                    *
* - the  maximum  step size  permitted  by  the multiple  scattering   *
*   theory used                                                        *
* - the accuracy for crossing medium boundaries and                    *
* - the absolute maximum step allowed                                  *
*                                                                      *
*  The limitations imposed  by the first three  processes could lead   *
* to extremely small steps for low energy particles.  To avoid this,   *
* in  GEANT has  been introduced  a minimum  step due  to continuous   *
* processes.   This represent  a lower  bound for  the maximum  step   *
* which is very important for keeping  the time taken to develop and   *
* follow a shower within reasonable limits.                            *
*                                                                      *
*  These  quantities are  part of  the so  called 'tracking  medium'   *
* parameters.  They  are usually calculated automatically  by GEANT,   *
* but may be provided by the user to be stored in the data structure   *
* JTMED, through the  routine GSTMED [CONS].  Usually,  this is done   *
* together with the initialisation  of the geometrical setup.  Users   *
* are  suggested   to  begin  their  simulations   with  the  values   *
* calculated by GEANT.   The optimisation is by no  means trivial as   *
* the economy of  computing time should not lead  to an unacceptable   *
* loss of accuracy.                                                    *
*  Other  general information  required for  the computation  of the   *
* step size is expected to be available in the data structures JPART   *
* and  JMATE,  for  the  properties  of the  particles  and  of  the   *
* materials,  and in  the  data structure  JVOLUM,  for the  current   *
* medium and its geometrical  boundaries.  The communication between   *
* the tracking package and the  structure JVOLUM is achieved through   *
* the  basic subroutines  of the  geometry package  GMEDIA (GTMEDI),   *
* GNEXT (GTNEXT) and GINVOL [GEOM,GTRAK]                               *
*  Some additional information is computed  at tracking time such as   *
* the probability  of occurence of an  interaction.  For convenience   *
* every particle is assigned a 'tracking  type', 1 for the gammas, 2   *
* for the  electrons and positrons,  3 for the neutral  hadrons (and   *
* neutrinos!), 4 for the charged hadrons and 5 for the muons.  Which   *
* physics processes  have potentially to  be considered for  a given   *
* particle depends on its tracking type.  For the hadrons it depends   *
* also, through  the subroutine GUPHAD, on  which hadronic processes   *
* have been selected (GHEISHA is the default) [PHYS 001].              *
*                                                                      *
* THE SUBROUTINES GTREVE and  GTRACK                                   *
*                                                                      *
*  At  event level  the  tracking is  controlled  by the  subroutine   *
* GTREVE called by  the subroutine GUTREV where the user  is free to   *
* take any other action.  GTREVE  loops over all vertices and stores   *
* all tracks  from the current vertex  in the stack JSTAK,  then for   *
* each  one  in  turn,  calls  GLTRAC to  prepare  the  commons  for   *
* tracking,  and starts  tracking through  a call  to GUTRAK,  which   *
* calls GTRACK.                                                        *
*  The subroutine GTRACK  tracks the particle up to the  end : stop,   *
* decay, interaction  or escape.   During this  phase it  may happen   *
* that secondary products  are generated and stored by  the user, as   *
* explained  below, in  the stack, and if  wanted, in  the permanent   *
* structure JKINE.                                                     *
*  The subroutine GTRACK loops over  all geometrical volumes seen by   *
* the  current  track,  first identifying,  through  the  subroutine   *
* GTMEDI, the new volume which  the particle has reached and storing   *
* the corresponding  material and  tracking medium constants  in the   *
* common blocks /GCMATE/ and /GCTMED/; the tracking is controlled by   *
* the  type-dependent  routines  GTELEC,GTGAMA,GTHADR,GTMUON,GTNEUT.   *
* These compute  the physical step  size according to  the activated   *
* physics processes, and compute the geometrical limit for the step,   *
* only when  necessary, through  GTNEXT, and propagate  the particle   *
* over the computed step.                                              *
*                                                                      *
* MAGNETIC FIELD ROUTINES                                              *
*                                                                      *
*  As mentioned before,  the effective propagation of the particles is *
* controlled by the routines GTGAMA, GTELEC, etc., which call GUSWIM.  *
* Depending on the  value chosen by the user for  the tracking medium  *
* parameter IFIELD the routine GUSWIM calls either                     *
*                                                                      *
* GRKUTA    for inhomogeneous fields, IFIELD=1                         *
* GHELIX    for quasi-homogeneous fields tilted w.r.t. the reference   *
*           frame, IFIELD=2, or                                        *
* GHELX3    for one-component fields along the z axis, IFIELD=3        *
*                                                                      *
*  GRKUTA and  GHELIX call the  default user subroutine  GUFLD where   *
* the  components of  the field  at  the given  point are  computed.   *
* GHELX3  takes  the value  of  the  field  in the  tracking  medium   *
* parameter FIELDM.                                                    *
*                                                                      *
* INFORMATION AVAILABLE AT TRACKING TIME, AND THE SUBROUTINE GUSTEP    *
*                                                                      *
*  At any  moment the  current track parameters  are available  in the *
* common block  /GCTRAK/ as well  as all  variables which have  to be  *
* preserved by  the tracking  routines for  the control  of the  step  *
* size.  In  addition a  few flags  and variables  are stored  in the  *
* common block /GCTRAK/ to record the history of the current step:     *
*                                                                      *
* INWVOL    is initialized  to 1 when  entering a new volume,  it is   *
*           set to  0 for all steps  inside the volume, to  2 if the   *
*           particle has reached  the volume boundary and  to 3 when   *
*           the particle is leaving the experimental setup.            *
* ISTOP     is initialized to 0 and set  to 1 if the particle looses   *
*           its identity or to 2 if it stops.                          *
*                                                                      *
*  The effect  which is responsible  for the limitation of  the step   *
* size as well as the corrective  effects which have been applied at   *
* the end of the step, if any,  are recorded in the first NMEC words   *
* of the mechanism vector LMEC and this is most useful to understand   *
* and debug the program.                                               *
*  The  total energy  loss for  the current  step is  stored in  the   *
* variable DESTEP, and the continuous energy loss in DESTEL.           *
*  This information  is necessary  for the user  to take  the proper   *
* actions in the subroutine GUSTEP which  is called by GTRACK at the   *
* end of every step.                                                   *
*  In addition, the  number NGKINE of secondary  products which have   *
* possibly been  generated and  their characteristics are  stored in   *
* the common  block /GCKING/ together with  an identification (array   *
* LMEC)  of   which  process  is  responsible.    Depending  on  the   *
* application  and on  the particle  type,  the user  may decide  in   *
* GUSTEP through the routine GSKING,                                   *
*                                                                      *
* - to discard the newly produced secondaries                          *
* - to  enter them  in  the  temporary JSTAK  data  structure to  be   *
*   tracked                                                            *
* - to  store them  in  the  permanent JKINE  data  structure to  be   *
*   tracked                                                            *
*                                                                      *
* CONNECTION WITH THE DETECTOR RESPONSE PACKAGE                        *
*                                                                      *
*  The loop over the volumes in  GTRACK makes the interface with the   *
* detector response  package simple [HITS].  By  construction of the   *
* geometrical setup  there is  a correspondance between  the volumes   *
* seen by  the particle and  the components of the  detectors.  When   *
* entering a new volume (in GTRACK) the subroutine GFINDS is called.   *
* If  the volume  has  been  declared by  the  user  as a  sensitive   *
* detector   through  appropriate   calls  to   GSDET  and   if  the   *
* corresponding tracking  medium constant ISVOL is  non zero, GFINDS   *
* returns in the  common block /GCSETS/ the  information to identify   *
* uniquely the detector component.  This  enables the user in GUSTEP   *
* to  record the  hits  properly  as well  as  the energy  deposited   *
* [HITS].                                                              *
*                                                                      *
* CONNECTION WITH THE DRAWING PACKAGE                                  *
*                                                                      *
*  The coordinates of the space points generated during the tracking   *
* are  available at  each step  in  the common  block /GCTRAK/.   In   *
* GUSTEP the user can store them in the structure JXYZ with the help   *
* of the subroutine  GSXYZ.  This information can be  used later for   *
* debug (subroutine  GPCXYZ) or for the  graphical representation of   *
* the trajectories [DRAW].                                             *
*                                                                      *
************************************************************************
#endif
+DECK,  GTREVE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:45  cernlib
* Geant

      SUBROUTINE GTREVE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GTREVE                                                *
C.    *                                                                *
C.    *   Controls tracking of all particles belonging to the current  *
C.    *    event.                                                      *
C.    *                                                                *
C.    *   Called by : GUTREV, called by GTRIG                          *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCNUM.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCUNIT.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
+CDE, GCVDMA.
      REAL UBUF(2)
      EQUIVALENCE (UBUF(1),WS(1))
      LOGICAL   BTEST
C.
C.    ------------------------------------------------------------------
      NTMSTO = 0
      NSTMAX = 0
      NALIVE = 0
*
      NV = NVERTX
      DO 290 IV = 1,NV
*
* ***   For each vertex in turn ..
*
         JV = LQ(JVERTX-IV)
         NT = Q(JV+7)
         IF (NT.LE.0) GO TO 290
         TOFG   = Q(JV+4)
         SAFETY = 0.
         IF (NJTMAX.GT.0) THEN
            CALL GMEDIA (Q(JV+1), NUMED)
            IF (NUMED.EQ.0) THEN
               WRITE (CHMAIL, 1001) (Q(JV+I), I=1,3)
               CALL GMAIL (0, 0)
               GO TO 290
            ENDIF
            CALL GLSKLT
         ENDIF
*
*  **   Loop over tracks attached to current vertex
*
         DO 190 IT = 1,NT
            JV   = LQ(JVERTX-IV)
            ITRA = Q(JV+7+IT)
            IF (BTEST(IQ(LQ(JKINE-ITRA)),0)) GO TO 190
            CALL GFKINE (ITRA, VERT, PVERT, IPART, IVERT, UBUF, NWBUF)
            IF (IVERT.NE.IV) THEN
               WRITE (CHMAIL, 1002) IV, IVERT
               CALL GMAIL (0, 0)
               GO TO 999
            ENDIF
*
*   *      Store current track parameters in stack JSTAK
*
            CALL GSSTAK (2)
  190    CONTINUE
*
*  **   Start tracking phase
*
  210    IF (NALIVE.NE.0) THEN
            NALIVE = NALIVE -1
*
*   *      Pick-up next track in stack JSTAK, if any
*
            IF (IQ(JSTAK+1).GT.0) THEN
*
*   *         Initialize tracking parameters
*
               CALL GLTRAC
               IF (NUMED.EQ.0) GO TO 210
            ELSE
*
*   *         otherwise, select next track segment from stack JTRACK
*
               CALL GFTRAC
*
            ENDIF
*
*   *       Resume tracking
*
            IF(RAYTRA.EQ.1.)THEN
+SELF, IF=HIGZ.
              CALL GDRACK
+SELF.
            ELSE
+SELF, IF=-USRJMP.
              CALL GUTRAK
+SELF, IF=USRJMP.
              CALL JUMPT0(JUTRAK)
+SELF.
            ENDIF
            IF (IEOTRI.NE.0) GO TO 999
            GO TO 210
         ENDIF
*
  290 CONTINUE
*
 1001 FORMAT (' GTREVE : Vertex outside setup, XYZ=',3G12.4)
 1002 FORMAT (' GTREVE : Abnormal track/vertex connection',2I8)
*                                                             END GTREVE
  999 END

+PATCH, GSTRAG.
+DECK,  GASHO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:37  cernlib
* Geant

+SELF, IF=ASHO.
      SUBROUTINE GASHO(P,XXMASS,GSTEP,DE)
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCCUTS.
+CDE, GCMATE.
+CDE, GCASHO.
C-----------------------------------------------------------------------
C      ASHO model for energy loss straggling
C      The main subprograms are:
C      - MIXMGO - prepares the parameters of a mixture
C          or compound used (called from GIASHO);
C      - GOSCMG - prepares the parameters of the oscillators;
C      - GDIFMG - calculates the differential spectrum of the
C          energy loss;
C      The main initial data bank is in COMMON block GCASHO contai-
C      ning the parameters of a number of elements.
C-----------------------------------------------------------------------
C      Update history: 16-8-93
C
C-----------------------------------------------------------------------
C      The main initial common block and its components.
C      NELM - number of basic elements;
C      ZELM - atomic numbers of the elements;
C      AELM - atomic weights of the elements;
C      DELM - densities of the elements (g/cm3);
C      E0ELM - ionization potentials of the elements (keV);
C      NSELM - numbers of the electron shells in the atoms;
C      ZSELM - numbers of electrons in each of the shells;
C      ESELM - binding energies of the shell electrons (keV).
C       This information may be included in JMATE by GSMATE or GMATE.
C      *)   The density values for gases are given at
C           0 C 1 atm. Those for solids are not precise and
C           should be substituted for particular
C           samples used.
C      **)  The current number of the elements used is equal to 16.
C      ***) To change the energy scale from keV to GeV, as it is
C           used in GEANT, it is needed to add 1.E-6 to E0ELM, ESELM,
C           PLASM, TRNSMA, 6. (in RESMGO), SL (in REAMGO), SL (in
C           SLDMGO) and extract 1.E-6 in DE (in DELMGO).
C-----------------------------------------------------------------------
C      GCASHO contains also the kinematical parame-
C      ters as well as some thermodynamical ones:
C      PLIN (P/mc), PLOG (log10(PLIN)), BE2 (velocity/c squared),
C      the path length STEP of the particle,
C      and the medium plasma energy
C      PLASM. TRNSMA is the maximum transferable energy (now
C      it is set to correspond to TCUT in GEANT !).
C      In GEANT the initial parameters are P, E, XMASS, STEP
C      and DENSIT.
C-----------------------------------------------------------------------
C      In addition, it contains the parameters of the oscillators:
C      - BOSC is the array of "ksi/I",
C      - AOSC is the array of "lnA",
C      - NOSC is the number of the oscillators,
C      - EOSC is the array of the oscillator energies,
C      - IOSC is the upper array in integers,
C      - ZOSC is the array of the oscillator weights,
C      - EMEAN is the mean energy loss.
C-----------------------------------------------------------------------
C      Finally, GCASHO contains the parameters of the energy loss
C      distribution:
C      - CMGO is the differential or integral distribution coeff.,
C      - NMGO is the number of bins,
C      - NMGOMA is the maximum of possible NMGO,
C      - EMGO is the energy corresponding to one bin,
C      - EMGOMI is the energy corresponding to 0th bin.
C-----------------------------------------------------------------------
      PARAMETER (DNMGOM=2000)
C-----------------------------------------------------------------------
      JASHO = LQ(JMA-20)
      NSMED = Q(JASHO+1)
      ZMED  = Q(JASHO+2)
      AMED  = Q(JASHO+3)
      ALFA  = Q(JASHO+4)
      E0MED = Q(JASHO+5)
      DO 10 KMED=1,NSMED
         ZSMED(KMED) = Q(JASHO+5+KMED)
         ESMED(KMED) = Q(JASHO+5+NSMED+KMED)
   10 CONTINUE
      PLASM = 0.028817*SQRT((ZMED/AMED)*DENS)
      STEP  = GSTEP
      NMGOMA = DNMGOM
C-----------------------------------------------------------------------
C      In GEANT the initial kinematic parameters : P, E, XMASS.
C      The following gets the kinematic parameters of the particle:
C      PLIN (P/mc), PLOG (lg(PLIN)), BE2 (velocity/c squared) and
C      its path length STEP.
C-----------------------------------------------------------------------
      PLIN = P/XXMASS
      PLOG = LOG10(PLIN)
      BE2 = PLIN**2/(1.+PLIN**2)
C-----------------------------------------------------------------------
C      Now we set TRNSMA to correspond to TCUT in GEANT.
C-----------------------------------------------------------------------
      TRNSMA = DCUTE*1E6
C-----------------------------------------------------------------------
C      Here is the calculation of the parameters of the oscillators
C-----------------------------------------------------------------------
      CALL GOSCMG
C-----------------------------------------------------------------------
C      Here is the calculation of the diffrential distribution
C-----------------------------------------------------------------------
      CALL GDIFMG(DE)
      DE = 1E-6*DE
C-----------------------------------------------------------------------
      END
+SELF.
+DECK,  GDIFMG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:37  cernlib
* Geant

+SELF, IF=ASHO.
      SUBROUTINE GDIFMG(DEL)

+CDE, GCCUTS.
+CDE, GCASHO.
C-----------------------------------------------------------------------
C      This program calculates the final distribution coef-
C      ficients until the integral S is more or equal to L2.
C      In case of S < L2 or miscalculations due to FORTRAN
C      limits DONE = FALSE.
C-----------------------------------------------------------------------
C      Update history: 10-08-93
C
C-----------------------------------------------------------------------
      REAL BN(50),BNA(50),L2
      INTEGER FLMAX
      PARAMETER (DL2=.1)
      DATA CORMAX/80./
C-----------------------------------------------------------------------
C      Initialization steps
C-----------------------------------------------------------------------
      XX = 0.
      Z = 1.
      DO 10 K=1,NOSC
         BN(K) = BOSC(K)*IOSC(K)
         BNA(K) = BN(K)*(AOSC(K) - 1.)
         XX = XX + AOSC(K)*BOSC(K)
   10 CONTINUE
C
      FLMAX = 0
      CORR = CORMAX - XX
      CMGO(1) = EXP(-CORMAX)
      CMGO(2) = CMGO(1)*BNA(1)
      Z = Z-(CMGO(1)+CMGO(2))*EXP(CORR)
C-----------------------------------------------------------------------
C      Calculation of the current Ci
C-----------------------------------------------------------------------
      CALL GRNDM(RNDM,1)

      L2 = DL2
      IF (RNDM.GE.L2) THEN
         L2 = RNDM
         FLMAX = 1
      ENDIF
      DO 40 NMGO=3,NMGOMA
         CMGO(NMGO) = CMGO(NMGO - 1)*BNA(1)
         DO 30 J = 1,NMGO - 2
            M = NMGO - 1 - J
            X = BOSC(1)/J
            DO 20 K=2,NOSC
               IF(MOD(J+1,IOSC(K)).EQ.0) THEN
                  L = (J+1)/IOSC(K)
                  IF(L.EQ.1) THEN
                     X = X + BNA(K)
                  ELSE
                     X = X + BN(K)/(L-1)
                  ENDIF
               ENDIF
   20       CONTINUE
            CMGO(NMGO) = CMGO(NMGO) + X*CMGO(M)
   30    CONTINUE
         CMGO(NMGO) = CMGO(NMGO)/(NMGO-1)
         Z = Z - CMGO(NMGO)*EXP(CORR)
         IF (Z.LE.L2) GOTO 50
   40 CONTINUE

   50 IF (FLMAX.EQ.1) THEN
         DEL = (NMGO-1)*EOSC(1)
      ELSE
         DEL = (NMGO-1)*EOSC(1)*L2/RNDM
      ENDIF
      IF (DEL.GE.DCUTE*1E6) DEL = DCUTE*1E6

      END
+SELF.
+DECK,  GIASHO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:37  cernlib
* Geant

+SELF, IF=ASHO.
      SUBROUTINE GIASHO
+CDE, GCBANK.
+CDE, GCMATE.
      DIMENSION E0ELM(100),NSELM(100)
      DIMENSION ZSELM(7,100),ESELM(7,100)
      DATA E0ELM /
     + 0.0204,0.0385,3*0.,0.0738,0.0978,0.1157,0.1248,0.1338,
     + 3*0.,0.1745,0.1791,2*0.,0.1816,12*0.,0.3018,0.2806,
     + 0.2906,2*0.,0.3408,12*0.,0.4823,4*0.,0.5088,46*0. /
      DATA NSELM /
     + 1,1,3*0,2,2,2,2,2,3*0,3,3,2*0,3,12*0,4,4,4,2*0,4,12*0,
     + 5,4*0,5,46*0/
      DATA ZSELM /
     + 1.,0.,0.,0.,0.,0.,0.,2.,0.,0.,0.,0.,0.,0.,21*0.,
     + 4.,2.,0.,0.,0.,0.,0.,5.,2.,0.,0.,0.,0.,0.,
     + 6.,2.,0.,0.,0.,0.,0.,7.,2.,0.,0.,0.,0.,0.,
     + 8.,2.,0.,0.,0.,0.,0.,21*0.,
     + 4.,8.,2.,0.,0.,0.,0.,5.,8.,2.,0.,0.,0.,0.,14*0.,
     + 8.,8.,2.,0.,0.,0.,0.,84*0.,
     + 3.,18.,8.,2.,0.,0.,0.,4.,18.,8.,2.,0.,0.,0.,
     + 5.,18.,8.,2.,0.,0.,0.,14*0.,
     + 8.,18.,8.,2.,0.,0.,0.,84*0.,
     + 5.,18.,16.,8.,2.,0.,0.,28*0.,
     + 8.,18.,18.,8.,2.,0.,0.,322*0./
*23456789_123456789_123456789_123456789_123456789_123456789_123456789_12
      DATA ESELM / 0.01360,0.,0.,0.,0.,0.,0.,0.02459,0.,0.,0.,0.,0.,0.,
     +21*0., 0.01367,0.288,0.,0.,0.,0.,0.,0.01662,0.4030,0.,0.,0.,0.,
     +0., 0.01742,0.5380,0.,0.,0.,0.,0.,0.02174,0.6940,0.,0.,0.,0.,0.,
     +0.02643,0.8701,0.,0.,0.,0.,0.,21*0., .01047,.1147,1.844,0.,0.,0.,
     +0.,.01247,.1467,2.148,0.,0.,0.,0., 14*0.,0.01845,0.2666,3.206,0.,
     +0.,0.,0.,84*0., 0.00899,0.04480,1.169,10.37,0.,0.,0., 0.01063,
     +0.06190,1.274,11.11,0.,0.,0., 0.01291,0.07953,1.384,11.87,0.,0.,
     +0.,14*0., 0.01676,0.1412,1.750,14.33,0.,0.,0.,84*0., 0.00720,
     +0.04012,0.5682,3.908,27.93,0.,0.,28*0., 0.01466,0.1006,0.8097,
     +5.030,34.570,0.,0.,322*0./
*
*-----------------------------------------------------------------------
*
      DIMENSION ZSMED(50),ESMED(50)
C-----------------------------------------------------------------------
C
      JMA   = LQ(JMATE-NMAT)
      JMIXT = LQ(JMA-5)
      NCOMP = ABS(Q(JMA+11))
      AMED = 0.
      ZMED = 0.
      E0CAL = 0.   !Sum of Z(i)*log(I(i))
      E0MED = 0.
      NSMED = 0

      DO 20 I = 1,NCOMP
         IF(NCOMP.GT.1) THEN
            IZ = Q(JMIXT+NCOMP+I)+0.5
            WEIGHT = Q(JMIXT+2*NCOMP+I)/Q(JMIXT+I)
            E0MED = E0MED + Q(JMIXT+NCOMP+I)*WEIGHT*LOG(E0ELM(IZ))
            ZMED = ZMED + Q(JMIXT+NCOMP+I)*WEIGHT
            AMED = AMED + Q(JMIXT+I)*WEIGHT
         ELSE
            IZ = Z+0.5
            E0MED = E0ELM(IZ)
            ZMED = Z
            AMED = A
         ENDIF
         DO 10 J = 1,NSELM(IZ)
            NSMED = NSMED + 1
            IF(NCOMP.GT.1) THEN
               ZSMED(NSMED) = ZSELM(J,IZ)*WEIGHT
            ELSE
               ZSMED(NSMED) = ZSELM(J,IZ)
            ENDIF
            ESMED(NSMED) = ESELM(J,IZ)
            E0CAL = E0CAL + ZSMED(NSMED)*LOG(ESELM(J,IZ))
   10    CONTINUE
   20 CONTINUE
      IF (NCOMP.GT.1) E0MED = EXP(E0MED/ZMED)
      E0CAL = EXP(E0CAL/ZMED)
      ALFA = E0MED/E0CAL
C-----------------------------------------------------------------------
C      The following sets ZSMED and ESMED in the order of increase
C      of ESMED.
C-----------------------------------------------------------------------
      DO 40 I = 1,NSMED - 1
         IMIN = I
         EMIN = ESMED(I)
         DO 30 J = I + 1,NSMED
            IF (EMIN.LE.ESMED(J)) GOTO 30
            EMIN = ESMED(J)
            IMIN = J
   30    CONTINUE
         IF (I.EQ.IMIN) GOTO 40
         X = ESMED(I)
         Y = ZSMED(I)
         ESMED(I) = ESMED(IMIN)
         ZSMED(I) = ZSMED(IMIN)
         ESMED(IMIN) = X
         ZSMED(IMIN) = Y
   40 CONTINUE
C-----------------------------------------------------------------------
C      The following combines the first smallest oscillators whose
C      integer relative potentials are equal to 1.
C-----------------------------------------------------------------------
      ZMIN = 0.
      EMIN = 0.
      IMIN = 1
      DO 50 I = 1,NSMED
         J = ESMED(I)/ESMED(1) + 0.5
         IF (J.GT.1) GOTO 60
         ZMIN = ZMIN + ZSMED(I)
         EMIN = EMIN + ZSMED(I)*LOG(ESMED(I))
         IMIN = I
   50 CONTINUE
   60 ESMED(1) = EXP(EMIN/ZMIN)
      ZSMED(1)        = ZMIN
      DO 70 I = IMIN + 1,NSMED
         ZSMED(I - IMIN + 1) = ZSMED(I)
         ESMED(I - IMIN + 1) = ESMED(I)
   70 CONTINUE
      NSMED = NSMED - IMIN + 1
      JASHO = LQ(JMA-20)
*
* *** Store parameters of ASHO in material bank 20
      Q(JASHO+1) = NSMED
      Q(JASHO+2) = ZMED
      Q(JASHO+3) = AMED
      Q(JASHO+4) = ALFA
      Q(JASHO+5) = E0MED
      DO 80 KMED=1,NSMED
         Q(JASHO+5+KMED) = ZSMED(KMED)
         Q(JASHO+5+NSMED+KMED) = ESMED(KMED)
   80 CONTINUE
      NLEFT = 2*NSMED - 100
      CALL MZPUSH(IXCONS,JASHO,0,NLEFT,'I')
      END
+SELF.
+DECK,  GKOKRI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:37  cernlib
* Geant

      FUNCTION GKOKRI(E,EMINEV,EMAXEV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Input energy in eV, Sandia tables in keV                   *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GC10EV.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION EINV,ECUR,ONE,RES,ZERO,EBEG,EEND
      DOUBLE PRECISION ALPH,BETA,GAMM,E1,E2,GPSCIN,POLE
      DOUBLE PRECISION EMAX,EMIN,REST
+SELF.
      PARAMETER (ONE=1,ZERO=0)
C.
C.    ------------------------------------------------------------------
C.
      REST   = ZERO
      EMAX   = EMAXEV*1E-3
      EMIN   = EMINEV*1E-3
      ECUR   = E*1E-3
      EINV   = ONE/ECUR
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      NZ     = Q(JPHXS+1)
      JWEIGH = JPHXS+1+2*NZ
      DO 30 JZ=1,NZ
         RES    = ZERO
         EBEG   = EMIN
         WEIGHT = Q(JWEIGH+JZ)
         JPHFN  = LQ(JPHXS-JZ)
         IPOINT = JPHFN+1
         IMAX   = Q(IPOINT)
         IPOINT = IPOINT-4
         DO 10 I = 1,IMAX
            IPOINT = IPOINT+5
            EEND   = Q(IPOINT)
            IF(EEND.GT.EMIN) THEN
               E1     = MAX(EBEG,EMIN)
               E2     = MIN(EEND,EMAX)
               J      = IPOINT+1
               IF(ECUR.LE.E2.AND.ECUR.GE.E1) THEN
*
* *** The pole of the integration is in this interval
                  EPS1 = (ECUR-EBEG)/ECUR
                  EPS2 = (EEND-ECUR)/EEND
                  IF(EPS1.LT.EPS2) THEN
*
* *** First the pole and then a simple integration
                     ALPH = ONE-EPS1
                     E1 = ECUR/ALPH
                     E2 = EEND
                  ELSE
*
* *** First a simple integration and then the pole
                     ALPH = ONE-EPS2
                     E1 = EBEG
                     E2 = ECUR*ALPH
                  ENDIF
                  BETA = -LOG(ALPH)
                  GAMM = ONE/ALPH
                  POLE = EINV*(Q(J)*BETA+EINV*( Q(J+1)*(GAMM-ALPH)+
     +            EINV*( Q(J+2)*(0.5*GAMM**2+BETA-0.5*ALPH**2)+EINV*
     +            Q(J+3)*(GAMM**3/3+GAMM-ALPH-ALPH**3/3))))
                  RES = RES - POLE
               ENDIF
*
* *** This is a normal integration
               RES = RES + GPSCIN(E1,E2,ECUR,Q(J))
            ENDIF
            EBEG = EEND
            IF(EBEG.GE.EMAX) GO TO 20
   10    CONTINUE
   20    REST = REST+WEIGHT*RES
   30 CONTINUE
C RES value is in cm**2/(g keV)
      GKOKRI = REST*1E-6*A/AVO
C Now in Megabarns/eV
C
      END
+DECK,  GOSCIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:38  cernlib
* Geant

      FUNCTION GOSCIN(EIN1EV,EIN2EV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Input energy in eV, Sandia tables in keV                   *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GC10EV.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION ONE,RES,ZERO,EIN1,EIN2,REST,EBEG,EEND
      DOUBLE PRECISION E1IN,E2IN,TWO,THREE,C1,C2,C3,C4
+SELF.
      PARAMETER (ZERO=0,ONE=1,TWO=2,THREE=3)
C.
C.    ------------------------------------------------------------------
C.
      REST   = ZERO
      EIN1   = EIN1EV*1E-3
      EIN2   = EIN2EV*1E-3
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      NZ     = Q(JPHXS+1)
      JWEIGH = JPHXS+1+2*NZ
      DO 30 JZ=1,NZ
         RES    = ZERO
         EBEG   = TENEV
         WEIGHT = Q(JWEIGH+JZ)
         JPHFN  = LQ(JPHXS-JZ)
         IPOINT = JPHFN+1
         IMAX   = Q(IPOINT)
         IPOINT = IPOINT-4
         DO 10 I = 1,IMAX
            IPOINT = IPOINT+5
            EEND   = Q(IPOINT)
            IF(EIN2.GT.EBEG.AND.EIN1.LT.EEND) THEN
               E1IN  = ONE/MAX(EBEG,EIN1)
               E2IN  = ONE/MIN(EEND,EIN2)
               J     = IPOINT+1
               C1    = -Q(J  )
               C2    = -Q(J+1)
               C3    = -Q(J+2)/TWO
               C4    = -Q(J+3)/THREE
               RES   = RES
     +         +C1*LOG(E2IN)+E2IN*(C2+E2IN*(C3+E2IN*C4))
     +         -C1*LOG(E1IN)-E1IN*(C2+E1IN*(C3+E1IN*C4))
            ENDIF
            EBEG = EEND
   10    CONTINUE
   20    REST = REST+WEIGHT*RES
   30 CONTINUE
C RES value is in cm**2/(g keV)
      GOSCIN = REST*1E-3*A/AVO
C Now in Megabarns/eV
C
      END
+DECK,  GOSCMG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:38  cernlib
* Geant

+SELF, IF=ASHO.
C
      SUBROUTINE GOSCMG

+CDE, GCMATE.
+CDE, GCASHO.
C-----------------------------------------------------------------------
C      This program calculates the parameters of the oscillators.
C      The input data are in the GCASHO. The lowest poten-
C      tials are convoluted to escape unreasonably high accuracy.
C-----------------------------------------------------------------------
C      Update history: 10-8-93
C
C-----------------------------------------------------------------------
      REAL KSI0
      PARAMETER (ENERR=0.02,TWOELM=2*511)
C-----------------------------------------------------------------------
C      Convolution of the first shells
C-----------------------------------------------------------------------
      C1 = 153.6*STEP*DENS/(BE2*AMED)
      C2 = 2.*LOG(PLIN)-BE2
      KSI0 = C1*ZMED
      X = 2.*LOG(E0MED/PLASM) + 1.
      CALL GSTCOR(X,E0MED,PLOG,DENS,D)
      A0 = LOG(TWOELM*TRNSMA/E0MED**2)+C2-D
      EMEAN = KSI0*A0
      DO 10 I = 1,NSMED
         IF (ESMED(I).GT.EMEAN*ENERR/ALFA) GOTO 20
   10 CONTINUE
   20 J = MAX(I - 1,1)
      S1 = 0.
      Z1 = 0.
      DO 30 I = 1,J
         S1 = S1 + LOG(ESMED(I))*ZSMED(I)
         Z1 = Z1 + ZSMED(I)
   30 CONTINUE
      S1  = EXP(S1/Z1)
      NOSC = NSMED - J + 1
      DO 40 I = 2,NOSC
         X = ESMED(I + J - 1)/S1
         IOSC(I) = X + 0.5
         EOSC(I) = S1*IOSC(I)*ALFA
         ZOSC(I) = ZSMED(I + J - 1)
   40 CONTINUE
      EOSC(1) = S1*ALFA
      IOSC(1) = 1
      ZOSC(1) = Z1
C-----------------------------------------------------------------------
C      Calculation of the oscillator parameters
C-----------------------------------------------------------------------
      C3 = C2 + 0.423
      DO 50 I = 1,NOSC
         X = C1*ZOSC(I)
         BOSC(I) = X/EOSC(I)
         X = 2.*LOG(EOSC(I)/PLASM)+1.
         CALL GSTCOR(X,EOSC(I),PLOG,DENS,D)
         AOSC(I) = LOG(TWOELM/EOSC(I)) +C3 -D
   50 CONTINUE
      END
+SELF.
+DECK,  GPSCIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:38  cernlib
* Geant

      FUNCTION GPSCIN(EBEG,EEND,ECUR,COEFF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+SELF.
      REAL COEFF(4)
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      YBEG = EBEG/ECUR
      YEND = EEND/ECUR
      YBEGIN = ONE/YBEG
      YENDIN = ONE/YEND
*
      EINV = ONE/ECUR
      C1 = COEFF(1)*EINV
      C2 = COEFF(2)*EINV**2
      C3 = COEFF(3)*EINV**3
      C4 = COEFF(4)*EINV**4
*
      CONS1 = 0.5*(C1+C3)
      CONS2 = C2+C4
      CONS3 = 0.5*CONS2
      CONS4 = 0.5*C3
      CONS5 = C4/3
*
*     VALBEG = CONS1*F1(YBEG)+CONS3*F2(YBEG)+
*    +         YBEGIN*(CONS2+YBEGIN*(CONS4+YBEGIN*CONS5))
*     VALEND = CONS1*F1(YEND)+CONS3*F2(YEND)+
*    +         YENDIN*(CONS2+YENDIN*(CONS4+YENDIN*CONS5))
*
*     GPSCIN = VALEND-VALBEG
      GPSCIN =
     +      CONS1*LOG(ABS((YEND**2-1)*YBEG**2/((YBEG**2-1)*YEND**2)))+
     +      CONS2*(YENDIN-YBEGIN)+
     +      CONS3*LOG(ABS((1-YEND)*(1+YBEG)/((1-YBEG)*(1+YEND))))+
     +      CONS4*(YENDIN**2-YBEGIN**2)+CONS5*(YENDIN**3-YBEGIN**3)
*
      END
+DECK,  GSTCOR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      SUBROUTINE GSTCOR(CC,POT,X,DENS,DELTA)

C.
C.    *****************************************************************
C.    *                                                               *
C.    *      Sternheimer correction as computed in GDRELX             *
C.    *                                                               *
C.    *    ==>Called by :                                             *
C.    *       Author    L.Urban    *********                          *
C.    *                                                               *
C.    *****************************************************************
*
*         condensed material ? ( dens .gt. 0.05 ? )
      IF(DENS.GT.0.05) THEN
*        IF(POT.LT.1.E-7) THEN   (POT was in GeV, now in keV)
         IF(POT.LT.0.1) THEN
            IF(CC.LT.3.681) THEN
               X0=0.2
            ELSE
               X0=0.326*CC-1.
            ENDIF
            X1=2.
         ELSE
            IF(CC.LT.5.215) THEN
               X0=0.2
            ELSE
               X0=0.326*CC-1.5
            ENDIF
            X1=3.
         ENDIF
*         gas ?   ( dens . le . 0.05 ? )
      ELSE
         IF(CC.LE.12.25) THEN
            IP=INT((CC-10.)/0.5)+1
            IF(IP.LT.0) IP=0
            IF(IP.GT.4) IP=4
            X0=1.6+0.1*FLOAT(IP)
            X1=4.
         ELSE
            IF(CC.LE.13.804) THEN
               X0=2.
               X1=5.
            ELSE
               X0=0.326*CC-2.5
               X1=5.
            ENDIF
         ENDIF
      ENDIF
*
      XA=CC/4.606
      XM=3.
      AA=4.606*(XA-X0)/(X1-X0)**XM
*
      DELTA=0.
      IF(X.GT.X0) THEN
         DELTA=4.606*X-CC
         IF(X.LT.X1) DELTA=DELTA+AA*(X1-X)**XM
      ENDIF

      END
+DECK,  GSTDN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      FUNCTION GSTDN(LGE)
*   ********************************************************************
*   *                                                                  *
*   *    dN^2/dxdE function for the preparation of the table as in     *
*   *    Grishin,Ermilova,Kotelnikov,NIM A307(1991),273                *
*   *                                                                  *
*   *    ==> Called by : GSTTAB                                        *
*   *        Author    : P. Nevski                                     *
*   *                                                                  *
*   ********************************************************************
+CDE, GCONSP.
+CDE, GCSTRA.
*
      REAL LGE
      COMPLEX I,CEPS1,C1,C2
      SEXP(X) = EXP(MAX(X,-99.))
*
*     ------------------------------------------------------------------
      I=(0.,1.)
      E=EXP(LGE)
*
*    Epsilon-1
      E0     = MAX(LGE,EMIN)
      E2INV  = 1/E**2
      CEPS1  =  CMPLX(GSTINT(LGE,EMM,EPSR,NTAB)*E2INV,
     +       SEXP(GSTINT(E0,EMM,EPSI,NTAB)))
      C1     = 1/GAMMA2-CEPS1*BETA2
      C2     = C1/(1+CEPS1)*LOG(2*BETA2*MEEV/(E*C1))
      GSTDN  = S2/BETA2 * (-2*AIMAG(C2)/(WP2*PI) + (1-SEXP(GSTINT(E0
     +, EMM,FINT,NTAB)))*E2INV) * E
      END
+DECK,  GSTINI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      SUBROUTINE GSTINI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Initialization of tables for energy loss straggling in       *
C.    *   thin gas layers                                              *
C.    *                                                                *
C.    *   ==> Called by : GPHYSI                                       *
C.    *       Authors   : K. Lassila-Perini, I. Gavrilenko, P. Nevski  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCMATE.
+CDE, GCSTRA.
C...
      DIMENSION GAMTT(21),FN(300),EN(300)
      DIMENSION ENOLD(300)
C...
      DATA GAMTT
     +  /     1.1 ,     1.2 ,     1.3 ,     1.5 ,     1.8 ,
     +        2.0 ,     2.5 ,     3.0 ,     4.0 ,     7.0 ,
     +       10.0 ,    20.0 ,    40.0 ,    70.0 ,   100.0 ,
     +      300.0 ,   600.0 ,  1000.0 ,  3000.0 , 10000.0 ,
     +    50000.0 /
C...
      DO 10 I=1,21
         GAMLOG(I) = LOG(GAMTT(I))
   10 CONTINUE
*
      JPHXS = LQ(JPHOT-1)
* NZ = number of elements in the cross-section bank
      NZ    = Q(JPHXS+1)
* NI = number of intervals
      NI    = Q(JPHXS+2+3*NZ)
      NFACT = 140/NI
      EMAX  = LOG(DCUTE*1E9)
      DO 30 NNP = 1,NI
         EM(NNP) = LOG(1E3*Q(JPHXS+2+3*NZ+1+(NNP-1)*5))
         IF (NNP.NE.NI) THEN
            EM2 = LOG(1E3*Q(JPHXS+2+3*NZ+1+NNP*5))
         ELSE
            EM2 = EMAX
         ENDIF
         EESTE = (EM2-EM(NNP))/NFACT
         DO 20 NPNP=1,NFACT
            EMM((NNP-1)*NFACT+NPNP) = EM(NNP) + (NPNP-1)*EESTE
            IF (NPNP.EQ.1.AND.NNP.NE.1)
     +        EMM((NNP-1)*NFACT+NPNP) = EM(NNP) + .3*EESTE
            IF (EMM((NNP-1)*NFACT+NPNP).GT.EMAX) THEN
               NP = (NNP-1)*NFACT+NPNP -1
               GOTO 40
            ENDIF
   20    CONTINUE
   30 CONTINUE
   40 EPS   = .001
*
      CALL GSTXIN
*
*
* Create and fill the banks. The number of intervals is decreased
* in GSTTAB. It is supposed that the EN vector is the same for
* every GAM, if not en error message is printed.
*
      DO 80 I = 1,21
         GAM = GAMTT(I)
         CALL GSTTAB(GAM,NT,EN,FN)
         IF (I.EQ.1) THEN
            CALL MZBOOK(IXCONS,JTSTCO,JTSTRA,-1,'STCO',0,0,NT*21,3,-1)
            CALL MZBOOK(IXCONS,JTSTEN,JTSTRA,-2,'STEN',0,0,NT,3,-1)
            DO 50 II=1,NT
               ENOLD(II) = EN(II)
   50       CONTINUE
         ELSE
            DO 60 III=1,NT
               IF (ENOLD(III).NE.EN(III)) PRINT *,'ERROR in GSTINI     '
     +         //'              (straggling): Energy vector EN is '
     +         //'changing in GSTTAB'
   60       CONTINUE
         ENDIF
         DO 70 J=1,NT
            Q(JTSTCO+(J-1)*21+I) = FN(NT+1-J)
   70    CONTINUE
   80 CONTINUE
*
* ***
      DO 90 J=1,NT
         Q(JTSTEN+J) = EN(NT+1-J)
   90 CONTINUE
*
      NNWE = 0
      DO 110 J=1,NT
         DO 100 I=1,21
            ANL1 = Q(JTSTCO+(J-1)*21+I)
            IF(ANL1.LE.0.) THEN
               GO TO 120
            ENDIF
            Q(JTSTCO+(J-1)*21+I) = LOG(ANL1)
  100    CONTINUE
         NNWE = NNWE+1
  110 CONTINUE
  120 Q(JTSTRA+1) = NNWE
*
      END
+DECK,  GSTINT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      FUNCTION GSTINT(X,A,F,N)
*
*       Simple linear interpolation
*
      DIMENSION A(N),F(N)
      DATA K1,K2,NO/0,0,0/
*
*       Check (N==NO) & (A(K1)<X<A(K2))
*
      IF (N.NE.NO.OR.A(K1).GT.X.OR.X.GT.A(K2)) THEN
*
*       Skip Unless N>1
*
         IF (N.LE.1) THEN
            GSTINT=F(1)
            GO TO 999
         ENDIF
         K1=1
         K2=N
         NO=N
*
*       Loop over K2-K1>1
*
  10     K=(K1+K2)/2
*
*       Check A(K)<X
*
         IF (A(K).LT.X) THEN
            K1=K
         ELSE
            K2=K
         END IF
         IF(K2-K1.GT.1) GO TO 10
      END IF
      X1=A(K1)
      X2=A(K2)
      GSTINT=(F(K1)*(X-X2)+F(K2)*(X1-X))/(X1-X2)
*
 999  END
+DECK,  GSTREN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      FUNCTION GSTREN (GAMMA,ECUT,STEP)
C.    ******************************************************************
C.    *                                                                *
C.    *   Simulation of energy loss straggling in thin layers.         *
C.    *   Sampling is done from the tables which are prepared          *
C.    *   in GSTINI.                                                   *
C.    *                                                                *
C.    *   ==> Called by : GTELEC, GTHADR, GTMUON                       *
C.    *       Authors   : K. Lassila-Perini, I. Gavrilenko             *
C.    *                                                                *
C.    ******************************************************************
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCMATE.
+CDE, GCSTRA.
C
      DIMENSION ANGL(200),RNDM(2)
C...
*   Reading the tables, if the medium has not changed
      NP     = Q(JTSTRA+1)
*
      EC       = 1.E9*ECUT
      GSTLOC   = 0.
      IF(STEP.LE.0.) GO TO 90
C...
*   Interpolate the tables for the current gamma-factor
      GAML     = LOG(GAMMA)
      IF(GAML.GT.GAMLOG(21)) THEN
         DO 10 J=1,NP
            ANGL(J)=Q(JTSTCO+J*21)
   10    CONTINUE
      ELSE
C...
         DO 20 I = 2,21
            IF(GAML.LE.GAMLOG(I)) THEN
               DGG = (GAML-GAMLOG(I-1))/(GAMLOG(I)-GAMLOG(I-1))
               IP=I
               GO TO 30
            ENDIF
   20    CONTINUE
   30    DG1=1.-DGG
C...
         DO 40 K = 1,NP
            ANGL(K) = Q(JTSTCO+(K-1)*21+IP-1)*DG1+
     +                Q(JTSTCO+(K-1)*21+IP  )*DGG
   40    CONTINUE
      ENDIF
*
*    The sampling from the tables
      ANMIN   = EXP(ANGL(NP))
      ANMAX   = EXP(ANGL( 1))
*
      DAN      = ANMAX-ANMIN
      AMU      = DAN*STEP
      CALL GPOISS(AMU,N,1)
      NICOLL   = MAX(N,1)
      DO 80  I  = 1,NICOLL
   50    K1 = 1
         K2 = NP
         CALL GRNDM(RNDM,1)
         R = LOG(RNDM(1)*DAN+ANMIN)
   60    K = (K1+K2)/2
         IF(R.GT.ANGL(K)) THEN
            K2=K
         ELSEIF(R.LT.ANGL(K)) THEN
            K1=K
         ELSE
            E=Q(JTSTEN+K)
            GOTO 70
         ENDIF
         IF(K2-K1.GT.1 ) GO TO 60
*
         E = Q(JTSTEN+K2)+(R-ANGL(K2))*
     +       (Q(JTSTEN+K1)-Q(JTSTEN+K2))/(ANGL(K1)-ANGL(K2))
   70    EE = EXP(E)
         IF(EE.GT.EC) GO TO 50
*
* *** Total energy calculation
         GSTLOC = GSTLOC+EE
   80 CONTINUE
*
   90 GSTREN  = GSTLOC*1.E-9
      END
+DECK,  GSTTAB, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      SUBROUTINE GSTTAB(GAMMA,NT,EN,FN)
C   ********************************************************************
C   *                                                                  *
C   *  dN^2/dEdx table for a gamma factor                              *
C   *                                                                  *
C   *  ==> Called by : GSTINI                                          *
C   *      Authors   : P. Nevski                                       *
C   *                                                                  *
C   ********************************************************************
+CDE, GCSTRA.
      EXTERNAL GSTDN
+SELF, IF=-SINGLE.
      DOUBLE PRECISION DGAMM, DGAM2, DBET2
+SELF.

      DIMENSION EN(1),FN(1)
      PARAMETER (RENER=0.05)
*
*     ------------------------------------------------------------------
*
C   ----  final tables for dN/dx integral vs Energy for a gamma   ------
      DGAMM = GAMMA
      DGAM2 = DGAMM**2
      GAMMA2= DGAM2
      DBET2 = 1-1/DGAM2
      BETA2 = DBET2
      S=0
      NT=0
      ES=0
      EI=EMAX
C   Loop over I=NTAB,1,-1
      DO 10 I=NTAB,1,-1
         EO=EI
         EI=EMM(I)
         S=S+GXGINT(GSTDN,EI,EO,EPPS)
C      Skip Unless ABS(ES-EI)>RENER \ I==1
         IF ((ABS(ES-EI).LE.RENER).AND.(I.NE.1))GO TO 10
         ES=EI
         NT=NT+1
         EN(NT)=EI
         FN(NT)=S
   10 CONTINUE
      DNDX=S
      END
+DECK,  GSTXIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      SUBROUTINE GSTXIN
*   ********************************************************************
*   *                                                                  *
*   *   Initialization of the values needed in computation of          *
*   *   dN^2/dE/dx as in                                               *
*   *   Grishin,Ermilova,Kotelnikov,NIM A307(1991),273                 *
*   *                 PLN 18.04.92, data tables of ILG                 *
*   *                                                                  *
*   *   ==> Called by : GSTINI                                         *
*.  *       Authors   : P. Nevski, K. Lassila-Perini                   *
*   *                                                                  *
*   ********************************************************************
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GCCUTS.
+CDE, GCSTRA.
*
      REAL NAV,MB,ME,NE
*
*   1 ev to erg [erg]
      PARAMETER (ERG=1.60218E-12)
*   1mb to cm2
      PARAMETER (MB=1E-18)
*   Electron mass [g]
      PARAMETER (ME=9.10943E-28)
*   Electron charge[ESU]
      PARAMETER (QE=4.80321E-10)
*   Plank constant[erg]
      PARAMETER (H=1.05457E-27)
*
*     ------------------------------------------------------------------
*
*   -----    physic constants
      EPPS=0.01
      EMIN=EM(1)-EPPS
      EMAX=LOG(DCUTE*1.E9)
*
      NAV = AVO*1.E24
*
*   Electron mass in ev
      MEEV=ME*CLIGHT**2/ERG
*
*   electron radius[cm]
      R0=QE**2/(ME*CLIGHT**2)
*
*   Plank constant in ev
      HE=H*CLIGHT/ERG
*
*   Gas density
      RO=DENS
*
*   Electron density
      NE=NAV*Z/A*RO
*
*   plasma freq**2 [ev]
      WP2=4*PI*R0*NE*HE**2
*
*   x-section to F.osc
      S1=MB/(2*PI**2*R0*HE*Z)
*
*   dN/dx scale
      S2=2*PI*R0*NE*QE**2/ERG
*
      NTAB = NP
      SFINT=0
*
*    Integration of the oscillator strength function
*    (photoelectric cross-section)
      DO 10  IE=NTAB,1,-1
         E1 = EMM(IE)
         IF (IE.EQ.NTAB) THEN
            E2 = EMAX
         ELSE
            E2 = EMM(IE+1)
         ENDIF
         SFINT = SFINT+ GOSCIN(EXP(E1),EXP(E2))
         FINT(IE)=SFINT
   10 CONTINUE
*
*   Normalization of the integrated cross-section
      DO 20  IE=1,NTAB
         FINT(IE)=LOG(FINT(IE)/SFINT)
   20 CONTINUE
*
*   Calculation of the real and imaginary parts of the
*   complex dielectric constant
      DO 30  IE=1,NTAB
         E=EXP(EMM(IE))
         EPSI(IE)=LOG(WP2*PIBY2*GPHSG2(E*1E-9)/(SFINT*E))
*      scaled by
         EPSR(IE)=WP2*GKOKRI(E,EXP(EMIN),DCUTE*1E9)*E/SFINT
   30 CONTINUE
      END
+DECK,  GXGINT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:39  cernlib
* Geant

      FUNCTION GXGINT(EXT,A,B,EPS)
*
*    Gauss integration routine
*
+CDE, GCUNIT.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION OTB,U1,U2,W1,W2,Y
+SELF.
      EXTERNAL EXT
      PARAMETER (U1=.3399810,U2=.8611363,W1=.6521452,W2=.3478548)
*
*-----------------------------------------------------------------------
*
      N      = 5
      OTB    = 0
      DHALF  = (B-A)/N
   10 CONTINUE
*
*   Convergence loop
*
      Y = OTB
      OTB = 0
      D = DHALF
      DHALF = 0.5*D
      CENTX = A-DHALF
      D1 = U1*DHALF
      D2 = U2*DHALF
*
*   Piecewise integration loop
*
      DO 20 I=1,N
         CENTX=CENTX+D
         OTB = OTB +W2*(EXT(CENTX-D2)+EXT(CENTX+D2)) +W1*(EXT(CENTX-D1)
     +   +EXT(CENTX+D1))
   20 CONTINUE
      OTB=OTB*DHALF
*
      IF(EPS.GT.0.AND.ABS(OTB-Y).GT.ABS(EPS*OTB)) THEN
         N = 2*N
         IF (N.GT.100 000) THEN
*
*   Check N>100 000
*
            WRITE(CHMAIL,10000) EPS, ABS((OTB-Y)/OTB)
            CALL GMAIL(1,0)
            GO TO 30
         END IF
         GOTO 10
      ENDIF
*
   30 CONTINUE
      GXGINT=OTB
10000 FORMAT('*** GXGINT : required precision ',G10.3,
     +      ' obtained precision ',G10.3)
      END
+PATCH, GPHYS.
+DECK,  GANNI, T=FORT.
* Revision 1.2  1996/02/27 10:08:11  ravndal
* Precision problem in cos(theta) solved
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      SUBROUTINE GANNI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates positron annihilation                               *
C.    *                                                                *
C.    *    ==>Called by : GTELEC                                       *
C.    *       Author    L.Urban *********                              *
C.    *       10/06/93: modified by Georges Azuelos (Vancouver)        *
C     *                 to include 1-quantum annihilation              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCPHYS.
+CDE, GCTRAK.
+CDE, GCCUTS.
+CDE, GCKING.
+CDE, GCONSP.
+CDE, GCBANK.
+CDE, GCMULO.
+CDE, GCJLOC.
+CDE, GCMATE.
      DIMENSION PGAM(3),RNDM(2)
      LOGICAL ROTATE
      PARAMETER (ALFA=7.29735E-3)
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(11)
      IF((IANNI.NE.1).OR.((GETOT+EMASS).LE.CUTGAM)) THEN
         ISTOP = 2
         DESTEP = DESTEP + GETOT + EMASS
         GEKIN = 0.
         GETOT = EMASS
         VECT(7)= 0.
         GO TO 999
      ENDIF
C
      XE=GETOT
      GAM=XE/EMASS
      GAM2=GAM**2
      GAM1=MAX(GAM2-1.,0.)
      GAMP1=GAM+1.
      C=SQRT(GAM1)
*
      SIG=(GAM2+4.*GAM+1.)*LOG(GAM+C)/GAM1-(GAM+3.)/C
      SIG=0.5*Q(JPROB+17)*SIG/GAMP1
*
      BIND=0.5*(Z*ALFA)**2*EMASS
      E1Q=XE+EMASS-BIND
      IF(E1Q .GT. 0.)THEN
         GVE=VECT(7)/EMASS
         SIG1=GAM2+2.*(GAM+2.)/3.-(GAM+2.)/GVE*LOG(GAM+GVE)
         SIG1=2.*Q(JPROB+18)*SIG1/(GVE*GAMP1**2)
      ELSE
         SIG1=0.
      END IF
*
      SIG=SIG+SIG1
      CALL GRNDM(RNDM,1)
C
      IF(RNDM(1).GE.SIG1/SIG)THEN
         GAMP12=GAMP1**2
         P=VECT(7)
         E0=1./(GAMP1+C)
C
   10    CALL GRNDM(RNDM,2)
         E=E0*((1.-E0)/E0)**RNDM(1)
C
         SCREJ=(GAMP12+2.*GAMP1-2.-GAMP12*E-1./E)/(GAMP12-2.)
         IF(RNDM(2).GT.SCREJ) GOTO 10
C
         EPHOT1=(XE+EMASS)*E
C
         COSTH=(GEKIN+EMASS*(2.*E-1.)/E)/P
C
C restrict COSTH to [-1.,+1.]
C
         COSTH = MIN( 1. , MAX( -1. , COSTH ) )
         SINTH=SQRT((1.-COSTH)*(1.+COSTH))
         CALL GRNDM(RNDM,1)
         PHI = TWOPI * RNDM(1)
         COSPHI = COS(PHI)
         SINPHI = SIN(PHI)
C
         PGAM(1) = EPHOT1* SINTH * COSPHI
         PGAM(2) = EPHOT1* SINTH * SINPHI
         PGAM(3) = EPHOT1* COSTH
C
C             Rotate tracks into GEANT system and store.
C
         CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
         NGGAMM = 0
         IF(EPHOT1.GT.CUTGAM) THEN
            NGGAMM = NGGAMM + 1
            NGKINE = NGKINE + 1
            GKIN(1,NGKINE) = PGAM(1)
            GKIN(2,NGKINE) = PGAM(2)
            GKIN(3,NGKINE) = PGAM(3)
            GKIN(4,NGKINE) = EPHOT1
            GKIN(5,NGKINE) = 1
            TOFD(NGKINE)=0.
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
            IF(ROTATE)
     +      CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
         ELSE
            DESTEP = DESTEP + EPHOT1
         ENDIF
C
C             Momentum vector of second photon.
C
         EPHOT2 = GETOT + EMASS - EPHOT1
         IF(EPHOT2.GT.CUTGAM) THEN
            NGGAMM = NGGAMM + 1
            NGKINE = NGKINE + 1
            GKIN(1,NGKINE) = - PGAM(1)
            GKIN(2,NGKINE) = - PGAM(2)
            GKIN(3,NGKINE) = P - PGAM(3)
            GKIN(4,NGKINE) = EPHOT2
            GKIN(5,NGKINE) = 1
            TOFD(NGKINE)=0.
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
            IF(ROTATE)
     +      CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
         ELSE
            DESTEP = DESTEP + EPHOT2
         ENDIF
      ELSE
C 1-quantum annihilation
         P=VECT(7)
         EPHOT=E1Q
C Assume photon collinear with positron
         PGAM(1) = 0.
         PGAM(2) = 0.
         PGAM(3) = EPHOT
C
C             Rotate tracks into GEANT system and store.
C
         CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
         NGGAMM = 0
         IF(EPHOT.GT.CUTGAM) THEN
            NGGAMM = NGGAMM + 1
            NGKINE = NGKINE + 1
            GKIN(1,NGKINE) = PGAM(1)
            GKIN(2,NGKINE) = PGAM(2)
            GKIN(3,NGKINE) = PGAM(3)
            GKIN(4,NGKINE) = EPHOT
            GKIN(5,NGKINE) = 1
            TOFD(NGKINE)=0.
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
            IF(ROTATE)
     +      CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
         ELSE
            DESTEP = DESTEP + EPHOT
         ENDIF
      END IF
C
      IF(NGGAMM.GT.0) THEN
         ISTOP = 1
      ELSE
         ISTOP = 2
      ENDIF
C
 999  END
+DECK,  GANNI2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      SUBROUTINE GANNI2
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Generates positron annihilation at rest                  *
C.    *       (alias of GANNIR , directly called from GPAIRG)          *
C.    *                                                                *
C.    *    ==>Called by : GPAIRG,GPAIRM                                *
C.    *       Author    M.Maire *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCPHYS.
+CDE, GCTRAK.
+CDE, GCKING.
+CDE, GCCUTS.
+CDE, GCONSP.
      DIMENSION RNDM(2)
C.
      KCASE = NAMEC(11)
      IF((IANNI.NE.1).OR.(EMASS.LE.CUTGAM)) THEN
         DESTEP = DESTEP + 2*EMASS
         GO TO 999
      ENDIF
      CALL GRNDM(RNDM,2)
      CT=-1.+2.*RNDM(1)
      ST=SQRT((1.-CT)*(1.+CT))
      PHI=TWOPI*RNDM(2)
      NGKINE=NGKINE+1
      GKIN(1,NGKINE)=EMASS*ST*COS(PHI)
      GKIN(2,NGKINE)=EMASS*ST*SIN(PHI)
      GKIN(3,NGKINE)=EMASS*CT
      GKIN(4,NGKINE)=EMASS
      GKIN(5,NGKINE)=1.
      TOFD(NGKINE)=0.
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
      NGKINE=NGKINE+1
      DO 10 J=1,3
   10 GKIN(J,NGKINE)=-GKIN(J,NGKINE-1)
      GKIN(4,NGKINE)=EMASS
      GKIN(5,NGKINE)=1.
      TOFD(NGKINE)=0.
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
  999 END
+DECK,  GANNII, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      SUBROUTINE GANNII
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for positron annihilation                                     *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, L.Urban  *********                    *
C.    *       10/06/93: modified by Georges Azuelos (Vancouver)        *
C     *                 to include 1-quantum annihilation              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCMATE.
+CDE, GCONSP.
+CDE, GCJLOC.
+CDE, GCMULO.
C.
C.    ------------------------------------------------------------------
C.
      SIG=0.
      IF(Z.GE.1.) THEN
         XE=ELOW(IEKBIN)+EMASS
         GAM=XE/EMASS
         GAM2=GAM**2
         GAM1=MAX(GAM2-1.,0.)
         C=SQRT(GAM1)
*
         SIG=(GAM2+4.*GAM+1.)*LOG(GAM+C)/GAM1-(GAM+3.)/C
         SIG=0.5*Q(JPROB+17)*SIG/(GAM+1.)
         PE=SQRT((XE-EMASS)*(XE+EMASS))
*
         GVE=PE/EMASS
         SIG1=GAM2+2.*(GAM+2.)/3.-(GAM+2.)/GVE*LOG(GAM+GVE)
         SIG1=2.*Q(JPROB+18)*SIG1/(GVE*(GAM+1.)**2)
*
         SIG=SIG+SIG1
      ENDIF
      IF(SIG.GT.0.)THEN
         Q(JANNI+IEKBIN)=1./SIG
      ELSE
         Q(JANNI+IEKBIN)=BIG
      ENDIF
C
      END
+DECK,  GANNIR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      SUBROUTINE GANNIR
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates positron annihilation in rest                       *
C.    *                                                                *
C.    *    ==>Called by : GTELEC                                       *
C.    *       Author    L.Urban, M.Maire *********                     *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCPHYS.
+CDE, GCTRAK.
+CDE, GCCUTS.
+CDE, GCKING.
+CDE, GCONSP.
      DIMENSION RNDM(2)
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(11)
      IF((IANNI.NE.1).OR.(EMASS.LE.CUTGAM)) THEN
          ISTOP = 2
          DESTEP = DESTEP + 2*EMASS
          RETURN
      ENDIF
         ISTOP = 1
         CALL GRNDM(RNDM,2)
         CT=-1.+2.*RNDM(1)
         ST=SQRT(ABS(1.-CT*CT))
         PHI=TWOPI*RNDM(2)
         NGKINE=NGKINE+1
         GKIN(1,NGKINE)=EMASS*ST*COS(PHI)
         GKIN(2,NGKINE)=EMASS*ST*SIN(PHI)
         GKIN(3,NGKINE)=EMASS*CT
         GKIN(4,NGKINE)=EMASS
         GKIN(5,NGKINE)=1.
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         NGKINE=NGKINE+1
         DO 30 J=1,3
  30     GKIN(J,NGKINE)=-GKIN(J,NGKINE-1)
         GKIN(4,NGKINE)=EMASS
         TOFD(NGKINE)=0.
         GKIN(5,NGKINE)=1.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
      END
+DECK,  GAVRL2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      REAL FUNCTION GAVRL2(GAMA,BETA,XM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  L2 shell x-section a la Gavrila                               *
C.    *    Gama  - L2 shell photoelectron gama                         *
C.    *    Beta  - L2 shell photoelectron beta                         *
C.    *    XM    - ratio of the electron mass to the photon energy     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION G,G2,G3,B,P1,P2,P3
+SELF.
      G = GAMA
      G2 = G*G
      G3 = G2*G
      B  = BETA
      P1 = (9*G3-5*G2+24*G-16)
      P2 = -(G2+3*G-8)
      P3 = 1
      IF(B.GT.0.0001) P3 = LOG(G*(1+B))/(B*G)
      GAVRL2 = (P1+P2*P3)*B*G*XM**5
      END
+DECK,  GAVRL3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      REAL FUNCTION GAVRL3(GAMA,BETA,XM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  L3 shell x-section a la Gavrila                               *
C.    *    Gama  - L3 shell photoelectron gama                         *
C.    *    Beta  - L3 shell photoelectron beta                         *
C.    *    XM    - ratio of the electron mass to the photon energy     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION G,G2,G3,B,P1,P2,P3
+SELF.
      G = GAMA
      G2 = G*G
      G3 = G2*G
      B  = BETA
      P1 = (4*G3-6*G2+5*G+3)
      P2 = -(G2-3*G+4)
      P3 = 1
      IF(BETA.GT.0.0001) P3 = LOG(G*(1+B))/(B*G)
      GAVRL3 = (P1+P2*P3)*B*G*XM**5
      END
+DECK,  GBFLOS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      FUNCTION GBFLOS(T,C)
C.    ******************************************************************
C.    *                                                                *
C.    *  It calculates a weight factor for the positron continuous     *
C.    *       bremsstrahlung energy loss.                              *
C.    *                                                                *
C.    *  Input:T kinetic energy (GeV)                                  *
C.    *        C cut for bremsstrahlung (BCUTE)                        *
C.    *        ETA ratio of positron to electron brems loss            *
C.    *  Output: weight factor                                         *
C.    *                                                                *
C.    *  ===>   positron loss = FLOS * electron loss   <===            *
C.    *                                                                *
C.    *  Author   L. Urban                                             *
C.    *                                                                *
C.    ******************************************************************
C.
      ETA = GCBREM(T)
      IF(ETA.LT.0.0001) THEN
         F=1.E-10
      ELSEIF(ETA.GT.0.9999) THEN
         F=1.
      ELSE
C
         E0=C/T
         IF(E0.GT.1.) E0=1.
C
         IF(E0.LT.1.E-8) THEN
            F=1.
         ELSE
            ALFA=1./ETA
            E1=1.-E0
            F=ETA*(1.-E1**ALFA)/E0
         ENDIF
C
      ENDIF
*
      GBFLOS=F
      END
+DECK,  GBFSIG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:21  cernlib
* Geant

      FUNCTION GBFSIG(T,C)
C.    ******************************************************************
C.    *                                                                *
C.    *  It calculates a weight factor for the positron discrete       *
C.    *       (hard) bremsstrahlung cross section                      *
C.    *                                                                *
C.    *  Input:T kinetic energy (GeV)                                  *
C.    *        C cut for bremsstrahlung (BCUTE)                        *
C.    *        ETA ratio of positron to electron brems cross section   *
C.    *  Output: weight factor                                         *
C.    *                                                                *
C.    *  ===>  positron sigma = Fsig * electron sigma  <===            *
C.    *                                                                *
C.    *  Author   L. Urban                                             *
C.    *                                                                *
C.    ******************************************************************
C.
      ETA = GCBREM(T)
      IF(ETA.LT.0.0001) THEN
         F=1.E-10
      ELSEIF(ETA.GT.0.9999) THEN
         F=1.
      ELSE
C
         E0=C/T
C
         IF(E0.GE.1.) THEN
            F=1.E-10
         ELSE
            ALFA=1./ETA
            E1=1.-E0
            F=ETA*E1**ALFA/E1
         ENDIF
      ENDIF
C
      GBFSIG=F
      END
+DECK,  GBIRK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      SUBROUTINE GBIRK(EDEP)
*
************************************************************************
*                                                                      *
* *** apply BIRK's saturation law to energy deposition ***             *
* *** only organic scintillators implemented in this version MODEL=1   *
*                                                                      *
* Note : the material is assumed ideal, which means that impurities    *
*        and aging effects are not taken into account                  *
*                                                                      *
* algorithm : edep = destep / (1. + RKB*dedx + C*(dedx)**2)            *
*                                                                      *
* the values of RKB and C can be entered via :                         *
*                                                                      *
* call gstpar(imate,'BIRK1',value) to set the model (must be 1 or 2)   *
* call gstpar(imate,'BIRK2',value) to set RKB                          *
* call gstpar(imate,'BIRK3',value) to set C                            *
*                                                                      *
* the basic units of the coefficient are g/(Mev*cm**2)                 *
* because the de/dx is obtained in Mev/cm                              *
*                                                                      *
* exp. values from NIM 80 (1970) 239-244 :                             *
*                                                                      *
* RKB = 0.013  g/mev*cm**2  and  C = 9.6e-6  g**2/(Mev**2)(cm**4)      *
*                                                                      *
*    ==>Called by : <USER>,GUSTEP                                      *
*       Author    R.Brun , N.Van Eijndhoven    *********               *
*                                                                      *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCMATE.
+CDE, GCTRAK.
C.
C.    ------------------------------------------------------------------
C.
      EDEP=DESTEP
C
C --- no saturation law for neutral particles ---
      IF (ABS(CHARGE) .LE. 1.E-10) GO TO 99
C
C --- get the values for the BIRK coefficients stored via GSTPAR ---
      JTMN=LQ(JTM)
      IF (JTMN .LE. 0)GO TO 99
      MODEL=Q(JTMN+27)
      IF(MODEL.GT.2)GO TO 99
      RKB=Q(JTMN+28)/DENS
      C=Q(JTMN+29)/DENS**2
C
C --- correction for particles with more than 1 charge unit ---
C --- based on alpha particle data (only apply for MODEL=1) ---
      IF(MODEL.EQ.1)THEN
         IF (ABS(CHARGE) .GE. 2.) RKB=RKB*7.2/12.6
      ENDIF
C
      DEDXCM=1000.*Q(JLOSS+IEKBIN)
C
      EDEP=DESTEP/(1.+RKB*DEDXCM+C*DEDXCM**2)
C
  99  RETURN
      END

+DECK,  GBRELA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      SUBROUTINE GBRELA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialize the bremsstrahlung energy loss tables              *
C.    *            ( See L.Urban report)                               *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    G.Patrick, L.Urban  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCMULO.
+CDE, GCJLOC.
+CDE, GCTRAK.
+CDE, GCCUTS.
+CDE, GCMATE.
+CDE, GCONSP.
+CDE, GCPHYS.
      DIMENSION DEM(8)
      DATA DEM/-6.76228E-1,4.35611E-1,-4.69224E-1,-7.05133E-3,
     +        1.31200,-8.07563E-1,-6.96166E-1,3.62549E-1/
C.
C.    ------------------------------------------------------------------
C.
C            Number of constituents(ie. element,mixture or compound).
C
      NLMAT = Q(JMA+11)
      NLM    = IABS(NLMAT)
      IF (NLMAT.EQ.0)                             GO TO 999
      IF(Z.LT.1.)                                 GO TO 999
C
      JEL1=LQ(JMA-1)
      JEL2=LQ(JMA-2)
      ICHAN=IEKBIN
      XE     = ELOW(ICHAN)
      XE1    = 10.**(EKBIN(1)+(ICHAN-0.5)/GEKA)
C
C==========>  A,Bremsstrahlung losses for electrons
C             special treatment for compounds/mixtures
C
      IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
         DEDX=GBRELE(Z,XE,BCUTE)
         DEDX=AVO*DENS*DEDX/A
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DEDX1=GBRELE(Z,XE1,BCUTE)
            DEDX1=AVO*DENS*DEDX1/A
         ENDIF
      ELSE
C
C             compound/mixture
C
         DEDX=0.
         DEDX1=0.
         DO 10 L=1,NLM
            J = JMIXT+NLM+L
            AA = Q(J-NLM)
            ZZ = Q(J)
            WMAT= Q(J+NLM)
            S = GBRELE(ZZ,XE,BCUTE)
            S = WMAT*S/AA
            DEDX= DEDX+AVO*DENS*S
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               S = GBRELE(ZZ,XE1,BCUTE)
               S = WMAT*S/AA
               DEDX1= DEDX1+AVO*DENS*S
            ENDIF
   10    CONTINUE
      ENDIF
C
      IF(DEDX.LT.0.)DEDX=0.
      Q(JEL1+ICHAN)=Q(JEL1+ICHAN)+DEDX
      FACT = GBFLOS(XE,BCUTE)
      Q(JEL1+ICHAN+NEK1)=Q(JEL1+ICHAN+NEK1)+FACT*DEDX
*
      IF(ISTRA.NE.0) Q(JEL1+ICHAN+2*NEK1) = DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         IF(DEDX1.LT.0.)DEDX1=0.
         WS(ICHAN)=WS(ICHAN)+DEDX1
         FACT = GBFLOS(XE1,BCUTE)
         WS(NEKBIN+ICHAN)=WS(NEKBIN+ICHAN)+FACT*DEDX1
      ENDIF
C
C===========>  B, Bremsstrahlung losses for muons
C
      IF(XE.GE.1.)GO TO 20
      CONS1=3.26485E-8*Z*Z*DENS/A
      CONS2=LOG(2.70511)-LOG(A)/3.
      R=EMMU/(XE+EMMU)
      RL=LOG(R)
      DEDX=DEM(1)+RL*DEM(3)+R*(DEM(5)+R*DEM(7))
      DEDX=DEDX+CONS2*(DEM(2)+RL*DEM(4)+R*(DEM(6)+R*DEM(8)))
      DEDX=CONS1*XE*DEDX
      IF(DEDX.LT.0.)DEDX=0.
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX
*
      IF(ISTRA.NE.0) Q(JEL2+ICHAN+NEK1) = DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         R=EMMU/(XE1+EMMU)
         RL=LOG(R)
         DEDX1=DEM(1)+RL*DEM(3)+R*(DEM(5)+R*DEM(7))
         DEDX1=DEDX1+CONS2*(DEM(2)+RL*DEM(4)+R*(DEM(6)+R*DEM(8)))
         DEDX1=CONS1*XE1*DEDX1
         IF(DEDX1.LT.0.)DEDX1=0.
         WS(NEKBIN*2+ICHAN) = WS(NEKBIN*2+ICHAN)+DEDX1
      ENDIF
      GO TO 999
C
   20 IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
         DEDX=GBRELM(Z,XE,BCUTM)
         DEDX=AVO*DENS*DEDX/A
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DEDX1=GBRELM(Z,XE1,BCUTM)
            DEDX1=AVO*DENS*DEDX1/A
         ENDIF
      ELSE
C
C             compound/mixture
C
         DEDX=0.
         DEDX1=0.
         DO 30 L=1,NLM
            J = JMIXT+NLM+L
            AA = Q(J-NLM)
            ZZ = Q(J)
            WMAT= Q(J+NLM)
            S = GBRELM(ZZ,XE,BCUTM)
            S = WMAT*S/AA
            DEDX= DEDX+AVO*DENS*S
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               S = GBRELM(ZZ,XE1,BCUTM)
               S = WMAT*S/AA
               DEDX1= DEDX1+AVO*DENS*S
            ENDIF
   30    CONTINUE
      ENDIF
C
      IF(DEDX.LT.0.)DEDX=0.
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX
*
      IF(ISTRA.NE.0) Q(JEL2+ICHAN+NEK1) = DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         IF(DEDX1.LT.0.)DEDX1=0.
         WS(NEKBIN*2+ICHAN)=WS(NEKBIN*2+ICHAN)+DEDX1
      ENDIF
C
  999 END
+DECK,  GBRELE, T=FORT.
* Revision 1.2  1996/09/30 13:30:03  ravndal
* Bremsstrahlung extension for higher energies
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      FUNCTION GBRELE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates energy loss by soft Bremsstrahlung                 *
C.    *         (in GeV barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRELA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *    ( correction for T>100. GeV)                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCMATE.
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
+SELF, IF=-BETHE.
      DATA C1/-0.960613E-01, 0.631029E-01,-0.142819E-01, 0.150437E-02
     +      ,-0.733286E-04, 0.131404E-05, 0.859343E-01,-0.529023E-01
     +      , 0.131899E-01,-0.159201E-02, 0.926958E-04,-0.208439E-05
     +      ,-0.684096E+01, 0.370364E+01,-0.786752E+00, 0.822670E-01
     +      ,-0.424710E-02, 0.867980E-04,-0.200856E+01, 0.129573E+01
     +      ,-0.306533E+00, 0.343682E-01,-0.185931E-02, 0.392432E-04
     +      , 0.127538E+01,-0.515705E+00, 0.820644E-01,-0.641997E-02
     +      , 0.245913E-03,-0.365789E-05, 0.115792E+00,-0.463143E-01
     +      , 0.725442E-02,-0.556266E-03, 0.208049E-04,-0.300895E-06
     +      ,-0.271082E-01, 0.173949E-01,-0.452531E-02, 0.569405E-03
     +      ,-0.344856E-04, 0.803964E-06, 0.419855E-02,-0.277188E-02
     +      , 0.737658E-03,-0.939463E-04, 0.569748E-05,-0.131737E-06
     +      ,-0.318752E-03, 0.215144E-03,-0.579787E-04, 0.737972E-05
     +      ,-0.441485E-06, 0.994726E-08, 0.938233E-05,-0.651642E-05
     +      , 0.177303E-05,-0.224680E-06, 0.132080E-07,-0.288593E-09/
      DATA C2/-0.245667E-03, 0.833406E-04,-0.129217E-04, 0.915099E-06
     +      ,-0.247179E-07, 0.147696E-03,-0.498793E-04, 0.402375E-05
     +      , 0.989281E-07,-0.133378E-07,-0.737702E-02, 0.333057E-02
     +      ,-0.553141E-03, 0.402464E-04,-0.107977E-05,-0.641533E-02
     +      , 0.290113E-02,-0.477641E-03, 0.342008E-04,-0.900582E-06
     +      , 0.574303E-05, 0.908521E-04,-0.256900E-04, 0.239921E-05
     +      ,-0.741271E-07,-0.341260E-04, 0.971711E-05,-0.172031E-06
     +      ,-0.119455E-06, 0.704166E-08, 0.341740E-05,-0.775867E-06
     +      ,-0.653231E-07, 0.225605E-07,-0.114860E-08,-0.119391E-06
     +      , 0.194885E-07, 0.588959E-08,-0.127589E-08, 0.608247E-10/
      DATA AKSI,BETA,VE/2.51,0.99,0.00004/
+SELF, IF=BETHE.
      DATA C1/ 0.834459E-02, 0.443979E-02,-0.101420E-02, 0.963240E-04
     +      ,-0.409769E-05, 0.642589E-07, 0.464473E-02,-0.290378E-02
     +      , 0.547457E-03,-0.426949E-04, 0.137760E-05,-0.131050E-07
     +      ,-0.547866E-02, 0.156218E-02,-0.167352E-03, 0.101026E-04
     +      ,-0.427518E-06, 0.949555E-08,-0.406862E-02, 0.208317E-02
     +      ,-0.374766E-03, 0.317610E-04,-0.130533E-05, 0.211051E-07
     +      , 0.158941E-02,-0.385362E-03, 0.315564E-04,-0.734968E-06
     +      ,-0.230387E-07, 0.971174E-09, 0.467219E-03,-0.154047E-03
     +      , 0.202400E-04,-0.132438E-05, 0.431474E-07,-0.559750E-09
     +      ,-0.220958E-02, 0.100698E-02,-0.596464E-04,-0.124653E-04
     +      , 0.142999E-05,-0.394378E-07, 0.477447E-03,-0.184952E-03
     +      ,-0.152614E-04, 0.848418E-05,-0.736136E-06, 0.190192E-07
     +      ,-0.552930E-04, 0.209858E-04, 0.290001E-05,-0.133254E-05
     +      , 0.116971E-06,-0.309716E-08, 0.212117E-05,-0.103884E-05
     +      ,-0.110912E-06, 0.655143E-07,-0.613013E-08, 0.169207E-09/
      DATA C2/ 0.301125E-04,-0.461920E-04, 0.871485E-05,-0.622331E-06
     +      , 0.151800E-07,-0.478023E-04, 0.247530E-04,-0.381763E-05
     +      , 0.232819E-06,-0.494487E-08,-0.336230E-04, 0.223822E-04
     +      ,-0.384583E-05, 0.252867E-06,-0.572599E-08, 0.105335E-04
     +      ,-0.567074E-06,-0.216564E-06, 0.237268E-07,-0.658131E-09
     +      , 0.282025E-05,-0.671965E-06, 0.565858E-07,-0.193843E-08
     +      , 0.211839E-10, 0.157544E-04,-0.304104E-05,-0.624410E-06
     +      , 0.120124E-06,-0.457445E-08,-0.188222E-05,-0.407118E-06
     +      , 0.375106E-06,-0.466881E-07, 0.158312E-08, 0.945037E-07
     +      , 0.564718E-07,-0.319231E-07, 0.371926E-08,-0.123111E-09/
      DATA AKSI,BETA,VE/2.10,1.00,0.001/
+SELF.
      DATA CORFAC/0.805485E-10/
C.
      DATA THIGH,CHIGH/100.,50./
C.    ------------------------------------------------------------------
C.
      GBRELE=0.

      IF(BCUT.LE.0.) GOTO 99
************************************
      CUTSAV=BCUT
      IF(BCUT.GT.T) BCUT=T
*************************************
      IF(T.GT.THIGH) THEN
          TT=THIGH
        IF(BCUT.GE.THIGH) THEN
            EC=CHIGH
        ELSE
            EC=BCUT
        ENDIF
      ELSE
          TT=T
          EC=BCUT
      ENDIF

      E=TT+EMASS
      IF(BCUT.GT.TT) EC=TT
C
      X=LOG(TT/EMASS)
      Y=LOG(EC/(E*VE))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
             ENDIF
             XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
+SELF, IF=-BETHE.
      CORR=1./(1.+CORFAC*DENS*Z*E*E/(A*EC*EC))
+SELF, IF=BETHE.
      CORR=1.
+SELF.
      FAC=ZZ*(ZZ+AKSI)*E*E*(EC*CORR/TT)**BETA/(E+EMASS)
      IF(FAC.LE.0.) GOTO 99
C
      GBRELE=FAC*S

      IF(T.GT.THIGH) THEN

       IF(BCUT.LT.THIGH) THEN
        RAT=BCUT/T
        S=(1.-0.5*RAT+2.*RAT*RAT/9.)
        RAT=BCUT/TT
        S=S/(1.-0.5*RAT+2.*RAT*RAT/9.)
       ELSE
        RAT=BCUT/T
        S=BCUT*(1.-0.5*RAT+2.*RAT*RAT/9.)
        RAT=EC/TT
        S=S/(EC*(1.-0.5*RAT+2.*RAT*RAT/9.))
       ENDIF

        GBRELE=GBRELE*S
      ENDIF
******************************************
      BCUT=CUTSAV
******************************************
C
  99  RETURN
      END

+DECK,  GBRELM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      FUNCTION GBRELM(Z,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  To calculate energy loss due to soft muon BREMSSTRAHLUNG.     *
C.    *                                                                *
C.    *    ==>Called by : GBRELA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION C(52),D(28)
      DATA C/0.615548E-07,-0.858333E-07, 0.148015E-06,-0.220289E-07
     +      , 0.162987E-08,-0.305945E-10, 0.170957E-06,-0.272156E-06
     +      , 0.610418E-07,-0.768052E-08, 0.391729E-09,-0.104624E-10
     +      , 0.412993E-07,-0.373362E-08,-0.110920E-08, 0.571124E-09
     +      ,-0.477538E-10, 0.169448E-11, 0.323774E-08,-0.305497E-08
     +      , 0.758138E-09,-0.121885E-09, 0.857707E-11,-0.253742E-12
     +      , 0.133703E-08,-0.676756E-09, 0.147782E-09,-0.136039E-10
     +      , 0.556182E-12,-0.634277E-14, 0.847418E-10,-0.288608E-10
     +      , 0.224661E-11, 0.514422E-13,-0.122288E-13, 0.333673E-15
     +      ,-0.153886E-08, 0.100179E-08,-0.149457E-09, 0.734506E-11
     +      ,-0.507324E-09, 0.146362E-09,-0.126608E-10, 0.778818E-13
     +      ,-0.161333E-10,-0.199252E-11, 0.100270E-11,-0.347404E-13
     +      ,-0.465077E-11, 0.121078E-11,-0.131113E-12, 0.431515E-14/
      DATA D/-0.389616E-05,-0.130106E-09, 0.101380E-04, 0.259032E-07
     +      ,-0.816804E-07,-0.961867E-05,-0.603907E-08, 0.192015E-07
     +      , 0.772670E-08, 0.459337E-05, 0.761272E-09,-0.251956E-08
     +      , 0.483037E-10,-0.289802E-08,-0.117497E-05,-0.484372E-10
     +      , 0.155476E-09,-0.218604E-10, 0.812047E-10, 0.380265E-09
     +      , 0.154338E-06, 0.118357E-11,-0.367778E-11, 0.119199E-11
     +      ,-0.273719E-11,-0.201239E-11,-0.221931E-10,-0.818793E-08/
C
      DATA AKSI,BETA,DEL/2.20,1.24,0.58/
C
      DATA CONMX/0.130653/
C        CONMX=0.75*SQRT(2.7182...)*EMMU
C.
C.    ------------------------------------------------------------------
C.
      GBRELM=0.
      IF(BCUT.LE.0.) GOTO 99
C
      Z3=Z**0.333333
      E=T+EMMU
      ECMAX=E-CONMX*Z3
      X=LOG(E/EMMU)
      IF(BCUT.GE.ECMAX) GOTO 60
C
      Y=LOG(BCUT/EMMU)
      S=0.
      YY=1.
      DO 30 I=1,6
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      SS=0.
      YY=1.
      DO 50 I=1,4
         XX=1.
         DO 40 J=1,4
            K=4*I+J+32
            SS=SS+C(K)*XX*YY
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=E*(BCUT/E)**BETA
      FAC=Z*(Z+AKSI*(1.+DEL*LOG(Z)))*FAC
      GBRELM=FAC*S
      GOTO 99
C
  60  Y=Z3
      S=D(1)
      K=1
      XX=1.
      YPX=Y/X
      DO 80 I=1,6
         II=I+1
         XX=XX*X
         XXYY=XX
         DO 70 J=1,II
            K=K+1
            S=S+D(K)*XXYY
            XXYY=XXYY*YPX
  70     CONTINUE
  80  CONTINUE
      IF(S.LE.0.) GOTO 99
C
      FAC=Z*(Z+1.)*ECMAX
      IF(FAC.LE.0.) GOTO 99
      GBRELM=FAC*S
C
  99  RETURN
      END
+DECK,  GBREME, T=FORT.
* Revision 1.2  1997/11/13 09:25:40  gunter
* Correction By Laszlo Urban; protect against divide by 0. if AL becomes 0.
* around GEKIN 2.93E-5.
* Reported by harald@psiclu.cern.ch (signed by keller@biomed.ee.ethz.ch)
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      SUBROUTINE GBREME
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates discrete hard BREMSSTRAHLUNG by electrons.          *
C.    *                                                                *
C.    *  The secondary photon energy is sampled from a                 *
C.    *  parametrization of the bremsstrahlung calculation of          *
C.    *  Seltzer and Berger (NIM B12,p.95(1985)) for electron          *
C.    *  energies 1 keV - 10 GeV . For higher energies the             *
C.    *  parametrization agrees with the screened Bethe-Heitler        *
C.    *  bremsstrahlung spectrum.Migdal corrections are applied        *
C.    *      by default. The routine works ( together                  *
C.    *  with the routines GBRELE and GBRSGE ) without the Migdal      *
C.    *  corrections using the Patchy switch +USE,BETHE.               *
C.    *                                                                *
C.    *  NOTE :                                                        *
C.    *      BCUTE is the cut-off energy above which the photon energy *
C.    *      spectrum is generated.                                    *
C.    *                                                                *
C.    *    ==>Called by : GTELEC                                       *
C.    *       Authors    L.Urban    29/10/93 *********                 *
C.    *                                                                *
C.    *  13/11/97 bug corrected by L.Urban                             *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCTRAK.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCCUTS.
      DIMENSION RNDM(2)
      PARAMETER (CORFAC=0.805485E-10)
      PARAMETER (TLIM=0.000999)
      PARAMETER  (
     +AL00=-0.205398E+01,AL01= 0.238815E-01,AL02= 0.525483E-03,
     +AL10=-0.769748E-01,AL11=-0.691499E-01,AL12= 0.222453E-02,
     +AL20= 0.406463E-01,AL21=-0.101281E-01,AL22= 0.340919E-03,
     +A10 = 0.467733E+01,A11 =-0.619012E+00,A12 = 0.202225E-01,
     +A20 =-0.734101E+01,A21 = 0.100462E+01,A22 =-0.320985E-01,
     +A30 = 0.293119E+01,A31 =-0.403761E+00,A32 = 0.125153E-01,
     +BL00= 0.104133E+01,BL01=-0.943291E-02,BL02=-0.454758E-03,
     +BL10= 0.119253E+00,BL11= 0.407467E-01,BL12=-0.130718E-02,
     +BL20=-0.159391E-01,BL21= 0.727752E-02,BL22=-0.194405E-03,
     +B10 = 0.423071E+01,B11 =-0.610995E+00,B12 = 0.195531E-01,
     +B20 =-0.712527E+01,B21 = 0.969160E+00,B22 =-0.274255E-01,
     +B30 = 0.269925E+01,B31 =-0.363283E+00,B32 = 0.955316E-02)
C.    ------------------------------------------------------------------
C.
C             Ensure cut-off avoids infra-red catastrophe.
C
      IF (GEKIN.LE.BCUTE) GO TO 30
      KCASE=NAMEC(9)
C
*******************************>  Z3=Q(JPROB+2)
      Z3=(Z*(Z+1.))**0.3333333
      IF(Z3.LE.0.)GO TO 30
      Z32=Z3**2
      EEL1   = GETOT
      XC=BCUTE/GEKIN
      ALXC=LOG(XC)
      U=LOG(GEKIN/EMASS)
      U2=U**2
      V=LOG(Z)
*
      IF(GEKIN.LE.TLIM) THEN
         AL0=AL00+AL01*Z3+AL02*Z32
         AL1=AL10+AL11*Z3+AL12*Z32
         AL2=AL20+AL21*Z3+AL22*Z32
         AL=AL0+AL1*U+AL2*U2
         BL0=BL00+BL01*Z3+BL02*Z32
         BL1=BL10+BL11*Z3+BL12*Z32
         BL2=BL20+BL21*Z3+BL22*Z32
         BL=BL0+BL1*U+BL2*U2
         GMAX=1.+AL*XC+BL*XC**2
         IF(GEKIN.LT.0.0001) THEN
            G1=1.+AL+BL
            IF(G1.GT.GMAX) GMAX=G1
*
            IF(ABS(AL).GT.1.e-6) THEN
              X0=-BL/(2.*AL)
              IF((XC.LT.X0).AND.(X0.LT.1.)) THEN
                 G0=1.+AL*X0+BL*X0**2
                 IF(G0.GT.GMAX) GMAX=G0
              ENDIF
            ENDIF
*
         ENDIF
      ELSE
         U3=U2*U
         A1=A10+A11*Z3+A12*Z32
         A2=A20+A21*Z3+A22*Z32
         A3=A30+A31*Z3+A32*Z32
         AH=1.+A1/U+A2/U2+A3/U3
         B1=B10+B11*Z3+B12*Z32
         B2=B20+B21*Z3+B22*Z32
         B3=B30+B31*Z3+B32*Z32
         BH=0.75+B1/U+B2/U2+B3/U3
*
         F=4*V-0.55*V**2
         DEL0=136.*EMASS/(Z3*EEL1)
         EPC=XC*GEKIN/EEL1
         DC=DEL0*EPC/(1.-EPC)
         CC=42.392-F
*
         IF(DC.LE.1.) THEN
            DC2=DC**2
            F1=(42.392-7.796*DC+1.961*DC2-F)/CC
            F2=(41.734-6.484*DC+1.250*DC2-F)/CC
         ELSE
            F1=(42.24-8.368*LOG(DC+0.952)-F)/CC
            IF(F1.LT.0.) F1=0.
            F2=F1
         ENDIF
*
         GMAX=(1.-AH*EPC)*F1+BH*EPC**2*F2
      ENDIF
*
      CORR0=CORFAC*DENS*Z/A
      EPM=GEKIN/EEL1
      SC0=1.+CORR0/(EPM*EPM)
*
*     sample photon energy  ( according to 1/Ephoton)
*
   10 CALL GRNDM(RNDM,2)
*
      X=EXP(RNDM(1)*ALXC)
      EP=X*GEKIN/EEL1
*
*     Migdal correction for Ephoton->0. or no correction (Bethe)
*
+SELF, IF=-BETHE.
      CORR=SC0/(1.+CORR0/(EP*EP))
+SELF, IF=BETHE.
      CORR=1.
+SELF.
*
*     calculate rejection function g(x)
*
      IF(GEKIN.LE.TLIM) THEN
         G=1.+AL*X+BL*X**2
      ELSE
         D=DEL0*EP/(1.-EP)
         IF(D.LE.1.) THEN
            D2=D**2
            F1=(42.392-7.796*D+1.961*D2-F)/CC
            F2=(41.734-6.484*D+1.250*D2-F)/CC
         ELSE
            F1=(42.24-8.368*LOG(D+0.952)-F)/CC
            IF(F1.LT.0.) F1=0.
            F2=F1
         ENDIF
         G=(1.-AH*EP)*F1+BH*EP**2*F2
      ENDIF
      G=G*CORR/GMAX
      IF(RNDM(2).GT.G) GOTO 10
*
*     photon energy is sampled according to the Seltzer-Berger spectrum
*
      EGAMMA=EEL1*EP
C
C        CUT ON ENERGY THRESHOLD ?
C
      IF((IBREM.NE.1).OR.(EGAMMA.LE.CUTGAM)) THEN
         DESTEP = DESTEP + EGAMMA
         GO TO 20
      ENDIF
C
C             Generate emitted photon angles with respect to a Z-axis
C             defined along parent track. PHI is generated isotropically
C             and THETA is assigned a universal angular distribution
C
      EMASS1 = EMASS
      THETA  = GBTETH(EEL1, EMASS1, EP)*EMASS/EEL1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      NGKINE = NGKINE + 1
      GKIN(1,1)=EGAMMA*SINTH*COSPHI
      GKIN(2,1)=EGAMMA*SINTH*SINPHI
      GKIN(3,1)=EGAMMA*COSTH
      GKIN(4,1)=EGAMMA
      GKIN(5,1)=1.
      TOFD(1)  =0.
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
C             Rotate photon into GEANT system
C
      CALL GVROT(VECT(4),GKIN)
C
C             Correct track for lost energy
C
   20 CONTINUE
      GEKIN = GEKIN - EGAMMA
      GETOT = GEKIN + EMASS
      VECT(7)=SQRT (ABS((GETOT+EMASS)*GEKIN))
      CALL GEKBIN
C
C             Update probabilities
C
   30 CALL GRNDM(RNDM,1)
      ZINTBR=-LOG(RNDM(1))
C
      END
+DECK,  GBREMM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      SUBROUTINE GBREMM
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates discrete hard BREMSSTRAHLUNG by muons.              *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GTMUON                                       *
C.    *       Author     L.Urban  *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCONSP.
+CDE, GCTRAK.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCCUTS.
      DIMENSION RNDM(2)
C.
C.    ------------------------------------------------------------------
C.
C             Ensure cut-off avoids infra-red catastrophe.
C
      EEM1   = GETOT
      IF (GEKIN.LE.BCUTM) GO TO 900
      KCASE  = NAMEC(9)
C
      C1   = Q(JPROB+31)
      C2   = Q(JPROB+32)
      C3   = Q(JPROB+33)
      VC   = BCUTM/EEM1
      VM   = 1.-C3/EEM1
      IF(VM.LE.0.)GO TO 900
      CREJ = C2/EEM1
C
  50  CALL GRNDM(RNDM,2)
      R    = RNDM(1)
      V    = VC*(VM/VC)**R
C
C             Compute rejection function
C
      V1   = 1.-V
      F1   = C1-LOG(1.+CREJ*V/V1)
      SCREJ= (V1+0.75*V*V)*F1/C1
      IF(RNDM(2).GT.SCREJ)GO TO 50
C
C             Photon energy
C
      EGAMMA=EEM1*V
C
C        CUT ON ENERGY THRESHOLD ?
C
      IF((IBREM.NE.1).OR.(EGAMMA.LE.CUTGAM)) THEN
          NGKINE = 0
          DESTEP = DESTEP + EGAMMA
          GO TO 800
      ENDIF
C
C             Generate emitted photon angles with respect to a Z-axis
C             defined along parent track. PHI is generated isotropically
C             and THETA is assigned a universal angular distribution
C
      THETA  = GBTETH(EEM1, AMASS, V)*AMASS/EEM1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      NGKINE = 1
      GKIN(1,1)=EGAMMA*SINTH*COSPHI
      GKIN(2,1)=EGAMMA*SINTH*SINPHI
      GKIN(3,1)=EGAMMA*COSTH
      GKIN(4,1)=EGAMMA
      GKIN(5,1)=1.
      TOFD(1)  =0.
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
C             Rotate photon into GEANT system
C
      CALL GVROT(VECT(4),GKIN)
C
C             Correct track for lost energy
C
  800 CONTINUE
      GEKIN = GEKIN - EGAMMA
      GETOT = GEKIN + AMASS
      VECT(7)=SQRT (ABS((GETOT+AMASS)*GEKIN))
      CALL GEKBIN
C
C             Update probabilities
C
  900 CALL GRNDM(RNDM,1)
      ZINTBR=-LOG(RNDM(1))
      SLBREM=SLENG
      STEPBR=BIG
C
      END
+DECK,  GBRSGA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      SUBROUTINE GBRSGA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) electron BREMSSTRAHLUNG.                   *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCMATE.
+CDE, GCONSP.
+CDE, GCJLOC.
+CDE, GCCUTS.
+CDE, GCMULO.
C.
C.    ------------------------------------------------------------------
C.
C=======>                 Electrons & Positrons
C
      SIG=0.
      IF(Z.LT.1.)GO TO 20
C
C             Calculate mean free path using total cross-section
C             formula of L.Urban (see Write-up)
C
      T      = ELOW(IEKBIN)
      IF(JMIXT.EQ.0)THEN
C
C           element
C
         SIG=GBRSGE(Z,T,BCUTE)
         SIG=AVO*DENS*SIG/A
      ELSE
C
C           compound/mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         SIG=0.
         DO 10 I=1,NLM
            J   = JMIXT+NLM+I
            AA  = Q(J-NLM)
            ZZ  = Q(J)
            WMAT= Q(J+NLM)
            S   = GBRSGE(ZZ,T,BCUTE)
            S   = WMAT*S/AA
            SIG = SIG+AVO*DENS*S
  10     CONTINUE
      ENDIF
C
  20  IF(SIG.GT.0.)THEN
         Q(JBREM+IEKBIN)=1./SIG
         Q(JBREM+NEK1+IEKBIN)=1./(SIG*GBFSIG(T,BCUTE))
      ELSE
         Q(JBREM+IEKBIN)=BIG
         Q(JBREM+NEK1+IEKBIN)=BIG
      ENDIF
C
C=======>                 Muons
C
      SIG=0.
      IF(Z.LT.1.)GO TO 40
C
C             Calculate mean free path using total cross-section
C             formula of L.Urban (see Write-up)
C
      IF(T.LT.1.)GO TO 40
      IF(JMIXT.EQ.0)THEN
C
C           element
C
         SIG=GBRSGM(Z,T,BCUTM)
         SIG=AVO*DENS*SIG/A
      ELSE
C
C           compound/mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         SIG=0.
         DO 30 I=1,NLM
            J   = JMIXT+NLM+I
            AA  = Q(J-NLM)
            ZZ  = Q(J)
            WMAT= Q(J+NLM)
            S   = GBRSGM(ZZ,T,BCUTM)
            S   = WMAT*S/AA
            SIG = SIG+AVO*DENS*S
  30     CONTINUE
      ENDIF
C
  40  IF(SIG.GT.0.)THEN
         Q(JBREM+IEKBIN+2*NEK1)=1./SIG
      ELSE
         Q(JBREM+IEKBIN+2*NEK1)=BIG
      ENDIF
C
      END
+DECK,  GBRSGE, T=FORT.
* Revision 1.2  1996/09/30 13:30:10  ravndal
* Bremsstrahlung extension for higher energies
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      FUNCTION GBRSGE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) electron BREMSSTRAHLUNG.                   *
C.    *         (SIG in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRSGA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    *  correction for T> 100 GeV !  (by L.Urban on 23/09/96)         *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCMATE.
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      SAVE C
+SELF, IF=-BETHE.
      PARAMETER (AKSI=1.80,ALFA=0.98,VS=0.0001)
      DATA C1/ 0.430748E-02, 0.576058E-02,-0.122564E-02, 0.114843E-03
     +      ,-0.489452E-05, 0.795991E-07, 0.326746E-02,-0.132872E-02
     +      , 0.217197E-03,-0.179769E-04, 0.766114E-06,-0.125603E-07
     +      , 0.326452E-02,-0.175331E-02, 0.415488E-03,-0.507652E-04
     +      , 0.297569E-05,-0.651741E-07, 0.847189E-03,-0.433923E-03
     +      , 0.116672E-03,-0.166799E-04, 0.110237E-05,-0.263383E-07
     +      , 0.846052E-04,-0.415764E-04, 0.129610E-04,-0.212844E-05
     +      , 0.152871E-06,-0.384393E-08, 0.300838E-05,-0.136833E-05
     +      , 0.507296E-06,-0.943623E-07, 0.720305E-08,-0.187210E-09
     +      , 0.448230E-01,-0.210048E-01, 0.379434E-02,-0.328431E-03
     +      , 0.136710E-04,-0.220593E-06,-0.539248E-02, 0.330244E-02
     +      ,-0.733726E-03, 0.732312E-04,-0.336810E-05, 0.583913E-07
     +      ,-0.106983E-02, 0.378021E-03,-0.384854E-04, 0.978156E-06
     +      , 0.410622E-07,-0.174250E-08,-0.117501E-04,-0.983887E-05
     +      , 0.239644E-05,-0.190104E-06, 0.619226E-08,-0.680932E-10/
      DATA C2/ 0.168074E-03,-0.934609E-04, 0.141293E-04,-0.854216E-06
     +      , 0.183287E-07, 0.932144E-04,-0.234926E-04, 0.136656E-05
     +      , 0.351109E-07,-0.330189E-08, 0.174523E-04, 0.253854E-05
     +      ,-0.171643E-05, 0.183074E-06,-0.566331E-08, 0.111970E-05
     +      , 0.112776E-05,-0.386924E-06, 0.367597E-07,-0.108504E-08
     +      , 0.171604E-07, 0.738801E-07,-0.218761E-07, 0.199032E-08
     +      ,-0.576173E-10,-0.105531E-03, 0.362995E-04,-0.433334E-05
     +      , 0.207664E-06,-0.330250E-08,-0.168293E-05,-0.773204E-06
     +      , 0.227974E-06,-0.159385E-07, 0.321958E-09, 0.167046E-05
     +      ,-0.440761E-06, 0.396377E-07,-0.151053E-08, 0.215624E-10/
+SELF, IF=BETHE.
      PARAMETER (AKSI=1.80,ALFA=1.00,VS=0.0001)
      DATA C1/ 0.111394E-01, 0.138592E-02,-0.274910E-03, 0.198389E-04
     +      ,-0.472291E-06,-0.668760E-09, 0.839876E-02,-0.449619E-02
     +      , 0.917722E-03,-0.874992E-04, 0.390015E-05,-0.653499E-07
     +      , 0.464718E-02,-0.260321E-02, 0.582582E-03,-0.631769E-04
     +      , 0.325801E-05,-0.638109E-07, 0.101243E-02,-0.532089E-03
     +      , 0.129100E-03,-0.161260E-04, 0.958116E-06,-0.212606E-07
     +      , 0.926006E-04,-0.455288E-04, 0.124755E-04,-0.182510E-05
     +      , 0.122078E-06,-0.294182E-08, 0.308111E-05,-0.134712E-05
     +      , 0.436230E-06,-0.751770E-07, 0.552327E-08,-0.140541E-09
     +      , 0.292552E-02,-0.830719E-03, 0.210705E-04, 0.103750E-04
     +      ,-0.953318E-06, 0.236453E-07, 0.110907E-02,-0.219463E-03
     +      , 0.128517E-04,-0.554575E-06, 0.507378E-07,-0.182214E-08
     +      ,-0.639866E-03, 0.209918E-03,-0.250183E-04, 0.138030E-05
     +      ,-0.358845E-07, 0.366305E-09, 0.300095E-04,-0.133668E-04
     +      , 0.198606E-05,-0.133100E-06, 0.414062E-08,-0.485929E-10/
      DATA C2/ 0.938677E-04,-0.613470E-04, 0.981984E-05,-0.646289E-06
     +      , 0.150731E-07, 0.331764E-04, 0.447248E-05,-0.313021E-05
     +      , 0.329777E-06,-0.997210E-08, 0.876484E-08, 0.110042E-04
     +      ,-0.313406E-05, 0.280040E-06,-0.794116E-08,-0.103097E-05
     +      , 0.220550E-05,-0.569158E-06, 0.491359E-07,-0.136987E-08
     +      ,-0.781963E-07, 0.123162E-06,-0.302825E-07, 0.255485E-08
     +      ,-0.702300E-10,-0.193213E-03, 0.640349E-04,-0.720586E-05
     +      , 0.329673E-06,-0.514682E-08, 0.362138E-04,-0.142783E-04
     +      , 0.184063E-05,-0.967983E-07, 0.179386E-08, 0.496130E-06
     +      , 0.210105E-06,-0.538512E-07, 0.372388E-08,-0.812734E-10/
+SELF.
C.
      DATA THIGH,CHIGH/100.,50./
C.    ------------------------------------------------------------------
C.
      GBRSGE=0.
*
      IF(BCUT.LE.0.) GOTO 99
      IF(BCUT.GE.T) GOTO 99
*
      IF(T.GT.THIGH) THEN
          TT=THIGH
        IF(BCUT.GE.THIGH) THEN
            EC=CHIGH
        ELSE
            EC=BCUT
        ENDIF
      ELSE
          TT=T
          EC=BCUT
      ENDIF
*
      E=TT+EMASS
*
C
      X=LOG(E/EMASS)
      Y=LOG(E*VS/EC)
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=ZZ*(ZZ+AKSI)*E*E*(LOG(TT/EC))**ALFA/(TT*(E+EMASS))
      IF(FAC.LE.0.) GOTO 99
C
      GBRSGE=FAC*S
*
      IF(T.GT.THIGH) THEN

       IF(BCUT.LT.THIGH) THEN
        RAT=BCUT/T
        S=(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
        RAT=BCUT/TT
        S=S/(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
       ELSE
        RAT=BCUT/T
        S=(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
        RAT=EC/TT
        S=S/(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
       ENDIF

        GBRSGE=GBRSGE*S
      ENDIF
*
99    RETURN
*
      END
+DECK,  GBRSGM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      FUNCTION GBRSGM(Z,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) muon BREMSSTRAHLUNG.                       *
C.    *         (SIG in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRSGA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION C(52)
      SAVE C
      PARAMETER (AKSI=2.30,ALFA=1.06,GAM=0.63)
C
      PARAMETER (CONMX=0.130653)
C       CONMX=0.75*SQRT(2.7182...)*EMMU
      DATA C/ 0.949313E-07,-0.819600E-07, 0.529075E-07,-0.832023E-08
     +      , 0.539299E-09,-0.127042E-10,-0.165784E-08,-0.307788E-07
     +      , 0.977905E-08,-0.113658E-08, 0.574481E-10,-0.106221E-11
     +      , 0.968339E-09,-0.108640E-08,-0.177634E-09, 0.889497E-10
     +      ,-0.876878E-11, 0.264303E-12, 0.216263E-08,-0.152680E-08
     +      , 0.380989E-09,-0.455274E-10, 0.264172E-11,-0.596016E-13
     +      , 0.444927E-09,-0.272978E-09, 0.645634E-10,-0.748783E-11
     +      , 0.424890E-12,-0.940837E-14, 0.162289E-10,-0.362486E-11
     +      ,-0.576652E-12, 0.211269E-12,-0.185482E-13, 0.522065E-15
     +      ,-0.215590E-09, 0.112204E-09,-0.819133E-11, 0.145128E-12
     +      ,-0.206029E-09, 0.559940E-10,-0.483350E-11, 0.134252E-12
     +      ,-0.368469E-10, 0.999457E-11,-0.904967E-12, 0.272717E-13
     +      ,-0.303446E-11, 0.853429E-12,-0.785466E-13, 0.236435E-14/
C.
C.    ------------------------------------------------------------------
C.
      GBRSGM=0.
      IF(BCUT.GE.T) GOTO 99
C
      E=T+EMMU
      ECMAX=E-CONMX*Z**0.333333
      IF(BCUT.GE.ECMAX) GOTO 99
      X=LOG(E/EMMU)
      Y=LOG(BCUT/EMMU)
C
      S=0.
      YY=1.
      DO 30 I=1,6
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      SS=0.
      YY=1.
      DO 50 I=1,4
         XX=1.
         DO 40 J=1,4
            K=4*I+J+32
            SS=SS+C(K)*XX*YY
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=LOG(ECMAX/BCUT)
      IF(FAC.LE.0.) GOTO 99
      FAC=Z*(Z+AKSI*(1.+GAM*LOG(Z)))*FAC**ALFA
      GBRSGM=FAC*S
C
  99  RETURN
      END
+DECK,  GBTETH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:22  cernlib
* Geant

      REAL FUNCTION GBTETH(ENER,PARTM,EFRAC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Universal distribution function for the Bremsstrahlung       *
C.    *   and pair production angles. This function approximates       *
C.    *   the real distribution function which can be found in         *
C.    *   Yung-Su Tsai: Rev. Mod. Phys. 46,815(1974)                   *
C.    *     +erratum  : Rev. Mod. Phys. 49,421(1977)                   *
C.    *                                                                *
C.    *   Called by : GBREME, GBREMM, GPAIRG                           *
C.    *   Authors   : L.Urban                                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCMATE.
      DIMENSION RNDM(3)
      PARAMETER (ALFA=0.625)
*     ----------------------------------------------------------
* GEANT 3.15
*     GBTETH=1.
*     GOTO 999
* Angular distribution with d=const
*     D=27.
* Angular distribution with d=d(Z,E,y)
      D=0.13*(0.8+1.3/Z)*(100.+1./ENER)*(1.+EFRAC)
*     -------------------------------------------------------------
*
      W1=9./(9.+D)
      UMAX=ENER*PI/PARTM
*
10    CALL GRNDM(RNDM,3)
*
      IF(RNDM(1).LE.W1) THEN
         BETA=ALFA
      ELSE
         BETA=3.*ALFA
      ENDIF
*
      U=-(LOG(RNDM(2)*RNDM(3)))/BETA
*
*     cut : theta should be .LE. PI  !!
*     this condition depend on E in the case of d=const too!!!!!
*
      IF(U.GE.UMAX) GOTO 10
*
      GBTETH=U
*
 999  END
+DECK,  GCBREM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      FUNCTION GCBREM(T)
C.    ******************************************************************
C.    *                                                                *
C.    *  It calculates the ratio of positron to electron               *
C.    *       bremsstrahlung energy loss.                              *
C.    *                                                                *
C.    *  Input:kinetic energy in GeV                                   *
C.    *  Output: ratio of positron to electron brems energy loss       *
C.    *                                                                *
C.    *  ( The ratio is calculated from a function fitted to the       *
C.    *    results of L.Kim et al.,PHYS.REV.A33,3002(1986)    )        *
C.    *                                                                *
C.    *  Author   L. Urban                                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCMATE.
+CDE, GCONSP.
      PARAMETER (AA=7522100.,A1=0.415,A3=0.0021,A5=0.00054)
C.
      CFAC=0.
      IF(Z.LE.0.) GOTO 10
      X=LOG(AA*T/Z**2)
*
      IF(X.LE.-8.) GOTO 10
*
      IF(X.GE.+9.) THEN
         CFAC=1.
      ELSE
         W=A1*X+A3*X**3+A5*X**5
         CFAC=0.5+ATAN(W)/PI
      ENDIF
*
   10 GCBREM = CFAC
*
      END
+DECK,  GCOEFF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GCOEFF
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the coefficients for the energy loss               *
C.    *     interpolation                                              *
C.    *     There are 4 tables : electron,positron,muon,proton         *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author      F.Carminati *********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCJLOC.
+CDE, GCMULO.
+CDE, GCONSP.
+CDE, GCMATE.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION CX1,CX2,CX3,CY1,CY2,CY3,CDEN1,CDEN2,CDEN3
      DOUBLE PRECISION ACOEFF,BCOEFF,CCOEFF,XRAT,CCOEF1,CCOEF3
      DOUBLE PRECISION SQEPSM,CFACT
      PARAMETER (EPSMAC=1E-6)
+SELF, IF=SINGLE.
      PARAMETER (EPSMAC=1E-11)
+SELF.
*
      SQEPSM = MAX(1.,91./NEK1)*10.*SQRT(EPSMAC)
      DO 10 IEKBIN=1,NEK1-2
*
         I1 = IEKBIN
         I2 = I1 + 1
         I3 = I2 + 1
         CY1 = ELOW(I1)
         CY2 = ELOW(I2)
         CY3 = ELOW(I3)
         IECOEF = 3*(IEKBIN-1)
*
* *** Electrons
*
         JRANG = LQ(JMA-15)
         JCOEF = LQ(JMA-17)
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
* *** Positons
*
         JRANG = LQ(JMA-15) + NEK1
         JCOEF = LQ(JMA-17) +3*NEK1
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
* *** Muons
*
         JRANG = LQ(JMA-16)
         JCOEF = LQ(JMA-18)
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
* *** Protons
*
         JRANG = LQ(JMA-16) + NEK1
         JCOEF = LQ(JMA-18) +3*NEK1
*
         CX1 = Q(JRANG+I1)
         CX2 = Q(JRANG+I2)
         CX3 = Q(JRANG+I3)
         IF(CX1.NE.CX2.AND.CX1.NE.CX3.AND.CX2.NE.CX3) THEN
            CDEN1 = 1./((CX1-CX2)*(CX1-CX3))
            CDEN2 = 1./((CX2-CX1)*(CX2-CX3))
            CDEN3 = 1./((CX3-CX1)*(CX3-CX2))
            ACOEFF = CY1*CDEN1+CY2*CDEN2+CY3*CDEN3
            BCOEFF = -(CY1*(CX2+CX3)*CDEN1+CY2*(CX1+CX3)*CDEN2+
     +                 CY3*(CX1+CX2)*CDEN3)
            CCOEFF = CY1*CX2*CX3*CDEN1+CX1*CY2*CX3*CDEN2+
     +               CX1*CX2*CY3*CDEN3
            IF(ACOEFF.EQ.0.) THEN
               XRAT = 0.
            ELSEIF(BCOEFF.GT.0.) THEN
               CFACT  = SQRT(ABS(ACOEFF))
               CCOEF1 = SQRT(ABS(CCOEFF-CY1))*CFACT
               CCOEF3 = SQRT(ABS(CCOEFF-CY3))*CFACT
               XRAT   = MAX(CCOEF1,CCOEF3)/BCOEFF
            ELSE
               XRAT=1.
            ENDIF
            IF(XRAT.LE.SQEPSM) THEN
               Q(JCOEF+IECOEF+1) = 0.
               Q(JCOEF+IECOEF+2) = BCOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF
            ELSE
               Q(JCOEF+IECOEF+1) = ACOEFF
               Q(JCOEF+IECOEF+2) = 0.5*BCOEFF/ACOEFF
               Q(JCOEF+IECOEF+3) = CCOEFF/ACOEFF
            ENDIF
         ENDIF
*
   10 CONTINUE
*
      END
+DECK,  GCOMP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GCOMP
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates photon-electron COMPTON scattering.                 *
C.    *                                                                *
C.    *  The scattered photon energy is sampled using the quantum-     *
C.    *  mechanical KLEIN-NISHINA formula. For this, the random       *
C.    *  number techniques of BUTCHER and MESSEL(NUC. PHYS.20(1960),   *
C.    *  15) are employed.                                             *
C.    *  NOTE :                                                        *
C.    *  (1) Effects due to binding of atomic electrons are            *
C.    *      ignored(recoil electron energy assumed large compared     *
C.    *      with binding energy).                                     *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCPHYS.
+CDE, GCTRAK.
+CDE, GCKING.
+CDE, GCONSP.
+CDE, GCCUTS.
      DIMENSION PGAM(3)
      REAL RNDM(5)
      LOGICAL ROTATE
C.
C.    ------------------------------------------------------------------
C.
      KCASE  = NAMEC(7)
      EGAM1  = VECT(7)
      EZERO  = EGAM1/EMASS
      EMINI  = 1.+2.*EZERO
      EMIN   = 1./EMINI
      DSIG1  = LOG(EMINI)
      DSIG2  = 0.5*(1.-EMIN*EMIN)
      DSIGT  = DSIG1+DSIG2
C
C             Decide which part of F(E)=1/E+E to sample from.
C
   10 CALL GRNDM(RNDM,3)
      IF (DSIG1.LT.DSIGT*RNDM(1))THEN
C
C             Sample from F2(E) distribution.
C
         BRD    = RNDM(2)
         CALL GRNDM(RNDM(4),1)
         IF (EZERO.GE.(EZERO+1.)*RNDM(4))THEN
            CALL GRNDM(RNDM(5),1)
            BRD    = MAX(BRD,RNDM(5))
         ENDIF
C
         BR     = EMIN+(1.-EMIN)*BRD
      ELSE
         BR     = EMIN*EXP(DSIG1*RNDM(2))
      ENDIF
C
C             Scattered photon energy.
C
      EGAM2  = BR*EGAM1
C
C             Calculate rejection function G(E).
C
      T      = EMASS*(1.-BR)/EGAM2
      SINTH  = MAX(0.,T*(2.-T))
      REJ    = 1.0-(BR*SINTH)/(1.+BR*BR)
      IF (RNDM(3).GT.REJ)                        GO TO 10
C
C             Successful sampling of scattered photon.
C
C             CUTS ON ENERGY THRESHOLDS ?
C
      TEL     = EGAM1-EGAM2
      IF((EGAM2.LE.CUTGAM).AND.(TEL.LE.CUTELE)) THEN
         ISTOP = 2
         VECT(7) = 0.
         GEKIN = 0.
         GETOT = 0.
         NGKINE = 0.
         DESTEP = DESTEP + EGAM1
         RETURN
      ENDIF
C
C             Generate photon angles with respect to a Z-axis
C             defined along the parent photon.
C             PHI is generated isotropically
C
      SINTH  = SQRT(SINTH)
      COSTH  = 1.-T
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      PGAM(1) = EGAM2*SINTH*COSPHI
      PGAM(2) = EGAM2*SINTH*SINPHI
      PGAM(3) = EGAM2*COSTH
C
C             Momentum vector of recoil electron.
C
      NGKINE = 1
      EEL    = TEL + EMASS
      GKIN(1,1) = -PGAM(1)
      GKIN(2,1) = -PGAM(2)
      GKIN(3,1) = EGAM1-PGAM(3)
      GKIN(4,1)=EEL
      GKIN(5,1)=3
      TOFD(NGKINE)=0.
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
C             Rotate electron and scattered photon into GEANT system
C
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
      IF(ROTATE) THEN
         CALL GDROT(PGAM(1),COSTH,SINTH,COSPH,SINPH)
         CALL GDROT(GKIN,COSTH,SINTH,COSPH,SINPH)
      ENDIF
C
C             Correct photon for energy lost and scattered angle
C
      DO 60 I=1,3
   60 VECT(I+3) = PGAM(I)/EGAM2
      VECT(7) = EGAM2
      GETOT = EGAM2
      GEKIN = EGAM2
      CALL GEKBIN
C
C              Stop electron ?
C
      IF((ICOMP.NE.1).OR.(TEL.LE.CUTELE)) THEN
         NGKINE = 0
         DESTEP = DESTEP + TEL
      ENDIF
C
C             Update probabilities
C
      CALL GRNDM(RNDM,1)
      ZINTCO=-LOG(RNDM(1))
C
      END
+DECK,  GCOMPI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GCOMPI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for COMPTON scattering.                                       *
C.    *                                                                *
C.    *  The total cross-section of L.Urban is used to estimate the    *
C.    *  photon mean free path.                                        *
C.    *    It gives a good description of the data from 10KeV to       *
C.    *    100/Z GeV                                                   *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, L.Urban  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GCJLOC.
+CDE, GCMULO.
      DIMENSION PCOMP(12),P(4)
      DATA AC,BC,CC/20.,230.,440./
      DATA PCOMP/ 0.27965,-0.18300,0.67527E+1,-0.19798E+2,
     +            0.19756E-4,-0.10205E-1,-0.73913E-1,0.27079E-1,
     +           -0.39178E-6,0.68241E-4,0.60480E-4,0.30274E-3/
      DATA PI2R2I/2.004275/
C.
C.    ------------------------------------------------------------------
C.
C             Energy cut-off above which we ignore COMPTON scattering.
C
      SIG=0.
      IF(Z.LT.1.)GO TO 90
      EGAM   = ELOW(IEKBIN)
      X=EGAM/EMASS
      IF(EGAM.GT.(100./Z))GO TO 90
      X2=X*X
      JPROB=LQ(JMA-4)
C
      DO 20 I=1,4
         C=1.
         P(I)=0.
         DO 10 J=1,3
            JJ=4*J+I-4
            P(I)=P(I)+C*PCOMP(JJ)
            C=C*Z
  10     CONTINUE
  20  CONTINUE
C
      SIG=P(1)*LOG(1.+2.*X)/X
      SIG=SIG+(P(2)+P(3)*X+P(4)*X2)/(1.+AC*X+BC*X2+CC*X2*X)
      SIG=PI2R2I*Q(JPROB+17)*SIG
C
  90  IF(SIG.GT.0.)THEN
         Q(JCOMP+IEKBIN)=1./SIG
      ELSE
         Q(JCOMP+IEKBIN)=BIG
      ENDIF
C
      END
+DECK,  GDECA2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GDECA2(XM0,XM1,XM2,PCM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates two body decay process with isotropic angular       *
C.    *  distribution in CMS.                                          *
C.    *                                                                *
C.    *    ==>Called by : GDECAY                                       *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION PCM(4,2)
      DIMENSION RNDM(2)
C.
C.    ------------------------------------------------------------------
C.
C             Generate first decay product in CMS.
C
      E1=(XM0*XM0+XM1*XM1-XM2*XM2)/(2.*XM0)
      P1=SQRT(ABS((E1-XM1)*(E1+XM1)))
C
C             Isotropic decay angular distribution.
C
      CALL GRNDM(RNDM,2)
      COSTH=2.*RNDM(1)-1.
      IF(ABS(COSTH).GE.1.0) THEN
         COSTH=SIGN(1.,COSTH)
         SINTH=0.
      ELSE
         SINTH=SQRT((1.-COSTH)*(1.+COSTH))
      ENDIF
      PHI=TWOPI*RNDM(2)
C
C             Polar co-ordinates to momentum components.
C
      PCM(1,1)=P1*SINTH*COS(PHI)
      PCM(2,1)=P1*SINTH*SIN(PHI)
      PCM(3,1)=P1*COSTH
      PCM(4,1)=E1
C
C             Generate second decay product.
C
      PCM(1,2)=-PCM(1,1)
      PCM(2,2)=-PCM(2,1)
      PCM(3,2)=-PCM(3,1)
      PCM(4,2)=SQRT(PCM(1,2)**2+PCM(2,2)**2+PCM(3,2)**2+XM2*XM2)
C
      END
+DECK,  GDECA3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GDECA3(XM0,XM1,XM2,XM3,PCM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine simulates three-body decays in center-of-mass.  *
C.    *   Written by Jurgen Schukraft and Vincent Hedberg for R807.    *
C.    *   Adapted for Geant3 by Sverker Johansson (Aug-1987).          *
C.    *   (Quite extensive modifications; comments etc. are not always *
C.    *    consistent with the code anymore. )                         *
C.    *                                                                *
C.    *   As it is, the decay is done according to pure phase-space.   *
C.    *   There is code in the routine to properly treat K decays (V-A)*
C.    *   but it is not used. (Requires an additional parameter        *
C.    *   in the call, to tell which type of decay.)                   *
C.    *                                                                *
C.    *    ==>Called by : GDECAY                                       *
C.    *       Author    S. Johansson  *********                        *
C.    *                                                                *
C.    ******************************************************************
C.
***************************************************************
******* original name :                     *******************
******SUBROUTINE  D E C 3 B (ID,IP,K1,K2,K3)*******************
***************************************************************
C--------------------------------------------------------
C      O B S O L E T E   C O M M E N T   ! ! !
C     THIS ROUTINE SIMULATES THE THREE-BODY DECAYS OF:
C--------------------------------------------------------
C     ID = 1 : ETA   INTO  PI0 + PI0 + PI0     PHASE SPACE
C     ID = 2 : OMEGA INTO  PI0 + PI- + PI+        - " -
C     ID = 3 : ETAPR INTO  PI0 + PI0 + ETA        - " -
C     ID = 4 : K+/-  INTO  E+/- + PI0 + NU        (V-A)
C     ID = 5 : K0L   INTO  E+/- + PI-/+ + NU      - " -
C     ID = 6 : D     INTO  E   +  K  + NU      PHASE SPACE
C     ID = 7 : D     INTO  E   +  K* + NU         - " -
**      (** or any other decay; input is now masses
**          rather than process ID   S.J.
**          But the ID parameter could someday be useful
**          since it controls the non-phase-space code. ***)
C--------------------------------------------------------
C     THE OUTPUT COMMON BLOCK /LAB/ PLAB(20,J) IS FILLED
*       (** Not a common block anymore.  S.J. **)
C     ACCORDING TO THE ORDER OF THE SECONDARY PARTICLES
C     AS THEY APPEARE IN THE COMMENTS ABOVE. FOR EXAMPLE,
C     IN THE CASE OF ID=6 (D-MESON DECAY)
C     J = K1 IN PLAB(20,J) CORRESPONDS TO ELECTRON,
C     J = K2  -- " -- " -- " -- " --  K-MESON,
C     J = K3  -- " -- " -- " -- " --  NEUTRINO
C--------------------------------------------------------
      DIMENSION  P(20,20)
      DIMENSION  HM(4,7)
      DIMENSION  PCM(4,3)
      DIMENSION RNDM(3)
*
****************************************************
*   Translation from new to old input parameters :
*      ( S.J. )
****************************************************
      ID = 1
      HM(1,ID) = XM1
      HM(2,ID) = XM2
      HM(3,ID) = XM3
      HM(4,ID) = XM0
      K1 = 1
      K2 = 2
      K3 = 3
      PI2 = 2. * 3.141592654
***********************
*  Original code :
C--------------------------------------------------------
C     SIMULATION OF SECONDARY PARTICLE MOMENTA
C     IN THE REST FRAME OF PARENT PARTICLE
C--------------------------------------------------------
      T0=HM(4,ID)-HM(1,ID)-HM(2,ID)-HM(3,ID)
  10  CALL GRNDM(RNDM,2)
      G1=RNDM(1)
      G2=RNDM(2)
      GMI=MIN(G1,G2)
      GMA=MAX(G1,G2)
      TE=GMI*T0
      TM=(1.-GMA)*T0
      TN=(GMA-GMI)*T0
      PA1=SQRT(TE**2+2.*HM(1,ID)*TE)
      PA2=SQRT(TM**2+2.*HM(2,ID)*TM)
      PA3=SQRT(TN**2+2.*HM(3,ID)*TN)
C--------------------------------------------------------
C     CHECK OF THE MOMENTUM CONSERVATION
C--------------------------------------------------------
      PMMM=MAX(PA1,PA2)
      PMAX=MAX(PA3,PMMM)
      SP=PA1+PA2+PA3
      IF(PMAX.GE.SP-PMAX) GOTO 10
      P(4,K1)=TE+HM(1,ID)
      P(4,K2)=TM+HM(2,ID)
      P(4,K3)=TN+HM(3,ID)
C--------------------------------------------------------
C     ACCOUNTING FOR MATRIX ELEMENT (FOR ID=4 AND 5)
*     (** Calculates correct (V-A) decay for kaons.       **)
*     (** Now inactive.  Change ID to activate it. (S.J)  **)
C--------------------------------------------------------
      IF(ID.NE.4.AND.ID.NE.5) GOTO 20
      EEM=((HM(4,ID)-HM(2,ID))**2+HM(1,ID)**2-
     *      HM(3,ID)**2)/(2.*(HM(4,ID)-HM(2,ID)))
      HMMAX=EEM*(HM(4,ID)-HM(2,ID)-EEM)+
     *      0.5*(EEM**2-HM(1,ID)**2)
      HMA=P(4,K1)*P(4,K3)+0.25*(PA1**2+PA3**2-PA2**2)
      CALL GRNDM(RNDM,1)
      GG=RNDM(1)
      IF(HMA.LT.GG*HMMAX) GOTO 10
C--------------------------------------------------------
C     CALCULATIONS OF MOMENTA
C--------------------------------------------------------
20    CONTINUE
      CALL GRNDM(RNDM,3)
      CTE=2.*RNDM(1)-1.
      STE=SQRT(ABS(1.-CTE**2))
      FE =PI2*RNDM(2)
      CFE=COS(FE)
      SFE=SIN(FE)
      P(1,K1)=PA1*STE*CFE
      P(2,K1)=PA1*STE*SFE
      P(3,K1)=PA1*CTE
      CTEN=(PA2**2-PA1**2-PA3**2)/(2.*PA1*PA3)
      STEN=SQRT(ABS(1.-CTEN**2))
      FEN =PI2*RNDM(3)
      CFEN=COS(FEN)
      SFEN=SIN(FEN)
      P(1,K3)=PA3*(STEN*CFEN*CTE*CFE-STEN*SFEN*SFE+CTEN*STE*CFE)
      P(2,K3)=PA3*(STEN*CFEN*CTE*SFE+STEN*SFEN*CFE+CTEN*STE*SFE)
      P(3,K3)=PA3*(-STEN*CFEN*STE+CTEN*CTE)
      P(1,K2)=-P(1,K1)-P(1,K3)
      P(2,K2)=-P(2,K1)-P(2,K3)
      P(3,K2)=-P(3,K1)-P(3,K3)
C-------------------------------------------------------
***   Re-translation from old to new output arrays : ***
***     (S.J.)                                       ***
***--------------------------------------------------***
      DO 37 I=1,4
        DO 38 J=1,3
          PCM(I,J) = P(I,J)
 38     CONTINUE
 37   CONTINUE
      END
+DECK,  GDECAY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GDECAY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Control routine for generation of particle decays.            *
C.    *                                                                *
C.    *  MODE(I)        I'th decay mode of current particle            *
C.    *  BRATIO(I)      branching ratio for I'th decay mode of         *
C.    *                 current particle.                              *
C.    *                                                                *
C.    *    ==>Called by : GHSTOP,GTHADR,GTNEUT,GTMUON                  *
C.    *       Author    G.Patrick *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCKING.
+CDE, GCKINE.
+CDE, GCUNIT.
+CDE, GCPHYS.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
      DIMENSION BAREA(7)
      DIMENSION BETA(4)
      DIMENSION BRATIO(6)
      DIMENSION MODE(6)
      DIMENSION NTYPE(3)
      DIMENSION PCM(4,3)
      DIMENSION XM(3)
      DIMENSION RNDM(1)
      LOGICAL ROTATE
C.
C.    ------------------------------------------------------------------
C.
C             Search for parent particle in decay list.
C
C
      KCASE   = NAMEC(5)
      NGKINE  = 0
      IF(IDCAY.EQ.2) THEN
         DESTEP = DESTEP+GETOT
         ISTOP  = 2
         GO TO 99
      ENDIF
      DMASS = AMASS
      JPA = LQ(JPART-IPART)
      JDK1 = LQ(JPA-1)
      JDK2 = LQ(JPA-2)
      IF (JDK1.LE.0)                               GO TO 90
      IF (JDK2.LE.0)                               GO TO 90
      DO 5 I=1,6
         BRATIO(I)=Q(JDK1+I)
         MODE(I)=IQ(JDK2+I)
   5  CONTINUE
C
C             Generate branching ratio and select decay mode.
C
      NBR      = 1
      BAREA(1) = 0.
      DO 10 I=2,7
         BRADD    = BRATIO(I-1)
         IF (BRADD.EQ.0.) GO TO 20
         NBR      = NBR+1
         BAREA(I) = BAREA(I-1)+BRADD
  10  CONTINUE
C
  20  CALL GRNDM(RNDM,1)
      BRAND    = 100.*RNDM(1)
      IF (BRAND.GE.BAREA(NBR)) GO TO 99
      ID       = IABS((LOCATF(BAREA,NBR,BRAND)))
C
C             Unpack decay mode.
C
      MXX      = MODE(ID)
      NTYPE(1) = MOD(MXX,100)
      NTYPE(2) = MOD(MXX/100,100)
      JP1 = LQ(JPART-NTYPE(1))
      JP2 = LQ(JPART-NTYPE(2))
      XM(1) = Q(JP1+7)
      XM(2) = Q(JP2+7)
      IF (MXX.LT.10000)THEN
C
C             Two body decay.
C
         NGKINE  = 2
         IF (TLIFE.LT.1.E-15) THEN
            XMTOT = XM(1)+XM(2)
            DO 30 I=1,1000
C--  Create Lorentz distributed energy with FWHM HBAR/TLIFE.
C--  (via integral-transformation of Lorentz-distribution)
C--                 (M.Guckes)
              CALL GRNDM(RNDM,1)
              RMASS = DMASS
     1                + 3.291086E-25/TLIFE * TAN(PI*(RNDM(1)-0.5))
              IF (RMASS.GE.XMTOT) GO TO 40
 30         CONTINUE
            WRITE(CHMAIL,1000) IPART, NTYPE(1), NTYPE(2)
            CALL GMAIL(0,0)
            NGKINE=0
            GO TO 99
 40         DMASS = RMASS
         END IF
         CALL GDECA2(DMASS,XM(1),XM(2),PCM)
      ELSE
C
C             Three body decay.
C
         NTYPE(3) = MXX/10000
         NGKINE  = 3
         JP3 = LQ(JPART-NTYPE(3))
         XM(3) = Q(JP3+7)
         IF (TLIFE.LT.1.E-15) THEN
            XMTOT = XM(1)+XM(2)+XM(3)
            DO 31 I=1,1000
C--  Create Lorentz distributed energy with FWHM HBAR/TLIFE.
C--  (via integral-transformation of Lorentz-distribution)
              CALL GRNDM(RNDM,1)
              RMASS = DMASS
     1                + 3.291086E-25/TLIFE * TAN(PI*(RNDM(1)-0.5))
              IF (RMASS.GE.XMTOT) GO TO 41
 31         CONTINUE
            WRITE(CHMAIL,1000) IPART, NTYPE(1), NTYPE(2), NTYPE(3)
            CALL GMAIL(0,0)
            NGKINE=0
            GO TO 99
 41         DMASS = RMASS
         END IF
         CALL GDECA3(DMASS,XM(1),XM(2),XM(3),PCM)
      ENDIF
C
C             LORENTZ boost into LAB system defined along parent vector
C             followed by rotation back into GEANT system.
C
      P0       = VECT(7)
      E0       = SQRT(P0*P0+DMASS*DMASS)
      BETA(1)  = 0.
      BETA(2)  = 0.
      BETA(3)  = -P0/E0
      BETA(4)  = E0/DMASS
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
C
      DO 60 K=1,NGKINE
         IF (P0.LE.0.) THEN
            DO 59 I = 1,3
   59       GKIN(I,K) = PCM(I,K)
         ELSE
            CALL GLOREN (BETA, PCM(1,K), GKIN(1,K))
         ENDIF
         IF(ROTATE) CALL GDROT  (GKIN(1,K),COSTH,SINTH,COSPH,SINPH)
         GKIN(4,K)=SQRT(GKIN(1,K)**2+GKIN(2,K)**2+GKIN(3,K)**2+XM(K)**2)
         GKIN(5,K)=NTYPE(K)
         TOFD(K)=0.
         GPOS(1,K) = VECT(1)
         GPOS(2,K) = VECT(2)
         GPOS(3,K) = VECT(3)
  60  CONTINUE
      GO TO 99
C
C             No branching ratio defined. Call user routine
C
+SELF, IF=-USRJMP.
  90  CALL GUDCAY
+SELF, IF=USRJMP.
  90  CALL JUMPT0(JUDCAY)
+SELF.
C
  99  RETURN
 1000 FORMAT(' ***** GDECAY ERROR : Not enough energy available for ',
     +       'decay of resonance',I3,' to',3I3,'; no decay.')
      END
+DECK,  GDRAY, T=FORT.
* Revision 1.2  1999/01/18 18:23:08  japost
*   Precision fix for momentum.
*    Origin of Fix:     Michel   Maire
*    Problem report
*     & further test:   Florence Ranjard
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GDRAY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Delta rays                                          *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTHADR,GTMUON                         *
C.    *       Authors    D.Ward, L.Urban  ********                     *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCPHYS.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCCUTS.
      DIMENSION PELS(3)
      DIMENSION RNDM(2)
      LOGICAL ROTATE
C.
C.    ------------------------------------------------------------------
C.
      P=VECT(7)
      XE=GETOT
      TE=GEKIN
      GAM=XE/AMASS
      GAM2=GAM*GAM
      T=GAM-1.
      X=DCUTE/(T*EMASS)
C
      KCASE = NAMEC(10)
      IF(IPART.EQ.3)   THEN
C
C======>       Moller scattering
C
        IF(X.GE.0.5) GO TO 90
        CC=1.-2.*X
C
  10    CALL GRNDM(RNDM,2)
        E=X/(1.-CC*RNDM(1))
C
        B1=4./(9.*GAM2-10.*GAM+5.)
        B2=T*T*B1
        B3=(2.*GAM2+2.*GAM-1.)*B1
        E1=1.-E
C
        SCREJ=B2*E*E-B3*E/E1+B1*GAM2/(E1*E1)
C
        IF(RNDM(2).GT.SCREJ) GOTO 10
C
      ELSEIF(IPART.EQ.2)THEN
C
C======>       Bhabha scattering
C
        IF(X.GE.1.) GO TO 90
        X1=1.-X
  20    CALL GRNDM(RNDM,2)
        E=X/(1.-X1*RNDM(1))
C
        Y=1./(GAM+1.)
        Y2=Y*Y
        C=1.-2.*Y
        B1=2.-Y2
        B2=C*(3.+Y2)
        C2=C*C
        B4=C2*C
        B3=C2+B4
        B0=GAM2/(GAM2-1.)
C
        SCREJ=(((B4*E-B3)*E+B2)*E-B1)*E+B0
        SCREJ=SCREJ/((((B4*X-B3)*X+B2)*X-B1)*X+B0)
        IF(RNDM(2).GT.SCREJ) GOTO 20
C
      ELSE
C
C======>     Heavy particle.
C
        TMAX=2.*EMASS*(GAM2-1.)/
     +  (1.+2.*GAM*EMASS/AMASS+(EMASS/AMASS)**2)
        IF(TMAX.LE.DCUTM)  GOTO 90
  40    CALL GRNDM(RNDM,2)
        E=1./DCUTM+RNDM(1)*(1./TMAX-1./DCUTM)
        E=1./E
        BET2=1.-1./GAM2
        SCREJ=1.-BET2*(E/TMAX)
C ---         extra term for spin 1/2 parent.
        IF(AMASS.GT.0.9 .OR. AMASS.LT.0.12)
     +  SCREJ=SCREJ+0.5*(E/GETOT)**2
        IF(RNDM(2).GT.SCREJ) GO TO 40
        E=E/(T*EMASS)
C
      ENDIF
C
      EEL=(T*E+1.)*EMASS
      TEL=EEL-EMASS
      PEL=SQRT(ABS((EEL+EMASS)*TEL))
      COSTH=(XE*EEL+EMASS*(TEL-XE))/(P*PEL)
      IF(COSTH.GE.1.) THEN
         COSTH=1.
         SINTH=0.
      ELSEIF(COSTH.LE.-1.) THEN
         COSTH=-1.
         SINTH=0.
      ELSE
         SINTH=SQRT((1.+COSTH)*(1.-COSTH))
      ENDIF
      CALL GRNDM(RNDM,1)
      PHI    = TWOPI*RNDM(1)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Polar co-ordinates to momentum components.
C
      NGKINE = 1
      GKIN(1,1)=PEL*SINTH*COSPHI
      GKIN(2,1)=PEL*SINTH*SINPHI
      GKIN(3,1)=PEL*COSTH
      GKIN(4,1)=EEL
      GKIN(5,1)=3
      TOFD(NGKINE)=0.
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
      PELS(1)=-GKIN(1,1)
      PELS(2)=-GKIN(2,1)
      PELS(3)=P-GKIN(3,1)
C
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
      IF(ROTATE) THEN
         CALL GDROT(PELS(1),COSTH,SINTH,COSPH,SINPH)
         CALL GDROT(GKIN,COSTH,SINTH,COSPH,SINPH)
      ENDIF
C
C             Correct track vector for lost energy and scattered angles
C
      TELS=TE-TEL
      EELS=TELS+AMASS
CC    PEELS=SQRT(ABS((EELS+AMASS)*TELS))
      PEELS=SQRT( PELS(1)**2 + PELS(2)**2 + PELS(3)**2)
      IF(PEELS.GT.0.)THEN
         DO 55 I=1,3
            VECT(I+3) = PELS(I)/PEELS
  55     CONTINUE
      ENDIF
      VECT(7) = PEELS
      GEKIN=TELS
      GETOT=EELS
      CALL GEKBIN
      IF((IDRAY.NE.1).OR.(TEL.LE.CUTELE)) THEN
          NGKINE = 0
          DESTEP = DESTEP + TEL
      ENDIF
C
C             Update probabilities
C
  90  CALL GRNDM(RNDM,1)
      ZINTDR=-LOG(RNDM(1))
      SLDRAY=SLENG
      STEPDR=BIG
C
      END
+DECK,  GDRELA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:23  cernlib
* Geant

      SUBROUTINE GDRELA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialise ionisation energy loss by filling proton DE/DX     *
C.    *  tables for each material.                                     *
C.    *                                                                *
C.    *  For chemical mixtures,compounds & molecules the approximation *
C.    *  is made that                                                  *
C.    *                                                                *
C.    *          DE/DX = W(1)*DE/DX(1)+W(2)*DE/DX(2)...+W(N)*DE/DX(N)  *
C.    *  with,                                                         *
C.    *          DE/DX(i) appropriate to the i'th constituent.         *
C.    *                                                                *
C.    *  For mixtures    W(i) = fractional wght of each element.       *
C.    *  For molecules   W(i) = No. atoms*atomic wght/molecular wght.  *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, G.Patrick  *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCMULO.
+CDE, GCJLOC.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCMATE.
C.
C.    ------------------------------------------------------------------
C.
C            Number of constituents(ie. element,mixture or compound).
C
      NLMAT = Q(JMA+11)
      NLMAT  = IABS(NLMAT)
      IF (NLMAT.EQ.0) GO TO 999
      IF(Z.LT.1.) GO TO 999
C
      JEL1=LQ(JMA-1)
      JEL2=LQ(JMA-2)
      JEL3=LQ(JMA-3)
C
      ICHAN=IEKBIN
      T      = ELOW(ICHAN)
      T1     = 10.**(EKBIN(1)+(ICHAN-0.5)/GEKA)
C
C==========>  A,Ionisation losses for particles other than electrons
C            Simple element.
C
      IF (NLMAT.EQ.1) THEN
         CALL GDRELP(A,Z,DENS,T,DEDX)
         IF(DEDX.LT.0.)DEDX=0.
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            CALL GDRELP(A,Z,DENS,T1,DEDX1)
            IF(DEDX1.LT.0.)DEDX1=0.
         ENDIF
      ELSE
C
C            Mixture/compound : Loop over chemical constituents.
C
         DEDX = 0.
         DEDX1 = 0.
         DO 10 L=1,NLMAT
            AA = Q(JMIXT+L)
            ZZ = Q(JMIXT+NLMAT+L)
            WGHT = Q(JMIXT+2*NLMAT+L)
            CALL GDRELP(AA,ZZ,DENS*WGHT,T,DEDXC)
            IF(DEDXC.LT.0.)DEDXC=0.
            DEDX = DEDX + WGHT*DEDXC
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               CALL GDRELP(AA,ZZ,DENS*WGHT,T1,DEDXC1)
               IF(DEDXC1.LT.0.)DEDXC1=0.
               DEDX1 = DEDX1 + WGHT*DEDXC1
            ENDIF
   10    CONTINUE
      ENDIF
C
      Q(JEL3+ICHAN)=Q(JEL3+ICHAN)+DEDX*DENS
      IF(ICHAN.NE.NEK1) THEN
         WS(NEKBIN*3+ICHAN) = WS(NEKBIN*3+ICHAN)+DEDX1*DENS
      ENDIF
C
C===========>  B, Ionisation losses for muons
C
C     Simple element
      IF(NLMAT.EQ.1) THEN
         CALL GDRELM(A,Z,DENS,T,DEDX)
         IF(DEDX.LT.0.)DEDX=0.
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            CALL GDRELM(A,Z,DENS,T1,DEDX1)
            IF(DEDX1.LT.0.)DEDX1=0.
         ENDIF
      ELSE
C
C     Mixture/compound
C
         DEDX = 0.
         DEDX1 = 0.
         DO 20 L=1,NLMAT
            AA=Q(JMIXT+L)
            ZZ=Q(JMIXT+NLMAT+L)
            WGHT=Q(JMIXT+2*NLMAT+L)
            CALL GDRELM(AA,ZZ,DENS*WGHT,T,DEDXC)
            IF(DEDXC.LT.0.)DEDXC=0.
            DEDX=DEDX+WGHT*DEDXC
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               CALL GDRELM(AA,ZZ,DENS*WGHT,T1,DEDXC1)
               IF(DEDXC1.LT.0.)DEDXC1=0.
               DEDX1 = DEDX1 + WGHT*DEDXC1
            ENDIF
   20    CONTINUE
      ENDIF
C
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX*DENS
      IF(ICHAN.NE.NEK1) THEN
         WS(NEKBIN*2+ICHAN) = WS(NEKBIN*2+ICHAN)+DEDX1*DENS
      ENDIF
C
C===========>  C, Ionisation losses for electrons/positrons
C
      CALL GDRELE(T,-1.,JMA,DEDX)
      Q(JEL1+ICHAN)=Q(JEL1+ICHAN)+DEDX
      CALL GDRELE(T,+1.,JMA,DEDX)
      Q(JEL1+ICHAN+NEK1)=Q(JEL1+ICHAN+NEK1)+DEDX
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         CALL GDRELE(T1,-1.,JMA,DEDX1)
         WS(ICHAN)=WS(ICHAN)+DEDX1
         CALL GDRELE(T1,+1.,JMA,DEDX1)
         WS(NEKBIN+ICHAN)=WS(NEKBIN+ICHAN)+DEDX1
      ENDIF
C
  999 END
+DECK,  GDRELE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDRELE(EEL,CHARGE,JMA,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Compute ion losses for electron/positron                 *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    G.Patrick *********                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCCUTS.
C
      DATA CONS/0.153536E-3/
C.
C.    ------------------------------------------------------------------
C.
      JPROB=LQ(JMA-4)
C
      GAM=EEL/EMASS + 1.
      GAM2=GAM*GAM
      T=GAM-1.
      DEDX=0.
      IF(T.LE.0.)GO TO 99
      TCME=DCUTE/EMASS
      BET2=1.-1./GAM2
C     ------------------------------
      IF(CHARGE.GT.0.) THEN
         Y=1./(1.+GAM)
         D=TCME
         IF(T.LT.TCME) D=T
         D2=D*D/2.
         D3=2.*D2*D/3.
         D4=D2*D2
         F=LOG(T*D)-BET2*(T+2.*D-Y*(3.*D2
     *    +Y*(D-D3+Y*(D2-T*D3+D4))))/T
C
      ELSE
        D=TCME
         IF(T.LT.2.*TCME) D=0.5*T
         F=-1.-BET2+LOG((T-D)*D)+T/(T-D)
     *    +(0.5*D*D+(1.+2.*T)*LOG(1.-D/T))/GAM2
      ENDIF
C
      POTL=Q(JPROB+11)
      FAC=Q(JPROB+12)
      C=Q(JPROB+13)
      X0=Q(JPROB+14)
      X1=Q(JPROB+15)
      AA=Q(JPROB+16)
C
      X=LOG(GAM2-1.)/4.606
      DEL=0.
      IF(X.GT.X0)THEN
         DEL=4.606*X+C
         IF(X.LE.X1)DEL=DEL+AA*(X1-X)**3.
      ENDIF
C
      DEDX=CONS*FAC*(LOG(2.*T+4.)-2.*POTL+F-DEL)/BET2
      IF(DEDX.LT.0.)DEDX=0.
C
  99  RETURN
      END
+DECK,  GDRELI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDRELI(A1,Z1,A2,Z2,DENS,T,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of an ion with charge Z1,    *
C.    *  atomic weight A1 and kinetic energy T in an element           *
C.    *  of atomic number Z2, atomic weight A2 and density             *
C.    *    DENS  ( the density is just used for the calculation        *
C.    *  of the density effect in the case of high T ).                *
C.    *  The routine reproduces the experimental and/or tabulated      *
C.    *  mean energy losses reasonably well.                           *
C.    *                                                                *
C.    *  The mean stopping power is obtained by calculating the proton *
C.    *  energy loss S at the equivalent proton kinetic energy  and    *
C.    *  multiplying this value by the effective charge of the ion.    *
C.    *  This method is used for high T ( T/A1 > Tamax , where         *
C.    *   Tamax depend on Z1 and Z2 , Tamax .le. few MeV).             *
C.    *  In the case of low T , the energy loss curve has been         *
C.    *  extrapolated down to T -> 0.                                  *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCCUTS.
+CDE, GCUNIT.
      PARAMETER (AMU=0.93149432,D=0.00015357)
*
      EM=A1*AMU
      TA=PMASS*T/EM
*
      Z11=Z1*Z1
      TAMAX=(120.902-3.121*Z1+0.270*Z11)-(35.988-27.794*Z1+0.120*Z11)*
     +                                                   LOG(Z2)
      TAMAX=0.000001*TAMAX
*
*     calculate  stopping power (total loss) , save DCUTM before
*
      CUTSAV=DCUTM
      DCUTM=BIG
*
      IF(TA.GE.TAMAX) THEN
*
*     "high energy" case
*
         CALL GDRELP(A2,Z2,DENS,TA,S)
         S=Z1**2*GEFCH2(Z1,Z2,TA)*S
      ELSE
*
*     "low energy" case
*
         CALL GDRELP(A2,Z2,DENS,TAMAX,S0)
         S0=Z1**2*GEFCH2(Z1,Z2,TAMAX)*S0
         R=TA/TAMAX
         S=S0*(2.*SQRT(R)-R)
      ENDIF
*
      DCUTM=CUTSAV
      TMAX=2.*EMASS*T*(T+2.*EM)/EM**2
*
*     check whether restricted loss needed ?
*     if restricted loss , calculate the loss from delta rays
*
      IF(DCUTM.LT.TMAX) THEN
         BET2=T*(T+2.*EM)/(T+EM)**2
         R=DCUTM/TMAX
         DELTA=-LOG(R)-BET2*(1.-R)
         DELTA=D*Z2*Z1**2*DELTA/(A2*BET2)
         S=S-DELTA
         IF(S.LT.0.) S=0.
      ENDIF
*
      DEDX=S
*
      END
+DECK,  GDRELM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDRELM(A,Z,DENS,T,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of a  MUON  with kinetic     *
C.    *  energy T in an element of atomic number Z, atomic weight A    *
C.    *  and density DENS ( the density is just used for the           *
C.    *  calculation of the density effect in the case of high T).     *
C.    *                                                                *
C.    *   ------------------------------------------------------       *
C.    *   It calls GDRELP with the substitution EMMU -- > PMASS !      *
C.    *    ( and put back the right value of PMASS after)       !      *
C.    *   -----------------------------------------------------        *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
*
      CALL GDRELX(A,Z,DENS,T,REAL(EMMU),DEDX)
*
      END
+DECK,  GDRELP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDRELP(A,Z,DENS,T,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of a  MUON  with kinetic     *
C.    *  energy T in an element of atomic number Z, atomic weight A    *
C.    *  and density DENS ( the density is just used for the           *
C.    *  calculation of the density effect in the case of high T).     *
C.    *                                                                *
C.    *   ------------------------------------------------------       *
C.    *   It calls GDRELP with the substitution EMMU -- > PMASS !      *
C.    *    ( and put back the right value of PMASS after)       !      *
C.    *   -----------------------------------------------------        *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
*
      CALL GDRELX(A,Z,DENS,T,REAL(PMASS),DEDX)
*
      END
+DECK,  GDRELX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDRELX(A,Z,DENS,T,HMASS,DEDX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the mean 1/DENS*dE/dx of a particle with kinetic   *
C.    *  energy T in an element of atomic number Z, atomic weight A    *
C.    *  and density DENS ( the density is just used for the           *
C.    *  calculation of the density effect in the case of high T).     *
C.    *  The routine reproduces the experimental and/or tabulated      *
C.    *  energy losses rather well down to T -> 0.                     *
C.    *  Simple parametrization is used for  T .le. T2L=2 MeV (see     *
C.    *  H.H.Andersen,J.F.Ziegler:Hydrogen stopping powers and         *
C.    *  ranges in all element,Pergamon Press,1977.).                  *
C.    *  For T .gt. T2L=2 MeV the corrected Bethe-Bloch stopping       *
C.    *  power / restricted energy loss formula is used.               *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GDRELA                                       *
C.    *       Author    L.Urban    *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCCUTS.
+CDE, GCUNIT.
      PARAMETER (AMUKEV=931494.32,D=0.000153537,T1L=0.00001,T2L=0.002)
      PARAMETER (EMPROT=0.9382723)
      DIMENSION B(6,92),C(6,92),CECOF(6)
*
      DATA ((B(I,J),I=1,6),J=1,19) /
     +     1.262,1.44,242.6,12000.,0.1159,18.8,
     +     1.229,1.397,484.5,5873.,0.05225,41.7,
     +     1.411,1.6,725.6,3013.,0.04578,47.6,
     +     2.248,2.59,966.,153.8,0.03475,62.7,
     +     2.474,2.815,1206.,1060.,0.02855,76.0,
     +     2.631,2.989,1445.,957.2,0.02819,77.3,
     +     2.954,3.35,1683.,1900.,0.02513,86.7,
     +     2.652,3.,1920.,2000.,0.0223,97.7,
     +     2.085,2.352,2157.,2634.,0.01816,120.,
     +     1.951,2.199,2393.,2699.,0.01568,139.,
     +     2.542,2.869,2628.,1854.,0.01472,148.,
     +     3.792,4.293,2862.,1009.,0.01397,156.,
     +     4.154,4.739,2766.,164.5,0.02023,162.,
     +     4.15,4.7,3329.,550.,0.01321,165.,
     +     3.232,3.647,3561.,1560.,0.01267,172.,
     +     3.447,3.891,3792.,1219.,0.01211,180.,
     +     5.047,5.714,4023.,878.6,0.01178,185.,
     +     5.731,6.5,4253.,530.,0.01123,194.,
     +     5.151,5.833,4482.,545.7,0.01129,193./
      DATA ((B(I,J),I=1,6),J=20,38) /
     +     5.521,6.252,4710.,553.3,0.01112,196.,
     +     5.201,5.884,4938.,560.9,0.009995,218.,
     +     4.862,5.496,5165.,568.5,0.009474,230.,
     +     4.48,5.055,5391.,952.3,0.009117,239.,
     +     3.983,4.489,5616.,1336.,0.008413,259.,
     +     3.469,3.907,5725.,1461.,0.008829,270.,
     +     3.519,3.963,6065.,1243.,0.007782,280.,
     +     3.14,3.535,6288.,1372.,0.007361,296.,
     +     3.553,4.004,6205.,555.1,0.008763,310.,
     +     3.696,4.175,4673.,387.8,0.02188,322.,
     +     4.21,4.75,6953.,295.2,0.006809,320.,
     +     5.041,5.697,7173.,202.6,0.006725,324.,
     +     5.554,6.3,6496.,110.,0.009689,330.,
     +     5.323,6.012,7611.,292.5,0.006447,338.,
     +     5.874,6.656,7395.,117.5,0.007684,340.,
     +     5.611,6.335,8046.,365.2,0.006244,349.,
     +     6.411,7.25,8262.,220.,0.006087,358.,
     +     5.694,6.429,8478.,292.9,0.006087,358.,
     +     6.339,7.159,8693.,330.3,0.006003,363./
      DATA ((B(I,J),I=1,6),J=39,57)  /
     +     6.407,7.234,8907.,367.8,0.005889,370.,
     +     6.734,7.603,9120.,405.2,0.005765,378.,
     +     6.902,7.791,9333.,442.7,0.005587,390.,
     +     6.425,7.248,9545.,480.2,0.005367,406.,
     +     6.799,7.671,9756.,517.6,0.005315,410.,
     +     6.108,6.887,9966.,555.1,0.005151,423.,
     +     5.924,6.677,10180.,592.5,0.004919,443.,
     +     5.238,5.9,10380.,630.,0.004758,458.,
     +     5.623,6.354,7160.,337.6,0.01394,466.,
     +     5.814,6.554,10800.,355.5,0.004626,471.,
     +     6.23,7.024,11010.,370.9,0.00454,480.,
     +     6.41,7.227,11210.,386.4,0.004474,487.,
     +     7.5,8.48,8608.,348.,0.009074,494.,
     +     6.979,7.871,11620.,392.4,0.004402,495.,
     +     7.725,8.716,11830.,394.8,0.004376,498.,
     +     8.231,9.289,12030.,397.3,0.004384,497.,
     +     7.287,8.218,12230.,399.7,0.004447,490.,
     +     7.899,8.911,12430.,402.1,0.004511,483.,
     +     8.041,9.071,12630.,404.5,0.00454,480./
      DATA ((B(I,J),I=1,6),J=58,76)  /
     +     7.489,8.444,12830.,406.9,0.00442,493.,
     +     7.291,8.219,13030.,409.3,0.004298,507.,
     +     7.098,8.,13230.,411.8,0.004182,521.,
     +     6.91,7.786,13430.,414.2,0.004058,537.,
     +     6.728,7.58,13620.,416.6,0.003976,548.,
     +     6.551,7.38,13820.,419.,0.003877,562.,
     +     6.739,7.592,14020.,421.4,0.003863,564.,
     +     6.212,6.996,14210.,423.9,0.003725,585.,
     +     5.517,6.21,14400.,426.3,0.003632,600.,
     +     5.219,5.874,14600.,428.7,0.003498,623.,
     +     5.071,5.706,14790.,433.,0.003405,640.,
     +     4.926,5.542,14980.,433.5,0.003342,652.,
     +     4.787,5.386,15170.,435.9,0.003292,662.,
     +     4.893,5.505,15360.,438.4,0.003243,672.,
     +     5.028,5.657,15550.,440.8,0.003195,682.,
     +     4.738,5.329,15740.,443.2,0.003186,684.,
     +     4.574,5.144,15930.,442.4,0.003144,693.,
     +     5.2,5.851,16120.,441.6,0.003122,698.,
     +     5.07,5.704,16300.,440.9,0.003082,707./
      DATA ((B(I,J),I=1,6),J=77,92)  /
     +     4.945,5.563,16490.,440.1,0.002965,735.,
     +     4.476,5.034,16670.,439.3,0.002871,759.,
     +     4.856,5.46,18320.,438.5,0.002542,755.,
     +     4.308,4.843,17040.,487.8,0.002882,756.,
     +     4.723,5.311,17220.,537.,0.002913,748.,
     +     5.319,5.982,17400.,586.3,0.002871,759.,
     +     5.956,6.7,17800.,677.,0.00266,765.,
     +     6.158,6.928,17770.,586.3,0.002812,775.,
     +     6.204,6.979,17950.,586.3,0.002776,785.,
     +     6.181,6.954,18120.,586.3,0.002748,793.,
     +     6.949,7.82,18300.,586.3,0.002737,796.,
     +     7.506,8.448,18480.,586.3,0.002727,799.,
     +     7.649,8.609,18660.,586.3,0.002697,808.,
     +     7.71,8.679,18830.,586.3,0.002641,825.,
     +     7.407,8.336,19010.,586.3,0.002603,837.,
     +     7.29,8.204,19180.,586.3,0.002573,847./
      DATA C/92*0.,92*0.,92*0.,92*0.,92*0.,92*0./
      DATA CECOF/0.42237,0.0304,-0.00038,3.858,-0.1668,0.00158/
      DATA EPS/0.000001/
*     ------------------------------------------------------------------
*      in the case of non-integer Z the low energy parameters
*      and the ionization potential are taken at INT(Z) !
*
      IZ=INT(Z+EPS)
      IF((IZ.LT.1).OR.(IZ.GT.92)) GOTO 10
*
*     Calculate coefficients C(I,J) if it has not been done already
*
      IF(C(1,IZ).LT.EPS) THEN
         FAC=AVO/A
         C(1,IZ)=FAC*AMUKEV**0.5*B(1,IZ)
         C(2,IZ)=FAC*AMUKEV**0.45*B(2,IZ)
         C(3,IZ)=FAC*B(3,IZ)/AMUKEV
         C(4,IZ)=B(4,IZ)/AMUKEV
         C(5,IZ)=AMUKEV*B(5,IZ)
*
*                     POTI=16.E-9*Z**0.9
*
         POTI=B(6,IZ)*1.E-9
*
*
         C(6,IZ)=POTI
*
      ENDIF
*     ----------------------------------------------------------------
      T1LIM=HMASS*T1L/EMPROT
      T2LIM=HMASS*T2L/EMPROT
*
*     Calculate dE/dx
*     ---> for T .le. T1LIM (very low energy)
*
      IF(T.LE.T1LIM) THEN
         TAU=T/HMASS
         DEDX=C(1,IZ)*TAU**0.5
      ELSE
*
*     ---> for T1LIM .lt. T   and  T .le. T2LIM (low energy)
*
         IF(T.LE.T2LIM) THEN
            TAU=T/HMASS
            SL=C(2,IZ)*TAU**0.45
            SH=C(3,IZ)*LOG(1.+C(4,IZ)/TAU+C(5,IZ)*TAU)/TAU
            DEDX=SL*SH/(SL+SH)
*
*     ---> for T .gt. T2LIM ( "high " energy , Bethe-Bloch formula)
*
         ELSE
            P=SQRT(T*(T+2.*HMASS))
            E=T+HMASS
            BET2=(P/E)**2
            ETA=P/HMASS
            ETA2=ETA*ETA
*+++ new line follows.....
            B2G2=ETA*ETA
*+++ end of correction
            TMAX=2.*EMASS*T*(T+2.*HMASS)
*+++  correction of the next line
*           TMAX=TMAX/(HMASS**2+EMASS**2+EMASS*(T+HMASS))
            TMAX=TMAX/(HMASS**2+EMASS**2+2.*EMASS*E)
*+++ end of correction
*
*         density correction
*
            POTI=C(6,IZ)
            CC=1.+2.*LOG(POTI/(28.8E-9*SQRT(DENS*Z/A)))
*         condensed material ? ( dens .gt. 0.05 ? )
            IF(DENS.GT.0.05) THEN
               IF(POTI.LT.1.E-7) THEN
                  IF(CC.LT.3.681) THEN
                     X0=0.2
                  ELSE
                     X0=0.326*CC-1.
                  ENDIF
                  X1=2.
               ELSE
                  IF(CC.LT.5.215) THEN
                     X0=0.2
                  ELSE
                     X0=0.326*CC-1.5
                  ENDIF
                  X1=3.
               ENDIF
*         gas ?   ( dens . le . 0.05 ? )
            ELSE
               IF(CC.LE.12.25) THEN
                  IP=INT((CC-10.)/0.5)+1
                  IF(IP.LT.0) IP=0
                  IF(IP.GT.4) IP=4
                  X0=1.6+0.1*FLOAT(IP)
                  X1=4.
               ELSE
                  IF(CC.LE.13.804) THEN
                     X0=2.
                     X1=5.
                  ELSE
                     X0=0.326*CC-2.5
                     X1=5.
                  ENDIF
               ENDIF
            ENDIF
*
            XA=CC/4.606
            XM=3.
            AA=4.606*(XA-X0)/(X1-X0)**XM
*
            X=LOG10(ETA)
            DELTA=0.
            IF(X.GT.X0) THEN
               DELTA=4.606*X-CC
               IF(X.LT.X1) DELTA=DELTA+AA*(X1-X)**XM
            ENDIF
*
*         calculate shell correction
*
            POTSQ=POTI*POTI
            IF(ETA.GT.0.13) THEN
               F1=1./ETA2
               F2=F1*F1
               F3=F1*F2
               F4=(F1*CECOF(1)+F2*CECOF(2)+F3*CECOF(3))*1.E+12
               F5=(F1*CECOF(4)+F2*CECOF(5)+F3*CECOF(6))*1.E+18
               CE=F4*POTSQ+F5*POTSQ*POTI
            ELSE
               ETA2=0.0169
               F1=1./ETA2
               F2=F1*F1
               F3=F1*F2
               F4=(F1*CECOF(1)+F2*CECOF(2)+F3*CECOF(3))*1.E+12
               F5=(F1*CECOF(4)+F2*CECOF(5)+F3*CECOF(6))*1.E+18
               CE=F4*POTSQ+F5*POTSQ*POTI
               CE=CE*LOG(T/T2LIM)/LOG(0.0079/T2LIM)
            ENDIF
*
            F1=D*Z/(A*BET2)
*
*         stopping power or restricted dE/dx ?
*
*+++  correction of the next few lines
*           IF(DCUTM.GE.TMAX) THEN
*              F2=2.*(LOG(TMAX/POTI)-BET2)
*           ELSE
*              F2=LOG(TMAX*DCUTM/POTSQ)-BET2*(1.+DCUTM/TMAX)
*           ENDIF
            TUPP=DCUTM
            IF(TMAX.LT.DCUTM) TUPP=TMAX
            F2=LOG(2.*EMASS*B2G2/POTI)+LOG(TUPP/POTI)
     +         -BET2*(1.+TUPP/TMAX)
*+++ end of correction
            DEDX=F1*(F2-DELTA-2.*CE/Z)
*
*
            TAU=T2LIM/HMASS
            SL=C(2,IZ)*TAU**0.45
            SH=C(3,IZ)*LOG(1.+C(4,IZ)/TAU+C(5,IZ)*TAU)/TAU
            ST=SL*SH/(SL+SH)
*
            TMAX=2.*EMASS*T2LIM*(T2LIM+2.*HMASS)
*+++  correction of the next line
*           TMAX=TMAX/(HMASS**2+EMASS**2+EMASS*(T2LIM+HMASS))
            TMAX=TMAX/(HMASS**2+EMASS**2+2.*EMASS*(T2LIM+HMASS))
*+++  end of correction
            BET2=T2LIM*(T2LIM+2.*HMASS)/(T2LIM+HMASS)**2
            SBB=2.*(LOG(TMAX/POTI)-BET2)
            SBB=D*Z*SBB/(A*BET2)
            CORBB=(ST/SBB-1.)*T2LIM
*
            DEDX=DEDX*(1.+CORBB/T)
*
         ENDIF
      ENDIF
*
      RETURN
   10 WRITE (CHMAIL,10000) Z
      CALL GMAIL(1,1)
10000 FORMAT(5X,'***GDRELP  (Z.LT.1.).OR.(Z.GT.92.) ==> Z=',F10.1)
      END
+DECK,  GDROT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDROT(P,COSTH,SINTH,COSPH,SINPH)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Rotates vector from one reference system into another.        *
C.    *  THETA and PHI are anti-clockwise Eulerian angles between the  *
C.    *  two systems.                                                  *
C.    *                                                                *
C.    *    ==>Called by : GBREME,GCOMP,GDECAY,GDECA3,GDRAY,GPAIRG      *
C.    *       Author    M.Hansroul, G.Patrick  *********               *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P(3)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION P1,P2,P3
+SELF.
C.
C.    ------------------------------------------------------------------
C.
      P1=P(1)
      P2=P(2)
      P3=P(3)
      P(1)=P1*COSTH*COSPH - P2*SINPH + P3*SINTH*COSPH
      P(2)=P1*COSTH*SINPH + P2*COSPH + P3*SINTH*SINPH
      P(3)=-P1*SINTH                 + P3*COSTH
C
      END
+DECK,  GDRPRT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDRPRT(IPART,IMATE,STEP,MPOINT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Landau fluctuations and/or delta-rays generation .            *
C.    *  print the value of some relevant parameters (see phys 332) :  *
C.    *  Tmax, zeta, kapa and the regime for fluctuations              *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IPART   Geant particle number                                 *
C.    *  IMATE   Geant material number                                 *
C.    *  STEP    cm                                                    *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire    *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCUNIT.
+CDE, GCMULO.
*
      PARAMETER (MXPOIN=100)
      DIMENSION TCUT(5)
      DIMENSION TKINV(MXPOIN),DEDXMV(MXPOIN),DNTOTV(MXPOIN)
      CHARACTER REGIME*14,KUNIT*4,NAPART*8,NAMATE*8
*
      PARAMETER (DGEV=0.153536 E-3)
*
* *** incident particle
      JPA = LQ(JPART-IPART)
      CALL UHTOC (IQ(JPA+1),4,NAPART,8)
      AMASS = Q(JPA+7)
      CHARG = Q(JPA+8)
      EAMAS = EMASS/AMASS
*
* *** material
      JMA = LQ(JMATE-IMATE)
      IF(JMA.LE.0.OR.IMATE.GT.IQ(JMATE-2)) THEN
         WRITE(CHMAIL,10000) IMATE
         GOTO 999
      ENDIF
      CALL UHTOC (IQ(JMA+1),4,NAMATE,8)
      AMT = Q(JMA+6)
      ZMT = Q(JMA+7)
      RO  = Q(JMA+8)
      JPR = LQ(JMA-4)
*
* *** mean ionization potential (GeV)
*     POTI=16E-9*ZMT**0.9
      POTI=Q(JPR+9)
*
      CONS = DGEV*CHARG*CHARG*STEP*RO*ZMT/AMT
*
      WRITE (CHMAIL,10200) NAPART,NAMATE,STEP
      CALL GMAIL(1,0)
      WRITE (CHMAIL,10100)
      CALL GMAIL(0,1)
      WRITE (CHMAIL,10300)
      CALL GMAIL(0,1)
*
* *** loop on kinetic energy
      NPOINT = MIN(MPOINT,MXPOIN)
      TKINI = ELOW(1)
      TKEND = ELOW(NEK1)
      STEPL = (TKEND/TKINI)**(1./(NPOINT-1))
      TKINV(1) = TKINI
      DO 10 JTK=2,NPOINT
         TKINV(JTK) = TKINV(JTK-1)*STEPL
   10 CONTINUE
      CALL GFTMAT(IMATE,IPART,'LOSS',NPOINT,TKINV,DEDXMV,TCUT,IXST)
      CALL GFTMAT(IMATE,IPART,'DRAY',NPOINT,TKINV,DNTOTV,TCUT,IXST)
      DO 20  I=1,NPOINT
         TKIN  = TKINV(I)
         DEDXM = DEDXMV(I)
         DNTOT = DNTOTV(I)
         TKM = TKIN/AMASS
         GAMA = TKM + 1.
         GAM2 = GAMA**2
         BTA2 = TKM*(TKM+2.)/GAM2
*        maximum transferable energy (gev)
         TMAX = (2*EMASS*GAM2*BTA2)/(1.+2*GAMA*EAMAS+EAMAS**2)
         IF(IPART.EQ.3) TMAX=0.5*TMAX
*
* ***    mean de/dx on material
         DEGEV = STEP*DEDXM*1.E-3
         DEPOT = DEGEV/POTI
*
* ***    total number of delta ray production
         DNTOT = DNTOT*STEP
*
* ***    low energy tranfert
         ZETA = CONS/BTA2
         DNLOW = ZETA/POTI
*
* ***    high energy transfert
         DNHIG = ZETA/TMAX
*
* ***    regime
         DNMIN = MIN(DNLOW,DEPOT)
         IF(DNMIN.GE.50.) THEN
            IF (DNHIG.GE.10. ) THEN
               REGIME = 'Gauss'
            ELSEIF (DNHIG.GE.0.01) THEN
               REGIME = 'Vavilov'
            ELSE
               REGIME = 'Landau'
            ENDIF
         ELSE
            IFREE = 1
            IF(DNMIN.GE.0.01) THEN
               REGIME = 'Urban/'
               IFREE  = 7
            ENDIF
            IF(DNMIN.GE.1..AND.DNMIN.LT.30.) THEN
               REGIME(IFREE:) = 'ASHO/'
               IFREE  = 12
            ENDIF
            REGIME(IFREE:) = 'PAI'
         ENDIF
*
* ***    print
         CALL GEVKEV (TKIN,TKUN,KUNIT)
         WRITE (CHMAIL,10400) TKUN,KUNIT,DNTOT,DEPOT,DNLOW,DNHIG,
     +   REGIME
         CALL GMAIL(0,0)
   20 CONTINUE
*
10000 FORMAT(' **** GDRPRT: Material N ',I3,' has not been defined')
10100 FORMAT (9X,'For an explication of the ''regimes'' field ',
     +           'see the GEANT manual')
10200 FORMAT (5X,'*** Energy loss straggling for ',A8,' in ',A8,
     +           ', step ',F8.4,' cm')
10300 FORMAT (4X,'   Ekin ','     N d-rays','      dE/I    ',
     +    '    xi/I    ','   xi/Emax ','    regime')
10400 FORMAT (4X,F5.1,A4,4E12.3,4X,A14)
*
  999 END
+DECK,  GDRSGA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GDRSGA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for Delta rays (Moller or Bhabba)                             *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    D.Ward, L.Urban  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GCJLOC.
+CDE, GCCUTS.
+CDE, GCMULO.
C.
C.    ------------------------------------------------------------------
C.
      Q(JDRAY+IEKBIN       )=BIG
      Q(JDRAY+IEKBIN+  NEK1)=BIG
      Q(JDRAY+IEKBIN+2*NEK1)=BIG
      IF(Z.LT.1.) GOTO 99
      JPROB=LQ(JMA-4)
      TKIN=ELOW(IEKBIN)
C
C=======>              A,   MUONS
C
      IF(TKIN.GT.DCUTM)THEN
         XE=TKIN+EMMU
         GAM=XE/EMMU
         GAM2=GAM**2
         BET2=1.-1./GAM2
         TMAX=2.*EMASS*(GAM2-1.)/
     +     (1.+2.*GAM*EMASS/EMMU+(EMASS/EMMU)**2)
         IF(TMAX.GT.DCUTM)THEN
            Y=DCUTM/TMAX
            SIG=(1.-Y+BET2*Y*LOG(Y))/DCUTM
            SIG=SIG+(TMAX-DCUTM)/(2.*XE**2)
            SIG=SIG*Q(JPROB+17)*EMASS/BET2
            IF(SIG.GT.0.)Q(JDRAY+IEKBIN+2*NEK1)=1./SIG
         ENDIF
      ENDIF
C
C======>            B,    ELECTRONS
C
      IF(TKIN.GT.DCUTE)THEN
C
         XE=TKIN+EMASS
         GAM=XE/EMASS
         GAM2=GAM*GAM
         BET2=1.-1./GAM2
         T=GAM-1.
         X=DCUTE/(T*EMASS)
         X1=1.-X
C
C     Moller
C
         IF(T.GT.2.*DCUTE/EMASS)THEN
            B1=T*T/GAM2
            B2=(2.*GAM-1.)/GAM2
            SIG=(B1*(0.5-X)+1./X-1./X1-B2*LOG(X1/X))/BET2
            SIG=Q(JPROB+17)*SIG/T
            IF(SIG.GT.0.)Q(JDRAY+IEKBIN)=1./SIG
         ENDIF
C
C     Bhabha
C
         IF(T.GT.DCUTE/EMASS)THEN
            Y=1./(GAM+1.)
            Y2=Y*Y
            C=1.-2.*Y
            B1=2.-Y2
            B2=C*(3.+Y2)
            C2=C*C
            B4=C2*C
            B3=C2+B4
            SIG=(1./X-1.)/BET2+B1*LOG(X)
     +           +B2*(1.-X)-B3*(1.-X*X)/2.+B4*(1.-X**3)/3.
            SIG=Q(JPROB+17)*SIG/T
            IF(SIG.GT.0.)Q(JDRAY+IEKBIN+NEK1)=1./SIG
         ENDIF
      ENDIF
C
  99  RETURN
      END
+DECK,  GEFCH2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      FUNCTION GEFCH2(Z1,Z2,TK)
C.    *******************************************************************
C.    *                                                                 *
C.    *  Calculates  gamma**2=( eff.charge/z1)**2 for heavy ions        *
C.    *   (see e.g. F.Hubert et al. Atomic Data and Nuclear Data        *
C.    *             Tables,Vol.40,1.(1990) )                            *
C.    *                                                                 *
C.    *  The stopping power S for a given combination of stopping       *
C.    *  medium and heavy ion can be calculated according to            *
C.    *  the scaling law                                                *
C.    *                                                                 *
C.    *            S = (gamma*Z1)**2*Sref/Zref**2                       *
C.    *                                                                 *
C.    *    where Z1 the ion charge , gamma*Z1 is the effective charge,  *
C.    *          Sref is the stopping power of the same medium          *
C.    *          for a reference ion of the same velocity and           *
C.    *          of effective charge Zref.                              *
C.    *                                                                 *
C.    *  Input: Z1 atomic number of the ion                             *
C.    *         Z2 atomic number of the medium                          *
C.    *         TK E/A in GeV (ion kin.energy/atomic weight)            *
C.    *                                                                 *
C.    *******************************************************************
C.
      ALZ2=LOG(Z2)
      TKMEV=1000.*TK
C
      X1=1.164+0.2319*EXP(-0.004302*Z2)+1.658*EXP(-0.05170*Z1)
      X2=8.144+0.09876*ALZ2
      X3=0.3140+0.01072*ALZ2
      X4=0.5218+0.02521*ALZ2
      EE=MAX(-50.,-X2*TKMEV**X3/Z1**X4)
C     .........................
      GA=1.-X1*EXP(EE)
C
      GEFCH2=GA**2
      END
+DECK,  GFANG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GFANG(P,COSTH,SINTH,COSPH,SINPH,ROTATE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Finds theta-phi angles for a particle with director cosines P *
C.    *  The logical flag ROTATE indicates whether the the director    *
C.    *  cosines are along the Z axis (.FALSE.) or not (.TRUE.).       *
C.    *                                                                *
C.    *    ==>Called by :                                              *
C.    *       Author    F.Carminati  *********                         *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P(*)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION DUX, DUY, DUZ, DSITH2, ONE, DNORM
+SELF.
      LOGICAL ROTATE
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      DUX      = P(1)
      DUY      = P(2)
      DUZ      = P(3)
      ROTATE   = .TRUE.
      IF(ABS(DUZ).GE.0.85) THEN
         DSITH2=DUX**2+DUY**2
         IF(DSITH2.GT.0.) THEN
            COSTH  = SIGN(ONE,DUZ)*SQRT(ONE-DSITH2)
            DSITH  = SQRT(DSITH2)
            SINTH  = DSITH
            COSPH  = DUX/DSITH
            SINPH  = DUY/DSITH
         ELSEIF(DUZ.GT.0.)THEN
            ROTATE = .FALSE.
            COSTH =  1.
            SINTH =  0.
            COSPH =  1.
            SINPH =  0.
         ELSE
            COSTH = -1.
            SINTH =  0.
            COSPH =  1.
            SINPH =  0.
         ENDIF
      ELSE
         COSTH  = DUZ
         DSITH  = SQRT((ONE+DUZ)*(ONE-DUZ))
         SINTH  = DSITH
         DNORM  = ONE/SQRT(DUX**2+DUY**2)
         COSPH  = DUX*DNORM
         SINPH  = DUY*DNORM
      ENDIF
*
      END
+DECK,  GFLUCT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:24  cernlib
* Geant

      SUBROUTINE GFLUCT(DEMEAN,DE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Subroutine to decide which method is used to simulate        *
C.    *   the straggling around the mean energy loss.                  *
C.    *                                                                *
C.    *                                                                *
C.    *   DNMIN:  <---------->1<-------->30<--------->50<--------->    *
C.    *                                                                *
C.    *   LOSS=2  :                                                    *
C.    *   STRA=0  <----------GLANDZ-------------------><--GLANDO-->    *
C.    *   LOSS=1,3:                                                    *
C.    *   STRA=0  <---------------------GLANDZ-------------------->    *
C.    *                                                                *
C.    *   STRA=1  <-----------PAI---------------------><--GLANDZ-->    *
+SELF, IF=ASHO.
C.    *   STRA=2  <---PAI----><---ASHO---><----PAI----><--GLANDZ-->    *
C.    *                                                                *
+SELF.
C.    *                                                                *
C.    *   DNMIN :  an estimation of the number of collisions           *
C.    *            with energy close to the ionization energy          *
C.    *            (see PHYS333)                                       *
C.    *                                                                *
C.    *   Input  : DEMEAN (mean energy loss)                           *
C.    *   Output : DE   (energy loss in the current step)              *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTMUON,GTHADR                         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GCCUTS.
+CDE, GCKINE.
+CDE, GCMULO.
+CDE, GCPHYS.
+CDE, GCTRAK.
*
      PARAMETER (EULER=0.577215,GAM1=EULER-1)
      PARAMETER (P1=.60715,P2=.67794,P3=.52382E-1,P4=.94753,
     +           P5=.74442,P6=1.1934)
      PARAMETER (DGEV=0.153536 E-3, DNLIM=50)
+SELF, IF=ASHO.
      PARAMETER (ASHMIN=1,ASHMAX=30)
+SELF.
      DIMENSION RNDM(2)
      FLAND(X) = P1+P6*X+(P2+P3*X)*EXP(P4*X+P5)
*
      IF(STEP.LE.0) THEN
         DE=DEMEAN
      ELSE
         DEDX = DEMEAN/STEP
         POTI=Q(JPROB+9)
         IF(ISTRA.EQ.0.AND.ILOSS.NE.2) THEN
            CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,Q(JPROB+10))
         ELSE
*
* *** mean ionization potential (GeV)
*        POTI=16E-9*Z**0.9
*
            GAMMA = GETOT/AMASS
            BETA = VECT(7)/GETOT
            BET2 = BETA**2
*
* ***    low energy transfer
            XI = DGEV*CHARGE**2*STEP*DENS*Z/(A*BET2)
*
* ***    regime
* ***    ISTRA = 1 --> PAI + URBAN
+SELF, IF=ASHO.
* ***    ISTRA = 2 --> PAI + URBAN + ASHO
+SELF.
            DNMIN = MIN(XI,DEMEAN)/POTI
*
            IF (ISTRA.EQ.0) THEN
               IF(DNMIN.GE.DNLIM) THEN
*
*  Energy straggling using Gaussian, Landau & Vavilov theories.
*
*  STEP   =  current step-length (cm)
*
*  DELAND =  DE/DX - <DE/DX>     (GeV)
*
*  Author      : G.N. Patrick
*
                  IF(STEP.LT.1.E-7)THEN
                     DELAND=0.
                  ELSE
*
*     Maximum energy transfer to atomic electron (GeV).
                     ETA = BETA*GAMMA
                     RATIO = EMASS/AMASS
*
*     Calculate Kappa significance ratio.
*                 EMAX=(2*EMASS*ETA**2)/(1+2*RATIO*GAMMA+RATIO**2)
*                 CAPPA = XI/EMAX
                     CAPPA = XI*(1+2*RATIO*GAMMA+RATIO**2)/(2*EMASS*
     +               ETA**2)
                     IF (CAPPA.GE.10.) THEN
*
*     +-----------------------------------+
*     I Sample from Gaussian distribution I
*     +-----------------------------------+
                        SIGMA = XI*SQRT((1.-0.5*BET2)/CAPPA)
                        CALL GRNDM(RNDM,2)
                        F1 = -2.*LOG(RNDM(1))
                        DELAND = SIGMA*SQRT(F1)*COS(TWOPI*RNDM(2))
                     ELSE
                        XMEAN = -BET2-LOG(CAPPA)+GAM1
                        IF (CAPPA.LT.0.01) THEN
                           XLAMX = FLAND(XMEAN)
*     +---------------------------------------------------------------+
*     I Sample lambda variable from Kolbig/Schorr Landau distribution I
*     +---------------------------------------------------------------+
*  10                   CALL GRNDM(RNDM,1)
*                       IF( RNDM(1) .GT. 0.980 ) GO TO 10
*                       XLAMB = GLANDR(RNDM(1))
*     +---------------------------------------------------------------+
*     I Sample lambda variable from James/Hancock Landau distribution I
*     +---------------------------------------------------------------+
   10                      CALL GLANDG(XLAMB)
                           IF(XLAMB.GT.XLAMX) GO TO 10
                        ELSE
*            +---------------------------------------------------------+
*            I Sample lambda variable (Landau not Vavilov) from        I
*            I Rotondi&Montagna&Kolbig Vavilov distribution            I
*            +---------------------------------------------------------+
                           CALL GRNDM(RNDM,1)
                           XLAMB = GVAVIV(CAPPA,BET2,RNDM(1))
                        ENDIF
*
*     Calculate DE/DX - <DE/DX>
                        DELAND = XI*(XLAMB-XMEAN)
                     ENDIF
                  ENDIF
                  DE = DEMEAN + DELAND
               ELSE
                  CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,
     +            Q(JPROB+ 10))
               ENDIF
            ELSE IF (ISTRA.LE.2) THEN
               IF(DNMIN.GE.DNLIM) THEN
                  CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,
     +            Q(JPROB+ 10))
               ELSE
                  NMEC = NMEC+1
                  LMEC(NMEC)=109
+SELF, IF=ASHO.
                  IF (DNMIN.GE.ASHMIN.AND.DNMIN.LT.ASHMAX .AND.ISTRA.EQ
     +            .2) THEN
                     CALL GASHO(VECT(7),AMASS,STEP,DE)
                  ELSE
                     DE = GSTREN(GAMMA,DCUTE,STEP)
                  ENDIF
+SELF, IF=-ASHO.
                  DE = GSTREN(GAMMA,DCUTE,STEP)
+SELF.
*
* ***   Add brem losses to ionisation
                  IF(ITRTYP.EQ.2) THEN
                     JBASE = LQ(JMA-1)+2*NEK1+IEKBIN
                     DE = DE +(1.-GEKRAT)*Q(JBASE)+GEKRAT*Q(JBASE+1)
                  ELSEIF(ITRTYP.EQ.5) THEN
                     JBASE = LQ(JMA-2)+NEK1+IEKBIN
                     DE = DE +(1.-GEKRAT)*Q(JBASE)+GEKRAT*Q(JBASE+1)
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      END
+DECK,  GFNRDT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GFNRDT(Z,ESHL,NSHL,NWORD,NONRAD,PRB,ENER)
C.
C.    ******************************************************************
C.    *                                                                *
C     *   Fetch Non-Radiative Decay probability Table and the modes    *
C.    *       the nonradiative shells decay                            *
C.    *                                                                *
C.    *    ==>Called by : GFSHDC                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCCUTS.
+CDE, GCPMXZ.
+CDE, GCPHNR.
      REAL  ONEEV
      PARAMETER (ONEEV = 1.E-9)
      DIMENSION ESHL(*),PRB(*),ENER(*),NONRAD(*)
      IZ = Z
      NWORD = 0
      DO 10 J = 1,NSHL
         NONRAD(J) = 0
         ESHELL = ESHL(J)
         IF(ESHELL.GT.0.0) THEN
            I1 = IGNRFN((J-1)*2+1,IZ)
            I2 = IGNRFN((J-1)*2+2,IZ)
            IF(I1*I2.GT.0) THEN
               NONRAD(J) = 1
               NWORD = NWORD+1
               ENER(NWORD) = ESHELL-ESHL(I1)-ESHL(I2)
               ENER(NWORD) = ENER(NWORD)*ONEEV
               IF(ENER(NWORD).LE.CUTELE) ENER(NWORD) = -ENER(NWORD)
               PRB(NWORD) = 1.
            ENDIF
         ENDIF
   10 CONTINUE
      END
+DECK,  GFRDT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GFRDT(ZZ,ESHL,NSHL,NWORD,NRAD,PRB,ENER)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Fetch Radiative Decay probability Tables and the modes   *
C.    *       the radiative shells decay                               *
C.    *                                                                *
C.    *    ==>Called by : GFSHDC                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCCUTS.
+CDE, GCPMXZ.
+CDE, GCPHRD.
      REAL ONEEV
      PARAMETER (ONEEV = 1.E-9)
      DIMENSION ESHL(*),PRB(*),ENER(*),NRAD(*)
      IZ = ZZ
      NWORD = 0
      DO 30 J = 1,NSHL
         NRAD(J) = 0
         ESHELL = ESHL(J)
         IF(ESHELL.GT.0.0) THEN
            IF(J.EQ.1) THEN
               NR = KSHLS
               NS = 0
            ELSEIF(J.EQ.2) THEN
               NR = L1SHLS
               NS = KSHLS
            ELSEIF(J.EQ.3) THEN
               NR = L2SHLS
               NS = KSHLS+L1SHLS
            ELSEIF(J.EQ.4) THEN
               NR = L3SHLS
               NS = KSHLS+L1SHLS+L2SHLS
            ENDIF
            NWS = NWORD+1
            QS = 0.0
            DO 10 I = 1,NR
               QS = QS+GPHRAT(NS+I,IZ)
               IF(GPHRAT(NS+I,IZ).GT.0.0) THEN
                  NWORD = NWORD+1
                  NRAD(J) = NRAD(J)+1
                  PRB(NWORD) = QS
                  ENER(NWORD) = ESHELL-ESHL(ISHLTR(NS+I))
                  ENER(NWORD) = ENER(NWORD)*ONEEV
                  IF(ENER(NWORD).LE.CUTGAM) ENER(NWORD) = -ENER(NWORD)
               ENDIF
   10       CONTINUE
            IF(QS.GT.0.0) THEN
               QS1 = 1./QS
               DO 20 I = NWS,NWORD
                  PRB(I) = PRB(I)*QS1
   20          CONTINUE
            ENDIF
         ENDIF
   30 CONTINUE
      END
+DECK,  GFSDPR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GFSDPR(Z,NSHL,PRB)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Fetch probability of radiative shells decay              *
C.    *                                                                *
C.    *    ==>Called by : GFSHDC                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCPMXZ.
+CDE, GCPHPR.
      DIMENSION PRB(NSHL)
      IZ = Z
      DO 10 I = 1,NSHL
         PRB(I) = GFLUPR(I,IZ)
   10 CONTINUE
      END
+DECK,  GFSHDC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GFSHDC(IELEM,Z)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Fetch Shell Decay Constants                                   *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHXSI                                       *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCUNIT.
      REAL ONEEV
      PARAMETER (ONEEV = 1.E-9)
      DIMENSION PRB(4),PRBR(92),ER(92),PRBNR(92),ENR(92)
      DIMENSION ESHL(24),NRAD(24),NONRAD(24)
      PARAMETER (NFNBIN = 17, NSHELL = 4)
C
C Push NZ JPFN banks which will contain constants for each Z
C
      JPHXS = LQ(JPHOT-1)
C
C Get Z, the shell potentials and the decay modes
C
      DO 10 I = 1,24
         ESHL(I) = 0.0
         NRAD(I) = 0
         NONRAD(I) = 0
   10 CONTINUE
      DO 20 I = 1,4
         PRB(I) = 0.0
   20 CONTINUE
      DO 30 I = 1,92
         PRBNR(I) = 0.0
         PRBNR(I) = 0.0
         ENR(I) = 0.0
         ER(I) = 0.0
   30 CONTINUE
      CALL GFSHLS(Z,ESHL,NSHLL)
      CALL GFRDT(Z,ESHL,NSHELL,NWR,NRAD,PRBR,ER)
      CALL GFNRDT(Z,ESHL,NSHELL,NWNR,NONRAD,PRBNR,ENR)
C Calculate how many words are needed for the final state bank JPHFN
      NWORD = 0
      DO 40 J = 1,NSHELL
         IF(NRAD(J).GT.0) NWORD = NWORD+2*NRAD(J)+1
         IF(NONRAD(J).GT.0) NWORD = NWORD+2*NONRAD(J)+1
   40 CONTINUE
      NBOOK = NWORD+NFNBIN
      JPHFN = LQ(JPHXS-IELEM)
C Push bank to store final state parameters
      CALL MZPUSH(IXCONS,JPHFN,0,NBOOK,'R')
      NUSED = 5*Q(JPHFN+1)+1
      JPHFN = JPHFN+NUSED
      Q(JPHFN+1) = NSHELL
C Get probability of the shell radiative decay
      CALL GFSDPR(Z,NSHELL,PRB)
C
C Copy potentials and radiative decay probabilities
C
      DO 50 J = 1,NSHELL
         IF(ESHL(J).GT.0.0) THEN
            Q(JPHFN+1+J) = ESHL(J)*ONEEV
            Q(JPHFN+1+J+NSHELL) = PRB(J)
         ELSE
C if the shell potential is zero set it to -1
            Q(JPHFN+1+J) = -1.
            Q(JPHFN+1+J+NSHELL) = -1.
         ENDIF
   50 CONTINUE
C
C Now configurations of the final state
C
      K = 18
      KR = 1
      KNR = 1
      IF(NWORD.GT.0) THEN
         Q(JPHFN+10) = 18+NUSED
         DO 100 J = 1,NSHELL
            IF(ESHL(J).GT.0.0) THEN
               IF(NRAD(J).GT.0) THEN
                  IF(J.GT.1) Q(JPHFN+9+J) = K+NUSED
                  Q(JPHFN+K) = NRAD(J)
                  K = K+1
                  KER = KR+NRAD(J)-1
                  DO 60 L = KR,KER
                     Q(JPHFN+K) = PRBR(L)
                     K = K+1
   60             CONTINUE
                  DO 70 L = KR,KER
                     Q(JPHFN+K) = ER(L)
                     K = K+1
   70             CONTINUE
                  KR = KR+NRAD(J)
               ENDIF
               IF(NONRAD(J).GT.0) THEN
                  Q(JPHFN+13+J) = K+NUSED
                  Q(JPHFN+K) = NONRAD(J)
                  K = K+1
                  KNER = KNR+NONRAD(J)-1
                  DO 80 L = KNR,KNER
                     Q(JPHFN+K) = PRBNR(L)
                     K = K+1
   80             CONTINUE
                  DO 90 L = KNR,KNER
                     Q(JPHFN+K) = ENR(L)
                     K = K+1
   90             CONTINUE
                  KNR = KNR+NONRAD(J)
               ENDIF
            ENDIF
  100    CONTINUE
      ELSE
C You should never land here unless Z < 6
         IF(Z.GT.5.) THEN
C               CALL MZDROP(IXCONS,JPHFN,'L')
            WRITE(CHMAIL,'(A25,I3)') ' GFSHDC. JPHFN Z > 5. Z = ',Z
            CALL GMAIL(0,0)
         ENDIF
      ENDIF
      END
+DECK,  GFSHLS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GFSHLS(Z,GSHPOT,NSHELL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Fetch the shells' potentials for e given Z               *
C.    *       The potentials are in eV !!!                             *
C.    *                                                                *
C.    *    ==>Called by : GPHXSI,GFSHDC                                *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      IMPLICIT NONE
+CDE, GCPMXZ.
+CDE, GCSHPT.
+CDE, GCUNIT.
      REAL ZZ,Z,GSHPOT(*)
      INTEGER I,IZ,NSHELL
      ZZ = Z
      IF(ZZ.LT.1.OR.ZZ.GT.MAXELZ) THEN
         IF(ZZ.LT. 1) WRITE(CHMAIL,10000) ZZ
         IF(ZZ.GT.MAXELZ) WRITE(CHMAIL,10100) ZZ
         CALL GMAIL(0,0)
      ELSE
         IZ = IFIX(ZZ)
         NSHELL = NSHLLS(IZ)
         DO 10 I = 1,NSHLLS(IZ)
            GSHPOT(I) = ESHELL(N1ST(IZ)-1+I)
   10    CONTINUE
      ENDIF
10000 FORMAT(' ***** GFSHLS ERROR:',
     +       '  Z of the material is less than   1.',
     +       ' Actual Z =',I5,'.')
10100 FORMAT(' ***** GFSHLS ERROR:',
     +       '  Z of the material is bigger than 100.',
     +       ' Actual Z =',I5,' (I5).')
      END
+DECK,  GHSIG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:36  cernlib
* Geant

      FUNCTION GHSIG(P,ITYPE,A)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Returns absorption cross-section in millibarns               *
C.    *   for a particle with                                          *
C.    *                momentum P (GEV/C)                              *
C.    *                type ITYPE                                      *
C.    *      on a nucleus of atomic number A                           *
C.    *                                                                *
C.    *    ==>Called by : GHSIGM                                       *
C.    *       Author    R.Barlow  *********                            *
C.    *                                                                *
C.    ******************************************************************
C
C              The internal particle types are as follows...
C                1 proton
C                2 antiproton
C                3 K+
C                4 K-
C                5 pion
C
      DIMENSION SIGB(100),ALPHA(100),SIG(162,5)
      DIMENSION SIGPR(162,1),SIGPB(162,1),SIGKP(162,1),SIGKM(162,1)
      DIMENSION SIGPI(162,1)
      EQUIVALENCE (SIGPR(1,1),SIG(1,1)),(SIGPB(1,1),SIG(1,2))
      EQUIVALENCE (SIGKP(1,1),SIG(1,3)),(SIGKM(1,1),SIG(1,4))
      EQUIVALENCE (SIGPI(1,1),SIG(1,5))
C
           DATA ALPHA/
     +  0.9826,0.9659,0.9500,0.9348,0.9203,0.9064,0.8932,0.8807,0.8687,
     +  0.8574,0.8466,0.8363,0.8265,0.8172,0.8084,0.8000,0.7921,0.7845,
     +  0.7773,0.7705,0.7640,0.7579,0.7520,0.7464,0.7411,0.7361,0.7313,
     +  0.7267,0.7224,0.7182,0.7142,0.7105,0.7069,0.7034,0.7001,0.6970,
     +  0.6939,0.6911,0.6883,0.6856,0.6831,0.6807,0.6783,0.6761,0.6739,
     +  0.6718,0.6698,0.6679,0.6660,0.6642,0.6625,0.6609,0.6592,0.6577,
     +  0.6562,0.6547,0.6533,0.6519,0.6506,0.6493,0.6481,0.6469,0.6457,
     +  0.6446,0.6435,0.6424,0.6413,0.6403,0.6393,0.6384,0.6374,0.6365,
     +  0.6356,0.6347,0.6339,0.6330,0.6322,0.6314,0.6307,0.6299,0.6292,
     +  0.6284,0.6277,0.6270,0.6263,0.6257,0.6250,0.6244,0.6237,0.6231,
     +  0.6225,0.6219,0.6213,0.6208,0.6202,0.6197,0.6191,0.6186,0.6181,
     +  0.6175/
           DATA SIGB/
     +    1.02,  2.10,  3.21,  4.36,  5.54,  6.75,  7.99,  9.24, 10.51,
     +   11.79, 13.08, 14.37, 15.66, 16.95, 18.22, 19.49, 20.75, 21.99,
     +   23.22, 24.43, 25.62, 26.79, 27.93, 29.06, 30.16, 31.24, 32.30,
     +   33.33, 34.34, 35.32, 36.29, 37.22, 38.14, 39.03, 39.91, 40.75,
     +   41.58, 42.39, 43.18, 43.95, 44.70, 45.43, 46.14, 46.83, 47.51,
     +   48.17, 48.82, 49.45, 50.06, 50.66, 51.25, 51.83, 52.39, 52.93,
     +   53.47, 53.99, 54.51, 55.01, 55.50, 55.98, 56.45, 56.92, 57.37,
     +   57.81, 58.25, 58.68, 59.10, 59.51, 59.91, 60.31, 60.70, 61.08,
     +   61.46, 61.83, 62.19, 62.55, 62.90, 63.25, 63.59, 63.93, 64.26,
     +   64.58, 64.90, 65.22, 65.53, 65.84, 66.14, 66.44, 66.74, 67.03,
     +   67.31, 67.60, 67.88, 68.15, 68.42, 68.69, 68.96, 69.22, 69.48,
     +   69.74/
       DATA SIGPR /
     +  79.01, 76.05, 73.81, 71.75, 69.67, 66.70, 64.89, 63.09, 60.58,
     +  58.99, 57.49, 56.09, 54.02, 52.75, 51.54, 50.39, 48.78, 47.79,
     +  46.86, 45.99, 44.73, 43.97, 43.25, 42.59, 41.59, 40.99, 40.41,
     +  39.85, 38.88, 38.26, 37.67, 37.06, 36.31, 35.82, 35.37, 35.00,
     +  34.40, 34.03, 33.71, 33.45, 33.00, 32.72, 32.50, 32.31, 32.01,
     +  31.84, 31.69, 31.56, 31.38, 31.29, 31.17, 31.09, 31.17, 31.34,
     +  31.61, 31.87, 32.62, 33.16, 33.84, 34.62, 35.85, 36.67, 37.51,
     +  38.72, 39.52, 40.29, 41.00, 41.97, 42.54, 43.01, 43.38, 43.82,
     +  44.01, 44.14, 44.24, 44.34, 44.38, 44.40, 44.40, 44.36, 44.33,
     +  44.28, 44.21, 44.07, 43.96, 43.84, 43.71, 43.48, 43.33, 43.17,
     +  43.02, 42.79, 42.64, 42.49, 42.36, 42.16, 42.05, 41.94, 41.85,
     +  41.71, 41.63, 41.54, 41.46, 41.35, 41.27, 41.20, 41.13, 41.02,
     +  40.95, 40.88, 40.81, 40.72, 40.66, 40.61, 40.57, 40.49, 40.44,
     +  40.37, 40.30, 40.19, 40.11, 40.04, 39.92, 39.84, 39.76, 39.69,
     +  39.57, 39.51, 39.45, 39.40, 39.32, 39.26, 39.21, 39.16, 39.09,
     +  39.05, 39.01, 38.98, 38.93, 38.90, 38.88, 38.85, 38.82, 38.81,
     +  38.79, 38.77, 38.75, 38.73, 38.72, 38.70, 38.68, 38.66, 38.65,
     +  38.64, 38.62, 38.60, 38.59, 38.57, 38.55, 38.53, 38.51, 38.49/
       DATA SIGPB /
     + 505.81,485.41,470.03,455.70,441.22,420.60,407.94,395.19,377.36,
     + 366.03,355.16,345.07,329.94,320.60,311.79,303.19,291.17,283.77,
     + 276.68,270.09,260.15,254.24,248.43,243.19,234.87,229.91,225.10,
     + 220.26,213.46,209.12,204.98,200.98,195.36,191.56,187.98,184.49,
     + 179.41,176.04,172.86,169.81,165.19,162.28,159.35,156.55,152.41,
     + 149.95,147.59,145.11,141.66,139.59,137.45,135.41,132.43,130.53,
     + 128.59,126.81,124.18,122.54,120.90,119.34,117.13,115.67,114.22,
     + 112.04,110.54,109.13,107.70,105.63,104.23,102.97,101.64, 99.62,
     +  98.30, 96.99, 95.81, 93.97, 92.88, 91.80, 90.69, 89.03, 87.97,
     +  86.92, 85.89, 84.36, 83.38, 82.39, 81.40, 79.89, 78.92, 77.95,
     +  76.96, 75.50, 74.59, 73.68, 72.81, 71.51, 70.73, 69.95, 69.19,
     +  68.07, 67.39, 66.71, 66.04, 65.13, 64.54, 63.99, 63.42, 62.55,
     +  62.05, 61.52, 61.02, 60.23, 59.74, 59.27, 58.79, 58.07, 57.64,
     +  57.20, 56.77, 56.10, 55.66, 55.23, 54.41, 53.90, 53.42, 52.94,
     +  52.20, 51.73, 51.30, 50.85, 50.20, 49.79, 49.47, 49.16, 48.72,
     +  48.46, 48.15, 47.84, 47.42, 47.17, 46.92, 46.68, 46.31, 46.12,
     +  45.90, 45.70, 45.42, 45.28, 45.13, 44.99, 44.80, 44.68, 44.58,
     +  44.48, 44.35, 44.28, 44.21, 44.15, 44.06, 44.00, 43.95, 43.90/
       DATA SIGKP /
     +   9.05,  8.86,  8.71,  8.58,  8.45,  8.28,  8.19,  8.11,  8.02,
     +   7.97,  7.94,  7.92,  7.90,  7.91,  7.92,  7.95,  8.01,  8.05,
     +   8.10,  8.17,  8.28,  8.37,  8.47,  8.56,  8.74,  8.86,  8.98,
     +   9.13,  9.35,  9.51,  9.66,  9.83, 10.10, 10.27, 10.45, 10.63,
     +  10.89, 11.07, 11.24, 11.40, 11.65, 11.81, 11.96, 12.12, 12.37,
     +  12.54, 12.71, 12.87, 13.19, 13.43, 13.70, 13.99, 14.49, 14.87,
     +  15.28, 15.71, 16.37, 16.79, 17.19, 17.57, 18.05, 18.30, 18.49,
     +  18.68, 18.74, 18.76, 18.75, 18.69, 18.63, 18.57, 18.50, 18.39,
     +  18.34, 18.29, 18.25, 18.18, 18.14, 18.09, 18.05, 17.98, 17.92,
     +  17.87, 17.81, 17.72, 17.66, 17.62, 17.59, 17.55, 17.52, 17.49,
     +  17.46, 17.44, 17.43, 17.42, 17.41, 17.41, 17.40, 17.40, 17.40,
     +  17.40, 17.40, 17.40, 17.40, 17.41, 17.41, 17.42, 17.42, 17.43,
     +  17.43, 17.44, 17.44, 17.45, 17.45, 17.46, 17.47, 17.48, 17.48,
     +  17.48, 17.49, 17.49, 17.50, 17.50, 17.50, 17.49, 17.49, 17.49,
     +  17.49, 17.50, 17.50, 17.50, 17.51, 17.52, 17.54, 17.55, 17.58,
     +  17.60, 17.62, 17.63, 17.66, 17.68, 17.70, 17.73, 17.76, 17.79,
     +  17.81, 17.83, 17.87, 17.90, 17.92, 17.95, 17.99, 18.01, 18.03,
     +  18.06, 18.10, 18.13, 18.16, 18.19, 18.23, 18.26, 18.29, 18.33/
       DATA SIGKM /
     +  76.56, 74.23, 72.44, 70.86, 69.28, 66.99, 65.66, 64.35, 62.47,
     +  61.33, 60.23, 59.18, 57.65, 56.68, 55.73, 54.78, 53.21, 52.17,
     +  51.31, 50.48, 49.27, 48.55, 47.89, 47.30, 46.48, 45.91, 45.31,
     +  44.74, 43.78, 43.13, 42.48, 41.77, 40.57, 39.85, 39.01, 38.22,
     +  37.05, 36.34, 35.66, 35.01, 34.23, 33.98, 33.73, 33.53, 33.26,
     +  33.24, 33.41, 33.68, 34.13, 34.53, 34.94, 35.52, 36.37, 37.02,
     +  37.58, 38.00, 38.11, 37.88, 37.44, 36.88, 35.77, 35.12, 34.34,
     +  33.26, 32.60, 31.91, 31.29, 30.54, 30.13, 29.77, 29.45, 29.03,
     +  28.80, 28.58, 28.35, 27.97, 27.70, 27.40, 27.10, 26.70, 26.48,
     +  26.29, 26.07, 25.73, 25.52, 25.31, 25.13, 24.86, 24.72, 24.57,
     +  24.42, 24.17, 24.01, 23.89, 23.77, 23.60, 23.49, 23.38, 23.29,
     +  23.14, 23.05, 22.97, 22.90, 22.79, 22.71, 22.64, 22.56, 22.45,
     +  22.37, 22.28, 22.20, 22.07, 21.99, 21.91, 21.82, 21.69, 21.61,
     +  21.53, 21.45, 21.34, 21.27, 21.20, 21.11, 21.06, 21.00, 20.95,
     +  20.87, 20.83, 20.80, 20.77, 20.71, 20.68, 20.65, 20.62, 20.57,
     +  20.54, 20.52, 20.50, 20.46, 20.43, 20.40, 20.38, 20.35, 20.32,
     +  20.30, 20.28, 20.25, 20.24, 20.23, 20.21, 20.20, 20.20, 20.19,
     +  20.19, 20.18, 20.18, 20.18, 20.17, 20.16, 20.15, 20.14, 20.12/
       DATA SIGPI /
     +   5.02,  5.69,  6.20,  6.81,  7.56,  9.29, 10.54, 12.24, 15.11,
     +  17.54, 20.45, 23.24, 28.67, 32.75, 37.60, 42.78, 52.32, 59.55,
     +  67.49, 75.47, 87.11, 94.75,101.54,106.41,111.56,113.00,112.73,
     + 110.52,105.96,101.22, 95.06, 88.38, 77.77, 70.51, 63.86, 57.83,
     +  49.65, 45.30, 41.45, 38.23, 34.33, 32.40, 30.86, 29.68, 28.76,
     +  28.61, 28.53, 28.41, 28.04, 27.81, 27.89, 28.24, 29.65, 31.04,
     +  32.53, 33.91, 34.81, 34.92, 35.12, 35.32, 35.83, 36.30, 36.71,
     +  36.93, 36.79, 36.49, 36.18, 35.80, 35.59, 35.35, 35.12, 34.65,
     +  34.26, 33.85, 33.46, 32.97, 32.75, 32.61, 32.51, 32.37, 32.25,
     +  32.12, 31.96, 31.67, 31.47, 31.25, 31.02, 30.67, 30.44, 30.21,
     +  29.98, 29.65, 29.44, 29.23, 29.03, 28.72, 28.52, 28.33, 28.14,
     +  27.85, 27.66, 27.47, 27.30, 27.04, 26.90, 26.76, 26.65, 26.51,
     +  26.43, 26.35, 26.28, 26.19, 26.13, 26.07, 26.02, 25.92, 25.85,
     +  25.78, 25.70, 25.58, 25.51, 25.43, 25.32, 25.25, 25.18, 25.11,
     +  25.01, 24.94, 24.87, 24.81, 24.72, 24.65, 24.59, 24.54, 24.46,
     +  24.41, 24.36, 24.32, 24.25, 24.21, 24.18, 24.14, 24.09, 24.06,
     +  24.03, 24.00, 23.96, 23.93, 23.91, 23.88, 23.84, 23.82, 23.80,
     +  23.78, 23.76, 23.74, 23.73, 23.73, 23.72, 23.72, 23.72, 23.73/
C
C             25.49675=1./LOG(1.04)
C
      X      = 25.49675 * LOG(P * 10.)
      N      = X
      DIFF   = X - N
      N      = N + 1
      IF (N .LE. 0) N = 1
      IF (N .GT. 162) N = 162
C
C             Interpolate in SIG tables.
C
      S      = SIG(N,ITYPE)
      IF (N.EQ.1 .OR. N.EQ.162) GO TO 50
      S = S + DIFF * (SIG(N + 1,ITYPE) - S)
  50  CONTINUE
C
C             NOW FIND ABUL-MAGD PARAMETERS
C
      IS     = S
      IF (IS.LE.0) IS = 1
      IF (IS.GE.100) IS = 99
      SB     = SIGB(IS) + (S - IS) * (SIGB(IS + 1) - SIGB(IS))
      AL     = ALPHA(IS) + (S - IS) * (ALPHA(IS + 1) - ALPHA(IS))
      GHSIG  = SB*A**AL
      END
+DECK,  GHSIGM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:36  cernlib
* Geant

      FUNCTION GHSIGM(P,IPART,A)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Returns absorption cross-section in millibarns               *
C.    *   for a particle with                                          *
C.    *                momentum P (GEV/C)                              *
C.    *                GEANT type IPART                                *
C.    *      on a nucleus of atomic number A                           *
C.    *                                                                *
C.    *    ==>Called by : GPHADR                                       *
C.    *       Author    R.Barlow  *********                            *
C.    *       Modified to deal with K0 and extend to 41 particle       *
C.    *                types by John Allison, 31/1/84. *               *
C.    *                                                                *
C.    ******************************************************************
C.
C              The array NTYPE maps the GEANT particle type (IPART)
C              onto GHSIG's internal particle type.  Simple assumptions
C              are made for highly flavoured particles.  The K0 is
C              given a non-existent internal type 6 which causes the
C              mean of the K+ and K- cross sections to be calculated.
C
      DIMENSION NTYPE(41)
      DATA NTYPE/6*0,3*5,6,3,4,2*1,2,6,
     +  8*1,8*2,2*0,4,3,2*6,2*3,1/
C.
C.    ------------------------------------------------------------------
C.
      GHSIGM = 1.E-20
      IF (IPART .GT. 41) RETURN
      ITYPE  = NTYPE(IPART)
      IF (ITYPE .EQ. 0) RETURN
C
      IF (ITYPE .NE. 6)THEN
         GHSIGM = GHSIG(P, ITYPE, A)
      ELSE
         GHSIGM = 0.5 * (GHSIG(P, 3, A) + GHSIG(P, 4, A))
      ENDIF
C
      END
+DECK,  GLANDE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      FUNCTION GLANDE(X)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine DENLAN (G110)                *
C.    *                                                                *
C.    *    ==>Called by : GVACOE                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P1(0:4),P2(0:4),P3(0:4),P4(0:4),P5(0:4),P6(0:4)
      DIMENSION Q1(0:4),Q2(0:4),Q3(0:4),Q4(0:4),Q5(0:4),Q6(0:4)
      DIMENSION A1(1:3),A2(1:2)
C
      DATA (P1(I),I=0,4),(Q1(J),J=0,4)
     1/ 0.42598 94875E+0,-0.12497 62550E+0, 0.39842 43700E-1,
     2 -0.62982 87635E-2, 0.15111 62253E-2,
     3  1.0             ,-0.33882 60629E+0, 0.95943 93323E-1,
     4 -0.16080 42283E-1, 0.37789 42063E-2/
C
      DATA (P2(I),I=0,4),(Q2(J),J=0,4)
     1/ 0.17885 41609E+0, 0.11739 57403E+0, 0.14888 50518E-1,
     2 -0.13949 89411E-2, 0.12836 17211E-3,
     3  1.0             , 0.74287 95082E+0, 0.31539 32961E+0,
     4  0.66942 19548E-1, 0.87906 09714E-2/
C
      DATA (P3(I),I=0,4),(Q3(J),J=0,4)
     1/ 0.17885 44503E+0, 0.93591 61662E-1, 0.63253 87654E-2,
     2  0.66116 67319E-4,-0.20310 49101E-5,
     3  1.0             , 0.60978 09921E+0, 0.25606 16665E+0,
     4  0.47467 22384E-1, 0.69573 01675E-2/
C
      DATA (P4(I),I=0,4),(Q4(J),J=0,4)
     1/ 0.98740 54407E+0, 0.11867 23273E+3, 0.84927 94360E+3,
     2 -0.74377 92444E+3, 0.42702 62186E+3,
     3  1.0             , 0.10686 15961E+3, 0.33764 96214E+3,
     4  0.20167 12389E+4, 0.15970 63511E+4/
C
      DATA (P5(I),I=0,4),(Q5(J),J=0,4)
     1/ 0.10036 75074E+1, 0.16757 02434E+3, 0.47897 11289E+4,
     2  0.21217 86767E+5,-0.22324 94910E+5,
     3  1.0             , 0.15694 24537E+3, 0.37453 10488E+4,
     4  0.98346 98876E+4, 0.66924 28357E+5/
C
      DATA (P6(I),I=0,4),(Q6(J),J=0,4)
     1/ 0.10008 27619E+1, 0.66491 43136E+3, 0.62972 92665E+5,
     2  0.47555 46998E+6,-0.57436 09109E+7,
     3  1.0             , 0.65141 01098E+3, 0.56974 73333E+5,
     4  0.16591 74725E+6,-0.28157 59939E+7/
C
      DATA (A1(I),I=1,3)
     1/ 0.41666 66667E-1,-0.19965 27778E-1, 0.27095 38966E-1/
C
      DATA (A2(I),I=1,2)
     1/-0.18455 68670E+1,-0.42846 40743E+1/
C
      V=X
      IF(V .LT. -5.5) THEN
       U=EXP(V+1.0)
       GLANDE=0.3989422803*(EXP(-1.0/U)/SQRT(U))*
     1        (1.0+(A1(1)+(A1(2)+A1(3)*U)*U)*U)
      ELSE IF(V .LT. -1.0) THEN
       U=EXP(-V-1.0)
       GLANDE=EXP(-U)*SQRT(U)*
     1        (P1(0)+(P1(1)+(P1(2)+(P1(3)+P1(4)*V)*V)*V)*V)/
     2        (Q1(0)+(Q1(1)+(Q1(2)+(Q1(3)+Q1(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 1.0) THEN
       GLANDE=(P2(0)+(P2(1)+(P2(2)+(P2(3)+P2(4)*V)*V)*V)*V)/
     1        (Q2(0)+(Q2(1)+(Q2(2)+(Q2(3)+Q2(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 5.0) THEN
       GLANDE=(P3(0)+(P3(1)+(P3(2)+(P3(3)+P3(4)*V)*V)*V)*V)/
     1        (Q3(0)+(Q3(1)+(Q3(2)+(Q3(3)+Q3(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 12.0) THEN
       U=1.0/V
       GLANDE=U**2*(P4(0)+(P4(1)+(P4(2)+(P4(3)+P4(4)*U)*U)*U)*U)/
     1             (Q4(0)+(Q4(1)+(Q4(2)+(Q4(3)+Q4(4)*U)*U)*U)*U)
      ELSE IF(V .LT. 50.0) THEN
       U=1.0/V
       GLANDE=U**2*(P5(0)+(P5(1)+(P5(2)+(P5(3)+P5(4)*U)*U)*U)*U)/
     1             (Q5(0)+(Q5(1)+(Q5(2)+(Q5(3)+Q5(4)*U)*U)*U)*U)
      ELSE IF(V .LT. 300.0) THEN
       U=1.0/V
       GLANDE=U**2*(P6(0)+(P6(1)+(P6(2)+(P6(3)+P6(4)*U)*U)*U)*U)/
     1             (Q6(0)+(Q6(1)+(Q6(2)+(Q6(3)+Q6(4)*U)*U)*U)*U)
      ELSE
       U=1.0/(V-V*LOG(V)/(V+1.0))
       GLANDE=U**2*(1.0+(A2(1)+A2(2)*U)*U)
      END IF
      RETURN
      END

+DECK,  GLANDG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GLANDG(YRAN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine GENLAN                       *
C.    *  Generation of LANDAU-distributed random numbers by 4-point    *
C.    *  interpolation in the previously-tabulated inverse cumulative  *
C.    *  distribution                                                  *
C.    *                                                                *
C.    *    ==>Called by : GLANDO                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (RANGE1=0.807069,RANGE2=0.994869)
      PARAMETER (X1BOT =0.0     ,X2BOT =0.791240)
      PARAMETER (GP1INV=118.836 ,GP2INV=486.178 )
C
      DIMENSION XCUM1(100) , XCUM2(100)
      DIMENSION RNDM(1)
C
C====>  1ST TABLE OF INVERSE CUMULATIVE LANDAU POINTS. ( 0.0<P<0.833 )
      DATA XCUM1(  1) / -2.57000 /   ,   XCUM1(  2) / -2.15412 /
      DATA XCUM1(  3) / -1.94167 /   ,   XCUM1(  4) / -1.79583 /
      DATA XCUM1(  5) / -1.67975 /   ,   XCUM1(  6) / -1.58090 /
      DATA XCUM1(  7) / -1.49341 /   ,   XCUM1(  8) / -1.41397 /
      DATA XCUM1(  9) / -1.34057 /   ,   XCUM1( 10) / -1.27185 /
      DATA XCUM1( 11) / -1.20686 /   ,   XCUM1( 12) / -1.14490 /
      DATA XCUM1( 13) / -1.08545 /   ,   XCUM1( 14) / -1.02809 /
      DATA XCUM1( 15) /  -.97249 /   ,   XCUM1( 16) /  -.91839 /
      DATA XCUM1( 17) /  -.86557 /   ,   XCUM1( 18) /  -.81386 /
      DATA XCUM1( 19) /  -.76308 /   ,   XCUM1( 20) /  -.71311 /
      DATA XCUM1( 21) /  -.66384 /   ,   XCUM1( 22) /  -.61515 /
      DATA XCUM1( 23) /  -.56696 /   ,   XCUM1( 24) /  -.51919 /
      DATA XCUM1( 25) /  -.47176 /   ,   XCUM1( 26) /  -.42462 /
      DATA XCUM1( 27) /  -.37769 /   ,   XCUM1( 28) /  -.33092 /
      DATA XCUM1( 29) /  -.28426 /   ,   XCUM1( 30) /  -.23767 /
      DATA XCUM1( 31) /  -.19109 /   ,   XCUM1( 32) /  -.14447 /
      DATA XCUM1( 33) /  -.09779 /   ,   XCUM1( 34) /  -.05100 /
      DATA XCUM1( 35) /  -.00405 /   ,   XCUM1( 36) /   .04308 /
      DATA XCUM1( 37) /   .09044 /   ,   XCUM1( 38) /   .13806 /
      DATA XCUM1( 39) /   .18598 /   ,   XCUM1( 40) /   .23423 /
      DATA XCUM1( 41) /   .28285 /   ,   XCUM1( 42) /   .33187 /
      DATA XCUM1( 43) /   .38134 /   ,   XCUM1( 44) /   .43128 /
      DATA XCUM1( 45) /   .48174 /   ,   XCUM1( 46) /   .53275 /
      DATA XCUM1( 47) /   .58435 /   ,   XCUM1( 48) /   .63658 /
      DATA XCUM1( 49) /   .68948 /   ,   XCUM1( 50) /   .74309 /
      DATA XCUM1( 51) /   .79746 /   ,   XCUM1( 52) /   .85263 /
      DATA XCUM1( 53) /   .90865 /   ,   XCUM1( 54) /   .96556 /
      DATA XCUM1( 55) /  1.02342 /   ,   XCUM1( 56) /  1.08228 /
      DATA XCUM1( 57) /  1.14219 /   ,   XCUM1( 58) /  1.20322 /
      DATA XCUM1( 59) /  1.26542 /   ,   XCUM1( 60) /  1.32887 /
      DATA XCUM1( 61) /  1.39362 /   ,   XCUM1( 62) /  1.45976 /
      DATA XCUM1( 63) /  1.52736 /   ,   XCUM1( 64) /  1.59650 /
      DATA XCUM1( 65) /  1.66727 /   ,   XCUM1( 66) /  1.73976 /
      DATA XCUM1( 67) /  1.81407 /   ,   XCUM1( 68) /  1.89032 /
      DATA XCUM1( 69) /  1.96860 /   ,   XCUM1( 70) /  2.04905 /
      DATA XCUM1( 71) /  2.13180 /   ,   XCUM1( 72) /  2.21699 /
      DATA XCUM1( 73) /  2.30477 /   ,   XCUM1( 74) /  2.39531 /
      DATA XCUM1( 75) /  2.48878 /   ,   XCUM1( 76) /  2.58540 /
      DATA XCUM1( 77) /  2.68535 /   ,   XCUM1( 78) /  2.78889 /
      DATA XCUM1( 79) /  2.89626 /   ,   XCUM1( 80) /  3.00775 /
      DATA XCUM1( 81) /  3.12364 /   ,   XCUM1( 82) /  3.24429 /
      DATA XCUM1( 83) /  3.37005 /   ,   XCUM1( 84) /  3.50136 /
      DATA XCUM1( 85) /  3.63866 /   ,   XCUM1( 86) /  3.78246 /
      DATA XCUM1( 87) /  3.93334 /   ,   XCUM1( 88) /  4.09194 /
      DATA XCUM1( 89) /  4.25900 /   ,   XCUM1( 90) /  4.43533 /
      DATA XCUM1( 91) /  4.62186 /   ,   XCUM1( 92) /  4.81960 /
      DATA XCUM1( 93) /  5.02974 /   ,   XCUM1( 94) /  5.25368 /
      DATA XCUM1( 95) /  5.49312 /   ,   XCUM1( 96) /  5.74987 /
      DATA XCUM1( 97) /  6.02605 /   ,   XCUM1( 98) /  6.32428 /
      DATA XCUM1( 99) /  6.64773 /   ,   XCUM1(100) /  7.00000 /
C
C====>  2ND TABLE OF INVERSE CUMULATIVE LANDAU POINTS. ( 0.791<P<0.995 )
      DATA XCUM2(  1) /   5.50000 /   ,   XCUM2(  2) /   5.56120 /
      DATA XCUM2(  3) /   5.62347 /   ,   XCUM2(  4) /   5.68684 /
      DATA XCUM2(  5) /   5.75133 /   ,   XCUM2(  6) /   5.81699 /
      DATA XCUM2(  7) /   5.88383 /   ,   XCUM2(  8) /   5.95191 /
      DATA XCUM2(  9) /   6.02125 /   ,   XCUM2( 10) /   6.09190 /
      DATA XCUM2( 11) /   6.16391 /   ,   XCUM2( 12) /   6.23732 /
      DATA XCUM2( 13) /   6.31219 /   ,   XCUM2( 14) /   6.38855 /
      DATA XCUM2( 15) /   6.46646 /   ,   XCUM2( 16) /   6.54597 /
      DATA XCUM2( 17) /   6.62712 /   ,   XCUM2( 18) /   6.70998 /
      DATA XCUM2( 19) /   6.79460 /   ,   XCUM2( 20) /   6.88103 /
      DATA XCUM2( 21) /   6.96935 /   ,   XCUM2( 22) /   7.05962 /
      DATA XCUM2( 23) /   7.15192 /   ,   XCUM2( 24) /   7.24633 /
      DATA XCUM2( 25) /   7.34294 /   ,   XCUM2( 26) /   7.44182 /
      DATA XCUM2( 27) /   7.54306 /   ,   XCUM2( 28) /   7.64676 /
      DATA XCUM2( 29) /   7.75300 /   ,   XCUM2( 30) /   7.86188 /
      DATA XCUM2( 31) /   7.97351 /   ,   XCUM2( 32) /   8.08800 /
      DATA XCUM2( 33) /   8.20548 /   ,   XCUM2( 34) /   8.32610 /
      DATA XCUM2( 35) /   8.44997 /   ,   XCUM2( 36) /   8.57725 /
      DATA XCUM2( 37) /   8.70808 /   ,   XCUM2( 38) /   8.84262 /
      DATA XCUM2( 39) /   8.98103 /   ,   XCUM2( 40) /   9.12349 /
      DATA XCUM2( 41) /   9.27021 /   ,   XCUM2( 42) /   9.42141 /
      DATA XCUM2( 43) /   9.57730 /   ,   XCUM2( 44) /   9.73812 /
      DATA XCUM2( 45) /   9.90410 /   ,   XCUM2( 46) /  10.07552 /
      DATA XCUM2( 47) /  10.25265 /   ,   XCUM2( 48) /  10.43584 /
      DATA XCUM2( 49) /  10.62540 /   ,   XCUM2( 50) /  10.82169 /
      DATA XCUM2( 51) /  11.02508 /   ,   XCUM2( 52) /  11.23598 /
      DATA XCUM2( 53) /  11.45487 /   ,   XCUM2( 54) /  11.68222 /
      DATA XCUM2( 55) /  11.91855 /   ,   XCUM2( 56) /  12.16441 /
      DATA XCUM2( 57) /  12.42045 /   ,   XCUM2( 58) /  12.68734 /
      DATA XCUM2( 59) /  12.96580 /   ,   XCUM2( 60) /  13.25663 /
      DATA XCUM2( 61) /  13.56075 /   ,   XCUM2( 62) /  13.87912 /
      DATA XCUM2( 63) /  14.21280 /   ,   XCUM2( 64) /  14.56296 /
      DATA XCUM2( 65) /  14.93088 /   ,   XCUM2( 66) /  15.31799 /
      DATA XCUM2( 67) /  15.72593 /   ,   XCUM2( 68) /  16.15650 /
      DATA XCUM2( 69) /  16.61170 /   ,   XCUM2( 70) /  17.09378 /
      DATA XCUM2( 71) /  17.60523 /   ,   XCUM2( 72) /  18.14884 /
      DATA XCUM2( 73) /  18.72792 /   ,   XCUM2( 74) /  19.34622 /
      DATA XCUM2( 75) /  20.00796 /   ,   XCUM2( 76) /  20.71792 /
      DATA XCUM2( 77) /  21.48176 /   ,   XCUM2( 78) /  22.30618 /
      DATA XCUM2( 79) /  23.19862 /   ,   XCUM2( 80) /  24.16809 /
      DATA XCUM2( 81) /  25.22547 /   ,   XCUM2( 82) /  26.38320 /
      DATA XCUM2( 83) /  27.65658 /   ,   XCUM2( 84) /  29.06490 /
      DATA XCUM2( 85) /  30.63048 /   ,   XCUM2( 86) /  32.38211 /
      DATA XCUM2( 87) /  34.35555 /   ,   XCUM2( 88) /  36.59607 /
      DATA XCUM2( 89) /  39.16212 /   ,   XCUM2( 90) /  42.13195 /
      DATA XCUM2( 91) /  45.61204 /   ,   XCUM2( 92) /  49.74758 /
      DATA XCUM2( 93) /  54.74189 /   ,   XCUM2( 94) /  60.89935 /
      DATA XCUM2( 95) /  68.67370 /   ,   XCUM2( 96) /  78.81480 /
      DATA XCUM2( 97) /  92.61047 /   ,   XCUM2( 98) / 112.50807 /
      DATA XCUM2( 99) / 143.78539 /   ,   XCUM2(100) / 200.00000 /
C.
C.    ------------------------------------------------------------------
C.
      CALL GRNDM(RNDM,1)
      X = RNDM(1)
      IF(X .LT. 0.004) THEN
*
* *** Extreme left-hand tail
         YRAN = -SQRT(ABS(LOG(X)))
*
      ELSEIF(X.LE.RANGE1) THEN
*
* *** 4-point interpolation in the first cumulative table
         TABPO1 = (X-X1BOT)*GP1INV
         J = TABPO1 + 1
         J = MAX(J,2)
         J = MIN(J,98)
         P = TABPO1 - (J-1)
         A = (P+1.0) * XCUM1(J+2) - (P-2.0) * XCUM1(J-1)
         B = (P-1.0) * XCUM1(J)   - P       * XCUM1(J+1)
         YRAN = A*P*(P-1.0)*0.16666667+B*(P+1.0)*(P-2.0)*0.5
*
      ELSEIF(X.LE.RANGE2) THEN
*
* *** 4-point interpolation in the first cumulative table
         TABPO2 = (X-X2BOT)*GP2INV
         J = TABPO2 + 1
         J = MAX(J,2)
         J = MIN(J,98)
         P = TABPO2 - (J-1)
         A = (P+1.0) * XCUM2(J+2) - (P-2.0) * XCUM2(J-1)
         B = (P-1.0) * XCUM2(J)   - P       * XCUM2(J+1)
         YRAN = A*P*(P-1.0)*0.16666667+B*(P+1.0)*(P-2.0)*0.5
*
      ELSE
*
* *** 1/x**2 sampling for extreme Landau tail
         CALL GRNDM(RNDM,1)
         YRAN=200./RNDM(1)
*
      ENDIF
      END
+DECK,  GLANDO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GLANDO(IMODE,STEP,Z,A,RHO,P,E,XMASS,DE,IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *  GLANDO                                                        *
C.    *  ------                                                        *
C.    *                                                                *
C.    *  Energy straggling using Gaussian, Landau & Vavilov theories.  *
C.    *                                                                *
C.    *  Input                                                         *
C.    *  -----                                                         *
C.    *  IMODE  =  3   Landau(RANLAN)  sampling                        *
C.    *         =  4   Landau(GENLAN)  sampling                        *
C.    *         =  5   Vavilov(DINVAV) sampling                        *
C.    *         =  6   Gaussian sampling                               *
C.    *         =  2   Automatic selection of relevant distribution    *
C.    *                                                                *
C.    *  STEP   =  current step-length (cm)                            *
C.    *                                                                *
C.    *  Output                                                        *
C.    *  ------                                                        *
C.    *  DE     =  DE/DX - <DE/DX>     (GeV)                           *
C.    *                                                                *
C.    *  IFLAG  =  3   Landau(RANLAN) sampling used                    *
C.    *         =  4   Landau(GENLAN) sampling used                    *
C.    *         =  5   Vavilov(GVAVIV) sampling used                   *
C.    *         =  6   Gaussian sampling used                          *
C.    *                                                                *
C.    *  Warning                                                       *
C.    *  -------                                                       *
C.    *  Only Landau sampling should be used since this has been well  *
C.    *  tested whereas both Vavilov and Gaussian sampling are being   *
C.    *  developed.                                                    *
C.    *                                                                *
C.    *  Author      : G.N. Patrick                                    *
C.    *  Date        : 03.05.1985                                      *
C.    *  Last update : 09.09.1985                                      *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (EULER=0.577215)
      PARAMETER (P1=.60715,P2=.67794,P3=.52382E-1,P4=.94753,
     +           P5=.74442,P6=1.1934)
+CDE, GCONSP.
      DIMENSION RNDM(2)
      FLAND(X) = P1+P6*X+(P2+P3*X)*EXP(P4*X+P5)
C.
C.    ------------------------------------------------------------------
C.
      IF(STEP.LT.1.E-7)THEN
         DE=0.
         IFLAG=0
         RETURN
      ENDIF
C
C     Calculate xi factor (KeV).
C
      BETA   = P/E
      GAMMA  = E/XMASS
      XI     = (153.5*Z*STEP*RHO)/(A*BETA*BETA)
C
C     Maximum energy transfer to atomic electron (KeV).
C
      ETA    = BETA*GAMMA
      ETASQ  = ETA*ETA
      RATIO  = EMASS/XMASS
      F1     = 2.*EMASS*ETASQ
      F2     = 1.+2.*RATIO*GAMMA+RATIO*RATIO
      EMAX   = F1*1.E+6/F2
C
C     Calculate Kappa significance ratio.
C
      CAPPA  = XI/EMAX
C
C     Choose correct function if IMODE set to automatic selection.
C
      IMODEI = IMODE
      IF (IMODEI.EQ.2)    THEN
         IF (CAPPA.LT.0.01)                              IMODEI = 4
*****    IF (CAPPA.GE.0.01.AND.CAPPA.LE.10.)             IMODEI = 3
         IF (CAPPA.GE.0.01.AND.CAPPA.LE.10.)             IMODEI = 5
         IF (CAPPA.GT.10.)                               IMODEI = 6
      ENDIF
C
C     +---------------------------------------------------------------+
C     I Sample lambda variable from Kolbig/Schorr Landau distribution I
C     +---------------------------------------------------------------+
C
   10 CONTINUE
      IF (IMODEI.EQ.3) THEN
         XMEAN = -BETA**2-LOG(XI/EMAX)+EULER-1.
         XLAMX = FLAND(XMEAN)
   20    CALL GRNDM(RNDM,1)
         IF( RNDM(1) .GT. 0.980 ) GO TO 20
         XLAMB = GLANDR(RNDM(1))
         IF(XLAMB.GT.XLAMX) GO TO 20
         IFLAG  = 3
C
C            +----------------------------------------------+
C            I  Sample lambda variable from James & Hancock I
C            I  Landau distribution                         I
C            +----------------------------------------------+
C

      ELSEIF (IMODEI.EQ.4) THEN
         XMEAN = -BETA**2-LOG(XI/EMAX)+EULER-1.
         XLAMX = FLAND(XMEAN)
  25     CALL GLANDG(XLAMB)
         IF(XLAMB.GT.XLAMX) GO TO 25
         IFLAG = 4
C
C            +---------------------------------------------------------+
C            I Sample lambda variable (Landau not Vavilov) from        I
C            I Rotondi&Montagna&Kolbig Vavilov distribution            I
C            +---------------------------------------------------------+
C
      ELSEIF (IMODEI.EQ.5) THEN
C
C            Keep within computation bounds.
C
         RKA = CAPPA
         BE2 = BETA*BETA
         CALL GRNDM(RNDM,1)
         XLAMB = GVAVIV(RKA,BE2,RNDM(1))
         IFLAG = 5
C
C     +-----------------------------------+
C     I Sample from Gaussian distribution I
C     +-----------------------------------+
C
      ELSEIF (IMODEI.EQ.6) THEN
         SIGMA  = XI*EMAX*(1.-(BETA*BETA/2.))
         SIGMA  = SQRT(SIGMA)
   30    CALL GRNDM(RNDM,2)
         IF(RNDM(1).LE.0.)GO TO 30
         F1     = -2.*LOG(RNDM(1))
         DEKEV  = SIGMA*SQRT(F1)*COS(2.*PI*RNDM(2))
         IFLAG  = 6
         GOTO 40
      ENDIF
C
C     Calculate DE/DX - <DE/DX>
C
      DEKEV  = XI*(XLAMB+BETA*BETA+LOG(XI/EMAX)-EULER+1.)
C
   40 DE=DEKEV*1.E-6
      END
+DECK,  GLANDR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      FUNCTION GLANDR(X)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine RANLAN for restricted        *
C.    *  Landau distribution.                                          *
C.    *                                                                *
C.    *    ==>Called by : GLANDO                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION F(-1:1002)
      DATA (F(I),I= -1,100)
     A/     7*0.,                                        -2.244733,
     B -2.204365,-2.168163,-2.135219,-2.104898,-2.076740,-2.050397,
     C -2.025605,-2.002150,-1.979866,-1.958612,-1.938275,-1.918760,
     D -1.899984,-1.881879,-1.864385,-1.847451,-1.831030,-1.815083,
     E -1.799574,-1.784473,-1.769751,-1.755383,-1.741346,-1.727620,
     F -1.714187,-1.701029,-1.688130,-1.675477,-1.663057,-1.650858,
     G -1.638868,-1.627078,-1.615477,-1.604058,-1.592811,-1.581729,
     H -1.570806,-1.560034,-1.549407,-1.538919,-1.528565,-1.518339,
     I -1.508237,-1.498254,-1.488386,-1.478628,-1.468976,-1.459428,
     J -1.449979,-1.440626,-1.431365,-1.422195,-1.413111,-1.404112,
     K -1.395194,-1.386356,-1.377594,-1.368906,-1.360291,-1.351746,
     L -1.343269,-1.334859,-1.326512,-1.318229,-1.310006,-1.301843,
     M -1.293737,-1.285688,-1.277693,-1.269752,-1.261863,-1.254024,
     N -1.246235,-1.238494,-1.230800,-1.223153,-1.215550,-1.207990,
     O -1.200474,-1.192999,-1.185566,-1.178172,-1.170817,-1.163500,
     P -1.156220,-1.148977,-1.141770,-1.134598,-1.127459,-1.120354,
     Q -1.113282,-1.106242,-1.099233,-1.092255/
C
      DATA (F(I),I=101,200)
     A/-1.085306,-1.078388,-1.071498,-1.064636,-1.057802,-1.050996,
     B -1.044215,-1.037461,-1.030733,-1.024029,-1.017350,-1.010695,
     C -1.004064, -.997456, -.990871, -.984308, -.977767, -.971247,
     D  -.964749, -.958271, -.951813, -.945375, -.938957, -.932558,
     E  -.926178, -.919816, -.913472, -.907146, -.900838, -.894547,
     F  -.888272, -.882014, -.875773, -.869547, -.863337, -.857142,
     G  -.850963, -.844798, -.838648, -.832512, -.826390, -.820282,
     H  -.814187, -.808106, -.802038, -.795982, -.789940, -.783909,
     I  -.777891, -.771884, -.765889, -.759906, -.753934, -.747973,
     J  -.742023, -.736084, -.730155, -.724237, -.718328, -.712429,
     K  -.706541, -.700661, -.694791, -.688931, -.683079, -.677236,
     L  -.671402, -.665576, -.659759, -.653950, -.648149, -.642356,
     M  -.636570, -.630793, -.625022, -.619259, -.613503, -.607754,
     N  -.602012, -.596276, -.590548, -.584825, -.579109, -.573399,
     O  -.567695, -.561997, -.556305, -.550618, -.544937, -.539262,
     P  -.533592, -.527926, -.522266, -.516611, -.510961, -.505315,
     Q  -.499674, -.494037, -.488405, -.482777/
C
      DATA (F(I),I=201,300)
     A/ -.477153, -.471533, -.465917, -.460305, -.454697, -.449092,
     B  -.443491, -.437893, -.432299, -.426707, -.421119, -.415534,
     C  -.409951, -.404372, -.398795, -.393221, -.387649, -.382080,
     D  -.376513, -.370949, -.365387, -.359826, -.354268, -.348712,
     E  -.343157, -.337604, -.332053, -.326503, -.320955, -.315408,
     F  -.309863, -.304318, -.298775, -.293233, -.287692, -.282152,
     G  -.276613, -.271074, -.265536, -.259999, -.254462, -.248926,
     H  -.243389, -.237854, -.232318, -.226783, -.221247, -.215712,
     I  -.210176, -.204641, -.199105, -.193568, -.188032, -.182495,
     J  -.176957, -.171419, -.165880, -.160341, -.154800, -.149259,
     K  -.143717, -.138173, -.132629, -.127083, -.121537, -.115989,
     L  -.110439, -.104889, -.099336, -.093782, -.088227, -.082670,
     M  -.077111, -.071550, -.065987, -.060423, -.054856, -.049288,
     N  -.043717, -.038144, -.032569, -.026991, -.021411, -.015828,
     O  -.010243, -.004656,  .000934,  .006527,  .012123,  .017722,
     P   .023323,  .028928,  .034535,  .040146,  .045759,  .051376,
     Q   .056997,  .062620,  .068247,  .073877/
C
      DATA (F(I),I=301,400)
     A/  .079511,  .085149,  .090790,  .096435,  .102083,  .107736,
     B   .113392,  .119052,  .124716,  .130385,  .136057,  .141734,
     C   .147414,  .153100,  .158789,  .164483,  .170181,  .175884,
     D   .181592,  .187304,  .193021,  .198743,  .204469,  .210201,
     E   .215937,  .221678,  .227425,  .233177,  .238933,  .244696,
     F   .250463,  .256236,  .262014,  .267798,  .273587,  .279382,
     G   .285183,  .290989,  .296801,  .302619,  .308443,  .314273,
     H   .320109,  .325951,  .331799,  .337654,  .343515,  .349382,
     I   .355255,  .361135,  .367022,  .372915,  .378815,  .384721,
     J   .390634,  .396554,  .402481,  .408415,  .414356,  .420304,
     K   .426260,  .432222,  .438192,  .444169,  .450153,  .456145,
     L   .462144,  .468151,  .474166,  .480188,  .486218,  .492256,
     M   .498302,  .504356,  .510418,  .516488,  .522566,  .528653,
     N   .534747,  .540850,  .546962,  .553082,  .559210,  .565347,
     O   .571493,  .577648,  .583811,  .589983,  .596164,  .602355,
     P   .608554,  .614762,  .620980,  .627207,  .633444,  .639689,
     Q   .645945,  .652210,  .658484,  .664768/
C
      DATA (F(I),I=401,500)
     A/  .671062,  .677366,  .683680,  .690004,  .696338,  .702682,
     B   .709036,  .715400,  .721775,  .728160,  .734556,  .740963,
     C   .747379,  .753807,  .760246,  .766695,  .773155,  .779627,
     D   .786109,  .792603,  .799107,  .805624,  .812151,  .818690,
     E   .825241,  .831803,  .838377,  .844962,  .851560,  .858170,
     F   .864791,  .871425,  .878071,  .884729,  .891399,  .898082,
     G   .904778,  .911486,  .918206,  .924940,  .931686,  .938446,
     H   .945218,  .952003,  .958802,  .965614,  .972439,  .979278,
     I   .986130,  .992996,  .999875, 1.006769, 1.013676, 1.020597,
     J  1.027533, 1.034482, 1.041446, 1.048424, 1.055417, 1.062424,
     K  1.069446, 1.076482, 1.083534, 1.090600, 1.097681, 1.104778,
     L  1.111889, 1.119016, 1.126159, 1.133316, 1.140490, 1.147679,
     M  1.154884, 1.162105, 1.169342, 1.176595, 1.183864, 1.191149,
     N  1.198451, 1.205770, 1.213105, 1.220457, 1.227826, 1.235211,
     O  1.242614, 1.250034, 1.257471, 1.264926, 1.272398, 1.279888,
     P  1.287395, 1.294921, 1.302464, 1.310026, 1.317605, 1.325203,
     Q  1.332819, 1.340454, 1.348108, 1.355780/
C
      DATA (F(I),I=501,600)
     A/ 1.363472, 1.371182, 1.378912, 1.386660, 1.394429, 1.402216,
     B  1.410024, 1.417851, 1.425698, 1.433565, 1.441453, 1.449360,
     C  1.457288, 1.465237, 1.473206, 1.481196, 1.489208, 1.497240,
     D  1.505293, 1.513368, 1.521465, 1.529583, 1.537723, 1.545885,
     E  1.554068, 1.562275, 1.570503, 1.578754, 1.587028, 1.595325,
     F  1.603644, 1.611987, 1.620353, 1.628743, 1.637156, 1.645593,
     G  1.654053, 1.662538, 1.671047, 1.679581, 1.688139, 1.696721,
     H  1.705329, 1.713961, 1.722619, 1.731303, 1.740011, 1.748746,
     I  1.757506, 1.766293, 1.775106, 1.783945, 1.792810, 1.801703,
     J  1.810623, 1.819569, 1.828543, 1.837545, 1.846574, 1.855631,
     K  1.864717, 1.873830, 1.882972, 1.892143, 1.901343, 1.910572,
     L  1.919830, 1.929117, 1.938434, 1.947781, 1.957158, 1.966566,
     M  1.976004, 1.985473, 1.994972, 2.004503, 2.014065, 2.023659,
     N  2.033285, 2.042943, 2.052633, 2.062355, 2.072110, 2.081899,
     O  2.091720, 2.101575, 2.111464, 2.121386, 2.131343, 2.141334,
     P  2.151360, 2.161421, 2.171517, 2.181648, 2.191815, 2.202018,
     Q  2.212257, 2.222533, 2.232845, 2.243195/
C
      DATA (F(I),I=601,700)
     A/ 2.253582, 2.264006, 2.274468, 2.284968, 2.295507, 2.306084,
     B  2.316701, 2.327356, 2.338051, 2.348786, 2.359562, 2.370377,
     C  2.381234, 2.392131, 2.403070, 2.414051, 2.425073, 2.436138,
     D  2.447246, 2.458397, 2.469591, 2.480828, 2.492110, 2.503436,
     E  2.514807, 2.526222, 2.537684, 2.549190, 2.560743, 2.572343,
     F  2.583989, 2.595682, 2.607423, 2.619212, 2.631050, 2.642936,
     G  2.654871, 2.666855, 2.678890, 2.690975, 2.703110, 2.715297,
     H  2.727535, 2.739825, 2.752168, 2.764563, 2.777012, 2.789514,
     I  2.802070, 2.814681, 2.827347, 2.840069, 2.852846, 2.865680,
     J  2.878570, 2.891518, 2.904524, 2.917588, 2.930712, 2.943894,
     K  2.957136, 2.970439, 2.983802, 2.997227, 3.010714, 3.024263,
     L  3.037875, 3.051551, 3.065290, 3.079095, 3.092965, 3.106900,
     M  3.120902, 3.134971, 3.149107, 3.163312, 3.177585, 3.191928,
     N  3.206340, 3.220824, 3.235378, 3.250005, 3.264704, 3.279477,
     O  3.294323, 3.309244, 3.324240, 3.339312, 3.354461, 3.369687,
     P  3.384992, 3.400375, 3.415838, 3.431381, 3.447005, 3.462711,
     Q  3.478500, 3.494372, 3.510328, 3.526370/
C
      DATA (F(I),I=701,800)
     A/ 3.542497, 3.558711, 3.575012, 3.591402, 3.607881, 3.624450,
     B  3.641111, 3.657863, 3.674708, 3.691646, 3.708680, 3.725809,
     C  3.743034, 3.760357, 3.777779, 3.795300, 3.812921, 3.830645,
     D  3.848470, 3.866400, 3.884434, 3.902574, 3.920821, 3.939176,
     E  3.957640, 3.976215, 3.994901, 4.013699, 4.032612, 4.051639,
     F  4.070783, 4.090045, 4.109425, 4.128925, 4.148547, 4.168292,
     G  4.188160, 4.208154, 4.228275, 4.248524, 4.268903, 4.289413,
     H  4.310056, 4.330832, 4.351745, 4.372794, 4.393982, 4.415310,
     I  4.436781, 4.458395, 4.480154, 4.502060, 4.524114, 4.546319,
     J  4.568676, 4.591187, 4.613854, 4.636678, 4.659662, 4.682807,
     K  4.706116, 4.729590, 4.753231, 4.777041, 4.801024, 4.825179,
     L  4.849511, 4.874020, 4.898710, 4.923582, 4.948639, 4.973883,
     M  4.999316, 5.024942, 5.050761, 5.076778, 5.102993, 5.129411,
     N  5.156034, 5.182864, 5.209903, 5.237156, 5.264625, 5.292312,
     O  5.320220, 5.348354, 5.376714, 5.405306, 5.434131, 5.463193,
     P  5.492496, 5.522042, 5.551836, 5.581880, 5.612178, 5.642734,
     Q  5.673552, 5.704634, 5.735986, 5.767610/
C
      DATA (F(I),I=801,900)
     A/ 5.799512, 5.831694, 5.864161, 5.896918, 5.929968, 5.963316,
     B  5.996967, 6.030925, 6.065194, 6.099780, 6.134687, 6.169921,
     C  6.205486, 6.241387, 6.277630, 6.314220, 6.351163, 6.388465,
     D  6.426130, 6.464166, 6.502578, 6.541371, 6.580553, 6.620130,
     E  6.660109, 6.700495, 6.741297, 6.782520, 6.824173, 6.866262,
     F  6.908795, 6.951780, 6.995225, 7.039137, 7.083525, 7.128398,
     G  7.173764, 7.219632, 7.266011, 7.312910, 7.360339, 7.408308,
     H  7.456827, 7.505905, 7.555554, 7.605785, 7.656608, 7.708035,
     I  7.760077, 7.812747, 7.866057, 7.920019, 7.974647, 8.029953,
     J  8.085952, 8.142657, 8.200083, 8.258245, 8.317158, 8.376837,
     K  8.437300, 8.498562, 8.560641, 8.623554, 8.687319, 8.751955,
     L  8.817481, 8.883916, 8.951282, 9.019600, 9.088889, 9.159174,
     M  9.230477, 9.302822, 9.376233, 9.450735, 9.526355, 9.603118,
     N  9.681054, 9.760191, 9.840558, 9.922186,10.005107,10.089353,
     O 10.174959,10.261958,10.350389,10.440287,10.531693,10.624646,
     P 10.719188,10.815362,10.913214,11.012789,11.114137,11.217307,
     Q 11.322352,11.429325,11.538283,11.649285/
C
      DATA (F(I),I=901,1002)
     A/11.762390,11.877664,11.995170,12.114979,12.237161,12.361791,
     B 12.488946,12.618708,12.751161,12.886394,13.024498,13.165570,
     C 13.309711,13.457026,13.607625,13.761625,13.919145,14.080314,
     D 14.245263,14.414134,14.587072,14.764233,14.945778,15.131877,
     E 15.322712,15.518470,15.719353,15.925570,16.137345,16.354912,
     F 16.578520,16.808433,17.044929,17.288305,17.538873,17.796967,
     G 18.062943,18.337176,18.620068,18.912049,19.213574,19.525133,
     H 19.847249,20.180480,20.525429,20.882738,21.253102,21.637266,
     I 22.036036,22.450278,22.880933,23.329017,23.795634,24.281981,
     J 24.789364,25.319207,25.873062,26.452634,27.059789,27.696581,
     K 28.365274,29.068370,29.808638,30.589157,31.413354,32.285060,
     L 33.208568,34.188705,35.230920,36.341388,37.527131,38.796172,
     M 40.157721,41.622399,43.202525,44.912465,46.769077,48.792279,
     N 51.005773,53.437996,56.123356,59.103894,              20*0./
C.
C.    ------------------------------------------------------------------
C.
      U=1000.0*X
      I=U
      U=U-FLOAT(I)
      GLANDR=F(I)+U*(F(I+1)-F(I))
      IF(I .GE. 70 .AND. I .LE. 800) RETURN
      GLANDR=GLANDR-0.25*U*(1.0-U)*(F(I+2)-F(I+1)-F(I)+F(I-1))
      IF(I .GE.  7 .AND. I .LE. 980) RETURN
      IF(I. LT. 7) THEN
         IF(X.LT.1.E-10)THEN
            V=-30.
         ELSE
            V=LOG(X)
         ENDIF
         U=1.0/V
         GLANDR=((0.99858950+(3.45213058E1+1.70854528E1*U)*U)/
     1           (1.0       +(3.41760202E1+4.01244582  *U)*U))*
     2           (-LOG(-0.91893853-V)-1.0)
      ELSE
         U=1.0-X
         V=U**2
         IF(X .LE. 0.999) THEN
            GLANDR=(1.00060006+2.63991156E2*U+4.37320068E3*V)/
     1             ((1.0       +2.57368075E2*U+3.41448018E3*V)*U)
         ELSE
            GLANDR=(1.00001538+6.07514119E3*U+7.34266409E5*V)/
     1             ((1.0       +6.06511919E3*U+6.94021044E5*V)*U)
         ENDIF
      ENDIF
      END
+DECK,  GLANDS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      FUNCTION GLANDS(X)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Copy of the CERN library routine DSTLAN (G110)                *
C.    *                                                                *
C.    *    ==>Called by : GVACOE                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION P1(0:4),P2(0:3),P3(0:3),P4(0:3),P5(0:3),P6(0:3)
      DIMENSION Q1(0:4),Q2(0:3),Q3(0:3),Q4(0:3),Q5(0:3),Q6(0:3)
      DIMENSION A1(1:3),A2(1:3)
C
      DATA (P1(I),I=0,4),(Q1(J),J=0,4)
     1/ 0.25140 91491E+0,-0.62505 80444E-1, 0.14583 81230E-1,
     2 -0.21088 17737E-2, 0.74112 47290E-3,
     3  1.0             ,-0.55711 75625E-2, 0.62253 10236E-1,
     4 -0.31373 78427E-2, 0.19314 96439E-2/
C
      DATA (P2(I),I=0,3),(Q2(J),J=0,3)
     1/ 0.28683 28584E+0, 0.35643 63231E+0, 0.15235 18695E+0,
     2  0.22513 04883E-1,
     3  1.0             , 0.61911 36137E+0, 0.17207 21448E+0,
     4  0.22785 94771E-1/
C
      DATA (P3(I),I=0,3),(Q3(J),J=0,3)
     1/ 0.28683 29066E+0, 0.30038 28436E+0, 0.99509 51941E-1,
     2  0.87338 27185E-2,
     3  1.0             , 0.42371 90502E+0, 0.10956 31512E+0,
     4  0.86938 51567E-2/
C
      DATA (P4(I),I=0,3),(Q4(J),J=0,3)
     1/ 0.10003 51630E+1, 0.45035 92498E+1, 0.10858 83880E+2,
     2  0.75360 52269E+1,
     3  1.0             , 0.55399 69678E+1, 0.19335 81111E+2,
     4  0.27213 21508E+2/
C
      DATA (P5(I),I=0,3),(Q5(J),J=0,3)
     1/ 0.10000 06517E+1, 0.49094 14111E+2, 0.85055 44753E+2,
     2  0.15321 53455E+3,
     3  1.0             , 0.50099 28881E+2, 0.13998 19104E+3,
     4  0.42000 02909E+3/
C
      DATA (P6(I),I=0,3),(Q6(J),J=0,3)
     1/ 0.10000 00983E+1, 0.13298 68456E+3, 0.91621 49244E+3,
     2 -0.96050 54274E+3,
     3  1.0             , 0.13398 87843E+3, 0.10559 90413E+4,
     4  0.55322 24619E+3/
C
      DATA (A1(I),I=1,3)
     1/-0.45833 33333E+0, 0.66753 47222E+0,-0.16417 41416E+1/
C
      DATA (A2(I),I=1,3)
     1/ 1.0             ,-0.42278 43351E+0,-0.20434 03138E+1/
C
      V=X
      IF(V .LT. -5.5) THEN
       U=EXP(V+1.0)
       GLANDS=0.3989422803*EXP(-1.0/U)*SQRT(U)*
     1        (1.0+(A1(1)+(A1(2)+A1(3)*U)*U)*U)
      ELSE IF(V .LT. -1.0) THEN
       U=EXP(-V-1.0)
       GLANDS=(EXP(-U)/SQRT(U))*
     1        (P1(0)+(P1(1)+(P1(2)+(P1(3)+P1(4)*V)*V)*V)*V)/
     2        (Q1(0)+(Q1(1)+(Q1(2)+(Q1(3)+Q1(4)*V)*V)*V)*V)
      ELSE IF(V .LT. 1.0) THEN
       GLANDS=(P2(0)+(P2(1)+(P2(2)+P2(3)*V)*V)*V)/
     1        (Q2(0)+(Q2(1)+(Q2(2)+Q2(3)*V)*V)*V)
      ELSE IF(V .LT. 4.0) THEN
       GLANDS=(P3(0)+(P3(1)+(P3(2)+P3(3)*V)*V)*V)/
     1        (Q3(0)+(Q3(1)+(Q3(2)+Q3(3)*V)*V)*V)
      ELSE IF(V .LT. 12.0) THEN
       U=1.0/V
       GLANDS=(P4(0)+(P4(1)+(P4(2)+P4(3)*U)*U)*U)/
     1        (Q4(0)+(Q4(1)+(Q4(2)+Q4(3)*U)*U)*U)
      ELSE IF(V .LT. 50.0) THEN
       U=1.0/V
       GLANDS=(P5(0)+(P5(1)+(P5(2)+P5(3)*U)*U)*U)/
     1        (Q5(0)+(Q5(1)+(Q5(2)+Q5(3)*U)*U)*U)
      ELSE IF(V .LT. 300.0) THEN
       U=1.0/V
       GLANDS=(P6(0)+(P6(1)+(P6(2)+P6(3)*U)*U)*U)/
     1        (Q6(0)+(Q6(1)+(Q6(2)+Q6(3)*U)*U)*U)
      ELSE
       U=1.0/(V-V*LOG(V)/(V+1.0))
       GLANDS=1.0-(A2(1)+(A2(2)+A2(3)*U)*U)*U
      END IF
      RETURN
      END

+DECK,  GLANDZ, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:25  cernlib
* Geant

      SUBROUTINE GLANDZ(Z,STEP,P,E,DEDX,DE,POTI,POTIL)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Energy straggling using a Monte Carlo model.                  *
C.    *  It can be used with or without delta ray generation.          *
C.    *                                                                *
C.    *   It is a NEW VERSION of the model , which reproduces          *
C.    *   the experimental data rather well.                           *
C.    *                                                                *
C.    *  Input : STEP  = current step-length (cm)                      *
C.    *                                                                *
C.    *  Output: DE    = actual energy loss (Gev)                      *
C.    *                 ( NOT the fluctuation DE/DX-<DE/DX> !)         *
C.    *                                                                *
C.    *     ==> Called by : GTELEC,GTHADR,GTMUON                       *
C.    *                                                                *
C.    *  Author      : L.Urban                                         *
C.    *  Date        : 28.04.1988       Last update :  1.02.90         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCCUTS.
      PARAMETER (MAXRND=100)
      DIMENSION RNDM(MAXRND),APOIS(3),NPOIS(3),FPOIS(3)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION E1,E2,P2,B2,BG2,TM,DEC,W,WW,WWW,RR
      DOUBLE PRECISION X,AK,ALFA,EA,SA,AKL,REALK,FPOIS
      DOUBLE PRECISION ONE,HALF,ZERO
      PARAMETER (HMXINT=2**30)
+SELF, IF=SINGLE.
      PARAMETER (HMXINT=2**45)
+SELF.
      PARAMETER (ONE=1,HALF=ONE/2,ZERO=0)
      PARAMETER (RCD=0.40, RCD1=1.-RCD, PROBLM=0.01)
      PARAMETER( C1=4, C2=16)
*
*     ------------------------------------------------------------------
*
*     POTI=1.6E-8*Z**0.9
*     POTIL=LOG(POTI)
*
      IF(Z.GT.2.) THEN
         F2=2./Z
      ELSE
         F2=0.
      ENDIF
      F1=1.-F2
*
      E2 = 1.E-8*Z*Z
      E2L= LOG(E2)
      E1L= (POTIL-F2*E2L)/F1
      E1 = EXP(E1L)
*
*
      P2=P*P
      B2=P2/(E*E)
      BG2=P2/(AMASS*AMASS)
      IF(ITRTYP.EQ.2) THEN
         TM=P2/(E+EMASS)
         IF(CHARGE.LT.0.) TM=TM/2.
         TM=TM-POTI
         IF(TM.GT.DCUTE) TM=DCUTE
      ELSE
         TM=EMASS*P2/(0.5*AMASS*AMASS+EMASS*E)
         TM=TM-POTI
         IF(TM.GT.DCUTM) TM=DCUTM
      ENDIF
*
*
* *** Protection against negative TM    ---------------------
*     TM can be negative only for heavy particles with  a very
*     low kinetic energy (e.g. for proton with T  100-300 kev)
      TM=MAX(TM,ZERO)
*
      W  = TM+POTI
      WW = W/POTI
      WWW= 2.*EMASS*BG2
      WL = LOG(WWW)
      CSB=STEP*RCD1*DEDX/(WL-POTIL-B2)
      APOIS(1)=CSB*F1*(WL-E1L-B2)/E1
      APOIS(2)=CSB*F2*(WL-E2L-B2)/E2
*
      IF(TM.GT.0.) THEN
         APOIS(3)=RCD*DEDX*STEP*TM/(POTI*W*LOG(WW))
      ELSE
         APOIS(1)=APOIS(1)/RCD1
         APOIS(2)=APOIS(2)/RCD1
         APOIS(3)=0.
      ENDIF
*
*    calculate the probability of the zero energy loss
*
      APSUM=APOIS(1)+APOIS(2)+APOIS(3)
      IF(APSUM.LT.0.) THEN
         PROB=1.
      ELSEIF(APSUM.LT.50.) THEN
         PROB=EXP(-APSUM)
      ELSE
         PROB=0.
      ENDIF
*
*
*      do it differently if prob > problm  <====================
      IF(PROB.GT.PROBLM) THEN
         E0=1.E-8
         EMEAN=DEDX*STEP
         IF(TM.LE.0.) THEN
*      excitation only ....
            APOIS(1)=EMEAN/E0
*
            CALL GPOISS(APOIS,NPOIS,1)
            FPOIS(1)=NPOIS(1)
            DE=FPOIS(1)*E0
*
         ELSE
*         ionization only ....
            EM=TM+E0
            APOIS(1)=EMEAN*(EM-E0)/(EM*E0*LOG(EM/E0))
            CALL GPOISS(APOIS,NPOIS,1)
            NN=NPOIS(1)
            DE=0.
*
            IF(NN.GT.0) THEN
               RCORR=1.
               IF(NN.GT.MAXRND) THEN
                  RCORR=FLOAT(NN)/MAXRND
                  NN=MAXRND
*
               ENDIF
               W=(EM-E0)/EM
               CALL GRNDM(RNDM,NN)
               DO 10 I=1,NN
                  DE=DE+E0/(1.-W*RNDM(I))
   10          CONTINUE
               DE=RCORR*DE
*
            ENDIF
         ENDIF
         GOTO 999
      ENDIF
*
      IF(MAX(APOIS(1),APOIS(2),APOIS(3)).LT.HMXINT) THEN
         CALL GPOISS(APOIS,NPOIS,3)
         FPOIS(1)=NPOIS(1)
         FPOIS(2)=NPOIS(2)
         FPOIS(3)=NPOIS(3)
      ELSE
         DO 20 JPOIS=1, 3
            IF(APOIS(JPOIS).LT.HMXINT) THEN
               CALL GPOISS(APOIS(JPOIS),NPOIS(JPOIS),1)
               FPOIS(JPOIS)=NPOIS(JPOIS)
            ELSE
               CALL GRNDM(RNDM,2)
               FPOIS(JPOIS)=ABS(SQRT(-2.*LOG(RNDM(1)*ONE)
     +         *APOIS(JPOIS))*SIN(TWOPI*RNDM(2)*ONE)+APOIS(JPOIS))
            ENDIF
   20    CONTINUE
      ENDIF

*
*          Now we have all three numbers in REAL/DOUBLE
*          variables. REALK is actually an INTEGER that now may
*          exceed the machine representation limit for integers.
*
      DE=FPOIS(1)*E1+FPOIS(2)*E2
*
*     smear to avoid peaks in the energy loss (note: E1<<E2)
*
      IF(DE.GT.0.) THEN
         CALL GRNDM(RNDM,1)
         DE=DE+E1*(1.-2.*RNDM(1))
      ENDIF
*
      ALFA=1.
      REALK=0
      DEC=0.
*
      ANC=FPOIS(3)
      IF(ANC.GE.C2) THEN
         R=ANC/(C2+ANC)
         AN=ANC*R
         SN=C1*R
         CALL GRNDM(RNDM,2)
         RR=SQRT(-2.*LOG(RNDM(1)))
         PHI=TWOPI*RNDM(2)
         X=RR*COS(PHI)
         AK=AN+SN*X
         ALFA=WW*(C2+ANC)/(C2*WW+ANC)
         EA=AK*POTI*ALFA*LOG(ALFA)/(ALFA-1.)
         SA=SQRT(ABS(AK*ALFA*POTI*POTI-EA*EA/AK))
         AKL=(EA-C1*SA)/POTI
         IF(AK.LE.AKL) THEN
            X=RR*SIN(PHI)
            DEC=EA+SA*X
            REALK=AK+HALF-MOD(AK+HALF,ONE)
         ELSE
            ALFA=1.
         ENDIF
      ENDIF
      NN=NINT(FPOIS(3)-REALK)
      IF(NN.GT.MAXRND) THEN
         W=1.-ALFA/WW
         WW=POTI*ALFA
*
*     Here we take a gaussian distribution to avoid loosing
*     too much time in computing
*
         AVERAG=-LOG(1.-W)/W
         SIGMA =SQRT(NN*(1./(1.-W)-AVERAG**2))
         CALL GRNDM(RNDM,2)
         DEC   = DEC+WW*(NN*AVERAG+SIGMA*SQRT(-2.*LOG(RNDM(1)))*
     +           SIN(TWOPI*RNDM(2)))
         DE=DE+DEC
      ELSEIF(NN.GT.0) THEN
         W=1.-ALFA/WW
         WW=POTI*ALFA
         CALL GRNDM(RNDM,NN)
         DO 30 I=1,NN
            DEC=DEC+WW/(1.-W*RNDM(I))
   30    CONTINUE
         DE=DE+DEC
      ENDIF
*
  999 END
+DECK,  GLISUR, T=FORT.
*PATCH,GEXAM1.
*CMZ :  3.21/02 29/03/94  15.41.35  by  S.Giani
*DECK,GLISUR
*CMZ :          12/09/95  11.22.49  by  S.Ravndal
*CMZ :  3.21/02 03/07/94  19.08.44  by  S.Giani
*-- Author :
      SUBROUTINE GLISUR(X0,X1,MEDI0,MEDI1,U,PDOTU,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  This routine simulates the surface profile of a boundary      *
C.    *  between two media as seen by an approaching particle with     *
C.    *  coordinates and direction given by X0. The surface is         *
C.    *  identified by the arguments MEDI0 and MEDI1 which are the     *
C.    *  media indices of the region in which the track is presently   *
C.    *  and the one which it approaches, respectively. The input      *
C.    *  vector X1 contains the coordinates of a point on the other    *
C.    *  side of the boundary from X0, and lying within medium MEDI1.  *
C.    *  The result is a unit vector U normal to the surface of        *
C.    *  reflection at X0 and pointing into the medium from which the  *
C.    *  track is approaching. The quality of the surface finish is    *
C.    *  described by the parameter POLISH, which varies from 0 to 1.  *
C.    *  POLISH=0 means maximum roughness, with effective plane of     *
C.    *  reflection distributed as cos(alpha), where alpha is the      *
C.    *  angle between the unit normal to the effective plane of       *
C.    *  reflection and the normal to the nominal medium boundary at   *
C.    *  X0. POLISH=1 means perfect smoothness. In between the surface *
C.    *  is modeled by a bell-shaped distribution in alpha, with       *
C.    *  limits defined by                                             *
C.    *              sin(alpha) = +/- (1-POLISH)                       *
C.    *  At the interface between two media, the surface POLISH        *
C.    *  parameter is taken from a user routine GUPLSH(MEDI0,MEDI1).   *
C.    *  The indices MEDI0 and MEDI1 refer to the media declared by    *
C.    *  the user. If GGPERP returns an error, there was a precision   *
C.    *  problem with the tracking, and point X0 is on the same side   *
C.    *  of the surface as X1. In this case (or any other error        *
C.    *  condition from GGPERP) a return is made with IERR ^=0. If     *
C.    *  IERR=0 on return then U contains a valid unit vector.         *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    F.Carminati, R.Jones ***********               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVOLU.
+CDE, GCVOL1.
C
      REAL X0(6),X1(3),U(3)
      REAL D(3),RNDM(3)

*
* *** Decide which volume defines the surface
      IF (NLEVEL.GE.NLEVL1) THEN
         LVOL = 1
      ELSE
         LVOL = -1
         DO 10 I=2,NLEVEL
            IF ((NAMES1(I).NE.NAMES(I)).OR. (NUMBR1(I).NE.NUMBER(I)))
     +      LVOL = 1
   10    CONTINUE
      END IF
*
* *** Find the nominal unit normal to the surface
      IF (LVOL.EQ.1) THEN
C
C Instead of X0, now X1 is used by GGPERP, in order to calculate
C the right perpendicular even near to a corner,
C see the modifactions in GTCKOV concerning VBOU
C
         CALL GGPERP(X1,U,IERR)
      ELSE
         LVOL = NLEVEL
         NLEVEL = NLEVL1
         CALL GGPERP(X1,U,IERR)
         U(1) = -U(1)
         U(2) = -U(2)
         U(3) = -U(3)
         NLEVEL = LVOL
      END IF
      IF (IERR.NE.0) GO TO 999
      PDOTU = X0(4)*U(1) + X0(5)*U(2) + X0(6)*U(3)
      POLISH=GUPLSH(MEDI0,MEDI1)
      IF (POLISH.LT.1.) THEN
*
* *** Generate distortion vector D within a uniform sphere
         DIAM = 2.*(1.-POLISH)
         DIA2 = DIAM**2
         IROUND = 0
   20    IF(IROUND.GT.5) GO TO 999
         IROUND = IROUND+1
         CALL GRNDM(RNDM,3)
         D(1) = RNDM(1)-0.5
         D(2) = RNDM(2)-0.5
         D(3) = RNDM(3)-0.5
         D2 = D(1)**2+D(2)**2+D(3)**2
         IF (D2.GT.0.25) GO TO 20
         D(1) = D(1)*DIAM
         D(2) = D(2)*DIAM
         D(3) = D(3)*DIAM
         D2 = D2*DIA2
*
* *** Insure that V=U+D will cause reflection away from surface
         PDOTD = X0(4)*D(1) + X0(5)*D(2) + X0(6)*D(3)
         PDOTV = PDOTU+PDOTD
         UDOTD = U(1)*D(1) + U(2)*D(2) + U(3)*D(3)
         V2 = 1+D2+2*UDOTD
         IF (PDOTD*V2+PDOTV*(1.-D2).GT.0.) GO TO 20
*
* *** Normalize V and call it U
         VABS = 1./SQRT(V2)
         U(1) = (U(1)+D(1))*VABS
         U(2) = (U(2)+D(2))*VABS
         U(3) = (U(3)+D(3))*VABS
         PDOTU = PDOTV*VABS
      END IF
  999 END
+DECK,  GLOREN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:26  cernlib
* Geant

      SUBROUTINE GLOREN(BETA,PA,PB)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Routine to transform momentum and energy from the        *
C     *       Lorentz frame A to the Lorentz frame B                   *
C     *                                                                *
C     *       PA(1)                                                    *
C     *       PA(2)     Momentum components in frame A                 *
C     *       PA(3)                                                    *
C     *       PA(4)     Energy                                         *
C     *       PB(..)   same quantities in frame B                      *
C     *                                                                *
C     *       BETA(1)    Components of velocity of frame B             *
C     *       BETA(2)        as seen from frame A                      *
C     *       BETA(3)                                                  *
C     *       BETA(4)    1./SQRT(1.-BETA**2)                           *
C.    *                                                                *
C.    *    ==>Called by : GDECAY,GDECA3                                *
C.    *       Author    M.Hansroul  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION BETA(4),PA(4),PB(4)
C.
C.    ------------------------------------------------------------------
C.
      BETPA  = BETA(1)*PA(1) + BETA(2)*PA(2) + BETA(3)*PA(3)
      BPGAM  = (BETPA * BETA(4)/(BETA(4) + 1.) - PA(4)) * BETA(4)
      PB(1) = PA(1) + BPGAM  * BETA(1)
      PB(2) = PA(2) + BPGAM  * BETA(2)
      PB(3) = PA(3) + BPGAM  * BETA(3)
      PB(4) =(PA(4) - BETPA) * BETA(4)
      END

+DECK,  GMCOUL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:26  cernlib
* Geant
*    NEW

      SUBROUTINE GMCOUL(OMEGA,DIN)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Generate NSCA single scatters in small angle approxima.  *
C.    *       for a particle with parameters VECT in common /GCTRAK/   *
C.    *                                                                *
C.    *       This subroutine must be called with the correct values   *
C.    *       of the constants OMC & CHC which depend of the medium    *
C.    *                                                                *
C.    *       OMC and CHC are computed at initialisation time (GMOLI)  *
C.    *       No lateral displacement of the particle with respect     *
C.    *       the incident direction is included.                      *
C.    *       No path length correction is included                    *
C.    *                                                                *
C.    *       Output angles overwrite VECT                             *
C.    *                                                                *
C.    *    ==>Called by : GMULTS                                       *
C.    *         Author G. Lynch (LBL)  (adapted by M. Maire  1.02.90)  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCMULO.
      PARAMETER (NSCMX = 50)
      DIMENSION DIN(3),RNDM(2*NSCMX)
      PARAMETER (OMCF=1.167)
*
*     ------------------------------------------------------------------
*
* *** Compute number of scatters (Poisson distr. with mean OMEGA0)
*
      OMEGA0 = OMCF*OMEGA
      CALL GPOISS (OMEGA0,NSCA,1)
      IF (NSCA.LE.0)THEN
         DIN(1) = 0.
         DIN(2) = 0.
         DIN(3) = 1.
         RETURN
      ENDIF
      NSCA = MIN(NSCA,NSCMX)
      CALL GRNDM (RNDM,2*NSCA)
*
* *** THMIN2 is the screening angle
      THMIN2 = (CHCMOL**2)/(OMCF*OMCMOL*(VECT(7)**2))
*
      SUMX = 0.
      SUMY = 0.
      DO 12 I=1,NSCA
         THET  = SQRT(THMIN2*((1./RNDM(I)) - 1.))
         PHI   = TWOPI*RNDM(NSCA+I)
         SUMX  = SUMX + THET*COS(PHI)
         SUMY  = SUMY + THET*SIN(PHI)
   12 CONTINUE
      THETA  = SQRT(SUMX**2 + SUMY**2)
      IF(THETA.NE.0.) THEN
      COSTH  = COS(THETA)
      SINTH  = SIN(THETA)
      CSPHI  = SUMX/THETA
      SNPHI  = SUMY/THETA
*
      DIN(1) = SINTH*CSPHI
      DIN(2) = SINTH*SNPHI
      DIN(3) = COSTH
      ELSE
         DIN(1) = 0.
         DIN(2) = 0.
         DIN(3) = 1.
      ENDIF
*
      END
+DECK,  GMGAUS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:26  cernlib
* Geant
*    EX GMUL

      SUBROUTINE GMGAUS(BETA2,DIN)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Compute multiple scattering angles for a particle        *
C.    *       with parameters VECT in common /GCTRAK/                  *
C.    *       in current medium described in common /GCMATE/           *
C.    *       Output angles overwrite VECT                             *
C.    *                                                                *
C.    *    ==>Called by : GMULTS                                       *
C.    *       Authors    R.Brun, M.Maire, G.Lynch  *********           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCTRAK.
+CDE, GCPHYS.
+CDE, GCMULO.
+CDE, GCONSP.
      DIMENSION DIN(3),RNDM(3)
*
*     ------------------------------------------------------------------
*
* *** Computes mean deviation angles in radian
*
*     Scattering corresponding to OMEGA0 = 4E4 scatters and F=0.98.
*
      SIGMA  = 2.557 * CHCMOL*SQRT(STMULS)/(GETOT*BETA2)
*
      CALL GRNDM(RNDM,3)
      PHI = TWOPI*RNDM(2)
      THETA  = SIGMA*SQRT(-2.*LOG(RNDM(1)))
      IF(RNDM(3).GT.0.5)THETA=-THETA
      SINT   = SIN(THETA)
      DIN(1) = SINT*SIN(PHI)
      DIN(2) = SINT*COS(PHI)
      DIN(3) = COS(THETA)
*
      END
+DECK,  GMOL4, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:26  cernlib
* Geant

      SUBROUTINE GMOL4(Y,X,VAL,ARG,EPS,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    * ROUTINE TAKEN FROM IBM SCIENTIFIC SUBROUTINE PACKAGE           *
C.    *                                                                *
C.    * 4 POINT CONTINUED FRACTION INTERPOLATION                       *
C.    * Y=INTERPOLATED VALUE FOR THE ARGUMENT X .                      *
C.    * VAL=VALUE ARRAY .                                              *
C.    * ARG=ARGUMENT ARRAY .                                           *
C.    * EPS=DESIRED ACCURACY .                                         *
C.    * OUTPUT ERROR PARAMETER IER = 0 ACCURACY O.K.                   *
C.    *                            = 1 ACCURACY CAN NOT BE TESTED      *
C.    *                                IN 4TH ORDER INTERPOLATION .    *
C.    *                            = 2 TWO IDENTICAL ELEMENTS IN THE   *
C.    *                                ARGUMENT ARRAY .                *
C.    *                                                                *
C.    *    ==>Called by : GMOLIE                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION ARG(4),VAL(4)
C.
C.    ------------------------------------------------------------------
C.
      IER=1
      Y=VAL(1)
      P2=1.
      P3=Y
      Q2=0.
      Q3=1.
      DO 16 I=2,4
         II=0
         P1=P2
         P2=P3
         Q1=Q2
         Q2=Q3
         Z=Y
         JEND=I-1
   3     AUX=VAL(I)
         DO 10 J=1,JEND
            H=VAL(I)-VAL(J)
            IF(ABS(H).GT.1.E-6*ABS(VAL(I)))GO TO 9
            IF(ARG(I).EQ.ARG(J))GO TO 17
            IF(J.LT.JEND)GO TO 8
            II=II+1
            III=I+II
            IF(III.GT.4)GO TO 19
            VAL(I)=VAL(III)
            VAL(III)=AUX
            AUX=ARG(I)
            ARG(I)=ARG(III)
            ARG(III)=AUX
            GO TO 3
   8        VAL(I)=1.E36
            GO TO 10
   9        VAL(I)=(ARG(I)-ARG(J))/H
  10     CONTINUE
         P3=VAL(I)*P2+(X-ARG(I-1))*P1
         Q3=VAL(I)*Q2+(X-ARG(I-1))*Q1
         IF(Q3.NE.0.)THEN
            Y=P3/Q3
         ELSE
            Y=1.E36
         ENDIF
         DELT=ABS(Z-Y)
         IF(DELT.LE.EPS)GO TO 19
  16  CONTINUE
      RETURN
  17  IER=2
      RETURN
  19  IER=0
      END
+DECK,  GMOLI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:27  cernlib
* Geant

      SUBROUTINE GMOLI (AC,ZC,WMAT,NLM,DENS,OMC,CHC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering.                                                *
C.    *                                                                *
C.    * WMAT=proportion by weight of NLM  individual constituents of   *
C.    *      charge ZC and atomic weight AC for the mixture/compound   *
C.    * DENS=density in gm/cm**3                                       *
C.    * Warning : the beta and charge dependance of ZX is omitted      *
C.    *                                                                *
C.    *    ==>Called by : GPROBI                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DIMENSION WMAT(*),AC(*),ZC(*)
      PARAMETER (ZETA=1)
*
*     ------------------------------------------------------------------
*
      ZS=0.
      ZE=0.
      ZX=0.
      DO 15 I=1,NLM
         TMP=(WMAT(I)/AC(I))*ZC(I)*(ZC(I)+ZETA)
         ZS=ZS+TMP
         ZE=ZE-0.66666*TMP*LOG(ZC(I))
         ZX=ZX+TMP*LOG(1.+3.34*(ZC(I)/137.036)**2)
15    CONTINUE
      CHC=0.39612E-3*SQRT(DENS*ZS)
      OMC=6702.33*ZS*DENS*EXP((ZE-ZX)/ZS)
*
      END
+DECK,  GMOLI1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:27  cernlib
* Geant

+SELF, IF=VER314.
      SUBROUTINE GMOLI1(AC,ZC,DENS,BETA2,OMC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering (case of a simple material)                     *
C.    *                                                                *
C.    *    ==>Called by : GMULOF                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DATA ZETA / 1. /
*
*     ------------------------------------------------------------------
*
      ZS=(1./AC)*ZC*(ZC+ZETA)
      ZE=-0.66666*ZS*LOG(ZC)
      ZX=ZS*LOG(1.+3.34*(ZC/(BETA2*137.036))**2)
      OMC=6702.33*ZS*DENS*EXP((ZE-ZX)/ZS)
*
      END
+SELF.
+DECK,  GMOLI2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:27  cernlib
* Geant

+SELF, IF=VER314.
      SUBROUTINE GMOLI2(AC,ZC,WMAT,NLM,DENS,BETA2,OMC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering.                                                *
C.    *                                                                *
C.    * WMAT=proportion by weight of NLM  individual constituents of   *
C.    *      charge ZC and atomic weight AC for the mixture/compound   *
C.    * DENS=density in gm/cm**3                                       *
C.    *                                                                *
C.    *    ==>Called by : GMULOF                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DIMENSION WMAT(1),AC(1),ZC(1)
      DATA ZETA / 1. /
*
*     ------------------------------------------------------------------
*
      ZS=0.
      ZE=0.
      ZX=0.
      DO 15 I=1,NLM
         TMP=(WMAT(I)/AC(I))*ZC(I)*(ZC(I)+ZETA)
         ZS=ZS+TMP
         ZE=ZE-0.66666*TMP*LOG(ZC(I))
         ZX=ZX+TMP*LOG(1.+3.34*(ZC(I)/(BETA2*137.036))**2)
15    CONTINUE
      OMC=6702.33*ZS*DENS*EXP((ZE-ZX)/ZS)
*
      END

+SELF.
+DECK,  GMOLIE, T=FORT.
* Revision 1.2  1996/05/02 08:17:11  ravndal
* correct spheric coordinate sampling
* Revision 1.1.1.1  1995/10/24 10:21:27  cernlib
* Geant
*    EX GMOL

      SUBROUTINE GMOLIE(OMEGA,BETA2,DIN)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Computes MOLIERE multiple scattering for a particle      *
C.    *       with parameters VECT in common /GCTRAK/                  *
C.    *                                                                *
C.    *       This subroutine must be called with the correct values   *
C.    *       of the constants OMC & CHC which depend of the medium    *
C.    *                                                                *
C.    *       OMC AND CHC are computed at initialisation time (GMOLI)  *
C.    *       No lateral displacement of the particle with respect     *
C.    *       the incident direction is included.                      *
C.    *       No path length correction is included                    *
C.    *                                                                *
C.    *  Generation of multiple scattering according to                *
C.    *  Moliere theory corrected for finite angle scattering          *
C.    *                                                                *
C.    *  evolved from Cern library program MLR                         *
C.    *                                                                *
C.    *  OMEGA & CHIC are number of scatterings and critical angle     *
C.    *  of the medium for a given incident particle                   *
C.    *                                                                *
C.    *  COSTH and SINTH are the cosine and sine of the generated      *
C.    *  scattering angle between 0 and 180 degrees                    *
C.    *                                                                *
C.    * THRED(NA)=reduced angles of Moliere theory                     *
C.    *                                                                *
C.    * F0I(NA),F1I(NA),F2I(NA)= integrale of Moliere functions        *
C.    *                                                                *
C.    *  4 point continued fraction interpolation is used to invert    *
C.    *  the total distribution function integral                      *
C.    *                                                                *
C.    * XINT= argument value                                           *
C.    * ARG= argument values of the table (arg,val)                    *
C.    * VAL= function values of the table (arg,val)                    *
C.    * THRI= the resulting interpolated function value                *
C.    *                                                                *
C.    *    ==>Called by : GMOLIE                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCTRAK.
+CDE, GCPHYS.
+CDE, GCMULO.
+CDE, GCONSP.
      PARAMETER (ENEPER = 2.7182818)
      DIMENSION DIN(3),RNDM(3)
      DIMENSION TINT(40),ARG(4),VAL(4),THRED(40),F0I(40),F1I(40),F2I(40)
      DATA THRED/
     +   0.00, 0.10, 0.20, 0.30
     +,  0.40, 0.50, 0.60, 0.70
     +,  0.80, 0.90, 1.00, 1.10
     +,  1.20, 1.30, 1.40, 1.50
     +,  1.60, 1.70, 1.80, 1.90
     +,  2.00, 2.20, 2.40, 2.60
     +,  2.80, 3.00, 3.20, 3.40
     +,  3.60, 3.80, 4.00, 5.00
     +,  6.00, 7.00, 8.00, 9.00
     +, 10.00,11.00,12.00,13.00/
      DATA F0I/
     +  0.000000E+00 ,0.995016E-02 ,0.392106E-01 ,0.860688E-01
     + ,0.147856E+00 ,0.221199E+00 ,0.302324E+00 ,0.387374E+00
     + ,0.472708E+00 ,0.555142E+00 ,0.632121E+00 ,0.701803E+00
     + ,0.763072E+00 ,0.815480E+00 ,0.859142E+00 ,0.894601E+00
     + ,0.922695E+00 ,0.944424E+00 ,0.960836E+00 ,0.972948E+00
     + ,0.981684E+00 ,0.992093E+00 ,0.996849E+00 ,0.998841E+00
     + ,0.999606E+00 ,0.999877E+00 ,0.999964E+00 ,0.999990E+00
     + ,0.999998E+00 ,0.999999E+00 ,0.100000E+01 ,0.100000E+01
     + ,0.100000E+01 ,0.100000E+01 ,0.100000E+01 ,0.100000E+01
     + ,1.,1.,1.,1./
      DATA F1I/
     +  0.000000E+00,0.414985E-02,0.154894E-01,0.310312E-01
     + ,0.464438E-01,0.569008E-01,0.580763E-01,0.468264E-01
     + ,0.217924E-01,-0.163419E-01,-0.651205E-01,-0.120503E+00
     + ,-0.178272E+00,-0.233580E+00,-0.282442E+00,-0.321901E+00
     + ,-0.350115E+00,-0.366534E+00,-0.371831E+00,-0.367378E+00
     + ,-0.354994E+00,-0.314803E+00,-0.266539E+00,-0.220551E+00
     + ,-0.181546E+00,-0.150427E+00,-0.126404E+00,-0.107830E+00
     + ,-0.933106E-01,-0.817375E-01,-0.723389E-01,-0.436650E-01
     + ,-0.294700E-01,-0.212940E-01,-0.161406E-01,-0.126604E-01
     + ,-0.102042E-01,-0.840465E-02,-0.704261E-02,-0.598886E-02/
      DATA F2I/
     +  0.0,0.121500E-01,0.454999E-01,0.913000E-01
     + ,0.137300E+00,0.171400E+00,0.183900E+00,0.170300E+00
     + ,0.132200E+00,0.763000E-01,0.126500E-01,-0.473500E-01
     + ,-0.936000E-01,-0.119750E+00,-0.123450E+00,-0.106300E+00
     + ,-0.732800E-01,-0.312400E-01,0.128450E-01,0.528800E-01
     + ,0.844100E-01,0.114710E+00,0.106200E+00,0.765830E-01
     + ,0.435800E-01,0.173950E-01,0.695001E-03,-0.809500E-02
     + ,-0.117355E-01,-0.125449E-01,-0.120280E-01,-0.686530E-02
     + ,-0.385275E-02,-0.231115E-02,-0.147056E-02,-0.982480E-03
     + ,-0.682440E-03,-0.489715E-03,-0.361190E-03,-0.272582E-03/
*
*     ------------------------------------------------------------------
*
*
* *** Compute Theta angle from Moliere distribution
*
      CHIC  = CHCMOL*SQRT(STMULS)/(GETOT*BETA2)
      COSTH=1.
      SINTH=0.
      IF(OMEGA.LE.ENEPER)GO TO 90
      CNST=LOG(OMEGA)
      B=5.
      DO 10 L=1,10
         IF(ABS(B).LT.1.E-10)THEN
            B=1.E-10
         ENDIF
         DB=-(B-LOG(ABS(B))-CNST)/(1.-1./B)
         B=B+DB
         IF(ABS(DB).LE.0.0001)GO TO 20
   10 CONTINUE
      GO TO 90
   20 CONTINUE
      IF(B.LE.0.)GO TO 90
      BINV = 1./B
      TINT(1) = 0.
      DO 30 JA=2,4
         TINT(JA)=F0I(JA)+(F1I(JA)+F2I(JA)*BINV)*BINV
   30 CONTINUE
      NMAX = 4
   40 CONTINUE
      CALL GRNDM(RNDM,3)
      XINT=RNDM(2)
      DO 50 NA=3,40
         IF(NA.GT.NMAX) THEN
            TINT(NA)=F0I(NA)+(F1I(NA)+F2I(NA)*BINV)*BINV
            NMAX=NA
         ENDIF
         IF(XINT.LE.TINT(NA-1)) GO TO 60
   50 CONTINUE
      IF(XINT.LE.TINT(40)) THEN
         NA=40
         GOTO 60
      ELSE
         TMP=1.-(1.-B*(1.-XINT))**5
         IF(TMP.LE.0.)GO TO 40
         THRI=5./TMP
         GO TO 80
      ENDIF
   60 CONTINUE
      NA = MAX(NA-1,3)
      NA3 = NA-3
      DO 70 M=1,4
         NA3M=NA3+M
         ARG(M)=TINT(NA3M)
         VAL(M)=THRED(NA3M)**2
   70 CONTINUE
      F=THRED(NA)*.02
      CALL GMOL4(THRI,XINT,VAL,ARG,F,IER)
   80 CONTINUE
      TH=CHIC*SQRT(ABS(B*THRI))
      IF(TH.GT.PI)GO TO 40
      SINTH=SIN(TH)
      TEST=TH*(RNDM(3))**2
      IF(TEST.GT.SINTH)GO TO 40
      COSTH=COS(TH)
      GOTO 100
   90 CONTINUE
      CALL GRNDM(RNDM,1)
*
* *** Calculate SINE and COSINE of a random angle between 0 and 360 deg
*
  100 PHI = RNDM(1)*TWOPI
*
      DIN(1) = SINTH*COS(PHI)
      DIN(2) = SINTH*SIN(PHI)
      DIN(3) = COSTH
*
      END
+DECK,  GMOLIO, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:27  cernlib
* Geant

      SUBROUTINE GMOLIO(AC,ZC,WMAT,NLM,DENS,BETA2,CHARG2,OMC)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Initializes material constants OMC,CHC for Moliere         *
C.    *     scattering.                                                *
C.    *                                                                *
C.    * WMAT=proportion by weight of NLM  individual constituents of   *
C.    *      charge ZC and atomic weight AC for the mixture/compound   *
C.    * DENS=density in gm/cm**3                                       *
C.    *                                                                *
C.    *    ==>Called by : GMULOF                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
C     ZETA=factor for scattering by atomic electrons
C
      DIMENSION WMAT(*),AC(*),ZC(*)
      PARAMETER (ZETA=1.)
*
* *** This is equal to 3.34/137.036**2
*
      PARAMETER (CONST1 = 1.778595E-4)
*
*     ------------------------------------------------------------------
*
      ZS     = 0.
      ZE     = 0.
      ZX     = 0.
      CONST  = CONST1*CHARG2/BETA2
      DO 10 I=1,NLM
         TMP   = (WMAT(I)/AC(I))*ZC(I)*(ZC(I)+ZETA)
         ZS    = ZS+TMP
         ZE    = ZE-0.66666*TMP*LOG(ZC(I))
         ZX    = ZX+TMP*LOG(1.+CONST*ZC(I)**2)
  10  CONTINUE
      OMC    = 6702.33*ZS*DENS*EXP((ZE-ZX)/ZS) * CHARG2
*
      END

+DECK,  GMOLS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:27  cernlib
* Geant

+SELF, IF=VER314.
      SUBROUTINE GMOLS (OMEGA,CHIC,COSTH,SINTH)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generation of multiple scattering according to                *
C.    *  Moliere theory corrected for finite angle scattering          *
C.    *                                                                *
C.    *  evolved from Cern library program MLR                         *
C.    *                                                                *
C.    *  OMEGA & CHIC are number of scatterings and critical angle     *
C.    *  of the medium for a given incident particle                   *
C.    *                                                                *
C.    *  COSTH and SINTH are the cosine and sine of the generated      *
C.    *  scattering angle between 0 and 180 degrees                    *
C.    *                                                                *
C.    * THRED(NA)=reduced angles of Moliere theory                     *
C.    *                                                                *
C.    * F0I(NA),F1I(NA),F2I(NA)= integrale of Moliere functions        *
C.    *                                                                *
C.    *  4 point continued fraction interpolation is used to invert    *
C.    *  the total distribution function integral                      *
C.    *                                                                *
C.    * XINT= argument value                                           *
C.    * ARG= argument values of the table (arg,val)                    *
C.    * VAL= function values of the table (arg,val)                    *
C.    * THRI= the resulting interpolated function value                *
C.    *                                                                *
C.    *    ==>Called by : GMOLIE                                       *
C.    *         Author M.S. Dixit NRCC Ottawa    *********             *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION TINT(40),ARG(4),VAL(4),THRED(40),F0I(40),F1I(40),F2I(40)
      DIMENSION RNDM(1)
      SAVE TINT
      DATA TINT(1)/0./
      DATA THRED/
     *   0.00, 0.10, 0.20, 0.30
     *,  0.40, 0.50, 0.60, 0.70
     *,  0.80, 0.90, 1.00, 1.10
     *,  1.20, 1.30, 1.40, 1.50
     *,  1.60, 1.70, 1.80, 1.90
     *,  2.00, 2.20, 2.40, 2.60
     *,  2.80, 3.00, 3.20, 3.40
     *,  3.60, 3.80, 4.00, 5.00
     *,  6.00, 7.00, 8.00, 9.00
     *, 10.00,11.00,12.00,13.00/
      DATA F0I/
     *  0.000000E+00 ,0.995016E-02 ,0.392106E-01 ,0.860688E-01
     * ,0.147856E+00 ,0.221199E+00 ,0.302324E+00 ,0.387374E+00
     * ,0.472708E+00 ,0.555142E+00 ,0.632121E+00 ,0.701803E+00
     * ,0.763072E+00 ,0.815480E+00 ,0.859142E+00 ,0.894601E+00
     * ,0.922695E+00 ,0.944424E+00 ,0.960836E+00 ,0.972948E+00
     * ,0.981684E+00 ,0.992093E+00 ,0.996849E+00 ,0.998841E+00
     * ,0.999606E+00 ,0.999877E+00 ,0.999964E+00 ,0.999990E+00
     * ,0.999998E+00 ,0.999999E+00 ,0.100000E+01 ,0.100000E+01
     * ,0.100000E+01 ,0.100000E+01 ,0.100000E+01 ,0.100000E+01
     * ,1.,1.,1.,1./
      DATA F1I/
     *  0.000000E+00,0.414985E-02,0.154894E-01,0.310312E-01
     * ,0.464438E-01,0.569008E-01,0.580763E-01,0.468264E-01
     * ,0.217924E-01,-0.163419E-01,-0.651205E-01,-0.120503E+00
     * ,-0.178272E+00,-0.233580E+00,-0.282442E+00,-0.321901E+00
     * ,-0.350115E+00,-0.366534E+00,-0.371831E+00,-0.367378E+00
     * ,-0.354994E+00,-0.314803E+00,-0.266539E+00,-0.220551E+00
     * ,-0.181546E+00,-0.150427E+00,-0.126404E+00,-0.107830E+00
     * ,-0.933106E-01,-0.817375E-01,-0.723389E-01,-0.436650E-01
     * ,-0.294700E-01,-0.212940E-01,-0.161406E-01,-0.126604E-01
     * ,-0.102042E-01,-0.840465E-02,-0.704261E-02,-0.598886E-02/
      DATA F2I/
     *  0.0,0.121500E-01,0.454999E-01,0.913000E-01
     * ,0.137300E+00,0.171400E+00,0.183900E+00,0.170300E+00
     * ,0.132200E+00,0.763000E-01,0.126500E-01,-0.473500E-01
     * ,-0.936000E-01,-0.119750E+00,-0.123450E+00,-0.106300E+00
     * ,-0.732800E-01,-0.312400E-01,0.128450E-01,0.528800E-01
     * ,0.844100E-01,0.114710E+00,0.106200E+00,0.765830E-01
     * ,0.435800E-01,0.173950E-01,0.695001E-03,-0.809500E-02
     * ,-0.117355E-01,-0.125449E-01,-0.120280E-01,-0.686530E-02
     * ,-0.385275E-02,-0.231115E-02,-0.147056E-02,-0.982480E-03
     * ,-0.682440E-03,-0.489715E-03,-0.361190E-03,-0.272582E-03/
*
*     ------------------------------------------------------------------
*
      CNST=LOG(OMEGA)
      IF(CNST.LE.1.)GO TO 190
      B=5.
      DO 20 L=1,10
         IF(ABS(B).LT.1.E-10)THEN
            B=1.E-10
         ENDIF
         DB=-(B-LOG(ABS(B))-CNST)/(1.-1./B)
         B=B+DB
         IF(ABS(DB).LE.0.0001)GO TO 30
  20  CONTINUE
      GO TO 190
  30  CONTINUE
      IF(B.LE.0.)GO TO 190
      BSQ=B*B
  31  CONTINUE
      CALL GRNDM(RNDM,1)
      XINT=RNDM(1)
      DO 50 NA=2,40
         TINT(NA)=F0I(NA)+F1I(NA)/B+F2I(NA)/BSQ
         S=XINT-TINT(NA)
         IF(S.LE.0.)GO TO 60
  50  CONTINUE
      GO TO 180
  60  CONTINUE
      IF(NA.GE.40)THEN
         NA=39
      ELSE
         TINT(NA+1)=F0I(NA+1)+F1I(NA+1)/B+F2I(NA+1)/BSQ
      ENDIF
      IF(NA.LE.2)THEN
         NA=3
         TINT(4)=F0I(4)+F1I(4)/B+F2I(4)/BSQ
      ENDIF
      NA3=NA-3
      DO 70 M=1,4
         NA3M=NA3+M
         ARG(M)=TINT(NA3M)
         VAL(M)=THRED(NA3M)**2
   70 CONTINUE
      F=THRED(NA)/50.
      CALL GMOL4(THRI,XINT,VAL,ARG,F,IER)
 200  CONTINUE
      TH=CHIC*SQRT(ABS(B*THRI))
      IF(TH.GT.3.141593)GO TO 31
      SINTH=SIN(TH)
      CALL GRNDM(RNDM,1)
      TEST=TH*(RNDM(1))**2
      IF(TEST.GT.SINTH)GO TO 31
      COSTH=COS(TH)
      RETURN
 180  CONTINUE
      TMP=1.-(1.-B*(1.-XINT))**5
      IF(TMP.LE.0.)GO TO 31
      THRI=5./TMP
      GO TO 200
 190  CONTINUE
      COSTH=1.
      SINTH=0.
*
      END
+SELF.
+DECK,  GMULOF, T=FORT.

      SUBROUTINE GMULOF
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates table of steps for multiple scattering             *
C.    *     energy loss and magnetic field for electrons,muons         *
C.    *           (cannot be tabuled for hadrons)                      *
C.    *   : smuls  = min (Tbethe , 10*radl)                            *
C.    *   : sloss  = DEEMAX*GEKIN/DEDX                                 *
C.    *   : sfield = CFLD*P                                            *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, Y.Dufour, M.Maire  *********          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCMULO.
+CDE, GCKINE.
+CDE, GCMATE.
+CDE, GCTRAK.
+CDE, GCKING.
+CDE, GCTMED.
+CDE, GCCUTS.
+CDE, GCPHYS.
*
      LOGICAL CERKOV
*
*-----------------------------------------------------------------------
*
      SMULS  = BIG
      SLOSS  = BIG
      SFIELD = BIG
      STOPMX = BIG
      STCKOV = BIG
      JPROB  = LQ(JMA-4)
      JMIXT  = LQ(JMA-5)
      OMC    = Q(JPROB+21)
      CHC2   = Q(JPROB+25)**2
      NLMAT=Q(JMA+11)
      NLM=IABS(NLMAT)
      IF (FIELDM.NE.0.) CFLD = 3333.*DEGRAD*TMAXFD/ABS(FIELDM)
*
      IF(ITCKOV.NE.0.AND.IQ(JTM-2).GE.3.AND. LQ(JTM-3)
     +.NE.0.AND.LQ(LQ(JTM-3)-3).NE.0) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag and calculate the
* ***  relevant pointers.
*
         CERKOV = .TRUE.
         JTCKOV = LQ(JTM-3)
         JABSCO = LQ(JTCKOV-1)
         JEFFIC = LQ(JTCKOV-2)
         JINDEX = LQ(JTCKOV-3)
         JCURIN = LQ(JTCKOV-4)
         NPCKOV = Q(JTCKOV+1)
      ELSE
         CERKOV = .FALSE.
      ENDIF
*
* *** Electrons
*
      JRANG = LQ(JMA-15)
      IKCUT = MAX((GEKA*LOG10(CUTELE) + GEKB),1.)
      GKC   = (CUTELE-ELOW(IKCUT))/(ELOW(IKCUT+1)-ELOW(IKCUT))
      STOPC = (1.-GKC)*Q(JRANG+IKCUT) + GKC*Q(JRANG+IKCUT+1)
      JMULOF = LQ(JTM-1)
      Q(JMULOF+NEK1+1) = IKCUT
      Q(JMULOF+NEK1+2) = STOPC
*
* *** Recompute STMIN ?
*     set STMIN to the range of an electron at energy=CUTELE + 200KeV
*     divided by sqrt(RADL) (important for light materials)
*
      IF(STMIN.LT.0.)THEN
         XES=CUTELE+2.E-4
         IKS = MAX((GEKA*LOG10(XES) + GEKB),1.)
         GKS   = (XES-ELOW(IKS))/(ELOW(IKS+1)-ELOW(IKS))
         STMIN = (1.-GKS)*Q(JRANG+IKS) + GKS*Q(JRANG+IKS+1) - STOPC
         IF(Q(JTM+7).EQ.0.)THEN
            STMIN = 2.*STMIN/SQRT(RADL)
         ELSE
            STMIN = 5.*STMIN/RADL
         ENDIF
      ENDIF
      Q(JTM+14)=STMIN
*
      DO 10 IEKBIN=1,NEK1
         GEKIN = ELOW(IEKBIN)
         GETOT = GEKIN + EMASS
         PMOM2 = GEKIN*(GETOT+EMASS)
         PMOM  = SQRT(PMOM2)
         BETA2 = PMOM2/(GETOT**2)
*
         IF (IMULS.GT.0.) THEN
            IF(JMIXT.LE.0)THEN
               CALL GMOLIO(A,Z,1.,1,DENS,BETA2,1.,OMC)
            ELSE
               CALL GMOLIO(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +                    NLM,DENS,BETA2,1.,OMC)
            ENDIF
            PMCH2  = PMOM2/CHC2
            TBETHE = (PMCH2*BETA2)/LOG(OMC*PMCH2)
            TMXCOR = 2232.*RADL*PMOM2*BETA2
            SMULS  = MIN(TBETHE,TMXCOR,10.*RADL)
         ENDIF
*
         IF (IFIELD*FIELDM.NE.0.) THEN
            SFIELD = CFLD*PMOM
         ENDIF
*
         IF (ILOSS*DEEMAX.GT.0.) THEN
            IF (IEKBIN.LE.IKCUT) THEN
               STOPMX = 0.
               SLOSS  = 0.
            ELSE
               STOPMX = Q(JRANG+IEKBIN)
               EKF = (1.-DEEMAX)*GEKIN
               IF (EKF.LE.ELOW(1)) EKF = ELOW(1)
               IKF = MAX((GEKA*LOG10(EKF) + GEKB),1.)
               GKR = (EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
               SLOSS = STOPMX-(1.-GKR)*Q(JRANG+IKF)-GKR*Q(JRANG+IKF+1)
               IF (SLOSS.LE.0.) SLOSS = 0.
               STOPMX = STOPMX-STOPC
               IF (STOPMX.LE.0.) STOPMX = 0.
            ENDIF
         ENDIF
         IF(CERKOV) THEN
            CHARGE = 1.
            VECT(7) = PMOM
            CALL GNCKOV
            STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         ENDIF
*
         STEP = MIN(SMULS,SLOSS,SFIELD,STCKOV)
         IF (STEP.LT.STMIN) THEN
            STEP = MIN(STMIN,STOPMX)
         ENDIF
         Q(JMULOF+IEKBIN) = STEP
   10 CONTINUE
      DO 20 I=1,IKCUT
         Q(JMULOF+I)=0.5*Q(JMULOF+IKCUT+1)
   20 CONTINUE
*
* *** Muons
*
      JRANG = LQ(JMA-16)
      IKCUT = GEKA*LOG10(CUTMUO) + GEKB
      GKC   = (CUTMUO-ELOW(IKCUT))/(ELOW(IKCUT+1)-ELOW(IKCUT))
      STOPC = (1.-GKC)*Q(JRANG+IKCUT) + GKC*Q(JRANG+IKCUT+1)
      JMULOF = LQ(JTM-2)
      Q(JMULOF+NEK1+1)=IKCUT
      Q(JMULOF+NEK1+2)=STOPC
*
      DO 30 IEKBIN=1,NEK1
         GEKIN = ELOW(IEKBIN)
         GETOT = GEKIN + EMMU
         PMOM2 = GEKIN*(GETOT+EMMU)
         PMOM  = SQRT(PMOM2)
         BETA2 = PMOM2/(GETOT**2)
*
         IF (IMULS.GT.0.) THEN
            IF(JMIXT.LE.0)THEN
               CALL GMOLIO(A,Z,1.,1,DENS,BETA2,1.,OMC)
            ELSE
               CALL GMOLIO(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +                    NLM,DENS,BETA2,1.,OMC)
            ENDIF
            PMCH2  = PMOM2/CHC2
            TBETHE = (PMCH2*BETA2)/LOG(OMC*PMCH2)
            TMXCOR = 2232.*RADL*PMOM2*BETA2
            SMULS  = MIN(TBETHE,TMXCOR,10.*RADL)
         ENDIF
*
         IF (IFIELD*FIELDM.NE.0.) THEN
            SFIELD = CFLD*PMOM
         ENDIF
*
         IF (ILOSS*DEEMAX.GT.0.) THEN
            IF (IEKBIN.LE.IKCUT) THEN
               STOPMX = 0.
               SLOSS  = 0.
            ELSE
               STOPMX = Q(JRANG+IEKBIN)
               EKF = (1.-DEEMAX)*GEKIN
               IF (EKF.LE.ELOW(1)) EKF = ELOW(1)
               IKF = GEKA*LOG10(EKF) + GEKB
               GKR = (EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
               SLOSS = STOPMX-(1.-GKR)*Q(JRANG+IKF)-GKR*Q(JRANG+IKF+1)
               IF (SLOSS.LE.0.) SLOSS = 0.
               STOPMX = STOPMX-STOPC
               IF (STOPMX.LE.0.) STOPMX = 0.
            ENDIF
         ENDIF
         IF(CERKOV) THEN
            CHARGE = 1.
            VECT(7) = PMOM
            CALL GNCKOV
            STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
         ENDIF
*
         STEP = MIN(SMULS,SLOSS,SFIELD,STCKOV)
         IF (STEP.LT.STMIN) THEN
            STEP = MIN(STMIN,STOPMX)
         ENDIF
         Q(JMULOF+IEKBIN) = STEP
   30 CONTINUE
      DO 40 I=1,IKCUT
         Q(JMULOF+I)=0.5*Q(JMULOF+IKCUT+1)
   40 CONTINUE
*
      END
+DECK,  GMULTS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:28  cernlib
* Geant

      SUBROUTINE GMULTS
C
C     ******************************************************************
C     *                                                                *
C     *       Steering routine for the multiple scattering.            *
C     *       select Moliere theory , Gaussian approximation           *
C     *       or single Coulomb scattering depending of their range    *
C     *       of validity.                                             *
C     *                                                                *
C     *    ==>Called by : GTELEC , GTHADR , GTMUON                     *
C.    *       Author     M.Maire  *********                            *
C     *                                                                *
C     ******************************************************************
*
      PARAMETER (THRMOL=50.,THRGAU=0.01)
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCTRAK.
+CDE, GCKINE.
+CDE, GCPHYS.
+CDE, GCMATE.
+CDE, GCMULO.
      DIMENSION DIN(3)
*
      BETA2 = (VECT(7)/GETOT)**2
      IF(BETA2.LE.0.) RETURN
      IF(IMULS.EQ.3) THEN
         CALL GMGAUS(BETA2,DIN)
*
      ELSE
         CHARG2=CHARGE**2
*
*     Here we decide whether we have to recalculate OMCMOL or not.
*     OMCMOL has been calculated in GMULOF according to a formula
*     which contains the term (1 + 3.34*(Alpha*z*Z/Beta)**2) where
*     z is the incident charge (CHARGE), setting Beta=1 and z=1.
*     We do not recalculate OMCMOL if:
*
*              3.34*(Z*Alpha)**2*((z/Beta)**2-1) << 1
*                   Z**2*(z**2-Beta**2)/Beta**2  << 3.34/Alpha**2 = 5500
*                   Z**2*(z**2-Beta**2)  <= 50.*Beta**2
*
*     We further multiply the first term for the number of elements
*     in the mixture because the approssimation is particularly bad
*     for mixtures so we make the condition more restrictive.
*     All this thanks to Gerry Lynch.
*
         IF(Z**2*(CHARG2-BETA2)*Q(JMA+11).GT.THRMOL*BETA2) THEN
            NLM=Q(JMA+11)
*
            IF(NLM.EQ.1)THEN
               CALL GMOLIO(A,Z,1.,1,DENS,BETA2,CHARG2,OMCMOL)
*
            ELSE
               CALL GMOLIO(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +         NLM,DENS,BETA2,CHARG2,OMCMOL)
*
            ENDIF
         ELSE
            JPROB = LQ(JMA-4)
            OMCMOL = Q(JPROB+21)*CHARG2
*
         ENDIF
*
         OMEGA = OMCMOL*STMULS/BETA2
*
         IF (OMEGA.LE.20.) THEN
            CALL GMCOUL(OMEGA,DIN)
*
         ELSE
            CALL GMOLIE(OMEGA,BETA2,DIN)
*
         ENDIF
      ENDIF
*
* *** Computes rotation matrix around particle direction
* *** Compute new direction cosines
*
      VMM = SQRT(VECT(4)*VECT(4)+VECT(5)*VECT(5))
      IF (VMM.NE.0.) THEN
         PD1=VECT(4)/VMM
         PD2=VECT(5)/VMM
         V4= PD1*VECT(6)*DIN(1) -PD2*DIN(2) +VECT(4)*DIN(3)
         V5= PD2*VECT(6)*DIN(1) +PD1*DIN(2) +VECT(5)*DIN(3)
         V6= -VMM*DIN(1) +VECT(6)*DIN(3)
      ELSE
         V4= DIN(1)
         V5= DIN(2)
         V6= DIN(3)*SIGN(1.,VECT(6))
      ENDIF
*
* *** Renormalize direction cosines
*
      VP = 1./SQRT(V4*V4+V5*V5+V6*V6)
      VECT(4) = V4*VP
      VECT(5) = V5*VP
      VECT(6) = V6*VP
*
      END
+DECK,  GPAIRG, T=FORT.
* Revision 1.5  1998/02/09 15:59:47  japost
*   Fixed a problem on AIX 4 xlf, caused by max(double,float).
* Revision 1.4  1998/02/06 16:46:57  japost
* Fix a wrong parenthesis.
* Revision 1.3  1998/02/06 16:22:24  japost
*   Protected a square root from a negative argument.
*   This root was added there in previous changes, and not deleted from its
* old position. In its old position it was protected from being negative, but in
* its new position it was not.
*   Deleted the same square root from its old position, as it was redundant.
* Revision 1.2  1996/03/13 12:03:24  ravndal
* Tranverse momentum conservation
* Revision 1.1.1.1  1995/10/24 10:21:28  cernlib
* Geant

+SELF, IF=HPUX.
$OPTIMIZE OFF
+SELF.
      SUBROUTINE GPAIRG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates e+e- pair production by photons.                    *
C.    *                                                                *
C.    *  The secondary electron energies are sampled using the         *
C.    *  Coulomb corrected BETHE-HEITLER cross-sections.For this the   *
C.    *   modified version of the random number techniques of          *
C.    *   BUTCHER and MESSEL (NUCL.PHYS,20(1960),15) are employed.     *
C.    *                                                                *
C.    *  NOTE :                                                        *
C.    *  (1) Effects due to the breakdown of the BORN approximation at *
C.    *      low energies are ignored.                                 *
C.    *  (2) The differential cross-section implicitly takes account   *
C.    *      of pair production in both nuclear and atomic electron    *
C.    *      fields. However, triplet production is not generated.     *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCTRAK.
+CDE, GCKING.
+CDE, GCPHYS.
+CDE, GCCUTS.
      DIMENSION NTYPEL(2)
      DIMENSION RNDM(2)
      LOGICAL ROTATE
      PARAMETER (ONE=1,ONETHR=ONE/3,EMAS2=2*EMASS)
C.
C.    ------------------------------------------------------------------
C.
C             If not enough energy : no pair production
C
      EGAM   = VECT(7)
      IF (EGAM.LT.EMAS2) GO TO 999
C
      KCASE  = NAMEC(6)
      IF(IPAIR.NE.1) THEN
         ISTOP  = 2
         NGKINE = 0
         DESTEP = DESTEP + EGAM
         VECT(7)= 0.
         GEKIN  = 0.
         GETOT  = 0.
         GO TO 999
      ENDIF
C
C             For low energy photons approximate the electron energy by
C             sampling from a uniform distribution in the interval
C             EMASS -> EGAM/2.
C
      IF (EGAM.LE.2.1E - 03)THEN
         CALL GRNDM(RNDM,1)
         EEL1   = EMASS + (RNDM(1)*(0.5*EGAM - EMASS))
         X=EEL1/EGAM
         GO TO 20
      ENDIF
C
      Z3=Q(JPROB+2)
      F=8.*Q(JPROB+3)
      IF(EGAM.GT.0.05) F=F+8.*Q(JPROB+4)
      X0=EMASS/EGAM
      DX=0.5-X0
      DMIN=544.*X0/Z3
      DMIN2=DMIN*DMIN
      IF(DMIN.LE.1.)THEN
         F10=42.392-7.796*DMIN+1.961*DMIN2-F
         F20=41.405-5.828*DMIN+0.8945*DMIN2-F
      ELSE
         F10=42.24-8.368*LOG(DMIN+0.952)-F
         F20=F10
      ENDIF
C
C             Calculate limit for screening variable,DELTA, to ensure
C             that screening rejection functions always remain
C             positive.
C
      DMAX=EXP((42.24-F)/8.368)-0.952
C
C             Differential cross-section factors which form
C             the coefficients of the screening functions.
C
      DSIG1=DX*DX*F10/3.
      DSIG2=0.5*F20
      BPAR   = DSIG1 / (DSIG1 + DSIG2)
C
C             Decide which screening rejection function to use and
C             sample the electron/photon fractional energy BR.
C
   10 CALL GRNDM(RNDM,2)
      IF(RNDM(1).LT.BPAR)THEN
         X=0.5-DX*RNDM(2)**ONETHR
         IREJ=1
      ELSE
         X=X0+DX*RNDM(2)
         IREJ   = 2
      ENDIF
C
C             Calculate DELTA ensuring positivity.
C
      D=0.25*DMIN/(X*(1.-X))
      IF(D.GE.DMAX) GOTO 10
      D2=D*D
C
C             Calculate F1 and F2 functions using approximations.
C             F10 and F20 are the F1 and F2 functions calculated for the
C             DELTA=DELTA minimum.
C
      IF(D.LE.1.)THEN
         F1=42.392-7.796*D+1.961*D2-F
         F2=41.405-5.828*D+0.8945*D2-F
      ELSE
         F1=42.24-8.368*LOG(D+0.952)-F
         F2=F1
      ENDIF
      IF(IREJ.NE.2)THEN
         SCREJ=F1/F10
      ELSE
         SCREJ=F2/F20
      ENDIF
C
C             Accept or reject on basis of random variate.
C
      CALL GRNDM(RNDM,1)
      IF(RNDM(1).GT.SCREJ) GOTO 10
      EEL1=X*EGAM
C
C             Successful sampling of first electron energy.
C
C             Select charges randomly.
C
   20 NTYPEL(1) = 2
      CALL GRNDM(RNDM,2)
      IF (RNDM(1).GT.0.5) NTYPEL(1) = 3
      NTYPEL(2) = 5 - NTYPEL(1)
C
C             Generate electron decay angles with respect to a Z-axis
C             defined along the parent photon.
C             PHI is generated isotropically and THETA is assigned
C             a universal angular distribution
C
      EMASS1 = EMASS
      THETA  = GBTETH(EEL1, EMASS1, X)*EMASS/EEL1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      PHI    = TWOPI*RNDM(2)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Rotate tracks into GEANT system
C
      CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
      NGKINE = 0
      TEL1 = EEL1 - EMASS
      PEL1 = SQRT(MAX((EEL1+REAL(EMASS))*TEL1,0.))
      IF(TEL1.GT.CUTELE) THEN
         NGKINE = NGKINE + 1
         GKIN(1,NGKINE) = PEL1 * SINTH * COSPHI
         GKIN(2,NGKINE) = PEL1 * SINTH * SINPHI
         GKIN(3,NGKINE) = PEL1 * COSTH
         GKIN(4,NGKINE) = EEL1
         GKIN(5,NGKINE) = NTYPEL(1)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL1
         IF(NTYPEL(1).EQ.2) CALL GANNI2
      ENDIF
C
C             Momentum vector of second electron. Recoil momentum of
C             target nucleus/electron ignored.
C
      EEL2=EGAM-EEL1
      TEL2=EEL2-EMASS
      IF(TEL2.GT.CUTELE) THEN
         PEL2 = SQRT((EEL2+EMASS)*TEL2)
         NGKINE = NGKINE + 1
         SINTH=SINTH*PEL1/PEL2
         COSTH=SQRT(MAX(0.,1.-SINTH**2))
         GKIN(1,NGKINE)=-PEL2*SINTH*COSPHI
         GKIN(2,NGKINE)=-PEL2*SINTH*SINPHI
         GKIN(3,NGKINE)=PEL2*COSTH
         GKIN(4,NGKINE)=EEL2
         GKIN(5,NGKINE) = NTYPEL(2)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL2
         IF(NTYPEL(2).EQ.2) CALL GANNI2
      ENDIF
      ISTOP = 1
      IF(NGKINE.EQ.0) ISTOP = 2
 999  END
+SELF, IF=HPUX.
$OPTIMIZE ON
+SELF.
+DECK,  GPAIRM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:28  cernlib
* Geant

      SUBROUTINE GPAIRM
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates direct pair production by muons                     *
C.    *                                                                *
C.    *    ==>Called by : GTMUON                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCTRAK.
+CDE, GCMATE.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCPHYS.
+CDE, GCCUTS.
      DIMENSION RNDM(2)
      LOGICAL ROTATE
C
C         CVM= 3*SQRT(e)*EMMU/4
C         EM6= 6*EMMU**2
      DATA CVM,EM6/0.130652,0.066983/
      DATA AL10T/9.212/
C.
C.    ------------------------------------------------------------------
C.
      IF(GEKIN.LE.PPCUTM)GO TO 900
      EEM1=GETOT
      KCASE=NAMEC(6)
C
      VMIN=4*EMASS/EEM1
      VMAX=1.-CVM*Z**0.333333/EEM1
      IF(VMAX.LE.VMIN)GO TO 900
      VC  = PPCUTM/EEM1
      ALE=LOG(EEM1)
      ALFA=1.+ALE/AL10T
      V0=0.18*(4.+ALE/AL10T)*ALFA*(ALFA*VMIN)**0.6666667
      BETA=0.1*(1.+3.*ALE/AL10T)
      B=0.9/(1.+0.4*ALE+0.022*ALE*ALE)
      AA=1.+2.*B*LOG(VC/V0)
      IF(AA.LE.1.) AA=1.05
      A1=1.-AA
      CC=EXP(-0.25*A1*A1/B)
      A1R=1./A1
      C1=VMAX**A1
      C2=VC**A1
C
C     SAMPLE V AND RO
C
  50  CALL GRNDM(RNDM,2)
      R=RNDM(1)
      V=(R*C1+(1.-R)*C2)**A1R
      IF(V.LE.VMIN) GOTO 50
      IF(V.LT.V0) THEN
        SCREJ=CC*((V-VMIN)/(V0-VMIN))**BETA*(V0/V)**A1
      ELSE
        SCREJ=CC*(V0/V)**(A1+B*LOG(V/V0))
      ENDIF
      IF(RNDM(2).GT.SCREJ) GOTO 50
      R0MAX= SCREJ*(1.-EM6/(EEM1**2*(1.-V)))
      CALL GRNDM(RNDM,2)
      R0   = R0MAX*(2.*RNDM(1)-1.)
C
C           Energies
C
      EPP  = V*EEM1
      IF(IPAIR.NE.1)THEN
         NGKINE=0
         DESTEP=DESTEP+EPP
         GO TO 60
      ENDIF
      EPOS = 0.5*EPP*(1.+R0)
      EMIN = EPP-EPOS
C
C           Angles
C
      THETA = AMASS/EEM1
      SINTH = SIN(THETA)
      COSTH = COS(THETA)
      PHI   = TWOPI*RNDM(2)
      COSPHI= COS(PHI)
      SINPHI= SIN(PHI)
C
      CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C           Positron
C
      NGKINE = 0
      TPOS   = EPOS-EMASS
      IF(TPOS.GT.CUTELE)THEN
         PPOS  = SQRT((EPOS+EMASS)*TPOS)
         NGKINE= NGKINE+1
         GKIN(1,NGKINE)=PPOS*SINTH*COSPHI
         GKIN(2,NGKINE)=PPOS*SINTH*SINPHI
         GKIN(3,NGKINE)=PPOS*COSTH
         GKIN(4,NGKINE)=EPOS
         GKIN(5,NGKINE)=2.
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP=DESTEP+TPOS
         CALL GANNI2
      ENDIF
C
C           Electron
C
      TMIN=EMIN-EMASS
      IF(TMIN.GT.CUTELE)THEN
         PMIN  = SQRT((EMIN+EMASS)*TMIN)
         NGKINE= NGKINE+1
         GKIN(1,NGKINE)=-PMIN*SINTH*COSPHI
         GKIN(2,NGKINE)=-PMIN*SINTH*SINPHI
         GKIN(3,NGKINE)=PMIN*COSTH
         GKIN(4,NGKINE)=EMIN
         GKIN(5,NGKINE)=3.
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP=DESTEP+TMIN
      ENDIF
C
C           Correct muon track
C
  60  GEKIN  = GEKIN-EPP
      GETOT  = GEKIN+AMASS
      VECT(7)= SQRT((GETOT+AMASS)*GEKIN)
      CALL GEKBIN
C
C           Update probabilities
C
 900  CALL GRNDM(RNDM,1)
      ZINTPA = -LOG(RNDM(1))
      SLPAIR = SLENG
      STEPPA = BIG
C
      END
+DECK,  GPHAK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:29  cernlib
* Geant

      REAL FUNCTION GPHAK(BET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Photoelectron Angular ditribution from K shell      *
C.    *   from L1 shell ditribution ENTRY GPHAL1                       *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
      DOUBLE PRECISION SAUT1,SAUT2,SAUT3,DRN
      DOUBLE PRECISION COST,SIN2T,X,ANOR,AMAJOR
      DOUBLE PRECISION GAMA,G1,G2,BETA,B1,ONE,HALF
      PARAMETER (BETMAX=0.999999)
      PARAMETER (ONE=1,HALF=ONE/2)
      DIMENSION RAN(2),BETVAL(7),AMAJOR(7)
      DATA BETVAL / 0.8601,0.901,0.9901,0.99901,0.999901,0.9999901,
     +              0.99999901 /
      DATA AMAJOR / 1.02,1.1,4.3,19.,68.,221.,704. /
      DATA ANOR / 0.0 /
C
C L1 shell entry
C
      ENTRY GPHAL1(BET)
C
      BETA = MIN(BET,BETMAX)
      B1 = ONE-BETA
      G2 = ONE/((ONE-BETA)*(ONE+BETA))
      GAMA = SQRT(G2)
      G1 = GAMA-ONE
      DO 10 I = 1,7
       IF(BETA.LE.BETVAL(I)) THEN
        ANOR = AMAJOR(I)*G2
        ANOR = ONE/ANOR
        GO TO 20
       ENDIF
   10 CONTINUE
   20 SAUT2 = HALF*GAMA*G1*(GAMA-2)
      GPHAK = 0.0
   30 CONTINUE
      CALL GRNDM(RAN,2)
      DRN = 2*RAN(1)
      SAUT1 = (DRN-B1)/(DRN*BETA+B1)
      COST = SAUT1
      X = ONE-BETA*COST
      SIN2T = (ONE-COST)*(ONE+COST)
      SAUT3 = SIN2T/(X**2)*(ONE+SAUT2*X)*ANOR
      IF(RAN(2).GT.SAUT3) GO TO 30
      GPHAK = COST
      GPHAL1 = GPHAK
      END
+DECK,  GPHAL2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:29  cernlib
* Geant

      FUNCTION GPHAL2(BET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Photoelectron Angular ditribution from L2 shell     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
      DOUBLE PRECISION SAUT1,SAUT2,SAUT3,SAUT4,SAUT5,SAUT6,SAUT7
      DOUBLE PRECISION S1,S2,S3,S4,S5,S6,S7,ONE,HALF
      DOUBLE PRECISION COST,SIN2T,X,XI,XI2,XI3,ANOR,DRN
      DOUBLE PRECISION GAMA,G1,G2,G3,G4,G5,BETA,B1
      DOUBLE PRECISION BETVAL,AMAJOR
      PARAMETER(BETMAX=0.999999)
      PARAMETER (ONE=1,HALF=ONE/2)
      DIMENSION BETVAL(15),AMAJOR(15),RAN(2)
      DATA BETVAL / 0.0101,0.101,0.2,0.301,0.401,0.501
     +             ,0.601,0.701,0.801,0.901,0.9901,0.99901
     +             ,0.999901,0.9999901,0.99999901 /
      DATA AMAJOR / 2.05,2.2,2.4,2.6,2.72,3.0,3.2,3.6
     +             ,4.4,6.2,25.,88.,280.,900.,2880. /
      DATA ANOR / 0.0 /
      BETA = MIN(BET,BETMAX)
      B1 = ONE-BETA
      G2 = ONE/((ONE-BETA)*(ONE+BETA))
      GAMA = SQRT(G2)
      G3 = G2*GAMA
      G4 = G2**2
      G5 = G4*GAMA
      G1 = GAMA-ONE
      DO 10 I = 1,15
       IF(BETA.LE.BETVAL(I)) THEN
        ANOR = AMAJOR(I)*G5
        GO TO 20
       ENDIF
   10 CONTINUE
   20 CONTINUE
      ANOR = ONE/ANOR
      S1 = HALF*GAMA*(3*GAMA+1)
      S2 = -0.125D0*G2*(9*G2+30*GAMA-7)
      S3 = 0.25D0*G3*(G3+6*G2+11*GAMA-2)
      S4 = -.125D0*G4*G1*(GAMA+7)
      S5 = 2*(GAMA+ONE)
      S6 = 2*GAMA*(GAMA+ONE)
      S7 = 0.125D0*G4*BETA**2*(3*GAMA+ONE)
      GPHAL2 = 0.0
   30 CONTINUE
      CALL GRNDM(RAN,2)
      DRN = 2*RAN(1)
      COST = (DRN-B1)/(DRN*BETA+B1)
      X = ONE-BETA*COST
      XI  = ONE/X
      XI2 = XI**2
      XI3 = XI**3
      SIN2T = (ONE-COST)*(ONE+COST)
      SAUT1 = S1*XI2
      SAUT2 = S2*XI
      SAUT3 = S3
      SAUT4 = S4*X
      SAUT5 = S5*XI3-S6*XI2-S7*XI
      SAUT6 = SAUT5*SIN2T
      SAUT7 = (SAUT1+SAUT2+SAUT3+SAUT4+SAUT6)*ANOR
      IF(RAN(2).GT.SAUT7) GO TO 30
      GPHAL2 = COST
      END
+DECK,  GPHAL3, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:29  cernlib
* Geant

      FUNCTION GPHAL3(BET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates Photoelectron Angular ditribution from L3 shell     *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOT                                        *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
      DOUBLE PRECISION SAUT1,SAUT2,SAUT3,SAUT4,SAUT5,SAUT6,SAUT7
      DOUBLE PRECISION S1,S2,S3,S4,S5,S6,S7,BETVAL,AMAJOR
      DOUBLE PRECISION COST,SIN2T,X,XI,XI2,XI3,ANOR,DRN
      DOUBLE PRECISION GAMA,G1,G2,G3,G4,G5,BETA,B1
      PARAMETER(BETMAX=0.999998)
      PARAMETER (ONE=1,HALF=ONE/2)
      DIMENSION BETVAL(13),AMAJOR(13),RAN(2)
      DATA BETVAL / 0.0101,0.101,0.2,0.401,0.601
     +             ,0.701,0.801,0.901,0.9901,0.99901
     +             ,0.999901,0.9999901,0.99999901 /
      DATA AMAJOR / 2.05,2.2,2.3,2.4,2.5,2.6,2.81
     +             ,3.8,15.,54.,176.,560.,1800. /
      DATA ANOR / 0.0 /
      BETA = MIN(BET,BETMAX)
      B1 = ONE-BETA
      G2 = ONE/((ONE-BETA)*(ONE+BETA))
      GAMA = SQRT(G2)
      G3 = G2*GAMA
      G4 = G2**2
      G5 = G4*GAMA
      G1 = GAMA-ONE
      DO 10 I = 1,13
       IF(BETA.LE.BETVAL(I)) THEN
        ANOR = AMAJOR(I)*G5
        GO TO 20
       ENDIF
   10 CONTINUE
   20 CONTINUE
      ANOR = ONE/ANOR
      S1 = -HALF*GAMA*(3*GAMA-ONE)
      S2 = G2*(3*G2-ONE)
      S3 = G3*(G3-3*G2+2*GAMA+ONE)
      S4 = HALF*G4*G1*(GAMA-2)
      S5 = 2*(GAMA+ONE)
      S6 = GAMA*(3*GAMA-ONE)*(GAMA+ONE)
      S7 = G2*(G2-1)
      GPHAL3 = 0.0
   30 CONTINUE
      CALL GRNDM(RAN,2)
      DRN = 2*RAN(1)
      COST = (DRN-B1)/(DRN*BETA+B1)
      X = ONE-BETA*COST
      SIN2T = (ONE-COST)*(ONE+COST)
      XI  = ONE/X
      XI2 = XI**2
      XI3 = XI**3
      SAUT1 = S1*XI2
      SAUT2 = S2*XI
      SAUT3 = S3
      SAUT4 = S4*X
      SAUT5 = S5*XI3-S6*XI2-S7*XI
      SAUT6 = SAUT5*SIN2T
      SAUT7 = (SAUT1+SAUT2+SAUT3+SAUT4+SAUT6)*ANOR
      IF(RAN(2).GT.SAUT7) GO TO 30
      GPHAL3 = COST
      END
+DECK,  GPHINI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:29  cernlib
* Geant

      SUBROUTINE GPHINI
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize material constants for                        *
C.    *       the photoelectric effect                                 *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      CALL GPHRIN
      CALL GSHLIN
      CALL GPHXIN
      END
+DECK,  GPHOT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:29  cernlib
* Geant

      SUBROUTINE GPHOT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  GENERATES PHOTO ELECTRIC MECHANISM                            *
C.    *  Corrected version of L. Urban's routine.                      *
C.    *  Improvements:                                                 *
C.    *    1. Angular distributions of photoelectrons from K-L3 shells *
C.    *    2. Generation of shell decay mode                           *
C.    *    3. Probability of interactioon with a shell = function      *
C.    *       of photon energy                                         *
C.    *                                                                *
C.    *    ==>CALLED BY : GTGAMA                                       *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCPHYS.
+CDE, GCONSP.
+CDE, GCKING.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCUNIT.
      DIMENSION POT(4),PROB(4),RNA(9)
      EQUIVALENCE (RNA(1),RN01),(RNA(2),RN02),(RNA(3),RN03)
      EQUIVALENCE (RNA(4),RN04),(RNA(5),RN05),(RNA(6),RN06)
      EQUIVALENCE (RNA(7),RN07),(RNA(8),RN08),(RNA(9),RN09)
      EQUIVALENCE (POT(1),POTK),(POT(2),POTL1)
      EQUIVALENCE (POT(3),POTL2),(POT(4),POTL3)
      EQUIVALENCE (PROB(1),PROBK),(PROB(2),PROBL1)
      EQUIVALENCE (PROB(3),PROBL2),(PROB(4),PROBL3)
      SAVE ZINOLD,POT,NSHELL
      DATA ZINOLD / 0.0 /
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(8)
C
C             STOP ELECTRON ?
C
C Check if the photoelectric effect was activated. If not deposit
C gamma & return
      IF(IPHOT.NE.1) THEN
         ISTOP = 2
         NGKINE= 0
         DESTEP = DESTEP + VECT(7)
         VECT(7) = 0.
         GEKIN = 0.
         GETOT = 0.
      ELSE
         E=VECT(7)
         CALL GRNDM(RNA,9)
         JPHXS = LQ(JPHOT-1)
         NZ = Q(JPHXS+1)
         IF(NZ.GT.1) THEN
            QS = 0.0
            QS2 = GPHSG1(E)*RN01
            DO 10 I = 1,NZ-1
               QS1 = GPHSGP(I,E)
               QS = QS+QS1
               IF(QS2.LE.QS) THEN
                  K = I
                  GO TO 20
               ENDIF
   10       CONTINUE
            K = NZ
   20       CONTINUE
            JPHFN = LQ(JPHXS-K)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+K)
         ELSE
            JPHFN = LQ(JPHXS-1)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+1)
         ENDIF
C COPY SHELLS POTENTIALS FROM THE ZEBRA STUCTURE
C Check if this atom was used in last entry
         IF(ZINT.NE.ZINOLD) THEN
            NSHELL = Q(JFN+1)
            DO 30 I = 1,NSHELL
               POT(I) = Q(JFN+1+I)
   30       CONTINUE
            ZINOLD = ZINT
         ENDIF
C Check if E-gamma is bigger than the L3 ionization potential.
C This will make GPHOT a little faster.
         ISHELL = 0
         PROB(1) = 0.
         PROB(2) = 0.
         PROB(3) = 0.
         PROB(4) = 0.
         IF(E.GE.POTL3) THEN
C If ZINT < 5 we can have K shell only, so
            IF(ZINT.LT.5) THEN
               IF(E.GT.POTK) THEN
                  PROBK = 1.
                  TK = E-POTK
                  ISHELL = 1
               ENDIF
            ELSE
C The probabilities given below come from crude approximation
C It uses the jump ratios and assumes that they are valid for the whole energy
C range.
               IF(E.LT.POTL2) THEN
                  PROBL3 = 1.0
                  TK = E-POTL3
                  ISHELL = 4
               ELSE
                  E3 = E-POTL3
                  GAMAL3 = E3/EMASS+1.
                  BETAL3 = SQRT(E3*(E3+2.0*EMASS))/(E+EMASS)
                  E2 = E-POTL2
                  GAMAL2 = E2/EMASS+1.
                  BETAL2 = SQRT(E2*(E2+2.0*EMASS))/(E+EMASS)
                  EFRAC = EMASS/E
                  PROBL3 = GAVRL3(GAMAL3,BETAL3,EFRAC)
                  PROBL2 = GAVRL2(GAMAL2,BETAL2,EFRAC)
                  ANOR = 1./(PROBL3+PROBL2)
                  PROBL3 = PROBL3*ANOR
                  PROBL2 = PROBL2*ANOR
                  IF(E.LT.POTL1) THEN
                     IF(RN02.LT.PROBL3) THEN
                        ISHELL = 4
                        TK = E-POTL3
                     ELSE
                        ISHELL = 3
                        TK = E-POTL2
                     ENDIF
                  ELSE
C Parametrization of L1 jump ratio gives constant 1.2
                     PROBL1 = 1.-1./1.2
                     IF(E.LT.POTK) THEN
                        PROBL2 = (1.-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBL1)*PROBL3
                     ELSE
                        PROBK = 125./ZINT+3.5
                        PROBK = 1.-1/PROBK
                        PROBL1 = (1.-PROBK)*PROBL1
                        PROBL2 = (1.-PROBK-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBK-PROBL1)*PROBL3
                     ENDIF
                     IF(POTL3.LE.0.0) PROBL3 = 0.0
                     IF(POTL2.LE.0.0) PROBL2 = 0.0
                     IF(POTL1.LE.0.0) PROBL1 = 0.0
                     ANOR = PROBK+PROBL1+PROBL2+PROBL3
                     IF(ANOR.GT.0.0) THEN
                        ANOR = 1./ANOR
                        PROBK = PROBK*ANOR
                        PROBL1 = PROBL1*ANOR+PROBK
                        PROBL2 = PROBL2*ANOR+PROBL1
                        PROBL3 = PROBL3*ANOR+PROBL2
                        ISHELL = 4
                        TK = E-POTL3
                        IF(RN02.LE.PROBK) THEN
                           ISHELL = 1
                           TK = E-POTK
                        ELSEIF(RN02.LE.PROBL1) THEN
                           ISHELL = 2
                           TK = E-POTL1
                        ELSEIF(RN02.LE.PROBL2) THEN
                           ISHELL = 3
                           TK = E-POTL2
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
            IF(TK.LE.CUTELE) ISHELL = -ISHELL
         ENDIF
         IF(ISHELL.LT.1) THEN
C None of the shells was chosen because of the CUTELE
            ISTOP = 2
            IF(ISHELL.LT.0) THEN
               DESTEP = DESTEP+TK
            ELSEIF(ISHELL.EQ.0) THEN
               DESTEP = DESTEP+VECT(7)
            ENDIF
            NGKINE= 0
            VECT(7) = 0.
            GEKIN = 0.
            GETOT = 0.
         ELSE
C
C             ENERGY AND MOMENTUM OF PHOTOELECTRON
C
            EEL=TK + EMASS
            PEL=SQRT((TK+2.*EMASS)*TK)
            BETA = PEL/EEL
            ISTOP = 1
            NGKINE = 1
            IF(ISHELL.EQ.1) THEN
               COST = GPHAK(BETA)
            ELSEIF(ISHELL.EQ.2) THEN
               COST = GPHAL1(BETA)
            ELSEIF(ISHELL.EQ.3) THEN
               COST = GPHAL2(BETA)
            ELSEIF(ISHELL.EQ.4) THEN
               COST = GPHAL3(BETA)
            ENDIF
            PHI = TWOPI*RN03
            COSPHI = COS(PHI)
            SINPHI = SIN(PHI)
            SINT = SQRT((1.-COST)*(1.+COST))
            GKIN(1,NGKINE) = PEL*SINT*COSPHI
            GKIN(2,NGKINE) = PEL*SINT*SINPHI
            GKIN(3,NGKINE) = PEL*COST
            GKIN(4,NGKINE) = EEL
            GKIN(5,NGKINE) = 3.
            TOFD(NGKINE) = 0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
C
C             ROTATE ELECTRON AND SCATTERED PHOTON INTO GEANT SYSTEM
C
            CALL GVROT(VECT(4),GKIN)
         ENDIF
         IF(ISHELL.NE.0) THEN
            ISHELL = ABS(ISHELL)
            IF(ZINT.GE.5.AND.POT(ISHELL).GT.MIN(CUTGAM,CUTELE)) THEN
C Generate shell decay mode
               IF(RN04.LE.Q(JFN+1+NSHELL+ISHELL)) THEN
                  IF(POT(ISHELL).LE.CUTGAM) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
C Radiative shell decay
                     JS = JFN+1+2*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 40 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 50
                        ENDIF
   40                CONTINUE
   50                CONTINUE
                  ENDIF
               ELSE
                  IF(POT(ISHELL).LE.CUTELE) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
c Nonradiative decay
                     JS = JFN+1+3*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 60 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTELE) THEN
                              EEL=TSEC + EMASS
                              PEL=SQRT((TSEC+2.*EMASS)*TSEC)
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = PEL*SINT*COSPHI
                              GKIN(2,NGKINE) = PEL*SINT*SINPHI
                              GKIN(3,NGKINE) = PEL*COST
                              GKIN(4,NGKINE) = EEL
                              GKIN(5,NGKINE) = 3.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 70
                        ENDIF
   60                CONTINUE
   70                CONTINUE
                  ENDIF
               ENDIF
            ELSE
               DESTEP = DESTEP+POT(ISHELL)
            ENDIF
         ENDIF
      ENDIF
      END
+DECK,  GPHOTI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:29  cernlib
* Geant

      SUBROUTINE GPHOTI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C     *  for PHOTOELECTRIC EFFECT using the empirical                  *
C     *  formula of L.Urban (see WRITE UP) for Z > 100                 *
C.    *                                                                *
C     *  otherwise Sandia parametrization                              *
C     *   F.Biggs & R. Lighthill, SAND87-0070, UC-34, May 1990         *
C     *                                                                *
C     *  NOTE:                                                         *
C     *  (1) Above 0.050 GeV ( 50 MeV) a cut is imposed as the         *
C     *   contribution from photoeffect is negligible for EGAM.GT.0.050*
C     *  (2) From 10KeV to 100KeV a special parametrization            *
C     *       has been introduced                                      *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GCJLOC.
+CDE, GCMULO.
C.
C.    ------------------------------------------------------------------
C.
C             universal energy cut-off
C
      SIG=0.
      EGAM=ELOW(IEKBIN)
      IF(EGAM.LE.0.05) THEN
C
         IF(Z.GT.100) THEN
C Below good old stuff
            IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
               JPROB=LQ(JMA-4)
               SIG=GPHSIG(Z,EGAM)*AVO*DENS/A
            ELSE
C
C             compound/mixture
C
               NLMAT=Q(JMA+11)
               NLM=IABS(NLMAT)
               SIG=0.
               DO 10 I=1,NLM
                  J=JMIXT+I
                  AA=Q(J)
                  ZZ=Q(J+NLM)
                  WMAT=Q(J+2*NLM)
                  S=GPHSIG(ZZ,EGAM)
                  S=S*WMAT/AA
                  SIG=SIG+AVO*DENS*S
   10          CONTINUE
            ENDIF
C
C
         ELSEIF(Z.GE.1.) THEN
C New x-sections. Sandia parametrization
            JPROB=LQ(JMA-4)
            SIG = 0.0
            IF(EGAM.GE.1.E-8) SIG=GPHSG1(EGAM)*DENS
         ENDIF
      ENDIF
      IF(SIG.GT.0.)THEN
         Q(JPHOT+IEKBIN)=1./SIG
      ELSE
         Q(JPHOT+IEKBIN)=BIG
      ENDIF
C
      END
+DECK,  GPHRIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:29  cernlib
* Geant

      SUBROUTINE GPHRIN
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize decay mode rates' constants for               *
C.    *       the photoelectric effect                                 *
C.    *                                                                *
C.    *                                                                *
C.    *    ==>Called by : GPHINI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      IMPLICIT NONE
+CDE, GCPMXZ.
+CDE, GCPHPR.
+CDE, GCPHNR.
+CDE, GCPHRD.
      INTEGER I,J,ITRN
      REAL TMP,TMP1
      DIMENSION TMP(ISHLS,MAXELZ),TMP1(4,MAXELZ)
      DIMENSION ITRN(29)
      DATA ITRN / 3,4,6, 7,11,12,
     +            3,4,6, 7,11,12,18,19,
     +            4,5,8,10,13,17,20,
     +            5,8,9,10,13,14,17,20 /
      DATA (TMP(J,1),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,2),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,3),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,4),J=1,ISHLS) / ISHLS*0.0 /
      DATA (TMP(J,  5),J=1,ISHLS) /
     +  0.333E+00, 0.667E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.333E+00, 0.667E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  6),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.332E+00, 0.668E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  7),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.332E+00, 0.668E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  8),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.331E+00, 0.669E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J,  9),J=1,ISHLS) /
     +  0.334E+00, 0.666E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.331E+00, 0.669E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J, 10),J=1,ISHLS) /
     +  0.335E+00, 0.665E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.329E+00, 0.671E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.100E+01, 14*0.0 /
      DATA (TMP(J, 11),J=1,ISHLS) /
     +  0.335E+00, 0.665E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.328E+00, 0.672E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.233E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 12),J=1,ISHLS) /
     +  0.335E+00, 0.665E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.326E+00, 0.674E+00
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.159E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 13),J=1,ISHLS) /
     +  0.333E+00, 0.661E+00, 0.203E-02, 0.404E-02
     +, 0.000E+00, 0.000E+00, 0.291E+00, 0.608E+00
     +, 0.342E-01, 0.663E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.239E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 14),J=1,ISHLS) /
     +  0.330E+00, 0.654E+00, 0.562E-02, 0.111E-01
     +, 0.000E+00, 0.000E+00, 0.216E+00, 0.456E+00
     +, 0.111E+00, 0.216E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.408E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 15),J=1,ISHLS) /
     +  0.325E+00, 0.645E+00, 0.100E-01, 0.199E-01
     +, 0.000E+00, 0.000E+00, 0.141E+00, 0.300E+00
     +, 0.190E+00, 0.369E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.703E-09, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 16),J=1,ISHLS) /
     +  0.321E+00, 0.635E+00, 0.149E-01, 0.296E-01
     +, 0.000E+00, 0.000E+00, 0.881E-01, 0.191E+00
     +, 0.246E+00, 0.475E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.120E-08, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 17),J=1,ISHLS) /
     +  0.315E+00, 0.625E+00, 0.201E-01, 0.398E-01
     +, 0.000E+00, 0.000E+00, 0.559E-01, 0.124E+00
     +, 0.281E+00, 0.540E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.199E-08, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 18),J=1,ISHLS) /
     +  0.314E+00, 0.611E+00, 0.253E-01, 0.500E-01
     +, 0.000E+00, 0.000E+00, 0.368E-01, 0.828E-01
     +, 0.302E+00, 0.579E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.324E-08, 0.100E+01
     +, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.100E+01,  7*0.0 /
      DATA (TMP(J, 19),J=1,ISHLS) /
     +  0.307E+00, 0.606E+00, 0.293E-01, 0.580E-01
     +, 0.000E+00, 0.000E+00, 0.260E-01, 0.597E-01
     +, 0.313E+00, 0.601E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.480E-08, 0.976E+00
     +, 0.000E+00, 0.238E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.976E+00, 0.000E+00, 0.000E+00
     +, 0.238E-01,  4*0.0 /
      DATA (TMP(J, 20),J=1,ISHLS) /
     +  0.304E+00, 0.600E+00, 0.323E-01, 0.639E-01
     +, 0.000E+00, 0.000E+00, 0.193E-01, 0.455E-01
     +, 0.321E+00, 0.614E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.678E-08, 0.929E+00
     +, 0.000E+00, 0.709E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.929E+00, 0.000E+00, 0.000E+00
     +, 0.709E-01,  4*0.0 /
      DATA (TMP(J, 21),J=1,ISHLS) /
     +  0.303E+00, 0.597E+00, 0.335E-01, 0.661E-01
     +, 0.000E+00, 0.000E+00, 0.155E-01, 0.376E-01
     +, 0.326E+00, 0.621E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.504E-08, 0.452E+00
     +, 0.513E+00, 0.347E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.461E+00, 0.506E-01, 0.453E+00
     +, 0.353E-01,  4*0.0 /
      DATA (TMP(J, 22),J=1,ISHLS) /
     +  0.303E+00, 0.595E+00, 0.343E-01, 0.677E-01
     +, 0.000E+00, 0.000E+00, 0.128E-01, 0.317E-01
     +, 0.330E+00, 0.626E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.463E-08, 0.276E+00
     +, 0.703E+00, 0.208E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.284E+00, 0.699E-01, 0.624E+00
     +, 0.214E-01,  4*0.0 /
      DATA (TMP(J, 23),J=1,ISHLS) /
     +  0.302E+00, 0.594E+00, 0.350E-01, 0.690E-01
     +, 0.000E+00, 0.000E+00, 0.107E-01, 0.273E-01
     +, 0.333E+00, 0.629E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.471E-08, 0.191E+00
     +, 0.795E+00, 0.139E-01, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.198E+00, 0.793E-01, 0.708E+00
     +, 0.145E-01,  4*0.0 /
      DATA (TMP(J, 24),J=1,ISHLS) /
     +  0.303E+00, 0.594E+00, 0.348E-01, 0.685E-01
     +, 0.000E+00, 0.000E+00, 0.926E-02, 0.245E-01
     +, 0.335E+00, 0.631E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.475E-08, 0.130E+00
     +, 0.861E+00, 0.888E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.136E+00, 0.863E-01, 0.769E+00
     +, 0.910E-02,  4*0.0 /
      DATA (TMP(J, 25),J=1,ISHLS) /
     +  0.302E+00, 0.592E+00, 0.359E-01, 0.708E-01
     +, 0.000E+00, 0.000E+00, 0.778E-02, 0.213E-01
     +, 0.337E+00, 0.633E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.573E-08, 0.111E+00
     +, 0.881E+00, 0.759E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.117E+00, 0.882E-01, 0.787E+00
     +, 0.803E-02,  4*0.0 /
      DATA (TMP(J, 26),J=1,ISHLS) /
     +  0.302E+00, 0.591E+00, 0.363E-01, 0.714E-01
     +, 0.000E+00, 0.000E+00, 0.675E-02, 0.192E-01
     +, 0.339E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.657E-08, 0.900E-01
     +, 0.904E+00, 0.597E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.955E-01, 0.906E-01, 0.807E+00
     +, 0.634E-02,  4*0.0 /
      DATA (TMP(J, 27),J=1,ISHLS) /
     +  0.302E+00, 0.590E+00, 0.366E-01, 0.719E-01
     +, 0.000E+00, 0.000E+00, 0.589E-02, 0.176E-01
     +, 0.341E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.767E-08, 0.751E-01
     +, 0.920E+00, 0.483E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.803E-01, 0.924E-01, 0.822E+00
     +, 0.515E-02,  4*0.0 /
      DATA (TMP(J, 28),J=1,ISHLS) /
     +  0.301E+00, 0.589E+00, 0.369E-01, 0.724E-01
     +, 0.000E+00, 0.000E+00, 0.521E-02, 0.162E-01
     +, 0.343E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.902E-08, 0.640E-01
     +, 0.932E+00, 0.398E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.690E-01, 0.938E-01, 0.833E+00
     +, 0.428E-02,  4*0.0 /
      DATA (TMP(J, 29),J=1,ISHLS) /
     +  0.302E+00, 0.590E+00, 0.366E-01, 0.717E-01
     +, 0.000E+00, 0.000E+00, 0.470E-02, 0.153E-01
     +, 0.345E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.104E-07, 0.537E-01
     +, 0.943E+00, 0.325E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.585E-01, 0.954E-01, 0.845E+00
     +, 0.134E-02,  4*0.0 /
      DATA (TMP(J, 30),J=1,ISHLS) /
     +  0.302E+00, 0.588E+00, 0.373E-01, 0.730E-01
     +, 0.000E+00, 0.000E+00, 0.416E-02, 0.141E-01
     +, 0.347E+00, 0.635E+00, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.000E+00, 0.127E-07, 0.488E-01
     +, 0.948E+00, 0.285E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.532E-01, 0.956E-01, 0.848E+00
     +, 0.311E-02,  4*0.0 /
      DATA (TMP(J, 31),J=1,ISHLS) /
     +  0.301E+00, 0.586E+00, 0.381E-01, 0.744E-01
     +, 0.217E-03, 0.414E-03, 0.365E-02, 0.131E-01
     +, 0.346E+00, 0.631E+00, 0.208E-02, 0.373E-02
     +, 0.000E+00, 0.000E+00, 0.153E-07, 0.449E-01
     +, 0.952E+00, 0.345E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.494E-01, 0.958E-01, 0.851E+00
     +, 0.378E-02,  4*0.0 /
      DATA (TMP(J, 32),J=1,ISHLS) /
     +  0.301E+00, 0.583E+00, 0.388E-01, 0.759E-01
     +, 0.633E-03, 0.122E-02, 0.322E-02, 0.121E-01
     +, 0.344E+00, 0.624E+00, 0.595E-02, 0.106E-01
     +, 0.000E+00, 0.000E+00, 0.187E-07, 0.421E-01
     +, 0.954E+00, 0.376E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.465E-01, 0.961E-01, 0.853E+00
     +, 0.414E-02,  4*0.0 /
      DATA (TMP(J, 33),J=1,ISHLS) /
     +  0.299E+00, 0.580E+00, 0.396E-01, 0.772E-01
     +, 0.121E-02, 0.232E-02, 0.282E-02, 0.112E-01
     +, 0.341E+00, 0.614E+00, 0.110E-01, 0.197E-01
     +, 0.000E+00, 0.000E+00, 0.229E-07, 0.398E-01
     +, 0.956E+00, 0.398E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.442E-01, 0.962E-01, 0.855E+00
     +, 0.441E-02,  4*0.0 /
      DATA (TMP(J, 34),J=1,ISHLS) /
     +  0.298E+00, 0.577E+00, 0.403E-01, 0.787E-01
     +, 0.191E-02, 0.368E-02, 0.249E-02, 0.105E-01
     +, 0.336E+00, 0.604E+00, 0.170E-01, 0.302E-01
     +, 0.000E+00, 0.000E+00, 0.279E-07, 0.379E-01
     +, 0.958E+00, 0.414E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.425E-01, 0.964E-01, 0.857E+00
     +, 0.462E-02,  4*0.0 /
      DATA (TMP(J, 35),J=1,ISHLS) /
     +  0.297E+00, 0.574E+00, 0.410E-01, 0.799E-01
     +, 0.273E-02, 0.526E-02, 0.220E-02, 0.979E-02
     +, 0.331E+00, 0.592E+00, 0.235E-01, 0.417E-01
     +, 0.000E+00, 0.000E+00, 0.340E-07, 0.364E-01
     +, 0.959E+00, 0.427E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.411E-01, 0.965E-01, 0.858E+00
     +, 0.480E-02,  4*0.0 /
      DATA (TMP(J, 36),J=1,ISHLS) /
     +  0.296E+00, 0.571E+00, 0.416E-01, 0.812E-01
     +, 0.366E-02, 0.704E-02, 0.194E-02, 0.921E-02
     +, 0.325E+00, 0.579E+00, 0.305E-01, 0.539E-01
     +, 0.000E+00, 0.000E+00, 0.413E-07, 0.352E-01
     +, 0.960E+00, 0.438E-02, 0.000E+00, 0.000E+00
     +, 0.000E+00, 0.400E-01, 0.966E-01, 0.858E+00
     +, 0.495E-02,  4*0.0 /
      DATA (TMP(J, 37),J=1,ISHLS) /
     +  0.295E+00, 0.567E+00, 0.423E-01, 0.824E-01
     +, 0.440E-02, 0.855E-02, 0.173E-02, 0.873E-02
     +, 0.321E+00, 0.569E+00, 0.358E-01, 0.636E-01
     +, 0.000E+00, 0.000E+00, 0.502E-07, 0.341E-01
     +, 0.961E+00, 0.463E-02, 0.000E+00, 0.130E-03
     +, 0.000E+00, 0.390E-01, 0.966E-01, 0.859E+00
     +, 0.529E-02, 0.000E+00, 0.000E+00, 0.148E-03, 0.0 /
      DATA (TMP(J, 38),J=1,ISHLS) /
     +  0.294E+00, 0.565E+00, 0.429E-01, 0.837E-01
     +, 0.506E-02, 0.985E-02, 0.155E-02, 0.836E-02
     +, 0.318E+00, 0.560E+00, 0.402E-01, 0.712E-01
     +, 0.000E+00, 0.000E+00, 0.607E-07, 0.331E-01
     +, 0.962E+00, 0.489E-02, 0.000E+00, 0.421E-03
     +, 0.000E+00, 0.382E-01, 0.967E-01, 0.859E+00
     +, 0.561E-02, 0.000E+00, 0.000E+00, 0.484E-03, 0.0 /
      DATA (TMP(J, 39),J=1,ISHLS) /
     +  0.293E+00, 0.562E+00, 0.436E-01, 0.848E-01
     +, 0.554E-02, 0.108E-01, 0.140E-02, 0.807E-02
     +, 0.317E+00, 0.554E+00, 0.432E-01, 0.762E-01
     +, 0.000E+00, 0.000E+00, 0.730E-07, 0.322E-01
     +, 0.957E+00, 0.501E-02, 0.496E-02, 0.465E-03
     +, 0.000E+00, 0.374E-01, 0.962E-01, 0.855E+00
     +, 0.579E-02, 0.494E-03, 0.437E-02, 0.535E-03, 0.0 /
      DATA (TMP(J, 40),J=1,ISHLS) /
     +  0.293E+00, 0.560E+00, 0.441E-01, 0.860E-01
     +, 0.595E-02, 0.116E-01, 0.127E-02, 0.785E-02
     +, 0.316E+00, 0.549E+00, 0.457E-01, 0.802E-01
     +, 0.000E+00, 0.000E+00, 0.871E-07, 0.312E-01
     +, 0.952E+00, 0.508E-02, 0.117E-01, 0.480E-03
     +, 0.000E+00, 0.367E-01, 0.957E-01, 0.850E+00
     +, 0.593E-02, 0.116E-02, 0.103E-01, 0.559E-03, 0.0 /
      DATA (TMP(J, 41),J=1,ISHLS) /
     +  0.292E+00, 0.558E+00, 0.447E-01, 0.871E-01
     +, 0.623E-02, 0.121E-01, 0.116E-02, 0.770E-02
     +, 0.316E+00, 0.546E+00, 0.472E-01, 0.823E-01
     +, 0.000E+00, 0.000E+00, 0.103E-06, 0.303E-01
     +, 0.941E+00, 0.506E-02, 0.232E-01, 0.198E-03
     +, 0.000E+00, 0.359E-01, 0.946E-01, 0.841E+00
     +, 0.595E-02, 0.232E-02, 0.204E-01, 0.233E-03, 0.0 /
      DATA (TMP(J, 42),J=1,ISHLS) /
     +  0.292E+00, 0.556E+00, 0.453E-01, 0.881E-01
     +, 0.656E-02, 0.127E-01, 0.107E-02, 0.758E-02
     +, 0.315E+00, 0.542E+00, 0.491E-01, 0.853E-01
     +, 0.000E+00, 0.000E+00, 0.123E-06, 0.295E-01
     +, 0.933E+00, 0.510E-02, 0.321E-01, 0.194E-03
     +, 0.000E+00, 0.352E-01, 0.939E-01, 0.833E+00
     +, 0.604E-02, 0.319E-02, 0.282E-01, 0.231E-03, 0.0 /
      DATA (TMP(J, 43),J=1,ISHLS) /
     +  0.291E+00, 0.554E+00, 0.458E-01, 0.890E-01
     +, 0.688E-02, 0.133E-01, 0.978E-03, 0.749E-02
     +, 0.315E+00, 0.538E+00, 0.508E-01, 0.878E-01
     +, 0.000E+00, 0.000E+00, 0.145E-06, 0.288E-01
     +, 0.924E+00, 0.510E-02, 0.416E-01, 0.189E-03
     +, 0.000E+00, 0.347E-01, 0.930E-01, 0.825E+00
     +, 0.610E-02, 0.413E-02, 0.364E-01, 0.226E-03, 0.0 /
      DATA (TMP(J, 44),J=1,ISHLS) /
     +  0.291E+00, 0.552E+00, 0.463E-01, 0.901E-01
     +, 0.716E-02, 0.139E-01, 0.902E-03, 0.745E-02
     +, 0.315E+00, 0.535E+00, 0.524E-01, 0.899E-01
     +, 0.000E+00, 0.000E+00, 0.172E-06, 0.281E-01
     +, 0.915E+00, 0.509E-02, 0.515E-01, 0.184E-03
     +, 0.000E+00, 0.341E-01, 0.921E-01, 0.817E+00
     +, 0.614E-02, 0.511E-02, 0.450E-01, 0.222E-03, 0.0 /
      DATA (TMP(J, 45),J=1,ISHLS) /
     +  0.291E+00, 0.550E+00, 0.468E-01, 0.909E-01
     +, 0.742E-02, 0.144E-01, 0.834E-03, 0.744E-02
     +, 0.315E+00, 0.531E+00, 0.538E-01, 0.918E-01
     +, 0.000E+00, 0.000E+00, 0.202E-06, 0.274E-01
     +, 0.906E+00, 0.508E-02, 0.617E-01, 0.177E-03
     +, 0.000E+00, 0.336E-01, 0.911E-01, 0.809E+00
     +, 0.618E-02, 0.612E-02, 0.540E-01, 0.216E-03, 0.0 /
      DATA (TMP(J, 46),J=1,ISHLS) /
     +  0.290E+00, 0.548E+00, 0.472E-01, 0.918E-01
     +, 0.762E-02, 0.147E-01, 0.773E-03, 0.747E-02
     +, 0.315E+00, 0.529E+00, 0.547E-01, 0.925E-01
     +, 0.000E+00, 0.000E+00, 0.236E-06, 0.267E-01
     +, 0.894E+00, 0.502E-02, 0.744E-01, 0.000E+00
     +, 0.000E+00, 0.332E-01, 0.900E-01, 0.799E+00
     +, 0.617E-02, 0.737E-02, 0.646E-01,  2*0.0 /
      DATA (TMP(J, 47),J=1,ISHLS) /
     +  0.290E+00, 0.547E+00, 0.477E-01, 0.927E-01
     +, 0.790E-02, 0.153E-01, 0.719E-03, 0.751E-02
     +, 0.315E+00, 0.525E+00, 0.564E-01, 0.947E-01
     +, 0.000E+00, 0.000E+00, 0.276E-06, 0.262E-01
     +, 0.886E+00, 0.503E-02, 0.828E-01, 0.164E-03
     +, 0.000E+00, 0.329E-01, 0.891E-01, 0.791E+00
     +, 0.624E-02, 0.820E-02, 0.723E-01, 0.202E-03, 0.0 /
      DATA (TMP(J, 48),J=1,ISHLS) /
     +  0.290E+00, 0.545E+00, 0.481E-01, 0.934E-01
     +, 0.823E-02, 0.159E-01, 0.668E-03, 0.758E-02
     +, 0.315E+00, 0.521E+00, 0.582E-01, 0.971E-01
     +, 0.000E+00, 0.000E+00, 0.323E-06, 0.257E-01
     +, 0.878E+00, 0.505E-02, 0.905E-01, 0.400E-03
     +, 0.000E+00, 0.326E-01, 0.884E-01, 0.784E+00
     +, 0.632E-02, 0.894E-02, 0.790E-01, 0.500E-03, 0.0 /
      DATA (TMP(J, 49),J=1,ISHLS) /
     +  0.290E+00, 0.543E+00, 0.484E-01, 0.941E-01
     +, 0.853E-02, 0.165E-01, 0.623E-03, 0.766E-02
     +, 0.315E+00, 0.516E+00, 0.598E-01, 0.995E-01
     +, 0.507E-03, 0.778E-03, 0.378E-06, 0.253E-01
     +, 0.871E+00, 0.507E-02, 0.978E-01, 0.503E-03
     +, 0.000E+00, 0.324E-01, 0.877E-01, 0.778E+00
     +, 0.641E-02, 0.965E-02, 0.855E-01, 0.634E-03, 0.0 /
      DATA (TMP(J, 50),J=1,ISHLS) /
     +  0.289E+00, 0.541E+00, 0.489E-01, 0.948E-01
     +, 0.884E-02, 0.171E-01, 0.580E-03, 0.776E-02
     +, 0.314E+00, 0.511E+00, 0.614E-01, 0.101E+00
     +, 0.140E-02, 0.218E-02, 0.439E-06, 0.249E-01
     +, 0.865E+00, 0.510E-02, 0.104E+00, 0.574E-03
     +, 0.000E+00, 0.322E-01, 0.870E-01, 0.772E+00
     +, 0.651E-02, 0.103E-01, 0.914E-01, 0.732E-03, 0.0 /
      DATA (TMP(J, 51),J=1,ISHLS) /
     +  0.289E+00, 0.540E+00, 0.492E-01, 0.953E-01
     +, 0.915E-02, 0.177E-01, 0.541E-03, 0.787E-02
     +, 0.313E+00, 0.505E+00, 0.629E-01, 0.103E+00
     +, 0.260E-02, 0.406E-02, 0.511E-06, 0.245E-01
     +, 0.859E+00, 0.513E-02, 0.111E+00, 0.634E-03
     +, 0.000E+00, 0.321E-01, 0.864E-01, 0.766E+00
     +, 0.661E-02, 0.109E-01, 0.967E-01, 0.816E-03, 0.0 /
      DATA (TMP(J, 52),J=1,ISHLS) /
     +  0.289E+00, 0.537E+00, 0.496E-01, 0.961E-01
     +, 0.945E-02, 0.183E-01, 0.505E-03, 0.800E-02
     +, 0.312E+00, 0.500E+00, 0.642E-01, 0.105E+00
     +, 0.404E-02, 0.631E-02, 0.593E-06, 0.242E-01
     +, 0.854E+00, 0.516E-02, 0.116E+00, 0.688E-03
     +, 0.000E+00, 0.320E-01, 0.859E-01, 0.762E+00
     +, 0.672E-02, 0.114E-01, 0.102E+00, 0.894E-03, 0.0 /
      DATA (TMP(J, 53),J=1,ISHLS) /
     +  0.289E+00, 0.536E+00, 0.499E-01, 0.967E-01
     +, 0.974E-02, 0.189E-01, 0.473E-03, 0.816E-02
     +, 0.311E+00, 0.494E+00, 0.656E-01, 0.107E+00
     +, 0.571E-02, 0.891E-02, 0.688E-06, 0.240E-01
     +, 0.849E+00, 0.519E-02, 0.121E+00, 0.738E-03
     +, 0.000E+00, 0.319E-01, 0.854E-01, 0.757E+00
     +, 0.683E-02, 0.119E-01, 0.106E+00, 0.968E-03, 0.0 /
      DATA (TMP(J, 54),J=1,ISHLS) /
     +  0.289E+00, 0.534E+00, 0.502E-01, 0.973E-01
     +, 0.100E-01, 0.195E-01, 0.442E-03, 0.833E-02
     +, 0.309E+00, 0.488E+00, 0.667E-01, 0.108E+00
     +, 0.759E-02, 0.118E-01, 0.792E-06, 0.237E-01
     +, 0.844E+00, 0.523E-02, 0.126E+00, 0.784E-03
     +, 0.000E+00, 0.319E-01, 0.849E-01, 0.753E+00
     +, 0.694E-02, 0.123E-01, 0.110E+00, 0.104E-02, 0.0 /
      DATA (TMP(J, 55),J=1,ISHLS) /
     +  0.288E+00, 0.533E+00, 0.505E-01, 0.978E-01
     +, 0.103E-01, 0.200E-01, 0.415E-03, 0.853E-02
     +, 0.309E+00, 0.482E+00, 0.679E-01, 0.109E+00
     +, 0.900E-02, 0.142E-01, 0.915E-06, 0.235E-01
     +, 0.840E+00, 0.526E-02, 0.130E+00, 0.857E-03
     +, 0.000E+00, 0.319E-01, 0.845E-01, 0.749E+00
     +, 0.706E-02, 0.128E-01, 0.114E+00, 0.115E-02, 0.0 /
      DATA (TMP(J, 56),J=1,ISHLS) /
     +  0.289E+00, 0.531E+00, 0.508E-01, 0.984E-01
     +, 0.106E-01, 0.206E-01, 0.391E-03, 0.876E-02
     +, 0.308E+00, 0.477E+00, 0.692E-01, 0.110E+00
     +, 0.103E-01, 0.162E-01, 0.105E-05, 0.232E-01
     +, 0.836E+00, 0.529E-02, 0.135E+00, 0.928E-03
     +, 0.000E+00, 0.320E-01, 0.841E-01, 0.745E+00
     +, 0.718E-02, 0.132E-01, 0.118E+00, 0.126E-02, 0.0 /
      DATA (TMP(J, 57),J=1,ISHLS) /
     +  0.289E+00, 0.530E+00, 0.510E-01, 0.989E-01
     +, 0.108E-01, 0.211E-01, 0.368E-03, 0.903E-02
     +, 0.308E+00, 0.472E+00, 0.705E-01, 0.112E+00
     +, 0.112E-01, 0.175E-01, 0.121E-05, 0.229E-01
     +, 0.831E+00, 0.531E-02, 0.139E+00, 0.980E-03
     +, 0.108E-02, 0.320E-01, 0.836E-01, 0.740E+00
     +, 0.730E-02, 0.135E-01, 0.121E+00, 0.134E-02, 0.103E-02 /
      DATA (TMP(J, 58),J=1,ISHLS) /
     +  0.288E+00, 0.529E+00, 0.514E-01, 0.995E-01
     +, 0.109E-01, 0.212E-01, 0.348E-03, 0.938E-02
     +, 0.310E+00, 0.471E+00, 0.710E-01, 0.111E+00
     +, 0.104E-01, 0.161E-01, 0.140E-05, 0.229E-01
     +, 0.833E+00, 0.530E-02, 0.138E+00, 0.927E-03
     +, 0.000E+00, 0.323E-01, 0.839E-01, 0.742E+00
     +, 0.736E-02, 0.135E-01, 0.120E+00, 0.128E-02, 0.0 /
      DATA (TMP(J, 59),J=1,ISHLS) /
     +  0.289E+00, 0.527E+00, 0.517E-01, 0.100E+00
     +, 0.110E-01, 0.214E-01, 0.330E-03, 0.973E-02
     +, 0.311E+00, 0.469E+00, 0.718E-01, 0.112E+00
     +, 0.105E-01, 0.160E-01, 0.161E-05, 0.228E-01
     +, 0.831E+00, 0.532E-02, 0.140E+00, 0.922E-03
     +, 0.000E+00, 0.325E-01, 0.838E-01, 0.740E+00
     +, 0.745E-02, 0.136E-01, 0.121E+00, 0.129E-02, 0.0 /
      DATA (TMP(J, 60),J=1,ISHLS) /
     +  0.289E+00, 0.526E+00, 0.520E-01, 0.101E+00
     +, 0.112E-01, 0.217E-01, 0.313E-03, 0.101E-01
     +, 0.313E+00, 0.466E+00, 0.725E-01, 0.112E+00
     +, 0.105E-01, 0.158E-01, 0.185E-05, 0.227E-01
     +, 0.830E+00, 0.532E-02, 0.141E+00, 0.918E-03
     +, 0.000E+00, 0.327E-01, 0.834E-01, 0.740E+00
     +, 0.753E-02, 0.136E-01, 0.122E+00, 0.129E-02, 0.0 /
      DATA (TMP(J, 61),J=1,ISHLS) /
     +  0.289E+00, 0.524E+00, 0.522E-01, 0.101E+00
     +, 0.113E-01, 0.219E-01, 0.297E-03, 0.105E-01
     +, 0.314E+00, 0.463E+00, 0.732E-01, 0.112E+00
     +, 0.105E-01, 0.156E-01, 0.213E-05, 0.226E-01
     +, 0.830E+00, 0.532E-02, 0.142E+00, 0.912E-03
     +, 0.000E+00, 0.330E-01, 0.834E-01, 0.739E+00
     +, 0.761E-02, 0.137E-01, 0.122E+00, 0.130E-02, 0.0 /
      DATA (TMP(J, 62),J=1,ISHLS) /
     +  0.289E+00, 0.523E+00, 0.525E-01, 0.101E+00
     +, 0.114E-01, 0.221E-01, 0.283E-03, 0.110E-01
     +, 0.316E+00, 0.461E+00, 0.740E-01, 0.112E+00
     +, 0.105E-01, 0.155E-01, 0.243E-05, 0.225E-01
     +, 0.829E+00, 0.531E-02, 0.142E+00, 0.905E-03
     +, 0.000E+00, 0.333E-01, 0.835E-01, 0.737E+00
     +, 0.772E-02, 0.138E-01, 0.123E+00, 0.131E-02, 0.0 /
      DATA (TMP(J, 63),J=1,ISHLS) /
     +  0.289E+00, 0.522E+00, 0.527E-01, 0.102E+00
     +, 0.115E-01, 0.223E-01, 0.269E-03, 0.115E-01
     +, 0.318E+00, 0.458E+00, 0.747E-01, 0.112E+00
     +, 0.104E-01, 0.153E-01, 0.277E-05, 0.224E-01
     +, 0.828E+00, 0.532E-02, 0.143E+00, 0.898E-03
     +, 0.000E+00, 0.335E-01, 0.832E-01, 0.737E+00
     +, 0.779E-02, 0.138E-01, 0.123E+00, 0.131E-02, 0.0 /
      DATA (TMP(J, 64),J=1,ISHLS) /
     +  0.290E+00, 0.521E+00, 0.529E-01, 0.102E+00
     +, 0.116E-01, 0.226E-01, 0.257E-03, 0.120E-01
     +, 0.318E+00, 0.454E+00, 0.755E-01, 0.112E+00
     +, 0.111E-01, 0.161E-01, 0.315E-05, 0.223E-01
     +, 0.826E+00, 0.533E-02, 0.145E+00, 0.933E-03
     +, 0.865E-03, 0.338E-01, 0.830E-01, 0.734E+00
     +, 0.790E-02, 0.139E-01, 0.125E+00, 0.138E-02, 0.798E-03 /
      DATA (TMP(J, 65),J=1,ISHLS) /
     +  0.290E+00, 0.520E+00, 0.532E-01, 0.103E+00
     +, 0.117E-01, 0.226E-01, 0.245E-03, 0.126E-01
     +, 0.321E+00, 0.453E+00, 0.760E-01, 0.112E+00
     +, 0.104E-01, 0.148E-01, 0.360E-05, 0.223E-01
     +, 0.827E+00, 0.532E-02, 0.144E+00, 0.887E-03
     +, 0.000E+00, 0.342E-01, 0.832E-01, 0.735E+00
     +, 0.799E-02, 0.139E-01, 0.124E+00, 0.133E-02, 0.0 /
      DATA (TMP(J, 66),J=1,ISHLS) /
     +  0.290E+00, 0.519E+00, 0.534E-01, 0.103E+00
     +, 0.118E-01, 0.228E-01, 0.234E-03, 0.133E-01
     +, 0.323E+00, 0.450E+00, 0.768E-01, 0.112E+00
     +, 0.104E-01, 0.146E-01, 0.409E-05, 0.223E-01
     +, 0.827E+00, 0.534E-02, 0.145E+00, 0.880E-03
     +, 0.000E+00, 0.346E-01, 0.832E-01, 0.735E+00
     +, 0.809E-02, 0.139E-01, 0.124E+00, 0.133E-02, 0.0 /
      DATA (TMP(J, 67),J=1,ISHLS) /
     +  0.291E+00, 0.517E+00, 0.536E-01, 0.104E+00
     +, 0.118E-01, 0.229E-01, 0.224E-03, 0.139E-01
     +, 0.325E+00, 0.447E+00, 0.774E-01, 0.111E+00
     +, 0.104E-01, 0.144E-01, 0.465E-05, 0.222E-01
     +, 0.826E+00, 0.534E-02, 0.146E+00, 0.876E-03
     +, 0.000E+00, 0.349E-01, 0.831E-01, 0.734E+00
     +, 0.819E-02, 0.139E-01, 0.125E+00, 0.134E-02, 0.0 /
      DATA (TMP(J, 68),J=1,ISHLS) /
     +  0.291E+00, 0.516E+00, 0.538E-01, 0.104E+00
     +, 0.119E-01, 0.230E-01, 0.214E-03, 0.147E-01
     +, 0.327E+00, 0.445E+00, 0.780E-01, 0.111E+00
     +, 0.104E-01, 0.142E-01, 0.527E-05, 0.222E-01
     +, 0.826E+00, 0.534E-02, 0.146E+00, 0.871E-03
     +, 0.000E+00, 0.353E-01, 0.830E-01, 0.734E+00
     +, 0.830E-02, 0.139E-01, 0.125E+00, 0.134E-02, 0.0 /
      DATA (TMP(J, 69),J=1,ISHLS) /
     +  0.291E+00, 0.515E+00, 0.540E-01, 0.104E+00
     +, 0.120E-01, 0.232E-01, 0.205E-03, 0.155E-01
     +, 0.329E+00, 0.442E+00, 0.788E-01, 0.111E+00
     +, 0.104E-01, 0.140E-01, 0.598E-05, 0.222E-01
     +, 0.825E+00, 0.535E-02, 0.146E+00, 0.866E-03
     +, 0.000E+00, 0.357E-01, 0.830E-01, 0.733E+00
     +, 0.840E-02, 0.140E-01, 0.125E+00, 0.135E-02, 0.0 /
      DATA (TMP(J, 70),J=1,ISHLS) /
     +  0.292E+00, 0.514E+00, 0.542E-01, 0.105E+00
     +, 0.121E-01, 0.233E-01, 0.197E-03, 0.163E-01
     +, 0.331E+00, 0.439E+00, 0.794E-01, 0.110E+00
     +, 0.104E-01, 0.138E-01, 0.677E-05, 0.221E-01
     +, 0.825E+00, 0.536E-02, 0.147E+00, 0.861E-03
     +, 0.000E+00, 0.361E-01, 0.828E-01, 0.732E+00
     +, 0.851E-02, 0.140E-01, 0.125E+00, 0.136E-02, 0.0 /
      DATA (TMP(J, 71),J=1,ISHLS) /
     +  0.292E+00, 0.513E+00, 0.543E-01, 0.105E+00
     +, 0.121E-01, 0.235E-01, 0.189E-03, 0.172E-01
     +, 0.332E+00, 0.435E+00, 0.801E-01, 0.110E+00
     +, 0.110E-01, 0.145E-01, 0.765E-05, 0.221E-01
     +, 0.823E+00, 0.537E-02, 0.148E+00, 0.890E-03
     +, 0.649E-03, 0.365E-01, 0.827E-01, 0.730E+00
     +, 0.863E-02, 0.140E-01, 0.126E+00, 0.142E-02, 0.572E-03 /
      DATA (TMP(J, 72),J=1,ISHLS) /
     +  0.293E+00, 0.512E+00, 0.545E-01, 0.105E+00
     +, 0.122E-01, 0.237E-01, 0.181E-03, 0.181E-01
     +, 0.334E+00, 0.430E+00, 0.810E-01, 0.110E+00
     +, 0.116E-01, 0.152E-01, 0.858E-05, 0.220E-01
     +, 0.821E+00, 0.539E-02, 0.149E+00, 0.921E-03
     +, 0.160E-02, 0.369E-01, 0.825E-01, 0.728E+00
     +, 0.875E-02, 0.141E-01, 0.127E+00, 0.149E-02, 0.142E-02 /
      DATA (TMP(J, 73),J=1,ISHLS) /
     +  0.293E+00, 0.511E+00, 0.546E-01, 0.106E+00
     +, 0.124E-01, 0.239E-01, 0.174E-03, 0.191E-01
     +, 0.335E+00, 0.426E+00, 0.818E-01, 0.110E+00
     +, 0.122E-01, 0.158E-01, 0.968E-05, 0.220E-01
     +, 0.818E+00, 0.539E-02, 0.151E+00, 0.950E-03
     +, 0.278E-02, 0.373E-01, 0.822E-01, 0.726E+00
     +, 0.888E-02, 0.142E-01, 0.127E+00, 0.156E-02, 0.250E-02 /
      DATA (TMP(J, 74),J=1,ISHLS) /
     +  0.293E+00, 0.509E+00, 0.548E-01, 0.106E+00
     +, 0.125E-01, 0.242E-01, 0.167E-03, 0.202E-01
     +, 0.337E+00, 0.421E+00, 0.826E-01, 0.110E+00
     +, 0.128E-01, 0.165E-01, 0.109E-04, 0.219E-01
     +, 0.816E+00, 0.541E-02, 0.152E+00, 0.980E-03
     +, 0.420E-02, 0.377E-01, 0.820E-01, 0.723E+00
     +, 0.901E-02, 0.143E-01, 0.128E+00, 0.162E-02, 0.377E-02 /
      DATA (TMP(J, 75),J=1,ISHLS) /
     +  0.294E+00, 0.508E+00, 0.549E-01, 0.106E+00
     +, 0.126E-01, 0.244E-01, 0.161E-03, 0.213E-01
     +, 0.338E+00, 0.417E+00, 0.835E-01, 0.109E+00
     +, 0.134E-01, 0.170E-01, 0.122E-04, 0.219E-01
     +, 0.813E+00, 0.543E-02, 0.153E+00, 0.101E-02
     +, 0.581E-02, 0.381E-01, 0.817E-01, 0.721E+00
     +, 0.914E-02, 0.144E-01, 0.129E+00, 0.169E-02, 0.522E-02 /
      DATA (TMP(J, 76),J=1,ISHLS) /
     +  0.294E+00, 0.507E+00, 0.550E-01, 0.106E+00
     +, 0.127E-01, 0.246E-01, 0.155E-03, 0.225E-01
     +, 0.340E+00, 0.412E+00, 0.844E-01, 0.109E+00
     +, 0.140E-01, 0.176E-01, 0.137E-04, 0.218E-01
     +, 0.810E+00, 0.544E-02, 0.154E+00, 0.104E-02
     +, 0.762E-02, 0.384E-01, 0.814E-01, 0.718E+00
     +, 0.928E-02, 0.145E-01, 0.130E+00, 0.176E-02, 0.684E-02 /
      DATA (TMP(J, 77),J=1,ISHLS) /
     +  0.295E+00, 0.506E+00, 0.552E-01, 0.107E+00
     +, 0.128E-01, 0.249E-01, 0.149E-03, 0.239E-01
     +, 0.342E+00, 0.408E+00, 0.854E-01, 0.109E+00
     +, 0.144E-01, 0.178E-01, 0.153E-04, 0.217E-01
     +, 0.806E+00, 0.545E-02, 0.155E+00, 0.105E-02
     +, 0.109E-01, 0.388E-01, 0.810E-01, 0.714E+00
     +, 0.940E-02, 0.145E-01, 0.131E+00, 0.181E-02, 0.958E-02 /
      DATA (TMP(J, 78),J=1,ISHLS) /
     +  0.295E+00, 0.505E+00, 0.553E-01, 0.107E+00
     +, 0.129E-01, 0.251E-01, 0.144E-03, 0.253E-01
     +, 0.343E+00, 0.403E+00, 0.863E-01, 0.109E+00
     +, 0.151E-01, 0.184E-01, 0.172E-04, 0.217E-01
     +, 0.803E+00, 0.547E-02, 0.157E+00, 0.109E-02
     +, 0.125E-01, 0.393E-01, 0.807E-01, 0.711E+00
     +, 0.955E-02, 0.146E-01, 0.132E+00, 0.188E-02, 0.111E-01 /
      DATA (TMP(J, 79),J=1,ISHLS) /
     +  0.296E+00, 0.503E+00, 0.554E-01, 0.107E+00
     +, 0.130E-01, 0.254E-01, 0.140E-03, 0.270E-01
     +, 0.348E+00, 0.392E+00, 0.881E-01, 0.110E+00
     +, 0.158E-01, 0.190E-01, 0.192E-04, 0.216E-01
     +, 0.799E+00, 0.549E-02, 0.158E+00, 0.111E-02
     +, 0.148E-01, 0.397E-01, 0.803E-01, 0.708E+00
     +, 0.969E-02, 0.147E-01, 0.132E+00, 0.195E-02, 0.131E-01 /
      DATA (TMP(J, 80),J=1,ISHLS) /
     +  0.296E+00, 0.502E+00, 0.555E-01, 0.107E+00
     +, 0.131E-01, 0.256E-01, 0.133E-03, 0.283E-01
     +, 0.347E+00, 0.393E+00, 0.882E-01, 0.108E+00
     +, 0.163E-01, 0.194E-01, 0.214E-04, 0.216E-01
     +, 0.796E+00, 0.551E-02, 0.159E+00, 0.114E-02
     +, 0.165E-01, 0.401E-01, 0.801E-01, 0.705E+00
     +, 0.984E-02, 0.147E-01, 0.133E+00, 0.203E-02, 0.147E-01 /
      DATA (TMP(J, 81),J=1,ISHLS) /
     +  0.297E+00, 0.501E+00, 0.556E-01, 0.108E+00
     +, 0.132E-01, 0.259E-01, 0.129E-03, 0.301E-01
     +, 0.348E+00, 0.388E+00, 0.891E-01, 0.108E+00
     +, 0.170E-01, 0.200E-01, 0.240E-04, 0.215E-01
     +, 0.793E+00, 0.553E-02, 0.160E+00, 0.117E-02
     +, 0.183E-01, 0.406E-01, 0.798E-01, 0.703E+00
     +, 0.999E-02, 0.148E-01, 0.134E+00, 0.210E-02, 0.163E-01 /
      DATA (TMP(J, 82),J=1,ISHLS) /
     +  0.297E+00, 0.500E+00, 0.557E-01, 0.108E+00
     +, 0.133E-01, 0.261E-01, 0.124E-03, 0.319E-01
     +, 0.350E+00, 0.382E+00, 0.901E-01, 0.107E+00
     +, 0.176E-01, 0.206E-01, 0.267E-04, 0.215E-01
     +, 0.790E+00, 0.555E-02, 0.161E+00, 0.120E-02
     +, 0.200E-01, 0.411E-01, 0.795E-01, 0.700E+00
     +, 0.101E-01, 0.149E-01, 0.135E+00, 0.218E-02, 0.179E-01 /
      DATA (TMP(J, 83),J=1,ISHLS) /
     +  0.298E+00, 0.498E+00, 0.557E-01, 0.108E+00
     +, 0.134E-01, 0.263E-01, 0.120E-03, 0.338E-01
     +, 0.352E+00, 0.377E+00, 0.910E-01, 0.107E+00
     +, 0.183E-01, 0.212E-01, 0.298E-04, 0.215E-01
     +, 0.787E+00, 0.557E-02, 0.163E+00, 0.123E-02
     +, 0.216E-01, 0.415E-01, 0.792E-01, 0.697E+00
     +, 0.103E-01, 0.150E-01, 0.135E+00, 0.226E-02, 0.194E-01 /
      DATA (TMP(J, 84),J=1,ISHLS) /
     +  0.299E+00, 0.497E+00, 0.558E-01, 0.108E+00
     +, 0.135E-01, 0.266E-01, 0.116E-03, 0.358E-01
     +, 0.354E+00, 0.371E+00, 0.921E-01, 0.106E+00
     +, 0.190E-01, 0.218E-01, 0.332E-04, 0.214E-01
     +, 0.785E+00, 0.560E-02, 0.164E+00, 0.126E-02
     +, 0.232E-01, 0.420E-01, 0.789E-01, 0.694E+00
     +, 0.105E-01, 0.150E-01, 0.136E+00, 0.234E-02, 0.208E-01 /
      DATA (TMP(J, 85),J=1,ISHLS) /
     +  0.299E+00, 0.496E+00, 0.559E-01, 0.108E+00
     +, 0.135E-01, 0.268E-01, 0.112E-03, 0.381E-01
     +, 0.356E+00, 0.365E+00, 0.930E-01, 0.106E+00
     +, 0.197E-01, 0.223E-01, 0.369E-04, 0.214E-01
     +, 0.782E+00, 0.562E-02, 0.165E+00, 0.129E-02
     +, 0.247E-01, 0.426E-01, 0.786E-01, 0.692E+00
     +, 0.106E-01, 0.151E-01, 0.137E+00, 0.243E-02, 0.222E-01 /
      DATA (TMP(J, 86),J=1,ISHLS) /
     +  0.300E+00, 0.495E+00, 0.560E-01, 0.109E+00
     +, 0.136E-01, 0.270E-01, 0.108E-03, 0.405E-01
     +, 0.358E+00, 0.360E+00, 0.940E-01, 0.105E+00
     +, 0.204E-01, 0.227E-01, 0.411E-04, 0.214E-01
     +, 0.779E+00, 0.565E-02, 0.166E+00, 0.133E-02
     +, 0.262E-01, 0.431E-01, 0.783E-01, 0.689E+00
     +, 0.108E-01, 0.151E-01, 0.138E+00, 0.251E-02, 0.235E-01 /
      DATA (TMP(J, 87),J=1,ISHLS) /
     +  0.301E+00, 0.493E+00, 0.560E-01, 0.109E+00
     +, 0.137E-01, 0.273E-01, 0.105E-03, 0.430E-01
     +, 0.360E+00, 0.354E+00, 0.951E-01, 0.104E+00
     +, 0.211E-01, 0.232E-01, 0.457E-04, 0.214E-01
     +, 0.776E+00, 0.568E-02, 0.167E+00, 0.136E-02
     +, 0.276E-01, 0.437E-01, 0.781E-01, 0.687E+00
     +, 0.110E-01, 0.152E-01, 0.138E+00, 0.260E-02, 0.248E-01 /
      DATA (TMP(J, 88),J=1,ISHLS) /
     +  0.301E+00, 0.492E+00, 0.561E-01, 0.109E+00
     +, 0.138E-01, 0.275E-01, 0.101E-03, 0.456E-01
     +, 0.362E+00, 0.348E+00, 0.960E-01, 0.103E+00
     +, 0.218E-01, 0.236E-01, 0.508E-04, 0.214E-01
     +, 0.774E+00, 0.571E-02, 0.168E+00, 0.139E-02
     +, 0.291E-01, 0.425E-01, 0.779E-01, 0.685E+00
     +, 0.112E-01, 0.153E-01, 0.139E+00, 0.269E-02, 0.261E-01 /
      DATA (TMP(J, 89),J=1,ISHLS) /
     +  0.302E+00, 0.491E+00, 0.561E-01, 0.109E+00
     +, 0.139E-01, 0.277E-01, 0.978E-04, 0.485E-01
     +, 0.364E+00, 0.341E+00, 0.971E-01, 0.103E+00
     +, 0.224E-01, 0.240E-01, 0.564E-04, 0.215E-01
     +, 0.771E+00, 0.574E-02, 0.170E+00, 0.142E-02
     +, 0.305E-01, 0.448E-01, 0.775E-01, 0.681E+00
     +, 0.113E-01, 0.153E-01, 0.140E+00, 0.277E-02, 0.272E-01 /
      DATA (TMP(J, 90),J=1,ISHLS) /
     +  0.303E+00, 0.490E+00, 0.561E-01, 0.109E+00
     +, 0.139E-01, 0.280E-01, 0.946E-04, 0.515E-01
     +, 0.366E+00, 0.335E+00, 0.981E-01, 0.102E+00
     +, 0.231E-01, 0.243E-01, 0.626E-04, 0.215E-01
     +, 0.769E+00, 0.577E-02, 0.171E+00, 0.145E-02
     +, 0.319E-01, 0.454E-01, 0.773E-01, 0.679E+00
     +, 0.115E-01, 0.153E-01, 0.140E+00, 0.286E-02, 0.284E-01 /
      DATA (TMP(J, 91),J=1,ISHLS) /
     +  0.304E+00, 0.488E+00, 0.562E-01, 0.110E+00
     +, 0.140E-01, 0.282E-01, 0.913E-04, 0.547E-01
     +, 0.368E+00, 0.329E+00, 0.991E-01, 0.101E+00
     +, 0.237E-01, 0.244E-01, 0.695E-04, 0.215E-01
     +, 0.766E+00, 0.580E-02, 0.172E+00, 0.147E-02
     +, 0.326E-01, 0.460E-01, 0.770E-01, 0.677E+00
     +, 0.117E-01, 0.154E-01, 0.141E+00, 0.294E-02, 0.290E-01 /
      DATA (TMP(J, 92),J=1,ISHLS) /
     +  0.304E+00, 0.487E+00, 0.562E-01, 0.110E+00
     +, 0.140E-01, 0.284E-01, 0.882E-04, 0.582E-01
     +, 0.371E+00, 0.322E+00, 0.100E+00, 0.997E-01
     +, 0.243E-01, 0.245E-01, 0.772E-04, 0.215E-01
     +, 0.764E+00, 0.584E-02, 0.173E+00, 0.150E-02
     +, 0.335E-01, 0.466E-01, 0.768E-01, 0.675E+00
     +, 0.119E-01, 0.154E-01, 0.142E+00, 0.302E-02, 0.299E-01 /
      DATA (TMP(J, 93),J=1,ISHLS) /
     +  0.305E+00, 0.486E+00, 0.562E-01, 0.110E+00
     +, 0.141E-01, 0.286E-01, 0.852E-04, 0.619E-01
     +, 0.373E+00, 0.316E+00, 0.101E+00, 0.987E-01
     +, 0.249E-01, 0.246E-01, 0.855E-04, 0.216E-01
     +, 0.762E+00, 0.587E-02, 0.174E+00, 0.153E-02
     +, 0.344E-01, 0.473E-01, 0.766E-01, 0.673E+00
     +, 0.121E-01, 0.155E-01, 0.142E+00, 0.310E-02, 0.304E-01 /
      DATA (TMP(J, 94),J=1,ISHLS) /
     +  0.306E+00, 0.484E+00, 0.561E-01, 0.110E+00
     +, 0.141E-01, 0.298E-01, 0.822E-04, 0.658E-01
     +, 0.376E+00, 0.309E+00, 0.102E+00, 0.974E-01
     +, 0.254E-01, 0.246E-01, 0.949E-04, 0.216E-01
     +, 0.760E+00, 0.591E-02, 0.175E+00, 0.155E-02
     +, 0.351E-01, 0.480E-01, 0.764E-01, 0.671E+00
     +, 0.123E-01, 0.156E-01, 0.143E+00, 0.318E-02, 0.308E-01 /
      DATA (TMP(J, 95),J=1,ISHLS) /
     +  0.307E+00, 0.483E+00, 0.562E-01, 0.110E+00
     +, 0.142E-01, 0.291E-01, 0.793E-04, 0.700E-01
     +, 0.378E+00, 0.302E+00, 0.103E+00, 0.962E-01
     +, 0.259E-01, 0.245E-01, 0.105E-03, 0.216E-01
     +, 0.758E+00, 0.595E-02, 0.176E+00, 0.158E-02
     +, 0.359E-01, 0.486E-01, 0.763E-01, 0.669E+00
     +, 0.125E-01, 0.156E-01, 0.143E+00, 0.326E-02, 0.314E-01 /
      DATA (TMP(J, 96),J=1,ISHLS) /
     +  0.308E+00, 0.482E+00, 0.562E-01, 0.111E+00
     +, 0.142E-01, 0.293E-01, 0.764E-04, 0.745E-01
     +, 0.381E+00, 0.295E+00, 0.104E+00, 0.948E-01
     +, 0.265E-01, 0.245E-01, 0.116E-03, 0.217E-01
     +, 0.756E+00, 0.598E-02, 0.178E+00, 0.160E-02
     +, 0.369E-01, 0.493E-01, 0.761E-01, 0.667E+00
     +, 0.127E-01, 0.156E-01, 0.144E+00, 0.335E-02, 0.322E-01 /
      DATA (TMP(J, 97),J=1,ISHLS) /
     +  0.309E+00, 0.481E+00, 0.561E-01, 0.111E+00
     +, 0.143E-01, 0.295E-01, 0.736E-04, 0.792E-01
     +, 0.383E+00, 0.287E+00, 0.106E+00, 0.934E-01
     +, 0.271E-01, 0.244E-01, 0.129E-03, 0.218E-01
     +, 0.754E+00, 0.603E-02, 0.179E+00, 0.163E-02
     +, 0.376E-01, 0.500E-01, 0.757E-01, 0.665E+00
     +, 0.129E-01, 0.157E-01, 0.144E+00, 0.343E-02, 0.327E-01 /
      DATA (TMP(J, 98),J=1,ISHLS) /
     +  0.310E+00, 0.479E+00, 0.561E-01, 0.111E+00
     +, 0.143E-01, 0.297E-01, 0.708E-04, 0.843E-01
     +, 0.386E+00, 0.280E+00, 0.106E+00, 0.919E-01
     +, 0.276E-01, 0.242E-01, 0.143E-03, 0.218E-01
     +, 0.752E+00, 0.607E-02, 0.180E+00, 0.165E-02
     +, 0.381E-01, 0.507E-01, 0.756E-01, 0.664E+00
     +, 0.131E-01, 0.157E-01, 0.145E+00, 0.351E-02, 0.330E-01 /
      DATA (TMP(J, 99),J=1,ISHLS) /
     +  0.311E+00, 0.478E+00, 0.561E-01, 0.111E+00
     +, 0.143E-01, 0.299E-01, 0.679E-04, 0.897E-01
     +, 0.388E+00, 0.272E+00, 0.107E+00, 0.903E-01
     +, 0.281E-01, 0.240E-01, 0.158E-03, 0.219E-01
     +, 0.751E+00, 0.611E-02, 0.181E+00, 0.168E-02
     +, 0.388E-01, 0.515E-01, 0.754E-01, 0.662E+00
     +, 0.133E-01, 0.157E-01, 0.145E+00, 0.359E-02, 0.335E-01 /
      DATA (TMP(J,100),J=1,ISHLS) /
     +  0.312E+00, 0.477E+00, 0.560E-01, 0.111E+00
     +, 0.144E-01, 0.301E-01, 0.650E-04, 0.954E-01
     +, 0.391E+00, 0.264E+00, 0.108E+00, 0.885E-01
     +, 0.286E-01, 0.238E-01, 0.175E-03, 0.220E-01
     +, 0.749E+00, 0.616E-02, 0.182E+00, 0.170E-02
     +, 0.395E-01, 0.522E-01, 0.752E-01, 0.660E+00
     +, 0.135E-01, 0.158E-01, 0.146E+00, 0.367E-02, 0.339E-01 /
C
      DATA (TMP1(I,  1),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  2),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  3),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  4),I=1,4) / 4*0.0 /
      DATA (TMP1(I,  5),I=1,4) /  0.170E-02, 3*0.0 /
      DATA (TMP1(I,  6),I=1,4) /  0.280E-02, 3*0.0 /
      DATA (TMP1(I,  7),I=1,4) /  0.520E-02, 3*0.0 /
      DATA (TMP1(I,  8),I=1,4) /  0.830E-02, 3*0.0 /
      DATA (TMP1(I,  9),I=1,4) /  0.130E-01, 3*0.0 /
      DATA (TMP1(I, 10),I=1,4) /  0.180E-01, 3*0.0 /
      DATA (TMP1(I, 11),I=1,4) /  0.230E-01, 3*0.0 /
      DATA (TMP1(I, 12),I=1,4) /
     +  0.300E-01, 0.290E-04, 0.120E-02, 0.120E-02 /
      DATA (TMP1(I, 13),I=1,4) /
     +  0.390E-01, 0.260E-04, 0.750E-03, 0.750E-03 /
      DATA (TMP1(I, 14),I=1,4) /
     +  0.500E-01, 0.300E-04, 0.370E-03, 0.380E-03 /
      DATA (TMP1(I, 15),I=1,4) /
     +  0.630E-01, 0.390E-04, 0.310E-03, 0.310E-03 /
      DATA (TMP1(I, 16),I=1,4) /
     +  0.780E-01, 0.740E-04, 0.260E-03, 0.260E-03 /
      DATA (TMP1(I, 17),I=1,4) /
     +  0.970E-01, 0.120E-03, 0.240E-03, 0.240E-03 /
      DATA (TMP1(I, 18),I=1,4) /
     +  0.118E+00, 0.180E-03, 0.220E-03, 0.220E-03 /
      DATA (TMP1(I, 19),I=1,4) /
     +  0.140E+00, 0.240E-03, 0.270E-03, 0.270E-03 /
      DATA (TMP1(I, 20),I=1,4) /
     +  0.163E+00, 0.310E-03, 0.330E-03, 0.330E-03 /
      DATA (TMP1(I, 21),I=1,4) /
     +  0.188E+00, 0.390E-03, 0.840E-03, 0.840E-03 /
      DATA (TMP1(I, 22),I=1,4) /
     +  0.214E+00, 0.470E-03, 0.150E-02, 0.150E-02 /
      DATA (TMP1(I, 23),I=1,4) /
     +  0.243E+00, 0.580E-03, 0.260E-02, 0.260E-02 /
      DATA (TMP1(I, 24),I=1,4) /
     +  0.275E+00, 0.710E-03, 0.370E-02, 0.370E-02 /
      DATA (TMP1(I, 25),I=1,4) /
     +  0.308E+00, 0.840E-03, 0.500E-02, 0.500E-02 /
      DATA (TMP1(I, 26),I=1,4) /
     +  0.340E+00, 0.100E-02, 0.630E-02, 0.630E-02 /
      DATA (TMP1(I, 27),I=1,4) /
     +  0.373E+00, 0.120E-02, 0.770E-02, 0.770E-02 /
      DATA (TMP1(I, 28),I=1,4) /
     +  0.406E+00, 0.140E-02, 0.860E-02, 0.930E-02 /
      DATA (TMP1(I, 29),I=1,4) /
     +  0.440E+00, 0.160E-02, 0.100E-01, 0.110E-01 /
      DATA (TMP1(I, 30),I=1,4) /
     +  0.474E+00, 0.180E-02, 0.110E-01, 0.120E-01 /
      DATA (TMP1(I, 31),I=1,4) /
     +  0.507E+00, 0.210E-02, 0.120E-01, 0.130E-01 /
      DATA (TMP1(I, 32),I=1,4) /
     +  0.535E+00, 0.240E-02, 0.130E-01, 0.150E-01 /
      DATA (TMP1(I, 33),I=1,4) /
     +  0.562E+00, 0.280E-02, 0.140E-01, 0.160E-01 /
      DATA (TMP1(I, 34),I=1,4) /
     +  0.589E+00, 0.320E-02, 0.160E-01, 0.180E-01 /
      DATA (TMP1(I, 35),I=1,4) /
     +  0.618E+00, 0.360E-02, 0.180E-01, 0.200E-01 /
      DATA (TMP1(I, 36),I=1,4) /
     +  0.643E+00, 0.410E-02, 0.200E-01, 0.220E-01 /
      DATA (TMP1(I, 37),I=1,4) /
     +  0.667E+00, 0.460E-02, 0.220E-01, 0.240E-01 /
      DATA (TMP1(I, 38),I=1,4) /
     +  0.690E+00, 0.510E-02, 0.240E-01, 0.260E-01 /
      DATA (TMP1(I, 39),I=1,4) /
     +  0.710E+00, 0.590E-02, 0.260E-01, 0.280E-01 /
      DATA (TMP1(I, 40),I=1,4) /
     +  0.730E+00, 0.680E-02, 0.280E-01, 0.310E-01 /
      DATA (TMP1(I, 41),I=1,4) /
     +  0.747E+00, 0.940E-02, 0.310E-01, 0.340E-01 /
      DATA (TMP1(I, 42),I=1,4) /
     +  0.765E+00, 0.100E-01, 0.340E-01, 0.370E-01 /
      DATA (TMP1(I, 43),I=1,4) /
     +  0.780E+00, 0.110E-01, 0.370E-01, 0.400E-01 /
      DATA (TMP1(I, 44),I=1,4) /
     +  0.794E+00, 0.120E-01, 0.400E-01, 0.430E-01 /
      DATA (TMP1(I, 45),I=1,4) /
     +  0.808E+00, 0.130E-01, 0.430E-01, 0.460E-01 /
      DATA (TMP1(I, 46),I=1,4) /
     +  0.820E+00, 0.140E-01, 0.470E-01, 0.490E-01 /
      DATA (TMP1(I, 47),I=1,4) /
     +  0.831E+00, 0.160E-01, 0.510E-01, 0.520E-01 /
      DATA (TMP1(I, 48),I=1,4) /
     +  0.843E+00, 0.180E-01, 0.560E-01, 0.560E-01 /
      DATA (TMP1(I, 49),I=1,4) /
     +  0.853E+00, 0.200E-01, 0.610E-01, 0.600E-01 /
      DATA (TMP1(I, 50),I=1,4) /
     +  0.862E+00, 0.370E-01, 0.650E-01, 0.640E-01 /
      DATA (TMP1(I, 51),I=1,4) /
     +  0.870E+00, 0.390E-01, 0.690E-01, 0.690E-01 /
      DATA (TMP1(I, 52),I=1,4) /
     +  0.877E+00, 0.410E-01, 0.740E-01, 0.740E-01 /
      DATA (TMP1(I, 53),I=1,4) /
     +  0.884E+00, 0.440E-01, 0.790E-01, 0.790E-01 /
      DATA (TMP1(I, 54),I=1,4) /
     +  0.891E+00, 0.460E-01, 0.830E-01, 0.850E-01 /
      DATA (TMP1(I, 55),I=1,4) /
     +  0.897E+00, 0.490E-01, 0.900E-01, 0.910E-01 /
      DATA (TMP1(I, 56),I=1,4) /
     +  0.902E+00, 0.520E-01, 0.960E-01, 0.970E-01 /
      DATA (TMP1(I, 57),I=1,4) /
     +  0.907E+00, 0.550E-01, 0.103E+00, 0.104E+00 /
      DATA (TMP1(I, 58),I=1,4) /
     +  0.912E+00, 0.580E-01, 0.110E+00, 0.111E+00 /
      DATA (TMP1(I, 59),I=1,4) /
     +  0.917E+00, 0.610E-01, 0.117E+00, 0.118E+00 /
      DATA (TMP1(I, 60),I=1,4) /
     +  0.921E+00, 0.640E-01, 0.124E+00, 0.125E+00 /
      DATA (TMP1(I, 61),I=1,4) /
     +  0.925E+00, 0.660E-01, 0.132E+00, 0.132E+00 /
      DATA (TMP1(I, 62),I=1,4) /
     +  0.929E+00, 0.710E-01, 0.140E+00, 0.139E+00 /
      DATA (TMP1(I, 63),I=1,4) /
     +  0.932E+00, 0.750E-01, 0.149E+00, 0.147E+00 /
      DATA (TMP1(I, 64),I=1,4) /
     +  0.935E+00, 0.790E-01, 0.158E+00, 0.155E+00 /
      DATA (TMP1(I, 65),I=1,4) /
     +  0.938E+00, 0.830E-01, 0.167E+00, 0.164E+00 /
      DATA (TMP1(I, 66),I=1,4) /
     +  0.941E+00, 0.890E-01, 0.178E+00, 0.174E+00 /
      DATA (TMP1(I, 67),I=1,4) /
     +  0.944E+00, 0.940E-01, 0.189E+00, 0.182E+00 /
      DATA (TMP1(I, 68),I=1,4) /
     +  0.947E+00, 0.100E+00, 0.200E+00, 0.192E+00 /
      DATA (TMP1(I, 69),I=1,4) /
     +  0.949E+00, 0.106E+00, 0.211E+00, 0.201E+00 /
      DATA (TMP1(I, 70),I=1,4) /
     +  0.951E+00, 0.112E+00, 0.222E+00, 0.210E+00 /
      DATA (TMP1(I, 71),I=1,4) /
     +  0.953E+00, 0.120E+00, 0.234E+00, 0.220E+00 /
      DATA (TMP1(I, 72),I=1,4) /
     +  0.955E+00, 0.128E+00, 0.246E+00, 0.231E+00 /
      DATA (TMP1(I, 73),I=1,4) /
     +  0.957E+00, 0.137E+00, 0.258E+00, 0.243E+00 /
      DATA (TMP1(I, 74),I=1,4) /
     +  0.958E+00, 0.147E+00, 0.270E+00, 0.255E+00 /
      DATA (TMP1(I, 75),I=1,4) /
     +  0.959E+00, 0.144E+00, 0.283E+00, 0.268E+00 /
      DATA (TMP1(I, 76),I=1,4) /
     +  0.961E+00, 0.130E+00, 0.295E+00, 0.281E+00 /
      DATA (TMP1(I, 77),I=1,4) /
     +  0.962E+00, 0.120E+00, 0.308E+00, 0.294E+00 /
      DATA (TMP1(I, 78),I=1,4) /
     +  0.963E+00, 0.114E+00, 0.321E+00, 0.306E+00 /
      DATA (TMP1(I, 79),I=1,4) /
     +  0.964E+00, 0.107E+00, 0.334E+00, 0.320E+00 /
      DATA (TMP1(I, 80),I=1,4) /
     +  0.965E+00, 0.107E+00, 0.347E+00, 0.333E+00 /
      DATA (TMP1(I, 81),I=1,4) /
     +  0.966E+00, 0.107E+00, 0.360E+00, 0.347E+00 /
      DATA (TMP1(I, 82),I=1,4) /
     +  0.967E+00, 0.112E+00, 0.373E+00, 0.360E+00 /
      DATA (TMP1(I, 83),I=1,4) /
     +  0.968E+00, 0.117E+00, 0.387E+00, 0.373E+00 /
      DATA (TMP1(I, 84),I=1,4) /
     +  0.968E+00, 0.122E+00, 0.401E+00, 0.386E+00 /
      DATA (TMP1(I, 85),I=1,4) /
     +  0.969E+00, 0.128E+00, 0.415E+00, 0.399E+00 /
      DATA (TMP1(I, 86),I=1,4) /
     +  0.969E+00, 0.134E+00, 0.429E+00, 0.411E+00 /
      DATA (TMP1(I, 87),I=1,4) /
     +  0.970E+00, 0.139E+00, 0.443E+00, 0.424E+00 /
      DATA (TMP1(I, 88),I=1,4) /
     +  0.970E+00, 0.146E+00, 0.456E+00, 0.437E+00 /
      DATA (TMP1(I, 89),I=1,4) /
     +  0.971E+00, 0.153E+00, 0.468E+00, 0.450E+00 /
      DATA (TMP1(I, 90),I=1,4) /
     +  0.971E+00, 0.161E+00, 0.479E+00, 0.463E+00 /
      DATA (TMP1(I, 91),I=1,4) /
     +  0.972E+00, 0.162E+00, 0.472E+00, 0.476E+00 /
      DATA (TMP1(I, 92),I=1,4) /
     +  0.972E+00, 0.176E+00, 0.467E+00, 0.489E+00 /
      DATA (TMP1(I, 93),I=1,4) /
     +  0.973E+00, 0.187E+00, 0.466E+00, 0.502E+00 /
      DATA (TMP1(I, 94),I=1,4) /
     +  0.973E+00, 0.205E+00, 0.464E+00, 0.514E+00 /
      DATA (TMP1(I, 95),I=1,4) /
     +  0.974E+00, 0.218E+00, 0.471E+00, 0.526E+00 /
      DATA (TMP1(I, 96),I=1,4) /
     +  0.974E+00, 0.228E+00, 0.479E+00, 0.539E+00 /
      DATA (TMP1(I, 97),I=1,4) /
     +  0.975E+00, 0.236E+00, 0.485E+00, 0.550E+00 /
      DATA (TMP1(I, 98),I=1,4) /
     +  0.975E+00, 0.244E+00, 0.490E+00, 0.560E+00 /
      DATA (TMP1(I, 99),I=1,4) /
     +  0.975E+00, 0.253E+00, 0.497E+00, 0.570E+00 /
      DATA (TMP1(I,100),I=1,4) /
     +  0.976E+00, 0.263E+00, 0.506E+00, 0.579E+00 /
C
      DO 20 J = 1,MAXELZ
         DO 10 I = 1,ISHLS
            GPHRAT(I,J) = TMP(I,J)
   10    CONTINUE
   20 CONTINUE
C
      DO 30 I = 1,29
         ISHLTR(I) = ITRN(I)
   30 CONTINUE
C
      DO 40 I = 1,MAXELZ
         GFLUPR(1,I) = TMP1(1,I)
         GFLUPR(2,I) = TMP1(2,I)
         GFLUPR(3,I) = TMP1(3,I)
         GFLUPR(4,I) = TMP1(4,I)
   40 CONTINUE
C
C K shell decay mode
      DO 50 I = 5,MAXELZ
         IF(I.LT.8) THEN
            IGNRFN(1,I) = 2
            IGNRFN(2,I) = 2
         ELSEIF(I.LT.81) THEN
            IGNRFN(1,I) = 3
            IGNRFN(2,I) = 4
         ELSE
            IGNRFN(1,I) = 3
            IGNRFN(2,I) = 3
         ENDIF
   50 CONTINUE
C L1 shell decay mode
      DO 60 I = 11,MAXELZ
         IGNRFN(3,I) = 4
         IF(I.LT.24) THEN
            IGNRFN(4,I) = 5
         ELSEIF(I.LT.49) THEN
            IGNRFN(4,I) = 9
         ELSEIF(I.LT.53) THEN
            IGNRFN(4,I) = 10
         ELSE
            IGNRFN(4,I) = 14
         ENDIF
   60 CONTINUE
C L2 shell decay mode
      DO 70 I = 12,MAXELZ
         IF(I.LT.13) THEN
            IGNRFN(5,I) = 5
            IGNRFN(6,I) = 5
         ELSEIF(I.LT.16) THEN
            IGNRFN(5,I) = 5
            IGNRFN(6,I) = 6
         ELSEIF(I.LT.29) THEN
            IGNRFN(5,I) = 6
            IGNRFN(6,I) = 7
         ELSE
            IGNRFN(5,I) = 8
            IGNRFN(6,I) = 9
         ENDIF
   70 CONTINUE
C L3 shell decay mode
      DO 80 I = 12,MAXELZ
         IF(I.LT.13) THEN
            IGNRFN(7,I) = 5
            IGNRFN(8,I) = 5
         ELSEIF(I.LT.16) THEN
            IGNRFN(7,I) = 5
            IGNRFN(8,I) = 7
         ELSEIF(I.LT.30) THEN
            IGNRFN(7,I) = 7
            IGNRFN(8,I) = 7
         ELSE
            IGNRFN(7,I) = 8
            IGNRFN(8,I) = 9
         ENDIF
   80 CONTINUE
      END
+DECK,  GPHSG1, T=FORT.
* Revision 1.2  1999/01/20 13:37:00  japost
*   Changed
*       IPOINT = JPHXS+Q(JPHXS+1)*3+2
* to
*       IPOINT = JPHXS+INT(Q(JPHXS+1))*3+2
* to protect against large values that cannot be accurately treated as Reals
* > Date: Fri, 20 Nov 1998 17:31:34 -0600 (CST)
* > From: Shuichi Kunori <kunori@fsgi02.FNAL.GOV>
* >
* >We increased the GCBANK size from 12M words to 28M words and found a
* >problem in some G3 routines. For example, s/r GPHSG1 in gphys has a
* >line
* >
* >      IPOINT = JPHXS+Q(JPHXS+1)*3+2
* >
* >Since second term on the right has Q, the calculation is done in REAL.
* >If JPHYS is bigger than 16.7M (7 digits precision for real number),
* >the calculation overflows     [Actually it loses precision JApostolakis]
* >and produces meaningless address IPOINT.
* >Once we started using 28M for GCBANK, IPOINT was collapsed and producing
* >wrong cross section for photo effect. We found other cases similar to
* > this.
* Revision 1.1  1995/10/24 10:21:28  cernlib
* Initial revision

      FUNCTION GPHSG1(E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FUNCTION TO COMPUTE THE PHOTOEFFECT TOTAL CROSS-SECTION  *
C.    *       AS A FUNCTION OF E                                       *
C.    *                                                                *
C.    *    ==>CALLED BY : GPHOTI                                       *
C.    *                                                                *
C.    *    (1) Sandia parametrizsation is used;                        *
C.    *    (2) GPHSG1 in cm**2/g.                                      *
C.    *    (3) E in GeV                                                *
C.    *                                                                *
C.    *     J. Chwastowski 17.11.92                                    *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GC10EV.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION EINV,ECUR,ONE
+SELF.
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      RES = 0.
      IF(E.LT.G10EV) GO TO 20
C Use Sandia data
      JPHXS = LQ(JPHOT-1)
      IPOINT = JPHXS+INT(Q(JPHXS+1))*3+2
      IMAX = Q(IPOINT)
      IPOINT = IPOINT+1
      ECUR = E*1.E6
      IF(ECUR.LT.Q(IPOINT)) GO TO 20
      EINV = ONE/ECUR
      DO 10 I = 2,IMAX
         IPOINT = IPOINT+5
         IF(ECUR.LT.Q(IPOINT)) THEN
            J = IPOINT+1
            RES = EINV*(Q(J)+EINV*(Q(J+1)+EINV*(Q(J+2)+EINV*Q(J+3))))
            GO TO 20
         ENDIF
   10 CONTINUE
C This value is in cm**2/g
   20 GPHSG1 = MAX(RES,0.)
C
      END
+DECK,  GPHSG2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:30  cernlib
* Geant

      FUNCTION GPHSG2(E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FUNCTION TO COMPUTE THE PHOTOEFFECT TOTAL CROSS-SECTION  *
C.    *       AS A FUNCTION OF Z AND E                                 *
C.    *                                                                *
C.    *    ==>CALLED BY : special dE/dx                                *
C.    *                                                                *
C.    *    (1) Sandia parametrizsation is used;                        *
C.    *    (2) GPHSG2 in Megabarns                                     *
C.    *    (3) E in GeV                                                *
C.    *                                                                *
C.    *     J. Chwastowski 31.03.93                                    *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GC10EV.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION EINV,ECUR,ONE,RES,ZERO
+SELF.
      PARAMETER (ONE=1,ZERO=0)
C.
C.    ------------------------------------------------------------------
C.
      RES = 0.
      IF(E.LT.G10EV) GO TO 30
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      NZ     = Q(JPHXS+1)
      ECUR   = E*1E6
      EINV   = ONE/ECUR
      JWEIGH = JPHXS+2*NZ+1
      DO 20 JZ=1,NZ
         JPHFN   = LQ(JPHXS-JZ)
         IPOINT  = JPHFN+1
         IMAX    = Q(IPOINT)
         IPOINT  = IPOINT-4
         DO 10 I = 1,IMAX
            IPOINT = IPOINT+5
            IF(ECUR.LT.Q(IPOINT)) THEN
               J   = IPOINT+1
               RES = RES+Q(JWEIGH+JZ)*
     +         EINV*(Q(J)+EINV*(Q(J+1)+EINV*(Q(J+2)+EINV*Q(J+3))))
               GO TO 20
            ENDIF
   10    CONTINUE
   20 CONTINUE
C RES value is in cm**2/g
C Now in Megabarns
   30 GPHSG2 = MAX(RES,ZERO)*A/AVO*1E-6
C
      END
+DECK,  GPHSGP, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:30  cernlib
* Geant

      FUNCTION GPHSGP(IELEM,E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FUNCTION TO COMPUTE THE PHOTOEFFECT TOTAL CROSS-SECTION  *
C.    *       AS A FUNCTION OF Z AND E                                 *
C.    *                                                                *
C.    *    ==>CALLED BY : special dE/dx                                *
C.    *                                                                *
C.    *    (1) Sandia parametrizsation is used;                        *
C.    *    (2) GPHSGP in cm**/g                                        *
C.    *    (3) E in GeV                                                *
C.    *                                                                *
C.    *     J. Chwastowski 31.03.93                                    *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCUNIT.
+CDE, GC10EV.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION EINV,ECUR,ONE
+SELF.
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      RES = 0.
      IF(E.LT.G10EV) GO TO 20
C Use Sandia data
      JPHXS  = LQ(JPHOT-1)
      IF(IELEM.GT.IQ(JPHXS-2)) THEN
         WRITE(CHMAIL,10010) IELEM, IQ(JPHXS-2)
10010 FORMAT(' *** GPHSGP : element N ',I6,' requested, ',
     +'but only ',I6,' elements in present mixture')
         CALL GMAIL(0,0)
         GOTO 20
      ENDIF
      JPHXSI = LQ(JPHXS-IELEM)
      IPOINT = JPHXSI+1
      IMAX = Q(IPOINT)
      IPOINT = IPOINT+1
      ECUR = E*1.E6
      IF(ECUR.LT.Q(IPOINT)) GO TO 20
      EINV = ONE/ECUR
      DO 10 I = 2,IMAX
         IPOINT = IPOINT+5
         IF(ECUR.LT.Q(IPOINT)) THEN
            J = IPOINT+1
            RES = EINV*(Q(J)+EINV*(Q(J+1)+EINV*(Q(J+2)+EINV*Q(J+3))))
            GO TO 20
         ENDIF
   10 CONTINUE
C This value is in cm**2/g
   20 GPHSGP = MAX(RES,0.)
C
      END
+DECK,  GPHSIG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:30  cernlib
* Geant

      FUNCTION GPHSIG(Z,E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Function to compute the photoeffect total cross-section  *
C.    *       as a function of Z and E                                 *
C.    *           (E in GeV,  GPHSIG in barn)                          *
C.    *                                                                *
C.    *    ==>Called by : GPHOTI                                       *
C.    *       Author : L.Urban   *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION EK(4),EL1(4),EL2(4),C(19)
      DATA EK / 0.66644E-8 , 0.22077E-9 ,-0.32552E-11, 0.18199E-13/
      DATA EL1/-0.29179E-9 , 0.87983E-10,-0.12589E-11, 0.69602E-14/
      DATA EL2/-0.68606E-9 , 0.10078E-9 ,-0.14496E-11, 0.78809E-14/
      DATA C  /-0.88893E-6 , 0.24394E-8 , 0.28835E-6 , 0.12133E-7,
     +         -0.31104E-6 ,-0.17284E-9 , 0.14400E-7 , 0.68357E-7,
     +          0.73945E-12,-0.48149E-10, 0.55823E-9 ,-0.10089E-9,
     +         -0.10927E-5 ,-0.97897E-9 , 0.12854E-6 ,-0.45803E-5,
     +          0.16858E-10, 0.12013E-6 , 0.16924E-7/
      DATA AZ,BE/3.845,2.975/
C.
C.    ------------------------------------------------------------------
C.
      Z2=Z*Z
      X=EMASS/E
      EKZ=Z2*(EK(1)+Z*(EK(2)+Z*(EK(3)+Z*EK(4))))
      IF(E.GT.EKZ)THEN
         X2=X*X
         S=C(1)/Z+C(2)*X+C(3)+C(4)*Z+C(5)/X+C(6)*Z2+C(7)*Z/X+C(8)/X2+
     +     C(9)*Z2*Z+C(10)*Z2/X+C(11)*Z/X2+C(12)/(X2*X)
         GO TO 50
      ENDIF
C
      EL1Z=Z2*(EL1(1)+Z*(EL1(2)+Z*(EL1(3)+Z*EL1(4))))
      IF(E.GT.EL1Z)THEN
         S=C(13)/Z+C(14)*X+C(15)
         GO TO 50
      ENDIF
C
      EL2Z=Z2*(EL2(1)+Z*(EL2(2)+Z*(EL2(3)+Z*EL2(4))))
      IF(E.GT.EL2Z)THEN
         S=C(16)/Z+C(17)*X+C(18)
      ELSE
         S=C(19)
      ENDIF
C
  50  GPHSIG=S*Z**AZ*X**BE
      IF(GPHSIG.LT.0.)GPHSIG=0.
C
      END
+DECK,  GPHXIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:30  cernlib
* Geant

      SUBROUTINE GPHXIN
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize x-section constants for                       *
C.    *       the photoelectric effect                                 *
C.    *                                                                *
C.    *       The constants are from SANDIA REPORT SAND87-0070 UC-34   *
C.    *       by F. Biggs and R. Lighthill                             *
C.    *                                                                *
C.    *    ==>Called by : GPHINI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
      IMPLICIT NONE
+CDE, GCPMXZ.
+CDE, GCPHXS.
+CDE, GC10EV.
+CDE, GCONSP.
      INTEGER I,J,K
      REAL TMP,TMP1
      CHARACTER*6 CTMP(MAXINT,MAXELZ)
      DIMENSION TMP(MAXPOW,MAXINT,MAXELZ),TMP1(MAXELZ)
      DATA (CTMP(I,  1),I=1,MAXINT)
     +/ 'K     ','.1    ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  2),I=1,MAXINT)
     +/ 'K     ','.15   ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  3),I=1,MAXINT)
     +/ 'K     ','.8    ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  4),I=1,MAXINT)
     +/ 'K     ','.8    ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  5),I=1,MAXINT)
     +/ 'K     ','.8    ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  6),I=1,MAXINT)
     +/ '.0457 ','K     ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  7),I=1,MAXINT)
     +/ '.0404 ','K     ','.8    ','4.    ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I,  8),I=1,MAXINT)
     +/ '.0483 ','K     ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I,  9),I=1,MAXINT)
     +/ '.0724 ','K     ','4.    ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 10),I=1,MAXINT)
     +/ 'L3    ','L1    ','.124  ','K     ','4.    ','20.   '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 11),I=1,MAXINT)
     +/ 'L3    ','L1    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 12),I=1,MAXINT)
     +/ 'L3    ','.123  ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 13),I=1,MAXINT)
     +/ '.0159 ','L3    ','L1    ','K     ','20.   ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I, 14),I=1,MAXINT)
     +/ '.0305 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 15),I=1,MAXINT)
     +/ '.0306 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 16),I=1,MAXINT)
     +/ '.0341 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 17),I=1,MAXINT)
     +/ '.0436 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 18),I=1,MAXINT)
     +/ '.0362 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 19),I=1,MAXINT)
     +/ '.0305 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 20),I=1,MAXINT)
     +/ '.0305 ','L3    ','K     ','20.   ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 21),I=1,MAXINT)
     +/ 'M3    ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 22),I=1,MAXINT)
     +/ '.1    ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 23),I=1,MAXINT)
     +/ '.12   ','L3    ','L1    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 24),I=1,MAXINT)
     +/ '.106  ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 25),I=1,MAXINT)
     +/ '.1    ','L3    ','K     ','100.  ','500.  ','I     '
     +,7*'      ' /
      DATA (CTMP(I, 26),I=1,MAXINT)
     +/ '.024  ','.12   ','L3    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 27),I=1,MAXINT)
     +/ '.0308 ','.093  ','L3    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 28),I=1,MAXINT)
     +/ '.1    ','L3    ','L2    ','L1    ','K     ','100.  '
     +,'500.  ','I     ',5*'      ' /
      DATA (CTMP(I, 29),I=1,MAXINT)
     +/ '.1    ','L3    ','L1    ','K     ','100.  ','500.  '
     +,'I     ',6*'      ' /
      DATA (CTMP(I, 30),I=1,MAXINT)
     +/ '.0307 ','.109  ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 31),I=1,MAXINT)
     +/ '.0278 ','.086  ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 32),I=1,MAXINT)
     +/ '.0305 ','.1    ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 33),I=1,MAXINT)
     +/ '.0371 ','.1    ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 34),I=1,MAXINT)
     +/ '.0371 ','.114  ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 35),I=1,MAXINT)
     +/ '.035  ','.1    ','.5    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 36),I=1,MAXINT)
     +/ '.0305 ','.097  ','.3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 37),I=1,MAXINT)
     +/ '.0305 ','M5    ','.3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 38),I=1,MAXINT)
     +/ '.0307 ','M5    ','.3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 39),I=1,MAXINT)
     +/ '.0232 ','.1677 ','.8    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 40),I=1,MAXINT)
     +/ 'M5    ','.5    ','L3    ','L2    ','L1    ','K     '
     +,'100.  ','500.  ','I     ',4*'      ' /
      DATA (CTMP(I, 41),I=1,MAXINT)
     +/ '.0297 ','.2083 ','.9    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 42),I=1,MAXINT)
     +/ '.03   ','M5    ','.8    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 43),I=1,MAXINT)
     +/ '.068  ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 44),I=1,MAXINT)
     +/ '.0716 ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 45),I=1,MAXINT)
     +/ '.072  ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 46),I=1,MAXINT)
     +/ '.07   ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 47),I=1,MAXINT)
     +/ '.086  ','M5    ','M3    ','L3    ','L2    ','L1    '
     +,'K     ','100.  ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 48),I=1,MAXINT)
     +/ '.03   ','.098  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 49),I=1,MAXINT)
     +/ '.031  ','.103  ','M5    ','M2    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 50),I=1,MAXINT)
     +/ '.0318 ','.093  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 51),I=1,MAXINT)
     +/ '.0304 ','.096  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 52),I=1,MAXINT)
     +/ '.0528 ','.106  ','M5    ','M1    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 53),I=1,MAXINT)
     +/ '.034  ','.103  ','M5    ','M2    ','M1    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 54),I=1,MAXINT)
     +/ '.0515 ','.1073 ','M5    ','M3    ','M1    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 55),I=1,MAXINT)
     +/ '.0704 ','.111  ','M5    ','M2    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 56),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M2    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 57),I=1,MAXINT)
     +/ '.04   ','.13   ','M5    ','M3    ','M2    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 58),I=1,MAXINT)
     +/ '.053  ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 59),I=1,MAXINT)
     +/ '.04   ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 60),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M1    ','L3    '
     +,'L2    ','L1    ','K     ','100.  ','500.  ','I     ','      ' /
      DATA (CTMP(I, 61),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 62),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','100.  ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 63),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','100.  ','500.  ','I     ' /
      DATA (CTMP(I, 64),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 65),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 66),I=1,MAXINT)
     +/ '.0305 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 67),I=1,MAXINT)
     +/ '.0426 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 68),I=1,MAXINT)
     +/ '.0322 ','N5    ','M5    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I, 69),I=1,MAXINT)
     +/ '.031  ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 70),I=1,MAXINT)
     +/ '.075  ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 71),I=1,MAXINT)
     +/ '.09   ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 72),I=1,MAXINT)
     +/ '.0512 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 73),I=1,MAXINT)
     +/ '.0233 ','.0428 ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 74),I=1,MAXINT)
     +/ '.031  ','.0493 ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 75),I=1,MAXINT)
     +/ '.0384 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 76),I=1,MAXINT)
     +/ '.0464 ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 77),I=1,MAXINT)
     +/ '.048  ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 78),I=1,MAXINT)
     +/ '.0266 ','.0735 ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 79),I=1,MAXINT)
     +/ '.07   ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 80),I=1,MAXINT)
     +/ '.09   ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 81),I=1,MAXINT)
     +/ '.0313 ','.0985 ','.386  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 82),I=1,MAXINT)
     +/ '.0311 ','.095  ','.413  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 83),I=1,MAXINT)
     +/ 'O5    ','O4    ','.0379 ','.1136 ','.362  ','M5    '
     +,'M3    ','L3    ','L2    ','L1    ','K     ','500.  ','I     ' /
      DATA (CTMP(I, 84),I=1,MAXINT)
     +/ '.0305 ','.07   ','.2415 ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 85),I=1,MAXINT)
     +/ '.0305 ','.072  ','.244  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 86),I=1,MAXINT)
     +/ '.0466 ','.093  ','.305  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 87),I=1,MAXINT)
     +/ '.0494 ','.196  ','.525  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 88),I=1,MAXINT)
     +/ '.0579 ','.15   ','.396  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 89),I=1,MAXINT)
     +/ '.0712 ','.216  ','.375  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 90),I=1,MAXINT)
     +/ 'O5    ','N5    ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 91),I=1,MAXINT)
     +/ 'O5    ','.371  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 92),I=1,MAXINT)
     +/ '.0171 ','O5    ','.617  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 93),I=1,MAXINT)
     +/ 'O5    ','.431  ','M5    ','M3    ','L3    ','L2    '
     +,'L1    ','K     ','500.  ','I     ',3*'      ' /
      DATA (CTMP(I, 94),I=1,MAXINT)
     +/ '.0306 ','O5    ','.405  ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 95),I=1,MAXINT)
     +/ 'O5    ','.498  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 96),I=1,MAXINT)
     +/ 'O5    ','.498  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 97),I=1,MAXINT)
     +/ 'O5    ','.531  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 98),I=1,MAXINT)
     +/ 'O5    ','.548  ','N5    ','M5    ','M3    ','L3    '
     +,'L2    ','L1    ','K     ','500.  ','I     ',2*'      ' /
      DATA (CTMP(I, 99),I=1,MAXINT)
     +/ 'N5    ','M5    ','M4    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
      DATA (CTMP(I,100),I=1,MAXINT)
     +/ 'N5    ','M5    ','M4    ','M3    ','M2    ','M1    '
     +,'L3    ','L2    ','L1    ','K     ','500.  ','I     ','      ' /
C
C For HYDROGEN the parametrization is changed below K shell
C  Orig. SANDIA     +   0.1000E-07,  0.0000E+00,  0.0000E+00,  0.0000E+00
C  New param        +   0.0000E+00,  0.0000E+00,  0.0000E+00,  0.0000E+00
C
      DATA ((TMP(I,J,  1),I=1,MAXPOW),J=1,MAXINT) /
     +   0.0000E+00,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.6383E+02, -0.6446E+01,  0.1317E+02, -0.5045E-01
     + ,  0.3051E+01, -0.7818E+01,  0.1144E+02,  0.6959E-01
     + ,  0.7636E-01, -0.9406E+00,  0.6144E+01,  0.1425E+01
     + ,  0.1180E-02, -0.8230E-01,  0.2880E+01,  0.5534E+01
     + ,  0.1620E-04, -0.5610E-02,  0.1214E+01,  0.1761E+02
     + ,  0.1034E-05, -0.4114E-03,  0.6287E+00,  0.3927E+02
     + ,  0.4599E-06,  0.5006E-03, -0.1425E-01,  0.1960E+03,  20*0.0 /
      DATA ((TMP(I,J,  2),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1000E-07,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1196E+04,  0.4759E+03,  0.1979E+02, -0.3540E+00
     + ,  0.1857E+02, -0.4079E+02,  0.8609E+02, -0.2618E+01
     + ,  0.1606E+01, -0.1726E+02,  0.8101E+02, -0.4928E+01
     + ,  0.3663E-02, -0.3782E+00,  0.2288E+02,  0.6006E+02
     + ,  0.5934E-03, -0.1109E+00,  0.1388E+02,  0.1680E+03
     + ,  0.1120E-04, -0.3894E-02,  0.6136E+01,  0.4354E+03
     + ,  0.4921E-05,  0.1493E-02,  0.4725E+01,  0.7128E+03,  20*0.0 /
      DATA ((TMP(I,J,  3),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.2418E+03,  0.3530E+02, -0.2699E+00,  0.5580E-03
     + , -0.1474E+03,  0.1578E+03,  0.2036E+03, -0.8521E+01
     + ,  0.4375E+01, -0.5094E+02,  0.3053E+03, -0.3064E+02
     + ,  0.4040E-01, -0.2930E+01,  0.1293E+03,  0.1828E+03
     + ,  0.3139E-02, -0.6107E+00,  0.7342E+02,  0.6852E+03
     + ,  0.4823E-04, -0.1161E-01,  0.2898E+02,  0.2129E+04
     + ,  0.2128E-04,  0.1951E-01,  0.1009E+02,  0.7144E+04,  24*0.0 /
      DATA ((TMP(I,J,  4),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.2785E+03,  0.1252E+03, -0.1912E+01,  0.8371E-02
     + , -0.4798E+03,  0.6302E+03,  0.4187E+03, -0.2783E+02
     + ,  0.1037E+02, -0.1280E+03,  0.8807E+03, -0.1646E+03
     + ,  0.1018E+00, -0.8264E+01,  0.4158E+03,  0.4366E+03
     + ,  0.5893E-02, -0.1595E+01,  0.2644E+03,  0.1566E+04
     + ,  0.2129E-03, -0.7972E-01,  0.1155E+03,  0.6065E+04
     + ,  0.7797E-04,  0.7695E-01,  0.3396E+02,  0.2439E+05,  24*0.0 /
      DATA ((TMP(I,J,  5),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.3387E+03,  0.1923E+03, -0.2742E+01,  0.1204E-01
     + , -0.9943E+03,  0.1816E+04,  0.3939E+03, -0.1755E+02
     + ,  0.3689E+01, -0.8834E+02,  0.1525E+04, -0.2145E+03
     + ,  0.6447E+00, -0.3953E+02,  0.1281E+04,  0.1768E+03
     + ,  0.1852E-02, -0.1358E+01,  0.5252E+03,  0.5160E+04
     + ,  0.4282E-03, -0.1297E+00,  0.2892E+03,  0.1601E+05
     + ,  0.1965E-03,  0.1947E+00,  0.1001E+03,  0.5902E+05,  24*0.0 /
      DATA ((TMP(I,J,  6),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5704E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.3935E+03,  0.3219E+03, -0.6549E+01,  0.2086E+00
     + , -0.9022E+03,  0.1760E+04,  0.1549E+04, -0.2280E+03
     + , -0.7363E+01, -0.1537E+01,  0.2672E+04, -0.4482E+03
     + ,  0.1640E+01, -0.9428E+02,  0.2872E+04, -0.5583E+03
     + , -0.3742E-02, -0.1232E+01,  0.9489E+03,  0.1406E+05
     + ,  0.6760E-03, -0.1164E+00,  0.6566E+03,  0.2739E+05
     + ,  0.4503E-03,  0.4692E+00,  0.2183E+03,  0.1308E+06,  20*0.0 /
      DATA ((TMP(I,J,  7),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1010E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.3622E+03,  0.3873E+03,  0.1244E+02, -0.4452E+00
     + , -0.2338E+04,  0.5732E+04, -0.2082E+03,  0.1482E+03
     + , -0.4940E+01, -0.8442E+02,  0.4620E+04, -0.1186E+04
     + ,  0.2019E+01, -0.1249E+03,  0.4609E+04, -0.9421E+03
     + ,  0.1709E-01, -0.8196E+01,  0.2345E+04,  0.1369E+05
     + ,  0.1872E-02, -0.6732E+00,  0.1282E+04,  0.5700E+05
     + ,  0.8122E-03,  0.8364E+00,  0.4410E+03,  0.2358E+06,  20*0.0 /
      DATA ((TMP(I,J,  8),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1144E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2863E+03,  0.4086E+03,  0.4436E+02, -0.1782E+01
     + , -0.7181E+02,  0.4748E+03,  0.5542E+04, -0.1363E+04
     + ,  0.2745E+01, -0.1747E+03,  0.7159E+04, -0.2213E+04
     + ,  0.3774E-01, -0.1559E+02,  0.4045E+04,  0.1810E+05
     + ,  0.3169E-02, -0.1146E+01,  0.2194E+04,  0.9131E+05
     + ,  0.1367E-02,  0.1473E+01,  0.7214E+03,  0.4048E+06,  24*0.0 /
      DATA ((TMP(I,J,  9),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1129E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2676E+03,  0.4767E+03,  0.8767E+02, -0.4504E+01
     + , -0.8907E+02,  0.6850E+03,  0.7217E+04, -0.2022E+04
     + ,  0.2813E+01, -0.2020E+03,  0.9903E+04, -0.4454E+04
     + ,  0.6097E-01, -0.2435E+02,  0.6099E+04,  0.2258E+05
     + ,  0.4857E-02, -0.1806E+01,  0.3335E+04,  0.1285E+06
     + ,  0.2041E-02,  0.2257E+01,  0.1084E+04,  0.5997E+06,  24*0.0 /
      DATA ((TMP(I,J, 10),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1000E-05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8235E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.6059E+04,  0.3242E+04, -0.1796E+03,  0.3141E+01
     + , -0.1940E+03,  0.4340E+03,  0.2357E+03, -0.1666E+02
     + , -0.8680E+02,  0.7434E+03,  0.1077E+05, -0.3822E+04
     + ,  0.3167E+01, -0.2491E+03,  0.1439E+05, -0.8187E+04
     + ,  0.1288E+00, -0.4471E+02,  0.9862E+04,  0.2497E+05
     + ,  0.5202E-02,  0.7337E-01,  0.4614E+04,  0.2256E+06
     + ,  0.3087E-02,  0.3402E+01,  0.1569E+04,  0.1147E+07,  16*0.0 /
      DATA ((TMP(I,J, 11),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5429E+02,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8874E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.5565E+03,  0.1000E+04,  0.1062E+03, -0.6846E+01
     + ,  0.1732E+01, -0.1853E+03,  0.1712E+05, -0.8415E+04
     + ,  0.2726E+00, -0.8218E+02,  0.1475E+05,  0.9467E+04
     + ,  0.2083E-02,  0.4548E+01,  0.5521E+04,  0.3358E+06
     + ,  0.4199E-02,  0.4808E+01,  0.1793E+04,  0.1898E+07,  24*0.0 /
      DATA ((TMP(I,J, 12),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.5574E+03,  0.8687E+02, -0.1493E+01,  0.8660E-02
     + , -0.2726E+05,  0.9700E+04, -0.6921E+03,  0.1446E+02
     + , -0.6179E+03,  0.1379E+04,  0.2321E+03, -0.2291E+02
     + , -0.6648E+00, -0.1084E+03,  0.2219E+05, -0.1241E+05
     + ,  0.4080E+00, -0.1205E+03,  0.2139E+05, -0.1143E+03
     + ,  0.8338E-02,  0.2236E+01,  0.8819E+04,  0.4284E+06
     + ,  0.6233E-02,  0.7344E+01,  0.2662E+04,  0.2460E+07,  24*0.0 /
      DATA ((TMP(I,J, 13),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.1654E+05,  0.1585E+03,  0.3907E+01, -0.3383E-01
     + ,  0.1122E+04, -0.4015E+02,  0.6623E+00, -0.2813E-02
     + ,  0.2390E+05, -0.6953E+03, -0.7978E+02,  0.1974E+01
     + , -0.5284E+03,  0.1399E+04,  0.4360E+03, -0.4747E+02
     + , -0.3674E+01, -0.1622E+02,  0.2732E+05, -0.1752E+05
     + ,  0.4158E+00, -0.1351E+03,  0.2716E+05,  0.3723E+03
     + ,  0.1125E-01,  0.2747E+01,  0.1174E+05,  0.5695E+06
     + ,  0.8505E-02,  0.1041E+02,  0.4429E+04,  0.2413E+07,  20*0.0 /
      DATA ((TMP(I,J, 14),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4575E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1168E+03,  0.1269E+03, -0.5506E+01,  0.6616E-01
     + , -0.6451E+03,  0.1836E+04,  0.5350E+03, -0.6436E+02
     + , -0.4056E+01, -0.1089E+02,  0.3544E+05, -0.2595E+05
     + ,  0.4945E+00, -0.1682E+03,  0.3627E+05, -0.1605E+05
     + ,  0.2716E-01, -0.5428E+01,  0.1775E+05,  0.6765E+06
     + ,  0.1127E-01,  0.1376E+02,  0.4871E+04,  0.4477E+07,  24*0.0 /
      DATA ((TMP(I,J, 15),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4728E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2227E+03,  0.2204E+03, -0.1122E+02,  0.1569E+00
     + , -0.5700E+03,  0.1909E+04,  0.7651E+03, -0.1123E+03
     + , -0.6098E+01,  0.7712E+02,  0.4196E+05, -0.3437E+05
     + ,  0.5710E+00, -0.2001E+03,  0.4505E+05, -0.3853E+05
     + ,  0.3613E-01, -0.8426E+01,  0.2277E+05,  0.8080E+06
     + ,  0.1421E-01,  0.1770E+02,  0.6221E+04,  0.5554E+07,  24*0.0 /
      DATA ((TMP(I,J, 16),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5368E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2097E+03,  0.3174E+03, -0.1815E+02,  0.2796E+00
     + , -0.4885E+03,  0.1976E+04,  0.1206E+04, -0.1934E+03
     + , -0.1021E+02,  0.2346E+03,  0.5164E+05, -0.4707E+05
     + ,  0.7467E+00, -0.2534E+03,  0.5800E+05, -0.6691E+05
     + ,  0.6338E-01, -0.3443E+02,  0.4058E+05,  0.2233E+06
     + ,  0.1867E-01,  0.2398E+02,  0.6706E+04,  0.8358E+07,  24*0.0 /
      DATA ((TMP(I,J, 17),I=1,MAXPOW),J=1,MAXINT) /
     +   0.7808E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.6163E+02,  0.3934E+03, -0.2563E+02,  0.4396E+00
     + , -0.2147E+03,  0.1269E+04,  0.2099E+04, -0.3705E+03
     + , -0.1192E+02,  0.3253E+03,  0.5927E+05, -0.5980E+05
     + ,  0.8789E+00, -0.2920E+03,  0.6860E+05, -0.1018E+06
     + ,  0.6556E-01, -0.2175E+02,  0.3895E+05,  0.9737E+06
     + ,  0.2236E-01,  0.2884E+02,  0.9717E+04,  0.9001E+07,  24*0.0 /
      DATA ((TMP(I,J, 18),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1275E+05,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1674E+04,  0.1047E+04, -0.9010E+02,  0.2166E+01
     + , -0.2244E+03,  0.1388E+04,  0.2571E+04, -0.5113E+03
     + , -0.1446E+02,  0.4359E+03,  0.6578E+05, -0.7284E+05
     + ,  0.8786E+00, -0.3001E+03,  0.7682E+05, -0.1219E+06
     + ,  0.6779E-01, -0.2695E+02,  0.5069E+05,  0.5281E+06
     + ,  0.2598E-01,  0.3454E+02,  0.1059E+05,  0.1068E+08,  24*0.0 /
      DATA ((TMP(I,J, 19),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3111E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.6162E+02,  0.5770E+03, -0.4497E+02,  0.9218E+00
     + , -0.3601E+03,  0.2287E+04,  0.2513E+04, -0.4591E+03
     + , -0.2113E+02,  0.7161E+03,  0.8183E+05, -0.9859E+05
     + ,  0.1048E+01, -0.3644E+03,  0.9844E+05, -0.1760E+06
     + ,  0.1040E+00, -0.3553E+02,  0.6096E+05,  0.1226E+07
     + ,  0.3453E-01,  0.4621E+02,  0.1669E+05,  0.1238E+08,  24*0.0 /
      DATA ((TMP(I,J, 20),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3029E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3816E+03,  0.5887E+03, -0.4888E+02,  0.1019E+01
     + , -0.1054E+03,  0.1120E+04,  0.5115E+04, -0.1325E+04
     + , -0.3015E+02,  0.1141E+04,  0.9459E+05, -0.1195E+06
     + ,  0.1408E+01, -0.4553E+03,  0.1206E+06, -0.2531E+06
     + ,  0.1204E+00, -0.5356E+02,  0.8779E+05,  0.6252E+06
     + ,  0.4178E-01,  0.5761E+02,  0.1377E+05,  0.2019E+08,  24*0.0 /
      DATA ((TMP(I,J, 21),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1121E+04,  0.7413E+01, -0.3020E+00,  0.1510E-02
     + ,  0.2970E+03,  0.6359E+03, -0.4935E+02,  0.1044E+01
     + , -0.1507E+03,  0.1501E+04,  0.5139E+04, -0.1442E+04
     + ,  0.4615E+00, -0.2614E+03,  0.1217E+06, -0.2057E+06
     + ,  0.1509E+00, -0.6913E+02,  0.9253E+05,  0.1096E+07
     + ,  0.4833E-01,  0.6880E+02,  0.2762E+05,  0.1290E+08,  28*0.0 /
      DATA ((TMP(I,J, 22),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3596E+04, -0.6877E+02,  0.9609E+00, -0.4754E-02
     + , -0.3132E+03,  0.1024E+04, -0.1008E+03,  0.3096E+01
     + , -0.4626E+02,  0.8678E+03,  0.7308E+04, -0.2383E+04
     + ,  0.2074E+00, -0.2292E+03,  0.1371E+06, -0.2489E+06
     + ,  0.1972E+00, -0.9550E+02,  0.1106E+06,  0.1067E+07
     + ,  0.5606E-01,  0.8140E+02,  0.3106E+05,  0.1567E+08,  28*0.0 /
      DATA ((TMP(I,J, 23),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4117E+04, -0.1054E+03,  0.1531E+01, -0.7725E-02
     + , -0.4052E+03,  0.1169E+04, -0.1212E+03,  0.4148E+01
     + ,  0.9968E+04, -0.1796E+04, -0.1204E+04,  0.1481E+04
     + , -0.1429E+03,  0.1632E+04,  0.7203E+04, -0.2283E+04
     + ,  0.3940E+00, -0.2733E+03,  0.1564E+06, -0.3184E+06
     + ,  0.2007E+00, -0.8911E+02,  0.1254E+06,  0.1137E+07
     + ,  0.6449E-01,  0.9483E+02,  0.3584E+05,  0.1821E+08,  24*0.0 /
      DATA ((TMP(I,J, 24),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5069E+04, -0.7968E+02,  0.8395E+00, -0.4494E-02
     + , -0.4404E+03,  0.1301E+04, -0.1166E+03,  0.3481E+01
     + ,  0.3932E+02,  0.1537E+03,  0.1228E+05, -0.4984E+04
     + ,  0.2740E+00, -0.2665E+03,  0.1818E+06, -0.3997E+06
     + ,  0.2727E+00, -0.1288E+03,  0.1543E+06,  0.9755E+06
     + ,  0.7660E-01,  0.1142E+03,  0.4290E+05,  0.2161E+08,  28*0.0 /
      DATA ((TMP(I,J, 25),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5692E+04, -0.1278E+03,  0.1150E+01, -0.3774E-02
     + , -0.4901E+03,  0.1450E+04, -0.1365E+03,  0.4134E+01
     + , -0.3065E+02,  0.7209E+03,  0.1275E+05, -0.5462E+04
     + ,  0.2930E+00, -0.2703E+03,  0.2034E+06, -0.4886E+06
     + ,  0.2940E+00, -0.1342E+03,  0.1761E+06,  0.8747E+06
     + ,  0.8736E-01,  0.1322E+03,  0.4952E+05,  0.2436E+08,  28*0.0 /
      DATA ((TMP(I,J, 26),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.3328E+04,  0.2590E+03, -0.3812E+01,  0.1679E-01
     + ,  0.4132E+04,  0.3963E+03, -0.2505E+02,  0.3437E+00
     + , -0.2683E+02,  0.1250E+04, -0.7321E+02,  0.1137E+01
     + , -0.8128E+01,  0.6550E+03,  0.1511E+05, -0.7079E+04
     + ,  0.2151E+00, -0.2680E+03,  0.2341E+06, -0.6063E+06
     + ,  0.3511E+00, -0.1633E+03,  0.2090E+06,  0.7131E+06
     + ,  0.1026E+00,  0.1572E+03,  0.5901E+05,  0.2806E+08,  24*0.0 /
      DATA ((TMP(I,J, 27),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2074E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.6932E+04, -0.6765E-01, -0.9182E+01,  0.1423E+00
     + , -0.8228E+03,  0.1982E+04, -0.1782E+03,  0.4937E+01
     + ,  0.2092E+02,  0.3311E+03,  0.1820E+05, -0.9303E+04
     + ,  0.4947E-01, -0.2478E+03,  0.2586E+06, -0.7185E+06
     + ,  0.3588E+00, -0.1492E+03,  0.2296E+06,  0.8856E+06
     + ,  0.1154E+00,  0.1796E+03,  0.6740E+05,  0.3100E+08,  24*0.0 /
      DATA ((TMP(I,J, 28),I=1,MAXPOW),J=1,MAXINT) /
     +   0.8515E+04, -0.2121E+03,  0.2132E+01, -0.7667E-02
     + , -0.1021E+04,  0.2388E+04, -0.2361E+03,  0.7261E+01
     + ,  0.0000E+00,  0.6600E+04,  0.0000E+00,  0.0000E+00
     + ,  0.0000E+00,  0.9810E+04,  0.0000E+00,  0.0000E+00
     + , -0.1175E+03,  0.2171E+04,  0.1514E+05, -0.6042E+04
     + ,  0.1685E-01, -0.2522E+03,  0.3005E+06, -0.9000E+06
     + ,  0.4681E+00, -0.2085E+03,  0.2782E+06,  0.4399E+06
     + ,  0.1364E+00,  0.2148E+03,  0.8039E+05,  0.3626E+08,  20*0.0 /
      DATA ((TMP(I,J, 29),I=1,MAXPOW),J=1,MAXINT) /
     +   0.9992E+04, -0.3780E+03,  0.5657E+01, -0.2788E-01
     + , -0.8896E+03,  0.2391E+04, -0.1986E+03,  0.3649E+01
     + , -0.5089E+03,  0.4139E+04,  0.7468E+04, -0.6981E+03
     + , -0.9173E+02,  0.1862E+04,  0.1777E+05, -0.8202E+04
     + ,  0.7440E-02, -0.2371E+03,  0.3202E+06, -0.1028E+07
     + ,  0.4729E+00, -0.2055E+03,  0.3000E+06,  0.2182E+06
     + ,  0.1472E+00,  0.2345E+03,  0.8644E+05,  0.3990E+08,  24*0.0 /
      DATA ((TMP(I,J, 30),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1479E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1325E+05, -0.6762E+03,  0.1188E+02, -0.6785E-01
     + , -0.1330E+04,  0.3104E+04, -0.3092E+03,  0.8946E+01
     + , -0.2807E+05,  0.1091E+06, -0.1511E+06,  0.7897E+05
     + , -0.3057E+04,  0.1385E+05,  0.3780E+03, -0.2163E+03
     + , -0.8018E+02,  0.1794E+04,  0.2095E+05, -0.1070E+05
     + , -0.1158E+01, -0.3871E+02,  0.3499E+06, -0.1154E+07
     + ,  0.4820E+00, -0.1832E+03,  0.3296E+06,  0.6802E+06
     + ,  0.1669E+00,  0.2696E+03,  0.1000E+06,  0.4382E+08,  16*0.0 /
      DATA ((TMP(I,J, 31),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1479E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1211E+05, -0.7144E+03,  0.1535E+02, -0.1030E+00
     + , -0.1199E+04,  0.3215E+04, -0.3594E+03,  0.1152E+02
     + , -0.1457E+05,  0.6363E+05, -0.1011E+06,  0.6416E+05
     + ,  0.3470E+04, -0.8674E+04,  0.2548E+05, -0.8411E+04
     + , -0.9431E+02,  0.2078E+04,  0.2172E+05, -0.1101E+05
     + , -0.1253E+01, -0.2897E+02,  0.3783E+06, -0.1357E+07
     + ,  0.5591E+00, -0.2217E+03,  0.3625E+06,  0.3392E+06
     + ,  0.1949E+00,  0.2371E+03,  0.1767E+06,  0.2400E+08,  16*0.0 /
      DATA ((TMP(I,J, 32),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4941E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1269E+05, -0.9339E+03,  0.2767E+02, -0.1952E+00
     + , -0.1358E+04,  0.3695E+04, -0.4569E+03,  0.1599E+02
     + , -0.7402E+04,  0.3636E+05, -0.6670E+05,  0.5346E+05
     + , -0.3400E+03,  0.3232E+04,  0.1163E+05, -0.1089E+04
     + , -0.5940E+02,  0.1646E+04,  0.2621E+05, -0.1507E+05
     + , -0.2025E+01,  0.1283E+03,  0.4069E+06, -0.1510E+07
     + ,  0.6478E+00, -0.2603E+03,  0.4045E+06, -0.5153E+05
     + ,  0.2155E+00,  0.2609E+03,  0.2074E+06,  0.2220E+08,  16*0.0 /
      DATA ((TMP(I,J, 33),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2547E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2402E+05, -0.3110E+04,  0.1364E+03, -0.1877E+01
     + , -0.1536E+04,  0.4198E+04, -0.5497E+03,  0.1920E+02
     + , -0.4525E+04,  0.2468E+05, -0.5130E+05,  0.5102E+05
     + , -0.3858E+03,  0.1013E+05,  0.3603E+04, -0.7657E+03
     + , -0.5339E+02,  0.1649E+04,  0.2950E+05, -0.1800E+05
     + , -0.1655E+01,  0.8588E+02,  0.4504E+06, -0.1795E+07
     + ,  0.7880E+00, -0.3490E+03,  0.4641E+06, -0.1258E+07
     + ,  0.2393E+00,  0.2906E+03,  0.2360E+06,  0.2145E+08,  16*0.0 /
      DATA ((TMP(I,J, 34),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1577E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1806E+05, -0.2230E+04,  0.9408E+02, -0.1263E+01
     + , -0.1610E+04,  0.4614E+04, -0.6392E+03,  0.2252E+02
     + , -0.6637E+03,  0.4194E+04, -0.1104E+05,  0.2806E+05
     + , -0.4265E+03,  0.9660E+04,  0.5343E+04, -0.1174E+04
     + , -0.3968E+02,  0.1459E+04,  0.3327E+05, -0.2229E+05
     + , -0.3461E+01,  0.4401E+03,  0.4690E+06, -0.1943E+07
     + ,  0.8564E+00, -0.3723E+03,  0.5020E+06, -0.1430E+07
     + ,  0.2590E+00,  0.3237E+03,  0.2541E+06,  0.2321E+08,  16*0.0 /
      DATA ((TMP(I,J, 35),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2129E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1451E+05, -0.1941E+04,  0.8744E+02, -0.1214E+01
     + , -0.3534E+04,  0.6788E+04, -0.1134E+04,  0.5165E+02
     + , -0.3347E+03,  0.2195E+04,  0.1033E+04, -0.2839E+03
     + ,  0.1461E+03, -0.1050E+04,  0.3457E+04,  0.2000E+05
     + , -0.4318E+03,  0.1070E+05,  0.6548E+04, -0.1535E+04
     + , -0.4033E+02,  0.1607E+04,  0.3681E+05, -0.2478E+05
     + , -0.3955E+01,  0.5482E+03,  0.5202E+06, -0.2262E+07
     + ,  0.9718E+00, -0.4209E+03,  0.5662E+06, -0.2099E+07
     + ,  0.2907E+00,  0.3653E+03,  0.2908E+06,  0.2417E+08,  12*0.0 /
      DATA ((TMP(I,J, 36),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3691E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2024E+04, -0.2083E+03,  0.4439E+01,  0.1056E+00
     + ,  0.7648E+03,  0.5257E+04, -0.9960E+03,  0.4686E+02
     + , -0.2451E+03,  0.2199E+04,  0.1217E+04, -0.3120E+03
     + ,  0.3611E+03, -0.2974E+04,  0.1308E+05,  0.1268E+05
     + , -0.4163E+03,  0.1017E+05,  0.7535E+04, -0.1891E+04
     + , -0.9924E+00,  0.8455E-01,  0.4446E+05, -0.3490E+05
     + , -0.3076E+01,  0.4257E+03,  0.5613E+06, -0.2587E+07
     + ,  0.1050E+01, -0.4435E+03,  0.6114E+06, -0.3028E+07
     + ,  0.3136E+00,  0.3952E+03,  0.3252E+06,  0.2248E+08,  12*0.0 /
      DATA ((TMP(I,J, 37),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4606E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1441E+04, -0.1761E+03,  0.6821E+01,  0.4470E-01
     + , -0.6763E+03,  0.6772E+04, -0.1372E+04,  0.7035E+02
     + , -0.3457E+03,  0.2591E+04,  0.1242E+04, -0.3481E+03
     + ,  0.3524E+03, -0.3194E+04,  0.1657E+05,  0.1224E+05
     + , -0.4025E+03,  0.1067E+05,  0.8396E+04, -0.2275E+04
     + ,  0.5234E+01,  0.7494E+03,  0.5033E+05, -0.4276E+05
     + , -0.2207E+01,  0.2653E+03,  0.6269E+06, -0.3163E+07
     + ,  0.1101E+01, -0.4280E+03,  0.6664E+06, -0.3481E+07
     + ,  0.3467E+00,  0.4515E+03,  0.3525E+06,  0.2783E+08,  12*0.0 /
      DATA ((TMP(I,J, 38),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4850E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.7854E+03, -0.6513E+02,  0.2134E+01,  0.1138E+00
     + , -0.2484E+04,  0.8950E+04, -0.2019E+04,  0.1171E+03
     + , -0.3209E+03,  0.2818E+04,  0.1344E+04, -0.3984E+03
     + ,  0.2746E+03, -0.2830E+04,  0.2149E+05,  0.7655E+04
     + , -0.4181E+03,  0.1025E+05,  0.1159E+05, -0.3199E+04
     + , -0.4367E+02,  0.1966E+04,  0.4835E+05, -0.3788E+05
     + , -0.5177E+00, -0.2546E+02,  0.6941E+06, -0.3733E+07
     + ,  0.1296E+01, -0.5192E+03,  0.7384E+06, -0.5040E+07
     + ,  0.3800E+00,  0.4950E+03,  0.4110E+06,  0.1955E+08,  12*0.0 /
      DATA ((TMP(I,J, 39),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3854E+05, -0.1366E+04,  0.1672E+02, -0.6795E-01
     + ,  0.2849E+04, -0.2828E+03,  0.1529E+02, -0.1723E+00
     + , -0.6721E+04,  0.1290E+05, -0.3111E+04,  0.1985E+03
     + ,  0.3585E+03, -0.4223E+03,  0.6620E+04, -0.2706E+04
     + , -0.8813E+02,  0.1840E+04,  0.2198E+05, -0.1440E+04
     + , -0.4141E+03,  0.1043E+05,  0.1385E+05, -0.4020E+04
     + , -0.1282E+02,  0.1204E+04,  0.6028E+05, -0.5752E+05
     + ,  0.4265E+00, -0.1646E+03,  0.7684E+06, -0.4421E+07
     + ,  0.1334E+01, -0.4917E+03,  0.8066E+06, -0.5879E+07
     + ,  0.4194E+00,  0.5651E+03,  0.4353E+06,  0.2981E+08,  12*0.0 /
      DATA ((TMP(I,J, 40),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2993E+03,  0.1449E+03, -0.3012E+01,  0.1713E-01
     + , -0.7040E+04,  0.1434E+05, -0.3926E+04,  0.2887E+03
     + , -0.1647E+03,  0.2296E+04,  0.3166E+04, -0.1127E+04
     + , -0.2164E+03,  0.3512E+04,  0.2053E+05, -0.3382E+04
     + , -0.3996E+03,  0.1064E+05,  0.1548E+05, -0.4776E+04
     + , -0.3011E+02,  0.1794E+04,  0.6153E+05, -0.5699E+05
     + , -0.5900E+00,  0.1945E+03,  0.8031E+06, -0.4579E+07
     + ,  0.1474E+01, -0.5530E+03,  0.8907E+06, -0.7927E+07
     + ,  0.4562E+00,  0.6248E+03,  0.4760E+06,  0.3216E+08,  16*0.0 /
      DATA ((TMP(I,J, 41),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3251E+04, -0.6844E+02,  0.1575E+01, -0.1094E-01
     + ,  0.2764E+04, -0.4897E+03,  0.4237E+02, -0.8372E+00
     + , -0.2018E+04,  0.8543E+04, -0.1769E+04,  0.2770E+02
     + ,  0.2150E+03,  0.4490E+03,  0.6409E+04, -0.2429E+04
     + , -0.2981E+03,  0.6188E+04,  0.1735E+05, -0.4420E+04
     + , -0.3923E+03,  0.1102E+05,  0.1751E+05, -0.5733E+04
     + , -0.1658E+02,  0.1435E+04,  0.7050E+05, -0.7037E+05
     + , -0.2292E+01,  0.5516E+03,  0.8555E+06, -0.5018E+07
     + ,  0.1599E+01, -0.5764E+03,  0.9643E+06, -0.8517E+07
     + ,  0.4986E+00,  0.7224E+03,  0.4910E+06,  0.4104E+08,  12*0.0 /
      DATA ((TMP(I,J, 42),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.3508E+04,  0.3050E+03, -0.4620E+01,  0.1998E-01
     + ,  0.3053E+04, -0.6192E+03,  0.5104E+02, -0.9955E+00
     + , -0.7786E+04,  0.1722E+05, -0.5215E+04,  0.3992E+03
     + , -0.1114E+03,  0.1895E+04,  0.5405E+04, -0.2261E+04
     + , -0.3027E+03,  0.7576E+04,  0.1570E+05, -0.4795E+04
     + , -0.3784E+03,  0.1099E+05,  0.1983E+05, -0.6801E+04
     + , -0.1840E+02,  0.1552E+04,  0.7635E+05, -0.8181E+05
     + , -0.2256E+01,  0.7317E+03,  0.9005E+06, -0.5349E+07
     + ,  0.1540E+01, -0.4834E+03,  0.1021E+07, -0.9300E+07
     + ,  0.5359E+00,  0.7662E+03,  0.5243E+06,  0.5200E+08,  12*0.0 /
      DATA ((TMP(I,J, 43),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2680E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.7592E+03,  0.8677E+03, -0.1346E+03,  0.6198E+01
     + , -0.3269E+05,  0.4110E+05, -0.1328E+05,  0.1384E+04
     + , -0.3863E+03,  0.3458E+04,  0.3500E+04, -0.1341E+04
     + , -0.2871E+03,  0.7198E+04,  0.1867E+05, -0.5767E+04
     + , -0.1101E+03,  0.1625E+05,  0.3183E+04, -0.1491E+04
     + , -0.2936E+02,  0.1924E+04,  0.7955E+05, -0.8669E+05
     + ,  0.5721E+00,  0.7164E+02,  0.1004E+07, -0.6678E+07
     + ,  0.1769E+01, -0.5691E+03,  0.1097E+07, -0.1069E+08
     + ,  0.5748E+00,  0.8119E+03,  0.6113E+06,  0.3605E+08,  12*0.0 /
      DATA ((TMP(I,J, 44),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2116E+04,  0.1001E+03, -0.2614E+01,  0.1466E-01
     + ,  0.1947E+03,  0.7270E+03, -0.1490E+03,  0.8092E+01
     + , -0.2141E+05,  0.2872E+05, -0.8592E+04,  0.8312E+03
     + , -0.2430E+01,  0.2793E+04,  0.5237E+04, -0.2042E+04
     + , -0.2831E+03,  0.7880E+04,  0.1913E+05, -0.6518E+04
     + , -0.3547E+03,  0.1093E+05,  0.2575E+05, -0.9586E+04
     + , -0.1311E+02,  0.1428E+04,  0.9237E+05, -0.1148E+06
     + ,  0.1007E-01,  0.1277E+03,  0.1086E+07, -0.7755E+07
     + ,  0.1633E+01, -0.4030E+03,  0.1144E+07, -0.9817E+07
     + ,  0.6218E+00,  0.9117E+03,  0.5873E+06,  0.6614E+08,  12*0.0 /
      DATA ((TMP(I,J, 45),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2535E+04,  0.1329E+03, -0.3193E+01,  0.1648E-01
     + , -0.1037E+04,  0.1357E+04, -0.2412E+03,  0.1212E+02
     + ,  0.1155E+04,  0.3456E+04,  0.8529E+03, -0.3075E+03
     + , -0.4773E+03,  0.3678E+04,  0.5261E+04, -0.2225E+04
     + , -0.2665E+03,  0.7197E+04,  0.2390E+05, -0.7946E+04
     + , -0.3285E+03,  0.9342E+04,  0.3454E+05, -0.1203E+05
     + , -0.2532E+02,  0.2009E+04,  0.9447E+05, -0.1115E+06
     + , -0.3043E+01,  0.9079E+03,  0.1126E+07, -0.8086E+07
     + ,  0.1870E+01, -0.4570E+03,  0.1251E+07, -0.1191E+08
     + ,  0.6726E+00,  0.9644E+03,  0.7281E+06,  0.4409E+08,  12*0.0 /
      DATA ((TMP(I,J, 46),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1095E+05, -0.2552E+03,  0.1914E+01, -0.3916E-02
     + ,  0.2418E+04,  0.9664E+02, -0.1050E+03,  0.9047E+01
     + , -0.1605E+05,  0.3107E+05, -0.1240E+05,  0.1658E+04
     + , -0.4705E+03,  0.3846E+04,  0.5959E+04, -0.2639E+04
     + , -0.2530E+03,  0.7129E+04,  0.2620E+05, -0.9068E+04
     + , -0.3225E+03,  0.1001E+05,  0.3550E+05, -0.1354E+05
     + ,  0.1642E+02,  0.4603E+03,  0.1181E+06, -0.1737E+06
     + , -0.2888E+01,  0.8714E+03,  0.1203E+07, -0.9306E+07
     + ,  0.1857E+01, -0.3662E+03,  0.1308E+07, -0.1219E+08
     + ,  0.7151E+00,  0.1066E+04,  0.7318E+06,  0.6061E+08,  12*0.0 /
      DATA ((TMP(I,J, 47),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1054E+05, -0.1973E+03,  0.1033E+01, -0.6574E-03
     + , -0.4089E+04,  0.3916E+04, -0.8005E+03,  0.4841E+02
     + , -0.2951E+04,  0.6256E+04,  0.1909E+04, -0.8620E+03
     + , -0.2321E+02,  0.1892E+04,  0.9451E+04, -0.4150E+04
     + , -0.2547E+03,  0.7851E+04,  0.2733E+05, -0.1038E+05
     + , -0.3170E+03,  0.1045E+05,  0.3850E+05, -0.1560E+05
     + , -0.1817E+01,  0.1265E+04,  0.1192E+06, -0.1684E+06
     + , -0.4061E+01,  0.1339E+04,  0.1260E+07, -0.9752E+07
     + ,  0.2065E+01, -0.4444E+03,  0.1433E+07, -0.1533E+08
     + ,  0.7734E+00,  0.1157E+04,  0.8006E+06,  0.6214E+08,  12*0.0 /
      DATA ((TMP(I,J, 48),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1876E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8550E+04, -0.2785E+03,  0.2021E+01,  0.1032E-01
     + ,  0.4933E+03,  0.1167E+04, -0.3452E+03,  0.2759E+02
     + ,  0.2088E+04,  0.3036E+04,  0.1247E+04, -0.2691E+03
     + ,  0.7508E+01,  0.2031E+04,  0.1014E+05, -0.4621E+04
     + , -0.2454E+03,  0.8162E+04,  0.2822E+05, -0.1156E+05
     + , -0.2677E+03,  0.8244E+04,  0.4935E+05, -0.1791E+05
     + , -0.2306E+02,  0.2129E+04,  0.1161E+06, -0.1547E+06
     + , -0.8206E+01,  0.2269E+04,  0.1268E+07, -0.9746E+07
     + ,  0.2254E+01, -0.4904E+03,  0.1506E+07, -0.1642E+08
     + ,  0.8123E+00,  0.1229E+04,  0.8686E+06,  0.5293E+08,  8*0.0 /
      DATA ((TMP(I,J, 49),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1702E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2333E+05, -0.1510E+04,  0.3498E+02, -0.2775E+00
     + , -0.4354E+04,  0.4933E+04, -0.1221E+04,  0.9073E+02
     + , -0.2048E+04,  0.9964E+04, -0.2857E+04,  0.7223E+03
     + , -0.1763E+03,  0.3053E+04,  0.9756E+04, -0.4718E+04
     + , -0.2324E+03,  0.7725E+04,  0.3333E+05, -0.1361E+05
     + , -0.2675E+03,  0.8828E+04,  0.5249E+05, -0.2065E+05
     + , -0.2149E+02,  0.2143E+04,  0.1256E+06, -0.1775E+06
     + , -0.2097E+01,  0.1045E+04,  0.1428E+07, -0.1216E+08
     + ,  0.2233E+01, -0.3526E+03,  0.1578E+07, -0.1747E+08
     + ,  0.8685E+00,  0.1331E+04,  0.9171E+06,  0.6234E+08,  8*0.0 /
      DATA ((TMP(I,J, 50),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1857E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3071E+05, -0.2069E+04,  0.4886E+02, -0.3894E+00
     + ,  0.6119E+02,  0.1769E+04, -0.5287E+03,  0.4438E+02
     + ,  0.2325E+04,  0.2905E+04,  0.1395E+04, -0.1160E+03
     + , -0.8411E+03,  0.7174E+04,  0.3429E+04, -0.1945E+04
     + , -0.2078E+03,  0.6795E+04,  0.3953E+05, -0.1546E+05
     + , -0.2735E+03,  0.1006E+05,  0.5154E+05, -0.2316E+05
     + ,  0.1409E+02,  0.5245E+03,  0.1554E+06, -0.2738E+06
     + , -0.6053E+01,  0.2153E+04,  0.1430E+07, -0.1218E+08
     + ,  0.2434E+01, -0.4441E+03,  0.1694E+07, -0.2116E+08
     + ,  0.9156E+00,  0.1438E+04,  0.9506E+06,  0.6990E+08,  8*0.0 /
      DATA ((TMP(I,J, 51),I=1,MAXPOW),J=1,MAXINT) /
     +   0.7076E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2538E+05, -0.2014E+04,  0.5518E+02, -0.5093E+00
     + , -0.2753E+04,  0.3809E+04, -0.9187E+03,  0.6404E+02
     + ,  0.4191E+04,  0.1201E+04,  0.6138E+03,  0.8057E+03
     + ,  0.9566E+02,  0.1292E+04,  0.1534E+05, -0.8151E+04
     + , -0.2154E+03,  0.7884E+04,  0.3884E+05, -0.1742E+05
     + , -0.2413E+03,  0.8640E+04,  0.6267E+05, -0.2629E+05
     + , -0.2300E+02,  0.2351E+04,  0.1410E+06, -0.2130E+06
     + , -0.9816E+01,  0.3157E+04,  0.1443E+07, -0.1193E+08
     + ,  0.2470E+01, -0.3671E+03,  0.1779E+07, -0.2260E+08
     + ,  0.9713E+00,  0.1520E+04,  0.1016E+07,  0.7466E+08,  8*0.0 /
      DATA ((TMP(I,J, 52),I=1,MAXPOW),J=1,MAXINT) /
     +   0.9416E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.5818E+05,  0.1470E+05, -0.1039E+04,  0.2257E+02
     + , -0.2734E+04,  0.3947E+04, -0.9985E+03,  0.7313E+02
     + , -0.1058E+06,  0.2917E+06, -0.2491E+06,  0.7124E+05
     + , -0.4397E+02,  0.2059E+04,  0.1571E+05, -0.9021E+04
     + , -0.1946E+03,  0.7129E+04,  0.4399E+05, -0.1939E+05
     + , -0.2372E+03,  0.9166E+04,  0.6308E+05, -0.2911E+05
     + ,  0.1086E+01,  0.1149E+04,  0.1640E+06, -0.2950E+06
     + , -0.3401E+01,  0.1832E+04,  0.1571E+07, -0.1426E+08
     + ,  0.2389E+01, -0.1733E+03,  0.1798E+07, -0.2273E+08
     + ,  0.1007E+01,  0.1586E+04,  0.1076E+07,  0.7154E+08,  8*0.0 /
      DATA ((TMP(I,J, 53),I=1,MAXPOW),J=1,MAXINT) /
     +   0.7020E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2410E+05, -0.2114E+04,  0.6324E+02, -0.6266E+00
     + , -0.2554E+04,  0.4115E+04, -0.1059E+04,  0.7800E+02
     + , -0.4564E+05,  0.1181E+06, -0.9050E+05,  0.2490E+05
     + ,  0.1940E+05, -0.1268E+05, -0.1443E+05,  0.1681E+05
     + , -0.1016E+04,  0.1150E+05, -0.8322E+04,  0.1024E+05
     + , -0.1833E+03,  0.6763E+04,  0.5201E+05, -0.2240E+05
     + , -0.2150E+03,  0.8275E+04,  0.7525E+05, -0.3297E+05
     + , -0.2566E+02,  0.2615E+04,  0.1595E+06, -0.2556E+06
     + , -0.3670E+01,  0.1872E+04,  0.1719E+07, -0.1646E+08
     + ,  0.2225E+01,  0.1829E+03,  0.1881E+07, -0.2157E+08
     + ,  0.1098E+01,  0.1755E+04,  0.1154E+07,  0.8971E+08,  4*0.0 /
      DATA ((TMP(I,J, 54),I=1,MAXPOW),J=1,MAXINT) /
     +   0.6262E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.7578E+05, -0.1206E+05,  0.6503E+03, -0.1177E+02
     + , -0.1456E+04,  0.3607E+04, -0.1050E+04,  0.8562E+02
     + ,  0.5494E+05, -0.4316E+05, -0.3353E+05,  0.3122E+05
     + , -0.2422E+05,  0.6454E+05, -0.3914E+05,  0.8599E+04
     + , -0.6606E+03,  0.7269E+04,  0.6119E+04, -0.3383E+04
     + , -0.1565E+03,  0.5749E+04,  0.5985E+05, -0.2396E+05
     + , -0.2236E+03,  0.9444E+04,  0.7463E+05, -0.3742E+05
     + , -0.2010E+02,  0.2400E+04,  0.1720E+06, -0.2977E+06
     + , -0.1622E+01,  0.1830E+04,  0.1780E+07, -0.1721E+08
     + ,  0.2082E+01,  0.3625E+03,  0.1962E+07, -0.2448E+08
     + ,  0.1148E+01,  0.1892E+04,  0.1133E+07,  0.1244E+09,  4*0.0 /
      DATA ((TMP(I,J, 55),I=1,MAXPOW),J=1,MAXINT) /
     +   0.6813E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1642E+06, -0.2922E+05,  0.1724E+04, -0.3361E+02
     + , -0.2400E+04,  0.4936E+04, -0.1531E+04,  0.1354E+03
     + ,  0.1295E+05, -0.7423E+04, -0.6620E+04,  0.9125E+04
     + ,  0.6121E+03, -0.1572E+04,  0.2712E+05, -0.1563E+05
     + , -0.8402E+02,  0.2872E+04,  0.7699E+05, -0.1853E+05
     + , -0.2254E+03,  0.1010E+05,  0.7940E+05, -0.4284E+05
     + , -0.1987E+01,  0.1400E+04,  0.2040E+06, -0.4166E+06
     + , -0.4238E+01,  0.2444E+04,  0.1873E+07, -0.1899E+08
     + ,  0.2278E+01,  0.4044E+03,  0.2085E+07, -0.2635E+08
     + ,  0.1226E+01,  0.2030E+04,  0.1249E+07,  0.1169E+09,  8*0.0 /
      DATA ((TMP(I,J, 56),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5765E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1759E+04, -0.2331E+03,  0.9598E+01,  0.3960E-01
     + , -0.4276E+03,  0.2995E+04, -0.9837E+03,  0.8771E+02
     + ,  0.6154E+04,  0.1190E+04, -0.2858E+03,  0.1593E+04
     + ,  0.2420E+03, -0.4033E+03,  0.3138E+05, -0.2304E+05
     + , -0.1084E+03,  0.4043E+04,  0.7718E+05, -0.2532E+05
     + , -0.1836E+03,  0.7952E+04,  0.9545E+05, -0.4532E+05
     + ,  0.8708E+01,  0.7581E+03,  0.2258E+06, -0.5011E+06
     + , -0.5846E+01,  0.3162E+04,  0.1902E+07, -0.1948E+08
     + ,  0.2590E+01,  0.2297E+03,  0.2236E+07, -0.3193E+08
     + ,  0.1281E+01,  0.2144E+04,  0.1303E+07,  0.1193E+09,  8*0.0 /
      DATA ((TMP(I,J, 57),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4514E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2741E+05, -0.4218E+04,  0.2117E+03, -0.3183E+01
     + , -0.1231E+04,  0.4053E+04, -0.1329E+04,  0.1203E+03
     + ,  0.2431E+04,  0.3780E+04,  0.2792E+04, -0.2167E+03
     + , -0.4024E+03,  0.8837E+04,  0.2398E+04, -0.4154E+03
     + , -0.2694E+03,  0.4549E+04,  0.1944E+05, -0.1264E+05
     + , -0.9085E+02,  0.3459E+04,  0.8639E+05, -0.2558E+05
     + , -0.1485E+03,  0.6357E+04,  0.1121E+06, -0.4626E+05
     + , -0.6527E+01,  0.1901E+04,  0.2209E+06, -0.4602E+06
     + , -0.7588E+01,  0.3685E+04,  0.1991E+07, -0.2054E+08
     + ,  0.2727E+01,  0.3137E+03,  0.2346E+07, -0.3362E+08
     + ,  0.1365E+01,  0.2298E+04,  0.1393E+07,  0.1220E+09,  4*0.0 /
      DATA ((TMP(I,J, 58),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1542E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2448E+05, -0.5012E+04,  0.3411E+03, -0.7413E+01
     + , -0.1622E+04,  0.4662E+04, -0.1505E+04,  0.1385E+03
     + ,  0.5551E+05, -0.1769E+06,  0.2024E+06, -0.7125E+05
     + ,  0.4656E+04,  0.6580E+04, -0.3256E+04,  0.8079E+03
     + , -0.2828E+03,  0.1019E+05,  0.2005E+04, -0.4180E+03
     + ,  0.3264E+03, -0.7440E+03,  0.3609E+05,  0.2685E+05
     + , -0.7263E+02,  0.2822E+04,  0.9606E+05, -0.2458E+05
     + , -0.1695E+03,  0.8899E+04,  0.1139E+06, -0.5644E+05
     + ,  0.1939E+02,  0.3799E+03,  0.2661E+06, -0.6583E+06
     + , -0.1029E+02,  0.4409E+04,  0.2101E+07, -0.2280E+08
     + ,  0.2723E+01,  0.4916E+03,  0.2494E+07, -0.3595E+08
     + ,  0.1464E+01,  0.2444E+04,  0.1486E+07,  0.1376E+09
     +/
      DATA ((TMP(I,J, 59),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3935E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.5885E+02,  0.5060E+02,  0.1142E+02, -0.2858E+00
     + , -0.2475E+04,  0.8072E+04, -0.2077E+04,  0.2099E+03
     + , -0.6489E+04,  0.2485E+05, -0.1060E+05,  0.2589E+04
     + , -0.5349E+03,  0.8049E+04,  0.5499E+04, -0.9313E+03
     + , -0.3829E+03,  0.1003E+05,  0.3437E+04, -0.7202E+03
     + ,  0.1158E+03,  0.1754E+04,  0.2978E+05, -0.2081E+05
     + , -0.4523E+02,  0.1773E+04,  0.1075E+06, -0.1884E+05
     + , -0.1401E+03,  0.6504E+04,  0.1315E+06, -0.5758E+05
     + ,  0.8492E+01,  0.8664E+03,  0.2819E+06, -0.7256E+06
     + , -0.9126E+01,  0.4223E+04,  0.2290E+07, -0.2709E+08
     + ,  0.3207E+01,  0.3424E+03,  0.2697E+07, -0.4123E+08
     + ,  0.1557E+01,  0.2710E+04,  0.1566E+07,  0.1383E+09
     +/
      DATA ((TMP(I,J, 60),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2269E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1142E+04,  0.4035E+03, -0.1726E+02,  0.2479E+00
     + , -0.4138E+03,  0.3657E+04, -0.1265E+04,  0.1287E+03
     + ,  0.1241E+05, -0.6608E+04, -0.8545E+04,  0.1174E+05
     + ,  0.2239E+03,  0.1119E+05, -0.1181E+04,  0.2885E+03
     + , -0.3530E+03,  0.6609E+04,  0.1641E+05, -0.7462E+04
     + , -0.6644E+02,  0.2796E+04,  0.1098E+06, -0.2924E+05
     + , -0.1114E+03,  0.5206E+04,  0.1457E+06, -0.5559E+05
     + ,  0.8287E+01,  0.9600E+03,  0.2935E+06, -0.7637E+06
     + , -0.9944E+01,  0.4886E+04,  0.2320E+07, -0.2702E+08
     + ,  0.3820E+01,  0.8492E+02,  0.2868E+07, -0.4750E+08
     + ,  0.1633E+01,  0.2833E+04,  0.1759E+07,  0.9295E+08,  4*0.0 /
      DATA ((TMP(I,J, 61),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2285E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3175E+04, -0.4311E+03,  0.2911E+02, -0.5124E+00
     + , -0.7108E+03,  0.4102E+04, -0.1397E+04,  0.1482E+03
     + , -0.5546E+03,  0.7912E+04,  0.4958E+04, -0.7606E+03
     + , -0.5157E+03,  0.8937E+04,  0.6066E+04, -0.1148E+04
     + , -0.4607E+03,  0.9760E+04,  0.6028E+04, -0.1298E+04
     + , -0.1912E+03,  0.5138E+04,  0.2120E+05, -0.1345E+05
     + , -0.7165E+02,  0.3169E+04,  0.1166E+06, -0.3499E+05
     + , -0.2589E+03,  0.8215E+04, -0.1102E+06,  0.1824E+07
     + , -0.4251E+02,  0.4740E+04,  0.2377E+06, -0.4279E+06
     + ,  0.9003E-01,  0.2739E+04,  0.2641E+07, -0.3336E+08
     + ,  0.2857E+01,  0.1090E+04,  0.2888E+07, -0.4432E+08
     + ,  0.1742E+01,  0.3069E+04,  0.1744E+07,  0.1719E+09
     +/
      DATA ((TMP(I,J, 62),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1754E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1174E+04,  0.1370E+03, -0.4815E+01,  0.3574E-01
     + , -0.1315E+04,  0.5218E+04, -0.1900E+04,  0.2181E+03
     + , -0.5499E+03,  0.7881E+04,  0.5664E+04, -0.8952E+03
     + , -0.1126E+03,  0.3912E+04,  0.3230E+05, -0.2774E+05
     + , -0.3580E+02,  0.1576E+04,  0.1290E+06, -0.2201E+05
     + , -0.6400E+02,  0.3084E+04,  0.1751E+06, -0.4595E+05
     + ,  0.7096E+01,  0.1071E+04,  0.3267E+06, -0.9193E+06
     + , -0.1082E+02,  0.5919E+04,  0.2475E+07, -0.2997E+08
     + ,  0.3844E+01,  0.4077E+03,  0.3137E+07, -0.5576E+08
     + ,  0.1799E+01,  0.3181E+04,  0.1898E+07,  0.1263E+09,  8*0.0 /
      DATA ((TMP(I,J, 63),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2047E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.4276E+04, -0.4382E+03,  0.2276E+02, -0.3499E+00
     + , -0.4678E+03,  0.4034E+04, -0.1326E+04,  0.1388E+03
     + , -0.5507E+03,  0.7936E+04,  0.6518E+04, -0.1058E+04
     + , -0.4589E+03,  0.1019E+05,  0.5669E+04, -0.1234E+04
     + , -0.4913E+03,  0.8740E+04,  0.1016E+05, -0.2142E+04
     + , -0.2288E+03,  0.5934E+04,  0.2154E+05, -0.1326E+05
     + , -0.2466E+02,  0.1115E+04,  0.1400E+06, -0.1768E+05
     + , -0.6266E+02,  0.3143E+04,  0.1878E+06, -0.5089E+05
     + , -0.4306E+01,  0.2026E+04,  0.3280E+06, -0.9012E+06
     + , -0.7610E+01,  0.5488E+04,  0.2642E+07, -0.3287E+08
     + ,  0.3783E+01,  0.7655E+03,  0.3245E+07, -0.5731E+08
     + ,  0.1904E+01,  0.3400E+04,  0.2020E+07,  0.1315E+09
     +/
      DATA ((TMP(I,J, 64),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1620E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1627E+04,  0.8320E+02, -0.5112E+01,  0.7828E-01
     + , -0.2404E+04,  0.7220E+04, -0.2684E+04,  0.2976E+03
     + , -0.5394E+03,  0.7849E+04,  0.7295E+04, -0.1216E+04
     + , -0.4486E+03,  0.1029E+05,  0.6091E+04, -0.1380E+04
     + , -0.4679E+03,  0.9424E+04,  0.9571E+04, -0.2201E+04
     + , -0.3017E+03,  0.6938E+04,  0.1944E+05, -0.1104E+05
     + , -0.5768E+02,  0.2841E+04,  0.1366E+06, -0.4131E+05
     + , -0.3358E+02,  0.1701E+04,  0.2029E+06, -0.3312E+05
     + , -0.8668E+01,  0.2379E+04,  0.3331E+06, -0.9285E+06
     + ,  0.3209E+01,  0.1579E+04,  0.3144E+07, -0.4804E+08
     + ,  0.1966E+01,  0.3553E+04,  0.2103E+07,  0.1345E+09,  4*0.0 /
      DATA ((TMP(I,J, 65),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1879E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3021E+04, -0.1618E+03,  0.9979E+01, -0.1862E+00
     + , -0.1406E+04,  0.5621E+04, -0.1912E+04,  0.2075E+03
     + , -0.5345E+03,  0.7632E+04,  0.8660E+04, -0.1449E+04
     + , -0.4988E+03,  0.9401E+04,  0.9226E+04, -0.2000E+04
     + , -0.4700E+03,  0.9391E+04,  0.1117E+05, -0.2613E+04
     + , -0.1902E+03,  0.5724E+04,  0.2615E+05, -0.1782E+05
     + , -0.1568E+03,  0.1116E+05,  0.8757E+05, -0.7647E+05
     + , -0.4533E+02,  0.2421E+04,  0.2126E+06, -0.4859E+05
     + , -0.4721E+01,  0.2127E+04,  0.3644E+06, -0.1109E+07
     + ,  0.3903E+01,  0.1250E+04,  0.3405E+07, -0.5637E+08
     + ,  0.2077E+01,  0.3763E+04,  0.2261E+07,  0.1115E+09,  4*0.0 /
      DATA ((TMP(I,J, 66),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3294E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3167E+04, -0.4242E+02,  0.5269E+01, -0.1178E+00
     + , -0.1109E+04,  0.5234E+04, -0.1650E+04,  0.1694E+03
     + , -0.5242E+03,  0.7751E+04,  0.9341E+04, -0.1624E+04
     + , -0.4635E+03,  0.1050E+05,  0.8066E+04, -0.1930E+04
     + , -0.4608E+03,  0.9448E+04,  0.1216E+05, -0.2942E+04
     + , -0.1077E+03,  0.4675E+04,  0.3253E+05, -0.2519E+05
     + , -0.6326E+02,  0.3407E+04,  0.1499E+06, -0.5526E+05
     + , -0.7262E+02,  0.4176E+04,  0.2130E+06, -0.8026E+05
     + , -0.1800E+02,  0.3374E+04,  0.3526E+06, -0.9982E+06
     + ,  0.4112E+01,  0.1344E+04,  0.3520E+07, -0.5867E+08
     + ,  0.2166E+01,  0.3928E+04,  0.2396E+07,  0.1007E+09,  4*0.0 /
      DATA ((TMP(I,J, 67),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1647E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2949E+04, -0.5473E+02, -0.1313E+01,  0.5447E-01
     + , -0.1961E+04,  0.6859E+04, -0.2353E+04,  0.2538E+03
     + , -0.5221E+03,  0.8169E+04,  0.9852E+04, -0.1807E+04
     + , -0.4878E+03,  0.9589E+04,  0.1119E+05, -0.2580E+04
     + , -0.4549E+03,  0.9349E+04,  0.1378E+05, -0.3393E+04
     + , -0.1379E+03,  0.5032E+04,  0.3428E+05, -0.2787E+05
     + , -0.4939E+02,  0.2705E+04,  0.1628E+06, -0.5056E+05
     + , -0.4426E+02,  0.2555E+04,  0.2349E+06, -0.5948E+05
     + , -0.2988E+01,  0.2094E+04,  0.4072E+06, -0.1335E+07
     + ,  0.5131E+01,  0.5023E+03,  0.4000E+07, -0.7974E+08
     + ,  0.2274E+01,  0.4258E+04,  0.2387E+07,  0.1450E+09,  4*0.0 /
      DATA ((TMP(I,J, 68),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2419E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3178E+04, -0.8940E+02,  0.5741E+01, -0.1173E+00
     + , -0.1598E+04,  0.6371E+04, -0.2015E+04,  0.1951E+03
     + , -0.5148E+03,  0.8464E+04,  0.1038E+05, -0.1998E+04
     + , -0.4781E+03,  0.8546E+04,  0.1463E+05, -0.3195E+04
     + , -0.4470E+03,  0.9490E+04,  0.1489E+05, -0.3799E+04
     + , -0.2279E+03,  0.6501E+04,  0.3083E+05, -0.2363E+05
     + , -0.5162E+02,  0.2947E+04,  0.1710E+06, -0.5828E+05
     + , -0.5360E+02,  0.3254E+04,  0.2449E+06, -0.7821E+05
     + ,  0.6456E+01,  0.1211E+04,  0.4583E+06, -0.1684E+07
     + , -0.4025E+01,  0.2031E+04,  0.3795E+07, -0.6651E+08
     + ,  0.2386E+01,  0.4497E+04,  0.2558E+07,  0.1403E+09,  4*0.0 /
      DATA ((TMP(I,J, 69),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1729E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.5004E+04, -0.3383E+03,  0.1358E+02, -0.1932E+00
     + , -0.1721E+04,  0.6821E+04, -0.2191E+04,  0.2162E+03
     + , -0.5074E+03,  0.8420E+04,  0.1161E+05, -0.2277E+04
     + ,  0.4504E+03, -0.4717E+04,  0.9421E+05, -0.1104E+06
     + , -0.5189E+02,  0.3077E+04,  0.1808E+06, -0.6499E+05
     + , -0.5311E+02,  0.3348E+04,  0.2598E+06, -0.8657E+05
     + , -0.3887E+01,  0.2132E+04,  0.4637E+06, -0.1723E+07
     + ,  0.4124E+01,  0.2299E+04,  0.3956E+07, -0.7043E+08
     + ,  0.2512E+01,  0.4774E+04,  0.2690E+07,  0.1454E+09,  12*0.0 /
      DATA ((TMP(I,J, 70),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2440E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.5923E+04, -0.5235E+03,  0.2450E+02, -0.3644E+00
     + , -0.1402E+04,  0.6524E+04, -0.1996E+04,  0.1849E+03
     + , -0.4649E+03,  0.1046E+05,  0.8110E+04, -0.1188E+04
     + ,  0.3077E+03, -0.2145E+04,  0.8374E+05, -0.9504E+05
     + , -0.5328E+02,  0.3291E+04,  0.1869E+06, -0.7332E+05
     + , -0.7311E+02,  0.4929E+04,  0.2602E+06, -0.1239E+06
     + , -0.2434E+02,  0.4269E+04,  0.4243E+06, -0.1379E+07
     + ,  0.4575E+01,  0.2312E+04,  0.4086E+07, -0.7562E+08
     + ,  0.2606E+01,  0.4980E+04,  0.2895E+07,  0.9923E+08,  12*0.0 /
      DATA ((TMP(I,J, 71),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2123E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8368E+04, -0.1105E+04,  0.5971E+02, -0.9746E+00
     + , -0.1536E+04,  0.7063E+04, -0.2291E+04,  0.2250E+03
     + , -0.4936E+03,  0.9095E+04,  0.1255E+05, -0.2717E+04
     + ,  0.2304E+03, -0.1379E+04,  0.8594E+05, -0.1012E+06
     + , -0.5213E+02,  0.3333E+04,  0.1974E+06, -0.7977E+05
     + , -0.5333E+02,  0.3627E+04,  0.2858E+06, -0.1071E+06
     + ,  0.3726E+01,  0.1486E+04,  0.5352E+06, -0.2222E+07
     + ,  0.5266E+01,  0.2137E+04,  0.4329E+07, -0.8327E+08
     + ,  0.2736E+01,  0.5209E+04,  0.3153E+07,  0.5239E+08,  12*0.0 /
      DATA ((TMP(I,J, 72),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5463E+04, -0.2212E+03,  0.3566E+01, -0.1819E-01
     + ,  0.9488E+04, -0.1416E+04,  0.8076E+02, -0.1382E+01
     + , -0.1796E+04,  0.7903E+04, -0.2748E+04,  0.2932E+03
     + , -0.4835E+03,  0.9549E+04,  0.1284E+05, -0.2957E+04
     + ,  0.3480E+03, -0.3031E+04,  0.9762E+05, -0.1203E+06
     + , -0.6090E+02,  0.4112E+04,  0.2015E+06, -0.9934E+05
     + , -0.7386E+02,  0.5387E+04,  0.2859E+06, -0.1536E+06
     + , -0.1873E+02,  0.4102E+04,  0.4698E+06, -0.1572E+07
     + ,  0.4753E+01,  0.2673E+04,  0.4462E+07, -0.8960E+08
     + ,  0.2845E+01,  0.5554E+04,  0.3013E+07,  0.1535E+09,  12*0.0 /
      DATA ((TMP(I,J, 73),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.9358E+04,  0.4382E+03, -0.5661E+01,  0.2301E-01
     + ,  0.3537E+05, -0.2591E+04,  0.6585E+02, -0.5643E+00
     + ,  0.9000E+04, -0.1376E+04,  0.8354E+02, -0.1487E+01
     + , -0.1944E+04,  0.8490E+04, -0.3040E+04,  0.3330E+03
     + , -0.4771E+03,  0.1003E+05,  0.1338E+05, -0.3254E+04
     + ,  0.1047E+03,  0.6524E+03,  0.8380E+05, -0.1025E+06
     + , -0.5521E+02,  0.3828E+04,  0.2145E+06, -0.1019E+06
     + , -0.4987E+02,  0.3641E+04,  0.3160E+06, -0.1250E+06
     + , -0.2176E+01,  0.2172E+04,  0.5708E+06, -0.2482E+07
     + ,  0.5194E+01,  0.2794E+04,  0.4645E+07, -0.9648E+08
     + ,  0.2973E+01,  0.5785E+04,  0.3320E+07,  0.9608E+08,  8*0.0 /
      DATA ((TMP(I,J, 74),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.2084E+04,  0.1834E+03, -0.2686E+01,  0.1131E-01
     + , -0.1398E+05,  0.2451E+04, -0.1057E+03,  0.1381E+01
     + ,  0.9985E+04, -0.1816E+04,  0.1301E+03, -0.2747E+01
     + , -0.1826E+04,  0.8623E+04, -0.3114E+04,  0.3432E+03
     + , -0.4666E+03,  0.1057E+05,  0.1355E+05, -0.3503E+04
     + ,  0.1412E+03,  0.2762E+03,  0.8940E+05, -0.1129E+06
     + , -0.6206E+02,  0.4525E+04,  0.2194E+06, -0.1223E+06
     + , -0.1211E+03,  0.1058E+05,  0.2701E+06, -0.2556E+06
     + , -0.2105E+02,  0.4623E+04,  0.5109E+06, -0.1184E+07
     + ,  0.5276E+01,  0.2999E+04,  0.4828E+07, -0.1030E+09
     + ,  0.3099E+01,  0.6112E+04,  0.3348E+07,  0.1310E+09,  8*0.0 /
      DATA ((TMP(I,J, 75),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.5759E+04,  0.4019E+03, -0.6479E+01,  0.3113E-01
     + ,  0.1235E+05, -0.2571E+04,  0.1879E+03, -0.4072E+01
     + , -0.1846E+04,  0.9196E+04, -0.3553E+04,  0.4261E+03
     + , -0.4438E+03,  0.1148E+05,  0.1253E+05, -0.3520E+04
     + ,  0.1961E+03, -0.3585E+03,  0.9550E+05, -0.1180E+06
     + , -0.5721E+02,  0.4284E+04,  0.2331E+06, -0.1270E+06
     + , -0.1192E+03,  0.1081E+05,  0.2828E+06, -0.2788E+06
     + , -0.8548E+01,  0.3122E+04,  0.5972E+06, -0.2571E+07
     + ,  0.4901E+01,  0.3621E+04,  0.4969E+07, -0.1085E+09
     + ,  0.3238E+01,  0.6600E+04,  0.3237E+07,  0.2204E+09,  12*0.0 /
      DATA ((TMP(I,J, 76),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5189E+03,  0.1085E+03, -0.2362E+01,  0.1285E-01
     + ,  0.9943E+04, -0.1964E+04,  0.1499E+03, -0.3533E+01
     + , -0.1915E+04,  0.9625E+04, -0.3819E+04,  0.4641E+03
     + , -0.4312E+03,  0.1174E+05,  0.1298E+05, -0.3813E+04
     + , -0.7620E+02,  0.3809E+04,  0.8189E+05, -0.1090E+06
     + , -0.5946E+02,  0.4643E+04,  0.2401E+06, -0.1434E+06
     + , -0.1116E+03,  0.1035E+05,  0.3012E+06, -0.2961E+06
     + , -0.1803E+02,  0.4548E+04,  0.5700E+06, -0.2246E+07
     + ,  0.5735E+01,  0.3318E+04,  0.5232E+07, -0.1209E+09
     + ,  0.3351E+01,  0.6829E+04,  0.3509E+07,  0.1607E+09,  12*0.0 /
      DATA ((TMP(I,J, 77),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.9441E+02,  0.1284E+03, -0.2563E+01,  0.1347E-01
     + ,  0.9926E+04, -0.2049E+04,  0.1630E+03, -0.4025E+01
     + , -0.2391E+04,  0.1087E+05, -0.4456E+04,  0.5612E+03
     + , -0.4371E+03,  0.1150E+05,  0.1539E+05, -0.4560E+04
     + ,  0.1540E+03, -0.7160E+03,  0.1147E+06, -0.1673E+06
     + , -0.5153E+02,  0.4097E+04,  0.2582E+06, -0.1419E+06
     + , -0.1366E+03,  0.1456E+05,  0.2707E+06, -0.3461E+06
     + , -0.1995E+02,  0.4906E+04,  0.6064E+06, -0.2648E+07
     + ,  0.6213E+01,  0.3458E+04,  0.5442E+07, -0.1286E+09
     + ,  0.3505E+01,  0.7126E+04,  0.3805E+07,  0.1114E+09,  12*0.0 /
      DATA ((TMP(I,J, 78),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1220E+05, -0.3768E+03,  0.4167E+01, -0.1564E-01
     + ,  0.1396E+05, -0.1184E+04,  0.3650E+02, -0.3548E+00
     + ,  0.1172E+05, -0.2752E+04,  0.2212E+03, -0.4579E+01
     + , -0.2373E+04,  0.1129E+05, -0.4739E+04,  0.6166E+03
     + , -0.4333E+03,  0.1147E+05,  0.1710E+05, -0.5181E+04
     + , -0.7755E+02,  0.2847E+04,  0.1047E+06, -0.1599E+06
     + , -0.6719E+02,  0.5737E+04,  0.2565E+06, -0.1880E+06
     + , -0.1399E+03,  0.1605E+05,  0.2671E+06, -0.3742E+06
     + ,  0.1076E+02,  0.9617E+03,  0.7776E+06, -0.4207E+07
     + ,  0.6088E+01,  0.4001E+04,  0.5552E+07, -0.1300E+09
     + ,  0.3646E+01,  0.7453E+04,  0.3931E+07,  0.1226E+09,  8*0.0 /
      DATA ((TMP(I,J, 79),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4105E+04,  0.2410E+02, -0.1837E+01,  0.1252E-01
     + ,  0.1581E+05, -0.4931E+04,  0.5197E+03, -0.1622E+02
     + , -0.2231E+04,  0.1142E+05, -0.4781E+04,  0.6012E+03
     + , -0.4203E+03,  0.1212E+05,  0.1690E+05, -0.5448E+04
     + ,  0.1443E+03, -0.4096E+03,  0.1249E+06, -0.1944E+06
     + , -0.8194E+02,  0.7574E+04,  0.2506E+06, -0.2318E+06
     + , -0.1134E+03,  0.1194E+05,  0.3355E+06, -0.3921E+06
     + , -0.3392E+01,  0.3070E+04,  0.7247E+06, -0.3499E+07
     + ,  0.7917E+01,  0.2918E+04,  0.6095E+07, -0.1596E+09
     + ,  0.3811E+01,  0.7846E+04,  0.4248E+07,  0.4571E+08,  12*0.0 /
      DATA ((TMP(I,J, 80),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5142E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1780E+05, -0.5970E+04,  0.6765E+03, -0.2176E+02
     + , -0.2317E+04,  0.1206E+05, -0.5219E+04,  0.7004E+03
     + , -0.3961E+03,  0.1286E+05,  0.1582E+05, -0.5482E+04
     + ,  0.2241E+03, -0.2195E+04,  0.1429E+06, -0.2325E+06
     + , -0.7533E+02,  0.7084E+04,  0.2675E+06, -0.2412E+06
     + , -0.1288E+03,  0.1524E+05,  0.3090E+06, -0.4397E+06
     + ,  0.4681E+00,  0.2405E+04,  0.7958E+06, -0.4232E+07
     + ,  0.6983E+01,  0.4309E+04,  0.5980E+07, -0.1518E+09
     + ,  0.3946E+01,  0.8311E+04,  0.4256E+07,  0.8942E+08,  12*0.0 /
      DATA ((TMP(I,J, 81),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1823E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1010E+05,  0.1911E+04, -0.7721E+02,  0.9111E+00
     + ,  0.1488E+05, -0.4878E+04,  0.5536E+03, -0.1923E+02
     + , -0.2399E+04,  0.1271E+05, -0.5745E+04,  0.7873E+03
     + , -0.4087E+03,  0.1156E+05,  0.2169E+05, -0.7188E+04
     + ,  0.1551E+03, -0.9040E+03,  0.1404E+06, -0.2314E+06
     + , -0.6647E+02,  0.6324E+04,  0.2871E+06, -0.2439E+06
     + , -0.1405E+03,  0.2137E+05,  0.2340E+06, -0.4290E+06
     + , -0.1063E+02,  0.4195E+04,  0.7543E+06, -0.3747E+07
     + ,  0.7684E+01,  0.4048E+04,  0.6314E+07, -0.1714E+09
     + ,  0.4082E+01,  0.8543E+04,  0.4521E+07,  0.5178E+08,  8*0.0 /
      DATA ((TMP(I,J, 82),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1569E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.9651E+04,  0.1870E+04, -0.7761E+02,  0.9425E+00
     + ,  0.1609E+05, -0.5855E+04,  0.7149E+03, -0.2672E+02
     + , -0.2194E+04,  0.1239E+05, -0.5418E+04,  0.6794E+03
     + , -0.4016E+03,  0.1173E+05,  0.2316E+05, -0.7955E+04
     + ,  0.6749E+02,  0.6789E+03,  0.1401E+06, -0.2437E+06
     + , -0.7125E+02,  0.7126E+04,  0.2931E+06, -0.2779E+06
     + , -0.1363E+03,  0.1992E+05,  0.2721E+06, -0.4887E+06
     + , -0.8206E+01,  0.4058E+04,  0.7950E+06, -0.4115E+07
     + ,  0.7595E+01,  0.4692E+04,  0.6429E+07, -0.1747E+09
     + ,  0.4240E+01,  0.8883E+04,  0.4754E+07,  0.3448E+08,  8*0.0 /
      DATA ((TMP(I,J, 83),I=1,MAXPOW),J=1,MAXINT) /
     +  -0.4395E+03,  0.1185E+02,  0.2207E+00, -0.1865E-02
     + ,  0.4586E+04, -0.1052E+03, -0.2706E+01,  0.7877E-01
     + ,  0.1118E+05, -0.3159E+03, -0.9250E+01,  0.2918E+00
     + , -0.1578E+05,  0.3450E+04, -0.1741E+03,  0.2596E+01
     + ,  0.2124E+05, -0.8884E+04,  0.1240E+04, -0.5312E+02
     + , -0.1835E+04,  0.1188E+05, -0.5123E+04,  0.6229E+03
     + , -0.3943E+03,  0.1129E+05,  0.2671E+05, -0.9164E+04
     + ,  0.2402E+03, -0.2657E+04,  0.1637E+06, -0.2867E+06
     + , -0.6824E+02,  0.7005E+04,  0.3089E+06, -0.2951E+06
     + , -0.1337E+03,  0.1999E+05,  0.2903E+06, -0.5342E+06
     + , -0.1411E+01,  0.3094E+04,  0.8901E+06, -0.5203E+07
     + ,  0.9935E+01,  0.3289E+04,  0.6983E+07, -0.2020E+09
     + ,  0.4425E+01,  0.9396E+04,  0.5008E+07, -0.5280E+08
     +/
      DATA ((TMP(I,J, 84),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1109E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1939E+05, -0.1380E+04,  0.3526E+02, -0.3106E+00
     + ,  0.9152E+04, -0.3829E+04,  0.5535E+03, -0.2106E+02
     + , -0.1131E+04,  0.1041E+05, -0.4126E+04,  0.4235E+03
     + , -0.3899E+03,  0.1134E+05,  0.2963E+05, -0.1038E+05
     + ,  0.4918E+03, -0.1053E+05,  0.2383E+06, -0.4647E+06
     + , -0.7471E+02,  0.8106E+04,  0.3143E+06, -0.3397E+06
     + , -0.1335E+03,  0.2199E+05,  0.2786E+06, -0.5569E+06
     + ,  0.7789E+01,  0.1767E+04,  0.1003E+07, -0.6443E+07
     + ,  0.8525E+01,  0.5102E+04,  0.6990E+07, -0.2009E+09
     + ,  0.4633E+01,  0.9868E+04,  0.5142E+07,  0.1775E+08,  8*0.0 /
      DATA ((TMP(I,J, 85),I=1,MAXPOW),J=1,MAXINT) /
     +   0.5224E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.2744E+05, -0.2310E+04,  0.6658E+02, -0.6458E+00
     + ,  0.6422E+04, -0.2954E+04,  0.4933E+03, -0.2019E+02
     + , -0.1933E+04,  0.1303E+05, -0.5806E+04,  0.6870E+03
     + , -0.3889E+03,  0.1171E+05,  0.3195E+05, -0.1160E+05
     + ,  0.3129E+03, -0.6378E+04,  0.2158E+06, -0.4073E+06
     + , -0.6880E+02,  0.7565E+04,  0.3411E+06, -0.3547E+06
     + , -0.1280E+03,  0.1941E+05,  0.3508E+06, -0.6558E+06
     + , -0.1695E+01,  0.3621E+04,  0.9665E+06, -0.5746E+07
     + ,  0.9913E+01,  0.4822E+04,  0.7370E+07, -0.2163E+09
     + ,  0.4871E+01,  0.1062E+05,  0.5352E+07, -0.2702E+08,  8*0.0 /
      DATA ((TMP(I,J, 86),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1284E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.7912E+03,  0.2111E+04, -0.1709E+03,  0.3589E+01
     + ,  0.1243E+05, -0.6150E+04,  0.1021E+04, -0.4644E+02
     + , -0.1804E+04,  0.1279E+05, -0.5624E+04,  0.6228E+03
     + , -0.3616E+03,  0.1088E+05,  0.3423E+05, -0.1248E+05
     + ,  0.1691E+03, -0.2424E+04,  0.1954E+06, -0.4008E+06
     + , -0.6756E+02,  0.7739E+04,  0.3363E+06, -0.3748E+06
     + , -0.1220E+03,  0.1976E+05,  0.3335E+06, -0.6657E+06
     + , -0.5899E+00,  0.3312E+04,  0.9833E+06, -0.6258E+07
     + ,  0.8633E+01,  0.5888E+04,  0.7122E+07, -0.2120E+09
     + ,  0.4841E+01,  0.1057E+05,  0.5286E+07,  0.1022E+08,  8*0.0 /
      DATA ((TMP(I,J, 87),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1287E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.9129E+04,  0.3064E+04, -0.1840E+03,  0.2869E+01
     + ,  0.1217E+05, -0.1865E+04, -0.1031E+04,  0.1980E+03
     + , -0.2201E+04,  0.1461E+05, -0.7082E+04,  0.9132E+03
     + , -0.3615E+03,  0.1150E+05,  0.3541E+05, -0.1363E+05
     + , -0.5769E+03,  0.1660E+05,  0.5526E+05, -0.7044E+05
     + , -0.6236E+02,  0.7249E+04,  0.3612E+06, -0.3893E+06
     + , -0.1213E+03,  0.2052E+05,  0.3455E+06, -0.7195E+06
     + , -0.8453E+01,  0.4660E+04,  0.9757E+06, -0.6010E+07
     + ,  0.1104E+02,  0.4630E+04,  0.7706E+07, -0.2445E+09
     + ,  0.5063E+01,  0.1115E+05,  0.5666E+07, -0.1082E+09,  8*0.0 /
      DATA ((TMP(I,J, 88),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1415E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.3003E+05,  0.8875E+04, -0.6798E+03,  0.1571E+02
     + ,  0.2941E+05, -0.1786E+05,  0.3591E+04, -0.2242E+03
     + , -0.1852E+04,  0.1361E+05, -0.6123E+04,  0.6294E+03
     + , -0.3547E+03,  0.1164E+05,  0.3753E+05, -0.1492E+05
     + ,  0.2933E+03, -0.6829E+04,  0.2528E+06, -0.5565E+06
     + , -0.6085E+02,  0.7287E+04,  0.3762E+06, -0.4161E+06
     + , -0.1192E+03,  0.2119E+05,  0.3500E+06, -0.7644E+06
     + , -0.1024E+02,  0.5310E+04,  0.9756E+06, -0.5773E+07
     + ,  0.1241E+02,  0.3727E+04,  0.8307E+07, -0.2833E+09
     + ,  0.5211E+01,  0.1168E+05,  0.5739E+07, -0.9046E+08,  8*0.0 /
      DATA ((TMP(I,J, 89),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1258E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2747E+04,  0.3975E+03,  0.1941E+03, -0.1439E+02
     + ,  0.1958E+05, -0.9878E+04,  0.1388E+04, -0.1778E+02
     + , -0.2098E+04,  0.1506E+05, -0.7581E+04,  0.9825E+03
     + , -0.3474E+03,  0.1153E+05,  0.4113E+05, -0.1657E+05
     + ,  0.5789E+03, -0.1507E+05,  0.3328E+06, -0.7718E+06
     + , -0.6339E+02,  0.7915E+04,  0.3884E+06, -0.4637E+06
     + , -0.1182E+03,  0.2194E+05,  0.3621E+06, -0.8244E+06
     + ,  0.8142E+01,  0.2287E+04,  0.1185E+07, -0.8439E+07
     + ,  0.1003E+02,  0.6690E+04,  0.7961E+07, -0.2545E+09
     + ,  0.5479E+01,  0.1217E+05,  0.5897E+07, -0.2287E+08,  8*0.0 /
      DATA ((TMP(I,J, 90),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1134E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1398E+05, -0.6113E+04,  0.8572E+03, -0.2963E+02
     + , -0.1466E+04,  0.1349E+05, -0.6743E+04,  0.1013E+04
     + , -0.3308E+03,  0.1094E+05,  0.4517E+05, -0.1812E+05
     + ,  0.2265E+03, -0.3796E+04,  0.2424E+06, -0.5526E+06
     + , -0.5998E+02,  0.7669E+04,  0.4039E+06, -0.4843E+06
     + , -0.1152E+03,  0.2229E+05,  0.3694E+06, -0.8743E+06
     + , -0.1965E+02,  0.7238E+04,  0.9916E+06, -0.5869E+07
     + ,  0.1150E+02,  0.6085E+04,  0.8292E+07, -0.2758E+09
     + ,  0.5620E+01,  0.1245E+05,  0.6338E+07, -0.1549E+09,  12*0.0 /
      DATA ((TMP(I,J, 91),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2194E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.8794E+04, -0.2841E+04,  0.2038E+03,  0.1370E+02
     + , -0.2042E+04,  0.1581E+05, -0.8451E+04,  0.1211E+04
     + , -0.3240E+03,  0.1078E+05,  0.5022E+05, -0.2015E+05
     + ,  0.1921E+04, -0.5267E+05,  0.6573E+06, -0.1562E+07
     + , -0.6436E+02,  0.8617E+04,  0.4180E+06, -0.5495E+06
     + , -0.1129E+03,  0.2138E+05,  0.4231E+06, -0.9875E+06
     + ,  0.1526E+02,  0.1356E+04,  0.1351E+07, -0.1082E+08
     + ,  0.1254E+02,  0.5894E+04,  0.8877E+07, -0.3120E+09
     + ,  0.5918E+01,  0.1306E+05,  0.6683E+07, -0.1778E+09,  12*0.0 /
      DATA ((TMP(I,J, 92),I=1,MAXPOW),J=1,MAXINT) /
     +   0.4400E+04, -0.1564E+03,  0.2241E+01, -0.1062E-01
     + , -0.2175E+04,  0.4327E+03, -0.1164E+02,  0.8742E-01
     + ,  0.1528E+05, -0.7106E+04,  0.1060E+04, -0.4036E+02
     + , -0.1807E+04,  0.1483E+05, -0.7405E+04,  0.8426E+03
     + , -0.3148E+03,  0.1094E+05,  0.5041E+05, -0.2121E+05
     + , -0.1100E+03,  0.4889E+04,  0.1908E+06, -0.4810E+06
     + , -0.6720E+02,  0.9489E+04,  0.4107E+06, -0.6000E+06
     + , -0.1033E+03,  0.1864E+05,  0.4878E+06, -0.1076E+07
     + ,  0.6281E+00,  0.3792E+04,  0.1281E+07, -0.1003E+08
     + ,  0.1146E+02,  0.7568E+04,  0.8699E+07, -0.3106E+09
     + ,  0.6017E+01,  0.1327E+05,  0.7079E+07, -0.2456E+09,  8*0.0 /
      DATA ((TMP(I,J, 93),I=1,MAXPOW),J=1,MAXINT) /
     +   0.2522E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.1668E+05, -0.8606E+04,  0.1441E+04, -0.6401E+02
     + , -0.2561E+04,  0.1858E+05, -0.1101E+05,  0.1791E+04
     + , -0.3232E+03,  0.1200E+05,  0.6096E+05, -0.2302E+05
     + , -0.4467E+02,  0.2778E+04,  0.2204E+06, -0.5257E+06
     + , -0.6355E+02,  0.9093E+04,  0.4439E+06, -0.6341E+06
     + , -0.1103E+03,  0.2501E+05,  0.3841E+06, -0.1044E+07
     + ,  0.5579E+01,  0.3489E+04,  0.1354E+07, -0.1078E+08
     + ,  0.1272E+02,  0.7422E+04,  0.9191E+07, -0.3336E+09
     + ,  0.6330E+01,  0.1392E+05,  0.7484E+07, -0.3064E+09,  12*0.0 /
      DATA ((TMP(I,J, 94),I=1,MAXPOW),J=1,MAXINT) /
     +   0.3508E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.2939E+04,  0.8224E+03, -0.3576E+02,  0.5087E+00
     + ,  0.1270E+05, -0.6607E+04,  0.1093E+04, -0.3674E+02
     + , -0.2063E+04,  0.1760E+05, -0.1057E+05,  0.1695E+04
     + , -0.3181E+03,  0.1245E+05,  0.5096E+05, -0.2427E+05
     + ,  0.3925E+03, -0.1022E+05,  0.3515E+06, -0.9309E+06
     + , -0.6367E+02,  0.9444E+04,  0.4539E+06, -0.6824E+06
     + , -0.1065E+03,  0.2299E+05,  0.4461E+06, -0.1181E+07
     + , -0.1248E+02,  0.6703E+04,  0.1250E+07, -0.9411E+07
     + ,  0.1781E+02,  0.3158E+04,  0.1075E+08, -0.4693E+09
     + ,  0.6490E+01,  0.1422E+05,  0.8179E+07, -0.5340E+09,  8*0.0 /
      DATA ((TMP(I,J, 95),I=1,MAXPOW),J=1,MAXINT) /
     +   0.9600E+03,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3669E+04, -0.1927E+04,  0.3556E+03, -0.1775E+02
     + , -0.8806E+05,  0.1824E+06, -0.1119E+06,  0.2150E+05
     + , -0.8786E+03,  0.1063E+05, -0.5553E+03, -0.1750E+04
     + , -0.3188E+03,  0.1325E+05,  0.5127E+05, -0.2586E+05
     + ,  0.3232E+03, -0.9027E+04,  0.3584E+06, -0.9931E+06
     + , -0.6201E+02,  0.9427E+04,  0.4778E+06, -0.7281E+06
     + , -0.9199E+02,  0.1716E+05,  0.6101E+06, -0.1350E+07
     + , -0.3730E+01,  0.5425E+04,  0.1376E+07, -0.1109E+08
     + ,  0.1966E+02,  0.2217E+04,  0.1154E+08, -0.5298E+09
     + ,  0.6763E+01,  0.1479E+05,  0.8647E+07, -0.6116E+09,  8*0.0 /
      DATA ((TMP(I,J, 96),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1000E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3148E+04, -0.1605E+04,  0.2954E+03, -0.1411E+02
     + , -0.7979E+05,  0.1716E+06, -0.1079E+06,  0.2118E+05
     + , -0.8139E+03,  0.1040E+05,  0.4547E+03, -0.2530E+04
     + , -0.3144E+03,  0.1378E+05,  0.5160E+05, -0.2733E+05
     + , -0.2912E+03,  0.1117E+05,  0.1679E+06, -0.4469E+06
     + , -0.5879E+02,  0.9126E+04,  0.4981E+06, -0.7597E+06
     + , -0.1010E+03,  0.2212E+05,  0.5193E+06, -0.1402E+07
     + , -0.1147E+02,  0.7190E+04,  0.1327E+07, -0.1016E+08
     + ,  0.2200E+02,  0.1083E+04,  0.1208E+08, -0.5684E+09
     + ,  0.7017E+01,  0.1439E+05,  0.9471E+07, -0.8527E+09,  8*0.0 /
      DATA ((TMP(I,J, 97),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1100E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3725E+04, -0.1998E+04,  0.3728E+03, -0.1783E+02
     + , -0.1348E+06,  0.2867E+06, -0.1865E+06,  0.3853E+05
     + , -0.1092E+04,  0.1257E+05, -0.3090E+04, -0.6861E+03
     + , -0.3108E+03,  0.1396E+05,  0.5425E+05, -0.2964E+05
     + , -0.8536E+02,  0.5200E+04,  0.2278E+06, -0.6067E+06
     + , -0.6035E+02,  0.9752E+04,  0.5095E+06, -0.8199E+06
     + , -0.1018E+03,  0.2538E+05,  0.4681E+06, -0.1141E+07
     + , -0.1308E+02,  0.7916E+04,  0.1354E+07, -0.1049E+08
     + ,  0.2374E+02,  0.1750E+03,  0.1285E+08, -0.6352E+09
     + ,  0.7219E+01,  0.1592E+05,  0.9491E+07, -0.8283E+09,  8*0.0 /
      DATA ((TMP(I,J, 98),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1220E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + ,  0.3846E+04, -0.2092E+04,  0.3854E+03, -0.1758E+02
     + , -0.5378E+05,  0.1380E+06, -0.9898E+05,  0.2185E+05
     + , -0.9355E+03,  0.1168E+05, -0.4663E+03, -0.2379E+04
     + , -0.3044E+03,  0.1361E+05,  0.6013E+05, -0.3273E+05
     + ,  0.3450E+03, -0.1057E+05,  0.4170E+06, -0.1248E+07
     + , -0.5797E+02,  0.9571E+04,  0.5352E+06, -0.8755E+06
     + , -0.9148E+02,  0.1942E+05,  0.6490E+06, -0.1673E+07
     + , -0.5416E+02,  0.1706E+05,  0.8630E+06, -0.1792E+07
     + ,  0.2771E+02, -0.2903E+04,  0.1419E+08, -0.7456E+09
     + ,  0.7544E+01,  0.1589E+05,  0.1052E+08, -0.1089E+10,  8*0.0 /
      DATA ((TMP(I,J, 99),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1330E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.8936E+03,  0.1145E+05,  0.1094E+04, -0.3692E+04
     + , -0.2152E+03,  0.7720E+04,  0.5372E+05, -0.2276E+05
     + , -0.2914E+03,  0.1268E+05,  0.6828E+05, -0.3620E+05
     + , -0.2568E+03,  0.1341E+05,  0.8685E+05, -0.5387E+05
     + , -0.2104E+03,  0.1155E+05,  0.1107E+06, -0.7279E+05
     + ,  0.1088E+03,  0.1536E+04,  0.2458E+06, -0.6005E+06
     + , -0.5691E+02,  0.9660E+04,  0.5556E+06, -0.9320E+06
     + , -0.9167E+02,  0.2050E+05,  0.6520E+06, -0.1784E+07
     + ,  0.9687E+00,  0.5331E+04,  0.1646E+07, -0.1518E+08
     + ,  0.3315E+02, -0.7298E+04,  0.1587E+08, -0.8866E+09
     + ,  0.7728E+01,  0.1675E+05,  0.1090E+08, -0.1231E+10,  4*0.0 /
      DATA ((TMP(I,J,100),I=1,MAXPOW),J=1,MAXINT) /
     +   0.1460E+04,  0.0000E+00,  0.0000E+00,  0.0000E+00
     + , -0.1082E+04,  0.1308E+05, -0.9100E+03, -0.2846E+04
     + , -0.1923E+03,  0.6709E+04,  0.6231E+05, -0.2410E+05
     + , -0.2559E+03,  0.1024E+05,  0.8602E+05, -0.3977E+05
     + , -0.2466E+03,  0.1276E+05,  0.9751E+05, -0.5925E+05
     + , -0.2304E+03,  0.1518E+05,  0.9220E+05, -0.7454E+05
     + , -0.8675E+02,  0.2132E+04,  0.2568E+06, -0.6538E+06
     + , -0.5579E+02,  0.1018E+05,  0.5793E+06, -0.1018E+07
     + , -0.8637E+02,  0.1890E+05,  0.7445E+06, -0.1949E+07
     + ,  0.5556E+00,  0.5648E+04,  0.1738E+07, -0.1662E+08
     + ,  0.2968E+02, -0.2026E+04,  0.1484E+08, -0.7825E+09
     + ,  0.8135E+01,  0.1726E+05,  0.1171E+08, -0.1346E+10,  4*0.0 /
C Ionization energies
      DATA (TMP1(I), I = 1,56) /
     +     13.60, 24.59,
     +      5.39,  9.32,  8.30, 11.26, 14.53, 13.62, 17.42, 21.56,
     +      5.14,  7.65,  5.99,  8.15, 10.49, 10.36, 12.97, 15.76,
     +      4.34,  6.11,
     +      6.56,  6.83,  6.75,  6.77,  7.43,  7.90,  7.88,  7.64,
     +      7.73,  9.39,
     +                    6.00,  7.90,  9.82,  9.75, 11.81, 14.00,
     +      4.18,  5.69,
     +      6.22,  6.63,  6.76,  7.09,  7.28,  7.36,  7.46,  8.34,
     +      7.58,  8.99,  5.79,  7.34,  8.64,  9.01, 10.45, 12.13,
     +      3.89,  5.21 /
      DATA (TMP1(I), I = 57,MAXELZ) /
     +      5.58,  5.54,  5.46,  5.52,  5.55,  5.64,  5.67,  6.15,
     +      5.86,  5.94,  6.02,  6.11,  6.18,  6.25,
     +      5.43,  6.83,  7.89,  7.98,  7.88,  8.70,  9.10,  9.00,
     +      9.23, 10.44,
     +                    6.11,  7.42,  7.29,  8.42,  9.65, 10.75,
     +      3.97,  5.28,
     +      5.17,  6.08,  5.89,  6.19,  6.27,  6.06,  5.99,  6.02,
     +      6.23,  6.30,  6.42,  6.50 /
      DO 10 J = 1,MAXELZ
         DO 10 I = 1,MAXINT
            CRNGUP(I,J) = CTMP(I,J)
   10 CONTINUE
      DO 20 K = 1,MAXELZ
         DO 20 J = 1,MAXINT
            DO 20 I = 1,MAXPOW
               COFS(I,J,K) = TMP(I,J,K)
   20 CONTINUE
      DO 30 I = 1,MAXELZ
         GPOMIN(I) = MAX(TENEV,TMP1(I)*1.E-3)
   30 CONTINUE
      END
+DECK,  GPHXSI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:31  cernlib
* Geant

      SUBROUTINE GPHXSI
*.
*.    ******************************************************************
*.    *  Creates PHXS bank containing x-section constants              *
*.    *                                                                *
*.    *    ==>CALLED BY : GPHYSI                                       *
*.    *       AUTHOR : J. CHWASTOWSKI                                  *
*.    *                                                                *
*.    ******************************************************************
*.
*      The photoelectric effect x-section bank
*       1                 - Number of elements neded to create medium = NZ
*       2      <-> NZ+1   -  Z of elements
*       NZ+1   <-> 2*NZ+1 -  0
*       2+2*NZ <-> 3*NZ+1 -  weight of x-section constants
*       3*NZ+2 <-> top    -  X-section constants
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCJLOC.
+CDE, GCONSP.
+CDE, GCUNIT.
+CDE, GCPMXZ.
+CDE, GCPHXS.
+CDE, GC10EV.
      CHARACTER*1 CHSHEL, CHGROU
      DIMENSION EUP(MAXINT),TMP(MAXPOW,MAXINT),ESHL(24)
      PARAMETER (NXSB=73,NXSBF=70)
      Z = Q(JMA+7)
      IPHXSP = 0
* Check Z range of validity for Sandia parametrization
      IF(Z.GE.1.AND.Z.LE.MAXELZ) THEN
*
* Find number of elements neded to create current medium
c
* Is this medium a mixture ?
         NMIX = Q(JMA+11)
         IF(NMIX.GT.1) THEN
            NZ = 0
            JMIXT=LQ(JMA-5)
            DO 10 I = 1,NMIX
               ZCUR = Q(JMIXT+NMIX+I)
               IF(ZCUR.NE.INT(ZCUR)) THEN
*
* When Z is non integer you need 2 elements
                  NZ=NZ+2
               ELSE
                  NZ=NZ+1
               ENDIF
   10       CONTINUE
            CALL GWORK(3*NZ+1)
            WS(1) = NZ
*
* Calculate weigths
*
            K = 1
            DO 20 I = 1,NMIX
               ZCUR = Q(JMIXT+NMIX+I)
               HZCUR = INT(ZCUR)
               WS(1+K) = HZCUR
               IF(ZCUR.NE.HZCUR) THEN
                  WS(1+2*NZ+K) = (HZCUR+1.-ZCUR)*Q(JMIXT+2*NMIX+I)
                  K = K+1
                  WS(1+K) = HZCUR+1
                  WS(1+2*NZ+K) = (ZCUR-HZCUR)*Q(JMIXT+2*NMIX+I)
               ELSE
                  WS(1+2*NZ+K) = Q(JMIXT+2*NMIX+I)
               ENDIF
               K = K+1
   20       CONTINUE
*
* Do Z values repeat ?
*
            K = NZ
            DO 40 I = 1,NZ-1
               Z1 = WS(1+I)
               IF(Z1.GT.0.0) THEN
                  DO 30 J = I+1,NZ
                     Z2 = WS(1+J)
                     IF(Z1.EQ.Z2) THEN
*                        WS(1+NZ+I) = WS(1+NZ+I)+WS(1+NZ+J)
                        WS(1+2*NZ+I) = WS(1+2*NZ+I)+WS(1+2*NZ+J)
                        WS(1+J) = -WS(1+J)
                        K = K-1
                     ENDIF
   30             CONTINUE
               ENDIF
   40       CONTINUE
* Now you can book a pht. eff. x-sec. constant bank and hang it as
* a first struc. link from JPHOT.
* From this bank you hang the banks for each separate Z !!!
            NW = NZ*NXSB+2
            IF(K.EQ.1) NW = NXSB+2
            CALL MZBOOK(IXCONS,JPHXS,JPHOT,-1,'PHXS',NZ,NZ,NW,3,0)
* Fill JPHXS bank and calculates the weights
            Q(JPHXS+1) = K
            NZN = K
            K = 1
            DO 50 I = 1,NZ
               IF(WS(1+I).GT.0.0) THEN
                  Q(JPHXS+1+K) = WS(1+I)
*                  Q(JPHXS+1+K+NZN) = WS(1+I+NZ)
                  Q(JPHXS+1+K+2*NZN) = WS(1+I+2*NZ)
                  K = K+1
               ENDIF
   50       CONTINUE
         ELSE
* Current medium consists of one "element"
            NZ = 1
            ZCUR = Z
            HZCUR = INT(ZCUR)
            IF(MOD(ZCUR,HZCUR).EQ.0) THEN
* Now you can book a pht. eff. x-sec. constant bank and hang it as
* a first struc. link from JPHOT.
               NW = NXSB+2
               CALL MZBOOK(IXCONS,JPHXS,JPHOT,-1,'PHXS',1,1,NW,3,0)
               Q(JPHXS+1) = 1.
               Q(JPHXS+2) = ZCUR
               Q(JPHXS+4) = 1.
            ELSE
* Somebody is cheating. We need two elements
               NZ = NZ+1
               NW = 2*NXSB+2
               CALL MZBOOK(IXCONS,JPHXS,JPHOT,-1,'PHXS',2,2,NW,3,0)
               Q(JPHXS+1) = 2.
               Q(JPHXS+2) = HZCUR
               Q(JPHXS+3) = HZCUR+1
               Q(JPHXS+6) = (HZCUR+1.-ZCUR)
               Q(JPHXS+7) = (ZCUR-HZCUR)
            ENDIF
         ENDIF
* We passed the bank booking phase and we can start real work
         NZ = Q(JPHXS+1)
* Create a temporary working space
         IBINS = 5*NZ+NZ*(MAXPOW+1)*(MAXINT+1)
         CALL GWORK(IBINS)
         DO 60 I = 1,IBINS
            WS(I) = 0.0
   60    CONTINUE
         KS = 5*NZ
         L = 0
         DO 170 N = 1,NZ
            JPHXS = LQ(JPHOT-1)
            ZCUR = Q(JPHXS+1+N)
            IZ = ZCUR
            DO 70 I = 1,24
               ESHL(I) = 0.0
   70       CONTINUE
            CALL GFSHLS(ZCUR,ESHL,NSHL)
            DO 80 I = 1,NSHL
               ESHL(I) = ESHL(I)*1.E-3
   80       CONTINUE
* Use Sandia data.
* Find out the interval upper limit.
            IMAX = 0
            DO 90 I = 1,MAXINT
               CHSHEL=CRNGUP(I,IZ)(1:1)
               CHGROU=CRNGUP(I,IZ)(2:2)
               IF(CHSHEL.EQ.'I') THEN
                  EUP(I) = 55.E11
                  IMAX = I
                  GO TO 100
               ELSEIF(CHSHEL.EQ.'K') THEN
                  EUP(I) = ESHL(1)
               ELSEIF(CHSHEL.EQ.'L') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(2)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(3)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(4)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for L '
     +               //'shell.  Maximum coded L3. Found shell '
     +               //'name: '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'M') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(5)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(6)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(7)
                  ELSEIF(CHGROU.EQ.'4') THEN
                     EUP(I) = ESHL(8)
                  ELSEIF(CHGROU.EQ.'5') THEN
                     EUP(I) = ESHL(9)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for M '
     +               //'shell.  Maximum coded M5. Found shell '
     +               //'name: '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'N') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(10)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(11)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(12)
                  ELSEIF(CHGROU.EQ.'4') THEN
                     EUP(I) = ESHL(13)
                  ELSEIF(CHGROU.EQ.'5') THEN
                     EUP(I) = ESHL(14)
                  ELSEIF(CHGROU.EQ.'6') THEN
                     EUP(I) = ESHL(15)
                  ELSEIF(CHGROU.EQ.'7') THEN
                     EUP(I) = ESHL(16)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for N '
     +               //'shell. Maximum coded N7. Found shell name:'
     +               //' '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'O') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(17)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(18)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(19)
                  ELSEIF(CHGROU.EQ.'4') THEN
                     EUP(I) = ESHL(20)
                  ELSEIF(CHGROU.EQ.'5') THEN
                     EUP(I) = ESHL(21)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for O '
     +               //'shell.  Maximum code O5. Found shell name:'
     +               //' '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSEIF(CHSHEL.EQ.'P') THEN
                  IF(CHGROU.EQ.'1') THEN
                     EUP(I) = ESHL(22)
                  ELSEIF(CHGROU.EQ.'2') THEN
                     EUP(I) = ESHL(23)
                  ELSEIF(CHGROU.EQ.'3') THEN
                     EUP(I) = ESHL(24)
                  ELSE
                     CHMAIL = ' GPHXSI Error: Inconsistent data for P '
     +               //'shell.  Maximum coded P3. Found shell '
     +               //'name: '//CRNGUP(I,IZ)
                     CALL GMAIL(0,0)
                  ENDIF
               ELSE
                  READ(CRNGUP(I,IZ),'(F6.0)') EUP(I)
               ENDIF
               IF(EUP(I).EQ.0.0) THEN
                  WRITE(CHMAIL,'(A44,I5)') ' GPHXSI Error: Upper limit '
     +            //'= 0. Interval:',I
                  CALL GMAIL(0,0)
                  STOP 14
               ENDIF
   90       CONTINUE
  100       CONTINUE
            DO 120 I = 1,IMAX
               DO 110 J = 1,MAXPOW
                  TMP(J,I) = COFS(J,I,IZ)*Q(JPHXS+1+2*NZ+N)
  110          CONTINUE
  120       CONTINUE
* Copy upper limits and coofficients to a work bank
            K = KS+1
            WS(K) = GPOMIN(IZ)
            WS(K+1) = 0.0
            WS(K+2) = 0.0
            WS(K+3) = 0.0
            WS(K+4) = 0.0
            K = K+5
            DO 140 I = 1,IMAX
               WS(K) = EUP(I)
               K = K+1
               DO 130 J = 1,MAXPOW
                  WS(K) = TMP(J,I)
                  K = K+1
  130          CONTINUE
  140       CONTINUE
            KS = KS+(MAXINT+1)*(MAXPOW+1)
            IWS(NZ+N) = IMAX
            IWS(2*NZ+N) = 0
            IWS(3*NZ+N) = 0
*            WS(N) = Q(JPHXS+1+2*NZ+N)
* Create element x-section & final state bank
            CALL MZBOOK(IXCONS,JPHFN,JPHXS,-N,'PHFN',0,0,IMAX*5+1,3,0)
            Q(JPHFN+1) = IMAX
* Update pointer
            JPHFN = JPHFN+1
            KFN = 1
* Copy energy & x-section parameters
            DO 160 I = 1,IMAX
               Q(JPHFN+KFN) = EUP(I)
               KFN = KFN+1
               DO 150 J = 1,MAXPOW
c                  Q(JPHFN+KFN) = TMP(J,I)*Q(JPHXS+1+2*NZ+N)
                  Q(JPHFN+KFN) = TMP(J,I)
                  KFN = KFN+1
  150          CONTINUE
  160       CONTINUE
* Get shells decay parameters
            CALL GFSHDC(N,ZCUR)
  170    CONTINUE
* Now find intervals and calculate the coofs for each
         K = 0
         JPHXS = LQ(JPHOT-1)
         IF(NZ.LT.2) THEN
* Simple element so life is easy and nice
            Q(JPHXS+5) = IMAX+1
            JPHXS6 = JPHXS+6
            Q(JPHXS6) = GPOMIN(IZ)
            Q(JPHXS6+1) = 0.0
            Q(JPHXS6+2) = 0.0
            Q(JPHXS6+3) = 0.0
            Q(JPHXS6+4) = 0.0
            JPHXS6 = JPHXS6+5
            DO 190 I = 1,IMAX
               Q(JPHXS6+K) = EUP(I)
               K = K+1
               DO 180 J = 1,MAXPOW
                  Q(JPHXS6+K) = TMP(J,I)
                  K = K+1
  180          CONTINUE
  190       CONTINUE
            NPSH = NW-5*(IMAX+1)-5
         ELSE
* More elements. It will not be so easy
* The following code is difficult and probably there are better solutions
* but I could think only about this one.
            IPHXSP = JPHXS+2+3*NZ
            IPIMAX = JPHXS+2+3*NZ
            IOFFST = (MAXPOW+1)*(MAXINT+1)
            DO 250 II = 1,NZ*(MAXINT+1)
* Find the interval for which the upper limit is the smallest
               AMINV = 1.E20
               DO 200 I = 1,NZ
                  K = IWS(2*NZ+I)
                  IPOINT = 5*NZ+1+(I-1)*IOFFST+K
                  IEUP = 4*NZ+I
                  WS(IEUP) = WS(IPOINT)
                  IF(WS(IEUP).LT.AMINV) AMINV = WS(IEUP)
  200          CONTINUE
               L = 0
               DO 210 I = 1,NZ
                  IF(WS(4*NZ+I).LE.AMINV) L = L+1
  210          CONTINUE
               IF(L.LT.1) THEN
                  CHMAIL = ' GPHXSI Error: Zero intervals found.'
                  CALL GMAIL(0,0)
                  STOP 16
               ENDIF
* Copy to JPHXS bank
               Q(IPIMAX) = Q(IPIMAX)+1.
               Q(IPHXSP+1) = AMINV
               IPHXSP = IPHXSP+1
               DO 230 J = 1,MAXPOW
                  QS = 0.0
                  DO 220 I = 1,NZ
                     K = IWS(2*NZ+I)
                     IPOINT = 5*NZ+1+(I-1)*IOFFST+K+J
c                     QS = QS+WS(I)*WS(IPOINT)
                     QS = QS+WS(IPOINT)
  220             CONTINUE
                  Q(IPHXSP+1) = QS
                  IPHXSP = IPHXSP+1
  230          CONTINUE
               IF(L.EQ.NZ.AND.AMINV.EQ.55.E11) GO TO 260
* Update local pointers
               DO 240 I = 1,NZ
                  IEUP = 4*NZ+I
                  IF(WS(IEUP).LE.AMINV) THEN
                     INZ2 = 2*NZ+I
                     IF(IWS(3*NZ+I).LT.IWS(I+NZ)) THEN
                        IWS(INZ2) = IWS(INZ2)+5
                        IWS(3*NZ+I) = IWS(3*NZ+I)+1
                     ENDIF
                  ENDIF
  240          CONTINUE
  250       CONTINUE
* It is THE END of th x-secs. part, however you may not believe it.
  260       CONTINUE
            NIT=Q(IPIMAX)
            IIT = -1
  261       IIT = IIT+1
*
* It just may happen that some of the energy limits are the same
               IENE=IIT*5+1
               IF(ABS(Q(IPIMAX+IENE)-Q(IPIMAX+IENE+5)).LT.
     +                                Q(IPIMAX+IENE)*5E-4) THEN
                  DO 262 II=1,(NIT-IIT-1)*5
                     Q(IPIMAX+IENE+II)=Q(IPIMAX+IENE+II+5)
  262             CONTINUE
                  NIT=NIT-1
                  IIT=IIT-1
               ENDIF
            IF(IIT.LT.NIT-1) GO TO 261
            Q(IPIMAX)=NIT
            NPSH = NW-Q(IPIMAX)*5-3*NZ-2
         ENDIF
* Return unused locations in JPHXSI bank to the system
         IF(NPSH.GT.0) THEN
            JPHXS = LQ(JPHOT-1)
            CALL MZPUSH(IXCONS,JPHXS,0,-NPSH,'R')
         ENDIF
      ELSEIF(Z.GT.100.) THEN
* Just in case we got called
         CHMAIL = ' GPHXSI Error: Z > 100. No Sandia parameters. '
         CALL GMAIL(0,0)
      ENDIF
      END
+DECK,  GPHYS_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:21:19  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                  Introduction to the section PHYS                    *
*                  --------------------------------                    *
*                                                                      *
*                                                                      *
* THE PHYSICS PROCESSES                                                *
*                                                                      *
*  The processes  currently implemented in GEANT3  can be classified   *
* as follows:                                                          *
*                                                                      *
* - Decays in flight                                                   *
* - Multiple scattering (Gaussian or Moliere)                          *
* - Continuous electromagnetic processes                               *
* - Discrete electromagnetic processes                                 *
* - Hadronic interactions                                              *
* - Muon nucleus-interactions.                                         *
*                                                                      *
*  The  fist  two  are  controlled  by  the  routines  GDECAY  which   *
* generates the decay products and  GMULTS which computes the change   *
* in  the angle  due to  multiple scattering  over a  given tracking   *
* step.   The  others  are  reviewed  separately  in  the  following   *
* paragraphs.                                                          *
*  For  convenience the  particles are  given a  'tracking type'  in   *
* GEANT, depending on their interaction with matter:                   *
*                                                                      *
*   ITRTYP = 1  photon                                                 *
*            2  electron and positron                                  *
*            3  neutral particles                                      *
*            4  charged hadrons                                        *
*            5  muon                                                   *
*            6  'Geantino'                                             *
*            7  Cerenkov photon                                        *
*            8  Ion                                                    *
*                                                                      *
*  The  paragraph  5  gives  a  summary  of  the  physics  processes   *
* activated for  each type  of particle with  the momentum  range of   *
* validity when relevant.  GPHYSI controls the initialisation of the   *
* various processes.                                                   *
*                                                                      *
* CONTINUOUS ELECTROMAGNETIC PROCESSES                                 *
*                                                                      *
* GMOLI     Initializes Moliere scattering                             *
* GPROBI    initializes material 'constants'  used for computing the   *
*           probability of various interactions.                       *
* GDRELA    Control routine  to fill   DE/DX tables for  energy loss   *
*           due to ionisation.                                         *
* GDRELP    Calculates  energy loss  due to  ionisation for  charged   *
*           particles other than electrons and positrons.              *
* GDRELE    Calculates energy  loss due to ionisation  for electrons   *
*           and  positrons.  As  Moller  and  Bhabba scattering  are   *
*           treated  as discrete  processes the  energy loss  due to   *
*           ionisation is a function  of the electron kinetic energy   *
*           cut-off DCUTE below which these processes are treated as   *
*           a continuous energy loss [BASE 030, common /GCPHYS/].      *
* GBRELA    Initializes   Bremsstrahlung  cross-section   and  fills   *
*           energy  loss tables  for Bremsstrahlung.   Both formulae   *
*           depend on  the photon  energy cut-off BCUTE  below which   *
*           Bremsstrahlung is  treated as  a continuous  energy loss   *
*           [BASE 030, common /GCPHYS/].                               *
* GPRELA    Fills  DE/DX  tables  for  energy loss  by  direct  pair   *
*           production  for high  energy  muons.  The  corresponding   *
*           discrete process is not considered.                        *
* GRANGI    Calculates    the    stopping     range    tables    for   *
*           electron/positron, muon and proton.                        *
* GMULOF    Calculates the tables for the maximum step allowed to to   *
*           continuous processes: Bending  in magnetic field, energy   *
*           loss and multiple scattering.                              *
* GCOEFF    Calculates  the   interpolation  coefficients   for  the   *
*           energy/Range relation  to be used in  the calculation of   *
*           the energy loss.                                           *
*                                                                      *
* DISCRETE ELECTROMAGNETIC PROCESSES                                   *
*                                                                      *
*   For the simulation of each  given discrete physics process three   *
* tasks have to be performed:                                          *
*                                                                      *
* - The evaluation  of the step  length.  This is computed  from the   *
*   updated  probability for  the  occurrence of  the process.   The   *
*   corresponding code  has been  inserted directly in  the tracking   *
*   routines for each tracking type as appropriate.                    *
* - After transport  of the  particle, the  generation of  the final   *
*   state particles (GEANT routines GPHOT, GCOMP, etc.)                *
* - If the  particle survives  after the interaction,  recompute the   *
*   probability.                                                       *
*                                                                      *
*   It should be outlined that the  evaluation of the step length is   *
* made independently  for each  process which  can occur,  the final   *
* step  size  being the  minimum  of  all  and the  process  finally   *
* considered being the corresponding one.                              *
*                                                                      *
* GPHOTI    Tabulates  cross-section  for photo-electric  effect  at   *
*           initialisation time                                        *
* GPHOT     Simulates photo-electric mechanism                         *
* GCOMPI    Tabulates  cross-section  for  Compton  intersection  at   *
*           initialisation time                                        *
* GCOMP     Simulates Compton scattering                               *
* GPRSGA    Tabulates   cross-section   for   pair   production   at   *
*           initialisation time                                        *
* GPAIRG    Simulates electron pair production by photons              *
* GBRSGA    Tabulates    cross-section    for   Bremsstrahlung    at   *
*           initialisation time                                        *
* GBREME    Simulates  hard  Bremsstrahlung   by  electrons.  -  see   *
*           cut-off BCUTE in routine GBRELA above                      *
* GDRSGA    Tabulates cross-section for  delta-ray at initialisation   *
*           time                                                       *
* GDRAY     Simulates delta rays (Moller or Bhabba scattering) - see   *
*           cut-off DCUTE in routine GDRELE above                      *
* GANNII    Tabulates  cross-section  for positron  annihilation  at   *
*           initialisation time                                        *
* GANNI     Simulates positron annihilation in flight                  *
* GANNIR    Simulates positron annihilation at rest.                   *
* GPFISI    Tabulates cross-section for photo-fission                  *
* GPFIS     Simulates photo-fission                                    *
*                                                                      *
* HADRONIC PROCESSES                                                   *
*                                                                      *
*   For GHEISHA:                                                       *
* GPGHEI    returns the hadronic cross section                         *
* GHEISH    Simulates  hadronic  interactions, program  GHEISHA  (H.   *
*           Fesefeldt) in GEANH file.                                  *
*                                                                      *
*   For FLUKA:                                                         *
* FLDIST    returns the hadronic cross section                         *
* FLUFIN    Simulates    hadronic   interactions,    program   FLUKA   *
*           (A.Ferrari et al.) in GEANH file.                          *
*                                                                      *
* MUON INTERACTION                                                     *
*                                                                      *
* GBRELM    Tabulates energy loss by soft Bremsstrahlung               *
* GBRSGM    Tabulates cross-section for hard Bremsstrahlung            *
* GBREMM    Generates hard Bremsstrahlung                              *
* GPAIRI    Tabulates cross-section for direct pair production         *
* GPAIRM    Generate direct pair production                            *
* GMUNUI    Tabulates cross-section for nuclear interaction            *
* GMUNU     Generates nuclear interaction                              *
* GDRELM    Tabulates energy loss by soft delta rays                   *
* GDRSGA    Tabulates cross-section for hard delta rays                *
* GDRAY     Generates delta rays                                       *
*                                                                      *
************************************************************************
#endif
+DECK,  GPHYSI, T=FORT.
* Revision 1.3  1999/09/15 16:09:36  mclareni
* Change In to In.m in Formats to improve the appearance of date and time in Y2k
* Revision 1.2  1996/09/30 13:28:58  ravndal
* Medium name length checked
* Revision 1.1.1.1  1995/10/24 10:21:31  cernlib
* Geant

      SUBROUTINE GPHYSI
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialise material constants for all the physics        *
C.    *       mechanisms used by GEANT                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCCUTS.
+CDE, GCFLAG.
+CDE, GCJLOC.
+CDE, GCLIST.
+CDE, GCMULO.
+CDE, GCTMED.
+CDE, GCMATE.
+CDE, GCNUM.
+CDE, GCONSP.
+CDE, GCTIME.
+CDE, GCTRAK.
+CDE, GCUNIT.
      DIMENSION CUTS(10),UCUT(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      CHARACTER*4 DNAME,KCUT(10)
      CHARACTER*20 CHTITL
      LOGICAL NUCRIN
C.
C.    ------------------------------------------------------------------
C.
C              Write RUN parameters, version numbers and CUTS
C
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10200)GVERSN,IGDATE,IGTIME
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10300)IDRUN
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10400)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10500)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10600)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
C
C              Get the version number of the original INIT structure
C
      OLDGVE=BIG
*
*        Set NUMOLD to 0 to force recalculation of
*        pointers in the tracking routines
      NUMOLD=0
      IF(JRUNG.NE.0)THEN
         OLDGVE =  Q(JRUNG+21)
         IQ(JRUNG+11)=IGDATE
         IQ(JRUNG+12)=IGTIME
         Q(JRUNG+21)=GVERSN
         Q(JRUNG+22)=ZVERSN
C
         DNAME='INIT'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+11),IQ(JRUNG+12), Q(JRUNG+
     +   21), Q(JRUNG+22)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         DNAME='KINE'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+13),IQ(JRUNG+14), Q(JRUNG+
     +   23), Q(JRUNG+24)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         DNAME='HITS'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+15),IQ(JRUNG+16), Q(JRUNG+
     +   25), Q(JRUNG+26)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         DNAME='DIGI'
         WRITE(CHMAIL,10700) DNAME,IQ(JRUNG+17),IQ(JRUNG+18), Q(JRUNG+
     +   27), Q(JRUNG+28)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         IF(NRNDM(1).EQ.0.AND.NRNDM(2).EQ.0) THEN
*
*             The random number sequence has not been explicitely
*             initialised via a data card. See whether we can initialise
*             it with the words 19/20 of the JRUNG data structure.
            IF(IQ(JRUNG+19).NE.0.OR.IQ(JRUNG+20).NE.0) THEN
               NRNDM(1) = IQ(JRUNG+19)
               NRNDM(2) = IQ(JRUNG+20)
               CALL GRNDMQ(NRNDM(1), NRNDM(2), 0, 'S')
            ENDIF
         ENDIF
         CALL GRNDMQ(IQ(JRUNG+19), IQ(JRUNG+20), 0, 'G')
         WRITE(CHMAIL,10900) IQ(JRUNG+19), IQ(JRUNG+20)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,11000)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
      ENDIF
C
C             Create energy loss and cross-section banks
C
      IF(NEKBIN.LE.0.OR.NEKBIN.GT.199)NEKBIN=90
      IF(EKMIN.GE.EKMAX.OR.EKMIN.LE.0.)THEN
         EKMIN=1.E-5
         EKMAX=1.E+4
      ENDIF
      NEK1=NEKBIN+1
      EKINV=1./LOG10(EKMAX/EKMIN)
      EKBIN(1)=LOG10(EKMIN)
      ELOW(1)=EKMIN
      GEKA=NEKBIN*EKINV
      GEKB=1.-GEKA*EKBIN(1)
      DO 10 I=2,NEK1
         EL=EKBIN(1)+(I-1)/GEKA
         EKBIN(I)=EL
         ELOW(I)=10.**EL
   10 CONTINUE
      ILOW=0
      IF(NMATE.LE.0)GO TO 999
      IF(JMATE.LE.0)GO TO 999
      IF(JTMED.LE.0)GO TO 999
C
      IF(IQ(JTMED-1).LT.40) THEN
         NPUSH=40-IQ(JTMED-1)
         CALL MZPUSH(IXCONS,JTMED,0,NPUSH,'I')
      END IF
      Q(JTMED+31)=ILABS
      Q(JTMED+32)=ISYNC
      Q(JTMED+33)=ISTRA
*
*             If Landau fluctuations activated, cancel delta rays
      KLOS=Q(JTMED+21)
      IF (KLOS .EQ. 0) Q(JTMED+15) = 0.
      IF (KLOS .EQ. 2) THEN
         Q(JTMED+ 8)=9999.
         Q(JTMED+ 9)=9999.
         Q(JTMED+15)=0.
      ENDIF
*
* If Cerenkov generation is on, activate Light absorbtion unless
* explicitely switched off by the user
*
      KLABS=Q(JTMED+31)
      IF(ITCKOV.NE.0) THEN
         IF(KLABS.EQ.-1) THEN
            Q(JTMED+31)=1
         ENDIF
      ENDIF
      Q(JTMED+31)=MAX(Q(JTMED+31),0.)
*
*             If BCUTE,BCUTM,DCUTE,DCUTM,PPCUTM not initialized (=BIG)
*             Set them to CUTGAM,CUTGAM,CUTELE,CUTELE respectively
*
      IF(Q(JTMED+ 6).GT.0.9*BIG)Q(JTMED+ 6)=Q(JTMED+1)
      IF(Q(JTMED+ 7).GT.0.9*BIG)Q(JTMED+ 7)=Q(JTMED+1)
      IF(Q(JTMED+ 8).GT.0.9*BIG)Q(JTMED+ 8)=Q(JTMED+2)
      IF(Q(JTMED+ 9).GT.0.9*BIG)Q(JTMED+ 9)=Q(JTMED+2)
      IF(Q(JTMED+10).GT.0.9*BIG)Q(JTMED+10)=0.010
      IF(Q(JTMED+10).LT.4.*EMASS)Q(JTMED+10)=4.*EMASS
C
      DO 20 K=1,10
   20 CALL GEVKEV(Q(JTMED+K),UCUT(K),KCUT(K))
      WRITE(CHMAIL,10800)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11200)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11300) (UCUT(K),KCUT(K),K=1,3)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11400) (UCUT(K),KCUT(K),K=4,5)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11500) (UCUT(K),KCUT(K),K=6,7)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11600) (UCUT(K),KCUT(K),K=8,10)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11700) (Q(JTMED+K),K=11,13)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,11800) (Q(JTMED+K),K=14,16)
      CALL GMAIL(0,0)
      IF(Q(JTMED+18).EQ.3.) THEN
         NUCRIN = .TRUE.
         Q(JTMED+18)=1.
      ELSE
         NUCRIN = .FALSE.
      ENDIF
      WRITE(CHMAIL,11900) (Q(JTMED+K),K=17,19)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,12000) (Q(JTMED+K),K=20,22)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,12100) Q(JTMED+23),Q(JTMED+31),Q(JTMED+32)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,12110) Q(JTMED+33)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      IF(NUCRIN) THEN
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,12800)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,12900)
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)
         CALL GMAIL(0,0)
      ENDIF
*
* ***    Here we clean up the old cross section tables if any
      DO 40  IMA=1,NMATE
         JMA=LQ(JMATE-IMA)
         IF(JMA.NE.0) THEN
            DO 30  J=1,20
               IF(LQ(JMA-J).NE.0.AND.J.NE.5) THEN
                  CALL MZDROP(IXCONS,LQ(JMA-J),'L')
               ENDIF
   30       CONTINUE
         ENDIF
   40 CONTINUE
*
* *** Call initialisation of the phtotelectric effect constants
      CALL GPHINI
      DO 180 ITM=1,NTMED
         JTM=LQ(JTMED-ITM)
         IF(JTM.LE.0) GO TO 180
         NL=10-IQ(JTM-2)
         IF(NL.GT.0)THEN
            CALL MZPUSH(IXCONS,JTM,NL,0,'I')
            JTM=LQ(JTMED-ITM)
         ENDIF
*         IF(IQ(JTM-1).LT.40) THEN
*           NPUSH=40-IQ(JTM-1)
*           CALL MZPUSH(IXCONS,JTM,0,NPUSH,'I')
*           JTM=LQ(JTMED-ITM)
*         ENDIF
         ISVOL = Q(JTM + 7)
         IFIELD = Q(JTM + 8)
         FIELDM = Q(JTM + 9)
         TMAXFD = Q(JTM + 10)
         STEMAX = Q(JTM + 11)
         DEEMAX = Q(JTM + 12)
         EPSIL = Q(JTM + 13)
         STMIN = Q(JTM + 14)
         IF (TMAXFD.LE.0..OR. (IGAUTO.NE.0.AND.TMAXFD.GT.20.)) THEN
            TMAXFD=20.
            Q(JTM+10) = TMAXFD
         ENDIF
         NMAT = Q(JTM+6)
         JMA = LQ(JMATE-NMAT)
         IF(JMA.LE.0)THEN
            WRITE(CHMAIL,12200)NMAT,ITM
            CALL GMAIL(1,1)
            GO TO 180
         ENDIF
C
C=====>       Get material parameters
C
         A=Q(JMA+6)
         Z=Q(JMA+7)
         DENS=Q(JMA+8)
         RADL=Q(JMA+9)
         IF (Z.LT.1.) THEN
            DEEMAX=0.
            STMIN =0.
            JTP=LQ(JTM)
            IF(JTP.EQ.0) THEN
               CALL MZBOOK(IXCONS,JTP,JTM,0,'TCUT',0,0,40,3,0)
               IQ(JTP-5)=ITM
               DO 50 I=1,23
                  Q(JTP+I)=Q(JTMED+I)
   50          CONTINUE
               Q(JTP+31)=Q(JTMED+31)
               Q(JTP+32)=Q(JTMED+32)
               Q(JTP+33)=Q(JTMED+33)
            ELSEIF(IQ(JTP-1).LT.40) THEN
               NPUSH=40-IQ(JTP-1)
               CALL MZPUSH(IXCONS,JTP,0,NPUSH,'I')
               JTP=LQ(JTM)
               Q(JTP+31)=Q(JTMED+31)
               Q(JTP+32)=Q(JTMED+32)
               Q(JTP+33)=Q(JTMED+33)
            ENDIF
C
C=====>     decay and synch. rad. in vacuum
C
            DO 60 I=11,23
               Q(JTP+I)=0.
   60       CONTINUE
            Q(JTP+20) = Q(JTMED+20)
            Q(JTP+31) = 0.
            Q(JTP+32) = Q(JTMED+32)
            Q(JTP+33) =0.
         ENDIF
C
C=====>       Get tracking medium parameters
C
         JTP=JTMED
         IF(LQ(JTM).NE.0)JTP=LQ(JTM)
         IF(JTP.NE.JTMED)THEN
            IF(IQ(JTP-1).LT.40) THEN
               NPUSH=40-IQ(JTP-1)
               CALL MZPUSH(IXCONS,JTP,0,NPUSH,'I')
               JTP=LQ(JTM)
               Q(JTP+31)=Q(JTMED+31)
               Q(JTP+32)=Q(JTMED+32)
               Q(JTP+33)=Q(JTMED+33)
            ENDIF
            KLOS=Q(JTP+21)
            IF (KLOS .EQ. 2) THEN
               Q(JTP+ 8)=9999.
               Q(JTP+ 9)=9999.
               Q(JTP+15)=0.
            ENDIF
*
* If Cerenkov generation is on, activate Light absorbtion unless
* explicitely switched off by the user
*
            KLABS=Q(JTP+31)
            IF(ITCKOV.NE.0) THEN
               IF(KLABS.EQ.-1) THEN
                  Q(JTP+31)=1
               ENDIF
            ENDIF
            Q(JTP+31)=MAX(Q(JTP+31),0.)
            IF(Q(JTP+ 6).GT.0.9*BIG)Q(JTP+ 6)=Q(JTP+1)
            IF(Q(JTP+ 7).GT.0.9*BIG)Q(JTP+ 7)=Q(JTP+1)
            IF(Q(JTP+ 8).GT.0.9*BIG)Q(JTP+ 8)=Q(JTP+2)
            IF(Q(JTP+ 9).GT.0.9*BIG)Q(JTP+ 9)=Q(JTP+2)
            IF(Q(JTP+10).GT.0.9*BIG)Q(JTP+10)=0.010
            IF(Q(JTP+10).LT.4.*EMASS)Q(JTP+10)=4.*EMASS
*
            CALL UHTOC(IQ(JTM+1),4,CHTITL,20)
            LAST=LNBLNK(CHTITL)
            IF(LAST.GT.0) THEN
               IF(CHTITL(LAST:LAST).EQ.'$') LAST=LAST-1
               IF(LAST.LT.20) CHTITL(LAST+1:20)=' '
            ENDIF
*
            DO 70 K=1,10
   70       CALL GEVKEV(Q(JTP+K),UCUT(K),KCUT(K))
            WRITE(CHMAIL,10100)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12300)ITM,CHTITL
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12400)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11300) (UCUT(K),KCUT(K),K=1,3)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11400) (UCUT(K),KCUT(K),K=4,5)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11500) (UCUT(K),KCUT(K),K=6,7)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11600) (UCUT(K),KCUT(K),K=8,10)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11700) (Q(JTP+K),K=11,13)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,11800) (Q(JTP+K),K=14,16)
            CALL GMAIL(0,0)
            IF(Q(JTP+18).EQ.3.) THEN
               NUCRIN = .TRUE.
               Q(JTP+18)=1.
            ELSE
               NUCRIN = .FALSE.
            ENDIF
            WRITE(CHMAIL,11900) (Q(JTP+K),K=17,19)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12000) (Q(JTP+K),K=20,22)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12100) Q(JTP+23),Q(JTP+31),Q(JTP+32)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,12110) Q(JTP+33)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10100)
            CALL GMAIL(0,0)
            IF(NUCRIN) THEN
               WRITE(CHMAIL,10100)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,12800)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,12900)
               CALL GMAIL(0,0)
               WRITE(CHMAIL,10100)
               CALL GMAIL(0,0)
            ENDIF
         ENDIF
C
         DO 80 I=1,10
            CUTS(I)=Q(JTP+I)
   80    CONTINUE
         DO 90 I=1,13
            MECA(1,I)=Q(JTP+10+I)
   90    CONTINUE
         ILABS=Q(JTP+10+21)
         ISYNC=Q(JTP+10+22)
         ISTRA=Q(JTP+10+23)
C
         IF(ILOW.EQ.0)THEN
            DO 100 I=1,10
               IF(Q(JTP+I).LT.0.0000099)THEN
                  WRITE(CHMAIL,12500)
                  CALL GMAIL(1,1)
                  ILOW=1
               ENDIF
  100       CONTINUE
         ENDIF
C
C             Check consistency of different tracking media
C             referencing the same material
C
         DO 120 ITM2=ITM+1,NTMED
            JTM2=LQ(JTMED-ITM2)
            IF(JTM2.NE.0)THEN
               NMAT2=Q(JTM2+6)
               IF(NMAT2.EQ.NMAT)THEN
                  JTP2=JTMED
                  IF(LQ(JTM2).NE.0)JTP2=LQ(JTM2)
                  IF(JTP.NE.JTP2)THEN
                     IF(JTP2.NE.JTMED)THEN
                        KLOS=Q(JTP2+21)
                        IF (KLOS .EQ. 2) THEN
                           Q(JTP2+ 8)=9999.
                           Q(JTP2+ 9)=9999.
                           Q(JTP2+15)=0.
                        ENDIF
                        IF(Q(JTP2+ 6).GT.0.9*BIG)Q(JTP2+ 6)=Q(JTP2+1)
                        IF(Q(JTP2+ 7).GT.0.9*BIG)Q(JTP2+ 7)=Q(JTP2+1)
                        IF(Q(JTP2+ 8).GT.0.9*BIG)Q(JTP2+ 8)=Q(JTP2+2)
                        IF(Q(JTP2+ 9).GT.0.9*BIG)Q(JTP2+ 9)=Q(JTP2+2)
                        IF(Q(JTP2+10).GT.0.9*BIG)Q(JTP2+10)=0.010
                        IF(Q(JTP2+10).LT.4.*EMASS)Q(JTP2+10)=4.*EMASS
                     ENDIF
                     DO 110 I=6,10
                        IF(Q(JTP+I).NE.Q(JTP2+I))THEN
                           WRITE(CHMAIL,12600)NMAT
                           CALL GMAIL(1,0)
                           WRITE(CHMAIL,12700)ITM,ITM2
                           CALL GMAIL(0,1)
                           GO TO 120
                        ENDIF
  110                CONTINUE
                  ENDIF
               ENDIF
            ENDIF
  120    CONTINUE
         IF (DEEMAX.LT.0.) THEN
            IF(ISVOL.EQ.0)THEN
               DEEMAX=0.25
               IF(RADL.GT.2.)DEEMAX=0.25-0.2/SQRT(RADL)
            ELSE
               DEEMAX = 0.2/SQRT(RADL)
            ENDIF
         ENDIF
         IF(OLDGVE.LT.3.15.OR.STEMAX.LE.0.) THEN
*
*       Before version 3.15 there was no STEMAX, so we put it to BIG
            STEMAX=BIG
         ENDIF
         Q(JTM+11) = STEMAX
         Q(JTM+12) = DEEMAX
C
*
*       It can happen that several tracking media refer to the
*       same material. In this case we do not fill the cross section
*       tables more than once. But we still fill the banks of the
*       tracking medium.
         IF(LQ(JMA-1).NE.0) GOTO 160
         NPUSH=20-IQ(JMA-2)
         IF(NPUSH.GT.0)THEN
            CALL MZPUSH(IXCONS,JMA,NPUSH,0,'I')
            JTM=LQ(JTMED-ITM)
            JMA=LQ(JMATE-NMAT)
         ENDIF
*
*     Energy loss and cross-section tables
         IF(ISTRA.EQ.0) THEN
         CALL MZBOOK(IXCONS,LBANK,JMA, -1,'MAEL',0,0,2*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA, -2,'MAMU',0,0, NEK1,3,0)
         ELSE
         CALL MZBOOK(IXCONS,LBANK,JMA, -1,'MAEL',0,0,3*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA, -2,'MAMU',0,0,2*NEK1,3,0)
         ENDIF
         CALL MZBOOK(IXCONS,LBANK,JMA, -3,'MAAL',0,0, NEK1,3,0)
         CALL MZBOOK(IXCONS,JPROB,JMA, -4,'MAPR',0,0, 40,3,0)
         CALL MZBOOK(IXCONS,JPHOT,JMA, -6,'MAPH',2,2, NEK1,3,0)
         CALL MZBOOK(IXCONS,JANNI,JMA, -7,'MAAN',0,0, NEK1,3,0)
         CALL MZBOOK(IXCONS,JCOMP,JMA, -8,'MACO',0,0, NEK1,3,0)
         CALL MZBOOK(IXCONS,JBREM,JMA, -9,'MABR',0,0,3*NEK1,3,0)
         CALL MZBOOK(IXCONS,JPAIR,JMA,-10,'MAPA',0,0,2*NEK1,3,0)
         CALL MZBOOK(IXCONS,JDRAY,JMA,-11,'MADR',0,0,3*NEK1,3,0)
*
* *** Special case for heavy materials, photo-fission
         IF(A.GE.230..AND.A.LE.240..AND.IPFIS.NE.0)THEN
            CALL MZBOOK(IXCONS,JPFIS,JMA,-12,'MAPF',0,0,2*NEK1,3,0)
         ENDIF
*
* *** Rayleigh effect
         CALL MZBOOK(IXCONS,JRAYL,JMA,-13,'MARA',0,0,2*NEK1,3,0)
*
* *** Muon nuclear interactions
         IF(IMUNU.EQ.0)THEN
            JMUNU=0
         ELSE
            CALL MZBOOK(IXCONS,JMUNU,JMA,-14,'MAMN',0,0,NEK1,3,0)
         ENDIF
*
* *** stopping range
         CALL MZBOOK(IXCONS,LBANK,JMA,-15,'MASE',0,0,2*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA,-16,'MASM',0,0,2*NEK1,3,0)
*
* *** Special for photeffect
         CALL GPHXSI
*
* *** coefficients for energy loss
         CALL MZBOOK(IXCONS,LBANK,JMA,-17,'MACE',0,0,6*NEK1,3,0)
         CALL MZBOOK(IXCONS,LBANK,JMA,-18,'MACM',0,0,6*NEK1,3,0)
*
* *** auxiliary tables for integration of dE/dx
         CALL GWORK(NEKBIN*4)
*
         DO 130 JWORK=1, NEKBIN*4
            WS(JWORK) = 0.
  130    CONTINUE
*
* *** Straggling for thin layers, if in effect
         IF(ISTRA.GT.0) THEN
            CALL MZBOOK(IXCONS,JTSTRA,JMA,-19,'MAST',2,2,1,3,0)
+SELF, IF=ASHO.
            IF(ISTRA.EQ.2) THEN
               CALL MZBOOK(IXCONS,JTASHO,JMA,-20,'MASH',0,0,106,3,0)
            ENDIF
+SELF.
         ENDIF
*
         DO 140 J=1,20
            JB=LQ(JMA-J)
            IF(JB.NE.0)IQ(JB-5)=NMAT
  140    CONTINUE
C
         JPROB=LQ(JMA-4)
         JMIXT=LQ(JMA-5)
         JPFIS=LQ(JMA-12)
*
* *** Fill above tables (energy losses,cross-sections,stopping ranges)
*
         CALL GPROBI
C
         DO 150 IEKBIN=1,NEK1
C
            CALL GDRELA
            CALL GBRELA
            CALL GPRELA
C
            CALL GPHOTI
            CALL GRAYLI
            CALL GANNII
            CALL GCOMPI
            CALL GBRSGA
            CALL GPRSGA
            CALL GDRSGA
            CALL GMUNUI
            CALL GPFISI
  150    CONTINUE
*
*           Stopping ranges
*
         CALL GRANGI
*
*           Energy loss coefficients
*
         CALL GCOEFF
* *** The table for the energy loss in thin gas layers if the tracking
*     media is defined as such
*
         IF(ISTRA.GT.0) THEN
            CALL GSTINI
+SELF, IF=ASHO.
            IF (ISTRA.EQ.2) THEN
               CALL GIASHO
            ENDIF
+SELF.
         ENDIF
*
* *** Multiple scattering,energy-loss and mag.field steps
  160    DO 170 J=1,2
            IF(LQ(JTM-J).NE.0) THEN
               CALL MZDROP(IXCONS,LQ(JTM-J),'L')
            ENDIF
  170    CONTINUE
         CALL MZBOOK(IXCONS,LBANK,JTM, -1,'MUEL',0,0,NEK1+2,3,0)
         IQ(LBANK-5)=ITM
         CALL MZBOOK(IXCONS,LBANK,JTM, -2,'MUMU',0,0,NEK1+2,3,0)
         IQ(LBANK-5)=ITM
         CALL GMULOF
C
  180 CONTINUE
*
      WRITE(CHMAIL,10100)
      CALL GMAIL(0,0)
      WRITE(CHMAIL,10400)
      CALL GMAIL(0,2)
C
10000 FORMAT(
     +'1************************************************************')
10100 FORMAT(
     +' *                                                          *')
10200 FORMAT(
     +' *    G E A N T  Version',F7.4,'      DATE/TIME',I7.6,'/',
     +   I4.4,2X,'*')
10300 FORMAT(
     +' *                      R U N  ',I5,10X,'              *')
10400 FORMAT(
     +' ************************************************************')
10500 FORMAT(
     +' *      Data structure   Date   Time    GVERSN    ZVERSN    *')
10600 FORMAT(
     +' *      --------------   ----   ----    ------    ------    *')
10700 FORMAT(' *',11X,A,6X,I7.6,2X,I4.4,3X,F7.4,2X,F7.2,5X,'*')
10800 FORMAT(
     +' *----------------------------------------------------------*')
10900 FORMAT(' *     Random number seeds: ',3X,I10,3X,I10,6X,'*')
11000 FORMAT(
     +' *     --------------------                                 *')
11100 FORMAT(
     +' *              Standard TPAR for this run are              *')
11200 FORMAT(
     +' *              ------------------------------              *')
11300 FORMAT(
     +' *  CUTGAM=',F6.2,A4,'  CUTELE=',F6.2,A4,'  CUTNEU=',F6.2,A4,1X,
     + '*')
11400 FORMAT(
     +' *  CUTHAD=',F6.2,A4,'  CUTMUO=',F6.2,A4,20X,'*')
11500 FORMAT(
     +' *  BCUTE =',F6.2,A4,'  BCUTM =',F6.2,A4,20X,'*')
11600 FORMAT(
     +' *  DCUTE =',F6.2,A4,'  DCUTM =',F6.2,A4,'  PPCUTM=',F6.2,A4,1X,
     + '*')
11700 FORMAT(
     +' *  IPAIR =',F10.0,'  ICOMP =',F10.0,'  IPHOT =',F10.0,1X,'*')
11800 FORMAT(
     +' *  IPFIS =',F10.0,'  IDRAY =',F10.0,'  IANNI =',F10.0,1X,'*')
11900 FORMAT(
     +' *  IBREM =',F10.0,'  IHADR =',F10.0,'  IMUNU =',F10.0,1X,'*')
12000 FORMAT(
     +' *  IDCAY =',F10.0,'  ILOSS =',F10.0,'  IMULS =',F10.0,1X,'*')
12100 FORMAT(
     +' *  IRAYL =',F10.0,'  ILABS =',F10.0,'  ISYNC =',F10.0,1X,'*')
12110 FORMAT(
     +' *  ISTRA =',F10.0, 39X,                                  '*')

12200 FORMAT(' ***** GPHYSI error, Material Nr=',I3,
     + ' referenced by Medium Nr=',I3)
12300 FORMAT(
     +' *     Special TPAR for TMED',I4,3X,A,5X,'*')
12400 FORMAT(
     +' *     -------------------------                            *')
12500 FORMAT(' ***** GPHYSI error, CUTS must be',
     + ' greater than 10 KeV *****')
12600 FORMAT(' ***** GPHYSI error for material nr ',I4)
12700 FORMAT(7X,'Tracking medium NR',I4,' and',I4,
     +' have different parameters')
12800 FORMAT(
     +' *  IHADR=3 not supported any more. GHEISHA will handle     *')
12900 FORMAT(
     +' *  hadronic interactions for the above tracking medium     *')
  999 END
+DECK,  GPOISS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:32  cernlib
* Geant

      SUBROUTINE GPOISS(AMVEC,NPVEC,LEN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates  a vector NPVEC of LEN random numbers               *
C.    *  POISSON distribued with mean values AMVEC                     *
C.    *                                                                *
C.    *  If the mean value A greater than PLIM, N is calculated        *
C.    *  according to the Gaussian approximation of the Poisson        *
C.    *  distribution.                                                 *
C.    *                                                                *
C.    *     ==> Called by : GLANDZ,GMCOUL                              *
C.    *                                                                *
C.    *  Author      : L.Urban                                         *
C.    *  Date        : 28.04.1988           Last update :  1.02.1990   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      REAL AMVEC(*),RNDM(2), N
      INTEGER NPVEC(*)
      PARAMETER (PLIM=16.,HMXINT=2E+9)
*
      DO 30 I=1,LEN
*     Protection against negative mean values
         N=0.
         IF(AMVEC(I).GT.0.) THEN
            IF(AMVEC(I).LE.PLIM) THEN
               CALL GRNDM(RNDM,1)
               R=RNDM(1)
               P=EXP(-AMVEC(I))
               S=P
               IF(R.LE.S) GOTO 20
   10          N=N+1.
               P=P*AMVEC(I)/N
               S=S+P
               IF(S.LT.R.AND.P.GT.1.E-30) GOTO 10
            ELSE
               CALL GRNDM(RNDM,2)
               RR=SQRT(-2.*LOG(RNDM(1)))
               PHI=TWOPI*RNDM(2)
               X=RR*COS(PHI)
               N=MIN(MAX(AMVEC(I)+X*SQRT(AMVEC(I)),0.),HMXINT)
            ENDIF
         ENDIF
*
   20    NPVEC(I) = N
   30 CONTINUE
*
      END
+DECK,  GPRELA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:32  cernlib
* Geant

      SUBROUTINE GPRELA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialise energy loss due to direct pair-production  and     *
C.    *  nuclear interactions by muons.                                *
C.    *                                                                *
C     *       A, Direct pair production  <=======                      *
C     *                                                                *
C.    *  The DE/DX expression of MANDO and RONCHI(NUOVO CIMENTO        *
C.    *  9(1952),517) is used which attempts to account for the effect *
C.    *  of atomic electron screening. The screening correction is     *
C.    *  applied above the energy limit defined by C. RICHARD-SERRE    *
C.    *  (CERN 71-18).                                                 *
C.    *                                                                *
C     *       B, Nuclear interactions  <=======                        *
C.    *                                                                *
C.    *  the following expression derived from the Williams-Weizsacker *
C.    *  relation for the virtual photon flux is used :                *
C.    *                                                                *
C.    *      DE/DX = FACTOR * XSEC * E                                 *
C.    *                                                                *
C.    *      where,                                                    *
C.    *      FACTOR  =  2. * N * ALPHA / PI                            *
C.    *      XSEC    =  total photo-nuclear cross-section assumed to   *
C.    *                 be independent of energy. Value of 140 mubarns *
C.    *                 calculated by averaging the results of Hesse   *
C.    *                 et al(Phys. Rev. Lett 25(1970),613).           *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCJLOC.
+CDE, GCMULO.
+CDE, GCMATE.
+CDE, GCPHYS.
+CDE, GCONSP.
+CDE, GCCUTS.
+CDE, GCTRAK.
      DATA XSEC  /140.E-30/
      DATA FACTOR/2.7976238E+21/
C.
C.    ------------------------------------------------------------------
C.
      IF(Z.LT.1.) GOTO 999
      ICHAN=IEKBIN
      T    = ELOW(ICHAN)
      T1   = 10.**(EKBIN(1)+(ICHAN-0.5)/GEKA)
      IF(T.LT.1.)GO TO 999
      E    = T+EMMU
      E1   = T1+EMMU
      IF(JMIXT.EQ.0)THEN
C
C           Element
C
         DEDX = GPRELM(Z,T,PPCUTM)
         DEDX = AVO*DENS*DEDX/A
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DEDX1 = GPRELM(Z,T1,PPCUTM)
            DEDX1 = AVO*DENS*DEDX1/A
         ENDIF
      ELSE
C
C          Compound/Mixture
C
         NLMAT = Q(JMA+11)
         NLM   = IABS(NLMAT)
         DEDX  = 0.
         DEDX1 = 0.
         DO 10 L=1,NLM
            J    = JMIXT+NLM+L
            AA   = Q(J-NLM)
            ZZ   = Q(J)
            WMAT = Q(J+NLM)
            S    = GPRELM(ZZ,T,PPCUTM)
            S    = WMAT*S/AA
            DEDX = DEDX+AVO*DENS*S
*
* *** auxiliary integration point for Range tables
            IF(ICHAN.NE.NEK1) THEN
               S = GPRELM(ZZ,T1,PPCUTM)
               S = WMAT*S/AA
               DEDX1 = DEDX1+AVO*DENS*S
            ENDIF
   10    CONTINUE
      ENDIF
C
C             Nuclear interactions
C
      IF(IMUNU.EQ.0.AND.E.GE.10.) THEN
         DENU=DENS*FACTOR*XSEC*E
*
* *** auxiliary integration point for Range tables
         IF(ICHAN.NE.NEK1) THEN
            DENU1=DENS*FACTOR*XSEC*E1
         ENDIF
      ELSE
         DENU=0.0
         DENU1=0.0
      ENDIF
      IF(DEDX.LT.0.)DEDX=0.
      IF(DENU.LT.0.)DENU=0.
      JEL2=LQ(JMA-2)
      Q(JEL2+ICHAN)=Q(JEL2+ICHAN)+DEDX+DENU
*
* *** auxiliary integration point for Range tables
      IF(ICHAN.NE.NEK1) THEN
         IF(DEDX1.LT.0.)DEDX1=0.
         IF(DENU1.LT.0.)DENU1=0.
         WS(NEKBIN*2+ICHAN)=WS(NEKBIN*2+ICHAN)+DEDX1+DENU1
      ENDIF
C
  999 END
+DECK,  GPRELM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:32  cernlib
* Geant

      FUNCTION GPRELM(Z,T,CUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To calculate DE/DX in GeV*barn/atom for direct           *
C.    *       pair production by muons.                                *
C.    *                                                                *
C.    *    ==>Called by : GPRSGA                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (AKSI=1.19,BETA=1.24,DEL=0.13,VE=0.008)
      PARAMETER (ECMIN=2.044E-3,CONMX=0.130653)
C                               CONMX=0.75*SQRT(2.7182...)*EMMU
+CDE, GCONSP.
      DIMENSION C(100),D(28),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      DATA C1/0.199979E-04,-0.247381E-04, 0.901012E-05,-0.624746E-06
     +      , 0.306301E-08, 0.568134E-09,-0.154371E-04, 0.192663E-04
     +      ,-0.638613E-05, 0.325587E-06, 0.798057E-08,-0.623709E-09
     +      , 0.334831E-04,-0.305301E-04, 0.514764E-05, 0.273273E-07
     +      ,-0.455952E-07, 0.200990E-08,-0.617418E-05,-0.119758E-04
     +      , 0.505842E-05,-0.680982E-06, 0.335650E-07,-0.465426E-09
     +      ,-0.134652E-04, 0.268825E-05, 0.722810E-07,-0.648440E-07
     +      , 0.532560E-08,-0.122207E-09,-0.354308E-05, 0.125249E-05
     +      ,-0.182348E-06, 0.125659E-07,-0.390005E-09, 0.423919E-11
     +      , 0.427113E-05,-0.570105E-05, 0.156413E-05,-0.247880E-07
     +      ,-0.534990E-08, 0.172881E-09,-0.309866E-06, 0.654607E-06
     +      ,-0.885876E-07,-0.148160E-07, 0.814881E-09, 0.144373E-10
     +      ,-0.594089E-07, 0.643470E-08,-0.204298E-07, 0.346177E-08
     +      , 0.451711E-10,-0.115400E-10, 0.849857E-08,-0.485366E-08
     +      , 0.247710E-08,-0.224799E-09,-0.125246E-10, 0.116449E-11/
      DATA C2/0.406000E-08,-0.164080E-07, 0.109450E-07,-0.201483E-08
     +      , 0.889711E-10, 0.583750E-08, 0.523552E-08,-0.713086E-08
     +      , 0.151684E-08,-0.703329E-10, 0.863004E-07,-0.107717E-06
     +      , 0.344991E-07,-0.382381E-08, 0.128222E-09,-0.659685E-07
     +      , 0.283383E-07,-0.263676E-08,-0.978698E-10, 0.109724E-10
     +      , 0.209150E-09, 0.880502E-09,-0.235454E-09, 0.120280E-10
     +      ,-0.120162E-13,-0.814192E-08, 0.402793E-08, 0.952674E-09
     +      ,-0.377756E-09, 0.198358E-10, 0.254519E-08,-0.187283E-08
     +      , 0.168056E-09, 0.293299E-10,-0.221041E-11,-0.233497E-09
     +      , 0.197097E-09,-0.321342E-10, 0.329587E-12, 0.691294E-13/
      DATA D/-0.790941E-07, 0.840429E-07, 0.738033E-08,-0.407627E-07
     +      ,-0.116392E-07, 0.358398E-08, 0.141013E-07, 0.814070E-08
     +      ,-0.423749E-08, 0.173692E-08,-0.174475E-08,-0.185530E-08
     +      , 0.737768E-09, 0.160269E-09,-0.598384E-09, 0.926201E-10
     +      , 0.133740E-09, 0.957004E-11,-0.850466E-10, 0.214267E-10
     +      , 0.967441E-10,-0.181431E-11,-0.324662E-11,-0.579085E-12
     +      ,-0.237465E-11, 0.108081E-10,-0.902849E-11,-0.408422E-11/
C.
C.    ------------------------------------------------------------------
C.
      GPRELM=0.
      IF(CUT.LT.ECMIN) GOTO 999
C
      Z3=Z**0.333333
      E=T+EMMU
      ECMAX=E-CONMX*Z3
      ECMA5=ECMAX*0.2
      X=LOG(E/EMMU)
      IF(CUT.GE.ECMAX) GOTO 160
C
      IF(CUT.LE.ECMA5) THEN
        CCUT=CUT
      ELSE
        CCUT=ECMA5
      ENDIF
      Y=LOG(CCUT/(VE*E))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 999
C
      FAC=E*((CCUT-ECMIN)/E)**BETA
      FAC=Z*(Z+AKSI*(1.+DEL*LOG(Z)))*FAC
      GPRELM=FAC*S
      IF(CUT.LE.ECMA5) GOTO 999
      GPREL5=GPRELM
C
 160  Y=Z3
      S=D(1)
      K=1
      XX=1.
      YPX=Y/X
      DO 180 I=1,6
         II=I+1
         XX=XX*X
         XXYY=XX
         DO 170 J=1,II
            K=K+1
            S=S+D(K)*XXYY
            XXYY=XXYY*YPX
 170     CONTINUE
 180  CONTINUE
      IF(S.LE.0.) GOTO 999
C
      FAC=Z*(Z+1.)*ECMAX
      IF(FAC.LE.0.) GOTO 999
      GPRELM=FAC*S
C
      IF((CUT.LE.ECMA5).OR.(CUT.GE.ECMAX)) GOTO 999
      DEL1=(GPRELM-GPREL5)/(ECMAX-ECMA5)
      GPRELM=GPREL5+DEL1*(CUT-ECMA5)
C
999   RETURN
      END
+DECK,  GPROBI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      SUBROUTINE GPROBI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Initialise material constants used in the computation of      *
C.    *  the probability for various interactions.                     *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, G.Patrick, L.Urban  *********         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GCJLOC.
      DIMENSION EK(4),EL1(4),EL2(4)
      DATA EK / 0.66644E-8 , 0.22077E-9 ,-0.32552E-11, 0.18199E-13/
      DATA EL1/-0.29179E-9 , 0.87983E-10,-0.12589E-11, 0.69602E-14/
      DATA EL2/-0.68606E-9 , 0.10078E-9 ,-0.14496E-11, 0.78809E-14/
      DATA ALFA/7.29735E-3/
      DATA REL/0.2817938/
C.
C.    ------------------------------------------------------------------
C.
      IF(Z.LT.1.) GOTO 999
      AEFF=A
      JPROB = LQ(JMA-4)
      IF(JMIXT.GT.0)THEN
         JMI1=LQ(JMIXT-1)
         AEFF=Q(JMI1+1)
      ENDIF
C
C             store constants for PAIR/BREMS routines
C
      X      = (Z*ALFA)**2
      FC     = (( - 0.002 * X + 0.0083) * X - 0.0369) * X + 0.20206
      FC     = X * (FC + 1. / (1. + X))
      C1=Z**0.333333
      C2=LOG(C1)
      C3=LOG(183./C1)-FC
      C4=LOG(1440./(C1*C1))/C3
      Q(JPROB+1)=Z*(Z+C4)*C3/A
      Q(JPROB+2)=C1
      Q(JPROB+3)=C2
      Q(JPROB+4)=FC
C
C             constants for PHOTOEFFECT
C
      Z2   = Z*Z
      EKZ  = Z2*(EK(1) +Z*(EK(2) +Z*(EK(3) +Z*EK(4))))
      EL1Z = Z2*(EL1(1)+Z*(EL1(2)+Z*(EL1(3)+Z*EL1(4))))
      EL2Z = Z2*(EL2(1)+Z*(EL2(2)+Z*(EL2(3)+Z*EL2(4))))
      Q(JPROB+5)=EKZ
      Q(JPROB+6)=EL1Z
      Q(JPROB+7)=EL2Z
C
C             Constants for Hadronic interactions
C
      Q(JPROB+8)= 1000.*AEFF/(AVO*DENS)
C
C             Constants for electron/positron ionisation losses
C             and S5 for one-photon annihilation
C
      IF(JMIXT.LE.0)THEN
         POTI=16.E-9*Z**0.9
         S1=Z/A
         S5=Z**5/A*ALFA**4
      ELSE
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         S1=0.
         S2=0.
         S5=0.
         DO 10 J=1,NLM
            AJ=Q(JMIXT+J)
            ZJ=Q(JMIXT+NLM+J)
            WJ=Q(JMIXT+2*NLM+J)
            S1=S1+WJ*ZJ/AJ
            S2=S2+WJ*ZJ*LOG(ZJ)/AJ
            S5=S5+WJ*ZJ**5/AJ*ALFA**4
   10    CONTINUE
         POTI=16.E-9*EXP(0.9*S2/S1)
      ENDIF
      Q(JPROB+9) = POTI
      Q(JPROB+10) = LOG(POTI)
C
      CON1=LOG(POTI/EMASS)
      CON2=DENS*S1
      CON3=1.+2.*LOG(POTI/(28.8E-9*SQRT(CON2)))
C
C             Condensed material ?
C             (at present that means: DENS.GT.0.05 g/cm**3)
C
      IF(DENS.GT.0.05)THEN
         IF(POTI.LT.1.E-7)THEN
            IF(CON3.LT.3.681)THEN
               CON4=0.2
            ELSE
               CON4=0.326*CON3-1.
            ENDIF
            CON5=2.
         ELSE
            IF(CON3.LT.5.215)THEN
               CON4=0.2
            ELSE
               CON4=0.326*CON3-1.5
            ENDIF
            CON5=3.
         ENDIF
      ELSE
C
C             Gas (T=0 C, P= 1 ATM)
C             if T.NE. 0 C and/or P.NE. 1 ATM
C             you have to modify the variable X
C             X=>X+0.5*LOG((273+T C)/(273*P ATM))
C             in the function GDRELE
C             ------------------------
C
         IF(CON3.LE.12.25)THEN
            IP=INT((CON3-10.)/0.5)+1
            IF(IP.LT.0) IP=0
            IF(IP.GT.4) IP=4
            CON4=1.6+0.1*FLOAT(IP)
            CON5=4.
         ELSE
            IF(CON3.LE.13.804)THEN
               CON4=2.
               CON5=5.
            ELSE
               CON4=0.326*CON3-2.5
               CON5=5.
            ENDIF
         ENDIF
      ENDIF
C
      XA=CON3/4.606
      CON6=4.606*(XA-CON4)/(CON5-CON4)**3.
      Q(JPROB+11)=CON1
      Q(JPROB+12)=CON2
      Q(JPROB+13)=-CON3
      Q(JPROB+14)=CON4
      Q(JPROB+15)=CON5
      Q(JPROB+16)=CON6
C
C            constant for delta rays
C            (the same constant is used in the Compton
C              and Annihilation subroutines )
C            and for one-photon annihilation
C
      Q(JPROB+17)=AVO*TWOPI*REL*REL*DENS*S1
      Q(JPROB+18)=AVO*TWOPI*REL*REL*DENS*S5
C
C            Constants for Moliere scattering
C
      IF(JMIXT.LE.0)THEN
         CALL GMOLI(A,Z,1.,1,DENS,Q(JPROB+21),Q(JPROB+25))
      ELSE
         CALL GMOLI(Q(JMIXT+1),Q(JMIXT+NLM+1),Q(JMIXT+2*NLM+1),
     +              NLM,DENS,Q(JPROB+21),Q(JPROB+25))
      ENDIF
C
C                Constants for muon bremsstrahlung
C
      Q(JPROB+31)=LOG(189.*EMMU/(EMASS*C1))
      IF(Z.GT.10)Q(JPROB+31)=Q(JPROB+31)+LOG(0.666666/C1)
      SE         =SQRT(2.71828)
      Q(JPROB+32)=189.*SE*EMMU*EMMU/(2.*EMASS*C1)
      Q(JPROB+33)=0.75*SE*EMMU*C1
C
  999 END
+DECK,  GPRSGA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      SUBROUTINE GPRSGA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for photon pair production and muon direct pair production.   *
C.    *                                                                *
C     *  semiempirical cross section formula of L.Urban is used        *
C     *  to estimate the photon mean free path in a given material     *
C     *            (see WRITEUP)                                       *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Authors    R.Brun, G.Patrick, L.Urban  *********         *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCONSP.
+CDE, GCTRAK.
+CDE, GCMATE.
+CDE, GCJLOC.
+CDE, GCMULO.
+CDE, GCCUTS.
C.
C.    ------------------------------------------------------------------
C.
C======>     A, Pair production by photons
C               ==========================
C               Cut on threshold kinetic energy. Special case for vacuum
C
      SST=0.
      IF(Z.LT.1.)GO TO 90
      EGAM   = ELOW(IEKBIN)
      IF (EGAM.LT.0.00099) GO TO 90
      IF (EGAM.LT.0.00199) EGAM=0.0014
C
      JPROB=LQ(JMA-4)
      IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
          SST=GPRSGG(Z,EGAM)/A
      ELSE
C
C             compound or mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         DO 10 I=1,NLM
            II=JMIXT+NLM+I
            AA=Q(II-NLM)
            ZZ=Q(II)
            W=Q(II+NLM)
            SST=SST+W*GPRSGG(ZZ,EGAM)/AA
  10     CONTINUE
      ENDIF
C
      SST=AVO*DENS*SST
C
  90  IF(SST.GT.0.)THEN
         Q(JPAIR+IEKBIN)=1./SST
      ELSE
         Q(JPAIR+IEKBIN)=BIG
      ENDIF
C
C======>     B, Direct pair production by muons
C               ===============================
C
      SST=0.
      IF(Z.LT.1.)GO TO 190
      T=ELOW(IEKBIN)
      IF(T.LT.1.)GO TO 190
      IF(T.LE.PPCUTM)GO TO 190
      IF(JMIXT.EQ.0)THEN
C
C            Element
C
         SST=GPRSGM(Z,T,PPCUTM)
         SST=SST/A
      ELSE
C
C            Compound/Mixture
C
         NLMAT=Q(JMA+11)
         NLM  =IABS(NLMAT)
         SST  =0.
         DO 110 I=1,NLM
            II   = JMIXT+NLM+I
            AA   = Q(II-NLM)
            ZZ   = Q(II)
            WMAT = Q(II+NLM)
            SST  = SST+WMAT*GPRSGM(ZZ,T,PPCUTM)/AA
 110     CONTINUE
      ENDIF
      SST=AVO*DENS*SST
C
 190  IF(SST.GT.0.)THEN
         Q(JPAIR+IEKBIN+NEK1)=1./SST
      ELSE
         Q(JPAIR+IEKBIN+NEK1)=BIG
      ENDIF
C
      END
+DECK,  GPRSGG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      FUNCTION GPRSGG(Z,E)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  To calculate cross-section for e+e- production                *
C.    *  by photons (in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GPRSGA                                       *
C.    *       Author    L.Urban  *********                             *
C.    *       Modified by: G.Battistoni                                *
C.    *                                                                *
C.    *   constant cross section is assumed above 100 GeV !            *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION C(18),CC(3)
      DATA C/ 0.87842E-3,-0.19625E-2, 0.12949E-2,-0.20028E-3
     +      , 0.12575E-4,-0.28333E-6,-0.10342E-4, 0.17692E-4
     +      ,-0.82391E-5, 0.13063E-5,-0.90815E-7, 0.23586E-8
     +      ,-0.45263E-3, 0.11161E-2,-0.86749E-3, 0.21773E-3
     +      ,-0.20467E-4, 0.65372E-6/
      DATA EUPP/100./
C.
C.    ------------------------------------------------------------------
C.
      SIG=0.
*
      ESAV=E
      IF(E.GT.EUPP) E=EUPP
*
      IF(E.LE.2.*EMASS)GO TO 90
      X=LOG(E/EMASS)
      DO 20 I=1,3
         CC(I)=0.
         D=1.
         DO 10 J=1,6
            JJ=6*I+J-6
            CC(I)=CC(I)+D*C(JJ)
            D=D*X
  10     CONTINUE
  20  CONTINUE
C
      SIG=Z*(Z+1.)*(CC(1)+CC(2)*Z+CC(3)/Z)
C
  90  IF(SIG.LT.0.)SIG=0.
      GPRSGG=SIG
*
      E=ESAV
*
      END
+DECK,  GPRSGM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      FUNCTION GPRSGM(Z,T,CCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       To calculate cross-section in barn/atom for direct       *
C.    *       pair production by muons.                                *
C.    *                                                                *
C.    *    ==>Called by : GPRSGA                                       *
C.    *       Author    L.Urban  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
C
      PARAMETER (AKSI=1.16,ALFA=3.46,GAM=0.06,VS=0.019)
      PARAMETER (ECMIN=2.044E-3,CONMX=0.130653)
C        CONMX=0.75*SQRT(2.7182...)*EMMU
C
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      DATA C1/0.230181E-08,-0.280842E-08, 0.137525E-08,-0.156503E-09
     +      , 0.728088E-11,-0.122631E-12, 0.133014E-08,-0.160591E-09
     +      ,-0.390814E-09, 0.314492E-10, 0.251296E-12,-0.574223E-13
     +      , 0.604923E-09,-0.560766E-09, 0.660253E-09,-0.103474E-09
     +      , 0.621338E-11,-0.135273E-12, 0.103739E-09, 0.710290E-09
     +      ,-0.544755E-10,-0.211241E-11, 0.286443E-12,-0.644602E-14
     +      , 0.332492E-09,-0.484785E-10, 0.126921E-10,-0.165217E-11
     +      , 0.845273E-13,-0.143180E-14,-0.112267E-13, 0.113308E-11
     +      , 0.292577E-12,-0.733441E-13, 0.475747E-14,-0.976279E-16
     +      ,-0.112856E-07, 0.936398E-08,-0.291882E-08, 0.422266E-09
     +      ,-0.279042E-10, 0.678485E-12, 0.112383E-07,-0.964400E-08
     +      , 0.313121E-08,-0.440224E-09, 0.278668E-10,-0.643012E-12
     +      ,-0.414131E-08, 0.355112E-08,-0.115035E-08, 0.158539E-09
     +      ,-0.976788E-11, 0.216911E-12, 0.521380E-09,-0.442265E-09
     +      , 0.141753E-09,-0.190826E-10, 0.114038E-11,-0.242085E-13/
      DATA C2/0.572943E-10,-0.296824E-10, 0.630217E-11,-0.623179E-12
     +      , 0.211467E-13,-0.143579E-10,-0.137247E-11, 0.118670E-11
     +      ,-0.793091E-13, 0.124745E-14,-0.269884E-10, 0.125314E-10
     +      ,-0.239259E-11, 0.181151E-12,-0.470277E-14,-0.342454E-11
     +      , 0.976666E-12,-0.236792E-12, 0.213290E-13,-0.607799E-15
     +      ,-0.748844E-12, 0.178214E-12,-0.226827E-13, 0.148441E-14
     +      ,-0.367972E-16, 0.840330E-12, 0.820025E-11,-0.294797E-11
     +      , 0.294669E-12,-0.970294E-14,-0.830636E-12,-0.309273E-11
     +      , 0.124169E-11,-0.135879E-12, 0.481683E-14, 0.438223E-12
     +      , 0.259162E-12,-0.149284E-12, 0.180170E-13,-0.677948E-15/
C.
C.    ------------------------------------------------------------------
C.
      GPRSGM=0.
      CUT=CCUT
      IF(CUT.LT.ECMIN) CUT=ECMIN
C
      E=T+EMMU
      ECMAX=E-CONMX*Z**0.333333
      IF(CUT.GE.ECMAX) GOTO 99
C
      X=LOG(E/EMMU)
      Y=LOG(CUT/(VS*E))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
        YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
C     DE/DX SHOULD BE MONOTON INCREASING AS A
C     FUNCTION OF THE CUT
C     SOLUTION: LIN. INTERPOLATION FOR 0.2*ECMAX<CUT<ECMAX
C
      FAC=2.*(LOG(ECMAX/CUT))**ALFA
      FAC=Z*(Z+AKSI*(1.+GAM*LOG(Z)))*FAC
      GPRSGM=FAC*S
C
  99  RETURN
      END
+DECK,  GRANGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      SUBROUTINE GRANGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the stopping range , in cm.                        *
C.    *     (i.e. the maximum step due to the continuous energy loss)  *
C.    *      The stopping range is the integral of the inverse of the  *
C.    *      DE/DX table.                                              *
C.    *     There are 4 tables : electron,positron,muon,proton         *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author      M.Maire   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCJLOC.
+CDE, GCMULO.
+CDE, GCONSP.
+CDE, GCMATE.
+SELF, IF=-SINGLE.
      DOUBLE PRECISION RANGMU, RANGEL, RANGPO, RANGPR
      DOUBLE PRECISION DDXEL1, DDXMU1, DDXPR1, DDXPO1
      DOUBLE PRECISION DDXEL2, DDXMU2, DDXPR2, DDXPO2
      DOUBLE PRECISION DDXEL3, DDXMU3, DDXPR3, DDXPO3
      DOUBLE PRECISION HFACT, ONE, TEN, HLOG10, HFACT2, HFACT3
+SELF.
      PARAMETER (ONE=1,TEN=10)
*
      HLOG10 = LOG(TEN)
*
      JRANEL = LQ(JMA-15)
      JRANPO = LQ(JMA-15)+NEK1
      JRANMU = LQ(JMA-16)
      JRANPR = LQ(JMA-16)+NEK1
*
      IF(Z.LT.1) THEN
         DO 10  IEKBIN=1,NEK1
            Q(JRANEL+IEKBIN)=BIG
            Q(JRANPO+IEKBIN)=BIG
            Q(JRANMU+IEKBIN)=BIG
            Q(JRANPR+IEKBIN)=BIG
   10    CONTINUE
*
      ELSE
         SMALL = 1./BIG
         JLOSEL = LQ(JMA-1)
         JLOSPO = LQ(JMA-1)+NEK1
         JLOSMU = LQ(JMA-2)
         JLOSPR = LQ(JMA-3)
*
         JWSPEL =         -1
         JWSPPO = NEKBIN  -1
         JWSPMU = NEKBIN*2-1
         JWSPPR = NEKBIN*3-1
*
         RANGPO = 0.
         RANGMU = 0.
         RANGEL = 0.
         RANGPR = 0.
*
         Q(JRANEL+1)=0.
         Q(JRANPO+1)=0.
         Q(JRANMU+1)=0.
         Q(JRANPR+1)=0.
*
         HFACT = ONE/(6.*GEKA)
*
         DDXEL3 = ELOW(1)*HLOG10/MAX(Q(JLOSEL+1),SMALL)
         DDXMU3 = ELOW(1)*HLOG10/MAX(Q(JLOSMU+1),SMALL)
         DDXPR3 = ELOW(1)*HLOG10/MAX(Q(JLOSPR+1),SMALL)
         DDXPO3 = ELOW(1)*HLOG10/MAX(Q(JLOSPO+1),SMALL)
*
         HFACT2 = HLOG10*TEN**(EKBIN(1)+0.5/GEKA)
*
         DO 20 IEKBIN=2,NEK1
*
            HFACT3 = ELOW(IEKBIN)*HLOG10
*
* *** Electrons
*
            DDXEL1 = DDXEL3
            DDXEL3 = HFACT3/MAX(Q(JLOSEL+IEKBIN),SMALL)
            DDXEL2 = HFACT2/MAX(WS(JWSPEL+IEKBIN),SMALL)
            RANGEL = RANGEL+DDXEL1+4.*DDXEL2+DDXEL3
            Q(JRANEL+IEKBIN)=RANGEL*HFACT
*
* *** Positons
*
            DDXPO1 = DDXPO3
            DDXPO3 = HFACT3/MAX(Q(JLOSPO+IEKBIN),SMALL)
            DDXPO2 = HFACT2/MAX(WS(JWSPPO+IEKBIN),SMALL)
            RANGPO = RANGPO+DDXPO1+4.*DDXPO2+DDXPO3
            Q(JRANPO+IEKBIN)=RANGPO*HFACT
*
* *** Muons
*
            DDXMU1 = DDXMU3
            DDXMU3 = HFACT3/MAX(Q(JLOSMU+IEKBIN),SMALL)
            DDXMU2 = HFACT2/MAX(WS(JWSPMU+IEKBIN),SMALL)
            RANGMU = RANGMU+DDXMU1+4.*DDXMU2+DDXMU3
            Q(JRANMU+IEKBIN)=RANGMU*HFACT
*
* *** Protons
*
            DDXPR1 = DDXPR3
            DDXPR3 = HFACT3/MAX(Q(JLOSPR+IEKBIN),SMALL)
            DDXPR2 = HFACT2/MAX(WS(JWSPPR+IEKBIN),SMALL)
            RANGPR = RANGPR+DDXPR1+4.*DDXPR2+DDXPR3
            Q(JRANPR+IEKBIN)=RANGPR*HFACT
*
            HFACT2 = HLOG10*TEN**(EKBIN(1)+(IEKBIN-0.5)/GEKA)
*
   20    CONTINUE
      ENDIF
*
      END
+DECK,  GRANGI1, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

+SELF, IF=NEVER.
      SUBROUTINE GRANGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates the stopping range , in cm.                        *
C.    *     (i.e. the maximum step due to the continuous energy loss)  *
C.    *      The stopping range is the integral of the inverse of the  *
C.    *      DE/DX table.                                              *
C.    *     There are 4 tables : electron,positron,muon,proton         *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author      M.Maire   *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCJLOC.
+CDE, GCMULO.
+CDE, GCONSP.
+CDE, GCMATE.
*
      DO 50 IEKBIN=1,NEK1
*
* *** Electrons
*
         JLOSS = LQ(JMA-1)
         JRANG = LQ(JMA-15)
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
*
* *** Positons
*
         JLOSS = LQ(JMA-1) + NEK1
         JRANG = LQ(JMA-15) + NEK1
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
*
* *** Muons
*
         JLOSS = LQ(JMA-2)
         JRANG = LQ(JMA-16)
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
*
* *** Protons
*
         JLOSS = LQ(JMA-3)
         JRANG = LQ(JMA-16) + NEK1
         IF (Z.LT.1.) THEN
            Q(JRANG+IEKBIN) = BIG
         ELSE IF ((IEKBIN.EQ.1).OR.(Q(JLOSS+IEKBIN-1).LE.0.)) THEN
            Q(JRANG+IEKBIN) = 0.
         ELSE
            DEBIN=ELOW(IEKBIN) - ELOW(IEKBIN-1)
            FRACT= Q(JLOSS+IEKBIN)/Q(JLOSS+IEKBIN-1) - 1.
            IF (ABS(FRACT).GE.0.1) THEN
               DRANG=DEBIN/(Q(JLOSS+IEKBIN)-Q(JLOSS+IEKBIN-1))
               DRANG=DRANG*LOG(1.+FRACT)
            ELSE
               DRANG=DEBIN/Q(JLOSS+IEKBIN-1)
               DRANG= DRANG*(1. - 0.5*FRACT + 0.3333*FRACT*FRACT)
            ENDIF
            Q(JRANG+IEKBIN)=Q(JRANG+IEKBIN-1) + DRANG
         ENDIF
   50 CONTINUE
*
      END
+SELF.
+DECK,  GRAYL, T=FORT.
* Revision 1.2  1996/11/06 12:53:21  ravndal
* Correct the rotation into the GEANT system
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      SUBROUTINE GRAYL
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Generates COHERENT SCATTERING mechanism                       *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Author    G.Tromba, P.Bregant                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCPHYS.
+CDE, GCONSP.
+CDE, GCKING.
+CDE, GCJLOC.
+CDE, GCMULO.
      DIMENSION VROT(3)
      DIMENSION RNDM(2)
      LOGICAL ROTATE
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(25)
      NGKINE=0
*
      IMAX=NEKBIN
      DO 2 I=2,NEK1
         IF (Q(JRAYL+I).GT.0.9*BIG) THEN
            IMAX = I-1
            GO TO 2
         ENDIF
   2  CONTINUE
C
C             Extract a value for the momentum transfer according
C             with the FORM FACTORS distribution.
C
      IF (IEKBIN.LT.IMAX) THEN
        GEKRT1=1.-GEKRAT
        A2MAX=GEKRT1*Q(JRAYL+NEK1+IEKBIN)+GEKRAT*Q(JRAYL+NEK1+IEKBIN+1)
      ELSE
        A2MAX=Q(JRAYL+NEK1+IEKBIN)
      ENDIF
      GEKIN1=1./GEKIN
   5  CALL GRNDM(RNDM,2)
      A2=RNDM(1)*A2MAX
      DO 10 I=1,(IMAX-1)
         IF (A2.LE.Q(JRAYL+I+NEK1)) THEN
            IE=I
            GO TO 20
         ENDIF
10    CONTINUE
      IE=IMAX
20    IF (IE.GT.1) THEN
        GA2RAT =(A2-Q(JRAYL+NEK1+IE-1))/(Q(JRAYL+NEK1+IE)
     +          -Q(JRAYL+NEK1+IE-1))
        QNEW   = ELOW(IE-1)*(1.-GA2RAT)+ELOW(IE)*GA2RAT
      ELSE
        GA2RAT  = A2/Q(JRAYL+NEK1+IE)
        QNEW    = ELOW(IE)*GA2RAT
      ENDIF
C
C            Find out cos(theta)
      COSTH=1.-0.5*(QNEW*GEKIN1)**2
      IF(RNDM(2).GT.0.5*(1.+COSTH**2)) GO TO 5
      SINTH=SQRT((1.-COSTH)*(1.+COSTH))
C
C            Extract PH  (PHI unif. between 0 and 2PI)
      CALL GRNDM(RNDM,2)
      PH=RNDM(1)*TWOPI
      COSPH=COS(PH)
      SINPH=SIN(PH)
C
C            Set new VECT(I), i=4,5,6
      VROT(1)=GEKIN*SINTH*COSPH
      VROT(2)=GEKIN*SINTH*SINPH
      VROT(3)=GEKIN*COSTH
C
C             Rotate scattered photon into GEANT system
C
      CALL GFANG(VECT(4),COSTH,SINTH,COSPH,SINPH,ROTATE)
      IF (ROTATE) CALL GDROT(VROT,COSTH,SINTH,COSPH,SINPH)

      VMROT=1./SQRT(VROT(1)*VROT(1)+VROT(2)*VROT(2)+VROT(3)*VROT(3))
      VECT(4)=VROT(1)*VMROT
      VECT(5)=VROT(2)*VMROT
      VECT(6)=VROT(3)*VMROT
C
C            Update probabilities
C
*
      ZINTRA=-LOG(RNDM(2))
      SLRAYL=SLENG
      STEPRA=BIG
*
C
      END

+DECK,  GRAYLI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      SUBROUTINE GRAYLI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section of current material for RAYLEIGH     *
C.    *  EFFECT using  polinomial fits of tables in log-log scale.     *
C.    *  One fit (4 coefficients) for each element is used.            *
C.    *  Atomic form factors are calculated as a function of momentum  *
C.    *  transfer using polinomial fits of data tables in log-log scale*
C.    *  One or two fits are used according with the value of NFIT.    *
C.    *  Evaluates the integral of atomic form factors which will be   *
C.    *  used in the SUBROUTINE GRAYL to sample scattering angles      *
C.    *  NOTE:                                                         *
C.    *  (1) Above 10 MeV a cut is imposed as the contribution of      *
C.    *  Rayleigh effect is negligible                                 *
C.    *                                                                *
C.    *    ==>Called by : GPHYSI                                       *
C.    *       Author    G.Tromba (*), P.Bregant (**)                   *
C.    *                                                                *
C.    *  (*) now at: Sincrotrone Trieste, Padriciano 99, Trieste (I)   *
C.    *  (**)U.S.L. n.1 Triestina                                      *
C.    *      Servizio di Fisica Sanitaria, v.Pieta' 19, 34129 Trieste  *
C     *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, GCMATE.
+CDE, GCJLOC.
+CDE, GCMULO.
      DIMENSION COHER(4,100),CFORM(8,100),ELIM(100)
*
      DATA((COHER(I,J),I=1,4),J=1,20)/-12.646,-1.9734,.13417,.23998E-01
     +,-10.303,-1.9553,0.15913,0.29927E-01
     +,-9.1274,-2.0474,0.87874E-01,0.23572E-01
     +,-8.3066,-2.0615,0.46623E-01,0.18455E-01
     +,-7.6967,-2.0684,0.24280E-01,0.15622E-01
     +,-7.2088,-2.0633,0.15713E-01,0.14402E-01
     +,-6.8026,-2.0574,0.16437E-01,0.14518E-01
     +,-6.4403,-2.0449,0.18975E-01,0.14716E-01
     +,-6.1099,-2.0390,0.21207E-01,0.15081E-01
     +,-5.7930,-2.0384,0.19210E-01,0.14989E-01
     +,-5.5410,-2.0430,0.20118E-01,0.15698E-01
     +,-5.3138,-2.0399,0.21325E-01,0.16074E-01
     +,-5.0993,-2.0395,0.19494E-01,0.16046E-01
     +,-4.9005,-2.0397,0.17404E-01,0.15937E-01
     +,-4.7149,-2.0394,0.15412E-01,0.15788E-01
     +,-4.5420,-2.0393,0.13945E-01,0.15704E-01
     +,-4.3846,-2.0372,0.14551E-01,0.15848E-01
     +,-4.2381,-2.0316,0.16322E-01,0.16051E-01
     +,-4.1023,-2.0249,0.17752E-01,0.16300E-01
     +,-3.9704,-2.0187,0.17285E-01,0.16217E-01/
      DATA ((COHER(I,J),I=1,4),J=21,40)/-3.8342,-2.0137,.014534,.015744
     +,-3.7014,-2.0118,0.10973E-01,0.15228E-01
     +,-3.5759,-2.0127,0.80253E-02,0.14884E-01
     +,-3.4584,-2.0121,0.70340E-02,0.14731E-01
     +,-3.3494,-2.0101,0.66838E-02,0.14731E-01
     +,-3.2392,-2.0074,0.57007E-02,0.14562E-01
     +,-3.1309,-2.0050,0.41822E-02,0.14312E-01
     +,-3.0235,-2.0049,0.19877E-02,0.14052E-01
     +,-2.9211,-2.0071,0.85036E-03,0.13970E-01
     +,-2.8192,-2.0069,-0.14296E-02,0.13732E-01
     +,-2.7265,-2.0088,-0.26683E-02,0.13717E-01
     +,-2.6378,-2.0095,-0.34226E-02,0.13727E-01
     +,-2.5496,-2.0094,-0.62157E-02,0.13425E-01
     +,-2.4704,-2.0092,-0.43550E-02,0.13753E-01
     +,-2.3900,-2.0083,-0.48368E-02,0.13730E-01
     +,-2.3111,-2.0072,-0.55407E-02,0.13668E-01
     +,-2.2355,-2.0065,-0.61290E-02,0.13697E-01
     +,-2.1614,-2.0064,-0.70329E-02,0.13672E-01
     +,-2.0899,-2.0060,-0.78982E-02,0.13612E-01
     +,-2.0203,-2.0057,-0.85764E-02,0.13570E-01/
      DATA((COHER(I,J),I=1,4),J=41,60)/-1.9519,-2.0049,-.0091079,.013506
     +,-1.8851,-2.0036,-0.94870E-02,0.13472E-01
     +,-1.8210,-2.0019,-0.10066E-01,0.13410E-01
     +,-1.7554,-2.0007,-0.11089E-01,0.13247E-01
     +,-1.6914,-1.9990,-0.11844E-01,0.13139E-01
     +,-1.6279,-1.9984,-0.12922E-01,0.12987E-01
     +,-1.5659,-1.9980,-0.13635E-01,0.12948E-01
     +,-1.5073,-1.9977,-0.14136E-01,0.12937E-01
     +,-1.4501,-1.9959,-0.14206E-01,0.12957E-01
     +,-1.3942,-1.9943,-0.14863E-01,0.12876E-01
     +,-1.3378,-1.9916,-0.15680E-01,0.12738E-01
     +,-1.2820,-1.9881,-0.16880E-01,0.12511E-01
     +,-1.2231,-1.9861,-0.18942E-01,0.12204E-01
     +,-1.1658,-1.9850,-0.21146E-01,0.11896E-01
     +,-1.1112,-1.9864,-0.22968E-01,0.11769E-01
     +,-1.0594,-1.9877,-0.24247E-01,0.11707E-01
     +,-1.0104,-1.9895,-0.24993E-01,0.11718E-01
     +,-0.96289,-1.9905,-0.25026E-01,0.11788E-01
     +,-0.91458,-1.9909,-0.25128E-01,0.11807E-01
     +,-0.86838,-1.9909,-0.25111E-01,0.11847E-01/
      DATA ((COHER(I,J),I=1,4),J=61,80)/-.82136,-1.9903,-.025340,.011835
     +,-0.77441,-1.9864,-0.26074E-01,0.11635E-01
     +,-0.72869,-1.9885,-0.26020E-01,0.11761E-01
     +,-0.68337,-1.9878,-0.26532E-01,0.11712E-01
     +,-0.63683,-1.9871,-0.26966E-01,0.11650E-01
     +,-0.59154,-1.9867,-0.27440E-01,0.11604E-01
     +,-0.54758,-1.9862,-0.27986E-01,0.11561E-01
     +,-0.50282,-1.9861,-0.28229E-01,0.11547E-01
     +,-0.45943,-1.9858,-0.28501E-01,0.11535E-01
     +,-0.41677,-1.9856,-0.28696E-01,0.11540E-01
     +,-0.37528,-1.9853,-0.29045E-01,0.11529E-01
     +,-0.33450,-1.9843,-0.29095E-01,0.11545E-01
     +,-0.29346,-1.9834,-0.29469E-01,0.11511E-01
     +,-0.25286,-1.9823,-0.29847E-01,0.11469E-01
     +,-0.21251,-1.9810,-0.30285E-01,0.11412E-01
     +,-0.17200,-1.9801,-0.30821E-01,0.11368E-01
     +,-0.13190,-1.9789,-0.31515E-01,0.11257E-01
     +,-0.92060E-01,-1.9781,-0.32135E-01,0.11179E-01
     +,-0.52955E-01,-1.9775,-0.32687E-01,0.11125E-01
     +,-0.14708E-01,-1.9770,-0.33185E-01,0.11092E-01/
      DATA((COHER(I,J),I=1,4),J=81,100)/.022864,-1.9751,-.033545,.011037
     +,0.60152E-01,-1.9764,-0.33897E-01,0.11092E-01
     +,0.96158E-01,-1.9760,-0.34169E-01,0.11099E-01
     +,0.13251,-1.9753,-0.34520E-01,0.11085E-01
     +,0.16833,-1.9747,-0.34818E-01,0.11081E-01
     +,0.20362,-1.9740,-0.35032E-01,0.11086E-01
     +,0.23778,-1.9734,-0.34984E-01,0.11155E-01
     +,0.27280,-1.9725,-0.35314E-01,0.11153E-01
     +,0.30673,-1.9718,-0.35308E-01,0.11229E-01
     +,0.34031,-1.9706,-0.35518E-01,0.11187E-01
     +,0.37415,-1.9695,-0.35653E-01,0.11175E-01
     +,0.40755,-1.9670,-0.34285E-01,0.11389E-01
     +,0.44086,-1.9671,-0.35957E-01,0.11154E-01
     +,0.47375,-1.9661,-0.36059E-01,0.11145E-01
     +,0.50582,-1.9648,-0.36048E-01,0.11154E-01
     +,0.53772,-1.9635,-0.36237E-01,0.11140E-01
     +,0.56929,-1.9622,-0.36256E-01,0.11141E-01
     +,0.60044,-1.9608,-0.36340E-01,0.11134E-01
     +,0.63122,-1.9596,-0.36313E-01,0.11138E-01
     +,0.66162,-1.9582,-0.36298E-01,0.11141E-01/
*
      DATA ELIM/3*0.,3*0.13569E-04,3*0.14408E-04,3*0.15299E-04
     +,3*0.21928E-04,3*0.27876E-04,3*0.35437E-04,3*0.45049E-04
     +,3*0.50793E-04,3*0.53934E-04,3*0.57269E-04,3*0.60810E-04
     +,3*0.68563E-04,3*0.77305E-04,3*0.87161E-04,3*0.98274E-04
     +,3* 0.11080E-03,3*0.11765E-03,3*0.12493E-03,3*0.13266E-03
     +,3*0.14086E-03,3*0.15882E-03,3* 0.16864E-03,3*0.19014E-03
     +,3*0.21438E-03,3*0.22764E-03,2*0.24171E-03,3*0.27253E-03
     +,4*0.28938E-03,3*0.3072E-03,10*0./
*
      DATA((CFORM(I,J),I=1,8),J=1,10)/-22.516,-5.1310,-.90555,-.055778
     +,0.11875,0.36659E-01,0.39279E-02,0.14494E-03
     +,-19.260,-4.6034,-0.60480,-0.86935E-01
     +,0.75207E-01,0.29358E-01,0.35640E-02,0.14448E-03
     +,-16.745,-2.9900,-0.34216E-01,-0.22543
     +,-0.29032E-01,0.11312E-01,0.24065E-02,0.12420E-03
     +,-17.780,-7.8538,-1.1320,-0.56378E-01
     +,-16.730,-4.1304,0.18327,0.63285E-01
     +,-5.7128,-1.8620,-0.14825,-0.39071E-02
     +,-15.923,-4.1463,0.24609,0.83958E-01
     +,6.1359,4.3284,0.91725,0.55486E-01
     +,-15.224,-4.1486,0.28574,0.99104E-01
     +,7.9239,5.4239,1.1417,0.69696E-01
     +,-14.548,-4.1850,0.26729,0.10343
     +,5.6813,4.4241,1.0125,0.64574E-01
     +,-13.948,-4.2241,0.23705,0.10507
     +,-0.73602,1.2353,0.51040,0.38876E-01
     +,-13.380,-4.3238,0.15807,0.98704E-01
     +,-4.5122,-0.69749,0.20317,0.23107E-01
     +,-12.880,-4.3645,0.11149,0.96212E-01/
      DATA((CFORM(I,J),I=1,8),J=11,20)/-12.894,-5.1262,-0.54343,-.017585
     +,-12.442,-4.4181,0.64564E-01,0.93785E-01
     +,-18.182,-7.9979,-1.0369,-0.44947E-01
     +,-11.961,-4.4932,-0.23538E-01,0.83167E-01
     +,-7.7002,-2.7396,-0.16988,0.17141E-02
     +,-11.655,-4.3468,0.67545E-01,0.10218
     +,-11.458,-4.8625,-0.54640,-0.19752E-01
     +,-11.288,-4.3645,0.31952E-01,0.10016
     +,-13.733,-6.1918,-0.78628,-0.33620E-01
     +,-10.866,-4.4125,-0.54747E-01,0.87723E-01
     +,-6.9281,-2.5933,-0.16486,0.11230E-02
     +,-10.716,-4.2771,0.63949E-01,0.11331
     +,-9.1472,-3.9093,-0.40549,-0.12939E-01
     +,-10.308,-4.3105,-0.26699E-01,0.98791E-01
     +,-10.558,-4.7765,-0.56625,-0.22421E-01
     +,-9.9972,-4.3437,-0.82898E-01,0.92124E-01
     +,-6.0983,-2.3464,-0.13404,0.24166E-02
     +,-10.027,-4.2552,0.73490E-01,0.13009
     +,-7.9984,-3.5151,-0.35363,-0.10654E-01
     +,-9.6508,-4.2506,-0.65510E-02,0.11484/
      DATA((CFORM(I,J),I=1,8),J=21,30)/-9.2121,-4.2776,-0.49730,-.019235
     +,-9.4905,-4.2588,0.32597E-02,0.12279
     +,-3.9128,-1.2033,0.75797E-01,0.14897E-01
     +,-9.3296,-4.1979,0.42817E-01,0.13360
     +,-5.1579,-1.9987,-0.76380E-01,0.56926E-02
     +,-9.0348,-4.1729,-0.43368E-02,0.12460
     +,-6.1115,-2.6115,-0.19286,-0.13208E-02
     +,-8.7478,-4.1599,-0.57064E-01,0.11511
     +,-4.5827,-1.7167,-0.21089E-01,0.91965E-02
     +,-8.6469,-4.1430,-0.21725E-01,0.12790
     +,-5.4795,-2.3056,-0.13495,0.22647E-02
     +,-8.4099,-4.1228,-0.55178E-01,0.12251
     +,-6.1802,-2.7722,-0.22505,-0.32066E-02
     +,-8.2279,-4.0934,-0.62350E-01,0.12269
     +,-5.8290,-2.5908,-0.19000,-0.10226E-02
     +,-8.0551,-4.0478,-0.60875E-01,0.12369
     +,-6.2227,-2.8633,-0.24196,-0.41418E-02
     +,-7.8068,-4.0203,-0.10682,0.11396
     +,-6.6260,-3.1507,-0.29866,-0.76188E-02
     +,-7.5763,-3.9966,-0.14839,0.10560/
      DATA((CFORM(I,J),I=1,8),J=31,40)/-5.8965,-2.7383,-.22009,-.0028149
     +,-7.5281,-3.9941,-0.10906,0.12081
     +,-6.2790,-3.0188,-0.27697,-0.63842E-02
     +,-7.3337,-3.9547,-0.13178,0.11541
     +,-6.5270,-3.2157,-0.31779,-0.89844E-02
     +,-7.1437,-3.9160,-0.15503,0.10982
     +,-6.6564,-3.3380,-0.34420,-0.10706E-01
     +,-6.9226,-3.8688,-0.19301,0.99252E-01
     +,-6.6676,-3.3866,-0.35637,-0.11562E-01
     +,-6.7647,-3.8417,-0.20928,0.96358E-01
     +,-6.5973,-3.3839,-0.35856,-0.11806E-01
     +,-6.5615,-3.7910,-0.24140,0.86548E-01
     +,-5.5223,-2.7503,-0.23696,-0.43562E-02
     +,-6.6156,-3.8232,-0.17222,0.11431
     +,-5.7577,-2.9413,-0.27766,-0.69923E-02
     +,-6.4351,-3.7636,-0.19273,0.10630
     +,-5.8988,-3.0704,-0.30602,-0.88735E-02
     +,-6.2520,-3.7107,-0.21873,0.97517E-01
     +,-5.1690,-2.6301,-0.21923,-0.34573E-02
     +,-6.2183,-3.7177,-0.18979,0.11175/
      DATA((CFORM(I,J),I=1,8),J=41,50)/-5.3652,-2.7941,-.25462,-.0057986
     +,-6.0669,-3.6847,-0.20939,0.10725
     +,-5.5028,-2.9182,-0.28166,-0.75863E-02
     +,-5.9625,-3.6681,-0.21256,0.10888
     +,-4.4716,-2.2542,-0.14575,0.11394E-02
     +,-5.9717,-3.7006,-0.17526,0.12848
     +,-4.6959,-2.4391,-0.18590,-0.15318E-02
     +,-5.8101,-3.6454,-0.19615,0.12040
     +,-4.8697,-2.5886,-0.21853,-0.36987E-02
     +,-5.6609,-3.6010,-0.21568,0.11417
     +,-4.3929,-2.2914,-0.15753,0.22346E-03
     +,-5.6585,-3.6429,-0.19093,0.13204
     +,-4.5695,-2.4433,-0.19070,-0.19681E-02
     +,-5.5414,-3.6051,-0.19872,0.12936
     +,-4.7029,-2.5655,-0.21777,-0.37707E-02
     +,-5.4029,-3.5513,-0.21291,0.12265
     +,-4.2616,-2.2896,-0.16092,-0.80603E-04
     +,-5.3622,-3.5694,-0.20212,0.13395
     +,-4.4165,-2.4282,-0.19184,-0.21565E-02
     +,-5.2567,-3.5409,-0.20978,0.13282/
      DATA((CFORM(I,J),I=1,8),J=51,60)/-4.5344,-2.5405,-.21724,-.0038729
     +,-5.1491,-3.5054,-0.21718,0.13045
     +,-3.6372,-1.9343,-0.88690E-01,0.46020E-02
     +,-5.0258,-3.4548,-0.22839,0.12463
     +,-3.8210,-2.0961,-0.12529,0.21101E-02
     +,-4.8945,-3.3989,-0.24271,0.11716
     +,-3.9712,-2.2334,-0.15661,-0.34134E-04
     +,-4.7735,-3.3522,-0.25562,0.11148
     +,-3.1689,-1.6776,-0.36233E-01,0.80485E-02
     +,-4.8172,-3.4334,-0.22782,0.13781
     +,-3.3490,-1.8398,-0.73631E-01,0.54743E-02
     +,-4.6932,-3.3773,-0.24060,0.13057
     +,-3.5038,-1.9826,-0.10676,0.31787E-02
     +,-4.5891,-3.3400,-0.25016,0.12742
     +,-3.6192,-2.0937,-0.13237,0.14104E-02
     +,-4.5112,-3.3248,-0.25437,0.12929
     +,-3.6974,-2.1750,-0.15093,0.13588E-03
     +,-4.4412,-3.3123,-0.25609,0.13194
     +,-3.7627,-2.2475,-0.16786,-0.10371E-02
     +,-4.3611,-3.2863,-0.25915,0.13169/
      DATA((CFORM(I,J),I=1,8),J=61,70)/-3.2202,-1.8724,-.086015,.0044765
     +,-4.3280,-3.3034,-0.25324,0.14193
     +,-3.3101,-1.9643,-0.10751,0.29785E-02
     +,-4.2204,-3.2500,-0.26236,0.13536
     +,-3.3804,-2.0408,-0.12547,0.17255E-02
     +,-4.1144,-3.1979,-0.27167,0.12901
     +,-2.9387,-1.7293,-0.56192E-01,0.64683E-02
     +,-4.1523,-3.3027,-0.26089,0.15874
     +,-3.0175,-1.8125,-0.75694E-01,0.51021E-02
     +,-4.0626,-3.2616,-0.26653,0.15504
     +,-3.0862,-1.8882,-0.93679E-01,0.38370E-02
     +,-3.9705,-3.2160,-0.27238,0.15031
     +,-3.1456,-1.9572,-0.11034,0.26582E-02
     +,-3.8761,-3.1664,-0.27856,0.14462
     +,-3.1764,-2.0014,-0.12079,0.19291E-02
     +,-3.7797,-3.1138,-0.28517,0.13823
     +,-3.2001,-2.0409,-0.13038,0.12518E-02
     +,-3.6830,-3.0606,-0.29220,0.13166
     +,-2.3527,-1.3953,0.18353E-01,0.11661E-01
     +,-3.7196,-3.1764,-0.28985,0.16452/
      DATA((CFORM(I,J),I=1,8),J=71,80)/-2.4343,-1.4853,-.0039059,.010053
     +,-3.6407,-3.1393,-0.29399,0.16168
     +,-2.5051,-1.5660,-0.23942E-01,0.86019E-02
     +,-3.5604,-3.0986,-0.29802,0.15798
     +,-1.8482,-1.0335,0.10459,0.17905E-01
     +,-3.5085,-3.1017,-0.30378,0.16493
     +,-1.9235,-1.1237,0.81217E-01,0.16159E-01
     +,-3.4387,-3.0742,-0.30789,0.16440
     +,-1.9968,-1.2113,0.58623E-01,0.14477E-01
     +,-3.3686,-3.0445,-0.31168,0.16331
     +,-1.5319,-0.79915,0.16481,0.22511E-01
     +,-3.2798,-2.9781,-0.31121,0.15278
     +,-1.5451,-0.83937,0.15298,0.21567E-01
     +,-3.2138,-2.9536,-0.31574,0.15312
     +,-1.5881,-0.90618,0.13445,0.20123E-01
     +,-3.1480,-2.9280,-0.31999,0.15319
     +,-1.6449,-0.98427,0.11327,0.18495E-01
     +,-3.0827,-2.9016,-0.32395,0.15299
     +,-1.7060,-1.0648,0.91680E-01,0.16851E-01
     +,-3.0177,-2.8739,-0.32760,0.15248/
      DATA((CFORM(I,J),I=1,8),J=81,90)/-1.4063,-0.78702,.16611,.02263
     +,-2.9358,-2.8086,-0.32466,0.14168
     +,-1.3849,-0.79373,0.16298,0.22357E-01
     +,-2.8720,-2.7814,-0.32852,0.14138
     +,-1.4038,-0.84050,0.14911,0.21248E-01
     +,-2.8081,-2.7526,-0.33199,0.14064
     +,-1.3918,-0.84924,0.14659,0.21073E-01
     +,-2.7440,-2.7219,-0.33502,0.13940
     +,-1.3620,-0.84008,0.14882,0.21263E-01
     +,-2.6798,-2.6896,-0.33763,0.13770
     +,-1.3138,-0.81488,0.15492,0.21729E-01
     +,-2.6153,-2.6552,-0.33976,0.13541
     +,-1.2903,-0.81842,0.15271,0.21530E-01
     +,-2.5504,-2.6186,-0.34144,0.13254
     +,-1.2999,-0.85623,0.14107,0.20590E-01
     +,-2.5124,-2.6461,-0.35864,0.14864
     +,-1.3280,-0.91171,0.12477,0.19289E-01
     +,-2.4543,-2.6213,-0.36244,0.14915
     +,-1.3618,-0.97145,0.10751,0.17921E-01
     +,-2.3971,-2.5968,-0.36603,0.14969/
      DATA((CFORM(I,J),I=1,8),J=91,100)/-2.1137,-2.5390,-0.89964,-.12482
     +, 0.77611E-01,0.30619E-01,0.38767E-02,0.16722E-03
     +,-2.0552,-2.4989,-0.89176,-0.12773
     +, 0.76385E-01,0.30504E-01,0.38795E-02,0.16780E-03
     +,-2.0034,-2.4634,-0.88113,-0.12883
     +, 0.75109E-01,0.30234E-01,0.38560E-02,0.16706E-03
     +,-1.9472,-2.4095,-0.85679,-0.12888
     +,0.72058E-01,0.29358E-01,0.37583E-02,0.16315E-03
     +,-1.8812,-2.3376,-0.82622,-0.13040
     +,0.67863E-01,0.28260E-01,0.36427E-02,0.15873E-03
     +,-1.8109,-2.2711,-0.80769,-0.13494
     +,0.64860E-01,0.27749E-01,0.36090E-02,0.15806E-03
     +,-1.7501,-2.2381,-0.81389,-0.14124
     +,0.65086E-01,0.28325E-01,0.37071E-02,0.16301E-03
     +,-1.7117,-2.2507,-0.84168,-0.14592
     +,0.68718E-01,0.29785E-01,0.38979E-02,0.17149E-03
     +,-1.6921,-2.2819,-0.86677,-0.14607
     +,0.72800E-01,0.31032E-01,0.40423E-02,0.17744E-03
     +,-1.3289,-1.3553,-0.20094,-0.91459E-01
     +,-0.17322E-01,-0.97804E-03,0.,0./
*
C.    ------------------------------------------------------------------
C
      SIG = 0.
      IF(JRAYL.LE.0) GO TO 99
      ELOW2 = ELOW(IEKBIN)
      IF (Z.LT.1.0.OR.ELOW2.GT.0.001) GO TO 20
      ALOGQ2 = LOG(ELOW2*1000.)
      IF(IEKBIN.GT.1) THEN
        ELOW1 = ELOW(IEKBIN-1)
        ALOGQ1 = LOG(ELOW1*1000.)
      ELSE
        ELOW1 = 0.
        ALOGQ1 = 0.
      ENDIF
      IF(JMIXT.EQ.0)THEN
C
C             simple material (element)
C
         IZ=INT(Z)
         JRAYL=LQ(JMA-13)
         SIG=EXP(((COHER(4,IZ) *ALOGQ2+
     +             COHER(3,IZ))*ALOGQ2+
     +             COHER(2,IZ))*ALOGQ2+
     +             COHER(1,IZ))*AVO*DENS/A
         IF(IEKBIN.NE.1) THEN
C
C*    Use one or two functions to fit form factors
            IF (ELIM(IZ).EQ.0.) THEN
               FUN1 = (EXP(((((((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))*ALOGQ1+
     +                    CFORM(4,IZ))*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                FUN2=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
            ELSE
                IF (ELOW1.LE.ELIM(IZ)) THEN
                    FUN1=(EXP(((CFORM(4,IZ)*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                ELSE
                    FUN1=(EXP(((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))**2)*2.*ELOW1
                ENDIF
               IF (ELOW2.LE.ELIM(IZ)) THEN
                    FUN2=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                ELSE
                    FUN2=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2.*ELOW2
                ENDIF
            ENDIF

            Q(JRAYL+NEK1+IEKBIN)=Q(JRAYL+NEK1+IEKBIN-1)+
     +      0.5*(FUN2+FUN1)*(ELOW2-ELOW1)
         ELSE
            IF (ELIM(IZ).EQ.0.) THEN
                 FUN1=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
            ELSE
               IF (ELOW2.LE.ELIM(IZ)) THEN
                    FUN1=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                ELSE
                    FUN1=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2.*ELOW2
                ENDIF
                Q(JRAYL+NEK1+1)=Q(JRAYL+NEK1+1)+0.5*FUN1*ELOW2
            ENDIF
         ENDIF
      ELSE
C
C             compound/mixture
C
         NLMAT=Q(JMA+11)
         NLM=IABS(NLMAT)
         SIG=0.
         IF(IEKBIN.NE.1) THEN
            HINT=0.
         ELSE
            Q(JRAYL+NEK1+1)=0.
         ENDIF
         DO 10 I=1,NLM
            J=JMIXT+I
            AA=Q(J)
            ZZ=Q(J+NLM)
            IZ=INT(ZZ)
            WMAT=Q(J+2*NLM)
            S=EXP(((COHER(4,IZ) *ALOGQ2+
     +                   COHER(3,IZ))*ALOGQ2+
     +                   COHER(2,IZ))*ALOGQ2+
     +                   COHER(1,IZ))
            S=S*WMAT/AA
            SIG=SIG+AVO*DENS*S
            IF(IEKBIN.NE.1) THEN
C
C*    Use one or two functions to fit form factors
            IF (ELIM(IZ).EQ.0.) THEN
                FUN1=(EXP(((((((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))*ALOGQ1+
     +                    CFORM(4,IZ))*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                FUN2=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
            ELSE
                IF (ELOW1.LE.ELIM(IZ)) THEN
                    FUN1=(EXP(((CFORM(4,IZ)*ALOGQ1+
     +                    CFORM(3,IZ))*ALOGQ1+
     +                    CFORM(2,IZ))*ALOGQ1+
     +                    CFORM(1,IZ))**2)*2.*ELOW1
                ELSE
                    FUN1=(EXP(((CFORM(8,IZ)*ALOGQ1+
     +                    CFORM(7,IZ))*ALOGQ1+
     +                    CFORM(6,IZ))*ALOGQ1+
     +                    CFORM(5,IZ))**2)*2.*ELOW1
                ENDIF
               IF (ELOW2.LE.ELIM(IZ)) THEN
                    FUN2=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                ELSE
                    FUN2=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2*ELOW2
                ENDIF
            ENDIF
               HINT=HINT+WMAT*0.5*(FUN2+FUN1)*(ELOW2-ELOW1)
*
            ELSE
               IF (ELIM(IZ).EQ.0.) THEN
                   FUN1=(EXP(((((((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))*ALOGQ2+
     +                    CFORM(4,IZ))*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
               ELSE
                  IF (ELOW2.LE.ELIM(IZ)) THEN
                      FUN1=(EXP(((CFORM(4,IZ)*ALOGQ2+
     +                    CFORM(3,IZ))*ALOGQ2+
     +                    CFORM(2,IZ))*ALOGQ2+
     +                    CFORM(1,IZ))**2)*2.*ELOW2
                  ELSE
                      FUN1=(EXP(((CFORM(8,IZ)*ALOGQ2+
     +                    CFORM(7,IZ))*ALOGQ2+
     +                    CFORM(6,IZ))*ALOGQ2+
     +                    CFORM(5,IZ))**2)*2.*ELOW2
                  ENDIF
               ENDIF
               Q(JRAYL+NEK1+1)=Q(JRAYL+NEK1+1)+WMAT*0.5*FUN1*ELOW2
            ENDIF
   10    CONTINUE
         IF(IEKBIN.NE.1)
     +   Q(JRAYL+NEK1+IEKBIN)=Q(JRAYL+NEK1+IEKBIN-1)+HINT
      ENDIF
C
   20 IF(SIG.GT.0.)THEN
         Q(JRAYL+IEKBIN)=1./SIG
      ELSE
         Q(JRAYL+IEKBIN)=BIG
         Q(JRAYL+NEK1+IEKBIN)=0.
      ENDIF
C
  99  END
+DECK,  GSHLIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:33  cernlib
* Geant

      SUBROUTINE GSHLIN
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Initialize atomic shells' potentials                     *
C.    *                                                                *
C.    * Potentials according to Rev.Mod.Phys. vol. 39 nr. 1 125 (1967) *
C.    * Xe upadetd according to Grishin et al. NIM A309, 476 (1991)    *
C.    *                                                                *
C.    *    ==>Called by : GPHINI                                       *
C.    *       Author    J. Chwastowski                                 *
C.    *                                                                *
C.    ******************************************************************
C.
C  Shells
c  See alse Handbook of Phys. & Chemistry
c
      IMPLICIT NONE
+CDE, GCPMXZ.
+CDE, GCSHPT.
      INTEGER NS,N1,NP,I
      REAL TMP
      DIMENSION NS(MAXSHL),N1(MAXELZ),NP(MAXELZ)
      DIMENSION TMP(LENGTH)
      DATA NS / 1,3*5,3*17,2*21,35,2*33,
     +          2*41,2*58,3*49,2*73,3*82 /
      DATA N1(  1),NP(  1) /    1,    1 /
      DATA TMP(   1) /  13.59811 /
      DATA N1(  2),NP(  2) /    2,    1 /
      DATA TMP(   2) /  24.58678 /
      DATA N1(  3),NP(  3) /    3,    1 /
      DATA TMP(   3) /  54.75000 /
      DATA N1(  4),NP(  4) /    4,    1 /
      DATA TMP(   4) / 111.00000 /
      DATA N1(  5),NP(  5) /    5,    4 /
      DATA (TMP(I),I=  5,  8) /
     +      188.00,     12.58,      4.70,      4.70 /
      DATA N1(  6),NP(  6) /    9,    4 /
      DATA (TMP(I),I=  9, 12) /
     +      283.80,     17.56,      6.40,      6.40 /
      DATA N1(  7),NP(  7) /   13,    4 /
      DATA (TMP(I),I= 13, 16) /
     +      401.60,     23.10,      9.20,      9.20 /
      DATA N1(  8),NP(  8) /   17,    4 /
      DATA (TMP(I),I= 17, 20) /
     +      532.00,     23.70,      7.10,      7.10 /
      DATA N1(  9),NP(  9) /   21,    4 /
      DATA (TMP(I),I= 21, 24) /
     +      685.40,     31.00,      8.60,      8.60 /
      DATA N1( 10),NP( 10) /   25,    4 /
      DATA (TMP(I),I= 25, 28) /
     +      866.90,     45.00,     18.30,     18.30 /
      DATA N1( 11),NP( 11) /   29,    4 /
      DATA (TMP(I),I= 29, 32) /
     +     1072.10,     63.30,     31.10,     31.10 /
      DATA N1( 12),NP( 12) /   33,    4 /
      DATA (TMP(I),I= 33, 36) /
     +     1305.00,     89.40,     51.40,     51.40 /
      DATA N1( 13),NP( 13) /   37,    4 /
      DATA (TMP(I),I= 37, 40) /
     +     1559.60,    117.70,     73.10,     73.10 /
      DATA N1( 14),NP( 14) /   41,    4 /
      DATA (TMP(I),I= 41, 44) /
     +     1838.90,    148.70,     99.20,     99.20 /
      DATA N1( 15),NP( 15) /   45,    4 /
      DATA (TMP(I),I= 45, 48) /
     +     2145.50,    189.30,    132.20,    132.20 /
      DATA N1( 16),NP( 16) /   49,    4 /
      DATA (TMP(I),I= 49, 52) /
     +     2472.00,    229.20,    164.80,    164.80 /
      DATA N1( 17),NP( 17) /   53,    7 /
      DATA (TMP(I),I=  53,  59) /
     +     2822.40,    270.20,    201.60,    200.00
     + ,     17.50,      6.80,      6.80 /
      DATA N1( 18),NP( 18) /   60,    7 /
      DATA (TMP(I),I=  60,  66) /
     +     3202.90,    320.00,    247.30,    245.20
     + ,     25.30,     12.40,     12.40 /
      DATA N1( 19),NP( 19) /   67,    7 /
      DATA (TMP(I),I=  67,  73) /
     +     3607.40,    377.10,    296.30,    293.60
     + ,     33.90,     17.80,     17.80 /
      DATA N1( 20),NP( 20) /   74,    7 /
      DATA (TMP(I),I=  74,  80) /
     +     4038.10,    437.80,    350.00,    346.40
     + ,     43.70,     25.40,     25.40 /
      DATA N1( 21),NP( 21) /   81,    9 /
      DATA (TMP(I),I=  81,  89) /
     +     4492.80,    500.40,    406.70,    402.20
     + ,     53.80,     32.30,     32.30,      6.60,      6.60 /
      DATA N1( 22),NP( 22) /   90,    9 /
      DATA (TMP(I),I=  90,  98) /
     +     4966.40,    563.70,    461.50,    455.50
     + ,     60.30,     34.60,     34.60,      3.70,      3.70 /
      DATA N1( 23),NP( 23) /   99,    9 /
      DATA (TMP(I),I=  99, 107) /
     +     5465.10,    628.20,    520.50,    512.90
     + ,     66.50,     37.80,     37.80,      2.20,      2.20 /
      DATA N1( 24),NP( 24) /  108,    9 /
      DATA (TMP(I),I= 108, 116) /
     +     5989.20,    694.60,    583.70,    574.50
     + ,     74.10,     42.50,     42.50,      2.30,      2.30 /
      DATA N1( 25),NP( 25) /  117,    9 /
      DATA (TMP(I),I= 117, 125) /
     +     6539.00,    769.00,    651.40,    640.30
     + ,     83.90,     48.60,     48.60,      3.30,      3.30 /
      DATA N1( 26),NP( 26) /  126,    9 /
      DATA (TMP(I),I= 126, 134) /
     +     7112.00,    846.10,    721.10,    708.10
     + ,     92.90,     54.00,     54.00,      3.60,      3.60 /
      DATA N1( 27),NP( 27) /  135,    9 /
      DATA (TMP(I),I= 135, 143) /
     +     7708.90,    925.60,    793.60,    778.60
     + ,    100.70,     59.50,     59.50,      2.90,      2.90 /
      DATA N1( 28),NP( 28) /  144,    9 /
      DATA (TMP(I),I= 144, 152) /
     +     8332.80,   1008.10,    871.90,    854.70
     + ,    111.80,     68.10,     68.10,      3.60,      3.60 /
      DATA N1( 29),NP( 29) /  153,    9 /
      DATA (TMP(I),I= 153, 161) /
     +     8978.90,   1096.60,    951.00,    931.10
     + ,    119.80,     73.60,     73.60,      1.60,      1.60 /
      DATA N1( 30),NP( 30) /  162,    9 /
      DATA (TMP(I),I= 162, 170) /
     +     9658.60,   1193.60,   1042.80,   1019.70
     + ,    135.90,     86.60,     86.60,      8.10,      8.10 /
      DATA N1( 31),NP( 31) /  171,    9 /
      DATA (TMP(I),I= 171, 179) /
     +    10367.10,   1297.70,   1142.30,   1115.40
     + ,    158.10,    106.80,    102.90,     17.40,     17.40 /
      DATA N1( 32),NP( 32) /  180,    9 /
      DATA (TMP(I),I= 180, 188) /
     +    11103.10,   1414.30,   1247.80,   1216.70
     + ,    180.00,    127.90,    120.80,     28.70,     28.70 /
      DATA N1( 33),NP( 33) /  189,   12 /
      DATA (TMP(I),I= 189, 200) /
     +    11866.70,   1526.50,   1358.60,   1323.10
     + ,    203.50,    146.40,    140.50,     41.20
     + ,     41.20,      0.00,      2.50,      2.50 /
      DATA N1( 34),NP( 34) /  201,   12 /
      DATA (TMP(I),I= 201, 212) /
     +    12657.80,   1653.90,   1476.20,   1435.80
     + ,    231.50,    168.20,    161.90,     56.70
     + ,     56.70,      0.00,      5.60,      5.60 /
      DATA N1( 35),NP( 35) /  213,   12 /
      DATA (TMP(I),I= 213, 224) /
     +    13473.70,   1782.00,   1596.00,   1549.90
     + ,    256.50,    189.30,    181.50,     70.10
     + ,     69.00,     27.30,      5.20,      4.60 /
      DATA N1( 36),NP( 36) /  225,   12 /
      DATA (TMP(I),I= 225, 236) /
     +    14325.60,   1921.00,   1727.20,   1674.90
     + ,    292.80,    222.70,    213.80,     95.00
     + ,     93.80,     24.00,     10.60,     10.60 /
      DATA N1( 37),NP( 37) /  237,   12 /
      DATA (TMP(I),I= 237, 248) /
     +    15199.70,   2065.10,   1863.90,   1804.40
     + ,    322.10,    247.40,    238.50,    111.80
     + ,    110.30,     29.30,     14.80,     14.00 /
      DATA N1( 38),NP( 38) /  249,   12 /
      DATA (TMP(I),I= 249, 260) /
     +    16104.60,   2216.30,   2006.80,   1939.60
     + ,    357.50,    279.80,    269.10,    135.00
     + ,    133.10,     37.70,     19.90,     19.90 /
      DATA N1( 39),NP( 39) /  261,   12 /
      DATA (TMP(I),I= 261, 272) /
     +    17038.40,   2372.50,   2155.50,   2080.00
     + ,    393.60,    312.40,    300.30,    159.60
     + ,    157.40,     45.40,     25.60,     25.60 /
      DATA N1( 40),NP( 40) /  273,   12 /
      DATA (TMP(I),I= 273, 284) /
     +    17997.60,   2531.60,   2306.70,   2222.30
     + ,    430.30,    344.20,    350.50,    182.40
     + ,    180.00,     51.30,     28.70,     28.70 /
      DATA N1( 41),NP( 41) /  285,   14 /
      DATA (TMP(I),I= 285, 298) /
     +    18985.60,   2697.70,   2464.70,   2370.50
     + ,    468.40,    378.40,    383.00,    207.40
     + ,    204.60,     58.10,     33.90,     33.90
     + ,      3.20,      3.20 /
      DATA N1( 42),NP( 42) /  299,   14 /
      DATA (TMP(I),I= 299, 312) /
     +    19999.50,   2865.50,   2625.10,   2520.20
     + ,    504.60,    409.70,    392.30,    230.30
     + ,    227.00,     61.80,     34.80,     34.80
     + ,      1.80,      1.80 /
      DATA N1( 43),NP( 43) /  313,   12 /
      DATA (TMP(I),I= 313, 324) /
     +    21044.00,   3042.50,   2793.20,   2676.90
     + ,      0.00,    444.90,    425.00,    256.40
     + ,    252.90,      0.00,     38.90,     38.90 /
      DATA N1( 44),NP( 44) /  325,   14 /
      DATA (TMP(I),I= 325, 338) /
     +    22117.20,   3224.00,   2966.90,   2837.90
     + ,    585.00,    482.80,    460.60,    283.60
     + ,    279.40,     74.90,     43.10,     43.10
     + ,      2.00,      2.00 /
      DATA N1( 45),NP( 45) /  339,   14 /
      DATA (TMP(I),I= 339, 352) /
     +    23219.90,   3411.90,   3146.10,   3003.80
     + ,    627.10,    521.00,    496.20,    311.70
     + ,    307.00,     81.00,     47.90,     47.90
     + ,      2.50,      2.50 /
      DATA N1( 46),NP( 46) /  353,   14 /
      DATA (TMP(I),I= 353, 366) /
     +    24350.30,   3604.30,   3330.30,   3173.30
     + ,    669.90,    559.10,    531.50,    340.00
     + ,    334.70,     86.40,     51.10,     51.10
     + ,      1.50,      1.50 /
      DATA N1( 47),NP( 47) /  367,   14 /
      DATA (TMP(I),I= 367, 380) /
     +    25514.00,   3805.80,   3523.70,   3351.10
     + ,    717.50,    602.40,    571.40,    372.80
     + ,    366.70,     95.20,     62.60,     55.90
     + ,      3.30,      3.30 /
      DATA N1( 48),NP( 48) /  381,   14 /
      DATA (TMP(I),I= 381, 394) /
     +    26711.20,   4018.00,   3727.00,   3537.50
     + ,    770.20,    650.70,    616.50,    410.50
     + ,    403.70,    107.60,     66.90,     66.90
     + ,      9.30,      9.30 /
      DATA N1( 49),NP( 49) /  395,   19 /
      DATA (TMP(I),I= 395, 413) /
     +    27939.90,   4237.50,   3938.00,   3730.10
     + ,    825.60,    702.20,    664.30,    450.80
     + ,    443.10,    121.90,     77.40,     77.40
     + ,     16.20,     16.20,      0.00,      0.00
     + ,      0.10,      0.80,      0.80 /
      DATA N1( 50),NP( 50) /  414,   19 /
      DATA (TMP(I),I= 414, 432) /
     +    29200.10,   4464.70,   4156.10,   3928.80
     + ,    883.80,    756.40,    714.40,    493.30
     + ,    484.80,    136.50,     88.60,     88.60
     + ,     23.90,     23.90,      0.00,      0.00
     + ,      0.90,      1.10,      1.10 /
      DATA N1( 51),NP( 51) /  433,   19 /
      DATA (TMP(I),I= 433, 451) /
     +    30491.20,   4698.30,   4380.40,   4132.20
     + ,    943.70,    811.90,    765.60,    536.90
     + ,    527.50,    152.00,     98.40,     98.40
     + ,     31.40,     31.40,      0.00,      0.00
     + ,      6.70,      2.10,      2.10 /
      DATA N1( 52),NP( 52) /  452,   19 /
      DATA (TMP(I),I= 452, 470) /
     +    31813.80,   4939.20,   4612.00,   4341.40
     + ,   1006.00,    869.70,    818.70,    582.50
     + ,    572.10,    168.30,    110.20,    110.20
     + ,     39.80,     39.80,      0.00,      0.00
     + ,     11.60,      2.30,      2.30 /
      DATA N1( 53),NP( 53) /  471,   19 /
      DATA (TMP(I),I= 471, 489) /
     +    33169.40,   5188.10,   4852.10,   4557.10
     + ,   1072.10,    930.50,    874.60,    631.30
     + ,    619.40,    186.40,    122.70,    122.70
     + ,     49.60,     49.60,      0.00,      0.00
     + ,     13.60,      3.30,      3.30 /
      DATA N1( 54),NP( 54) /  490,   19 /
      DATA (TMP(I),I= 490, 508) /
     +    34561.40,   5452.80,   5103.70,   4782.20
     + ,   1145.70,    999.00,    937.00,    689.00
     + ,    672.30,    213.20,    157.00,    146.70
     + ,     69.50,     67.50,      0.00,      0.00
     + ,     23.39,     13.43,     12.13 /
      DATA N1( 55),NP( 55) /  509,   19 /
      DATA (TMP(I),I= 509, 527) /
     +    35984.60,   5714.30,   5359.40,   5011.90
     + ,   1217.10,   1065.00,    997.60,    739.50
     + ,    725.50,    230.80,    172.30,    161.60
     + ,     78.80,     76.50,      0.00,      0.00
     + ,     22.70,     13.10,     11.40 /
      DATA N1( 56),NP( 56) /  528,   19 /
      DATA (TMP(I),I= 528, 546) /
     +    37440.60,   5988.80,   5623.60,   5247.00
     + ,   1292.80,   1136.70,   1062.20,    796.10
     + ,    780.70,    253.00,    191.80,    179.70
     + ,     92.50,     89.90,      0.00,      0.00
     + ,     39.10,     16.60,     14.60 /
      DATA N1( 57),NP( 57) /  547,   19 /
      DATA (TMP(I),I= 547, 565) /
     +    38924.60,   6266.30,   5890.60,   5482.70
     + ,   1361.30,   1204.40,   1123.40,    848.50
     + ,    831.70,    270.40,    205.80,    191.40
     + ,     98.90,     98.90,      0.00,      0.00
     + ,     32.30,     14.40,     14.40 /
      DATA N1( 58),NP( 58) /  566,   19 /
      DATA (TMP(I),I= 566, 584) /
     +    40443.00,   6548.80,   6164.20,   5723.40
     + ,   1434.60,   1272.80,   1185.40,    901.30
     + ,    883.30,    289.60,    223.30,    207.20
     + ,    110.00,    110.00,      0.10,      0.10
     + ,     37.80,     19.80,     19.80 /
      DATA N1( 59),NP( 59) /  585,   19 /
      DATA (TMP(I),I= 585, 603) /
     +    41990.60,   6834.80,   6440.40,   5964.30
     + ,   1511.00,   1337.40,   1242.20,    951.10
     + ,    931.00,    304.50,    236.30,    217.60
     + ,    113.20,    113.20,      2.00,      2.00
     + ,     37.40,     22.30,     22.30 /
      DATA N1( 60),NP( 60) /  604,   19 /
      DATA (TMP(I),I= 604, 622) /
     +    43568.90,   7126.00,   6721.50,   6207.90
     + ,   1575.30,   1402.80,   1297.40,    999.90
     + ,    977.70,    315.20,    243.30,    224.60
     + ,    117.50,    117.50,      1.50,      1.50
     + ,     37.50,     21.20,     21.80 /
      DATA N1( 61),NP( 61) /  623,   14 /
      DATA (TMP(I),I= 623, 636) /
     +    45184.00,   7427.90,   7012.80,   6459.30
     + ,   1650.00,   1471.40,   1356.90,   1051.50
     + ,   1026.90,      0.00,    242.00,    242.00
     + ,    120.40,    120.40 /
      DATA N1( 62),NP( 62) /  637,   19 /
      DATA (TMP(I),I= 637, 655) /
     +    46834.20,   7736.80,   7311.80,   6716.20
     + ,   1722.80,   1540.70,   1419.80,   1106.00
     + ,   1080.20,    345.70,    265.60,    247.40
     + ,    129.00,    129.00,      5.50,      5.50
     + ,     37.40,     21.30,     21.30 /
      DATA N1( 63),NP( 63) /  656,   19 /
      DATA (TMP(I),I= 656, 674) /
     +    48519.00,   8052.00,   7617.10,   6976.90
     + ,   1800.00,   1613.90,   1480.60,   1160.60
     + ,   1130.90,    360.20,    283.90,    256.60
     + ,    133.20,    133.20,      0.00,      0.00
     + ,     31.80,     22.00,     22.00 /
      DATA N1( 64),NP( 64) /  675,   19 /
      DATA (TMP(I),I= 675, 693) /
     +    50239.10,   8375.60,   7930.30,   7242.80
     + ,   1880.80,   1688.30,   1544.00,   1217.20
     + ,   1185.20,    375.80,    288.50,    270.90
     + ,    140.50,    140.50,      0.10,      0.10
     + ,     36.10,     20.30,     20.30 /
      DATA N1( 65),NP( 65) /  694,   19 /
      DATA (TMP(I),I= 694, 712) /
     +    51995.70,   8708.00,   8251.60,   7514.00
     + ,   1967.50,   1767.70,   1611.30,   1275.00
     + ,   1241.20,    397.90,    310.20,    285.00
     + ,    147.00,    147.00,      2.60,      2.60
     + ,     39.00,     25.40,     25.40 /
      DATA N1( 66),NP( 66) /  713,   19 /
      DATA (TMP(I),I= 713, 731) /
     +    53788.50,   9045.80,   8580.60,   7790.10
     + ,   2046.80,   1841.80,   1675.60,   1332.50
     + ,   1294.90,    416.30,    331.80,    292.90
     + ,    154.20,    154.20,      4.20,      4.20
     + ,     62.90,     26.30,     26.30 /
      DATA N1( 67),NP( 67) /  732,   19 /
      DATA (TMP(I),I= 732, 750) /
     +    55617.70,   9394.20,   8917.80,   8071.10
     + ,   2128.30,   1922.80,   1741.20,   1391.50
     + ,   1351.40,    435.70,    343.50,    306.60
     + ,    161.00,    161.00,      3.70,      3.70
     + ,     51.20,     20.30,     20.30 /
      DATA N1( 68),NP( 68) /  751,   19 /
      DATA (TMP(I),I= 751, 769) /
     +    57485.50,   9751.30,   9264.30,   8357.90
     + ,   2206.50,   2005.80,   1811.80,   1453.30
     + ,   1409.30,    449.10,    366.20,    320.00
     + ,    176.70,    167.60,      4.30,      4.30
     + ,     59.80,     29.40,     29.40 /
      DATA N1( 69),NP( 69) /  770,   19 /
      DATA (TMP(I),I= 770, 788) /
     +    59389.60,  10115.70,   9616.90,   8648.00
     + ,   2306.80,   2089.80,   1884.50,   1514.60
     + ,   1467.70,    471.70,    385.90,    336.60
     + ,    179.60,    179.60,      5.30,      5.30
     + ,     53.20,     32.30,     32.30 /
      DATA N1( 70),NP( 70) /  789,   19 /
      DATA (TMP(I),I= 789, 807) /
     +    61332.30,  10486.40,   9978.20,   8943.60
     + ,   2398.10,   2173.00,   1949.80,   1576.30
     + ,   1527.80,    487.20,    396.70,    343.50
     + ,    198.10,    184.90,      6.30,      6.30
     + ,     54.10,     23.40,     23.40 /
      DATA N1( 71),NP( 71) /  808,   19 /
      DATA (TMP(I),I= 808, 826) /
     +    63313.80,  10870.40,  10348.60,   9244.10
     + ,   2491.20,   2263.50,   2023.60,   1639.40
     + ,   1588.50,    506.20,    410.10,    359.30
     + ,    204.80,    195.00,      6.90,      6.90
     + ,     56.80,     28.00,     28.00 /
      DATA N1( 72),NP( 72) /  827,   19 /
      DATA (TMP(I),I= 827, 845) /
     +    65350.80,  11270.70,  10739.40,   9560.70
     + ,   2600.90,   2365.40,   2107.60,   1716.40
     + ,   1661.70,    538.10,    437.00,    380.40
     + ,    223.80,    213.70,     17.10,     17.10
     + ,     64.90,     38.10,     30.60 /
      DATA N1( 73),NP( 73) /  846,   21 /
      DATA (TMP(I),I= 846, 866) /
     +    67416.40,  11681.50,  11136.10,   9881.10
     + ,   2708.00,   2468.70,   2194.00,   1793.20
     + ,   1735.10,    565.50,    464.80,    404.50
     + ,    241.30,    229.30,     25.00,     25.00
     + ,     71.10,     44.90,     36.40,      5.70,      5.70 /
      DATA N1( 74),NP( 74) /  867,   21 /
      DATA (TMP(I),I= 867, 887) /
     +    69525.00,  12099.80,  11544.00,  10206.80
     + ,   2819.60,   2574.90,   2281.00,   1871.60
     + ,   1809.20,    595.00,    491.60,    425.30
     + ,    258.80,    245.40,     36.50,     33.60
     + ,     77.10,     46.80,     35.60,      6.10,      6.10 /
      DATA N1( 75),NP( 75) /  888,   21 /
      DATA (TMP(I),I= 888, 908) /
     +    71676.40,  12526.70,  11958.70,  10535.30
     + ,   2931.70,   2681.60,   2367.30,   1948.90
     + ,   1882.90,    625.00,    517.90,    444.40
     + ,    273.70,    260.20,     40.60,     40.60
     + ,     82.80,     45.60,     34.60,      3.50,      3.50 /
      DATA N1( 76),NP( 76) /  909,   19 /
      DATA (TMP(I),I= 909, 927) /
     +    73870.80,  12968.00,  12385.00,  10870.90
     + ,   3048.50,   2792.20,   2457.20,   2030.80
     + ,   1960.10,    654.30,    546.50,    468.20
     + ,    289.40,    272.80,     46.30,     43.40
     + ,     83.70,     58.00,     45.40 /
      DATA N1( 77),NP( 77) /  928,   21 /
      DATA (TMP(I),I= 928, 948) /
     +    76111.00,  13418.50,  12824.10,  11215.20
     + ,   3173.70,   2908.70,   2550.70,   2116.10
     + ,   2040.40,    690.10,    577.10,    494.30
     + ,    311.40,    294.90,     63.40,     60.50
     + ,     95.20,     63.00,     50.50,      1.80,      1.80 /
      DATA N1( 78),NP( 78) /  949,   21 /
      DATA (TMP(I),I= 949, 969) /
     +    78394.80,  13879.90,  13272.60,  11563.70
     + ,   3296.00,   3026.50,   2645.40,   2201.90
     + ,   2121.60,    722.00,    609.20,    519.00
     + ,    330.80,    313.30,     74.30,     71.10
     + ,    101.70,     65.30,     51.70,      2.20,      2.20 /
      DATA N1( 79),NP( 79) /  970,   20 /
      DATA (TMP(I),I= 970, 989) /
     +    80724.90,  14352.80,  13733.60,  11918.70
     + ,   3424.90,   3147.80,   2743.00,   2291.10
     + ,   2205.70,    758.80,    643.70,    545.40
     + ,    352.00,    333.90,     86.40,     82.80
     + ,    107.80,     71.70,     53.70,      2.50 /
      DATA N1( 80),NP( 80) /  990,   21 /
      DATA (TMP(I),I= 990,1010) /
     +    83102.30,  14839.30,  14208.70,  12283.90
     + ,   3561.60,   3278.50,   2847.10,   2384.90
     + ,   2294.90,    800.30,    676.90,    571.00
     + ,    378.30,    359.80,    102.20,     98.50
     + ,    120.30,     80.50,     57.60,      6.40,      6.40 /
      DATA N1( 81),NP( 81) / 1011,   21 /
      DATA (TMP(I),I=1011,1031) /
     +    85530.40,  15346.70,  14697.90,  12657.50
     + ,   3704.10,   3425.70,   2956.60,   2485.10
     + ,   2389.30,    845.50,    721.30,    609.00
     + ,    406.60,    386.20,    122.80,    118.50
     + ,    136.30,     99.60,     75.40,     15.30,     13.10 /
      DATA N1( 82),NP( 82) / 1032,   24 /
      DATA (TMP(I),I=1032,1055) /
     +    88004.50,  15860.80,  15200.00,  13035.20
     + ,   3850.70,   3554.20,   3066.40,   2585.60
     + ,   2484.00,    893.60,    763.90,    644.50
     + ,    435.20,    412.90,    142.90,    138.10
     + ,    147.30,    104.80,     86.00,     21.80
     + ,     19.20,      3.10,      0.70,      0.70 /
      DATA N1( 83),NP( 83) / 1056,   24 /
      DATA (TMP(I),I=1056,1079) /
     +    90525.90,  16387.50,  15711.10,  13418.60
     + ,   3999.10,   3696.30,   3176.90,   2687.60
     + ,   2579.60,    938.20,    805.30,    678.90
     + ,    463.60,    440.00,    161.90,    157.40
     + ,    159.30,    116.80,     92.80,     26.50
     + ,     24.40,      0.00,      2.70,      2.70 /
      DATA N1( 84),NP( 84) / 1080,   21 /
      DATA (TMP(I),I=1080,1100) /
     +    93105.00,  16939.30,  16244.30,  13813.80
     + ,   4149.40,   3854.10,   3301.90,   2798.00
     + ,   2683.00,    995.30,    851.00,    705.00
     + ,    500.20,    473.40,      0.00,      0.00
     + ,      0.00,      0.00,      0.00,     31.40,     31.40 /
      DATA N1( 85),NP( 85) / 1101,   14 /
      DATA (TMP(I),I=1101,1114) /
     +    95729.90,  17493.00,  16784.70,  14213.50
     + ,   4317.00,   4008.00,   3426.00,   2908.70
     + ,   2786.70,   1042.00,    886.00,    740.00
     + ,    533.20,    506.00 /
      DATA N1( 86),NP( 86) / 1115,   14 /
      DATA (TMP(I),I=1115,1128) /
     +    98404.00,  18049.00,  17337.10,  14619.40
     + ,   4482.00,   4159.00,   3538.00,   3021.50
     + ,   2892.40,   1097.00,    929.00,    768.00
     + ,    566.60,    541.00 /
      DATA N1( 87),NP( 87) / 1129,   14 /
      DATA (TMP(I),I=1129,1142) /
     +   101137.00,  18639.00,  17906.50,  15031.20
     + ,   4652.00,   4327.00,   3663.00,   3136.20
     + ,   2999.90,   1153.00,    980.00,    810.00
     + ,    603.30,    577.00 /
      DATA N1( 88),NP( 88) / 1143,   24 /
      DATA (TMP(I),I=1143,1166) /
     +   103921.90,  19236.70,  18484.30,  15444.40
     + ,   4822.00,   4489.50,   3791.80,   3248.40
     + ,   3104.90,   1208.40,   1057.60,    879.10
     + ,    635.90,    602.70,    298.90,    298.90
     + ,    254.40,    200.40,    152.80,     67.20
     + ,     67.20,     43.50,     18.80,     18.80 /
      DATA N1( 89),NP( 89) / 1167,   14 /
      DATA (TMP(I),I=1167,1180) /
     +   106755.30,  19840.00,  19083.20,  15871.00
     + ,   5002.00,   4656.00,   3909.00,   3370.20
     + ,   3219.00,   1269.00,   1080.00,    890.00
     + ,    674.90,    644.00 /
      DATA N1( 90),NP( 90) / 1181,   24 /
      DATA (TMP(I),I=1181,1204) /
     +   109650.90,  20472.10,  19693.20,  16300.30
     + ,   5182.30,   4830.40,   4046.10,   3490.80
     + ,   3332.00,   1329.50,   1168.20,    967.30
     + ,    714.10,    676.40,    344.40,    335.20
     + ,    290.20,    229.40,    181.80,     94.30
     + ,     87.90,     59.50,     49.00,     43.00 /
      DATA N1( 91),NP( 91) / 1205,   21 /
      DATA (TMP(I),I=1205,1225) /
     +   112601.40,  21104.60,  20313.70,  16733.10
     + ,   5366.90,   5000.90,   4173.80,   3611.20
     + ,   3441.80,   1387.10,   1224.30,   1006.70
     + ,    743.40,    708.20,    371.20,    359.50
     + ,    309.60,    222.90,    222.90,     94.10,     94.10 /
      DATA N1( 92),NP( 92) / 1226,   24 /
      DATA (TMP(I),I=1226,1249) /
     +   115606.10,  21757.40,  20947.60,  17166.30
     + ,   5548.00,   5182.20,   4303.40,   3727.60
     + ,   3551.70,   1440.80,   1272.60,   1044.90
     + ,    780.40,    737.70,    391.30,    380.90
     + ,    323.70,    259.30,    195.10,    105.00
     + ,     96.30,     70.70,     42.30,     32.30 /
      DATA N1( 93),NP( 93) / 1250,   21 /
      DATA (TMP(I),I=1250,1270) /
     +   118678.00,  22426.80,  21600.50,  17610.00
     + ,   5723.20,   5366.20,   4434.70,   3850.30
     + ,   3665.80,   1500.70,   1327.70,   1086.80
     + ,    815.90,    770.30,    415.00,    404.40
     + ,      0.00,    283.40,    206.10,    109.30,    101.30 /
      DATA N1( 94),NP( 94) / 1271,   21 /
      DATA (TMP(I),I=1271,1291) /
     +   121818.00,  23097.20,  22266.20,  18056.80
     + ,   5932.90,   5541.20,   4556.60,   3972.60
     + ,   3778.10,   1558.60,   1372.10,   1114.80
     + ,    848.90,    801.40,    445.80,    432.40
     + ,    351.90,    274.10,    206.50,    116.00,    105.40 /
      DATA N1( 95),NP( 95) / 1292,   21 /
      DATA (TMP(I),I=1292,1312) /
     +   125027.00,  23772.90,  22944.00,  18504.10
     + ,   6120.50,   5710.20,   4667.00,   4092.10
     + ,   3886.90,   1617.10,   1411.80,   1135.70
     + ,    878.70,    827.60,      0.00,      0.00
     + ,      0.00,      0.00,      0.00,    115.80,    103.30 /
      DATA N1( 96),NP( 96) / 1313,   21 /
      DATA (TMP(I),I=1313,1333) /
     +   128220.00,  24460.00,  23779.00,  18930.00
     + ,   6288.00,   5895.00,   4797.00,   4227.00
     + ,   3971.00,   1643.00,   1440.00,   1154.00
     + ,      0.00,    853.00,      0.00,      0.00
     + ,    385.00,      0.00,      0.00,      0.00,    100.00 /
      DATA N1( 97),NP( 97) / 1334,   21 /
      DATA (TMP(I),I=1334,1354) /
     +   131590.00,  25275.00,  24385.00,  19452.00
     + ,   6556.00,   6147.00,   4977.00,   4366.00
     + ,   4132.00,   1755.00,   1554.00,   1235.00
     + ,      0.00,    877.00,      0.00,      0.00
     + ,    398.00,      0.00,      0.00,      0.00,    100.00 /
      DATA N1( 98),NP( 98) / 1355,   21 /
      DATA (TMP(I),I=1355,1375) /
     +   135960.00,  26110.00,  25250.00,  19930.00
     + ,   6754.00,   6359.00,   5109.00,   4497.00
     + ,   4253.00,   1799.00,   1616.00,   1279.00
     + ,      0.00,    902.00,      0.00,      0.00
     + ,    419.00,      0.00,      0.00,      0.00,    100.00 /
      DATA N1( 99),NP( 99) / 1376,   17 /
      DATA (TMP(I),I=1376,1392) /
     +   139490.00,  26900.00,  26020.00,  20410.00
     + ,   6977.00,   6574.00,   5252.00,   4630.00
     + ,   4374.00,   1868.00,   1680.00,   1321.00
     + ,      0.00,    927.00,      0.00,      0.00,    435.00 /
      DATA N1(100),NP(100) / 1393,   17 /
      DATA (TMP(I),I=1393,1409) /
     +   143090.00,  27700.00,  26810.00,  20900.00
     + ,   7205.00,   6793.00,   5397.00,   4766.00
     + ,   4498.00,   1937.00,   1747.00,   1366.00
     + ,      0.00,    952.00,      0.00,      0.00,    454.00 /
      DO 10 I = 1,LENGTH
         ESHELL(I) = TMP(I)
   10 CONTINUE
      DO 20 I = 1,MAXSHL
         NSHLST(I) = NS(I)
   20 CONTINUE
      DO 30 I = 1,MAXELZ
         N1ST(I) = N1(I)
         NSHLLS(I) = NP(I)
   30 CONTINUE
      END
+DECK,  GSYNC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:34  cernlib
* Geant

      SUBROUTINE GSYNC
C
C.    ******************************************************************
C.    *                                                                *
C.    *   Simulation of synchrotron radiation for e- and e+.           *
C.    *                                                                *
C.    *   ==> Called by : GTELEC                                       *
C.    *       Authors   : Igor Gavrilenko                              *
C.    *                                                                *
C.    ******************************************************************
C
+CDE, GCPHYS.
+CDE, GCTRAK.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCTMED.
+CDE, GCCUTS.
C...
      DIMENSION ETR(100),STR(100),VECTS(7),VECTN(7),FLD(3)
C...
      IF(ABS(CHARGE).NE.1..OR.STEP.LE.0.) GO TO 999
      GAMMA  = GETOT/AMASS
      IF(GAMMA.LE.1000.                 ) GO TO 999
      KCASE = NAMEC1(8)
      IF (IFIELD.EQ.3) THEN
          FLD(1) = 0.
          FLD(2) = 0.
          FLD(3) = FIELDM
      ELSE
          CALL GUFLD(VECT,FLD)
      END IF
      FLDS2  = FLD(1)**2+FLD(2)**2+FLD(3)**2
      IF(FLDS2.LE.1E-10) GO TO 999
      FLDT   = SQRT(FLDS2-
     +  (VECT(4)*FLD(1)+VECT(5)*FLD(2)+VECT(6)*FLD(3))**2)
C...
      CALL GSYNGE(GAMMA,AMASS,FLDT,STEP,NTR,ETR,STR)
      IF(NTR.EQ.0) GO TO 999
C...
      ELOSS          = 0.
C
C     When SYNC=1 the generation point of the photons is the current
C     particle point
C     When SYNC=3, the generation point of the photon is distributed
C     along the real trajectory of the particle (not along the step
C     taken) computed by GUSWIM.
      DO 10 N = 1,NTR
         IF (ISYNC.NE.2.AND.ETR(N).GT.CUTGAM) THEN
            NGKINE = NGKINE+1
            IF(NGKINE.GT.MXGKIN) GO TO 20
            IF (ISYNC.EQ.1) THEN
                GKIN(1,NGKINE) = ETR(N)*VECT(4)
                GKIN(2,NGKINE) = ETR(N)*VECT(5)
                GKIN(3,NGKINE) = ETR(N)*VECT(6)
                GKIN(4,NGKINE) = ETR(N)
                GKIN(5,NGKINE) = 1.
                GPOS(1,NGKINE) = VECT(1)
                GPOS(2,NGKINE) = VECT(2)
                GPOS(3,NGKINE) = VECT(3)
                TOFD (NGKINE) = 0.
            ELSE IF (ISYNC.EQ.3) THEN
                VECTS(1) = VECT(1)
                VECTS(2) = VECT(2)
                VECTS(3) = VECT(3)
                VECTS(4) = -VECT(4)
                VECTS(5) = -VECT(5)
                VECTS(6) = -VECT(6)
                VECTS(7) = VECT(7)
                CALL GUSWIM(1.,STR(N),VECTS,VECTN)
                GKIN(1,NGKINE) = -ETR(N)*VECTN(4)
                GKIN(2,NGKINE) = -ETR(N)*VECTN(5)
                GKIN(3,NGKINE) = -ETR(N)*VECTN(6)
                GKIN(4,NGKINE) = ETR(N)
                GKIN(5,NGKINE) = 1.
                GPOS(1,NGKINE) = VECTN(1)
                GPOS(2,NGKINE) = VECTN(2)
                GPOS(3,NGKINE) = VECTN(3)
                TOFD (NGKINE) = 0.
             END IF
         ELSE
             DESTEP = DESTEP +ETR(N)
         END IF
         ELOSS = ELOSS+ETR(N)
   10 CONTINUE
C
C..Update the energy of the primary particle
C
   20 GETOT = GETOT-ELOSS
      GEKIN = GEKIN-ELOSS
      VECT(7) = SQRT(GEKIN*(GEKIN+2.*AMASS))
      CALL GEKBIN
C...
 999  END
+DECK,  GSYNGE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:34  cernlib
* Geant

      SUBROUTINE GSYNGE (GAMMA,AM,HKGAUS,STEP,NTR,ETR,STR)
C
C.    ******************************************************************
C.    *                                                                *
C.    *  Generation of synchrotron radiation photons:                  *
C.    *     o sample the number of generated photons from              *
C.    *       Poisson distribution                                     *
C.    *     o sample the energy of each photon from the                *
C.    *       tables below (these numbers can be computed by           *
C.    *       the routine GSYNIT)                                      *
C.    *       YT(I)  = photon energy/ critical photon energy (e/ec)    *
C.    *       FTI(I) = int from YT(I) to inf (20) of dN**2/dxde        *
C.    *                where dN**2/dxde = int from e/ec to inf of      *
C.    *                                   K_5/3(x) dx                  *
C.    *                                                                *
C.    *   GAMMA      - Lorentz factor,                                 *
C.    *   H          - transverse component of the magnetic field      *
C.    *                to particle direction,                          *
C.    *   STEP       - current step in magnetic field,                 *
C.    *   NTR        - number of the synchrotron photons,              *
C.    *   ETR(k)     - photon energy,                                  *
C.    *   STR(k)     - photon coordinate.                              *
C.    *                                                                *
C.    *   ==> Called by : GSYNC                                        *
C.    *       Authors   : Igor Gavrilenko                              *
C.    *                                                                *
C.    ******************************************************************
C
C
+CDE, GCUNIT.
+SELF, IF=NEVER.
      COMMON /SYNTAB / YT(54),FT(53),FTI(53)
+SELF.
C...
      DIMENSION ETR(100),STR(100),RNDM(200)
+SELF, IF=-NEVER.
      DIMENSION YT(54),FTI(53)
+SELF.
C...
      DATA FTI/0.9827082157, 0.9756910801, 0.9708271027, 0.9669673443,
     +        0.9637124538, 0.9608694911, 0.9583284855, 0.9560201764,
     +        0.9538975954, 0.9519274235, 0.9368366003, 0.9263846874,
     +        0.9180962443, 0.9111109376, 0.9050130844, 0.8995658755,
     +        0.8946199417, 0.8900741935, 0.8858568072, 0.8536163568,
     +        0.8313701749, 0.8137849569, 0.7990072370, 0.7861415148,
     +        0.7746775150, 0.7642934322, 0.7547715902, 0.7459571362,
     +        0.6792119741, 0.6339961290, 0.5988188982, 0.5696868896,
     +        0.5446703434, 0.5226698518, 0.5029919147, 0.4851673245,
     +        0.4688622653, 0.3516088724, 0.2802021503, 0.2298262119,
     +        0.1918447465, 0.1620831937, 0.1381656080, 0.1185975820,
     +        0.1023733467,     0.8878208697E-01, 0.2343492396E-01,
     +        0.7047536317E-02, 0.2237016102E-02, 0.7283322047E-03,
     +        0.2375631739E-03, 0.7417966117E-04, 0.1891316060E-04/

      DATA YT/1E-5,2E-5,3E-5,4E-5,5E-5,6E-5,7E-5,8E-5,9E-5,
     +        1E-4,2E-4,3E-4,4E-4,5E-4,6E-4,7E-4,8E-4,9E-4,
     +        1E-3,2E-3,3E-3,4E-3,5E-3,6E-3,7E-3,8E-3,9E-3,
     +        1E-2,2E-2,3E-2,4E-2,5E-2,6E-2,7E-2,8E-2,9E-2,
     +        .1,.2,.3,.4,.5,.6,.7,.8,.9,1.,2.,3.,4.,5.,6.,7.,8.,9./
C...
      NTR         = 0
      H = 0.1*HKGAUS
      IF(H.LE.0.) GO TO 999
C...
      RAD         = 333.33*AM*GAMMA/H
C...
      EC          = 2.96E-8*GAMMA**3/RAD
C...
      AN          = .01053*GAMMA/RAD*STEP
      CALL GPOISS(AN,N,1)
      N=MIN(N,100)
      IF(N.LE.0) GO TO 999
C...
      CALL GRNDM(RNDM,N*2)
      DO 40 I = 1,N
         K1 = 1
         K2 = 53
         R = RNDM(2*I-1)*(FTI(1)-FTI(53))+FTI(53)
C...
   10    K = (K1+K2)/2
         IF(R.NE.FTI(K)) GO TO 20
         E = YT(K)*EC
         GO TO 30
C...
   20    IF(R.GT.FTI(K)) THEN
            K2 = K
         ELSEIF(R.LT.FTI(K)) THEN
            K1 = K
         ENDIF
         IF(K2-K1.GT.1) GO TO 10
C...
         IF(YT(K2).LE.1.) THEN
            Y2 = LOG(YT(K2))
            Y1 = LOG(YT(K1))
            E = Y2+(R-FTI(K2))*(Y1-Y2)/(FTI(K1)-FTI(K2))
            E = EXP(E)*EC
         ELSE
            F2 = LOG(FTI(K2))
            F1 = LOG(FTI(K1))
            DR = LOG(R)
            E = YT(K2)+(DR-F2)*(YT(K1)-YT(K2))/(F1-F2)
            E = E*EC
         END IF
C...
   30    CONTINUE
C
         IF(E/EC.GT.20.) THEN
            WRITE(CHMAIL,'('' *** GSYNGE: Photons have e>20*ec, e= '',
     +      G10.4,'' keV, ec= '',G10.4,'' keV'')') E,EC
            CALL GMAIL(1,0)
            GO TO 40
         ENDIF
C...
         NTR = NTR+1
         ETR(NTR) = E*1.E-6
         STR(NTR) = STEP*RNDM(2*I)
   40 CONTINUE
C...
 999  END
+DECK,  GSYNIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:35  cernlib
* Geant

+SELF, IF=NEVER.
      SUBROUTINE GSYNIT
C
C  Preperation of synchrotron radiation tables.
C  This routine can be used to compute the YT and FTI used
C  in GSYNGE.
C  Author: Igor Gavrilenko
C
      COMMON /SYNTAB/ YT(54),FT(54),FTI(53)
      EXTERNAL BK53,BKS53
      DOUBLE PRECISION YM,YMA,EPS,XX
C...
      DATA EPS/.0001/
C...
      L = 0
      YS = .000001
      DO 20 I = 1,6
         YS = YS*10.
         DO 10 J = 1,9,1
            L = L+1
            YM = J*YS
            YT(L) = YM
            YMA = YM+YS
            IF(L.EQ.54) YMA = 20.
            FT(L) = DGAUSS(BK53,YM,YMA,EPS)
   10    CONTINUE
   20 CONTINUE
C...
      DO 30 I = 53,1,-1
         FT(I) = FT(I)+FT(I+1)
   30 CONTINUE
C...
      DO 40 I = 53,1,-1
         YM = YT(I)
         YMA = YT(I+1)
         IF(I.LT.53) FTI(I) = DGAUSS(BKS53,YM,YMA,EPS)+FTI(I+1)
         IF(I.EQ.53) FTI(I) = DGAUSS(BKS53,YM,YMA,EPS)
   40 CONTINUE
C...
      E N D
C-------------------------------------------------------
      DOUBLE PRECISION FUNCTION B K 5 3 (X)
C
      DOUBLE PRECISION X
C...
      BK53 = 4./(3.*X)*DBSKR3(X,2)+DBSKR3(X,1)
      RETURN
      E N D
C------------------------------------------------------
      DOUBLE PRECISION FUNCTION B K S 5 3 (X)
C
      COMMON /SYNTAB/ YT(54),FT(54),FTI(53)
      DOUBLE PRECISION X
C...
      IF(X.GT.YT(1)) GO TO 10
      BKS53 = FT(1)
      GO TO 60
C...
   10 IF(X.LT.YT(54)) GO TO 20
      BKS53 = 0.
      RETURN
C...
   20 K1 = 1
      K2 = 54
   30 K = (K1+K2)/2
      IF(X.GT.YT(K)) K1 = K
      IF(X.LT.YT(K)) K2 = K
      IF(X.NE.YT(K)) GO TO 40
      BKS53 = FT(K)
      GO TO 60
C...
   40 IF(K2-K1.GT.1) GO TO 30
      F1 = FT(K1)
      F2 = FT(K2)
      X1 = YT(K1)
      X2 = YT(K2)
C...
      IF(X.LE.1.) THEN
         X1 = LOG(X1)
         X2 = LOG(X2)
         B = F1+(F2-F1)/(X2-X1)*(LOG(X)-X1)
         GO TO 50
      ENDIF
C...
      IF(X.GT.1.) THEN
         F1 = LOG(F1)
         F2 = LOG(F2)
         B = F1+(F2-F1)/(X2-X1)*(X-X1)
         B = EXP(B)
      ENDIF
C...
   50 BKS53 = B
   60 BKS53 = .1909859*BKS53
      RETURN
      E N D
+SELF.
+DECK,  GVAVIV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:35  cernlib
* Geant

      FUNCTION GVAVIV(RKAPPA,BETA2,RAN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *  GVAVIV                                                        *
C.    *  ------                                                        *
C.    *                                                                *
C.    *  Initializes the parameters for a Vavilov distribution         *
C.    *                                                                *
C.    *  BETA2 is the particle velocity squared                        *
C.    *  RKAPPA the usual straggling parameter                         *
C.    *                                                                *
C.    *  This routine has been extracted from a proposed CERNLIB       *
C.    *  set of routines (VAVCOE,VAVFSM).                              *
C.    *  The authors of these routines have submitted an article       *
C.    *  to NIM:                                                       *
C.    *                                                                *
C.    *    Alberto Rotondi, Paolo Montagna                             *
C.    *    Fast calculation of Vavilov distribution NIMB 1990          *
C.    *                                                                *
C.    *       Author    K.S.Koelbig     ********                       *
C.    *                                                                *
C.    *   ==> Called by : GLANDO                                       *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION AC(0:12),HC(0:8),H(9)

      PARAMETER
     1(BKMNX1 = 0.02, BKMNY1 = 0.05, BKMNX2 = 0.12, BKMNY2 = 0.05,
     2 BKMNX3 = 0.22, BKMNY3 = 0.05, BKMXX1 = 0.1 , BKMXY1 = 1   ,
     3 BKMXX2 = 0.2 , BKMXY2 = 1   , BKMXX3 = 0.3 , BKMXY3 = 1   )
      PARAMETER
     1(FBKX1 = 2/(BKMXX1-BKMNX1), FBKX2 = 2/(BKMXX2-BKMNX2),
     2 FBKX3 = 2/(BKMXX3-BKMNX3), FBKY1 = 2/(BKMXY1-BKMNY1),
     3 FBKY2 = 2/(BKMXY2-BKMNY2), FBKY3 = 2/(BKMXY3-BKMNY3))

      DIMENSION EDGEC(2:7),FNINV(5),DRK(5),DSIGM(5),ALFA(2:5)
      DIMENSION U1(13),U2(13),U3(13),U4(12),U5(13),U6(13),U7( 8),U8(13)
      DIMENSION V1(12),V2(12),V3(13),V4(12),V5(13),V6(13),V7(11),V8(11)
      DIMENSION W1(13),W2(11),W3(13),W4(13),W5(13),W6(13),       W8( 8)

      DATA FNINV /1, 0.5, 0.33333333, 0.25, 0.2/

      DATA (EDGEC(J),J=2,7)
     1/ 0.16666667E+0, 0.41666667E-1, 0.83333333E-2,
     2  0.13888889E-1, 0.69444444E-2, 0.77160493E-3/

      DATA (U1(K),K=1,13)
     1/ 0.25850868E+0,  0.32477982E-1, -0.59020496E-2,
     2  0.            , 0.24880692E-1,  0.47404356E-2,
     3 -0.74445130E-3,  0.73225731E-2,  0.           ,
     4  0.11668284E-2,  0.           , -0.15727318E-2,-0.11210142E-2/

      DATA (U2(K),K=1,13)
     1/ 0.43142611E+0,  0.40797543E-1, -0.91490215E-2,
     2  0.           ,  0.42127077E-1,  0.73167928E-2,
     3 -0.14026047E-2,  0.16195241E-1,  0.24714789E-2,
     4  0.20751278E-2,  0.           , -0.25141668E-2,-0.14064022E-2/

      DATA (U3(K),K=1,13)
     1/ 0.25225955E+0,  0.64820468E-1, -0.23615759E-1,
     2  0.           ,  0.23834176E-1,  0.21624675E-2,
     3 -0.26865597E-2, -0.54891384E-2,  0.39800522E-2,
     4  0.48447456E-2, -0.89439554E-2, -0.62756944E-2,-0.24655436E-2/

      DATA (U4(K),K=1,12)
     1/ 0.12593231E+1, -0.20374501E+0,  0.95055662E-1,
     2 -0.20771531E-1, -0.46865180E-1, -0.77222986E-2,
     3  0.32241039E-2,  0.89882920E-2, -0.67167236E-2,
     4 -0.13049241E-1,  0.18786468E-1,  0.14484097E-1/

      DATA (U5(K),K=1,13)
     1/-0.24864376E-1, -0.10368495E-2,  0.14330117E-2,
     2  0.20052730E-3,  0.18751903E-2,  0.12668869E-2,
     3  0.48736023E-3,  0.34850854E-2,  0.           ,
     4 -0.36597173E-3,  0.19372124E-2,  0.70761825E-3, 0.46898375E-3/

      DATA (U6(K),K=1,13)
     1/ 0.35855696E-1, -0.27542114E-1,  0.12631023E-1,
     2 -0.30188807E-2, -0.84479939E-3,  0.           ,
     3  0.45675843E-3, -0.69836141E-2,  0.39876546E-2,
     4 -0.36055679E-2,  0.           ,  0.15298434E-2, 0.19247256E-2/

      DATA (U7(K),K=1,8)
     1/ 0.10234691E+2, -0.35619655E+1,  0.69387764E+0,
     2 -0.14047599E+0, -0.19952390E+1, -0.45679694E+0,
     3  0.           ,  0.50505298E+0/

      DATA (U8(K),K=1,13)
     1/ 0.21487518E+2, -0.11825253E+2,  0.43133087E+1,
     2 -0.14500543E+1, -0.34343169E+1, -0.11063164E+1,
     3 -0.21000819E+0,  0.17891643E+1, -0.89601916E+0,
     4  0.39120793E+0,  0.73410606E+0,  0.           ,-0.32454506E+0/

      DATA (V1(K),K=1,12)
     1/ 0.27827257E+0, -0.14227603E-2,  0.24848327E-2,
     2  0.           ,  0.45091424E-1,  0.80559636E-2,
     3 -0.38974523E-2,  0.           , -0.30634124E-2,
     4  0.75633702E-3,  0.54730726E-2,  0.19792507E-2/

      DATA (V2(K),K=1,12)
     1/ 0.41421789E+0, -0.30061649E-1,  0.52249697E-2,
     2  0.           ,  0.12693873E+0,  0.22999801E-1,
     3 -0.86792801E-2,  0.31875584E-1, -0.61757928E-2,
     4  0.           ,  0.19716857E-1,  0.32596742E-2/

      DATA (V3(K),K=1,13)
     1/ 0.20191056E+0, -0.46831422E-1,  0.96777473E-2,
     2 -0.17995317E-2,  0.53921588E-1,  0.35068740E-2,
     3 -0.12621494E-1, -0.54996531E-2, -0.90029985E-2,
     4  0.34958743E-2,  0.18513506E-1,  0.68332334E-2,-0.12940502E-2/

      DATA (V4(K),K=1,12)
     1/ 0.13206081E+1,  0.10036618E+0, -0.22015201E-1,
     2  0.61667091E-2, -0.14986093E+0, -0.12720568E-1,
     3  0.24972042E-1, -0.97751962E-2,  0.26087455E-1,
     4 -0.11399062E-1, -0.48282515E-1, -0.98552378E-2/

      DATA (V5(K),K=1,13)
     1/ 0.16435243E-1,  0.36051400E-1,  0.23036520E-2,
     2 -0.61666343E-3, -0.10775802E-1,  0.51476061E-2,
     3  0.56856517E-2, -0.13438433E-1,  0.           ,
     4  0.           , -0.25421507E-2,  0.20169108E-2,-0.15144931E-2/

      DATA (V6(K),K=1,13)
     1/ 0.33432405E-1,  0.60583916E-2, -0.23381379E-2,
     2  0.83846081E-3, -0.13346861E-1, -0.17402116E-2,
     3  0.21052496E-2,  0.15528195E-2,  0.21900670E-2,
     4 -0.13202847E-2, -0.45124157E-2, -0.15629454E-2, 0.22499176E-3/

      DATA (V7(K),K=1,11)
     1/ 0.54529572E+1, -0.90906096E+0,  0.86122438E-1,
     2  0.           , -0.12218009E+1, -0.32324120E+0,
     3 -0.27373591E-1,  0.12173464E+0,  0.           ,
     4  0.           ,  0.40917471E-1/

      DATA (V8(K),K=1,11)
     1/ 0.93841352E+1, -0.16276904E+1,  0.16571423E+0,
     2  0.           , -0.18160479E+1, -0.50919193E+0,
     3 -0.51384654E-1,  0.21413992E+0,  0.           ,
     4  0.           ,  0.66596366E-1/

      DATA (W1(K),K=1,13)
     1/ 0.29712951E+0,  0.97572934E-2,  0.           ,
     2 -0.15291686E-2,  0.35707399E-1,  0.96221631E-2,
     3 -0.18402821E-2, -0.49821585E-2,  0.18831112E-2,
     4  0.43541673E-2,  0.20301312E-2, -0.18723311E-2,-0.73403108E-3/

      DATA (W2(K),K=1,11)
     1/ 0.40882635E+0,  0.14474912E-1,  0.25023704E-2,
     2 -0.37707379E-2,  0.18719727E+0,  0.56954987E-1,
     3  0.           ,  0.23020158E-1,  0.50574313E-2,
     4  0.94550140E-2,  0.19300232E-1/

      DATA (W3(K),K=1,13)
     1/ 0.16861629E+0,  0.           ,  0.36317285E-2,
     2 -0.43657818E-2,  0.30144338E-1,  0.13891826E-1,
     3 -0.58030495E-2, -0.38717547E-2,  0.85359607E-2,
     4  0.14507659E-1,  0.82387775E-2, -0.10116105E-1,-0.55135670E-2/

      DATA (W4(K),K=1,13)
     1/ 0.13493891E+1, -0.26863185E-2, -0.35216040E-2,
     2  0.24434909E-1, -0.83447911E-1, -0.48061360E-1,
     3  0.76473951E-2,  0.24494430E-1, -0.16209200E-1,
     4 -0.37768479E-1, -0.47890063E-1,  0.17778596E-1, 0.13179324E-1/

      DATA (W5(K),K=1,13)
     1/ 0.10264945E+0,  0.32738857E-1,  0.           ,
     2  0.43608779E-2, -0.43097757E-1, -0.22647176E-2,
     3  0.94531290E-2, -0.12442571E-1, -0.32283517E-2,
     4 -0.75640352E-2, -0.88293329E-2,  0.52537299E-2, 0.13340546E-2/

      DATA (W6(K),K=1,13)
     1/ 0.29568177E-1, -0.16300060E-2, -0.21119745E-3,
     2  0.23599053E-2, -0.48515387E-2, -0.40797531E-2,
     3  0.40403265E-3,  0.18200105E-2, -0.14346306E-2,
     4 -0.39165276E-2, -0.37432073E-2,  0.19950380E-2, 0.12222675E-2/

      DATA (W8(K),K=1,8)
     1/ 0.66184645E+1, -0.73866379E+0,  0.44693973E-1,
     2  0.           , -0.14540925E+1, -0.39529833E+0,
     3 -0.44293243E-1,  0.88741049E-1/

      GVAVIV=0
      IF(RKAPPA .LT. 0.01 .OR. RKAPPA .GT. 12) RETURN
      IF(RKAPPA .GE. 0.29) THEN
       ITYPE=1
       NPT=100
       WK=1/SQRT(RKAPPA)
       AC(0)=(-0.032227*BETA2-0.074275)*RKAPPA+
     1   (0.24533*BETA2+0.070152)*WK+(-0.55610*BETA2-3.1579)
       AC(8)=(-0.013483*BETA2-0.048801)*RKAPPA+
     1   (-1.6921*BETA2+8.3656)*WK+(-0.73275*BETA2-3.5226)
       DRK(1)=WK**2
       DSIGM(1)=SQRT(RKAPPA/(1-0.5*BETA2))
       DO 1 J = 1,4
       DRK(J+1)=DRK(1)*DRK(J)
       DSIGM(J+1)=DSIGM(1)*DSIGM(J)
    1  ALFA(J+1)=(FNINV(J)-BETA2*FNINV(J+1))*DRK(J)

       HC(0)=LOG(RKAPPA)+BETA2+0.42278434
       HC(1)=DSIGM(1)
       HC(2)=ALFA(3)*DSIGM(3)
       HC(3)=(3*ALFA(2)**2+ALFA(4))*DSIGM(4)-3
       HC(4)=(10*ALFA(2)*ALFA(3)+ALFA(5))*DSIGM(5)-10*HC(2)
       HC(5)=HC(2)**2
       HC(6)=HC(2)*HC(3)
       HC(7)=HC(2)*HC(5)
       DO 2 J = 2,7
    2  HC(J)=EDGEC(J)*HC(J)
       HC(8)=0.39894228*HC(1)
      ELSEIF(RKAPPA .GE. 0.22) THEN
       ITYPE=2
       NPT=150
       X=1+(RKAPPA-BKMXX3)*FBKX3
       Y=1+(SQRT(BETA2)-BKMXY3)*FBKY3
       XX=2*X
       YY=2*Y
       X2=XX*X-1
       X3=XX*X2-X
       Y2=YY*Y-1
       Y3=YY*Y2-Y
       XY=X*Y
       P2=X2*Y
       P3=X3*Y
       Q2=Y2*X
       Q3=Y3*X
       PQ=X2*Y2
       AC(1)=W1(1)+W1(2)*X+W1(4)*X3+W1(5)*Y+W1(6)*Y2+W1(7)*Y3+
     1  W1(8)*XY+W1(9)*P2+W1(10)*P3+W1(11)*Q2+W1(12)*Q3+W1(13)*PQ
       AC(2)=W2(1)+W2(2)*X+W2(3)*X2+W2(4)*X3+W2(5)*Y+W2(6)*Y2+
     1  W2(8)*XY+W2(9)*P2+W2(10)*P3+W2(11)*Q2
       AC(3)=W3(1)+W3(3)*X2+W3(4)*X3+W3(5)*Y+W3(6)*Y2+W3(7)*Y3+
     1  W3(8)*XY+W3(9)*P2+W3(10)*P3+W3(11)*Q2+W3(12)*Q3+W3(13)*PQ
       AC(4)=W4(1)+W4(2)*X+W4(3)*X2+W4(4)*X3+W4(5)*Y+W4(6)*Y2+W4(7)*Y3+
     1  W4(8)*XY+W4(9)*P2+W4(10)*P3+W4(11)*Q2+W4(12)*Q3+W4(13)*PQ
       AC(5)=W5(1)+W5(2)*X+W5(4)*X3+W5(5)*Y+W5(6)*Y2+W5(7)*Y3+
     1  W5(8)*XY+W5(9)*P2+W5(10)*P3+W5(11)*Q2+W5(12)*Q3+W5(13)*PQ
       AC(6)=W6(1)+W6(2)*X+W6(3)*X2+W6(4)*X3+W6(5)*Y+W6(6)*Y2+W6(7)*Y3+
     1  W6(8)*XY+W6(9)*P2+W6(10)*P3+W6(11)*Q2+W6(12)*Q3+W6(13)*PQ
       AC(8)=W8(1)+W8(2)*X+W8(3)*X2+W8(5)*Y+W8(6)*Y2+W8(7)*Y3+W8(8)*XY
       AC(0)=-3.05
      ELSEIF(RKAPPA .GE. 0.12) THEN
       ITYPE=3
       NPT=200
       X=1+(RKAPPA-BKMXX2)*FBKX2
       Y=1+(SQRT(BETA2)-BKMXY2)*FBKY2
       XX=2*X
       YY=2*Y
       X2=XX*X-1
       X3=XX*X2-X
       Y2=YY*Y-1
       Y3=YY*Y2-Y
       XY=X*Y
       P2=X2*Y
       P3=X3*Y
       Q2=Y2*X
       Q3=Y3*X
       PQ=X2*Y2
       AC(1)=V1(1)+V1(2)*X+V1(3)*X2+V1(5)*Y+V1(6)*Y2+V1(7)*Y3+
     1  V1(9)*P2+V1(10)*P3+V1(11)*Q2+V1(12)*Q3
       AC(2)=V2(1)+V2(2)*X+V2(3)*X2+V2(5)*Y+V2(6)*Y2+V2(7)*Y3+
     1  V2(8)*XY+V2(9)*P2+V2(11)*Q2+V2(12)*Q3
       AC(3)=V3(1)+V3(2)*X+V3(3)*X2+V3(4)*X3+V3(5)*Y+V3(6)*Y2+V3(7)*Y3+
     1  V3(8)*XY+V3(9)*P2+V3(10)*P3+V3(11)*Q2+V3(12)*Q3+V3(13)*PQ
       AC(4)=V4(1)+V4(2)*X+V4(3)*X2+V4(4)*X3+V4(5)*Y+V4(6)*Y2+V4(7)*Y3+
     1  V4(8)*XY+V4(9)*P2+V4(10)*P3+V4(11)*Q2+V4(12)*Q3
       AC(5)=V5(1)+V5(2)*X+V5(3)*X2+V5(4)*X3+V5(5)*Y+V5(6)*Y2+V5(7)*Y3+
     1  V5(8)*XY+V5(11)*Q2+V5(12)*Q3+V5(13)*PQ
       AC(6)=V6(1)+V6(2)*X+V6(3)*X2+V6(4)*X3+V6(5)*Y+V6(6)*Y2+V6(7)*Y3+
     1  V6(8)*XY+V6(9)*P2+V6(10)*P3+V6(11)*Q2+V6(12)*Q3+V6(13)*PQ
       AC(7)=V7(1)+V7(2)*X+V7(3)*X2+V7(5)*Y+V7(6)*Y2+V7(7)*Y3+
     1  V7(8)*XY+V7(11)*Q2
       AC(8)=V8(1)+V8(2)*X+V8(3)*X2+V8(5)*Y+V8(6)*Y2+V8(7)*Y3+
     1  V8(8)*XY+V8(11)*Q2
       AC(0)=-3.04
      ELSE
       ITYPE=4
       IF(RKAPPA .GE. 0.02) ITYPE=3
       NPT=200
       X=1+(RKAPPA-BKMXX1)*FBKX1
       Y=1+(SQRT(BETA2)-BKMXY1)*FBKY1
       XX=2*X
       YY=2*Y
       X2=XX*X-1
       X3=XX*X2-X
       Y2=YY*Y-1
       Y3=YY*Y2-Y
       XY=X*Y
       P2=X2*Y
       P3=X3*Y
       Q2=Y2*X
       Q3=Y3*X
       PQ=X2*Y2
       IF(ITYPE .EQ. 4) GO TO 4
       AC(1)=U1(1)+U1(2)*X+U1(3)*X2+U1(5)*Y+U1(6)*Y2+U1(7)*Y3+
     1  U1(8)*XY+U1(10)*P3+U1(12)*Q3+U1(13)*PQ
       AC(2)=U2(1)+U2(2)*X+U2(3)*X2+U2(5)*Y+U2(6)*Y2+U2(7)*Y3+
     1  U2(8)*XY+U2(9)*P2+U2(10)*P3+U2(12)*Q3+U2(13)*PQ
       AC(3)=U3(1)+U3(2)*X+U3(3)*X2+U3(5)*Y+U3(6)*Y2+U3(7)*Y3+
     1  U3(8)*XY+U3(9)*P2+U3(10)*P3+U3(11)*Q2+U3(12)*Q3+U3(13)*PQ
       AC(4)=U4(1)+U4(2)*X+U4(3)*X2+U4(4)*X3+U4(5)*Y+U4(6)*Y2+U4(7)*Y3+
     1  U4(8)*XY+U4(9)*P2+U4(10)*P3+U4(11)*Q2+U4(12)*Q3
       AC(5)=U5(1)+U5(2)*X+U5(3)*X2+U5(4)*X3+U5(5)*Y+U5(6)*Y2+U5(7)*Y3+
     1  U5(8)*XY+U5(10)*P3+U5(11)*Q2+U5(12)*Q3+U5(13)*PQ
       AC(6)=U6(1)+U6(2)*X+U6(3)*X2+U6(4)*X3+U6(5)*Y+U6(7)*Y3+
     1  U6(8)*XY+U6(9)*P2+U6(10)*P3+U6(12)*Q3+U6(13)*PQ
    4  AC(7)=U7(1)+U7(2)*X+U7(3)*X2+U7(4)*X3+U7(5)*Y+U7(6)*Y2+U7(8)*XY
       AC(8)=U8(1)+U8(2)*X+U8(3)*X2+U8(4)*X3+U8(5)*Y+U8(6)*Y2+U8(7)*Y3+
     1  U8(8)*XY+U8(9)*P2+U8(10)*P3+U8(11)*Q2+U8(13)*PQ
       AC(0)=-3.03
      ENDIF
      AC(9)=(AC(8)-AC(0))/NPT
      IF(ITYPE .EQ. 3) THEN
       X=(AC(7)-AC(8))/(AC(7)*AC(8))
       Y=1/LOG(AC(8)/AC(7))
       P2=AC(7)**2
       AC(11)=P2*(AC(1)*EXP(-AC(2)*(AC(7)+AC(5)*P2)-
     1            AC(3)*EXP(-AC(4)*(AC(7)+AC(6)*P2)))-0.045*Y/AC(7))/
     2            (1+X*Y*AC(7))
       AC(12)=(0.045+X*AC(11))*Y
      ENDIF
      IF(ITYPE .EQ. 4) AC(10)=0.995/GLANDS(AC(8))

      T=2*RAN/AC(9)
      RLAM=AC(0)
      FL=0
      S=0
      DO 21 N = 1,NPT
      RLAM=RLAM+AC(9)
      IF(ITYPE .EQ. 1) THEN
       FN=1
       X=(RLAM+HC(0))*HC(1)
       H(1)=X
       H(2)=X**2-1
       DO 31 K = 2,8
       FN=FN+1
   31  H(K+1)=X*H(K)-FN*H(K-1)
       Y=1+HC(7)*H(9)
       DO 32 K = 2,6
   32  Y=Y+HC(K)*H(K+1)
       FU=HC(8)*EXP(-0.5*X**2)*MAX(Y,0.)
      ELSEIF(ITYPE .EQ. 2) THEN
       X=RLAM**2
       FU=AC(1)*EXP(-AC(2)*(RLAM+AC(5)*X)-
     1    AC(3)*EXP(-AC(4)*(RLAM+AC(6)*X)))
      ELSEIF(ITYPE .EQ. 3) THEN
       IF(RLAM .LT. AC(7)) THEN
        X=RLAM**2
        FU=AC(1)*EXP(-AC(2)*(RLAM+AC(5)*X)-
     1     AC(3)*EXP(-AC(4)*(RLAM+AC(6)*X)))
       ELSE
        X=1/RLAM
        FU=(AC(11)*X+AC(12))*X
       ENDIF
      ELSE
       FU=AC(10)*GLANDE(RLAM)
      ENDIF
      S=S+FL+FU
      IF(S .GT. T) GO TO 22
   21 FL=FU

   22 S0=S-FL-FU
      GVAVIV=RLAM-AC(9)
      IF(S .GT. S0) GVAVIV=GVAVIV+AC(9)*(T-S0)/(S-S0)
      RETURN
      END
+DECK,  GVROT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:35  cernlib
* Geant

      SUBROUTINE GVROT(DCOSIN,PART)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Rotates vector from one reference system into another         *
C.    *  defined by the direction cosines contained in the vector      *
C.    *  DCOSIN. The input vector PART is overwritten.                 *
C.    *                                                                *
C.    *    ==>Called by :                                              *
C.    *       Author    F.Carminati **********                         *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION PART(*),DCOSIN(*)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION DUX,DUY,DUZ,SINTH2,ONE,COSTH,SINTH,COSPH,SINPH
      DOUBLE PRECISION DNORM
+SELF.
      LOGICAL ROTATE
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      DUX      = DCOSIN(1)
      DUY      = DCOSIN(2)
      DUZ      = DCOSIN(3)
      ROTATE   = .TRUE.
      IF(ABS(DUZ).GE.0.85) THEN
         SINTH2=DUX**2+DUY**2
         IF(SINTH2.GT.0.) THEN
            COSTH  = SIGN(ONE,DUZ)*SQRT(ONE-SINTH2)
            SINTH  = SQRT(SINTH2)
            COSPH  = DUX/SINTH
            SINPH  = DUY/SINTH
         ELSEIF(DUZ.GT.0.)THEN
            ROTATE = .FALSE.
         ELSE
            COSTH = -1.
            SINTH =  0.
            COSPH =  1.
            SINPH =  0.
         ENDIF
      ELSE
         COSTH  = DUZ
         SINTH  = SQRT((ONE+DUZ)*(ONE-DUZ))
         DNORM  = ONE/SQRT(DUX**2+DUY**2)
         COSPH  = DUX*DNORM
         SINPH  = DUY*DNORM
      ENDIF
*
      IF(ROTATE) THEN
         P1=PART(1)
         P2=PART(2)
         P3=PART(3)
         PART(1)= P1*COSTH*COSPH - P2*SINPH + P3*SINTH*COSPH
         PART(2)= P1*COSTH*SINPH + P2*COSPH + P3*SINTH*SINPH
         PART(3)=-P1*SINTH                  + P3*COSTH
      ENDIF
C
      END
+PATCH, GPARAL.
+DECK,  CHECKSTR, T=FORT.
*CMZ :          26/02/96  11.38.47  by  S.Ravndal
*-- Author :
+SELF, IF=PARA.
      subroutine checkstr( chREADIN, chExpected, nch, chDescription,
     $ierr )
      implicit none
      character chREADIN*(*), chExpected*(*), chDescription*(*)
      integer   ierr, nch

+CDE, GCUNIT.
      integer   lunerr
      lunerr= lout

*    Example:
*     call checkstr( chSUBSEQ, 'SUBSEQ ', !!                          ! '(a7)'
*    $     ,'Number  of  subsequences ', ichkerr(1) )

      if ( chReadin(1:nch) .ne. chExpected(1:nch) ) then
         write( lunerr, * )
     $        ' Checkstr: Values of string read-in and expected differ '
         write( lunerr, * ) '   Expected>', chExpected , '<'
         write( lunerr, * ) '   Read-in >', chReadin   , '<'
         ierr = 1
      else
         ierr = 0
      endif
      return
      end
+SELF.
+DECK,  GPABORT, T=FORT.
*CMZ :          23/08/95  15.00.00  by  John Apostolakis
*-- Author :    John Apostolakis  CERN/GP-MIMD2   22/07/94
      subroutine gpabort
+SELF, IF=PARA.
c
c      This makes a "best attempt" to abort all parallel Geant tasks.
c      It should be used if a fatal error is detected in a task that
c      cannot be recovered, or will cause irreperable damage later.
c
      implicit none
      integer  ierror
+CDE, MPIFINC.
+CDE, MULTIPROX.
+CDE, GCUNIT.
      write(chmail,*)
     $' gpabort: calling MPI_abort to terminate program from  node ',
     $ nprank
      call gmail(2,2)

      call MPI_abort( MPI_COMM_WORLD, ierror )
      if (ierror .ne. 0)  then
	 write(chmail,*)
     $     ' ERROR in gpabort: MPI_abort failed to terminate on node ',
     $     nprank, ' error code: ', ierror, ' STOPPING this node.'
         call gmail(2,2)
         stop
      endif
+SELF.
      return
      end

+DECK,  GPDEFRNG, T=FORT.
*CMZ :          26/02/96  11.38.47  by  S.Ravndal
*-- Author :
C------------------------------------------------------------------------
c     gpdefrng( ibase )
c
c     Modified: November 6, 1995  J.A. to provide more flexibility by
c                                       including argument
c
c     Function: Provide seeds for the pseudo-random number
c                 generator different on each node
c               If ibase <= 0 default sequences are used.
c
c     Should be called to provide a default seeding.
c     Only currently available for RANECU/GRNDM.
c
c     ibase=  the RNG sequence for first node.
c             If ibase=0 a system default is used.
c
C     called by:  <USER>, uginit, (if CERNLIB_PARA switch is used)
C------------------------------------------------------------------------
+SELF, IF=PARA.
      subroutine gpdefrng( ibase )
      implicit none
      integer ibase

C--------------------------------------------------------------
C     Must be called in uginit only after other routines that do the
C   default RNG seeding for sequential machines
C   have been called (ie after ginit) ... see example uginit
C--------------------------------------------------------------
+CDE, MPIFINC.
+CDE, MULTIPROX.
+CDE, MULTSEEDS.
+CDE, GCFLAG.
+CDE, GCUNIT.
      integer ibasedef, lunerr
      data    ibasedef / 1 /
      integer msgerror, rngerror
      data    msgerror, rngerror / 0, 0 /
c----------------------------------------------------------------------------
c     Random number generator seeding:
c
c     Set the seeds on each node for the start of a different sequence.
c----------------------------------------------------------------------------
c     Done for RANECU
c----------------------------------------------------------------------------

      if ( ibase .lt. 0 ) then
          ibase = 0
          write( chmail, '(a,a,i4,a)' )
     $         ' Warning: gpdefrng: ibase < 0 is invalid. Value =',
     $         ibase , ' Reset to zero '
          call gmail(1,1)
      endif
      if ( ibase .eq. 0 ) then
          ibase = ibasedef
      endif

C     We check to see if the resulting sequence is valid for RANECU

      iseqnc = ibase + nprank
      if( (iseqnc .gt.0 ) .and. (iseqnc .le. 215 )) then
          call GRNDMQ( iseeda, iseedb, iseqnc, 'Q' )
          write (*,*)  ' Node ', nprank, ' init-ed seq ', iseqnc,
     &              ' and got seeds ', iseeda, iseedb
          call GRNDMQ( iseeda, iseedb, iseqnc, 'S' )
      else
          write (lunerr, *) ' Node ', nprank, ': in GRNDMQ exceeds ',
     &        ' number of rng sequences with precalculated seeds.'
	  rngerror = 1

c         --- Other Possibility: ---
c         write (lunerr, *) ' Node ', nprank, ':    wrapping around ... '
c         iseqnc = mod( iseqnc, 215 ) + 1
c         call GRNDMQ( iseeda, iseedb, iseqnc, 'Q' )
      endif
+SELF, IF=PARA, IF=PARA_RANMAR.
c----------------------------------------------------------------------------
c     In the case that RANMAR is used
c
c----------------------------------------------------------------------------
      ibase  = nrndm(1)
      iseeda = ibase * 100 + nprank
      iseqnc = 1
c
c     As changed by Stic/Delphi only the first parameter is used.
c
      call GRNDMQ( iseeda, iseedb, iseqnc, 'S' )
c
+SELF, IF=PARA.
      return
      end
+SELF.

+DECK,  GPDYNAMIC, T=FORT.
*CMZ :          11/11/94  14.40.52  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   13/07/94
C------------------------------------------------------------------------
C     gpdynamic
C           Function: informs parallel Geant that events will be
C                     dynamically distributed between nodes, ie
C                     each "worker" node will request (the data of) an event
C                     from a "master" or "leader".
C
C     called by:  <USER>, (if CERNLIB_PARA switch is used)
C------------------------------------------------------------------------
+SELF, IF=PARA.
      subroutine gpdynamic
      implicit none
+CDE, MULTIPROX.

c
c     This routine overrides the default (set in gpinit)
c       of a static decomposition of events , with which
c       each processor would get 1/(number of processors) of the share
c       of events.
c     It should be used if an input file exists or the time per event
c       has a large standard deviation, the events can be dynamically assigned.
c       You will need to look at the routines gukine and muxread
c       in gexam3 for how to distribute events.

c
c     The following initialises the "dynamic" configuration,
c       in which there is no "master" or "leader".
c
c         -- Id of task expected to be a "master"
      npleader = 0
c         -- Id of task expected to be 1st worker
c       		          (representative for printout ...)
      nfirstworker= 1

      return
      end
+SELF.
+DECK,  GPINIT, T=FORT.
*CMZ :          11/11/94  14.40.52  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   13/07/94
C------------------------------------------------------------------------
C     gpinit
C           Function: initialises the parallel environment (MPI) and
C           parallel's Geant's variables that track it.
C
C     called by:  <USER>, uginit, (if CERNLIB_PARA switch is used)
C------------------------------------------------------------------------
+SELF, IF=PARA.
      subroutine gpinit
      implicit none
+CDE, MPIFINC.
+CDE, MULTIPROX.
+CDE, MULTSEEDS.
+CDE, GCFLAG.
      integer             msgerrpas, ierr
      common  /gpinitpas/ msgerrpas, ierr

      integer ierr1, ierr2, ierr3
      integer ibase, lunerr
      integer msgerror, rngerror
      data    ibase / 1 /
      data    msgerror, rngerror / 0, 0 /
      parameter (lunerr= 0)

c     Initialise Event Level Parallel Geant (message passing)
c
c     Tasks:
c       Initialise Message Passing and my relevant variables (npsize etc)

      nprank= -1

c     Initialise Message Passing

      call MPI_init( ierr1 )
      call MPI_Comm_rank( MPI_COMM_WORLD, nprank, ierr2 )
      call MPI_Comm_size( MPI_COMM_WORLD, npsize, ierr3 )
      if ( (ierr1 .gt. 0)  .or. (ierr2 .gt. 0)  .or. (ierr3 .gt. 0) )
     +    msgerror=1

      write(*,*)  ' Node ', nprank , ' initialised - one of ', npsize

c     Set Error flag ...

      if( msgerror .ne. 0) then
          write (lunerr, *)  ' Message Passing Library error ',
     &				        ' in initialisation. '
          if ( (ierr1.ne.0) .or. (nprank .ne. -1)) then
             write (lunerr, *)  ' Occured in node ', nprank
          else
             write (lunerr, *)  ' MASSIVE ERROR> in an unknown node. '
             write (lunerr, *)
     &       ' This is non-recoverable, MPI did not initialise at all'
c
c            This is non-recoverable, MPI did not initialise at all
             call gpabort()
c            ieorun= 1
             stop
          endif
      endif
c
c     By default a static decomposition of events is done, with
c       each processor geting 1/number of processors of the share
c       of events.
c     If an input file exists or the time per event has a large standard
c       deviation, the events can be dynamically assigned. You will then
c       need to look at the routines gukine and muxread in gexam3.
c
c     The following just initialises the default "static" configuration,
c       in which there is no "master" or "leader".
c
c         -- Id of task expected to be a "master"
      npleader = -1
c         -- Id of task expected to be 1st worker
c       		          (representative for printout ...)
      nfirstworker= 0

      msgerrpas= msgerror

      return
      end
+SELF.
+DECK,  GPLAST, T=FORT.
*CMZ :          23/08/94  15.10.00  by  John Apostolakis
*-- Author :    John Apostolakis  CERN/GP-MIMD2   23/08/94
+SELF, IF=PARA.
      subroutine gplast
c
c       This routine cleans up all the parallel environment on which
c      parallel Geant is layered. No parallel Geant routines should
c      be called after calling gplast.
c       To ensure that compatibility with all current MPI implementations
c      we ask that no code is executed after calling gplast.
c       To implement this choice we call 'STOP' at the end !!
c
      implicit none
      integer  ierror

+CDE, MULTIPROX.
* +SEQ, IOUNIT.    to get LUNOUT/LUNERR --- the keep is defined in geanf

      call MPI_finalize( ierror )
      if (ierror .ne. 0)  then
	 write(*,*) ' gplast: Error in MPI_finalize on node ', nprank
*	 write(LUNERR,*) ' gplast: Error in MPI_finalize on node ', nprank
      endif

      write(*,*) ' Calling STOP in MPI_finalize on node ', nprank
      stop
      end
+SELF.
+DECK,  GPMSGERR, T=FORT.
c-----------------------------------------------------------------
c   Author John Apostolakis, GPMIMD-2, CERN-CN,  February 1994
c
c        gpmsgerr(..)   report a error given by MPI (in sending
c                       or receiving a message).
c-----------------------------------------------------------------

      subroutine gpmsgerr( mpi_routine, ierr, srcroutinename )
      implicit none
      character*(*) srcroutinename, mpi_routine
      integer   lunerr, ierr
+CDE, MULTIPROX.
+CDE, GCUNIT.

c     As stderr is not defined, use Geant's stdout
      lunerr= lout

      write(LUNERR,*) 'WARNING: MPI routine ', mpi_routine,
     &      ' returned error code ', ierr , ' on node ', nprank,
     &      ' when called from routine ', srcroutinename

      RETURN
      END
+DECK,  GPREADRNG, T=FORT.
*CMZ :          26/02/96  11.38.47  by  S.Ravndal
*-- Author :
C------------------------------------------------------------------------
C     SUBROUTINE gpreadrng( lunread, filename, ierr )
C
C     Function: read a file containing a state of the pseudo random number
C               generator on all the nodes and set the RNG seeds using it.
c
c     A convention: if lunread is >= 0, use that unit.
c     If not, read from the file called <filename>
c
C     Possible error codes:
c	  ierr= -102         The number of seeds required for a subsequence of
c                            the RNG (numperseq) is more than allocated
c                	     in the array iseedrng (SEEDS_PER_SEQ)
c
c     called by:  <USER> (if PARALLEL switch is used)
c
c     Author:     John Apostolakis,  January 1996.
c
c     Last Modified: February 22, 1996   J.A.
c------------------------------------------------------------------------
+SELF, IF=PARA.
      subroutine gpreadrng( lunread, filename, ierr )
      implicit none
+SELF, IF=PARA, IF=PARA_COMM.
+CDE, MPIFINC.
+SELF, IF=PARA.
      integer lunread, ierr
      character filename*(*)
c     Containes iseeda, iseedb, iseqnc
+CDE, MULTSEEDS.
      integer    numprocs, nrank, nleader
      integer    MAXNODES, SEEDS_PER_SEQ
      parameter (MAXNODES=4096)
c     RANMAR
      parameter (SEEDS_PER_SEQ=103)

      integer   myseeds(SEEDS_PER_SEQ)
      integer   iseedrng( SEEDS_PER_SEQ, MAXNODES )

+CDE, GCUNIT.
c     version of the seed file format
      real   version, versionrd
      integer nsubseq, numperseq, nperline, nsubseqexp, nsubseqrd
      integer lunrd, lunerr
      integer isubseq, inumb, imax, ino, ichkerr(4), iia, iseqrd
      character*12 chSUBSEQ, chNOPERSEQ, chNPERLINE, chENDPROLOG,
     $     chsubsequence , chVersion
      character*12 chNameRng, chNameRead, chIdRng
      data  version / 1.0 /

      lunerr= lout

      if (lunread .lt. 0) then
          lunrd= 74   !! Some number ...
          open (unit=lunrd, file=filename, status='old')
      else
          lunrd= lunread
      endif

c #if defined(CERNLIB_PARA_RANECU)
c     if( ParaRng .eq. 'RANECU' )
c     --------------------------------------------------------------------
c     The RANECU pseudo random number generator, used by GEANT's GRNDM(Q).
c     --------------------------------------------------------------------
+SELF, IF=PARA, IF=-PARA_TASKRNG.
c     Currently the number of sequences must be the number of processors!
      call gprocs( numprocs, nrank, nleader )
      nsubseqexp=  numprocs

      if( numprocs .gt. MAXNODES )then
c        write(lunerr, *) 'GPreadRng: ERROR Too many nodes ', numprocs
         write(*, *) 'GPreadRng: ERROR Too many nodes ', numprocs
      endif
+SELF, IF=PARA.
      chnamerng= 'RANECU'
      numperseq= 2              !  2 "seed" integers per RANECU sequence
      nperline=  2              !  2 numbers per line
c #endif

+SELF, IF=PARA.

      read ( lunrd, 905 )  chVersion, versionrd
 905  format( a8, f5.2, a )
      write ( *, * ) ' Reading seedfile version ', version

      read(lunrd, 910) chIdRng,    chNameRead
 910  format( a7, a12 )
      read(lunrd, 920) chSUBSEQ,   nsubseqrd
 920  format( a9, i6 )
      read(lunrd, 920) chNOPERSEQ, numperseq
      read(lunrd, 920) chNPERLINE, nperline
      read(lunrd, 930) chENDPROLOG
 930  format( a9 )

c     Check that the strings before the values were correctly read in.
c
      call checkstr( chSUBSEQ,    'SUBSEQ ',   7,
     $     'Number  of  subsequences ', ichkerr(1) )
      call checkstr( chNOPERSEQ,  'NOPERSEQ ', 9,
     $     ' Numbers per subsequence ',  ichkerr(2) )
      call checkstr( chNPERLINE,  'NPERLINE ', 9,
     $     ' Numbers per line ',         ichkerr(3) )
      call checkstr( chENDPROLOG, 'ENDPROLOG', 9,
     $     ' No variable to be read ',   ichkerr(4) )
      DO iia=1,4
          IF( ichkerr(iia) .ne. 0 ) then
             write(*,*) ' GpReadRng : STOPping because of error ',
     $            '  in reading overall header, part ', iia
             stop
          ENDIF
      ENDDO

C     CHECK the VALUES read in
C
      IF ( nsubseqexp .ne. nsubseqrd ) THEN
         write(*,*)
     $        ' GpReadRng: Error: Mismatch in number of subsequences, ',
     $        ' expected = ' , nsubseqexp, ' file = ', nsubseqrd
         IF ( nsubseqexp .lt. nsubseqrd ) THEN
            write(*,*) ' Enough seeds to work with, continuing '
            nsubseq= nsubseqexp
         ELSE
            write(*,*) ' Not enough subsequences, aborting '
            call gpabort()
         ENDIF
      ELSE
         nsubseq= nsubseqexp
      ENDIF

c     Now read in the values from each subsequence
c
      DO isubseq= 1, nsubseq
          read(lunrd, 970 )  chSubsequence, iseqrd
          call checkstr( chSubsequence, ' Subsequence', 11,
     $         ' Which of the Subsequences ', ichkerr(1) )
          IF( (ichkerr(1).ne.0) .or. (iseqrd .ne. isubseq) ) then
             write(*,*) ' GpReadRng : STOPping because of error ',
     $                    ' in reading subsequence header '
             write(*,*) ' chSubsequence=/', chSubsequence, '/, iseqrd=',
     $                    iseqrd, ' iseq-expected= ', isubseq
             stop
          ENDIF
          DO inumb= 1, numperseq, nperline
             imax=max(inumb+nperline-1,numperseq)
             read( lunrd, 980 ) ( iseedrng( ino, isubseq ),
     $            ino=inumb, imax)
          ENDDO
      ENDDO
 970  format( a14, i6 )
 980  format( 8i15 )
+SELF, IF=PARA, IF=PARA_RANECU, IF=-PARA_TASKRNG.

+SELF, IF=PARA, IF=PARA_RANECU, IF=-PARA_TASKRNG, IF=PARA_COMM.
c     Now "scatter" all seeds from node 0 to all the nodes
c
c     if numperseq < SEEDS_PER_SEQ the following should still work.
c
      call MPI_Scatter( iseedrng, SEEDS_PER_SEQ, MPI_INTEGER,
     $                  myseeds,  numperseq,     MPI_INTEGER,
     $                  0, MPI_COMM_WORLD, ierr)
c
      if ( ierr .gt. 0 ) then
         write( lunerr, '(a,i,a)' ) 'GpDefRng: Error ', ierr,
     $        ' in Mpi_gather '
      endif
+SELF, IF=PARA, IF=PARA_RANECU, IF=-PARA_TASKRNG, IF=-PARA_COMM.
c     Else each node selects its seeds ...
c
      DO inumb= 1, numperseq
	  myseeds( inumb )= iseedrng( inumb, nrank+1 )
      ENDDO
+SELF, IF=PARA, IF=PARA_RANECU, IF=-PARA_TASKRNG.

c     Set the pRNG seeds (In this version there is one sequence per node)
      call grndmq( myseeds(1), myseeds(2), iseqnc, 'S' )
+SELF, IF=PARA.
      if (lunread .lt. 0) then
          close (unit=lunrd)
      endif

      return
      end
+SELF.
+DECK,  GPROCS, T=FORT.
*CMZ :           1/08/95  16.58.00  by  John Apostolakis
*-- Author :    John Apostolakis  CERN/GP-MIMD2    1/08/95
**DOC
*  Routine to allow calling GEANT program to become aware of
*  the extent of the parallel machine it is running on and its place
*  within it.
+SELF, IF=PARA.
      subroutine gprocs( nsize, nrank, nleader )
      implicit none
      integer nsize, nrank, nleader
*  nsize   = Number of nodes or processes
*  nrank   = The id or rank of the this process ( 0 <= rank < size )
*  nleader = The node that does input distibution (if there is one,
*                  and -1 if there is no leader)
**ENDDOC
+CDE, MULTIPROX.
      nsize= npsize
      nrank= nprank
      nleader= npleader

      RETURN
      END
+SELF.
+DECK,  GPRUN, T=FORT.
*CMZ :          11/11/94  15.39.18  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   13/07/94
**DOC
C  Parallel Geant - main routines, to be used in parallelising GEANT programs.
C  Target architectures: scalable parallel processors and (for appropriate
C  problems) workstation clusters
C  Implemenation relies on availability of:
C  An implementation of the MPI (Message Passing Interface Standard) for the
C   relevant ensemble of machines or parallel processor.
C
C  A common file base for input and output files, such as NFS or AFS.
C
C  [ NOTE: MPI Implementations exist for most Unix machines, including
C    the portable, public domain, implementation. For more information see
C    the MPI Web page at URL http://www.mcs.anl.gov/mpi/index.html  ]
C  ---
C  First released version  March 1996, John Apostolakis japost@dxcern.cern.ch
C  --------------------------------------------------------------------------
C     subroutine gprun
C
C           Function: in some cases of static event partitioning, it
C             makes sure each node only does its portion of the events to
C             to be simulated.
C
C     called by:  grun (if CERNLIB_PARA switch is used)
C------------------------------------------------------------------------
**ENDDOC
+SELF, IF=PARA.
      subroutine gprun
c     Routine is called at the start of grun, to normalize Number of Events
c       in the case of a "static" decomposition of events
      implicit none
*
+CDE, GCFLAG.
+CDE, MULTIPROX.
*
*
      integer modsize
*
c     The default method of partitioning events between processors is
c     the Static method.

c     To choose the dynamic method, in which events are shared out
c     to different nodes by a master, the user must call gpdynamic
c     and write a multiplexing routine (modifying the routine muxread
c     in the example gexam3).


      if ( npleader .eq. -1) then
c
c     Static distribution of events, the new default
c     All nodes share the events equally. It will work well if events take
c     close to the same CPU time to simulate, ie the standard deviation
c     of the event time is small compared to the average event time.
c
c     In this case do a static distribution of events ...
c     (assumes 1<=nprank<npsize, so it is OK for MPI, where 0<=nprank<npsize )
c
c
	  nevtot  = nevent
	  nevent  = nevtot / npsize
	  modsize = mod(nevtot,npsize)
	  if( nprank .lt. modsize ) then
	      nevent = nevent + 1
	  endif
      else
c
c     Dynamic distribution of events, the new default
c
c     This version does dynamic distribution of events, and terminates at
c     the end of the input file. The number of events each node will
c     simulate is not determined in advance. Each node requests work
c     from the "master" node, which gives it out (the "farming" model).
c     The number of events that each node will simulate can vary, so it
c     is best to make the maximum number of events
c     per node equal be the original nevent [ ... or else one node could
c     terminate unexpectedly ]
c
	  nevtot  = nevent
c
c     This code must be used in conjunction with additional code in
c     the routine "gukine" to handle sharing the work load. An example
c     of such a routine can be found in "muxread".

      endif

      return
      end
+SELF.
+DECK,  GPSUMHR, T=FORT.
*CMZ :          08/23/94  15.20.00  by  John Apostolakis CERN GP-MIMD 2
*-- Author :
      subroutine GPSUMHR( idh, file, chopt )
c
c     Saves histograms into a single RZ file, putting each
c     process' histogram into a subdirectory, as well as saving the
c     running total in the subdirectory 'totals'. At the end the
c     directory 'totals' will contain the sum total of all
c     contributions from all processes.
c
c       ( A 'replacement' for hrput for parallel Geant.)
c
c.    Implementation notes:
c.
c.          Currently chopt is ignored!
c.
c-------------------------------------------------------------------------
+SELF, IF=PARA.
      IMPLICIT NONE
      INTEGER       idh
      CHARACTER*(*) file, chopt

      INTEGER myid
      character*13  myname
+CDE, MPIFINC.
+CDE, MULTIPROX.
C
      INTEGER istat, icycle, lunhist
C
      integer       iquest(100), nrec, itag
      integer       npstat(MPI_STATUS_SIZE), ierr
      integer       idebgsvh, npnext, nfirst, indivout
      character*1   filemode
      common /quest/  iquest
      data    nrec / 1024 /
      data    itag / 1001 /
      data    idebgsvh / 1 /
      data    indivout / 1 /
      data    lunhist / 29 /
      parameter (nfirst=0)
c----------------------------------------------------------------------
c J. Apostolakis: Use a directory for each process and a
c                     a directory called 'totals' for totals,
c                 v0.1 February 9, 1994   using mvlock/mvunlock
c                 v0.2 August   4, 1994   using mpi_{send,recv}
c
c     Node 0 creates the file, others wait their turn (a message goes
c       around that each node receives, does its stuff and sends on)
c       [ Older idea was to use a barrier: call mpi_barrier( MPI_COMM_WORLD ) ]
c
c     Notes:
c     x     The current scheme is not robust, but has worked well.
c     x   The potential problem is if one node fails before getting to
c     x   this point or during its call to gpsumhr. The former could be
c     x   handled by replacing the current method with a robust scheme
c     x   capable of handling node failures, by using lockf/unlockf to
c     x   lock the file ...
c     x
c     x   For file creation, having all nodes try to create a new hbook
c     x   file will not work, since one will overwrite another ...
c	
      if( nprank .eq. nfirst )  then
          filemode= 'N'
          nrec= 1024
      else
          filemode= 'U'
          nrec= 0
c
c         Wait here until the previous node is finished !
c
          call mpi_recv( istat, 1, MPI_INTEGER,
     &                   nprank-1, itag, MPI_COMM_WORLD, npstat, ierr )
      endif

      CALL HROPEN ( LUNHIST, 'OUTPUT', file, filemode, nrec, istat)

      if(istat.ne.0) then
          print *, ' HROPEN of ', file, ' on node ', nprank,
     &             ' failed in gpsumhr. Istat = ', istat
      else
          print *, ' HROPEN of ', file, ' on node ', nprank,
     &             ' succeeded and gave nrec=', nrec
      endif

      myid = nprank
      if( myid.ge.10000 ) then
          print *, 'Warning in gpsumhr: The id (',myid,
     &            ')is too big to be used in gpsumhr.f'
          myid = mod(myid, 10000)
      endif
      write (myname, '(a7,i6)')  'process',myid+10000
      myname(8:8)='0'

      if( idebgsvh .eq. 1 ) then
          call hldir  ( '//PAWC', ' ' )
          call hldir  ( '//OUTPUT', 't' )
      endif

      call hcdir  ( '//OUTPUT', ' ' )

c     Could make 'indivout' an option: it creates subdirectories with
c     each node's output.
      if( indivout .eq. 1 ) then
          call hmdir  ( myname, ' ' )
          call hcdir  ( myname, ' ' )   !  if it has been created already ...
          CALL HROUT  ( idh, icycle,' ')
      endif

      if( nprank .eq. nfirst ) then
          call hmdir  ( '//OUTPUT/TOTALS','S')
      else
          call hcdir  ( '//OUTPUT/TOTALS',' ')
          CALL HRIN   ( idh, 888888, 99999)
      endif
c                                ! 99999 is an undocumented feature => it adds
c                                        the histograms to the ones in memory
c     ------------------------------------------------------------------
      call hrout  ( idh, icycle, 'T')

      CALL HREND  ('OUTPUT')
      close( LUNHIST )
c
c     Send a message to the next node, which is waiting until this one
c      is finished !
c
      npnext = nprank+1
      if ( npnext .ge. npsize ) npnext = npnext - npsize
      call mpi_send( istat, 1, MPI_INTEGER,
     &               npnext,   itag, MPI_COMM_WORLD, ierr  )

c
c     Finally have the first node receive the last node's message!
c
      if( nprank .eq. nfirst ) then
          call mpi_recv( istat, 1, MPI_INTEGER,
     &                   npsize-1, itag, MPI_COMM_WORLD, npstat, ierr  )
      endif
c-----------------------------------------------------------------------

      RETURN
+SELF.
      END
+DECK,  GPTRIG, T=FORT.
*CMZ :          02/11/94  15.22.20  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD/2  Started: 13/07/94
C------------------------------------------------------------------------
C     gptrig
C           Function: prints some default information about the number of
C             the event simulated, the node and the current RNG seeds.
C
C     called by:  gtrig (if PARALLEL switch is used)
C------------------------------------------------------------------------
+SELF, IF=PARA.
      subroutine gptrig
      implicit none
+CDE, GCFLAG.
+CDE, MULTIPROX.
+CDE, MULTSEEDS.
      integer  isequence, idbg

      idbg= 0

c     if (idbg) write( *, 10000)  nprank, iseqnc, iseeda, iseedb
10000 FORMAT (' --> Node',I4,' Before grndmq call. ',
     &        ' Sequence expected ', I5, ' Previous Seeds', 2I11 )

      isequence = -1
      call GRNDMQ( iseeda, iseedb, isequence, 'G' )

      if(idbg) write( *, 10005)  nprank, isequence
10005 FORMAT (' --> Node',I4,' After grndmq call. ',
     &        ' Sequence returned ', I5 )

c     call GRNDMQ( iseeda, iseedb, iseqnc, 'G' )

      write( *, 10010)  nprank, ievent, iseeda, iseedb
10010 FORMAT (' --> Node',I4,'  Event',I7,'  Seeds',2I11 )

      return
      end
+SELF.
+DECK,  GPTRIGI, T=FORT.
*CMZ :          20/10/94  15.26.50  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   13/07/94
+SELF, IF=PARA.
      subroutine gptrigi
      implicit none
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, MULTIPROX.
      integer  iseed1, iseed2

      call GRNDMQ( iseed1, iseed2, 0, 'G' )

      WRITE (CHMAIL,10000) IEVENT,nprank, IDEVT, iseed1, iseed2
      CALL GMAIL(0,0)

10000 FORMAT(' **** GTRIGI: IEVENT=',I7,' NODE ', I3 , ' IDEVT=',I7,
     +' Random Seeds = ',I10,2X,I10)

      return
      end
+SELF.
+DECK,  GPWRITERNG, T=FORT.
*CMZ :          26/02/96  11.38.47  by  S.Ravndal
*-- Author :
C------------------------------------------------------------------------
C     gpwriterng( lunwrite, filename, ierr )
C
C     Function: write out the state of the pseudo random number
C               generator on all the nodes into a file.
C
c     A convention: if lunwrite is >= 0, use that unit.
c       If not, create a new file called <filename>
C
C     Possible error codes:
c	  ierr= -102         The number of seeds required for a subsequence of
c                              the RNG (numperseq) is more than allocated
c			       in the array iseedrng (SEEDS_PER_SEQ)
c
C     called by:  <USER> (if PARALLEL switch is used)
C------------------------------------------------------------------------
+SELF, IF=PARA.
      subroutine gpwriterng( lunwrite, filename, ierr )
      implicit none
      integer lunwrite, ierr
      character filename*(*)

+CDE, MPIFINC.
+CDE, MULTSEEDS.
      integer    numprocs, nrank, nleader
      integer    MAXNODES, SEEDS_PER_SEQ
      parameter (MAXNODES=4096)
      character*12 chNameRng

c     In order to accomodate RANMAR, which has the largest table of seeds.
      parameter (SEEDS_PER_SEQ=103)

c     For  RANECU it would be enough: (SEEDS_PER_SEQ=2).
c     For ranlux            parameter (SEEDS_PER_SEQ= 25)

      integer   myseeds(SEEDS_PER_SEQ)
      integer   iseedrng( SEEDS_PER_SEQ, MAXNODES )
c     version of the seed file format
      real   version
      integer nsubseq, numperseq, nperline
      integer lunwr, lunerr
      integer isubseq, inumb, imax, ino
      data  version / 1.0 /

      if (lunwrite .lt. 0) then
c     Default number
          lunwr= 74
          open (unit=lunwr, file=filename )
      else
          lunwr= lunwrite
      endif

c     Make sure to go to the start of the file
c
      rewind( lunwr )
+SELF, IF=PARA, IF=PARA_RANECU.
c     -----------------------------------------------------------------
c     The RANECU pseudo random number generator, used by GEANT's GRNDM.
c     -----------------------------------------------------------------
+SELF, IF=PARA, IF=PARA_RANECU, IF=-PARA_TASKRNG.
c     Currently the number of sequences is the number of processors!
      call gprocs( numprocs, nrank, nleader )
      nsubseq=   numprocs

      if( numprocs .gt. MAXNODES ) then
         write(*, *) 'GPwriteRng: ERROR Too many nodes ', numprocs
	 ierr= -101
	 goto 9999
      endif

+SELF, IF=PARA, IF=PARA_RANECU.
      chnamerng= 'RANECU'
      numperseq= 2              !  2 "seed" integers per RANECU sequence
      nperline=  2              !  2 numbers per line
+SELF, IF=PARA, IF=PARA_RANMAR.
      chnamerng= 'RANMAR'
      numperseq= 103            !  103 "seed" integers per RANMAR sequence
      nperline=  5              !    5 numbers per line
+SELF, IF=PARA, IF=PARA_RANLUX.
      chnamerng= 'RANLUX'
      numperseq= 25             !   25 "seed" integers per RANMAR sequence
      nperline=  5              !    5 numbers per line
+SELF, IF=PARA.

c     "Gather" all seeds to node 0
c
+SELF, IF=PARA, IF=PARA_RANECU, IF=-PARA_TASKRNG.
c     In this version there is one sequence per node
      call grndmq( myseeds(1), myseeds(2), iseqnc, 'G' )

      if (numperseq .gt. SEEDS_PER_SEQ ) then
	  ierr= -102
	  goto 9999
      endif

c     The following has all nodes send their seed, and node 0 collect them.
c      It should work if  numperseq <= SEEDS_PER_SEQ
c
      call MPI_Gather( myseeds, numperseq, MPI_INTEGER, iseedrng,
     $     SEEDS_PER_SEQ, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr )
c
      if ( ierr .gt. 0 ) then
         write( lunerr, '(a,i,a)' ) 'GpWr(iteRng)Seeds: Error ', ierr,
     $        ' in Mpi_gather '
         goto 9999
      endif
+SELF, IF=PARA.
c     Write out the header and then all the seeds, on node 0 only !!
c
      if ( nrank .eq. 0	  ) then
	  write(lunwr, 900 ) 'Version ', version,
     $         ' of pRNG seed file for parallel Geant '

	  write(lunwr, 905)  'RNG    ',   chNameRng,
     $         ' Identity of pseudorandom Number generator '
	  write(lunwr, 910)  'SUBSEQ   ',   nsubseq,
     $         ' Number  of  subsequences '
	  write(lunwr, 910)  'NOPERSEQ ', numperseq,
     $         ' Numbers per subsequence '
	  write(lunwr, 910)  'NPERLINE ', nperline,
     $         ' Numbers per line '
	  write(lunwr, 920)  'ENDPROLOG'


	  DO isubseq= 1, nsubseq
	      write(lunwr, 930 )  ' Subsequence ' , isubseq
	      DO inumb= 1, numperseq, nperline
		 imax=max(inumb+nperline-1,numperseq)
		 write( lunwr, 940 ) ( iseedrng( ino, isubseq ),
     $ 	             ino=inumb, imax)
	      ENDDO
	  ENDDO

	  if (lunwrite .lt. 0) then
	      close (unit=lunwr)
	  endif

      endif

 900  format( a8, f5.2, a )
 905  format( a7, a12, a )
 910  format( a9, i6, a )
 920  format( a )
 930  format( a14, i6 )
 940  format( 8i15 )


9999  continue

      return
      end
+SELF.
+DECK,  PBARRIER, T=FORT.
*CMZ :          23/03/95  14.24.24  by  John Apostolakis CERN GP-MIMD 2
*-- Author :    John Apostolakis CERN GP-MIMD 2   23/03/95
+SELF, IF=PARA.
      subroutine pbarrier
      implicit none
c
c     Any processes making this call will wait, until all processes
c     have arrived at this point.
c
+CDE, MPIFINC.
+CDE, GCUNIT.
      integer ierr

c     It would make sense when debugging to include the following write:
c     write (lout,*)  ' Entering barrier: if any process cannot reach ',
c     ' this point the program will hang here '
c
      call MPI_barrier( MPI_COMM_WORLD, ierr )
      if ( ierr .lt. 0 ) then
          write (lout,*)  ' There was error ', ierr, ' in pbarrier '
      endif
      return
      end
+SELF.
+PATCH, GKINE.
+DECK,  GFKINE, T=FORT.
* Revision 1.2  1998/02/10 16:04:18  japost
*   Comments are correctly redistributed.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GFKINE(ITRA,VERT,PVERT,IPART,NVERT,UBUF,NWBUF)
*
************************************************************************
*                                                                      *
*           Retrieves Vertex and Track parameters                      *
*           -------------------------------------                      *
*                                                                      *
*  Retrieves parameters for a track with a long lifetime.              *
*                                                                      *
*  Input:                                                              *
*    ITRA      track number for which parameters are requested         *
*                                                                      *
*  Output:                                                             *
*    VERT      vector origin of the track                              *
*    PVERT     4 momentum components at the track origin               *
*    IPART     particle type (=0 if track ITRA does not exist)         *
*    NVERT     vertex number origin of the track                       *
*    UBUF      user words stored in GSKINE.                            *
*                                                                      *
*    ==>Called by : <USER>, GTREVE                                     *
*       Author    R.Brun  *********                                    *
*                                                                      *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCTRAK.
      DIMENSION VERT(3),PVERT(4),UBUF(*)
C.
C.    ------------------------------------------------------------------
C.
      IPART  = 0
      IF (JKINE.LE.0)GO TO 99
      IF (ITRA.LE.0)GO TO 99
      IF (ITRA.GT.NTRACK)GO TO 99
C
      JK = LQ(JKINE- ITRA)
      IF (JK.LE.0)GO TO 99
      NV = Q(JK + 6)
      IF (JVERTX.LE.0)GO TO 99
      JV = LQ(JVERTX- NV)
      IF (JV.LE.0)GO TO 99
      DO 10 I=1,3
  10  VERT(I) = Q(JV + I)
*     TOFG=Q(JV+4)
C
      DO 20 I=1,4
  20  PVERT(I) = Q(JK + I)
      IPART = Q(JK + 5)
      NVERT = Q(JK + 6)
      NLINK = IQ(JK-2)
      NWBUF  = 0
      IF (NLINK.LE.0)GO TO 99
      JKU = LQ(JK- 1)
      IF (JKU.LE.0)GO TO 99
      NWBUF = IQ(JKU-1)
      DO 30 I=1,NWBUF
  30  UBUF(I)=Q(JKU+I)
C
  99  RETURN
      END
+DECK,  GFVERT, T=FORT.
* Revision 1.2  1998/02/10 16:04:20  japost
*   Comments are correctly redistributed.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GFVERT(NVTX,V,NTBEAM,NTTARG,TOFG,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Retrieves the parameter of a vertex bank                 *
C     *       Vertex is generated from tracks NTBEAM NTTARG            *
C     *       NVTX is the new vertex number                            *
C.    *                                                                *
C.    * Input:                                                         *
C.    *  NVTX      new vertex number (=0 in case of error).            *
C.    *                                                                *
C.    * Output:                                                        *
C.    *  VERT      array of (x,y,z) position of the vertex             *
C.    *  NTBEAM    beam track number origin of the vertex              *
C.    *            =0 if none exists                                   *
C.    *  NTTARG    target track number origin of the vertex            *
C.    *  TOFG      time of flight when the vertex was created
C.    *  UBUF      user array of NUBUF floating point numbers          *
C.    *  NUBUF                                                         *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    F.Carminati                   *********       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      DIMENSION V(3),UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      IF (JVERTX.EQ.0.OR.NVERTX.LE.0)THEN
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      IF(NVTX.GT.NVERTX) THEN
         WRITE(CHMAIL,10100)NVERTX
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      JV=LQ(JVERTX-NVTX)
      IF(JV.LE.0) THEN
         WRITE(CHMAIL,10100)NVERTX
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      DO 10 I=1,3
         V(I) = Q(JV + I)
   10 CONTINUE
      TOFG = Q(JV + 4)
      NTBEAM = Q(JV + 5)
      NTTARG = Q(JV + 6)
*
      NWBUF=0
      IF(IQ(JV-2).GE.1) THEN
         JUV=LQ(JV-1)
         IF(JUV.GT.0) THEN
            NWBUF=IQ(JUV-1)
            DO 20 IBUF=1,NWBUF
               UBUF(IBUF)=Q(JUV+IBUF)
   20       CONTINUE
         ENDIF
      ENDIF
*
10000 FORMAT(' **** GFVERT: No vertex stored in memory')
10100 FORMAT(' **** GFVERT: Vertex ',I10,' does not exist')
  999 END
+DECK,  GKINE_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
*
************************************************************************
*            -----------------------------------------------           *
*            The Kinematics data structures JVERTX and JKINE           *
*            -----------------------------------------------           *
*                                                                      *
*                                          | JVERTX                    *
*     NVERTX          IVERT                v                           *
*      ...............................................                 *
*      |              | |                 | | NVERTX |                 *
*      ...............................................                 *
*                      |                                               *
*                      | JV                                            *
*                      v                                               *
*           ..........................                                 *
*           | 1 |   VX               |                                 *
*           |...|....................|                                 *
*           | 2 |   VY               |                                 *
*           |...|....................|                                 *
*           | 3 |   VZ               |                                 *
*           |...|....................|                                 *
*           | 4 |   TOF              |                                 *
*           |...|....................|                                 *
*           | 5 |   NTBEAM           |                                 *
*           |...|....................|                                 *
*           | 6 |   NTTARG           |                                 *
*           |...|....................|                                 *
*           | 7 |   no. of tracks    |                                 *
*           |...|....................|                                 *
*           | 8 |   List of tracks   |                                 *
*           |...|....................|                                 *
*           | 9 |                    |                                 *
*           ..........................                                 *
*                                                                      *
*  JV        = LQ(JVERTX-IVERT) pointer to parameters of vertex        *
*            number IVERT                                              *
*  Q(JV+1)   x coordinate of this vertex.                              *
*                                                                      *
*  The JVERTX  banks are filled  by the routine GSVERT.   The Vertex   *
* parameters are retrieved by the routine GFVERT.                      *
*                                                                      *
*                                                                      *
*                                          | JKINE                     *
*     NTRACK          ITRA                 v                           *
*      ...............................................                 *
*      |              | |                 | | NTRACK |                 *
*      ...............................................                 *
*                      |                                               *
*                      | JK                                            *
*                      v                                               *
*           ..........................                                 *
*           | 1 |   PX               |                                 *
*           |...|....................|                                 *
*           | 2 |   PY               |                                 *
*           |...|....................|                                 *
*           | 3 |   PZ               |                                 *
*           |...|....................|                                 *
*           | 4 |   Energy           |                                 *
*           |...|....................|                                 *
*           | 5 |   IPART            |                                 *
*           |...|....................|                                 *
*           | 6 |   Vertex origin    |                                 *
*           |...|....................|                                 *
*           | 7 |   no. of vertices  |                                 *
*           |...|....................|                                 *
*           | 8 |   List of vertices |                                 *
*           |...|....................|                                 *
*           | 9 |                    |                                 *
*           ..........................                                 *
*                                                                      *
*  JK        = LQ(JKINE-ITRA)   pointer to parameters  of track        *
*            number ITRA                                               *
*  Q(JK+1)   x component of the momentum for this track.               *
*                                                                      *
*  The  JKINE  banks  are  filled  by  the  routine  GSKINE.   Track   *
* parameters are obtained by GFKINE.                                   *
*                                                                      *
************************************************************************
#endif
+DECK,  GLUDKY, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GLUDKY
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        GEANT INTERFACE TO THE LUND MONTE-CARLO                 *
C.    *        FOR TAU DECAY GENERATION ONLY                           *
C.    *                                                                *
C.    *  THIS INTERFACE TO LUND                                        *
C.    *  A) INHIBITS DECAYS OF K0S,SIG+,SIG-,XI0,XI-,LAM,OM-           *
C.    *  B) ACCEPTS STABLE PARTICLES ONLY                              *
C.    *  C) CONVERTS THE PARTICLE CODES TO GEANT CONVENTIONS           *
C.    *                                                                *
C.    *  THUS THE PARTICLES FORWARDED TO GEANT ARE                     *
C.    *  GAMMA,ELECTRON,NEUTRINO(E,MU,TAU),MU-,PI+,K+,K0S,K0L,         *
C.    *  PROTON,NEUTRON,SIG(+,-),XI(0,-),LAM,OM-                       *
C.    *  ....  AND THEIR ANTIPARTICLES                                 *
C.    *                                                                *
C.    *       That routine can be called from the user routine GUDCAY  *
C.    *                                                                *
C.    *       Author    R.Hemingway  26 SEPT 1985                      *
C.    *                                                                *
C.    ******************************************************************
C.
C
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCTRAK.
+CDE, GCONSP.
+CDE, LUJETS.
+CDE, LUDAT3.
      PARAMETER (NSEL=44)
      DIMENSION IPLUND(NSEL)
      DATA IPLUND/
     +    22,   -11,    11,    12,   -13,    13,   111,   211,
     +  -211,   130,   321,  -321,  2112,  2212, -2212,   310,
     +   221,  3122,  3222,  3212,  3112,  3322,  3312,  3334,
     + -2112, -3122, -3112, -3212, -3222, -3322, -3312, -3334,
     +   -15,    15,   411,  -411,   421,  -421,   431,  -431,
     +  4122,    24,   -24,    23/
*.
*.    ------------------------------------------------------------------
*.
      IF (IFINIT(6).EQ.0)THEN
*
*--  Set some particles to be stable in LUND so that GEANT can handle
*--  their tracking and decays. (K0s, sigma+-, xi0-, lambda0, omega-)
*
         MDCY(LUCOMP(310) ,1)=0
         MDCY(LUCOMP(3222),1)=0
         MDCY(LUCOMP(3112),1)=0
         MDCY(LUCOMP(3322),1)=0
         MDCY(LUCOMP(3312),1)=0
         MDCY(LUCOMP(3122),1)=0
         MDCY(LUCOMP(3334),1)=0
         IFINIT(6) = 1
      ENDIF
C
      IF(IPART.EQ.33.OR.IPART.EQ.34) THEN
         N=0
         EDKY=GETOT
         THDKY=ACOS(VECT(6))
         PHDKY=ATAN2(VECT(5),VECT(4))
*
*            for TAU+ TAU-
*            could be extended to all charm particles
*
         CALL LU1ENT(1,IPLUND(IPART),EDKY,THDKY,PHDKY)
         CALL LUEXEC
         NGKINE=0
         DO 20 I = 1,N
            IF(K(I,1).GE.1.AND.K(I,1).LE.10) THEN
               DO 10 IGE=1, NSEL
                  IF(IPLUND(IGE).EQ.K(I,2)) THEN
                     NGKINE=NGKINE+1
                     GKIN(1,NGKINE)=P(I,1)
                     GKIN(2,NGKINE)=P(I,2)
                     GKIN(3,NGKINE)=P(I,3)
                     GKIN(4,NGKINE)=P(I,4)
                     GKIN(5,NGKINE)=IGE
                     GPOS(1,NGKINE)=V(I,1)
                     GPOS(2,NGKINE)=V(I,2)
                     GPOS(3,NGKINE)=V(I,3)
                     TOFD(NGKINE)  =V(I,4)/(10.*CLIGHT)
                  ENDIF
   10          CONTINUE
            ENDIF
   20    CONTINUE
      ENDIF
*
      END
+DECK,  GLUND, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GLUND
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        GEANT INTERFACE TO THE LUND MONTE-CARLO                 *
C.    *                                                                *
C.    *  FOR TECHNICAL DETAILS OF THE LUND MONTE CARLO,SEE             *
C.    *  1. THE LUND MONTE CARLO FOR JET FRAGMENTATION - T.SJOSTRAND   *
C.    *     LU TP 82-3  and COMPUTER PHYSICS COMMUNICATION 27(1982)243 *
C.    *  2. THE LUND MONTE CARLO FOR E+E- JET PHYSICS  - T.SJOSTRAND   *
C.    *     LU TP 82-7 and COMPUTER PHYSICS COMMUNICATION 28(1983)229  *
C.    *                                                                *
C.    *    The parameters to use the LUND interface are set in GLUNDI  *
C.    *    They can be changed by data cards (see GLUNDI)              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE                               *
C.    *       Author    R.Hemingway  *********                         *
C.    *       modified by R.Brun  18/11/85 **                          *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION VERT(3)
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCPUSH.
+CDE, LUJETS.
+CDE, GCLUND.
      PARAMETER (NSEL=44)
      DIMENSION IPLUND(NSEL)
      REAL      PGEANT(3),BUF(1)
      EQUIVALENCE (BUF,K)
      DATA IPLUND/
     +    22,   -11,    11,    12,   -13,    13,   111,   211,
     +  -211,   130,   321,  -321,  2112,  2212, -2212,   310,
     +   221,  3122,  3222,  3212,  3112,  3322,  3312,  3334,
     + -2112, -3122, -3112, -3212, -3222, -3322, -3312, -3334,
     +   -15,    15,   411,  -411,   421,  -421,   431,  -431,
     +  4122,    24,   -24,    23/
*.
*.    ------------------------------------------------------------------
*.
      IF (IFINIT(3).EQ.0)  CALL GLUNDI
*
      CALL LUEEVT(IFLUND,ECLUND)
*
      NCVERT = 10
      NCKINE = N+10
      NCJXYZ = NCKINE
      NPVERT =  5
      NPKINE = 10
      NPJXYZ = 10
*
      VERT(1)   = 0.
      VERT(2)   = 0.
      VERT(3)   = 0.
      NWBUF=2+10*N
      CALL GSVERT(V,0,0,BUF,NWBUF,NVTX)
      IF (NVTX.GT.0) THEN
         DO 20 I = 1,N
            IF(K(I,1).GE.1.AND.K(I,1).LE.10) THEN
               DO 10 IGE=1, NSEL
                  IF(IPLUND(IGE).EQ.K(I,2)) THEN
                     PGEANT(1)=P(I,1)
                     PGEANT(2)=P(I,2)
                     PGEANT(3)=P(I,3)
                     CALL GSKINE(PGEANT,IGE,NVTX,BUF,0,NT)
                     GOTO 20
                  ENDIF
   10          CONTINUE
            ENDIF
   20    CONTINUE
*
         JV = LQ(JVERTX-1)
         JUV = LQ(JV-1)
         Q(JUV+1)= 527.0
         Q(JUV+2)= N
*
*     Copy the LUND record into a bank of real variables.
*
         DO 30 NP=1, N
            Q(JUV+2    +NP) = K(NP,1)
            Q(JUV+2+  N+NP) = K(NP,2)
            Q(JUV+2+2*N+NP) = K(NP,3)
            Q(JUV+2+3*N+NP) = K(NP,4)
            Q(JUV+2+4*N+NP) = K(NP,5)
            Q(JUV+2+5*N+NP) = P(NP,1)
            Q(JUV+2+6*N+NP) = P(NP,2)
            Q(JUV+2+7*N+NP) = P(NP,3)
            Q(JUV+2+8*N+NP) = P(NP,4)
            Q(JUV+2+9*N+NP) = P(NP,5)
   30    CONTINUE
*
      ENDIF
      END
+DECK,  GLUNDI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GLUNDI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        GEANT INTERFACE TO THE LUND MONTE-CARLO                 *
C.    *            (Initialization routine)                            *
C.    *                                                                *
C.    *  FOR TECHNICAL DETAILS OF THE LUND MONTE CARLO,SEE             *
C.    *  1. THE LUND MONTE CARLO FOR JET FRAGMENTATION - T.SJOSTRAND   *
C.    *     LU TP 82-3  and COMPUTER PHYSICS COMMUNICATION 27(1982)243 *
C.    *  2. THE LUND MONTE CARLO FOR E+E- JET PHYSICS  - T.SJOSTRAND   *
C.    *     LU TP 82-7 and COMPUTER PHYSICS COMMUNICATION 28(1983)229  *
C.    *                                                                *
C.    *  THE PARTICLES FORWARDED TO GEANT ARE                          *
C.    *  GAMMA,ELECTRON,NEUTRINO(E,MU,TAU),MU-,PI+,K+,K0S,K0L,         *
C.    *  PROTON,NEUTRON,SIG(+,-),XI(0,-),LAM,OM-                       *
C.    *  ....  AND THEIR ANTIPARTICLES                                 *
C.    *                                                                *
C.    *                                                                *
C.    *  THE USER MUST SUPPLY TWO PARAMETERS FOR EVENT GENERATION      *
C.    *  VIA     CALL LUEEVT(IFLUND,ECLUND)     WHERE                  *
C.    *  IFLUND=THE FLAVOUR CODE (1=U,2=D,3=S,4=C,5=B,6=T,0=MIX)       *
C.    *  ECLUND=THE TOTAL CMS ENERGY                                   *
C.    *                                                                *
C.    *     GLUNDI is automatically called by GLUND.                   *
C.    *     GLUNDI can be called by the user in the initialization     *
C.    *     routine UGINIT just before reading data cards (GFFGO)      *
C.    *     In this case the default parameters can be changed by      *
C.    *     the data cards KTYP,PMAS,PWID,MSTE,LUND and IDB            *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE                               *
C.    *       Author    R.Hemingway , D.Ward *********                 *
C.    *       modified by R.Brun 18/11/85 ******                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCFLAG.
+CDE, LUDAT1.
+CDE, LUDAT3.
+CDE, GCLUND.
C.
C.    ------------------------------------------------------------------
C.
      IF (IFINIT(3).EQ.0)THEN
*
*              Set defaults
*
         IFINIT(3) = 1
         IFLUND = 0
         ECLUND = 92.25
*
*--  Initial state radiative effects     MSTJ(107) =  1
*
         MSTJ(107)= 1
*
*--  Set some particles to be stable in LUND so that GEANT can handle
*--  their tracking and decays. (K0s, sigma+-, xi0-, lambda0, omega-)
*
         MDCY(LUCOMP(310) ,1)=0
         MDCY(LUCOMP(3222),1)=0
         MDCY(LUCOMP(3112),1)=0
         MDCY(LUCOMP(3322),1)=0
         MDCY(LUCOMP(3312),1)=0
         MDCY(LUCOMP(3122),1)=0
         MDCY(LUCOMP(3334),1)=0
*
         CALL FFKEY('LUND',IFLUND,2,'MIXED')
      ENDIF
C
      END
+DECK,  GPKINE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GPKINE(IT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints kinematics bank JKINE for track number IT         *
C.    *       If IT=0 Prints all kinematics banks                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      WRITE(CHMAIL,1000)
      CALL GMAIL(1,0)
C
      I1=1
      I2=NTRACK
      IF(IT.NE.0)I1=IT
      IF(IT.NE.0)I2=IT
      IF(I2.GT.NTRACK)GO TO 99
      IF(I1.LT.1)GO TO 99
      IF(JKINE.LE.0)GO TO 99
C
      DO 20 ITRACK=I1,I2
         JK=LQ(JKINE-ITRACK)
         IF(JK.NE.0)THEN
            IPART=Q(JK+5)
            JPA=LQ(JPART-IPART)
            NL=IQ(JK-2)
            NG=Q(JK+7)+7
            NW=MIN(NG,16)
            WRITE(CHMAIL,2000)ITRACK,IQ(JPA+1),IQ(JPA+2),IQ(JPA+3),IPART
     +       ,(Q(JK+I),I=1,4),Q(JK+6),(INT(Q(JK+L)),L=8,NW)
   10       CALL GMAIL(0,0)
            IF(NG-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NG,NW+9)
               WRITE(CHMAIL,3000) (INT(Q(JK+L)),L=NS,NW)
               GO TO 10
            END IF
            IF(NL.GT.0) THEN
               JUK = LQ(JK-1)
               IF (JUK.GT.0) THEN
                  WRITE(CHMAIL,4000)
                  CALL GMAIL(0,0)
                  ND  = IQ(JUK-1)
                  NW=MIN(ND,9)
                  WRITE(CHMAIL,5000) (Q(JUK+L),L=1,NW)
   15             CALL GMAIL(0,0)
                  IF(ND-NW.GT.0) THEN
                     NS=NW+1
                     NW=MIN(ND,NW+9)
                     WRITE(CHMAIL,5000) (Q(JUK+L),L=NS,NW)
                     GO TO 15
                  END IF
               END IF
            END IF
         ENDIF
   20 CONTINUE
C
 1000 FORMAT(3X,'Kine',5X,'Name',10X,'Type',5X,'Px',9X,'Py',
     +       9X,'Pz',7X,'Energy',5X,'Vorigin',2X,'Vgener')
 2000 FORMAT(1X,I5,6X,3A4,I5,5(1X,F10.4),9(1X,I4))
 3000 FORMAT(84X,9(1X,I4))
 4000 FORMAT(62X,'User words')
 5000 FORMAT(1X,9(2X,E12.5))
C
  99  RETURN
      END
+DECK,  GPKINX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GPKINX(IT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints kinematics bank JKINE for track number IT         *
C.    *       If IT=0 Prints all kinematics banks                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  S.Giani *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
      CHARACTER*20 NAME
      CHARACTER*32 CHLINE,CHSTRI(50)
C.
C.    ------------------------------------------------------------------
C.
*      WRITE(CHMAIL,1000)
*      CALL GMAIL(1,0)
C
      I1=1
      I2=NTRACK
      IF(IT.NE.0)I1=IT
      IF(IT.NE.0)I2=IT
      IF(I2.GT.NTRACK)GO TO 999
      IF(I1.LT.1)GO TO 999
      IF(JKINE.LE.0)GO TO 999
C
      DO 40 ITRACK=I1,I2
         JK=LQ(JKINE-ITRACK)
         IF(JK.NE.0)THEN
            IPART=Q(JK+5)
            JPA=LQ(JPART-IPART)
            NL=IQ(JK-2)
            NG=Q(JK+7)+7
            NW=MIN(NG,16)
            CHLINE='Kine='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(ITRACK,CHLINE(ILEN:))
            CHSTRI(1)=CHLINE
            CALL UHTOC(IQ(JPA+1),4,NAME,20)
            CHLINE='Name='
            ILEN=LENOCC(CHLINE)+1
            CHLINE(ILEN:)=NAME
            CHSTRI(2)=CHLINE
            CHLINE='Type='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IPART,CHLINE(ILEN:))
            CHSTRI(3)=CHLINE
            CHLINE='Px='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+1),CHLINE(ILEN:))
            CHSTRI(4)=CHLINE
            CHLINE='Py='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+2),CHLINE(ILEN:))
            CHSTRI(5)=CHLINE
            CHLINE='Pz='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+3),CHLINE(ILEN:))
            CHSTRI(6)=CHLINE
            CHLINE='Energy='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+4),CHLINE(ILEN:))
            CHSTRI(7)=CHLINE
            CHLINE='Vorigin='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JK+6),CHLINE(ILEN:))
*      WRITE(CHLINE(ILEN:),1002)Q(JK+6)
            CHSTRI(8)=CHLINE
            DO 10 JJ=8,NW
               CHLINE='Vgener='
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(INT(Q(JK+JJ)),CHLINE(ILEN:))
*       WRITE(CHLINE(ILEN:),1002)INT(Q(JK+JJ)
               CHSTRI(1+JJ)=CHLINE
   10       CONTINUE
            NLINE=8
            IF(NW.GE.8)NLINE=8+(NW-8+1)
            CALL IGMESS(NLINE,CHSTRI,'PICK','P')
*            WRITE(CHMAIL,2000)ITRACK,IQ(JPA+1),IQ(JPA+2),IQ(JPA+3),IPART
*     +       ,(Q(JK+I),I=1,4),Q(JK+6),(INT(Q(JK+L)),L=8,NW)
*   10       CALL GMAIL(0,0)
   20       CONTINUE
            IF(NG-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NG,NW+9)
               WRITE(CHMAIL,10200) (INT(Q(JK+L)),L=NS,NW)
               CALL GMAIL(0,0)
               GO TO 20
            END IF
            IF(NL.GT.0) THEN
*               WRITE(CHMAIL,10300)
*               CALL GMAIL(0,0)
*               JUK = LQ(JK-1)
*               NL  = IQ(JUK-1)
*               NW=MIN(NL,9)
*               WRITE(CHMAIL,10400) (Q(JUK+L),L=1,NW)
*   30          CALL GMAIL(0,0)
*               IF(NL-NW.GT.0) THEN
*                  NS=NW+1
*                  NW=MIN(NL,NW+9)
*                  WRITE(CHMAIL,10400) (Q(JUK+L),L=NS,NW)
*                  GO TO 30
*               END IF
            END IF
         ENDIF
   40 CONTINUE
C
10000 FORMAT(3X,'Kine',5X,'Name',10X,'Type',5X,'Px',9X,'Py',
     +       9X,'Pz',7X,'Energy',5X,'Vorigin',2X,'Vgener')
10100 FORMAT(1X,I5,6X,3A4,I5,5(1X,F10.4),9(1X,I4))
10200 FORMAT(84X,9(1X,I4))
10300 FORMAT(62X,'User words')
10400 FORMAT(1X,9(2X,E12.5))
10500 FORMAT(E12.5)
C
  999 END
+DECK,  GPVERT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:18  cernlib
* Geant

      SUBROUTINE GPVERT(IV)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints vertex bank JVERTX for vertex number IV           *
C.    *       If IV=0 Prints all vertex banks                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      WRITE(CHMAIL,1000)
      CALL GMAIL(1,0)
C
      I1=1
      I2=NVERTX
      IF(IV.NE.0)I1=IV
      IF(IV.NE.0)I2=IV
      IF(I2.GT.NVERTX)GO TO 99
      IF(I1.LT.1)GO TO 99
      IF(JVERTX.LE.0)GO TO 99
C
      DO 20 IVERT=I1,I2
         JV=LQ(JVERTX-IVERT)
         IF(JV.NE.0)THEN
            TOFGN=Q(JV+4)*1.E+9
            NL=IQ(JV-2)
            NG=Q(JV+7)+7
            NW=MIN(NG,16)
            WRITE(CHMAIL,2000)IVERT,(Q(JV+I),I=1,3),TOFGN,
     +          INT(Q(JV+5)),INT(Q(JV+6)),(INT(Q(JV+L)),L=8,NW)
  10        CALL GMAIL(0,0)
            IF(NG-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NG,NW+9)
               WRITE(CHMAIL,3000)(INT(Q(JV+L)),L=NS,NW)
               GOTO 10
            ENDIF
            IF(NL.GT.0) THEN
               JUV = LQ(JV-1)
               IF(JUV.GT.0) THEN
                  WRITE(CHMAIL,4000)
                  CALL GMAIL(0,0)
                  ND  = IQ(JUV-1)
                  NW=MIN(ND,9)
                  WRITE(CHMAIL,5000) (Q(JUV+L),L=1,NW)
   15             CALL GMAIL(0,0)
                  IF(ND-NW.GT.0) THEN
                     NS=NW+1
                     NW=MIN(ND,NW+9)
                     WRITE(CHMAIL,5000) (Q(JUV+L),L=NS,NW)
                     GO TO 15
                  END IF
               END IF
            END IF
         ENDIF
   20 CONTINUE
C
 1000 FORMAT(3X,'Vert',8X,'Vx',11X,'Vy',11X,'Vz',8X,'Tofg',
     +       3X,'Tbeam',3X,'Targ',14X,'Gener tracks')
 2000 FORMAT(2X,I4,3(1X,F12.4),1X,F10.4,2X,2(I5,2X),9(1X,I4))
 3000 FORMAT(72X,9(1X,I4))
 4000 FORMAT(62X,'User words')
 5000 FORMAT(1X,9(2X,E12.5))
C
  99  RETURN
      END
+DECK,  GSKINE, T=FORT.
* Revision 1.2  1998/02/10 16:04:19  japost
*   Comments are correctly redistributed.
* Revision 1.1.1.1  1995/10/24 10:21:19  cernlib
* Geant

      SUBROUTINE GSKINE(PLAB,IPART,NV,BUF,NWBUF,NT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Store kinematics of track NT into data structure         *
C     *       Track is coming from vertex NV                           *
C.    *                                                                *
C.    *                                                                *
C.    * In detail:                                                     *
C.    *                                                                *
C.    *  Stores long life track parameters.                            *
C.    *                                                                *
C.    *  Input:                                                        *
C.    *    PLAB      components of momentum                            *
C.    *    IPART     type of particle (see GSPART)                     *
C.    *    NV        vertex number origin of track                     *
C.    *    UBUF      array of NUBUF floating point user parameters     *
C.    *    NUBUF                                                       *
C.    *                                                                *
C.    *  Output:                                                       *
C.    *    NT        track number (if=0 error).                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCPUSH.
      DIMENSION PLAB(3),BUF(1)
      SAVE JV
C.
C.    ------------------------------------------------------------------
C.
      IF(NV.LE.0)GO TO 10
      IF(NV.GT.NVERTX)GO TO 90
      JV = LQ(JVERTX- NV)
      IF(JV.LE.0)GO TO 90
C
   10 NT     = NTRACK + 1
      IF (JKINE.EQ.0)THEN
         CALL MZBOOK(IXDIV,JKINE,JKINE,1,'KINE',NCKINE,NCKINE,1,2,0)
         IQ(JKINE-5)=0
      ENDIF
      IF(NT.GT.IQ(JKINE-2)) CALL MZPUSH(IXDIV,JKINE,NPKINE,0,'I')
C
      CALL MZBOOK(IXDIV,JK,JKINE,-NT,'KINE',1,1,8,3,0)
C
      IF (JPART.LE.0) GO TO 90
      IF (IPART.GT.IQ(JPART-2)) GO TO 90
      JPA = LQ(JPART- IPART)
      IF (JPA.LE.0) GO TO 90
      P2     = PLAB(1)**2 + PLAB(2)**2 + PLAB(3)**2
      AMASS = Q(JPA + 7)
      E      = SQRT(P2 + AMASS*AMASS)
C
C            Store kinematics in JKINE
C
      Q(JK + 1) = PLAB(1)
      Q(JK + 2) = PLAB(2)
      Q(JK + 3) = PLAB(3)
      Q(JK + 4) = E
      Q(JK + 5) = IPART
      Q(JK + 6) = NV
C
C            Copy user words
C
      IF(NWBUF.GT.0)THEN
         CALL MZBOOK(IXDIV,JUK,JK,-1,'KINU',0,0,NWBUF,3,0)
         IQ(JUK-5)=NT
C
         DO 15 I=1,NWBUF
            Q(JUK+I)=BUF(I)
   15    CONTINUE
      ENDIF
C
C
C            Connect track NT to vertex NV
C
      IF(NV.GT.0)THEN
         JV = LQ(JVERTX- NV)
         NTG = Q(JV + 7)
         NFREE=IQ(JV-1)-7-NTG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JV,0,2,'I')
         Q(JV + NTG + 8) = NT
         Q(JV + 7) = NTG + 1
      ENDIF
C
      NTRACK = NT
      IQ(JKINE+1)=NTRACK
      GO TO 99
C
C            Error
C
  90  NT     = 0
  99  RETURN
      END
+DECK,  GSKINU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:19  cernlib
* Geant

      SUBROUTINE GSKINU (ITRA,NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in JKINE  user bank,          *
C     *       for track ITRA. (ITRA must be an already existing track) *
C     *       IADR is the stating location within the bank.            *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCFLAG.
*
      DIMENSION UBUF(1)
*
      IF ((JKINE.GT.0).AND.(LQ(JKINE-ITRA).GT.0)) THEN
*
         JK = LQ(JKINE-ITRA)
         NDATA = IADR + NWBUF
         IF (LQ(JK-1).EQ.0) THEN
            CALL MZBOOK (IXDIV,JKU,JK,-1,'KINU',0,0,NDATA,3,0)
            IQ(JKU-5) = ITRA
         ELSE
            JKU = LQ(JK-1)
            NFREE = IQ(JKU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXDIV,JKU,0,-NFREE,'I')
         ENDIF
*
         DO 10 I=1,NWBUF
            Q(JKU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
      ELSE
*
         IADR = 0
         WRITE(CHMAIL,1000) IEVENT,ITRA
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSKINU: No JKINE bank in memory for ievent:',I7,
     &       '   or track:',I4,'does not exist')
*
      END
+DECK,  GSVERT, T=FORT.
* Revision 1.2  1998/02/10 16:04:21  japost
*   Comments are correctly redistributed.
* Revision 1.1.1.1  1995/10/24 10:21:19  cernlib
* Geant

      SUBROUTINE GSVERT(V,NTBEAM,NTTARG,UBUF,NWBUF,NVTX)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Creates a new vertex bank                                *
C     *       Vertex is generated from tracks NTBEAM NTTARG            *
C     *       NVTX is the new vertex number                            *
C.    *                                                                *
C.    *                                                                *
C.    * In detail:                                                     *
C.    *                                                                *
C.    *  Stores vertex parameters.                                     *
C.    *                                                                *
C.    *  Input:                                                        *
C.    *    V         array of (x,y,z) position of the vertex           *
C.    *    NTBEAM    beam track number origin of the vertex            *
C.    *            =0 if none exists                                   *
C.    *    NTTARG    target track number origin of the vertex          *
C.    *    UBUF      user array of NUBUF floating point numbers        *
C.    *    NUBUF                                                       *
C.    *                                                                *
C.    *  Output:                                                       *
C.    *    NVTX      new vertex number (=0 in case of error).          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCPUSH.
+CDE, GCTRAK.
      DIMENSION V(3),UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      NVTX   = NVERTX + 1
      IF (JVERTX.EQ.0)THEN
         CALL MZBOOK(IXDIV,JVERTX,JVERTX,1,'VERT',NCVERT,NCVERT,1,2,0)
         IQ(JVERTX-5)=0
      ENDIF
      IF(NVTX.GT.IQ(JVERTX-2)) CALL MZPUSH(IXDIV,JVERTX,NPVERT,0,'I')
C
      CALL MZBOOK(IXDIV,JV,JVERTX,-NVTX,'VERT',1,1,9,3,0)
C
      IF(NWBUF.GT.0)THEN
         CALL MZBOOK(IXDIV,JUV,JV,-1,'VERU',0,0,NWBUF,3,0)
         IQ(JUV-5)=NVTX
         DO 3 I=1,NWBUF
   3     Q(JUV+I)=UBUF(I)
      ENDIF
      DO 4 I=1,3
   4  Q(JV + I) = V(I)
      Q(JV + 4) = TOFG
      Q(JV + 5) = NTBEAM
      Q(JV + 6) = NTTARG
      NTK=0
      IF(JKINE.GT.0)NTK=IQ(JKINE-2)
      IF(NTBEAM.GT.NTK)GO TO 90
      IF(NTBEAM.LT.0)GO TO 90
      IF(NTTARG.GT.NTK)GO TO 90
      IF(NTTARG.LT.0)GO TO 90
      IF(NTBEAM.NE.0)THEN
         JK = LQ(JKINE- NTBEAM)
         IF(JK.EQ.0)GO TO 90
         NVG = Q(JK + 7)
         NFREE=IQ(JK-1)-7-NVG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JK,0,2,'I')
         Q(JK + NVG + 8) = NVTX
         Q(JK + 7) = NVG + 1
      ENDIF
C
      IF(NTTARG.NE.0)THEN
         JK = LQ(JKINE- NTTARG)
         NVG = Q(JK + 7)
         NFREE=IQ(JK-1)-7-NVG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JK,0,2,'I')
         Q(JK + NVG + 8) = NVTX
         Q(JK + 7) = NVG + 1
      ENDIF
C
      NVERTX = NVTX
      IQ(JVERTX+1)=NVERTX
      GO TO 99
C
C             Error
C
  90  NVTX   = 0
  99  RETURN
      END
+DECK,  GSVERU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:19  cernlib
* Geant

      SUBROUTINE GSVERU (IVTX,NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in VERTEX user bank,          *
C     *       for vertex IVTX. (IVTX must be an already existing vertex)*
C     *       IADR is the stating location within the bank.            *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCFLAG.
*
      DIMENSION UBUF(1)
*
      IF ((JVERTX.GT.0).AND.(LQ(JVERTX-IVTX).GT.0)) THEN
*
         JV = LQ(JVERTX-IVTX)
         NDATA = IADR + NWBUF
         IF (LQ(JV-1).EQ.0) THEN
            CALL MZBOOK (IXDIV,JVU,JV,-1,'VERU',0,0,NDATA,3,0)
            IQ(JVU-5) = IVTX
         ELSE
            JVU = LQ(JV-1)
            NFREE = IQ(JVU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXDIV,JVU,0,-NFREE,'I')
         ENDIF
*
         DO 10 I=1,NWBUF
            Q(JVU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
      ELSE
*
         IADR = 0
         WRITE(CHMAIL,1000) IEVENT,IVTX
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSVERU: No Vertex bank in memory for ievent:',I7,
     &       '   or vertex:',I4,'does not exist')
*
      END
+DECK,  GTAU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:19  cernlib
* Geant

      SUBROUTINE GTAU
C.
C.    ******************************************************************
C.    *                                                                *
C.    *            Generates the process e+e- -> tau+ tau-             *
C.    *             can be called from GUKINE                          *
C.    *                                                                *
C.    *       Author    R.Hemingway  26 Sept 1985                      *
C.    *       Obsoleted in 3.15                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
      WRITE(CHMAIL,10000)
10000 FORMAT('Obsolete GTAU reached. This routine is now dummy.')
      CALL GMAIL(1,1)
C
      END
+PATCH, GIOPA.
+DECK,  GCLOSE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:16  cernlib
* Geant

      SUBROUTINE GCLOSE (LUN,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to close I/O units                               *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       IER      error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGLAST                               *
C.    *       Authors    R.Brun, F.Carena  *********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      IER=0
      IF(LUN.EQ.0)THEN
         CALL FZENDO(LUN,'T')
         CALL FZENDI(LUN,'T')
      ELSE
         DO 10 I=1,NUNITS
            IF(LUN.EQ.ABS(LUNITS(I)))THEN
               IF(LUNITS(I).LT.0)THEN
                  CALL FZENDI(LUN,'T')
               ELSE
                  CALL FZENDO(LUN,'T')
               ENDIF
               LUNITS(I)=0
               GOTO 999
            ENDIF
   10    CONTINUE
         IER=1
      ENDIF
  999 END
+DECK,  GFIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:16  cernlib
* Geant

      SUBROUTINE GFIN(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read GEANT object(s) fromin the FZ file       *
C.    *       The data structures from disk are read in memory         *
C.    *                                                                *
C.    *       LUN    Logical unit                                      *
C.    *                                                                *
C.    *       CHOBJ  The type of data structure to be read:            *
C.    *              MATE material                                     *
C.    *              TMED tracking medium                              *
C.    *              VOLU volumes                                      *
C.    *              ROTM rotation matrix                              *
C.    *              SETS detector set                                 *
C.    *              PART particle                                     *
C.    *              SCAN geometry                                     *
C.    *              INIT read all above                               *
C.    *              KINE this keyword will trigger the read of        *
C.    *                   KINE and VERT unless the flag 'S' is set     *
C.    *              DIGI digitisation                                 *
C.    *              DRAW drawing                                      *
C.    *              HEAD event header                                 *
C.    *              HITS hits                                         *
C.    *              RUNG run                                          *
C.    *              STAK particle temporary stack                     *
C.    *              STAT volume statistic                             *
C.    *              VERT vertex                                       *
C.    *              JXYZ track points                                 *
C.    *              TRIG this keyword will trigger the read of        *
C.    *                   DIGI, HEAD, HITS, KINE, VERT abd JXYZ        *
C.    *                   unless the 'S' flag is set                   *
C.    *                                                                *
C.    *       NKEYS  number of keys in vector CHOBJ                    *
C.    *                                                                *
C.    *       IDVERS version of the data structure to be read in       *
C.    *                                                                *
C.    *       CHOPT  List of options                                   *
C.    *                   'I'      read only initialisation data       *
C.    *                            structures                          *
C.    *                   'K'      read only KINE and TRIG data        *
C.    *                            structures                          *
C.    *                   'T'      read only DIGI, HEAD, HITS, KINE,   *
C.    *                            VERT and JXYZ data structures       *
C.    *              even if other keys are specified in CHOBJ         *
C.    *                                                                *
C.    *                   'S'       interpret KINE to mean only        *
C.    *                             KINE and TRIG and INIT to mean     *
C.    *                             nothing                            *
C.    *                   'Q'       quiet option, no message is        *
C.    *                             printed                            *
C.    *                                                                *
C.    *       IER    error flag. <0 ZEBRA error flag as returned in    *
C.    *                             IQUEST(1)                          *
C.    *                           0 read completed successfully        *
C.    *                          >0 if only IER structures read in     *
C.    *                                                                *
C.    *    The FZ data base has been created via GOPEN/GFOUT           *
C.    *                                                                *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GOPEN(1,'I',1024,IER)                                *
C.    *      CALL GFIN (1,'VOLU',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'MATE',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'TMED',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'ROTM',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'PART',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'SCAN',1,0,' ',IER)                          *
C.    *      CALL GFIN (1,'SETS',1,0,' ',IER)                          *
C.    *                                                                *
C.    *    ==>Called by : <USER> ,GOPEN                                *
C.    *       Author    F.Carminati *******                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCONSP.
+CDE, GCNUM.
+CDE, GCCUTS.
+CDE, GCSCAL.
+CDE, GCDRAW.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCTIME.
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),LINIT(NLINIT),LKINE(NLKINE)
      DIMENSION LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),IVERSI(NMKEY),LDIV(2),IRESUL(NMKEY)
      DIMENSION IDOLD(8), IDNEW(8), VEROLD(8), VERNEW(8)
      DIMENSION IUHEAD(2),ITRAN(23)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 KNAMES(NMKEY),CHOBJ(*)
      CHARACTER*(*) CHOPT
      DATA KNAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +     'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +     'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA ITRAN/7,6,13,16,8,10,2,9,8*0,3,15,5,17,4,1,21/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA IDNEW / 8*0 /
      DATA VERNEW / 8*0. /
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
      KVOL=JVOLUM
      IER=0
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTS=INDEX(CHOPT,'s')+INDEX(CHOPT,'S')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
*     Save old JRUNG dates and versions
      IF(JRUNG.GT.0) THEN
         DO 10 J=1,8
            IDOLD(J) = IQ(JRUNG+10+J)
            VEROLD(J) = Q(JRUNG+20+J)
   10    CONTINUE
      ENDIF
*
      NLINK=0
      DO 100 JKEY=1,NKEYS
         IF(IOPTS.EQ.0) THEN
         IF(CHOBJ(JKEY).EQ.'INIT') THEN
            DO 30 J=1, NLINIT
               DO 20  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LINIT(J)) GO TO 30
   20          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LINIT(J)
   30       CONTINUE
            GO TO 100
         ELSEIF(CHOBJ(JKEY).EQ.'TRIG') THEN
            DO 50 J=1, NLTRIG
               DO 40  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LTRIG(J)) GO TO 50
   40          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LTRIG(J)
   50       CONTINUE
            GO TO 100
         ELSEIF(CHOBJ(JKEY).EQ.'KINE') THEN
            DO 70 J=1, NLKINE
               DO 60  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LKINE(J)) GO TO 70
   60          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LKINE(J)
   70       CONTINUE
            GO TO 100
         ENDIF
         ENDIF
            DO 90 J=1,NMKEY
               IF(CHOBJ(JKEY).EQ.KNAMES(J)) THEN
                  DO 80 MLINK=1,NLINK
                     IF(LINK(MLINK).EQ.J) GO TO 100
   80             CONTINUE
                  NLINK=NLINK+1
                  LINK(NLINK)=J
                  GO TO 100
               ENDIF
   90       CONTINUE
            WRITE(CHMAIL,10300) CHOBJ(JKEY)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
  100 CONTINUE
*
      IF(IOPTI.GT.0) THEN
         DO 120 J=1, NLINK
            DO 110 K=1, NLINIT
               IF(LINK(J).EQ.LINIT(K)) GO TO 120
  110       CONTINUE
            WRITE(CHMAIL,10000) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  120    CONTINUE
      ELSEIF(IOPTK.GT.0) THEN
         DO 140 J=1, NLINK
            DO 130 K=1, NLKINE
               IF(LINK(J).EQ.LKINE(K)) GO TO 140
  130       CONTINUE
            WRITE(CHMAIL,10100) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  140    CONTINUE
      ELSEIF(IOPTT.GT.0) THEN
         DO 160 J=1, NLINK
            DO 150 K=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(K)) GO TO 160
  150       CONTINUE
            WRITE(CHMAIL,10200) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  160    CONTINUE
      ENDIF
      IOFF=0
      DO 170 J=1, NLINK
         IF(LINK(J).EQ.0) THEN
            IOFF=IOFF-1
         ELSE
            LINK(J+IOFF)=LINK(J)
         ENDIF
  170 CONTINUE
      NLINK=NLINK+IOFF
      NPOS=0
      DO 171 JL=1,NLINK
         IF(LINK(JL).EQ.9.OR.LINK(JL).EQ.3) THEN
            NPOS=JL
            GOTO 172
         ENDIF
  171 CONTINUE
  172 CONTINUE
*
      IF(NLINK.LE.0) THEN
         WRITE(CHMAIL,10400)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
         GOTO 999
      ENDIF
*
      IF(IOPTI+IOPTK+IOPTT.EQ.0) THEN
*
*        We have to choose which event header to read, JRUNG or JHEAD
*        If the banks list contains banks depending from both headers,
*        the result is unpredictable. Error message to be inserted later.
         DO 168 J=1, NLINK
            DO 161 L=1, NLINIT
               IF(LINK(J).EQ.LINIT(L)) THEN
                  IOPTI=-1
                  GOTO 169
               ENDIF
  161       CONTINUE
            DO 162 L=1, NLKINE
               IF(LINK(J).EQ.LKINE(L)) THEN
                  IOPTK=-1
                  GOTO 169
               ENDIF
  162       CONTINUE
            DO 163 L=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(L)) THEN
                  IOPTT=-1
                  GOTO 169
               ENDIF
  163       CONTINUE
  168    CONTINUE
  169    CONTINUE
      ENDIF
*
      DO 180 J=1, NLINK
         IVERSI(J)=0
         IRESUL(J)=0
  180 CONTINUE
*
*               Go for next start of event data structure
  190 IF(IOPTI.NE.0) THEN
         IF(JRUNG.NE.0)CALL MZDROP(IXCONS,JRUNG,' ')
         NUH=2
         CALL FZIN(LUN,IXCONS,JRUNG,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GE.2) THEN
            IER = -IQUEST(1)
            GO TO 240
         ENDIF
         IF(NPOS.NE.0) THEN
            IVERSI(NPOS)=IUHEAD(1)
            IRESUL(NPOS)=1
         ENDIF
      ELSEIF(IOPTT+IOPTK.NE.0) THEN
         IF(JHEAD.NE.0)CALL MZDROP(IXDIV,JHEAD,' ')
         NUH=2
         CALL FZIN(LUN,IXDIV,JHEAD,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GE.2) THEN
            IER = -IQUEST(1)
            GO TO 240
         ENDIF
         IF(NPOS.NE.0) THEN
            IVERSI(NPOS)=IUHEAD(1)
            IRESUL(NPOS)=1
         ENDIF
      ENDIF
*
      IVERIN = IUHEAD(1)
      IF(IDVERS.NE.0.AND.IDVERS.NE.IVERIN) THEN
         DO 200 I=1,NLINK
            LINK(I)=-ABS(LINK(I))
  200    CONTINUE
         GOTO 190
      ELSE
         IF (IDVERS .EQ. 0) IDVERS = IVERIN
         DO 210 I=1,NLINK
            LINK(I)= ABS(LINK(I))
  210    CONTINUE
      ENDIF
      NK   = IUHEAD(2)
      IF(NK.GT.10) THEN
         WRITE(CHMAIL,11100) NK
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
         GO TO 999
      ENDIF
      DO 230 IK=1,NK
C
C              Read next header
C
         NUH=2
         CALL FZIN(LUN,0,0,0,'S',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 320
         IKEY=ITRAN(IUHEAD(1))
         DO 220 I=1,NLINK
            NKEY=LINK(I)
            IF(IKEY.EQ.NKEY)THEN
               IDIV=LDIV(IXD(NKEY))
               IF(NKEY.LE.20)THEN
                  IF(JNAMES(NKEY).NE.0)THEN
                     CALL MZDROP(IDIV,JNAMES(NKEY),'L')
                     JNAMES(NKEY)=0
                  ENDIF
                  CALL FZIN(LUN,IDIV,JNAMES(NKEY),1,'A',NUH,IUHEAD)
               ELSE
                  NKL=NKEY-20
                  IF(ISLINK(NKL).NE.0)THEN
                     CALL MZDROP(IDIV,ISLINK(NKL),'L')
                     ISLINK(NKL)=0
                  ENDIF
                  CALL FZIN(LUN,IDIV,ISLINK(NKL),1,'A',NUH,IUHEAD)
               ENDIF
               IF(IQUEST(1).LE.2.AND.IQUEST(1).GE.0) THEN
                  IVERSI(I)=IVERIN
                  IRESUL(I)=1
                  GOTO 230
               ELSE
                  GOTO 320
               ENDIF
            ENDIF
  220    CONTINUE
  230 CONTINUE
*
  240 NIN=0
      DO 250 I=1,NLINK
         IF(IRESUL(I).EQ.1) THEN
            WRITE(CHMAIL,10500) KNAMES(LINK(I)), IVERSI(I)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            NIN=NIN+1
         ELSEIF(LINK(I).GT.0) THEN
            WRITE(CHMAIL,10600) KNAMES(LINK(I))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         ELSEIF(LINK(I).LT.0) THEN
            WRITE(CHMAIL,10700) KNAMES(-LINK(I)), IDVERS
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         ENDIF
  250 CONTINUE
*
      IF(NIN.EQ.0) THEN
         WRITE(CHMAIL,10800)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IF(IER.GE.0) IER=-1
         GOTO 999
      ELSEIF(NIN.LT.NLINK) THEN
         IER=NIN
      ENDIF
*
      IF(KVOL.NE.JVOLUM)THEN
         NVOLUM=IQ(JVOLUM-1)
         CALL MZGARB(IXCONS,0)
         CALL GGDVLP
         CALL GGNLEV
      ENDIF
*
      IF(JVOLUM.GT.0) THEN
         NLEVEL=0
         NVOLUM=0
         DO 260 J=1, IQ(JVOLUM-2)
            IF(LQ(JVOLUM-J).EQ.0) GOTO 270
            NVOLUM=NVOLUM+1
  260    CONTINUE
  270    CONTINUE
      ENDIF
*
      IF(JTMED.NE.0 )THEN
         CALL UCOPY(Q(JTMED+1),CUTGAM,10)
         NTMED=IQ(JTMED-2)
      ENDIF
*
      IF(JPART.NE.0 ) NPART = IQ(JPART-2)
      IF(JVERTX.NE.0) NVERTX = IQ(JVERTX+1)
      IF(JKINE.NE.0) NTRACK = IQ(JKINE+1)
      IF(JMATE.NE.0 ) NMATE = IQ(JMATE-2)
      IF(JROTM.NE.0 ) NROTM = IQ(JROTM-2)
      IF(JDRAW.GT.0 ) THEN
         NKVIEW = IQ(JDRAW-2)
      ELSE
         NKVIEW = 0
C
C             Book JDRAW structure for view banks
C
         CALL MZBOOK(IXCONS,JDRAW,JDRAW,1,'DRAW',0,0,0,3,0)
      ENDIF

C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
      IF(JRUNG.GT.0) THEN
*
*             Here we deal with version numbers If JRUNG has been read in,
*             then save the version numbers of the new JRUNG and restore
*             the current version number for KINE, HITS and DIGI
         DO 300 J=1, NLINK
            IF(IVERSI(J).GT.0) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'RUNG') THEN
                  DO 280 I=1,8
                     IDNEW(I) = IQ(JRUNG+10+I)
                     VERNEW(I) = Q(JRUNG+20+I)
  280             CONTINUE
*
*             And we put back the old version numbers because,
*             in principle, KINE, HITS and DIGI have not be read in
                  DO 290 I=3,8
                     IQ(JRUNG+10+I) = IDOLD(I)
                     Q(JRUNG+20+I) = VEROLD(I)
  290             CONTINUE
               ENDIF
            ENDIF
  300    CONTINUE
*
*            And here we do it again for KINE, HITS and DIGI
         DO 310 J=1, NLINK
            IF(IVERSI(J).GT.0) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'KINE') THEN
                  IF(IDNEW(3).GT.0) THEN
                     IQ(JRUNG+13) = IDNEW(3)
                     IQ(JRUNG+14) = IDNEW(4)
                     Q(JRUNG+23) = VERNEW(3)
                     Q(JRUNG+24) = VERNEW(4)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'HITS') THEN
                  IF(IDNEW(5).GT.0) THEN
                     IQ(JRUNG+15) = IDNEW(5)
                     IQ(JRUNG+16) = IDNEW(6)
                     Q(JRUNG+25) = VERNEW(5)
                     Q(JRUNG+26) = VERNEW(6)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'DIGI') THEN
                  IF(IDNEW(7).GT.0) THEN
                     IQ(JRUNG+17) = IDNEW(7)
                     IQ(JRUNG+18) = IDNEW(8)
                     Q(JRUNG+27) = VERNEW(7)
                     Q(JRUNG+28) = VERNEW(8)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'MATE'.OR. KNAMES(NKEY) .EQ.'TMED'
     +         ) THEN
                  IF(VERNEW(1).NE.0) THEN
*                We know which version number we are reading
                     IF(VERNEW(1).LT.GVERSN) THEN
                        WRITE(CHMAIL,10900) KNAMES(NKEY),VERNEW(1),
     +                  GVERSN
                        IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
                        WRITE(CHMAIL,11000)
                        IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
  310    CONTINUE
      ENDIF
  320 CONTINUE
*
10000 FORMAT(' *** GFIN *** Key ',A4,' ignored for initialization')
10100 FORMAT(' *** GFIN *** Key ',A4,' ignored for kinematics')
10200 FORMAT(' *** GFIN *** Key ',A4,' ignored for trigger')
10300 FORMAT(' *** GFIN *** Unknown key ',A4)
10400 FORMAT(' *** GFIN *** No valid key given')
10500 FORMAT(' *** GFIN *** Data structure ',A4,' version ',I10,
     +       ' successfully read in ')
10600 FORMAT(' *** GFIN *** Data structure ',A4,' was not found')
10700 FORMAT(' *** GFIN *** Data structure ',A4,' version ',I10,
     +       ' was not found')
10800 FORMAT(' *** GFIN *** Nothing found to read !')
10900 FORMAT(' *** GFIN *** ',A4,' data structure ',
     +       'version ',F6.4,' current version is ',F6.4)
11000 FORMAT('              Please call subroutine GPHYSI before ',
     +       'tracking')
11100 FORMAT(' *** GFIN ***  Illegal number of links ',I10)
  999 END
+DECK,  GFOUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:16  cernlib
* Geant

      SUBROUTINE GFOUT(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write GEANT object(s) into the FZ file        *
C.    *       The data structures in memory are written on disk        *
C.    *                                                                *
C.    *       LUN    Logical unit                                      *
C.    *                                                                *
C.    *       CHOBJ  The type of data structure to be written:         *
C.    *              MATE material                                     *
C.    *              TMED tracking medium                              *
C.    *              VOLU volumes                                      *
C.    *              ROTM rotation matrix                              *
C.    *              SETS detector set                                 *
C.    *              PART particle                                     *
C.    *              SCAN geometry                                     *
C.    *              INIT all above                                    *
C.    *              KINE this keyword will trigger the write of       *
C.    *                   KINE and VERT unless the flag 'S' is set     *
C.    *              DIGI digitisation                                 *
C.    *              DRAW drawing                                      *
C.    *              HEAD event header                                 *
C.    *              HITS hits                                         *
C.    *              RUNG run                                          *
C.    *              STAK particle temporary stack                     *
C.    *              STAT volume statistic                             *
C.    *              VERT vertex                                       *
C.    *              JXYZ track points                                 *
C.    *              TRIG this keyword will trigger the write of       *
C.    *                   DIGI, HEAD, HITS, KINE, VERT abd JXYZ        *
C.    *                   unless the 'S' flag is set                   *
C.    *                                                                *
C.    *       NKEYS  number of keys in vector CHOBJ                    *
C.    *                                                                *
C.    *       IDVERS version of the data structure to be written out   *
C.    *                                                                *
C.    *       CHOPT  List of options                                   *
C.    *                   'I'      write only initialisation data      *
C.    *                            structures                          *
C.    *                   'K'      write only KINE and TRIG data       *
C.    *                            structures                          *
C.    *                   'T'      write only DIGI, HEAD, HITS, KINE,  *
C.    *                            VERT and JXYZ data structures       *
C.    *              even if other keys are specified in CHOBJ         *
C.    *                                                                *
C.    *                   'S'       interpret KINE to mean only        *
C.    *                             KINE and TRIG and INIT to mean     *
C.    *                             nothing                            *
C.    *                   'Q'       quiet option, no message is        *
C.    *                             printed                            *
C.    *                                                                *
C.    *       IER    error flag. <0 ZEBRA error flag as returned in    *
C.    *                             IQUEST(1)                          *
C.    *                           0 read completed successfully        *
C.    *                          >0 if only IER structures read in     *
C.    *                                                                *
C.    *    The FZ data base can be read in via GOPEN/GFIN              *
C.    *                                                                *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GOPEN(1,'O',1024,IER)                                *
C.    *      CALL GFOUT (1,'VOLU',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'MATE',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'TMED',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'ROTM',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'PART',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'SCAN',1,0,' ',IER)                         *
C.    *      CALL GFOUT (1,'SETS',1,0,' ',IER)                         *
C.    *                                                                *
C.    *    ==>Called by : <USER> ,GOPEN                                *
C.    *       Author    F.Carminati *******                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCONSP.
+CDE, GCNUM.
+CDE, GCCUTS.
+CDE, GCSCAL.
+CDE, GCDRAW.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCTIME.
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),LINIT(NLINIT),LKINE(NLKINE)
      DIMENSION LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),IVERSI(NMKEY),LDIV(2),IRESUL(NMKEY)
      DIMENSION IUHEAD(2),ITRAN(23),JTRAN(23)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 KNAMES(NMKEY),CHOBJ(*)
      CHARACTER*(*) CHOPT
      DATA KNAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +     'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +     'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA ITRAN/7,6,13,16,8,10,2,9,8*0,3,15,5,17,4,1,21/
      DATA JTRAN/22,7,17,21,19,2,1,5,8,6,2*0,3,0,18,4,20,3*0,23,2*0/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      IER=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTS=INDEX(CHOPT,'s')+INDEX(CHOPT,'S')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
      NLINK=0
      DO 90  JKEY=1,NKEYS
         IF(IOPTS.EQ.0) THEN
         IF(CHOBJ(JKEY).EQ.'INIT') THEN
            DO 20 J=1, NLINIT
               DO 10  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LINIT(J)) GO TO 20
   10          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LINIT(J)
   20       CONTINUE
            GO TO 90
         ELSEIF(CHOBJ(JKEY).EQ.'TRIG') THEN
            DO 40 J=1, NLTRIG
               DO 30  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LTRIG(J)) GO TO 40
   30          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LTRIG(J)
   40       CONTINUE
            GO TO 90
         ELSEIF(CHOBJ(JKEY).EQ.'KINE') THEN
            DO 60 J=1, NLKINE
               DO 50  MLINK=1,NLINK
                  IF(LINK(MLINK).EQ.LKINE(J)) GO TO 60
   50          CONTINUE
               NLINK=NLINK+1
               LINK(NLINK)=LKINE(J)
   60       CONTINUE
            GO TO 90
         ENDIF
         ENDIF
            DO 80 J=1,NMKEY
               IF(CHOBJ(JKEY).EQ.KNAMES(J)) THEN
                  DO 70 MLINK=1,NLINK
                     IF(LINK(MLINK).EQ.J) GO TO 90
   70             CONTINUE
                  NLINK=NLINK+1
                  LINK(NLINK)=J
                  GO TO 90
               ENDIF
   80       CONTINUE
            WRITE(CHMAIL,10300) CHOBJ(JKEY)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
   90 CONTINUE
*
      IF(IOPTI.GT.0) THEN
         DO 110 J=1, NLINK
            DO 100 K=1, NLINIT
               IF(LINK(J).EQ.LINIT(K)) GO TO 110
  100       CONTINUE
            WRITE(CHMAIL,10000) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  110    CONTINUE
      ELSEIF(IOPTK.GT.0) THEN
         DO 130 J=1, NLINK
            DO 120 K=1, NLKINE
               IF(LINK(J).EQ.LKINE(K)) GO TO 130
  120       CONTINUE
            WRITE(CHMAIL,10100) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  130    CONTINUE
      ELSEIF(IOPTT.GT.0) THEN
         DO 150 J=1, NLINK
            DO 140 K=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(K)) GO TO 150
  140       CONTINUE
            WRITE(CHMAIL,10200) KNAMES(LINK(J))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            LINK(J)=0
  150    CONTINUE
      ENDIF
*
      IOFF=0
      DO 160 J=1, NLINK
         IF(LINK(J).EQ.0) THEN
           IOFF=IOFF-1
         ELSE
           LINK(J+IOFF)=LINK(J)
         ENDIF
  160 CONTINUE
      NLINK=NLINK+IOFF
      IF(IOPTI+IOPTK+IOPTT.EQ.0) THEN
*
*        We have to choose which event header to write, JRUNG or JHEAD
*        If the banks list contains banks which depends on both headers,
*        the result is unpredictable. Error message to be inserted later.
         DO 168 J=1, NLINK
            DO 161 L=1, NLINIT
               IF(LINK(J).EQ.LINIT(L)) THEN
                  IOPTI=-1
                  GOTO 169
               ENDIF
  161       CONTINUE
            DO 162 L=1, NLKINE
               IF(LINK(J).EQ.LKINE(L)) THEN
                  IOPTK=-1
                  GOTO 169
               ENDIF
  162       CONTINUE
            DO 163 L=1, NLTRIG
               IF(LINK(J).EQ.LTRIG(L)) THEN
                  IOPTT=-1
                  GOTO 169
               ENDIF
  163      CONTINUE
  168    CONTINUE
  169    CONTINUE
      ENDIF
*
      IF(NLINK.LE.0) THEN
         WRITE(CHMAIL,10400)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
         GOTO 999
      ENDIF
*
      NWOUT=0
      IOFW =0
      DO 170 J=1,NLINK
         IVERSI(J)=0
         IRESUL(J)=0
         NKEY=LINK(J)
         IF(NKEY.EQ.3.OR.NKEY.EQ.9) THEN
            IOFW=1
            NPOS=J
         ENDIF
         LINK(J)=-ABS(LINK(J))
         IF(NKEY.LE.20)THEN
            IF(JNAMES(NKEY).NE.0) THEN
               LINK(J)=ABS(LINK(J))
               NWOUT=NWOUT+1
            ENDIF
         ELSE
            NKL=NKEY-20
            IF(ISLINK(NKL).NE.0) THEN
               LINK(J)=ABS(LINK(J))
               NWOUT=NWOUT+1
            ENDIF
         ENDIF
  170 CONTINUE
*
*               Write next start of event data structure
      IUHEAD(1)=IDVERS
      IUHEAD(2)=NWOUT-IOFW
      NUH=2
      IF(IOPTI.NE.0) THEN
         CALL FZOUT(LUN,IXCONS,JRUNG,1,'L',2,NUH,IUHEAD)
      ELSEIF(IOPTT+IOPTK.NE.0) THEN
         CALL FZOUT(LUN,IXDIV,JHEAD,1,'L',2,NUH,IUHEAD)
      ENDIF
      IF(IQUEST(1).EQ.0) THEN
         IVERSI(NPOS)=IDVERS
         IRESUL(NPOS)=1
      ELSE
         WRITE(CHMAIL,10500) KNAMES(LINK(NPOS))
      ENDIF
*
      DO 180 IK=1,NLINK
*
*              Write selected data structures
         NKEY=LINK(IK)
         IF(NKEY.GT.0) THEN
            IF(NKEY.EQ.9) THEN
               GOTO 180
            ELSEIF(NKEY.EQ.3) THEN
               GOTO 180
            ELSEIF(NKEY.EQ.1) THEN
               CALL GRLEAS(JDIGI)
            ELSEIF(NKEY.EQ.4) THEN
               CALL GRLEAS(JHITS)
            ENDIF
            IDIV=LDIV(IXD(NKEY))
            JKEY=JTRAN(NKEY)
            IF(NKEY.LE.20)THEN
               CALL FZOUT(LUN,IDIV,JNAMES(NKEY),0,'L',2,1,JKEY)
            ELSE
               NKL=NKEY-20
               CALL FZOUT(LUN,IDIV,ISLINK(NKL),0,'L',2,1,JKEY)
            ENDIF
            IF(IQUEST(1).EQ.0) THEN
               IVERSI(IK)=IDVERS
               IRESUL(IK)=1
            ELSE
               WRITE(CHMAIL,10500) KNAMES(NKEY)
            ENDIF
         ENDIF
  180 CONTINUE
*
      NOUT=0
      DO 190 I=1,NLINK
         IF(IRESUL(I).EQ.1) THEN
            WRITE(CHMAIL,10600) KNAMES(ABS(LINK(I))),IVERSI(I)
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
            NOUT=NOUT+1
         ELSE
            WRITE(CHMAIL,10700) KNAMES(ABS(LINK(I)))
            IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         ENDIF
  190 CONTINUE
*
      IF(NOUT.LE.0) THEN
         WRITE(CHMAIL,10800)
         IF(IOPTQ.EQ.0) CALL GMAIL(0,0)
         IER=-1
      ELSEIF(NOUT.LT.NLINK) THEN
         IER=NOUT
      ENDIF
*
10000 FORMAT(' *** GFOUT *** Key ',A4,' ignored for initialization')
10100 FORMAT(' *** GFOUT *** Key ',A4,' ignored for kinematics')
10200 FORMAT(' *** GFOUT *** Key ',A4,' ignored for trigger')
10300 FORMAT(' *** GFOUT *** Unknown key ',A4)
10400 FORMAT(' *** GFOUT *** No valid key given')
10500 FORMAT(' *** GFOUT *** Problems writing data structure ',A4)
10600 FORMAT(' *** GFOUT *** Data structure ',A4,' version ',I10,
     +       ' successfully written out')
10700 FORMAT(' *** GFOUT *** Data structure ',A4,' not found')
10800 FORMAT(' *** GFOUT *** Nothing written out !')
  999 END
+DECK,  GGET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:16  cernlib
* Geant

      SUBROUTINE GGET (LUN,KEYSU,NUKEYS,IDENT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read in data structures                       *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       KEYSU    Keywords to select data structures              *
C.    *       NKEYS    Number of keywords                              *
C.    *       IER      Error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUKINE                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCDRAW.
+CDE, GCCUTS.
      COMMON/QUEST/IQUEST(100)
C
      CHARACTER*4 KLEY(22)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYS(22),IUHEAD(2)
      DIMENSION KSEL(14),LKEY(22),LKNUM(22),LINK(14),JLINK(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      SAVE IFIRST,LKEY
      DATA LINK/7,6,13,16,8,10,2,9,3,15,5,17,4,1/
      DATA KLEY/'PART','MATE','TMED','VOLU','ROTM','SETS','DRAW','RUNG'
     +         ,'INIT','INIT','INIT','INIT','INIT','INIT','INIT','INIT'
     +         ,'HEAD','KINE','KINE','JXYZ','HITS','DIGI'/
      DATA LKNUM/1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,10,11,12,13,14/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,88)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GGET *** Obsolete routine. Please use GFIN')
C
      IDENT=-1
      IER    = 0
      NKEYS=IABS(NUKEYS)
      IF (NKEYS.LE.0)                                 GO TO 99
      CALL UCTOH(KEYSU,KEYS,4,4*NKEYS)
C
      IF(NUKEYS.LT.0)THEN
        I1=1
        I2=15
        K1=1
        K2=7
      ELSE
        I1=18
        I2=22
        K1=10
        K2=14
      ENDIF
C
      NKT=0
      DO 10 K=K1,K2
  10  KSEL(K)=0
      DO 20 I=I1,I2
      N=LKNUM(I)
      DO 20 IK=1,NKEYS
      IF(KEYS(IK).EQ.LKEY(I))THEN
         KSEL(N)=1
         NKT=NKT+1
      ENDIF
  20  CONTINUE
      IF(NKT.EQ.0)GO TO 99
      NUH=2
C
C               Go for next start of event data structure
C
      IF(NUKEYS.LT.0)THEN
         IF(JRUNG.NE.0)CALL MZDROP(IXCONS,JRUNG,' ')
         CALL FZIN(LUN,IXCONS,JRUNG,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
         IDIV=IXCONS
      ELSE
         IF(JHEAD.NE.0)CALL MZDROP(IXDIV,JHEAD,' ')
         CALL FZIN(LUN,IXDIV,JHEAD,1,'E',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
         IDIV=IXDIV
      ENDIF
C
      IDENT= IUHEAD(1)
      NK   = IUHEAD(2)
      IF(NK.LE.0)GO TO 99
      IF(NK.GT.10)GO TO 99
      DO 30 I=1,NK
C
C              Read next header
C
         NUH=2
         CALL FZIN(LUN,IDIV,0,0,'S',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
         KS=IUHEAD(1)
         IF(KS.LE.0)GO TO 30
         IF(KS.GT.14)GO TO 30
         IF(KSEL(KS).EQ.0)GO TO 30
         IL=LINK(KS)
         IF(JLINK(IL).NE.0)CALL MZDROP(IDIV,JLINK(IL),' ')
C
C              Read pending data structure
C
         CALL FZIN(LUN,IDIV,JLINK(IL),1,'A',NUH,IUHEAD)
         IF(IQUEST(1).GT.2)GO TO 90
  30  CONTINUE
C
C             Fill header bank
C             Reconstruct NKVIEW,NVOLUM,NVERTX,NTRACK
C             Reconstruct NMATE, NTMED, NPART
C
      IF(NUKEYS.LT.0)THEN
         IF(KSEL(1).NE.0.AND.JPART.GT.0) NPART=IQ(JPART-2)
         IF(KSEL(2).NE.0.AND.JMATE.NE.0) NMATE=IQ(JMATE-2)
         IF(KSEL(3).NE.0.AND.JTMED.NE.0) THEN
            CALL UCOPY(Q(JTMED+1),CUTGAM,10)
            NTMED=IQ(JTMED-2)
         ENDIF
         IF(KSEL(4).NE.0.AND.JVOLUM.GT.0) THEN
            NVOLUM=0
            DO 40 J=1, IQ(JVOLUM-2)
               IF(LQ(JVOLUM-J).EQ.0) GO TO 50
               NVOLUM=NVOLUM+1
  40        CONTINUE
  50        CONTINUE
         END IF
         IF(KSEL(7).NE.0.AND.JDRAW.GT.0) NKVIEW=IQ(JDRAW-2)
      ENDIF
C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
C
      IF(KSEL(10).GT.0)THEN
         NVERTX=0
         NTRACK=0
         IF(JVERTX.GT.0)NVERTX=IQ(JVERTX+1)
         IF(JKINE .GT.0)NTRACK=IQ(JKINE +1)
      ENDIF
      GO TO 99
C
C             Error, EOF,etc
C
  90  IER=IQUEST(1)
C
  99  RETURN
      END
+DECK,  GIOPA_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:21:16  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                       The I/O service routines                       *
*                       ------------------------                       *
*                                                                      *
*  The  I/O routines  permit  to  read and  write,  the GEANT3  data   *
* structures.   The  possibility  exists  to  write  and  read  data   *
* structures to/from  direct access  files, in machine  dependent or   *
* independent format  and to/from direct  access files.  All  I/O is   *
* done via the  ZEBRA I/O routines both for direct  access files (FZ   *
* package) and for direct access files (RZ package).                   *
*  Data can  be generated on one  type of machine, for  example full   *
* detector simulation,  and the data  produced can be analyzed  on a   *
* different machine.                                                   *
*  The data structures written to tape or disk can be read either in   *
* whole or in part.                                                    *
*                                                                      *
*                                                                      *
*                     Routines to perform I/O                          *
*                     -----------------------                          *
*                                                                      *
*       CALL GCLOSE(LUN, IER)                                          *
*                                                                      *
*   LUN       Logical unit number                                      *
*   IER       Error flag                                               *
*                                                                      *
*  Close sequential  FZ file open  with logical unit LUN.   If LUN=0   *
* close all  FZ files.  IER=1  if the file is  no FZ file  open with   *
* logical unit LUN is found, 0 otherwise.                              *
*                                                                      *
*      CALL GFIN(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)                     *
*                                                                      *
*   LUN       Logical unit number                                      *
*   CHOBJ     CHARACTER*4 array containing the data structures to be   *
*             read (DIGI,DRAW,HEAD,HITS,KINE,MATE,PART,ROTM,RUNG,      *
*             SETS,STAK,STAT,TMED,VERT,VOLU,JXYZ,SCAN). In addition    *
*             the following keywords are defined:                      *
*             INIT = DRAW,MATE,PART,ROTM,RUNG,SETS,TMED,VOLU,SCAN      *
*             KINE = KINE,VERT                                         *
*             TRIG = DIGI,HEAD,HITS,KINE,VERT,JXYZ                     *
*   NKEYS     Number of valid elements in the array CHOBJ              *
*   IDVERS    Version to be retrieved. If IDVERS=0 the first version   *
*             found will be retrieved.                                 *
*   CHOPT     Character option.                                        *
*   IER       Error flag. -1 if nothing has been read in. >0  in not   *
*             all the requested data structures have been read in.     *
*                                                                      *
*                                                                      *
*                                                                      *
*  Routine  to  read GEANT  object(s)  from    a  FZ file  The  data   *
* structures from disk are read in memory.                             *
*                                                                      *
*      CALL GFOUT(LUN,CHOBJ,NKEYS,IDVERS,CHOPT,IER)                    *
*                                                                      *
*  See above for  the parameters.  Routine to  write GEANT object(s)   *
* into a  FZ file  The data  structures are  written from  memory to   *
* disk.                                                                *
*                                                                      *
*      CALL GOPEN(LUN,LUNTYP,LEN,IER)                                  *
*                                                                      *
*   LUN       Logical unit                                             *
*   LUNTYP    CHARACTER variable specifying the format of the FZ       *
*             file. Possible options are I,O,A,X. See the FZ manual    *
*             for more information.                                    *
*   LEN       Logical record length of the FZ file.                    *
*   IER       Error flag. 0 if file has been open correctly.           *
*                                                                      *
*  Routine to open a FZ file for input or output.                      *
*                                                                      *
*      CALL GREND (LUN)                                                *
*                                                                      *
*    LUN      Logical unit                                             *
*                                                                      *
*  Routine to close the RZ direct access file opened with logical      *
* unit LUN.                                                            *
*                                                                      *
*      CALL GRFILE(LUN,CHFILE,CHOPTT)                                  *
*                                                                      *
*    LUN      Logical unit number                                      *
*    CHFILE   Name of the file to be open                              *
*    CHOPTT   Character option                                         *
*                                                                      *
*  Routine to open an  RZ file for input or output.   If option I is   *
* given, then  the INIT data structures  will be read from  the file   *
* and if the option O is given they will be written to the file.       *
*                                                                      *
*      CALL GRIN(CHOBJT,IDVERS,CHOPT)                                  *
*                                                                      *
*   CHOBJT    CHARACTER*4 variable with the name of the data           *
*             structure to be retrieved. See GFIN for more details.    *
*   IDVERS    Version of the data structure to be retrieved. If 0      *
*             the first found data structure will be retrieved.        *
*   CHOPT     Option variable                                          *
*                                                                      *
*  Routine  to  read  from  a  RZ  direct  access  file  GEANT  data   *
* structures.                                                          *
*                                                                      *
*      CALL GRLEAS(JBANK)                                              *
*                                                                      *
*   JBANK     Pointer to a data structure                              *
*                                                                      *
*  Routine to release unused space  in the data structure pointed to   *
* by JBANK.                                                            *
*                                                                      *
*      CALL GRMDIR(CHDIR,CHOPT)                                        *
*                                                                      *
*    CHDIR    Name of the directory                                    *
*    CHOPT    Character option                                         *
*                                                                      *
*  Routine to create a GEANT subdirectory in an RZ file.               *
*                                                                      *
*      CALL GROUT(CHOBJT,IDVERS,CHOPT)                                 *
*                                                                      *
*  Routine  to  write  to  a   RZ  direct  access  file  GEANT  data   *
* structures.  See GRIN for explanations on the parameters.            *
*                                                                      *
************************************************************************
#endif
+DECK,  GOPEN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GOPEN (LUN,LUNTYP,LEN,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to open I/O units                                *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       LUNTYP   ZEBRA flag    I,O,X  (must be CHARACTER)        *
C.    *                'I' LUN is an INPUT file                        *
C.    *                'O' LUN is an OUTPUT file                       *
C.    *                'X' LUN is in exchange mode format              *
C.    *       LEN      Buffer length (see FZFILE)                      *
C.    *       IER      error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
      CHARACTER*(*) LUNTYP
C.
C.    ------------------------------------------------------------------
C.
      IF (NUNITS.LT.5)THEN
         CALL FZFILE(LUN,LEN,LUNTYP)
         NUNITS = NUNITS + 1
         LUNITS(NUNITS) = LUN
         IF(INDEX(LUNTYP,'I').NE.0)LUNITS(NUNITS)=-LUN
         IER    = 0
      ELSE
         IER    = 1
      ENDIF
C
      END
+DECK,  GREND, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GREND (LUN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to close an RZ file                              *
C.    *                                                                *
C.    *       CHDIR    Top directory name of the file                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*5 CHDIR
C.
C.    ------------------------------------------------------------------
C.
      IF(LUN.LT.10) THEN
         WRITE(CHDIR,'(''LUN'',I1)') LUN
      ELSE
         WRITE(CHDIR,'(''LUN'',I2)') LUN
      ENDIF
      CALL RZEND(CHDIR)
C
      END
+DECK,  GRFILE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GRFILE(LUN,CHFILE,CHOPTT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to open a GEANT/RZ data base.                    *
C.    *                                                                *
C.    *       LUN logical unit number associated to the file           *
C.    *                                                                *
C.    *       CHFILE RZ file name                                      *
C.    *                                                                *
C.    *       CHOPT is a character string which may be                 *
C.    *          'N' To create a new file                              *
C.    *          'U' to open an existing file for update               *
C.    *          ' ' to open an existing file for read only            *
C.    *          'Q' The initial allocation (default 1000 records)     *
C.    *              is given in IQUEST(10)                            *
C.    *          'X' Open the file in exchange format                  *
C.    *          'I' Read all data structures from file to memory      *
C.    *          'O' Write all data structures from memory to file     *
C.    *                                                                *
C.    *    Note:                                                       *
C.    *         If options 'I' or 'O' all data structures are read or  *
C.    *            written from/to file and the file is closed.        *
C.    *         See routine GRMDIR to create subdirectories            *
C.    *         See routines GROUT,GRIN to write,read objects          *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      COMMON/QUEST/IQUEST(100)
      CHARACTER*(*) CHFILE,CHOPTT
      CHARACTER*8 CHOPT,CHTOP,CHTAGS(2)
      CHARACTER*10 CHOPT1,CHOPT2
      SAVE CHTAGS,CHTOP
      DATA CHTAGS,CHTOP/'Object','Version','        '/
C.
C.    ------------------------------------------------------------------
C.
*
      CHOPT=CHOPTT
      CALL CLTOU(CHOPT)
      IOPTN=INDEX(CHOPT,'N')
      IOPTU=INDEX(CHOPT,'U')
      IOPTQ=INDEX(CHOPT,'Q')
      IOPTI=INDEX(CHOPT,'I')
      IOPTO=INDEX(CHOPT,'O')
      IF(IOPTN.EQ.0.AND.IOPTU.EQ.0)IOPTO=0
      IF(IOPTN.NE.0)IOPTI=0
*
*          Open file
*
      CHOPT2 = CHOPT//'XW'
      CHOPT1 = CHOPT//'X'
      CALL RZOPEN(LUN,CHTOP,CHFILE,CHOPT2,1024,ISTAT)
      IF(ISTAT.NE.0)GO TO 99
*
      IF(IOPTN.NE.0)THEN
         IF(IOPTQ.NE.0)THEN
            NQUOT=IQUEST(10)
            IF(NQUOT.LT.100.OR.NQUOT.GT.100000)NQUOT=1000
         ELSE
            NQUOT=1000
         ENDIF
         CALL RZMAKE(LUN,CHTOP,2,'HI',CHTAGS,NQUOT,CHOPT1)
      ELSE
         CALL RZFILE(LUN,CHTOP,CHOPT1)
      ENDIF
*
*           Read/write initialisation structures
*
      IF(IOPTI.NE.0)THEN
         CALL GRIN('INIT',0,' ')
      ENDIF
      IF(IOPTO.NE.0)THEN
         CALL GROUT('INIT',1,' ')
      ENDIF
      IF(IOPTI.NE.0.OR.IOPTO.NE.0)THEN
         CALL RZEND(CHTOP)
         CLOSE(LUN)
      ENDIF
*
  99  END
+DECK,  GRGET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GRGET (KEYSU,ID1,ID2,ID3,ICYCLE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read  data structures from a RZ file          *
C.    *                                                                *
C.    *       KEYSU    Keyword to select data structure                *
C.    *       ID1      First  RZ KEY identifier (ex IDRUN)             *
C.    *       ID2      Second RZ KEY identifier (ex IDEVT)             *
C.    *       ID3      Third  RZ KEY identifier (user free)            *
C.    *       ICYCLE   Cycle number                                    *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUKINE                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCDRAW.
+CDE, GCCUTS.
C
      DIMENSION CUTVEC(10)
      EQUIVALENCE (CUTVEC,CUTGAM)
C
      CHARACTER*4 KLEY(19)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYRZ(4)
      DIMENSION LINIT(8),LKINE(2),LTRIG(6)
      DIMENSION LKEY(19),LINK(10),JLINK(17),KSEL(17),IXD(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      EQUIVALENCE (LKEY(18),KINIT),(LKEY(19),KTRIG),(LKEY(5),KKINE)
C
      SAVE IFIRST,LKEY
      DATA KLEY/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART','ROTM'
     +         ,'RUNG','SETS','STAK','STAT','TMED','TRAC','VERT','VOLU'
     +         ,'JXYZ','INIT','TRIG'/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2/
      DATA LINIT/2,6,7,8,9,10,13,16/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA NLINIT/8/
      DATA NLKINE/2/
      DATA NLTRIG/6/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,76)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GRGET *** Obsolete routine. Please use GRIN')
C
      CALL UCTOH(KEYSU,KEY,4,4)
      CALL VZERO(KSEL,17)
C
      IF(KEY.EQ.KINIT)THEN
         CALL UCOPY(LINIT,LINK,NLINIT)
         NLINK=NLINIT
      ELSEIF(KEY.EQ.KKINE)THEN
         CALL UCOPY(LKINE,LINK,NLKINE)
         NLINK=NLKINE
      ELSEIF(KEY.EQ.KTRIG)THEN
         CALL UCOPY(LTRIG,LINK,NLTRIG)
         NLINK=NLTRIG
      ELSE
         IL=IUCOMP(KEY,LKEY,17)
         IF(IL.EQ.0)GO TO 50
         LINK(1)=IL
         NLINK=1
      ENDIF
C
C               Read data structure(s)
C
      KEYRZ(2)=ID1
      KEYRZ(3)=ID2
      KEYRZ(4)=ID3
C
      DO 10 I=1,NLINK
         IL=LINK(I)
         IF(JLINK(IL).NE.0)THEN
            CALL MZDROP(IXCONS,JLINK(IL),' ')
            JLINK(IL)=0
         ENDIF
         KEYRZ(1)=LKEY(IL)
         IF(IXD(IL).NE.2)THEN
            IDIV=IXCONS
         ELSE
            IDIV=IXDIV
         ENDIF
         CALL RZIN(IDIV,JLINK(IL),1,KEYRZ,ICYCLE,' ')
         KSEL(IL)=1
   10 CONTINUE
C
C             Fill header bank
C             Reconstruct NKVIEW,NVOLUM,NVERTX,NTRACK
C             Reconstruct NMATE, NTMED, NPART
C
      IF(KSEL(6).NE.0.AND.JMATE.GT.0) NMATE=IQ(JMATE-2)
      IF(KSEL(7).NE.0.AND.JPART.GT.0) NPART=IQ(JPART-2)
      IF(KSEL(13).NE.0.AND.JTMED.NE.0 ) THEN
         DO 20 J=1,10
            CUTVEC(J) = Q(JTMED+J)
   20    CONTINUE
         NTMED=IQ(JTMED-2)
      ENDIF
      IF(KSEL(16).NE.0.AND.JVOLUM.GT.0) THEN
         NVOLUM=0
         DO 30 J=1, IQ(JVOLUM-2)
            IF(LQ(JVOLUM-J).EQ.0) GO TO 40
            NVOLUM=NVOLUM+1
   30    CONTINUE
   40    CONTINUE
      END IF
      IF(KSEL( 2).NE.0.AND.JDRAW.GT.0 ) NKVIEW=IQ(JDRAW-2)
C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
C
      IF(KSEL(5).GT.0)THEN
         NVERTX=0
         NTRACK=0
         IF(JVERTX.GT.0)NVERTX=IQ(JVERTX+1)
         IF(JKINE .GT.0)NTRACK=IQ(JKINE +1)
      ENDIF
C
   50 RETURN
      END
+DECK,  GRIN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GRIN(CHOBJT,IDVERS,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to read GEANT object(s) fromin the RZ file       *
C.    *         at the Current Working Directory (See RZCDIR)          *
C.    *       The data structures from disk are read in memory         *
C.    *           (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)                 *
C.    *                                                                *
C.    *       CHOBJ  The type of object to be read:                    *
C.    *              MATE read JMATE structure                         *
C.    *              TMED read JTMED structure                         *
C.    *              VOLU read JVOLUM structure                        *
C.    *              ROTM read JROTM structure                         *
C.    *              SETS read JSET  structure                         *
C.    *              PART read JPART structure                         *
C.    *              SCAN read LSCAN structure                         *
C.    *              INIT read all initialisation structures           *
C.    *                                                                *
C.    *       IDVERS is a positive integer which specifies the version *
C.    *           number of the object(s).                             *
C.    *                                                                *
C.    *       CHOPT List of options (none for the time being)          *
C.    *                                                                *
C.    *                                                                *
C.    *    The RZ data base has been created via GRFILE/GROUT          *
C.    *                                                                *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GRFILE(1,'Geometry.dat',' ')                         *
C.    *      CALL GRIN ('VOLU',1,' ')                                  *
C.    *      CALL GRIN ('MATE',1,' ')                                  *
C.    *      CALL GRIN ('TMED',1,' ')                                  *
C.    *      CALL GRIN ('ROTM',1,' ')                                  *
C.    *      CALL GRIN ('PART',1,' ')                                  *
C.    *      CALL GRIN ('SCAN',1,' ')                                  *
C.    *      CALL GRIN ('SETS',1,' ')                                  *
C.    *                                                                *
C.    *      The same result can be achieved by:                       *
C.    *      CALL GRFILE(1,'Geometry.dat','I')                         *
C.    *                                                                *
C.    *    ==>Called by : <USER> ,GRFILE                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCONSP.
+CDE, GCNUM.
+CDE, GCCUTS.
+CDE, GCSCAL.
+CDE, GCDRAW.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCTIME.
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),KEYS(2),LINIT(NLINIT),LKINE(NLKINE)
      DIMENSION LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),IVERSI(NMKEY),LDIV(2),IRESUL(NMKEY)
      DIMENSION IDOLD(8), IDNEW(8), VEROLD(8), VERNEW(8)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 CHOBJ,CKEY,KNAMES(NMKEY)
      CHARACTER*(*) CHOPT,CHOBJT
      DATA KNAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +     'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +     'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA IDNEW / 8*0 /
      DATA VERNEW / 8*0. /
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
      KVOL=JVOLUM
      CHOBJ=CHOBJT
*
*     Save old JRUNG dates and versions
      IF(JRUNG.GT.0) THEN
         DO 10 J=1,8
            IDOLD(J) = IQ(JRUNG+10+J)
            VEROLD(J) = Q(JRUNG+20+J)
   10    CONTINUE
      ENDIF
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
      IF(CHOBJ.EQ.'INIT') THEN
         CHOBJ='*'
         IOPTI=1
         IOPTT=0
         IOPTK=0
         IF(JDRAW.NE.0)CALL MZDROP(IXSTOR,JDRAW,'L')
         IF(JSTAK.NE.0)CALL MZDROP(IXSTOR,JSTAK,'L')
         IF(JGPAR.NE.0)CALL MZDROP(IXSTOR,JGPAR,'L')
      ELSEIF(CHOBJ.EQ.'TRIG') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=1
         IOPTK=0
      ELSEIF(CHOBJ.EQ.'KINE') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=0
         IOPTK=1
      ENDIF
*
      IF(CHOBJ.EQ.'*') THEN
         IF(IOPTI.NE.0) THEN
            DO 20 J=1, NLINIT
               LINK(J)=LINIT(J)
   20       CONTINUE
            NLINK=NLINIT
         ELSEIF(IOPTT.NE.0) THEN
            DO 30 J=1, NLTRIG
               LINK(J)=LTRIG(J)
   30       CONTINUE
            NLINK=NLTRIG
         ELSEIF(IOPTK.NE.0) THEN
            DO 40 J=1, NLKINE
               LINK(J)=LKINE(J)
   40       CONTINUE
            NLINK=NLKINE
         ENDIF
      ELSE
         NLINK=0
         DO 100 J=1, NMKEY
            IF(CHOBJ.EQ.KNAMES(J)) THEN
               IF(IOPTI.NE.0) THEN
                  DO 50 L=1, NLINIT
                     IF(LINIT(L).EQ.J) GOTO 80
   50             CONTINUE
                  GOTO 90
               ELSEIF(IOPTT.NE.0) THEN
                  DO 60 L=1, NLTRIG
                     IF(LTRIG(L).EQ.J) GOTO 80
   60             CONTINUE
                  GOTO 90
               ELSEIF(IOPTK.NE.0) THEN
                  DO 70 L=1, NLKINE
                     IF(LKINE(L).EQ.J) GOTO 80
   70             CONTINUE
                  GOTO 90
               ENDIF
   80          NLINK=1
               LINK(1)=J
               GOTO 110
*
   90          WRITE(CHMAIL,10000) CHOBJ, CHOPT
               CALL GMAIL(0,0)
               GOTO 999
*
            ENDIF
  100    CONTINUE
      ENDIF
*
  110 IF(NLINK.EQ.0) THEN
         WRITE(CHMAIL,10100) CHOBJ
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
      DO 120 J=1, NLINK
         IVERSI(J)=0
         IRESUL(J)=0
  120 CONTINUE
*
      IKEY=0
  130 CONTINUE
      IKEY=IKEY+1
      CALL RZINK(IKEY,9999,'S')
      IF(IQUEST(1).NE.0) THEN
         IQUEST(1)=0
         GOTO 150
      ENDIF
      CALL UHTOC(IQUEST(21),4,CKEY,4)
      DO 140 I=1,NLINK
         NKEY=ABS(LINK(I))
         IF(CKEY.EQ.KNAMES(NKEY))THEN
            IF(IDVERS.NE.0.AND.IDVERS.NE.IQUEST(22)) THEN
               LINK(I)=-ABS(LINK(I))
               GOTO 130
            ENDIF
            KEYS(1)=IQUEST(21)
            KEYS(2)=IQUEST(22)
            IDIV=LDIV(IXD(NKEY))
            IF(NKEY.LE.20)THEN
               IF(JNAMES(NKEY).NE.0)THEN
                  CALL MZDROP(IDIV,JNAMES(NKEY),'L')
                  JNAMES(NKEY)=0
               ENDIF
               CALL RZIN(IDIV,JNAMES(NKEY),1,KEYS,9999,' ')
            ELSE
               NKL=NKEY-20
               IF(ISLINK(NKL).NE.0)THEN
                  CALL MZDROP(IDIV,ISLINK(NKL),'L')
                  ISLINK(NKL)=0
               ENDIF
               CALL RZIN(IDIV,ISLINK(NKL),1,KEYS,9999,' ')
            ENDIF
            IF(IQUEST(1).EQ.0) THEN
               IVERSI(I)=IQUEST(22)
               IRESUL(I)=1
            ENDIF
         ENDIF
  140 CONTINUE
      GOTO 130
*
  150 NIN=0
      DO 160 I=1,NLINK
         IF(IRESUL(I).EQ.1) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10200) KNAMES(LINK(I)), IVERSI(I)
            CALL GMAIL(0,0)
            ENDIF
            NIN=NIN+1
         ELSEIF(LINK(I).GT.0) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10300) KNAMES(LINK(I))
            CALL GMAIL(0,0)
            ENDIF
         ELSEIF(LINK(I).LT.0) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10400) KNAMES(-LINK(I)), IDVERS
            CALL GMAIL(0,0)
            ENDIF
         ENDIF
  160 CONTINUE
*
      IF(NIN.EQ.0) THEN
         WRITE(CHMAIL,10500)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
      IF(KVOL.NE.JVOLUM)THEN
         NVOLUM=IQ(JVOLUM-1)
         CALL MZGARB(IXCONS,0)
         CALL GGDVLP
         CALL GGNLEV
      ENDIF
*
      IF(JVOLUM.GT.0) THEN
         NLEVEL=0
         NVOLUM=0
         DO 170 J=1, IQ(JVOLUM-2)
            IF(LQ(JVOLUM-J).EQ.0) GOTO 180
            NVOLUM=NVOLUM+1
  170    CONTINUE
  180    CONTINUE
      ENDIF
*
      IF(JTMED.NE.0 )THEN
         CALL UCOPY(Q(JTMED+1),CUTGAM,10)
         NTMED=IQ(JTMED-2)
      ENDIF
*
      IF(JPART.NE.0 ) NPART  = IQ(JPART-2)
      IF(JVERTX.NE.0) NVERTX = IQ(JVERTX-2)
      IF(JMATE.NE.0 ) NMATE  = IQ(JMATE-2)
      IF(JROTM.NE.0 ) NROTM  = IQ(JROTM-2)
      IF(JDRAW.GT.0 ) THEN
         NKVIEW = IQ(JDRAW-2)
      ELSE
         NKVIEW = 0
C
C             Book JDRAW structure for view banks
C
         CALL MZBOOK(IXCONS,JDRAW,JDRAW,1,'DRAW',0,0,0,3,0)
      ENDIF

C
      IF(JHEAD.GT.0)THEN
         IDRUN=IQ(JHEAD+1)
         IDEVT=IQ(JHEAD+2)
      ENDIF
      IF(JRUNG.GT.0) THEN
*
*             Here we deal with version numbers If JRUNG has been read in,
*             then save the version numbers of the new JRUNG and restore
*             the current version number for KINE, HITS and DIGI
         DO 210 J=1, NLINK
            IF(IRESUL(J).EQ.1) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'RUNG') THEN
                  DO 190 I=1,8
                     IDNEW(I) = IQ(JRUNG+10+I)
                     VERNEW(I) = Q(JRUNG+20+I)
  190             CONTINUE
*
*             And we put back the old version numbers because,
*             in principle, KINE, HITS and DIGI have not be read in
                  DO 200 I=3,8
                     IQ(JRUNG+10+I) = IDOLD(I)
                     Q(JRUNG+20+I) = VEROLD(I)
  200             CONTINUE
               ENDIF
            ENDIF
  210    CONTINUE
*
*            And here we do it again for KINE, HITS and DIGI
         DO 220 J=1, NLINK
            IF(IRESUL(J).EQ.1) THEN
               NKEY = ABS(LINK(J))
               IF(KNAMES(NKEY).EQ.'KINE') THEN
                  IF(IDNEW(3).GT.0) THEN
                     IQ(JRUNG+13) = IDNEW(3)
                     IQ(JRUNG+14) = IDNEW(4)
                     Q(JRUNG+23) = VERNEW(3)
                     Q(JRUNG+24) = VERNEW(4)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'HITS') THEN
                  IF(IDNEW(5).GT.0) THEN
                     IQ(JRUNG+15) = IDNEW(5)
                     IQ(JRUNG+16) = IDNEW(6)
                     Q(JRUNG+25) = VERNEW(5)
                     Q(JRUNG+26) = VERNEW(6)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'DIGI') THEN
                  IF(IDNEW(7).GT.0) THEN
                     IQ(JRUNG+17) = IDNEW(7)
                     IQ(JRUNG+18) = IDNEW(8)
                     Q(JRUNG+27) = VERNEW(7)
                     Q(JRUNG+28) = VERNEW(8)
                  ENDIF
               ELSEIF(KNAMES(NKEY).EQ.'MATE'.OR.
     +                KNAMES(NKEY).EQ.'TMED') THEN
                  IF(VERNEW(1).NE.0) THEN
*                We know which version number we are reading
                     IF(VERNEW(1).LT.GVERSN) THEN
                        WRITE(CHMAIL,10600)
     +                        KNAMES(NKEY),VERNEW(1),GVERSN
                        CALL GMAIL(0,0)
                        WRITE(CHMAIL,10700)
                        CALL GMAIL(0,0)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
  220    CONTINUE
      ENDIF
*
10000 FORMAT(' *** GRIN *** Data structure ',A4,' not read in ',
     +       'phase ',A)
10100 FORMAT(' *** GRIN *** Unknown key ',A4)
10200 FORMAT(' *** GRIN *** Data structure ',A4,' version ',I10,
     +       ' successfully read in ')
10300 FORMAT(' *** GRIN *** Data structure ',A4,' was not found')
10400 FORMAT(' *** GRIN *** Data structure ',A4,' version ',I10,
     +       ' was not found')
10500 FORMAT(' *** GRIN *** Nothing found to read !')
10600 FORMAT(' *** GRIN *** ',A4,' data structure ',
     +       'version ',F6.4,' current version is ',F6.4)
10700 FORMAT('              Please call subroutine GPHYSI before ',
     +       'tracking')
  999 END
+DECK,  GRLEAS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GRLEAS(JBANK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Release unused space in data structure pointed by JBANK. *
C.    *       JBANK can be either JHITS or JDIGI                       *
C.    *                                                                *
C.    *    ==>Called by : GSAVE                                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
C.
      IF(JBANK.LE.0)GO TO 99
      NS=IQ(JBANK-2)
      IF(NS.LE.0)GO TO 99
      DO 20 IS=1,NS
         JB=LQ(JBANK-IS)
         IF(JB.GT.0)THEN
            ND=IQ(JB-1)
            IF(ND.GT.0)THEN
               DO 10 ID=1,ND
                  JBD=LQ(JB-ID)
                  IF(JBD.GT.0)THEN
                     NPUSH=IQ(JBD-1)-IQ(JB+ID)
                     IF(NPUSH.GT.0)CALL MZPUSH(IXDIV,JBD,0,-NPUSH,'I')
                  ENDIF
  10           CONTINUE
            ENDIF
         ENDIF
  20  CONTINUE
C
  99  RETURN
      END
+DECK,  GRMDIR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GRMDIR(CHDIR,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to create a "standard" GEANT subdirectory        *
C.    *                                                                *
C.    *       CHDIR Subdirectory name                                  *
C.    *                                                                *
C.    *       CHOPT is a character string which may be                 *
C.    *          ' ' To create a subdirectory                          *
C.    *          'S' To create a subdirectory and set the new          *
C.    *              Current Directory to this directory.              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*(*) CHDIR,CHOPT
      CHARACTER*8 CHTAGS(2)
      DATA CHTAGS/'Object','Version'/
C.
C.    ------------------------------------------------------------------
C.
      CALL UOPTC(CHOPT,'S',IOPTS)
*
      CALL RZMDIR(CHDIR,2,'HI',CHTAGS)
      IF(IOPTS.NE.0)THEN
         CALL RZCDIR(CHDIR,' ')
      ENDIF
*
      END
+DECK,  GROUT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GROUT(CHOBJT,IDVERS,CHOPT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write GEANT object(s) in the RZ file          *
C.    *         at the Current Working Directory (See RZCDIR)          *
C.    *       Input is taken from the data structures in memory        *
C.    *           (VOLU,ROTM,TMED,MATE,SETS,PART,SCAN)                 *
C.    *                                                                *
C.    *       CHOBJ  The type of object to be written:                 *
C.    *              MATE write JMATE structure                        *
C.    *              TMED write JTMED structure                        *
C.    *              VOLU write JVOLUM structure                       *
C.    *              ROTM write JROTM structure                        *
C.    *              SETS write JSET  structure                        *
C.    *              PART write JPART structure                        *
C.    *              SCAN write LSCAN structure                       *
C.    *              INIT write all initialisation structures          *
C.    *                                                                *
C.    *       IDVERS is a positive integer which specifies the version *
C.    *           number of the object(s).                             *
C.    *                                                                *
C.    *       CHOPT List of options (none for the time being)          *
C.    *                                                                *
C.    *    Note that if the cross-sections and energy loss tables      *
C.    *       are available in the data structure JMATE, then they are *
C.    *       saved on the data base.                                  *
C.    *                                                                *
C.    *                                                                *
C.    *    The data structures saved by this routine can be retrieved  *
C.    *    with the routine GRIN.                                      *
C.    *                                                                *
C.    *    Before calling this routine a RZ data base must have been   *
C.    *    created using GRFILE.                                       *
C.    *    The data base must be closed with RZEND.                    *
C.    *                                                                *
C.    *    The RZ data base can be transported between different       *
C.    *    machines in using the ZEBRA RZ utility RZTOFZ.              *
C.    *                                                                *
C.    *    The interactive version of GEANT provides facilities        *
C.    *    to interactively update, create and display objects.        *
C.    *                                                                *
C.    *      Example.                                                  *
C.    *                                                                *
C.    *      CALL GRFILE(1,'Geometry.dat','N')                         *
C.    *      CALL GROUT('VOLU',1,' ')                                  *
C.    *      CALL GROUT('MATE',1,' ')                                  *
C.    *      CALL GROUT('TMED',1,' ')                                  *
C.    *      CALL GROUT('ROTM',1,' ')                                  *
C.    *      CALL GROUT('PART',1,' ')                                  *
C.    *      CALL GROUT('SCAN',1,' ')                                  *
C.    *      CALL GROUT('SETS',1,' ')                                  *
C.    *                                                                *
C.    *      The same result can be achieved by:                       *
C.    *      CALL GRFILE(1,'Geometry.dat','NO')                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>,GRFILE                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCCUTS.
+CDE, GCSCAL.
+CDE, GCDRAW.
+CDE, GCUNIT.
*      COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART
*     +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX
*     +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT
      COMMON/QUEST/IQUEST(100)
      PARAMETER (NLINIT=9,NLKINE=2,NLTRIG=6,NMKEY=22)
      DIMENSION JNAMES(20),KEYS(2)
      DIMENSION LINIT(NLINIT),LKINE(NLKINE),LTRIG(NLTRIG),IXD(NMKEY)
      DIMENSION LINK(NMKEY),LDIV(2)
      EQUIVALENCE (JNAMES(1),JDIGI)
      CHARACTER*4 CHOBJ,NAMES(NMKEY)
      CHARACTER*(*) CHOPT,CHOBJT
      DATA NAMES/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART',
     +    'ROTM','RUNG','SETS','STAK','STAT','TMED','NULL','VERT',
     +    'VOLU','JXYZ','NULL','NULL','NULL','SCAN','NULL'/
      DATA IXD/2,1,2,2,2,8*1,2,2,1,2,3*0,1,0/
      DATA LINIT/2,6,7,8,9,10,13,16,21/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
C.
C.    ------------------------------------------------------------------
C.
      IQUEST(1)=0
      LDIV(1)  =IXCONS
      LDIV(2)  =IXDIV
      CHOBJ=CHOBJT
*
      IOPTI=INDEX(CHOPT,'i')+INDEX(CHOPT,'I')
      IOPTT=INDEX(CHOPT,'t')+INDEX(CHOPT,'T')
      IOPTK=INDEX(CHOPT,'k')+INDEX(CHOPT,'K')
      IOPTQ=INDEX(CHOPT,'q')+INDEX(CHOPT,'Q')
*
      IF(CHOBJ.EQ.'INIT') THEN
         CHOBJ='*'
         IOPTI=1
         IOPTT=0
         IOPTK=0
      ELSEIF(CHOBJ.EQ.'TRIG') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=1
         IOPTK=0
      ELSEIF(CHOBJ.EQ.'KINE') THEN
         CHOBJ='*'
         IOPTI=0
         IOPTT=0
         IOPTK=1
      ENDIF
*
      IF(CHOBJ.EQ.'*') THEN
         IF(IOPTI.NE.0) THEN
            DO 10 J=1, NLINIT
               LINK(J)=LINIT(J)
   10       CONTINUE
            NLINK=NLINIT
         ELSEIF(IOPTT.NE.0) THEN
            DO 20 J=1, NLTRIG
               LINK(J)=LTRIG(J)
   20       CONTINUE
            NLINK=NLTRIG
         ELSEIF(IOPTK.NE.0) THEN
            DO 30 J=1, NLKINE
               LINK(J)=LKINE(J)
   30       CONTINUE
            NLINK=NLKINE
         ENDIF
      ELSE
         NLINK=0
         DO 90 J=1, NMKEY
            IF(CHOBJ.EQ.NAMES(J)) THEN
               IF(IOPTI.NE.0) THEN
                  DO 40 L=1, NLINIT
                     IF(LINIT(L).EQ.J) GOTO 70
   40             CONTINUE
                  GOTO 80
               ELSEIF(IOPTT.NE.0) THEN
                  DO 50 L=1, NLTRIG
                     IF(LTRIG(L).EQ.J) GOTO 70
   50             CONTINUE
                  GOTO 80
               ELSEIF(IOPTK.NE.0) THEN
                  DO 60 L=1, NLKINE
                     IF(LKINE(L).EQ.J) GOTO 70
   60             CONTINUE
                  GOTO 80
               ENDIF
   70          NLINK=1
               LINK(1)=J
               GOTO 100
*
   80          WRITE(CHMAIL,10000) CHOBJ, CHOPT
               CALL GMAIL(0,0)
               GOTO 999
*
            ENDIF
   90    CONTINUE
      ENDIF
*
  100 IF(NLINK.EQ.0) THEN
         WRITE(CHMAIL,10100) CHOBJ
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
      NOUT=0
      DO 110 I=1,NLINK
         NKEY=LINK(I)
         CALL UCTOH(NAMES(NKEY),KEYS,4,4)
         KEYS(2)=IDVERS
         IDIV=LDIV(IXD(NKEY))
         IF(NKEY.LE.20)THEN
            IF(JNAMES(NKEY).GT.0)    THEN
               CALL RZOUT(IDIV,JNAMES(NKEY),KEYS,ICYCLE,' ')
               LINK(I)=-LINK(I)
            ENDIF
         ELSE
            IF(ISLINK(NKEY-20).GT.0)    THEN
               CALL RZOUT(IDIV,ISLINK(NKEY-20),KEYS,ICYCLE,' ')
               LINK(I)=-LINK(I)
            ENDIF
         ENDIF
         IF(LINK(I).GT.0) THEN
            IF(IOPTQ.EQ.0) THEN
            WRITE(CHMAIL,10200) NAMES(LINK(I))
            CALL GMAIL(0,0)
            ENDIF
            GOTO 110
         ELSEIF(LINK(I).LT.0) THEN
            IF(IQUEST(1).EQ.0) THEN
            IF(IOPTQ.EQ.0) THEN
               WRITE(CHMAIL,10300) NAMES(-LINK(I)), IDVERS
               CALL GMAIL(0,0)
            ENDIF
               NOUT=NOUT+1
            ELSE
               WRITE(CHMAIL,10400) NAMES(-LINK(I))
               CALL GMAIL(0,0)
            ENDIF
         ENDIF
  110 CONTINUE
*
      IF(NOUT.EQ.0) THEN
         WRITE(CHMAIL,10500)
         CALL GMAIL(0,0)
      ENDIF
*
10000 FORMAT(' *** GROUT *** Data structure ',A4,' not written ',
     +       'in phase ',A)
10100 FORMAT(' *** GROUT *** Unknown key ',A4)
10200 FORMAT(' *** GROUT *** Data structure ',A4,' was not found')
10300 FORMAT(' *** GROUT *** Data structure ',A4,' version ',I10,
     +       ' saved to disk')
10400 FORMAT(' *** GROUT *** Error in writing data structure ',
     +        A4,' to disk')
10500 FORMAT(' *** GROUT *** Nothing written to disk !')
  999 END
+DECK,  GRSAVE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GRSAVE(KEYSU,ID1,ID2,ID3,ICYCLE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write out data structures on a RZ file        *
C.    *                                                                *
C.    *       KEYSU    Keyword to select data structure(s)             *
C.    *       ID1      First  RZ KEY identifier (ex IDRUN)             *
C.    *       ID2      Second RZ KEY identifier (ex IDEVT)             *
C.    *       ID3      Third  RZ KEY identifier (user free)            *
C.    *       ICYCLE   Cycle number (output)                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUOUT                         *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      CHARACTER*4 KLEY(19)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYRZ(4)
      DIMENSION LINIT(8),LKINE(2),LTRIG(6)
      DIMENSION LKEY(19),LINK(10),JLINK(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      EQUIVALENCE (LKEY(18),KINIT),(LKEY(19),KTRIG),(LKEY(5),KKINE)
      SAVE IFIRST,LKEY
C
      DATA KLEY/'DIGI','DRAW','HEAD','HITS','KINE','MATE','PART','ROTM'
     +         ,'RUNG','SETS','STAK','STAT','TMED','TRAC','VERT','VOLU'
     +         ,'JXYZ','INIT','TRIG'/
      DATA LINIT/2,6,7,8,9,10,13,16/
      DATA LKINE/5,15/
      DATA LTRIG/1,3,4,5,15,17/
      DATA NLINIT/8/
      DATA NLKINE/2/
      DATA NLTRIG/6/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,76)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GRSAVE *** Obsolete routine. Please use GROUT')
C
      CALL UCTOH(KEYSU,KEY,4,4)
C
      IF(KEY.EQ.KINIT)THEN
         CALL UCOPY(LINIT,LINK,NLINIT)
         NLINK=NLINIT
      ELSEIF(KEY.EQ.KKINE)THEN
         CALL UCOPY(LKINE,LINK,NLKINE)
         NLINK=NLKINE
      ELSEIF(KEY.EQ.KTRIG)THEN
         CALL UCOPY(LTRIG,LINK,NLTRIG)
         NLINK=NLTRIG
      ELSE
         IL=IUCOMP(KEY,LKEY,17)
         IF(IL.EQ.0)GO TO 99
         LINK(1)=IL
         NLINK=1
      ENDIF
C
C               Write data structure(s)
C
      KEYRZ(2)=ID1
      KEYRZ(3)=ID2
      KEYRZ(4)=ID3
C
      DO 10 I=1,NLINK
         IL=LINK(I)
         IF(JLINK(IL).EQ.0)GO TO 10
         KEYRZ(1)=LKEY(IL)
         IF(IL.EQ.4)CALL GRLEAS(JHITS)
         IF(IL.EQ.1)CALL GRLEAS(JDIGI)
         CALL RZOUT(IXSTOR,JLINK(IL),KEYRZ,ICYCLE,'L')
  10  CONTINUE
C
  99  RETURN
      END
+DECK,  GSAVE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:17  cernlib
* Geant

      SUBROUTINE GSAVE(LUN,KEYSU,NUKEYS,IDENT,IER)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to write out data structures                     *
C.    *                                                                *
C.    *       LUN      Logical unit number                             *
C.    *       KEYSU    Keywords to select data structures              *
C.    *       NKEYS    Number of keywords                              *
C.    *       IER      Error flag                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT,GUOUT                         *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      CHARACTER*4 KLEY(22)
      CHARACTER*4 KEYSU(1)
      DIMENSION KEYS(22),IUHEAD(2)
      DIMENSION KSEL(14),LKEY(22),LKNUM(22),LINK(14),JLINK(17)
      EQUIVALENCE (JLINK(1),JDIGI)
      COMMON/QUEST/IQUEST(100)
      SAVE IFIRST,LKEY
C
      DATA LINK/7,6,13,16,8,10,2,9,3,15,5,17,4,1/
      DATA KLEY/'PART','MATE','TMED','VOLU','ROTM','SETS','DRAW','RUNG'
     +         ,'INIT','INIT','INIT','INIT','INIT','INIT','INIT','INIT'
     +         ,'HEAD','KINE','KINE','JXYZ','HITS','DIGI'/
      DATA LKNUM/1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,10,11,12,13,14/
      DATA IFIRST/0/
C.
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KLEY,LKEY,4,88)
      ENDIF
*
      WRITE(CHMAIL,10000)
      CALL GMAIL(0,0)
10000 FORMAT(' *** GSAVE *** Obsolete routine. Please use GFOUT')
C
      IER    = 0
      NKEYS=IABS(NUKEYS)
      IF (NKEYS.LE.0)                                 GO TO 99
      CALL UCTOH(KEYSU,KEYS,4,4*NKEYS)
C
      IF(NUKEYS.LT.0)THEN
        I1=1
        I2=15
        K1=1
        K2=7
      ELSE
        I1=18
        I2=22
        K1=10
        K2=14
      ENDIF
C
      DO 10 K=K1,K2
  10  KSEL(K)=0
      NK=0
      DO 25 I=I1,I2
         N=LKNUM(I)
         DO 20 IK=1,NKEYS
            IF(KEYS(IK).EQ.LKEY(I))THEN
               IL=LINK(N)
               IF(JLINK(IL).NE.0)THEN
                  KSEL(N)=1
                  NK=NK+1
               ENDIF
            ENDIF
  20     CONTINUE
  25  CONTINUE
C
      IUHEAD(1)=IDENT
      IUHEAD(2)=NK
      IF(NUKEYS.LT.0)THEN
C
C======>      Write RUN header and constants
C
         CALL FZOUT(LUN,IXCONS,JRUNG,1,'L',2,2,IUHEAD)
         IF(IQUEST(1).NE.0)GO TO 90
         DO 30 I=1,7
            IF(KSEL(I).NE.0)THEN
               IL=LINK(I)
               CALL FZOUT(LUN,IXCONS,JLINK(IL),0,'L',2,1,I)
               IF(IQUEST(1).NE.0)GO TO 90
            ENDIF
  30     CONTINUE
C
      ELSE
C
C======>      Write event header and data structures
C             Released unused space in JHITS and JDIGI
C
         IF(KSEL(13).NE.0)CALL GRLEAS(JHITS)
         IF(KSEL(14).NE.0)CALL GRLEAS(JDIGI)
C
         CALL FZOUT(LUN,IXDIV,JHEAD,1,' ',2,2,IUHEAD)
         IF(IQUEST(1).NE.0)GO TO 90
         DO 40 I=10,14
            IF(KSEL(I).NE.0)THEN
               IL=LINK(I)
               CALL FZOUT(LUN,IXDIV ,JLINK(IL),0,'L',2,1,I)
               IF(IQUEST(1).NE.0)GO TO 90
            ENDIF
  40     CONTINUE
C
      ENDIF
      GO TO 99
C
C             Error
C
  90  IER=IQUEST(1)
C
  99  RETURN
      END
+PATCH, GHITS.
+DECK,  GCDERR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:08  cernlib
* Geant

      SUBROUTINE GCDERR (ICD,ERP,ERS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       ROUTINE TO CALCULATE THE ERROR ON THE CURRENT DIVISION   *
C.    *       INFORMATION AS OBTAINED BY "GCDRIF"                      *
C.    *                                                                *
C.    *       INPUT:  ICD = DIGITIZED CURRENT DIVISION INFORMATION     *
C.    *                     ( 0 ... 1000 )                             *
C.    *               ERP = VARIANCE OF GAUSSIAN DISTRIBUTED PEDESTAL  *
C.    *                     ERRORS ON THE MEASURED PULSE HEIGHTS       *
C.    *                     RELATIVE TO THE SUM OF THE PULSE HEIGHTS   *
C.    *               ERS = VARIANCE OF GAUSSIAN DISTRIBUTED SLOPE     *
C.    *                     ERRORS ON THE MEASURED PULSE HEIGHTS       *
C.    *                     RELATIVE TO EACH PULSE HEIGHT              *
C.    *       OUTPUT: ICD = VALUE UPDATED ACCORDING TO RANDOM ERRORS   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Author    D.Mitaroff  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      COMMON  /GCYDR/ ZL
      DIMENSION RNDM(4)
C
      Z = ICD
C
C---- CALCULATE PEDESTAL ERRORS FOR VARIANCE BEING 1.
      CALL GRNDM(RNDM,4)
*          call rannor(eps1,eps2)
      RY=RNDM(1)
      RZ=RNDM(2)
      RX=6.283185*RZ
      A1=SQRT(-2.*LOG(RY))
      EPS1=A1*SIN(RX)
      EPS2=A1*COS(RX)
      DZP = - EPS1 * Z + EPS2 * (ZL - Z)
C
C---- CALCULATE SLOPE ERRORS FOR VARIANCE BEING 1.
*          call rannor(eps1,eps2)
      RY=RNDM(3)
      RZ=RNDM(4)
      RX=6.283185*RZ
      A1=SQRT(-2.*LOG(RY))
      EPS1=A1*SIN(RX)
      EPS2=A1*COS(RX)
      DZS = (EPS2 - EPS1) * Z * (ZL - Z) / ZL
C
C---- CALCULATE NEW VALUE OF ICD FOR VARIANCES ERP, ERS.
      Z = Z + ERP * DZP + ERS * DZS
      IF (Z .LT. 0.)   Z = 0.
      IF (Z .GT. ZL)   Z = ZL
C
      ICD = Z
C
      END
+DECK,  GCDRIF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:08  cernlib
* Geant

      SUBROUTINE  GCDRIF (RADD,ZMIN,ZMAX,DETREP,HITREP,IOUT)
C.
C.    **************************************************************************
C.    *                                                                        *
C.    *              Digitisation of Drift-  Chambers                          *
C.    *              --------------------------------                          *
C.    *                                                                        *
C.    *   Digitisation routine for a cylindrical drift chamber.                *
C.    * RADD      radius of cylinder in cm                                     *
C.    * ZMIN      z of lower end of cylinder                                   *
C.    * ZMAX      z of upper end of "                                          *
C.    * DETREP(1) number of wires                                              *
C.    * DETREP(2) wire spacing in PHI (radians)                                *
C.    * DETREP(3) cosine of wire angle                                         *
C.    * DETREP(4) sine of wire angle (signed like dphi/dz)                     *
C.    * DETREP(5) dphi/dz along wire                                           *
C.    * DETREP(6)  phi of point with z=0 on wire 1                             *
C.    * DETREP(7) drift velocity (cm/nsec)                                     *
C.    * DETREP(8) quantity describing the drift angle                          *
C.    *           if.ne.0 ==> user routine GUDTIM                              *
C.    * HITREP(1) phi coordinate of intersection                               *
C.    * HITREP(2) z coordinate                                                 *
C.    * HITREP(3) dphi/dr                                                      *
C.    * HITREP(4) dz/dr                                                        *
C.    * IOUT(1)   wire number (1..NWI with  increasing phi)  (-1 for           *
C.    *           bad DETREP parameters)                                       *
C.    * IOUT(2)   drift time (nsec) (+/- for phi(hit)>/< phi(wire)             *
C.    * IOUT(3)   digitised current division information (rel.  pos.           *
C.    *           along wire of charge) (per mille)                            *
C.    * IOUT(4)   amount of charge deposited to wire                           *
C.    * Coordinate systems along wire                                          *
C.    *     I.             Charge                   I.                         *
C.    *     .              |                        .                          *
C.    *     |              .                        |                          *
C.    *     =========================================  SENSE WIRE              *
C.    * ...................................................> Z (cm)            *
C.    *     Z              Z.                       Z.                         *
C.    *      L                                                                 *
C.    * ...............................................> X (arbitrary scale)   *
C.    *     0              X.                       L                          *
C.    *           X.                  (L-X.)                                   *
C.    * The scaling used is such that L . 1000.                                *
C.    * Knowing the position Z. of the deposit of charge,                      *
C.    *            Z.-ZL                                                       *
C.    *    X.                          =                           L           *
C.    * .          .....                                                       *
C.    *            Z.-ZL                                                       *
C.    * This information is stored into IOUT(3).                               *
C.    *   Routine to  calculate the  error on  the current  division           *
C.    * information as obtained by "GCDRIFT".                                  *
C.    * ICD       digitized     current     division     information           *
C.    *           (0 ... 1000)                                                 *
C.    * ERP       variance of Gaussian  distributed pedestral errors           *
C.    *           on the measured pulse heights  relative to the sum           *
C.    *           of the pulse heights                                         *
C.    * ERS       variance of  Gaussian distributed slope  errors on           *
C.    *           the measured  pulse heights  relative to  the each           *
C.    *           pulse heights                                                *
C.    *   Here we  assume that X.  has been determined  by measuring           *
C.    * the pulse heights I., I. with some statistical errors.                 *
C.    * X.   is then given by the formula                                      *
C.    *     X. = L . I./I.   with  I. . I.+I.                                  *
C.    * and its error is determined by                                         *
C.    *     .X. = -(X./I.) .I. + (L-X./I.) .I.                                 *
C.    * with the errors on measuring the pulse heights                         *
C.    *      .I. = .. + ...I.                                                  *
C.    *      .I. = .. + ...I.                                                  *
C.    * ..,  .. are of dimension  (I)  and represent the "pedestral"           *
C.    * errors;                                                                *
C.    * .., .. are the "slope" errors.                                         *
C.    * All  are   assumed  to  be  distributed   independently  (no           *
C.    * correlations), randomly and Gaussian around zero. This gives           *
C.    * the final result                                                       *
C.    *           ..      ..                  X.(L-X.)                         *
C.    *   .X. = - .. X. + .. (L-X.) + (..-..) ........                         *
C.    *           I.      I.                     L                             *
C.    *         ..................   .................                         *
C.    *               "pedestal"          "slope"                              *
C.    * In  GCDERR,  the X. derived from GCDRIF is set to                      *
C.    *      X. = X. + .X.    (but 0 . X. . L)                                 *
C.    * using  ERP .....  variance for ./I.  ,  ../I.  distributions           *
C.    *        ERS .....  variance for .., ..  distributions.                  *
C.    *                                                                        *
C.    *    ==>Called by : <USER>, GUDIGI                                       *
C.    *       Author    D.Mitaroff *********                                   *
C.    *                                                                        *
C.    **************************************************************************
C.
      DIMENSION  DETREP(8), HITREP(4), IOUT(4)
+CDE, GCONSP.
C.
C.    -----------------------------------------------------------------
C.
      ZREL    = 1000.
      IOUT(1) = -1
      NWI = DETREP(1)
      WSP = DETREP(2)
      DVL = DETREP(7)
      IF (WSP .EQ. 0.)   GOTO 99
      IF (DVL .EQ. 0.)   GOTO 99
C
C---- CALCULATE WIRE NUMBER.
      FI = HITREP(1)
      ZZ = HITREP(2)
      FI0 = DETREP(6) + ZZ * DETREP(5)
      DFI = FI - FI0
   10 IF (DFI .GE. 0.)    GOTO 11
      DFI = DFI + TWOPI
      GOTO 10
   11 IF (DFI .LT. TWOPI)   GOTO 12
      DFI = DFI - TWOPI
      GOTO 11
   12 IW = DFI / WSP + 0.5
      DIS = DFI - IW * WSP
      IF (IW .EQ. NWI)   IW = 0
      IOUT(1) = IW + 1
C
C---- CALCULATE DRIFT TIME.
      DIS = DIS * RADD * DETREP(3)
      IF ( DETREP(8) .NE. 0. )   GOTO 2
      IOUT(2) = DIS / DVL
      GOTO 3
C
C---- DRIFT TIME BY USER ROUTINE.
    2 IOUT(2) = GUDTIM (DETREP,HITREP,IW+1,DIS)
C
C---- CALCULATE CURRENT DIVISION INFORMATION.
    3 Z0 = ZZ + DIS * DETREP(4)
      IF (Z0 .LT. ZMIN)   Z0 = ZMIN
      IF (Z0 .GT. ZMAX)   Z0 = ZMAX
      IOUT(3) = ZREL * (Z0 - ZMIN) / (ZMAX - ZMIN)
      IOUT(4) = 0
C.
  99  RETURN
      END
+DECK,  GCMWPC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:08  cernlib
* Geant

      SUBROUTINE GCMWPC (DETREP,HITREP,IOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Routine to compute one or  two digitisations produced by a   *
C.    * hit on a cylindrical MWPC.                                     *
C.    * DETREP(1) number of wires                                      *
C.    * DETREP(2) wire spacing (radians)                               *
C.    * DETREP(3) dtheta/dz along the wires                            *
C.    * DETREP(4) theta of a point on wire 1                           *
C.    * DETREP(5) z of a point on wire 1                               *
C.    * DETREP(6) gap width                                            *
C.    * HITREP(1) theta coordinate of intersection                     *
C.    * HITREP(2) z coordinate                                         *
C.    * HITREP(3) dtheta/dr                                            *
C.    * HITREP(4) dz/dr                                                *
C.    * IOUT(1)   wire number (-1-missing)                             *
C.    * IOUT(2)   cluster size                                         *
C.    * IOUT(3)   wire number of second cluster if any                 *
C.    * IOUT(4)   cluster size                                         *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Author    M.Hansroul  *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCONSP.
      DIMENSION HITREP(4), DETREP(6), IOUT(4)
+SELF, IF=-SINGLE.
      DOUBLE PRECISION ONE
+SELF.
      PARAMETER (ONE=1)
C.
C.    ------------------------------------------------------------------
C.
      IOUT(1) = - 1
      IOUT(3) = - 1
      ZS     = DETREP(2)
      IF (ZS.EQ.0.)                                   GO TO 99
C.
C.            COMPUTE WIRE NUMBER
C.
      HG     = .5 * DETREP(6)
      DT     = HG * HITREP(3)
      DZ     = HG * HITREP(4)
      T1     = HITREP(1) - DT
      T2     = HITREP(1) + DT
      Z1     = HITREP(2) - DZ
      Z2     = HITREP(2) + DZ
C
      Z0     = DETREP(5)
      DT     = DETREP(3)
      DZ     = Z1 - Z0
      T1     = T1 - DZ * DT
      DZ     = Z2 - Z0
      T2     = T2 - DZ * DT
      T0     = DETREP(4)
C
      T1     = MOD (ONE*T1,TWOPI)
      T2     = MOD (ONE*T2,TWOPI)
      T0     = MOD (ONE*T0,TWOPI)
      IF (T1.LT.0.) T1 = T1 + TWOPI
      IF (T2.LT.0.) T2 = T2 + TWOPI
      IF (T0.LT.0.) T0 = T0 + TWOPI
C
      NN     = 0
      W1     = (T1 - T0) / ZS
      IF (W1.LE.0.)THEN
         NN     = NN + 1
         W1     = W1 + TWOPI / ZS
      ENDIF
C
      W2     = (T2 - T0) / ZS
      IF (W2.LE.0.)THEN
         NN     = NN + 1
         W2     = W2 + TWOPI / ZS
      ENDIF
C
      W1     = W1 + 1.5
      W2     = W2 + 1.5
      IW1    = W1
      IW2    = W2
      NWIR   = DETREP(1)
      IF (NN.NE.1)THEN
C.
C.            1 CLUSTER
C.
         IWMIN  = MIN (IW1,IW2)
         IWMAX  = MAX (IW1,IW2)
         IF (IWMIN.GT.NWIR)                              GO TO 99
C
         IWMAX  = MIN (NWIR,IWMAX)
C
         IOUT(1) = IWMIN
         IOUT(2) = IWMAX - IWMIN + 1
      ELSE
C.
C.            SPECIAL CASE: SIGNAL ON WIRE 1
C.            AND ON WIRE 'NWIRES' --> 2 CLUSTERS
C.
         IW     = MIN (IW1,IW2)
         IW     = MIN (IW,NWIR)
         IOUT(1) = 1
         IOUT(2) = IW
         IW     = MAX (IW1,IW2)
         IF (IW.GT.NWIR)                                 GO TO 99
         IOUT(3) = IW
         IOUT(4) = NWIR - IW + 1
      ENDIF
C
  99  RETURN
      END
+DECK,  GCUBS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:08  cernlib
* Geant

      SUBROUTINE GCUBS(X,Y,D1,D2,A)
C.
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Calculates a cubic through P1,(-X,Y1),(X,Y2),P2          *
C.    *       where Y2=-Y1                                             *
C.    *        Y=A(1)+A(2)*X+A(3)*X**2+A(4)*X**3                       *
C.    *        The coordinate system is assumed to be the cms system   *
C.    *        of P1,P2.                                               *
C.    *                                                                *
C.    *    ==>Called by : GIPLAN,GICYL                                 *
C.    *       Author    H.Boerner  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
      REAL X,Y,D1,D2,A(4)
C.
C.
C.    ------------------------------------------------------------------
C.
C.
      IF (X.EQ.0.)                               GO TO 10
C
C
      FACT   = (D1 - D2) * 0.25
      A(1)   = - 1. * FACT * X
      A(3)   = FACT / X
      A(2)   = (6. * Y - (D1 + D2) * X) / (4. * X)
      A(4)   = ((D1 + D2)*X - 2.*Y) / (4.*X**3)
      RETURN
C
  10  A(1)   = 0.
      A(2)   = 1.
      A(3)   = 0.
      A(4)   = 0.
      END
+DECK,  GFDET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFDET(IUSET,IUDET,NV,NAMESV,NBITSV,IDTYPE
     +                ,NWHI,NWDI,ISET,IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       returns volume parameters for detector IUDET of set IUSET*
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * NV        number of volume descriptors                         *
C.    * NAMESV    vector of NV volume descriptors (4 characters)       *
C.    * NBITSV    vector of  NV bit numbers  for packing  the volume   *
C.    *           numbers                                              *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for the primary allocation of HITS   *
C.    *           banks                                                *
C.    * NWDI      number of words for the primary allocation of DIGI   *
C.    *           banks when first allocation not sufficient           *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The vector NAMESV (length NV)  contains the list of volume   *
C.    *   names which  permit the  identification of  every physical   *
C.    *   detector with detector name IUDET.    [See example in HITS   *
C.    *   110].                                                        *
C.    * - Each  element of  the vector  NBITSV (length  NV)  is  the   *
C.    *   number  of  bits  used  for  packing  the  number  of  the   *
C.    *   corresponding volume,  when building the packed identifier   *
C.    *   of a given physical detector.                                *
C.    * - Vectors NAMESV and NBITSV must be dimensionned at least      *
C.    *   to NV in the calling routine.                                *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun , M.Maire *********                     *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION NBITSV(1)
      CHARACTER*4 NAMESV(1),IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      ISET=0
      IDET=0
C
C             Check if detector IUDET has been defined
C
      IF (JSET.LE.0) GO TO 90
      NSET = IQ(JSET-1)
      IF (NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET.EQ.0) GO TO 90
      JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.LE.0) GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF (IDET.EQ.0) GO TO 95
      JD=LQ(JS-IDET)
      NV=IQ(JD+2)
      NWHI=IQ(JD+7)
      NWDI=IQ(JD+8)
C
      IF(NV.GT.0)THEN
         DO 10 I=1,NV
            CALL UHTOC(IQ(JD+2*I+ 9),4,NAMESV(I),4)
            NBITSV(I)=IQ(JD+2*I+10)
  10     CONTINUE
      ENDIF
C
      CALL GFATT(IUDET,'DTYP',IDTYPE)
      GO TO 99
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDET ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDET ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,  GFDETA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFDETA (IUSET,IUALI,IALI)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Returns the position IALI of the detector alias IUALI      *
C.    *                                                                *
C.    *    ==>Called by : <USER>,                                      *
C.    *       Author    F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      CHARACTER*4 IUSET,IUALI
C
C.    ------------------------------------------------------------------
C.
      IF (JSET.LE.0) GO TO 90
      NSET = IQ(JSET-1)
      IF (NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET.EQ.0) GO TO 90
      JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.LE.0) GO TO 90
      CALL GLOOK(IUALI,IQ(JS+1),NDET,IALI)
      IF (IALI.EQ.0) GO TO 95
      GO TO 99
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETA ERROR FOR SET ',A4)
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUALI
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETA ERROR FOR SET ',A4,' ALIAS ',A4,
     + ' NOT FOUND')
C
   99 RETURN
      END
+DECK,  GFDETD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFDETD(IUSET,IUDET,ND,NAMESD,NBITSD)
C.
C.    ******************************************************************
C.    *                                                                *
C.    * Returns digitisation  parameters for  detector IUDET  of set   *
C.    * IUSET.                                                         *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ND        number of elements per digitisation                  *
C.    * NAMESD    the  ND   variable  names  for   the  digitisation   *
C.    *           elements                                             *
C.    * NBITSD    the  ND  bit  numbers  for  packing  the  variable   *
C.    *           values.                                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION NBITSD(1)
      CHARACTER*4 IUSET,IUDET,NAMESD(1)
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 95
      JD=LQ(JS-IDET)
      JDD=LQ(JD-2)
      ND=IQ(JD+6)
C
      IF(ND.GT.0)THEN
         DO 10 I=1,ND
            CALL UHTOC(IQ(JDD+2*I-1),4,NAMESD(I),4)
            NBITSD(I)=IQ(JDD+2*I )
  10     CONTINUE
      ENDIF
      GO TO 99
C
C              Error
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETD ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETD ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,  GFDETH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFDETH(IUSET,IUDET,NH,NAMESH,NBITSH,ORIG,FACT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Returns hit parameters for detector IUDET of set IUSET.      *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * NH        number of elements per hit                           *
C.    * NAMESH    the NH variable names for the hit elements           *
C.    * NBITSH    the NH bit numbers for packing the variable values   *
C.    * ORIG      The quantity packed in the structure JHITS for the   *
C.    *           Ith variable is a  positive integer with NBITSH(I)   *
C.    *           bits and such that                                   *
C.    * FACT      IVAR(I) = (VAR(I)+ORIG(I))*FACT(I)                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun ,M.Maire *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION NBITSH(1),ORIG(1),FACT(1)
      CHARACTER*4 IUSET,IUDET,NAMESH(1)
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 95
      JD=LQ(JS-IDET)
      JDH=LQ(JD-1)
      NH=IQ(JD+4)
C
      IF(NH.GT.0)THEN
         DO 10 I=1,NH
            CALL UHTOC(IQ(JDH+4*I-3),4,NAMESH(I),4)
            NBITSH(I)=IQ(JDH+4*I-2)
            ORIG(I)  = Q(JDH+4*I-1)
            FACT(I)  = Q(JDH+4*I )
  10     CONTINUE
      ENDIF
      GO TO 99
C
C              Error
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETH ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETH ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,  GFDETU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFDETU(IUSET,IUDET,NUPAR,NW,UPAR)
C.
C.    *******************************************************************
C.    *                                                                 *
C.    *  Return in UPAR the first NUPAR user parameters of detector     *
C.    *  IUDET. NW is the total number of parameters(output), or zero   *
C.    *  if an  error occured.                                          *
C.    *                                                                 *
C.    *    ==>Called by : <USER>                                        *
C.    *       Author    W.Gebel  *********                              *
C.    *                                                                 *
C.    *******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION UPAR(1)
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      NW=0
      NSET=IQ(JSET-1)
      IF(NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,IS)
      IF(IS.LE.0) GO TO 90
      JS=LQ(JSET-IS)
      ND=IQ(JS-1)
      IF(ND.LE.0) GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),ND,ID)
      IF(ID.LE.0) GO TO 95
      JD=LQ(JS-ID)
      JU=LQ(JD-3)
      IF(JU.NE.0)THEN
         NW=IQ(JU-1)
         IF(NUPAR.GT.0) CALL UCOPY(Q(JU+1),UPAR(1),NUPAR)
      ENDIF
      GO TO 99
C
C              Error
C
   90 WRITE (CHMAIL, 1000) IUSET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GFDETU ERROR SET ',A4,' NOT FOUND')
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GFDETU ERROR FOR SET ',A4,
     + ' DETECTOR ',A4,' NOT FOUND')
C
  99  RETURN
      END
+DECK,  GFDIGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFDIGI(IUSET,IUDET,NTDIM,NVDIM,NDDIM,NDMAX,NUMVS
     +,                 LTRA,NTRA,NUMBV,KDIGI,NDIGS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *   Returns  the   digitisations  for   the  physical   volume   *
C.    * specified by the  list NUMVS with generic  volume name IUDET   *
C.    * belonging to set IUSET.                                        *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user    detector   identifier    (name   of    the   *
C.    *           corresponding sensitive volume)                      *
C.    * NTDIM     1st  dimension of  LTRA  (max.   number of  tracks   *
C.    *           contributing)                                        *
C.    * NVDIM     1st  dimension of  NUMVS,  NUMBV  (usually =NV, the  *
C.    *           number of volume descriptors which permit to iden-   *
C.    *           tify a given detector, possibly smaller than NV)     *
C.    * NDDIM     1st dimension of KDIGI (argument ND of GSDETD)       *
C.    * NDMAX     is  the  maximum  number of  digitisations  to  be   *
C.    *           returned                                             *
C.    * NUMVS     is a  1-Dim array that  must contain on  input the   *
C.    *           geometric  path  of  the  detector  volume  to  be   *
C.    *           selected.                                            *
C.    *           All 0  interpreted as  'all physical  volumes with   *
C.    *           generic name IUDET'                                  *
C.    * LTRA      is a 2-Dim  array that will contain  on output for   *
C.    *           each digitisation the numbers  of the tracks which   *
C.    *           have produced it                                     *
C.    * NTRA      is a 1-Dim  array that will contain  on output for   *
C.    *           each  digitisation  the  total  number  of  tracks   *
C.    *           contributing.                                        *
C.    *           In case this  number is greater than  NTDIM,  only   *
C.    *           the  first  NTDIM  corresponding   tracks  can  be   *
C.    *           returned on LTRA                                     *
C.    * NUMBV     is a 2-Dim  array that will contain  on output for   *
C.    *           each digitisation the list of volume numbers which   *
C.    *           identify each physical volume                        *
C.    * KDIGI     is  a 2-Dim  array  that  will contain  the  NDIGI   *
C.    *           digitisations                                        *
C.    * NDIGI     is  the  total  number of  digitisations  in  this   *
C.    *           detector.                                            *
C.    *           In  case  the  total number  of  digitisations  is   *
C.    *           greater than NDMAX,   NDIGI is set to  NDMAX+1 and   *
C.    *           only NDMAX digitisations are returned                *
C.    *     -  KDIGI(1,I)  =  digitisation type  1 for  digitisation   *
C.    *   number I                                                     *
C.    *     - NUMBV(1,I) = volume number 1 for digitisation number I   *
C.    *     -  LTRA (1,I)   =  first  track number  contributing  to   *
C.    *   digitisation number I                                        *
C.    *   In the calling  routine,  the arrays LTRA,   NTRA,  NUMVS,   *
C.    * NUMBV, KDIGI must be dimensioned to:                           *
C.    *    LTRA (NTDIM,NDMAX)                                          *
C.    *    NTRA (NDMAX)                                                *
C.    *    NUMVS(NVDIM)                                                *
C.    *    NUMBV(NVDIM,NDMAX)                                          *
C.    *    KDIGI(NDDIM,NDMAX)                                          *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    W.Gebel  *********                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      PARAMETER (NVMAX=20)
      DIMENSION NUMVT(NVMAX),NUMVS(NVDIM),NUMBV(NVDIM,1)
      DIMENSION LTRA(NTDIM,1),NTRA(1),KDIGI(NDDIM,1)
      EQUIVALENCE (WS(1),NUMVT(1))
      CHARACTER*4 IUSET,IUDET
C.
C.    --------------------------------------------------------------------------
C.
C             Find if selected set, detector exists
C
      NDIGS=0
      IF(JDIGI.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 999
C
      JS=LQ(JSET-ISET)
      JDI=LQ(JDIGI-ISET)
      IF(JS.LE.0)GO TO 999
      IF(JDI.LE.0)GO TO 999
      NDET=IQ(JS-1)
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.EQ.0)GO TO 999
C
      JD=LQ(JS-IDET)
      JDID=LQ(JDI-IDET)
      IF(JDID.LE.0)GO TO 999
      JDDI=LQ(JD-2)
C
      ILAST=IQ(JDI+IDET)
      IF(ILAST.EQ.0)GO TO 999
      NV=IQ(JD+2)
      ND=IQ(JD+6)
C
C
C             Loop on all digits
C
C
      IDIG=0
      I=0
      NWDI=0
C
   10 CONTINUE
      I=I+NWDI
      IF(I.GE.ILAST)GO TO 110
      NWDI=IQ(JDID+I+1)
      NK=2
C
      NTRM1= IBITS(IQ(JDID+I+NK),0,16)
      NTRT = NTRM1+1
      NWTR = NTRT/2+1
      NK   = NK+NWTR
C
C             Find the selected volume
C             (if NO volumes exist take ALL digits)
C
      IF(NV.GT.0)THEN
         K=1
         DO 40 IV=1,NV
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   K=1
                   NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IQ(JDID+I+NK)
               IF(IV.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IBITS(IQ(JDID+I+NK),K-1,NB)
               K=K+NB
            ENDIF
            IF(IV.LE.NVDIM)THEN
               IF(NUMVS(IV).NE.0)THEN
                  IF(NUMVS(IV).NE.NUMVT(IV))GO TO 10
               ENDIF
            ENDIF
   40    CONTINUE
         NK=NK+1
      ENDIF
C
C
C
C ========>   Now store number of tracks and volume numbers,
C             and fetch track numbers and digits
C
      IDIG=IDIG+1
      IF(IDIG.GT.NDMAX)GO TO 110
C
      NTRA(IDIG)=NTRT
      NVMIN=MIN(NV,NVDIM)
      CALL VZERO (NUMBV(1,IDIG),NVDIM)
      CALL UCOPY (NUMVT(1),NUMBV(1,IDIG),NVMIN)
C
C             Get track numbers
C
      MK=NK
      NK=2
      IF(NTRT.GT.0)THEN
         IF(NTRM1.GE.1)THEN
            DO 54 ITR=1,NTRM1,2
               IF(ITR.LE.NTDIM)THEN
                  LTRA(ITR ,IDIG)=IBITS(IQ(JDID+I+NK),16,16)
               ENDIF
               NK=NK+1
               IF(ITR.LT.NTDIM)THEN
                  LTRA(ITR+1,IDIG)=IBITS(IQ(JDID+I+NK), 0,16)
               ENDIF
   54       CONTINUE
         ENDIF
         IF(NTRT.LE.NTDIM)THEN
           IF(MOD(NTRT,2).EQ.1)
     +               LTRA(NTRT,IDIG)=IBITS(IQ(JDID+I+NK),16,16)
         ENDIF
      ENDIF
      NK=MK
C
C             Get unpacked digits
C
      IF(ND.LE.0)GO TO 10
      K=1
      DO 90 ID=1,ND
         NB=IQ(JDDI+2*ID)
         IF(NB.LE.0)THEN
            IF(K.GT.1)THEN
                K=1
                NK=NK+1
            ENDIF
            IF(ID.LE.NDDIM)KDIGI(ID,IDIG)=IQ(JDID+I+NK)
            IF(ID.NE.ND)NK=NK+1
         ELSE
            IF(K+NB.GT.33)THEN
               K=1
               NK=NK+1
            ENDIF
            IF(ID.LE.NDDIM)KDIGI(ID,IDIG)=IBITS(IQ(JDID+I+NK),K-1,NB)
            K=K+NB
         ENDIF
  90  CONTINUE
C
      GO TO 10
C
 110  NDIGS=IDIG
C
 999  RETURN
      END
+DECK,  GFHITS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFHITS(IUSET,IUDET,NVDIM,NHDIM,NHMAX,ITRS,NUMVS
     +,                 ITRA,NUMBV,HITS,NHITS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *   Returns the  hits produced  by track ITRS  (if 0,   by all   *
C.    * tracks)  in the physical volume  specified by the list NUMVS   *
C.    * with generic volume name IUDET belonging to set IUSET.         *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user    detector   identifier    (name   of    the   *
C.    *           corresponding sensitive volume)                      *
C.    * NVDIM     1st dimension of NUMBV and NUMVS (usually =NV, the   *
C.    *           number of volume descriptors which permit to identify*
C.    *           a given detector, eventually smaller than  NV)       *
C.    * NHDIM     1st  dimension  of  array  HITS  (argument  NH  of   *
C.    *           GSDETH)                                              *
C.    * NHMAX     maximum number of hits to be returned                *
C.    * ITRS      number of  the selected  track.   If  ITRS=0,  all   *
C.    *           tracks are taken                                     *
C.    * NUMVS     is a  1-Dim array that  must contain on  input the   *
C.    *           geometric  path  of  the  detector  volume  to  be   *
C.    *           selected.    All 0  interpreted  as 'all  physical   *
C.    *           volumes with generic names IUDET'                    *
C.    * ITRA      is a 1-Dim  array that will contain  on output for   *
C.    *           each  hit  the  number  of  the  track  which  has   *
C.    *           produced it                                          *
C.    * NUMBV     2-Dim array that  will contain on output  for each   *
C.    *           hit the list of volume numbers which identify each   *
C.    *           physical volume.   Zeroed when no more volumes are   *
C.    *           stored                                               *
C.    * HITS      2-Dim array that will contain the NHITS hits         *
C.    * NHITS     returns the number of selected  hits.  In case the   *
C.    *           total number of hits is greater than NHMAX,  NHITS   *
C.    *           is set to NHMAX+1 and only NHMAX hits are returned   *
C.    *   - HITS(1,I)  is the element 1 for hit number I               *
C.    *   - NUMBV(1,I) is the volume number 1 for hit number I         *
C.    *   - ITRA(I)    is  the  track number  corresponding  to  hit   *
C.    * number I                                                       *
C.    *   In the calling routine the arrays NUMVS,  NUMBV,  HITS and   *
C.    * ITRA must be dimensioned to:                                   *
C.    *     NUMVS(NVDIM)                                               *
C.    *     NUMBV(NVDIM,NHMAX)                                         *
C.    *     HITS(NHDIM,NHMAX)                                          *
C.    *     ITRA(NHMAX)                                                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      PARAMETER (NVMAX=20)
      DIMENSION NUMVT(NVMAX),NUMVS(NVDIM),NUMBV(NVDIM,1),ITRA(1)
      DIMENSION HITS(NHDIM,1)
      EQUIVALENCE (WS(1),NUMVT(1))
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
C             Find if selected set, detector exists
C
      NHITS=0
      IF(JHITS.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 999
C
      JS=LQ(JSET-ISET)
      JH=LQ(JHITS-ISET)
      IF(JS.LE.0)GO TO 999
      IF(JH.LE.0)GO TO 999
      NDET=IQ(JS-1)
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.EQ.0)GO TO 999
C
      JD=LQ(JS-IDET)
      JHD=LQ(JH-IDET)
      IF(JHD.LE.0)GO TO 999
      JDH=LQ(JD-1)
C
      ILAST=IQ(JH+IDET)
      IF(ILAST.EQ.0)GO TO 999
      NV=IQ(JD+2)
      NH=IQ(JD+4)
      NW=IQ(JD+1)+IQ(JD+3)+1
C
C
C             Loop on all hits
C
C
      IHIT=0
      DO 100 I=1,ILAST,NW
C
C             Find the selected track
C
      ITRT=IQ(JHD+I)
      IF(ITRS.NE.0 .AND. ITRS.NE.ITRT)GO TO 100
C
C             Find the selected volume
C             (if NO volumes exist take ALL hits)
C
      NK=1
      IF(NV.GT.0)THEN
         K=1
         DO 40 IV=1,NV
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   K=1
                   NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IQ(JHD+I+NK)
               IF(IV.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                 K=1
                 NK=NK+1
               ENDIF
               IF(IV.LE.NVMAX)NUMVT(IV)=IBITS(IQ(JHD+I+NK),K-1,NB)
               K=K+NB
            ENDIF
            IF(IV.LE.NVDIM)THEN
               IF(NUMVS(IV).NE.0)THEN
                  IF(NUMVS(IV).NE.NUMVT(IV))GO TO 100
               ENDIF
            ENDIF
   40    CONTINUE
         NK=NK+1
      ENDIF
C
C
C
C ========>   Now store track number and volume numbers and fetch hits
C
      IHIT=IHIT+1
      IF(IHIT.GT.NHMAX)GO TO 110
C
      ITRA(IHIT)=ITRT
      NVMIN=MIN(NV,NVDIM)
      DO 55 J=1,NVDIM
  55  NUMBV(J,IHIT)=0
      DO 57 J=1,NVMIN
  57  NUMBV(J,IHIT)=NUMVT(J)
C
C             Get unpacked hits
C             Hits origin is shifted . Division by scale factor
C
      IF(NH.GT.0)THEN
      K=1
      DO 90 IH=1,NH
         NB=IQ(JDH+4*IH-2)
         IF(NB.LE.0)THEN
            IF(K.GT.1)THEN
                K=1
                NK=NK+1
            ENDIF
            KHIT=IQ(JHD+I+NK)
            NK=NK+1
         ELSE
            IF(K+NB.GT.33)THEN
               K=1
               NK=NK+1
            ENDIF
            KHIT=IBITS(IQ(JHD+I+NK),K-1,NB)
            K=K+NB
         ENDIF
         IF(IH.LE.NHDIM)THEN
            HITS(IH,IHIT)=FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
         ENDIF
  90  CONTINUE
      ENDIF
 100  CONTINUE
C
 110  NHITS=IHIT
C
 999  RETURN
      END
+DECK,  GFNDIG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFNDIG (IUSET, IUDET, NDIGI)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GFNDIG (IUSET, IUDET, NDIGI*)                         *
C.    *                                                                *
C.    *   Returns the number of digits belonging to the detector IUDET *
C.    *   of set IUSET                                                 *
C.    *                                                                *
C.    *   IUSET    User set identifier                                 *
C.    *   IUDET    User detector identifier (name of the corresponding *
C.    *            sensivitive volume)                                 *
C.    *   NDIGI    returns the total number of digits                  *
C.    *                                                                *
C.    *   Called by : <USER>                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      CHARACTER*4     IUSET, IUDET
C.
C.    ------------------------------------------------------------------
*
* *** Find if selected set, detector exists
*
      NDIGI = 0
      IF (JDIGI.LE.0)   GO TO 999
      NSET  = IQ(JSET-1)
      CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
      IF (ISET.LE.0)    GO TO 999
*
      JS    = LQ(JSET-ISET)
      JDI   = LQ(JDIGI-ISET)
      IF (JS.LE.0)      GO TO 999
      IF (JDI.LE.0)     GO TO 999
      NDET  = IQ(JS-1)
      CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
      IF (IDET.LE.0)    GO TO 999
*
      JDID  = LQ(JDI-IDET)
      IF (JDID.LE.0)    GO TO 999
      ILAST = IQ(JDI+IDET)
*
      IF (ILAST.NE.0) NDIGI = IQ(JDID+ILAST)
*                                                             END GFNDIG
  999 END
+DECK,  GFNHIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:09  cernlib
* Geant

      SUBROUTINE GFNHIT (IUSET, IUDET, NHITS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GFNHIT (IUSET, IUDET, NHITS*)                         *
C.    *                                                                *
C.    *   Returns the number of hits belonging to the detector IUDET   *
C.    *   of set IUSET                                                 *
C.    *                                                                *
C.    *   IUSET    User set identifier                                 *
C.    *   IUDET    User detector identifier (name of the corresponding *
C.    *            sensivitive volume)                                 *
C.    *   NHITS    returns the total number of hits                    *
C.    *                                                                *
C.    *   Called by : <USER>                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      CHARACTER*4     IUSET, IUDET
C.
C.    ------------------------------------------------------------------
*
* *** Find if selected set, detector exists
*
      NHITS = 0
      IF (JHITS.LE.0)   GO TO 999
      NSET  = IQ(JSET-1)
      CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
      IF (ISET.LE.0)    GO TO 999
*
      JS    = LQ(JSET-ISET)
      JH    = LQ(JHITS-ISET)
      IF (JS.LE.0)      GO TO 999
      IF (JH.LE.0)      GO TO 999
      NDET  = IQ(JS-1)
      CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
      IF (IDET.LE.0)    GO TO 999
*
      JD    = LQ(JS-IDET)
      JHD   = LQ(JH-IDET)
      IF (JHD.LE.0)     GO TO 999
      NFIX  = IQ(JD+1) + IQ(JD+3) + 1
      ILAST = IQ(JH+IDET)
*
      IF (ILAST.GT.0) NHITS = ILAST / NFIX
*                                                             END GFNHIT
  999 END
+DECK,  GFPATH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:10  cernlib
* Geant

      SUBROUTINE GFPATH (ISET, IDET, NUMBV, NLEV, LNAM, LNUM)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Return the lists of NLEV volume names (LNAM) and numbers  *
C.    *      (LNUM) which identify the path through the JVOLUM data    *
C.    *      structure for the volume corresponding to the detector    *
C.    *      at position IDET in set at position ISET identified by    *
C.    *      the list of node identifiers given in NUMBV.              *
C.    *                                                                *
C.    *      NLEV is expected to be greater than 1                     *
C.    *      and no checks are performed on the validity of ISET/IDET  *
C.    *      In case of user error NLEV returns with the value 0.      *
C.    *                                                                *
C.    *   ==> Called by : <USER>                                       *
C.    *         Author  F.Bruyant  **********                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      INTEGER  LNAM(*), LNUM(*), NUMBV(*)
C.
C.    -----------------------------------------------------------------
C.
      JS = LQ(JSET-ISET)
      JD = LQ(JS-IDET)
      NV = IQ(JD+2)
      IPJD = JD +10 +2*NV
      LNAM(1) = IQ(IPJD+1)
      LNUM(1) = 1
      NLEV = IQ(IPJD+2)
C
      NSOL = IQ(JD+9)
      IF (NSOL.EQ.1) THEN
C
C       Usual case
C
        I = 0
        DO 10 N = 2,NLEV
          IPJD = IPJD +2
          LNAM(N) = IQ(IPJD+1)
          LNUM(N) = 1
          IF (IQ(IPJD+2).LE.1) GO TO 10
          I = I +1
          LNUM(N) = NUMBV(I)
   10   CONTINUE
C
      ELSE IF (NSOL.GT.1) THEN
C
C       Case with multiple path
C
        IPSTO = IPJD
        DO 90 IS = 1,NSOL
          IPJDD = JD +8
          DO 30 I = 1,NV
            IPJDD = IPJDD +2
            IF (NUMBV(I).EQ.0)  GO TO 30
            IPJD = IPSTO
            DO 20 N = 2,NLEV
              IPJD = IPJD +2
              IF (IQ(IPJD+1).EQ.IQ(IPJDD+1))  GO TO 30
   20       CONTINUE
            GO TO 81
   30     CONTINUE
C
C         Fill LNAM,LNUM
C
          IPJD = IPSTO
          DO 40 N = 2,NLEV
            IPJD = IPJD +2
            LNAM(N) = IQ(IPJD+1)
            LNUM(N) = 1
   40     CONTINUE
          IPJDD = JD +8
          DO 60 I = 1,NV
            IPJDD = IPJDD +2
            IF (NUMBV(I).EQ.0)  GO TO 60
            IPJD = IPSTO
            DO 50 N = 2,NLEV
              IPJD = IPJD +2
              IF (IQ(IPJD+1).NE.IQ(IPJDD+1))  GO TO 50
              IF (NUMBV(I).GT.IQ(IPJD+2)) GO TO 991
              LNUM(N) = NUMBV(I)
              GO TO 60
   50       CONTINUE
   60     CONTINUE
          GO TO 999
C
   81     IF (IS.EQ.NSOL)  GO TO 991
          IPSTO = IPSTO +2*NLEV
          NLEV = IQ(IPSTO+2)
C
   90   CONTINUE
C
      ELSE
C
C       User error
C
        GO TO 991
C
      ENDIF
      GO TO 999
C
  991 NLEV = 0
      WRITE (CHMAIL, 1000) IQ(JD+9)
      CALL GMAIL(0,0)
C
 1000 FORMAT (' ***** GFPATH USER ERROR, IQ(JD+9)=',I2)
C
  999 RETURN
      END
+DECK,  GGDETV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:10  cernlib
* Geant

      SUBROUTINE GGDETV (ISET, IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routine - to compute and store the list of volumes which    *
C.    *    permit to identify uniquely any detector volume specified   *
C.    *    by  the set number ISET, the detector number IDET and the   *
C.    *    corresponding list of volume copy numbers                   *
C.    *            - to compute and store the physical path(s) through *
C.    *    the JVOLUM data structure down to the given detector volume *
C.    *                                                                *
C.    *    ==>Called by : GHCLOS                                       *
C.    *         Author  F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCNUM.
+CDE, GCUNIT.
C.
      PARAMETER (NLVMAX=15,NSKMAX=20,NVMAX=20)
      INTEGER  IVOSK(NSKMAX,NLVMAX-1), LIMUL(NLVMAX), LINAM(NLVMAX)
     +,        LIST(2), NSK(NLVMAX-1)
      EQUIVALENCE (LINAM(1),WS(1)), (LIMUL(1),WS(NLVMAX+1)), (IVOSK(1,1)
     +,   WS(2*NLVMAX+1)), (NSK(1),WS((NSKMAX+2)*(NLVMAX-1)+3))
     +,   (LIST(1),WS((NSKMAX+3)*(NLVMAX-1)+3))
C.
C.         -------------------------------------------------------------
C.
      JS = LQ(JSET-ISET)
      JD = LQ(JS-IDET)
C
C     Check that JD bank has been created by GSDETV (not GSDET)
C      or has not been already processed.
C
      IF (IQ(JD+9).NE.-1) GO TO 999
      IQ(JD+9) = -2
      IHDET = IQ(JS+IDET)
      IF (IDEBUG.NE.0) THEN
         WRITE (CHMAIL, 1001) IHDET
         CALL GMAIL (0,0)
 1001    FORMAT (' GGDETV : Detector ',A4)
      ENDIF
C
C     Check that current detector is not an alias
C
      IALI = IQ(JD+10)
      IF (IALI.NE.0) GO TO 200
      NSOL = 0
      NV = 0

      NLIST = 0
      CALL VZERO (NSK, NLVMAX-1)
      NLEV = 1
      LINAM(1) = IHDET
      MULT1 = 1
   10 IVOS = IUCOMP (LINAM(NLEV), IQ(JVOLUM+1), NVOLUM)
C
C     Search for detector parents up to top of tree
C
   20 IF (IVOS.EQ.1) GO TO 60
C
      DO 40 IVO=1,NVOLUM
         IF (IVO.EQ.IVOS) GO TO 40
         JVO = LQ(JVOLUM-IVO)
         NIN = Q(JVO+3)
         IF (NIN.EQ.0) GO TO 40
         IF (NSOL.GT.0) THEN
C           Skip mother banks already found
            IF (IUCOMP (IVO, IVOSK(1,NLEV), NSK(NLEV)) .NE. 0) GO TO 40
         ENDIF
C
         IF (NIN.LT.0) THEN
C           Division case
            JDIV = LQ(JVO-1)
            IF (IFIX(Q(JDIV+2)).NE.IVOS) GO TO 40
            MULTI = ABS(Q(JDIV+3))
            IF (MULTI.EQ.0)  MULTI = 255
         ELSE
C           Position case
            MULTI = 0
            DO 30 IN=1,NIN
               JIN = LQ(JVO-IN)
               IF (IFIX(Q(JIN+2)).NE.IVOS) GO TO 30
               MULTI = MAX(MULTI, IFIX(Q(JIN+3)))
   30       CONTINUE
            IF (MULTI.EQ.0) GO TO 40
         ENDIF
C
C     New level found
C
         LIMUL(NLEV) = MULTI
         IF (NLEV.EQ.NLVMAX) GO TO 920
         IF (NSK(NLEV).EQ.NSKMAX) GO TO 930
         NSK(NLEV) = NSK(NLEV) +1
         IVOSK(NSK(NLEV),NLEV) = IVO
         NLEV = NLEV +1
         LINAM(NLEV) = IQ(JVOLUM+IVO)
         IVOS = IVO
         GO TO 20
C
   40 CONTINUE
C
C     No more path found at current level
C
      IF (NSK(NLEV).EQ.0) GO TO 910
      IF (NSK(NLEV).GT.1.OR.LIMUL(NLEV+1).GT.1) THEN
         DO 50 N = 1,NSK(NLEV)
            IVO = IVOSK(N,NLEV)
            NANEW = IQ(JVOLUM+IVO)
            IPJD = JD +10
            IF (NV.GT.0) THEN
               DO 49 I = 1,NV
                  IF (NANEW.EQ.IQ(IPJD+1)) GO TO 50
                  IPJD = IPJD +2
   49          CONTINUE
            ENDIF
            IF (NV.EQ.NVMAX) GO TO 940
            NV = NV +1
            IQ(IPJD+1) = NANEW
   50    CONTINUE
      ENDIF
      GO TO 90
C
C     Store current solution
C
   60 NSOL = NSOL +1
      LIMUL(NLEV) = 0
      IF (LIMUL(1).GT.MULT1) MULT1 = LIMUL(1)
+SELF, IF=DEBUGG.
      IF (IDEBUG.NE.0) THEN
         WRITE (CHMAIL, 1002) NSOL, NLEV
         CALL GMAIL (0,0)
         WRITE (CHMAIL, 1012) (LINAM(I),LIMUL(I),I=1,NLEV)
         CALL GMAIL (0,0)
 1002    FORMAT (' GGDETV DEBUG : NSOL,NLEV ',2I3)
 1012    FORMAT (15(1X,A4,I3))
      ENDIF
+SELF.
C
      DO 80 N = NLEV,1,-1
         LIST(NLIST+1) = LINAM(N)
         LIST(NLIST+2) = LIMUL(N)
         IF (N.EQ.NLEV)  LIST(NLIST+2) = NLEV
         NLIST = NLIST +2
   80 CONTINUE
      IF (NLEV.LT.3) GO TO 100
      NLEV = NLEV -1
C
   90 NSK(NLEV) = 0
      NLEV = NLEV -1
      IF (NLEV.GT.0) GO TO 10
C
  100 IF (MULT1.GT.1) THEN
        NV = NV +1
        IQ(JD+9+2*NV) = LINAM(1)
      ENDIF
C
C     Perform final operations on JD bank
C
      NW = 0
      IF (NV.EQ.0) GO TO 150
C
C     Compute maximum multiplicities
C
      DO 120 N = 1,NLIST,2
         IPJD = JD +10
         DO 110 I = 1,NV
            IF (IQ(IPJD+1).EQ.LIST(N))
     +          IQ(IPJD+2)=MAX(IQ(IPJD+2),LIST(N+1))
            IPJD = IPJD +2
  110    CONTINUE
  120 CONTINUE
C
      IF (IDEBUG.NE.0) THEN
         I2 = 0
  125    I1 = I2 + 1
         I2 = I1 + 14
         IF (I2.GT.NV) I2 = NV
         WRITE (CHMAIL, 1003) (IQ(JD+10+I),I=2*I1-1,2*I2)
         CALL GMAIL (0, 0)
         IF (I2.LT.NV)  GO TO 125
 1003    FORMAT (10X,15(1X,A4,I3))
      ENDIF
C
C     Compute corresponding bit numbers for packing
C
      IPJD = JD +10
      K = 32
      DO 140 N = 1,NV
         NBITS = 0
  130    NBITS = NBITS +1
         IF (IQ(IPJD+2).GT.2**NBITS-1) GO TO 130
         IF (NBITS.GE.32)  NBITS = 0
         IQ(IPJD+2) = NBITS
         IPJD = IPJD +2
         IF (NBITS.EQ.0) THEN
            K = 32
            NW = NW +1
         ELSE
            K = K +NBITS
            IF (K.LE.32) GO TO 140
            K = NBITS
            NW = NW +1
         ENDIF
  140 CONTINUE
C
  150 IQ(JD+1) = NW
      IQ(JD+2) = NV
      IQ(JD+9) = NSOL
C
      NDATA = 10 +2*NV +NLIST
      ND = IQ(JD-1)
      CALL MZPUSH (IXCONS, JD, 0, NDATA-ND, 'I')
      CALL UCOPY (LIST, IQ(JD+2*NV+11), NLIST)
+SELF, IF=DEBUGG.
      IF (IDEBUG.NE.0) THEN
         ND1=MIN(10,NDATA)
         WRITE (CHMAIL, 1004) NDATA,(IQ(JD+I),I=1,ND1)
         CALL GMAIL (0,0)
         DO 160 II=ND1+1,NDATA,10
            ND2=MIN(II+9,NDATA)
            WRITE (CHMAIL, 1005) (IQ(JD+I),I=II,ND2)
            CALL GMAIL (0,0)
 160     CONTINUE
 1004    FORMAT (' GGDETV DEBUG : NDATA ',I3,'  JD --> ',10I4)
 1005    FORMAT (10(1X,A4,I4))
      ENDIF
+SELF.
      GO TO 999
C
C     Current detector IDET is an alias
C
  200 CONTINUE
      IF (IDEBUG.NE.0) THEN
         IHALI = IQ(JS+IALI)
         WRITE (CHMAIL, 1006) IHALI
         CALL GMAIL (0,0)
 1006    FORMAT ('       Alias of detector ',A4)
      ENDIF
C
      IDM = IQ(JD+10)
      JDM = LQ(JS-IDM)
      NDM = IQ(JDM-1)
      ND = IQ(JD-1)
      CALL MZPUSH (IXCONS, JD, 0, NDM-ND, 'I')
      NWHI = IQ(JD+7)
      NWDI = IQ(JD+8)
      JS = LQ(JSET-ISET)
      JDM  = LQ(JS-IDM)
      CALL UCOPY (IQ(JDM+1), IQ(JD+1), NDM)
      IQ(JD+7) = NWHI
      IQ(JD+8) = NWDI
      IQ(JD+10) = IDM
      GO TO 999
C
C     Errors
C
  910 WRITE (CHMAIL, 1000) LINAM(NLEV)
      CALL GMAIL (0,0)
 1000 FORMAT (' GGDETV : Hanging volume ',A4)
      GO TO 990
  920 CHMAIL=' GGDETV : Parameter NLVMAX too small'
      CALL GMAIL (0,0)
      GO TO 990
  930 CHMAIL=' GGDETV : Parameter NSKMAX too small'
      CALL GMAIL (0,0)
      GO TO 990
  940 CHMAIL=' GGDETV : NVMAX (= size of NUMBV) too small'
      CALL GMAIL (0,0)
  990 IEOTRI = 1
C
  999 RETURN
      END
+DECK,  GHITS_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:21:08  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*           Introduction to the Detector Response package              *
*           ---------------------------------------------              *
*                                                                      *
*                                                                      *
* THE DETECTOR RESPONSE PACKAGE                                        *
*                                                                      *
* In the context of GEANT3:                                            *
*                                                                      *
* - a hit is  the user defined 'quantum of  information' recorded at   *
*   tracking  time to  keep  track of  the  interaction between  one   *
*   particle  and  a  given  sensitive  detector,  and  regarded  as   *
*   necessary to compute the digitisations later.                      *
*                                                                      *
* - a  digitisation is  the  user defined  'quantum of  information'   *
*   simulating  the  response of  a  given  detector element,  after   *
*   tracking  of a  complete event.                                    *
*                                                                      *
*  The detector response package consists  of tools to store in, and   *
* retrieve or print from, the  data structures JSET, JHITS and JDIGI   *
* the information  relevant to  the hits  and digitisations.   A few   *
* subroutines which  may help the  user to  solve some of  the usual   *
* problems of  digitisation in simple  detectors have been  added to   *
* the package,  e.g. the intersection of  a track with a  plane or a   *
* cylinder  and  the  digitisation  of conventional  drift  and  MWP   *
* chambers.                                                            *
*  For complex  set-ups with different  types of detectors  the user   *
* has normally  to define several  types of hits  and digitisations.   *
* In addition to the hits generated  by all particles of the current   *
* event,   computing  the   digitisations   requires  usually   some   *
* information about the intrinsic characteristics and performance of   *
* the detectors.                                                       *
*  The information to be recorded  for the hits and digitisations is   *
* highly  experiment dependent,  therefore only  a framework  can be   *
* proposed  to  store  it.   The solution  adopted  here  should  be   *
* satisfactory  for most  of  the applications.   Feedback from  the   *
* users is needed and will be welcome.                                 *
*  Two remarks can be made:                                            *
*                                                                      *
* - the stability of the information to be stored is usually reached   *
*   much earlier for the hits than for the digitisations.  Therefore   *
*   the user  may save computing  time by designing  an intermediate   *
*   event output at the hits level.                                    *
* - the scheme proposed for storing  the digitisations should in any   *
*   case be considered  as an intermediate stage,   a reshuffling of   *
*   the data  being necessary  if the  user wants  to simulate  more   *
*   closely the specific format of the real data acquisition system.   *
*                                                                      *
* SETS AND DETECTORS                                                   *
*                                                                      *
* The reader is assumed to be  familiar with the way the geometrical   *
* setup is described [GEOM 001],  in particular with the concepts of   *
* logical volume structure  and of physical path  through the volume   *
* tree.                                                                *
*  The  user  is  required  to  classify  into  sets  all  sensitive   *
* detectors for which  storing the hits in the  data structure JHITS   *
* is wanted.                                                           *
*  The 4-character names  which identify the sets  are user defined,   *
* and the list of sets which the  user wants to activate for a given   *
* run  can be  entered  through the  data card  SETS.   The user  is   *
* entirely  free to  group  together,  in one  or  in several  sets,   *
* detectors  of   the  same  type   or  of  different   types.   For   *
* convenience, it is  recommended to have at least one  set for each   *
* main   component  of   the   setup,   e.g.  hadron   calorimeters,   *
* electromagnetic calorimeters, vertex chamber, etc.                   *
*   A detector  can be  declared as  sensitive through  the tracking   *
* medium  parameter  ISVOL,  and  allocated to  a  set  through  the   *
* subroutine GSDET.   Currently, the active sets  and detectors have   *
* to be  redefined for every run.   Tools will be provided  later to   *
* read in part  or the whole of the information  from a previous run   *
* and  to  update the  relevant  structures  according to  the  user   *
* requirements.                                                        *
*   Each (logical) detector is identified by the 4-character name of   *
* the corresponding volume.  As a  given volume may describe several   *
* similar  detectors   of  the   physical  setup,   some  additional   *
* information is needed for associating  correctly the hits with the   *
* physical detectors.  The user has  to enter the (shortest) list of   *
* volume names,  the vector NAMESV, which  permits identification of   *
* the  path through  the  physical  tree, even  in  the presence  of   *
* multiple copies at  the volume level or at any  lower level in the   *
* tree.   The  identification  will  be  achieved  when  needed,  by   *
* specifying a list  of volume numbers, the vector NUMBV,  in one to   *
* one  correspondence with  the above  list of  volume names.   This   *
* list,  after  packing,  will  constitute  the  identifier  of  the   *
* physical detector.                                                   *
*                                                                      *
* THE BASIC USER TOOLS                                                 *
*                                                                      *
* The  data structure  JSET is  built through  calls to  the routine   *
* GSDET  which  allocates  detectors   to  sets  and  defines  their   *
* parameters,  and  to the  auxiliary  routines  GSDETH, GSDETD  and   *
* GSDETU which  store respectively in  the structure JSET,  for each   *
* logical detector separately:                                         *
*                                                                      *
* - the parameters required  for the storage of the  hit elements in   *
*   the  data  structure JHITS,  such  as  the packing  and  scaling   *
*   conventions.                                                       *
*                                                                      *
* - the parameters required for the  storage of the digitisations in   *
*   the structure JDIGI,  such as the packing  conventions. the user   *
*   parameters, which  may consist,  for instance, of  the intrinsic   *
*   detector characteristics needed for computing the digitisations.   *
*                                                                      *
*  To  permit storage  of more  than  one type  of hit  for a  given   *
* sensitive  detector, detector  'aliases'  can  be defined  through   *
* calls  to  the routine  GSDETA.   They  are  entered in  the  JSET   *
* structure  as  additional  detectors, with  the  same  geometrical   *
* characteristics  as the  original  one.  Then,  the  user has  the   *
* possibility to  call the  appropriate routines GSDETH,  GSDETD and   *
* GSDETU.                                                              *
*  During  the   tracking,  for  each  step   inside  the  sensitive   *
* detectors, under control of the subroutine GUSTEP, the hits can be   *
* stored in the data structure  JHITS with the subroutine GSAHIT (or   *
* GSCHIT,  more  appropriate for  calorimetry).   For  each hit  the   *
* information consists of:                                             *
*                                                                      *
* - the reference to the track in the structure JKINE,                 *
* - the packed identifier of the physical detector, and                *
* - the packed data for the different elements of the hit.             *
*                                                                      *
*  When  the tracking  has been  completed for  the whole  event the   *
* digitisations can be computed in  the user subroutine GUDIGI which   *
* may  extract the  hits with  the subroutine  GFHITS and  store the   *
* digitisations  in the  data structure  JDIGI, with  the subroutine   *
* GSDIGI.   For each  digitisation the  information should  at least   *
* consist of:                                                          *
*                                                                      *
* - the reference to the track(s),                                     *
* - the packed identifier of the physical detector, and                *
* - the packed data for the digitisation itself.                       *
*                                                                      *
* RETRIEVAL OF GEOMETRICAL INFORMATION                                 *
*                                                                      *
*  The packed  identifier of as  physical detector stored a  part of   *
* the hit  (or digitisation) information, is  returned (unpacked) by   *
* the routines GFHITS  or GFDIGI which extract  the information from   *
* the JHITS  or JDIGI structures,  and may  be used to  retrieve the   *
* identity and geometrical characteristics of the given detector.      *
*   At  the  moment this  is  automatized  through  the use  of  the   *
* routines GFPATH  (which assumes that the  sensitive detectors have   *
* been declared  through the routine  GSDETV, not GSDET)  and GLVOLU   *
* which fills the common /GCVOLU/.                                     *
*   GFPATH prepares the lists LNAM  and LNUM required by the routine   *
* GLVOLU [GEOM 001].                                                   *
*   Worth  is in  progress in  this area  and might  lead to  a more   *
* transparent approach.  Therefore, the  routines GSDETV, GGDETV and   *
* GFPATH  and  their action  on  the  structure  JSETS will  not  be   *
* documented in more detail now.                                       *
*                                                                      *
************************************************************************
#endif
+DECK,  GICYL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:10  cernlib
* Geant

      SUBROUTINE GICYL(R,X1,X2,S1,S2,IC,XINT,SINT,PZINT,IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Intersection of a Track with a Cylinder or a Plane         *
C.    *     --------------------------------------------------         *
C.    *                                                                *
C.    *   Calculates intersection of track (x1,x2)  with cylindrical   *
C.    * detector of radius R.  The track  is approximated by a cubic   *
C.    * in the track length.  To  improve stability,  the coordinate   *
C.    * system is shifted.                                             *
C.    * R         radius of cylinder in cm                             *
C.    * X1        x,y,z,xp,yp,zp of 1st point                          *
C.    * X2        x,y,z,xp,yp,zp of 2nd point                          *
C.    * S1(2)     S at 1st (2nd) point                                 *
C.    * IC        =1 straight line defined by x+xp                     *
C.    * IC        =2 straight line defined by x1+x2                    *
C.    * IC        =3 cubic model                                       *
C.    * XINT      x,y,z,xp,yp,zp at intersection point                 *
C.    * SINT      S at intersection point                              *
C.    * PZINT     phi,z,dphi/dr,dz/dr                                  *
C.    * IFLAG     =1 if track intersects cylinder, =0 if not           *
C.    *   Calculates  intersection  of  track  (x1,x2)   with  plane   *
C.    * parallel to (X-Z).   The track is approximated by a cubic in   *
C.    * the  track length.   To improve  stability,  the  coordinate   *
C.    * system is shifted.                                             *
C.    * YC        Y coordinate of plane                                *
C.    * X1,...    as for GICYL                                         *
C.    * IFLAG     =1 if track intersects plane,                        *
C.    *           =0 if not                                            *
C.    * Warning:  the default accuracy is  10 microns.  The value of   *
C.    *         EPSI  (internal variable)   must  be  changed for  a   *
C.    *         better precision.                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *                                                                *
C.    *       AUTHORS:R.BRUN/JJ.DUMONT FROM AN ORIGINAL ROUTINE BY     *
C.    *       H. BOERNER  KEK  OCTOBER 1982                            *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X1(6),X2(6),XINT(6),PZINT(4),A(4),B(4),C(4)
C
      DATA MAXHIT/100/
      DATA EPSI2/0.000001/
C.
C.
C.    ------------------------------------------------------------------
C.
C.
      IFLAG  = 1
      R12    = X1(1) * X1(1) + X1(2) * X1(2)
      R22    = X2(1) * X2(1) + X2(2) * X2(2)
      R2     = R * R
      DR2  = R22-R2
C
C             TRACK CROSSING THE CYLINDER FROM INSIDE OR OUTSIDE ?
C
      IF (R22.LT.R12)                            GO TO 5
      IF (R2.LT.R12)                             GO TO 90
      IF (R2.GT.R22)                             GO TO 90
      DRCTN  = 1.
      IF (IC.EQ.3) GO TO 7
C
      IF(IC.EQ.2) GOTO 30
      S=S1
      DXDS=X1(4)
      DYDS=X1(5)
      DZDS=X1(6)
      BX=X1(1)-DXDS*S
      BY=X1(2)-DYDS*S
      BZ=X1(3)-DZDS*S
      GO TO 40
C
   5  IF (R2.LT.R22)                             GO TO 90
      IF (R2.GT.R12)                             GO TO 90
      DRCTN  = - 1.
C
      IF(IC.EQ.3) GOTO 7
      IF(IC.EQ.2) GOTO 30
      S=S2
      DXDS=X2(4)
      DYDS=X2(5)
      DZDS=X2(6)
      BX=X2(1)-DXDS*S
      BY=X2(2)-DYDS*S
      BZ=X2(3)-DZDS*S
      GOTO 40
C
   30 DX=X2(1)-X1(1)
      DY=X2(2)-X1(2)
      DZ=X2(3)-X1(3)
      DS=SQRT(DX*DX+DY*DY+DZ*DZ)
      S=S1
      DXDS=DX/DS
      DYDS=DY/DS
      DZDS=DZ/DS
      BX=X1(1)-DXDS*S
      BY=X1(2)-DYDS*S
      BZ=X1(3)-DZDS*S
C
   40 AE=DYDS*DYDS+DXDS*DXDS
      IF(AE.EQ.0.) GO TO 30
      BE=DXDS*BX+DYDS*BY
      CE=BY*BY+BX*BX-R2
      SG=SIGN(1.,DR2)
      XX=BE*BE-AE*CE
      IF(XX.LE.0.) GOTO 30
      TRLEN=(SG*SQRT(ABS(XX))-BE)/AE
      XINT(1)=DXDS*TRLEN+BX
      XINT(2)=DYDS*TRLEN+BY
      XINT(3)=DZDS*TRLEN+BZ
      SINT=TRLEN
      XINT(4)=DXDS
      XINT(5)=DYDS
      XINT(6)=DZDS
      GO TO 200
C
C             SHIFT COORDINATE SYSTEM SUCH THAT CENTER OF GRAVITY=0
C
   7  IF(R.LE.0.)                                GO TO 90
      SHIFTX = (X1(1) + X2(1)) * 0.5
      SHIFTY = (X1(2) + X2(2)) * 0.5
      SHIFTZ = (X1(3) + X2(3)) * 0.5
      SHIFTS = (S1 + S2) * 0.5
C
C             ONLY ONE VALUE NECESSARY SINCE X1= -X2 ETC.
C
      XSHFT  = X1(1) - SHIFTX
      YSHFT  = X1(2) - SHIFTY
      ZSHFT  = X1(3) - SHIFTZ
      SSHFT  = S1 - SHIFTS
C
      PABS1  = SQRT(X1(4)**2 + X1(5)**2 + X1(6)**2)
      PABS2  = SQRT(X2(4)**2 + X2(5)**2 + X2(6)**2)
      IF (PABS1.EQ.0..OR.PABS2.EQ.0.)            GO TO 90
C
C             PARAMETRIZE THE TRACK BY A CUBIC THROUGH X1,X2
C
      CALL GCUBS(SSHFT,XSHFT,X1(4)/PABS1,X2(4)/PABS2,A)
      CALL GCUBS(SSHFT,YSHFT,X1(5)/PABS1,X2(5)/PABS2,B)
      CALL GCUBS(SSHFT,ZSHFT,X1(6)/PABS1,X2(6)/PABS2,C)
C
C             ITERATE TO FIND THE TRACK LENGTH CORRESPONDING TO
C             THE INTERSECTION OF TRACK AND CYLINDER.
C             START AT S=0. MIDDLE OF THE SHIFTED INTERVAL.
C
      DINTER = ABS(S2 - S1) * 0.5
      S      = 0.
C
      DO 10 I = 1,MAXHIT
         X = SHIFTX + A(1) + S * (A(2) + S * (A(3) + S * A(4)))
         Y = SHIFTY + B(1) + S * (B(2) + S * (B(3) + S * B(4)))
         RN2    = X * X + Y * Y
         DR2    = (R2 - RN2) * DRCTN
         IF (ABS(DR2).LT.EPSI2)                     GO TO 20
         DINTER = DINTER * 0.5
         IF (DR2.LT.0.)S = S - DINTER
         IF (DR2.GE.0.)S = S + DINTER
  10  CONTINUE
C
C             COMPUTE INTERSECTION IN ORIGINAL COORDINATES
C
  20  CONTINUE
      XINT(1) = SHIFTX + A(1) + S * (A(2) + S * (A(3) + S * A(4)))
      XINT(2) = SHIFTY + B(1) + S * (B(2) + S * (B(3) + S * B(4)))
      XINT(3) = SHIFTZ + C(1) + S * (C(2) + S * (C(3) + S * C(4)))
      XINT(4) = A(2) + S * (2. * A(3) + 3. * S * A(4))
      XINT(5) = B(2) + S * (2. * B(3) + 3. * S * B(4))
      XINT(6) = C(2) + S * (2. * C(3) + 3. * S * C(4))
C
C             COMPUTE PHIHIT,ZHIT AND CORRESPONDING DERIVATIVES
C
      SINT   = S + SHIFTS
  200 TERM   = 1. / (XINT(4) * XINT(1) + XINT(5) * XINT(2))
      PZINT(1) = ATAN2(XINT(2),XINT(1))
      PZINT(2) = XINT(3)
      PZINT(3) = (XINT(1) * XINT(5) - XINT(2) * XINT(4)) * TERM / R
      PZINT(4) = TERM * XINT(6) * R
      RETURN
C
  90  IFLAG  = 0
      END
+DECK,  GIPLAN, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:10  cernlib
* Geant

      SUBROUTINE GIPLAN(YC,X1,X2,S1,S2,IC,XINT,SINT,PZINT,IFLAG)
C.
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Calculates intersection of track (X1,X2)                 *
C.    *       with plane parallel to (X-Z)                             *
C.    *        The track is approximated by a cubic in the             *
C.    *       track length.                                            *
C.    *       To improve stability, the coordinate system              *
C.    *       is shifted.                                              *
C.    *       input parameters                                         *
C.    *        YC    = Y COORDINATE OF PLANE                           *
C.    *        X1    = X,Y,Z,XP,YP,ZP OF 1ST POINT                     *
C.    *        X2    =                   2ND                           *
C.    *        S1(2) = S AT 1ST(2ND) POINT                             *
C.    *        IC    = 1 STRAIGHT LINE DEFINED BY X+XP                 *
C.    *        IC    = 2 STRAIGHT LINE DEFINED BY X1+X2                *
C.    *        IC    = 3 CUBIC MODEL                                   *
C.    *                                                                *
C.    *      output parameters                                         *
C.    *        XINT  = X,Y,Z,XP,YP,ZP AT INTERSECTION POINT            *
C.    *        SINT  = S AT INTERSECTION POINT                         *
C.    *        PZINT = PHI,Z,DPHI/DR,DZ/DR                             *
C.    *        IFLAG = 1 IF TRACK INTERSECTS PLANE                     *
C.    *              = 0 IF NOT                                        *
C.    *                                                                *
C.    *      Warning : the default accuracy is 10 microns. The value   *
C.    *      of EPSI must be changed for a better precision            *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *                                                                *
C.    *        Authors: R.BRUN/JJ.DUMONT from an original routine by   *
C.    *       H. BOERNER  KEK  OCTOBER 1982                            *
C.    *                                                                *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION X1(6),X2(6),XINT(6),PZINT(4),A(4),B(4),C(4)
C
      DATA MAXHIT/100/
      DATA EPSI/0.001/
C.
C.
C.    ------------------------------------------------------------------
C.
C.
      IFLAG  = 1
      DRCTN  = 1.
C
C             Track crossing the plane from above or below ?
C
      IF (X2(2).LT.X1(2))                        GO TO 5
      IF (YC.LT.X1(2))                           GO TO 90
      IF (YC.GT.X2(2))                           GO TO 90
      IF (IC.EQ.2) GO TO 30
      IF (IC.EQ.3) GO TO 7
C
      S=S1
      DXDS=X1(4)
      DYDS=X1(5)
      DZDS=X1(6)
      BX=X1(1)-DXDS*(X1(2)-YC)/DYDS
      BZ=X1(3)-DZDS*(X1(2)-YC)/DYDS
      TRL2=(BX-X1(1))**2+(X1(2)-YC)**2+(BZ-X1(3))**2
      GO TO 40
C
   5  IF (YC.LT.X2(2))                           GO TO 90
      IF (YC.GT.X1(2))                           GO TO 90
      IF(IC.EQ.2) GO TO 30
      DRCTN  = - 1.
C
      IF(IC.EQ.3) GOTO 7
      S=S2
      DXDS=X2(4)
      DYDS=X2(5)
      DZDS=X2(6)
      BX=X2(1)-DXDS*(X2(2)-YC)/DYDS
      BZ=X2(3)-DZDS*(X2(2)-YC)/DYDS
      TRL2=(BX-X2(1))**2+(X2(2)-YC)**2+(BZ-X2(3))**2
      GOTO 40
C
   30 DX=X2(1)-X1(1)
      DY=X2(2)-X1(2)
      DZ=X2(3)-X1(3)
      DS=SQRT(DX*DX+DY*DY+DZ*DZ)
      S=S1
      DXDS=DX/DS
      DYDS=DY/DS
      DZDS=DZ/DS
      BX=X1(1)-DX*(X1(2)-YC)/DY
      BZ=X1(3)-DZ*(X1(2)-YC)/DY
      TRL2=(BX-X1(1))**2+(X1(2)-YC)**2+(BZ-X1(3))**2
C
   40 TRLEN=SQRT(TRL2)*DRCTN+S
      XINT(1)=BX
      XINT(2)=YC
      XINT(3)=BZ
      SINT=TRLEN
      XINT(4)=DXDS
      XINT(5)=DYDS
      XINT(6)=DZDS
      GO TO 200
C
C               Shift coordinate system such that center of gravity=0
C
   7  IF(YC.LE.0.)                                GO TO 90
      SHIFTX = (X1(1) + X2(1)) * 0.5
      SHIFTY = (X1(2) + X2(2)) * 0.5
      SHIFTZ = (X1(3) + X2(3)) * 0.5
      SHIFTS = (S1 + S2) * 0.5
C
C             Only one value necessary since X1= -X2 etc...
C
      XSHFT  = X1(1) - SHIFTX
      YSHFT  = X1(2) - SHIFTY
      ZSHFT  = X1(3) - SHIFTZ
      SSHFT  = S1 - SHIFTS
C
      PABS1  = SQRT(X1(4)**2 + X1(5)**2 + X1(6)**2)
      PABS2  = SQRT(X2(4)**2 + X2(5)**2 + X2(6)**2)
      IF (PABS1.EQ.0..OR.PABS2.EQ.0.)            GO TO 90
C
C              Parametrize the track by a cubic through X1, X2
C
      CALL GCUBS(SSHFT,XSHFT,X1(4)/PABS1,X2(4)/PABS2,A)
      CALL GCUBS(SSHFT,YSHFT,X1(5)/PABS1,X2(5)/PABS2,B)
      CALL GCUBS(SSHFT,ZSHFT,X1(6)/PABS1,X2(6)/PABS2,C)
C
C              Iterate to find the track length corresponding to
C              the intersection of track and plane.
C              Start at S=0. middle of the shifted interval.
C
      DINTER = ABS(S2 - S1) * 0.5
      S      = 0.
C
      DO 10 I = 1,MAXHIT
         Y = SHIFTY + B(1) + S * (B(2) + S * (B(3) + S * B(4)))
         DR=(YC-Y)*DRCTN
         IF (ABS(DR).LT.EPSI)                     GO TO 20
         DINTER = DINTER * 0.5
         IF (DR.LT.0.)S = S - DINTER
         IF (DR.GE.0.)S = S + DINTER
  10  CONTINUE
C
C              Compute intersection in original coordinates
C
  20  CONTINUE
      XINT(1) = SHIFTX + A(1) + S * (A(2) + S * (A(3) + S * A(4)))
      XINT(2)=YC
      XINT(3) = SHIFTZ + C(1) + S * (C(2) + S * (C(3) + S * C(4)))
      XINT(4) = A(2) + S * (2. * A(3) + 3. * S * A(4))
      XINT(5) = B(2) + S * (2. * B(3) + 3. * S * B(4))
      XINT(6) = C(2) + S * (2. * C(3) + 3. * S * C(4))
C
C             Compute PHIHIT,ZHIT and corresponding derivatives
C
      SINT   = S + SHIFTS
  200 TERM   = 1. / (XINT(4) * XINT(1) + XINT(5) * XINT(2))
      PZINT(1) = ATAN2(XINT(2),XINT(1))
      PZINT(2) = XINT(3)
      PZINT(3) = (XINT(1) * XINT(5) - XINT(2) * XINT(4)) * TERM / YC
      PZINT(4) = TERM * XINT(6) * YC
      RETURN
C
  90  IFLAG  = 0
      END
+DECK,  GPDIGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:10  cernlib
* Geant

      SUBROUTINE GPDIGI(IUSET,IUDET)
C.
C.    **************************************************************************
C.    *                                                                        *
C.    *       Print DIGIts in detector IUDET of set IUSET                      *
C.    *       (in case IUSET/IUDET = *, take all sets/detectors)               *
C.    *                                                                        *
C.    *       JDI=LQ(JDIGI-ISET)                                               *
C.    *       JDID=LQ(JDI-IDET)                                                *
C.    *       IQ(JDI+IDET)= pointer to LAST USED word in JDID                  *
C.    *                                                                        *
C.    *          Each digit is packed in JDID in the following format          *
C.    *          -- Track  numbers packed                                      *
C.    *          -- Volume numbers packed                                      *
C.    *          -- Digits packed                                              *
C.    *                                                                        *
C.    *    ==>Called by : <USER>, GPRINT                                       *
C.    *       Author    W.Gebel  *********                                     *
C.    *                                                                        *
C.    **************************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      PARAMETER (NDEMX=100,NVMAX=20)
      DIMENSION KDIGI(NDEMX),NUMBV(NVMAX),KWS(130),LTR(3)
      EQUIVALENCE (WS(1),NUMBV(1)),(WS(101),KDIGI(1))
      CHARACTER*4 IUSET,IUDET
C.    ------------------------------------------------------------------
C.
      IF(JDIGI.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      NS1=1
      NS2=NSET
      IF(IUSET(1:1).NE.'*')THEN
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF(ISET.LE.0)GO TO 999
         NS1=ISET
         NS2=ISET
      ENDIF
C
C             Loop on all selected sets
C
      DO 230 ISET=NS1,NS2
      JS=LQ(JSET-ISET)
      JDI=LQ(JDIGI-ISET)
      IF(JDI.LE.0)GO TO 230
      NDET=IQ(JS-1)
      ND1=1
      ND2=NDET
      IF(IUDET(1:1).NE.'*')THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.EQ.0)GO TO 230
         ND1=IDET
         ND2=IDET
      ENDIF
C
C             Loop on selected detectors for this set
C
      DO 220 IDET=ND1,ND2
      JD=LQ(JS-IDET)
      JDID=LQ(JDI-IDET)
      IF(JDID.LE.0)GO TO 220
      JDDI=LQ(JD-2)
C
      WRITE(CHMAIL,1000)IQ(JS+IDET),IQ(JSET+ISET)
      CALL GMAIL(0,0)
C
C             Get volumes / digitisings names and print header line
C
      ILAST=IQ(JDI+IDET)
      IF(ILAST.EQ.0)GO TO 220
      NV=IQ(JD+2)
      ND=IQ(JD+6)
C
      CALL VBLANK(KWS,130)
      K=3
      IF(NV.GT.0)THEN
C        Number of printed elements limited to 15
         NVM=MIN(NV,15)
         DO 22 I=1,NVM
            CALL UBLOW(IQ(JD+2*I+9),KWS(K),4)
  22     K=K+5
         K=K+5
      ENDIF
      IF(ND.GT.0)THEN
         DO 26 I=1,ND
            IF(K.LE.101) CALL UBLOW(IQ(JDDI+2*I-1),KWS(K),4)
            K=K+8
  26     CONTINUE
         IF(K.GT.104)K=104
      ENDIF
      WRITE(CHMAIL,2000)(KWS(I),I=1,K)
      CALL GMAIL(0,1)
C
C             Now loop on all digits
C             to get track numbers, volume numbers and digits
C
      IDIG=0
      I=0
      NWDI=0
C
   30 CONTINUE
      I=I+NWDI
      IF(I.GE.ILAST)GO TO 220
      NK=2
      IDIG=IDIG+1
      CALL VZERO (LTR(1),3)
C
C             Get unpacked (first 3) tracks producing this digit
C             (2 tracks packed in 1 word; 1st half of 1st word: NTRA-1)
C
      NWDI=IQ(JDID+I+1)
      NTRM1=IBITS(IQ(JDID+I+NK), 0,16)
      NTRA=NTRM1+1
      IF(NTRA.GE.1)LTR(1)=IBITS(IQ(JDID+I+NK),16,16)
      NK=NK+1
      IF(NTRA.GE.2)LTR(2)=IBITS(IQ(JDID+I+NK), 0,16)
      IF(NTRA.GE.3)LTR(3)=IBITS(IQ(JDID+I+NK),16,16)
      NWTR=NTRA/2+1
      NK=NWTR+2
C
C             Get unpacked volume numbers
C
      IF(NV.GT.0)THEN
         K=1
         DO 50 IV=1,NV
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               NUMBV(IV)=IQ(JDID+I+NK)
               K=1
               NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               NUMBV(IV)=IBITS(IQ(JDID+I+NK),K-1,NB)
               K=K+NB
            ENDIF
  50     CONTINUE
         IF(K.NE.1)NK=NK+1
      ENDIF
C
C             Get unpacked digits
C
      IF(ND.GT.0)THEN
         K=1
         DO 90 ID=1,ND
            NB=IQ(JDDI+2*ID)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IF(ID.LE.NDEMX) KDIGI(ID)=IQ(JDID+I+NK)
               K=1
               NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               IF(ID.LE.NDEMX) KDIGI(ID)=IBITS(IQ(JDID+I+NK),K-1,NB)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
C             Do the printout
C             (fitting in 1 line of 128 characters per each digit)
C
      IF(NV.EQ.0)GO TO 119
      IF(NV.GT.15)NV=15
      GO TO (101,102,103,104,105,106,107,108,109,110
     +,      111,112,113,114,115), NV
C
  101 NDP=MIN(ND,12)
      WRITE(CHMAIL,3001)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  102 NDP=MIN(ND,11)
      WRITE(CHMAIL,3002)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  103 NDP=MIN(ND,10)
      WRITE(CHMAIL,3003)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  104 NDP=MIN(ND,10)
      WRITE(CHMAIL,3004)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  105 NDP=MIN(ND, 9)
      WRITE(CHMAIL,3005)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  106 NDP=MIN(ND, 8)
      WRITE(CHMAIL,3006)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  107 NDP=MIN(ND, 8)
      WRITE(CHMAIL,3007)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  108 NDP=MIN(ND, 7)
      WRITE(CHMAIL,3008)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  109 NDP=MIN(ND, 7)
      WRITE(CHMAIL,3009)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  110 NDP=MIN(ND, 6)
      WRITE(CHMAIL,3010)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  111 NDP=MIN(ND, 5)
      WRITE(CHMAIL,3011)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  112 NDP=MIN(ND, 5)
      WRITE(CHMAIL,3012)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  113 NDP=MIN(ND, 4)
      WRITE(CHMAIL,3013)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  114 NDP=MIN(ND, 4)
      WRITE(CHMAIL,3014)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  115 NDP=MIN(ND, 3)
      WRITE(CHMAIL,3015)IDIG,(LTR(J),J=1,3),(NUMBV(L),L=1,NV)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
  119 NDP=MIN(ND,12)
      WRITE(CHMAIL,3000)IDIG,(LTR(J),J=1,3)
     +,               (KDIGI(L),L=1,NDP)
      CALL GMAIL(0,0)
      GO TO 30
C
 220  CONTINUE
 230  CONTINUE
C
C
 1000 FORMAT(' =====>DIGITS OF DETECTOR ** ',A4,
     +' ** OF SET ** ',A4,' **')
 2000 FORMAT(' DIGIT    TR1  TR2  TR3  ',104A1)
 3000 FORMAT(1X,I5,2X,3I5,3X,             12(1X,I7))
 3001 FORMAT(1X,I5,2X,3I5,3X, 1(1X,I4),2X,12(1X,I7))
 3002 FORMAT(1X,I5,2X,3I5,3X, 2(1X,I4),2X,11(1X,I7))
 3003 FORMAT(1X,I5,2X,3I5,3X, 3(1X,I4),2X,10(1X,I7))
 3004 FORMAT(1X,I5,2X,3I5,3X, 4(1X,I4),2X,10(1X,I7))
 3005 FORMAT(1X,I5,2X,3I5,3X, 5(1X,I4),2X, 9(1X,I7))
 3006 FORMAT(1X,I5,2X,3I5,3X, 6(1X,I4),2X, 8(1X,I7))
 3007 FORMAT(1X,I5,2X,3I5,3X, 7(1X,I4),2X, 8(1X,I7))
 3008 FORMAT(1X,I5,2X,3I5,3X, 8(1X,I4),2X, 7(1X,I7))
 3009 FORMAT(1X,I5,2X,3I5,3X, 9(1X,I4),2X, 7(1X,I7))
 3010 FORMAT(1X,I5,2X,3I5,3X,10(1X,I4),2X, 6(1X,I7))
 3011 FORMAT(1X,I5,2X,3I5,3X,11(1X,I4),2X, 5(1X,I7))
 3012 FORMAT(1X,I5,2X,3I5,3X,12(1X,I4),2X, 5(1X,I7))
 3013 FORMAT(1X,I5,2X,3I5,3X,13(1X,I4),2X, 4(1X,I7))
 3014 FORMAT(1X,I5,2X,3I5,2X,14(1X,I4),2X, 4(1X,I7))
 3015 FORMAT(1X,I5,2X,3I5,3X,15(1X,I4),2X, 3(1X,I7))
 999  RETURN
      END
+DECK,  GPDRIF, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:10  cernlib
* Geant

      SUBROUTINE GPDRIF (DETREP,HITREP,IOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *     DETREP(1)=NUMBER OF WIRES                                  *
C     *           (2)=WIRE SPACING                                     *
C     *           (3)=SIN (ALPHA) (ALPHA=ANGLE OF THE NORMAL           *
C     *                            TO THE WIRE WITH RESPECT TO         *
C     *                            AXIS I)                             *
C     *           (4)=COS (ALPHA)                                      *
C     *           (5)=DISTANCE OF WIRE 1 FROM THE ORIGIN               *
C     *           (6)=DRIFT VELOCITY (CM/NSEC)                         *
C     *                                                                *
C     *     HITREP(1)=X COORDINATE OF INTERSECTION                     *
C     *           (2)=Y COORDINATE                                     *
C     *                                                                *
C     *     IOUT(1)=WIRE NUMBER                                        *
C     *         (2)=DRIFT TIME (SIGNED TO AVOID RIGHT/LEFT AMBIGUITY)  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Authors    F.Carena, M.Hansroul  *********               *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION HITREP(2), DETREP(6), IOUT(2)
C.
C.    ------------------------------------------------------------------
C.
      IOUT(1) = - 1
      SP     = DETREP(2)
      DV     = DETREP(6)
      IF (SP.EQ.0.)                                   GO TO 99
      IF (DV.EQ.0.)                                   GO TO 99
C
      X      = HITREP(1)
      Y      = HITREP(2)
      SA     = DETREP(3)
      CA     = DETREP(4)
      U      = X * CA + Y * SA
      OR     = DETREP(5)
      W      = (U - OR) / SP + 1.5
C
      IW     = W
      NWIR   = DETREP(1)
      IF (IW.GT.NWIR)                                 GO TO 99
      IF (IW.LE.0)                                    GO TO 99
C
      DIST   = U - OR - (IW - 1) * SP
      TDRIF  = DIST / DV
C
      IOUT(1) = IW
      IOUT(2) = TDRIF
C
  99  RETURN
      END
+DECK,  GPHITS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:10  cernlib
* Geant

      SUBROUTINE GPHITS(IUSET,IUDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints HITS into detector IUDET of set IUSET             *
C.    *                                                                *
C.    *       If IPKHIT in /CGDRAW/ is greater than zero,              *
C.    *       only hit nr. IPKHIT is printed.                          *
C.    *                                                                *
C.    *       JH=LQ(JHITS-ISET)                                        *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)= pointer to first free word in JHD           *
C.    *         Each hit is packed into JHD in the following format    *
C.    *        --Track number ITRA not packed                          *
C.    *        --Volume numbers packed                                 *
C.    *        --Hits transformed and packed                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT ,<GXINT>, GINC4, GKHITS       *
C.    *       Authors : R.Brun      **********                         *
C.    *                 P.Zanarini  *                                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCDRAW.
      PARAMETER (NHEMX=100,NVMAX=20)
      DIMENSION HITS(NHEMX),KWS(120),NUMBV(NVMAX)
      EQUIVALENCE (WS(1),NUMBV(1)),(WS(101),HITS(1)),(WS(201),KWS(1))
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      IF(JHITS.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      NS1=1
      NS2=NSET
      IF(IUSET(1:1).NE.'*')THEN
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF(ISET.LE.0)GO TO 999
         NS1=ISET
         NS2=ISET
      ENDIF
C
C             loop on all selected sets
C
      DO 130 ISET=NS1,NS2
      JS=LQ(JSET-ISET)
      JH=LQ(JHITS-ISET)
      IF(JS.LE.0)GO TO 130
      IF(JH.LE.0)GO TO 130
      NDET=IQ(JS-1)
      ND1=1
      ND2=NDET
      IF(IUDET(1:1).NE.'*')THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.EQ.0)GO TO 130
         ND1=IDET
         ND2=IDET
      ENDIF
C
C             loop on selected detectors for this set
C
      DO 120 IDET=ND1,ND2
      JD=LQ(JS-IDET)
      JHD=LQ(JH-IDET)
      IF(JHD.LE.0)GO TO 120
      JDH=LQ(JD-1)
C
      WRITE(CHMAIL,1000)IQ(JS+IDET),IQ(JSET+ISET)
      CALL GMAIL(1,1)
C
      ILAST=IQ(JH+IDET)
      IF(ILAST.EQ.0)GO TO 120
      NV=IQ(JD+2)
      NH=IQ(JD+4)
      NW=IQ(JD+1)+IQ(JD+3)+1
C
      CALL VBLANK(KWS,120)
      K=0
      IF(NV.GT.0) THEN
C        Number of printed elements limited to 9
         NVM=MIN(NV,NVMAX)
         DO 22 I=1,NVM
            CALL UBLOW(IQ(JD+2*I+9),KWS(K+1),4)
            K=K+5
  22     CONTINUE
      ENDIF
      IF(NH.GT.0)THEN
         K=K+5
         IP0 = K
         NHM=MIN(NH,NHEMX)
         DO 26 I=1,NHM
            IF(K.GT.110)GO TO 26
            NH1=I
            CALL UBLOW(IQ(JDH+4*I-3),KWS(K+1),4)
            K=K+10
  26     CONTINUE
      ENDIF
      WRITE(CHMAIL,2000)(KWS(I),I=1,K)
      CALL GMAIL(0,0)
C
      IF(NH.GT.0)THEN
         IF(NH1.LT.NHM)THEN
            CALL VBLANK(KWS,IP0)
            DO 40 NHP1=NH1+1,NHM,NH1
               NHP2=NHP1+NH1-1
               NHP2=MIN(NHP2,NHM)
               K=IP0
               DO 30 I=NHP1,NHP2
                  CALL UBLOW(IQ(JDH+4*I-3),KWS(K+1),4)
                  K=K+10
  30           CONTINUE
               WRITE(CHMAIL,2100)(KWS(I),I=1,K)
               CALL GMAIL(0,0)
  40        CONTINUE
         ENDIF
      ENDIF
C
C             Now loop on all hits to get volume numbers and hits
C
      IHIT=0
      DO 110 I=1,ILAST,NW
      IHIT=IHIT+1
C
C             IPKHIT in /CGDRAW/ is used to print just that hit
C
      IF (IPKHIT.GT.0.AND.IHIT.NE.IPKHIT) GO TO 110
C
      ITRA=IQ(JHD+I)
C
C             Get unpacked volume numbers
C
      NK=1
      IF(NV.GT.0)THEN
         K=1
         DO 50 IV=1,NVM
            NB=IQ(JD+2*IV+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   K=1
                   NK=NK+1
               ENDIF
               NUMBV(IV)=IQ(JHD+I+NK)
               IF(IV.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               NUMBV(IV)=IBITS(IQ(JHD+I+NK),K-1,NB)
               K=K+NB
            ENDIF
  50  CONTINUE
      NK=NK+1
      ENDIF
C
C             Get unpacked hits
C             Hits origin is shifted . Division by scale factor
C
      IF(NH.GT.0)THEN
         K=1
         DO 90 IH=1,NHM
            NB=IQ(JDH+4*IH-2)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               KHIT=IQ(JHD+I+NK)
               K=1
               NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               KHIT=IBITS(IQ(JHD+I+NK),K-1,NB)
               K=K+NB
            ENDIF
            HITS(IH)=FLOAT(KHIT)/Q(JDH+4*IH) - Q(JDH+4*IH-1)
  90  CONTINUE
      ENDIF
C
      WRITE(CHMAIL,3000)IHIT,ITRA,(NUMBV(L),L=1,NV)
      IF(NH.GT.0)THEN
         IP0=NV*5+15
         DO 100 NHP1=1,NHM,NH1
            NHP2=NHP1+NH1-1
            NHP2=MIN(NHP2,NHM)
            WRITE(CHMAIL(IP0+1:),4000)(HITS(L),L=NHP1,NHP2)
            CALL GMAIL(0,0)
            CHMAIL(1:IP0)=' '
 100     CONTINUE
      ENDIF
C
      IF(IHIT.EQ.IPKHIT)GO TO 999
C
 110  CONTINUE
 120  CONTINUE
 130  CONTINUE
C
 1000 FORMAT(' =====>HITS IN DETECTOR ** ',A4,
     +' ** OF SET ** ',A4,' **')
 2000 FORMAT('  HIT TRACK ',120A1)
 2100 FORMAT(12X,120A1)
 3000 FORMAT(1X,I4,I6,20I5)
 4000 FORMAT(12(G10.3))
 999  RETURN
      END
+DECK,  GPMWPC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GPMWPC (DETREP,HITREP,IOUT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *     DETREP(1)=NUMBER OF WIRES                                  *
C     *           (2)=WIRE SPACING                                     *
C     *           (3)=SIN (ALPHA) (ALPHA=ANGLE OF THE NORMAL           *
C     *                            TO THE WIRE WITH RESPECT TO         *
C     *                            AXIS I)                             *
C     *           (4)=COS (ALPHA)                                      *
C     *           (5)=DISTANCE OF WIRE 1 FROM THE ORIGIN               *
C     *           (6)=GAP WIDTH                                        *
C     *                                                                *
C     *     HITREP(1)=X COORDINATE OF INTERSECTION                     *
C     *           (2)=Y COORDINATE                                     *
C     *           (3)=DX/DZ                                            *
C     *           (4)=DY/DZ                                            *
C     *                                                                *
C     *     IOUT(1)=WIRE NUMBER                                        *
C     *         (2)=CLUSTER SIZE                                       *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Authors    F.Carena, M.Hansroul  *********               *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION HITREP(4), DETREP(6), IOUT(2)
C.
C.    ------------------------------------------------------------------
C.
      IOUT(1) = - 1
      SP     = DETREP(2)
      IF (SP.EQ.0.)                                   GO TO 99
C
      HG     = .5 * DETREP(6)
      DX     = HG * HITREP(3)
      DY     = HG * HITREP(4)
      X1     = HITREP(1) - DX
      X2     = HITREP(1) + DX
      Y1     = HITREP(2) - DY
      Y2     = HITREP(2) + DY
      SA     = DETREP(3)
      CA     = DETREP(4)
      U1     = X1 * CA + Y1 * SA
      U2     = X2 * CA + Y2 * SA
      OR     = DETREP(5)
      W1     = (U1 - OR) / SP + 1.5
      W2     = (U2 - OR) / SP + 1.5
C
      IW1    = W1
      IW2    = W2
      IWMIN  = MIN (IW1,IW2)
      IWMAX  = MAX (IW1,IW2)
      NWIR   = DETREP(1)
      IF (IWMIN.GT.NWIR)                              GO TO 99
      IF (IWMAX.LE.0)                                 GO TO 99
C
      IWMIN  = MAX (1,IWMIN)
      IWMAX  = MIN (NWIR,IWMAX)
C
      IOUT(1) = IWMIN
      IOUT(2) = IWMAX - IWMIN + 1
C
  99  RETURN
      END
+DECK,  GPSETS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GPSETS(IUSET,IUDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints set and detector parameters                       *
C.    *                                                                *
C.    *        IUSET  user set identifier                              *
C.    *               If * prints all detectors of all sets            *
C.    *        IUDET  user detector identifier                         *
C.    *               If * prints all detectors of set IUSET           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT   ,<GXINT> GINC4              *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      IF(IUSET(1:1).EQ.'*')THEN
         WRITE(CHMAIL,1000)
         CALL GMAIL(0,0)
      ENDIF
      IF(JSET.LE.0)GO TO 999
      NSET=IQ(JSET-1)
      NS1=1
      NS2=NSET
      IF(IUSET(1:1).NE.'*')THEN
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF(ISET.LE.0)GO TO 999
         NS1=ISET
         NS2=ISET
      ENDIF
C
C             loop on all selected sets
C
      DO 130 ISET=NS1,NS2
      JS=LQ(JSET-ISET)
      IF(JS.LE.0)GO TO 130
      NDET=IQ(JS-1)
      ND1=1
      ND2=NDET
      IF(IUDET(1:1).NE.'*')THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.EQ.0)GO TO 130
         ND1=IDET
         ND2=IDET
      ENDIF
C
C             loop on selected detectors for this set
C
      DO 120 IDET=ND1,ND2
      JD=LQ(JS-IDET)
      IF(JD.LE.0)GO TO 120
      NV=IQ(JD+2)
      NWHI=IQ(JD+7)
      NWDI=IQ(JD+8)
C
      WRITE(CHMAIL,2000)IQ(JSET+ISET),IQ(JS+IDET),NWHI,NWDI
      CALL GMAIL(0,0)
C
      IF(NV.NE.0)THEN
         DO 10 I=1,NV
            WRITE(CHMAIL,3000)IQ(JD+2*I+9),IQ(JD+2*I+10)
            CALL GMAIL(0,0)
  10     CONTINUE
      ENDIF
C
      JDH=LQ(JD-1)
      IF(JDH.GT.0)THEN
         NH=IQ(JD+4)
         IF(NH.GT.0)THEN
            DO 30 I=1,NH
               WRITE(CHMAIL,4000)IQ(JDH+4*I-3),IQ(JDH+4*I-2),
     +                           Q(JDH+4*I-1),Q(JDH+4*I)
               CALL GMAIL(0,0)
  30        CONTINUE
         ENDIF
      ENDIF
C
      JDD=LQ(JD-2)
      IF(JDD.GT.0)THEN
         ND=IQ(JD+6)
         IF(ND.GT.0)THEN
            DO 50 I=1,ND
               WRITE(CHMAIL,5000)IQ(JDD+2*I-1),IQ(JDD+2*I)
               CALL GMAIL(0,0)
  50        CONTINUE
         ENDIF
      ENDIF
C
      JDU=LQ(JD-3)
      IF(JDU.GT.0)THEN
         NU=IQ(JDU-1)
         IF(NU.GT.0)THEN
            WRITE(CHMAIL,6000)
            CALL GMAIL(0,0)
            DO 60 I=1,NU,10
               L2=I+9
               IF(L2.GT.NU)L2=NU
               WRITE(CHMAIL,7000)(Q(JDU+L),L=I,L2)
               CALL GMAIL(0,0)
  60        CONTINUE
         ENDIF
      ENDIF
C
 120  CONTINUE
 130  CONTINUE
C
 1000 FORMAT('0',51('='),3X,'SETS AND DETECTORS',3X,50('='))
 2000 FORMAT('   SET ',A4,'  DETECTOR ',A4,'  NWHI=',I6,'  NWDI=',I6)
 3000 FORMAT(10X,'VOLUME ',A4,'  NBITSD=',I4)
 4000 FORMAT(10X,'HIT ELEMENT =',A4,'  NBITSH=',I4,
     +'  ORIG =',E12.4,'  FACT =',E12.4)
 5000 FORMAT(10X,'DIGIT ELEMENT =',A4,'  NBITSD=',I4)
 6000 FORMAT(10X,'USER PARAMETERS')
 7000 FORMAT(5X,10E12.4)
 999  RETURN
      END
+DECK,  GRHITS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GRHITS (IUSET, IUDET, NTRA, ITRA)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GRHITS (IUSET, IUDET, NTRA, ITRA)                     *
C.    *                                                                *
C.    *   Removes the hits produced by the tracks ITRA(1...NTRA) in    *
C.    *   the generic volume name IUDET belonging to the set IUSET.    *
C.    *                                                                *
C.    *   IUSET    User set identifier                                 *
C.    *   IUDET    User detector identifier (name of the corresponding *
C.    *            sensivitive volume)                                 *
C.    *   NTRA     Number of tracks whose hits are to be removed       *
C.    *   ITRA     Track indices whose hits are to be removed          *
C.    *                                                                *
C.    *   Called by : <USER>                                           *
C.    *   Author    : S.Banerjee                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      COMMON /GC1HIT/ LOC(2), JD, JDH, JH, JHD, JHDN, JS
      DIMENSION       ITRA(*)
      CHARACTER*(*)   IUSET, IUDET
      SAVE JHDNN
      DATA JHDNN/0/
*
*     ------------------------------------------------------------------
*
      IF (NTRA.LE.0)                  GO TO 999
      IF (JSET.LE.0)                  GO TO 999
      IF (JHITS.LE.0)                 GO TO 999
*
* *** Find the selected set(s)
*
      NSET  = IQ(JSET-1)
      IF (IUSET(1:1).EQ.'*') THEN
         NS1   = 1
         NS2   = NSET
      ELSE
         CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
         IF (ISET.LE.0)               GO TO 999
         NS1   = ISET
         NS2   = ISET
      ENDIF
      CALL MZLINT (IXSTOR, '/GC1HIT/', LOC, JD, JS)
*
* *** Loop over selected sets
*
      DO 30  ISET = NS1, NS2
         JS    = LQ(JSET-ISET)
         JH    = LQ(JHITS-ISET)
         IF (JS.LE.0.OR.JH.LE.0)      GO TO 30
         NDET  = IQ(JS-1)
*
*  **    Find the selected detector(s)
*
         IF (IUDET(1:1).EQ.'*') THEN
            ND1   = 1
            ND2   = NDET
         ELSE
            CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
            IF (IDET.EQ.0)            GO TO 30
            ND1   = IDET
            ND2   = IDET
         ENDIF
*
*  **    Loop over selected detectors
*
         DO 20 IDET = ND1, ND2
            JD    = LQ(JS-IDET)
            JHD   = LQ(JH-IDET)
            IF (JD.LE.0)              GO TO 20
            IF (JHD.LE.0)             GO TO 20
            JDH   = LQ(JD-1)
            IF (JDH.LE.0)             GO TO 20
            ILAST = IQ(JH+IDET)
            IF (ILAST.EQ.0)           GO TO 20
            NW    = IQ(JD+1) + IQ(JD+3) + 1
*
*  **       Shunt the original bank and lift a new SJDH bank
*
            CALL ZSHUNT (IXDIV, JHD, JHDNN, 2, 0)
            CALL MZBOOK (IXDIV, JHDN, JH, -IDET, 'SJHD', 0, 0, ILAST,
     +                   1, -1)
            IQ(JHDN-5) = IQ(JHD-5)
*
*  **       Copy the relevant part
*
            LAST  = 0
            DO 10 I = 1, ILAST, NW
               II    = IUCOMP (IQ(JHD+I), ITRA, NTRA)
               IF (II.LE.0) THEN
                  CALL UCOPY (IQ(JHD+I), IQ(JHDN+LAST+1), NW)
                  LAST  = LAST + NW
               ENDIF
   10       CONTINUE
*
*  **       Drop the old bank
*
            IF (LAST.LT.ILAST) THEN
               CALL VZERO (IQ(JHDN+LAST+1), ILAST-LAST)
            ENDIF
            IQ(JH+IDET) = LAST
            CALL MZDROP (IXDIV, JHD, ' ')
   20    CONTINUE
   30 CONTINUE
*
  100 LOC(1) = 0
*                                                             END GRHITS
  999 END
+DECK,  GSAHIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routines to Communicate with the JHITS data structure       *
C.    *   ---------------------------------------------------------    *
C.    *                                                                *
C.    *   Stores  element  values  for current  hit  into  the  data   *
C.    * structure JHITS.                                               *
C.    * ISET      set number  (can be obtained from  /GCSETS/ filled   *
C.    *           by GFINDS)                                           *
C.    * IDET      detector    number   "           "               "   *
C.    *           "                                                    *
C.    * ITRA      track number producing this hit                      *
C.    * NUMBV     array  of  volume numbers  corresponding  to  list   *
C.    *           NAMESV of GSDET                                      *
C.    * HITS      array of values for current hit elements             *
C.    * IHIT      on return, current hit number.  If =0, hit has not   *
C.    *           been stored.                                         *
C.    *                                                                *
C.    *       JH=LQ(JHITS-ISET)                                        *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)= pointer to LAST USED word in JHD            *
C.    *         Each hit is packed into JHD in the following format    *
C.    *        --Track number ITRA not packed                          *
C.    *        --Volume numbers packed                                 *
C.    *        --Hits transformed and packed                           *
C.    *                                                                *
C.    *                The Hit data structure JHITS                    *
C.    *                ----------------------------                    *
C.    *                                                                *
C.    *                                            | JHITS             *
C.    *    NSET                  ISET              v                   *
C.    *     ..........................................                 *
C.    *     |                   |  |              |  |                 *
C.    *     ..........................................                 *
C.    *                           |                                    *
C.    *                           | JH                                 *
C.    *      NDET    IDET         v               NDET                 *
C.    *        .....................................                   *
C.    *        |      |  |      |  |               |                   *
C.    *        .....................................                   *
C.    *                |                                               *
C.    *                | JHD                                           *
C.    *                v                                               *
C.    *               .........................................        *
C.    *               |  | 1st hit        | 2nd hit, etc.     |        *
C.    *               .........................................        *
C.    *                         Bank layout                            *
C.    * JH            =  LQ(JHITS-ISET,)  pointer  to  hits for  set   *
C.    *           number ISET                                          *
C.    * JHD           = LQ(JH-IDET),   pointer to  hits of  detector   *
C.    *           IDET                                                 *
C.    *                  of set ISET                                   *
C.    * IQ(JH+IDET)    number of words  used so far for  storing the   *
C.    *           hits                                                 *
C.    *                  of detector IDET                              *
C.    * IQ(JHD+1)       1st word of 1st hit                            *
C.    * IQ(JHD+NWH+1)  1st word of 2nd hit                             *
C.    *                      JS=LQ(JSET-ISET)                          *
C.    *                      JD=LQ(JS-IDET)                            *
C.    *                      NWH=IQ(JD+3)                              *
C.    *   The JHITS structure is filled with the routines GSAHIT and   *
C.    * GSCHIT.   The routine GFHITS can be used to get the hits for   *
C.    * a detector IDET and set ISET.                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(1),HITS(1)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      IHIT=0
      IF(JSET.LE.0)GO TO 99
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 99
      IF(ISET.LE.0)GO TO 99
      IF(ISET.GT.NSET)GO TO 99
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 99
      IF(IDET.LE.0)GO TO 99
      IF(IDET.GT.NDET)GO TO 99
      JD=LQ(JS-IDET)
      JDH=LQ(JD-1)
      IF(JDH.LE.0)GO TO 99
      NW=IQ(JD+1)+IQ(JD+3)+1
      NH=IQ(JD+4)
      NV=IQ(JD+2)
C
C              Create HITS master bank
C
      IF(JHITS.EQ.0)THEN
         CALL MZBOOK(IXDIV,JHITS,JHITS,1,'HITS',NSET,NSET,0,2,0)
         IQ(JHITS-5)=0
      ENDIF
      JH=LQ(JHITS-ISET)
      IF(JH.EQ.0)THEN
         CALL MZBOOK(IXDIV,JH,JHITS,-ISET,'HITS',NDET,NDET,NDET,2,0)
      ENDIF
C
      JHD=LQ(JH-IDET)
      IF(JHD.EQ.0)THEN
C
C            Create Hits bank
C
         NWHI=IQ(JD+7)
         CALL MZBOOK(IXDIV,JHD,JH,-IDET,'SJHD',0,0,NWHI,1,0)
         IQ(JHD-5)=1000*ISET+IDET
         ILAST=0
      ELSE
C
C           Check if enough space. If not increase bank size
C
         NHD=IQ(JHD-1)
         ILAST=IQ(JH+IDET)
         NFREE=NHD-ILAST
         IF(NFREE.LE.NW)THEN
            NWHI2=MAX(100,NW,IQ(JD+7)/2)
            CALL MZPUSH(IXDIV,JHD,0,NWHI2,'I')
            JS  = LQ(JSET-ISET)
            JD  = LQ(JS-IDET)
            JDH = LQ(JD-1)
            JH  = LQ(JHITS-ISET)
         ENDIF
      ENDIF
C
      IQ(JH+IDET)=ILAST+NW
      IHIT=IQ(JH+IDET)/NW
C
C ========>    Store track number,volumes numbers and hits
C
      IQ(JHD+ILAST+1)=ITRA
C
C
C           Store packed volume numbers
C
      NK=ILAST+2
      IF(NV.GT.0)THEN
         K=1
C
         DO 50 I=1,NV
            NB=IQ(JD+2*I+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=NUMBV(I)
               K=1
               IF(I.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(NUMBV(I),0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  50     CONTINUE
         NK=NK+1
      ENDIF
C
C          Store packed hits
C          Before packing, hits are changed to integers
C          Origin is shifted to have only positive integers
C          Result is multiplied by a constant to get resolution
C
      IF(NH.GT.0)THEN
         K=1
         DO 90 I=1,NH
            NB=IQ(JDH+4*I-2)
            XHIT=(HITS(I)+Q(JDH+4*I-1))*Q(JDH+4*I)
            IF(NB.EQ.0)THEN
               VALMX=2.147483E+9
            ELSE
               VALMX=2.**NB-1.
            ENDIF
            IFLAG=0
            IF(XHIT.LT.0.)THEN
               XHIT=0.
               IFLAG=1
            ELSE IF(XHIT.GT.VALMX)THEN
               XHIT=VALMX
               IFLAG=1
            ENDIF
            IF(IFLAG.NE.0)THEN
               NMESS=NMESS+1
               IF(NMESS.LT.10)THEN
                  WRITE(CHMAIL,1000)IQ(JSET+ISET),IQ(JS+IDET),I,HITS(I)
     +             ,Q(JDH+4*I-1),Q(JDH+4*I)
                  CALL GMAIL(0,0)
               ENDIF
            ENDIF
C
            KHIT=XHIT+0.5
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=KHIT
               NK=NK+1
               K=1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(KHIT,0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
 1000 FORMAT(' ***** GSAHIT OVERFLOW WHEN IUSET= ',A4,' IUDET= ',
     +A4,' HITS(',I2,')=',E14.7,' ORIG= ',E14.7,' FACT= ',E14.7)
  99  RETURN
      END
+DECK,  GSCHIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GSCHIT(ISET,IDET,ITRA,NUMBV,HITS,NHSUM,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store HITS values into detector IUDET of set IUSET       *
C.    *                                                                *
C.    *       NUMBV  volume numbers                                    *
C.    *       HITS  array of values for the elements of current hit    *
C.    *       ITRA  track number associated to this hit                *
C.    *       IHIT  output parameter containing the hit number         *
C.    *             If IHIT=0  hit has not been stored                 *
C.    *                                                                *
C.    *       Same action as GSAHIT but in case the physical volume    *
C.    *       specified by NUMBV contains already some hit for the     *
C.    *       same track, then the routine will sum up the last NHSUM  *
C.    *       elements of the hit.                                     *
C.    *        In order to use that routine , no packing must be       *
C.    *        specified for these NHSUM last hits.                    *
C.    *        If NHSUM.LE.0 then GSCHIT is the same as GSAHIT.        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(*),HITS(*)
      PARAMETER (MAXINT=2147483647)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      CALL GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
      IF(IHIT.LE.1)GO TO 999
      IF(NHSUM.LE.0)GO TO 999
C
      NV=IQ(JD+1)
      NH=IQ(JD+3)
      NW=NV+NH+1
      JNEWH = JHD+(IHIT-1)*NW
      JCURR = JNEWH
C
      DO 30 I=1,IHIT-1
         JCURR = JCURR-NW
C
C             Check if track number is ITRA
C
         IF(ITRA.NE.IQ(JCURR+1))GO TO 999
C
C             Check if volume numbers are the same
C
         DO 10 J=2,NV+1
            IF(IQ(JCURR+J).NE.IQ(JNEWH+J))GO TO 30
   10    CONTINUE
C
C             Volumes are the same. Now sum the last NHSUM hits
C
         DO 20 K=NW,NW-NHSUM+1,-1
            IF(IQ(JCURR+K).GT.MAXINT-IQ(JNEWH+K)) THEN
               IQ(JCURR+K) = MAXINT
               NMESS=NMESS+1
               IF(NMESS.LT.10)THEN
                  WRITE(CHMAIL,10000)IQ(JSET+ISET),IQ(JS+IDET)
                  CALL GMAIL(0,0)
               ENDIF
            ELSE
               IQ(JCURR+K)=IQ(JCURR+K)+IQ(JNEWH+K)
            ENDIF
   20    CONTINUE
C
C             Remove temporarily stored hit
C
         IHIT=IHIT-1
         IQ(JH+IDET)=IQ(JH+IDET)-NW
         GO TO 999
   30 CONTINUE
C
10000 FORMAT(' ***** GSCHIT OVERFLOW WHEN IUSET= ',A4,' IUDET= ',A4)
  999 END
+DECK,  GSDET, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GSDET(IUSET,IUDET,NV,NAMESV,NBITSV,IDTYPE
     +                ,NWHI,NWDI,ISET,IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines volume parameters for detector IUDET of set IUSET*
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    * NV        number of volume descriptors                         *
C.    * NAMESV    vector of NV volume descriptors (4 characters)       *
C.    * NBITSV    vector of  NV bit numbers  for packing  the volume   *
C.    *           numbers                                              *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for the primary allocation of HITS   *
C.    *           banks                                                *
C.    * NWDI      number of words for the primary allocation of DIGI   *
C.    *           banks when first allocation not sufficient           *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The vector NAMESV (length NV)  contains the list of volume   *
C.    *   names which  permit the  identification of  every physical   *
C.    *   detector with detector name IUDET.    [See example in HITS   *
C.    *   110].                                                        *
C.    * - Each  element of  the vector  NBITSV (length  NV)  is  the   *
C.    *   number  of  bits  used  for  packing  the  number  of  the   *
C.    *   corresponding volume,  when building the packed identifier   *
C.    *   of a given physical detector.                                *
C.    * - For more details see the example given in GSDETH.            *
C.    * - The detector type  IDTYPE is not used  internally by GEANT   *
C.    *   and  can be  defined by  the user  to distinguish  quickly   *
C.    *   between various kinds of detectors,  in the routine GUSTEP   *
C.    *   for example.                                                 *
C.    *                                                                *
C.    *       IQ(JSET+ISET) = IUSET                                    *
C.    *       JS = LQ(JSET-ISET) + pointer to set parameters           *
C.    *       IQ(JS+IDET)=IUDET                                        *
C.    *       JD= LQ(JS-1)  = pointer to detector IDET                 *
C.    *       IQ(JD+1)=Total number of words to store packed volumes   *
C.    *       IQ(JD+2)=NV                                              *
C.    *       IQ(JD+3)=Number of words required per hit                *
C.    *       IQ(JD+4)=Number of different hits types                  *
C.    *       IQ(JD+5)=Number of words required per digit              *
C.    *       IQ(JD+6)=Number of different digit types                 *
C.    *       IQ(JD+7)=NWHI                                            *
C.    *       IQ(JD+8)=NWDI                                            *
C.    *       IQ(JD+9)=Number of paths through the JVOLUM tree         *
C.    *       IQ(JD+10)= For an alias only, IDET of main detector      *
C.    *       IQ(JD+2*I+9) = name of volume i = NAMESV(I)              *
C.    *       IQ(JD+2*I+10)= number of bits/volume = NBITSV(I)         *
C.    *                                                                *
C.    *            The Detector Set data structure JSET                *
C.    *            ------------------------------------                *
C.    *                                                                *
C.    *                                        | JSET                  *
C.    *    NSET            ISET                v         NSET          *
C.    *     ................................................           *
C.    *     |              | |               |  | Set names|           *
C.    *     ................................................           *
C.    *                     | JS                                       *
C.    *                     |                                          *
C.    *    NDET       IDET  v                    NDET                  *
C.    *     ........................................                   *
C.    *     |        |  |  | | Detector names      |                   *
C.    *     ........................................                   *
C.    *               | JD                                             *
C.    *      -3 -2 -1 v                                                *
C.    *     ................................................           *
C.    *     |  |  |  |  |   Parameters of GSDET            |           *
C.    *     ................................................           *
C.    *      |  |  |                                                   *
C.    *      |  |  |  JDH                                              *
C.    *      |  |  |                                                   *
C.    *      |  |  |           .............................           *
C.    *      |  |  ............| Parameters of GSDETH      |           *
C.    *      |  |              .............................           *
C.    *      |  |                                                      *
C.    *      |  | JDD                                                  *
C.    *      |  |                                                      *
C.    *      |  |              .............................           *
C.    *      |  ...............|  Parameters of GSDETD     |           *
C.    *      |                 .............................           *
C.    *      |                                                         *
C.    *      |  JDU                                                    *
C.    *      |                 .............................           *
C.    *      ..................| Parameters of GSDETU      |           *
C.    *                        .............................           *
C.    *  JS = LQ(JSET-ISET) pointer to detector set number ISET        *
C.    * The JSET data structure is filled by GSDET, GSDETH,  GSDETD,   *
C.    * GSDETU and eventually by GSDETA.                               *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCMZFO.
      PARAMETER (NVMAX=20)
      DIMENSION NBITSV(1),NAV(NVMAX)
      CHARACTER*4 NAMESV,IUSET,IUDET
      EQUIVALENCE (WS(1),NAV(1))
C.
C.    ------------------------------------------------------------------
C.
      ISET=0
      IDET=0
      IF(NV.GT.15)GO TO 94
C
C             Check if volume IUDET has been defined
C
      IF(JVOLUM.LE.0)GO TO 90
      NVOLUM=IQ(JVOLUM-1)
      CALL GLOOK(IUDET,IQ(JVOLUM+1),NVOLUM,IVOL)
      IF(IVOL.EQ.0)GO TO 90
C
      IF(JSET.EQ.0)THEN
C
C               Create mother JSET bank
C
         CALL MZBOOK(IXCONS,JSET,JSET,1,'SETS',0,0,0,5,0)
         IQ(JSET-5)=0
         NSET=0
      ELSE
         NSET=IQ(JSET-1)
         CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
         IF (ISET.NE.0) GO TO 30
      ENDIF
C
C               Create JS bank
C
      CALL MZPUSH(IXCONS,JSET,1,1,'I')
      NSET=NSET+1
C
      ISET=NSET
      CALL UCTOH(IUSET,IQ(JSET+ISET),4,4)
      CALL MZBOOK(IXCONS,JS,JSET,-ISET,'SETS',0,0,0,5,0)
C
C            Check if detector has already been defined
C
  30  JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.NE.0)THEN
         CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
         IF(IDET.NE.0) GO TO 92
      ENDIF
C
C                If not, create detector bank
C
      CALL MZPUSH(IXCONS,JS,1,1,'I')
      NDET=NDET+1
      IDET=NDET
      CALL UCTOH(IUDET,IQ(JS+IDET),4,4)
      CALL MZBOOK(IXCONS,JD,JS,-IDET,'SEJD',4,4,10+2*NV,IOSEJD,0)
      IQ(JD-5)=10*ISET+IDET
C
      NW=0
      IF(NV.GT.0)THEN
         CALL UCTOH(NAMESV,NAV,4,4*NV)
         K=32
         DO 70 I=1,NV
            NB=NBITSV(I)
            IF(NB.LT.0)NB=0
            IF(NB.GE.32)NB=0
            IQ(JD+2*I+ 9)=NAV(I)
            IQ(JD+2*I+10)=NB
            IF(NB.LE.0)THEN
               NW=NW+1
               K=32
            ELSE
               K=K+NB
               IF(K.GT.32)THEN
                  K=NB
                  NW=NW+1
               ENDIF
            ENDIF
  70     CONTINUE
      ENDIF
  80  IQ(JD+1)=NW
      IQ(JD+2)=NV
      IQ(JD+7)=NWHI
      IQ(JD+8)=NWDI
      IQ(JD+10)=0
C
C             Now enter set,det into JVOLUM data structure
C
      CALL GSATT(IUDET,'SET ',ISET)
      CALL GSATT(IUDET,'DET ',IDET)
      CALL GSATT(IUDET,'DTYP',IDTYPE)
      GO TO 99
C
C              Errors
C
  90  WRITE(CHMAIL,1000)IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDET ERROR, VOLUME ',A4,' NOT DEFINED')
      GO TO 99
C
  92  WRITE(CHMAIL,2000)IUSET,IUDET
      CALL GMAIL(0,0)
 2000 FORMAT(' ***** GSDET ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' ALREADY DEFINED')
      GO TO 99
C
  94  WRITE(CHMAIL,3000)NV
      CALL GMAIL(0,0)
 3000 FORMAT(' ***** GSDET ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' Too many descriptors:',I5)
C
  99  RETURN
      END
+DECK,  GSDETA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GSDETA (IUSET, IUDET, IUALI, NWHI, NWDI, IALI)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                 Handling Detector Aliases                      *
C.    *                 --------------------------                     *
C.    *                                                                *
C.    * Detector  'aliases'  can  be  specified  for  any  sensitive   *
C.    * detector for  which the  user needs to  store more  than one   *
C.    * type of hit.                                                   *
C.    *   Defines an  alias IUALI for  detector IUDET of  set IUSET.   *
C.    * Enters it in the JSET structure as an additional detector in   *
C.    * the corresponding set,  at the position IALI.  Copies to the   *
C.    * link  position  IALI  the  GSDET  parameter  bank  from  the   *
C.    * original detector  IUDET,  with empty  links to  the GSDETH,   *
C.    * GSDETD and GSDETU parameter banks.    The user can therefore   *
C.    * call  these   three  routines   again  with   the  arguments   *
C.    * appropriate to the  detector IUALI.  Several aliases  can be   *
C.    * defined  for the  same  detector through  as  many calls  to   *
C.    * GSDETA.                                                        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    F.Bruyant  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCMZFO.
      CHARACTER*4 IUSET,IUDET,IUALI
C.
C.    ------------------------------------------------------------------
C.
      IF (JSET.LE.0) GO TO 90
      NSET = IQ(JSET-1)
      IF (NSET.LE.0) GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF (ISET.LE.0) GO TO 90
      JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.LE.0) GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF (IDET.LE.0) GO TO 90
      CALL GLOOK(IUALI,IQ(JS+1),NDET,IALI)
      IF (IALI.NE.0) GO TO 95
      JD = LQ(JS-IDET)
      NDATA = IQ(JD-1)
C
      CALL MZPUSH(IXCONS, JS, 1, 1,'I')
      NDET = NDET +1
      IALI = NDET
      CALL UCTOH(IUALI,IQ(JS+IALI),4,4)
C
      CALL MZBOOK(IXCONS,JD2,JS,-IALI, 'SEJD',4,4, NDATA,IOSEJD,0)
      IQ(JD2-5)=10*ISET+IALI
      JD = LQ(JS-IDET)
      CALL UCOPY (IQ(JD+1), IQ(JD2+1), NDATA)
      IQ(JD2+7) = NWHI
      IQ(JD2+8) = NWDI
      IQ(JD2+10) = IDET
      GO TO 99
C
   90 WRITE (CHMAIL, 1000) IUSET, IUDET
      CALL GMAIL(0,0)
 1000 FORMAT (' ***** GSDETA ERROR FOR SET ',A4,' OR DETECTOR ',A4)
      GO TO 99
   95 WRITE (CHMAIL, 2000) IUSET, IUALI
      CALL GMAIL(0,0)
 2000 FORMAT (' ***** GSDETA ERROR FOR SET ', A4, ' ALIAS NAME '
     +, A4, ' ALREADY USED')
C
  99  RETURN
      END
+DECK,  GSDETD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:11  cernlib
* Geant

      SUBROUTINE GSDETD(IUSET,IUDET,ND,NAMESD,NBITSD)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Handling sensitive DETector Digitisation parameters        *
C.    *     ---------------------------------------------------        *
C.    *                                                                *
C.    * Defines digitisation  parameters for  detector IUDET  of set   *
C.    * IUSET.                                                         *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    * ND        number of elements per digitisation                  *
C.    * NAMESD    the  ND   variable  names  for   the  digitisation   *
C.    *           elements                                             *
C.    * NBITSD    the  ND  bit  numbers  for  packing  the  variable   *
C.    *           values.                                              *
C.    *   The  routine  is  used at  initialisation  time  once  the   *
C.    * geometrical  volumes  have  been  defined  to  describe  the   *
C.    * digitisation elements  and the way  to do packing  in memory   *
C.    * and on tape.  Let us use the same example as in GSDETH.  The   *
C.    * non  geometrical  information  we want  to  store  for  each   *
C.    * digitisation is for example:                                   *
C.    *  - ADC  pulse height in a lead glass block.                    *
C.    * Example of one digitisation in that scheme:                    *
C.    *       EPHI 12                                                  *
C.    *       EZRI 41                                                  *
C.    *       BLOC  3                                                  *
C.    *       ADC  789                                                 *
C.    * The FORTRAN  coding to  define the  digitisation information   *
C.    * could be:                                                      *
C.    *   DATA NAMESD/'ADC '/                                          *
C.    *   DATA NBITSD/16/                                              *
C.    *       CALL GSDETD('ECAL','BLOC',1,NAMESD,NBITSD)               *
C.    *   Returns the digitisation parameters  for detector IUDET of   *
C.    * set IUSET.  All arguments as explained in GSDETD.              *
C..   *                                                                *
C.    *       JS = LQ(JSET-ISET)                                       *
C.    *       JD = LQ(JS-IDET)                                         *
C.    *       JDD= LQ(JD-2)                                            *
C.    *       IQ(JDD+2*I-1)=NAMESD(I)                                  *
C.    *       IQ(JDD+2*I)  =NBITSD(I)                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCMZFO.
      PARAMETER (NDEMX=100)
      DIMENSION NBITSD(1),NAMD(NDEMX)
      CHARACTER*4 NAMESD(1),IUSET,IUDET
      EQUIVALENCE (WS(1),NAMD(1))
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 90
      JD=LQ(JS-IDET)
C
      CALL MZBOOK(IXCONS,JDD,JD,-2,'SJDD',0,0,2*ND,IOSJDD,0)
C
      NW=0
      IF(ND.GT.0)THEN
         CALL UCTOH(NAMESD,NAMD,4,4*ND)
         K=32
         DO 30 I=1,ND
            NB=NBITSD(I)
            IF(NB.LT.0)NB=0
            IF(NB.GE.32)NB=0
            IQ(JDD+2*I-1)=NAMD(I)
            IQ(JDD+2*I )=NB
            IF(NB.LE.0)THEN
               NW=NW+1
               K=32
            ELSE
               K=K+NB
               IF(K.GT.32)THEN
                  K=NB
                  NW=NW+1
               ENDIF
            ENDIF
  30     CONTINUE
      ENDIF
      IQ(JD+5)=NW
      IQ(JD+6)=ND
      GO TO 99
C
C              Error
C
  90  WRITE(CHMAIL,1000)IUSET,IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDETD ERROR FOR SET ',A4,' OR DETECTOR ',A4)
C
  99  RETURN
      END
+DECK,  GSDETH, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:12  cernlib
* Geant

      SUBROUTINE GSDETH(IUSET,IUDET,NH,NAMESH,NBITSH,ORIG,FACT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *          Handling sensitive DETector Hit parameters            *
C.    *          ------------------------------------------            *
C.    *                                                                *
C.    *   Defines hit parameters for detector IUDET of set IUSET.      *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    * NH        number of elements per hit                           *
C.    * NAMESH    the NH variable names for the hit elements           *
C.    * NBITSH    the NH bit numbers for packing the variable values   *
C.    * ORIG      The quantity packed in the structure JHITS for the   *
C.    *           Ith variable is a  positive integer with NBITSH(I)   *
C.    *           bits and such that                                   *
C.    * FACT      IVAR(I) = (VAR(I)+ORIG(I))*FACT(I)                   *
C.    *   The  routine  is  used at  initialisation  time  once  the   *
C.    * geometrical volumes  have been defined  to describe  the hit   *
C.    * elements and the way to do packing in memory and on tape.      *
C.    *                           EXAMPLE                              *
C.    *   Assume an electromagnetic calorimeter ECAL divided into 40   *
C.    * PHI  sections called  EPHI.   Each  EPHI division  is  again   *
C.    * divided along  the Z axis in  60 objects called  EZRI.  Each   *
C.    * EZRI  is finally  divided into  4 lead  glass blocks  called   *
C.    * BLOC.                                                          *
C.    * The geometrical  information to describe  one hit  will then   *
C.    * be:                                                            *
C.    *  - The EPHI section number (between 1 and 40)                  *
C.    *  - The EZRI division number (between 1 and 60)                 *
C.    *  - The BLOC number (1 to 4)                                    *
C.    * The variables we want to store for each hit are for example:   *
C.    *  - X     x position of the hit in the lead glass block         *
C.    *  - Y     y                                                     *
C.    *  - Z     z                                                     *
C.    *  - E     energy of the particle at this point                  *
C.    *  - ELOS  the energy deposited into this block                  *
C.    * Example of one hit in that scheme:                             *
C.    *       EPHI 12                                                  *
C.    *       EZRI 41                                                  *
C.    *       BLOC  3                                                  *
C.    *        X    7.89 cm                                            *
C.    *        Y    -345.6 cm                                          *
C.    *        Z    1234.8 cm                                          *
C.    *        E    12 Gev                                             *
C.    *        ELOS  11.85 Gev                                         *
C.    * The FORTRAN  coding to  define the  set/det/hits information   *
C.    * could be:                                                      *
C.    *   DIMENSION NAMESV(3),NBITSV(3)                                *
C.    *   DIMENSION NAMESH(5),NBITSH(5),ORIG(5),FACT(5)                *
C.    *   DATA NAMESV/'EPHI','EZRI','BLOC'/                            *
C.    *   DATA NBITSV/6,6,3/                                           *
C.    *   DATA NAMESH/'X   ','Y   ','Z   ','E   ','ELOS'/              *
C.    *   DATA NBITSH/5*16/                                            *
C.    *   DATA ORIG/3*1000.,0.,0./                                     *
C.    *   DATA FACT/3*10.,2*100./                                      *
C.    *       CALL GSDET ('ECAL','BLOC',3,NAMESV,NBITSV,2,100,100,     *
C.    *      +                         ISET,IDET)                      *
C.    *       CALL GSDETH('ECAL','BLOC',5,NAMESH,NBITSH,ORIG,FACT)     *
C.    *   Returns  the hit  parameters  for  detector IUDET  of  set   *
C.    * IUSET.  All arguments are explained above.                     *
C..   *                                                                *
C.    *                                                                *
C.    *       JS = LQ(JSET-ISET)                                       *
C.    *       JD = LQ(JS-IDET)                                         *
C.    *       JDH= LQ(JD-1)                                            *
C.    *       IQ(JDH+4*I-3)= NAMESH(I)                                 *
C.    *       IQ(JDH+4*I-2)= NBITSH(I)                                 *
C.    *        Q(JDH+4*I-1)= ORIG(I)                                   *
C.    *        Q(JDH+4*I)  = FACT(I)                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCMZFO.
      PARAMETER (NHEMX=100)
      DIMENSION NBITSH(1),ORIG(1),FACT(1),NAMH(NHEMX)
      CHARACTER*4 NAMESH(1),IUSET,IUDET
      EQUIVALENCE (WS(1),NAMH(1))
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 90
      JD=LQ(JS-IDET)
C
      CALL MZBOOK(IXCONS,JDH,JD,-1,'SJDH',0,0,4*NH,IOSJDH,0)
C
      NW=0
      IF(NH.GT.0)THEN
         CALL UCTOH(NAMESH,NAMH,4,4*NH)
         K=32
         DO 30 I=1,NH
            NB=NBITSH(I)
            IF(NB.LT.0)NB=0
            IF(NB.GE.32)NB=0
            IQ(JDH+4*I-3)=NAMH(I)
            IQ(JDH+4*I-2)=NB
            Q(JDH+4*I-1)=ORIG(I)
            Q(JDH+4*I )=FACT(I)
            IF(FACT(I).LE.0.)Q(JDH+4*I)=1.
            IF(NB.LE.0)THEN
               NW=NW+1
               K=32
            ELSE
               K=K+NB
               IF(K.GT.32)THEN
                  K=NB
                  NW=NW+1
               ENDIF
            ENDIF
  30     CONTINUE
      ENDIF
      IQ(JD+3)=NW
      IQ(JD+4)=NH
      GO TO 99
C
C              Error
C
  90  WRITE(CHMAIL,1000)IUSET,IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDETH ERROR FOR SET ',A4,' OR DETECTOR ',A4)
C
  99  RETURN
      END
+DECK,  GSDETU, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:12  cernlib
* Geant

      SUBROUTINE GSDETU(IUSET,IUDET,NUPAR,UPAR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Storing and Retrieving User Detector parameters           *
C.    *      -----------------------------------------------           *
C.    *                                                                *
C.    *   Stores user parameters for detector IUDET of set IUSET.      *
C.    * IUSET     user set identifier                                  *
C.    * IUDET     user detector identifier                             *
C.    * NUPAR     number of user parameters                            *
C.    * UPAR      array of NUPAR user floating point parameters.       *
C.    *   The  routine  is  used at  initialisation  time  once  the   *
C.    * geometrical volumes have been defined.                         *
C.    *                                                                *
C.    *                                                                *
C.    *       JS = LQ(JSET-ISET)                                       *
C.    *       JD = LQ(JS-IDET)                                         *
C.    *       JDU= LQ(JD-1)                                            *
C.    *       Q(JDU+1) = UPAR(1)  1st user parameter,etc               *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION UPAR(1)
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      IF(JSET.LE.0)GO TO 90
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 90
      CALL GLOOK(IUSET,IQ(JSET+1),NSET,ISET)
      IF(ISET.LE.0)GO TO 90
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 90
      CALL GLOOK(IUDET,IQ(JS+1),NDET,IDET)
      IF(IDET.LE.0)GO TO 90
      JD=LQ(JS-IDET)
C
      IF(NUPAR.LE.0)GO TO 90
      CALL MZBOOK(IXCONS,JDU,JD,-3,'SJDU',0,0,NUPAR,3,0)
C
      CALL UCOPY(UPAR,Q(JDU+1),NUPAR)
      GO TO 99
C
C              Error
C
  90  WRITE(CHMAIL,1000)IUSET,IUDET
      CALL GMAIL(0,0)
 1000 FORMAT(' ***** GSDETU ERROR FOR SET ',A4,' OR DETECTOR ',A4)
C
  99  RETURN
      END
+DECK,  GSDETV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:12  cernlib
* Geant

      SUBROUTINE GSDETV (IUSET, IUDET, IDTYPE, NWHI, NWDI, ISET, IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines detector IUDET as a member of set IUSET          *
C.    *     and prepares the DETector structure                        *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for primary allocation of HITS banks *
C.    * NWDI      number of words for primary allocation of DIGI banks *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The path through the volume tree will be automatically set   *
C.    *   in GGDETV,called by GGCLOS, after all volumes have been      *
C.    *   positionned.                                                 *
C.    * - The detector type  IDTYPE is not used  internally by GEANT   *
C.    *   and  can be  defined by  the user  to distinguish  quickly   *
C.    *   between various kinds of detectors,  in the routine GUSTEP   *
C.    *   for example.                                                 *
C.    *                                                                *
C.    *       IQ(JSET+ISET) = IUSET                                    *
C.    *       JS = LQ(JSET-ISET) = pointer to set IUSET                *
C.    *       IQ(JS+IDET)=IUDET                                        *
C.    *       JD= LQ(JS-1)  = pointer to detector IUDET                *
C.    *       IQ(JD+1)=Number of words to store packed volume numbers  *
C.    *       IQ(JD+2)=Number of volume descriptors                    *
C.    *       IQ(JD+3)=Number of words per hit                         *
C.    *       IQ(JD+4)=Number of elements per hit                      *
C.    *       IQ(JD+5)=Number of words per digitisation                *
C.    *       IQ(JD+6)=Number of elements per digitisation             *
C.    *       IQ(JD+7)=NWHI, primary size of hit bank                  *
C.    *       IQ(JD+8)=NWDI, primary size of digitisation bank         *
C.    *       IQ(JD+9)=Number of paths through the JVOLUM tree         *
C.    *       IQ(JD+10)=For aliases only, IDET of mother detector      *
C.    *       IQ(JD+11)=Name of first volume descriptor                *
C.    *       IQ(JD+12)=Number of bits for packing its number          *
C.    *       ...                                                      *
C.    *       IQ(JD+9+2*NV)=Name of last volume descriptor             *
C.    *       IQ(JD+10+2*NV)=Number of bits for packing its number     *
C.    *       then for each possible path                              *
C.    *       list of names and numbers for all levels                 *
C.    *       (The number of levels is entered as number attached to   *
C.    *       the first name which is the top of the JVOLUM tree)      *
C.    *                                                                *
C.    *            The Detector Set data structure JSET                *
C.    *            ------------------------------------                *
C.    *                                                                *
C.    *                                        | JSET                  *
C.    *    NSET            ISET                v         NSET          *
C.    *     ................................................           *
C.    *     |              | |               |  | Set names|           *
C.    *     ................................................           *
C.    *                     | JS                                       *
C.    *                     |                                          *
C.    *    NDET       IDET  v                    NDET                  *
C.    *     ........................................                   *
C.    *     |        |  |  | | Detector names      |                   *
C.    *     ........................................                   *
C.    *                  | JD                                          *
C.    *       -3  -2  -1 v                                             *
C.    *     ................................................           *
C.    *     |   |   |   |  | Volume parameters, in GGDETV  |           *
C.    *     ................................................           *
C.    *              JDH                                               *
C.    *          JDD                                                   *
C.    *      JDU                                                       *
C.    *                                                                *
C.    * The JSET structure is filled by GSDETV + GGDETV, and by        *
C.    *      GSDETH, GSDETD and GSDETU, eventually by GSDETA.          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors   R.Brun, F.Bruyant    **********                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCMZFO.
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      ISET = 0
      IDET = 0
C
C     Check if volume IUDET has been defined
C
      IF (JVOLUM.LE.0) GO TO 920
      NVOLUM = IQ(JVOLUM-1)
      CALL GLOOK (IUDET, IQ(JVOLUM+1), NVOLUM, IVOL)
      IF (IVOL.EQ.0) GO TO 920
C
C     Check that volume IVOL is a sensitive medium
C
      JVO = LQ(JVOLUM-IVOL)
      ITM = Q(JVO+4)
      JTM = LQ(JTMED-ITM)
      IF (Q(JTM+7).EQ.0.)THEN
         WRITE (CHMAIL,1000) IUDET
         CALL GMAIL(0,0)
      ENDIF
C
      IF (JSET.EQ.0)THEN
C
C     Create mother JSET bank
C
         CALL MZBOOK (IXCONS, JSET, JSET, 1, 'SETS', 0,0,0, 5, 0)
         IQ(JSET-5)=0
         NSET = 0
      ELSE
C
         NSET = IQ(JSET-1)
         CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
         IF (ISET.NE.0) GO TO 30
      ENDIF
C
C     Create JSET bank
C
      CALL MZPUSH (IXCONS, JSET, 1, 1, 'I')
      NSET = NSET +1
C
      ISET = NSET
      CALL UCTOH (IUSET, IQ(JSET+ISET), 4, 4)
      CALL MZBOOK (IXCONS, JS, JSET, -ISET, 'SETS', 0,0,0, 5, 0)
      IQ(JS-5) = ISET
C
C     Check if detector has already been defined
C
  30  JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.NE.0)THEN
         CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
         IF (IDET.NE.0) GO TO 930
      ENDIF
C
C     If not, create detector bank
C
      CALL MZPUSH (IXCONS, JS, 1, 1, 'I')
      NDET = NDET +1
      IDET = NDET
      CALL UCTOH (IUDET, IQ(JS+IDET), 4, 4)
      CALL MZBOOK (IXCONS, JD, JS, -IDET, 'SEJD', 4,4,100, IOSEJD, 0)
      IQ(JD-5) = IDET
C
      IQ(JD+7) = NWHI
      IQ(JD+8) = NWDI
      IQ(JD+9) = -1
C
C     Now enter Set/Det into JVOLUM data structure
C
      CALL GSATT (IUDET, 'SET ', ISET)
      CALL GSATT (IUDET, 'DET ', IDET)
      CALL GSATT (IUDET, 'DTYP', IDTYPE)
      GO TO 999
C
C     Errors
C
  920 WRITE (CHMAIL,2000) IUDET
      CALL GMAIL(0,0)
      GO TO 999
C
  930 WRITE (CHMAIL,3000)  IUSET, IUDET
      CALL GMAIL(0,0)
C
 1000 FORMAT (' ***** GSDETV - ISVOL=0 FOR DETECTOR',A4,' - WARNING!')
 2000 FORMAT (' ***** GSDETV ERROR, VOLUME ',A4,' NOT DEFINED')
 3000 FORMAT (' ***** GSDETV ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' ALREADY DEFINED')
C
  999 RETURN
      END
+DECK,  GSDIGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:21:12  cernlib
* Geant

      SUBROUTINE GSDIGI(ISET,IDET,LTRA,NTRA,NUMBV,KDIGI,IDIG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routines to Communicate with the data structure JDIGI       *
C.    *   ---------------------------------------------------------    *
C.    *                                                                *
C.    *   Stores element  values for  current digitisation  into the   *
C.    * data structure JDIGI.                                          *
C.    * ISET      set number                                           *
C.    * IDET      detector number                                      *
C.    * LTRA      list  of   NTRA  track   numbers  producing   this   *
C.    *           digitisation                                         *
C.    * NUMBV     volume  numbers corresponding  to  list NAMESV  of   *
C.    *           GSDET                                                *
C.    * KDIGI     integer  array of  values  for current  digisation   *
C.    *           elements                                             *
C.    * IDIG      on return, current digitisation number.              *
C.    *           If =0 digitisation has not been stored.              *
C.    *                                                                *
C.    *           The Digitisation data structure JDIGI                *
C.    *           -------------------------------------                *
C.    *                                                                *
C.    *                                            | JDIGI             *
C.    *    NSET                  ISET              v                   *
C.    *     ..........................................                 *
C.    *     |                   |  |              |  |                 *
C.    *     ..........................................                 *
C.    *                           |                                    *
C.    *                           | JDIG                               *
C.    *      NDET    IDET         v               NDET                 *
C.    *        .....................................                   *
C.    *        |      |  |      |  |               |                   *
C.    *        .....................................                   *
C.    *                |                                               *
C.    *                | JDD                                           *
C.    *                v                                               *
C.    *               ...........................................      *
C.    *               |  | 1st digitisation | 2nd digitisation, etc.   *
C.    *               ...........................................      *
C.    *                         Bank layout                            *
C.    * JDIG           = LQ(JDIGI-ISET),   pointer to  digitisations   *
C.    *                for set ISET                                    *
C.    * JDD            = LQ(JDIG-IDET),  pointer to digitisations of   *
C.    *                detector IDET of set ISET                       *
C.    * IQ(JDIG+IDET)  pointer to last word of last digitisation for   *
C.    *                this detector                                   *
C.    * IQ(JDD+1)      1st word of first digitisation                  *
C.    * IQ(JDD+NWD+1)  1st word of second digitisation                 *
C.    *                JS=LQ(JSET-ISET)                                *
C.    *                JD=LQ(JS-IDET)                                  *
C.    *                NWD=IQ(JD+5)                                    *
C.    *   The JDIGI  structure is  filled with  the routine  GSDIGI.   *
C.    * The routine GFDIGI can be used  to get the digitisations for   *
C.    * a detector IDET and set ISET.                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUDIGI                               *
C.    *       Authors    R.Brun, W.Gebel  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDDI,JDI,JDID,LOCAL(15)
      DIMENSION NUMBV(1),KDIGI(1),LTRA(1)
C.
C.    ------------------------------------------------------------------
C.
C             Find if selected set, detector exists
C
      IDIG=0
C
      IF(JSET.LE.0)GO TO 99
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 99
      IF(ISET.LE.0)GO TO 99
      IF(ISET.GT.NSET)GO TO 99
C
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 99
      IF(IDET.LE.0)GO TO 99
      IF(IDET.GT.NDET)GO TO 99
C
      JD=LQ(JS-IDET)
      JDDI=LQ(JD-2)
      IF(JDDI.LE.0)GO TO 99
      NW=IQ(JD+1)+IQ(JD+5)+2
      ND=IQ(JD+6)
      NV=IQ(JD+2)
      NWTR=NTRA/2+1
      NWD=NW+NWTR
C
C              Create DIGItisation master bank
C
      IF(JDIGI.EQ.0)THEN
         CALL MZBOOK(IXDIV,JDIGI,JDIGI,1,'DIGI',NSET,NSET,0,2,0)
         IQ(JDIGI-5)=0
      ENDIF
      JDI=LQ(JDIGI-ISET)
      IF(JDI.EQ.0)THEN
         CALL MZBOOK(IXDIV,JDI,JDIGI,-ISET,'DIGI',NDET,NDET,NDET,2,0)
      ENDIF
C
      JDID=LQ(JDI-IDET)
      IF(JDID.EQ.0)THEN
C
C            Create DIGItisation bank
C
         NWDI=IQ(JD+8)
         CALL MZBOOK(IXDIV,JDID,JDI,-IDET,'SJDI',0,0,NWDI,1,0)
         IQ(JDI+IDET)=0
      ENDIF
C
C           Check if enough space. If not increase bank size
C
  10  NDID=IQ(JDID-1)
      ILAST=IQ(JDI+IDET)
      NFREE=NDID-ILAST
      IF(NFREE.LE.NWD)THEN
         NWDI2=MAX(100,NWD,IQ(JD+8)/2)
         CALL MZPUSH(IXDIV,JDID,0,NWDI2,'I')
         GO TO 10
      ENDIF
C
      IQ(JDI+IDET)=ILAST+NWD
      IF(ILAST.NE.0)IDIG=IQ(JDID+ILAST)
      IDIG=IDIG+1
C
C
C
C
C ========>    Store tracks numbers, volumes numbers and digits
C
      IQ(JDID+ILAST+1)=NWD
      IQ(JDID+ILAST+NWD)=IDIG
      NK=ILAST+2
C
C             Store packed track numbers
C             Every 2 consecutive numbers into 1 word
C             1st half of 1st word: NTRA-1
C
      IQ(JDID+NK)=0
      IF(NTRA.GT.0)THEN
         NTRM1=NTRA-1
         CALL MVBITS(NTRM1,0,16,IQ(JDID+NK),0)
         IF(NTRM1.GE.1)THEN
            DO 23 ITR=1,NTRM1,2
               CALL MVBITS(LTRA(ITR),0,16,IQ(JDID+NK),16)
               NK=NK+1
               CALL MVBITS(LTRA(ITR+1),0,16,IQ(JDID+NK),0)
   23       CONTINUE
         ENDIF
         IF(MOD(NTRA,2).EQ.1)
     +          CALL MVBITS(LTRA(NTRA),0,16,IQ(JDID+NK),16)
      ENDIF
      NK=NK+1
C
C           Store packed volume numbers
C
      IF(NV.GT.0)THEN
         K=1
C
         DO 50 I=1,NV
            NB=IQ(JD+2*I+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JDID+NK)=NUMBV(I)
                K=1
               IF(I.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(NUMBV(I),0,NB,IQ(JDID+NK),K-1)
               K=K+NB
            ENDIF
  50     CONTINUE
         NK=NK+1
      ENDIF
C
C          Store packed digits
C
      IF(ND.GT.0)THEN
         K=1
         DO 90 I=1,ND
            NB=IQ(JDDI+2*I)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JDID+NK)=KDIGI(I)
               NK=NK+1
               K=1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(KDIGI(I),0,NB,IQ(JDID+NK),K-1)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
  99  RETURN
      END
+PATCH, GCONS.
+DECK,  GCONS_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:20:12  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
************************************************************************
*                                                                      *
*                   Introduction to the section CONS                   *
*                   --------------------------------                   *
*                                                                      *
*   THE SECTION CONS                                                   *
*                                                                      *
*  The  experimental   setup  is  represented  by   a  structure  of   *
* geometrical volumes.  Each volume is  given a medium number by the   *
* user.  Different volumes may have the same medium number [GEOM].     *
*  A  medium is  defined  by  a set  of  parameters, the  so>-called   *
* 'tracking  medium'  parameters,  which include  reference  to  the   *
* material filling the volume.                                         *
*  The tracking  of particles  through an experimental  setup [TRAK]   *
* requires access to the data which describe                           *
*       - the geometrical setup,                                       *
*       - the characteristics of the materials used,                   *
*       - the tracking medium parameters, and                          *
*       - the particle properties.                                     *
*  The section CONS contains all routines related to the storage and   *
* retrieval of information for the materials, the tracking media and   *
* the particles.                                                       *
*                                                                      *
*   MATERIALS                                                          *
*                                                                      *
*  The material  constants are  stored in  the data  structure JMATE   *
* through  the routine  GMATE which  defines the  standard table  of   *
* materials.   They can  be  accessed with  the  routine GFMATE  and   *
* printed with the routine GPMATE.                                     *
*  GMATE calls  the routine GSMATE  for each material in  turn.  The   *
* user may directly use GSMATE instead  of, or in addition to, or to   *
* partly override, GMATE.                                              *
*  MIXTUREs of  basic materials, or COMPOUNDs,  molecules with atoms   *
* from  different basic  materials, may  also be  defined and  their   *
* characteristics  can be  stored  in the  structure JMATE,  through   *
* calls  to the  routine  GSMIXT.  Mixtures  of  compounds are  also   *
* accepted.                                                            *
*  In addition,  some quantities computed during  the initialisation   *
* of the physics processes are stored  in the structure JMATE , such   *
* as energy loss and cross>-section tables [PHYS].                     *
*                                                                      *
* TRACKING MEDIUM PARAMETERS                                           *
*                                                                      *
*  For  each medium  in  turn, the  tracking  medium parameters  are   *
* stored in  the data  structure JTMED  through the  routine GSTMED.   *
* Details about these  parameters are given in [TRAK].   They can be   *
* accessed  with the  routine GFTMED  and printed  with the  routine   *
* GPTMED.                                                              *
*  The correct setting  of the tracking media  parameters is crucial   *
* for the  correctness of the  results of the simulation.   In GEANT   *
* some  of  these parameters  are  calculated  automatically by  the   *
* program by default.  This can be  disabled by the data record AUTO   *
* 0, but only experienced users should use this option.                *
*  The tracking cuts,  the physics cuts and the  flags which control   *
* the physics processes, defined in  GINIT and possibly modified via   *
* the relevant data  cards, are also stored in  the structure JTMED.   *
* Any of  these additional  parameters can  be modified  through the   *
* routine GSTPAR.                                                      *
*                                                                      *
* PARTICLES                                                            *
*                                                                      *
*  The particle  constants are  stored in  the data  structure JPART   *
* through  the routine  GPART which  defines the  standard table  of   *
* particles and, if relevant, the  branching ratios and decay modes.   *
*  The standard particle constants can  be accessed with the routine   *
* GFPART and printed with the routine GPPART.                          *
*  GPART calls the routine GSPART (and GSDK for the decays) for each   *
* particle  in turn.   The user  may call  directly GSPART  and GSDK   *
* instead of, or in addition to, or to partly override, GPART.         *
*                                                                      *
************************************************************************
#endif
+DECK,  GEVKEV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:13  cernlib
* Geant

      SUBROUTINE GEVKEV(EGEV,ENERU,KUNIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Convert energy from GeV to more appropriate units        *
C.    *                                                                *
C.    *    ==>Called by : GPLMAT,GPRMAT,GPHYSI,GPCXYZ                  *
C.    *       Author     M.Maire    *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*4 KUNIT
*
      IF(EGEV.LT.0.0000009999) THEN
         ENERU = EGEV*1.E+9
         KUNIT = '  eV'
      ELSEIF(EGEV.LT.0.0009999) THEN
         ENERU = EGEV*1.E+6
         KUNIT = ' keV'
      ELSEIF(EGEV.LT.0.9999) THEN
         ENERU = EGEV*1.E+3
         KUNIT = ' MeV'
      ELSEIF(EGEV.LT.999.9) THEN
         ENERU = EGEV
         KUNIT = ' GeV'
      ELSE
         ENERU = EGEV*1.E-3
         KUNIT = ' TeV'
      ENDIF
*
      END
+DECK,  GFCOUL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:13  cernlib
* Geant

      FUNCTION GFCOUL(Z)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Compute Coulomb correction for pair production and Brem       *
C.    *  REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78              *
C.    *                        FORMULA 2.7.17                          *
C.    *                                                                *
C.    *    ==>Called by : GSMIXT                                       *
C.    *       Author    M.Maire *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      PARAMETER (ALPHA = 7.29927E-03)
C
      AZ2   = (ALPHA*Z)**2
      AZ4   =   AZ2 * AZ2
      FP    = ( 0.0083*AZ4 + 0.20206 + 1./(1.+AZ2) ) * AZ2
      FM    = ( 0.0020*AZ4 + 0.0369  ) * AZ4
      GFCOUL = FP - FM
      END
+DECK,  GFMATE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:13  cernlib
* Geant

      SUBROUTINE GFMATE(IMAT,NAMATE,A,Z,DENS,RADL,ABSL,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Return parameters for material IMAT                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GTRACK                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
      CHARACTER NAMATE*(*)
      DIMENSION UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      A=-1.
      IF (JMATE.LE.0)GO TO 99
      IF (IMAT.LE.0)GO TO 99
      IF (IMAT.GT.NMATE)GO TO 99
C
      JMA = LQ(JMATE- IMAT)
      IF (JMA.LE.0)GO TO 99
      CALL UHTOC(IQ(JMA+1),4,NAMATE,MIN(20,LEN(NAMATE)))
      A = Q(JMA + 6)
      Z = Q(JMA + 7)
      DENS = Q(JMA + 8)
      RADL = Q(JMA + 9)
      ABSL = Q(JMA + 10)
      NWBUF = IQ(JMA-1) - 11
      IF(NWBUF.GT.0) CALL UCOPY(Q(JMA+12),UBUF,NWBUF)
C
  99  RETURN
      END
+DECK,  GFPART, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:14  cernlib
* Geant

      SUBROUTINE GFPART(IPART,NAPART,ITRTYP,AMASS,CHARGE,TLIFE
     +          ,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Return parameters for particle of type IPART             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GTREVE                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
      CHARACTER*20 NAPART
      DIMENSION UBUF(10)
C.
C.    ------------------------------------------------------------------
C.
      ITRTYP=0
      IF (JPART.LE.0)GO TO 99
      IF (IPART.LE.0)GO TO 99
      IF (IPART.GT.NPART)GO TO 99
      JPA = LQ(JPART- IPART)
      IF (JPA.LE.0)GO TO 99
C
      CALL UHTOC(IQ(JPA+1),4,NAPART,20)
      ITRTYP = Q(JPA + 6)
      AMASS = Q(JPA + 7)
      CHARGE = Q(JPA + 8)
      TLIFE = Q(JPA + 9)
      NWBUF = IQ(JPA-1) - 9
      IF(NWBUF.LE.0) GO TO 99
      DO 20 I=1,NWBUF
  20  UBUF(I)=Q(JPA+9+I)
C
  99  RETURN
      END
+DECK,  GFTMAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:14  cernlib
* Geant

      SUBROUTINE GFTMAT(IMATE,IPATT,CHMECA,KDIM,TKIN,VALUE,PCUT,IXST)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       FETCH and INTERPOLATE the DE/DX and Cross sections       *
C.    *       tabulated in JMATE banks coresponding to  :              *
C.    *       material IMATE, particle IPATT, mecanism name CHMECA,    *
C.    *       kinetic energies TKIN                                    *
C.    *                                                                *
C.    *      The CHMECAnism name can be :                              *
C.    *      'HADF'   'INEF'   'ELAF'   'FISF'   'CAPF'                *
C.    *      'HADG'   'INEG'   'ELAG'   'FISG'   'CAPG'                *
C.    *      'LOSS'   'PHOT'   'ANNI'   'COMP'   'BREM'                *
C.    *      'PAIR'   'DRAY'   'PFIS'   'RAYL'   'HADG'                *
C.    *      'MUNU'   'RANG'   'STEP'                                  *
C.    *                                                                *
C.    *       For Hadronic particles it also computes the              *
C.    *       hadronic cross section from FLUKA ( '***F' ) or          *
C.    *       GHEISHA ( '***G' ) programs:                             *
C.    *       HADF or HADG -- total                                    *
C.    *       INEF or INEG -- inelastic                                *
C.    *       ELAF or ELAG -- elastic                                  *
C.    *       FISF or FISG -- fission (0.0 for FLUKA)                  *
C.    *       CAPF or CAPG -- neutron capture (0.0 for FLUKA)          *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IMATE   Geant material number                                 *
C.    *  IPATT   Geant particle number                                 *
C.    *  CHMECA   mechanism name of the bank to be fetched             *
C.    *  KDIM   dimension of the arrays TKIN , VALUE                   *
C.    *  TKIN   array of kinetic energy of incident particle (in Gev)  *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    *  VALUE  array of energy loss (in Mev/cm) ,                     *
C.    *               or stopping range (cm) ,or continuous step (cm)  *
C.    *               or macroscopic cross section (in 1/cm)           *
C.    *  PCUT(5)  array of the physical cuts in material IMATE  (Gev)  *
C.    *  IXST   flag = 1 if the array VALUE is filled ,  =0 otherwise  *
C.    *                                                                *
C.    *    ==>Called by : <USER>  GPLMAT  GRPMAT                       *
C.    *       Authors    R.Brun, M.Maire    *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCONST.
+CDE, GCUNIT.
+CDE, GCMULO.
+CDE, GSECTI.
+CDE, GCFLAG.
+CDE, GCTRAK.
+CDE, GCMATE.
+CDE, GCTMED.
+CDE, GFKDIS.
+CDE, GCKING.
+CDE, GCKINE.
*
      LOGICAL CERKOV
      CHARACTER*4  CHMECA
      DIMENSION TKIN(KDIM), VALUE(KDIM), PCUT(5)
+CDE, GCNMEC.
*
*     ------------------------------------------------------------------
*
      IXST = 0
      IF(KDIM.LE.0) GO TO 999
      IMECA = 0
      DO 10  KMECA=1,NMECA
         IF(CHMECA.EQ.CHNMEC(KMECA)) THEN
            IMECA = KMECA
         ENDIF
   10 CONTINUE
      IF(IMECA.EQ.0) THEN
         WRITE(CHMAIL,'('' *** GFTMAT: Mechanism '',A,                 '
     +   //'    ''not implemented'')') CHMECA
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
      DO 20  IDIM=1, KDIM
         VALUE(IDIM)=0.
   20 CONTINUE
      DO 30  ICUT=1,5
         PCUT(ICUT)=0.
   30 CONTINUE
*
      IF(JMATE.LE.0) GO TO 999
      IF(IMATE.LE.0) GO TO 999
      IF(IMATE.GT.NMATE) GO TO 110
      JMA = LQ(JMATE-IMATE)
      IF(JMA.LE.0) GO TO 110
      A      =  Q(JMA+6)
      Z      =  Q(JMA+7)
      IF(Z.LT.1.) GO TO 999
      DENS   =  Q(JMA+8)
      RADL   =  Q(JMA+9)
      NLM    =  Q(JMA+11)
      JPROB  = LQ(JMA-4)
      AZRO   =  Q(JPROB+8)
      AHEFF  =  A
      IF(NLM .GT.1) THEN
         JMIXT = LQ(JMA-5)
         JMI1  = LQ(JMIXT-1)
         AHEFF =  Q(JMI1+1)
      ENDIF
*
      IF(JTMED.LE.0) GO TO 999
      IF(NTMED.LE.0) GO TO 999
      JBANK = JTMED
      DO 40 ITM = 1,NTMED
         JTM = LQ(JTMED-ITM)
         IF(JTM.LE.0) GO TO 40
         JTMN =  0
         IMAT =  Q(JTM+6)
         IF(IMAT.EQ.IMATE) THEN
            JTMN = LQ(JTM)
            IF(JTMN.NE.0) JBANK = JTMN
            GO TO 50
         ENDIF
   40 CONTINUE
   50 CALL UCOPY( Q(JBANK+6),PCUT(1),5)
      CUTHAD = Q(JBANK+ 4)
      ILOSS  = Q(JBANK+21)
      IMULS  = Q(JBANK+22)
      IFIELD = Q(JTM +  8)
      FIELDM = Q(JTM +  9)
      TMAXFD = Q(JTM + 10)
      STEMAX = Q(JTM + 11)
      DEEMAX = Q(JTM + 12)
      STMIN  = Q(JTM + 14)
*
      IF(JPART.LE.0) GO TO 999
      IF(IPATT.LE.0) GO TO 999
      IF(IPATT.GT.NPART) GO TO 110
      JPA = LQ(JPART-IPATT)
      IF(JPA.LE.0) GO TO 110
      ITYPE  =  Q(JPA+6)
      AMASS  =  Q(JPA+7)
      CHARGE =  Q(JPA+8)
*
* *** Find the correct pointer
*
      JBANK  = 0
      ISHIF  = 0
      RMASS  = 1.
*
* *** Photons
*
      IF (ITYPE.EQ.1) THEN
         IF (CHMECA.EQ.'PHOT') JBANK = LQ(JMA- 6)
         IF (CHMECA.EQ.'COMP') JBANK = LQ(JMA- 8)
         IF (CHMECA.EQ.'PAIR') JBANK = LQ(JMA-10)
         IF (CHMECA.EQ.'PFIS') JBANK = LQ(JMA-12)
         IF (CHMECA.EQ.'RAYL') JBANK = LQ(JMA-13)
*
* *** Electrons / positons
*
      ELSE IF (ITYPE.EQ.2) THEN
         IF (CHMECA.EQ.'LOSS') THEN
            JBANK = LQ(JMA- 1)
            IF (CHARGE.GT.0.) ISHIF = NEK1
         ELSE IF (CHMECA.EQ.'RANG') THEN
            JBANK = LQ(JMA- 15)
            IF (CHARGE.GT.0.) ISHIF = NEK1
         ELSE IF (CHMECA.EQ.'STEP') THEN
            JBANK = LQ(JTM- 1)
         ELSE IF ((CHMECA.EQ.'ANNI').AND.(CHARGE.GT.0.)) THEN
            JBANK = LQ(JMA- 7)
         ELSE IF (CHMECA.EQ.'BREM') THEN
            JBANK = LQ(JMA- 9)
         ELSE IF (CHMECA.EQ.'DRAY') THEN
            JBANK = LQ(JMA-11)
            IF (CHARGE.GT.0.) ISHIF = NEK1
         ENDIF
*
* *** Neutral hadrons (***F for FLUKA cross sections
*                      ***G for GHEISHA cross sections
*                      LOWN and N*** for MICAP cross sections)
*
      ELSE IF (ITYPE.EQ.3) THEN
         IF((CHMECA.EQ.'HADF').OR.(CHMECA.EQ.'INEF')
     +   .OR.(CHMECA.EQ.'ELAF') .OR.(CHMECA.EQ.'FISF')
     +   .OR.(CHMECA.EQ.'CAPF')) THEN
            JBANK = -3
            IF (IFINIT(5) .EQ. 0) CALL FLINIT
         ELSE IF((CHMECA.EQ.'HADG').OR.(CHMECA.EQ.'INEG')
     +   .OR.(CHMECA.EQ. 'ELAG').OR.(CHMECA.EQ.'FISG')
     +   .OR.(CHMECA.EQ.'CAPG')) THEN
            JBANK = -4
            CALL GHEINI
         ELSE IF(IMECA.GE.IBLOWN.AND.IPATT.EQ.13) THEN
            IF (IFINIT(7) .EQ. 0) CALL GMORIN
            JBANK = -5
         ENDIF
         K0OLD = K0FLAG
*
* *** Charged hadrons (***F for FLUKA cross sections
*                      ***G for GHEISHA cross sections)
* *** Heavy ions
*
      ELSE IF (ITYPE.EQ.4.OR.ITYPE.EQ.8) THEN
         RMASS = PMASS/AMASS
         IF (CHMECA.EQ.'LOSS') THEN
            JBANK = LQ(JMA- 3)
         ELSE IF (CHMECA.EQ.'RANG') THEN
            JBANK = LQ(JMA- 16) + NEK1
         ELSE IF (CHMECA.EQ.'STEP') THEN
            JBANK = -1
            JRANG = LQ(JMA -16) + NEK1
            CUTPRO = CUTHAD*RMASS
            CUTPRO = MAX(ELOW(1), MIN( CUTPRO, ELOW(NEK1)*0.99))
            IKCUT  = GEKA*LOG10(CUTPRO) + GEKB
            GKC = (CUTPRO - ELOW(IKCUT))/(ELOW(IKCUT+1) - ELOW(IKCUT))
            STOPC = (1.-GKC)*Q(JRANG+IKCUT) + GKC*Q(JRANG+IKCUT+1)
         ELSE IF (CHMECA.EQ.'DRAY') THEN
            JBANK = -2
            JPROB = LQ(JMA-4)
            AZRO  =  Q(JPROB+17)
            DCUTM =  PCUT(4)
         ELSE IF(((CHMECA.EQ.'HADF').OR.(CHMECA.EQ.'INEF')
     +   .OR.(CHMECA.EQ. 'ELAF').OR.(CHMECA.EQ.'FISF')
     +   .OR.(CHMECA.EQ.'CAPF')).AND.ITYPE.NE.8) THEN
            JBANK = -3
            IF (IFINIT(5) .EQ. 0) CALL FLINIT
         ELSE IF(((CHMECA.EQ.'HADG').OR.(CHMECA.EQ.'INEG')
     +   .OR.(CHMECA.EQ. 'ELAG').OR.(CHMECA.EQ.'FISG')
     +   .OR.(CHMECA.EQ.'CAPG')).AND.ITYPE.NE.8) THEN
            JBANK = -4
            CALL GHEINI
         ENDIF
         K0OLD = K0FLAG
*
* *** Muons
*
      ELSE IF (ITYPE.EQ.5) THEN
         IF (CHMECA.EQ.'LOSS') THEN
            JBANK = LQ(JMA- 2)
         ELSE IF (CHMECA.EQ.'RANG') THEN
            JBANK = LQ(JMA- 16)
         ELSE IF (CHMECA.EQ.'STEP') THEN
            JBANK = LQ(JTM- 2)
         ELSE IF (CHMECA.EQ.'MUNU') THEN
            JBANK = LQ(JMA- 14)
         ELSE IF (CHMECA.EQ.'BREM') THEN
            JBANK = LQ(JMA- 9)
            ISHIF = 2*NEK1
         ELSE IF (CHMECA.EQ.'PAIR') THEN
            JBANK = LQ(JMA- 10)
            ISHIF = NEK1
         ELSE IF (CHMECA.EQ.'DRAY') THEN
            JBANK = LQ(JMA-11)
            ISHIF = 2*NEK1
         ENDIF
*
* *** Geantinos
*
      ELSEIF (ITYPE.EQ.6) THEN
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
         JBANK = 0
*
* *** Cerenkov
*
      ELSEIF (ITYPE.EQ.7) THEN
         IF (CHMECA.EQ.'LABS') THEN
*
* *** Not implemented yet!
            JBANK=0
         ENDIF
*
      ENDIF
      CERKOV=.FALSE.
      IF(CHARGE.NE.0.AND.ITCKOV.NE.0) THEN
         IF(IQ(JTM-2).GE.3) THEN
            IF(LQ(JTM-3).NE.0.AND.LQ(LQ(JTM-3)-3).NE.0) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag and calculate the
* ***  relevant pointers.
*
               CERKOV = .TRUE.
               JTCKOV = LQ(JTM-3)
               JABSCO = LQ(JTCKOV-1)
               JEFFIC = LQ(JTCKOV-2)
               JINDEX = LQ(JTCKOV-3)
               JCURIN = LQ(JTCKOV-4)
               NPCKOV = Q(JTCKOV+1)
            ENDIF
         ENDIF
      ENDIF

      IF(JBANK.EQ.0) GO TO 999
      IXST = 1
*
*
      JBANK = JBANK + ISHIF
      DO 100 IKB = 1,KDIM
*        Find bin number in table JMATE
         EKP = TKIN(IKB)*RMASS
         EKP = MAX(ELOW(1), MIN( EKP, ELOW(NEK1)*0.99))
         IKP=GEKA*LOG10(EKP)+GEKB +0.001
         GKRA=(EKP-ELOW(IKP))/(ELOW(IKP+1)-ELOW(IKP))
*
         IF(JBANK.GT.0) THEN
*           Retieve value from bank JMATE
            VALUE(IKB) =  (1.-GKRA)*Q(JBANK+IKP) + GKRA*Q(JBANK+IKP+1)
            IF ((CHMECA.EQ.'PHOT').AND.(EKP.GE.0.05 )) VALUE(IKB) =
     +      BIG
            IF ((CHMECA.EQ.'MUNU').AND.(EKP.LT.0.05 )) VALUE(IKB) =
     +      BIG
            IF ( CHMECA.EQ.'LOSS') THEN
               VALUE(IKB) = VALUE(IKB)*CHARGE**2*1.E+3
            ELSE IF (CHMECA.EQ.'RANG') THEN
               VALUE(IKB) = VALUE(IKB)/(RMASS*CHARGE*CHARGE)
            ELSE IF (CHMECA.NE.'STEP') THEN
               IF (VALUE(IKB).GT.0.) THEN
                  VALUE(IKB) = 1./VALUE(IKB)
               ELSE
                  VALUE(IKB) = 1./BIG
               ENDIF
            ENDIF
*
         ELSEIF (JBANK.EQ.-1) THEN
*           Compute step due to muls + loss + field
            GEKIN=TKIN(IKB)
            GETOT=GEKIN+AMASS
            PMOM =SQRT(GEKIN*(GETOT+AMASS))
            SFIELD = BIG
            SMULS  = BIG
            SLOSS  = BIG
            STOPMX = BIG
            IF (IFIELD*FIELDM.NE.0.)
     +         SFIELD = 3333.*DEGRAD*TMAXFD*PMOM/ABS(FIELDM*CHARGE)
            IF (IMULS.GT.0.)
     +         SMULS = MIN (2232.*RADL*((PMOM**2)/(GETOT*CHARGE))**2 ,
     +                      10.*RADL )
            IF (ILOSS*DEEMAX.GT.0.) THEN
               STOPP  = (1.-GKRA)*Q(JRANG+IKP) + GKRA*Q(JRANG+IKP+1)
               STOPMX = (STOPP - STOPC)/(RMASS*CHARGE*CHARGE)
               IF (STOPMX.LT.0.) STOPMX = 0.
               EKF = MAX ( ELOW(1) , (1.-DEEMAX)*EKP )
               IKF = GEKA*LOG10(EKF) + GEKB
               GKF = (EKF-ELOW(IKF))/(ELOW(IKF+1)-ELOW(IKF))
               SLOSP= STOPP - (1.-GKF)*Q(JRANG+IKF) - GKF*Q(JRANG+IKF+1)
               SLOSS = SLOSP/(RMASS*CHARGE*CHARGE)
            ENDIF
            IF(CERKOV) THEN
               VECT(7)=SQRT(TKIN(IKB)*(TKIN(IKB)+2*AMASS))
               CALL GNCKOV
               STCKOV = MXPHOT/MAX(3.*DNDL,1E-10)
            ELSE
               STCKOV=BIG
            ENDIF
*
            IF (STOPMX.LE.STMIN) THEN
               VALUE(IKB) = STOPMX
            ELSE
               VALUE(IKB) = MAX(STMIN,MIN(STCKOV,SLOSS,SFIELD,SMULS,
     +         STEMAX))
            ENDIF
*
         ELSEIF (JBANK.EQ.-2) THEN
*           Compute delta ray cross section for hadrons
            GEKIN=TKIN(IKB)
            GETOT=GEKIN+AMASS
            GAMASS=GETOT+AMASS
            BET2=GEKIN*GAMASS/(GETOT*GETOT)
            TMAX=EMASS*GEKIN*GAMASS/(0.5*AMASS*AMASS+EMASS*GETOT)
            IF(TMAX.GT.DCUTM)THEN
               Y=DCUTM/TMAX
               SIG=(1.-Y+BET2*Y*LOG(Y))/DCUTM
               IF(AMASS.GT.0.9)SIG=SIG+0.5*(TMAX-DCUTM)/(GETOT*GETOT)
               VALUE(IKB)=SIG*AZRO*CHARGE*CHARGE*EMASS/BET2
            ELSE
               VALUE(IKB)=1./BIG
            ENDIF
*
*           compute hadronic cross section from FLUKA code
*
         ELSEIF (JBANK.EQ.-3) THEN
            GEKIN=TKIN(IKB)
            PMOM = SQRT(GEKIN*(GEKIN+2*AMASS))
            NMAT = IMATE
            VECT(7) = PMOM
            IF (IPATT.NE.IPART) THEN
                IOLDP = IPART
                IPART = IPATT
                CALL FLDIST
                IPART = IOLDP
            ELSE
                CALL FLDIST
            END IF
            IF (CHMECA.EQ.'HADF') VALUE(IKB)= FSIG
            IF (CHMECA.EQ.'INEF') VALUE(IKB)= SINE
            IF (CHMECA.EQ.'ELAF') VALUE(IKB)= SELA
            IF (CHMECA.EQ.'FISF') VALUE(IKB)= 0.0
            IF (CHMECA.EQ.'CAPF') VALUE(IKB)= 0.0
*
*           compute hadronic cross section from GHEISHA code
*
         ELSEIF (JBANK.EQ.-4) THEN
            GEKIN=TKIN(IKB)
            PMOM = SQRT(GEKIN*(GEKIN+2*AMASS))
            K0FLAG = 1
*           (compounds)
            IF(NLM.GT.1) THEN
               HHHH=0.
               IF (JTMN.GT.0) HHHH=Q(JTMN+26)
               VALUE(IKB)=GHESIG(PMOM,GEKIN,A,Q(JMIXT+1), Q(JMIXT+NLM+
     +         1),Q(JMIXT+2*NLM+1),NLM,DENS,HHHH,IPATT)
               IF (CHMECA .EQ. 'INEG') THEN
                  VALUE(IKB) = 0.
                  DO 60 K=1,NLM
                     VALUE(IKB) = AIIN(K) + VALUE(IKB)
   60             CONTINUE
               ELSE IF (CHMECA .EQ. 'ELAG') THEN
                  VALUE(IKB) = 0.
                  DO 70 K=1,NLM
                     VALUE(IKB) = AIEL(K) + VALUE(IKB)
   70             CONTINUE
               ELSE IF (CHMECA .EQ. 'FISG') THEN
                  VALUE(IKB) = 0.
                  DO 80 K=1,NLM
                     VALUE(IKB) = AIFI(K) + VALUE(IKB)
   80             CONTINUE
               ELSE IF (CHMECA .EQ. 'CAPG') THEN
                  VALUE(IKB) = 0.
                  DO 90 K=1,NLM
                     VALUE(IKB) = AICA(K) + VALUE(IKB)
   90             CONTINUE
               ENDIF
            ELSE
*           (simple elements)
               VALUE(IKB)=GHESIG(PMOM,GEKIN,A,A,Z,1.,1,DENS,0.,IPATT)
               IF (CHMECA .EQ. 'INEG') VALUE(IKB) = AIIN(1)
               IF (CHMECA .EQ. 'ELAG') VALUE(IKB) = AIEL(1)
               IF (CHMECA .EQ. 'FISG') VALUE(IKB) = AIFI(1)
               IF (CHMECA .EQ. 'CAPG') VALUE(IKB) = AICA(1)
            END IF
            K0FLAG = K0OLD
*
*           compute the cross-section for low-energy neutrons
*           from MICAP code
*
         ELSEIF (JBANK.EQ.-5) THEN
            GEKIN=TKIN(IKB)
            IF (GEKIN.LE..02) THEN
               IF (CHMECA .EQ. 'LOWN') THEN
                  VALUE(IKB) = SIGMOR(GEKIN*1.E+9,IMATE)
               ELSE
                  NMAT = IMATE
                  CALL GMXSEC (IMECA,VALUE(IKB))
               ENDIF
            ELSE
               VALUE(IKB) = 0.
            ENDIF
*
         ENDIF
  100 CONTINUE
*
      GO TO 999
  110 WRITE(CHMAIL,10100) IMATE ,IPATT
      CALL GMAIL(0,0)
*
10000 FORMAT(' ***** GFTMAT: No processes active for geantinos')
10100 FORMAT(' ***** GFTMAT error : material',I4,
     +       '  or particle',I4,' not defined'   )
  999 END
+DECK,  GFTMED, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:14  cernlib
* Geant

      SUBROUTINE GFTMED(NUMED,NATMED,NMAT,ISVOL,IFIELD,FIELDM,
     +           TMAXFD,STEMAX,DEEMAX,EPSIL,STMIN,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Return parameters for tracking medium NUMED              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GTRACK                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
      CHARACTER*20 NATMED
      DIMENSION UBUF(1)
C.
C.    ------------------------------------------------------------------
C.
      NMAT=0
      IF (JTMED.LE.0)GO TO 99
      IF (NUMED.LE.0)GO TO 99
      IF (NUMED.GT.NTMED)GO TO 99
      JTM = LQ(JTMED- NUMED)
      IF (JTM.LE.0)GO TO 99
C
      CALL UHTOC(IQ(JTM+1),4,NATMED,20)
      NMAT = Q(JTM + 6)
      ISVOL = Q(JTM + 7)
      IFIELD = Q(JTM + 8)
      FIELDM = Q(JTM + 9)
      TMAXFD = Q(JTM + 10)
      STEMAX = Q(JTM + 11)
      DEEMAX = Q(JTM + 12)
      EPSIL = Q(JTM + 13)
      STMIN = Q(JTM + 14)
      NWBUF = IQ(JTM-1) - 14
      IF(NWBUF.LE.0) GO TO 99
      DO 20 I=1,NWBUF
  20  UBUF(I)=Q(JTM+14+I)
C
  99  RETURN
      END
+DECK,  GHMIX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:18  cernlib
* Geant

      SUBROUTINE GHMIX(A, W, N, AEFF)
C
C     ******************************************************************
C     *                                                                *
C     *   Works out an effective atomic weight AEFF for a material     *
C     * with N elements of atomic weight A(I) in proportion W(I) by    *
C     * weight.  The criterion is that the hadronic interaction        *
C     * length of a 5 GeV/c pion is correct.  Errors on the calculated *
C     * hadronic interaction length for other momenta and other        *
C     * particles in GEANT version 3.04 are less than 1% in most cases.*
C     * For details see Memorandum OPAL/0037N/JA/md, ref. Hadron       *
C     * Milestone 84/003, Calculation of Hadronic Interaction Lengths  *
C     * for Mixtures.                                                  *
C.    *                                                                *
C.    *    ==>Called by : GSMIXT                                       *
C.    *       Author    J.Allison  *********                           *
C     *                                                                *
C     ******************************************************************
C
+CDE, GCUNIT.
      DIMENSION A(N), W(N)
C.
C.    ------------------------------------------------------------------
C.
C         Work out PINT which is proportional to the interaction
C         probability.  Also work out the mean atomic weight, i.e. that
C         weighted by proportion by numbers, as starting value for
C         iterative method of finding AEFF.
C
      PINT   = 0.
      AINV   = 0.
      WTOT   = 0.
      DO 10 I = 1, N
         PINT   = PINT + W(I) * GHSIGM(5., 8, A(I)) / A(I)
         AINV   = AINV + W(I) / A(I)
         WTOT   = WTOT + W(I)
  10  CONTINUE
C
      IF ( ABS ( WTOT - 1. ) .GT. 0.01 ) GO TO 98
C
C         Work out AEFF which gives PINT for 5 GeV/c pion.
C         (This is a short Newton's method loop.)
C
      AEFF   = 1. / AINV
      PNEW   = GHSIGM ( 5., 8, AEFF ) / AEFF
      DA     = 1.
      ITER   = 0
   20 CONTINUE
      ITER   = ITER + 1
      AEFF   = AEFF + DA
      POLD   = PNEW
      DAOLD  = DA
      PNEW   = GHSIGM ( 5., 8, AEFF ) / AEFF
      DP     = PNEW - POLD
      DA     = (PINT - PNEW ) * DAOLD / DP
      IF ( ( ITER .GT. 1 ) .AND. ( ABS ( DA ) .GT. ABS ( DAOLD ) ) )
     +                            GO TO 97
      IF ( ABS ( DA ) .GT. 0.01 ) GO TO 20
C
      RETURN
C
C            Error conditions.
C
  97  CONTINUE
      WRITE (CHMAIL,197)
      CALL GMAIL(0,0)
 197  FORMAT ( ' ***** GHMIX : ',
     +'HADRONIC INTERACTION MIXTURE ROUTINE NOT CONVERGING')
      RETURN
C
  98  CONTINUE
      WRITE (CHMAIL,198) WTOT
      CALL GMAIL(0,0)
 198  FORMAT ( ' ***** GHMIX : ',
     +'FRACTIONS BY WEIGHT OF MIXTURES DO NOT ADD UP TO 1',F10.4)
      END
+DECK,  GMATE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:15  cernlib
* Geant

      SUBROUTINE GMATE
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Define standard GEANT materials                               *
C.    *                                                                *
C.    *  All data EXCEPT for nuclear absorption lengths taken from :   *
C.    *                        M. Aguilar-Benitez et al,               *
C.    *                        Rev. of Particle Properties,            *
C.    *                        Rev. Mod. Phys. 56(1984)                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION UBUF(1)
      DATA UBUF/0./
C
      CALL GSMATE( 1,'HYDROGEN$ ',  1.01, 1.,0.0708,865.,790.,UBUF,0)
      CALL GSMATE( 2,'DEUTERIUM$',  2.01, 1.,0.162 ,757.,342.,UBUF,0)
      CALL GSMATE( 3,'HELIUM$   ',  4.  , 2.,0.125 ,755.,478.,UBUF,0)
      CALL GSMATE( 4,'LITHIUM$  ',  6.94, 3.,0.534 ,155.,120.6,UBUF,0)
      CALL GSMATE( 5,'BERILLIUM$',  9.01, 4.,1.848 ,35.3,36.7,UBUF,0)
      CALL GSMATE( 6,'CARBON$   ', 12.01, 6.,2.265 ,18.8,49.9,UBUF,0)
      CALL GSMATE( 7,'NITROGEN$ ', 14.01, 7.,0.808 ,44.5,99.4,UBUF,0)
      CALL GSMATE( 8,'NEON$     ', 20.18,10.,1.207 , 24.,74.9,UBUF,0)
      CALL GSMATE( 9,'ALUMINIUM$', 26.98,13.,2.7   , 8.9,37.2,UBUF,0)
      CALL GSMATE(10,'IRON$     ', 55.85,26.,7.87  ,1.76,17.1,UBUF,0)
      CALL GSMATE(11,'COPPER$   ', 63.54,29.,8.96  ,1.43,14.8,UBUF,0)
      CALL GSMATE(12,'TUNGSTEN$ ',183.85,74.,19.3  ,0.35,10.3,UBUF,0)
      CALL GSMATE(13,'LEAD$     ',207.19,82.,11.35 ,0.56,18.5,UBUF,0)
      CALL GSMATE(14,'URANIUM$  ',238.03,92.,18.95 ,0.32,12. ,UBUF,0)
      CALL GSMATE(15,'AIR$      ',14.61,7.3,0.001205,30423.24,67500.
     +                           ,UBUF,0)
      CALL GSMATE(16,'VACUUM$ ',1.E-16,1.E-16,1.E-16,1.E+16,1.E+16
     +                           ,UBUF,0)
C
      END
+DECK,  GPART, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:15  cernlib
* Geant

      SUBROUTINE GPART
C.
C.    *******************************************************************
C.    *                                                                 *
C.    *  Define standard GEANT particles plus selected decay modes      *
C.    *  and branching ratios.                                          *
C.    *                                                                 *
C.    *  All data taken from : M. AGUILAR-BENITEZ et al,                *
C.    *                        Review of Particle Properties,           *
C.    *                        Rev. Mod. Phys. 56(1984).                *
C.    *                                                                 *
C.    *  Updated to:           Phys.Rev. D50,1173(1994)                 *
C.    *                        S. Ravndal                               *
C.    *                                                                 *
C.    *                                                                 *
C.    *  In the case of W and Z, the lifetimes are calculated from      *
C.    *  quoted upper limits on widths.                                 *
C.    *                                                                 *
C.    *  NPAR           Number of parent particles defined for decay.   *
C.    *  IPAR           List of parent partilces allowed to decay.      *
C.    *                 Currently set up for pi0,pi+,pi-,K0long,K+,K-,  *
C.    *                 K0short,eta,lambda,sigma+,sigma0,sigma-,xi0,    *
C.    *                 xi-,omega-,antilambda,antisigma -,antisigma 0,  *
C.    *                 antisigma +,antixi 0,antixi +,antiomega +       *
C.    *                 decays.                                         *
C.    *  MODE(I,J)      I'th decay mode of J'th particle defined in     *
C.    *                 IPAR.                                           *
C.    *  BRATIO(I,J)    Branching ratio for I'th decay mode of J'th     *
C.    *                 particle in IPAR.                               *
C.    *                                                                 *
C.    *    ==>Called by : <USER>, UGINIT                                *
C.    *       Author    G.Patrick  *********                            *
C.    *                                                                 *
C.    *******************************************************************
C.
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCONSP.
C
      DIMENSION BRATIO(6,24),BRTIO1(6,20),BRTIO2(6,4)
      DIMENSION IPAR(24)
      DIMENSION MODE(6,24),MODE1(6,20),MODE2(6,4)
      DIMENSION UBUF(1)
C
      EQUIVALENCE(BRTIO1(1,1),BRATIO(1,1)),(BRTIO2(1,1),BRATIO(1,21))
      EQUIVALENCE(MODE1(1,1),MODE(1,1)),(MODE2(1,1),MODE(1,21))
C
      DATA IPAR/ 7, 8, 9,10,11,12,16,17,18,19,20,21,22,23,24,26,27,
     *          28,29,30,31,32,5,6/
      DATA BRTIO1/ 98.802, 1.198, 0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *             21.60, 19.35, 19.35, 13.50, 13.50, 12.38,
     *             63.51, 21.17,  5.59,  4.82,  3.18,  1.73,
     *             63.51, 21.17,  5.59,  4.82,  3.18,  1.73,
     *             68.61, 31.39,  0.,    0.,    0.,    0.,
     *             38.80, 31.90, 23.6,   4.88,  0.5,   0.071,
     *             63.90, 35.80,  0.,    0.,    0.,    0.,
     *             51.57, 48.30,  0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *             67.80, 23.60,  8.60,  0.,    0.,    0.,
     *             63.90, 35.80,  0.,    0.,    0.,    0.,
     *             51.57, 48.30,  0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0./
      DATA BRTIO2/100.00,  0.,    0.,    0.,    0.,    0.,
     *             67.80, 23.60,  8.60,  0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0./
      DATA MODE1/  101,30201,    0,    0,    0,    0,
     *             405,    0,    0,    0,    0,    0,
     *             406,    0,    0,    0,    0,    0,
     *             70707,40308,40209,40608,40509,70908,
     *             405,  708,90808,70402,70405,70708,
     *             406,  709,80909,70403,70406,70709,
     *             908,  707,    0,    0,    0,    0,
     *             101,70707,70908,10908,10302,10107,
     *             914,  713,    0,    0,    0,    0,
     *             714,  813,    0,    0,    0,    0,
     *             118,    0,    0,    0,    0,    0,
     *             913,    0,    0,    0,    0,    0,
     *             718,    0,    0,    0,    0,    0,
     *             918,    0,    0,    0,    0,    0,
     *            1218,  922,  723,    0,    0,    0,
     *             815,  725,    0,    0,    0,    0,
     *             715,  925,    0,    0,    0,    0,
     *             126,    0,    0,    0,    0,    0,
     *             825,    0,    0,    0,    0,    0,
     *             726,    0,    0,    0,    0,    0/
      DATA MODE2/  826,    0,    0,    0,    0,    0,
     *            1126,  830,  731,    0,    0,    0,
     *           40402,    0,    0,    0,    0,    0,
     *           40403,    0,    0,    0,    0,    0/
      DATA NPAR/24/
      DATA UBUF/0./
C.
C.    -------------------------------------------------------------------
C.
      REMASS=EMASS
      REMMU =EMMU
      RPMASS=PMASS
      CALL GSPART( 1,'GAMMA$      ',1,0.      , 0.,1.E+15,UBUF,0)
      CALL GSPART( 2,'POSITRON$   ',2,REMASS  , 1.,1.E+15,UBUF,0)
      CALL GSPART( 3,'ELECTRON$   ',2,REMASS  ,-1.,1.E+15,UBUF,0)
      CALL GSPART( 4,'NEUTRINO$   ',3,0.      , 0.,1.E+15,UBUF,0)
      CALL GSPART( 5,'MUON +$     ',5,REMMU   , 1.,2.19703E-06,UBUF,0)
      CALL GSPART( 6,'MUON -$     ',5,REMMU   ,-1.,2.19703E-06,UBUF,0)
      CALL GSPART( 7,'PION 0$     ',3,0.1349764,0.,0.84E-16,UBUF,0)
      CALL GSPART( 8,'PION +$     ',4,0.1395700, 1.,2.603E-08,UBUF,0)
      CALL GSPART( 9,'PION -$     ',4,0.1395700,-1.,2.603E-08,UBUF,0)
      CALL GSPART(10,'KAON 0 LONG$',3,0.497672, 0.,5.17E-08,UBUF,0)
      CALL GSPART(11,'KAON +$     ',4,0.493677, 1.,1.237E-08,UBUF,0)
      CALL GSPART(12,'KAON -$     ',4,0.493677,-1.,1.237E-08,UBUF,0)
      CALL GSPART(13,'NEUTRON$    ',3,0.93956563, 0.,8.870E+02,UBUF,0)
      CALL GSPART(14,'PROTON$     ',4,RPMASS  , 1.,1.000000E+15,UBUF,0)
      CALL GSPART(15,'ANTIPROTON$ ',4,RPMASS  ,-1.,1.000000E+15,UBUF,0)
      CALL GSPART(16,'KAON 0 SHORT$',3,0.497672, 0.,8.926E-11,UBUF,0)
      CALL GSPART(17,'ETA$        ',3,0.54745 , 0.,5.485E-19,UBUF,0)
      CALL GSPART(18,'LAMBDA$     ',3,1.115684, 0.,2.632E-10,UBUF,0)
      CALL GSPART(19,'SIGMA +$    ',4,1.18937 , 1.,0.799E-10,UBUF,0)
      CALL GSPART(20,'SIGMA 0$    ',3,1.19255 , 0.,7.4E-20,UBUF,0)
      CALL GSPART(21,'SIGMA -$    ',4,1.197436,-1.,1.479E-10,UBUF,0)
      CALL GSPART(22,'XI 0$       ',3,1.3149  , 0.,2.9E-10,UBUF,0)
      CALL GSPART(23,'XI -$       ',4,1.32132 ,-1.,1.639E-10,UBUF,0)
      CALL GSPART(24,'OMEGA -$    ',4,1.67245 ,-1.,0.822E-10,UBUF,0)
      CALL GSPART(25,'ANTINEUTRON$',3,0.93956563, 0.,8.870E+02,UBUF,0)
      CALL GSPART(26,'ANTILAMBDA$ ',3,1.115684, 0.,2.632E-10,UBUF,0)
      CALL GSPART(27,'ANTISIGMA -$',4,1.18937 ,-1.,0.799E-10,UBUF,0)
      CALL GSPART(28,'ANTISIGMA 0$',3,1.19255 , 0.,7.4E-20,UBUF,0)
      CALL GSPART(29,'ANTISIGMA +$',4,1.197436, 1.,1.479E-10,UBUF,0)
      CALL GSPART(30,'ANTIXI 0$   ',3,1.3149  , 0.,2.9E-10,UBUF,0)
      CALL GSPART(31,'ANTIXI +$   ',4,1.32132 , 1.,1.639E-10,UBUF,0)
      CALL GSPART(32,'ANTIOMEGA +$',4,1.67245 , 1.,0.822E-10,UBUF,0)
*     CALL GSPART(33,'TAU +$      ',4,1.7771  , 1.,3.040000E-13,UBUF,0)
*     CALL GSPART(34,'TAU -$      ',4,1.7771  ,-1.,3.040000E-13,UBUF,0)
*     CALL GSPART(35,'D +$        ',4,1.8694  , 1.,1.062000E-12,UBUF,0)
*     CALL GSPART(36,'D -$        ',4,1.8694  ,-1.,1.062000E-12,UBUF,0)
*     CALL GSPART(37,'D 0$        ',3,1.8646  , 0.,4.280000E-13,UBUF,0)
*     CALL GSPART(38,'ANTI D 0$   ',3,1.8646  , 0.,4.280000E-13,UBUF,0)
*     CALL GSPART(39,'DS+$        ',4,1.9685  , 1.,4.360000E-13,UBUF,0)
*     CALL GSPART(40,'DS-$        ',4,1.9685  ,-1.,4.360000E-13,UBUF,0)
*     CALL GSPART(41,'LAMBDA C +$ ',4,2.2851  , 1.,1.790000E-13,UBUF,0)
*     CALL GSPART(42,'W +$        ',4,80.220  , 1.,3.160000E-25,UBUF,0)
*     CALL GSPART(43,'W -$        ',4,80.220  ,-1.,2.640000E-25,UBUF,0)
*     CALL GSPART(44,'Z 0$        ',3,91.187  , 0.,7.740000E-26,UBUF,0)
      CALL GSPART(45,'DEUTERON$   ',8,1.875613,+1.,1.000000E+15,UBUF,0)
      CALL GSPART(46,'TRITON$     ',8,2.80925 ,+1.,1.000000E+15,UBUF,0)
      CALL GSPART(47,'ALPHA$      ',8,3.727417,+2.,1.000000E+15,UBUF,0)
      CALL GSPART(48,'GEANTINO$   ',6,0.      , 0.,1.000000E+15,UBUF,0)
      CALL GSPART(49,'HE3$        ',8,2.80923 ,+2.,1.000000E+15,UBUF,0)
      CALL GSPART(50,'Cerenkov$   ',7,0.      , 0.,1.000000E+15,UBUF,0)
C
C     Define decay modes.
C
      DO 10 I=1,NPAR
      CALL GSDK(IPAR(I),BRATIO(1,I),MODE(1,I))
   10 CONTINUE
C
  99  RETURN
      END
+DECK,  GPIONS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:15  cernlib
* Geant

      SUBROUTINE GPIONS
C.
C.    *******************************************************************
C.    *                                                                 *
C.    *  Define a subset of the 'stable' most common elements           *
C.    *    in the Nature                                                *
C.    *                                                                 *
C.    *    ==>Called by : <USER>, UGINIT                                *
C.    *       Author    B.Grosdidier (Strasbourg) *****                 *
C.    *                                                                 *
C.    *******************************************************************
C.
      DIMENSION UBUF(1)
      DATA UBUF/0./
*
*     The Geant particle identification begin to IPART = 61
      CALL GSPART( 61,'LI6  ',8,   5.60305,  3., 1000., UBUF,0)
      CALL GSPART( 62,'LI7  ',8,   6.53536,  3., 1000., UBUF,0)
      CALL GSPART( 63,'BE7  ',8,   6.53622,  4., 1000., UBUF,0)
      CALL GSPART( 64,'BE9  ',8,   8.39479,  4., 1000., UBUF,0)
      CALL GSPART( 65,'B10  ',8,   9.32699,  5., 1000., UBUF,0)
      CALL GSPART( 66,'B11  ',8,  10.25510,  5., 1000., UBUF,0)
      CALL GSPART( 67,'C12  ',8,  11.17793,  6., 1000., UBUF,0)
      CALL GSPART( 68,'N14  ',8,  13.04378,  7., 1000., UBUF,0)
      CALL GSPART( 69,'O16  ',8,  14.89917,  8., 1000., UBUF,0)
      CALL GSPART( 70,'F19  ',8,  17.69690,  9., 1000., UBUF,0)
      CALL GSPART( 71,'NE20 ',8,  18.62284, 10., 1000., UBUF,0)
      CALL GSPART( 72,'NA23 ',8,  21.41483, 11., 1000., UBUF,0)
      CALL GSPART( 73,'MG24 ',8,  22.34193, 12., 1000., UBUF,0)
      CALL GSPART( 74,'AL27 ',8,  25.13314, 13., 1000., UBUF,0)
      CALL GSPART( 75,'SI28 ',8,  26.06034, 14., 1000., UBUF,0)
      CALL GSPART( 76,'P31  ',8,  28.85188, 15., 1000., UBUF,0)
      CALL GSPART( 77,'S32  ',8,  29.78180, 16., 1000., UBUF,0)
      CALL GSPART( 78,'CL35 ',8,  32.57328, 17., 1000., UBUF,0)
      CALL GSPART( 79,'AR36 ',8,  33.50356, 18., 1000., UBUF,0)
      CALL GSPART( 80,'K39  ',8,  36.29447, 19., 1000., UBUF,0)
      CALL GSPART( 81,'CA40 ',8,  37.22492, 20., 1000., UBUF,0)
      CALL GSPART( 82,'SC45 ',8,  41.87617, 21., 1000., UBUF,0)
      CALL GSPART( 83,'TI48 ',8,  44.66324, 22., 1000., UBUF,0)
      CALL GSPART( 84,'V51  ',8,  47.45401, 23., 1000., UBUF,0)
      CALL GSPART( 85,'CR52 ',8,  48.38228, 24., 1000., UBUF,0)
      CALL GSPART( 86,'MN55 ',8,  51.17447, 25., 1000., UBUF,0)
      CALL GSPART( 87,'FE56 ',8,  52.10307, 26., 1000., UBUF,0)
      CALL GSPART( 88,'CO59 ',8,  54.89593, 27., 1000., UBUF,0)
      CALL GSPART( 89,'NI58 ',8,  53.96644, 28., 1000., UBUF,0)
      CALL GSPART( 90,'CU63 ',8,  58.61856, 29., 1000., UBUF,0)
      CALL GSPART( 91,'ZN64 ',8,  59.54963, 30., 1000., UBUF,0)
      CALL GSPART( 92,'GE74 ',8,  68.85715, 32., 1000., UBUF,0)
      CALL GSPART( 93,'SE80 ',8,  74.44178, 34., 1000., UBUF,0)
      CALL GSPART( 94,'KR84 ',8,  78.16309, 36., 1000., UBUF,0)
      CALL GSPART( 95,'SR88 ',8,  81.88358, 38., 1000., UBUF,0)
      CALL GSPART( 96,'ZR90 ',8,  83.74571, 40., 1000., UBUF,0)
      CALL GSPART( 97,'MO98 ',8,  91.19832, 42., 1000., UBUF,0)
      CALL GSPART( 98,'PD106',8,  98.64997, 46., 1000., UBUF,0)
      CALL GSPART( 99,'CD114',8, 106.10997, 48., 1000., UBUF,0)
      CALL GSPART(100,'SN120',8, 111.68821, 50., 1000., UBUF,0)
      CALL GSPART(101,'XE132',8, 122.86796, 54., 1000., UBUF,0)
      CALL GSPART(102,'BA138',8, 128.45793, 56., 1000., UBUF,0)
      CALL GSPART(103,'CE140',8, 130.32111, 58., 1000., UBUF,0)
      CALL GSPART(104,'SM152',8, 141.51236, 62., 1000., UBUF,0)
      CALL GSPART(105,'DY164',8, 152.69909, 66., 1000., UBUF,0)
      CALL GSPART(106,'YB174',8, 162.02245, 70., 1000., UBUF,0)
      CALL GSPART(107,'W184 ',8, 171.34924, 74., 1000., UBUF,0)
      CALL GSPART(108,'PT194',8, 180.67513, 78., 1000., UBUF,0)
      CALL GSPART(109,'AU197',8, 183.47324, 79., 1000., UBUF,0)
      CALL GSPART(110,'HG202',8, 188.13451, 80., 1000., UBUF,0)
      CALL GSPART(111,'PB208',8, 193.72907, 82., 1000., UBUF,0)
      CALL GSPART(112,'U238 ',8, 221.74295, 92., 1000., UBUF,0)
*
      END
+DECK,  GPLMAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:15  cernlib
* Geant

      SUBROUTINE GPLMAT(IMATES,IPART,MECAN,KDIN,TKIN,IDM)
C.
C     ******************************************************************
C.    *                                                                *
C.    *       INTERPOLATE and PLOT  the DE/DX and Cross sections       *
C.    *       tabulated in JMATE banks corresponding to :              *
C.    *       material IMATE, particle IPART, mecanism name HMECAN,    *
C.    *       kinetic energies TKIN                                    *
C.    *                                                                *
C.    *      The MECANism name can be :                                *
C.    *      'HADF'   'INEF'   'ELAF'   'FISF'   'CAPF'                *
C.    *      'HADG'   'INEG'   'ELAG'   'FISG'   'CAPG'                *
C.    *      'LOSS'   'PHOT'   'ANNI'   'COMP'   'BREM'                *
C.    *      'PAIR'   'DRAY'   'PFIS'   'RAYL'   'HADG'                *
C.    *      'MUNU'   'RANG'   'STEP'                                  *
C.    *                                                                *
C.    *       For Hadronic particles it also computes the              *
C.    *       hadronic cross section from FLUKA ( '***F' ) or          *
C.    *       GHEISHA ( '***G' ) programs:                             *
C.    *       HADF or HADG -- total                                    *
C.    *       INEF or INEG -- inelastic                                *
C.    *       ELAF or ELAG -- elastic                                  *
C.    *       FISF or FISG -- fission (0.0 for FLUKA)                  *
C.    *       CAPF or CAPG -- neutron capture (0.0 for FLUKA)          *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IMATE   Geant material number                                 *
C.    *  IPART   Geant particle number                                 *
C.    *  MECAN  mechanism name of the bank to be fetched               *
C.    *  KDIM   dimension of the arrays TKIN , VALUE                   *
C.    *  TKIN   array of kinetic energy of incident particle (in Gev)  *
C.    *  IDM    convention for histogramming mode :                    *
C.    *         IDM.gt.0  fill , print , keep histogram(s)             *
C.    *         IDM.eq.0  fill , print , delete histogram(s)           *
C.    *         IDM.lt.0  fill , noprint , keep histogram(s)           *
C.    *           The histogram IDentificator will be :                *
C.    *             10000*imate + 100*ipart + imeca                    *
C.    *          where IMECA is the link number in stucture JMATE      *
C.    *          (see Geant3 writeup CONS 199)                         *
C.    *           for 'HADG'  imeca = 17                               *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    R.Brun, M.Maire    *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCONSP.
+CDE, GCUNIT.
+CDE, GCPHYS.
      PARAMETER (MMX= 201,NCOL= 5)
      CHARACTER*(*) MECAN
      CHARACTER*4 MECA , KU(NCOL)
      CHARACTER   NAPART*16 , NAMATE*16 , CHTITL*68
      DIMENSION   TKIN(KDIN),VALUE(MMX),SIGT(MMX),PCUT(5)
      DIMENSION   KI(NCOL),EK(NCOL)
      LOGICAL     LXBARN
*
+CDE, GCNMEC.
*
*     ------------------------------------------------------------------
*
      IF (KDIN.LE.0)  GO TO 999
      KDIM = MIN(KDIN,MMX)
      IF(IMATES.LT.0) THEN
         LXBARN=.TRUE.
      ELSEIF(IMATES.GT.0) THEN
         LXBARN=.FALSE.
      ELSE
         GOTO 999
      ENDIF
      IMATE=ABS(IMATES)
*
      IF (JMATE.LE.0) GO TO 999
      IF (IMATE.GT.NMATE) GO TO 80
      JMA = LQ(JMATE-IMATE)
      IF  (JMA.LE.0) GO TO 80
      CALL UHTOC(IQ(JMA+1),4,NAMATE,16)
      IF(LXBARN) THEN
         CMIBAR=Q(JMA+6)/(AVO*Q(JMA+8))
      ELSE
         CMIBAR=1.
      ENDIF
*
      IF (JPART.LE.0) GO TO 999
      IF (IPART.LE.0) GO TO 999
      IF (IPART.GT.NPART) GO TO 80
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0) GO TO 80
      CALL UHTOC(IQ(JPA+1),4,NAPART,16)
*
* *** Print  bin meaning
      IF (IDM.GE.0) THEN
         CHMAIL='1'
         CALL GMAIL(0,0)
         CHMAIL=' '
         CHMAIL(31:)='Kinetic energy bin meaning'
         CALL GMAIL(0,0)
         CHMAIL(31:)='--------------------------'
         CALL GMAIL(0,1)
         NROW = (KDIM-1)/NCOL + 1
         DO 20  IR=1,NROW
            DO 10  IC=1,NCOL
               IKB = IR + (IC-1)*NROW
               IF (IKB.GT.KDIM) IKB=KDIM
               KI(IC) = IKB
               CALL GEVKEV(TKIN(IKB),EK(IC),KU(IC))
   10       CONTINUE
            WRITE(CHMAIL,10200) (KI(IC),EK(IC),KU(IC),IC=1,NCOL)
            CALL GMAIL(0,0)
   20    CONTINUE
      ENDIF
*
      BIGINV= 1000./BIG
      DO 30  JMX = 1, MMX
         SIGT(JMX) = 0.
   30 CONTINUE
      IF(MECAN.EQ.'ALL') THEN
         N1 = 1
         N2 = NMECA
      ELSE
         N1 = 0
         DO 40  IMECA=1,NMECA
            IF(MECAN.EQ.CHNMEC(IMECA)) THEN
               N1 = IMECA
            ENDIF
   40    CONTINUE
         IF(N1.EQ.0) THEN
            WRITE(CHMAIL,'('' *** GPLMAT: Mechanism '',A,
     +      '' not implemented'')') MECAN
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         N2 = N1
      ENDIF
      DO 60  IMEC = N1,N2
C
         IF (MECAN.EQ.'ALL') THEN
             IF (CHNMEC(IMEC).EQ.'RANG') GO TO 60
             IF (CHNMEC(IMEC).EQ.'STEP') GO TO 60
         END IF
C
         IF(CHNMEC(IMEC).NE.'NULL') THEN
            MECA = CHNMEC(IMEC)
            CALL GFTMAT(IMATE,IPART,MECA,KDIM,TKIN,VALUE,PCUT,IXST)
            IF(IXST.EQ.0) GO TO 60
*
* ***    Book histogram
            ISIG = 0
            IF (MECA.EQ.'LOSS') THEN
               CHTITL = NAPART//' in '//NAMATE//'   dE/dx (MeV/cm)'
            ELSEIF (MECA.EQ.'RANG') THEN
               CHTITL = NAPART//' in '//NAMATE//'   Stopping range (cm)'
            ELSEIF (MECA.EQ.'STEP') THEN
               CHTITL = NAPART//' in '//NAMATE//'   continuous step '
     +         //'(cm)'
            ELSE
               CHTITL = NAPART//' in '//NAMATE//'   '//MECA// ' cross '
     +         //'section'
               IF(LXBARN) THEN
                  CHTITL(LNBLNK(CHTITL)+1:) = ' (barn)'
               ELSE
                  CHTITL(LNBLNK(CHTITL)+1:) = ' (1/cm)'
               ENDIF
               ISIG = 1
            ENDIF
*
            ID = 10000*IMATE + 100*IPART + IMEC
            CALL HBOOKB(ID,CHTITL,KDIM-1,TKIN,0.)
*
* ***    Fill histogram
*
            VALMI = MAX (BIGINV,VMAX(VALUE,KDIM)*1.E-8)
            DO 50  IKB = 1,KDIM
               IF (MECA.NE.'LOSS'.AND.MECA.NE.'RANG'
     +             .AND.MECA.NE.'STEP')
     +             VALUE(IKB)=VALUE(IKB)*CMIBAR
               IF (VALUE(IKB).GE.VALMI) THEN
                  CALL HFILL(ID,TKIN(IKB),0.,VALUE(IKB))
               ENDIF
               IF (ISIG.EQ.1) THEN
                  IF(MECA(1:3).NE.'INE'.AND.MECA(1:3).NE.'ELA'.AND.
     +            MECA(1:3).NE.'FIS'.AND.MECA(1:3).NE.'CAP'.AND.
     +            MECA(1:3).NE.'HAD'.AND.IMEC.LT.IBLOWN) THEN
                     SIGT(IKB) = SIGT(IKB) + VALUE(IKB)
                  ELSE IF (MECA(1:3).EQ.'HAD') THEN
                     IF ((MECA.EQ.'HADG'.AND.IHADR.LE.2).OR. (MECA.EQ.
     +               'HADF'.AND.IHADR.EQ.4)) THEN
                        SIGT(IKB) = SIGT(IKB) + VALUE(IKB)
                     ENDIF
                  ENDIF
               ENDIF
   50       CONTINUE
            CALL HIDOPT(ID,'LOGY')
            IF(IDM.GE.0) CALL HPHIST(ID,' ',0)
            IF(IDM.EQ.0) CALL HDELET(ID)
         ENDIF
   60 CONTINUE
*
* *** plot total cross section and mean free path
      IF (MECAN.EQ.'ALL') THEN
         CHTITL= NAPART//' in '//NAMATE//'   total cross section'
         IF(LXBARN) THEN
            CHTITL(LNBLNK(CHTITL)+1:) = ' (barn)'
         ELSE
            CHTITL(LNBLNK(CHTITL)+1:) = ' (1/cm)'
         ENDIF
         ID = 10000*IMATE + 100*IPART + NMECA+1
         CALL HBOOKB(ID,CHTITL,KDIM-1,TKIN,0.)
*
         CHTITL= NAPART//' in '//NAMATE//'   total mean free path (cm)'
         II = ID + 1
         CALL HBOOKB(II,CHTITL,KDIM-1,TKIN,0.)
*
         VALMI = MAX (BIGINV,VMAX( SIGT,KDIM)*1.E-8)
         DO 70  IKB = 1,KDIM
            IF (SIGT(IKB).GE.VALMI) THEN
               CALL HFILL(ID,TKIN(IKB),0.,       SIGT(IKB))
               CALL HFILL(II,TKIN(IKB),0.,CMIBAR/SIGT(IKB))
            ENDIF
   70    CONTINUE
         CALL HIDOPT(ID,'LOGY')
         IF(IDM.GE.0) CALL HPHIST(ID,' ',0)
         IF(IDM.EQ.0) CALL HDELET(ID)
*
         CALL HIDOPT(II,'LOGY')
         IF(IDM.GE.0) CALL HPHIST(II,' ',0)
         IF(IDM.EQ.0) CALL HDELET(II)
      ENDIF
*
      GO TO 999
*
   80 WRITE(CHMAIL,10000) IMATE ,IPART
      CALL GMAIL(0,0)
10000 FORMAT(' ***** GPLMAT error : material',I4,
     +       '  or particle',I4,' not defined'   )
10100 FORMAT(6X,'BCUTE =',F6.2,A4,3X,'BCUTM =',F6.2,A4,3X,
     +             'DCUTE =',F6.2,A4,3X,'DCUTM =',F6.2,A4,3X,
     +            'PPCUTM =',F6.2,A4 )
10200 FORMAT(1X,5('   bin ',I3,' =',F7.2,A4))
  999 END
+DECK,  GPMATE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:15  cernlib
* Geant

      SUBROUTINE GPMATE (NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print material data structures JMATE          *
C.    *       NUMB     Material number                                 *
C.    *                                                                *
C.    *      Changed by S.Egli at 8.5.90: also show mixture contents   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER CHMIXT*17
C.
C.    ------------------------------------------------------------------
C.
      IF (JMATE.LE.0) GO TO 999
      IF (NUMB .EQ.0) THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NMATE
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
      IF(NUMB.GE.0) THEN
         WRITE (CHMAIL,10100)
         CALL GMAIL(0,1)
      ENDIF
C
      DO 20 I=N1,N2
         JMA = LQ(JMATE-I)
         IF (JMA.LE.0) GO TO 20
C
         NMIXT=Q(JMA+11)
         CHMIXT=' '
         IF(NMIXT.GT.1) CHMIXT='   A      Z     W'
         WRITE (CHMAIL,10200) I,(Q(JMA + J),J = 1,10),NMIXT,CHMIXT
         CALL GMAIL(0,0)
         IF(NMIXT.GT.1)THEN
            JMX=LQ(JMA-5)
            DO 10 J=1,NMIXT
               WRITE(CHMAIL,10300)Q(JMX+J),Q(JMX+NMIXT+J),
     +         Q(JMX+2*NMIXT+J)
               CALL GMAIL(0,0)
   10       CONTINUE
         ENDIF
   20 CONTINUE
C
10000 FORMAT ('0',51('='),5X,'MATERIALS',6X,50('='))
10100 FORMAT ('0','MATERIAL',27X,'A',9X,'Z',5X,'DENSITY'
     +,2X,'RADIAT L',2X,'ABSORP L',' NMIXT')
10200 FORMAT (' ',I8,1X,5A4,3F10.3,2E10.3,I4,2X,A17)
10300 FORMAT (' ',85X,2F7.2,F7.3)
  999 END
+DECK,  GPMATX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:15  cernlib
* Geant

      SUBROUTINE GPMATX (NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print material data structures JMATE          *
C.    *       NUMB     Material number                                 *
C.    *                                                                *
C.    *      Changed by S.Egli at 8.5.90: also show mixture contents   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  S.Giani *****                          *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER CHMIXT*17
      CHARACTER NAME*20
      CHARACTER*32 CHLINE,CHSTRI(50)
C.
C.    ------------------------------------------------------------------
C.
      IF (JMATE.LE.0) GO TO 999
      IF (NUMB .EQ.0) THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NMATE
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
*      IF(NUMB.GE.0) THEN
*         WRITE (CHMAIL,10100)
*         CALL GMAIL(0,1)
*      ENDIF
C
      DO 20 I=N1,N2
         JMA = LQ(JMATE-I)
         IF (JMA.LE.0) GO TO 20
C
         NMIXT=Q(JMA+11)
         CHMIXT=' '
*         IF(NMIXT.GT.1) CHMIXT='   A      Z     W'
*         WRITE (CHMAIL,10200) I,(Q(JMA + J),J = 1,10),NMIXT,CHMIXT
*         CALL GMAIL(0,0)

         CHLINE='Material Number='
         ILEN=LENOCC(CHLINE)+1
         CALL IZITOC(I,CHLINE(ILEN:))
         CHSTRI(1)=CHLINE
         CALL UHTOC(IQ(JMA+1),4,NAME,20)
         CHLINE='Name='
         ILEN=LENOCC(CHLINE)+1
         CHLINE(ILEN:)=NAME
         CHSTRI(2)=CHLINE
         CHLINE='A='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+6),CHLINE(ILEN:))
         CHSTRI(3)=CHLINE
         CHLINE='Z='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+7),CHLINE(ILEN:))
         CHSTRI(4)=CHLINE
         CHLINE='Dens='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+8),CHLINE(ILEN:))
         CHSTRI(5)=CHLINE
         CHLINE='RadLeng='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JMA+9),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10300)Q(JMA+9)
         CHSTRI(6)=CHLINE
         CHLINE='AbsLeng='
         ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JMA+10),CHLINE(ILEN:))
         WRITE(CHLINE(ILEN:),10300)Q(JMA+10)
         CHSTRI(7)=CHLINE
         CHLINE='Nmixt='
         ILEN=LENOCC(CHLINE)+1
         CALL IZRTOC(Q(JMA+11),CHLINE(ILEN:))
         CHSTRI(8)=CHLINE

         JJJ=8
         IF(NMIXT.GT.1)THEN
            JMX=LQ(JMA-5)
            DO 10 JJ=1,NMIXT
               CHLINE='A('
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(JJ,CHLINE(ILEN:))
               ILEN=LENOCC(CHLINE)+1
               CHLINE(ILEN:)=')='
               ILEN=LENOCC(CHLINE)+1
               CALL IZRTOC(Q(JMX+JJ),CHLINE(ILEN:))
               JJJ=JJJ+1
               CHSTRI(JJJ)=CHLINE
               CHLINE='Z('
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(JJ,CHLINE(ILEN:))
               ILEN=LENOCC(CHLINE)+1
               CHLINE(ILEN:)=')='
               ILEN=LENOCC(CHLINE)+1
               CALL IZRTOC(Q(JMX+NMIXT+JJ),CHLINE(ILEN:))
               JJJ=JJJ+1
               CHSTRI(JJJ)=CHLINE
               CHLINE='W('
               ILEN=LENOCC(CHLINE)+1
               CALL IZITOC(JJ,CHLINE(ILEN:))
               ILEN=LENOCC(CHLINE)+1
               CHLINE(ILEN:)=')='
               ILEN=LENOCC(CHLINE)+1
               CALL IZRTOC(Q(JMX+2*NMIXT+JJ),CHLINE(ILEN:))
               JJJ=JJJ+1
               CHSTRI(JJJ)=CHLINE
   10       CONTINUE
*            DO 10 J=1,NMIXT
*               WRITE(CHMAIL,10300)Q(JMX+J),Q(JMX+NMIXT+J),
*     +         Q(JMX+2*NMIXT+J)
*               CALL GMAIL(0,0)
*   10       CONTINUE
         ENDIF
         CALL IGMESS(JJJ,CHSTRI,'PRINT','P')
   20 CONTINUE
C
10000 FORMAT ('0',51('='),5X,'MATERIALS',6X,50('='))
10100 FORMAT ('0','MATERIAL',27X,'A',9X,'Z',5X,'DENSITY'
     +,2X,'RADIAT L',2X,'ABSORP L',' NMIXT')
10200 FORMAT (' ',I8,1X,5A4,3F10.3,2E10.3,I4,2X,A17)
10300 FORMAT (E12.5)
10400 FORMAT (' ',85X,2F7.2,F7.3)
  999 END
+DECK,  GPPART, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GPPART (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print particle definition JPART               *
C.    *       NUMB     Particle number                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JPART.LE.0)  GO TO 99
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,1000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = IQ(JPART-2)
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
C
      IF(NUMB.GE.0) THEN
         WRITE (CHMAIL,1001)
         CALL GMAIL(0,1)
      ENDIF
C
      DO 10 I=N1,N2
         JP = LQ(JPART-I)
         IF (JP.NE.0)THEN
            IOPT = Q(JP+6)
            NL = IQ(JP-1)
            CALL UCOPY(IQ(JP+1),ITITLE,5)
            NW=MIN(NL,13)
            WRITE (CHMAIL,1002) I,ITITLE,IOPT,
     +                          (Q(JP + J),J = 7,NW)
    5       CALL GMAIL(0,0)
            IF(NL-NW.GT.0) THEN
               NS=NW+1
               NW=MIN(NL,NW+5)
               WRITE(CHMAIL,1003) (Q(JP + J),J = NS,NW)
               GO TO 5
            END IF
         ENDIF
   10 CONTINUE
C
 1000 FORMAT ('0',51('='),3X,'Particle Types',3X,50('='))
 1001 FORMAT ('0','Part',25X,'Options',8X,'Mass',4X,'Charge'
     +,'    Life time                  User words')
 1002 FORMAT (' ',I4,1X,5A4,I8,6X,E11.4,F7.0,3X,5(E12.5,2X))
 1003 FORMAT (61X,5(E12.5,2X))
  99  RETURN
      END
+DECK,  GPPARX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GPPARX (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print particle definition JPART               *
C.    *       NUMB     Particle number                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  S.Giani *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
      CHARACTER*32 CHLINE,CHSTRI(50)
      CHARACTER*20 NAME
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JPART.LE.0) GO TO 999
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = IQ(JPART-2)
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
C
*      IF(NUMB.GE.0) THEN
*         WRITE (CHMAIL,1001)
*         CALL GMAIL(0,1)
*      ENDIF
C
      DO 20 I=N1,N2
         JP = LQ(JPART-I)
         IF (JP.NE.0)THEN
            IOPT = Q(JP+6)
            NL = IQ(JP-1)
            CALL UCOPY(IQ(JP+1),ITITLE,5)
*            NW=MIN(NL,13)
*            NW=NL
            CHLINE='Particle Number='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(I,CHLINE(ILEN:))
            CHSTRI(1)=CHLINE
            CALL UHTOC(IQ(JP+1),4,NAME,20)
            CHLINE='Name='
            ILEN=LENOCC(CHLINE)+1
            CHLINE(ILEN:)=NAME
            CHSTRI(2)=CHLINE
            CHLINE='Iopt='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IOPT,CHLINE(ILEN:))
            CHSTRI(3)=CHLINE
            CHLINE='Mass='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JP+7),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10200)Q(JP+7)
            CHSTRI(4)=CHLINE
            CHLINE='Charge='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JP+8),CHLINE(ILEN:))
            CHSTRI(5)=CHLINE
            CHLINE='LifeTim='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JP+9),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10300)Q(JP+9)
            CHSTRI(6)=CHLINE
            DO 10 JJ=7,NL
               CHLINE='User='
               ILEN=LENOCC(CHLINE)+1
*       CALL IZRTOC(Q(JP+JJ),CHLINE(ILEN:))
               WRITE(CHLINE(ILEN:),10300)Q(JP+JJ)
               CHSTRI(JJ)=CHLINE
   10       CONTINUE
            CALL IGMESS(NL,CHSTRI,'PRINT','P')
*            WRITE (CHMAIL,1002) I,ITITLE,IOPT,
*     +                          (Q(JP + J),J = 7,NW)
*    5       CALL GMAIL(0,0)
*            IF(NL-NW.GT.0) THEN
*               NS=NW+1
*               NW=MIN(NL,NW+5)
*               WRITE(CHMAIL,1003) (Q(JP + J),J = NS,NW)
*               GO TO 5
*            END IF
         ENDIF
   20 CONTINUE
C
10000 FORMAT ('0',51('='),3X,'Particle Types',3X,50('='))
10100 FORMAT ('0','Part',25X,'Options',8X,'Mass',4X,'Charge'
     +,'    Life time                  User words')
* 1002 FORMAT (' ',I4,1X,5A4,I8,6X,E11.4,F7.0,3X,5(E12.5,2X))
10200 FORMAT (E11.4)
10300 FORMAT (E12.5)
  999 END
+DECK,  GPRMAT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GPRMAT(IMATE,IPART,MECAN,KDIN,TKIN)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       INTERPOLATE and PRINT the DE/DX ,stopping range and      *
C.    *       Cross sections tabulated in JMATE banks corresponding to *
C.    *       material IMATE, particle IPART, mecanism name MECAN ,    *
C.    *       kinetic energies TKIN.                                   *
C.    *                                                                *
C.    *      The MECAnism name can be :                                *
C.    *      'HADF'   'INEF'   'ELAF'   'FISF'   'CAPF'                *
C.    *      'HADG'   'INEG'   'ELAG'   'FISG'   'CAPG'                *
C.    *      'LOSS'   'PHOT'   'ANNI'   'COMP'   'BREM'                *
C.    *      'PAIR'   'DRAY'   'PFIS'   'RAYL'   'HADG'                *
C.    *      'MUNU'   'RANG'   'STEP'                                  *
C.    *                                                                *
C.    *       For Hadronic particles it also computes the              *
C.    *       hadronic cross section from FLUKA ( '***F' ) or          *
C.    *       GHEISHA ( '***G' ) programs:                             *
C.    *       HADF or HADG -- total                                    *
C.    *       INEF or INEG -- inelastic                                *
C.    *       ELAF or ELAG -- elastic                                  *
C.    *       FISF or FISG -- fission (0.0 for FLUKA)                  *
C.    *       CAPF or CAPG -- neutron capture (0.0 for FLUKA)          *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    *  IMATE   Geant material number                                 *
C.    *  IPART   Geant particle number                                 *
C.    *  MECAN   mechanism name of the bank to be fetched              *
C.    *  KDIM   dimension of the arrays TKIN , VALUE                   *
C.    *  TKIN   array of kinetic energy of incident particle (in Gev)  *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Authors    R.Brun, M.Maire    *********                  *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
      PARAMETER (MMX=100)
      CHARACTER*(*) MECAN
      CHARACTER*4  MECA
      CHARACTER*4  KU1 , KU2 , KU3 , KU(5)
      DIMENSION   TKIN(KDIN),VALUE(MMX),SIGT(MMX),PCUT(5),CU(5)
*
+CDE, GCNMEC.
*
*     ------------------------------------------------------------------
*
      KDIM = MIN(KDIN,MMX)
      IF (KDIM.LE.0) GO TO 999
*
      IF (JMATE.LE.0) GO TO 999
      IF (IMATE.LE.0) GO TO 999
      IF (IMATE.GT.NMATE) GO TO 90
      JMA = LQ(JMATE-IMATE)
      IF (JMA.LE.0) GO TO 90
*
      IF (JPART.LE.0) GO TO 999
      IF (IPART.LE.0) GO TO 999
      IF (IPART.GT.NPART) GO TO 90
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0) GO TO 90
*
      DO 10 JSIG=1,MMX
         SIGT(JSIG)=0.
   10 CONTINUE
      IF(MECAN.EQ.'ALL') THEN
         N1 = 1
         N2 = NMECA
      ELSE
         N1 = 0
         DO 20  IMECA=1,NMECA
            IF(MECAN.EQ.CHNMEC(IMECA)) THEN
               N1 = IMECA
            ENDIF
   20    CONTINUE
         IF(N1.EQ.0) THEN
            WRITE(CHMAIL,'('' *** GPRMAT: Mechanism '',A,
     +      '' not implemented'')') MECAN
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         N2 = N1
      ENDIF
      DO 60  IMEC = N1,N2
         IF(CHNMEC(IMEC).NE.'NULL') THEN
            MECA = CHNMEC(IMEC)
            CALL GFTMAT(IMATE,IPART,MECA,KDIM,TKIN,VALUE,PCUT,IXST)
            IF(IXST.EQ.0) GO TO 60
            CHMAIL='1'
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10100)(IQ(JMA+I),I=1,5),MECA,(IQ(JPA+J),J=1,5)
            CALL GMAIL(0,0)
            CHMAIL(31:)='-----------------------------------------'
            CALL GMAIL(0,1)
            CHMAIL=' '
            DO 30  K=1,5
   30       CALL GEVKEV(PCUT(K),CU(K),KU(K))
            WRITE(CHMAIL,10200) (CU(K),KU(K),K=1,5)
            CALL GMAIL(0,1)
*
            IF (MECA.EQ.'LOSS'.OR.MECA.EQ.'RANG'.OR.MECA.EQ.'STEP')
     +      THEN
               IF (MECA.EQ.'LOSS') WRITE(CHMAIL,10300)
               IF (MECA.EQ.'RANG') WRITE(CHMAIL,10400)
               IF (MECA.EQ.'STEP') WRITE(CHMAIL,10500)
               CALL GMAIL(0,1)
               NROW = (KDIM-1)/3 + 1
               DO 40  IKB=1,NROW
                  IK = IKB
                  DE1 = VALUE(IK)
                  CALL GEVKEV(TKIN(IK),EK1,KU1)
*
                  IK = IKB + NROW
                  IF (IK.GT.KDIM) IK=KDIM
                  DE2 = VALUE(IK)
                  CALL GEVKEV(TKIN(IK),EK2,KU2)
*
                  IK = IKB + 2*NROW
                  IF (IK.GT.KDIM) IK=KDIM
                  DE3 = VALUE(IK)
                  CALL GEVKEV(TKIN(IK),EK3,KU3)
*
                  WRITE(CHMAIL,10600) EK1,KU1,DE1,EK2,KU2,DE2,EK3,KU3,
     +            DE3
                  CALL GMAIL(0,0)
   40          CONTINUE
            ELSE
               WRITE(CHMAIL,10700)
               CALL GMAIL(0,1)
               NROW = (KDIM-1)/2 + 1
               DO 50  IKB=1,NROW
                  IK = IKB
                  SIG1 = VALUE(IK)
                  AL1=0.
                  IF(SIG1.NE.0.)AL1 = 1./SIG1
                  SIGT(IK) = SIGT(IK) + SIG1
                  CALL GEVKEV(TKIN(IK),EK1,KU1)
*
                  IK = IKB + NROW
                  IF (IK.GT.KDIM) IK=KDIM
                  SIG2 = VALUE(IK)
                  AL2=0.
                  IF(SIG2.NE.0.)AL2 = 1./SIG2
                  SIGT(IK) = SIGT(IK) + SIG2
                  CALL GEVKEV(TKIN(IK),EK2,KU2)
*
                  WRITE(CHMAIL,10900) EK1,KU1,SIG1,AL1,EK2,KU2,SIG2,AL2
                  CALL GMAIL(0,0)
   50          CONTINUE
            ENDIF
         ENDIF
   60 CONTINUE
*
* *** print total cross section
      IF (MECAN.EQ.'ALL') THEN
         MECA = 'SIGT'
         CHMAIL='1'
         CALL GMAIL(0,0)
         WRITE(CHMAIL,10100)(IQ(JMA+I),I=1,5),MECA,(IQ(JPA+J),J=1,5)
         CALL GMAIL(0,0)
         CHMAIL(31:)='-----------------------------------------'
         CALL GMAIL(0,1)
         CHMAIL=' '
         DO 70  K=1,5
   70    CALL GEVKEV(PCUT(K),CU(K),KU(K))
         WRITE(CHMAIL,10200) (CU(K),KU(K),K=1,5)
         CALL GMAIL(0,1)
         WRITE(CHMAIL,10800)
         CALL GMAIL(0,1)
         NROW = (KDIM-1)/2 + 1
         DO 80  IKB=1,NROW
            IK = IKB
            SIG1 = SIGT(IK)
            AL1=0.
            IF(SIG1.NE.0.)AL1 = 1./SIG1
            CALL GEVKEV(TKIN(IK),EK1,KU1)
*
            IK = IKB + NROW
            IF (IK.GT.KDIM) IK=KDIM
            SIG2 = SIGT(IK)
            AL2=0.
            IF(SIG2.NE.0.)AL2 = 1./SIG2
            CALL GEVKEV(TKIN(IK),EK2,KU2)
*
            WRITE(CHMAIL,10900) EK1,KU1,SIG1,AL1,EK2,KU2,SIG2,AL2
            CALL GMAIL(0,0)
   80    CONTINUE
      ENDIF
*
      GO TO 999
*
   90 WRITE(CHMAIL,10000) IMATE ,IPART
      CALL GMAIL(0,0)
*
10000 FORMAT(' ***** GPRMAT error : material',I4,
     +       '  or particle',I4,' not defined'   )
10100 FORMAT(30X,5A4,A4, ' for  ',5A4)
10200 FORMAT(  6X,'BCUTE =',F6.2,A4,3X,'BCUTM =',F6.2,A4,3X,
     +             'DCUTE =',F6.2,A4,3X,'DCUTM =',F6.2,A4,3X,
     +            'PPCUTM =',F6.2,A4 )
10300 FORMAT(  6X,'kinetic energy   DE/DX(mev/cm)',
     +         6X,'kinetic energy   DE/DX(mev/cm)',
     +         6X,'kinetic energy   DE/DX(mev/cm)')
10400 FORMAT(  6X,'kinetic energy   Stop range cm',
     +         6X,'kinetic energy   Stop ramge cm',
     +         6X,'kinetic energy   Stop range cm')
10500 FORMAT(  6X,'kinetic energy   Mulof step cm',
     +         6X,'kinetic energy   Mulof step cm',
     +         6X,'kinetic energy   Mulof step cm')
10600 FORMAT( 3(F16.2,A4,E15.4))
10700 FORMAT(  6X,'kinetic energy   Sigma (1/cm)    Lambda (cm)',
     +         6X,'kinetic energy   Sigma (1/cm)    Lambda (cm)')
10800 FORMAT(  6X,'kinetic energy   Sigto (1/cm)    Lambda (cm)',
     +         6X,'kinetic energy   Sigto (1/cm)    Lambda (cm)')
10900 FORMAT( 2(F16.2,A4,2(E15.4)))
  999 END
+DECK,  GPTMED, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GPTMED (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print tracking media data structure JTMED     *
C.    *       NUMB     medium number                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JTMED.LE.0)  GO TO 99
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,1000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NTMED
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
      IF(NUMB.GE.0) THEN
         WRITE (CHMAIL,1001)
         CALL GMAIL(0,1)
      ENDIF
C
      DO 10 I=N1,N2
         JTM = LQ(JTMED-I)
         IF (JTM.NE.0)THEN
            IMAT = Q(JTM+6)
            ISVOL = Q(JTM+7)
            IFIELD = Q(JTM+8)
            CALL UCOPY(IQ(JTM+1),ITITLE,5)
            WRITE(CHMAIL,1002)I,ITITLE,IMAT,ISVOL,IFIELD,
     +                        (Q(JTM+J),J=9,14)
            CALL GMAIL(0,0)
         ENDIF
   10 CONTINUE
C
 1000 FORMAT ('0',51('='),3X,'TRACKING MEDIA',3X,50('='))
 1001 FORMAT ('0','TMED',26X,'MATERIAL ','ISVOL',' IFIELD  FIELDM'
     +, '  TMAXFD','  STEMAX','    DEEMAX','   EPSIL','   STMIN')
 1002 FORMAT (' ',I6,1X,5A4,I8,I8,I6,4X,F6.2,2X,F6.2,G10.3,3F8.3)
  99  RETURN
      END
+DECK,  GPTMEX, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GPTMEX (NUMB  )
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print tracking media data structure JTMED     *
C.    *       NUMB     medium number                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPRINT                               *
C.    *       Author    R.Brun S.Giani  *********                      *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCNUM.
      CHARACTER*32 CHLINE,CHSTRI(50)
      CHARACTER*20 NAME
      DIMENSION ITITLE(5)
C.
C.    ------------------------------------------------------------------
C.
      IF (JTMED.LE.0) GO TO 999
C
      IF (NUMB  .EQ.0)THEN
         WRITE (CHMAIL,10000)
         CALL GMAIL(0,0)
         N1     = 1
         N2     = NTMED
      ELSE
         N1     = ABS(NUMB)
         N2     = ABS(NUMB)
      ENDIF
*      IF(NUMB.GE.0) THEN
*         WRITE (CHMAIL,1001)
*         CALL GMAIL(0,1)
*      ENDIF
C
      DO 10 I=N1,N2
         JTM = LQ(JTMED-I)
         IF (JTM.NE.0)THEN
            IMAT = Q(JTM+6)
            ISVOL = Q(JTM+7)
            IFIELD = Q(JTM+8)
            CALL UCOPY(IQ(JTM+1),ITITLE,5)
            CHLINE='T. Med. Number='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(I,CHLINE(ILEN:))
            CHSTRI(1)=CHLINE
            CALL UHTOC(IQ(JTM+1),4,NAME,20)
            CHLINE='Name='
            ILEN=LENOCC(CHLINE)+1
            CHLINE(ILEN:)=NAME
            CHSTRI(2)=CHLINE
            CHLINE='Material='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IMAT,CHLINE(ILEN:))
            CHSTRI(3)=CHLINE
            CHLINE='Isvol='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(ISVOL,CHLINE(ILEN:))
            CHSTRI(4)=CHLINE
            CHLINE='Ifield='
            ILEN=LENOCC(CHLINE)+1
            CALL IZITOC(IFIELD,CHLINE(ILEN:))
            CHSTRI(5)=CHLINE
            CHLINE='Fieldm='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+9),CHLINE(ILEN:))
            CHSTRI(6)=CHLINE
            CHLINE='Tmaxfd='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+10),CHLINE(ILEN:))
            CHSTRI(7)=CHLINE
            CHLINE='Stepmax='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JTM+11),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10200)Q(JTM+11)
            CHSTRI(8)=CHLINE
            CHLINE='Deemax='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+12),CHLINE(ILEN:))
            CHSTRI(9)=CHLINE
            CHLINE='Epsil='
            ILEN=LENOCC(CHLINE)+1
*      CALL IZRTOC(Q(JTM+13),CHLINE(ILEN:))
            WRITE(CHLINE(ILEN:),10200)Q(JTM+13)
            CHSTRI(10)=CHLINE
            CHLINE='Stmin='
            ILEN=LENOCC(CHLINE)+1
            CALL IZRTOC(Q(JTM+14),CHLINE(ILEN:))
            CHSTRI(11)=CHLINE
            CALL IGMESS(11,CHSTRI,'PRINT','P')

*            WRITE(CHMAIL,1002)I,ITITLE,IMAT,ISVOL,IFIELD,
*     +                        (Q(JTM+J),J=9,14)
*            CALL GMAIL(0,0)
         ENDIF
   10 CONTINUE
C
10000 FORMAT ('0',51('='),3X,'TRACKING MEDIA',3X,50('='))
10100 FORMAT ('0','TMED',26X,'MATERIAL ','ISVOL',' IFIELD  FIELDM'
     +, '  TMAXFD','  STEMAX','    DEEMAX','   EPSIL','   STMIN')
10200 FORMAT (E12.5)
  999 END
+DECK,  GSCKOV, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GSCKOV(ITMED, NPCKOV, PPCKOV, ABSCO, EFFIC, RINDEX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Stores the tables for UV photon tracking in medium ITMED    *
C.    *    Please note that it is the user's responsability to         *
C.    *    provide all the coefficients:                               *
C.    *                                                                *
C.    *                                                                *
C.    *       ITMED       Tracking medium number                       *
C.    *       NPCKOV      Number of bins of each table                 *
C.    *       PPCKOV      Value of photon momentum (in GeV)            *
C.    *       ABSCO       Absorbtion coefficents                       *
C.    *                   dielectric: absorbtion length in cm          *
C.    *                   metals    : absorbtion fraction (0<=x<=1)    *
C.    *       EFFIC       Detection efficiency for UV photons          *
C.    *       RINDEX      Refraction index (if=0 metal)                *
C.    *                                                                *
C.    *       Called by : <USER>                                       *
C.    *                                                                *
C.    *       Authors: F.Carminati, R.Jones  ************              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCMZFO.
+CDE, GCUNIT.
+CDE, GCJLOC.
      DIMENSION PPCKOV(*), ABSCO(*), EFFIC(*), RINDEX(*)
C.
C.    ------------------------------------------------------------------
C.
      JTM = 0
      IF(ITMED.GT.0) THEN
         IF(JTMED.GT.0) THEN
            IF(IQ(JTMED-2).GE.ITMED) THEN
               JTM = LQ(JTMED-ITMED)
            ENDIF
         ENDIF
      ENDIF
      IF(JTM.LE.0) THEN
         WRITE(CHMAIL,10000)
10000   FORMAT(' **** GSCKOV Tracking medium ',I10,' not defined')
         CALL GMAIL(0,0)
         GO TO 999
      ENDIF
      IF(IQ(JTM-2).LT.3) THEN
         CALL MZPUSH(IXSTOR,JTM,3-IQ(JTM-2),0,' ')
      ENDIF
      CALL MZBOOK(IXCONS,JTCKOV,JTM,-3,'CKOV',4,4,NPCKOV+1,3,-1)
      CALL MZBOOK(IXCONS,JABSCO,JTCKOV,-1,'ABSC',0,0,NPCKOV,3,-1)
      CALL MZBOOK(IXCONS,JEFFIC,JTCKOV,-2,'EFFI',0,0,NPCKOV,3,-1)
      IF(RINDEX(1).GE.1.) THEN
         CALL MZBOOK(IXCONS,JINDEX,JTCKOV,-3,'RIND',0,0,NPCKOV,3,-1)
         CALL MZBOOK(IXCONS,JCURIN,JTCKOV,-4,'ABCU',0,0,NPCKOV,3,-1)
      ENDIF
      Q(JTCKOV+1)=NPCKOV
      DO 10 J=1, NPCKOV
         Q(JTCKOV+1+J) = PPCKOV(J)
         Q(JABSCO+  J) = MAX(1E-10,ABSCO(J))
         Q(JEFFIC+  J) = EFFIC(J)
         IF(RINDEX(1).GE.1.) THEN
            Q(JINDEX+ J) = RINDEX(J)
            IF(J.GT.1) THEN
               Q(JCURIN+J)=0.5*((1/RINDEX(J-1)**2)+(1./RINDEX(J)**2))
               Q(JCURIN+J)=Q(JCURIN+J-1)+(PPCKOV(J)-PPCKOV(J-1))*
     +                     Q(JCURIN+J)
            ELSE
               Q(JCURIN+J)=0.
            ENDIF
         ENDIF
   10 CONTINUE
*
  999 END
+DECK,  GSDK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GSDK(IPART,BRATIO,MODE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Defines branching ratios and decay modes for standard         *
C.    *  GEANT particles.                                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPART                                *
C.    *       Author    G.Patrick  *********                           *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCNUM.
+CDE, GCUNIT.
      DIMENSION BRATIO(6)
      DIMENSION MODE(6)
C.
C.    ------------------------------------------------------------------
C.
      IF (IPART.LE.0)                              GO TO 99
      IF (IPART.GT.NPART)                          GO TO 99
C
C     Particle pointer.
C
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0)                                GO TO 99
C
C     Book decay links and data banks.
C
      JDK1=LQ(JPA-1)
      JDK2=LQ(JPA-2)
      IF(JDK1+JDK2.NE.0) THEN
         WRITE(CHMAIL, 10000)
         CALL GMAIL(1,0)
         CALL GPPART(IPART)
         CALL MZDROP(IXCONS,LQ(JPA-1),' ')
         CALL MZDROP(IXCONS,LQ(JPA-2),' ')
      ENDIF
      CALL MZBOOK(IXCONS,JDK1,JPA,-1,'PABR',0,0,6,3,0)
      JPA=LQ(JPART-IPART)
      CALL MZBOOK(IXCONS,JDK2,JPA,-2,'PAMO',0,0,6,2,0)
      JPA=LQ(JPART-IPART)
      JDK1=LQ(JPA-1)
      IQ(JDK1-5)=IPART
      IQ(JDK2-5)=IPART
C
C     Store branching ratios & decay modes.
C
      DO 20 I=1,6
         Q(JDK1+I) = BRATIO(I)
         IQ(JDK2+I) = MODE(I)
   20 CONTINUE
C
  99  RETURN
10000 FORMAT(' *** GSDK ***: Warning, redefinition of decay ',
     +       'for particle:')
      END
+DECK,  GSMATE, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:16  cernlib
* Geant

      SUBROUTINE GSMATE(IMAT,NAMATE,A,Z,DENS,RADL,ABSL,UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *       Store material parameters                                *
C.    *                                                                *
C.    *                                                                *
C.    *             The Material data structure JMATE                  *
C.    *             ---------------------------------                  *
C.    *                                                                *
C.    *                                         | JMATE                *
C.    *    NMATE           IMATE                v                      *
C.    *     ......................................                     *
C.    *     |              | |                 | |                     *
C.    *     ......................................                     *
C.    *                     |                                          *
C.    *                     | JMA                                      *
C.    *                     v                                          *
C.    *                    .....................                       *
C.    *                    | 1 |               |                       *
C.    *                    .....               |                       *
C.    *                    | 2 |  Material     |                       *
C.    *                    |...|               |                       *
C.    *                    | 3 |   Name        |                       *
C.    *                    |...|               |                       *
C.    *                    | 4 |               |                       *
C.    *                    |...|               |                       *
C.    *                    | 5 |               |                       *
C.    *                    .....................                       *
C.    *                    | 6 |   A           |                       *
C.    *                    |...|...............|                       *
C.    *                    | 7 |   Z           |                       *
C.    *                    |...|...............|                       *
C.    *                    | 8 |   Density     |                       *
C.    *                    |...|...............|                       *
C.    *                    | 9 |   RADL        |                       *
C.    *                    |...|...............|                       *
C.    *                    | 10|   ABSL        |                       *
C.    *                    |...|...............|                       *
C.    *                    | 11|   NMIXT       |                       *
C.    *                    |...|...............|                       *
C.    *                    |   |               |                       *
C.    *                    .....................                       *
C.    *                                                                *
C.    * JMA = LQ(JMATE-IMATE) pointer to material IMATE                *
C.    *                                                                *
C.    *   When  the subroutine  GPHYSI is  called at  initialisation   *
C.    * time  the following  banks  are  created for  each  material   *
C.    * (tabulation of energy loss and cross-section).                 *
C.    *                                               | JMATE          *
C.    * NMATE                     IMATE               v                *
C.    * ................................................               *
C.    * |                        | |                 | |               *
C.    * ................................................               *
C.    *                           | JMA = LQ(JMATE-IMATE)              *
C.    *                           v                              11    *
C.    * ............................................................   *
C.    * |  13 12 11 10 9 8 7 6 5 4 3 2 1 | |  Material parameters  |   *
C.    * ............................................................   *
C.    *    |  |  |  |  | | | | | | | | |                               *
C.    *    |  |  |  |  | | | | | | | | v  JMAEL = LQ(JMA-1)            *
C.    *    |  |  |  |  | | | | | | | |                         270     *
C.    *    |  |  |  |  | | | | | | | |................................ *
C.    *    |  |  |  |  | | | | | | | ||Energy loss for electron/positro*
C.    *    |  |  |  |  | | | | | | | |............................     *
C.    *    |  |  |  |  | | | | | | | v  JMAMU = LQ(JMA-2)       90     *
C.    *    |  |  |  |  | | | | | | |..............................     *
C.    *    |  |  |  |  | | | | | | ||Energy loss for muons       |     *
C.    *    |  |  |  |  | | | | | | |..............................     *
C.    *    |  |  |  |  | | | | | | v  JMAAL = LQ(JMA-3)         90     *
C.    *    |  |  |  |  | | | | | |................................     *
C.    *    |  |  |  |  | | | | | ||Energy loss for other particles|    *
C.    *    |  |  |  |  | | | | | |................................     *
C.    *    |  |  |  |  | | | | | v  JPROB = LQ(JMA-4)           30     *
C.    *    |  |  |  |  | | | | |..................................     *
C.    *    |  |  |  |  | | | | ||Some material constants         |     *
C.    *    |  |  |  |  | | | | |..................................     *
C.    *    |  |  |  |  | | | | v  JMIXT = LQ(JMA-5)             11     *
C.    *    |  |  |  |  | | | |....................................     *
C.    *    |  |  |  |  | | | ||Mixture or compound parameters    |     *
C.    *    |  |  |  |  | | | |....................................     *
C.    *    |  |  |  |  | | | v  JPHOT = LQ(JMA-6) and JMUNU     90     *
C.    *    |  |  |  |  | | |......................................     *
C.    *    |  |  |  |  | | ||Photo-effect cross-section          |     *
C.    *    |  |  |  |  | | |......................................     *
C.    *    |  |  |  |  | | v  JANNI = LQ(JMA-7)                 90     *
C.    *    |  |  |  |  | |........................................     *
C.    *    |  |  |  |  | ||Positron annihilation cross-section   |     *
C.    *    |  |  |  |  | |........................................     *
C.    *    |  |  |  |  | V  JCOMP = LQ(JMA-8)                   90     *
C.    *    |  |  |  |  |..........................................     *
C.    *    |  |  |  |  ||Compton scattering cross-section        |     *
C.    *    |  |  |  |  |..........................................     *
C.    *    |  |  |  |  V  JBREM = LQ(JMA-9)                     90     *
C.    *    |  |  |  | ............................................     *
C.    *    |  |  |  | |Bremsstrahlung cross-section              |     *
C.    *    |  |  |  | ............................................     *
C.    *    |  |  |  V  JPAIR = LQ(JMA-10)                       90     *
C.    *    |  |  | ...............................................     *
C.    *    |  |  | |Pair production cross-section                |     *
C.    *    |  |  | ...............................................     *
C.    *    |  |  V  JDRAY = LQ(JMA-11)                         210     *
C.    *    |  | ..................................................     *
C.    *    |  | |Moller and Bhabha cross-sections                |     *
C.    *    |  | ..................................................     *
C.    *    |  V  JPFIS = LQ(JMA-12)                             90     *
C.    *    | .....................................................     *
C.    *    | |Photo fission cross section                        |     *
C.    *    | .....................................................     *
C.    *    V  JRAYL = LQ(JMA-13)                                62     *
C.    *   ........................................................     *
C.    *   |Rayleigh scattering cross section and atomic form fact|     *
C.    *   ........................................................     *
C.    * V  JMUNU = LQ(JMA-14)                                  90      *
C.    *   ........................................................     *
C.    * V  JRANG = LQ(JMA-15)                                 180      *
C.    * V........................................................      *
C.    *  |Stopping range for electrons/positrons                |      *
C.    *  ........................................................      *
C.    * V  JRANG = LQ(JMA-16)                                 180      *
C.    * V........................................................      *
C.    *  |Stopping range for muons / other particles            |      *
C.    *  ........................................................      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM    ,<GXINT> GINC3              *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCMZFO.
+CDE, GCUNIT.
      DIMENSION UBUF(1)
      CHARACTER*(*) NAMATE
      CHARACTER*20 NAME
C.
C.    ------------------------------------------------------------------
C.
      IF(IMAT.LE.0)GO TO 99
      IF(JMATE.LE.0)THEN
         CALL MZBOOK(IXCONS,JMATE,JMATE,1,'MATE',NMATE,NMATE,0,3,0)
         IQ(JMATE-5)=0
      ENDIF
      IF(IMAT.GT.NMATE)THEN
         CALL MZPUSH(IXCONS,JMATE,IMAT-NMATE,0,'I')
         NMATE=IMAT
         JMA1=0
      ELSE
         JMA1=LQ(JMATE-IMAT)
         IF(JMA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPMATE(IMAT)
            CALL MZDROP(IXCONS,LQ(JMATE-IMAT),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JMA,JMATE,-IMAT,'MATE',20,20,NWBUF+11,IOMATE,0)
C
      NAME=NAMATE
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JMA+1),4,20)
C
      Q(JMA + 6) = A
      Q(JMA + 7) = Z
      Q(JMA + 8) = DENS
      Q(JMA + 9) = RADL
      Q(JMA + 10) = ABSL
      Q(JMA + 11) = 1.
      IF(NWBUF.GT.0)CALL UCOPY(UBUF,Q(JMA+12),NWBUF)
C
      IF(JMA1.GT.0) THEN
         CALL GPMATE(-IMAT)
      ENDIF
C
10000 FORMAT(' *** GSMATE ***: Warning, material redefinition:')
  99  END

+DECK,  GSMIXT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:17  cernlib
* Geant

      SUBROUTINE GSMIXT(IMAT,NAMATE,A,Z,DENS,NLMAT,WMAT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines mixture OR COMPOUND IMAT as composed by          *
C.    *       THE BASIC NLMAT materials defined by arrays A,Z and WMAT *
C.    *                                                                *
C.    *       If NLMAT.GT.0 then WMAT contains the PROPORTION BY       *
C.    *       WEIGTHS OF EACH BASIC MATERIAL IN THE MIXTURE.           *
C.    *                                                                *
C.    *       If NLMAT.LT.0 then WMAT contains the number of atoms     *
C.    *       of a given kind into the molecule of the COMPOUND        *
C.    *       In this case, WMAT in output is changed to relative      *
C.    *       weigths.                                                 *
C.    *                                                                *
C.    *       nb : the radiation length is computed according          *
C.    *            the EGS manual slac-210 uc-32 June-78               *
C.    *                           formula  2-6-8 (37)                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCMZFO.
      DIMENSION WMAT(1),A(1),Z(1)
      CHARACTER*(*) NAMATE
      CHARACTER*20 NAME
      DATA ALR2AV , AL183 / 1.39621E-03  ,  5.20948 /
C.
C.    ------------------------------------------------------------------
C.
      IF (IMAT.LE.0)GO TO 99
      IF(JMATE.LE.0)THEN
         CALL MZBOOK(IXCONS,JMATE,JMATE,1,'MATE',NMATE,NMATE,0,3,0)
         IQ(JMATE-5)=0
      ENDIF
      IF(IMAT.GT.NMATE)THEN
         CALL MZPUSH(IXCONS,JMATE,IMAT-NMATE,0,'I')
         NMATE=IMAT
         JMA1=0
      ELSE
         JMA1=LQ(JMATE-IMAT)
         IF(JMA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPMATE(IMAT)
            CALL MZDROP(IXCONS,LQ(JMATE-IMAT),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JMA,JMATE,-IMAT,'MATE',20,20,11,IOMATE,0)
C
      NAME=NAMATE
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JMA+1),4,20)
C
C             Store mixture parameters
C             and parameter for Pair/Brems and
C             Photoelectric routines
C
      NLM    = IABS(NLMAT)
      IF (NLM.LE.0)GO TO 90
      CALL MZBOOK(IXCONS,JMIXT,JMA,-5,'MAMI',2,2,4*NLM,3,0)
      CALL MZBOOK(IXCONS,JMI1,JMIXT,-1,'MAM1',0,0,10,3,0)
      JMA = LQ(JMATE- IMAT)
      IQ(JMIXT-5)=IMAT
      IQ(JMI1-5)=IMAT
C
C             Compute proportion by weigths in the compound
C
      IF(NLMAT.LT.0) THEN
         AMOL   = 0.
         ZMOL   = 0.
         DO 10 I= 1,NLM
         AMOL   = AMOL + WMAT(I)*A(I)
         ZMOL   = ZMOL + WMAT(I)*Z(I)
   10    CONTINUE
         DO 20 I= 1,NLM
         WMAT(I)= WMAT(I)*A(I) / AMOL
   20    CONTINUE
      ENDIF
C
C             Compute effective mixture parameters
C
      AEFF   = 0.
      ZEFF   = 0.
      RADINV = 0.
      DO 40 I = 1,NLM
         AEFF   = AEFF + WMAT(I)*A(I)
         ZEFF   = ZEFF + WMAT(I)*Z(I)
         ZC     = Z(I)
         ALZ    = LOG(ZC)/3.
         XINV   = ZC*(ZC+GXSI(ZC))*(AL183-ALZ-GFCOUL(ZC))/A(I)
         RADINV = RADINV + WMAT(I)*XINV
         Q(JMIXT+3*NLM+I)=XINV
         Q(JMIXT + 2* NLM + I) = WMAT(I)
         Q(JMIXT + NLM + I) = Z(I)
         Q(JMIXT + I) = A(I)
   40 CONTINUE
      RADINV = ALR2AV * DENS * RADINV
      RADEFF = 1. / RADINV
      CALL GHMIX(A,WMAT,NLM,AHEFF)
      ABSEFF=10000.*AHEFF/(6.022*DENS*GHSIGM(5.,8,AHEFF))
C
      Q(JMA + 6) = AEFF
      Q(JMA + 7) = ZEFF
      Q(JMA + 8) = DENS
      Q(JMA + 9) = RADEFF
      Q(JMA + 10) = ABSEFF
      Q(JMA + 11) = NLM
      Q(JMI1 + 1) = AHEFF
      IF(NLMAT.GT.0)THEN
         Q(JMI1 + 2) = AEFF
         Q(JMI1 + 3) = ZEFF
      ELSE
         Q(JMI1 + 2) = AMOL
         Q(JMI1 + 3) = ZMOL
      ENDIF
C
      IF(JMA1.GT.0) THEN
         CALL GPMATE(-IMAT)
      ENDIF
C
      GO TO 99
C
  90  CHMAIL=' ***** GSMIXT ERROR. MIXTURE WITH NO COMPONENTS'
      CALL GMAIL(0,0)
C
  99  RETURN
10000 FORMAT(' *** GSMIXT ***: Warning, material redefinition:')
      END
+DECK,  GSPART, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:17  cernlib
* Geant

      SUBROUTINE GSPART(IPART,NAPART,ITRTYP,AMASS,CHARGE,TLIFE,
     +            UBUF,NWBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store particle parameters                                *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GPART                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCMZFO.
+CDE, GCUNIT.
      DIMENSION UBUF(1)
      CHARACTER*(*) NAPART
      CHARACTER*20 NAME
C.
C.    ------------------------------------------------------------------
C.
      IF(IPART.LE.0)GO TO 99
      IF(JPART.LE.0)THEN
         CALL MZBOOK(IXCONS,JPART,JPART,1,'PART',NPART,NPART,0,3,0)
         IQ(JPART-5)=0
      ENDIF
      IF(IPART.GT.NPART)THEN
         CALL MZPUSH(IXCONS,JPART,IPART-NPART,0,'I')
         NPART=IPART
         JPA1=0
      ELSE
         JPA1=LQ(JPART-IPART)
         IF(JPA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPPART(IPART)
            CALL MZDROP(IXCONS,LQ(JPART-IPART),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JPA,JPART,-IPART,'PART',2,2,NWBUF+9,IOPART,0)
C
      NAME=NAPART
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JPA+1),4,20)
C
      Q(JPA + 6) = ITRTYP
      Q(JPA + 7) = AMASS
      Q(JPA + 8) = CHARGE
      Q(JPA + 9) = TLIFE
      IF(NWBUF.GT.0)CALL UCOPY(UBUF,Q(JPA+10),NWBUF)
C
      IF(JPA1.GT.0) THEN
         CALL GPPART(-IPART)
      ENDIF
C
  99  RETURN
10000 FORMAT(' *** GSPART ***: Warning, particle redefinition:')
      END
+DECK,  GSTMED, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:17  cernlib
* Geant

      SUBROUTINE GSTMED(KTMED,NATMED,NMAT,ISVOL,IFIELD,FIELDM,TMAXFD,
     +        STEMAX,DEEMAX,EPSIL,STMIN,UBUF,NWBUF)
*
***********************************************************************
*                                                                     *
*                                                                     *
*       Store tracking media parameters                               *
*                                                                     *
*    Stores the  parameters of the tracking  medium ITMED in  the data*
*  structure JTMED.                                                   *
*  ITMED     tracking medium number 0<ITMED<100                       *
*  NATMED    tracking medium name (up to 20 characters ended by $)    *
*  NMAT      material number corresponding to ITMED                   *
*  ISVOL     =0 if not a sensitive volume                             *
*  IFIELD    = 0  if no magnetic field                                *
*            = -1  reserved for user decision in GUSWIM               *
*            = 1  tracking performed with GRKUTA                      *
*            = 2  tracking performed with GHELIX                      *
*            = 3  tracking performed with GHELX3                      *
*  FIELDM    maximum field value (in Kilogauss)                       *
*  TMAXFD    maximum  angle due  to field  permitted in  one step  (in*
*            degrees)                                                 *
*  STEMAX    Maximum step allowed                                     *
*            (in cm)                                                  *
*  DEEMAX    maximum fractional energy loss in one step               *
*  EPSIL     tracking precision (in cm)                               *
*  STMIN     minimum step  due to energy  loss or  multiple scattering*
*            (in cm)                                                  *
*  UBUF      array of NWBUF additional parameters                     *
*  NWBUF                                                              *
*                                                                     *
*                                                                     *
*          The Tracking Medium data structure JTMED                   *
*          ----------------------------------------                   *
*                                                                     *
*                                         | JTMED                     *
*    NTMED           ITMED                v                           *
*     ..........................................................      *
*     |               | |                | | Standard Trac.media      *
*     ..........................................................      *
*                      | JT                                           *
*                      v                                              *
*                    ..........................                       *
*                    | 1 |                    |                       *
*                    .....                    |                       *
*                    | 2 |  Tracking medium   |                       *
*                    |...|                    |                       *
*                    | 3 |   Name             |                       *
*                    |...|                    |                       *
*                    | 4 |                    |                       *
*                    |...|                    |                       *
*                    | 5 |                    |                       *
*                    ..........................                       *
*                    | 6 |   NMAT             |                       *
*                    |...|....................|                       *
*                    | 7 |   ISVOL            |                       *
*                    |...|....................|                       *
*                    | 8 |   IFIELD           |                       *
*                    |...|....................|                       *
*                    | 9 |   FIELDM           |                       *
*                    |...|....................|                       *
*                    | 10|   TMAXFD           |                       *
*                    |...|....................|                       *
*                    | 11|   STEMAX           |                       *
*                    |...|....................|                       *
*                    | 12|   DEEMAX           |                       *
*                    |...|....................|                       *
*                    | 13|   EPSIL            |                       *
*                    |...|....................|                       *
*                    | 14|   STMIN            |                       *
*                    |...|....................|                       *
*                    | 15|   User words ....  |                       *
*                    ..........................                       *
*   JT = LQ(JTMED-ITMED) pointer to tracking medium ITMED             *
*                                                                     *
*    ==>Called by : <USER>, UGEOM    ,<GXINT> GINC3                   *
*       Author    R.Brun  *********                                   *
*                                                                     *
***********************************************************************
*
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCPHYS.
+CDE, GCONSP.
+CDE, GCUNIT.
+CDE, GCNUM.
+CDE, GCMZFO.
+CDE, GCTRAK.
      DIMENSION MECA(5,13)
      EQUIVALENCE (MECA(1,1),IPAIR)
      DIMENSION UBUF(1),CUTVEC(10)
      EQUIVALENCE (CUTVEC,CUTGAM)
      CHARACTER*(*) NATMED
      CHARACTER*20 NAME
C.
C.    ------------------------------------------------------------------
C.
      ITMED=ABS(KTMED)
      IF(JTMED.LE.0)THEN
         CALL MZBOOK(IXCONS,JTMED,JTMED,1,'TMED',NTMED,NTMED,40,3,0)
         CALL UCOPY(CUTVEC,Q(JTMED+1),10)
         IQ(JTMED-5)=0
         DO 10 I=1,13
            Q(JTMED+10+I)=MECA(1,I)
   10    CONTINUE
         Q(JTMED+10+21)=ILABS
         Q(JTMED+10+22)=ISYNC
         Q(JTMED+10+23)=ISTRA
      ENDIF
      IF(ITMED.GT.NTMED)THEN
         CALL MZPUSH(IXCONS,JTMED,ITMED-NTMED,0,'I')
         NTMED=ITMED
         JTM1=0
      ELSE
         JTM1=LQ(JTMED-ITMED)
         IF(JTM1.GT.0) THEN
            WRITE(CHMAIL,10100)
            CALL GMAIL(1,0)
            CALL GPTMED(ITMED)
            CALL MZDROP(IXCONS,LQ(JTMED-ITMED),' ')
         ENDIF
      ENDIF
      NW=NWBUF+14
      CALL MZBOOK(IXCONS,JTM,JTMED,-ITMED,'TMED',10,10,NW,IOTMED,0)
C
      NAME=NATMED
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JTM+1),4,20)
C
      EPS=EPSIL
      IF(EPSIL.LE.0.0) THEN
         WRITE(CHMAIL,10000) ITMED, EPSIL
         CALL GMAIL(0,0)
         EPS=1.E-4
      END IF
      IF(IFIELD.NE.0.AND.FIELDM.EQ.0.0) THEN
         WRITE(CHMAIL,10200) ITMED, IFIELD
         CALL GMAIL(0,0)
      END IF
      IF(IGAUTO.NE.0.AND.ITMED.GT.0)THEN
         DE=-1.
         ST=-1.
         SM=-1.
      ELSE
         DE=DEEMAX
         ST=STMIN
         SM=STEMAX
      ENDIF
      Q(JTM + 6) = NMAT
      Q(JTM + 7) = ISVOL
      Q(JTM + 8) = IFIELD
      Q(JTM + 9) = FIELDM
      Q(JTM + 10) = TMAXFD
      Q(JTM + 11) = SM
      Q(JTM + 12) = DE
      Q(JTM + 13) = EPS
      Q(JTM + 14) = ST
      IF(NWBUF.GT.0)CALL UCOPY(UBUF,Q(JTM+15),NWBUF)
C
      IF(JTM1.GT.0) THEN
         CALL GPTMED(-ITMED)
      ENDIF
C
10000 FORMAT('0*** GSTMED *** Warning, medium = ',I5,
     +       ', value of EPSIL=',E10.3,' reset to 1 micron')
10100 FORMAT(' *** GSTMED *** Warning, tracking medium redefinition:')
10200 FORMAT('0*** GSTMED *** Warning, medium = ',I5,
     +       ', IFIELD = ',I3,' and FIELDM = 0.0 is illegal')
  999 END
+DECK,  GSTPAR, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:18  cernlib
* Geant

      SUBROUTINE GSTPAR(ITMED,CHPAR,PARVAL)
*
************************************************************************
*                                                                      *
*  To change the value of cut  or mechanism "CHPAR"                    *
*      to a new value PARVAL  for tracking medium ITMED                *
*    The  data   structure  JTMED   contains  the   standard  tracking *
*  parameters (CUTS and flags to control the physics processes)  which *
*  are used  by default  for all  tracking media.   It is  possible to *
*  redefine individually  with GSTPAR  any of  these parameters  for a *
*  given tracking medium.                                              *
*  ITMED     tracking medium number                                    *
*  CHPAR     is a character string (variable name)                     *
*  PARVAL    must be given as a floating point.                        *
*  For     example     to     change    CUTGAM     to     0.0001       *
*                                                                      *
*    ==>Called by : <USER>                                             *
*       Author    R.Brun     *********                                 *
*                                                                      *
************************************************************************
*
+CDE, GCBANK.
+CDE, GCPHYS.
+CDE, GCCUTS.
+CDE, GCUNIT.
+CDE, GCNUM.
      DIMENSION CUTS(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      CHARACTER*(*) CHPAR
C.
C.    ------------------------------------------------------------------
C.
      IF(ITMED.LE.0)GO TO 90
      IF(ITMED.GT.NTMED)GO TO 90
      JTM=LQ(JTMED-ITMED)
      IF(JTM.LE.0)GO TO 90
      JTMN=LQ(JTM)
      IF(JTMN.EQ.0)THEN
         CALL MZBOOK(IXCONS,JTMN,JTM,0,'TCUT',0,0,40,3,0)
         IQ(JTMN-5)=ITMED
         DO 10 I=1,10
            Q(JTMN+I)=CUTS(I)
  10     CONTINUE
         DO 20 I=1,13
            Q(JTMN+10+I)=MECA(1,I)
  20     CONTINUE
*
* *** New mechanisms in version 3.16
         Q(JTMN+10+21)=ILABS
         Q(JTMN+10+22)=ISYNC
         Q(JTMN+10+23)=ISTRA
      ENDIF
C
      ITPAR=0
      IF(CHPAR.EQ.'CUTGAM')ITPAR=1
      IF(CHPAR.EQ.'CUTELE')ITPAR=2
      IF(CHPAR.EQ.'CUTNEU')ITPAR=3
      IF(CHPAR.EQ.'CUTHAD')ITPAR=4
      IF(CHPAR.EQ.'CUTMUO')ITPAR=5
      IF(CHPAR.EQ.'BCUTE' )ITPAR=6
      IF(CHPAR.EQ.'BCUTM' )ITPAR=7
      IF(CHPAR.EQ.'DCUTE' )ITPAR=8
      IF(CHPAR.EQ.'DCUTM' )ITPAR=9
      IF(CHPAR.EQ.'PPCUTM')ITPAR=10
      IF(CHPAR.EQ.'PAIR'  )ITPAR=11
      IF(CHPAR.EQ.'COMP'  )ITPAR=12
      IF(CHPAR.EQ.'PHOT'  )ITPAR=13
      IF(CHPAR.EQ.'PFIS'  )ITPAR=14
      IF(CHPAR.EQ.'DRAY'  )ITPAR=15
      IF(CHPAR.EQ.'ANNI'  )ITPAR=16
      IF(CHPAR.EQ.'BREM'  )ITPAR=17
      IF(CHPAR.EQ.'HADR'  )ITPAR=18
      IF(CHPAR.EQ.'MUNU'  )ITPAR=19
      IF(CHPAR.EQ.'DCAY'  )ITPAR=20
      IF(CHPAR.EQ.'LOSS'  )ITPAR=21
      IF(CHPAR.EQ.'MULS'  )ITPAR=22
      IF(CHPAR.EQ.'RAYL'  )ITPAR=23
      IF(CHPAR.EQ.'GHCOR1')ITPAR=26
      IF(CHPAR.EQ.'GHCOR2')ITPAR=27
      IF(CHPAR.EQ.'GHCOR3')ITPAR=28
      IF(CHPAR.EQ.'GHCOR4')ITPAR=29
      IF(CHPAR.EQ.'BIRK1' )ITPAR=27
      IF(CHPAR.EQ.'BIRK2' )ITPAR=28
      IF(CHPAR.EQ.'BIRK3' )ITPAR=29
      IF(CHPAR.EQ.'LABS' ) ITPAR=31
      IF(CHPAR.EQ.'SYNC' ) ITPAR=32
      IF(CHPAR.EQ.'STRA' ) ITPAR=33
      IF(ITPAR.NE.0)THEN
         Q(JTMN+ITPAR)=PARVAL
         IF(ITPAR.EQ.21)THEN
            KLOSS=PARVAL+0.001
            IF(KLOSS.EQ.3.OR.KLOSS.EQ.1)Q(JTMN+15)=1.
         ENDIF
      ELSE
         WRITE(CHMAIL,1000)ITMED,CHPAR
         CALL GMAIL(0,0)
      ENDIF
      GO TO 99
C
  90  WRITE(CHMAIL,2000)ITMED
      CALL GMAIL(0,0)
C
 1000 FORMAT(' ***** GSTPAR error for tracking medium ',
     +  I3,' Tracking parameter ',A,'  not defined ***** ')
 2000 FORMAT(' ***** GSTPAR error. Tracking medium NR ',
     +  I3,' not defined ***** ')
  99  END

+DECK,  GXSI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:18  cernlib
* Geant

      FUNCTION GXSI (Z)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  COMPUTE SCREENING FACTOR   FOR PAIR PRODUCTION AND BREM       *
C.    *  REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78              *
C.    *                        FORMULA 2.7.22                          *
C.    *                                                                *
C.    *    ==>Called by : GSMIXT                                       *
C.    *       Author    M.Maire *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DATA AL183  , AL1440 / 5.20948 , 7.27239 /
      ALZ  = LOG(Z)/3.
      GXSI  = (AL1440 - 2*ALZ) / (AL183 - ALZ - GFCOUL(Z))
      END
+PATCH, GBASE.
+DECK,  GBASE_DOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1.1.1  1995/10/24 10:20:06  cernlib
* Geant
*
*
#include "geant321/pilot.h"
#if defined(CERNLIB_DOC)
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
*
************************************************************************
*                                                                      *
*                                                                      *
*                         Introduction to GEANT3                       *
*                         ----------------------                       *
*                                                                      *
*                                                                      *
*    GEANT3 APPLICATIONS                                               *
*                                                                      *
*  The principal applications of GEANT3 are:                           *
*                                                                      *
*  - The  tracking of  particles  through an  experimental setup  for  *
*    acceptance studies or simulation of detector response, and        *
*  - the graphical  representation of the  setup and of  the particle  *
*    trajectories.                                                     *
*                                                                      *
*  It is of course desirable and  very instructive to combine the two  *
*  interactively since the observation of  what happens to a particle  *
*  during the tracking may underline  the weaknesses of the setup and  *
*  makes  the debugging  easier. In view  of these  applications, the  *
*  GEANT3 system allows:                                               *
*                                                                      *
*  - to  describe an  experimental setup  in a  rather efficient  and  *
*    simple  way.   The  setup  is  represented  by  a  structure  of  *
*    geometrical VOLUMEs.  Each volume is  given a 'MEDIUM' number by  *
*    the user.   Different volumes  may have  the same  medium number  *
*    [GEOM].   A  medium is  defined  by  a  set of  parameters,  the  *
*    so-called TRACKING MEDIUM parameters, which include reference to  *
*    the MATERIAL filling the volume [CONS].                           *
*  - to  generate   simulated  events   from  standard   Monte  Carlo  *
*    generators [KINE].                                                *
*  - to  control  the  transport  of particles  through  the  various  *
*    regions of the setup, taking into account the geometrical volume  *
*    boundaries and  all physical  effects due to  the nature  of the  *
*    particles themselves, to their  interactions with the matter and  *
*    to the magnetic field [TRAK, PHYS].                               *
*  - to  record the  elements of  the particle  trajectories and  the  *
*    response from the sensitive detectors [HITS],                     *
*  - to visualize either interactively  or in batch the detectors and  *
*    the particle trajectories [DRAW, XINT].                           *
*                                                                      *
*   Part of the  subroutines available in GEANT3  are integrated into  *
*  program segments which perform these tasks.                         *
*   The  program  segments may  contain  'dummy'  and 'default'  user  *
*  subroutines  called  whenever  application dependent  actions  are  *
*  expected.                                                           *
*   Other  subroutines   provide  tools  either  to   perform  simple  *
*  functions (control  print, debug, I/O,  etc.) or to  implement the  *
*  operations required  for most of the  applications (description of  *
*  the geometrical setup, handling of detector responses,etc.).        *
*   It is the responsibility of  the user to assemble the appropriate  *
*  program segments and tools into an executable program, to code the  *
*  relevant  user subroutines,  to  provide the  data describing  the  *
*  experimental environment and to  submit the appropriate data cards  *
*  which control the  execution of the program.  The  section BASE of  *
*  the User's Guide gives the information necessary to understand how  *
*  to do this job.                                                     *
*                                                                      *
*  Note: as a  general convention the  names of the dummy  or default  *
*        user subroutines have GU or UG  as first two letters and are  *
*        printed in bold characters.                                   *
*                                                                      *
*  EVENT SIMULATION FRAMEWORK                                          *
*                                                                      *
*  The framework for  event simulation is described  in the following  *
*  paragraphs to  familiarize the  reader with  the areas  where user  *
*  interventions are expected.                                         *
*   At  the same  time, the  GEANT3 data  structures are  introduced.  *
*  This last point  is important as the coding to  be provided by the  *
*  user  often consists  of  filling data  structures, or  extracting  *
*  information from  them, or  saving them on  output, making  use of  *
*  standard routines available in the system.                          *
*   A main  program has to  be provided by  the user [BASE  100].  It  *
*  allocates the dynamic memory for ZEBRA and HBOOK and gives control  *
*  to the three phases of the run:                                     *
*                                                                      *
*  - Initialisation                                                    *
*  - Event processing                                                  *
*  - Termination.                                                      *
*                                                                      *
*  INITIALISATION                                                      *
*                                                                      *
*  The initialisation  phase is under  the control of the  user [BASE  *
*  100].  It consists of the  following steps, most of them performed  *
*  via calls to standard GEANT3 subroutines:                           *
*                                                                      *
*  - GINIT,  to  initialize the  GEANT3  common  blocks with  default  *
*    values which the user should be aware of [BASE 030, 110].         *
*  - GFFGO to read  'free format' data cards which  can override some  *
*    of the  values defined in  GINIT the default options  [BASE 040,  *
*    110].                                                             *
*  - GZINIT to initialize the dynamic  core divisions, the link areas  *
*    and the data structure JRUNG [BASE 110].                          *
*  - GDINIT  to initialize the drawing package [DRAW].                 *
*  - GPART  and auxiliaries,  to  generate the  data structure  JPART  *
*    describing the standard particle properties [CONS].               *
*  - GMATE  and auxiliaries,  to  generate the  data structure  JMATE  *
*    describing  the  characteristics  of   the  most  commonly  used  *
*    MATERIALs [CONS].                                                 *
*  - <USER> to define the geometry of the different components of the  *
*    experimental  setup [GEOM]  and the  tracking medium  parameters  *
*    [CONS,TRAK], and  to generate the corresponding  data structures  *
*    JROTM, JVOLUM and JTMED.                                          *
*  - <USER> to specify which elements of the geometrical setup should  *
*    be considered as 'sensitive detectors', giving a 'response' when  *
*    hit by a particle [HITS].                                         *
*  - GGCLOS to close the Geometry package (mandatory).                 *
*  - GBHSTA to  book standard  GEANT3 histograms  as required  by the  *
*    user with the data card HSTA [BASE 040, 110].                     *
*  - GPHYSI to  compute energy loss  and cross section tables  and to  *
*    store them in the data structure JMATE [CONS,PHYS].               *
*                                                                      *
*  EVENT PROCESSING                                                    *
*                                                                      *
*  The processing phase is triggered by  a call to the subroutine GRUN *
*  which,  for each  event to  be  processed,  gives  control to  the  *
*  subroutines:                                                        *
*                                                                      *
*  - GTRIGI, to  initialize the  event processing  and to  create the  *
*    Header bank JHEAD.                                                *
*  - GTRIG to process the event.                                       *
*  - GTRIGC to clean up the event division                             *
*                                                                      *
*  and checks that enough time is left for the next event [BASE 200].  *
*  The main  steps of GTRIG  consist of  calls to the  following user  *
*  routines:                                                           *
*                                                                      *
*  - GUKINE generates the data structures JVERTX and JKINE describing  *
*    the kinematics  of the current  event on input [KINE],  or reads  *
*    them [IOPA].                                                      *
*  - GUTREV (calls GTREVE) controls the  tracking for the whole event  *
*    [TRAK].  Each particle  is tracked in turn and  when a sensitive  *
*    detector is  hit, the user  may store any useful  information in  *
*    the  data  structure JHITS  [HITS].   Before  tracking the  next  *
*    particle, any  secondary products generated by  the current one,  *
*    and stored  by the user  in the temporary data  structure JSTAK,  *
*    are processed in the same way.                                    *
*    Simultaneously,   the  data   structure  JXYZ,   containing  the  *
*    coordinates  of space  points  along the  tracks  for the  whole  *
*    event, can be filled by the user [TRAK].                          *
*  - GUDIGI  simulates the  detector responses  for the  whole event,  *
*    making use  of the information  previously recorded in  the data  *
*    structure JHITS,  and stores the  results in the  data structure  *
*    JDIGI [HITS].                                                     *
*  - GUOUT outputs the relevant data structures for the current event  *
*    [IOPA].                                                           *
*                                                                      *
*  Other user routines called during  the tracking phase triggered by  *
*  GTREVE should be mentioned for completeness:                        *
*                                                                      *
*  - The hadronic processes activated by  default for the tracking of  *
*    hadrons in  GEANT3 are  described by  the program  GHEISHA (file  *
*    GEANH).  In  the subroutines GUPHAD  and GUHADR [TRAK]  the user  *
*    may select, instead of GHEISHA,  the program FLUKA (file GEANF).  *
*  - After each  tracking step of  a given  track in a  given medium,  *
*    control is given to the subroutine GUSTEP.  From the information  *
*    available  in  common  blocks  the  user is  able  to  take  the  *
*    appropriate  action, such  as  storing a  hit or transferring  a  *
*    secondary product  either in  the stack JSTAK  or in  the events  *
*    structure JVERTX/JKINE.                                           *
*  - The subroutine GUSWIM is called  by various tracking routines to  *
*    select the appropriate  code for transport of  the particle over  *
*    the given tracking  step.  A default version is  provided in the  *
*    library for  this routine which in  normal cases need not  to be  *
*    provided by the user.                                             *
*  - The magnetic field,  unless constant with no  X- or Y-component,  *
*    has to be returned by the user subroutine GUFLD.                  *
*                                                                      *
*  TERMINATION                                                         *
*                                                                      *
*   The  termination phase  is under  the control  of the  user [BASE  *
*  300].  For trivial applications it may simply consist of a call to  *
*  the subroutine  GLAST which  computes and prints  some statistical  *
*  information (time per event, use of dynamic memory, etc.).          *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*                                                                      *
*                  Simplified Program Flow Chart                       *
*                  -----------------------------                       *
*                                                                      *
*  MAIN(user)                                                          *
*  |                                                                   *
*  |-GZEBRA  initialisation   of   ZEBRA  system, dynamic core         *
*  |         allocation                                                *
*  |-UGINIT  (user)                                                    *
*  ||                                                                  *
*  ||- GINIT    initialisation of GEANT3 variables                     *
*  ||- GFFGO    interpretation of data cards                           *
*  ||- GZINIT   initialisation  of ZEBRA  core  divisions and  link    *
*  ||           areas                                                  *
*  ||- GPART    creation of the 'particle' data structure JPART        *
*  ||- GMATE    creation of the 'material' data structure JMATE        *
*  ||- <USER>   description  of the geometrical setup,   of the        *
*  ||           sensitive detectors and creation of data structures    *
*  ||           JVOLUM, JTMED, JROTM, JSETS                            *
*  ||- GGCLOS   close Geometry package                                 *
*  ||- GPHYSI   preparation of cross-sections and energy loss tables   *
*  |            for all used materials                                 *
*  |                                                                   *
*  |-GRUN (loop over events)                                           *
*  ||                                                                  *
*  ||- GTRIGI   initialisation for event processing                    *
*  ||- GTRIG    event processing                                       *
*  ||  |                                                               *
*  ||  |- GUKINE (user)  generation (or input)  of  event initial      *
*  ||  |                 kinematics                                    *
*  ||  |- GUTREV (user)                                                *
*  ||  |   |- GTREVE   (simplified flow for sequential tracking)       *
*  ||  |      |- GSSTAK   store primary tracks in stack                *
*  ||  |      |- Loop over tracks                                      *
*  ||  |        |- GLTRAC   prepare commons for tracking               *
*  ||  |            |- GMEDIA  find current volume /tracking medium    *
*  ||  |        |- GUTRAK (user)                                       *
*  ||  |          |- GTRACK                                            *
*  ||  |            |- GTGAMA/GTELEC/...  tracking   of  particle      *
*  ||  |                                  according to type            *
*  ||  |                 |-   compute physical step size               *
*  ||  |                 |- GTNEXT compute geometrical step size       *
*  ||  |                 |-   propagate (GUSWIM..)                     *
*  ||  |                 |-   test change of volume (GINVOL)           *
*  ||  |            |- GUSTEP (user) recording of hits in data         *
*  ||  |                      structure JHITS and of space points      *
*  ||  |                      in structure JXYZ                        *
*  ||  |- GUDIGI computation  of  digitisations  and recording  in     *
*  ||  |         structure JDIGI                                       *
*  ||  |- GUOUT  output of current event                               *
*  ||                                                                  *
*  ||- GTRIGC   clearing of memory for next event                      *
*  |                                                                   *
*  |-UGLAST (user)                                                     *
*  ||                                                                  *
*  ||- GLAST    standard GEANT3 termination.                           *
*  |                                                                   *
*  |                                                                   *
*  STOP                                                                *
*                                                                      *
*                                                                      *
************************************************************************
************************************************************************
*                                                                      *
*                    Overview of COMMON Blocks                         *
*                    -------------------------                         *
*                                                                      *
*                                                                      *
*  INTRODUCTION                                                        *
*                                                                      *
*  The communication between program segments of the GEANT3 system is  *
*  ensured by data structures and by 'long range' variables in common  *
*  blocks.  In addition,within the  program segments, the subroutines  *
*  communicate with each other  via  explicit arguments  and via  the  *
*  common block variables.                                             *
*   The data structures are described in separate sections. Here, the  *
*  main features of the common  blocks used in GEANT3 are summarized,  *
*  with special mention of the  variables initialized in GINIT and of  *
*  the possibility to override them via data cards [BASE040].          *
*   The  labelled   common  blocks  are  accessible   via  Patchy/CMZ  *
*  sequences identified by the name  of the COMMON.  They are defined  *
*  in the Patch GCDES.                                                 *
*                                                                      *
*  Note: Unless  otherwise specified  the  long  range variables  are  *
*        initialized  in GINIT.   When not  zero, default  values are  *
*        quoted between brackets.  If the value may be modified via a  *
*        standard data  card the  card  keyword is also given between  *
*        brackets.                                                     *
*                                                                      *
*  DYNAMIC CORE                                                        *
*                                                                      *
*  The  GEANT3 data  structures  are stored  in  the common  /GCBANK/  *
*  accessible via the following Patchy sequence.                       *
*                                                                      *
*+KEEP,GCBANK                                                          *
*     PARAMETER (KWBANK=69000,KWWORK=5200)                             *
*     COMMON/GCBANK/NZEBRA,GVERSN,ZVERSN,IXSTOR,IXDIV,IXCONS,FENDQ(16) *
*    +             ,LMAIN,LR1,WS(KWBANK)                               *
*     DIMENSION IQ(2),Q(2),LQ(8000),IWS(2)                             *
*     EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN),(IWS(1),WS(1))      *
*     EQUIVALENCE (JCG,JGSTAT)                                         *
*     COMMON/GCLINK/JDIGI ,JDRAW ,JHEAD ,JHITS ,JKINE ,JMATE ,JPART    *
*    +      ,JROTM ,JRUNG ,JSET  ,JSTAK ,JGSTAT,JTMED ,JTRACK,JVERTX   *
*    +      ,JVOLUM,JXYZ  ,JGPAR ,JGPAR2,JSKLT                         *
*                                                                      *
*  The /GCLINK/ variables are pointers to the GEANT3 data structures.  *
*  They belong  to a permanent  area declared in GZINIT.   The common  *
*  /GCLINK/ alone may be accessed through the sequence GCLINK.         *
*                                                                      *
*  OTHER LABELLED COMMON BLOCKS                                        *
*                                                                      *
*        COMMON/GCCUTS/CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM) *
*       +             ,DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS(5)            *
*  C                                                                   *
*  CUTGAM   Kinetic energy cut for gammas              (0.001, CUTS)   *
*  CUTELE   Kinetic energy cut for electrons           (0.001, CUTS)   *
*  CUTHAD   Kinetic energy cut for hadrons             (0.01, CUTS)    *
*  CUTNEU   Kinetic energy cut for neutral hadrons     (0.01, CUTS)    *
*  CUTMUO   Kinetic energy cut for muons               (0.01, CUTS)    *
*  BCUTE    Kinetic energy cut for electron Brems.     (CUTGAM, CUTS)  *
*  BCUTM    Kinetic energy cut for muon Brems.         (CUTGAM, CUTS)  *
*  DCUTE    Kinetic energy cut for electron delta-rays (CUTELE, CUTS)  *
*  DCUTM    Kinetic energy cut for muon delta-rays     (CUTELE, CUTS)  *
*  PPCUTM   Kinetic energy cut for e+e- pair production by muons       *
*                                                      (.01, CUTS)     *
*  TOFMAX   Tracking cut on time of flight integrated from  primary    *
*           interaction time                           (1.E+10, CUTS)  *
*  GCUTS    For user applications                      (CUTS)          *
*                                                                      *
*  Note: The cuts BCUTE, BCUTM and DCUTE, DCUTM are given, in GPHYSI,  *
*        the  respective  default  values CUTGAM  and  CUTELE.   Only  *
*        experienced users should make use of the facility offered by  *
*        the data card CUTS to  change BCUTE, DCUTE, BCUTM and DCUTM.  *
*                                                                      *
*     COMMON /GCDRAW/ .....                                            *
*                     see GEANG Pam file                               *
*                                                                      *
*        COMMON/GCFLAG/IDEBUG,IDEMIN,IDEMAX,ITEST,IDRUN,IDEVT,IEORUN   *
*       +        ,IEOTRI,IEVENT,ISWIT(10),IFINIT(20),NEVENT,NRNDM(2)   *
*        COMMON/GCFLAX/BATCH, NOLOG                                    *
*        LOGICAL BATCH, NOLOG                                          *
*  C                                                                   *
*  IDEBUG   Flag set equal to 1 to activate debug if IEVENT (below)    *
*  IDEMIN            is greater or equal to IDEMIN                     *
*  IDEMAX            and less or equal to IDEMAX             (DEBU)    *
*  ITEST    Flag to request printing of IEVENT, IDEVT and NRNDM        *
*           (below) every ITEST events                       (DEBU)    *
*  IDRUN    Current user run number                        (1, RUN)    *
*  IDEVT    Current user event number                         (RUN)    *
*  IEORUN   Flag to terminate current run if non zero                  *
*  IEOTRI   Flag to abort current event if non zero                    *
*  IEVENT   Current event sequence number                       (1)    *
*  ISWIT    Flags reserved for user in relation to debug     (SWIT)    *
*  IFINIT   System flags to check initialisation of GEANT routines     *
*  NEVENT   Number of events to be processed        (10000000,TRIG)    *
*  NRNDM    Initial value of random number seeds NRNDM(1),             *
*           NRNDM(2). If NRNDM(2) is 0, the independent sequence       *
*           NRNDM(1) is used. If NRNDM(1) is 0, the default sequence   *
*           is used. (9876, 54321, RNDM)                               *
*  BATCH    Flag set to .TRUE. if the program is running in            *
*           batch.                                                     *
*  NOLOG    Flag set to .TRUE. if the no logon file has been           *
*           requested.                                                 *
*                                                                      *
*        COMMON/GCJLOC/NJLOC(2),JTM,JMA,JLOSS,JPROB,JMIXT,JPHOT,JANNI  *
*       +                  ,JCOMP,JBREM,JPAIR,JDRAY,JPFIS,JMUNU,JRAYL  *
*       +                  ,JMULOF,JCOEF,JRANG                         *
*  C                                                                   *
*   For relocation of local pointers. Self-explanatory [CONS 199].     *
*                                                                      *
*        COMMON/GCKINE/IKINE,PKINE(10),ITRA,ISTAK,IVERT,IPART,ITRTYP   *
*       +      ,NAPART(5),AMASS,CHARGE,TLIFE,VERT(3),PVERT(4),IPAOLD   *
*  C                                                                   *
*  IKINE    User flag(0, KINE)                                         *
*  PKINE    User array(1E10, KINE)                                     *
*  ITRA     Current track number                                       *
*  ISTAK    Current stack-track number                                 *
*  IVERT    Current vertex number                                      *
*  IPART    Current particle number                                    *
*  ITRTYP   Tracking type of current particle                          *
*  NAPART   Name of current particle                                   *
*  AMASS    Mass of current particle                                   *
*  CHARGE   Charge of current particle                                 *
*  TLIFE    Life-time of current particle                              *
*  VERT     Coordinates of origin vertex for current track             *
*  PVERT    Track kinematics at origin vertex (PVERT(4) no longer      *
*           used)                                                      *
*  IPAOLD   Particle number of the previous track.                     *
*                                                                      *
*        INTEGER MXGKIN                                                *
*        PARAMETER (MXGKIN=100)                                        *
*        COMMON/GCKING/KCASE,NGKINE,GKIN(5,MXGKIN),                    *
*       +                           TOFD(MXGKIN),IFLGK(MXGKIN)         *
*  KCASE     Mechanism having generated the secondary particles        *
*  NGKINE    Number of generated secondaries                           *
*  GKIN(1,I) Px      of I-th secondary                                 *
*  GKIN(2,I) Py               " "                                      *
*  GKIN(3,I) Pz               " "                                      *
*  GKIN(4,I) E                " "                                      *
*  GKIN(5,I) Particle number  " "                                      *
*  TOFD(I)   Time delay introduced by the interaction.                 *
*                                                                      *
*     COMMON/GCLIST/NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT    *
*    +       ,NSTAT,LHSTA(20),LGET (20),LSAVE(20),LSETS(20),LPRIN(20)  *
*    +             ,LGEOM(20),LVIEW(20),LPLOT(20),LSTAT(20)            *
*C                                                                     *
*  NHSTA    Number of histograms declared on data card HSTA            *
*  NGET     Number of data structures declared on data card GET        *
*  NSAVE    Number of data structures declared on data card SAVE       *
*  NSETS    Number of items described on data card SETS                *
*  NPRIN    Number of items described on data card PRIN                *
*  NGEOM    Number of items described on data card GEOM                *
*  NVIEW    Number of items described on data card VIEW                *
*  NPLOT    Number of items described on data card PLOT                *
*  NSTAT    Number of items described on data card STAT                *
*  LHSTA,...,LSTAT Corresponding user lists of items (HSTA,...,STAT)   *
*                                                                      *
*   See examples of utilisation of  the user lists in GEANT3 examples  *
*  in  GEANX file.   LSTAT(1) is  reserved by  the system  for volume  *
*  statistics.                                                         *
*                                                                      *
*        COMMON/GCMATE/NMAT,NAMATE(5),A,Z,DENS,RADL,ABSL               *
*  C                                                                   *
*  NMAT      Current material number                                   *
*  NAMATE    Name of current material                                  *
*  A         Atomic weight of current material                         *
*  Z         Atomic number of current material                         *
*  DENS      Density of current material                               *
*  RADL      Radiation length of current material                      *
*  ABSL      Absorption length of current material                     *
*                                                                      *
*     COMMON/GCMULO/SINMUL(101),COSMUL(101),SQRMUL(101),OMCMOL,CHCMOL  *
*    +  ,EKMIN,EKMAX,NEKBIN,NEK1,EKINV,GEKA,GEKB,EKBIN(200),ELOW(200)  *
*                                                                      *
*   Pre-computed  quantities  for   multiple  scattering  and  energy  *
*  binning [CONS 199]                                                  *
*  SINMUL   Not used                                                   *
*  COSMUL   Not used                                                   *
*  SQRMUL   Not used                                                   *
*  OMCMOL   Constant Omega for Moliere scattering                      *
*  CHCMOL   Constant for Moliere scattering                            *
*  EKMIN    Lower edge for the energy range           (1E-5, ERAN)     *
*  EKMAX    Upper edge for the energy range           (1E+4, ERAN)     *
*  NEKBIN   Number of energy bins to be used          (90, ERAN)       *
*  NEK1     Number of energy bins to be used + 1                       *
*  EKINV    \                                                          *
*  GEKA      >Constants for the energy binning                         *
*  GEKB     /                                                          *
*  EKBIN    Lower edges of energy bins                                 *
*  ELOW     Lower edges of logarithm of energy bins                    *
*                                                                      *
*        COMMON/GCNUM/NMATE ,NVOLUM,NROTM,NTMED,NTMULT,NTRACK,NPART    *
*       +            ,NSTMAX,NVERTX,NHEAD,NBIT                         *
*        COMMON /GCNUMX/ NALIVE,NTMSTO                                 *
*  C                                                                   *
*  NMATE    Number of Materials                                        *
*  NVOLUM   Number of Volumes                                          *
*  NROTM    Number of Rotation matrices                                *
*  NTMED    Number of Tracking media                                   *
*  NTMULT   Number of  tracks processed  in current  event (including  *
*           secondaries), reset to 0 for each event                    *
*  NTRACK   Number of tracks in JKINE banks for current event          *
*  NPART    Number of Particle banks                                   *
*  NSTMAX   Maximum  number of  tracks  in  stack JSTAK  for  current  *
*           event, reset to 0 for each event                           *
*  NVERTX   Number of Vertices in JVERTX banks for current event       *
*  NHEAD    Number of data words in the JHEAD bank       (10)          *
*  NBIT     Number of bits per word (initialized in GINIT via FFINIT   *
*  NALIVE   Internal counter used for parallel tracking                *
*  NTMSTO   Internal counter used for parallel tracking                *
*                                                                      *
**KEEP,GCONSP                                                          *
*      DOUBLE PRECISION PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS  *
*      DOUBLE PRECISION EMMU,PMASS,AVO                                 *
*C                                                                     *
*      PARAMETER (PI=3.14159265358979324)                              *
*      PARAMETER (TWOPI=6.28318530717958648)                           *
*      PARAMETER (PIBY2=1.57079632679489662)                           *
*      PARAMETER (DEGRAD=0.0174532925199432958)                        *
*      PARAMETER (RADDEG=57.2957795130823209)                          *
*      PARAMETER (CLIGHT=29979245800.)                                 *
*      PARAMETER (BIG=10000000000.)                                    *
*      PARAMETER (EMASS=0.0005109990615)                               *
*      PARAMETER (EMMU=0.105658387)                                    *
*      PARAMETER (PMASS=0.9382723128)                                  *
*      PARAMETER (AVO=0.60221367)                                      *
*                                                                      *
*  PI       Number PI                                                  *
*  TWOPI    (2.*PI)                                                    *
*  PIBY2    (PI/2.)                                                    *
*  DEGRAD   Degree to radian conversion factor  (PI/180.)              *
*  RADDEG   Radian to degree conversion factor  (180./PI)              *
*  CLIGHT   Light velocity                                             *
*  BIG      Arbitrary large number                                     *
*  EMASS    Electron mass                                              *
*  EMMU     Muon mass                                                  *
*  PMASS    Proton mass                                                *
*  AVO      Avogadro Number * 1E-24                                    *
*                                                                      *
*  Control of Geometry optimisation                                    *
*     COMMON/GCOPTI/IOPTIM                                             *
*  IOPTIM  -1 = No optimisation at all. GSORD calls disabled           *
*           0 = No optimisation. Only user calls to GSORD kept         *
*           1 = All non-ordered volumes are ordered along the best axis*
*           2 = All volumes are ordered along the best axis            *
*                                                                      *
*   Control of physics processes.                                      *
*        COMMON/GCPHYS/IPAIR,SPAIR,SLPAIR,ZINTPA,STEPPA                *
*       +             ,ICOMP,SCOMP,SLCOMP,ZINTCO,STEPCO                *
*       +             ,IPHOT,SPHOT,SLPHOT,ZINTPH,STEPPH                *
*       +             ,IPFIS,SPFIS,SLPFIS,ZINTPF,STEPPF                *
*       +             ,IDRAY,SDRAY,SLDRAY,ZINTDR,STEPDR                *
*       +             ,IANNI,SANNI,SLANNI,ZINTAN,STEPAN                *
*       +             ,IBREM,SBREM,SLBREM,ZINTBR,STEPBR                *
*       +             ,IHADR,SHADR,SLHADR,ZINTHA,STEPHA                *
*       +             ,IMUNU,SMUNU,SLMUNU,ZINTMU,STEPMU                *
*       +             ,IDCAY,SDCAY,SLIFE ,SUMLIF,DPHYS1                *
*       +             ,ILOSS,SLOSS,SOLOSS,STLOSS,DPHYS2                *
*       +             ,IMULS,SMULS,SOMULS,STMULS,DPHYS3                *
*       +             ,IRAYL,SRAYL,SLRAYL,ZINTRA,STEPRA                *
*  *                                                                   *
*  IPAIR    Controls pair production process               (1,PAIR)    *
*           0 = no pair production                                     *
*           1 = pair production with generation of secondaries         *
*           2 = same without generation of secondaries                 *
*  ICOMP    Controls Compton scattering process            (1,COMP)    *
*           0 = no Compton scattering                                  *
*           1 = Compton scattering with generation of secondaries      *
*           2 = same without generation of secondaries                 *
*  IPHOT    Controls photo-electric effect process         (1,PHOT)    *
*           0 = no photo-electric effect                               *
*           1 = photo-electric effect with generation of secondaries   *
*           2 = same without generation of secondaries                 *
*  IPFIS    Controls photofission process                  (0,PFIS)    *
*           0 = no photofission                                        *
*           1 = photofission with generation of secondaries            *
*           2 = same without generation of secondaries                 *
*  IDRAY    Controls delta rays process                    (1,DRAY)    *
*           0 = no delta rays effect                                   *
*           1 = delta rays with generation of secondaries              *
*           2 = same without generation of secondaries                 *
*  IANNI    Controls positron annihilation process         (1,ANNI)    *
*           0 = no positron annihilation effect                        *
*           1 = positron annihilation with generation of secondaries   *
*           2 = same without generation of secondaries                 *
*  IBREM    Controls Bremsstrahlung process                (1,BREM)    *
*           0 = no Bremsstrahlung effect                               *
*           1 = Bremsstrahlung with generation of secondaries          *
*           2 = same without generation of secondaries                 *
*  IHADR    Controls hadron interactions process           (1,HADR)    *
*           0 = no hadron interactions effect                          *
*           1 = hadron interactions with generation of secondaries     *
*           2 = same without generation of secondaries                 *
*  IMUNU    Controls muon nuclear interaction process       (0,MUNU)   *
*           0 = no muon nuclear interaction effect                     *
*           1 = muon nuclear interaction with generation of secondaries*
*           2 = same without generation of secondaries                 *
*  IDCAY    Controls decay process                          (1,DCAY)   *
*           0 = no decay effect                                        *
*           1 = decay with generation of secondaries                   *
*           2 = same without generation of secondaries                 *
*  ILOSS    Controls energy loss process                    (2,LOSS)   *
*           0 = no energy loss effect                                  *
*           1 = delta ray and reduced Landau fluctuations              *
*           2 = full Landau fluctuations and no delta rays             *
*           3 = same as 1                                              *
*           4 = average Energy loss and no fluctuations                *
*  IMULS    Controls multiple scattering                   (1,MULS)    *
*           1 = Moliere or Coulomb scattering                          *
*           2 = Moliere or Coulomb scattering                          *
*           3 = Gaussian scattering                                    *
*  IRAYL    0 = No Rayleigh scattering                                 *
*           1 = Rayleigh scattering                                    *
*                                                                      *
*        COMMON/GCPOLY/IZSEC,IPSEC                                     *
*  C                                                                   *
*  Internal flags for polygon and polycone shapes. See GEANG file.     *
*                                                                      *
*        COMMON/GCPUSH/NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ       *
*  C                                                                   *
*  NCVERT   Initial size of mother bank JVERTX              (5)        *
*  NCKINE   Initial size of mother bank JKINE              (50)        *
*  NCJXYZ   Initial size of mother bank JXYZ               (50)        *
*  NPVERT   Increment for size of mother bank JVERTX        (5)        *
*  NPKINE   Increment for size of mother bank JKINE        (10)        *
*  NPJXYZ   Increment for size of mother bank JXYZ         (10)        *
*                                                                      *
*        COMMON/GCSETS/IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV(20)   *
*  C                                                                   *
*  IHSET    Set identifier                                             *
*  IHDET    Detector identifier                                        *
*  ISET     Position of set in bank JSET                               *
*  IDET     Position of detector in bank JS=IB(JSET-IDET)              *
*  IDTYPE   User defined detector type                                 *
*  NVNAME   Number of elements in NUMBV                                *
*  NUMBV    List of volume numbers to identify the detector            *
*                                                                      *
*      PARAMETER (NWSTAK=12,NWINT=11,NWREAL=12,NWTRAC=NWINT+NWREAL+5)  *
*      COMMON /GCSTAK/ NJTMAX, NJTMIN, NTSTKP, NTSTKS, NDBOOK, NDPUSH, *
*     +                NJFREE, NJGARB, NJINVO, LINSAV(15), LMXSAV(15)  *
*C                                                                     *
*  NTKSTP   Primary allocation for stack JSTAK                         *
*  NTKSTS   Secondary allocation for stack JSTAK                       *
*  NDBOOK   local variable for control of stack size                   *
*  NDPUSH   local variable for control of stack size                   *
*  (other variables used in parallel tracking only)                    *
*                                                                      *
*        COMMON/GCTIME/TIMINT,TIMEND,ITIME,IGDATE,IGTIME               *
*        INTEGER ITIME,IGDATE,IGTIME                                   *
*        REAL TIMINT,TIMEND                                            *
*  C                                                                   *
*  TIMINT   Total time left after initialization  (System, TIME)       *
*  TIMEND   Time required for program termination phase (1., TIME)     *
*  ITIME    Test on time left done every ITIME events (1, ITIME)       *
*  IGDATE   Date of the day  YYMMDD  integer (e.g. 920407)             *
*  IGTIME   Time of the day  HHMM    integer (e.g. 1425)               *
*                                                                      *
*      COMMON/GCTMED/NUMED,NATMED(5),ISVOL,IFIELD,FIELDM,TMAXFD,STEMAX *
*     +      ,DEEMAX,EPSIL,STMIN,CFIELD,PREC,IUPD,ISTPAR,NUMOLD        *
*  NUMED    Current tracking medium number                             *
*  NATMED   Name of current tracking medium                            *
*  ISVOL    Sensitive volume flag (if non zero)                        *
*  IFIELD   Field map type (0 if no field)                             *
*  FIELDM   Maximum field                                              *
*  TMAXFD   Maximum field turning angle in one step                    *
*  STEMAX   Maximum step allowed                                       *
*  DEEMAX   Maximum energy loss gradient in one step                   *
*  EPSIL    Boundary crossing accuracy                                 *
*  STMIN    Minimum step size by energy loss, multiple scattering      *
*           or field                                                   *
*  CFIELD   Constant for field step evaluation                         *
*  PREC     Initial step for boundary crossing (0.1*EPSIL)             *
*  IUDP     0 If medium change, (1 otherwise)                          *
*  ISTPAR   0 If standard tracking parameters                          *
*  NUMOLD   Numed of the last medium.                                  *
*                                                                      *
*        PARAMETER (MAXMEC=30)                                         *
*        COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7),NMEC,LMEC(MAXMEC)   *
*       + ,NAMEC(MAXMEC),NSTEP ,MAXNST,DESTEP,DESTEL,SAFETY,SLENG      *
*       + ,STEP  ,SNEXT ,SFIELD,TOFG  ,GEKRAT,UPWGHT,IGNEXT,INWVOL     *
*       + ,ISTOP ,IGAUTO,IEKBIN, ILOSL, IMULL,INGOTO,NLDOWN,NLEVIN     *
*       + ,NLVSAV,ISTORY                                               *
*  VECT     Current track parameters (X,Y,Z,Px/P,Py/P,Pz/P,P)          *
*  GETOT    Current track total energy                                 *
*  GEKIN    Current track kinetic energy                               *
*  VOUT     Local use                                                  *
*  NMEC     Number of mechanisms for current step                      *
*  LMEC     List of mechanism indices for current step                 *
*  NAMEC    Mechanism names (See below)                                *
*  NSTEP    Number of steps so far                                     *
*  MAXNST   Maximum number of steps allowed (default = 10000)          *
*  DESTEP   Total energy lost in current step                          *
*  DESTEL   Continuous energy loss in current step                     *
*  SAFETY   Overestimated distance to closest medium boundary          *
*  SLENG    Track length at current point                              *
*  STEP     Size of current tracking step                              *
*  SNEXT    Straight distance to next current medium boundary          *
*  SFIELD   Field turning angle step size evaluation                   *
*  TOFG     Time of flight                                             *
*  GEKRAT   Interpolation factor in table ELOW                         *
*  UPWGHT   User particle weight                                       *
*  IGNEXT   Flag set to 1 when SNEXT has been recomputed               *
*  INWVOL   Flag set to 1 when entering a new volume,                  *
*                       2 when leaving a volume and                    *
*                       3 when leaving the experimental setup.         *
*                       0 otherwise 0                                  *
*  ISTOP    Flag set to 1 when track looses its identity               *
*                       2 when energy below cut                        *
*  IGAUTO   Automatic computation of DEEMAX,STMIN,TMAXFD,STEMAX        *
*  IEKBIN   Current kinetic energy bin in table ELOW                   *
*  ILOSL    Local value of ILOSS for current tracking medium           *
*  IMULL    Local value of IMULS for current tracking medium           *
*  INGOTO   Content number of limiting content when computing SNEXT    *
*  NLDOWN   Lowest level reached down the tree (parallel tracking only)*
*  NLEVIN   Number of levels currently filled and valid in /GCVOLU/    *
*  NLVSAV   Current level (parallel tracking only)                     *
*  ISTORY   User flag for current track history (reset to 0 in GLTRAC) *
*  --------                                                            *
*  NAMEC    List  of possible  mechanisms  for  step size  limitation  *
*           filled in GINIT :                                          *
*     DATA MEC/'NEXT','MULS','LOSS','FIEL','DCAY','PAIR','COMP','PHOT' *
*    +        ,'BREM','DRAY','ANNI','HADR','ECOH','EVAP','FISS','ABSO' *
*    +        ,'ANNH','CAPT','EINC','INHE','MUNU','TOFM','PFIS','SCUT' *
*    +        ,'RAYL','PARA','PRED','LOOP','NULL','STOP'/              *
*  *                                                                   *
*                                                                      *
*        COMMON/GCUNIT/LIN,LOUT,NUNITS,LUNITS(5)                       *
*        INTEGER LIN,LOUT,NUNITS,LUNITS                                *
*        COMMON/GCMAIL/CHMAIL                                          *
*        CHARACTER*132 CHMAIL                                          *
*  C                                                                   *
*  LIN      Input unit to read data cards                              *
*  LOUT     Line printer output unit                                   *
*  NUNITS   Number of additional units                                 *
*  LUNITS   List of additional units.                                  *
*  CHMAIL   Internal string used for error messages                    *
*   LIN and  LOUT are defined in  GINIT through calls to  the routine  *
*  FFGET from  the standard  FFREAD package.   NUNITS and  LUNITS are  *
*  reserved for user applications.                                     *
*                                                                      *
*     COMMON /GCVOLU/   ......                                         *
*                     see GEANG Pam file                               *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*                      Summary of Data Cards                           *
*                      ---------------------                           *
*                                                                      *
*                                                                      *
*  INTRODUCTION                                                        *
*                                                                      *
*  GEANT3 uses the standard FFREAD package to read 'free format' data  *
*  cards in  the routine GFFGO.   The cards currently  interpreted by  *
*  GFFGO can be classified into four categories:                       *
*                                                                      *
*  - General control of the run.                                       *
*  - Control of the physics processes.                                 *
*  - Debug and I/O operations.                                         *
*  - User applications.                                                *
*                                                                      *
*  The data  cards are  listed below by  category with  the following  *
*  information:                                                        *
*                                                                      *
*  - KEY, card  keyword, any  number of  characters truncated  to the  *
*    first 4                                                           *
*  - N, maximum expected number of variables NVAR,                     *
*  - T,  TYPE of these variables (I=INTEGER,  R=REAL or M=MIXED)       *
*                                                                      *
*  for each variable in turn:                                          *
*                                                                      *
*      - VAR.., FORTRAN name                                           *
*      - Short description (more detail in BASE 030)                   *
*      - COMMON where it is stored, and                                *
*      - Default value from GINIT.                                     *
*                                                                      *
*  When a  card is decoded,  the values  entered by the  user without  *
*  explicit assignment are  assigned to the variables  in order.  The  *
*  number of values can  be less than NVAR.  In case  of a MIXED type  *
*  the values entered have to be in agreement with the default of the  *
*  corresponding FORTRAN variable names.                               *
*                                                                      *
*  Example of data card:     RUN   5   201                             *
*                                                                      *
*  to  preset  the  current  run  and  event  number  to  5  and  201  *
*  respectively.                                                       *
*   In batch jobs  there is no need for any  special termination card  *
*  and none of the cards mentioned below is mandatory.                 *
*                                                                      *
*  USER DEFINED DATA CARDS                                             *
*                                                                      *
*  Before  calling  GFFGO the  user  may  define private  data  cards  *
*  through calls to FFKEY as follows:                                  *
*      CALL FFKEY('KEY',VAR(1),NVAR,'TYPE')                            *
*   They will be interpreted by GFFGO in the same way as the standard  *
*  cards.                                                              *
*                                                                      *
*  SUMMARY OF THE MOST IMPORTANT GEANT3 DATA CARDS                     *
*                                                                      *
*  KEY   N  T  VAR..  Short description                COMMON  GINIT   *
*  General control of the run:                                         *
*  HSTA 20  M LHSTA   Names of required histograms     GCLIST    0     *
*  PATR  4  I NJTMAX  Max number of tracks in parallel GCSTAK    0     *
*                     tracking stack                                   *
*             NJTMIN  Number of tracks above which        "      0     *
*                     parallel tracking can be                         *
*                     reactivated when frozen earlier                  *
*             NTSTKP  Primary allocation for stack JSTAK  "    500     *
*             NTSTKS  Secondary  ... (when parallel       "    100     *
*                     tracking used)                                   *
*  RNDM  2  I NRNDM   Initial random number seeds                      *
*             NRNDM(1)                                 GCFLAG  9876    *
*             NRNDM(2)                                 GCFLAG 54321    *
*  RNDM  2  I NRNDM   Initial random number seeds      GCFLAG    0     *
*  RUNG  2  I IDRUN   User run number                  GCFLAG    1     *
*             IDEVT   User event number                GCFLAG    1     *
*  TIME  3  M TIMINT  Time left after initialisation   GCTIME System   *
*             TIMEND  Time required for termination    GCTIME   1.     *
*             ITIME   Test every ITIME events          GCTIME   1      *
*  TRIG  1  I NEVENT  Number of events to process      GCFLAG  1E7     *
*  Geometry optimization:                                              *
*  OPTI  1  I IOPTIM  Optimization level               GCOPTI   1      *
*  SCAN process control:                                               *
*  SCAN  8  M         SCAN granularity and mode                        *
*           SCANFL    Scan processing flag (Logical)   GCSCAN  FALSE   *
*           NPHI      Number of divisions in PHI       GCSCAN   90     *
*           PHIMIN    Minimum value of PHI             GCSCAN   0.     *
*           PHIMAX    Maximum value of PHI             GCSCAN 360.     *
*           NTETA     Number of divisions in TETA      GCSCAN  90      *
*           TETMIN    Minimum value of TETA            GCSCAN  0.      *
*           TETMAX    Maximum value of TETA            GCSCAN 180.     *
*           MODTET    Type of TETA division            GCSCAN   1      *
*  SCAL 32  M SLIST   List of scanned volumes          GCSCAN  'XXXX'  *
*  SCAP  6  R         SCAN parameters                                  *
*           VX      SCAN vertex X coordinate           GCSCAN  0.0     *
*           VY      SCAN vertex Y coordinate           GCSCAN  0.0     *
*           VZ      SCAN vertex Z coordinate           GCSCAN  0.0     *
*           FACTX0  Scale factor for SX0               GCSCAN  100.    *
*           FACTL   Scale factor for SL                GCSCAN  1000.   *
*           FACTR   Scale factor for R                 GCSCAN  100.    *
*  Control of physics processes:                                       *
*  AUTO  1  I IGAUTO  Automatic computation of STMIN   GCTRAK   1      *
*                     STEMAX,DEEMAX,TMAXFD                             *
*                     0 = Tracking media parameters                    *
*                         taken from the argument list                 *
*                         of GSTMED                                    *
*                     1 = Tracking media parameters                    *
*                         calculated by GEANT                          *
*  ANNI  1  I IANNI   Annihilation flag                GCPHYS   1      *
*  BREM  1  I IBREM   Bremsstrahlung flag              GCPHYS   1      *
*  COMP  1  I ICOMP   Compton scattering flag          GCPHYS   1      *
*  CUTS 15  R         Kinetic energy cuts :                            *
*           CUTGAM    " "   for gammas                 GCCUTS   0.001  *
*           CUTELE    " "   for electrons              GCCUTS   0.001  *
*           CUTHAD    " "   for charged hadrons        GCCUTS   0.01   *
*           CUTNEU    " "   for neutral hadrons        GCCUTS   0.01   *
*           CUTMUO    " "   for muons                  GCCUTS   0.01   *
*           BCUTE     " "   for electron brems.        GCCUTS   CUTGAM *
*           BCUTM     " "   for muon Brems.            GCCUTS   CUTGAM *
*           DCUTE     " "   for electron delta-rays    GCCUTS   CUTELE *
*           DCUTM     " "   for muon delta-rays        CCUTS    CUTELE *
*           PPCUTM    " "   for e+e- pairs by muons    CCUTS    10 MeV *
*           TOFMAX  Time of flight cut                 GCCUTS   1.E+10 *
*           GCUTS   5 user words                       GCCUTS   0.     *
*  DCAY  1  I IDCAY   Decay flag                       GCPHYS   1      *
*  DRAY  1  I IDRAY   delta-rays flag                  GCPHYS   1      *
*  ERAN  3  M Cross section tables                                     *
*           R EKMIN   Minimum energy for the tables    GCMULO  1E-5    *
*           R EKMAX   Maximum energy for the tables    GCMULO  1E+4    *
*           I NEKBIN  Number of bins in the table      GCMULO   90     *
*  HADR  1  I IHADR   Hadronic process flag            GCPHYS   1      *
*  LOSS  1  I ILOSS   Energy loss flag                 CGPHYS   2      *
*  MULS  1  I IMULS   Multiple scattering flag         GCPHYS   1      *
*  MUNU  1  I IMUNU   Muon nuclear interactions flag   GCPHYS   0      *
*  PAIR  1  I IPAIR   Pair production flag             GCPHYS   1      *
*  PFIS  1  I IPFIS   Photofission flag                GCPHYS   0      *
*  PHOT  1  I IPHOT   Photo-electric effect flag       GCPHYS   1      *
*  RAYL  1  I IRAYL   Rayleigh scattering flag         GCPHYS   0      *
*                                                                      *
*  Debug and I/O operations:                                           *
*  DEBU 3  M IDEMIN  First event to debug              GCFLAG   0      *
*            IDEMAX  Last event to debug               GCFLAG   0      *
*            ITEST   Print control frequency           GCFLAG   0      *
*  GET  20 M LGET    Names of data structure to get    GCLIST   ' '    *
*  PRIN 20 M LPRIN   User keywords to print data       GCLIST   ' '    *
*                   structures                                         *
*  SAVE 20 M LSAVE   Names of data struct. to save     GCLIST   ' '    *
*  SWIT 10 I ISWIT   User flags for debug or else      GCFLAG   0      *
*                   User applications:                                 *
*  KINE 11 M IKINE   User flag                         GCKINE   0      *
*            PKINE   10 user words                     GCKINE 1.E+10   *
*  SETS 20 M LSETS   User words for detector sets      GCLIST   ' '    *
*  STAT 20 M LSTAT   1 system + 19 user words          GCLIST   ' '    *
*  PLOT 20 M LPLOT   User words to control plots       GCLIST   ' '    *
*  GEOM 20 M LGEOM   User words to control geometry    GCLIST   ' '    *
*  VIEW 20 M LVIEW   User words to control View banks  GCLIST ' '      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*               The Reference Systems and dimensional Units            *
*               -------------------------------------------            *
*                                                                      *
*                                                                      *
*  THE MASTER REFERENCE SYSTEM  (MARS)                                 *
*                                                                      *
*   The Master Reference  System (MARS) is determined by  the way the  *
*  user  represents  the kinematical  quantities.   If  the axes  are  *
*  labelled (X,Y,Z), then the point P(A,B,C) is represented by         *
*                                                                      *
*           Y |                                                        *
*             |         * P(A,B,C)                                     *
*             |                    * X                  A on axis X    *
*             |                  *                      B on axis Y    *
*             |                *                        C on axis Z    *
*             |              *                                         *
*             |            *                                           *
*             |          *                                             *
*             |        *                                               *
*             |      *                                                 *
*             |                                                        *
*             |                                                        *
*             ............................>                            *
*                                         Z                            *
*    The tracking is performed in  the MAster Reference System.  This  *
*  implies that  the arguments  of the  user magnetic  field routine,  *
*  space point  coordinates and field  components, are given  in this  *
*  system.                                                             *
*                                                                      *
*  THE LOCAL REFERENCE SYSTEMS (MRS AND DRS)                           *
*                                                                      *
*   As explained in GEOM 001, the experimental set-up is described by  *
*  the  definition  of  an   'initial  MOTHER'  volume  inside  which  *
*  'DAUGHTER' volumes are positioned.   Other daughter volumes can be  *
*  positioned  inside  these volumes  which  are  promoted as  mother  *
*  volumes and so on, as russian dolls.                                *
*   This  requires the  definition  of local  reference systems,  the  *
*  Mother  Reference  Systems  (MRS,  Origin  O.)  and  the  Daughter  *
*  Reference Systems (DRS, Origin O.).                                 *
*   The  local  reference  system  of  the  'initial  mother'  volume  *
*  coincides with the MAster Reference System.                         *
*   The full description of a given  detector is usually given in the  *
*  local reference system of the associated volume.                    *
*   The transformation of a point from  the MRS (V.) to the DRS (V.),  *
*  at any level, requires the knowledge  of a rotation matrix R and a  *
*  translation vector T defined through the relation :                 *
*              ( V. ) = [ R ] ( V. - T )                               *
*   The components of  T are the projections of the  vector O.O. onto  *
*  the MRS axes.                                                       *
*   The rotation matrices  are computed from the  spherical angles of  *
*  each of  the axes of  the daughter  reference system (I,  II, III)  *
*  with respect to the mother reference system (1,2,3).                *
*   The spherical angles  THETA and PHI of a direction  D are defined  *
*  as follows :                                                        *
*                                                                      *
*  THETA     is the angle formed by the axis 3 and D (range : 0 to 180 *
*            degrees)                                                  *
*  PHI       is the angle formed by the axis 1 and the projection of D *
*            onto the plane defined by the axes 1 and 2 (range : 0 to  *
*            360 degrees)                                              *
*  Examples are given in GEOM 200.                                     *
*   The various rotation matrices required for a given set-up must be  *
*  defined  during  the initialisation  stage,  usually  in the  user  *
*  routine UGEOM.                                                      *
*   A serial number is assigned to each matrix [GEOM 200].             *
*   The translation parameters and the  serial number of the rotation  *
*  matrix are specified  by the user when the  volumes are positioned  *
*  inside the set-up [GEOM 110].                                       *
*                                                                      *
*  THE DIMENSIONAL UNITS                                               *
*                                                                      *
*  Unless  otherwise   specified,  the   following  units   are  used  *
*  throughout the program :                                            *
*                                                                      *
*      -  CENTIMETER, SECOND, KILOGAUSS, GEV, GEV/C, DEGREE            *
*                                                                      *
************************************************************************
*                                                                      *
*        Examples of MAIN Program and User Initialisation              *
*        ------------------------------------------------              *
*                                                                      *
*      PROGRAM MAIN                                                    *
*  C                                                                   *
*      PARAMETER (NG=100000,NH=10000)                                  *
*      COMMON/PAWC/H(NH)                                               *
*      COMMON/GCBANK/Q(NG)                                             *
*  C                                                                   *
*  C       Allocate memory for ZEBRA and HBOOK                         *
*      CALL GZEBRA(NG)                                                 *
*      CALL HLIMIT(-NH)                                                *
*  C                                                                   *
*  C       Initialize Graphics package                                 *
*      CALL IGINIT(0)                                                  *
*  C       Open metafile and define workstation type                   *
*  C         (computer dependent)                                      *
*                  ....                                                *
*  C                                                                   *
*  C       Initialisation phase                                        *
*      CALL UGINIT                                                     *
*  C                                                                   *
*  C       Processing phase                                            *
*      CALL GRUN                                                       *
*  C                                                                   *
*  C       Termination phase                                           *
*      CALL UGLAST                                                     *
*  C                                                                   *
*      END                                                             *
*      SUBROUTINE UGINIT                                               *
*  C                                                                   *
*  +SEQ,GCLIST                                                         *
*  C                                                                   *
*  C       Initialize GEANT variables                                  *
*      CALL GINIT                                                      *
*  C                                                                   *
*  C       Read data cards                                             *
*      CALL GFFGO                                                      *
*  C                                                                   *
*  C       Initialize data structures                                  *
*      CALL GZINIT                                                     *
*  C                                                                   *
*  C       Initialize drawing package                                  *
*      CALL GDINIT                                                     *
*  C                                                                   *
*  C       Open I/O buffers                                            *
*      IF(NGET .GT.0)CALL GOPEN(1,'I',0,IER)                           *
*      IF(NSAVE.GT.0)CALL GOPEN(2,'O',0,IER)                           *
*  C                                                                   *
*  C       Fetch permanent data structures (if any)                    *
*      CALL GFIN(1,'INIT',1,IDENT,' ',IER)                             *
*      IF(IER.LT.0) THEN                                               *
*  C                                                                   *
*  C       Define standard Particle and Material data                  *
*         CALL GPART                                                   *
*         CALL GMATE                                                   *
*  C                                                                   *
*  C       Define the geometrical set-up                               *
*         CALL 'user code'                                             *
*         CALL GGCLOS                                                  *
*  C                                                                   *
*  C       Compute cross-section and energy loss tables                *
*         CALL GPHYSI                                                  *
*       ENDIF                                                          *
*  C                                                                   *
*  C       Initialize standard histograms                              *
*       CALL GBHSTA                                                    *
*  C                                                                   *
*       END                                                            *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************
*                                                                      *
*               The System Initialisation routines                     *
*               ----------------------------------                     *
*                                                                      *
*  Presets COMMON  block variables to default  values.  Preprocessing  *
*  of  various  COMMON  block  variables.  See  'Overview  of  COMMON  *
*  blocks' [BASE  030].  Reads a  set of  data cards with  the FFREAD  *
*  package.  See 'Summary  of data cards' [BASE 040]  GFFGO should be  *
*  called  after  GINIT.   Allocates   the  dynamic  core  divisions.  *
*  Initialize the link areas and the data structure JRUNG [BASE 299].  *
*  Initialize  exotic bank  formats.  GZINIT  should be  called after  *
*  GFFGO.  To be called before the  user geometry routine if the user  *
*  wants  to  open  VIEW   banks  there.   Initializes  any  standard  *
*  histogram required by the user with the data record HSTA.           *
*   The following histogram keywords may be used :                     *
*  TIME     Time per event                                             *
*  SIZE     Size of division LXDIV per event                           *
*  MULT     Total number of tracks per event                           *
*  NTRA     Number of 'long life' tracks per event                     *
*  STAK     Maximum stack size per event                               *
*                                                                      *
*   GBHSTA should be called after GFFGO.                               *
*                                                                      *
*             Steering routines for Event Processing                   *
*             --------------------------------------                   *
*                                                                      *
*   The following flow chart is  only valid for the 'batch' execution  *
*  mode.   For  interactive  applications, see  section  XINT.   Main  *
*  routine to control a run of events                                  *
*                     .........                                        *
*                 ...>|  TIMEX|                                        *
*                 |   .........                                        *
*                 |      Get    time   left    (TIMINT)    after       *
*   initialisation                                                     *
*                 |                                                    *
*                 .............................                        *
*                 |    ...........            |                        *
*                 ... >| GTRIGI  |            |                        *
*                 |    ...........            |                        *
*                 |    ...........            |                        *
*   ........ .    |.. >| GTRIG   |       ......... .                   *
*   |        |    |    ......... .       |loop on  |                   *
*   | GRUN   |... |    |                 |         |                   *
*   ........ .    |    ......... .       | events  |                   *
*                 |.. >| GTRIGC  |       ......... .                   *
*                 |    ......... .            .                        *
*                 |    ...................    |                        *
*                 ... >| check time left |    |                        *
*                 |    ...................    |                        *
*                 .............................                        *
*                                                                      *
*   Resets to 0  the flag IEOTRI in /GCFLAG/ and  the counters NTRACK  *
*  and NVERTX in /GCNUM/.  Sets the  debug flag IDEBUG in /GCFLAG/ to  *
*  the value required for the current event.                           *
*   Creates the Header bank for current event.                         *
*   Prints  the sequence  number,  the event  number  and the  number  *
*  random  generators, under  control of  the flag  ITEST (data  card  *
*  DEBU).                                                              *
*   Steering routine to process one event (trigger)                    *
*                                                                      *
*                      ..........................                      *
*                      | Generates kinematics,  |                      *
*                 ... >| or read event GUKINE   |                      *
*                 |    ..........................                      *
*                 |    ................                                *
*                 |    | Tracking/hits|                                *
*   ........ .    |.. >| GUTREV       |                                *
*   | GTRIG  |.. >|    .............. .                                *
*   ........ .    |    .............. .                                *
*                 |.. >|                                               *
*   Digitisations |                                                    *
*                 |    | GUDIGI       |                                *
*                 |    ................                                *
*                 |    ................                                *
*                 |    | Output event |                                *
*                 ... >| GUOUT        |                                *
*                      ................                                *
*   The partition initialized  in GTRIGI is cleared.   The space used  *
*  by the current event may be used by the next one.                   *
*                                                                      *
*                    The banks JRUNG and JHEAD                         *
*                    -------------------------                         *
*                                                                      *
*  Run bank JRUNG:  1 user link, 30 data words                         *
*  LQ(JRUNG-1)   user link                                             *
*   IQ(JRUNG+1) IDRUN     Run number                                   *
*    ""  +2/10)           Reserved for user applications               *
*          +11) creation date for 'INIT' data structures               *
*          +12) creation time for 'INIT' data structures               *
*          +13) creation data for 'KINE'                               *
*          +14) creation time for 'KINE'                               *
*          +15) creation data for 'HITS'                               *
*          +16) creation time for 'HITS'                               *
*          +17) creation data for 'DIGI'                               *
*          +18) creation time for 'DIGI'                               *
*          +19) Random number seed 1                                   *
*          +20) Random number seed 2                                   *
*          +21) GEANT version number when 'INIT' created               *
*          +22) ZEBRA version number when 'INIT' created               *
*          +23) GEANT version number when 'KINE' created               *
*          +24) ZEBRA version number when 'KINE' created               *
*          +25) GEANT version number when 'HITS' created               *
*          +26) ZEBRA version number when 'HITS' created               *
*          +27) GEANT version number when 'DIGI' created               *
*          +28) ZEBRA version number when 'DIGI' created               *
*  Header bank JHEAD: 1 user link, NHEAD(=10) data words               *
*   IQ(JHEAD+1) IDRUN     Run number                                   *
*       ""  +2) IDEVT     Event number                                 *
*       ""  +3) NRNDM(1)  Random number seed 1 at beginning of event   *
*       ""  +4) NRNDM(2)          "     "                              *
*     "" +5/10)           Reserved for user applications               *
*                                                                      *
************************************************************************
*                                                                      *
*                                                                      *
*        Example of User Termination and related routines              *
*        ------------------------------------------------              *
*                                                                      *
*     SUBROUTINE UGLAST                                                *
*  C                                                                   *
*  +SEQ,GCLIST                                                         *
*  C                                                                   *
*  C      Call standard GEANT termination routine                      *
*     CALL GLAST                                                       *
*  C                                                                   *
*  C      Close HIGZ files                                             *
*     CALL IGEND                                                       *
*  C                                                                   *
*  C      Close I/O buffers                                            *
*     IF(NGET.EQ.0.AND.NSAVE.EQ.0) GO TO 5                             *
*     CALL GCLOSE(0,IER)                                               *
*  C                                                                   *
*  C      Print histograms                                             *
*   5 CALL HISTDO                                                      *
*  C                                                                   *
*     END                                                              *
*                                                                      *
*                                                                      *
************************************************************************
#endif
+DECK,  GBHSTA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:08  cernlib
* Geant

      SUBROUTINE GBHSTA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Books histograms statistics                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUOUT                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCLIST.
C.
C.    ------------------------------------------------------------------
C.
      IF(NHSTA.GT.0)THEN
         CALL GLOOK('TIME',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Time per event$',100,0.,0.,0.)
*
         CALL GLOOK('SIZE',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Space used in IXDIV per event$',
     +   100,0.,0.,0.)
*
         CALL GLOOK('MULT',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Total number of tracks per event$'
     +   ,100,0.,0.,0.)
*
         CALL GLOOK('NTRA',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Long life tracks per event$',100,
     +   0.,0.,0.)
*
         CALL GLOOK('STAK',LHSTA,NHSTA,ID)
         IF(ID.NE.0) CALL HBOOK1(-ID,'Maximum stack size per event$',
     +   100,0.,0.,0.)
*
      ENDIF
      END
+DECK,  GEAMON, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:08  cernlib
* Geant

+SELF, IF=MONITOR.
      SUBROUTINE GEAMON(ICASE,CHINFO)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine for GEANT monitoring                             *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUOUT                                *
C.    *       Author    R.Brun, F.Carminati ********                   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      COMMON/CWK/IWK
      CHARACTER*5  ENTRY, EXIT, BATINT
      LOGICAL FIRST, INTRAC
      CHARACTER*(*) CHINFO
      SAVE IWK1,IM1,TIM1,FIRST,ENTRY,EXIT,BATINT
      DATA ENTRY  /'GINIT'/
      DATA EXIT   /'GLAST'/
      DATA BATINT /'BATCH'/
      DATA FIRST  /.TRUE./
*
*________________________________________________________
*
      IF(ICASE.LE.1)THEN
         IF(FIRST) THEN
            CALL TIMEL(TIM1)
            IWK1=IWK
            CALL DATIME(IDAT1,ITIM1)
            IH1=ITIM1/100
            IM1=ITIM1-100*IH1+IH1*60
            IF(INTRAC()) BATINT='INTER'
            FIRST=.FALSE.
         ENDIF
      ENDIF
      IF(ICASE.EQ.0) THEN
         ENTRY='GXINT'
         EXIT ='GXINT'
      ELSE
         IF(ICASE.EQ.1) THEN
            WRITE(CHMAIL,10000)IWK1,CHINFO,ENTRY,BATINT
         ELSEIF(ICASE.EQ.2) THEN
            IF(ENTRY.EQ.'GXINT'.AND.CHINFO.EQ.'GLAST') THEN
               EXIT='GLAST'
               GOTO 999
            ENDIF
            CALL TIMEL(TIM2)
            CPTIME=TIM1-TIM2
            CALL DATIME(IDAT2,ITIM2)
            IH2=ITIM2/100
            IM2=ITIM2-100*IH2+IH2*60
            IMD=IM2-IM1
            IF(IMD.LT.0) IMD=IMD+24*60
            IRTIME=MIN(9999,MAX(IMD,1))
            CPTIME=MIN(99999.,CPTIME)
            IF(IRTIME.GT.999)THEN
               WRITE(CHMAIL,10101)IWK1,IRTIME,CPTIME,EXIT
            ELSE
               WRITE(CHMAIL,10100)IWK1,IRTIME,CPTIME,EXIT
            ENDIF
         ENDIF
*
         CALL UMLOG('GEANTMON',CHMAIL(1:LNBLNK(CHMAIL)))
*
      ENDIF
*
10000 FORMAT('LOG321 WTYP=',I6,1X,A,2(1X,A5))
10100 FORMAT('LOGOUT WTYP=',I6,' RT=',I3,' min CP=',F9.3,' sec ',A5)
10101 FORMAT('LOGOUT WTYP=',I6,' RT', I4,' min CP=',F9.3,' sec ',A5)
*
  999 END
+SELF.
+DECK,  GETNUM, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:09  cernlib
* Geant

      SUBROUTINE GETNUM(LIST,N)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to count the number of non blank elements        *
C.    *      in the array LIST before the first blank one              *
C.    *                                                                *
C.    *    ==>Called by : GFFGO                                        *
C.    *    ==>Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION LIST(*)
      SAVE IFIRST,IDFLT
      DATA IFIRST/0/
C.    ------------------------------------------------------------------
C.
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH('    ',IDFLT,4,4)
      ENDIF
C
      N = 0
      DO 10 I=1,20
         IF(LIST(I).EQ.IDFLT) GO TO 99
         N=N+1
  10  CONTINUE
C
  99  RETURN
      END
+DECK,  GETVER, T=FORT.
* Revision 1.14  1999/11/15 15:30:33  mclareni
* Updated version number to 3.21/13
* Revision 1.13  1999/01/27 14:21:03  mclareni
* Updated version number to 3.21/12
* Revision 1.12  1998/02/10 18:13:44  japost
*  Correct the version number HVERS returned (now 3.2111 not 3.2210 for 3.21/11)
* Revision 1.11  1997/11/13 16:06:04  mclareni
* Update the date also
* Revision 1.10  1997/11/13 13:04:29  mclareni
* Increase cradle no. to 0.10
* Revision 1.9  1997/10/17 10:26:20  mclareni
* Increase cradle no. to 0.09
* Revision 1.8  1997/06/20 18:40:43  japost
*   Updating the version number after commiting several changes:
*   to gthion, gflufin, ghetun
*   Remaining problem: gdrawp, ghadr?
* Revision 1.7  1997/01/06 17:16:29  cernlib
* Remove ginit.F- and getver.F-
* Revision 1.6  1996/11/13 11:19:06  ravndal
* new cradle number /06
* Revision 1.5  1996/04/15 14:16:04  ravndal
* Slash instead of underscore
* Revision 1.4  1996/03/27 08:29:14  cernlib
* In line 40 the Hollerith had less than thespecified 40 characters.
* Time to get rid of these HOLLERITH
* Revision 1.3  1996/03/15 14:51:40  ravndal
* 96A version of GEANT
* Revision 1.2  1996/03/07 13:18:00  ravndal
* Preparing version number for 96A release
* Revision 1.1.1.1  1995/10/24 10:20:12  cernlib
* Geant

      SUBROUTINE GETVER(CHVER,CHDAT,HVERS)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Routine to get the current version number from a pam       *
C.    *     file. This routine is cracking the title given in          *
C.    *     HOLLERITH format, because CMZ and old versions of PATCHY   *
C.    *     do not support the character title sequence QFTITLCH       *
C.    *                                                                *
C.    *    ==>Called by : GINIT                                        *
C.    *       Author    F.Carminati *********                          *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*60 CHTIT
      CHARACTER*6 CHFOR
      CHARACTER*8 CHVER,CHDAT
*
      CHVER = ' '
      HVERS = 0.
      CHDAT = ' '
*
      WRITE(CHTIT,'(
     + 40H GEANT   3.21/13  15111999
     +)')
      DO 10 JSLASH=1,60
         IF(CHTIT(JSLASH:JSLASH).EQ.'/') THEN
            JSL=JSLASH
            GOTO 20
         ENDIF
   10 CONTINUE
      GOTO 999
*
   20 CONTINUE
      DO 30 JBLA=JSL,1,-1
         IF(CHTIT(JBLA-1:JBLA-1).EQ.' ') THEN
            JBEG=JBLA
            GOTO 40
         ENDIF
   30 CONTINUE
      GOTO 999
*
   40 CONTINUE
      DO 50 JBLA=JSL,60
         IF(CHTIT(JBLA+1:JBLA+1).EQ.' ') THEN
            JEND=JBLA
            GOTO 60
         ENDIF
   50 CONTINUE
      GOTO 999
*
   60 WRITE(CHFOR,'(''(F'',I1,''.2)'')') JSL-JBEG
      READ(CHTIT(JBEG:JSL-1),CHFOR) HMAIN
      READ(CHTIT(JSL+1:JEND),'(I2)')   ISUBV
      HVERS=HMAIN+ISUBV*.0001
      NCHA=JEND-JBEG+1
      CHVER=' '
      IF(NCHA.EQ.8) THEN
         CHVER=CHTIT(JBEG:JEND)
      ELSE
         CHVER=' '//CHTIT(JBEG:JEND)
      ENDIF
*
      CHDAT=CHTIT(JEND+3:JEND+11)
*
  999 END
+DECK,  GFFGO, T=FORT.
* Revision 1.2  1996/09/30 13:40:37  ravndal
* IABAN initialization
* Revision 1.1.1.1  1995/10/24 10:20:09  cernlib
* Geant

      SUBROUTINE GFFGO
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to define and read GEANT/FFREAD data cards       *
C.    *      If user data cards have been defined via FFKEY            *
C.    *      they will be read as well                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCPHYS.
+CDE, GCCUTS.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCLIST.
+CDE, GCPARM.
+CDE, GCSTAK.
+CDE, GCTIME.
+CDE, GCTRAK.
+CDE, GCMULO.
+CDE, GCSCAN.
+CDE, GCUNIT.
+CDE, GCOPTI.
+CDE, GCTMED.
+CDE, GCRZ.
C.
C.    ------------------------------------------------------------------
C.
      IABAN = NINT(DPHYS1)
      CALL FFKEY ('ANNI',IANNI , 1,'INTEGER')
      CALL FFKEY ('BREM',IBREM , 1,'INTEGER')
      CALL FFKEY ('COMP',ICOMP , 1,'INTEGER')
      CALL FFKEY ('CUTS',CUTGAM,16,'REAL')
      CALL FFKEY ('DEBU',IDEMIN, 3,'INTEGER')
      CALL FFKEY ('DCAY',IDCAY , 1,'INTEGER')
      CALL FFKEY ('DRAY',IDRAY , 1,'INTEGER')
      CALL FFKEY ('LABS',ILABS , 1,'INTEGER')
      CALL FFKEY ('GEOM',LGEOM ,20,'MIXED')
      CALL FFKEY ('GET ',LGET  ,20,'MIXED')
      CALL FFKEY ('HADR',IHADR , 1,'INTEGER')
      CALL FFKEY ('HSTA',LHSTA ,20,'MIXED')
      CALL FFKEY ('KINE',IKINE ,11,'MIXED')
      CALL FFKEY ('LOSS',ILOSS , 1,'INTEGER')
      CALL FFKEY ('MULS',IMULS , 1,'INTEGER')
      CALL FFKEY ('MUNU',IMUNU , 1,'INTEGER')
      CALL FFKEY ('PAIR',IPAIR , 1,'INTEGER')
*     CALL FFKEY ('PATR',NJTMAX, 4,'INTEGER')
      CALL FFKEY ('SORD',ISTORD, 1,'INTEGER')
      CALL FFKEY ('PFIS',IPFIS , 1,'INTEGER')
      CALL FFKEY ('PHOT',IPHOT , 1,'INTEGER')
      CALL FFKEY ('PLOT',LPLOT ,20,'MIXED')
      CALL FFKEY ('PRIN',LPRIN ,20,'MIXED')
      CALL FFKEY ('RAYL',IRAYL , 1,'INTEGER')
      CALL FFKEY ('RGET',LRGET ,20,'MIXED')
      CALL FFKEY ('RSAV',LRSAVE,20,'MIXED')
      CALL FFKEY ('RNDM',NRNDM , 2,'INTEGER')
      CALL FFKEY ('RUNG',IDRUN , 2,'INTEGER')
      CALL FFKEY ('SAVE',LSAVE ,20,'MIXED')
      CALL FFKEY ('SETS',LSETS ,20,'MIXED')
      CALL FFKEY ('STAT',LSTAT ,20,'MIXED')
      CALL FFKEY ('SWIT',ISWIT ,10,'INTEGER')
      CALL FFKEY ('TIME',TIMINT, 3,'MIXED')
      CALL FFKEY ('TRIG',NEVENT, 1,'INTEGER')
      CALL FFKEY ('VIEW',LVIEW ,20,'MIXED')
      CALL FFKEY ('ERAN',EKMIN , 3,'MIXED')
      CALL FFKEY ('AUTO',IGAUTO, 1,'INTEGER')
      CALL FFKEY ('OPTI',IOPTIM, 1,'INTEGER')
      CALL FFKEY ('CKOV',ITCKOV, 1,'INTEGER')
      CALL FFKEY ('SYNC',ISYNC,  1,'INTEGER')
      CALL FFKEY ('STRA',ISTRA,  1,'INTEGER')
      CALL FFKEY ('ABAN',IABAN,  1,'INTEGER')
*--------------- SCAN/Parametrize cards
      CALL FFKEY ('SCAN',SCANFL, 8,'MIXED')
      CALL FFKEY ('SCAL',ISLIST,MSLIST,'MIXED')
      CALL FFKEY ('SCAP',VSCAN , 6,'REAL')
      CALL FFKEY ('PCUT',IPARAM,  6,'MIXED')
      CALL FFKEY ('PNUM',MPSTAK,  2,'MIXED')
C
C             Now read data cards
C
      CALL FFGO
C
C             Get some parameters from the data cards
C
      CALL GETNUM (LHSTA ,NHSTA)
      CALL GETNUM (LGET  ,NGET)
      CALL GETNUM (LSAVE ,NSAVE)
      CALL GETNUM (LRGET ,NRGET)
      CALL GETNUM (LRSAVE,NRSAVE)
      CALL GETNUM (LSETS ,NSETS)
      CALL GETNUM (LPRIN ,NPRIN)
      CALL GETNUM (LGEOM ,NGEOM)
      CALL GETNUM (LVIEW ,NVIEW)
      CALL GETNUM (LPLOT ,NPLOT)
      CALL GETNUM (LSTAT ,NSTAT)
      CALL GETNUM (ISLIST,NSLIST)
*
      IF(ILABS.NE.0) THEN
         IF(ITCKOV.NE.0) ILABS=1
      ENDIF
*
      IF (NINT(DPHYS1).NE.IABAN) THEN
          DPHYS1 = IABAN
      END IF
*
      IF(MODTET.LT.1.OR.MODTET.GT.MAXMDT) THEN
         WRITE(LOUT,10000) MODTET
10000    FORMAT(' MODTET = ',I2,' out of range - 1 assumed')
         MODTET=1
      ENDIF
      TETMIN = TETMID(MODTET)
      TETMAX = TETMAD(MODTET)
      IF(IDEVT.GT.0)IDEVT=IDEVT-1
C
C             Set IDEBUG flag for initialisation phase
C
      IF(IDEMIN.LT.0.AND.IDEMAX.GE.0)THEN
         IDEMIN=-IDEMIN
         IDEBUG=1
      ENDIF
C
C             Initialise the random number generator
C
      IF(NRNDM(2).NE.0)THEN
         CALL GRNDMQ(NRNDM(1),NRNDM(2),1,'S')
      ELSEIF(NRNDM(1).GT.0)THEN
         ISEQ=NRNDM(1)
         CALL GRNDMQ(NRNDM(1),NRNDM(2),ISEQ,'Q')
         CALL GRNDMQ(NRNDM(1),NRNDM(2),ISEQ,'S')
      ENDIF
C
  999 END
+DECK,  GFHEAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:09  cernlib
* Geant

      SUBROUTINE GFHEAD (NWHEAD,IHEAD,NWBUF,UBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Retrieves the parameter of the Header bank               *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCFLAG.
*
      DIMENSION IHEAD(1),UBUF(1)
*
      IF (JHEAD.NE.0) THEN
         NWHEAD = IQ(JHEAD-1)
         DO 10 I=1,NWHEAD
            IHEAD(I) = IQ(JHEAD+I)
   10    CONTINUE
*
         NWBUF = 0
         IF (LQ(JHEAD-1).NE.0) THEN
            JHU = LQ(JHEAD-1)
            NWBUF = IQ(JHU-1)
            DO 20 I=1,NWBUF
               UBUF(I) = Q(JHU+I)
   20       CONTINUE
         ENDIF
*
      ELSE
         NWHEAD = 0
         WRITE(CHMAIL,1000) IEVENT
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GFHEAD: No Header bank in memory for ievent:',I7)
*
      END
+DECK,  GFHSTA, T=FORT.
* Revision 1.2  1997/10/24 16:17:42  mclareni
* NZLEFT 2nd parameter changed to 0 from blank
* Revision 1.1.1.1  1995/10/24 10:20:09  cernlib
* Geant

      SUBROUTINE GFHSTA
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Fills histograms statistics                              *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUOUT                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCLIST.
      COMMON/QUEST/IQUEST(100)
C.
C.    ------------------------------------------------------------------
C.
      IF(NHSTA.GT.0) THEN
         CALL GLOOK('TIME',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL TIMED(TEVENT)
            CALL HFILL(-ID,TEVENT,0.,1.)
         ENDIF
*
         CALL GLOOK('SIZE',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            NL=NZLEFT(IXDIV,0)
            CALL HFILL(-ID,IQUEST(11)+0.5,0.,1.)
         ENDIF
*
         CALL GLOOK('MULT',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL HFILL(-ID,NTMULT+0.5,0.,1.)
         ENDIF
*
         CALL GLOOK('NTRA',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL HFILL(-ID,NTRACK+0.5,0.,1.)
         ENDIF
*
         CALL GLOOK('STAK',LHSTA,NHSTA,ID)
         IF(ID.NE.0)THEN
            CALL HFILL(-ID,NSTMAX+0.5,0.,1.)
         ENDIF
*
      ENDIF
      END
+DECK,  GFRUNG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:10  cernlib
* Geant

      SUBROUTINE GFRUNG (NWRUNG,IRUNG,NWBUF,UBUF)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Retrieves the parameter of the RUNG   bank               *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
*
      DIMENSION IRUNG(1),UBUF(1)
*
      IF (JRUNG.NE.0) THEN
         NWRUNG = IQ(JRUNG-1)
         DO 10 I=1,NWRUNG
            IRUNG(I) = IQ(JRUNG+I)
   10    CONTINUE
*
         NWBUF = 0
         IF (LQ(JRUNG-1).NE.0) THEN
            JRU = LQ(JRUNG-1)
            NWBUF = IQ(JRU-1)
            DO 20 I=1,NWBUF
               UBUF(I) = Q(JRU+I)
   20       CONTINUE
         ENDIF
*
      ELSE
         NWRUNG = 0
         WRITE(CHMAIL,1000)
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GFRUNG: No RUNG bank existing in memory ')
*
      END
+DECK,  GGCLO2, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

+SELF, IF=OLD.
      SUBROUTINE GGCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Closes off the geometry setting.                            *
C.    *    Initializes the search list for the contents of each        *
C.    *    volume following the order they have been positioned, and   *
C.    *    inserting the content '0' when a call to GSNEXT (-1) has    *
C.    *    been required by the user.                                  *
C.    *    Performs the development of the JVOLUM structure for all    *
C.    *    volumes with variable parameters, by calling GGDVLP.        *
C.    *    Interprets the user calls to GSORD, through GGORD.          *
C.    *    Computes and stores in a bank (next to JVOLUM mother bank)  *
C.    *    the number of levels in the geometrical tree and the        *
C.    *    maximum number of contents per level, by calling GGNLEV.    *
C.    *    Sets status bit for CONCAVE volumes, through GGCAVE.        *
C.    *    Completes the JSET structure with the list of volume names  *
C.    *    which identify uniquely a given physical detector, the      *
C.    *    list of bit numbers to pack the corresponding volume copy   *
C.    *    numbers, and the generic path(s) in the JVOLUM tree,        *
C.    *    through the routine GHCLOS.                                 *
C.    *                                                                *
C.    *    Called by : <USER>                                          *
C.    *    Authors   : R.Brun, F.Bruyant  *********                    *
C.    *                                                                *
C.    *    Modified by S.Egli at 15.9.90: automatic sorting of volumes *
C     *    done by calling GGORDQ for each volume                      *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCLIST.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCOPTI.
      CHARACTER*4 NAME
      LOGICAL BTEST
C.
C.    ------------------------------------------------------------------
C.
*
* *** Stop the run in case of serious anomaly during initialization
*
      IF (IEORUN.NE.0) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         STOP
      ENDIF
*
      IF (NVOLUM.LE.0) THEN
         WRITE (CHMAIL, 1002) NVOLUM
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      NPUSH = NVOLUM -IQ(JVOLUM-2)
      CALL MZPUSH (IXCONS, JVOLUM, NPUSH, NPUSH,'I')
*
* *** Loop over volumes, create default JNear banks as relevant,
*      and release unused bank space
*
      IDO = 0
      DO 80 IVO = 1,NVOLUM
         JVO = LQ(JVOLUM-IVO)
*
* *** Check if Tracking medium has been defined
*
         NMED=Q(JVO+4)
         IF(NMED.LE.0.OR.NMED.GT.IQ(JTMED-2))THEN
            WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
            CALL GMAIL (0, 0)
         ELSE
            IF(LQ(JTMED-NMED).EQ.0)THEN
               WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
               CALL GMAIL (0, 0)
            ENDIF
         ENDIF
         IF (BTEST(IQ(JVO),0)) GO TO 80
         IDO = 1
         IQ(JVO) = IBSET(IQ(JVO),0)
         NINL  = IQ(JVO-2)
         NIN   = Q(JVO+3)
         NUSED = IABS(NIN)
         IF (NIN.GT.0) THEN
*           reserve enough additional space for sorted volumes
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
              NUSED=NUSED+1
            ELSE
              NUSED=NUSED+2
            ENDIF
         ENDIF
*
         NPUSH = NUSED -NINL
         DO 90 IN=NINL,NUSED+1,-1
            JIN = LQ(JVO-IN)
            IF(JIN.GT.0) THEN
               CALL MZDROP(IXCONS,JIN,'L')
            ENDIF
  90     CONTINUE
         CALL MZPUSH (IXCONS, JVO, NPUSH, 0, 'I')
         IF (NIN.LE.0) GO TO 80
*
         IF(BTEST(IQ(JVO),3)) THEN
            IZERO=1
         ELSE
            IZERO=0
         ENDIF
         NEL = NIN +IZERO
         JN = LQ(JVO-NIN-1)
         IF(JN.EQ.0) THEN
            CALL MZBOOK (IXCONS,JN,JVO,-NIN-1,'VONE',0,0,NEL+1,2,0)
         ENDIF
         IQ(JN-5) = IVO
         IQ(JN+1) = NEL
         JN = JN +1
         DO 29 I = 1,NIN
            IQ(JN+IZERO+I) = I
   29    CONTINUE
         IF (IZERO.NE.0) IQ(JN+1) = 0
*
   80 CONTINUE
*
      IF (IDO.NE.0) THEN
*
* ***    Perform development of JVOLUM structure where necessary
*
         CALL GGDVLP
*
* ***    Fill GSORD ordering banks if required
*
* Modified by S.Egli to allow GGORDQ to find the optimum sorting for
* all volumes
*
         IF(IOPTIM.GE.1)THEN
            WRITE(6,'(A)')' GGCLOS: Start automatic volume ordering:'
         ENDIF
         DO 91 IVO = 1,NVOLUM
            JVO = LQ(JVOLUM-IVO)
            NIN = Q(JVO+3)
            ISEARC=Q(JVO+1)
            IF(ISEARC.GT.0) GO TO 91
*           check if sorting not possible or not wanted
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
               Q(JVO+1)=0.
               IF(NIN.GT.500.AND.IOPTIM.GE.1)THEN
                 CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
                 WRITE (CHMAIL,1004) NAME,NIN
                 CALL  GMAIL (0, 0)
               ENDIF
            ELSEIF(IOPTIM.EQ.0)THEN
               IF(ISEARC.LT.0)CALL GGORD (IVO)
            ELSEIF(IOPTIM.EQ.1)THEN
               IF(ISEARC.EQ.0) THEN
                  CALL GGORDQ(IVO)
               ELSE
                  CALL GGORD (IVO)
               END IF
            ELSE
               CALL GGORDQ(IVO)
            ENDIF
   91    CONTINUE
*
* ***    Set status bit for concave volumes
*
         CALL GGCAVE
*
* ***    Compute maximum number of levels and of contents per level
*
         CALL GGNLEV
*
      ENDIF
*
* *** Scan the volume structure to retrieve the path through
*      the physical tree for all sensitive detectors
*
       CALL GHCLOS
*
* *** Books STAT banks if data card STAT is submitted
*
      IF (NSTAT.GT.0)  CALL GBSTAT
*
      CALL MZGARB (IXCONS, 0)
*
 1001 FORMAT (' Severe diagnostic in initialization phase. STOP')
 1002 FORMAT (' GGCLOS : NVOLUM =',I5,' *****')
 1003 FORMAT (' Illegal tracking medium number in volume : ',A4)
 1004 FORMAT (' GGORDQ : Volume ',A4,' has more than 500 (',
     +        I3,') daughters ; volume sorting not possible !')
*                                                             END GGCLOS
  999 END

+SELF.
+DECK,  GGCLOS, T=FORT.
* Revision 1.2  1997/11/14 17:44:00  mclareni
* Make sure the maximum angle is greater than the minimun
* Revision 1.1.1.1  1995/10/24 10:20:10  cernlib
* Geant

+SELF, IF=-OLD.
      SUBROUTINE GGCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Closes off the geometry setting.                            *
C.    *    Initializes the search list for the contents of each        *
C.    *    volume following the order they have been positioned, and   *
C.    *    inserting the content '0' when a call to GSNEXT (-1) has    *
C.    *    been required by the user.                                  *
C.    *    Performs the development of the JVOLUM structure for all    *
C.    *    volumes with variable parameters, by calling GGDVLP.        *
C.    *    Interprets the user calls to GSORD, through GGORD.          *
C.    *    Computes and stores in a bank (next to JVOLUM mother bank)  *
C.    *    the number of levels in the geometrical tree and the        *
C.    *    maximum number of contents per level, by calling GGNLEV.    *
C.    *    Sets status bit for CONCAVE volumes, through GGCAVE.        *
C.    *    Completes the JSET structure with the list of volume names  *
C.    *    which identify uniquely a given physical detector, the      *
C.    *    list of bit numbers to pack the corresponding volume copy   *
C.    *    numbers, and the generic path(s) in the JVOLUM tree,        *
C.    *    through the routine GHCLOS.                                 *
C.    *                                                                *
C.    *    Called by : <USER>                                          *
C.    *    Authors   : R.Brun, F.Bruyant, S.Giani  *********           *
C.    *                                                                *
C.    *    Modified by S.Giani for automatic initialization of the new *
C.    *    tracking based on virtual divisions (1993).                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCLIST.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCOPTI.
+CDE, GCHVIR.
      CHARACTER*4 NAME
      LOGICAL BTEST
C.
C.    ------------------------------------------------------------------
      dimension dx(3),tmpmax(7),ndivto(7),qualit(7),ivoaxi(7)
      data jfirst/0/
      save jfirst
      COMMON /QUEST/ IQUEST(100)
      COMMON/GCDINA/jphi2,jclow,jchig,jbuff
*
* *** Stop the run in case of serious anomaly during initialization
*
      IF (IEORUN.NE.0) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         STOP
      ENDIF
*
      IF (NVOLUM.LE.0) THEN
         WRITE (CHMAIL, 1002) NVOLUM
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      NPUSH = NVOLUM -IQ(JVOLUM-2)
      CALL MZPUSH (IXCONS, JVOLUM, NPUSH, NPUSH,'I')
*
* *** Loop over volumes, create default JNear banks as relevant,
*      and release unused bank space
*
      IDO = 0
      DO 80 IVO = 1,NVOLUM
         JVO = LQ(JVOLUM-IVO)
*
* *** Check if Tracking medium has been defined
*
         NMED=Q(JVO+4)
         IF(NMED.LE.0.OR.NMED.GT.IQ(JTMED-2))THEN
            WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
            CALL GMAIL (0, 0)
         ELSE
            IF(LQ(JTMED-NMED).EQ.0)THEN
               WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
               CALL GMAIL (0, 0)
            ENDIF
         ENDIF
         IF (BTEST(IQ(JVO),0)) GO TO 80
         IDO = 1
         IQ(JVO) = IBSET(IQ(JVO),0)
         NINL  = IQ(JVO-2)
         NIN   = Q(JVO+3)
         NUSED = IABS(NIN)
         IF (NIN.GT.0) THEN
*           reserve enough additional space for sorted volumes
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
              NUSED=NUSED+1
            ELSE
              NUSED=NUSED+2
            ENDIF
         ENDIF
*
         NPUSH = NUSED -NINL
         DO 90 IN=NINL,NUSED+1,-1
            JIN = LQ(JVO-IN)
            IF(JIN.GT.0) THEN
               CALL MZDROP(IXCONS,JIN,'L')
            ENDIF
  90     CONTINUE
         CALL MZPUSH (IXCONS, JVO, NPUSH, 0, 'I')
         IF (NIN.LE.0) GO TO 80
*
         IF(BTEST(IQ(JVO),3)) THEN
            IZERO=1
         ELSE
            IZERO=0
         ENDIF
         NEL = NIN +IZERO
         JN = LQ(JVO-NIN-1)
         IF(JN.EQ.0) THEN
            CALL MZBOOK (IXCONS,JN,JVO,-NIN-1,'VONE',0,0,NEL+1,2,0)
         ENDIF
         IQ(JN-5) = IVO
         IQ(JN+1) = NEL
         JN = JN +1
         DO 29 I = 1,NIN
            IQ(JN+IZERO+I) = I
   29    CONTINUE
         IF (IZERO.NE.0) IQ(JN+1) = 0
*
   80 CONTINUE
*
      IF (IDO.NE.0) THEN
*
* ***    Perform development of JVOLUM structure where necessary
*
         CALL GGDVLP
*
* ***    Fill GSORD ordering banks if required
*
* Modified by S.Egli to allow GGORDQ to find the optimum sorting for
* all volumes
*
         IF(IOPTIM.GE.1)THEN
            WRITE(6,'(A)')' GGCLOS: Start automatic volume ordering:'
         ENDIF
         DO 91 IVO = 1,NVOLUM
            JVO = LQ(JVOLUM-IVO)
            NIN = Q(JVO+3)
            ISEARC=Q(JVO+1)
            IF(ISEARC.GT.0) GO TO 91
*           check if sorting not possible or not wanted
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
               Q(JVO+1)=0.
               IF(NIN.GT.500.AND.IOPTIM.GE.1)THEN
                 CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
                 WRITE (CHMAIL,1004) NAME,NIN
                 CALL  GMAIL (0, 0)
               ENDIF
            ELSEIF(IOPTIM.EQ.0)THEN
               IF(ISEARC.LT.0)CALL GGORD (IVO)
            ELSEIF(IOPTIM.EQ.1)THEN
               IF(ISEARC.EQ.0) THEN
                  CALL GGORDQ(IVO)
               ELSE
                  CALL GGORD (IVO)
               END IF
            ELSE
               CALL GGORDQ(IVO)
            ENDIF
   91    CONTINUE
*
* ***    Set status bit for concave volumes
*
         CALL GGCAVE
*
* ***    Compute maximum number of levels and of contents per level
*
         CALL GGNLEV
*
      ENDIF
*
********************************************************************************
*
      if(jfirst.eq.0)then
        jfirst=1
        call mzlink(ixcons,'/GCHVIR/',jvirt,jvdiv,jcont)
        call mzlink(ixstor,'/GCDINA/',jphi2,jbuff,jphi2)
      endif
      jflag=0
      nwjvdi=0
      jphi2=0
      jclow=0
      jchig=0
      jbuff=0
      if(jvirt.ne.0)call mzdrop(ixcons,jvirt,' ')
      nwjvir=5*nvolum+20
      call mzneed(ixcons,nwjvir,'G')
      if(iquest(11).lt.0)then
          print *,'No space for jvirt bank'
      else
          call mzbook(ixcons,jvirt,jvirt,1,'VIRT',nvolum,nvolum,
     +              4*nvolum+20,0,0)
      endif
      dx(1)=0.
      dx(2)=0.
      dx(3)=0.
      ndivst=0
      ndioff=0
      ninmax=0
      do 101 ivo=1,nvolum
        jvo=lq(jvolum-ivo)
        call uhtoc(iq(jvolum+ivo),4,NAME,4)
*         print *,'VOLUME ',NAME
*         print *,' '
        nin=q(jvo+3)
        isearc=q(jvo+1)
*        if(nin.eq.0)then
*          print *,'No daughters.'
*        elseif(nin.lt.0)then
*          print *,'Divided volume.'
*        elseif(nin.le.1)then
*          print *,'Only 1 daughter.'
*        endif
 1      continue
        if(nin.gt.1)then
         if(jflag.eq.0)then
          if(iswit(9).eq.12345)then
            print *,'VOLUME ',NAME
            print *,' '
          endif
         endif
         if(jflag.eq.1)then
           q(jvirt+4*(ivo-1)+1)=itmpq
           iaxlo=itmpq
           iaxhi=itmpq
         else
           iaxlo=1
           iaxhi=7
         endif
          if(nin.gt.ninmax)then
           if(jphi2.ne.0)call mzdrop(ixstor,jphi2,' ')
           if(jclow.ne.0)call mzdrop(ixstor,jclow,' ')
           if(jchig.ne.0)call mzdrop(ixstor,jchig,' ')
           call mzbook(ixstor,jphi2,jphi2,2,'PHI2',0,0,
     +                 nin+20,2,-1)
           call mzbook(ixstor,jclow,jclow,2,'CLOW',0,0,
     +                 nin+20,3,-1)
           call mzbook(ixstor,jchig,jchig,2,'CHIG',0,0,
     +                 nin+20,3,-1)
           if(jflag.eq.1)then
             if(jbuff.ne.0)call mzdrop(ixstor,jbuff,' ')
             call mzbook(ixstor,jbuff,jbuff,2,'BUFF',0,0,
     +                   nin+20,2,-1)
           endif
          endif
         do 110 iaxis=iaxlo,iaxhi
          myphif=0
*          print *,'Quality search for axis ',iaxis
          ish=q(jvo+2)
          if(iaxis.le.3)then
            call gvdcar(iaxis,ish,0,q(jvo+7),clmoth,chmoth,ierr)
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          elseif(iaxis.le.5)then
            call gvdrad(iaxis,ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
             if(iaxis.eq.5)ierr=1
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          elseif(iaxis.eq.6)then
            call gvdphi(ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            elseif((chmoth-clmoth).gt.360..or.chmoth.gt.360)then
              print *,'(chmoth-clmoth).gt.360.or.chmoth.gt.360'
            elseif((chmoth-clmoth).eq.360.)then
              myphif=1
            endif
          elseif(iaxis.eq.7)then
            call gvdthe(ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
            ierr=1
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          endif
          if(jflag.eq.1)then
            q(jvirt+4*(ivo-1)+3)=clmoth
            q(jvirt+4*(ivo-1)+4)=chmoth
          endif
          thimot=abs(chmoth-clmoth)
          thimin=100000.
          do 102 in=1,nin
            iq(jphi2+in)=0
            jin=lq(jvo-in)
            call gvdlim(jvo,in,iaxis,clow,chigh,ierr)
            if(ierr.eq.1.or.(chigh.le.clow))then
*              if(ierr.eq.0)print *,'Error in gvdlim: corrected',iaxis
              clow=clmoth
              chigh=chmoth
            elseif(myphif.eq.1)then
              clowm=clow
              chighm=chigh
              sg=sign(1.0,clow)
              clow=mod(abs(clow),360.0)
              if(chigh.ne.360.0)then
               if(sg.le.0.0)clow=360.-clow
               sg=sign(1.0,chigh)
               chigh=mod(abs(chigh),360.0)
               if(sg.le.0.0)chigh=360.-chigh
              endif
              if(chigh.lt.clow)then
                chightf = clow
                clow = chigh
                chigh = chightf
                iq(jphi2+in)=1
              endif
            elseif(iaxis.eq.6.and.myphif.eq.0)then
             if((chigh-chmoth).gt..01.or.(clmoth-clow).gt..01)then
               if(clmoth.lt.0..and.clow.gt.0.)then
                clow=clow-360.
                chigh=chigh-360.
                if((chigh-chmoth).gt..01)then
                  chigh=chmoth
                  if(chigh.le.clow)clow=clmoth
                elseif((clmoth-clow).gt..01)then
                  clow=clmoth
                  if(clow.ge.chigh)chigh=chmoth
                endif
               elseif(chigh.lt.0..and.chmoth.gt.0.)then
                clow=clow+360.
                chigh=chigh+360.
                if((chigh-chmoth).gt..01)then
                  chigh=chmoth
                  if(chigh.le.clow)clow=clmoth
                elseif((clmoth-clow).gt..01)then
                  clow=clmoth
                  if(clow.ge.chigh)chigh=chmoth
                endif
               endif
             endif
            endif
            if((chigh-chmoth).gt..01)then
*** ONLY FOR DEBUG
*              print *,'iaxis =',iaxis,'protuding daughter',in
**              print *,'myphif =',myphif,'myphi2 =',iq(jphi2+in)
*              print *,'Dhigh=',chigh-chmoth
*              print *,'Dlow=',clmoth-clow
***
              chigh=chmoth
              if(chigh.le.clow)clow=clmoth
            elseif((clmoth-clow).gt..01)then
*** ONLY FOR DEBUG
*              print *,'iaxis =',iaxis,'protuding daughter',in
**              print *,'myphif =',myphif,'myphi2 =',iq(jphi2+in)
*              print *,'Dhigh=',chigh-chmoth
*              print *,'Dlow=',clmoth-clow
***
              clow=clmoth
              if(clow.ge.chigh)chigh=chmoth
            endif
            q(jclow+in)=clow
            q(jchig+in)=chigh
            if(iq(jphi2+in).eq.0)then
             tmpthi=abs(chigh-clow)
            else
             tmpthi=abs(chighm-clowm)
            endif
            if(thimin.gt.tmpthi)thimin=tmpthi
 102      continue
          if((thimin-thimot).gt.1)then
*            print *,'thimin.gt.thimot',thimin-thimot,'iax=',iaxis
            qualit(iaxis)=10000
            goto 110
          endif
          if(thimin.lt.0.04)thimin=0.04
          tmpndi=2.*thimot/thimin
          nditmp=tmpndi+1
*****          print *,nditmp,' divisions asked for ',nin,' daughters.'
*****           if(nditmp.lt.nin)then
*****             nditmp=nin
*****             print *,'Number of divisions corrected to be = ',nin
*****           endif
*****          if(nditmp.gt.1000.)print *,'1000 divisions are enough.'
          ndivto(iaxis)=min(nditmp,1000)
          if(jflag.eq.1)then
            q(jvirt+4*(ivo-1)+2)=ndivto(iaxis)
           jvdiv=lq(jvirt-ivo)
           if(jvdiv.ne.0)call mzdrop(ixcons,jvdiv,' ')
           nwvili=ndivto(iaxis)+ivoaxi(itmpq)+11
           nwjvdi=nwjvdi+nwvili
           call mzneed(ixcons,nwvili,'G')
           if(iquest(11).lt.0)then
            print *,'No space for jvdiv bank',ivo
           else
            call mzbook(ixcons,jvdiv,jvirt,-ivo,'VLIST',0,0,
     +                  nwvili,2,0)
           endif
          endif
          thisli=thimot/ndivto(iaxis)
          clslic=clmoth
          chslic=clmoth+thisli
          avelis=0.
          aveave=0.
          avesta=0.
          ii=0
          tmpmax(iaxis)=0.
          import=0
          if(jflag.eq.1)ioff=ndivto(iaxis)
          do 103 i=1,ndivto(iaxis)
            j=1
            do 104 in=1,nin
             if(iq(jphi2+in).eq.0)then
              if(q(jchig+in).ge.clslic.and.
     +           q(jclow+in).le.chslic)then
                j=j+1
                if(jflag.eq.1)then
                  iq(jbuff+j)=in
                endif
              endif
             else
              if(q(jchig+in).ge.clslic.or.
     +           q(jclow+in).le.chslic)then
                j=j+1
                if(jflag.eq.1)then
                  iq(jbuff+j)=in
                endif
              endif
             endif
 104        continue
            inbuf1=j-1
            if(jflag.eq.1)then
             if(i.gt.1.and.iq(jbuff+1).eq.(j-1))then
               if(j-1.eq.0)then
                 import=1
               elseif(j-1.eq.1)then
                 if(iq(jbuff+2).eq.iq(jvdiv+ioff-nposti+2))then
                   import=1
                 else
                   import=0
                 endif
               else
                import=1
                do 234 ijk=2,nposti-2
                 do 432 kji=2,nposti-2
                  if(iq(jbuff+ijk).eq.iq(jvdiv+ioff-nposti+kji))then
                    goto 234
                  endif
 432             continue
                 import=0
                 goto 235
 234            continue
 235            continue
               endif
               if(import.eq.1)then
                 iq(jvdiv+ioff-nposti+nposti)=i
                 iq(jvdiv+i)=ioff-nposti
                 goto 145
               endif
             else
               import=0
             endif
             iq(jbuff+1)=j-1
             nposti=j+2
             iq(jbuff+j+1)=i
             iq(jbuff+j+2)=i
             iq(jvdiv+i)=ioff
             do 144 m=1,nposti
               iq(jvdiv+ioff+m)=iq(jbuff+m)
 144         continue
             ioff=ioff+nposti
            else
             aveinc=j+2
             avesta=avesta+aveinc
            endif
 145        continue
            if(inbuf1.gt.tmpmax(iaxis))then
             tmpmax(iaxis)=inbuf1
            endif
            if(inbuf1.ne.0.)ii=ii+1
            avelis=avelis+inbuf1
            clslic=chslic
            chslic=clslic+thisli
 103      continue
          if(jflag.eq.1)then
             ndioff=ndioff+ioff
             if(iswit(9).eq.12345)then
              print *,'words booked =',nwvili,'; words used =',ioff
              print *,' '
          endif
*** ONLY FOR DEBUG
**             mymyof=0
**             do 2 mm=1,ndivto(iaxis)
**               myoff=iq(jvdiv+mm)
**              if(myoff.ne.mymyof)then
**               if(iq(jvdiv+myoff+1).eq.0)then
**                 print *,'Lower div =',iq(jvdiv+myoff+2)
**                 print *,'Upper div =',iq(jvdiv+myoff+3)
**               elseif(iq(jvdiv+myoff+1).eq.1)then
**                 print *,'Lower div =',iq(jvdiv+myoff+3)
**                 print *,'Upper div =',iq(jvdiv+myoff+4)
**               endif
**             endif
**               mymyof=iq(jvdiv+mm)
** 2           continue
***
          endif
          if(ii.eq.0)then
            print *,iaxis,'=iax: not filled divisions: error!'
            print *,' '
            aveave=10000
            avelis=10000
            goto 105
          endif
          if(jflag.eq.0)then
            ivoaxi(iaxis)=avesta
          endif
          aveave=avelis/ndivto(iaxis)
          avelis=avelis/ii
 105      continue
          qualit(iaxis)=avelis
*** ONLY FOR DEBUG
**      print *,'Max n. of objects per div = ',tmpmax(iaxis)
**      print *,'Aver. n. of obj. per not-empty div = ',avelis
**      print *,'Average n. of objects per div = ',aveave
**            print *,' '
***
 110     continue
        if(jflag.eq.0)then
         tmpq=10000
         tmpm=10000
         itmpq=0
         itmpm=0
         do 111 iaxis=1,7
          if(qualit(iaxis).lt.tmpq)then
           tmpq=qualit(iaxis)
           itmpq=iaxis
          endif
          if(tmpmax(iaxis).lt.tmpm)then
           tmpqm=tmpmax(iaxis)
           itmpm=iaxis
          endif
 111     continue
         if(iswit(9).eq.12345)then
          print *,'nin=',nin,' iax=',itmpq,' ndiv=',ndivto(itmpq)
          print *,'Max n. of objects per div = ',tmpmax(itmpq)
          print *,'Average n. of objects per div = ',tmpq
         endif
*** ONLY FOR DEBUG
**         if(isearc.lt.0)then
**           jsb=lq(lq(jvo-nin-1))
**           iaxor=q(jsb+1)
**           ndivor=q(jsb+2)-1
**           jsco=lq(jvo-nin-2)
**           tmpqor=0.
**           tmpmor=0.
**           do 133 idivor=1,ndivor
**             if(iq(jsco+idivor).gt.tmpmor)tmpmor=iq(jsco+idivor)
**             tmpqor=tmpqor+iq(jsco+idivor)
** 133       continue
**           tmpqor=tmpqor/ndivor
**           print *,'Gsord: iax=',iaxor,' ndiv=',ndivor
**           print *,'Gsord: Max n. of obj. per div = ',tmpmor
**           print *,'Gsord: Aver. n. of obj. per div = ',tmpqor
**         endif
***
         ndivst=ndivst+(ndivto(itmpq)+ndivto(itmpq)*(3.+tmpq)+10.)
         jflag=1
         goto 1
        else
          jflag=0
*** ONLY FOR DEBUG
**          print *,'nin=',nin,' iax=',q(jvirt+4*(ivo-1)+1),' ndiv=',
**     +q(jvirt+4*(ivo-1)+2)
**          ittmp=0
**          iind=q(jvirt+4*(ivo-1)+2)
**          do 155 n=1,iind
**           jvdiv=lq(jvirt-ivo)
**           iofset=iq(jvdiv+n)
**           nnobj=iq(jvdiv+iofset+1)
**           if(nnobj.gt.ittmp)ittmp=nnobj
** 155      continue
**          print *,'Max n. of objects per div = ',ittmp
**          print *,' '
**          print *,' '
***
        endif
        endif
        if(nin.gt.ninmax)ninmax=nin
 101  continue
       nwtota=ndivst+nvolum*5+10.
       if(iswit(9).eq.12345)then
        print *,'Computed number of words foreseen = ',nwtota
       endif
       nwreal=nwjvir+nwjvdi
       if(iswit(9).eq.12345)then
        print *,'Computed number of words booked = ',nwreal
       endif
       nwneed=nwjvir+ndioff
       if(iswit(9).eq.12345)then
        print *,'Computed number of words needed = ',nwneed
       endif
       if(jphi2.ne.0)call mzdrop(ixstor,jphi2,' ')
       if(jclow.ne.0)call mzdrop(ixstor,jclow,' ')
       if(jchig.ne.0)call mzdrop(ixstor,jchig,' ')
       if(jbuff.ne.0)call mzdrop(ixstor,jbuff,' ')
*
********************************************************************************
*
* *** Scan the volume structure to retrieve the path through
*      the physical tree for all sensitive detectors
*
       CALL GHCLOS
*
* *** Books STAT banks if data card STAT is submitted
*
      IF (NSTAT.GT.0)  CALL GBSTAT
*
      CALL MZGARB (IXCONS, 0)
*
 1001 FORMAT (' Severe diagnostic in initialization phase. STOP')
 1002 FORMAT (' GGCLOS : NVOLUM =',I5,' *****')
 1003 FORMAT (' Illegal tracking medium number in volume : ',A4)
 1004 FORMAT (' GGORDQ : Volume ',A4,' has more than 500 (',
     +        I3,') daughters ; volume sorting not possible !')
*                                                             END GGCLOS
  999 END

+SELF.
+DECK,  GHCLOS, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:10  cernlib
* Geant

      SUBROUTINE GHCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *        SUBR. GHCLOS                                            *
C.    *                                                                *
C.    *   For every sensitive detector, calls GGDETV in order to       *
C.    *   complete the JD bank with the list of volume names which     *
C.    *   permit to identify uniquely a given physical detector, the   *
C.    *   list of bit numbers to pack the corresponding volume copy    *
C.    *   numbers,  and the generic path(s) through the JVOLUM tree.   *
C.    *                                                                *
C.    *   Called by : GGCLOS, <USER>                                   *
C.    *   Author    : F.Bruyant                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
*
      IF (JSET.NE.0) THEN
*
* ***   Scan the volume structure to retrieve the path through
*       the physical tree for all sensitive detectors
*
        NSET = IQ(JSET-1)
        DO 20 ISET=1,NSET
          JS = LQ(JSET-ISET)
          NDET = IQ(JS-1)
          DO 10 IDET=1,NDET
            CALL GGDETV (ISET, IDET)
   10     CONTINUE
   20   CONTINUE
      ENDIF
*                                                             END GHCLOS
      END
+DECK,  GINIT, T=FORT.
* Revision 1.4  1996/09/30 14:25:31  ravndal
* Windows NT related modifications
* Revision 1.3  1996/04/15 14:14:55  ravndal
* PATCHY does not set date and time any more
* Revision 1.2  1996/03/13 17:20:42  ravndal
* Mod's for the parallel version
* Revision 1.1.1.1  1995/10/24 10:20:10  cernlib
* Geant

      SUBROUTINE GINIT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       GEANT initialisation routine                             *
C.    *                                                                *
C.    *         IFINIT(1)=1 free                                       *
C.    *               (2)=1 if GZINIT   "  "                           *
C.    *               (3)=1 if GLUND or GLUNDI have been called        *
C.    *               (4)=1 if GHEINI or GPGHEI have been called       *
C.    *               (5)=1 if GHCASC has been called                  *
C.    *               (6)=1 if GLUDKY has been called                  *
C.    *               (7)=1 if GTAU  "   "                             *
C.    *               (8)=1 if GPRELA                                  *
C.    *               (9)=1 if GPCXYZ                                  *
C.    *              (10)=1 if GDRAW                                   *
C.    *              (11)=1 if INIT_GMR                                *
C.    *              (12)=1 if GET_GEANT_STRUCTURE                     *
C.    *              (13)=1 if GPIONS                                  *
C.    *              (14)=1 if GDINIT                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCLIST.
+CDE, GCSETS.
+CDE, GCONSP.
+CDE, GCPUSH.
+CDE, GCTIME.
+CDE, GCPHYS.
+CDE, GCPARM.
+CDE, GCCUTS.
+CDE, GCFLAG.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMULO.
+CDE, GCSCAN.
+CDE, GCOPTI.
+CDE, GCNUM.
+CDE, GCSTAK.
+CDE, GCTRAK.
+CDE, GCUNIT.
+CDE, GCVOLU.
+CDE, GCTMED.
+CDE, GCRZ.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
*
*     COMMON/GCONST/PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS
*     COMMON/GCONSX/EMMU,PMASS,AVO
      COMMON/GCONST/CONS1(8)
      COMMON/GCONSX/CONS2(3)
+SELF, IF=USRJMP.
      EXTERNAL      GUDCAY, GUDIGI, GUDTIM, GUFLD , GUHADR, GUIGET,
     +              GUINME, GUINTI, GUKINE, GUNEAR, GUOUT , GUPHAD,
     +              GUSKIP, GUSTEP, GUSWIM, GUTRAK, GUTREV, GUVIEW,
     +              GUPARA
+SELF.
C
C             ZEBRA system common blocks
C
      COMMON /ZHEADP/IQHEAD(20),IQDATE,IQTIME,IQPAGE,NQPAGE(4)
      COMMON /ZMACH/ NQBITW,NQBITC,NQCHAW,NQLNOR,NQLMAX,NQLPTH,NQRMAX
     +,              IQLPCT,IQNIL
      COMMON /ZSTATE/QVERSN,NQPHAS,IQDBUG,NQDCUT,NQWCUT,NQERR
     +,              NQLOGD,NQLOGM,NQLOCK,NQDEVZ,NQAUGM(6)
      COMMON /ZUNIT/ IQREAD,IQPRNT,IQPR2,IQLOG,IQPNCH,IQTTIN,IQTYPE
C
      CHARACTER*4 MEC(MAXMEC),MEC1(MAXME1),DFLT(2)
      CHARACTER*8 CHVERS,CHDATE

      CHARACTER*4 CDUMMY
+SELF, IF=MONITOR.
      CHARACTER*32 CHINFO
+SELF.
      PARAMETER (LEFTM1=MAXME1-9)
      SAVE LOAD
      DATA LOAD/0/
      DATA  DFLT /'    ','XXXX'/
      DATA MEC/'NEXT','MULS','LOSS','FIEL','DCAY','PAIR','COMP','PHOT'
     +        ,'BREM','DRAY','ANNI','HADR','ECOH','EVAP','FISS','ABSO'
     +        ,'ANNH','CAPT','EINC','INHE','MUNU','TOFM','PFIS','SCUT'
     +        ,'RAYL','PARA','PRED','LOOP','NULL','STOP'/
      DATA MEC1/'LABS','LREF','SMAX','SCOR','CKOV','REFL','REFR',
     +          'SYNC','STRA',LEFTM1*'    '/
C.
C.    ------------------------------------------------------------------
C.
C
+SELF, IF=PARA.
      CALL GPINIT()
+SELF.
      IDATQQ = 0
      ITIMQQ = 0
      CALL GETVER(CHVERS,CHDATE,GVERSN)
      ZVERSN = QVERSN
      IGDATE = IQDATE
      IGTIME = IQTIME
      LIN    = IQREAD
      IF(IQTTIN.NE.0) LIN=IQTTIN
      LOUT   = IQPRNT
C
      WRITE (CHMAIL,10100) CHVERS,CHDATE
      CALL GMAIL(0,0)
*
      GVERSC = 0.0
+CDE, GVERSC.
* Ignoring t=pass
      IF (GVERSC.NE.0.0) THEN
         WRITE (CHMAIL,10200) GVERSC
         CALL GMAIL(0,0)
      ENDIF
+SELF, IF=MONITOR.
*
      WRITE(CHINFO,10000) GVERSN, GVERSC
10000 FORMAT(' Version/Cradle: ',F7.4,'/',F7.4)
      CALL GEAMON(1,CHINFO)
+SELF.
C      Since conversion to CVS library handling, this
C      is ommitted because PATCHY does not anymore
C      set IDATQQ, ITIMQQ
C	
C      WRITE(CHMAIL,10300)IDATQQ,ITIMQQ
C      CALL GMAIL(0,1)
C
+SELF, IF=USRJMP.
      JUDCAY = JUMPAD(GUDCAY)
      JUDIGI = JUMPAD(GUDIGI)
* GUDTIM is a function
      JUFLD  = JUMPAD(GUFLD)
      JUHADR = JUMPAD(GUHADR)
      JUIGET = JUMPAD(GUIGET)
      JUINME = JUMPAD(GUINME)
      JUINTI = JUMPAD(GUINTI)
      JUKINE = JUMPAD(GUKINE)
      JUNEAR = JUMPAD(GUNEAR)
      JUOUT  = JUMPAD(GUOUT)
      JUPHAD = JUMPAD(GUPHAD)
      JUSKIP = JUMPAD(GUSKIP)
      JUSTEP = JUMPAD(GUSTEP)
      JUSWIM = JUMPAD(GUSWIM)
      JUTRAK = JUMPAD(GUTRAK)
      JUTREV = JUMPAD(GUTREV)
      JUVIEW = JUMPAD(GUVIEW)
      JUPARA = JUMPAD(GUPARA)
+SELF.
C
      CALL FFINIT(0)
      NBIT   = NQBITW
      CALL UCTOH(DFLT,IDFLT,4,4)
      CONS1( 1) = PI
      CONS1( 2) = TWOPI
      CONS1( 3) = PIBY2
      CONS1( 4) = DEGRAD
      CONS1( 5) = RADDEG
      CONS1( 6) = CLIGHT
      CONS1( 7) = BIG
      CONS1( 8) = EMASS
      CONS2( 1) = EMMU
      CONS2( 2) = PMASS
      CONS2( 3) = AVO
      DO 10 J=1,MXGKIN
         TOFD(J)  = 0.
         IFLGK(J) = 0
   10 CONTINUE
C
      IGAUTO= 1
      IPAIR = 1
      ICOMP = 1
      IPHOT = 1
      IRAYL = 0
      IBREM = 1
      IHADR = 1
      IANNI = 1
      IDRAY = 1
      IMUNU = 1
      IPFIS = 0
      IDCAY = 1
      ILOSS = 2
      IMULS = 1
      ILABS = -1
      ITCKOV = 0
      ISYNC = 0
      ISTRA = 0
C
      IABAN = 1
      DPHYS1 = IABAN
C
      CUTGAM = 0.001
      CUTELE = 0.001
      CUTHAD = 0.01
      CUTNEU = 0.01
      CUTMUO = 0.01
      TOFMAX = BIG
      DO 20 J=1,5
         GCUTS(J) = 0.
   20 CONTINUE
C
C               The following cuts can be changed by data card CUTS
C               If they are now changed, then the routine GPHYSI
C               will change them respectively to
C               BCUTE=CUTGAM,BCUTM=CUTGAM, DCUTE=CUTELE, DCUTM=CUTELE
C               and PPCUTM=4.*EMASS
C
      DCUTE = BIG
      DCUTM = BIG
      BCUTE = BIG
      BCUTM = BIG
      PPCUTM= BIG
      ISTPAR= 1
      IOPTIM= 0
C
      NCVERT =  5
      NCKINE =  50
      NCJXYZ = 100
      NPVERT = 5
      NPKINE = 10
      NPJXYZ = 200
C
      IKINE = 0
      DO 30 J=1,10
         PKINE(J) = BIG
   30 CONTINUE
      CALL VZERO (IHSET,26)
      CALL VZERO (NHSTA,9)
      CALL VFILL (LHSTA, 180, IDFLT)
      CALL VFILL (LRGET,  40, IDFLT)
      CALL VZERO (NUNITS,6)
      CALL VZERO (IDEBUG,42)
      CALL VZERO (NMATE,9)
      CALL VZERO (NLEVEL,306)
      NALIVE = 0
      NTMSTO = 0
      NJTMAX = 0
      NJTMIN = 0
      NTSTKP = 500
      NTSTKS = 100
*
*-------- Scan parameters defaults
      SCANFL = .FALSE.
      NPHI   = 90
      PHIMIN = 0.
      PHIMAX = 360.
      IPHI1  = 1
      IPHIL  = NPHI
      NTETA  = 90
      TETMID(1) = -10.
      TETMID(2) = 0.
      TETMID(3) = -1.
      TETMAD(1) =  10.
      TETMAD(2) = 180.
      TETMAD(3) = 1.
      MODTET = 1
      CALL VFILL (ISLIST,MSLIST,IDFLT)
      CALL UCTOH(DFLT(2),ISLIST(1),4,4)
      NSLIST = 1
      VSCAN(1) = 0.
      VSCAN(2) = 0.
      VSCAN(3) = 0.
      FACTX0 = 100.
      FACTL  = 10.
      FACTSF = 100.
      FACTR  = 100.
*---      Parametrization cut=0 means no parametrization
      IPARAM  = 0
      DO 40 J=1,5
         PACUTS(J) = 0.
   40 CONTINUE
*---      Size for the primary parametrization stak
      MPSTAK = 1000
*---      Number of particles generated for every shower
      NPGENE = 20
*-------- Scan parameters defaults
C
      RZTAGS(1)='STRUCTUR'
      RZTAGS(2)='TRIG-NR '
      RZTAGS(3)='RUNG-NRT '
      RZTAGS(4)='USER-ID '
      NRGET  = 0
      NRSAVE = 0
      NRECRZ = 1000
C
      IPAOLD =-1
      NUMOLD = 0
C
      IEVENT = 0
      IDRUN  = 1
      NHEAD  = 10
      NTMED  = 100
      NMATE  = 100
      NROTM  = 100
      NPART  = 100
      NEVENT = 10000000
C
      TIMINT = 0.
      TIMEND = 1.
      ITIME  = 1
C
      CALL UCTOH(MEC,NAMEC,4,MAXMEC*4)
      CALL UCTOH(MEC1,NAMEC1,4,MAXME1*4)
      MAXNST=10000
C
C             Constants for energy loss and physics processes
C
      UPWGHT=1.
      NEKBIN=90
      NEK1=NEKBIN+1
      EKMIN=1.E-5
      EKMAX=1.E+4
C
C             Initialize Random number generator
C
      NRNDM(1) = 0
      NRNDM(2) = 0
      CALL GRNDMQ(0,0,1,' ')
+SELF, IF=PARA.
      CALL GPDEFRNG(1)
+SELF.
C
C             Constants for multiple scattering (GMUL)
C
      DXM=TWOPI/100.
      XM=-0.5*DXM
      SQ=-0.0099999
      DO 50 I=1,101
         SQ=SQ+0.01
         IF(I.LT.101)SQRMUL(I)=SQRT(-2.*LOG(SQ))
         XM=XM+DXM
         SINMUL(I)=SIN(XM)
   50 COSMUL(I)=COS(XM)
      SQRMUL(101)=0.01
C
C               This piece of code to force loading of default
C               routines from the GEANG file on some machines
C               like VAX.
C
      IF(LOAD.NE.0)THEN
         CALL GWORK (IP1)
+SELF, IF=-USRJMP.
         CALL GUDCAY
         CALL GUDIGI
         CALL GUDTIM( P2, P3,IP4, P4)
         CALL GUFLD ( P1, P2)
         CALL GUHADR
         CALL GUIGET(IP1,IP2,IP3)
         CALL GUINME( P1, P2, P3,IP4)
         CALL GUINTI
         CALL GUKINE
         CALL GUNEAR(IP1,IP2, P3,IP4)
         CALL GUOUT
         CALL GUPHAD
         CALL GUSKIP(IP1)
         CALL GUSTEP
         CALL GUSWIM( P1, P2, P3, P4)
         CALL GUTRAK
         CALL GUTREV
         CALL GUVIEW(IP1,IP2,CDUMMY,IP4)
         CALL GUPARA
+SELF.
      ENDIF
C
10100 FORMAT('1*****  GEANT Version ',A8,' Released on ',A8)
10200 FORMAT('0*****  Correction Cradle Version ',F7.4)
10300 FORMAT(' *****  Library compiled on ',I6,' at ',I4,' *****')
      END
+DECK,  GLAST, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:10  cernlib
* Geant

      SUBROUTINE GLAST
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       TERMINATION ROUTINE                                      *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGLAST                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCTIME.
C.
C.    ------------------------------------------------------------------
C.
      WRITE (CHMAIL,1000) IEVENT
      CALL GMAIL(0,0)
C
      CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'G')
C
      WRITE (CHMAIL,3000) NRNDM
      CALL GMAIL(0,0)
C
C             COMPUTE ONE EVENT PROCESSING TIME
C
      IF(IEVENT.GT.0)THEN
         CALL TIMEL(TIMLFT)
         XMEAN  = (TIMINT - TIMLFT)/IEVENT
         WRITE(CHMAIL,4000)XMEAN
         CALL GMAIL(0,2)
      ENDIF
C
C             Print ZEBRA statistics
C
      CALL MZEND
C
C             Print statistics
C
      IF(JGSTAT.NE.0)CALL GPSTAT
+SELF, IF=MONITOR.
C
C             Call monitoring routine
C
      CALL GEAMON(2,'GLAST')
+SELF.
C
 1000 FORMAT('1',9X,'**** NUMBER OF EVENTS PROCESSED =',I10)
 3000 FORMAT(10X,'**** RANDOM NUMBER GENERATOR AFTER'
     +,' LAST COMPLETE EVENT ',2I12)
 4000 FORMAT(10X,'**** TIME TO PROCESS ONE EVENT IS =',F10.4,
     +      ' SECONDS')
      END
+DECK,  GLOOK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:10  cernlib
* Geant

      SUBROUTINE GLOOK(NAME,IVECT,N,ILOOK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Search position ILOOK of element NAME in array IVECT     *
C.    *       of length N                                              *
C.    *                                                                *
C.    *    ==>Called by : many GEANT and GEANG routines                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      DIMENSION IVECT(1)
      CHARACTER*(*) NAME
C.
C.    ------------------------------------------------------------------
C.
      CALL UCTOH(NAME,NAMEH,4,4)
      ILOOK=IUCOMP(NAMEH,IVECT,N)
C
      END
+DECK,  GMAIL, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GMAIL(LINBEF,LINAFT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Send a mail on the output device (usually unit LOUT)     *
C.    *       The mail is in character array CHMAIL of /GCMAIL/        *
C.    *       Max length is 132 chars and trailing blanks are stripped *
C.    *       LINBEF lines are skipped before mail and LINAFT after    *
C.    *                                                                *
C.    *    ==>Called by : many routines                                *
C.    *       Authors : R.Brun, P.Zanarini   *********                 *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCUNIT.
C.
C.    ------------------------------------------------------------------
C.
      DO 10 I=1,LINBEF
        WRITE (LOUT,1000)
   10 CONTINUE
      DO 20 NCH=132,1,-1
        IF (CHMAIL(NCH:NCH).NE.' ') GO TO 30
   20 CONTINUE
      NCH=1
   30 CONTINUE
      WRITE (LOUT,2000) CHMAIL(1:NCH)
      DO 40 I=1,LINAFT
        WRITE (LOUT,1000)
   40 CONTINUE
 1000 FORMAT (1X)
 2000 FORMAT (A)
      END
+DECK,  GPHEAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GPHEAD
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints Header bank JHEAD                                 *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    M.Maire                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCFLAG.
*
      IF (JHEAD.NE.0) THEN
         NHEAD = IQ(JHEAD-1)
         WRITE (CHMAIL,1000) (IQ(JHEAD+I),I=1,4)
         CALL GMAIL(0,0)
         WRITE (CHMAIL,1001) (IQ(JHEAD+I),I=5,NHEAD)
         CALL GMAIL(0,0)
         IF (LQ(JHEAD-1).NE.0) THEN
             WRITE(CHMAIL,2000)
             CALL GMAIL(0,0)
             JHU = LQ(JHEAD-1)
             NDT = IQ(JHU-1)
             NW  = MIN(NDT,9)
             WRITE(CHMAIL,3000) (Q(JHU+I),I=1,NW)
   15        CALL GMAIL(0,0)
             IF ((NDT-NW).GT.0) THEN
                NS = NW+1
                NW = MIN(NDT,NW+9)
                WRITE(CHMAIL,3000) (Q(JHU+I),I=NS,NW)
                GO TO 15
             ENDIF
         ENDIF
      ELSE
         WRITE(CHMAIL,4000) IEVENT
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GPHEAD: IDRUN=',I4,' IDEVT=',I7,
     &       ' Random Seeds = ',I10,2X,I10)
 1001 FORMAT(20X,10I10)
 2000 FORMAT(14X,'User words')
 3000 FORMAT( 1X,9(2X,E12.5))
 4000 FORMAT(' **** GPHEAD: No Header bank in memory for ievent:',I7)
*
      END
+DECK,  GPRINT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GPRINT(CHNAME,NUMB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to print data structures                         *
C.    *                                                                *
C.    *       CHNAME   name of a data structure                        *
C.    *       NUMB     data structure number                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT  ,<GXINT> GINC4               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
      CHARACTER*4 KNAMES(11),NAME
      DIMENSION NHAMES(11)
      CHARACTER*(*) CHNAME
      SAVE IFIRST,KNAMES,NHAMES
      DATA IFIRST/0/
      DATA KNAMES/'DIGI','JXYZ','HITS','KINE','MATE','VOLU'
     +           ,'ROTM','SETS','TMED','PART','VERT'/
C.
C.    ------------------------------------------------------------------
C.
      NAME=CHNAME
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL UCTOH(KNAMES,NHAMES,4,44)
      ENDIF
C
      CALL GLOOK(NAME,NHAMES,11,JUMP)
C
      IF(JUMP.EQ. 1) CALL GPDIGI ('*','*')
      IF(JUMP.EQ. 2) CALL GPJXYZ (NUMB)
      IF(JUMP.EQ. 3) CALL GPHITS ('*','*')
      IF(JUMP.EQ. 4) CALL GPKINE (NUMB)
      IF(JUMP.EQ. 5) CALL GPMATE (NUMB)
      IF(JUMP.EQ. 6) CALL GPVOLU (NUMB)
      IF(JUMP.EQ. 7) CALL GPROTM (NUMB)
      IF(JUMP.EQ. 8) CALL GPSETS ('*','*')
      IF(JUMP.EQ. 9) CALL GPTMED (NUMB)
      IF(JUMP.EQ.10) CALL GPPART (NUMB)
      IF(JUMP.EQ.11) CALL GPVERT (NUMB)
C
      END
+DECK,  GPRUNG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GPRUNG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Prints Rung bank JRUNG                                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    M.Maire                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
*
      IF (JRUNG.NE.0) THEN
         NRUNG = IQ(JRUNG-1)
         WRITE (CHMAIL,1000) (IQ(JRUNG+I),I=1,10)
         CALL GMAIL(0,0)
         WRITE (CHMAIL,1001) (IQ(JRUNG+I),I=11,20)
         CALL GMAIL(0,0)
         WRITE (CHMAIL,1002) ( Q(JRUNG+I),I=21,30)
         CALL GMAIL(0,0)
         IF (LQ(JRUNG-1).NE.0) THEN
             WRITE(CHMAIL,2000)
             CALL GMAIL(0,0)
             JRU = LQ(JRUNG-1)
             NDT = IQ(JRU-1)
             NW  = MIN(NDT,9)
             WRITE(CHMAIL,3000) (Q(JRU+I),I=1,NW)
   15        CALL GMAIL(0,0)
             IF ((NDT-NW).GT.0) THEN
                NS = NW+1
                NW = MIN(NDT,NW+9)
                WRITE(CHMAIL,3000) (Q(JRU+I),I=NS,NW)
                GO TO 15
             ENDIF
         ENDIF
      ELSE
         WRITE(CHMAIL,4000)
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GPRUNG: IDRUN=',I4,2X,9I7)
 1001 FORMAT(20X,10I10)
 1002 FORMAT(20X,10F10.4)
 2000 FORMAT(14X,'User words')
 3000 FORMAT( 1X,9(2X,E12.5))
 4000 FORMAT(' **** GPRUNG: No Rung bank existing in memory ')
*
      END
+DECK,  GRUN, T=FORT.
*CMZ :          03/11/94  15.43.38  by  John Apostolakis CERN GP-MIMD 2
*-- Author :
      SUBROUTINE GRUN
*.
*.    ******************************************************************
*.    *                                                                *
*.    *       Steering routine to process all the events               *
*.    *                                                                *
*.    *    ==>Called by : <USER>, main program                         *
*.    *       Author    R.Brun  *********                              *
*.    *                                                                *
*.    ******************************************************************
*.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCTIME.

+SELF, IF=PARA.
+CDE, MULTIPROX.
+SELF.

      SAVE IFIRST
      DATA IFIRST/0/
*.
*.    ------------------------------------------------------------------
*.
*             Keep starting time
*
      IF(IFIRST.EQ.0)THEN
         IFIRST=1
         CALL TIMEL(TIMINT)
      ENDIF
+SELF, IF=PARA.
*      Parallel : Does not change nevent on nodes - using it as maximum
*                   number that one node can process and regulating
*                   end by end of input file ...
*                 For programs that have no input file, gprun should
*                   divide the total number of events evenly between tasks.
*
      call gprun
*
+SELF.
   10 IF(IEVENT.LT.NEVENT) THEN
         IEVENT=IEVENT+1
*
*             Initialises event partition
*
         CALL GTRIGI
*
*             Process one event (trigger)
*
         CALL GTRIG
*
*             Clear event partition
*
         CALL GTRIGC
*
         IF(IEORUN.EQ.0) THEN
*
*             Check time left
*
            IF(ITIME.LE.0)GO TO 10
            IF(MOD(IEVENT,ITIME).NE.0)GO TO 10
            CALL TIMEL(TIMNOW)
            IF(TIMNOW.GT.TIMEND)GO TO 10
            WRITE(CHMAIL,10000)TIMEND
            CALL GMAIL(0,2)
            IEORUN = 1
         ENDIF
      ENDIF
*
10000 FORMAT(5X,'***** THE JOB STOPS NOW BECAUSE THE TIME LEFT IS LESS',
     +' THAN     ',F8.3,' SECONDS *****')
      END
+DECK,  GSHEAD, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GSHEAD (NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in HEADER user bank.          *
C     *       IADR is the stating location in the bank                 *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
+CDE, GCFLAG.
*
      DIMENSION UBUF(1)
*
      IF (JHEAD.GT.0) THEN
*
         NDATA = IADR + NWBUF
         IF (LQ(JHEAD-1).EQ.0) THEN
            CALL MZBOOK (IXDIV,JHU,JHEAD,-1,'HEDU',0,0,NDATA,3,0)
         ELSE
            JHU = LQ(JHEAD-1)
            NFREE = IQ(JHU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXDIV,JHU,0,-NFREE,'I')
         ENDIF
*
         DO  10 I=1,NWBUF
            Q(JHU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
      ELSE
*
         IADR = 0
         WRITE(CHMAIL,1000) IEVENT
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSHEAD: No Header bank in memory for ievent:',I7)
*
      END
+DECK,  GSRUNG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GSRUNG (NWBUF,UBUF,IADR)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Stores User's informations in RUNG user bank.            *
C     *       IADR is the stating location in the bank                 *
C     *                                                                *
C     *       on output IADR is the new starting location              *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author     M.Maire                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCUNIT.
*
      DIMENSION UBUF(1)
*
      IF (JRUNG.GT.0) THEN
*
         NDATA = IADR + NWBUF
         IF (LQ(JRUNG-1).EQ.0) THEN
            CALL MZBOOK (IXCONS,JRU,JRUNG,-1,'RUNU',0,0,NDATA,3,0)
         ELSE
            JRU = LQ(JRUNG-1)
            NFREE = IQ(JRU-1) - NDATA
            IF (NFREE.LT.0) CALL MZPUSH (IXCONS,JRU,0,-NFREE,'I')
         ENDIF
*
         DO 10 I=1,NWBUF
            Q(JRU+IADR+I) = UBUF(I)
   10    CONTINUE
*
         IADR = IADR + NWBUF
*
      ELSE
         IADR = 0
         WRITE(CHMAIL,1000)
         CALL GMAIL(0,0)
      ENDIF
*
 1000 FORMAT(' **** GSRUNG: No RUNG bank existing in memory ')
*
      END
+DECK,  GTRIG, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GTRIG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Steering routine to process one event                    *
C.    *    ==>Called by : GRUN   ,<GXINT> GINC4                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVDMA.
+CDE, GCFLAG.
+SELF, IF=USRJMP.
+CDE, GCJUMP.
+SELF.
C.
C.    ------------------------------------------------------------------
C.
C.            Kinematics
C.
      IF(RAYTRA.NE.1.)THEN
+SELF, IF=-USRJMP.
       CALL GUKINE
+SELF, IF=USRJMP.
       CALL JUMPT0(JUKINE)
+SELF.
      ELSE
       CALL GDKINE
      ENDIF
      IF (IEOTRI.NE.0)  GO TO  99
C.
C.            Tracking
C.
+SELF, IF=-USRJMP.
      CALL GUTREV
+SELF, IF=USRJMP.
      CALL JUMPT0(JUTREV)
+SELF.
      IF (RAYTRA.EQ.1.) GO TO  99
      IF (IEOTRI.NE.0)  GO TO  99
C.
C.            Digitisation
C.
+SELF, IF=-USRJMP.
      CALL GUDIGI
+SELF, IF=USRJMP.
      CALL JUMPT0(JUDIGI)
+SELF.
      IF (IEOTRI.NE.0)  GO TO  99
C.
C.            User end of event control routine
C.
+SELF, IF=-USRJMP.
      CALL GUOUT
+SELF, IF=USRJMP.
      CALL JUMPT0(JUOUT)
+SELF.
C
  99  RETURN
      END
+DECK,  GTRIGC, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GTRIGC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Clear event partition                                    *
C.    *                                                                *
C.    *    ==>Called by : GRUN   ,<GXINT> GINC4                        *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCSTAK.
+CDE, GCFLAG.
C.
C.    ------------------------------------------------------------------
C.
*
      IF (NJTMAX.LT.0) NJTMAX = -NJTMAX
*
      CALL GRNDMQ(IQ(JRUNG+19),IQ(JRUNG+20),0,'G')
      IQ(JRUNG+29) = IEVENT
*
      IF (JSTAK.NE.0) THEN
         IQ(JSTAK+1) = 0
         IQ(JSTAK+3) = 0
      ENDIF
*
      CALL MZWIPE (IXDIV)
*                                                             END GTRIGC
      END

+DECK,  GTRIGI, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GTRIGI
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Initialises event partition                              *
C.    *    ==>Called by : GRUN ,<GXINT> GINC4                          *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCVDMA.
+CDE, GCBANK.
+CDE, GCNUM.
+CDE, GCFLAG.
+CDE, GCUNIT.
+CDE, GCTRAK.
C.
C.    ------------------------------------------------------------------
C.
      IEOTRI=0
      NTRACK=0
      NVERTX=0
      IDEBUG=0
      TOFG  =0.
C
C               Print event number and random number generator
C
      IF(RAYTRA.NE.1.)CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'G')
C
C               Create event header bank
C
      CALL MZBOOK(IXDIV,JHEAD,JHEAD,1,'HEAD', 1, 1,NHEAD,2,0)
      IDEVT=IDEVT+1
      IQ(JHEAD+1)=IDRUN
      IQ(JHEAD+2)=IDEVT
      IQ(JHEAD+3)=NRNDM(1)
      IQ(JHEAD+4)=NRNDM(2)
C
      IF(ITEST.GT.0)THEN
         IF(MOD(IEVENT,ITEST).EQ.0)THEN
           IF(RAYTRA.NE.1.)THEN
            WRITE (CHMAIL,1000) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
            CALL GMAIL(0,0)
           ENDIF
         ENDIF
      ENDIF
C
      IF(IEVENT.GE.IDEMIN.AND.IEVENT.LE.IDEMAX)IDEBUG=1
C
 1000 FORMAT(' **** GTRIGI: IEVENT=',I7,' IDEVT=',I7,
     +' Random Seeds = ',I10,2X,I10)
  99  RETURN
      END
+DECK,  GWORK, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GWORK(NWORK)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *     Handle working space.                                      *
C.    *                                                                *
C.    *     If NWORK>0 make sure that at least NWORK words of working  *
C.    *     space are available in the GCBANK common. If current       *
C.    *     working space is >= NWORK, do nothing.                     *
C.    *                                                                *
C.    *     If NWORK=0 return in NWORK the current size of the         *
C.    *     working space.                                             *
C.    *                                                                *
C.    *     If NWORK<0 reset the working space to be NWORK words       *
C.    *     irrespective of its value.                                 *
C.    *                                                                *
C.    *    ==>Called by :USER,GZINIT,GPHYSI,GDRAWC,GDRAWX,GDSHOW,GKXYZ *
C.    *                                                                *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+SELF, IF=DEBUG.
+CDE, GCUNIT.
+SELF.
      COMMON / QUEST / IQUEST(100)
C.
C.    ------------------------------------------------------------------
C.
      IF(NWORK.GE.0) THEN
         CALL MZINQS(IXSTOR)
         NOWORK = IQUEST(5)-IQUEST(3)-1
+SELF, IF=DEBUG.
         WRITE(CHMAIL,
     +   '('' *** GWORK: Size of the working space = '',I10)') NOWORK
         CALL GMAIL(0,0)
+SELF.
         IF(NWORK.EQ.0) THEN
            NWORK=NOWORK
         ELSE
            IF(NWORK.GT.NOWORK) THEN
               CALL MZWORK(IXSTOR,WS,WS(NWORK),0)
            ENDIF
         ENDIF
      ELSE
         CALL MZWORK(IXSTOR,WS,WS(-NWORK),0)
      ENDIF
      END
+DECK,  GZEBRA, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GZEBRA(NZEB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to initialise ZEBRA store (//)                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
C.
C.    ------------------------------------------------------------------
C.
      NZEBRA=NZEB
      CALL MZEBRA(-1)
      CALL MZSTOR(IXSTOR,'/GCBANK/',' ',FENDQ,LQ,LR1,WS,LQ(KWWORK+100)
     +            ,LQ(NZEBRA-30))
      CALL MZLOGL(IXSTOR,0)
C
      RETURN
      END
+DECK,  GZINIT, T=FORT.
* Revision 1.1.1.1  1995/10/24 10:20:11  cernlib
* Geant

      SUBROUTINE GZINIT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to initialise GEANT/ZEBRA data structures        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGINIT                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCJLOC.
+CDE, GCTIME.
+CDE, GCMZFO.
+CDE, GCSCAL.
      COMMON/GCLOCA/NLOCAL(2),LOCAL(20)
C.
C.    ------------------------------------------------------------------
C.
      IF(IFINIT(2).NE.0)RETURN
      IFINIT(2)=1
C
C                 Create one long range division (reverse)
C                 to store all constants
C                 The event structures are created in division 2
C                 of the store
C
      MINCON=2000
      MAXCON=8*NZEBRA/10
      CALL MZDIV(IXSTOR,IXCONS,'Constants',MINCON,MAXCON,'LRC')
      IXDIV=IXSTOR+2
C
C                 IXDIV and IXCONS are two self contained divisions.
C                 To gain time we specify that to ZEBRA
C
      CALL MZXREF(IXCONS,IXDIV,'C')
      CALL MZXREF(IXDIV,IXCONS,'C')
C
C                 Define a default work space of KWWORK words
C
      CALL GWORK(KWWORK)
C
C                 Create a permanent link area for master pointers
C
      CALL MZLINK(IXSTOR,'/GCLINK/',JDIGI,JSKLT,JDIGI)
C
C                 Create a permanent link area for param. pointers
C
      CALL MZLINK(IXSTOR,'/GCSLNK/',LSCAN,LSLAST,LSCAN)
C
C                 Create temporary link areas
C
      CALL MZLINT(IXSTOR,'/GCLOCA/',NLOCAL,LOCAL(1),LOCAL(20))
      CALL MZLINT(IXSTOR,'/GCJLOC/',NJLOC ,JTM,JRANG)
      CALL MZLINT(IXSTOR,'/GCJLCK/',NJLCK ,JTCKOV,JTASHO)
C
C             Define IO descriptors of GEANT banks
C
      CALL MZFORM('MATE','5H -F'      ,IOMATE)
      CALL MZFORM('PART','5H -F'      ,IOPART)
      CALL MZFORM('TMED','5H -F'      ,IOTMED)
      CALL MZFORM('SEJD','10I / 1H 1I',IOSEJD)
      CALL MZFORM('SJDD','/ 1H 1I'    ,IOSJDD)
      CALL MZFORM('SJDH','/ 1H 1I 2F' ,IOSJDH)
      CALL MZFORM ('STAK', '3I / 3I 9F',IOSTAK)
      CALL MZFORM('RUNG','20I 8F 2I'   ,IORUNG)
C
C             Create RUN header bank
C
      CALL MZBOOK(IXCONS,JRUNG,JRUNG,1,'RUNG',1,1,30,IORUNG,0)
      IQ(JRUNG-5)=1
      IQ(JRUNG+1)=IDRUN
C
C             Fill header with default date,time,Geant and Zebra
C             version numbers for the 4 main GEANT data structures
C             INIT,KINE,HITS,DIGI
C
       DO 10 I=1,4
         IQ(JRUNG+2*I+ 9)=IGDATE
         IQ(JRUNG+2*I+10)=IGTIME
          Q(JRUNG+2*I+19)=GVERSN
          Q(JRUNG+2*I+20)=ZVERSN
  10  CONTINUE
C
  99  RETURN
      END

+PATCH, DOC.
+DECK,  GEDOC_D, T=DATA, IF=DOC.
*
* $Id: geant321.car100,v 1.1.1.1 2003/04/24 14:25:05 tretiak Exp $
*
* $Log: geant321.car100,v $
* Revision 1.1.1.1  2003/04/24 14:25:05  tretiak
* Imported sources
*
* Revision 1.1  1996/03/06 15:31:14  mclareni
* Add geane321 history, CMZ and doc files
*
*
*CMZ :  3.21/02 29/03/94  15.41.49  by  S.Giani
*-- Author :

*-- Author :
   1. Introduction

   2. Definitions

   3. Description of the User Routines and COMMONs

   4. Examples of application

   5. Interface with GEANT

   6. Acknowledgements



   1. Introduction
      ============

      The present Package allows the user to calculate the
average trajectories of particles and to calculate the
transport matrix as well as the propagated error covariance
matrix. It makes use of a set of routines worked out
by the European Muon Collaboration [1] and it is integrated
to the GEANT3 system [2] with expected applications in both
simulation and reconstruction context.

      The package is available as a PAM-file. It contains
two basic PATCHes, one with the original EMC routines,
the other with new GEANT-type tracking routines and interface
between them and the EMC routines. This second PATCH
contains those routines the user should invoke
to carry out the tracking (routines ERTRAK, EUFILL, EUFILP, EUFILV).
In addition to this a series of utilities are available for
the user (e.g. to transform the track representation from one
system to another or to carry out 5 X 5 matrix multiplication
in an optimum way).

     In Section 2 we give the definitions of the mathematical
quantities to be dealt with. In Section 3 the description of
the user routines are given. In Section 4 we illustrate the
application of the program by several examples. Finally in
Section 5 the GEANT part is described.

      Further development will concern the improvement of the
error matrix by taking into account the Landau tail in the
fluctuation of the energy loss, the bremsstrahlung and direct
pair production of the muons.


      2. Definitions
         ===========

         2.1 Track variables, Representations
             --------------------------------

      The particle trajectory is characterized by 5 independent
variables as a function of one parameter (e.g. the pathlength).
Among the 5 variables 1 is related to the curvature (to the absolute
value of the momentum, p), 2 are related to the direction of the
particle and the other 2 are related to the spatial location.
The most usual representation of these 5 parameters are:

       I.

       1/p, lambda, phi, y_perp, z_perp


where lambda and phi are the dip and azimuthal angles related
to the momentum components in the following way:

            p_x = p cos(lambda) cos(phi)
            p_y = p cos(lambda) sin(phi)
            p_z = p sin(lambda)


y_perp and z_perp are the coordinates of the trajectory in a
local orthonormal reference frame with the x_perp axis along the
particle direction, the y_perp being parallel to the x-y plane.
This representation is usually applied in the overall reference
frame. (In the EMC code this reference frame is labelled by 'SC'
since the overall system was identified with that of the Streamer
Chamber.)

       II.

       1/p, y', z', y, z


where y'=dy/dx and z'=dz/dx. This representation is particularly
useful in fixed target experiments, where the trajectory is evaluated
on successive parallel planes (which are perpendicular to the x-axis).
(In the EMC code this representation is labelled by 'SP' since a
convenient mathematical description of a trajectory being approxima-
tely parallel to the x-axis is a 'spline'.)

       III.

       1/p, v', w', v, w


where v'=dv/du and w'=dw/du in an orthonormal coordinate system with
axis u, v and w. This representation is paricularly useful when the
trajectory has to be evaluated on different detector planes
in a colliding beam experiment, where the planes can take a great
variety of directions.(In the EMC code this representation is
labelled by 'SD' as System of Detection.)

      Of course, all the above representations of the trajectory
are equivalent and one can go from one representation to the
other by calculating the corresponding Jacobian. These Jacobians
are provided by the following EMC routines:

     S/R TRSCSP    from I   to II
     S/R TRSPSC    from II  to I
     S/R TRSCSD    from I   to III
     S/R TRSDSC    from III to I



     2.2 Error Propagation
         -----------------


     Let us denote in the following the 5 independent variables at
a given value of parameter l_0 (e.g. pathlength) by x_i(l_0),
(i=1,...,5). In many applications we are interested in the evolution
of the average value of x_i for l>l_0: E(x_i). This is calculated
by GEANT as will be outlined in Section 5.

     The knowledge on the avarage trajectory is characterized by the
5 X 5 covariance matrix of the variables:

   sigma_$ij(l_0) = E(x_i(l_0).x_j(l_0)) - E(x_i(l_0)).E(x_j(l_0))

We are also interested in the evolution of sigma_$ij for l>l_0,
which we call error propagation. If the particle is propagating in a
deterministic way, i.e. without any random process involved (
e.g. in vacuum) then the propagation of sigma is simply described by
the so called transport matrix in the following way:

   sigma_$ij(l) = T_$jm(l,l_0).sigma_$mn(l_0)T_$in(l,l_0)

where the transport matrix expresses the infinitesimal change
in the parameters at l with respect to the change of parameters
at l_0:

        T_$ij(l,l_0) = delta (x_i(l))/ delta (x_j(l_0)).

    In a realistic detector, however, the particles undergo random
processes as well, like Multiple Coulomb scattering, energy loss
due to delta ray production, etc. therefore the error propagation
should contain an additional term:

    sigma_$ij(l) = T_$jm(l,l_0).sigma_$mn(l_0).T_$in(l,l_0) +
                  + sigma_$ij:$random(l).

   The program calculates sigma_$ij(l) step by step using the above
recursive formula, where T_$ij and sigma_$ij:$random refers to the
actual step and sigma_$mn is the cumulative error for all previous
steps. For the mathematical formulae to calculate T_$ij for a finite
step the reader is referred to Ref [1].

   By invoking the subroutine ERTRAK (see next Section) the user
will have access to the average trajectory, to the full error matrix
represented and in addition to this the program makes available also
the transport matrix given by which can be useful in several
applications (see Section 4.)



   3. Description of the User Routines and COMMONs
      ============================================

   To run the program the user should first initialize GEANT,
(set-up the geometry and initialize the appropriate physics
processes). This procedure will be described in Section 5.
The tracking with error propagation is carried out by invoking
subr. ERTRAK. However, before calling ERTRAK the user should
provide informations to the program in two commons:
/ERTRIO/ and the pair /EROPTS/ and /EROPTC/. For this purpose
a series of user routines
are forseen (routines EUFILL, EUFILP, EUFILV), which should be
called by the user. The result of the tracking is partly
returned in the arguments of the routine ERTRAK and partly can be
accessed through the common /ERTRIO/. In the following we give
a description of the user routines (subr. ERTRAK, EUFIL,L,P,V)
and that of the commons /ERTRIO/, /EROPTS/ and /EROPTC/.


       3.1 User Routines
           -------------

    The output parameters are denoted by asterisk in the calling
sequence.

      SUBROUTINE ERTRAK (X1, P1, X2*, P2*, IPA, CHOPT)
      ================================================


   Performs the tracking of the track from point X1 to
             point X2
   (Before calling this routine the user should also provide
             the input informations in /EROPTS/, /EROPTC/ and /ERTRIO/
             using subr. EUFIL(L/P/V)

          X1       - Starting coordinates (Cartesian)
          P1       - Starting 3-momentum  (Cartesian)
          X2       - Final coordinates    (Cartesian)
          P2       - Final 3-momentum     (Cartesian)
          IPA      - Particle code (a la GEANT) of the track

          CHOPT
              'B'   'Backward tracking' - i.e. energy loss
                                 added to the current energy
              'E'   'Exact' calculation of errors assuming
                                 helix (i.e. pathlength not
                                 assumed as infinitesimal)
              'L'   Tracking upto prescribed Lengths reached
              'M'   'Mixed' prediction (not yet coded)
              'O'   Tracking 'Only' without calculating errors
              'P'   Tracking upto prescribed Planes reached
              'V'   Tracking upto prescribed Volumes reached
              'X'   Tracking upto prescribed Point approached


       SUBROUTINE EUFILL (N, EIN, XLF)
       ===============================


    User routine to fill the input values of the commons :
               /EROPTS/, /EROPTC/ and /ERTRIO/ for CHOPT = 'L'

         N     Number of predictions where to store results
         EIN   Input error matrix
         XLF   Defines the tracklengths which if passed the
                      result should be stored

        SUBROUTINE EUFILP (N, EIN, PLI, PLF)
        ====================================


    User routine to fill the input values of the commons :
               /EROPTS/, /EROPTC/ and /ERTRIO/ for CHOPT = 'P'
         N     Number of predictions where to store results
         EIN   Input error matrix (in the 'Plane' system )
         PLI   Defines the start plane
                      PLI(3,1) - and
                      PLI(3,2) - 2 unit vectors in the plane
         PLF   Defines the end plane
                      PLF(3,1,I) - and
                      PLF(3,2,I) - 2 unit vectors in the plane
                      PLF(3,3,I) - point on the plane
                                   at intermediate point I


        SUBROUTINE EUFILV (N, EIN, CNAMV, NUMV, IOVL)
        ============================================


    User routine to fill the input values of the commons :
               /EROPTS/, /EROPTC/ and /ERTRIO/ for CHOPT = 'V'
         N     Number of predictions where to store results
         EIN   Input error matrix
       CNAMV   Volume name of the prediction
        NUMV   Volume number (if 0 = all volumes)
        IOVL   = 1  prediction when entering in the volume
               = 2  prediction when leaving the volume


         2.2 User COMMONs
             ------------

      CHARACTER*8      CHOPTI
      PARAMETER        (MXPRED = 10)
      DOUBLE PRECISION ERDTRP
      LOGICAL          LEEXAC, LELENG, LEONLY, LEPLAN, LEPOIN, LEVOLU

      COMMON /EROPTS/ ERPLI(3,2), ERPLO(3,4,MXPRED), ERLENG(MXPRED),
     ,                NAMEER(MXPRED), NUMVER(MXPRED), IOVLER(MXPRED),
     ,                LEEXAC, LELENG, LEONLY, LEPLAN, LEPOIN, LEVOLU
      COMMON /EROPTC/CHOPTI

      COMMON /ERTRIO/  ERDTRP(5,5,MXPRED), ERRIN(15), ERROUT(15,MXPRED),
     ,                 ERTRSP(5,5,MXPRED), ERXIN( 3), ERXOUT( 3,MXPRED),
     ,                 ERPIN(3),ERPOUT(3,MXPRED),NEPRED,INLIST, ILPRED,
     ,                 IEPRED(MXPRED)


LEEXAC           = .TRUE. if CHOPT = 'E' in  ERTRAK
LELENG           = .TRUE. if CHOPT = 'L' in  ERTRAK
LEONLY           = .TRUE. if CHOPT = 'O' in  ERTRAK
LEPLAN           = .TRUE. if CHOPT = 'P' in  ERTRAK
LEPOIN           = .TRUE. if CHOPT = 'X' in  ERTRAK
LEVOLU           = .TRUE. if CHOPT = 'V' in  ERTRAK
IOPTER(I)        = 1 if the Ith letter of the alphabet is
                 occuring in CHOPT in ERTRAK (else = 0)

NEPRED           Number of predictions (c.f. N in EUFILL,P,V)
ERPLI            Initial plane descriptor (c.f. PLI in EUFILP)
ERPLO(,,INLIST)  Final plane descriptor - first 3 vectors are identic
                 with PLF in EUFILP, the 4th vector is the cross-product
                 of the first two vectors (plane normal)
ERLENG(INLIST)   Lengths to store results (c.f. XLF in EUFILL)
NAMEER(INLIST)   Volume names   to store results (c.f. CNAMV in EUFILV)
NUMVER(INLIST)   Volume numbers to store results (c.f. NUMV in EUFILV)
IOVLER(INLIST)   (c.f. IOVL in EUFILV)

ILPRED           Current number of prediction
IEPRED(ILPRED) = INLIST if the ILPREDth prediction reached (else = 0)
ERDTRP(,,ILPRED) Double precision value of the Transport Matrix
                 at the prediction ILPRED
ERRIN            Input Error Matrix in Triangular form
ERROUT(,ILPRED)  Output Error Matrix in Triangular form
                 at the prediction ILPRED
ERTRSP(,,ILPRED) Single precision value of the Transport Matrix
                 at the prediction ILPRED
ERXIN            Starting coordinates (c.f. X1 in ERTRAK)
ERXOUT(,ILPRED)  Output coordinates at the prediction ILPRED
ERPIN            Starting momentum
ERPOUT(,ILPRED)  Output momentum at the prediction ILPRED



    Note that ERRIN, ERROUT, ERPIN, ERPOUT, ERTRSP and ERDTSP are
given by the program in the representation which is requested by
CHOPT in subr. ERTRAK. (E.g. if CHOPT='P', all the above quantites
are given in the representation III.)



   4. Examples of Application
      =======================


    4.1 The simplest case: Representing the trajectory at another point
        ---------------------------------------------------------------

    Usually the particle trajectory is not measured at the  point of
production where its physical parameters are of interest. Therefore
the measurement has to be extrapolated back close to the origin. This
can be achieved by the simple call:

        CALL ERTRAK(X1,P1,X2,P2,IT,CHOPT).

Since this extrapolation is opposite to the particle direction,
CHOPT should contain the letter 'B'. If the tracking should be
stopped on a prescribed plane, CHOPT should also contain 'P',
and before invoking ERTRAK the user should call subr. EUFILP.
This extrapolation can be carried out simultaneousely onto several
planes, in this case the 1st argument of EUFILP is greater than 1.
The result can be retrieved from the common /ERTRIO/ as described
in Section 3.

     4.2 Joining track elements in different parts of the detector
         ---------------------------------------------------------

    It happens frequently that one measures a part of a trajectory
in a downstream detector and would like to join this information
to another one obtained in a detector close to the interaction
point. Since there are usually several trajectories which could be
a priori joined the first task is to find the one which  matches
the best. The next task is to improve the trajectory parameters.

    One chooses a plane near to the interaction point and extrapolates
onto this plane all candidate trajectories as described in the
preceeding section. For the i-th trajectory one obtains an
avarage value  x_i and a covariance: sigma_i. (In this discussion
the indices will represent the trajectory numbers.) Next one
extrapolates back the trajectory from the downstream detector
to the same plane and obtains x_d and  sigma_d. One can then construct
a chi:2 for each track i:

       chi:2_i = (x_i-x_d)(sigma_i+sigma_d):$-1(x_i-x_d)

    The matching condition can be defined as:

                   chi:2_i.leq.chi:2_0,

where chi:2_0 is some prescribed value.

     Having chosen trajectory i for the matching the improved track
parameters can be obtained by minimizing

   chi:2 = (x-x_d).sigma_d:$-1.(x-x_d)+(x-x_i).sigma_i:$-1.(x-x_i)

w.r.t. x resulting in:

  x_$impr = (sigma_d:$-1+sigma_i:$-1):$-1.
                      (sigma_d:$-1.x_d+sigma_i:$-1.x_i)

The covariance of x_$impr

       sigma_$impr =  (sigma_d:$-1+sigma_i:$-1):$-1

shows explicitely the improvement of the trajectory parameters.

   This procedure can be easily generalized to join more than 2
measurements on the particle trajectory. If e.g. between the two
above planes there is another detection plane, one can first
merge the informations of the downstream and intermediate
plane and continue the backtracking from the intermediate
plane to the plane close to the interaction point with the
improved trajectory parameters.

   The procedure can be used in principle also if not all
the five parameters are measured (e.g. if only the
coordinate informations are available). In this case one
starts the back-tracking with some initial values of the
unmeasured parameters and assigns an error to these
parameters which is much larger than the difference between
the true and the initial value. The user is however has to
ensure that the result is stable against the choice of
the starting value of parameters and errors (e.g. by performing
several iterations). These problems can be overcome
by a fitting procedure which is described in Section 4.4.

      4.3 Prediction of the trajectory
          ----------------------------

      It is often needed to predict the particle trajectory in a
detector plane at a certain confidence level in order to
perform pattern recognition. An example is to find hits from
a penetrating particle inside a segmented calorimeter when the
particle trajectory is well measured at the two extrems of the
calorimeter.

      In the case of 1 intermediate plane inside the calorimeter
the solution can be obtained by combining the methods outlined
in the previous two sections. One extrapolates the measured track
parameters from the two endplanes of the calorimeter onto the plane
set up inside the calorimeter (Section 3.1) and one joins the two
 informations on that plane (Section 3.2). This procedure of course
can be carried out on any number of intermediate planes. However,
if there is a large number of planes, it is advantageous to carry
out the tracking in one direction and in one go, for which case a
method is outlined below.

      Let's start the tracking from one end of the calorimeter
and denote by x_i and by x_e the average track parameters on the
intermediate plane i and on the other end-plane e, respectively.
 Let's denote the true track parameters on the same planes by x
and by y, respectively. The corresponding chi:2, which we should
minimize w.r.t. x is:

         chi:2 = (x-x_i).sigma_i:$-1.(x-x_i) +
                 + (y(x)-x_m).sigma_$em:$-1.(y(x)-x_m)

where x_m is the measured trajectory at the end-plane with
covariance matrix sigma_m, sigma_i is the propagated error
matrix from the starting plane to plane i and

            sigma_$em = sigma_m + sigma_$ei

where sigma_$ei is the propagated error from plane i to plane e
(n o t  including the error on plane i itself).

   The minimization results in the following equation:

   sigma_i:$-1.(x-x_i) + dy/dx.sigma_$em:$-1.(y(x)-x_m) = 0,

which we solve by linearization:

                  x = x_i + Delta x

      y = y(x_i)+dy(x_i)/dx.Delta x = x_e+T(e,i).Delta x.

   The result is:

        Delta x = sigma_x.T:T(e,i).sigma_$em:$-1.(x_m-x_e)

where:

   sigma_x = (sigma_i:$-1+T:T(e,i).sigma_$em:$-1.T(e,i)):$-1

is the covariance matrix of the trajectory prediction at the
plane i (T:T means the transpose of T).

    The following glossary gives the correspondance between the
mathematical quantities used in the above equations and the
varibales in the user common /ERTRIO/:

x_i        ERXOUT(,I), ERPOUT(,I) (I standing for prediction i)
x_         ERXOUT(,IE), ERPOUT(,IE) (IE standing for prediction e)
sigma_i    ERROUT(,I)
T(e,i)     T(e,1).T:$-1(i,1)
T(e,1)     ERTRSP(,,IE)
T(i,1)     ERTRSP(,,I)
sigma_$ei sigma_e-T(e,i).sigma_iT(e,i)
sigma_e    ERROUT(,IE)




     4.4 Fitting trajectory parameters
         -----------------------------


      In the above examples all of the 5 variables of the trajectory
have been known at least in one space point. However, in most of the
cases direct mesurements yield only the coordinate informations, from
which one should reconstruct the curvature and the direction. The
following example shows how to use the program package for this pur-
pose. This tool can be applied in the most general case: in inhomoge-
neous magnetic field and even if the particle passes through a great
amount of material.

      Suppose we would like to reconstruct the particle trajectory
x_0 at plane 0 by measuring the coordinate informations x_i:m
at N different detector planes (i=1,...,N). If in the formation
of the trajectory random processes can be neglected, then
the average trajectory can be obtained by
minimizing the following chi:2 w.r.t. x_0:

 chi:2 = Sum_$i=1:N[(x_i(x_0)-x_i:m).sigma_i:m:$-1.(x_i(x_0)-x_i:m)]

where x_i are the true track parameters at plane i, and sigma_i:m is
the 2 X 2 covariance matrix of the measurement on plane i. This results
in the following equation:

    Sum_$i=1:NT:T(i,0).sigma_i:m:$-1.(x_i(x_0)-x_i:m) = 0

where T(i,0) is the transport matrix between plane 0 and plane i.
This equation is again solved by linearization. In the first
approximation we calculate the trial trajectory x_i:t on plane i
starting with a value x_0:t. The true value is then obtained by:

              x_0 = x_0:t + Delta x_0
with

Delta x_0 = sigma_$x_0.Sum_$i=1:NT:T(i,0).sigma_i:m:$-1.(x_i:m-x_i:t),

where the covariance matrix of x_0 is given by:

  sigma_$x_0 = Sum_$i=1:NT:T(i,0).sigma_i:m:$-1.T(i,0)]:$-1.

     If in the formation of the particle trajectory random processes,
like multiple Coulomb scattering, cannot be neglected then obviousely
there are correlations in the error matrix between different planes
and therefore the above chi:2 should be written as

          chi:2 = (x(x_0)-x:m).sigma:$-1.(x(x_0)-x:m)

where x is a vector of length 2 X N containing the coordinate values
(xi,eta) of the average trajectory plane by plane:

     (xi_1,eta_1,xi_2,eta_2,...,xi_N,eta_N),

x:m is the corresponding vector of the measured coordinates.
sigma is a 2N X 2N matrix, whose 2 X 2 diagonal submatrices can be
written as

            sigma_$ii = sigma_i:m + sigma(2)_i:r

where sigma(2)_i:r is the 2 X 2 part of the covariance matrix sigma_i:r
due to random processes. The off-diagonal 2 X 2 matrices give the the
correlations between planes:

          sigma_$ij = T(j,i).sigma_i:r      (i<j)

where T(j,i) is the 5 X 5 transport matrix between plane i and j and
only the 2 X 2 part of sigma_$ij is considered.

   The minimization procedure is formally the same as before:

                 x_0 = x_0:t + Delta x_0

with

     Delta x_0 = sigma_$x_0.tau:T.sigma:$-1.(x:m-x:t),

where the 5 X 5 covariance matrix of x_0 is given by:

      sigma_$x_0 = (tau:T.sigma:$-1.tau):$-1.

Here tau is the joint transport matrix of dimension 5 X 2N
containing the transport matrices T(i,0) (5 variables for
plane 0 and 2 coordinate variables for plane i).

    Again the correspondance between the above symbols and variables
calculated by the program package is given by the following glossary:

     In case of tracking from plane 0 to plane i in one go:


x_i:t           ERXOUT(,I), ERPOUT(,I) (I standing for prediction i)
sigma_i:r       ERROUT(,I) (starting with 0 error)
T(j,i)          T(j,0).T:$-1(i,0)
T(i,0)          ERTRSP(,,I)




    5. Interface with GEANT
       ====================


     The following diagram shows the program flow-chart of ERTRAK.
Two running examples show how to build up a complete application.
(see patch EREXAM1 and EREXAM2)

     As can be seen from the flow-chart the particle is propagated
through the experimental setup by the routine ERTRGO which is a
simplified version of the GEANT routines GTRACK and GTVOL. In fact,
the calculation of the average trajectory is independent of the basic
GEANT Tracking Package.

     On the other hand, the GEANT Geometry Package is invoked
by calling GMEDIA,GTMEDI,GINVOL,GTNEXT (see the flowchart).
Therefore the GEANT Data Structures: JVOLU, JMATE, JTMED, JPART
must be set up at initialization time (see patch erexample below).

     In fact, in the JMATE data structure, only the energy loss
tables (JLOSS and JRANG) are required. The energy loss calculation must
include the contributions coming from the undetectable random
processes: delta rays, bremsstrahlung and direct pair production
of muons. The user should check that the values of the parameters
DCUTE/M, BCUTE/M, PPCUTM have been set coherently with his
application. (In most of the cases these parameters should be set
to their maximum value (say 10 TeV).)

    No other GEANT facilities are required to run ERTRAK.
No GEANT data structurs are overwritten. Only the commons /GCKINE/
and /GCTRAK/ are used to keep the current values of the parameters
of the average trajectory.

     For debugging purposes the control is given to the user at each
tracking step via the routine EUSTEP. This is the equivalent of
the GEANT GUSTEP routine. The routine ERXYZC is a copy of GPCXYZ.

    After the initialization a call to ERTRAK can be done at any
place of the user's code both in a context of Reconstruction or
Simulation, without interfering with other eventual GEANT calls
in the same event.



               Flow-Chart for subroutine ERTRAK
               ================================


    ERTRAK
    ======
      |
      | ----> GUFLD
      | ----> TRSCSD
      | ----> TRSDSC
      | ----> ERBCER
      | ----> GEKBIN
      | ----> ERPINI ----> TRPROP
      | ----> ERTRGO
              ======
                |
                | ----> GMEDIA
                | ----> GUFLD
                | ----> EVOLIO
                | ----> ERSTOR
                |       ======
                |         |
                |         | ----> ERBCER
                |         | ----> ERBCTR
                |         | ----> TRSCSD
                |         | ----> DMMSS
                |
                |
                | ----> ERTRCH -| ----> GTNEXT
                |       ======  |
                | ----> ERTRNT -| ----> GUSWIM ----> GUFLD
                |       ======  | ----> GINVOL
                |               | ----> ERLAND
                |               | ----> GEKBIN
                |               | ----> ERPROP
                |               |       ======
                | ----> EUSTEP  |          |
                | ----> EVOLIO  |          | ----> GUFLD
                l               |          | ----> TRPROP
                l ----> GTMEDI  |          | ----> TRPRFN
                                |          | ----> SSMTST
                                |          | ----> ERMCSC
                                |
                                | ----> ERSTOR
                                        ======



   6. Acknowledgements
      ================

      The authors of the present interface benefitted numerous critical
remarks and useful suggestions from the authors of the GEANT3 Package,
especially from F. Bruyant (CERN), which are greatly acknowledged here.

      Complaints and suggest must be sent to one of the authors :
          Innocent@cernvm    Maire@cernvm    Nagy@cernvm



                References:
                ===========


[1] W.Wittek, EMC Internal Reports: EMC/80/15,   EMCSW/80/39,
                                    EMCSW/81/13, EMCSW/81/18
    A.Haas,   The EMC Utility Package: UTIL42

[2] R.Brun, F.Bruyant, M.Maire, A.C.McPherson, P.Zanarini
    DD/EE/84-1, May 1986




+DECK,  UPDATE97A_TXT_D, T=DATA, IF=DOC.
/gbase/gffgo.F		IABAN initialization
/gphys/gphysi.F		Medium name length checked
/gtrak/gtelec.F		DESTEP added in case of IABAN=1
/gdraw/gdrawv.F		Backward compatibility for view banks
/gdraw/gdrawp.F		Draw black edges
/gphys/gmulof.F		Rounding errors under WNT fixed
/geant321/ertrio.inc	GEANE CMZ-CVS conversion artefacts deleted
/geant321/eropts.inc	GEANE CMZ-CVS conversion artefacts deleted
/geant321/erwork.inc	GEANE CMZ-CVS conversion artefacts deleted
/geant321/trcom3.inc	GEANE CMZ-CVS conversion artefacts deleted
/geant321/pilot.h       Changes due to WNT compliance
/miface/gmorin.F	Changes due to WNT compliance
/peanut/pfnclv.F	Changes due to WNT compliance
/gbase/ginit.F		Changes due to WNT compliance
/ggeom/gmedia.F		Changes due to WNT compliance
/gexam1/uglast.F	Changes due to WNT compliance
/gphys/gbrele.F		Bremsstrahlung extensions to higher energies
/gphys/gbrsge.F		Bremsstrahlung extensions to higher energies
/ghrout/Imakefile	higclu.F de-optimization
/gdraw/gdspec.F		Correct units for the PARA shape
/gdraw/gdspec.F		Correct units for the SPHE shape
/gphys/grayl.F		Correct the rotation into the GEANT coordinate system
/peanut/nclvst.F	Parameter ZERO is real
/gtrak/gtelec.F		Parameter ZERO is real
/gbase/getver.F		Cradle number /06
/gtrak/gtelec.F		DESTEP calculation corrected
/gtrak/gtckov.F		Photon reflection corrected, avoiding stuck photons
+PATCH, DATA.
+DECK,  FLUKAAF, T=DATA.
   1   2   3   4   5   6   7   7   8   9  10  11  12  13  14  16  17  17
  18  20  21  21  22  24  25  25  26  28  29  29  30  33  34  35  36  38
  39  41  42  47  48  48  49  53  54  55  56  59  60  60  61  64  65  65
  66  70  71  72  73  77  78  79  80  84  85  85  86  91  92  93  94  99
 100 101 102 105 106 106 107 111 112 112 113 119 120 120 121 127 128 128
 129 134 135 136 137 144 145 146 147 156 157 158 159 166 167 167 168 176
 177 177 178 184 185 186 187 190 191 191 192 198 199 199 200 206 207 208
 209 215 216 216 217 223 224 224 225 230 231 231 232 238 239 240 241 246
 247 248 249 253 254 255 256 262 263 264 265 270 271 271 272 278 279 280
 281 284 285 285 286 286 287 287 288 288 289 289 290 290 291 291 292 292
 293 293 294 296 297 297 298 298 299 299 300 300 301 301 302 302 303 303
 304 304
   1   2   4   3   7   6   9  11  10  12  13  14  15  16  18  17  19  20
  22  21  23  24  26  25  27  28  29  30  31  32  34  33  36  35  37  40
  36  38  39  41  40  40  44  42  46  48  43  45  48  46  47  49  50  51
  50  52  53  50  54  55  56  54  57  58  59  58  60  62  61  64  63  65
  64  66  68  67  70  69  71  74  72  70  73  76  75  80  78  82  76  77
  74  79  81  84  86  82  83  80  78  85  87  88  86  87  84  89  90  94
  92  91  96  93  98  96  92  95 100  97  94  97 102 104 101  99 100  96
  98 103 106 108 105 110 104 102 107 109 114 112 111 110 113 116 106 108
 115 113 120 118 116 119 117 124 112 112 114 115 121 123 130 128 126 125
 124 122 123 120 127 132 129 131 134 136 130 128 124 126 133 138 137 136
 135 134 130 132 139 138 140 142 138 136 141 142 144 146 143 145 148 150
 145 152 154 147 149 148 150 144 153 151 158 160 156 157 155 154 152 159
 164 162 163 161 160 158 156 165 166 168 167 170 164 162 169 174 172 173
 171 176 170 168 175 176 180 178 177 179 176 174 181 180 184 186 182 183
 180 187 185 192 190 189 188 187 186 184 193 191 195 194 196 198 192 190
 197 202 200 199 201 198 204 196 205 203 208 206 207 204 209 209 210 222
 223 226 227 232 231 238 235 234 237 244 243 247 247 251 254 257
  0.999850000000000       1.500000000000000E-004  0.999998700000000
  1.300000000000000E-006  0.925800000000000       7.420000000000000E-002
   1.00000000000000       0.802200000000000       0.197800000000000
  0.988900000000000       1.110000000000000E-002  0.996300000000000
  3.700000000000000E-003  0.997590000000000       2.040000000000000E-003
  3.700000000000000E-004   1.00000000000000       0.911335258510691
  8.840713792415629E-002  2.576035651531538E-004   1.00000000000000
  0.787000000000000       0.111700000000000       0.101300000000000
   1.00000000000000       0.922029826844160       4.704233810429386E-002
  3.092783505154639E-002   1.00000000000000       0.950057003420205
  4.220253215192912E-002  7.600456027361642E-003  1.400084005040303E-004
  0.755300000000000       0.244700000000000       0.996000000000000
  3.370000000000000E-003  6.300000000000000E-004  0.931076348260557
  6.880564206264915E-002  1.180096767934971E-004  0.967757069986124
  2.079319604300388E-002  6.448586002775087E-003  1.856713616898090E-003
  1.796819629256216E-003  1.347614721942162E-003   1.00000000000000
  0.739400000000000       7.929999999999998E-002  7.279999999999999E-002
  5.509999999999999E-002  5.339999999999999E-002  0.997600000000000
  2.400000000000000E-003  0.837600000000000       9.550000000000000E-002
  4.310000000000000E-002  2.380000000000000E-002   1.00000000000000
  0.916600000000000       5.820000000000000E-002  2.190000000000000E-002
  3.300000000000000E-003   1.00000000000000       0.682740000000000
  0.260950000000000       3.593000000000000E-002  1.134000000000000E-002
  9.039999999999999E-003  0.690900000000000       0.309100000000000
  0.486847389558233       0.279216867469880       0.186445783132530
  4.126506024096385E-002  6.224899598393573E-003  0.604000000000000
  0.396000000000000       0.365363463653635       0.274272572742726
  0.205179482051795       7.759224077592240E-002  7.759224077592240E-002
   1.00000000000000       0.498200000000000       0.235200000000000
  9.190000000000000E-002  9.020000000000000E-002  7.580000000000001E-002
  8.699999999999999E-003  0.505400000000000       0.494600000000000
  0.569000000000000       0.173700000000000       0.115600000000000
  0.115500000000000       2.270000000000000E-002  3.499999999999999E-003
  0.721500000000000       0.278500000000000       0.825600000000000
  9.859999999999999E-002  7.020000000000000E-002  5.600000000000001E-003
   1.00000000000000       0.514600000000000       0.174000000000000
  0.171100000000000       0.112300000000000       2.799999999999999E-002
   1.00000000000000       0.237800000000000       0.165300000000000
  0.158400000000000       0.157200000000000       9.630000000000001E-002
  9.460000000000000E-002  9.039999999999999E-002   1.00000000000000
  0.316163232646529       0.185837167433487       0.170734146829366
  0.127225445089018       0.126225245049010       5.511102220444088E-002
  1.870374074814963E-002   1.00000000000000       0.273272672732727
  0.267073292670733       0.222277772222778       0.118088191180882
  0.109689031096890       9.599040095990399E-003  0.518200000000000
  0.481800000000000       0.288571142885711       0.240675932406759
  0.127487251274873       0.123887611238876       0.122587741225877
  7.579242075792421E-002  1.219878012198780E-002  8.799120087991200E-003
  0.957200000000000       4.280000000000000E-002  0.328500000000000
  0.240300000000000       0.143000000000000       8.580000000000000E-002
  7.610000000000000E-002  5.940000000000000E-002  4.720000000000000E-002
  9.599999999999999E-003  6.600000000000000E-003  3.500000000000000E-003
  0.572500000000000       0.427500000000000       0.344803448034480
  0.317903179031790       0.187101871018710       6.990069900699007E-002
  4.610046100461004E-002  2.460024600246002E-002  8.700087000870008E-003
  8.900089000890008E-004   1.00000000000000       0.268883866967982
  0.264384136951783       0.211787292762434       0.104393736375817
  8.869467831930082E-002  4.079755214687118E-002  1.919884806911585E-002
  9.599424034557925E-004  8.999460032398054E-004   1.00000000000000
  0.716614332286646       0.113202264045281       7.810156203124062E-002
  6.590131802636053E-002  2.420048400968019E-002  1.010020200404008E-003
  9.700194003880077E-004  0.999110000000000       8.899999999999999E-004
  0.884861940335823       0.110707749542468       2.500175012250857E-003
  1.930135109457662E-003   1.00000000000000       0.270019920318725
  0.237549800796813       0.175498007968127       0.121215139442231
  8.266932270916334E-002  5.707171314741035E-002  5.597609561752987E-002
   1.00000000000000       0.267200000000000       0.227100000000000
  0.149700000000000       0.138300000000000       0.112400000000000
  7.439999999999999E-002  3.089999999999999E-002  0.521800000000000
  0.478200000000000       0.248700000000000       0.219000000000000
  0.204700000000000       0.156800000000000       0.147300000000000
  2.149999999999999E-002  2.000000000000000E-003   1.00000000000000
  0.279557945278864       0.253268784349517       0.247713339021051
  0.187297871073987       2.271780321819011E-002  8.928394277891312E-003
  5.158627805003868E-004   1.00000000000000       0.334113364534581
  0.270710828433137       0.229409176367055       0.148805952238090
  1.560062402496100E-002  1.360054402176087E-003   1.00000000000000
  0.318415920796040       0.218210910545527       0.161308065403270
  0.143107155357768       0.127306365318266       3.030151507575378E-002
  1.350067503375169E-003  0.974100000000000       2.590000000000000E-002
  0.352364763523648       0.271372862713729       0.184981501849815
  0.137486251374862       5.199480051994800E-002  1.799820017998200E-003
  0.999877000368999       1.229996310011070E-004  0.306400000000000
  0.284100000000000       0.264100000000000       0.144000000000000
  1.400000000000000E-003  0.625000000000000       0.375000000000000
  0.403555555555556       0.266666666666667       0.162626262626263
  0.134343434343434       1.656565656565656E-002  1.606060606060606E-002
  1.818181818181818E-004  0.626000000000000       0.374000000000000
  0.337990874246395       0.328991117239835       0.252993169184432
  7.209805335255949E-002  7.799789405686048E-003  1.269965710925805E-004
   1.00000000000000       0.297982121072736       0.231286122832630
  0.168389896606204       0.132192068475891       0.100193988360698
  6.849589024658520E-002  1.459912405255685E-003  0.705000000000000
  0.295000000000000       0.523104620924185       0.236047209441888
  0.226045209041808       1.480296059211842E-002   1.00000000000000
   1.00000000000000        1.00000000000000        1.00000000000000
   1.00000000000000        1.00000000000000        1.00000000000000
   1.00000000000000        1.00000000000000       0.992254260156914
  7.196042176802758E-003  5.496976662835440E-004   1.00000000000000
   1.00000000000000        1.00000000000000        1.00000000000000
   1.00000000000000        1.00000000000000        1.00000000000000
   1.00000000000000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  5.155720000000000E-025  6.352660000000000E-028  0.000000000000000E+000
  2.206280000000000E-024  1.074000000000000E-026  3.268510000000000E-003
  5.313590000000000E-024  5.741770000000000E-026  7.364860000000000E-003
  1.011680000000000E-023  1.917390000000000E-025  1.290260000000000E-002
  1.693820000000000E-023  4.948320000000000E-025  2.003300000000000E-002
  2.614920000000000E-023  1.085180000000000E-024  2.861950000000000E-002
  3.817710000000000E-023  2.127230000000000E-024  3.864270000000000E-002
  5.351240000000000E-023  3.841620000000000E-024  5.006100000000000E-002
  7.271770000000000E-023  6.517220000000000E-024  6.284210000000000E-002
  9.643750000000000E-023  1.052530000000000E-023  7.694360000000000E-002
  1.254090000000000E-022  1.633610000000000E-023  9.232970000000000E-002
  1.604740000000000E-022  2.453840000000000E-023  0.108963000000000
  2.025950000000000E-022  3.586240000000000E-023  0.126807000000000
  2.528670000000000E-022  5.120600000000000E-023  0.145824000000000
  3.125390000000000E-022  7.166590000000000E-023  0.165979000000000
  3.830320000000000E-022  9.857380000000000E-023  0.187236000000000
  4.659630000000000E-022  1.335380000000000E-022  0.209560000000000
  5.631680000000000E-022  1.784910000000000E-022  0.232915000000000
  6.767310000000000E-022  2.357490000000000E-022  0.257269000000000
  8.090190000000000E-022  3.080720000000000E-022  0.282588000000000
  9.627150000000000E-022  3.987420000000000E-022  0.308839000000000
  1.140860000000000E-021  5.116500000000000E-022  0.335990000000000
  1.346890000000000E-021  6.513920000000000E-022  0.364010000000000
  1.584700000000000E-021  8.233900000000000E-022  0.392867000000000
  1.858710000000000E-021  1.034020000000000E-021  0.422532000000000
  2.173890000000000E-021  1.290760000000000E-021  0.452976000000000
  2.535880000000000E-021  1.602390000000000E-021  0.484169000000000
  2.951020000000000E-021  1.979130000000000E-021  0.516085000000000
  3.426510000000000E-021  2.432970000000000E-021  0.548696000000000
  3.970430000000000E-021  2.977830000000000E-021  0.581975000000000
  4.591930000000000E-021  3.629910000000000E-021  0.615897000000000
  5.301320000000000E-021  4.408080000000000E-021  0.650438000000000
  6.110190000000000E-021  5.334170000000000E-021  0.685572000000000
  7.031620000000000E-021  6.433510000000000E-021  0.721278000000000
  8.080359999999999E-021  7.735410000000000E-021  0.757531000000000
  9.272980000000001E-021  9.273750000000000E-021  0.794311000000000
  1.062820000000000E-020  1.108770000000000E-020  0.831596000000000
  1.216690000000000E-020  1.322230000000000E-020  0.869366000000000
  1.391280000000000E-020  1.572970000000000E-020  0.907601000000000
  1.589240000000000E-020  1.866970000000000E-020  0.946281000000000
  1.813550000000000E-020  2.211120000000000E-020  0.985390000000000
  2.067580000000000E-020  2.613350000000000E-020   1.02491000000000
  2.355090000000000E-020  3.082750000000000E-020   1.06482000000000
  2.680310000000000E-020  3.629760000000000E-020   1.10511000000000
  3.048000000000000E-020  4.266350000000000E-020   1.14576000000000
  3.463490000000000E-020  5.006250000000000E-020   1.18675000000000
  3.932760000000000E-020  5.865150000000000E-020   1.22808000000000
  4.462540000000000E-020  6.861040000000000E-020   1.26972000000000
  5.060360000000000E-020  8.014490000000001E-020   1.31166000000000
  5.734670000000000E-020  9.348980000000000E-020   1.35390000000000
  6.494960000000000E-020  1.089140000000000E-019   1.39642000000000
  7.351840000000000E-020  1.267230000000000E-019   1.43920000000000
  8.317220000000000E-020  1.472680000000000E-019   1.48224000000000
  9.404460000000000E-020  1.709460000000000E-019   1.52552000000000
  1.062850000000000E-019  1.982130000000000E-019   1.56904000000000
  1.200610000000000E-019  2.295870000000000E-019   1.61278000000000
  1.355600000000000E-019  2.656570000000000E-019   1.65674000000000
  1.529920000000000E-019  3.070940000000000E-019   1.70090000000000
  1.725920000000000E-019  3.546630000000000E-019   1.74526000000000
  1.946240000000000E-019  4.092320000000000E-019   1.78980000000000
  2.193830000000000E-019  4.717880000000000E-019   1.83453000000000
  2.471970000000000E-019  5.434540000000000E-019   1.87943000000000
  2.784370000000000E-019  6.255030000000000E-019   1.92450000000000
  3.135140000000000E-019  7.193820000000000E-019   1.96973000000000
  3.528910000000000E-019  8.267340000000000E-019   2.01510000000000
  3.970840000000000E-019  9.494210000000001E-019   2.06063000000000
  4.466700000000000E-019  1.089560000000000E-018   2.10629000000000
  5.022950000000000E-019  1.249540000000000E-018   2.15209000000000
  5.646810000000000E-019  1.432080000000000E-018   2.19802000000000
  6.346350000000000E-019  1.640260000000000E-018   2.24407000000000
  7.130580000000000E-019  1.877560000000000E-018   2.29024000000000
  8.009570000000000E-019  2.147930000000000E-018   2.33652000000000
  8.994600000000000E-019  2.455830000000000E-018   2.38291000000000
  1.009820000000000E-018  2.806320000000000E-018   2.42941000000000
  1.133450000000000E-018  3.205130000000000E-018   2.47601000000000
  1.271920000000000E-018  3.658710000000000E-018   2.52270000000000
  1.426980000000000E-018  4.174370000000000E-018   2.56949000000000
  1.600580000000000E-018  4.760400000000000E-018   2.61636000000000
  1.794910000000000E-018  5.426130000000000E-018   2.66332000000000
  2.012430000000000E-018  6.182120000000000E-018   2.71037000000000
  2.255830000000000E-018  7.040290000000000E-018   2.75749000000000
  2.528180000000000E-018  8.014109999999999E-018   2.80469000000000
  2.832870000000000E-018  9.118780000000000E-018   2.85197000000000
  3.173680000000000E-018  1.037150000000000E-017   2.89931000000000
  3.554850000000000E-018  1.179150000000000E-017   2.94672000000000
  3.981080000000000E-018  1.340080000000000E-017   2.99420000000000
  4.457660000000000E-018  1.522400000000000E-017   3.04174000000000
  4.990440000000000E-018  1.728880000000000E-017   3.08934000000000
  5.585990000000000E-018  1.962660000000000E-017   3.13700000000000
  6.251610000000000E-018  2.227280000000000E-017   3.18472000000000
  6.995440000000000E-018  2.526710000000000E-017   3.23250000000000
  7.826600000000000E-018  2.865450000000000E-017   3.28032000000000
  8.755199999999999E-018  3.248550000000000E-017   3.32820000000000
  9.792559999999999E-018  3.681690000000000E-017   3.37612000000000
  1.095130000000000E-017  4.171310000000000E-017   3.42410000000000
  1.224540000000000E-017  4.724620000000000E-017   3.47211000000000
  1.369060000000000E-017  5.349740000000000E-017   3.52018000000000
  1.530440000000000E-017  6.055840000000000E-017   3.56828000000000
  1.710610000000000E-017  6.853210000000001E-017   3.61643000000000
  1.911760000000000E-017  7.753440000000000E-017   3.66462000000000
  2.136290000000000E-017  8.769340000000001E-017   3.71263000000000
  2.386910000000000E-017  9.916040000000000E-017   3.76091000000000
  2.666610000000000E-017  1.120980000000000E-016   3.80923000000000
  2.978750000000000E-017  1.266920000000000E-016   3.85758000000000
  3.327050000000000E-017  1.431510000000000E-016   3.90596000000000
  3.715670000000000E-017  1.617090000000000E-016   3.95438000000000
  4.149220000000000E-017  1.826300000000000E-016   4.00283000000000
  4.632870000000000E-017  2.062100000000000E-016   4.05130000000000
  5.172360000000000E-017  2.327820000000000E-016   4.09981000000000
  5.774079999999999E-017  2.627210000000000E-016   4.14835000000000
  6.445160000000000E-017  2.964450000000000E-016   4.19691000000000
  7.193530000000000E-017  3.344280000000000E-016   4.24551000000000
  8.028020000000000E-017  3.772000000000000E-016   4.29412000000000
  8.958470000000000E-017  4.253550000000000E-016   4.34277000000000
  9.995840000000001E-017  4.795620000000000E-016   4.39144000000000
  1.115230000000000E-016  5.405720000000000E-016   4.44013000000000
  1.244150000000000E-016  6.092260000000000E-016   4.48885000000000
  1.387850000000000E-016  6.864710000000000E-016   4.53759000000000
  1.548010000000000E-016  7.733660000000000E-016   4.58635000000000
  1.726510000000000E-016  8.711040000000000E-016   4.63513000000000
  1.925440000000000E-016  9.810190000000001E-016   4.68394000000000
  2.147110000000000E-016  1.104610000000000E-015   4.73276000000000
  2.394110000000000E-016  1.243560000000000E-015   4.78161000000000
  2.669310000000000E-016  1.399750000000000E-015   4.83047000000000
  2.975930000000000E-016  1.575300000000000E-015   4.87936000000000
  3.317500000000000E-016  1.772580000000000E-015   4.92826000000000
  3.698020000000000E-016  1.994240000000000E-015   4.97719000000000
  4.121870000000000E-016  2.243270000000000E-015   5.02612000000000
  4.593980000000000E-016  2.523020000000000E-015   5.07508000000000
  5.119790000000000E-016  2.837220000000000E-015   5.12406000000000
  5.705400000000000E-016  3.190070000000000E-015   5.17305000000000
  6.357550000000000E-016  3.586280000000000E-015   5.22205000000000
  7.083770000000000E-016  4.031120000000000E-015   5.27108000000000
  7.892430000000000E-016  4.530500000000000E-015   5.32011000000000
  8.792820000000000E-016  5.091040000000000E-015   5.36917000000000
  9.795310000000000E-016  5.720150000000000E-015   5.41823000000000
  1.091140000000000E-015  6.426130000000000E-015   5.46732000000000
  1.215390000000000E-015  7.218290000000000E-015   5.51641000000000
  1.353710000000000E-015  8.107039999999999E-015   5.56552000000000
  1.507680000000000E-015  9.104050000000000E-015   5.61465000000000
  1.679060000000000E-015  1.022240000000000E-014   5.66378000000000
  1.869810000000000E-015  1.147670000000000E-014   5.71293000000000
  2.082120000000000E-015  1.288330000000000E-014   5.76209000000000
  2.318400000000000E-015  1.446060000000000E-014   5.81127000000000
  2.581350000000000E-015  1.622900000000000E-014   5.86045000000000
  2.873960000000000E-015  1.821160000000000E-014   5.90965000000000
  3.199570000000000E-015  2.043400000000000E-014   5.95886000000000
  3.561880000000000E-015  2.292510000000000E-014   6.00808000000000
  3.965010000000000E-015  2.571700000000000E-014   6.05731000000000
  4.413540000000000E-015  2.884560000000000E-014   6.10655000000000
  4.912560000000000E-015  3.235150000000000E-014   6.15581000000000
  5.467720000000000E-015  3.627950000000000E-014   6.20507000000000
  6.085320000000000E-015  4.068010000000000E-014   6.25434000000000
  6.772350000000000E-015  4.560990000000000E-014   6.30363000000000
  7.536580000000001E-015  5.113180000000000E-014   6.35292000000000
  8.386650000000000E-015  5.731639999999999E-014   6.40222000000000
  9.332170000000000E-015  6.424270000000001E-014   6.45153000000000
  1.038380000000000E-014  7.199890000000000E-014   6.50085000000000
  1.155340000000000E-014  8.068380000000000E-014   6.55018000000000
  1.285420000000000E-014  9.040770000000000E-014   6.59952000000000
  1.430080000000000E-014  1.012940000000000E-013   6.64887000000000
  1.590950000000000E-014  1.134810000000000E-013   6.69822000000000
  1.769840000000000E-014  1.271220000000000E-013   6.74759000000000
  1.968760000000000E-014  1.423890000000000E-013   6.79696000000000
  2.189940000000000E-014  1.594770000000000E-013   6.84634000000000
  2.435870000000000E-014  1.785990000000000E-013   6.89573000000000
  2.709310000000000E-014  1.999970000000000E-013   6.94512000000000
  3.013320000000000E-014  2.239390000000000E-013   6.99453000000000
  3.351310000000000E-014  2.507270000000000E-013   7.04394000000000
  3.727070000000000E-014  2.806950000000000E-013   7.09336000000000
  4.144790000000000E-014  3.142190000000000E-013   7.14278000000000
  4.609150000000000E-014  3.517180000000000E-013   7.19221000000000
  5.125350000000000E-014  3.936610000000000E-013   7.24165000000000
  5.699130000000000E-014  4.405710000000000E-013   7.29110000000000
  6.336920000000000E-014  4.930310000000000E-013   7.34055000000000
  7.045820000000001E-014  5.516960000000000E-013   7.39001000000000
  7.833750000000001E-014  6.172940000000000E-013   7.43947000000000
  8.709470000000000E-014  6.906400000000000E-013   7.48894000000000
  9.682750000000000E-014  7.726430000000000E-013   7.53842000000000
  1.076440000000000E-013  8.643190000000000E-013   7.58791000000000
  1.196650000000000E-013  9.668000000000001E-013   7.63740000000000
  1.330240000000000E-013  1.081360000000000E-012   7.68689000000000
  1.478680000000000E-013  1.209400000000000E-012   7.73639000000000
  1.643650000000000E-013  1.352510000000000E-012   7.78590000000000
  1.826950000000000E-013  1.512450000000000E-012   7.83541000000000
  2.030630000000000E-013  1.691190000000000E-012   7.88493000000000
  2.256940000000000E-013  1.890920000000000E-012   7.93445000000000
  2.508400000000000E-013  2.114100000000000E-012   7.98398000000000
  2.787780000000000E-013  2.363460000000000E-012   8.03352000000000
  3.098190000000000E-013  2.642070000000000E-012   8.08306000000000
  3.443050000000000E-013  2.953320000000000E-012   8.13260000000000
  3.826180000000000E-013  3.301030000000000E-012   8.18215000000000
  4.251820000000000E-013  3.689440000000000E-012   8.23170000000000
  4.724660000000000E-013  4.123290000000000E-012   8.28126000000000
  5.249940000000000E-013  4.607880000000000E-012   8.33082000000000
  5.833440000000000E-013  5.149110000000000E-012   8.38039000000000
  6.481610000000000E-013  5.753550000000000E-012   8.42997000000000
  7.201590000000000E-013  6.428570000000000E-012   8.47954000000000
  8.001330000000000E-013  7.182350000000000E-012   8.52912000000000
  8.889620000000000E-013  8.024039999999999E-012   8.57871000000000
  9.876250000000000E-013  8.963859999999999E-012   8.62830000000000
  1.097210000000000E-012  1.001320000000000E-011   8.67789000000000
  1.218920000000000E-012  1.118470000000000E-011   8.72749000000000
  1.354090000000000E-012  1.249260000000000E-011   8.77710000000000
  1.504220000000000E-012  1.395260000000000E-011   8.82670000000000
  1.670940000000000E-012  1.558240000000000E-011   8.87631000000000
  1.856100000000000E-012  1.740160000000000E-011   8.92593000000000
  2.061720000000000E-012  1.943220000000000E-011   8.97555000000000
  2.290060000000000E-012  2.169860000000000E-011   9.02517000000000
  2.543630000000000E-012  2.422800000000000E-011   9.07480000000000
  2.825200000000000E-012  2.705090000000000E-011   9.12442000000000
  3.137860000000000E-012  3.020110000000000E-011   9.17406000000000
  3.485040000000000E-012  3.371640000000000E-011   9.22370000000000
  3.870540000000000E-012  3.763910000000000E-011   9.27334000000000
  4.298570000000000E-012  4.201590000000000E-011   9.32298000000000
  4.773830000000000E-012  4.689940000000000E-011   9.37263000000000
  5.301510000000000E-012  5.234790000000000E-011   9.42228000000000
  5.887380000000000E-012  5.842660000000000E-011   9.47193000000000
  6.537840000000000E-012  6.520790000000000E-011   9.52159000000000
  7.260010000000000E-012  7.277290000000000E-011   9.57125000000000
  8.061750000000000E-012  8.121160000000000E-011   9.62091000000000
  8.951840000000000E-012  9.062460000000000E-011   9.67058000000000
  9.939980000000000E-012  1.011240000000000E-010   9.72025000000000
  1.103690000000000E-011  1.128350000000000E-010   9.76993000000000
  1.225470000000000E-011  1.258960000000000E-010   9.81960000000000
  1.360650000000000E-011  1.404620000000000E-010   9.86928000000000
  1.510720000000000E-011  1.567070000000000E-010   9.91896000000000
  1.677290000000000E-011  1.748230000000000E-010   9.96865000000000
  1.862200000000000E-011  1.950250000000000E-010   10.0183000000000
  2.067450000000000E-011  2.175520000000000E-010   10.0680000000000
  2.295270000000000E-011  2.426700000000000E-010   10.1177000000000
  2.548140000000000E-011  2.706770000000000E-010   10.1674000000000
  2.828820000000000E-011  3.019030000000000E-010   10.2171000000000
  3.140340000000000E-011  3.367180000000000E-010   10.2668000000000
  3.486110000000000E-011  3.755310000000000E-010   10.3165000000000
  3.869870000000000E-011  4.188020000000000E-010   10.3662000000000
  4.295790000000000E-011  4.670390000000000E-010   10.4159000000000
  4.768500000000000E-011  5.208120000000000E-010   10.4656000000000
  5.293120000000000E-011  5.807520000000000E-010   10.5154000000000
  5.875350000000000E-011  6.475650000000000E-010   10.5651000000000
  6.521490000000000E-011  7.220360000000000E-010   10.6148000000000
  7.238569999999999E-011  8.050400000000000E-010   10.6645000000000
  8.034330000000000E-011  8.975520000000000E-010   10.7142000000000
  8.917420000000000E-011  1.000660000000000E-009   10.7640000000000
  9.897390000000000E-011  1.115560000000000E-009   10.8137000000000
  1.098490000000000E-010  1.243610000000000E-009   10.8634000000000
  1.219160000000000E-010  1.386320000000000E-009   10.9132000000000
  1.353060000000000E-010  1.545330000000000E-009   10.9629000000000
  1.501650000000000E-010  1.722530000000000E-009   11.0126000000000
  1.666520000000000E-010  1.919970000000000E-009   11.0624000000000
  1.849470000000000E-010  2.139970000000000E-009   11.1121000000000
  2.052460000000000E-010  2.385090000000000E-009   11.1619000000000
  2.277690000000000E-010  2.658190000000000E-009   11.2116000000000
  2.527590000000000E-010  2.962460000000000E-009   11.2614000000000
  2.804870000000000E-010  3.301450000000000E-009   11.3111000000000
  3.112510000000000E-010  3.679090000000000E-009   11.3609000000000
  3.453840000000000E-010  4.099790000000000E-009   11.4106000000000
  3.832540000000000E-010  4.568450000000000E-009   11.4604000000000
  4.252690000000000E-010  5.090500000000000E-009   11.5101000000000
  4.718830000000000E-010  5.672020000000000E-009   11.5599000000000
  5.235970000000000E-010  6.319770000000000E-009   11.6097000000000
  5.809690000000000E-010  7.041250000000000E-009   11.6594000000000
  6.446180000000000E-010  7.844840000000000E-009   11.7092000000000
  7.152290000000000E-010  8.739870000000001E-009   11.7589000000000
  7.935620000000000E-010  9.736690000000000E-009   11.8087000000000
  8.804610000000000E-010  1.084690000000000E-008   11.8585000000000
  9.768610000000000E-010  1.208320000000000E-008   11.9083000000000
  1.083800000000000E-009  1.346010000000000E-008   11.9580000000000
  1.202430000000000E-009  1.499340000000000E-008   12.0078000000000
  1.334020000000000E-009  1.670080000000000E-008   12.0576000000000
  1.479990000000000E-009  1.860220000000000E-008   12.1074000000000
  1.641910000000000E-009  2.071930000000000E-008   12.1572000000000
  1.821510000000000E-009  2.307670000000000E-008   12.2069000000000
  2.020740000000000E-009  2.570160000000000E-008   12.2567000000000
  2.241720000000000E-009  2.862420000000000E-008   12.3065000000000
  2.486830000000000E-009  3.187810000000000E-008   12.3563000000000
  2.758700000000000E-009  3.550100000000000E-008   12.4061000000000
  3.060260000000000E-009  3.953440000000000E-008   12.4559000000000
  3.394730000000000E-009  4.402480000000000E-008   12.5057000000000
  3.765700000000000E-009  4.902380000000000E-008   12.5555000000000
  4.177160000000000E-009  5.458890000000000E-008   12.6053000000000
  4.633510000000000E-009  6.078400000000000E-008   12.6551000000000
  5.139640000000000E-009  6.768030000000000E-008   12.7049000000000
  5.700990000000000E-009  7.535700000000000E-008   12.7547000000000
  6.323560000000000E-009  8.390210000000000E-008   12.8045000000000
  7.014030000000000E-009  9.341360000000000E-008   12.8543000000000
  7.779790000000000E-009  1.040000000000000E-007   12.9041000000000
  8.629030000000000E-009  1.157840000000000E-007   12.9539000000000
  9.570860000000000E-009  1.288990000000000E-007   13.0037000000000
  1.061530000000000E-008  1.434970000000000E-007   13.0535000000000
  1.177370000000000E-008  1.597430000000000E-007   13.1033000000000
  1.305820000000000E-008  1.778230000000000E-007   13.1531000000000
  1.448270000000000E-008  1.979450000000000E-007   13.2029000000000
  1.606250000000000E-008  2.203380000000000E-007   13.2527000000000
  1.781430000000000E-008  2.452580000000000E-007   13.3026000000000
  1.975690000000000E-008  2.729900000000000E-007   13.3524000000000
  2.191110000000000E-008  3.038500000000000E-007   13.4022000000000
  2.429990000000000E-008  3.381900000000000E-007   13.4520000000000
  2.694870000000000E-008  3.764010000000000E-007   13.5018000000000
  2.988600000000000E-008  4.189190000000000E-007   13.5516000000000
  3.314310000000000E-008  4.662290000000000E-007   13.6015000000000
  3.675460000000000E-008  5.188690000000000E-007   13.6513000000000
  4.075920000000000E-008  5.774380000000000E-007   13.7011000000000
  4.519970000000000E-008  6.426030000000000E-007   13.7509000000000
  5.012320000000000E-008  7.151050000000000E-007   13.8008000000000
  5.558250000000000E-008  7.957680000000000E-007   13.8506000000000
  6.163569999999999E-008  8.855100000000000E-007   13.9004000000000
  6.834730000000000E-008  9.853469999999999E-007   13.9503000000000
  7.578890000000000E-008  1.096420000000000E-006   14.0001000000000
  8.403990000000000E-008  1.219980000000000E-006   14.0499000000000
  9.318800000000000E-008  1.357430000000000E-006   14.0998000000000
  1.033310000000000E-007  1.510340000000000E-006   14.1496000000000
  1.145760000000000E-007  1.680430000000000E-006   14.1994000000000
  1.270440000000000E-007  1.869640000000000E-006   14.2493000000000
  1.408680000000000E-007  2.080100000000000E-006   14.2991000000000
  1.561930000000000E-007  2.314210000000000E-006   14.3490000000000
  1.731840000000000E-007  2.574600000000000E-006   14.3988000000000
  1.920220000000000E-007  2.864240000000000E-006   14.4486000000000
  2.129060000000000E-007  3.186380000000000E-006   14.4985000000000
  2.360590000000000E-007  3.544680000000000E-006   14.5483000000000
  2.617270000000000E-007  3.943190000000000E-006   14.5982000000000
  2.901830000000000E-007  4.386410000000000E-006   14.6480000000000
  3.217290000000000E-007  4.879340000000000E-006   14.6979000000000
  3.567020000000000E-007  5.427550000000000E-006   14.7477000000000
  3.954720000000000E-007  6.037220000000000E-006   14.7976000000000
  4.384520000000000E-007  6.715240000000000E-006   14.8474000000000
  4.860970000000000E-007  7.469260000000000E-006   14.8973000000000
  5.389150000000000E-007  8.307759999999999E-006   14.9471000000000
  5.974660000000000E-007  9.240210000000001E-006   14.9970000000000
  6.623720000000000E-007  1.027710000000000E-005   15.0468000000000
  7.343220000000000E-007  1.143010000000000E-005   15.0967000000000
  8.140800000000000E-007  1.271230000000000E-005   15.1465000000000
  9.024910000000000E-007  1.413790000000000E-005   15.1964000000000
  1.000490000000000E-006  1.572320000000000E-005   15.2462000000000
  1.109130000000000E-006  1.748580000000000E-005   15.2961000000000
  1.229550000000000E-006  1.944570000000000E-005   15.3460000000000
  1.363030000000000E-006  2.162490000000000E-005   15.3958000000000
  1.510990000000000E-006  2.404770000000000E-005   15.4457000000000
  1.674990000000000E-006  2.674160000000000E-005   15.4955000000000
  1.856780000000000E-006  2.973660000000000E-005   15.5454000000000
  2.058280000000000E-006  3.306640000000000E-005   15.5953000000000
  2.281620000000000E-006  3.676840000000000E-005   15.6451000000000
  2.529170000000000E-006  4.088410000000000E-005   15.6950000000000
  2.803560000000000E-006  4.545970000000000E-005   15.7449000000000
  3.107690000000000E-006  5.054640000000000E-005   15.7947000000000
  3.444780000000000E-006  5.620120000000000E-005   15.8446000000000
  3.818410000000000E-006  6.248749999999999E-005   15.8945000000000
  4.232510000000000E-006  6.947580000000000E-005   15.9443000000000
  4.691490000000000E-006  7.724410000000000E-005   15.9942000000000
  5.200190000000000E-006  8.587960000000000E-005   16.0441000000000
  5.764000000000000E-006  9.547870000000000E-005   16.0939000000000
  6.388890000000000E-006  1.061490000000000E-004   16.1438000000000
  7.081460000000000E-006  1.180090000000000E-004   16.1937000000000
  7.849040000000000E-006  1.311930000000000E-004   16.2435000000000
  8.699749999999999E-006  1.458470000000000E-004   16.2934000000000
  9.642569999999999E-006  1.621340000000000E-004   16.3433000000000
  1.068750000000000E-005  1.802380000000000E-004   16.3932000000000
  1.184550000000000E-005  2.003600000000000E-004   16.4430000000000
  1.312900000000000E-005  2.227240000000000E-004   16.4929000000000
  1.455130000000000E-005  2.475800000000000E-004   16.5428000000000
  1.612760000000000E-005  2.752060000000000E-004   16.5927000000000
  1.787460000000000E-005  3.059090000000000E-004   16.6426000000000
  1.981060000000000E-005  3.400320000000000E-004   16.6924000000000
  2.195610000000000E-005  3.779550000000000E-004   16.7423000000000
  2.433380000000000E-005  4.201000000000000E-004   16.7922000000000
  2.696870000000000E-005  4.669380000000000E-004   16.8421000000000
  2.988880000000000E-005  5.189890000000000E-004   16.8920000000000
  3.312480000000000E-005  5.768330000000000E-004   16.9418000000000
  3.671080000000000E-005  6.411140000000000E-004   16.9917000000000
  4.068470000000000E-005  7.125470000000000E-004   17.0416000000000
  4.508840000000000E-005  7.919260000000000E-004   17.0915000000000
  4.996850000000000E-005  8.801340000000000E-004   17.1414000000000
  5.537620000000000E-005  9.781519999999999E-004   17.1913000000000
  6.136880000000000E-005  1.087070000000000E-003   17.2411000000000
  6.800930000000000E-005  1.208100000000000E-003   17.2910000000000
  7.536780000000000E-005  1.342580000000000E-003   17.3409000000000
  8.352190000000000E-005  1.492000000000000E-003   17.3908000000000
  9.255750000000000E-005  1.658040000000000E-003   17.4407000000000
  1.025700000000000E-004  1.842520000000000E-003   17.4906000000000
  1.136640000000000E-004  2.047490000000000E-003   17.5405000000000
  1.259580000000000E-004  2.275240000000000E-003   17.5904000000000
  1.395800000000000E-004  2.528280000000000E-003   17.6403000000000
  1.546750000000000E-004  2.809420000000000E-003   17.6902000000000
  1.714000000000000E-004  3.121780000000000E-003   17.7401000000000
  1.899330000000000E-004  3.468810000000000E-003   17.7899000000000
  2.104680000000000E-004  3.854370000000000E-003   17.8398000000000
  2.332220000000000E-004  4.282710000000000E-003   17.8897000000000
  2.584340000000000E-004  4.758600000000000E-003   17.9396000000000
  2.863690000000000E-004  5.287290000000000E-003   17.9895000000000
  3.173220000000000E-004  5.874630000000000E-003   18.0394000000000
  3.516180000000000E-004  6.527120000000000E-003   18.0893000000000
  3.896180000000000E-004  7.251990000000000E-003   18.1392000000000
  4.317210000000000E-004  8.057230000000000E-003   18.1891000000000
  4.783720000000000E-004  8.951770000000000E-003   18.2390000000000
  5.300590000000000E-004  9.945490000000000E-003   18.2889000000000
  5.873270000000000E-004  1.104940000000000E-002   18.3388000000000
  6.507790000000000E-004  1.227560000000000E-002   18.3887000000000
  7.210800000000000E-004  1.363770000000000E-002   18.4386000000000
  7.989710000000000E-004  1.515080000000000E-002   18.4885000000000
  8.852690000000001E-004  1.683140000000000E-002   18.5384000000000
  9.808820000000000E-004  1.869830000000000E-002   18.5883000000000
  1.086810000000000E-003  2.077200000000000E-002   18.6382000000000
  1.204180000000000E-003  2.307530000000000E-002   18.6881000000000
  1.334210000000000E-003  2.563380000000000E-002   18.7380000000000
  1.478270000000000E-003  2.847550000000000E-002   18.7879000000000
  1.637880000000000E-003  3.163180000000000E-002   18.8378000000000
  1.814710000000000E-003  3.513740000000000E-002   18.8877000000000
  2.010620000000000E-003  3.903120000000000E-002   18.9376000000000
  2.227660000000000E-003  4.335580000000000E-002   18.9875000000000
  2.468110000000000E-003  4.815900000000000E-002   19.0374000000000
  2.734500000000000E-003  5.349360000000000E-002   19.0874000000000
  3.029630000000000E-003  5.941840000000000E-002   19.1373000000000
  3.356590000000000E-003  6.599850000000000E-002   19.1872000000000
  3.718810000000000E-003  7.330639999999999E-002   19.2371000000000
  4.120090000000000E-003  8.142260000000000E-002   19.2870000000000
  4.564650000000000E-003  9.043619999999999E-002   19.3369000000000
  5.057140000000000E-003  0.100446000000000        19.3868000000000
  5.602740000000000E-003  0.111563000000000        19.4367000000000
  6.207160000000000E-003  0.123909000000000        19.4866000000000
  6.876740000000000E-003  0.137619000000000        19.5365000000000
  7.618510000000000E-003  0.152844000000000        19.5865000000000
  8.440240000000000E-003  0.169751000000000        19.6364000000000
  9.350549999999999E-003  0.188527000000000        19.6863000000000
  1.035900000000000E-002  0.209376000000000        19.7362000000000
  1.147610000000000E-002  0.232529000000000        19.7861000000000
  1.271360000000000E-002  0.258239000000000        19.8360000000000
  1.408450000000000E-002  0.286788000000000        19.8859000000000
  1.560310000000000E-002  0.318489000000000        19.9358000000000
  1.728530000000000E-002  0.353691000000000        19.9857000000000
  1.914880000000000E-002  0.392779000000000        20.0357000000000
  2.121310000000000E-002  0.436181000000000        20.0856000000000
  2.349980000000000E-002  0.484374000000000        20.1355000000000
  2.603280000000000E-002  0.537885000000000        20.1854000000000
  2.883870000000000E-002  0.597302000000000        20.2353000000000
  3.194690000000000E-002  0.663274000000000        20.2852000000000
  3.538990000000000E-002  0.736524000000000        20.3352000000000
  3.920370000000000E-002  0.817855000000000        20.3851000000000
  4.342820000000000E-002  0.908156000000000        20.4350000000000
  4.810770000000000E-002   1.00842000000000        20.4849000000000
  5.329120000000000E-002   1.11973000000000        20.5348000000000
  5.903280000000000E-002   1.24332000000000        20.5848000000000
  6.539270000000000E-002   1.38054000000000        20.6347000000000
  7.243740000000000E-002   1.53289000000000        20.6846000000000
  8.024060000000000E-002   1.70202000000000        20.7345000000000
  8.888390000000000E-002   1.88980000000000        20.7844000000000
  9.845780000000000E-002   2.09828000000000        20.8344000000000
  0.109062000000000        2.32972000000000        20.8843000000000
  0.120808000000000        2.58667000000000        20.9342000000000
  0.133819000000000        2.87193000000000        20.9841000000000
  0.148229000000000        3.18861000000000        21.0340000000000
  0.164191000000000        3.54017000000000        21.0840000000000
  0.181870000000000        3.93046000000000        21.1339000000000
  0.201453000000000        4.36372000000000        21.1838000000000
  0.223142000000000        4.84469000000000        21.2337000000000
  0.247166000000000        5.37862000000000        21.2837000000000
  0.273774000000000        5.97134000000000        21.3336000000000
  0.303246000000000        6.62930000000000        21.3835000000000
  0.335888000000000        7.35969000000000        21.4334000000000
  0.372042000000000        8.17046000000000        21.4834000000000
  0.412086000000000        9.07046000000000        21.5333000000000
  0.456437000000000        10.0695000000000        21.5832000000000
  0.505560000000000        11.1784000000000        21.6331000000000
  0.559966000000000        12.4094000000000        21.6831000000000
  0.620224000000000        13.7758000000000        21.7330000000000
  0.686963000000000        15.2925000000000        21.7829000000000
  0.760880000000000        16.9760000000000        21.8329000000000
  0.842747000000000        18.8446000000000        21.8828000000000
  0.933417000000000        20.9187000000000        21.9327000000000
   1.03384000000000        23.2209000000000        21.9826000000000
   1.14506000000000        25.7762000000000        22.0326000000000
   1.26823000000000        28.6124000000000        22.0825000000000
   1.40466000000000        31.7604000000000        22.1324000000000
   1.55574000000000        35.2544000000000        22.1824000000000
   1.72308000000000        39.1324000000000        22.2323000000000
   1.90840000000000        43.4366000000000        22.2822000000000
   2.11364000000000        48.2137000000000        22.3321000000000
   2.34095000000000        53.5157000000000        22.3821000000000
   2.59269000000000        59.4002000000000        22.4320000000000
   2.87149000000000        65.9312000000000        22.4819000000000
   3.18025000000000        73.1795000000000        22.5319000000000
   3.52220000000000        81.2239000000000        22.5818000000000
   3.90089000000000        90.1519000000000        22.6317000000000
   4.32029000000000        100.060000000000        22.6817000000000
   4.78475000000000        111.057000000000        22.7316000000000
   5.29912000000000        123.260000000000        22.7815000000000
   5.86876000000000        136.804000000000        22.8315000000000
   6.49961000000000        151.834000000000        22.8814000000000
   7.19824000000000        168.514000000000        22.9313000000000
   7.97193000000000        187.025000000000        22.9813000000000
   8.82874000000000        207.567000000000        23.0312000000000
   9.77759000000000        230.364000000000        23.0811000000000
   10.8284000000000        255.662000000000        23.1311000000000
   11.9920000000000        283.735000000000        23.1810000000000
   13.2807000000000        314.889000000000        23.2309000000000
   14.7077000000000        349.460000000000        23.2809000000000
   16.2881000000000        387.823000000000        23.3308000000000
   18.0381000000000        430.395000000000        23.3808000000000
   19.9762000000000        477.635000000000        23.4307000000000
   22.1223000000000        530.055000000000        23.4806000000000
   24.4989000000000        588.224000000000        23.5306000000000
   27.1308000000000        652.771000000000        23.5805000000000
   30.0452000000000        724.394000000000        23.6304000000000
   33.2726000000000        803.870000000000        23.6804000000000
   36.8465000000000        892.057000000000        23.7303000000000
   40.8041000000000        989.910000000000        23.7803000000000
   45.1866000000000        1098.49000000000        23.8302000000000
   50.0396000000000        1218.97000000000        23.8801000000000
   55.4135000000000        1352.65000000000        23.9301000000000
   61.3644000000000        1500.97000000000        23.9800000000000
   67.9541000000000        1665.55000000000        24.0300000000000
   75.2511000000000        1848.16000000000        24.0799000000000
   83.3313000000000        2050.78000000000        24.1298000000000
   92.2787000000000        2275.59000000000        24.1798000000000
   102.187000000000        2525.02000000000        24.2297000000000
   113.158000000000        2801.77000000000        24.2797000000000
   125.306000000000        3108.83000000000        24.3296000000000
   138.758000000000        3449.51000000000        24.3795000000000
   153.654000000000        3827.50000000000        24.4295000000000
   170.148000000000        4246.87000000000        24.4794000000000
   188.412000000000        4712.15000000000        24.5294000000000
   208.636000000000        5228.37000000000        24.5793000000000
   231.030000000000        5801.10000000000        24.6293000000000
   255.826000000000        6436.52000000000        24.6792000000000
   283.283000000000        7141.48000000000        24.7291000000000
   313.685000000000        7923.58000000000        24.7791000000000
   347.349000000000        8791.28000000000        24.8290000000000
   384.624000000000        9753.92000000000        24.8790000000000
   425.897000000000        10821.9000000000        24.9289000000000
   471.597000000000        12006.7000000000        24.9789000000000
   522.200000000000        13321.1000000000        25.0288000000000
   578.230000000000        14779.3000000000        25.0788000000000
   640.270000000000        16397.0000000000        25.1287000000000
   708.963000000000        18191.7000000000        25.1786000000000
   785.023000000000        20182.6000000000        25.2286000000000
   869.240000000000        22391.2000000000        25.2785000000000
   962.489000000000        24841.3000000000        25.3285000000000
   1065.74000000000        27559.4000000000        25.3784000000000
   1180.06000000000        30574.6000000000        25.4284000000000
   1306.63000000000        33919.5000000000        25.4783000000000
   1446.78000000000        37630.0000000000        25.5283000000000
   1601.96000000000        41746.1000000000        25.5782000000000
   1773.77000000000        46312.1000000000        25.6282000000000
   1964.01000000000        51377.2000000000        25.6781000000000
   2174.64000000000        56995.8000000000        25.7280000000000
   2407.84000000000        63228.4000000000        25.7780000000000
   2666.05000000000        70142.0000000000        25.8279000000000
   2951.94000000000        77811.1000000000        25.8779000000000
   3268.48000000000        86318.0000000000        25.9278000000000
   3618.94000000000        95754.4000000000        25.9778000000000
   4006.96000000000        106222.000000000        26.0277000000000
   4436.58000000000        117832.000000000        26.0777000000000
   4912.24000000000        130711.000000000        26.1276000000000
   5438.88000000000        144996.000000000        26.1776000000000
   6021.96000000000        160842.000000000        26.2275000000000
   6667.53000000000        178418.000000000        26.2775000000000
   7382.29000000000        197913.000000000        26.3274000000000
   8173.62000000000        219536.000000000        26.3774000000000
   9049.77000000000        243521.000000000        26.4273000000000
   10019.8000000000        270124.000000000        26.4773000000000
   11093.7000000000        299632.000000000        26.5272000000000
   12282.8000000000        332360.000000000        26.5772000000000
   13599.2000000000        368661.000000000        26.6271000000000
   15056.7000000000        408925.000000000        26.6771000000000
   16670.3000000000        453582.000000000        26.7270000000000
   18456.8000000000        503113.000000000        26.7770000000000
   20434.6000000000        558049.000000000        26.8269000000000
   22624.4000000000        618980.000000000        26.8769000000000
   25048.7000000000        686558.000000000        26.9268000000000
   27732.7000000000        761510.000000000        26.9768000000000
   30704.2000000000        844639.000000000        27.0267000000000
   33994.0000000000        936837.000000000        27.0767000000000
   37636.1000000000        1039090.00000000        27.1266000000000
   41668.4000000000        1152500.00000000        27.1766000000000
   46132.5000000000        1278280.00000000        27.2265000000000
   51074.6000000000        1417770.00000000        27.2765000000000
   56546.1000000000        1572480.00000000        27.3265000000000
   62603.5000000000        1744060.00000000        27.3764000000000
   69309.6000000000        1934350.00000000        27.4264000000000
   76733.8000000000        2145380.00000000        27.4763000000000
   84953.0000000000        2379430.00000000        27.5263000000000
   94052.2000000000        2638990.00000000        27.5762000000000
   104126.000000000        2926850.00000000        27.6262000000000
   115278.000000000        3246080.00000000        27.6761000000000
   127624.000000000        3600110.00000000        27.7261000000000
   141292.000000000        3992740.00000000        27.7760000000000
   156424.000000000        4428150.00000000        27.8260000000000
   173175.000000000        4911010.00000000        27.8760000000000
   191720.000000000        5446500.00000000        27.9259000000000
   212250.000000000        6040330.00000000        27.9759000000000
   234977.000000000        6698870.00000000        28.0258000000000
   260138.000000000        7429170.00000000        28.0758000000000
   287992.000000000        8239030.00000000        28.1257000000000
   318827.000000000        9137110.00000000        28.1757000000000
   352962.000000000        10133000.0000000        28.2256000000000
   390752.000000000        11237400.0000000        28.2756000000000
   432586.000000000        12462100.0000000        28.3256000000000
   478897.000000000        13820200.0000000        28.3755000000000
   530164.000000000        15326200.0000000        28.4255000000000
   586919.000000000        16996300.0000000        28.4754000000000
   649747.000000000        18848100.0000000        28.5254000000000
   719298.000000000        20901700.0000000        28.5753000000000
   796292.000000000        23178800.0000000        28.6253000000000
   881526.000000000        25703900.0000000        28.6752000000000
   975879.000000000        28503900.0000000        28.7252000000000
   1080330.00000000        31608700.0000000        28.7752000000000
   1195950.00000000        35051500.0000000        28.8251000000000
   1323950.00000000        38869000.0000000        28.8751000000000
   1465640.00000000        43102100.0000000        28.9250000000000
   1622500.00000000        47796000.0000000        28.9750000000000
   1796130.00000000        53000700.0000000        29.0250000000000
   1988340.00000000        58771800.0000000        29.0749000000000
   2201110.00000000        65171000.0000000        29.1249000000000
   2436640.00000000        72266600.0000000        29.1748000000000
   2697370.00000000        80134200.0000000        29.2248000000000
   2985990.00000000        88857800.0000000        29.2747000000000
   3305490.00000000        98530600.0000000        29.3247000000000
   3659150.00000000        109256000.000000        29.3747000000000
   4050650.00000000        121148000.000000        29.4246000000000
   4484030.00000000        134333000.000000        29.4746000000000
   4963750.00000000        148953000.000000        29.5246000000000
   5494790.00000000        165163000.000000        29.5745000000000
   6082620.00000000        183136000.000000        29.6245000000000
   6733310.00000000        203064000.000000        29.6744000000000
   7453600.00000000        225159000.000000        29.7244000000000
   8250920.00000000        249657000.000000        29.7744000000000
   9133500.00000000        276819000.000000        29.8243000000000
   10110500.0000000        306934000.000000        29.8743000000000
   11191900.0000000        340324000.000000        29.9242000000000
   12389000.0000000        377344000.000000        29.9742000000000
   13714100.0000000        418389000.000000        30.0242000000000
   15180800.0000000        463896000.000000        30.0741000000000
   16804400.0000000        514350000.000000        30.1241000000000
   18601600.0000000        570288000.000000        30.1740000000000
   20590900.0000000        632307000.000000        30.2240000000000
   22793000.0000000        701066000.000000        30.2740000000000
   25230400.0000000        777299000.000000        30.3239000000000
   27928500.0000000        861816000.000000        30.3739000000000
   30915000.0000000        955518000.000000        30.4238000000000
   34220800.0000000        1059400000.00000        30.4738000000000
   37879900.0000000        1174580000.00000        30.5238000000000
   41930200.0000000        1302260000.00000        30.5737000000000
   46413400.0000000        1443820000.00000        30.6237000000000
   51375900.0000000        1600760000.00000        30.6737000000000
   56868800.0000000        1774750000.00000        30.7236000000000
   62948900.0000000        1967650000.00000        30.7736000000000
   69678800.0000000        2181490000.00000        30.8235000000000
   77128000.0000000        2418570000.00000        30.8735000000000
   85373400.0000000        2681390000.00000        30.9235000000000
   94500000.0000000        2972760000.00000        30.9734000000000
   104602000.000000        3295780000.00000        31.0234000000000
   115784000.000000        3653880000.00000        31.0733000000000
   128160000.000000        4050860000.00000        31.1233000000000
   141860000.000000        4490950000.00000        31.1733000000000
   157023000.000000        4978840000.00000        31.2233000000000
   173806000.000000        5519700000.00000        31.2732000000000
   192384000.000000        6119280000.00000        31.3232000000000
   212946000.000000        6783960000.00000        31.3731000000000
   235705000.000000        7520800000.00000        31.4231000000000
   260896000.000000        8337630000.00000        31.4731000000000
   288779000.000000        9243140000.00000        31.5230000000000
   319641000.000000        10246900000.0000        31.5730000000000
   353800000.000000        11359700000.0000        31.6230000000000
   391609000.000000        12593200000.0000        31.6729000000000
   433458000.000000        13960600000.0000        31.7229000000000
   479777000.000000        15476500000.0000        31.7729000000000
   531045000.000000        17156800000.0000        31.8228000000000
   587790000.000000        19019400000.0000        31.8728000000000
   650596000.000000        21084200000.0000        31.9227000000000
   720113000.000000        23373100000.0000        31.9727000000000
   797055000.000000        25910300000.0000        32.0227000000000
   882216000.000000        28722800000.0000        32.0726000000000
   976474000.000000        31840400000.0000        32.1226000000000
   1080800000.00000        35296200000.0000        32.1726000000000
   1196270000.00000        39127000000.0000        32.2225000000000
   1324070000.00000        43373300000.0000        32.2725000000000
   1465530000.00000        48080200000.0000        32.3225000000000
   1622090000.00000        53297700000.0000        32.3724000000000
   1795370000.00000        59081100000.0000        32.4224000000000
   1987160000.00000        65491700000.0000        32.4724000000000
   2199430000.00000        72597600000.0000        32.5223000000000
   2434380000.00000        80474200000.0000        32.5723000000000
   2694410000.00000        89204900000.0000        32.6223000000000
   2982210000.00000        98882400000.0000        32.6722000000000
   3300750000.00000        109609000000.000        32.7222000000000
   3653310000.00000        121499000000.000        32.7722000000000
   4043510000.00000        134678000000.000        32.8221000000000
   4475370000.00000        149287000000.000        32.8721000000000
   4953350000.00000        165478000000.000        32.9221000000000
   5482370000.00000        183426000000.000        32.9720000000000
   6067880000.00000        203318000000.000        33.0220000000000
   6715900000.00000        225368000000.000        33.0720000000000
   7433110000.00000        249807000000.000        33.1219000000000
   8226900000.00000        276895000000.000        33.1719000000000
   9105440000.00000        306920000000.000        33.2219000000000
   10077800000.0000        340198000000.000        33.2718000000000
   11153900000.0000        377083000000.000        33.3218000000000
   12344900000.0000        417966000000.000        33.3718000000000
   13663100000.0000        463279000000.000        33.4218000000000
   15122000000.0000        513502000000.000        33.4717000000000
   16736700000.0000        569168000000.000        33.5217000000000
   18523700000.0000        630865000000.000        33.5717000000000
   20501500000.0000        699247000000.000        33.6216000000000
   22690300000.0000        775038000000.000        33.6716000000000
   25112900000.0000        859040000000.000        33.7216000000000
   27794000000.0000        952143000000.000        33.7715000000000
   30761300000.0000        1055330000000.00        33.8215000000000
   34045300000.0000        1169700000000.00        33.8715000000000
   37679800000.0000        1296450000000.00        33.9214000000000
   41702300000.0000        1436940000000.00        33.9714000000000
   46154100000.0000        1592640000000.00        34.0214000000000
   51081000000.0000        1765210000000.00        34.0713000000000
   56533700000.0000        1956470000000.00        34.1213000000000
   62568400000.0000        2168440000000.00        34.1713000000000
   69247000000.0000        2403360000000.00        34.2213000000000
   76638500000.0000        2663730000000.00        34.2712000000000
   84818700000.0000        2952290000000.00        34.3212000000000
   93871900000.0000        3272100000000.00        34.3712000000000
   103891000000.000        3626530000000.00        34.4211000000000
   114980000000.000        4019340000000.00        34.4711000000000
   127251000000.000        4454690000000.00        34.5211000000000
   140832000000.000        4937160000000.00        34.5710000000000
   155863000000.000        5471870000000.00        34.6210000000000
   172497000000.000        6064460000000.00        34.6710000000000
   190906000000.000        6721210000000.00        34.7209000000000
   211279000000.000        7449050000000.00        34.7709000000000
   233826000000.000        8255670000000.00        34.8209000000000
   258778000000.000        9149600000000.00        34.8708000000000
   286393000000.000        10140300000000.0        34.9208000000000
   316954000000.000        11238200000000.0        34.9708000000000
   350775000000.000        12454900000000.0        35.0208000000000
   388204000000.000        13803300000000.0        35.0707000000000
   429627000000.000        15297700000000.0        35.1207000000000
   475469000000.000        16953700000000.0        35.1707000000000
   526201000000.000        18789000000000.0        35.2207000000000
   582345000000.000        20822800000000.0        35.2706000000000
   644478000000.000        23076700000000.0        35.3206000000000
   713239000000.000        25574500000000.0        35.3706000000000
   789334000000.000        28342500000000.0        35.4205000000000
   873547000000.000        31410000000000.0        35.4705000000000
   966743000000.000        34809300000000.0        35.5205000000000
   1069880000000.00        38576400000000.0        35.5704000000000
   1184020000000.00        42751000000000.0        35.6204000000000
   1310330000000.00        47377200000000.0        35.6704000000000
   1450110000000.00        52503800000000.0        35.7204000000000
   1604800000000.00        58184900000000.0        35.7703000000000
   1775990000000.00        64480500000000.0        35.8203000000000
   1965440000000.00        71457000000000.0        35.8703000000000
   2175090000000.00        79188000000000.0        35.9203000000000
   2407110000000.00        87755200000000.0        35.9702000000000
   2663860000000.00        97248800000000.0        36.0202000000000
   2948000000000.00        107769000000000.        36.0702000000000
   3262440000000.00        119427000000000.        36.1201000000000
   3610410000000.00        132346000000000.        36.1701000000000
   3995490000000.00        146661000000000.        36.2201000000000
   4421630000000.00        162524000000000.        36.2701000000000
   4893210000000.00        180103000000000.        36.3200000000000
   5415080000000.00        199582000000000.        36.3700000000000
   5992600000000.00        221167000000000.        36.4200000000000
   6631690000000.00        245085000000000.        36.4700000000000
   7338940000000.00        271589000000000.        36.5199000000000
   8121590000000.00        300958000000000.        36.5699000000000
   8987690000000.00        333502000000000.        36.6199000000000
   9946140000000.00        369564000000000.        36.6698000000000
   11006800000000.0        409524000000000.        36.7198000000000
   12180500000000.0        453803000000000.        36.7698000000000
   13479300000000.0        502868000000000.        36.8198000000000
   14916700000000.0        557235000000000.        36.8697000000000
   16507300000000.0        617479000000000.        36.9197000000000
   18267400000000.0        684233000000000.        36.9697000000000
   20215200000000.0        758201000000000.        37.0197000000000
   22370600000000.0        840162000000000.        37.0696000000000
   24755800000000.0        930980000000000.        37.1196000000000
   27395300000000.0       1.031610000000000E+015   37.1696000000000
   30316100000000.0       1.143120000000000E+015   37.2196000000000
   33548400000000.0       1.266670000000000E+015   37.2695000000000
   37125100000000.0       1.403570000000000E+015   37.3195000000000
   41083100000000.0       1.555260000000000E+015   37.3695000000000
   45463100000000.0       1.723340000000000E+015   37.4194000000000
   50309800000000.0       1.909580000000000E+015   37.4694000000000
   55673200000000.0       2.115940000000000E+015   37.5194000000000
   61608300000000.0       2.344590000000000E+015   37.5694000000000
   68176000000000.0       2.597940000000000E+015   37.6194000000000
   75443700000000.0       2.878660000000000E+015   37.6693000000000
   83486000000000.0       3.189700000000000E+015   37.7193000000000
   92385500000000.0       3.534330000000000E+015   37.7693000000000
   102233000000000.       3.916190000000000E+015   37.8192000000000
   113131000000000.       4.339290000000000E+015   37.8692000000000
   125190000000000.       4.808080000000000E+015   37.9192000000000
   138534000000000.       5.327510000000000E+015   37.9692000000000
   153300000000000.       5.903020000000000E+015   38.0191000000000
   169640000000000.       6.540690000000000E+015   38.0691000000000
   187721000000000.       7.247220000000000E+015   38.1191000000000
   207729000000000.       8.030040000000000E+015   38.1691000000000
   229869000000000.       8.897390000000000E+015   38.2191000000000
   254369000000000.       9.858380000000000E+015   38.2690000000000
   281479000000000.       1.092310000000000E+016   38.3190000000000
   311477000000000.       1.210290000000000E+016   38.3690000000000
   344673000000000.       1.341000000000000E+016   38.4189000000000
   381406000000000.       1.485820000000000E+016   38.4689000000000
   422053000000000.       1.646270000000000E+016   38.5189000000000
   467031000000000.       1.824050000000000E+016   38.5689000000000
   516801000000000.       2.021010000000000E+016   38.6189000000000
   571874000000000.       2.239240000000000E+016   38.6688000000000
   632815000000000.       2.481030000000000E+016   38.7188000000000
   700250000000000.       2.748920000000000E+016   38.7688000000000
   774868000000000.       3.045710000000000E+016   38.8188000000000
   857438000000000.       3.374550000000000E+016   38.8687000000000
   948803000000000.       3.738870000000000E+016   38.9187000000000
  1.049900000000000E+015  4.142520000000000E+016   38.9687000000000
  1.161770000000000E+015  4.589730000000000E+016   39.0187000000000
  1.285560000000000E+015  5.085200000000000E+016   39.0686000000000
  1.422540000000000E+015  5.634140000000000E+016   39.1186000000000
  1.574110000000000E+015  6.242310000000000E+016   39.1686000000000
  1.741830000000000E+015  6.916120000000000E+016   39.2186000000000
  1.927410000000000E+015  7.662630000000000E+016   39.2685000000000
  2.132760000000000E+015  8.489690000000000E+016   39.3185000000000
  2.359990000000000E+015  9.405990000000000E+016   39.3685000000000
  2.611420000000000E+015  1.042120000000000E+017   39.4185000000000
  2.889640000000000E+015  1.154590000000000E+017   39.4684000000000
  3.197490000000000E+015  1.279190000000000E+017   39.5184000000000
  3.538130000000000E+015  1.417240000000000E+017   39.5684000000000
  3.915060000000000E+015  1.570180000000000E+017   39.6184000000000
  4.332130000000000E+015  1.739610000000000E+017   39.6684000000000
  4.793630000000000E+015  1.927330000000000E+017   39.7183000000000
  5.304290000000000E+015  2.135300000000000E+017   39.7683000000000
  5.869330000000000E+015  2.365700000000000E+017   39.8183000000000
  6.494570000000000E+015  2.620950000000000E+017   39.8683000000000
  7.186390000000000E+015  2.903730000000000E+017   39.9182000000000
  7.951890000000000E+015  3.217020000000000E+017   39.9682000000000
  8.798920000000000E+015  3.564090000000000E+017   40.0182000000000
  9.736170000000000E+015  3.948600000000000E+017   40.0682000000000
  1.077320000000000E+016  4.374580000000000E+017   40.1181000000000
  1.192070000000000E+016  4.846490000000000E+017   40.1681000000000
  1.319050000000000E+016  5.369300000000000E+017   40.2181000000000
  1.459540000000000E+016  5.948490000000000E+017   40.2681000000000
  1.614990000000000E+016  6.590140000000000E+017   40.3181000000000
  1.787000000000000E+016  7.300980000000000E+017   40.3680000000000
  1.977330000000000E+016  8.088470000000000E+017   40.4180000000000
  2.187930000000000E+016  8.960870000000000E+017   40.4680000000000
  2.420950000000000E+016  9.927330000000000E+017   40.5180000000000
  2.678790000000000E+016  1.099800000000000E+018   40.5679000000000
  2.964080000000000E+016  1.218410000000000E+018   40.6179000000000
  3.279750000000000E+016  1.349810000000000E+018   40.6679000000000
  3.629030000000000E+016  1.495370000000000E+018   40.7179000000000
  4.015510000000000E+016  1.656630000000000E+018   40.7679000000000
  4.443130000000000E+016  1.835280000000000E+018   40.8178000000000
  4.916290000000000E+016  2.033180000000000E+018   40.8678000000000
  5.439830000000000E+016  2.252410000000000E+018   40.9178000000000
  6.019110000000000E+016  2.495280000000000E+018   40.9678000000000
  6.660070000000000E+016  2.764320000000000E+018   41.0178000000000
  7.369280000000000E+016  3.062370000000000E+018   41.0677000000000
  8.153990000000000E+016  3.392540000000000E+018   41.1177000000000
  9.022250000000000E+016  3.758290000000000E+018   41.1677000000000
  9.982950000000000E+016  4.163470000000000E+018   41.2177000000000
  1.104590000000000E+017  4.612320000000000E+018   41.2677000000000
  1.222210000000000E+017  5.109540000000000E+018   41.3176000000000
  1.352350000000000E+017  5.660350000000000E+018   41.3676000000000
  1.496340000000000E+017  6.270520000000000E+018   41.4176000000000
  1.655660000000000E+017  6.946440000000000E+018   41.4676000000000
  1.831940000000000E+017  7.695200000000000E+018   41.5175000000000
  2.026980000000000E+017  8.524640000000000E+018   41.5675000000000
  2.242800000000000E+017  9.443460000000000E+018   41.6175000000000
  2.481580000000000E+017  1.046130000000000E+019   41.6675000000000
  2.745780000000000E+017  1.158880000000000E+019   41.7175000000000
  3.038110000000000E+017  1.283780000000000E+019   41.7674000000000
  3.361560000000000E+017  1.422130000000000E+019   41.8174000000000
  3.719430000000000E+017  1.575390000000000E+019   41.8674000000000
  4.115400000000000E+017  1.745170000000000E+019   41.9174000000000
  4.553520000000000E+017  1.933230000000000E+019   41.9674000000000
  5.038280000000000E+017  2.141550000000000E+019   42.0173000000000
  5.574630000000000E+017  2.372320000000000E+019   42.0673000000000
  6.168070000000000E+017  2.627950000000000E+019   42.1173000000000
  6.824680000000000E+017  2.911110000000000E+019   42.1673000000000
  7.551170000000000E+017  3.224780000000000E+019   42.2173000000000
  8.354990000000000E+017  3.572230000000000E+019   42.2672000000000
  9.244360000000000E+017  3.957110000000000E+019   42.3172000000000
  1.022840000000000E+018  4.383440000000000E+019   42.3672000000000
  1.131710000000000E+018  4.855700000000000E+019   42.4172000000000
  1.252180000000000E+018  5.378810000000000E+019   42.4671000000000
  1.385460000000000E+018  5.958270000000000E+019   42.5171000000000
  1.532930000000000E+018  6.600140000000000E+019   42.5671000000000
  1.696100000000000E+018  7.311130000000000E+019   42.6171000000000
  1.876620000000000E+018  8.098690000000000E+019   42.6671000000000
  2.076370000000000E+018  8.971070000000000E+019   42.7171000000000
  2.297360000000000E+018  9.937390000000000E+019   42.7670000000000
  2.541880000000000E+018  1.100780000000000E+020   42.8170000000000
  2.812420000000000E+018  1.219340000000000E+020   42.8670000000000
  3.111740000000000E+018  1.350670000000000E+020   42.9170000000000
  3.442920000000000E+018  1.496140000000000E+020   42.9669000000000
  3.809340000000000E+018  1.657280000000000E+020   43.0169000000000
  4.214760000000000E+018  1.835760000000000E+020   43.0669000000000
  4.663310000000000E+018  2.033460000000000E+020   43.1169000000000
  5.159600000000000E+018  2.252450000000000E+020   43.1669000000000
  5.708690000000000E+018  2.495020000000000E+020   43.2169000000000
  6.316210000000000E+018  2.763690000000000E+020   43.2668000000000
  6.988380000000000E+018  3.061300000000000E+020   43.3168000000000
  7.732070000000000E+018  3.390940000000000E+020   43.3668000000000
  8.554890000000000E+018  3.756070000000000E+020   43.4168000000000
  9.465250000000000E+018  4.160500000000000E+020   43.4668000000000
  1.047250000000000E+019  4.608470000000000E+020   43.5167000000000
  1.158690000000000E+019  5.104660000000000E+020   43.5667000000000
  1.281980000000000E+019  5.654260000000000E+020   43.6167000000000
  1.418400000000000E+019  6.263010000000000E+020   43.6667000000000
  1.569330000000000E+019  6.937290000000000E+020   43.7167000000000
  1.736320000000000E+019  7.684150000000000E+020   43.7666000000000
  1.921070000000000E+019  8.511380000000001E+020   43.8166000000000
  2.125480000000000E+019  9.427650000000000E+020   43.8666000000000
  2.351630000000000E+019  1.044250000000000E+021   43.9166000000000
  2.601850000000000E+019  1.156660000000000E+021   43.9666000000000
  2.878680000000000E+019  1.281170000000000E+021   44.0166000000000
  3.184970000000000E+019  1.419080000000000E+021   44.0665000000000
  3.523840000000000E+019  1.571830000000000E+021   44.1165000000000
  3.898760000000000E+019  1.741010000000000E+021   44.1665000000000
  4.313570000000000E+019  1.928400000000000E+021   44.2165000000000
  4.772500000000000E+019  2.135950000000000E+021   44.2665000000000
  5.280260000000000E+019  2.365840000000000E+021   44.3164000000000
  5.842020000000000E+019  2.620460000000000E+021   44.3664000000000
  6.463550000000000E+019  2.902480000000000E+021   44.4164000000000
  7.151190000000000E+019  3.214850000000000E+021   44.4664000000000
  7.911980000000000E+019  3.560820000000000E+021   44.5164000000000
  8.753690000000000E+019  3.944010000000000E+021   44.5663000000000
  9.684940000000000E+019  4.368430000000000E+021   44.6163000000000
  1.071520000000000E+020  4.838510000000000E+021   44.6663000000000
  1.185510000000000E+020  5.359160000000000E+021   44.7163000000000
  1.311630000000000E+020  5.935820000000000E+021   44.7663000000000
  1.451160000000000E+020  6.574510000000000E+021   44.8163000000000
  1.605530000000000E+020  7.281920000000000E+021   44.8662000000000
  1.776310000000000E+020  8.065420000000000E+021   44.9162000000000
  1.965270000000000E+020  8.933190000000000E+021   44.9662000000000
  2.174320000000000E+020  9.894310000000001E+021   45.0162000000000
  2.405610000000000E+020  1.095880000000000E+022   45.0662000000000
  2.661490000000000E+020  1.213780000000000E+022   45.1161000000000
  2.944590000000000E+020  1.344360000000000E+022   45.1661000000000
  3.257800000000000E+020  1.488990000000000E+022   45.2161000000000
  3.604320000000000E+020  1.649170000000000E+022   45.2661000000000
  3.987690000000000E+020  1.826570000000000E+022   45.3161000000000
  4.411840000000000E+020  2.023060000000000E+022   45.3661000000000
  4.881090000000000E+020  2.240680000000000E+022   45.4160000000000
  5.400250000000000E+020  2.481700000000000E+022   45.4660000000000
  5.974620000000001E+020  2.748640000000000E+022   45.5160000000000
  6.610070000000000E+020  3.044290000000000E+022   45.5660000000000
  7.313110000000000E+020  3.371730000000000E+022   45.6160000000000
  8.090900000000001E+020  3.734370000000000E+022   45.6660000000000
  8.951410000000000E+020  4.136020000000000E+022   45.7159000000000
  9.903420000000001E+020  4.580850000000000E+022   45.7659000000000
  1.095670000000000E+021  5.073510000000000E+022   45.8159000000000
  1.212190000000000E+021  5.619140000000000E+022   45.8659000000000
  1.341110000000000E+021  6.223440000000000E+022   45.9159000000000
  1.483730000000000E+021  6.892720000000000E+022   45.9659000000000
  1.641520000000000E+021  7.633940000000000E+022   46.0158000000000
  1.816090000000000E+021  8.454860000000000E+022   46.0658000000000
  2.009230000000000E+021  9.364040000000000E+022   46.1158000000000
  2.222890000000000E+021  1.037100000000000E+023   46.1658000000000
  2.459280000000000E+021  1.148610000000000E+023   46.2158000000000
  2.720800000000000E+021  1.272120000000000E+023   46.2657000000000
  3.010130000000000E+021  1.408900000000000E+023   46.3157000000000
  3.330230000000000E+021  1.560380000000000E+023   46.3657000000000
  3.684350000000000E+021  1.728150000000000E+023   46.4157000000000
  4.076130000000000E+021  1.913950000000000E+023   46.4657000000000
  4.509570000000000E+021  2.119730000000000E+023   46.5157000000000
  4.989090000000000E+021  2.347620000000000E+023   46.5656000000000
  5.519590000000000E+021  2.600010000000000E+023   46.6156000000000
  6.106490000000000E+021  2.879530000000000E+023   46.6656000000000
  6.755800000000000E+021  3.189080000000000E+023   46.7156000000000
  7.474130000000000E+021  3.531910000000000E+023   46.7656000000000
  8.268840000000000E+021  3.911580000000000E+023   46.8156000000000
  9.148040000000000E+021  4.332060000000000E+023   46.8655000000000
  1.012070000000000E+022  4.797730000000000E+023   46.9155000000000
  1.119680000000000E+022  5.313440000000000E+023   46.9655000000000
  1.238720000000000E+022  5.884570000000000E+023   47.0155000000000
  1.370430000000000E+022  6.517080000000000E+023   47.0655000000000
  1.516130000000000E+022  7.217559999999999E+023   47.1155000000000
  1.677330000000000E+022  7.993309999999999E+023   47.1654000000000
  1.855660000000000E+022  8.852419999999999E+023   47.2154000000000
  2.052940000000000E+022  9.803840000000000E+023   47.2654000000000
  2.271200000000000E+022  1.085750000000000E+024   47.3154000000000
  2.512660000000000E+022  1.202440000000000E+024   47.3654000000000
  2.779790000000000E+022  1.331660000000000E+024   47.4154000000000
  3.075320000000000E+022  1.474770000000000E+024   47.4653000000000
  3.402260000000000E+022  1.633250000000000E+024   47.5153000000000
  3.763950000000000E+022  1.808770000000000E+024   47.5653000000000
  4.164090000000000E+022  2.003140000000000E+024   47.6153000000000
  4.606760000000000E+022  2.218390000000000E+024   47.6653000000000
  5.096490000000000E+022  2.456760000000000E+024   47.7153000000000
  5.638270000000000E+022  2.720750000000000E+024   47.7652000000000
  6.237640000000000E+022  3.013090000000000E+024   47.8152000000000
  6.900720000000000E+022  3.336840000000000E+024   47.8652000000000
  7.634270000000000E+022  3.695370000000000E+024   47.9152000000000
  8.445799999999999E+022  4.092410000000000E+024   47.9652000000000
  9.343579999999999E+022  4.532100000000000E+024   48.0152000000000
  1.033680000000000E+023  5.019020000000000E+024   48.0652000000000
  1.143560000000000E+023  5.558250000000000E+024   48.1151000000000
  1.265110000000000E+023  6.155390000000000E+024   48.1651000000000
  1.399580000000000E+023  6.816670000000000E+024   48.2151000000000
  1.548350000000000E+023  7.548980000000000E+024   48.2651000000000
  1.712930000000000E+023  8.359940000000000E+024   48.3151000000000
  1.895000000000000E+023  9.258010000000000E+024   48.3651000000000
  2.096420000000000E+023  1.025250000000000E+025   48.4150000000000
  2.319240000000000E+023  1.135380000000000E+025   48.4650000000000
  2.565750000000000E+023  1.257340000000000E+025   48.5150000000000
   1   1   2   3   3   4   0   1   1   1   2   2
  0.000000000000000E+000  0.000000000000000E+000  0.705880000000000
  0.705880000000000       0.705880000000000       0.705880000000000
   1.00000000000000        1.00000000000000        3.00000000000000
   3.00000000000000        3.00000000000000        2.00000000000000
   8.07131000000004        7.28897545999993        13.1357354599999
   14.9497831614761        14.9311833068413        2.42492104827388
   26.1700000000000        19.2500000000000        24.2100000000000
   20.9200000000000        23.1500000000000        18.0100000000000
   19.5500000000000        16.9400000000000        19.7300000000000
   17.0700000000000        18.2100000000000        14.9900000000000
   16.0100000000000        12.0400000000000        13.2700000000000
   11.0900000000000        12.1700000000000        10.2600000000000
   11.0400000000000        8.41000000000000        9.79000000000000
   7.36000000000000        8.15000000000000        5.63000000000000
   5.88000000000000        3.17000000000000        3.32000000000000
  0.820000000000000        1.83000000000000       0.970000000000000
   2.33000000000000        1.27000000000000        2.92000000000000
   1.61000000000000        2.91000000000000        1.35000000000000
   2.40000000000000       0.890000000000000        1.74000000000000
  0.360000000000000       0.950000000000000      -0.650000000000000
 -4.000000000000000E-002  -1.73000000000000      -0.960000000000000
  -2.87000000000000       -2.05000000000000       -4.05000000000000
  -3.40000000000000       -5.72000000000000       -3.75000000000000
  -4.13000000000000       -2.42000000000000       -2.85000000000000
  -1.01000000000000       -1.33000000000000       0.540000000000000
 -2.000000000000000E-002   1.74000000000000       0.750000000000000
   2.24000000000000        1.00000000000000        1.98000000000000
  0.790000000000000        1.54000000000000       0.390000000000000
   1.08000000000000       0.000000000000000E+000  0.780000000000000
 -0.350000000000000       0.580000000000000      -0.550000000000000
  0.590000000000000      -0.610000000000000       0.590000000000000
 -0.350000000000000       0.320000000000000      -0.960000000000000
 -0.520000000000000       -2.08000000000000       -2.46000000000000
  -3.64000000000000       -1.55000000000000      -0.960000000000000
  0.970000000000000       0.880000000000000        2.37000000000000
   1.75000000000000        2.72000000000000        1.90000000000000
   2.55000000000000        1.46000000000000        1.93000000000000
  0.860000000000000        1.17000000000000       8.000000000000000E-002
  0.390000000000000      -0.760000000000000      -0.390000000000000
  -1.51000000000000       -1.17000000000000       -2.36000000000000
  -1.95000000000000       -3.06000000000000       -2.62000000000000
  -3.55000000000000       -2.95000000000000       -3.75000000000000
  -3.07000000000000       -3.79000000000000       -3.06000000000000
  -3.77000000000000       -3.05000000000000       -3.78000000000000
  -3.12000000000000       -3.90000000000000       -3.35000000000000
  -4.24000000000000       -3.86000000000000       -4.92000000000000
  -5.06000000000000       -6.77000000000000       -7.41000000000000
  -9.18000000000000       -10.1600000000000       -11.1200000000000
  -9.76000000000000       -9.23000000000000       -7.96000000000000
  -7.65000000000000
  -8.32000000000000       -15.9000000000000       -11.5100000000000
  -14.3100000000000       -11.5700000000000       -15.9000000000000
  -13.9100000000000       -16.0300000000000       -12.1300000000000
  -13.8700000000000       -12.2500000000000       -14.4000000000000
  -13.0700000000000       -15.8000000000000       -13.8100000000000
  -14.9800000000000       -12.6300000000000       -13.7600000000000
  -11.3700000000000       -12.3800000000000       -9.23000000000000
  -9.65000000000000       -7.64000000000000       -9.17000000000000
  -8.05000000000000       -9.72000000000000       -8.87000000000000
  -10.7600000000000       -8.64000000000000       -8.89000000000000
  -6.60000000000000       -7.13000000000000       -4.77000000000000
  -5.33000000000000       -3.06000000000000       -3.79000000000000
  -1.72000000000000       -2.79000000000000      -0.930000000000000
  -2.19000000000000      -0.520000000000000       -1.90000000000000
 -0.450000000000000       -2.20000000000000       -1.22000000000000
  -3.07000000000000       -2.42000000000000       -4.37000000000000
  -3.94000000000000       -6.08000000000000       -4.49000000000000
  -4.50000000000000       -3.14000000000000       -2.93000000000000
  -1.04000000000000       -1.36000000000000       0.690000000000000
  0.210000000000000        2.11000000000000        1.33000000000000
   3.29000000000000        2.46000000000000        4.30000000000000
   3.32000000000000        4.79000000000000        3.62000000000000
   4.97000000000000        3.64000000000000        4.63000000000000
   3.07000000000000        4.06000000000000        2.49000000000000
   3.30000000000000        1.46000000000000        2.06000000000000
  0.510000000000000       0.740000000000000       -1.18000000000000
  -1.26000000000000       -3.54000000000000       -3.97000000000000
  -5.26000000000000       -4.18000000000000       -3.71000000000000
  -2.10000000000000       -1.70000000000000      -8.000000000000000E-002
 -0.180000000000000       0.940000000000000       0.270000000000000
   1.13000000000000       8.000000000000000E-002  0.910000000000000
 -0.310000000000000       0.490000000000000      -0.780000000000000
  8.000000000000000E-002  -1.15000000000000      -0.230000000000000
  -1.41000000000000      -0.420000000000000       -1.55000000000000
 -0.550000000000000       -1.66000000000000      -0.660000000000000
  -1.73000000000000      -0.750000000000000       -1.74000000000000
 -0.780000000000000       -1.69000000000000      -0.780000000000000
  -1.60000000000000      -0.750000000000000       -1.46000000000000
 -0.670000000000000       -1.26000000000000      -0.510000000000000
  -1.04000000000000      -0.530000000000000       -1.84000000000000
  -2.42000000000000       -4.52000000000000       -4.76000000000000
  -6.33000000000000       -6.76000000000000       -7.81000000000000
  -5.80000000000000       -5.37000000000000       -3.63000000000000
  -3.35000000000000       -1.75000000000000       -1.88000000000000
 -0.610000000000000      -0.900000000000000       9.000000000000000E-002
 -0.320000000000000       0.550000000000000      -0.130000000000000
  0.700000000000000      -6.000000000000000E-002  0.490000000000000
 -0.200000000000000       0.400000000000000      -0.220000000000000
  0.360000000000000      -9.000000000000000E-002  0.580000000000000
  0.120000000000000       0.750000000000000       0.150000000000000
  0.700000000000000       0.170000000000000        1.11000000000000
  0.890000000000000        1.85000000000000        1.62000000000000
   2.54000000000000        2.29000000000000        3.20000000000000
   2.91000000000000        3.84000000000000        3.53000000000000
   4.48000000000000        4.15000000000000        5.12000000000000
   4.78000000000000        5.75000000000000        5.39000000000000
   6.31000000000000        5.91000000000000        6.87000000000000
   6.33000000000000        7.13000000000000        6.61000000000000
   7.30000000000000        6.31000000000000        6.27000000000000
   4.83000000000000        4.49000000000000        2.85000000000000
   2.32000000000000       0.580000000000000      -0.110000000000000
 -0.980000000000000       0.810000000000000        1.77000000000000
   3.37000000000000        4.13000000000000        5.60000000000000
   6.15000000000000        7.29000000000000        7.35000000000000
   7.95000000000000        7.67000000000000        8.16000000000000
   7.83000000000000        8.31000000000000        8.01000000000000
   8.53000000000000        8.27000000000000
  0.000000000000000E+000   5.44000000000000       0.000000000000000E+000
   2.76000000000000       0.000000000000000E+000   3.34000000000000
  0.000000000000000E+000   2.70000000000000       0.000000000000000E+000
   1.90000000000000       0.000000000000000E+000   2.12000000000000
  0.000000000000000E+000   2.13000000000000       0.000000000000000E+000
   1.54000000000000       0.000000000000000E+000   1.42000000000000
  0.000000000000000E+000   1.51000000000000       0.000000000000000E+000
   1.73000000000000       0.000000000000000E+000   1.44000000000000
  0.000000000000000E+000   1.45000000000000       0.000000000000000E+000
   1.37000000000000       0.000000000000000E+000   1.09000000000000
  0.000000000000000E+000   1.36000000000000       0.000000000000000E+000
   1.42000000000000       0.000000000000000E+000   1.33000000000000
  0.000000000000000E+000   1.20000000000000       0.000000000000000E+000
   1.00000000000000       0.000000000000000E+000   1.16000000000000
  0.000000000000000E+000   1.28000000000000       0.000000000000000E+000
   1.38000000000000       0.000000000000000E+000   1.38000000000000
  0.000000000000000E+000   1.32000000000000       0.000000000000000E+000
   1.04000000000000       0.000000000000000E+000   1.11000000000000
  0.000000000000000E+000   1.13000000000000       0.000000000000000E+000
   1.21000000000000       0.000000000000000E+000   1.43000000000000
  0.000000000000000E+000   1.15000000000000       0.000000000000000E+000
  0.990000000000000       0.000000000000000E+000  0.910000000000000
  0.000000000000000E+000  0.920000000000000       0.000000000000000E+000
   1.00000000000000       0.000000000000000E+000   1.11000000000000
  0.000000000000000E+000   1.23000000000000       0.000000000000000E+000
  0.850000000000000       0.000000000000000E+000  0.980000000000000
  0.000000000000000E+000  0.720000000000000       0.000000000000000E+000
  0.800000000000000       0.000000000000000E+000  0.770000000000000
  0.000000000000000E+000  0.890000000000000       0.000000000000000E+000
  0.920000000000000       0.000000000000000E+000  0.800000000000000
  0.000000000000000E+000  0.810000000000000       0.000000000000000E+000
  0.690000000000000       0.000000000000000E+000  0.700000000000000
  0.000000000000000E+000  0.760000000000000       0.000000000000000E+000
  0.730000000000000       0.000000000000000E+000  0.800000000000000
  0.000000000000000E+000  0.740000000000000       0.000000000000000E+000
  0.730000000000000       0.000000000000000E+000  0.720000000000000
  0.000000000000000E+000  0.720000000000000       0.000000000000000E+000
  0.720000000000000       0.000000000000000E+000  0.710000000000000
  0.000000000000000E+000  0.690000000000000       0.000000000000000E+000
  0.680000000000000       0.000000000000000E+000  0.660000000000000
  0.000000000000000E+000  0.610000000000000       0.000000000000000E+000
  0.420000000000000       0.000000000000000E+000  0.360000000000000
  0.000000000000000E+000  0.410000000000000       0.000000000000000E+000
  0.490000000000000
  0.000000000000000E+000   5.98000000000000       0.000000000000000E+000
   2.77000000000000       0.000000000000000E+000   3.16000000000000
  0.000000000000000E+000   3.01000000000000       0.000000000000000E+000
   1.68000000000000       0.000000000000000E+000   1.73000000000000
  0.000000000000000E+000   2.17000000000000       0.000000000000000E+000
   1.74000000000000       0.000000000000000E+000   1.75000000000000
  0.000000000000000E+000   1.72000000000000       0.000000000000000E+000
   1.63000000000000       0.000000000000000E+000   1.41000000000000
  0.000000000000000E+000   1.29000000000000       0.000000000000000E+000
   1.47000000000000       0.000000000000000E+000   1.32000000000000
  0.000000000000000E+000   1.46000000000000       0.000000000000000E+000
   1.44000000000000       0.000000000000000E+000   1.46000000000000
  0.000000000000000E+000   1.52000000000000       0.000000000000000E+000
   1.51000000000000       0.000000000000000E+000   1.47000000000000
  0.000000000000000E+000   1.45000000000000       0.000000000000000E+000
   1.28000000000000       0.000000000000000E+000   1.23000000000000
  0.000000000000000E+000   1.27000000000000       0.000000000000000E+000
  0.620000000000000       0.000000000000000E+000  0.760000000000000
  0.000000000000000E+000   1.23000000000000       0.000000000000000E+000
   1.22000000000000       0.000000000000000E+000   1.40000000000000
  0.000000000000000E+000   1.36000000000000       0.000000000000000E+000
   1.30000000000000       0.000000000000000E+000   1.29000000000000
  0.000000000000000E+000   1.24000000000000       0.000000000000000E+000
   1.28000000000000       0.000000000000000E+000   1.24000000000000
  0.000000000000000E+000   1.20000000000000       0.000000000000000E+000
  0.940000000000000       0.000000000000000E+000   1.00000000000000
  0.000000000000000E+000   1.05000000000000       0.000000000000000E+000
  0.540000000000000       0.000000000000000E+000  0.600000000000000
  0.000000000000000E+000  0.750000000000000       0.000000000000000E+000
  0.750000000000000       0.000000000000000E+000  0.850000000000000
  0.000000000000000E+000  0.970000000000000       0.000000000000000E+000
   1.02000000000000       0.000000000000000E+000   1.05000000000000
  0.000000000000000E+000   1.06000000000000       0.000000000000000E+000
   1.07000000000000       0.000000000000000E+000   1.06000000000000
  0.000000000000000E+000   1.05000000000000       0.000000000000000E+000
   1.02000000000000       0.000000000000000E+000  0.970000000000000
  0.000000000000000E+000  0.910000000000000       0.000000000000000E+000
  0.830000000000000       0.000000000000000E+000  0.740000000000000
  0.000000000000000E+000  0.660000000000000       0.000000000000000E+000
  0.610000000000000       0.000000000000000E+000  0.610000000000000
  0.000000000000000E+000  0.900000000000000       0.000000000000000E+000
  0.520000000000000       0.000000000000000E+000  0.810000000000000
  0.000000000000000E+000  0.680000000000000       0.000000000000000E+000
  0.720000000000000       0.000000000000000E+000  0.770000000000000
  0.000000000000000E+000  0.680000000000000       0.000000000000000E+000
  0.670000000000000       0.000000000000000E+000  0.800000000000000
  0.000000000000000E+000  0.680000000000000       0.000000000000000E+000
  0.640000000000000       0.000000000000000E+000  0.580000000000000
  0.000000000000000E+000  0.550000000000000       0.000000000000000E+000
  0.570000000000000       0.000000000000000E+000  0.570000000000000
  0.000000000000000E+000  0.550000000000000       0.000000000000000E+000
  0.600000000000000       0.000000000000000E+000  0.580000000000000
  0.000000000000000E+000  0.580000000000000       0.000000000000000E+000
  0.610000000000000       0.000000000000000E+000  0.630000000000000
  0.000000000000000E+000  0.650000000000000       0.000000000000000E+000
  0.660000000000000       0.000000000000000E+000  0.650000000000000
  0.000000000000000E+000  0.650000000000000       0.000000000000000E+000
  0.640000000000000       0.000000000000000E+000  0.640000000000000
  0.000000000000000E+000  0.630000000000000       0.000000000000000E+000
  0.610000000000000       0.000000000000000E+000  0.590000000000000
  0.000000000000000E+000  0.550000000000000       0.000000000000000E+000
  0.390000000000000       0.000000000000000E+000  0.360000000000000
  0.000000000000000E+000  0.400000000000000       0.000000000000000E+000
  0.400000000000000       0.000000000000000E+000  0.400000000000000
  0.000000000000000E+000  0.400000000000000       0.000000000000000E+000
  0.400000000000000       0.000000000000000E+000  0.400000000000000
  0.000000000000000E+000  0.400000000000000
  0.360000000000000       0.510000000000000       0.600000000000000
  0.660000000000000       0.680000000000000       0.690000000000000
  0.690000000000000       0.770000000000000       0.810000000000000
  0.850000000000000       0.890000000000000       0.930000000000000
  0.970000000000000        1.00000000000000       8.000000000000000E-002
  0.000000000000000E+000 -6.000000000000000E-002 -0.100000000000000
 -0.100000000000000      -0.100000000000000      -0.100000000000000
   1.00000000000000        1.25992104989487        1.44224957030741
   1.58740105196820        1.70997594667670        1.81712059283214
   1.91293118277239        2.00000000000000        2.08008382305190
   2.15443469003188        2.22398009056932        2.28942848510666
   2.35133468772076        2.41014226417523        2.46621207433047
   2.51984209978975        2.57128159065824        2.62074139420890
   2.66840164872194        2.71441761659491        2.75892417638112
   2.80203933065539        2.84386697985157        2.88449914061482
   2.92401773821287        2.96249606840737        3.00000000000000
   3.03658897187566        3.07231682568585        3.10723250595386
   3.14138065239139        3.17480210393640        3.20753432999583
   3.23961180127748        3.27106631018859        3.30192724889463
   3.33222185164595        3.36197540679896        3.39121144301417
   3.41995189335339        3.44821724038273        3.47602664488645
   3.50339806038672        3.53034833532606        3.55689330449006
   3.58304787101595        3.60882608013869        3.63424118566428
   3.65930571002297        3.68403149864039        3.70842976926619
   3.73251115681725        3.75628575422107        3.77976314968462
   3.80295246076139        3.82586236554478        3.84850113127680
   3.87087664062780        3.89299641587326        3.91486764116886
   3.93649718310217        3.95789160968041        3.97905720789639
   4.00000000000000        4.02072575858906        4.04124002062219
   4.06154810044568        4.08165510191735        4.10156592970235
   4.12128529980856        4.14081774942285        4.16016764610381
   4.17933919638123        4.19833645380841        4.21716332650875
   4.23582358425489        4.25432086511501        4.27265868169792
   4.29084042702621        4.30886938006377        4.32674871092222
   4.34448148576861        4.36207067145484        4.37951913988789
   4.39682967215818        4.41400496244210        4.43104762169363
   4.44796018113863        4.46474509558454        4.48140474655716
   4.49794144527541        4.51435743547400        4.53065489608349
   4.54683594377634        4.56290263538697        4.57885697021333
   4.59470089220704        4.61043629205845        4.62606500918274
   4.64158883361278        4.65700950780383        4.67232872835526
   4.68754814765360        4.70266937544151        4.71769398031653
   4.73262349116337        4.74745939852340        4.76220315590460
   4.77685618103502        4.79141985706278        4.80589553370533
   4.82028452835046        4.83458812711164        4.84880758583988
   4.86294413109428        4.87699896107331        4.89097324650875
   4.90486813152402        4.91868473445873        4.93242414866094
   4.94608744324870        4.95967566384230        4.97318983326859
   4.98663095223865        5.00000000000000        5.01329793496458
   5.02652569531348        5.03968419957949        5.05277434720856
   5.06579701910089        5.07875307813270        5.09164336965949
   5.10446872200146        5.11722994691205        5.12992784003009
   5.14256318131647        5.15513673547577        5.16764925236362
   5.18010146738029        5.19249410185110        5.20482786339420
   5.21710344627617        5.22932153175598        5.24148278841779
   5.25358787249290        5.26563742817144        5.27763208790408
   5.28957247269421        5.30145919238090        5.31329284591305
   5.32507402161499        5.33680329744389        5.34848124123936
   5.36010841096536        5.37168535494483        5.38321261208728
   5.39469071210959        5.40612017575022        5.41750151497718
   5.42883523318981        5.44012182541480        5.45136177849642
   5.46255557128140        5.47370367479843        5.48480655243262
   5.49586466009501        5.50687844638735        5.51784835276224
   5.52877481367887        5.53965825675446        5.55049910291155
   5.56129776652123        5.57205465554262        5.58277017165842
   5.59344471040698        5.60407866131077        5.61467240800149
   5.62522632834186        5.63574079454424        5.64621617328617
   5.65665282582291        5.66705110809706        5.67741137084543
   5.68773395970313        5.69801921530506        5.70826747338486
   5.71847906487132        5.72865431598244        5.73879354831717
   5.74889707894483        5.75896522049240        5.76899828122963
   5.77899656515213        5.78896037206240        5.79888999764900
   5.80878573356370        5.81864786749696        5.82847668325146
   5.83827246081400        5.84803547642573        5.85776600265065
   5.86746430844261        5.87713065921074        5.88676531688334
   5.89636853997037        5.90594058362449        5.91548169970072
   5.92499213681474        5.93447214039994        5.94392195276313
   5.95334181313905        5.96273195774369        5.97209261982640
   5.98142402972088        5.99072641489509        6.00000000000000
   6.00924500691737        6.01846165480645        6.02765016014974
   6.03681073679769        6.04594359601251        6.05504894651110
   6.06412699450696        6.07317794375132        6.08220199557340
   6.09119934891978        6.10017020039306        6.10911474428961
   6.11803317263662        6.12692567522842        6.13579243966196
   6.14463365137169        6.15344949366368        6.16224014774904
   6.17100579277672        6.17974660586564        6.18846276213620
   6.19715443474113        6.20582179489575        6.21446501190772
   6.22308425320606        6.23167968436975        6.24025146915571
   6.24879976952624        6.25732474567597        6.26582655605827
   6.27430535741117        6.28276130478279        6.29119455155629
   6.29960524947437        6.30799354866327        6.31635959765638
   6.32470354341737        6.33302553136292        6.34132570538500
   6.34960420787280        6.35786117973420        6.36609676041689
   6.37431108792909        6.38250429885991        6.39067652839931
   6.39882791035777        6.40695857718556        6.41506865999165
   6.42315828856237        6.43122759137962        6.43927669563891
   6.44730572726691        6.45531481093889        6.46330407009565
   6.47127362696036        6.47922360255497        6.48715411671635
   6.49506528811226        6.50295723425693        6.51083007152643
   6.51868391517377        6.52651887934375        6.53433507708757
   6.54213262037718        6.54991162011937        6.55767218616971
   6.56541442734614        6.57313845144243        6.58084436524139
   6.58853227452786        6.59620228410148        6.60385449778925
   6.61148901845794        6.61910594802623        6.62670538747667
   6.63428743686750        6.64185219534421        6.64939976115097
   6.65693023164187      -5.563810000000000E-067   34426700.0000000
   2.69000000000000        2.29184000000000        2.09819000000000
   1.97582000000000        1.88867000000000        1.82212000000000
   1.76892000000000        1.72500000000000        1.68785000000000
   1.65583000000000        1.62781000000000        1.60300000000000
   1.58081000000000        1.56078000000000        1.54258000000000
   1.52592000000000        1.51060000000000        1.49643000000000
   1.48328000000000        1.47102000000000        1.45955000000000
   1.44878000000000        1.43865000000000        1.42909000000000
   1.42005000000000        1.41148000000000        1.40333000000000
   1.39558000000000        1.38819000000000        1.38113000000000
   1.37438000000000        1.36791000000000        1.36171000000000
   1.35575000000000        1.35002000000000        1.34451000000000
   1.33919000000000        1.33407000000000        1.32912000000000
   1.32434000000000        1.31971000000000        1.31523000000000
   1.31089000000000        1.30669000000000        1.30261000000000
   1.29865000000000        1.29480000000000        1.29106000000000
   1.28742000000000        1.28388000000000        1.28044000000000
   1.27708000000000        1.27380000000000        1.27061000000000
   1.26750000000000        1.26446000000000        1.26149000000000
   1.25859000000000        1.25576000000000        1.25299000000000
   1.25028000000000        1.24763000000000        1.24504000000000
   1.24250000000000        1.24001000000000        1.23758000000000
   1.23519000000000        1.23285000000000        1.23055000000000
   1.22830000000000        1.22609000000000        1.22392000000000
   1.22180000000000        1.21971000000000        1.21765000000000
   1.21564000000000        1.21366000000000        1.21171000000000
   1.20979000000000        1.20791000000000        1.20606000000000
   1.20424000000000        1.20245000000000        1.20069000000000
   1.19895000000000        1.19724000000000        1.19556000000000
   1.19391000000000        1.19228000000000        1.19067000000000
   1.18909000000000        1.18752000000000        1.18599000000000
   1.18447000000000        1.18298000000000        1.18150000000000
   1.18005000000000        1.17861000000000        1.17720000000000
   1.17581000000000        1.17443000000000        1.17307000000000
   1.17173000000000        1.17040000000000        1.16910000000000
   1.16781000000000        1.16653000000000        1.16527000000000
   1.16403000000000        1.16280000000000        1.16159000000000
   1.16039000000000        1.15921000000000        1.15804000000000
   1.15688000000000        1.15574000000000        1.15460000000000
   1.15349000000000        1.15238000000000        1.15129000000000
   1.15021000000000        1.14914000000000        1.14808000000000
   1.14703000000000        1.14600000000000        1.14498000000000
   1.14396000000000        1.14296000000000        1.14197000000000
   1.14099000000000        1.14001000000000        1.13905000000000
   1.13810000000000        1.13716000000000        1.13622000000000
   1.13530000000000        1.13438000000000        1.13348000000000
   1.13258000000000        1.13169000000000        1.13081000000000
   1.12994000000000        1.12907000000000        1.12822000000000
   1.12737000000000        1.12653000000000        1.12569000000000
   1.12487000000000        1.12405000000000        1.12324000000000
   1.12244000000000        1.12164000000000        1.12085000000000
   1.12007000000000        1.11929000000000        1.11852000000000
   1.11776000000000        1.11700000000000        1.11625000000000
   1.11551000000000        1.11477000000000        1.11404000000000
   1.11331000000000        1.11259000000000        1.11188000000000
   1.11117000000000        1.11047000000000        1.10977000000000
   1.10908000000000        1.10840000000000        1.10772000000000
   1.10704000000000        1.10637000000000        1.10571000000000
   1.10505000000000        1.10439000000000        1.10374000000000
   1.10310000000000        1.10246000000000        1.10182000000000
   1.10119000000000        1.10056000000000        1.09994000000000
   1.09933000000000        1.09871000000000        1.09811000000000
   1.09750000000000        1.09690000000000        1.09631000000000
   1.09572000000000        1.09513000000000        1.09455000000000
   1.09397000000000        1.09339000000000        1.09282000000000
   1.09225000000000        1.09169000000000        1.09113000000000
   1.09058000000000        1.09002000000000        1.08948000000000
   1.08893000000000        1.08839000000000        1.08785000000000
   1.08732000000000        1.08679000000000        1.08626000000000
   1.08574000000000        1.08522000000000        1.08470000000000
   1.08419000000000        1.08368000000000        1.08317000000000
   1.08267000000000        1.08216000000000        1.08167000000000
   1.08117000000000        1.08068000000000        1.08019000000000
   1.07970000000000        1.07922000000000        1.07874000000000
   1.07826000000000        1.07779000000000        1.07732000000000
   1.07685000000000        1.07638000000000        1.07592000000000
   1.07546000000000        1.07500000000000        1.07455000000000
   1.07409000000000        1.07364000000000        1.07320000000000
   1.07275000000000        1.07231000000000        1.07187000000000
   1.07143000000000        1.07100000000000        1.07057000000000
   1.07014000000000        1.06971000000000        1.06928000000000
   1.06886000000000        1.06844000000000        1.06802000000000
   1.06760000000000        1.06719000000000        1.06678000000000
   1.06637000000000        1.06596000000000        1.06556000000000
   1.06515000000000        1.06475000000000        1.06435000000000
   1.06396000000000        1.06356000000000        1.06317000000000
   1.06278000000000        1.06239000000000        1.06200000000000
   1.06162000000000        1.06123000000000        1.06085000000000
   1.06047000000000        1.06010000000000        1.05972000000000
   1.05935000000000        1.05898000000000        1.05861000000000
   1.05824000000000        1.05787000000000        1.05751000000000
   1.05715000000000        1.05679000000000        1.05643000000000
   1.05607000000000        1.05572000000000        1.05536000000000
   1.05501000000000        1.05466000000000        1.05431000000000
   1.05396000000000        1.05362000000000        1.05328000000000
   1.05293000000000        1.05259000000000        1.05225000000000
   1.05192000000000        1.05158000000000        1.05125000000000
   1.05091000000000        1.05058000000000        1.05025000000000
   1.04992000000000       3.984620000000000E+028  2.171050000000000E-056
  0.598513000000000       0.434469000000000       0.356520000000000
  0.308110000000000       0.274114000000000       0.248467000000000
  0.228183000000000       0.211594000000000       0.197684000000000
  0.185790000000000       0.175462000000000       0.166378000000000
  0.158303000000000       0.151061000000000       0.144516000000000
  0.138561000000000       0.133111000000000       0.128098000000000
  0.123466000000000       0.119167000000000       0.115163000000000
  0.111422000000000       0.107915000000000       0.104620000000000
  0.101514000000000       9.858040000000000E-002  9.580360000000000E-002
  9.317000000000000E-002  9.066740000000000E-002  8.828530000000000E-002
  8.601399999999999E-002  8.384519999999999E-002  8.177130000000001E-002
  7.978550000000000E-002  7.788170000000000E-002  7.605430000000001E-002
  7.429810000000001E-002  7.260890000000000E-002  7.098230000000000E-002
  6.941440000000000E-002  6.790180000000000E-002  6.644140000000000E-002
  6.503000000000000E-002  6.366510000000000E-002  6.234400000000000E-002
  6.106450000000000E-002  5.982440000000000E-002  5.862170000000000E-002
  5.745460000000000E-002  5.632120000000000E-002  5.522010000000000E-002
  5.414960000000000E-002  5.310830000000000E-002  5.209510000000000E-002
  5.110850000000000E-002  5.014740000000000E-002  4.921080000000000E-002
  4.829760000000000E-002  4.740690000000000E-002  4.653770000000000E-002
  4.568910000000000E-002  4.486040000000000E-002  4.405080000000000E-002
  4.325960000000000E-002  4.248600000000000E-002  4.172940000000000E-002
  4.098920000000000E-002  4.026480000000000E-002  3.955570000000000E-002
  3.886130000000000E-002  3.818110000000000E-002  3.751460000000000E-002
  3.686140000000000E-002  3.622100000000000E-002  3.559300000000000E-002
  3.497700000000000E-002  3.437260000000000E-002  3.377950000000000E-002
  3.319730000000000E-002  3.262570000000000E-002  3.206440000000000E-002
  3.151300000000000E-002  3.097130000000000E-002  3.043890000000000E-002
  2.991570000000000E-002  2.940130000000000E-002  2.889550000000000E-002
  2.839810000000000E-002  2.790880000000000E-002  2.742750000000000E-002
  2.695380000000000E-002  2.648760000000000E-002  2.602880000000000E-002
  2.557700000000000E-002  2.513210000000000E-002  2.469400000000000E-002
  2.426250000000000E-002  2.383740000000000E-002  2.341860000000000E-002
  2.300580000000000E-002  2.259900000000000E-002  2.219800000000000E-002
  2.180270000000000E-002  2.141300000000000E-002  2.102860000000000E-002
  2.064950000000000E-002  2.027560000000000E-002  1.990680000000000E-002
  1.954280000000000E-002  1.918370000000000E-002  1.882930000000000E-002
  1.847950000000000E-002  1.813430000000000E-002  1.779340000000000E-002
  1.745690000000000E-002  1.712460000000000E-002  1.679650000000000E-002
  1.647240000000000E-002  1.615230000000000E-002  1.583610000000000E-002
  1.552360000000000E-002  1.521500000000000E-002  1.491000000000000E-002
  1.460850000000000E-002  1.431070000000000E-002  1.401620000000000E-002
  1.372510000000000E-002  1.343740000000000E-002  1.315290000000000E-002
  1.287160000000000E-002  1.259350000000000E-002  1.231840000000000E-002
  1.204630000000000E-002  1.177720000000000E-002  1.151100000000000E-002
  1.124770000000000E-002  1.098720000000000E-002  1.072940000000000E-002
  1.047440000000000E-002  1.022200000000000E-002  9.972200000000001E-003
  9.724999999999999E-003  9.480400000000000E-003  9.238200000000000E-003
  8.998400000000000E-003  8.761100000000001E-003  8.526100000000000E-003
  8.293399999999999E-003  8.063000000000001E-003  7.834900000000001E-003
  7.608900000000000E-003  7.385200000000000E-003  7.163600000000000E-003
  6.944000000000000E-003  6.726600000000000E-003  6.511200000000000E-003
  6.297800000000000E-003  6.086400000000000E-003  5.876900000000000E-003
  5.669300000000000E-003  5.463600000000000E-003  5.259800000000000E-003
  5.057800000000000E-003  4.857600000000000E-003  4.659200000000000E-003
  4.462500000000000E-003  4.267600000000000E-003  4.074300000000000E-003
  3.882800000000000E-003  3.692800000000000E-003  3.504500000000000E-003
  3.317800000000000E-003  3.132700000000000E-003  2.949200000000000E-003
  2.767100000000000E-003  2.586600000000000E-003  2.407600000000000E-003
  2.230100000000000E-003  2.054000000000000E-003  1.879300000000000E-003
  1.706100000000000E-003  1.534200000000000E-003  1.363700000000000E-003
  1.194600000000000E-003  1.026800000000000E-003  8.603000000000000E-004
  6.952000000000000E-004  5.313000000000000E-004  3.687000000000000E-004
  2.074000000000000E-004  4.730000000000000E-005 -1.116000000000000E-004
 -2.693000000000000E-004 -4.258000000000000E-004 -5.811000000000000E-004
 -7.353000000000000E-004 -8.883000000000000E-004 -1.040200000000000E-003
 -1.190900000000000E-003 -1.340600000000000E-003 -1.489200000000000E-003
 -1.636700000000000E-003 -1.783100000000000E-003 -1.928500000000000E-003
 -2.072800000000000E-003 -2.216100000000000E-003 -2.358400000000000E-003
 -2.499700000000000E-003 -2.640000000000000E-003 -2.779300000000000E-003
 -2.917600000000000E-003 -3.055000000000000E-003 -3.191500000000000E-003
 -3.327000000000000E-003 -3.461600000000000E-003 -3.595300000000000E-003
 -3.728000000000000E-003 -3.859900000000000E-003 -3.990900000000000E-003
 -4.121000000000000E-003 -4.250300000000000E-003 -4.378700000000000E-003
 -4.506300000000000E-003 -4.633000000000000E-003 -4.758900000000000E-003
 -4.884000000000000E-003 -5.008300000000000E-003 -5.131700000000000E-003
 -5.254400000000000E-003 -5.376300000000000E-003 -5.497500000000000E-003
 -5.617800000000000E-003 -5.737400000000000E-003 -5.856300000000000E-003
 -5.974400000000000E-003 -6.091800000000000E-003 -6.208400000000000E-003
 -6.324400000000000E-003 -6.439600000000000E-003 -6.554100000000000E-003
 -6.667900000000000E-003 -6.781100000000000E-003 -6.893500000000000E-003
 -7.005300000000000E-003 -7.116400000000000E-003 -7.226800000000000E-003
 -7.336600000000000E-003 -7.445700000000000E-003 -7.554200000000000E-003
 -7.662100000000000E-003 -7.769300000000000E-003 -7.875900000000000E-003
 -7.981900000000000E-003 -8.087300000000000E-003 -8.192000000000000E-003
 -8.296200000000000E-003 -8.399800000000001E-003 -8.502700000000000E-003
 -8.605099999999999E-003 -8.706900000000000E-003 -8.808200000000000E-003
 -8.908900000000001E-003 -9.009000000000000E-003 -9.108500000000000E-003
 -9.207500000000000E-003 -9.306000000000000E-003 -9.403900000000000E-003
 -9.501300000000001E-003 -9.598100000000000E-003 -9.694500000000000E-003
 -9.790300000000000E-003 -9.885500000000000E-003 -9.980299999999999E-003
 -1.007460000000000E-002 -1.016830000000000E-002 -1.026160000000000E-002
 -1.035440000000000E-002 -1.044660000000000E-002 -1.053840000000000E-002
 -1.062970000000000E-002 -1.072060000000000E-002 -1.081090000000000E-002
 -1.090080000000000E-002 -1.099020000000000E-002 -1.107920000000000E-002
 -1.116770000000000E-002 -1.125580000000000E-002 -1.134340000000000E-002
 -1.143050000000000E-002 -1.151730000000000E-002 -1.160350000000000E-002
 -1.168940000000000E-002 -1.177480000000000E-002 -1.185980000000000E-002
 -1.194440000000000E-002  5.078110000000000E+017 -9.816000000000000E-054
  0.000000000000000E+000   1.00000000000000        1.00000000000000
   1.00000000000000        1.00000000000000        2.00000000000000
   2.00000000000000        2.00000000000000        3.00000000000000
   3.00000000000000        3.00000000000000        4.00000000000000
   4.00000000000000        4.00000000000000        5.00000000000000
   5.00000000000000        5.00000000000000        6.00000000000000
   6.00000000000000        7.00000000000000        7.00000000000000
   8.00000000000000        8.00000000000000        9.00000000000000
   9.00000000000000        10.0000000000000        10.0000000000000
   11.0000000000000        11.0000000000000        11.0000000000000
   11.0000000000000        11.0000000000000        12.0000000000000
   13.0000000000000        13.0000000000000        14.0000000000000
   14.0000000000000        15.0000000000000        15.0000000000000
   16.0000000000000        16.0000000000000        17.0000000000000
   17.0000000000000        18.0000000000000        18.0000000000000
   18.0000000000000        19.0000000000000        19.0000000000000
   20.0000000000000        20.0000000000000        21.0000000000000
   21.0000000000000        22.0000000000000        22.0000000000000
   23.0000000000000        23.0000000000000        24.0000000000000
   24.0000000000000        25.0000000000000        25.0000000000000
   26.0000000000000        26.0000000000000        27.0000000000000
   27.0000000000000        28.0000000000000        28.0000000000000
   28.0000000000000        29.0000000000000        29.0000000000000
   29.0000000000000        30.0000000000000        30.0000000000000
   30.0000000000000        30.0000000000000        30.0000000000000
   30.0000000000000        30.0000000000000        30.0000000000000
   31.0000000000000        31.0000000000000        32.0000000000000
   32.0000000000000        33.0000000000000        33.0000000000000
   34.0000000000000        34.0000000000000        35.0000000000000
   35.0000000000000        36.0000000000000        36.0000000000000
   36.0000000000000        36.0000000000000        36.0000000000000
   37.0000000000000        37.0000000000000        37.0000000000000
   38.0000000000000        38.0000000000000        39.0000000000000
   40.0000000000000        40.0000000000000        41.0000000000000
   41.0000000000000        42.0000000000000        42.0000000000000
   43.0000000000000        43.0000000000000        44.0000000000000
   44.0000000000000        45.0000000000000        45.0000000000000
   46.0000000000000        46.0000000000000        47.0000000000000
   47.0000000000000        47.0000000000000        47.0000000000000
   48.0000000000000        48.0000000000000        48.0000000000000
   49.0000000000000        49.0000000000000        49.0000000000000
   49.0000000000000        49.0000000000000        49.0000000000000
   49.0000000000000        49.0000000000000        49.0000000000000
   49.0000000000000        50.0000000000000        50.0000000000000
   51.0000000000000        51.0000000000000        52.0000000000000
   52.0000000000000        53.0000000000000        53.0000000000000
   54.0000000000000        54.0000000000000        54.0000000000000
   54.0000000000000        55.0000000000000        55.0000000000000
   55.0000000000000        56.0000000000000        57.0000000000000
   58.0000000000000        58.0000000000000        59.0000000000000
   59.0000000000000        60.0000000000000        60.0000000000000
   61.0000000000000        61.0000000000000        62.0000000000000
   62.0000000000000        63.0000000000000        63.0000000000000
   63.0000000000000        64.0000000000000        64.0000000000000
   65.0000000000000        65.0000000000000        66.0000000000000
   66.0000000000000        67.0000000000000        67.0000000000000
   67.0000000000000        67.0000000000000        68.0000000000000
   68.0000000000000        68.0000000000000        69.0000000000000
   69.0000000000000        69.0000000000000        70.0000000000000
   70.0000000000000        71.0000000000000        71.0000000000000
   72.0000000000000        72.0000000000000        72.0000000000000
   72.0000000000000        73.0000000000000        73.0000000000000
   74.0000000000000        74.0000000000000        74.0000000000000
   74.0000000000000        75.0000000000000        76.0000000000000
   76.0000000000000        76.0000000000000        76.0000000000000
   77.0000000000000        77.0000000000000        77.0000000000000
   78.0000000000000        78.0000000000000        78.0000000000000
   79.0000000000000        79.0000000000000        79.0000000000000
   80.0000000000000        80.0000000000000        81.0000000000000
   81.0000000000000        81.0000000000000        81.0000000000000
   82.0000000000000        82.0000000000000        82.0000000000000
   82.0000000000000        83.0000000000000        83.0000000000000
   84.0000000000000        84.0000000000000        85.0000000000000
   85.0000000000000        86.0000000000000        86.0000000000000
   87.0000000000000        87.0000000000000        87.0000000000000
   87.0000000000000        87.0000000000000        88.0000000000000
   88.0000000000000        88.0000000000000        89.0000000000000
   89.0000000000000        90.0000000000000        90.0000000000000
   90.0000000000000        91.0000000000000        91.0000000000000
   91.0000000000000        92.0000000000000        92.0000000000000
   93.0000000000000        93.0000000000000        94.0000000000000
   94.0000000000000        94.0000000000000        94.0000000000000
   95.0000000000000        95.0000000000000        96.0000000000000
   96.0000000000000        8.07131000000004        13.1357354599999
   14.9497831614761        25.9197974264349        33.7897359197236
   17.5968624734944        26.1107959337053        31.6087529649761
   24.9546049697993        33.8297356071101        40.9396800400558
   25.0298043820859        34.8997272446982        40.9696798055956
   29.5297692130642        37.9997030171499        45.2696461996415
   25.3698017248709        34.4297309179072        22.1998264994929
   26.9497893766366        9.48992583244087        17.9498597146800
   8.64993239732492        12.8398996510580      -0.189998515085750
   6.66994787169448       -1.12999116866788        2.65997921120050
   8.37993450746622        10.6099170792621        16.4098717503008
   4.12996772265340       -4.14996756634664      -0.839993435115946
  -12.6699009796655       -7.00994521447950       -14.5598862086764
  -12.2999038713406       -22.2398261868793       -18.0998585423793
  -24.4198091494421       -23.1398191530750       -32.2707477912223
  -29.7297676499965       -29.7297676499965       -35.6977210080584
  -32.2197481898045       -41.2856773359488       -39.5716907314384
  -43.2196622210848       -40.1396862923263       -46.8896335387937
  -45.3296457307212       -49.0096169702768       -46.2096388532237
  -52.7895874282986       -52.0495932116488       -55.4775664206696
  -52.9495861778445       -59.0095388168952       -58.9295394421223
  -61.8495166213348       -59.7905327131161       -65.1239910300100
  -66.0204840235594       -63.4695039604870       -65.3894889550377
  -65.9394846566018       -63.3895045857141       -67.3234738401737
  -68.1334675097498       -65.0294917685595       -65.6694867667431
  -62.4595118539786       -62.5495111505981       -58.9095395984290
  -58.0795460851597       -62.8095091186102       -59.5295347529194
  -66.3394815304665       -65.7894858289025       -69.9494533170957
  -66.1594829372274       -72.5694328409098       -70.8594462051380
  -74.2094200237552       -71.0894444076102       -76.7893998601827
  -75.1794124428772       -71.7694390931803       -69.1494595693663
  -64.9194926282467       -69.4594571466114       -66.5494798892455
  -62.7695094312237       -69.0794601164399       -67.3794734025148
  -71.4994412033216       -76.5994013450970       -73.0494290895475
  -76.3594032207781       -75.4094106453494       -80.4993708652782
  -77.1393971248144       -80.0293745384871       -79.5093786024629
  -83.8193449183555       -80.8093684425233       -82.9293518740064
  -82.5293550001417       -86.3253253331180       -83.6393463251163
  -85.1593344458023       -84.9093363996369       -82.6193542967613
  -82.2393572665898       -86.7063223554742       -84.2293417140668
  -83.9803436600860       -85.8413291157417       -83.5993466377299
  -83.4393478881840       -81.0993661760753       -80.4993708652782
  -77.8993911851574       -77.1693968903542       -74.3394190077612
  -73.1194285424738       -70.0794523011018       -77.4793944675994
  -76.3894029863180       -78.9793827445922       -73.8694226809702
  -77.5993935297588       -74.8294151782455       -76.7194004072564
  -71.7294394057938       -75.7494079881344       -73.1794280735535
  -68.9994607416670       -66.0494837969146       -68.3594657434834
  -63.9295003654315       -61.7195176373288       -65.5594876264303
  -67.5394721520607       -70.7094473774387       -67.4694726991344
  -68.6794632425752       -67.4394729335945       -70.1454517852895
  -67.3594735588216       -68.4494650401030       -67.0994755908095
  -69.3674578656226       -66.8594774664907       -67.2394744966622
  -65.9294847347552       -63.5395034134133       -65.5064880406432
  -64.3594970048361       -64.6794945039279       -62.1095145893469
  -63.6105028585243       -62.5825108926920       -62.3155129793873
  -60.2695289695691       -58.7925405128236       -56.0995615595293
  -57.7135489455735       -56.4905585037320       -53.7295800818807
  -53.8495791440401       -52.2895913359676       -49.5896124373807
  -50.9856015271686       -49.6596118903070       -49.1096161887430
  -46.6796351800147       -47.4026295295252       -45.9896405725980
  -43.2686618381332       -41.4796758197731       -41.3596767576137
  -38.5996983279470       -39.8926882227148       -38.6566978824728
  -35.4697227899555       -34.2197325591282       -34.3427315978416
  -35.8747196247435       -33.3867390693049       -32.4167466501829
  -29.6897679626100       -29.4397699164446       -28.4297778099361
  -25.5198005525702       -27.4197857034277       -26.5997921120050
  -23.7398144638721       -23.8598135260315       -22.9798204035291
  -20.1998421301692       -22.2988257257744       -20.9548362295889
  -21.0408355574698       -16.7678689524097       -13.6498933206341
  -9.25092770030669       -10.4918180022536       -7.56194090041284
  -3.13997545983818      -0.185298551817839        1.70998663577175
   5.96995334243119        5.95995342058457        8.35453470597581
   10.5299177044892        14.1998890221981        14.3798876154373
   16.3698720629143        18.3821563361094        21.7098303290086
   23.7898140731052        27.4597853908141        29.5797688222972
   28.9407738162983        32.7197442821354        34.5597299019132
   35.9097193512067        39.1496940295111        38.7319972939778
   40.6116826034867        44.1496549528203        45.5396440895002
   47.6396276772901        51.2695993076126        50.5718047611555
   52.7115880378949        54.3095755489846        57.5195504617491
   57.7520486446830        59.8025326193320        63.1565064066879
   65.2894897365716        67.1294753563494        70.4894490968131
   70.7474470804559        72.9854295897291        7.28897545999993
  0.000000000000000E+000   14.9311833068413        2.42492104827388
   11.3899109832984        14.0871899029867        14.9080834873757
   20.9467362928931        11.3479113115426        12.6075014673426
   20.1758423177373        13.3693955128365        16.5618705623694
   23.6568151125452        9.87312283760328        13.6928929845746
   21.0598354089784        13.2738962592013        15.5998780807247
   3.79897030953033        8.11993653945414        2.82597791385436
   3.34997381861717       -5.94895350655329       -2.14998319702296
  -6.88794616795076       -5.62995599964616       -15.0162826417561
  -10.7499159851148       -9.78992348783942       -3.89996952018118
  -2.88997741367272       -9.36992677028145       -20.2498417394023
  -15.0398824573141       -20.7698376754264       -19.0098514304216
  -26.8617900643864       -22.9998202472223       -27.5397847655871
  -27.3997858597344       -34.4197309960606       -31.9797500654857
  -35.8067201561865       -36.6107138726546       -35.4197231807224
  -42.3425690759179       -44.2156544370079       -46.5546361569320
  -44.5386519126537       -49.7326113197873       -49.4686133830366
  -51.8625946731170       -49.9296097801657       -55.1058693256308
  -55.2645680853366       -57.4865507196552       -56.2095606998421
  -60.6609259106458       -61.4365198490695       -62.8965084386758
  -61.5035193254418       -65.5120879968773       -67.0973756072217
  -67.2609743286324       -66.2561821814842       -67.3044739886652
  -70.0057528770922       -68.4164652980092       -69.5593563658592
  -70.1409518204585       -68.5904639381403       -69.7294550364701
  -68.0194684006984       -68.5594641804158       -66.4394807489327
  -66.4094809833928       -63.6795023192660       -69.5694562869243
  -69.4294573810716       -72.6394322938361       -70.1894514414146
  -75.4094106453494       -75.9414064875895       -78.6693851673470
  -75.9594063469134       -80.7063692475032       -79.6883772035174
  -81.7163613540116       -79.5693781335427       -77.9693906380837
  -75.1194129117975       -72.9194301055414       -78.9593829008989
  -75.1394127554907       -73.0694289332407       -76.2794038460052
  -73.1894279954001       -77.8893912633108       -79.9593750855608
  -78.9493829790523       -83.5613469347127       -80.6093700055910
  -82.6993536715342       -82.5393549219883       -86.3323252784107
  -83.7093457780427       -85.0193355399497       -85.1093348365692
  -88.3343096321037       -86.0293276464581       -86.6193230354086
  -87.0393197529666       -90.0188964663850       -88.0923115234155
  -88.7169066419553       -86.4153246297376       -87.4493165486780
  -87.7293143603833       -85.6993302255197       -89.2011028577686
  -89.9452970415939       -87.8203136491875       -88.2393103745608
  -85.9013286468214       -86.0233276933502       -83.5993466377299
  -83.4393478881840       -80.6393697711308       -80.3793718031187
  -82.0993583607371       -79.6093778209291       -82.9293518740064
  -82.6693539059944       -83.7953451059236       -79.4293792276900
  -82.2143574619732       -80.0293745384871       -80.6293698492842
  -77.2393963432806       -74.9994138496380       -70.9494455017576
  -74.0094215868228       -72.0294370611924       -67.8194699637660
  -69.4594571466114       -72.2394354199714       -72.5094333098301
  -71.3694422193156       -73.6814241502537       -70.9444455408343
  -71.2894428445426       -70.7594469866718       -72.4534337474890
  -70.1954513945226       -70.0824522776558       -69.4644571075348
  -70.6904475259302       -68.5614641647851       -67.9424690024794
  -67.4654727303957       -65.7594860633626       -66.3814812022223
  -65.9664844455876       -64.8954928158148       -63.0665071100683
  -63.2855053985092       -62.9845077509260       -60.9165239130453
  -60.1035302669153       -59.2045372929043       -57.3795515558964
  -56.2255605747967       -56.9395549946452       -54.6905725713407
  -53.4895819575619       -52.3815906169565       -50.2996068884906
  -50.4616056224058       -49.7786109602818       -48.4246215422496
  -46.4166372354487       -45.2786461293035       -42.8206653394047
  -43.3696610487840       -42.4976678637589       -41.2046779689911
  -39.0056951549197       -37.9697032516101       -35.5197223991886
  -36.3877156154751       -34.8257278230333       -34.5187302223421
  -32.5137458920951       -31.6917523163031       -32.6517448135784
  -30.4307621714445       -29.9207661572669       -29.1037725423982
  -27.2997866412682       -26.3997936750726       -27.3557862036093
  -25.2768024516973       -24.7028069377014       -23.8368137057843
  -22.2688259602345       -22.4628244440589       -21.7588299460570
  -17.6238622624803       -14.7378848175462       -11.8649072710127
  -8.13493642222407       -5.24295902418203       -1.20899055125617
 -0.540495775809725        1.76898617466680        4.38196575318818
   8.09893670357625        8.83063098509331        10.5989171652308
   13.2648963295393        16.3378723130052        17.2346653042099
   18.8128529700432        21.9871281618153        23.6655150445517
   27.1847875400321        28.8947741758039        30.7197599128117
   33.7597361541837        33.8119357462231        35.4469229681452
   37.4868070256369        40.3486846589206        42.3196692548891
   42.4416683014178        45.3883452719609        47.3066302797977
   49.3060146538106        52.2095919611947        52.9525861543984
   54.7145723837726        57.1696531963359        59.8781320284925
   61.8968162516693        64.9194926282467        65.5294878608904
   67.3884733321768        69.8474541142602        72.9494298710813
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
   25.1298036005521        11.6799087168503        18.3748563931613
   15.7699767513357        4.94172137847450        12.4160029639799
   12.0516058118891        8.66783225743037       0.000000000000000E+000
   3.12500557683379        3.01989639830399       0.101509206665023
   5.68155559637471        7.86993849328868      -0.783023880355761
   3.33137396398246      -1.709986635771748E-002 -4.699963267910651E-002
  -8.02603727331440       -5.15505971115025       -8.41743421439104
  -9.35692687188084       -16.2122732946116       -14.5848860132929
  -16.8480683256196       -18.2118576670614       -15.8898758142766
  -15.0998819883938       -11.2899117648322       -20.5698392384941
  -24.5498081334482       -24.9398050854663       -30.6656603356215
  -26.9077897048808       -29.7977671185535       -29.8027670794768
  -35.0399261489878       -33.0674415647424       -35.0225262849747
  -36.5877140524074       -41.4656759291879       -40.8092810591759
  -43.1378628603794       -44.3301535421517       -44.4976522330826
  -48.5583204973389       -51.4316980407462       -52.1986920463819
  -51.4384979876019       -55.2832679391898       -56.9308550626386
  -57.7095489768348       -56.9083552384838       -60.1785296807649
  -62.1513142626658       -62.2259136796416       -61.6461182109746
  -64.2185981060172       -66.7448783621284       -65.5779874818465
  -65.4224886971316       -65.9090848941880       -68.8977615364869
  -67.8790694979719       -67.0846757064765       -69.3209582290358
  -68.9046614825611       -69.9052536625337       -72.5820327424365
  -71.2929428171889       -73.4215261814601       -71.8555384202797
  -73.2129278117397       -71.2137434361637       -71.7594391713337
  -73.7194238532709       -72.0594368267322       -76.3904029785027
  -77.5853936391736       -79.0243823929020       -77.7583922871201
  -81.4711632703325       -83.2623492714988       -84.5950388559977
  -82.6013544374374       -86.2023262944046       -85.9340283912599
  -83.6653461219176       -82.8913521709893       -80.2793725846526
  -82.3813561568117       -81.2323651366353       -78.4293870430282
  -82.9535516848753       -81.2913646755303       -82.3453564381639
  -86.1883264038194       -83.5153472942183       -84.5993388223917
  -84.9093363996369       -88.0983114765235       -85.9373283654693
  -86.3713249736125       -86.8593211597275       -89.5223003474819
  -87.6053153294852       -87.4553165017859       -88.2253104839755
  -90.5771921030817       -89.0496040417923       -88.5753077486072
  -89.5403002068059       -88.2523102729614       -88.9433048725627
  -91.6528836961225       -90.0659960982826       -91.1010880086261
  -89.5876998363588       -88.3226097235431       -89.2168027350678
  -87.6127152716517       -88.2513102807767       -86.4013247391524
  -86.7033223789202       -84.7293378063978       -84.6293385879316
  -82.3793561724424       -85.2003341253735       -85.2123340315894
  -85.9013286468214       -83.9693437460547       -86.5053239263572
  -86.4243245593996       -86.5593235043289       -82.7693531244606
  -84.9243362824068       -83.2843490995614       -79.9793749292540
  -77.8193918103844       -78.3093879808687       -74.9294143967117
  -72.9194301055414       -75.7594079099811       -75.4394104108893
  -77.4063950381191       -74.3734187420397       -73.5494251818784
  -73.3854264635938       -74.7604157175039       -72.5564329425092
  -71.7254394370552       -71.8244386633367       -72.5354331066313
  -70.8244464786749       -69.4744570293814       -69.5354565526458
  -67.8394698074593       -68.0554681193462       -68.1804671424290
  -66.3784812256683       -64.9364924953859       -64.5174957700126
  -64.9204926204314       -62.5365112521975       -61.3055208728788
  -61.2685211620463       -59.7905327131161       -59.3015365348165
  -59.2495369412141       -57.5455502585503       -55.5615657641812
  -55.1585689137625       -53.3805828094337       -52.8785867327335
  -52.4335902105589       -50.3466065211697       -48.9136177205493
  -48.2366230115332       -48.2276230818713       -46.3466377825223
  -45.6866429406455       -43.8016576725579       -41.9096724591777
  -41.2076779455451       -41.1246785942182       -38.9776953737492
  -38.6986975542286       -36.6977131927202       -36.2827164360856
  -34.4577306990777       -34.7647282997689       -32.8017436412777
  -31.1617564584323       -31.1497565522163       -29.5907687363285
  -29.5567690020500       -29.5137693381096       -27.6717837339625
  -25.9877968949919       -25.7687986065510       -24.3528096730698
  -23.7768141747046       -23.7948140340285       -20.0578432399472
  -18.8788524542309       -18.2678572294025       -14.8008843251799
  -12.4439027459319       -10.3809188689746       -6.66294792640184
  -4.47896499510038       -1.26199013704324        2.23698251708854
   3.64897148183106        5.21195926645751        8.61693265523108
   11.4699103580713        12.9568987366635        14.3118881468803
   17.8248606915973        20.2188419816778        21.6258309854970
   24.3008100794674        25.8497979735086        26.7577908771815
   29.5806688152634        30.8610588085045        33.4228387871712
   35.9337191636386        36.9144114991365        38.1423019026827
   40.9160802244977        43.4256606111251        44.8689493312475
   47.4522291418845        48.5847202910140        50.1224082733685
   52.9317863169575        55.4622665402443        57.1769531392839
   58.4491431966107        61.0008232542123        62.6155106347858
   65.4834882203960        67.9894686351585        69.7210551021190
   71.1692437839463       0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000   27.9397816394518        22.9217208576002
   28.9118740421616        15.7027772765264        10.6499167666486
   17.3378644976670        5.34555822232834        2.86341762124810
   2.85537768408342       -4.73698297858683      -0.809893670357625
  0.872493181117456       -1.48736837562233       -7.04294495657334
  -5.73305519388480       -5.18395948528698       -9.52952552295348
  -13.9304911276502       -13.1906969094374       -12.2075045934779
  -17.1941656207311       -21.4910320390045       -21.8935288933309
  -24.4315090580027       -22.9485206481492       -24.0918117128731
  -26.3366941682204       -29.9309660775505       -28.8460745564109
  -29.5215692771499       -31.7615517707925       -34.7147286905358
  -33.2407402103442       -33.5349379110718       -35.5594220889197
  -38.5435987663875       -38.4050998488119       -37.8104044965934
  -41.0661790514155       -41.7552736658659       -44.9306488490412
  -48.4873210522279       -47.9565252006094       -49.2189153345265
  -51.4473979180454       -55.4148669106913       -54.6869725994759
  -55.5538658243593       -57.4781507853041       -60.6036263584647
  -59.3419362190768       -59.8435322989032       -61.1524220694071
  -64.4696961435858       -61.9802155998701       -62.7955092280249
  -62.2106137992162       -66.0006841783031       -62.6533103393660
  -63.7228019808619       -66.8779773219069       -66.9714765911728
  -67.0954756220709       -70.5608485387980       -67.8924693932463
  -68.2314667438467       -70.9484455095729       -70.8591462074826
  -73.0333292153744       -72.2900350245152       -73.9151223238092
  -72.7394315123023       -75.9200066548377       -77.7606922691448
  -77.9753905911917       -77.4973943269233       -79.9839748933035
  -82.4312557668264       -82.1581579011952       -82.7370533768960
  -84.8682367208473       -87.9099129489332       -87.6946146315755
  -86.4800241240852       -86.3488251494576       -84.8213370873867
  -84.2263417375129       -87.2632180031124       -85.6627305115611
  -85.4440322207756       -85.6109309163956       -83.5293471848035
  -85.9688281192861       -86.0181277339899       -86.3263253253027
  -89.0998036494623       -87.2607180226507       -86.9513204407164
  -87.8543133834660       -89.9122972995001       -88.3703093507515
  -87.6013153607466       -88.7213066075678       -90.3482938920126
  -89.2533024498079       -87.9993122502420       -89.3713015275980
  -90.5592922429763       -90.0343963452473       -91.5253846925781
  -90.3981935020273       -87.9663125081481       -89.4823006600955
  -88.4203089599846       -88.5073082800502       -90.3032942437029
  -89.1648031414653       -90.5175925688759       -89.0183042864124
  -90.0652961037533       -88.2843100228706       -88.9916044950819
  -87.0063200108728       -87.3473173458425       -87.4503165408626
  -85.7053301786277       -87.6613148918263       -88.1243112733247
  -87.6643148683803       -86.3573250830272       -87.7323143369373
  -88.2723101166547       -87.2303182602370       -84.3193410106864
  -83.0073512644101       -80.0173746322712       -81.6093621902528
  -80.4303714045365       -77.1193972811212       -76.8393994694158
  -78.1433892782149       -76.8693992349557       -76.0624055419336
  -77.0483978360102       -74.5734171789721       -72.8834303868936
  -73.3624266433466       -73.7034239783163       -72.0704367407635
  -70.0974521604257       -70.7664469319645       -70.4094497220402
  -69.1704594052442       -69.6734554741291       -67.2024747858297
  -66.0464838203606       -65.1674906900428       -65.9394846566018
  -62.9235082276617       -61.8735164337667       -60.5825265233683
  -61.5645188487062       -60.3605282583734       -60.7585251478688
  -57.8205481093323       -56.7255566671276       -56.8705555339035
  -55.8295636696706       -54.5475736889341       -54.5665735404427
  -51.7205957828951       -50.5196051691162       -49.2826148366895
  -49.6236121716592       -46.4396370556959       -45.4296449491874
  -45.7906421278503       -44.1906546323914       -42.7866656051262
  -42.9866640420585       -39.7096896529217       -38.3227004927957
  -38.4796992657876       -36.6997131770895       -35.6977210080584
  -32.7677439069992       -33.3597392803190       -32.2557479084523
  -32.5717454388055       -31.8457511127410       -30.7347597955817
  -30.9637580058692       -28.0797805453045       -27.0597885169494
  -27.1847875400321       -25.9417972544975       -24.7938062265057
  -25.1168037021515       -21.0698353308250       -20.0328434353307
  -17.1498659669506       -17.4748634269657       -16.3728720394683
  -15.9628752437570       -11.6529089278644       -8.62493259270837
  -6.58894850473687       -3.38897351381898       -1.17899078571631
  0.244998085242151        4.30696633933855        7.04994490186598
   9.37692671557408        10.2629197911845        14.5178865369206
   16.6168701325258        19.2558495078484        19.9928437479442
   22.3028256945130        23.1888187701234        25.8060983150389
   28.8697743711873        29.8867664229884        32.1652486157404
   33.7797359978770        34.5967296127457        38.0097029389966
   39.9506877694252        41.0391792624296        42.8886648079617
   45.0866476298484        46.1604392377383        49.3886140082636
   51.4425979555591        53.6955803476022        54.8010717077459
   58.6845413568801        60.6455260310020        61.8105169261330
   64.0194996620510        66.1494830153808        67.2424744732161
   71.1154442044115        73.1694281517069       0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
   35.0847257988607       0.000000000000000E+000   39.4996912941427
   25.2298028190182        32.0697493621052        23.1048194266118
   8.00823741242742        17.6598619811281        10.6919164384044
   1.95164474711713        5.31895843021633        1.75088631612442
   6.84394651182564       -2.18578291723385      -0.394096919975231
  -5.47055724541107      -5.199959360241571E-002  -8.91283034267252
  -7.14304417425799       -12.3852032046923       -7.15944404608645
  -16.9491675354889       -20.2043420950002       -24.4393089970431
  -24.3045100505506       -26.5856922222012       -24.4381090064215
  -29.0134732481232       -30.2310637321675       -30.9476581316962
  -28.8017749026303       -33.8059357931151       -34.8465276604742
  -35.1382253807401       -32.1204489658676       -36.1847172019887
  -37.5459065637504       -39.0036951705504       -44.1223551661790
  -42.0007717472004       -44.4724524300291       -45.3286457385366
  -50.2576072167348       -48.2394229896503       -50.7038037295309
  -50.9438018538497       -56.2509603762871       -54.0234777849528
  -56.0362620542402       -56.0985615673446       -60.2238293267301
  -56.3517595885010       -58.3428440273812       -56.5795578081669
  -61.1685219435801       -56.6895569484797       -58.8355401767641
  -56.4095591367744       -61.6205184110473       -62.4495119321319
  -58.7695406925764       -63.1195066958554       -64.3384971689582
  -63.0895069303155       -67.8934693854310       -68.2084669235995
  -72.2121356333301       -72.1684359748604       -75.2586118239024
  -74.6055169280997       -77.0308979727786       -76.0694054872262
  -75.8904068861717       -77.7063926935176       -80.5903701540824
  -78.9863826898848       -79.7513767111511       -81.0943662151520
  -84.5114395093599       -83.0065512706623       -84.2973411826238
  -84.8588367943115       -88.7639062746344       -87.8918130903908
  -88.4554086856662       -87.1160191535302       -86.3664250119077
  -86.7858217341548       -85.6073309445309       -87.5438158101285
  -88.1147113483519       -87.3255175162168       -89.2209027030249
  -87.9509126285043       -86.7763218084005       -88.0233120626739
  -89.3993013087685       -88.4213089521693       -86.9283206204691
  -88.4033090928453       -89.2503024732539       -88.5393080299594
  -86.4083246844450       -88.4043090850300       -88.6573071077495
  -88.3313096555497       -84.8693367122504       -87.0043200265034
  -86.9293206126538       -88.6533071390108       -87.6703148214882
  -87.1883185884812       -89.4033012775072       -86.1393267867710
  -86.1593266304642       -87.9693124847021       -87.3603172442431
  -88.8403056775426       -87.9103129458071       -88.9793045912106
  -87.7333143291219       -88.5043083034962       -86.8963208705600
  -88.4203089599846       -89.2853021997171       -88.0883115546769
  -86.9083207767759       -87.8693132662359       -88.9053051695456
  -87.1293190495862       -86.5233237856811       -86.9653203313016
  -88.0803116171996       -85.4373322731383       -84.5343393303887
  -83.0643508189358       -80.7493689114436       -79.6243777036991
  -80.9223675593901       -79.0393822756719       -79.3343799701471
  -77.1343971638911       -74.7554157565805       -74.6494165850064
  -74.7024161707935       -73.1184285502891       -70.2394510506477
  -71.2554431102641       -70.5264488076456       -69.4244574201483
  -66.4324808036401       -67.3174738870658       -66.3874811553303
  -65.1964904633980       -66.3344815695432       -62.7695094312237
  -61.9775156209716       -60.1605298214410       -61.5815187158455
  -57.4495510088227       -57.0995537441911       -57.8805476404120
  -57.3185520326320       -55.2995678117998       -56.3295597620015
  -55.2695680462599       -51.9795937587225       -52.3495908670474
  -51.4695977445449       -49.7196114213867       -50.4296058724966
  -46.5896358833952       -45.8286418308675       -43.4096607361705
  -44.5796515922248       -43.4896601109434       -44.2326543041472
  -40.2896851200256       -39.1556939826190       -36.8097123174024
  -37.7877046740016       -36.5697141930835       -37.3177083472106
  -33.8697352944965       -31.9697501436390       -31.0197575682103
  -32.2057482992192       -31.0497573337502       -27.3497862505013
  -28.3297785914699       -27.4997850782006       -25.2798024282513
  -26.1597955507538       -25.3268020609304       -21.0398355652851
  -21.5998311886958       -20.8198372846595       -17.5758626376165
  -18.1898578389989       -13.3098959778491       -12.6399012141257
  -12.8878992759218       -11.9759064035102       -8.76093152982238
  -8.66593227227951       -5.70595540568046       -4.32796617521645
  0.308997585060509        2.97497674936898        5.88095403799628
   6.64394807489327        11.5599096546909        13.7468925625463
   16.9338676550636        17.1968655996297        22.3298254834989
   23.7978140105825        24.3198099309760        26.0287965745630
   26.8317902988465        29.2207716280036        31.2007561536341
   31.6067529806068        35.6257215707627        37.2897085660400
   40.0416870582294        40.3416847136280        42.1596705053432
   46.0196403381379        46.6396354926282        48.4166216047723
   51.0896007143734        51.7115958532331        56.0995615595293
   57.7995482734544        60.9095239677527        61.4645196302400
   63.3765046873135        64.0956990665223        68.5494642585692
   70.2194512069544        73.4994255726453        74.0684211257179
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000   33.6097373264845       0.000000000000000E+000
   24.1098115721970        16.4778712188578        25.3198021156378
   12.9298989476776        17.5678627001392        10.9119147190300
   18.2098576826921        6.76794710579134        10.7399160632682
   3.82397011414688        11.2599119992923      -0.589995388950486
   4.18996725373311       -3.15997530353142       -14.0618901007148
  -19.0439511639186       -26.0148966831962       -21.0028358544526
  -18.3790563603369       -23.0487198650523       -17.4258638099172
  -24.7992061843029       -22.0598275936402       -27.2817867819443
  -20.5268395745536       -28.6432761413614       -25.1218036630748
  -29.3237708230238       -23.8498136041849       -31.8787508548348
  -37.0705102791622       -34.6177294486236       -42.8176653628507
  -37.6127060416858       -42.6253668657402       -40.2276856045765
  -48.3316222690761       -42.6396667539809       -48.0092247887411
  -45.3336456994599       -53.9015787376425       -47.6196278335969
  -51.6612962463446       -47.5896280680570       -54.1835765337172
  -47.7496268176029       -51.7695953999435       -47.5496283806705
  -54.4295746111440       -47.1496315068058       -51.5195973537780
  -56.6495572610933       -54.1695766431319       -56.2995599964616
  -61.5895186533228       -56.4895585115474       -58.9295394421223
  -63.6695023974194       -65.2944896974949       -69.1584594990282
  -70.3024505582814       -73.2409275929102       -73.4574259008895
  -74.4384182340427       -77.8963912086034       -75.4444103718126
  -76.2124043696328       -76.7364002743956       -80.6403697633155
  -77.8343916931544       -79.2383807204196       -79.4293792276900
  -83.6203464736078       -80.6203699196222       -82.6533540310398
  -86.6362229033294       -86.4474243788653       -87.2083184321745
  -88.4116090279780       -87.7114145002778       -88.7942060378297
  -87.2233183149444       -86.4333244890615       -87.6191152216335
  -85.5913310695763       -87.4093168612915       -87.9243128363923
  -87.4773163298485       -85.1493345239557       -87.0743194794298
  -87.1303190417708       -86.9863201671795       -84.0993427300608
  -86.5233237856811       -85.8333291782644       -85.9403283420232
  -81.7393611742588       -84.4423400493998       -82.1893576573567
  -82.4193558598289       -85.3693328045813       -85.1633344145410
  -81.3693640659340       -83.8193449183555       -83.9993435115946
  -82.3493564069026       -85.1593344458023       -85.2893334298084
  -87.4493165486780       -87.1093192058929       -89.1613031688190
  -88.3153097805951       -89.8604977043346       -88.6968067990436
  -89.8803975488094       -88.0653117344297       -87.1743186978959
  -87.5683156186527       -88.9673046849946       -86.6693226446417
  -86.0393275683048       -85.9093285842987       -87.5643156499141
  -84.8533368372958       -84.6923380955653       -86.0173277402422
  -83.7893451528156       -83.9993435115946       -83.7453454966905
  -81.4293635970137       -79.4413791339059       -79.2643805172208
  -76.2344041976954       -76.4384026033664       -75.7644078709043
  -74.1674203519994       -70.8524462598454       -71.3284425397444
  -70.3914498627163       -69.1564595146589       -65.4294886424242
  -66.8894772320305       -65.0294917685595       -64.3894967703759
  -66.0514837812839       -61.6795179499423       -61.5395190440897
  -59.1695375664411       -60.8795242022129       -56.1595610906090
  -56.0995615595293       -53.1495846147768       -55.0995693748674
  -54.5295738296102       -56.1195614032225       -51.5995967285510
  -51.4095982134652       -52.3695907107406       -50.0796086078650
  -49.4496135315280       -50.5696047783493       -46.1196395566041
  -45.7696422919725       -42.8896648001463       -44.2196544057466
  -39.3396925445968       -38.9796953581185       -40.0896866830932
  -39.5096912159893       -36.4897148183106       -37.8297043457574
  -32.8697431098347       -32.4897460796632       -33.4097388895521
  -32.8757430629427       -30.4797617884929       -25.5898000054965
  -27.0197888295629       -26.8097904707839       -27.8497823428323
  -25.1498034442453       -24.6298075082211       -25.8997975827417
  -20.6098389258805       -20.4598400981813       -21.4098326736100
  -17.7798610432875       -17.3598643257296       -18.2498573700786
  -12.9598987132175       -12.7299005107452       -8.68993208471139
  -9.55992528536720       -8.99392970884859       -9.60792491023096
  -4.21996701927297       -3.68997116140219       -3.55597220865751
 -0.964992458198676        2.53098021937912        3.28497432661415
   8.70093199874267        10.8369153051804        14.4698869120568
   14.6628854036966       0.000000000000000E+000   21.9588283829894
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
   27.1857875322168        28.8797742930340       0.000000000000000E+000
   33.7577361698144        35.2317246500060       0.000000000000000E+000
   38.3617001879975       0.000000000000000E+000   44.4596525300654
   44.6496510451512        47.8896257234555        49.1696157198227
   49.3976139379256        54.2795757834447        55.7095646075111
   59.1895374101343        59.3315363003563        64.7994935660873
   65.9694844221416        66.3794812178530        67.9294691040788
   71.5394408907081        71.8904381475244        77.2593961869738
   78.5993857144207       0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
   4.83996217376331       -7.06994474555921       -13.3288958293577
  -9.38492665305137       -1.47998843329952       -11.1689127104881
  -6.64994802800124       -13.1638971188885       -4.45996514359181
  -14.0798899600387       -9.03992934934304       -15.7798766739638
  -8.01993732098796       -18.0198591676064       -13.4998944929348
  -19.4598479135194       -29.4607697523225       -22.9198208724494
  -29.1697720265859       -24.4698087586752       -34.4297309179072
  -27.2297871883419       -34.2297324809748       -29.4097701509047
  -39.2096935605908       -31.5297535823878       -38.4996991094809
  -32.6297449855159       -42.2596697238094       0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  -47.0796320538795       0.000000000000000E+000
  -46.6196356489350       -51.1396003236065       -46.4996365867756
  -53.8695789877333       -56.9795546820317       -62.0195152927274
  -64.1594985679037       -69.0994599601332       -70.2354510819090
  -74.1494204926755       -70.8594462051380       -72.1894358107383
  -71.4594415159351       -75.9984060421152       -72.4394338569037
  -73.6914240721003       -73.1294284643204       -77.9393908725438
  -74.4294183043808       -76.4194027518579       -75.2194121302636
  -80.1663734677858       -82.1983575870186       -86.8063215739404
  -86.8023216052018       -84.1553422924019       -86.0123277793189
  -85.8203292798638       -86.0693273338446       -88.2253104839755
  -85.5163316557266       -85.2293338987287       -85.4273323512917
  -82.3293565632093       -84.7993372593241       -83.8493446838953
  -84.3353408856410       -80.5853701931591       -83.4993474192637
  -81.8993599238047       -82.6193542967613       -77.4293948583663
  -80.8393682080632       -77.5493939205257       -78.5393861833410
  -73.0694289332407       -76.6194011887902       -77.6093934516054
  -80.8493681299098       -78.0693898565499       -78.8293839168929
  -82.0493587515040       -77.1493970466610       -78.0093903254702
  -80.8893678172963       -81.5293628154799       -84.0393431989811
  -84.3293409325330       -86.2053262709586       -85.9343283889153
  -87.5623156655448       -86.8623211362815       -86.7253222069828
  -88.4523087098938       -85.5693312415137       -85.2673336017458
  -84.5493392131586       -86.4993239732492       -83.2093496857117
  -83.1273503265695       -82.0493587515040       -84.2193417922202
  -84.2023419250810       -85.9483282795005       -82.9583516473616
  -81.4153637064284       -81.2693648474678       -80.9833670826545
  -77.5343940377558       -76.2674039397893       -75.1304128258287
  -71.0974443450876       -71.6074403592651       -70.1154520197496
  -69.1544595302896       -64.6344948556181       -66.0544837578379
  -63.9295003654315       -63.0895069303155       -58.4295433497913
  -60.1895295947962       -60.1295300637165       -57.3995513995896
  -59.3395362378336       -54.3695750800643       -54.5795734388433
  -51.2595993857659       -53.4795820357152       -47.9496252545353
  -48.3996217376331       -50.0296089986319       -50.1196082952514
  -46.8996334606403       -48.8096185333444       -48.4696211905594
  -43.5796594075630       -45.1496471374821       -44.9696485442430
  -41.6196747256258       -43.3496612050908       -37.8897038768371
  -37.9297035642236       -34.0597338095823       -35.9797188041330
  -35.6297215395014       -37.2097091912671       -31.7297520193202
  -31.6897523319337       -28.0597807016112       -29.8797664776958
  -29.2097717139724       -30.9597580371306       -25.6697993802694
  -22.2898257961124       -22.0698275154868       -23.8098139167984
  -23.5498159487863       -17.7598611995943       -19.4098483042863
  -19.2998491639735       -15.0498823791607       -16.7398691712392
  -16.4098717503008       -10.5199177826426       -11.9699064504022
  -11.9699064504022       -7.59994060342999       -8.96992989641671
  -2.64997928935388       -2.76997835151330       -3.75997061432852
  -3.63997155216910       0.779993904036236      -0.109999140312802
  0.289997733551934       8.999929661956566E-002   5.94995349873795
   7.97993763360149        12.1409051139794        12.3619033867897
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000   54.2795757834447       0.000000000000000E+000
   58.0295464759266       0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000   70.0194527700221
   70.1304519025195       0.000000000000000E+000   76.9993982189617
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  -2.20998272810267       0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  -12.4699025427332
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  -57.5095505399024       -60.6095263123542
  -65.1094911433324       -67.0894756689629       -65.4594884079641
  -70.3894498783470       0.000000000000000E+000  -67.9094692603856
  0.000000000000000E+000  -71.4394416722419       0.000000000000000E+000
  -69.3394580844520       0.000000000000000E+000  -72.9194301055414
  0.000000000000000E+000  -70.9694453454508       -75.9794061906067
  -78.9353830884670       -83.6093465595765       -82.5703546797128
  -83.4513477943999       -86.0743272947679       -82.5593547656816
  -83.1673500139560       -82.1113582669530       -77.9293909506972
  -81.3293643785475       -79.4293792276900       -80.5993700837443
  -75.8494072066006       -79.3393799310704       -76.9893982971151
  -78.3993872774883       -72.3994341695173       -76.1194050964593
  -71.7594391713337       -73.4694258071054       -67.4394729335945
  -71.4394416722419       -67.0894756689629       -68.6994630862685
  -73.2694273701730       -74.4794179136139       -68.6694633207286
  -72.5294331535233       -73.6394244784979       -70.5694484715861
  -74.2594196329883       -75.3894108016562       -78.7493845421199
  -79.4593789932298       -82.5593547656816       -82.7593532026139
  -85.4813319292635       -85.1153347896772       -87.3023176975327
  -83.7693453091224       -83.7393455435825       -82.1693578136634
  -84.7693374937842       -80.9893670357625       -81.3993638314738
  -79.4093793839968       -82.0293589078108       -77.4993943112926
  -78.1793889968627       -80.4693710997383       -81.0593664886888
  -79.5103785946476       -81.9633594236231       -80.6553696460854
  -77.1103973514592       -75.2064122318630       -70.6394479245124
  -71.4334417191339       -69.1394596475197       -68.6004638599869
  -63.7095020848059       -64.9534923625252       -62.4395120102853
  -62.0565150035598       -56.9395549946452       -58.4895428808711
  -55.5295660142720       -55.2895678899532       -57.5495502272889
  -52.0795929771887       -52.3395909452007       -48.7696188459580
  -51.2795992294592       -45.3596454962611       -46.0996397129109
  -41.9496721465642       -44.4996522174519       -44.8896491694700
  -46.9196333043336       -41.0996787896016       -41.5096755853130
  -43.3696610487840       -39.6196903563021       -39.7096896529217
  -41.8096732407116       -35.8197200545871       -36.2697165376850
  -32.0097498310255       -34.1197333406620       -27.6397839840533
  -28.1797797637707       -30.0097654617018       -30.2197638204808
  -26.1397957070605       -28.3497784351632       -21.9298286096342
  -22.2898257961124       -24.0198122755774       -24.1598111814301
  -20.2298418957090       -13.6698931643274       -15.5598783933382
  -15.9798751108962       -17.6798618248213       -13.2098967593829
  -13.2298966030762       -15.0698822228539       -8.46993380408579
  -8.66993224101816       -10.5199177826426       -5.87995404581162
  -5.99995310797104       -7.76993927482250       -1.03999187204831
  -1.17999077790097        3.69997108324881        1.92998491639735
   1.96998460378383       0.609995232643723        7.39994216649762
   7.17994388587201        6.16995177936356        6.13995201382370
   10.8699150472742        10.3899187986365       0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  -57.9595470230003       -63.8495009906585
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  -77.3093957962069
  0.000000000000000E+000  -78.3393877464086       -79.6323776411763
  -77.7593922793047       -81.2693648474678       -76.5094020484774
  0.000000000000000E+000  -75.5294097075088       -70.1294519103349
  -74.0994208834424       -71.1494439386900       -73.0894287769339
  -66.1894827027672       -70.3994498001936       -65.3194895021114
  -67.4694726991344       0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  -62.6295105253711       -66.8494775446440
  0.000000000000000E+000  -64.5294956762286       -69.0494603509001
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  -77.7593922793047       -78.6793850891936       -81.1193660197685
  -81.5993622684062       -79.4693789150765       -82.3393564850560
  -77.9693906380837       -78.4693867304146       -76.2894037678518
  -79.1893811033712       -74.2094200237552       -75.0294136151779
  -72.2994349510511       -75.4794100982757       -75.9094067376803
  -78.9773827602228       -74.4094184606875       -75.6354088790830
  -77.9353909038052       -75.9094067376803       -70.5094489405064
  -67.7694703545329       -67.5294722302141       -62.0395151364206
  -63.4395041949472       -60.4095278754218       -60.3095286569556
  -54.5295738296102       -56.4495588241609       -53.0595853181573
  -53.2695836769363       -47.2296308815787       -49.4896132189145
  -49.9296097801657       -46.1296394784507       -48.7596189241114
  -42.3696688641222       -43.0796633152321       -38.6696977808734
  -41.4796758197731       -34.6497291985328       -35.6997209924277
  -38.1297020011560       -38.9196958270388       -34.1597330280485
  -36.8397120829422       -37.4097076281995       -30.8897585842043
  -33.1597408433866       -33.8397355289567       -29.3497706198250
  -31.6297528008540       -24.7498065703806       -25.6297996928830
  -20.7898375191197       -23.2098186060013       -23.6898148546390
  -26.0397964885943       -19.1098506488878       -19.8598447873842
  -14.9398832388479       -17.4998632315822       -17.8598604180605
  -20.2198419738624       -13.0498980098370       0.000000000000000E+000
  -8.30993505453990       -10.8099155161945       -11.0599135623600
  -4.04996834788045       -6.02995287351090       -6.66994787169448
  0.000000000000000E+000  -3.73997077063528       -3.94996912941427
   3.15997530353142        1.22999038713406       0.869993200655801
   5.97995326427781        3.95996905126089       0.000000000000000E+000
  0.000000000000000E+000   9.11992872411599        8.85993075610391
  0.000000000000000E+000  0.000000000000000E+000   12.2399043402609
   10.8699150472742       0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  -69.8794538641694       -71.4794413596284       -68.5094645711827
  -71.9394377645728       -72.9394299492347       -67.8094700419194
  -64.2094981771368       0.000000000000000E+000  -61.5295191222431
  -57.9395471793070       -58.1995451473191       -51.8095950873300
  -53.8695789877333       -50.0496088423251       -50.4496057161899
  -43.8096576100352       -46.4696368212357       -42.2196700364229
  -42.7996655035268       -45.7496424482792       -38.8396964522659
  -39.7096896529217       -34.8497276354651       -38.0397027045364
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  -30.5497612414192       -33.5297379517115
  -26.1797953944470       -27.3197864849615       -29.9097662432357
  -24.9298051636197       -25.6397996147296       -28.5397769502489
  -21.1898343929844       -22.4098248582718       -16.7998687023189
  -19.8598447873842       0.000000000000000E+000  0.000000000000000E+000
  -15.8298762831969       -16.8998679207851       -11.7399082479300
  -14.3298880062042       0.000000000000000E+000  0.000000000000000E+000
  -9.86992286261236       -10.8499152035810       0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
   6.27995091967636       0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000
  0.130000000000000       0.250000000000000       0.380000000000000
  0.500000000000000       0.630000000000000       0.750000000000000
  0.880000000000000        1.00000000000000        1.13000000000000
   1.25000000000000        1.38000000000000        1.50000000000000
   1.63000000000000        1.75000000000000        1.88000000000000
   2.00000000000000        2.13000000000000        2.25000000000000
   2.38000000000000        3.94000000000000        2.63000000000000
   2.75000000000000        2.88000000000000        3.55000000000000
   4.35000000000000        3.25000000000000        3.38000000000000
   3.96000000000000        3.63000000000000        3.75000000000000
   3.88000000000000        4.82000000000000        4.44000000000000
   4.43000000000000        4.43000000000000        4.42000000000000
   4.63000000000000        5.66000000000000        5.81000000000000
   5.95000000000000        5.49000000000000        6.18000000000000
   7.11000000000000        6.96000000000000        7.20000000000000
   7.73000000000000        6.41000000000000        6.85000000000000
   6.77000000000000        6.91000000000000        7.26000000000000
   7.20000000000000        6.86000000000000        8.06000000000000
   7.81000000000000        7.82000000000000        8.41000000000000
   8.13000000000000        7.19000000000000        8.35000000000000
   8.13000000000000        8.02000000000000        8.93000000000000
   8.90000000000000        9.69000000000000        9.65000000000000
   10.5500000000000        9.38000000000000        9.72000000000000
   10.6600000000000        11.9800000000000        12.7600000000000
   12.1000000000000        12.8600000000000        13.0300000000000
   12.8100000000000        12.5400000000000        12.6500000000000
   12.0000000000000        12.6900000000000        14.0500000000000
   13.3300000000000        13.2800000000000        13.2300000000000
   13.1700000000000        8.66000000000000        11.0900000000000
   10.4000000000000        13.4700000000000        10.1700000000000
   12.2200000000000        11.6200000000000        12.9500000000000
   13.1500000000000        13.5700000000000        12.8700000000000
   16.1600000000000        14.7100000000000        15.6900000000000
   14.0900000000000        18.5600000000000        16.2200000000000
   16.6700000000000        17.1300000000000        17.0000000000000
   16.8600000000000        15.3300000000000        15.6100000000000
   16.7700000000000        17.9300000000000        17.4500000000000
   16.9700000000000        17.8800000000000        17.5800000000000
   15.7800000000000        16.8300000000000        17.4900000000000
   16.0300000000000        15.0800000000000        16.7400000000000
   17.7400000000000        17.4300000000000        18.1400000000000
   17.0600000000000        19.0100000000000        17.0200000000000
   17.0200000000000        17.0200000000000        18.5100000000000
   17.2000000000000        16.7500000000000        16.9700000000000
   16.9400000000000        16.9100000000000        17.6900000000000
   15.5500000000000        14.5600000000000        14.3500000000000
   16.5500000000000        18.2900000000000        17.8000000000000
   17.0500000000000        21.3100000000000        19.1500000000000
   19.5100000000000        19.8700000000000        20.3900000000000
   20.9000000000000        21.8500000000000        22.8900000000000
   25.6800000000000        24.6400000000000        24.9100000000000
   23.2400000000000        22.8500000000000        22.4600000000000
   21.9800000000000        21.6400000000000        21.7500000000000
   21.8500000000000        21.7700000000000        21.6900000000000
   23.7400000000000        21.3500000000000        23.0300000000000
   20.6600000000000        21.8100000000000        20.7700000000000
   22.1800000000000        22.5800000000000        22.5500000000000
   21.4500000000000        21.1600000000000        21.0200000000000
   20.8700000000000        22.0900000000000        22.0000000000000
   21.2800000000000        23.0500000000000        21.7000000000000
   21.4500000000000        22.2800000000000        23.0000000000000
   22.1100000000000        23.5600000000000        22.8300000000000
   24.8800000000000        22.6400000000000        23.2700000000000
   23.8900000000000        23.9200000000000        23.9400000000000
   21.1600000000000        22.3000000000000        21.7500000000000
   21.1900000000000        20.7200000000000        20.2400000000000
   21.3400000000000        19.0000000000000        17.9300000000000
   17.8500000000000        15.7000000000000        13.5400000000000
   11.7800000000000        10.0200000000000        10.9800000000000
   10.2800000000000        11.7200000000000        13.8100000000000
   14.4600000000000        15.3000000000000        16.1500000000000
   16.9900000000000        17.8400000000000        18.6800000000000
   19.5300000000000        20.3700000000000        21.2200000000000
   22.0600000000000        22.9100000000000        23.7500000000000
   24.6000000000000        25.4400000000000        26.2900000000000
   27.1300000000000        27.9800000000000        28.8200000000000
   29.6700000000000        30.7100000000000        30.5300000000000
   31.4500000000000        29.6300000000000        30.1500000000000
   30.6500000000000        30.2700000000000        29.5200000000000
   30.0800000000000        29.8000000000000        29.8700000000000
   32.4512260786668        32.5858784690347        32.7205308594026
   32.8551832497705        32.9898356401384        33.1244880305063
   33.2591404208742        33.3937928112421        33.5284452016101
   33.6630975919780
  0.100000000000000       0.900000000000000      F T F
  0.178441146042939       0.176854755447340       0.175457523511159
  0.178440798291086       0.177847580665707       0.177178950695165
  0.176542728233259       0.175967661944468       0.175456823596599
  0.175005168033411       0.174605505760961       0.174250735402598
  0.173934480416989       0.173651244352414       0.173396399197021
  0.176284676038272       0.176005252123378       0.175741801502665
  0.175493821420086       0.175260563010190       0.175041152196171
  0.174834694659134       0.174640301295590       0.174457108584218
  0.174284274484268       0.174121060727579       0.173966751275695
  0.173820693656522       0.173682295461442       0.173550990323865
  0.173426281108896       0.173307698178998       0.173194833498812
  0.173087290981306       0.172984722514601       0.172886786445479
  0.172793190434770       0.172703651742762       0.172617938672571
  0.172535787912517       0.172457013428583       0.172381393903792
  0.172308745673507       0.172238919838372       0.172171736659333
  0.172107057186978       0.172044744904835       0.171984673531151
  0.171926718099366       0.171870789914284       0.171816765250475
  0.171764562450018       0.171714071153700       0.171665228454992
  0.171617948837318       0.171572158885393       0.171527796465106
  0.171484782600370       0.171443063233302       0.171402581095653
  0.171363282082134       0.171325108165235       0.171288031882564
  0.171251987132930       0.171216938064970       0.171182837032322
  0.171149666076201       0.171117361544088       0.171085916272709
  0.171055270179356       0.171025419508950       0.170996314310324
  0.170967926663031       0.170940243344760       0.170913232205649
  0.170886875980471       0.170861138037182       0.170836003406656
  0.170811450916359       0.170787454244663       0.170764013982761
  0.170741085618302       0.170718671627445       0.170696755166074
  0.170675300794188       0.170654319456517       0.170633776821819
  0.170613665685691       0.170593965931055       0.170574684426576
  0.170555782619628       0.170537268427738       0.170519130476294
  0.170501344654811       0.170483900681757       0.170466801495381
  0.170450037279425       0.170433579262678       0.170417444570396
  0.170401604974142       0.170386052236448       0.170370791270107
  0.170355814336234       0.170341094662250       0.170326650782861
  0.170312456565112       0.170298505345497       0.170284809827809
  0.170271338174411       0.170258110004008       0.170245100286411
  0.170232309760820       0.170219733138796       0.170207365023389
  0.170195200380670       0.170183227927957       0.170171455642058
  0.170159878853221       0.170148480521709       0.170137262548154
  0.170126214451279       0.170115344811094       0.170104649766787
  0.170094112839613       0.170083730213538       0.170073517430401
  0.170063451920238       0.170053530360435       0.170043762084085
  0.170034143891283       0.170024660091918       0.170015313939387
  0.170006102636771       0.169997023222620       0.169988072979511
  0.169979242956101       0.169970549313136       0.169961970825056
  0.169953504917733       0.169945161748312       0.169936932719445
  0.169928815557190       0.169920808009674       0.169912914235195
  0.169905119655493       0.169897422161807       0.169889838489013
  0.169882341748084       0.169874948835945       0.169867651572232
  0.169860448196458       0.169853343127943       0.169846316142078
  0.169839390288340       0.169832545363639       0.169825779791752
  0.169819110606634       0.169812517715288       0.169805999652889
  0.169799573531819       0.169793213216579       0.169786942051128
  0.169780733957195       0.169774612417112       0.169768557503757
  0.169762568109508       0.169756655207108       0.169750817692467
  0.169745035930372       0.169739333332254       0.169733690356599
  0.169728105889472       0.169722597391865       0.169717139122623
  0.169711754746491       0.169706418591380       0.169701148180695
  0.169695942518575       0.169690782287533       0.169685691105419
  0.169680643521851       0.169675663171359       0.169670730807017
  0.169665851795987       0.169661025223985       0.169656250313439
  0.169651526273317       0.169646852299504       0.169642221592594
  0.169637651703675       0.169633117456545       0.169628642544881
  0.169624207987350       0.169619819190840       0.169615469398103
  0.169611176200974       0.169606920700169       0.169602708317220
  0.169598538512418       0.169594410564779       0.169590323957695
  0.169586272035110       0.169582266304065       0.169578306192436
  0.169574373008326       0.169570490429236       0.169566633679605
  0.169562820437863       0.169559044050722       0.169555304116932
  0.169551606109689       0.169547937468310       0.169544303738611
  0.169540704526921       0.169537139294262       0.169533601574138
  0.169530102999001       0.169526643124760       0.169523209450670
  0.169519801559757       0.169516437102556       0.169513097653856
  0.169509782744194       0.169506510052757       0.169503261191319
  0.169500035711533       0.169496851295283       0.169493683574667
  0.169490556155754       0.169487444697369       0.169484372898017
  0.169481316300907       0.169478298672298       0.169475301655411
  0.169472330860674       0.169469386058103       0.169466460839528
  0.169463566961235       0.169460704087973       0.169457853953814
  0.169455034202520       0.169452238546337       0.169449472730705
  0.169446724492888       0.169443993492467       0.169441297499142
  0.169438618198596       0.169435955395394       0.169433326746792
  0.169430714075063       0.169428123063354       0.169425553483127
  0.169423005066731       0.169420471664465       0.169417964895747
  0.169415484605056       0.169413012593961       0.169410572502353
  0.169408146248256       7.217811636347234E-002  8.129581305187805E-002
  8.763518850627663E-002  7.218141089560161E-002  7.629665779441844E-002
  7.975838337086377E-002  8.273410813243250E-002  8.533494778667595E-002
  8.763835851510482E-002  8.970041250018267E-002  9.156300834527263E-002
  9.325822231701057E-002  9.481115044026464E-002  9.624176041170709E-002
  9.756622460019979E-002  8.390592500058276E-002  8.516576505378123E-002
  8.635159855841179E-002  8.747089261043796E-002  8.853007076980608E-002
  8.953470157219140E-002  9.048961000631973E-002  9.139904978210528E-002
  9.226673915807433E-002  9.309599314911385E-002  9.388974538863536E-002
  9.465062230496527E-002  9.538096702045375E-002  9.608289819186931E-002
  9.675832101606661E-002  9.740897610978053E-002  9.803642214170383E-002
  9.864208949465036E-002  9.922729251439434E-002  9.979322340196760E-002
  0.100340979931685       0.100871575887651       0.101385929903472
  0.101884913754470       0.102369318926122       0.102839882933118
  0.103297294810415       0.103742179364428       0.104175142553832
  0.104596738339593       0.105007471902239       0.105407844236502
  0.105798296733111       0.106179255187926       0.106551127986591
  0.106914287147969       0.107269091106383       0.107615861066063
  0.107954924728797       0.108286579681937       0.108611098765514
  0.108928748194359       0.109239788684674       0.109544459353559
  0.109842978511874       0.110135561586462       0.110422421936752
  0.110703750042038       0.110979735621353       0.111250542322180
  0.111516351457543       0.111777319301768       0.112033603497464
  0.112285337429965       0.112532678447346       0.112775742970325
  0.113014672155580       0.113249584280920       0.113480596837192
  0.113707826834900       0.113931369127343       0.114151344924641
  0.114367836158129       0.114580956017153       0.114790778741458
  0.114997410296863       0.115200922405123       0.115401396815165
  0.115598925529541       0.115793566653947       0.115985406548847
  0.116174515662534       0.116360948586984       0.116544784192359
  0.116726081284428       0.116904905394561       0.117081306588761
  0.117255341848112       0.117427079668710       0.117596559905743
  0.117763834066252       0.117928960955008       0.118091988827839
  0.118252950929834       0.118411905962712       0.118568893263216
  0.118723955300774       0.118877133243469       0.119028467009513
  0.119177999828028       0.119325760241685       0.119471784694222
  0.119616117604559       0.119758788816404       0.119899831699828
  0.120039278673024       0.120177165770476       0.120313510010947
  0.120448354760467       0.120581724431914       0.120713647179746
  0.120844150394864       0.120973265281125       0.121101004132129
  0.121227405853383       0.121352490488138       0.121476286548875
  0.121598808250998       0.121720078321718       0.121840132612647
  0.121958974454873       0.122076638606477       0.122193141031349
  0.122308501754049       0.122422740308391       0.122535875752981
  0.122647931270115       0.122758911260415       0.122868847196111
  0.122977751794877       0.123085641952360       0.123192538765356
  0.123298444569628       0.123403388899420       0.123507382550368
  0.123610440564153       0.123712577643911       0.123813812771141
  0.123914150788966       0.124013605436743       0.124112199378532
  0.124209941156755       0.124306848255100       0.124402919414206
  0.124498180805870       0.124592639873942       0.124686313048736
  0.124779198017428       0.124871319970512       0.124962685368521
  0.125053305068166       0.125143189704421       0.125232349696378
  0.125320795252924       0.125408536378227       0.125495582877047
  0.125581944359882       0.125667634890590       0.125752649778009
  0.125837016652865       0.125920725816772       0.126003804567010
  0.126086247505659       0.126168063009872       0.126249268605447
  0.126329867710583       0.126409872899623       0.126489277973719
  0.126568109188802       0.126646355396887       0.126724042588474
  0.126801163997243       0.126877731369864       0.126953751664708
  0.127029227047783       0.127104173565835       0.127178593145891
  0.127252496937402       0.127325877288539       0.127398754468430
  0.127471129949994       0.127543009772208       0.127614404549025
  0.127685310758861       0.127755734133056       0.127825689670826
  0.127895178235994       0.127964205279528       0.128032776161746
  0.128100896154270       0.128168570441926       0.128235804124596
  0.128302606909864       0.128368969660553       0.128434915998067
  0.128500436624008       0.128565536236182       0.128630228850935
  0.128694519024914       0.128758401845150       0.128821886419460
  0.128884977090149       0.128947673429828       0.129009993753892
  0.129071923395203       0.129133480544145       0.129194664515607
  0.129255483974383       0.129315928695073       0.129376016639231
  0.129435746880525       0.129495123143852       0.129554149098818
  0.129612828360811       0.129671164492032       0.129729165718308
  0.129786821351112       0.129844148946463       0.129901151866688
  0.129957819266574       0.130014168565947       0.130070202984722
  0.130125911529303       0.130181316214604       0.130236405955283
  0.130291183787717       0.130345666884864       0.130399844025581
  0.130453718121252       0.130507306230306       0.130560592272772
  0.130613597962412       0.130666311866948       0.130718741436558
  0.130770884621190       0.130822753534339       0.130874350790485
  0.130925669497008       0.130976712194073       0.131027495601637
  0.131078003246160       0.131128256524014       0.131178243630740
  0.131227971685051       0.131277438294142       0.131326655259925
  0.131375620130170       0.131424339908834       0.131472802593370
  0.131521029365266       0.131569003416439       0.131616741131761
  0.131664244633432       0.131711506518753       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.100000000000000       0.100000000000000       0.100000000000000
  0.446954236795279       0.680434579027796       0.861355896853944
  0.606689359698639       0.745352165247297       0.867393077575275
  0.977029354965613        1.07697864081173        1.16911231968359
   1.25478190619091        1.33500026261228        1.41054827228344
   1.48204247445287        1.54997904961819        1.61476417374020
   1.29038544290716        1.35202128663984        1.41120279126526
   1.46815734932654        1.52308048180927        1.57614177088282
   1.62748898040696        1.67725226113397        1.72554642865628
   1.77247389909183        1.81812588545020        1.86258443841741
   1.90592337624535        1.94820958249603        1.98950380602565
   2.02986148516595        2.06933310972744        2.10796499122491
   2.14579987510557        2.18287697322382        2.21923264275415
   2.25490050238092        2.28991163270456        2.32429506275074
   2.35807788885051        2.39128518387733        2.42394066023784
   2.45606624552965        2.48768267185614        2.51880948299468
   2.54946478621939        2.57966599499936        2.60942920819502
   2.63876979918970        2.66770225705142        2.69624036745160
   2.72439711161486        2.75218478800088        2.77961514716860
   2.80669935972806        2.83344791550437        2.85987085947196
   2.88597798121165        2.91177841012328        2.93728079398672
   2.96249349217416        2.98742464163109        3.01208171843496
   3.03647221746167        3.06060295585377        3.08448085967152
   3.10811220679070        3.13150341007324        3.15466009402053
   3.17758836000250        3.20029332509671        3.22278057052307
   3.24505513836153        3.26712185247458        3.28898554119785
   3.31065055649551        3.33212160713440        3.35340267423068
   3.37449808291129        3.39541161407346        3.41614719054460
   3.43670852106378        3.45709905350782        3.47732242395673
   3.49738189219208        3.51728069941448        3.53702212837034
   3.55660901032504        3.57604452204250        3.59533133620270
   3.61447247736970        3.63347039070479        3.65232769659488
   3.67104721113544        3.68963123066387        3.70808206427462
   3.72640216665651        3.74459395155060        3.76265925854741
   3.78060055939850        3.79841988613629        3.81611917891331
   3.83370041954676        3.85116568371653        3.86851671984380
   3.88575538376023        3.90288346175359        3.91990267131077
   3.93681484557251        3.95362144372381        3.97032422974991
   3.98692479355389        4.00342448665367        4.01982499890596
   4.03612773482882        4.05233417768865        4.06844562617021
   4.08446351069644        4.10038907872220        4.11622377611129
   4.13196886764005        4.14762556349875        4.16319495626631
   4.17867834300547        4.19407708595495        4.20939191478972
   4.22462429808325        4.23977526712432        4.25484578967558
   4.26983691536205        4.28474977781112        4.29958539738685
   4.31434456402497        4.32902844144892        4.34363791152155
   4.35817395645417        4.37263739214037        4.38702907271101
   4.40135007271860        4.41560107608359        4.42978297836644
   4.44389660522174        4.45794283388990        4.47192227020007
   4.48583580302322        4.49968433314780        4.51346837969396
   4.52718896854553        4.54084645493752        4.55444180897292
   4.56797566128979        4.58144871062359        4.59486159307829
   4.60821495260077        4.62150953919530        4.63474599258449
   4.64792477204054        4.66104666416971        4.67411227642970
   4.68712203540480        4.70007675510666        4.71297678478872
   4.72582299002543        4.73861549046403        4.75135528661053
   4.76404263854062        4.77667824317469        4.78926241204732
   4.80179583281582        4.81427892100500        4.82671227833203
   4.83909646654396        4.85143158011366        4.86371861237040
   4.87595751207012        4.88814925998964        4.90029391934607
   4.91239200792993        4.92444414313962        4.93645044967150
   4.94841173555975        4.96032811185569        4.97220024377018
   4.98402826310310        4.99581278926472        5.00755414643144
   5.01925272540106        5.03090898429239        5.04252321745824
   5.05409561755935        5.06562694173814        5.07711723835377
   5.08856704808923        5.09997666401001        5.11134649605381
   5.12267670489948        5.13396781319215        5.14522016857341
   5.15643387895131        5.16760956653850        5.17874733007693
   5.18984754814576        5.20091055879241        5.21193667067692
   5.22292622537718        5.23387934943487        5.24479658867183
   5.25567797372798        5.26652408153752        5.27733489650393
   5.28811086330232        5.29885231040412        5.30955952533603
   5.32023255206254        5.33087188545517        5.34147777758267
   5.35205036280622        5.36258989866218        5.37309676697404
   5.38357121961047        5.39401339010858        5.40442348575305
   5.41480197903458        5.42514891739274        5.43546449935388
   5.44574918972038        5.45600302652356        5.46622626461740
   5.47641918015619        5.48658202316903        5.49671475451265
   5.50681808447275        5.51689173555353        5.52693611551213
   5.53695160335896        5.54693809534512        5.55689617483478
   5.56682567983284        5.57672688914588        5.58660012034794
   5.59644552954144        5.60626337713158        5.61605363187990
   5.62581661577916        5.63555275372181        5.64526171685252
   5.65494420420633        5.66460016074435        5.67422964551140
   5.68383295696217        5.69341036332645        5.70296195942155
   5.71248799730987        5.72198847547864        5.73146374742780
   5.74091366025185        5.75033882113332        5.75973912396630
   5.76911477266374        1.31638374772749        1.31301479128529
   1.31258170576189        1.78651765784193        1.78360027129278
   1.78229934255929        1.78171349400699        1.78145960468310
   1.78136080700509        1.78133121831877        1.78132763126180
   1.78132832927348        1.78132252785475        1.78130517008433
   1.78127439093290        2.25041138173802        2.25027887459302
   2.25019553440087        2.25014553141220        2.25011767092553
   2.25010394334230        2.25009871026269        2.25009796263730
   2.25009881491187        2.25009907834994        2.25009747520856
   2.25009298240193        2.25008495642702        2.25007304925782
   2.25005693199261        2.25003656291683        2.25001188676167
   2.24998308055404        2.24995020431302        2.24991346252648
   2.24987290986279        2.24982878462180        2.24978121646143
   2.24973057397274        2.24967680929455        2.24962034982011
   2.24956119591214        2.24949952162413        2.24943568187558
   2.24936965110375        2.24930164519732        2.24923180932037
   2.24916028166188        2.24908712702496        2.24901266458165
   2.24893681377170        2.24885981598863        2.24878157300874
   2.24870238181336        2.24862226574238        2.24854130991387
   2.24845966337169        2.24837726190000        2.24829424439252
   2.24821067667831        2.24812662012269        2.24804206006464
   2.24795726579896        2.24787207218737        2.24778659870842
   2.24770081540643        2.24761498431703        2.24752884893965
   2.24744274262763        2.24735640007382        2.24727015365157
   2.24718380669785        2.24709738581772        2.24701106924021
   2.24692480484221        2.24683869338895        2.24675260021938
   2.24666662304824        2.24658077927305        2.24649500775896
   2.24640956084154        2.24632413682484        2.24623898798524
   2.24615412754327        2.24606932662134        2.24598491866981
   2.24590067111661        2.24581667520356        2.24573285666001
   2.24564947102171        2.24556619542624        2.24548328550769
   2.24540074872496        2.24531842306365        2.24523631371717
   2.24515459415444        2.24507326938353        2.24499208830940
   2.24491139644572        2.24483094017853        2.24475072186935
   2.24467091668879        2.24459152804127        2.24451229707584
   2.24443357407263        2.24435509928310        2.24427687320615
   2.24419916124260        2.24412161105529        2.24404457829180
   2.24396779699001        2.24389135617974        2.24381525701948
   2.24373949878921        2.24366408177922        2.24358891491696
   2.24351417954119        2.24343987585476        2.24336582150651
   2.24329210625892        2.24321863735042        2.24314559817963
   2.24307298933365        2.24300062428454        2.24292850028430
   2.24285689794231        2.24278553473043        2.24271440892666
   2.24264370763421        2.24257343035754        2.24250338629330
   2.24243366831780        2.24236427591240        2.24229520666932
   2.24222645937905        2.24215793604379        2.24208992411160
   2.24202213357008        2.24195456107078        2.24188739946132
   2.24182055009722        2.24175401128141        2.24168778098273
   2.24162195659918        2.24155633965061        2.24149092699406
   2.24142601416364        2.24136120259100        2.24129678918030
   2.24123267193781        2.24116884938758        2.24110541987228
   2.24104208115769        2.24097923281517        2.24091657123682
   2.24085409389594        2.24079210326022        2.24073029324576
   2.24066866133800        2.24060751213537        2.24054643483390
   2.24048583757476        2.24042530736761        2.24036525520622
   2.24030536879772        2.24024564699469        2.24018629398472
   2.24012730967616        2.24006837969279        2.24000991889911
   2.23995161258673        2.23989345801693        2.23983576977311
   2.23977812394733        2.23972094190894        2.23966379799514
   2.23960700881910        2.23955057302133        2.23949416966101
   2.23943822353752        2.23938230533597        2.23932684160433
   2.23927150915970        2.23921641446342        2.23916155489341
   2.23910692918637        2.23905253575262        2.23899837267431
   2.23894433029503        2.23889073335451        2.23883714415007
   2.23878399779436        2.23873096521877        2.23867815409077
   2.23862545290328        2.23857319017716        2.23852103441887
   2.23846909382100        2.23841736795014        2.23836585399066
   2.23831455153197        2.23826334773171        2.23821246312478
   2.23816189690378        2.23811131291754        2.23806115709502
   2.23801097962041        2.23796111610689        2.23791145196153
   2.23786198722310        2.23781283271514        2.23776376128566
   2.23771488427375        2.23766620141899        2.23761771039839
   2.23756929613479        2.23752118546529        2.23747337770533
   2.23742564274554        2.23737797878342        2.23733072895961
   2.23728354838768        2.23723643425898        2.23718973177709
   2.23714309440044        2.23709651935328        2.23705035353962
   2.23700413238527        2.23695831854997        2.23691244600690
   2.23686698029614        2.23682145185438        2.23677632874556
   2.23673125850188        2.23668635610704        2.23664162187675
   2.23659693531562        2.23655253227802        2.23650841189523
   2.23646421832773        2.23642030498062        2.23637655244317
   2.23633307948450        2.23628964709060        2.23624625267818
   2.23620325497479        2.23616029326960        2.23611736711366
   2.23607483507337        2.23603233664886        2.23598999014511
   2.23594779496639        2.23590574982162        2.23586373383888
   2.23582198650796        2.23578050883213        2.23573893483736
   2.23569774930676        2.23565658753281       0.778535295339175
  0.769559969937697       0.765094446294627        1.05657792870164
   1.05033923396818        1.04608436767054        1.04291972779625
   1.04041483697828        1.03833970615725        1.03656239532245
   1.03500084121343        1.03360255713590        1.03233161434628
   1.03116386510464        1.03007998980880        1.31591487151620
   1.31440668310954        1.31303360562624        1.31177293569894
   1.31060659745200        1.30951938530414        1.30850103252299
   1.30754122447866        1.30663372607165        1.30577150321674
   1.30494956448182        1.30416346493825        1.30341018977712
   1.30268625091908        1.30198947804547        1.30131642991061
   1.30066625971533        1.30003712245962        1.29942678721803
   1.29883421337079        1.29825831436820        1.29769754907608
   1.29715222767923        1.29662008814242        1.29610098586136
   1.29559397312283        1.29509814376889        1.29461420447784
   1.29414020742657        1.29367560169650        1.29322149777016
   1.29277538098659        1.29233850418119        1.29191036069838
   1.29148950234076        1.29107646553058        1.29067006564389
   1.29027193836430        1.28987990843859        1.28949399337670
   1.28911488022456        1.28874238199566        1.28837517766630
   1.28801329898556        1.28765736610193        1.28730721730360
   1.28696185032076        1.28662145756593        1.28628537343501
   1.28595508421544        1.28562890099332        1.28530698421421
   1.28498903723283        1.28467629799114        1.28436673721872
   1.28406202500305        1.28376077582124        1.28346345193849
   1.28316968943523        1.28287895044403        1.28259283171072
   1.28230903236619        1.28202975865931        1.28175257296478
   1.28147975080604        1.28120881979287        1.28094165307513
   1.28067810440129        1.28041603946534        1.28015832982770
   1.27990260916282        1.27964897602764        1.27939943034243
   1.27915185955625        1.27890674607716        1.27866354371123
   1.27842354952474        1.27818648073003        1.27795055112289
   1.27771756511772        1.27748762238292        1.27725912860696
   1.27703228217364        1.27680871705189        1.27658682859781
   1.27636699021598        1.27614905211591        1.27593314451130
   1.27571940011958        1.27550671124401        1.27529665739433
   1.27508921506428        1.27488281077307        1.27467823773994
   1.27447541157459        1.27427447064941        1.27407445722419
   1.27387745376542        1.27368157764896        1.27348716471821
   1.27329458645689        1.27310336368523        1.27291309363049
   1.27272576923216        1.27253914735889        1.27235415415002
   1.27216992382617        1.27198763664726        1.27180765053639
   1.27162764359144        1.27145038632875        1.27127380278233
   1.27109870159065        1.27092468982693        1.27075209911180
   1.27058075894884        1.27040983546574        1.27024185494951
   1.27007425612419        1.26990778146969        1.26974264678965
   1.26957780802934        1.26941573478784        1.26925409219096
   1.26909352719937        1.26893416963545        1.26877573658266
   1.26861769330250        1.26846145544781        1.26830721745085
   1.26815320121590        1.26800010829562        1.26784725545521
   1.26769713833317        1.26754703457046        1.26739800442369
   1.26724907897768        1.26710293620232        1.26695672835505
   1.26681142039034        1.26666727488577        1.26652374957761
   1.26638136529923        1.26623983668550        1.26609898716297
   1.26595921107263        1.26582027778689        1.26568128427142
   1.26554478852410        1.26540750029576        1.26527277347891
   1.26513711573340        1.26500314387576        1.26487083555581
   1.26473835390563        1.26460661133755        1.26447492770222
   1.26434561021621        1.26421552798746        1.26408771098421
   1.26395901037713        1.26383184744127        1.26370525543837
   1.26357967449627        1.26345547018757        1.26333119993213
   1.26320741521862        1.26308367548299        1.26296218738628
   1.26284058065418        1.26271973130249        1.26259934730265
   1.26247890929242        1.26235996463832        1.26224244341415
   1.26212476633346        1.26200760249285        1.26189101490400
   1.26177523014187        1.26165991342791        1.26154527809452
   1.26143119498198        1.26131678507201        1.26120468934847
   1.26109153019174        1.26097976183488        1.26086943967149
   1.26075889585465        1.26064782833041        1.26053834508260
   1.26042919916354        1.26032079986017        1.26021391248725
   1.26010549001870        1.25999966124178        1.25989326304941
   1.25978733707937        1.25968107478105        1.25957720807550
   1.25947299633926        1.25936913995374        1.25926591802610
   1.25916293246946        1.25906068293604        1.25895877059453
   1.25885646114519        1.25875650005529        1.25865610068437
   1.25855498940024        1.25845642383974        1.25835750168453
   1.25825785002487        1.25816069964643        1.25806193572697
   1.25796459568833        1.25786876157113        1.25777141108022
   1.25767535965598        1.25758077387210        1.25748463994569
   1.25739079830236        1.25729554930697        1.25720164622747
   1.25710819756682        1.25701605858976        1.25692347394259
   1.25683018730473        1.25673813840580        1.25664764124739
   1.25655568232194        1.25646590957045        1.25637456039960
   1.25628465333834        1.25619501390010        1.25610671609591
   1.25601798055924        1.25592940977575        1.25584038878929
   1.25575372287482        1.25566531925392        1.25557926471252
   1.25549265099483        1.25540514863169        1.25531928208049
  1.995685895545864E-002  2.177115436048020E-002  2.300290209214514E-002
  1.995752452760037E-002  2.078307507895309E-002  2.146892990160294E-002
  2.205261809280136E-002  2.255855981916636E-002  2.300351245878934E-002
  2.339944672528240E-002  2.375520745476195E-002  2.407749911564056E-002
  2.437152220645288E-002  2.464138218499233E-002  2.489038236949494E-002
  2.228104624980776E-002  2.252576433647243E-002  2.275530243398843E-002
  2.297125926318719E-002  2.317500219852179E-002  2.336771039512381E-002
  2.355039937005067E-002  2.372396108187790E-002  2.388917060996332E-002
  2.404671695171613E-002  2.419720684585317E-002  2.434118170323583E-002
  2.447912235478672E-002  2.461146250951741E-002  2.473859061698240E-002
  2.486086108969864E-002  2.497858945253040E-002  2.509206488891356E-002
  2.520155273640586E-002  2.530729259243782E-002  2.540950468719804E-002
  2.550839208988480E-002  2.560413772912871E-002  2.569691582618335E-002
  2.578688358305378E-002  2.587418734876340E-002  2.595896376261524E-002
  2.604133580309966E-002  2.612142357579129E-002  2.619933619748683E-002
  2.627517246562161E-002  2.634903146645627E-002  2.642099916752880E-002
  2.649115890301361E-002  2.655959085154777E-002  2.662636742240088E-002
  2.669155865027930E-002  2.675522647782176E-002  2.681743516138269E-002
  2.687824246184478E-002  2.693770088907943E-002  2.699586198874229E-002
  2.705277656729910E-002  2.710849081507209E-002  2.716304646790258E-002
  2.721648504886174E-002  2.726884802995340E-002  2.732017185152482E-002
  2.737049316448296E-002  2.741984278869695E-002  2.746825609076380E-002
  2.751576281210947E-002  2.756239332753850E-002  2.760817254487828E-002
  2.765313133356722E-002  2.769729111289908E-002  2.774067941528678E-002
  2.778331858057614E-002  2.782523098353073E-002  2.786643909355725E-002
  2.790696033299412E-002  2.794681855112931E-002  2.798602848119329E-002
  2.802461242095615E-002  2.806258361905482E-002  2.809996297827577E-002
  2.813676345445919E-002  2.817300051400407E-002  2.820869217619184E-002
  2.824384858453819E-002  2.827848667350942E-002  2.831261973661382E-002
  2.834625743912410E-002  2.837941527745258E-002  2.841210411724918E-002
  2.844433650594682E-002  2.847612143970584E-002  2.850746963325333E-002
  2.853839459631136E-002  2.856890317623126E-002  2.859900504252637E-002
  2.862871165567237E-002  2.865803206482134E-002  2.868697185859737E-002
  2.871554267799937E-002  2.874375167360712E-002  2.877160679373502E-002
  2.879911573942679E-002  2.882628597437039E-002  2.885312579364016E-002
  2.887964009593732E-002  2.890583568610118E-002  2.893172128843105E-002
  2.895730225268572E-002  2.898258480131658E-002  2.900757497668138E-002
  2.903227971054538E-002  2.905670151659962E-002  2.908084912438056E-002
  2.910472685732692E-002  2.912833995226777E-002  2.915169350198786E-002
  2.917479352581225E-002  2.919764164712888E-002  2.922024575280190E-002
  2.924260934291771E-002  2.926473792958699E-002  2.928663370740600E-002
  2.930830089110210E-002  2.932974679168401E-002  2.935097113860957E-002
  2.937198103724642E-002  2.939277922126769E-002  2.941336939754722E-002
  2.943375518089371E-002  2.945394009700236E-002  2.947392865623725E-002
  2.949372100162508E-002  2.951332362093966E-002  2.953273863975788E-002
  2.955196917861585E-002  2.957101935706504E-002  2.958988893256588E-002
  2.960858402935216E-002  2.962710641380890E-002  2.964545885982910E-002
  2.966364407807475E-002  2.968166579244259E-002  2.969952444375179E-002
  2.971722256294930E-002  2.973476477586837E-002  2.975215242872941E-002
  2.976938896576738E-002  2.978647347525144E-002  2.980341145206689E-002
  2.982020403797854E-002  2.983685448080853E-002  2.985336167332540E-002
  2.986973092710780E-002  2.988596320115929E-002  2.990206048938739E-002
  2.991802474448196E-002  2.993385787901621E-002  2.994956176651188E-002
  2.996513824246977E-002  2.998058910536688E-002  2.999591611762182E-002
  3.001112208669559E-002  3.002620546516391E-002  3.004117223391817E-002
  3.005601969805165E-002  3.007075377625159E-002  3.008537279050318E-002
  3.009987827468215E-002  3.011427389702206E-002  3.012856005275029E-002
  3.014273927285839E-002  3.015680973186510E-002  3.017077715431598E-002
  3.018463857855628E-002  3.019839967967480E-002  3.021205852763926E-002
  3.022561750021731E-002  3.023907786864710E-002  3.025243979711382E-002
  3.026570667930814E-002  3.027887863523409E-002  3.029195793199421E-002
  3.030494247703675E-002  3.031783666543573E-002  3.033064053355579E-002
  3.034335518290589E-002  3.035598278157937E-002  3.036852222215681E-002
  3.038097454954973E-002  3.039334296335082E-002  3.040562738788300E-002
  3.041782881627533E-002  3.042994822496153E-002  3.044198657404309E-002
  3.045394480764269E-002  3.046582385424835E-002  3.047762571459804E-002
  3.048934802425703E-002  3.050099601733808E-002  3.051256729986956E-002
  3.052406272649334E-002  3.053548531495980E-002  3.054683589373614E-002
  3.055811310056308E-002  3.056931882571567E-002  3.058045385839364E-002
  3.059151788613988E-002  3.060251494141889E-002  3.061344141961726E-002
  3.062430133014201E-002  3.063509431326233E-002  3.064582217755441E-002
  3.065648236033778E-002  3.066707882860586E-002  3.067761117852377E-002
  3.068808008599163E-002  3.069848621677480E-002  3.070883022670056E-002
  3.071911276185000E-002  3.072933555004159E-002  3.073949594453477E-002
  3.074959783716733E-002  3.075964183730714E-002  3.076962526982352E-002
  3.077955200131480E-002  3.078942261507976E-002  3.079923440912727E-002
  3.080899231869834E-002  3.081869362511419E-002  3.082833887829120E-002
  3.083793189897172E-002  3.084746994393401E-002  3.085695354023733E-002
  3.086638648739766E-002  3.087576492552672E-002  3.088509373377408E-002
  3.089437013080626E-002  3.090359570205106E-002  3.091276983890293E-002
  3.092189520779807E-002  3.093097228136474E-002  3.093999933725362E-002
  3.094897683470980E-002  3.095790851050115E-002  3.096679043410282E-002
  3.097562742548471E-002  3.098441663628713E-002  3.099315959112932E-002
  3.100185561915273E-002  3.101050732933447E-002  3.101911403995121E-002
  3.102767725449151E-002  3.103619408909388E-002  3.104466932360456E-002
  3.105309896767310E-002  3.106148669599610E-002  3.106983289142617E-002
  3.107813573954309E-002  0.185693632080300       0.195148210789810
  0.201400346186374       0.185697158442746       0.190037537686309
  0.193594372772626       0.196588130842567       0.199159480881945
  0.201403413041125       0.203386850174637       0.205158678747753
  0.206755570472722       0.208205720382171       0.209531198837098
  0.210749653788469       0.197751736606150       0.198993451958266
  0.200153651136967       0.201241294371986       0.202264003738091
  0.203228321367726       0.204139835679039       0.205003448370645
  0.205823380681686       0.206603384280003       0.207346740134794
  0.208056369013717       0.208734847884787       0.209384499909948
  0.210007393949012       0.210605421475120       0.211180246672779
  0.211733397363538       0.212266276643176       0.212780140762039
  0.213276143836918       0.213755350050491       0.214218705412365
  0.214667124398616       0.215101420449632       0.215522351721093
  0.215930627308774       0.216326873611831       0.216711717281454
  0.217085719191360       0.217449378069455       0.217803212399456
  0.218147653524634       0.218483126876101       0.218810046652480
  0.219128778588669       0.219439681350979       0.219743060904238
  0.220039251215499       0.220328544564552       0.220611200704025
  0.220887479783102       0.221157643521955       0.221421924456447
  0.221680526797830       0.221933659095079       0.222181535070862
  0.222424334490563       0.222662243659862       0.222895408141058
  0.223124013159199       0.223348204266728       0.223568135747886
  0.223783923050484       0.223995731252801       0.224203655327371
  0.224407840650778       0.224608395188950       0.224805429868446
  0.224999058879318       0.225189359767884       0.225376462064693
  0.225560426965206       0.225741376178661       0.225919363435722
  0.226094503425686       0.226266851226024       0.226436482971128
  0.226603496055780       0.226767928646408       0.226929872704540
  0.227089393481212       0.227246529593426       0.227401365810890
  0.227553952425387       0.227704353805535       0.227852608082155
  0.227998767649006       0.228142907366018       0.228285051823616
  0.228425248219951       0.228563558369852       0.228700026389029
  0.228834670631584       0.228967556673373       0.229098716353307
  0.229228188336908       0.229356010066993       0.229482217813409
  0.229606854836681       0.229729938969434       0.229851503231304
  0.229971595889016       0.230090239893929       0.230207465394110
  0.230323301651221       0.230437785203246       0.230550919250560
  0.230662754978334       0.230773310293812       0.230882610500088
  0.230990680193511       0.231097551428044       0.231203223044895
  0.231307742085104       0.231411122422446       0.231513393624276
  0.231614560254874       0.231714642612265       0.231813684910246
  0.231911673812266       0.232008652526089       0.232104631183157
  0.232199627599826       0.232293659143474       0.232386742747078
  0.232478903081329       0.232570131777535       0.232660469021642
  0.232749921985565       0.232838505629681       0.232926242720173
  0.233013123020264       0.233099184940495       0.233184433909323
  0.233268883202798       0.233352545790096       0.233435442513083
  0.233517569414476       0.233598938593328       0.233679578223415
  0.233759491698850       0.233838698503833       0.233917185171727
  0.233994987045833       0.234072106532547       0.234148562163898
  0.234224339533160       0.234299473091814       0.234373964364710
  0.234447822851217       0.234521057851714       0.234593678472959
  0.234665693633299       0.234737112067693       0.234807942332582
  0.234878192810596       0.234947879903377       0.235016987094655
  0.235085555026980       0.235153558674219       0.235221038376116
  0.235287976991566       0.235354381804111       0.235420276343069
  0.235485659423373       0.235550546112599       0.235614918568107
  0.235678816184770       0.235742212668835       0.235805147174501
  0.235867601360752       0.235929589558257       0.235991117787868
  0.236052183760103       0.236112809677367       0.236172993038002
  0.236232747638987       0.236292054369475       0.236350943231969
  0.236409411325717       0.236467463858336       0.236525114150845
  0.236582350821143       0.236639178807166       0.236695619374437
  0.236751669088440       0.236807332638420       0.236862614633839
  0.236917519606127       0.236972052010390       0.237026216227073
  0.237080024773663       0.237133457255807       0.237186550680844
  0.237239284514539       0.237291662785973       0.237343705883719
  0.237395417709956       0.237446785677062       0.237497821773905
  0.237548529716555       0.237598904947239       0.237648975709618
  0.237698712686136       0.237748144009662       0.237797264897669
  0.237846086946605       0.237894588832786       0.237942798483265
  0.237990710907026       0.238038329280884       0.238085656733473
  0.238132696346190       0.238179451154116       0.238225932367132
  0.238272118269728       0.238318036423992       0.238363689689673
  0.238409056219295       0.238454163452275       0.238499014124630
  0.238543586264216       0.238587915417870       0.238631979535214
  0.238675781195766       0.238719347614927       0.238762656628707
  0.238805710708253       0.238848536965639       0.238891104903760
  0.238933449793847       0.238975549295847       0.239017413939626
  0.239059037770831       0.239100439484169       0.239141621291213
  0.239182568917805       0.239223284513940       0.239263794885779
  0.239304069213595       0.239344142476831       0.239383992027016
  0.239423628103397       0.239463044460009       0.239502259514039
  0.239541266967897       0.239580076959001       0.239618666677025
  0.239657070902778       0.239695258545083       0.239733256107460
  0.239771065377186       0.239808671653993       0.272781742544511
  0.271970967003571       0.271252841601382       0.272781565342448
  0.272478946798018       0.272137050321145       0.271810925505433
  0.271515474220994       0.271252480917569       0.271019530985467
  0.270813063099977       0.270629522511881       0.270465697728265
  0.270318808587378       0.270186506692013       0.271678425742497
  0.271534806539347       0.271399258054886       0.271271545524439
  0.271151304966950       0.271038105184688       0.270931501920720
  0.270831051191468       0.270736320035814       0.270646884625835
  0.270562373097715       0.270482423606038       0.270406705919105
  0.270334919804199       0.270266777543498       0.270202026479193
  0.270140427484586       0.270081772783004       0.270025860246054
  0.269972512190962       0.269921553860621       0.269872835772650
  0.269826213110272       0.269781567344615       0.269738763223291
  0.269697705525920       0.269658280447327       0.269620393625397
  0.269583968674528       0.269548912982881       0.269515155090076
  0.269482624695203       0.269451256739305       0.269420986758363
  0.269391769152969       0.269363539952517       0.269336257097933
  0.269309863470696       0.269284326701353       0.269259602554348
  0.269235653076160       0.269212446174277       0.269189940908705
  0.269168109341235       0.269146921824695       0.269126350339458
  0.269106364786402       0.269086951046096       0.269068074747312
  0.269049717337597       0.269031854069158       0.269014475729791
  0.268997549153582       0.268981070757222       0.268965009214525
  0.268949362706607       0.268934105191605       0.268919222163153
  0.268904706812410       0.268890542398555       0.268876719977452
  0.268863220440224       0.268850036031759       0.268837155737163
  0.268824565833585       0.268812266712903       0.268800235096186
  0.268788472354864       0.268776969718745       0.268765708651981
  0.268754694960780       0.268743910682396       0.268733352089557
  0.268723008672564       0.268712884087971       0.268702958139308
  0.268693235028835       0.268683708826371       0.268674366909476
  0.268665203915740       0.268656221425363       0.268647414317427
  0.268638767509977       0.268630290032218       0.268621967083079
  0.268613794362514       0.268605774479794       0.268597903395048
  0.268590167062978       0.268582575249147       0.268575114241246
  0.268567780558215       0.268560580899423       0.268553498548237
  0.268546543838029       0.268539703628014       0.268532978324383
  0.268526365163528       0.268519861323943       0.268513464174215
  0.268507167795841       0.268500976398346       0.268494887540132
  0.268488892272436       0.268482991607561       0.268477180044466
  0.268471462108311       0.268465835779970       0.268460292401476
  0.268454829975410       0.268449456688904       0.268444160677149
  0.268438940200988       0.268433800180362       0.268428738940648
  0.268423748233925       0.268418829780210       0.268413982115480
  0.268409203688793       0.268404493077313       0.268399845576749
  0.268395269699973       0.268390754281730       0.268386297973125
  0.268381906126861       0.268377574223405       0.268373301071464
  0.268369085491134       0.268364929677085       0.268360825959542
  0.268356773233009       0.268352780313408       0.268348833047969
  0.268344940337866       0.268341097880324       0.268337304752616
  0.268333563286138       0.268329862834668       0.268326215540089
  0.268322610766952       0.268319047688558       0.268315535279494
  0.268312062961102       0.268308629964978       0.268305245307399
  0.268301895225864       0.268298592019061       0.268295321953761
  0.268292097401975       0.268288907869899       0.268285752776551
  0.268282637904788       0.268279562675766       0.268276516747940
  0.268273512457253       0.268270539511135       0.268267597324787
  0.268264695099888       0.268261819276528       0.268258982325156
  0.268256170721554       0.268253393700632       0.268250650739798
  0.268247931662084       0.268245248914262       0.268242589087284
  0.268239964637114       0.268237365423154       0.268234794275294
  0.268232250713324       0.268229734329029       0.268227244707052
  0.268224781425094       0.268222340901081       0.268219932386466
  0.268217542613751       0.268215184072011       0.268212846758352
  0.268210533523757       0.268208240807789       0.268205977884152
  0.268203734792383       0.268201514391258       0.268199316397410
  0.268197140431889       0.268194986223438       0.268192850264358
  0.268190738621570       0.268188650994616       0.268186577530701
  0.268184530712882       0.268182497480903       0.268180487155448
  0.268178496229884       0.268176524493530       0.268174574832828
  0.268172640626363       0.268170724798771       0.268168827143278
  0.268166947376479       0.268165082089598       0.268163237416656
  0.268161413124347       0.268159602622084       0.268157805690561
  0.268156031637381       0.268154270747785       0.268152522774738
  0.268150797041275       0.268149083851715       0.268147382970113
  0.268145703721241       0.268144033255666       0.268142384022371
  0.268140743185671       0.268139123243579       0.268137511299102
  0.268135919886264       0.268134339324774       0.268132772573885
  0.268131219512790       0.268129676762296       0.268128150523094
  0.268126640618931       0.268125137416589       0.268123650222027
  0.268122175719433       0.268120716939570       0.268119267415089
  0.268117826966734       0.268116404967464       0.268114991757841
  0.268113587235058       0.268112200713035       0.268110822604055
  0.268109455906118       0.268108100499025       0.268106756241934
  0.268105419891244       0.268104097576437       0.268102789215892
  0.268101485210153       0.268100198029759       0.268098918136578
   67.7329901571050        75.8185959181902        665.182572850822
   115.869434091927        160.474181027104        1097.60845421896
   185.087281132147        201.180482264731        662.042826436802
   244.094685964488        1032.11296678146        1405.64706946553
   1568.74091061950        1570.42610797630        325.762297411258
   942.246985030232        913.888756757840        380.322661044247
   932.450578501054        1456.48228150973        393.327320551373
   1208.22198352078        431.984301710938        1423.00601067542
   450.397526670683        1418.60951506139        1575.31030014282
   1661.60986125894        1578.72127037594        593.451575015394
   1557.89334730101        540.437791767525        550.187460904607
   574.136219618147        577.996930476474        587.604265609717
   599.141826804382        736.540754818391        608.014526076899
   617.476754844676        2064.71679871272        645.579348029656
   648.399841665227        660.014401741465        842.565263209839
   868.914260264792        904.254418931116        2164.06941927571
   877.577090938868        894.147000191452        758.054933402812
   962.515379751506        2360.89204853276        959.257505790396
   976.676610822792        1105.98077404774        1019.13384110420
   1019.02602855263        857.749564606297        878.375848692263
   862.753445598153        913.571887336457        922.536285300584
   1090.16228442131        918.408154951307        1112.03312696188
   940.485862650182        951.671203381407        1139.08658802296
   975.547408260313        984.619582764978        1004.07731621232
   2978.01461118769        1014.44563733305        1030.90979621815
   1047.59605870857        1051.38603904683        1046.08358750619
   1054.88610192596        1340.88662177640        1385.73377455442
   1433.70327496086        2789.05749299599        1398.01829385113
   1400.08689447013        1157.60158582894        1418.89898960785
   1185.77122425342        1192.86632657964        1227.65464317587
   1221.09634456603        1258.77882024325        1559.21820969156
   1608.45549274736        1601.23870313912        1630.26809198997
   1630.26985174964        1659.97502977156        854.080570923614
   1706.50933891242      -0.130185471214501        82.0498419323812
  -1.03865527039585        69.5432733613805        32.2189358819872
  -1.08446730998720        85.2513898382939        589.920264839048
 -0.866781115105599        155.301520842655      -0.748750546576173
 -0.954524174123868      -0.960170006610870       -1.00311861630991
   38.8949011382710      -0.751425125053170      -0.651998794070653
   26.7430876450646      -0.563531075854446      -0.943273471681448
   20.2808332216394      -0.713322503731803        20.5774256422459
 -0.832243422064763        45.6459555230136      -0.757720956452089
 -0.827635900509698      -0.915303649236434      -0.785401570320002
   39.1735667852763      -0.684986320792960        44.7268924106343
   43.4133241843749        13.6425064596990        13.7062770347847
   38.6419031414253        13.8152866402807        24.4928147078077
   36.2334325846038        35.5641473799184      -0.786268577590054
   14.0641210622149        13.6817579085061        12.5204255472278
   26.0376262180393        26.2444330184680        67.8704674018086
 -0.701309955980143        19.9568638468402        18.2492042659512
   13.4070519380001        13.8576360225394      -0.693780376099139
   14.1561834501077        12.7577637605657        137.692410115846
   12.7436162929327        12.8471364564147        33.8707664227871
   14.6719071215938        19.0830354357760        34.7730281271450
   12.4364792951429        14.6353400564036        14.4775896126756
   15.1852341018403        37.2917561400758        13.0474758270438
   15.7980827311535        12.3907342196970        12.2619572804764
   12.3011774816685      -0.664201942021106        42.3165606445522
   11.6493054915886        11.5780842678644        11.2132796034755
   10.1232487537406        31.1954592092284        13.7204628607811
   15.7550505147410        17.2115836011293      -0.575987813877370
   15.5554116646713        15.2039559527080        12.2054188539429
   12.7490582684386        11.6073556458973        11.6702752838360
   12.0072693397109        11.9545435694687        13.1104486087288
   6.98626607828786        5.58453704278612        5.77330562755682
   5.02505000967392        5.02506737416108        4.27968220164206
   18.6474053148371        3.21165967713564      -0.429953657644099
   20.6855791766191      -0.717969219726807        6.78049703941272
   9.35520688994885       0.728808672136311        13.8952811596836
   34.5361277725552      -0.833830129243419        19.4849989792895
 -0.600599348487693       0.687357755229946      -0.688254138130586
 -0.721209836794927        9.19993649175603       0.748163797131075
 -0.702715424028785       -7.20987803488949       0.637136661794896
 -0.752686200971265        5.86219371816205      -0.724661287530780
   5.95857497279935       0.778818143046712        8.59093284928841
 -0.734075563871811       0.763772858760134       0.818633928037552
  0.749927855737226        11.8282035112330       0.690742387460465
   8.38152532084861        8.22809672204246        4.76215997628856
   4.76613296085012        7.68229260681019        4.72367940027844
   10.2725568984350        7.39332019538979        7.31015946342246
  0.740691099121688        4.75363423824256        4.66990820147272
   4.39898676845254        12.0240956008849        12.6273197038833
   24.8552417497111      -0.701866598890901        9.00351980398225
   8.55189394521363        4.63942905018503        8.00844676587766
 -0.689019527908062        7.39572168117921        7.25009773439900
   42.4060129342340        7.58714059113161        7.28350711959655
   7.50904163157153        5.06228621607496        5.59582729721060
   7.77995129070978        4.74858385514185        7.59558530756835
   4.86691566791234        7.66901142536209        7.64377465945414
   4.61521680258704       -7.74978877418055        4.49956832755414
   4.48391237069158        4.52364361113207       0.664895459830414
   8.09023469886606        4.37371885617621        4.35501486641223
   4.25773636043296        3.95127277093269        6.76929108087507
   8.62190019376292        10.3134217306707       -12.5822173351067
  0.682464359263113        10.0014233474378       -9.75178413371484
   4.35136471128321        7.48564375300070        4.34202468123414
  -4.37080016532772        4.51614683927094        4.49186953033173
  -4.72581902327362        7.48765797733824        7.25268260835427
   7.27976118719583        7.17841533816674        7.17849405320447
   7.06117136305611        2.77366511498159        6.95092563236516
   162.553921566724        195.418307565019       -6.00130379892909
  -43.0188827876788        197.052628711985       -4.04937730764168
   111.856465340286        801.999672496536        117.202452135629
   37.6720350741586       -1.30947847621951       -3.32577185927466
  -3.50711526072291       -2.98082130355943        4052.68587909283
   869.129291422670        24.7773890695073        13065.3522514445
   95.1647382709331        93.1028176731605        463.494934357538
   7.75857039045726        698.409629612660        5.22566311710325
  -61.5156164833308        42.7088127207074       -25.0079960050309
  -8.35639663094240        31.6704270423812        4.14726658800307
   44.2575406789008       -72.2452873677243       -73.1800948044479
   887.362006230175        984.266461906330       -75.1789399824850
   1696.71606875237        4.88137271263817       -75.2278742891984
  -76.5718315473945       -44.8257033160945        1409.42309346682
   1969.22163700593        2915.29021499002        5.56686672234588
   5.72283516514152        6.87065481825032        2.29365125985335
   4.50773490383628        4.55759501959422        3410.03975312034
   7.49195091608922       -41.9695160127477        5.80549497617779
   7.24801956277299        16.8309992225084        7.85160880757816
   6.33957624988680       -126.429300819666       -72000.8541287100
  -56.3681365523469       -103.339471934831        2606.87997269383
   5.19695819016656        1598.70169513283        4.65426208518786
  -105.546789368186        2019.74785729127        4.07126444366289
   3564.59343129981        4168.98697045531        1260.28612647291
  -14.7895313941701       -101.324729149212        3685.58396440766
   1532.00412708613        747.338978116175        4402.61428093370
  -72.4609598016362        4.55544986840982        5.84257257123679
   8.19543074043737       0.915663918094231        5.53611081654923
   5.44199275643736        2692.39450713957        4.13072258174985
   1101.02961724373        962.576555025957        543.737360375725
   814.714921526147        3393.43148540985        11.9644409746508
   14.0858924831709        13.7802589901800        15.0178506552208
   15.0178863764060        16.2762038056774       -4.86921394023521
   18.2099802445748       -5.67901926650714       -4.97155665843574
   3.09190769426196       -3.19958677767614       -8.62812618112795
   2.81397728962948        7.60207016685699       -11.0270226314512
   9.55634363270122        5.73932258868365        1.98232474609784
   2.68265986170219       -2.65739805014587       -2.73220976476402
  -28.2173845511261        17.2204831792290        6.78808964594402
   42.2551863957267        11.6944040282775       -13.3980664774771
  -15.6560425168144        5.84869675424636       -18.2184674074461
   7.81604875903698       -7.06727318917924        10.9592332500335
  -10.6705209701391        9.11690361264305        11.8734947545762
   2.71691973185975        13.3297510364404        6.72457518488130
   6.74579511510728        18.2189721449425        18.9135040688507
   6.82972367899174        22.7705120678839        2.68503783282703
   6.86048168970714        6.89775753871355        12.1166892565746
   23.2278112691698        24.8246617457993        26.2574170817975
  -2.67572816525882       -2.66581185105223       -2.70373507159306
   5.57540384771646       -2.68792301858895       -2.70644923723912
  -29.8814970397812       -3.02848347927886        13.3966746890656
  -2.94109070965943       -3.07827598708370       -3.41264557994766
   3.09562021969419       -3.04950942141777       -8.22468705294798
  -196.295251359907        9.67374428121576       -7.65879268410552
  -29.4840534266906       -2.84311512250433       -32.9998372393940
   2.76688893721196       -7.37574934538902       -26.8584520528795
  -2.67266820977226       -29.1349194077684       -30.0710172107269
  -22.7851470356644        9.08184197213474        7.09789164451231
  -28.3963609336565       -25.6067157071597       -21.4630906235332
  -29.6257034545388        6.06923713131390       -2.55932890091005
  -2.65863293986076        2.83614994899265        2.33154888117122
  -2.60947558564611       -2.60752480946929       -28.2214077297034
  -2.58913609915951       -25.4777975507908       -24.9249318276573
  -23.0402176810423       -25.2605810963786        33.5331771798398
  -3.10158834269080       -3.19237625858075        3.18039918363604
  -3.22585323551510       -3.22585390540105       -3.26818978370647
  -1.53577562784641        3.32289119425470       2.245000000000000E-002
  0.201000000000000       0.000000000000000E+000  1.680000000000000E-002
  8.000000000000000E-003  4.439099999999999E-002  2.312900000000000E-002
  6.049000000000000E-002  4.000000000000000E-003  1.630000000000000E-002
  1.000000000000000E-003  2.008070620517118E-002  2.000000000000000E-002
  1.978832714156626E-002  0.000000000000000E+000  1.927298413644493E-002
  1.000000000000000E-003  3.000000000000000E-003  0.000000000000000E+000
  1.734465313652002E-002  0.000000000000000E+000  2.000000000000000E-003
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  3.000000000000000E-003  0.000000000000000E+000  3.000000000000000E-003
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  3.000000000000000E-003  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  7.695933752943111E-003  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  1.000000000000000E-003  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  1.000000000000000E-003
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  7.382716607354267E-003  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  7.078964802252524E-003  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000
  1.843629105080054E-002  3.798362174350185E-002  1.200000000000000E-002
  1.317237308749320E-002  1.200000000000000E-002  1.489470235587796E-002
  1.233497727675813E-002  1.285543263010093E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.368160168175772E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.391032167319767E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.666778258987562E-002  1.625554909288714E-002
  1.591668689780140E-002  1.200000000000000E-002  1.200000000000000E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  1.259436108092836E-002  1.362718334436635E-002  1.778398168473416E-002
  2.307196187658076E-002  1.470555429400495E-002  1.978291810147374E-002
  2.303424289043007E-002  2.713696277122805E-002  2.370696576764288E-002
  2.164259802862675E-002  2.132007848646355E-002  1.978771559425813E-002
  2.073806735614954E-002  2.056534279880984E-002  1.775862097415827E-002
  1.785400400775197E-002  1.959970116366359E-002  1.650073245313672E-002
  2.107700538357553E-002  1.835473756101359E-002  1.543787547468385E-002
  1.724863324015160E-002  1.692430995960952E-002  1.755671279453666E-002
  1.200000000000000E-002  1.200000000000000E-002  1.200000000000000E-002
  2.007235040916432E-002  2.072207446568267E-002  2.010940570438069E-002
  1.200000000000000E-002  1.492592521640383E-002  1.220927458918939E-002
  3.030042938732257E-002  1.200000000000000E-002  1.252005942892061E-002
  1.300979318155476E-002  2.147005089376972E-002  1.781978221772817E-002
  2.108672242341920E-002  2.102048754147479E-002  2.069439477421361E-002
  2.076209486579146E-002  2.056757011557935E-002  2.929859594265454E-002
  2.922286117991111E-002  2.923561467185242E-002  2.919389360585583E-002
  2.919389793352542E-002  2.914379021696404E-002  2.882592831548406E-002
  2.909072235241390E-002   207.345459040867        126.808280041395
   526.470864406831        543.065681609426        603.719154986680
   580.334741859072        696.316864683526        776.755137757670
   969.796628551507        912.202905751388        912.786378395824
   981.811522525053        1092.33343806190        1099.11660651185
   1154.54797334818        1234.78351778426        1068.29473358366
   1156.75963080538        1131.69959376039        1323.52540818226
   1228.74568515311        1198.19046544764        1320.01828353207
   1342.48720623605        1383.43373999434        1471.47779354518
   1266.34812511062        1363.68747920602        1571.70950880039
   1553.88188633079        1562.27531776339        1587.57813717509
   1595.91310151113        1590.31885903007        1591.86046896170
   1622.19667925242        1608.84614221570        1646.95492891532
   1635.96390477803        1643.35354137409        1652.39491217141
   1687.41304335673        1690.08039821329        1713.82643510765
   1763.60332192770        1770.00971335083        1736.93860815780
   1991.70598079751        1904.48045528270        1911.40923353429
   1935.81816123317        1969.67219324250        1989.07514423817
   2010.16883693306        2033.98963352068        2143.00441959709
   2094.71306301427        2086.41449436166        2124.68378932364
   2150.17430216698        2196.08834463275        2190.66866262454
   2214.02865763938        2262.87506241305        2315.09167107339
   2318.22119681943        2351.76137989558        2388.03116624500
   2389.10313268487        2438.70305328634        2456.24497323331
   2485.54175169601        2479.06308214315        2674.11887587923
   2563.60778316744        2520.16179511420        2511.08546150002
   2499.19198753996        2574.94398080211        2507.98023006946
   2536.03617948725        2604.43836472137        2634.11753992464
   2578.22928988771        2588.60097259082        2784.71360977614
   2756.75851995573        2834.16561736765        2846.91682683695
   2911.14043888759        2898.65258169405        2977.81682918408
   3060.40247075345        3187.33703516505        3169.28837146778
   3241.79146198004        3241.79092138789        3314.26928832939
   3321.91967255706        3423.79158731440
   222.416603317021        194.030007867155        581.662635062325
   1067.36025821244        1173.99748073334        1062.14901959531
   826.325819610748        1316.56722725267        1137.82747289107
   1021.15512190847        1407.07409257103        1809.65973463832
   1815.96748881437        2169.81164175290        1646.21617448126
   1538.04881927315        1280.71318447704        899.978637200776
   1168.29211125935        593.351232344279        1263.76573377770
   1406.35274018452        1575.10588631105        1795.96381695763
   2027.05504271969        2340.85988788457        1978.93445996465
   2219.93905308457        1218.40588197166        1103.00116798552
   1198.16788666346        1208.50288953484        1218.01867271803
   1242.30595469648        1248.33450328724        1276.98780457877
   1293.28687670057        1312.51257985226        1326.48657075119
   1275.86348685019        1389.32558430914        1437.80435107687
   1458.34914039334        1539.01784508312        1581.33205366074
   1670.51116719197        1710.84880332497        1855.60284334712
   1944.71610335745        2035.77858434662        2103.83990050168
   2276.18719029762        2254.90517986174        2644.03077488165
   2336.66086239326        2580.28695606946        2822.26206882924
   2843.57469861163        2858.15971085891        3024.53181143196
   3038.07997451754        2979.28353875037        3210.59147868259
   3286.80272375129        3519.98020784630        3409.25936356733
   2823.52762997858        3700.58144072165        3405.63504081882
   3667.24913747850        3460.77471530776        3613.16407515940
   4496.99856368775        3698.52611972311        3301.17023155766
   3058.59217976990        2486.95908628268        2537.23400604408
   1445.30087388715        2469.60418876377        2951.55400621892
   3352.94874929349        3591.09133549443        3591.25570879776
   3290.90207334628        5006.49879955135        5826.57450445285
   6366.88220241843        6550.93715855354        7501.83776656631
   7306.62735218817        8709.39153762045        8512.22503573930
   9998.46225390475        9773.09517878987        10660.7846651822
   10663.7819462762        11579.3933564789        12286.4461515460
   13002.7660459598       -1.23772454516813        3.06386167943644
  -1.26477457994377       -3.32512037103658       -3.30277963587130
  -1.94168703541120      -0.769813503196809       -2.06422046483010
  -2.21798777441006       0.656875414192024       -2.04550664809691
  -2.95235881189203       -3.23682497087142       -4.01531026642102
  -2.52552407483116       -2.09864753844885      -0.797140135883153
   2.64436861978816      -0.170561289688515        7.62678973394863
  0.693221204769310       0.486796948771578      -0.240425965912123
  -1.12023202721432       -1.34631871146980       -1.65927392623540
  -1.40588496468785       -1.74201621305859        1.66885129476492
   4.59136057753833        3.20008572931974        3.26879577289976
   3.30623795728855        3.31445773958171        3.31019365484880
   3.26508555270857        3.20518541449486        3.15412358281285
   3.10410672753140        3.42085659003782        2.78750000290205
   2.82953360428688        2.81490862015163        2.78963966611297
   2.74356825019647        2.61283030795422        2.54234832264456
   2.25700279232960        2.06325116301646        2.51043272191803
   1.40838197605061       0.833278576207242       0.899894477608372
 -0.451734805784948       0.778122873822093      -2.988517607523618E-003
 -0.753847602695252      -0.774585514494653      -0.789497917200668
  -1.15017822380519       -1.16243406742636      -0.806121038781837
  -1.37044527697596       -1.37717078446355       -1.70718958474081
  -1.59507675193112       8.024753165083813E-002  -2.10577199492120
  -1.40299696280735       -1.84963651654540       -1.32461770328922
  -1.53034495528611       -2.62568288524056       -1.60599407997023
 -0.870120678134128      -0.556135836236043        1.29052683236957
  0.787679789570852        7.57971274195160        1.53958041812355
  0.199553324605204      -0.643074441195629       -1.03736175788442
  -1.03744883725864      -0.161076583360367       -2.33269866148222
  -3.25301387968462       -3.55721457976068       -3.64950383600555
  -4.05514439751972       -3.98074363695051       -4.44191123705286
  -4.38751742146024       -4.74984755504668       -4.70074041160041
  -4.87825522548623       -4.87948502348079       -5.03176372310760
  -5.13295427458729       -5.22447656122274       0.621598543733159
  -12.4839980453756      -0.412277728073746        7.04082879663345
   6.26516661785970        1.03135774666432       -2.62193996672898
   1.47040150816820        3.59153849872157       -8.62652524873010
   2.48839973293238        5.75627481235640        6.67876097604667
   9.37066710164659        4.26167983004657        2.89685394534211
  -1.08849630472299       -12.1664776727881       -2.21796292742692
  -28.7251122334231       -6.16054027983151       -5.98273215436767
  -3.04248418786718       8.552399357955441E-002  0.469774773143334
  0.898364263381963        1.21260109558540        1.01277812230391
  -9.69824071558264       -19.5371546957055       -14.1558674374933
  -14.1971670875248       -14.1729315426278       -13.9689438269648
  -13.9034673773315       -13.5411508429653       -13.2463353214890
  -12.9760031386748       -12.7514046573068       -13.7211906147358
  -11.4308490634108       -11.6623072369216       -11.6472873339738
  -11.6957275504611       -11.6151332739583       -11.3090893472718
  -11.1289246836688       -10.3515189374691       -9.79889275077505
  -12.0115875391719       -7.55461607804986       -5.65162476053135
  -5.87247105787351       -1.14968291952994       -5.57541210072413
  -2.90532455769516      -0.230235122536160      -0.187156095822191
 -0.155936844352131        1.07025280561793        1.09483028874712
 -0.343076900272498        1.67401766721613        1.55806781909755
   2.71038097600802        2.53190332142046       -3.61624112176552
   4.30877965334910        1.63950611941747        3.14942425652900
   1.12156515231340        1.72783130551112        5.16995897027034
   2.13487670184023      -0.255129782620519      -0.777816931222458
  -7.09498595835517       -4.76931552957600       -28.0077401814477
  -7.39407257915214       -2.68495299629862       0.273188749243716
   1.63080912631324        1.63102134586732       -1.45366805048034
   6.03337452272000        9.27362818553268        10.3043785417104
   10.6164684868201        11.9850506947508        11.7362298355561
   13.2756793105961        13.0942030930896        14.2921501182219
   14.1302487874371        14.7124661335434        14.7167435214552
   15.2115499148452        15.5362595998898        15.8328463372402
 -0.491520349825810        16.4101387176199        2.30540587126529
  -8.21097336843830       -6.52691350906175        1.45291499601356
   6.27184973503466       0.810533638526066       -3.73224263433007
   15.7343054207833       -1.73719297580736       -6.55586035646889
  -7.59568407903777       -11.4194247245824       -4.04842646647485
  -2.20681937852305        2.95222506717529        18.0084113648689
   3.37035279230307        41.5659550044541        10.1272483238909
   10.5666508786142        5.75399373166938        1.13083909864566
   1.01801812035805        1.13719671452332      -0.473193454462162
   1.32819356373240        16.1328368180362        29.4416652779339
   21.2166975327088        21.1290267786743        20.9758579249137
   20.5136319642407        20.3827716045483        19.7103768777391
   19.2194578038427        18.7673003180851        18.4073867486280
   20.1306874718062        16.3093410180271        16.6659270781706
   16.6584031488612        16.7766211963344        16.7032214943771
   16.3402132267041        16.1174136396014        15.1278767634304
   14.4101980238272        18.2998611461637        11.3722680253932
   8.81842195395070        9.11544642669664        2.23855138965914
   8.93851715736504        5.14299371528491        1.15112957508743
   1.13847961252007        1.12916280418522      -0.602145785050374
 -0.608502201304532        1.81586662632146       -1.21132168088927
 -0.820431597772678       -2.60233924774031       -2.54833958480317
   6.95678981605543       -5.13079901578869      -0.892432028019230
  -3.04153323754871       0.223251833821613      -0.519848430603934
  -5.18486926324859       -1.25057584728824        2.13377230864300
   2.29144911957043        11.6123907160319        7.51193546688740
   41.8397440936302        11.4704279967990        4.38395185342740
 -7.239653462617071E-002  -2.07774343957153       -2.07798220203689
   2.56181501842837       -8.56492613290864       -13.4340992265649
  -14.9468796410426       -15.4043301500021       -17.4087166986002
  -17.0468619470964       -19.2848551145744       -19.0197958191801
  -20.7530159649166       -20.5189117383209       -21.3556591469591
  -21.3620185018360       -22.0694648517084       -22.5289293159363
  -22.9538365276803       0.757527909420183       -9.44944521838354
  -1.78025280416351        4.84651305169607        3.52025389537239
  -1.90653114157260       -4.81455356944119       -1.47184948710073
   2.15807563429797       -11.3386631480622       0.710688670941776
   3.90936234850923        4.43078480603660        6.91395273894781
   2.02483279985699       0.880885949868907       -2.19418413553600
  -11.6192943299188       -1.79108973163566       -27.1508718888352
  -6.83016401181417       -7.54594384977733       -4.02129760183142
 -0.906681456352114       -1.07434956850477       -1.55984173768131
  6.285950630655962E-002  -1.82979624101538       -11.3298138988101
  -19.6016889446349       -13.9245043792815       -13.8171779802291
  -13.6747930262736       -13.3187512264195       -13.2215927165866
  -12.7330314932982       -12.3886461696147       -12.0759598905353
  -11.8291603994715       -13.3369003585255       -10.3830322804332
  -10.6140550442188       -10.6110631429024       -10.6906863294816
  -10.6543778608199       -10.4362905828696       -10.3005860176488
  -9.69273530985470       -9.24782603602960       -12.2123000117892
  -7.39944992354049       -5.84200432920899       -6.02357834046790
  -1.44259661788375       -6.07281564193326       -3.60101820687928
 -0.878431812156330      -0.901273031147632      -0.918088128208956
  0.202760080124789       0.188808110728448       -1.63352657715630
  0.442701772959540       4.717772207773797E-002   1.31513834181785
   1.40197085805673       -5.27753295420337        3.12791052606502
  8.948919310603415E-002   1.50147373597199      -0.861878402262922
 -0.441135025606639        2.47839520968395       0.102238338135743
  -2.11034194306033       -1.86774264699318       -8.18157200384718
  -5.02160436293244       -28.1909902463170       -7.82728452941452
  -3.01149316934107       2.794076964118403E-002   1.36723593680843
   1.36733478577486       -1.85838101792182        5.65699044363242
   9.03031334713575        10.0432667322759        10.3493484017418
   11.6907428064495        11.4499242004394        12.9402561014644
   12.7627010987485        13.9146047555016        13.7585821867031
   14.3118291759944        14.3162536136396        14.7825813807538
   15.0828125527272        15.3640833850756      -0.331263040553284
   2.03744964745919       0.438864926175240       -1.12607301612396
 -0.761687437288881       0.608857353791649        1.27013170069034
  0.496760931263345      -0.504869454755113        2.92810950514188
 -0.133888298473656      -0.926067737968114       -1.02794940252289
  -1.63737227079082      -0.411637481045171      -0.142315567754252
  0.552530250554967        2.78940002799529       0.307557297696647
   6.67599245759464        1.68170991048224        1.95654473598756
   1.00090845072453       0.212346728667741       0.304990049729217
  0.511734178538956       1.938366288244370E-003  0.590602203790280
   2.89826913058730        4.86351336190421        3.39298237512705
   3.36068527121544        3.32019122651811        3.22731311148153
   3.20229372205892        3.07720181654110        2.98973002608862
   2.91206089880305        2.85037171517896        3.33309390330137
   2.48606722872967        2.54114884648464        2.54032388347555
   2.55807339082178        2.55043150410313        2.49846770320728
   2.46609922362613        2.32143562123649        2.21503686725283
   3.04150882703865        1.79288206665071        1.43438501786484
   1.47628625643854       0.326151763691070        1.52606942993845
  0.917821731303788       0.219863609006095       0.232453364978580
  0.241806925601985      -3.272488112968032E-002 -2.524452024736238E-002
  0.477872719583811      -5.696089741532916E-002  7.149848950467189E-002
 -0.265689714470930      -0.317061590485158        1.43539402222875
 -0.753510951145285       5.569883463988144E-002 -0.296288482270673
  0.337304057689721       0.246165357642990      -0.444681619815064
  0.101607892884234       0.646797508194861       0.507203416209330
   2.11314477705417        1.22365761621435        7.07289250085264
   1.98082764027056       0.766599073354097      -3.779711371840801E-003
 -0.335902837893040      -0.335908778608166       0.510582309852459
  -1.38049615514363       -2.26129602917194       -2.51459353969880
  -2.59110247339935       -2.92664124610984       -2.86667898181199
  -3.23820353543287       -3.19368652810461       -3.48069448760429
  -3.44161428220817       -3.57891005116188       -3.58008219734881
  -3.69557662441363       -3.76936165687869       -3.83938492095079
  2.245000000000000E-002  0.184000000000000       4.995456808291191E-003
  1.700000000000000E-002  2.200000000000000E-002  8.000000000000000E-002
  4.000000000000000E-002  8.000000000000000E-002  1.071388187345269E-002
  4.200000000000000E-002  4.000000000000000E-002  5.000000000000000E-002
  5.000000000000000E-002  4.000000000000000E-002  3.954393247688096E-002
  3.834360119586522E-002  3.505770321755805E-002  3.152542951603161E-002
  3.213249785003090E-002  2.629679961095212E-002  3.784581327835196E-002
  4.000000000000000E-002  4.460073469802006E-002  4.680084097329058E-002
  5.324945396240532E-002  6.000000000000000E-002  5.000000000000000E-002
  6.500000000000000E-002  3.789606515127635E-002  3.942183973854008E-002
  4.153622276903409E-002  4.304563483080672E-002  4.422716344734613E-002
  4.631418488436640E-002  4.678225205483591E-002  4.876414745464152E-002
  4.960894072651007E-002  5.069449076882333E-002  5.134436530260107E-002
  5.174584585002585E-002  5.269957342504428E-002  5.453232790405289E-002
  5.515804916715826E-002  5.772374660951764E-002  5.886071994143913E-002
  6.104476060183125E-002  6.193730479194276E-002  6.477070798830334E-002
  6.626482578087686E-002  6.999999999999999E-002  6.963025748668962E-002
  7.158306194131865E-002  7.134440689671144E-002  7.278354010221125E-002
  7.330773588439302E-002  7.473116582992502E-002  7.523453213187041E-002
  7.561862389812245E-002  7.586982245006768E-002  7.692138687576607E-002
  7.712956261514614E-002  7.882115760397239E-002  7.931310773387135E-002
  8.092440801189553E-002  8.000000000000000E-002  8.225433454407435E-002
  8.368285100632117E-002  8.503540404339392E-002  8.600764989096830E-002
  8.839769980232332E-002  8.952512626205164E-002  9.158802953652141E-002
  9.499999999999999E-002  9.247825870525096E-002  9.210420061901224E-002
  9.148278586701411E-002  9.118054807133953E-002  9.075325202013876E-002
  9.000000000000001E-002  9.266446200694359E-002  9.400230284414772E-002
  9.499999999999999E-002  9.560183108778503E-002  9.560252525934770E-002
  9.594515183254111E-002  0.100016082717832       0.100352634640763
  0.101359724045338       0.101694814547458       0.103364200005449
  0.103031024281191       0.105347676670228       0.105024388274803
  0.107334377472957       0.107005246555151       0.108318954137637
  0.108318937988878       0.109629792206280       0.110608214675099
  0.111583208369679       1.432910631689862E-002  4.833325903694274E-002
  6.222275648154255E-003  8.413921485323494E-003  9.616455129747566E-003
  2.380988120888511E-002  1.841484010832272E-002  2.361429713409051E-002
  7.816553507523420E-003  1.970700273051601E-002  1.676399479991240E-002
  1.735596694002415E-002  1.673698861555367E-002  1.299134472680727E-002
  1.586236562216881E-002  1.661615134390072E-002  1.930796920633007E-002
  2.434456072905426E-002  2.153417698396758E-002  2.644190413145755E-002
  2.264860832499861E-002  2.210553636931107E-002  2.273912394757618E-002
  2.188204824810470E-002  2.230765303261347E-002  2.209986723992064E-002
  2.261684299071079E-002  2.292501518997497E-002  2.425100162551922E-002
  2.622322105528265E-002  2.687154210438619E-002  2.753772895628333E-002
  2.805257046590821E-002  2.889408224361021E-002  2.908133703295294E-002
  2.986250290888359E-002  3.019394013581575E-002  3.060415189263862E-002
  3.084012467742422E-002  3.183529376642485E-002  3.155315084918532E-002
  3.162988717116327E-002  3.164509437727544E-002  3.172597506673532E-002
  3.173080143106130E-002  3.174532435238223E-002  3.174269223921990E-002
  3.171076657008501E-002  3.166889224151025E-002  3.125250504899098E-002
  3.253599915646574E-002  3.293199803629464E-002  3.287998779222579E-002
  3.322237478218969E-002  3.330574546664998E-002  3.360328609911782E-002
  3.383613467269808E-002  3.391557496341518E-002  3.396808797136938E-002
  3.430481656697063E-002  3.434276378717301E-002  3.455006217328945E-002
  3.489286887623665E-002  3.519094670206362E-002  3.429065735821592E-002
  3.652343816719581E-002  3.585222278468762E-002  3.861182135927092E-002
  3.740568222324602E-002  3.892978998451915E-002  3.810779131070235E-002
  3.884460149744492E-002  3.858802548950652E-002  4.065937459996354E-002
  4.086543496905867E-002  4.332792573262651E-002  4.165920122893570E-002
  4.402246939378456E-002  4.124498382094741E-002  4.337510554909374E-002
  4.484440119235690E-002  4.600807818518968E-002  4.663529770286970E-002
  4.663472087274564E-002  4.482216624128142E-002  4.787901458208471E-002
  5.049642645398719E-002  5.100613921173114E-002  5.115832938682963E-002
  5.180152102964582E-002  5.168491465318384E-002  5.238198498160255E-002
  5.231526617717978E-002  5.280928000715800E-002  5.274166592729824E-002
  5.298862564575122E-002  5.299277752579554E-002  5.318804858075203E-002
  5.331841776405580E-002  5.342317780750782E-002   156.482114078369
   114.807292333697        492.293372730001        651.910738053537
   665.316537977239        430.290497182148        519.554387339780
   523.200776972053        831.515911652783        722.060578169282
   770.701059065608        811.788198915636        780.727287824262
   921.134357141456        854.825507003871        853.976400925825
   863.545791909875        896.329284341857        884.991883946947
   883.072782456065        991.204427788963        1050.98623310669
   1070.56995999429        1085.48685694993        1129.38823705917
   1169.85980767326        1138.74361325352        1057.99679591235
   1056.46994835592        1222.80642028685        1196.89033465403
   1213.96834259834        1227.38247351983        1251.78371853089
   1257.23439982511        1280.46837791555        1290.17859839236
   1302.92351530975        1310.61546157986        1305.50721457195
   1340.93329398661        1377.22101983233        1389.54694128219
   1439.62906679740        1461.77639964560        1503.87881396248
   1520.96143272239        1574.95075171800        1602.97564474394
   1678.60988317012        1610.29124554946        1626.94218967726
   1624.92120871995        1628.81918960721        1644.59423434348
   1653.50900141857        1651.80398626344        1655.62776607810
   1658.07365713004        1665.26250295514        1667.34852492133
   1689.05368348985        1688.02634512469        1705.03415563964
   1741.48686910915        1727.24810352050        1744.24633857131
   1722.72589634463        1731.02459542531        1728.02371473784
   1734.22508360606        1733.84488186800        1728.35132854769
   1770.98973588670        1779.64287090667        1788.66674018995
   1798.78661124248        1802.65540431718        1769.41174433761
   1876.13970045519        1952.61890996569        2011.64824414431
   2048.19403837133        2048.24362088227        2070.91177478251
   2331.63169947478        2358.31683507195        2428.10054299849
   2451.63841443949        2571.29955370118        2547.19301769365
   2718.11844875558        2693.90893041841        2870.25755724313
   2844.61934318837        2947.43612724335        2947.44233478492
   3052.15525503342        3131.68201671531        3212.29894364813
+PATCH, PAMEND.
*- THIS IS THE LAST LINE OF THE PAM FILE geant321
